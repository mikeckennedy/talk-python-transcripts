WEBVTT

00:00:00.000 --> 00:00:09.000
- Hey, Samuel. Welcome to Talk Python To Me.


00:00:09.000 --> 00:00:13.000
- Hi, Mike. Great to meet you. Very excited to be here.


00:00:13.000 --> 00:00:17.000
- Yeah, I'm really excited to have you here. You've been working on one of my favorite


00:00:17.000 --> 00:00:21.000
projects these days that is just super, super neat, solving a lot of problems,


00:00:21.000 --> 00:00:25.000
Pydantic, and I'm really excited to talk to you about it.


00:00:25.000 --> 00:00:32.680
Yeah, it's, as I said, it's great to be here. I've been doing Pilotic on and off now since


00:00:32.680 --> 00:00:35.000
2017, but...


00:00:35.000 --> 00:00:36.000
Gosh.


00:00:36.000 --> 00:00:48.000
A lot of work, but it's exciting to see something this popular.


00:00:48.000 --> 00:00:54.440
Yeah, I'm sure it's a lot of work, but it really seems to have caught the imagination


00:00:54.440 --> 00:00:56.420
and they're really excited about it.


00:00:56.420 --> 00:00:58.680
So, fantastic work.


00:00:58.680 --> 00:01:00.960
Before we get into the details there,


00:01:00.960 --> 00:01:03.640
let's start with just your background.


00:01:03.640 --> 00:01:05.780
How'd you get into programming Python?


00:01:05.780 --> 00:01:08.680
- I guess I did a bit of programming at university,


00:01:08.680 --> 00:01:12.200
a lot of, a bit of MATLAB and a bit of C++,


00:01:12.200 --> 00:01:14.260
and then my first job after university,


00:01:14.260 --> 00:01:18.020
I worked on oil rigs in Indonesia, of all strange things.


00:01:18.020 --> 00:01:19.560
And there's a lot of time on an oil rig


00:01:19.560 --> 00:01:21.940
when you're flat out, and there's a lot of other time


00:01:21.940 --> 00:01:23.660
when you're doing absolutely nothing,


00:01:23.660 --> 00:01:24.580
that don't have much to do,


00:01:24.580 --> 00:01:27.060
and so I programmed quite a lot in that time,


00:01:27.060 --> 00:01:28.720
and I suppose that was when I really got into loving it,


00:01:28.720 --> 00:01:30.660
rather than just doing it when I had to.


00:01:30.660 --> 00:01:32.380
And then, I guess Python from there,


00:01:32.380 --> 00:01:34.580
bit of JavaScript, bit of Python ever since.


00:01:34.580 --> 00:01:36.460
- Yeah, yeah, really cool.


00:01:36.460 --> 00:01:39.600
I think things like MATLAB often do sort of pull people in,


00:01:39.600 --> 00:01:42.940
and they have to learn a little bit of programming,


00:01:42.940 --> 00:01:45.220
'cause it's a pain to just keep typing it into,


00:01:45.220 --> 00:01:47.260
you know, whatever the equivalent of the REPL is


00:01:47.260 --> 00:01:49.780
that MATLAB has, and create the .imp file,


00:01:49.780 --> 00:01:52.180
and you kind of get going, and you start to combine them,


00:01:52.180 --> 00:01:55.940
and then all of a sudden, it sort of sucks you into the programming world


00:01:55.940 --> 00:01:57.940
when you maybe didn't plan to go that way.


00:01:57.940 --> 00:02:00.340
Yeah, I worry...


00:02:00.340 --> 00:02:02.340
Maybe other people learn it the right way


00:02:02.340 --> 00:02:04.340
and sit down and read a book and understand how to do stuff,


00:02:04.340 --> 00:02:06.580
but there's a lot of things that I wish I had known back then


00:02:06.580 --> 00:02:09.460
that I learned only through reading other code


00:02:09.460 --> 00:02:11.460
or through banging my head against the wall


00:02:11.460 --> 00:02:13.460
that would have been really easy to learn


00:02:13.460 --> 00:02:15.460
if someone had shown me them.


00:02:15.460 --> 00:02:17.460
But hey, we got here.


00:02:17.460 --> 00:02:19.460
Yeah, well, I think many,


00:02:19.460 --> 00:02:22.460
I'd probably say most people got into programming that way,


00:02:22.460 --> 00:02:24.060
and I think it's all fine.


00:02:24.060 --> 00:02:24.900
- Yeah.


00:02:24.900 --> 00:02:25.940
- It's all good.


00:02:25.940 --> 00:02:28.700
So what was living on an oil rig like?


00:02:28.700 --> 00:02:30.580
That must have been insane.


00:02:30.580 --> 00:02:32.420
- It was pretty peculiar.


00:02:32.420 --> 00:02:34.300
So half the time I was on land rigs


00:02:34.300 --> 00:02:36.040
and half the time I was offshore.


00:02:36.040 --> 00:02:37.900
Offshore, the conditions were a lot better.


00:02:37.900 --> 00:02:40.640
Land rigs, the food was pretty horrific.


00:02:40.640 --> 00:02:43.740
And a lot of, they were all,


00:02:43.740 --> 00:02:45.840
I always did like a 14 hour night shift


00:02:45.840 --> 00:02:47.540
and then occasionally had to do the day shift as well


00:02:47.540 --> 00:02:48.540
and then go on to the night shift.


00:02:48.540 --> 00:02:52.060
So sleep was a problem and the heat was a problem.


00:02:52.060 --> 00:02:56.740
Yeah, it was a hard baptism of the real working world


00:02:56.740 --> 00:02:58.980
after university, I must say.


00:02:58.980 --> 00:03:00.100
- Yeah, I guess so.


00:03:00.100 --> 00:03:03.060
It sounds really interesting, not an interesting like,


00:03:03.060 --> 00:03:05.780
wow, I really wanna necessarily go out there and do it,


00:03:05.780 --> 00:03:09.700
but you just must have come away with some wild stories


00:03:09.700 --> 00:03:11.660
and a different perspective.


00:03:11.660 --> 00:03:15.140
- Yeah, lots of stories that I won't retell now.


00:03:15.140 --> 00:03:16.980
I don't think that's the kind of subject matter


00:03:16.980 --> 00:03:18.580
the ones on your podcast.


00:03:18.580 --> 00:03:20.820
But yeah, I mean, how oil rigs work,


00:03:20.820 --> 00:03:22.040
well, whatever you think about it,


00:03:22.040 --> 00:03:24.300
and however much we all want to get away from them,


00:03:24.300 --> 00:03:25.720
it is crazy what you can do.


00:03:25.720 --> 00:03:28.760
And so being like up against the,


00:03:28.760 --> 00:03:31.240
the like at the coalface of that was really fascinating.


00:03:31.240 --> 00:03:33.560
It's kind of like aerospace, but no one minds crashing.


00:03:33.560 --> 00:03:36.560
So you can innovate, you can try a new thing.


00:03:36.560 --> 00:03:38.120
You just, the faster you can drill, the better.


00:03:38.120 --> 00:03:39.760
It's all that anyone cares about.


00:03:39.760 --> 00:03:40.600
- Yeah. - Well,


00:03:40.600 --> 00:03:42.320
mostly what they care about.


00:03:42.320 --> 00:03:43.160
- Exactly.


00:03:43.160 --> 00:03:44.800
Yeah, it must've been a cool adventure.


00:03:44.800 --> 00:03:45.640
Awesome.


00:03:46.600 --> 00:03:49.020
So I thought it'd be fun to start our conversation,


00:03:49.020 --> 00:03:50.900
not exactly about Pydantic,


00:03:50.900 --> 00:03:54.520
but just about this larger story,


00:03:54.520 --> 00:03:57.520
that larger space that Pydantic lives in.


00:03:57.520 --> 00:04:00.060
But maybe to set the stage,


00:04:00.060 --> 00:04:02.140
give us like a real quick overview of like,


00:04:02.140 --> 00:04:04.600
what problem does Pydantic solve for the world?


00:04:04.600 --> 00:04:06.780
What is it and what does it solve for the world?


00:04:06.780 --> 00:04:09.740
- So the most simplest way of thinking about it is


00:04:09.740 --> 00:04:11.320
you've got some user somewhere,


00:04:11.320 --> 00:04:13.180
they might be on the other end of a web connection,


00:04:13.180 --> 00:04:14.700
they might be using a GUI,


00:04:14.700 --> 00:04:17.940
they might be using a client, it doesn't really matter.


00:04:17.940 --> 00:04:19.300
And they're entering some data


00:04:19.300 --> 00:04:24.300
and you need to trust the data that they put in is correct.


00:04:24.300 --> 00:04:27.220
So with Pydantic, I don't really care what someone enters.


00:04:27.220 --> 00:04:30.120
All I care about is that you can validate it


00:04:30.120 --> 00:04:30.960
to get what you want.


00:04:30.960 --> 00:04:35.940
So if I need an integer and a string and a list of bytes,


00:04:35.940 --> 00:04:38.180
all I care about is that I can get to that


00:04:38.180 --> 00:04:39.540
integer, string and list of bytes.


00:04:39.540 --> 00:04:42.140
I don't care if someone entered bytes for the string field


00:04:42.140 --> 00:04:43.560
as long as I can decode it.


00:04:43.560 --> 00:04:46.240
or if they entered a tuple instead of a list.


00:04:46.240 --> 00:04:48.620
But yeah, the fundamental problem is people,


00:04:48.620 --> 00:04:50.880
I suppose in theory, like intentionally trying


00:04:50.880 --> 00:04:52.680
to do it wrong, but mostly innocently getting


00:04:52.680 --> 00:04:55.860
something wrong, trying to coerce data


00:04:55.860 --> 00:04:58.140
into the shape that you want it to be in.


00:04:58.140 --> 00:04:59.320
And that's something that--


00:04:59.320 --> 00:05:00.800
- Yeah, it's super easy to say like,


00:05:00.800 --> 00:05:03.760
well, I read this value from a file,


00:05:03.760 --> 00:05:07.840
and the value in the file is a number, it says one,


00:05:07.840 --> 00:05:09.800
but you read it as strings.


00:05:09.800 --> 00:05:11.740
So the thing you sent over is quote one,


00:05:11.740 --> 00:05:14.220
not the number one.


00:05:14.220 --> 00:05:16.940
And in programming, computers hate that, right?


00:05:16.940 --> 00:05:19.140
They don't think those things are the same,


00:05:19.140 --> 00:05:20.500
unless maybe you're JavaScript


00:05:20.500 --> 00:05:23.140
and you do it in the right order, maybe.


00:05:23.140 --> 00:05:25.860
But excluding that odd case, right?


00:05:25.860 --> 00:05:27.900
A lot of times it's just crash, wrong data format


00:05:27.900 --> 00:05:31.820
or whatever, we expected an integer and gave us a string.


00:05:31.820 --> 00:05:34.340
But, you know, PyNandic just looks at it and says,


00:05:34.340 --> 00:05:36.660
it could be an integer if you want it to be.


00:05:36.660 --> 00:05:38.420
So we'll just do that.


00:05:38.420 --> 00:05:39.660
- Yeah, and I think it's something


00:05:39.660 --> 00:05:41.620
that there's been a lot of discussion about


00:05:41.620 --> 00:05:43.760
on Pydantic's issue tracker,


00:05:43.760 --> 00:05:46.800
there's an entire label strict about the discussions


00:05:46.800 --> 00:05:48.160
about how strict we should be.


00:05:48.160 --> 00:05:50.320
And I think it's fair to say Pydantic compared


00:05:50.320 --> 00:05:53.040
to the other libraries is more lenient,


00:05:53.040 --> 00:05:56.520
more keen on if we can try and coerce it into that type,


00:05:56.520 --> 00:05:57.360
we will.


00:05:57.360 --> 00:05:59.040
That really started for me trying to make it simple


00:05:59.040 --> 00:06:00.020
and performant.


00:06:00.020 --> 00:06:01.600
And I just called the,


00:06:01.600 --> 00:06:04.160
I decided if something wasn't in by calling int on it


00:06:04.160 --> 00:06:05.380
and seeing what happened.


00:06:05.380 --> 00:06:07.680
That had some kind of strange side cases


00:06:07.680 --> 00:06:10.720
because I called list on something to see if it was a list.


00:06:10.720 --> 00:06:13.300
and that meant you could put a string of integers,


00:06:13.300 --> 00:06:16.600
a string into a list of ints field,


00:06:16.600 --> 00:06:18.240
and it would first of all call list on it,


00:06:18.240 --> 00:06:21.360
turn it into a list, and then call int on each member,


00:06:21.360 --> 00:06:22.840
and that was completely crazy.


00:06:22.840 --> 00:06:24.640
So we've got stricter over the years,


00:06:24.640 --> 00:06:26.440
and I think that in the future,


00:06:26.440 --> 00:06:28.500
Pydantic will have to get a bit stricter.


00:06:28.500 --> 00:06:32.600
In particular, stuff like coercing from a float to an int


00:06:32.600 --> 00:06:35.880
quite often doesn't make sense or isn't what people want,


00:06:35.880 --> 00:06:38.680
but most of the time, just working is really powerful,


00:06:38.680 --> 00:06:39.520
really helpful.


00:06:39.520 --> 00:06:47.680
some kind of data loss, right? If it's 1.0000, coincorsing that to one's fine. If it's 1.52,


00:06:47.680 --> 00:06:48.680
maybe not.


00:06:48.680 --> 00:06:52.760
Yeah, but it's difficult because we're in the Python world where Python is pretty lenient.


00:06:52.760 --> 00:06:59.280
It doesn't mind you adding two floats together. If you call the int function on a float, it's


00:06:59.280 --> 00:07:05.500
fine. So it's also trying to be Pythonic at the same time as being strict enough for people,


00:07:05.500 --> 00:07:09.020
but without doing stuff that obviously,


00:07:09.020 --> 00:07:10.820
without not doing stuff that's obvious,


00:07:10.820 --> 00:07:13.480
because lots of people do just want coercion to work.


00:07:13.480 --> 00:07:15.720
- Right, we'll get into it.


00:07:15.720 --> 00:07:19.660
There's lots of places to plug in and write your own code


00:07:19.660 --> 00:07:22.140
and do those kinds of checks if you really need to.


00:07:22.140 --> 00:07:22.960
- Yeah.


00:07:22.960 --> 00:07:26.540
- All right, Carlos has a good question out there


00:07:26.540 --> 00:07:29.700
in the live stream, but I'm gonna get to that later


00:07:29.700 --> 00:07:31.620
when we get a little bit more into it.


00:07:31.620 --> 00:07:33.820
First, let's talk about some of the other things.


00:07:33.820 --> 00:07:37.860
So, Pydantic is surprisingly popular these days,


00:07:37.860 --> 00:07:41.260
but there's plenty of people I'm sure


00:07:41.260 --> 00:07:42.820
who haven't heard of it,


00:07:42.820 --> 00:07:45.540
who are hearing about it the first time here.


00:07:45.540 --> 00:07:48.700
And there's other libraries that try to solve


00:07:48.700 --> 00:07:50.940
these same type of problems, right?


00:07:50.940 --> 00:07:55.860
Problem is I've got data in often a dictionary list mix,


00:07:55.860 --> 00:07:56.700
right?


00:07:56.700 --> 00:07:57.900
Like a list of dictionaries or a dictionary,


00:07:57.900 --> 00:08:00.940
which contains lists, which contains like that kind of


00:08:00.940 --> 00:08:03.220
object graph type of thing.


00:08:03.220 --> 00:08:06.100
And I want to turn that into probably a class,


00:08:06.100 --> 00:08:08.300
probably a Python class of some sort


00:08:08.300 --> 00:08:10.540
or understand it in some way.


00:08:10.540 --> 00:08:14.480
So, you know, we've got some of the really simple ways


00:08:14.480 --> 00:08:15.980
of doing this where I just have those,


00:08:15.980 --> 00:08:18.140
I don't want to stash that into a binary form,


00:08:18.140 --> 00:08:19.820
which is pickle.


00:08:19.820 --> 00:08:23.100
Pickle has been bad in certain ways


00:08:23.100 --> 00:08:25.060
'cause it can run arbitrary Python code.


00:08:25.060 --> 00:08:26.140
That's not ideal.


00:08:26.140 --> 00:08:29.060
There's another related library called Quickle,


00:08:29.060 --> 00:08:31.780
which is like pickle, but doesn't run arbitrary code.


00:08:31.780 --> 00:08:33.340
that's pretty nice.


00:08:33.340 --> 00:08:36.140
We have data classes that look very much


00:08:36.140 --> 00:08:38.740
like what you're doing with Pydantic.


00:08:38.740 --> 00:08:41.300
We have Marshmallow, which I hear often being used


00:08:41.300 --> 00:08:44.460
with like Flask and SQLAlchemy and Marshmallow.


00:08:44.460 --> 00:08:46.500
You maybe want to sort of give your perspective


00:08:46.500 --> 00:08:48.180
on like what the choices are out there


00:08:48.180 --> 00:08:51.660
and you know, where things are learning


00:08:51.660 --> 00:08:54.180
from other libraries and growing from.


00:08:54.180 --> 00:08:57.380
- Yeah, I put serialization as in pickle, JSON,


00:08:57.380 --> 00:09:00.140
YAML, TOML, all of them into a different category,


00:09:00.140 --> 00:09:06.580
message pack as a slightly different thing from taking Python objects and trying to turn


00:09:06.580 --> 00:09:11.140
them into classes. So putting them to one side, because I think that's a kind of different


00:09:11.140 --> 00:09:16.300
problem that Pydantic and Marshmallow and people aren't trying to solve exactly. Then


00:09:16.300 --> 00:09:20.220
there's data classes, which are the kind of canonical standard library way of doing this.


00:09:20.220 --> 00:09:24.340
They're great, but they don't provide any validation. So you can add a type in that


00:09:24.340 --> 00:09:28.660
that says, "Name," so age is an integer,


00:09:28.660 --> 00:09:31.000
but data classes don't care.


00:09:31.000 --> 00:09:33.180
Whatever you put in will end up in that field.


00:09:33.180 --> 00:09:36.580
And so that's useful if you have a fully type-inted system


00:09:36.580 --> 00:09:38.420
where you know already that something's an integer


00:09:38.420 --> 00:09:39.780
before you pass it to a data class,


00:09:39.780 --> 00:09:42.600
but if you're loading it from a foreign source,


00:09:42.600 --> 00:09:44.380
you often don't have that certainty.


00:09:44.380 --> 00:09:46.500
And so that's where libraries like Pydantic


00:09:46.500 --> 00:09:47.900
and Marshmallow come in.


00:09:47.900 --> 00:09:51.580
Actually, Pydantic has a wrapper for data classes.


00:09:51.580 --> 00:09:54.580
So you basically import the Pydantic version of DataClasses


00:09:54.580 --> 00:09:57.180
instead of normal DataClasses, and from there on,


00:09:57.180 --> 00:09:58.680
Pydantic will do all the validation,


00:09:58.680 --> 00:10:00.780
give you back a completely standard DataClass,


00:10:00.780 --> 00:10:02.780
but having done the validation.


00:10:02.780 --> 00:10:06.920
Marshmallow is probably, well, it is undoubtedly


00:10:06.920 --> 00:10:10.320
the biggest, most obvious competitor to Pydantic,


00:10:10.320 --> 00:10:14.820
and it's great. I'm not going to sit here and badmouth it.


00:10:14.820 --> 00:10:19.260
It's been around for longer, and it does a lot of things really well.


00:10:19.760 --> 00:10:22.960
Pydantic has just overtaken a few months ago


00:10:22.960 --> 00:10:25.360
Marshmallow in terms of popularity,


00:10:25.360 --> 00:10:27.360
in terms of GitHub stars,


00:10:27.360 --> 00:10:29.360
whether you care about that or not is another matter.


00:10:29.360 --> 00:10:34.520
There's also Atras, which kind of predates data classes


00:10:34.520 --> 00:10:36.520
and is closer to data classes.


00:10:36.520 --> 00:10:39.600
But the big difference between Pydantic and Marshmallow


00:10:39.600 --> 00:10:42.960
and most of the other competitors is Pydantic uses type ints.


00:10:42.960 --> 00:10:46.120
So that one means you don't have to learn


00:10:46.120 --> 00:10:48.880
a whole new kind of micro-language to define types.


00:10:48.880 --> 00:10:51.840
You just write your classes and it works.


00:10:51.840 --> 00:10:57.360
It works with mypy and with your static type analysis.


00:10:57.360 --> 00:11:04.080
It works with your IDE like PyCharm now because it's an amazing extension.


00:11:04.080 --> 00:11:07.040
I've forgotten the name of the guy who wrote it,


00:11:07.040 --> 00:11:10.920
but there's an amazing extension that I used the whole time with PyCharm


00:11:10.920 --> 00:11:13.520
that means it works seamlessly with Pydantic.


00:11:13.520 --> 00:11:15.120
And there's some exciting stuff happening.


00:11:15.120 --> 00:11:17.440
Microsoft, they emailed me actually two days ago,


00:11:17.440 --> 00:11:22.000
one of their technical fellows about extending their


00:11:22.000 --> 00:11:26.360
language server or their front-end for language server,


00:11:26.360 --> 00:11:29.520
Pyright, to work with Pydantic and other such libraries.


00:11:29.520 --> 00:11:31.720
So because you're using standard type hints,


00:11:31.720 --> 00:11:33.320
all the other stuff, including your brain,


00:11:33.320 --> 00:11:36.000
should, in theory, click into place.


00:11:36.000 --> 00:11:38.480
- Yeah, yeah, that's really neat.


00:11:38.480 --> 00:11:40.440
I do think it makes sense to separate


00:11:40.440 --> 00:11:41.920
sort of the serialization file,


00:11:41.920 --> 00:11:44.640
save me a file, load a file type of thing out.


00:11:46.240 --> 00:11:49.580
I really love the way that the type hints work in there


00:11:49.580 --> 00:11:52.540
because you can almost immediately understand what's happening.


00:11:52.540 --> 00:11:56.780
It's not like, "Oh, this is the way in which you describe the schema


00:11:56.780 --> 00:11:58.540
and the way you describe the transformations."


00:11:58.540 --> 00:12:00.900
It's just, "Here's a class.


00:12:00.900 --> 00:12:03.780
It has some fields. Those fields have types."


00:12:03.780 --> 00:12:07.300
That's all you need to know, and Pydantic will make the magic happen.


00:12:07.300 --> 00:12:13.700
What would you say the big difference between Pydantic and Marshmallow is?


00:12:13.700 --> 00:12:15.700
And I haven't used Marshmallow that frequently,


00:12:15.700 --> 00:12:17.700
so I don't know it super well.


00:12:17.700 --> 00:12:20.380
I would first give the same proviso


00:12:20.380 --> 00:12:22.380
that I haven't used it that much either.


00:12:22.380 --> 00:12:25.060
Probably, if I was more disciplined, I'd have sat down and used it


00:12:25.060 --> 00:12:27.060
for some time before building Pydantic,


00:12:27.060 --> 00:12:29.060
but that's not always the way things work.


00:12:29.060 --> 00:12:31.860
The main difference is it doesn't use type hints,


00:12:31.860 --> 00:12:33.860
or it doesn't primarily use type hints as its source


00:12:33.860 --> 00:12:36.260
of data about what type something is.


00:12:36.260 --> 00:12:40.740
And Pydantic is around, from my memory, I can check,


00:12:40.740 --> 00:12:43.860
but significantly more performant than Marshmallow.


00:12:44.420 --> 00:12:47.860
Yeah, you actually have some benchmarks on the site. We could talk about that in a little bit.


00:12:47.860 --> 00:12:51.940
Yeah, so just briefly it's about two and a half times faster.


00:12:51.940 --> 00:12:59.960
The advantage of Marshmallow at the moment is it has more logic around customizing how you serialize


00:12:59.960 --> 00:13:03.300
types, so when you're going back from a class to a


00:13:03.300 --> 00:13:10.580
dictionary or list of dictionaries and then out to JSON or whatever, Marshmallow has some really cool tools there


00:13:11.300 --> 00:13:13.340
which Panasonic doesn't have yet,


00:13:13.340 --> 00:13:15.500
and I'm hoping to build into V2


00:13:15.500 --> 00:13:18.800
some more powerful ways of customizing serialization.


00:13:18.800 --> 00:13:20.980
- Okay, fantastic.


00:13:20.980 --> 00:13:23.500
Well, let's dive into it.


00:13:23.500 --> 00:13:28.140
And I wanna talk about some of the core features here.


00:13:28.140 --> 00:13:31.820
Maybe we could start with just you walking us through


00:13:31.820 --> 00:13:36.900
a simple example of creating a class


00:13:36.900 --> 00:13:39.180
and then taking some data and parsing over.


00:13:39.180 --> 00:13:41.180
You've got this nice example right here on the homepage.


00:13:41.180 --> 00:13:45.340
I think this is so good to just sort of look at.


00:13:45.340 --> 00:13:50.220
There's a bunch of little nuances to cool things that happen here that I think people will benefit from.


00:13:50.220 --> 00:13:55.500
Yeah, so you're obviously defining your class user here.


00:13:55.500 --> 00:14:00.640
Very simple inheritance from base model, no decorator.


00:14:00.640 --> 00:14:05.260
I thought about at the beginning that this should work for people who haven't been writing


00:14:05.660 --> 00:14:09.740
Python for the last 10 years and where decorators look like strange magic,


00:14:09.740 --> 00:14:12.620
I think using inheritance is the obvious way to do it.


00:14:12.620 --> 00:14:16.060
And then obviously we define our fields.


00:14:16.060 --> 00:14:20.460
The key thing really is that the type int, int in the case of id,


00:14:20.460 --> 00:14:24.700
is used to define what type that field's going to be.


00:14:24.700 --> 00:14:26.940
And then if we do give it a value, as we do with name,


00:14:26.940 --> 00:14:29.820
that means that the field is not required.


00:14:29.820 --> 00:14:31.020
It has a default value.


00:14:31.020 --> 00:14:35.100
And obviously we can infer the type there from the default,


00:14:35.100 --> 00:14:42.460
which is a string. Then sign up time stamp is obviously an optional date time, so it can be none.


00:14:42.460 --> 00:14:49.660
And critically here, you could either enter none or leave it blank, and it would again be none.


00:14:49.660 --> 00:14:53.100
And then we have friends, which is a more complex type, that's a list of integers.


00:14:53.100 --> 00:14:56.780
And the cool stuff is because we're just using Python type int, we can


00:14:56.780 --> 00:15:02.140
burrow down into lists of dicts, of lists of sets of whatever you like, within reason,


00:15:02.140 --> 00:15:04.140
and it will continue to work.


00:15:04.140 --> 00:15:06.700
And then looking at the external data,


00:15:06.700 --> 00:15:09.420
again, we see a few things like we were talking about the coercion.


00:15:09.420 --> 00:15:11.260
So we coerce from...


00:15:11.260 --> 00:15:13.260
Right, this external data is just a dictionary


00:15:13.260 --> 00:15:15.820
that you probably have gotten from an API call,


00:15:15.820 --> 00:15:17.100
but it could have come from anywhere.


00:15:17.100 --> 00:15:19.020
It doesn't have to come from there.


00:15:19.020 --> 00:15:21.020
Right, exactly. Anywhere outside.


00:15:21.020 --> 00:15:23.260
But right now we've got it as far as being a dictionary.


00:15:23.260 --> 00:15:27.900
So the point here is we're doing a bit of coercion.


00:15:27.900 --> 00:15:35.080
So trivial converting from a string 123 to the number 123,


00:15:35.080 --> 00:15:40.620
but then a bit more complex, parsing the date and converting that into a date object.


00:15:40.620 --> 00:15:41.620
And then as you can see...


00:15:41.620 --> 00:15:44.500
Right, so you have in here the data that's passed in,


00:15:44.500 --> 00:15:49.760
you've got a quote, 2019-06-01 and a time.


00:15:49.760 --> 00:15:56.260
And this is notoriously tricky because things like JSON don't even support dates.


00:15:56.260 --> 00:15:58.260
Like don't freak out if you try to send one over.


00:15:58.260 --> 00:16:01.940
So you just got this string, but it'll be turned into a date.


00:16:01.940 --> 00:16:05.700
Yeah, and we do a whole bunch of different things to try and do


00:16:05.700 --> 00:16:07.700
all of the sensible date formats.


00:16:07.700 --> 00:16:10.140
There's obviously a limit as how far to go,


00:16:10.140 --> 00:16:12.940
because one of the things Pivantic can do is


00:16:12.940 --> 00:16:17.140
it can interpret integers as dates using Unix timestamps.


00:16:17.140 --> 00:16:20.660
And if they're over some threshold in about two centuries from now,


00:16:20.660 --> 00:16:23.700
it assumes they're in milliseconds, so it works with


00:16:23.700 --> 00:16:26.180
milliseconds, which are often used,


00:16:26.180 --> 00:16:28.740
but it does also lead to confusions when someone puts in


00:16:28.740 --> 00:16:32.340
123 as a date, and it's three seconds after 1970.


00:16:32.340 --> 00:16:36.620
There's an ongoing debate about exactly what you should try


00:16:36.620 --> 00:16:38.940
and coerce and when it gets magic, but for me,


00:16:38.940 --> 00:16:42.060
there's a number of times I've just found it incredibly useful


00:16:42.060 --> 00:16:44.260
that it just works.


00:16:44.260 --> 00:16:47.780
So, for example, the string format that Postgre uses


00:16:47.780 --> 00:16:50.820
when you use toJSON just works with Pydantic,


00:16:50.820 --> 00:16:52.540
so you don't even have to think about whether that's come through


00:16:52.540 --> 00:16:54.860
as a date or as a string until you're worried


00:16:54.860 --> 00:16:57.940
about a limit of performance, most of that stuff just works.


00:16:57.940 --> 00:17:01.320
- Yeah, then one of the things that I think


00:17:01.320 --> 00:17:04.540
is super interesting is you have these friend IDs


00:17:04.540 --> 00:17:08.260
that you're passing over, and you said in PyDandig,


00:17:08.260 --> 00:17:11.040
it's a list of integers, and in the external data,


00:17:11.040 --> 00:17:16.040
it is a list of sometimes integers and sometimes strings,


00:17:16.040 --> 00:17:18.660
but once it gets parsed across,


00:17:18.660 --> 00:17:21.420
it not just looks at the immediate fields,


00:17:21.420 --> 00:17:23.820
but it looks at, say, things inside of a list and says,


00:17:23.820 --> 00:17:25.380
oh, you wanted a list of integers.


00:17:25.380 --> 00:17:27.380
Here, this is a list that has a string in it,


00:17:27.380 --> 00:17:29.740
but it's like quote three, so it's fine.


00:17:29.740 --> 00:17:32.220
- Yeah, and this is where it gets cool,


00:17:32.220 --> 00:17:35.020
because we can go recursively down into the rabbit hole


00:17:35.020 --> 00:17:36.900
and it will continue to validate.


00:17:36.900 --> 00:17:39.340
One of the tricky things that I think


00:17:39.340 --> 00:17:42.740
is what most people want, but where our language fails us


00:17:42.740 --> 00:17:44.020
is about the word validation,


00:17:44.020 --> 00:17:46.820
because quite often validation sounds like


00:17:46.820 --> 00:17:49.660
I'm checking the input data is in the form that I said.


00:17:49.660 --> 00:17:51.700
That's kind of not what Pydantic's doing.


00:17:51.700 --> 00:17:53.820
It's optimistically trying to parse.


00:17:53.820 --> 00:17:56.020
So it doesn't care what the list contains in a sense,


00:17:56.020 --> 00:17:58.660
as long as it can find a way to make that into an int.


00:17:58.660 --> 00:18:00.820
So this wouldn't be a good library to use


00:18:00.820 --> 00:18:03.340
for like unit testing and checking


00:18:03.340 --> 00:18:04.860
that something is the way that it should be,


00:18:04.860 --> 00:18:07.380
because it's gonna accept a million different things.


00:18:07.380 --> 00:18:09.180
It's gonna be as lenient as possible


00:18:09.180 --> 00:18:10.620
in what it will take in.


00:18:10.620 --> 00:18:12.160
But that's by design.


00:18:12.160 --> 00:18:14.300
- Yeah.


00:18:14.300 --> 00:18:17.820
The way to take this external dictionary


00:18:17.820 --> 00:18:20.480
and then get PyDance to parse it


00:18:20.480 --> 00:18:22.820
is you just pass it as keyword arguments


00:18:22.820 --> 00:18:24.700
to the class constructor.


00:18:24.700 --> 00:18:29.060
So you say user of star star dictionary,


00:18:29.060 --> 00:18:33.020
so that'll explode that out to keyword arguments.


00:18:33.020 --> 00:18:35.820
And that's it, that runs the entire parsing, right?


00:18:35.820 --> 00:18:37.380
That's super simple.


00:18:37.380 --> 00:18:39.000
- Yeah, and that's again by design


00:18:39.000 --> 00:18:40.900
to make it just the simplest way of doing it.


00:18:40.900 --> 00:18:42.960
If you want to do crazy complex stuff


00:18:42.960 --> 00:18:45.760
like constructing models without doing validation


00:18:45.760 --> 00:18:47.620
because you know it's already been validated,


00:18:47.620 --> 00:18:50.680
That's all possible, but the simplest interface,


00:18:50.680 --> 00:18:53.460
just calling in it on the class


00:18:53.460 --> 00:18:56.340
is designed to work and do the validation.


00:18:56.340 --> 00:18:57.260
- Yeah, cool.


00:18:57.260 --> 00:19:00.320
One thing I think is really neat and not obvious right away


00:19:00.320 --> 00:19:02.940
is that you can nest these things as well, right?


00:19:02.940 --> 00:19:04.620
Like I could have a shopping cart


00:19:04.620 --> 00:19:06.600
and the shopping cart could have a list of orders


00:19:06.600 --> 00:19:08.540
and each order in that list


00:19:08.540 --> 00:19:11.180
could be a PyDantec model itself, right?


00:19:11.180 --> 00:19:13.340
- Exactly, and it's probably an open question


00:19:13.340 --> 00:19:15.920
as to how complex we should make this first example.


00:19:15.920 --> 00:19:17.260
Maybe it's already too complicated.


00:19:17.260 --> 00:19:19.260
Maybe it doesn't demonstrate all the power,


00:19:19.260 --> 00:19:23.060
but I think it's probably about right.


00:19:23.060 --> 00:19:25.980
But yeah, you can go recursive,


00:19:25.980 --> 00:19:27.480
you can even do some crazy things


00:19:27.480 --> 00:19:30.620
like the root type of a model can actually not itself


00:19:30.620 --> 00:19:33.860
be a lit sequence of fields, it can be a list itself.


00:19:33.860 --> 00:19:36.660
So there is a long tail of complex stuff you can do,


00:19:36.660 --> 00:19:39.800
but you're right, the inheritance of different models


00:19:39.800 --> 00:19:41.980
is a really powerful way of defining types,


00:19:41.980 --> 00:19:45.460
because in reality, our models are never nice,


00:19:45.460 --> 00:19:47.180
key and value of different types.


00:19:47.180 --> 00:19:50.900
They always have complex items deeper down.


00:19:50.900 --> 00:19:54.860
- Right, yeah, I just think that that's really cool.


00:19:54.860 --> 00:19:58.260
And on top of these, I guess we can add validation.


00:19:58.260 --> 00:20:01.500
Like you have the, you said the very optimistic validation,


00:20:01.500 --> 00:20:06.500
like if in the friends list, it said one, two comma Jane,


00:20:06.500 --> 00:20:08.700
well, it's probably gonna crash


00:20:08.700 --> 00:20:11.100
when it tries to convert Jane into an integer


00:20:11.100 --> 00:20:12.820
and say, no, no, no, this is wrong.


00:20:12.820 --> 00:20:14.140
And it gives you a really good error message.


00:20:14.140 --> 00:20:17.940
it says something like the third item in this list is Jane,


00:20:17.940 --> 00:20:19.220
and that's not an integer, right?


00:20:19.220 --> 00:20:22.220
It doesn't just go, well, they're bad, you know,


00:20:22.220 --> 00:20:23.820
too bad.


00:20:23.820 --> 00:20:26.260
- Yeah, and you could decide,


00:20:26.260 --> 00:20:27.620
perhaps Jane's a strange case,


00:20:27.620 --> 00:20:30.940
but if you wanted the word one, O-N-E, to somehow work,


00:20:30.940 --> 00:20:34.300
you could add your own logic relatively trivially


00:20:34.300 --> 00:20:36.740
via a decorator, which said, okay, cool,


00:20:36.740 --> 00:20:39.620
if we get the word one or the word two or the word three,


00:20:39.620 --> 00:20:43.020
then we can convert them to the equivalent integers.


00:20:43.020 --> 00:20:45.220
and that's relatively easy to add.


00:20:45.220 --> 00:20:48.040
- Yeah, cool.


00:20:48.040 --> 00:20:50.540
Now, one thing that I guess the scenario


00:20:50.540 --> 00:20:52.040
where people run into this often,


00:20:52.040 --> 00:20:53.260
run into working with PyDandic


00:20:53.260 --> 00:20:57.300
is it's sort of the exchange layer for FastAPI,


00:20:57.300 --> 00:21:00.780
which is one of the more popular API frameworks these days.


00:21:00.780 --> 00:21:03.220
And you just say, your API function


00:21:03.220 --> 00:21:05.260
takes some PyDandic model


00:21:05.260 --> 00:21:06.980
and it returns some PyDandic model


00:21:06.980 --> 00:21:09.140
and magic happens.


00:21:09.140 --> 00:21:11.100
But if you're not working in that world,


00:21:11.100 --> 00:21:12.900
if you're not in FastAPI,


00:21:12.900 --> 00:21:15.540
and most people doing web development these days are not,


00:21:15.540 --> 00:21:18.540
'cause it's not the most popular framework,


00:21:18.540 --> 00:21:19.980
and it's also certainly not


00:21:19.980 --> 00:21:21.900
the most popular legacy framework.


00:21:21.900 --> 00:21:27.580
So you can do things like create these models directly


00:21:27.580 --> 00:21:31.540
in your code, let it do the validation there,


00:21:31.540 --> 00:21:32.820
and then if you need to return


00:21:32.820 --> 00:21:34.700
the whole object graph as a dictionary,


00:21:34.700 --> 00:21:37.520
you can just say model.dict, right?


00:21:37.520 --> 00:21:39.420
- Yeah, and also model.json,


00:21:39.420 --> 00:21:41.420
and that will take it right out to JSON.


00:21:41.420 --> 00:21:43.700
-As a string. -Yeah.


00:21:43.700 --> 00:21:45.700
So it will turn a string of that JSON.


00:21:45.700 --> 00:21:51.500
And you can even swap in more performant JSON encoders and decoders.


00:21:51.500 --> 00:21:56.460
And this is why I was talking about just already some power


00:21:56.460 --> 00:21:59.540
and what you can do here and which fields you can exclude.


00:21:59.540 --> 00:22:02.060
And it's pretty powerful, but it's, as I say,


00:22:02.060 --> 00:22:05.820
something in V2 that we might look at to make even more powerful


00:22:05.820 --> 00:22:08.140
is customizing how you do this.


00:22:08.140 --> 00:22:13.140
- Nice, yeah, so you might expect to just call .dict


00:22:13.140 --> 00:22:15.380
and it converts it to a dictionary,


00:22:15.380 --> 00:22:17.940
kind of reverses it, if you will.


00:22:17.940 --> 00:22:21.620
But there's actually a lot of parameters and arguments


00:22:21.620 --> 00:22:23.580
you can pass in to have more control.


00:22:23.580 --> 00:22:25.780
Do you want to talk about maybe just some


00:22:25.780 --> 00:22:27.060
of the use cases there?


00:22:27.060 --> 00:22:30.340
- Yeah, as we see here, you can choose


00:22:30.340 --> 00:22:31.980
to include specific fields and the rest


00:22:31.980 --> 00:22:33.820
will be excluded by default.


00:22:33.820 --> 00:22:37.620
You can set exclude, which will exclude certain fields


00:22:37.620 --> 00:22:39.500
and the rest will be included by default.


00:22:39.500 --> 00:22:41.660
Those include and exclude fields


00:22:41.660 --> 00:22:44.060
can do some pretty ridiculously crazy logic


00:22:44.060 --> 00:22:47.420
going recursively into the models that you're looking at


00:22:47.420 --> 00:22:50.340
and excluding specific fields from those models


00:22:50.340 --> 00:22:53.020
or specific items from lists even.


00:22:53.020 --> 00:22:54.620
Some of the code, I forget who wrote that,


00:22:54.620 --> 00:22:56.320
but I wrote the first version of it,


00:22:56.320 --> 00:22:58.300
I wrote the second and third version of it,


00:22:58.300 --> 00:23:00.260
and I was looking through about the 10th version of it


00:23:00.260 --> 00:23:03.700
the other day, and it is some of the most complex


00:23:03.700 --> 00:23:05.460
bits of Pydantic.


00:23:06.500 --> 00:23:07.920
but that's amazingly powerful.


00:23:07.920 --> 00:23:10.120
And then we didn't talk about aliases,


00:23:10.120 --> 00:23:13.000
but you can imagine if you were interacting


00:23:13.000 --> 00:23:14.480
with the JavaScript framework,


00:23:14.480 --> 00:23:16.840
you might be using camel case on the front end


00:23:16.840 --> 00:23:19.440
for like user name with a capital N,


00:23:19.440 --> 00:23:22.040
but have user underscore name in Python world


00:23:22.040 --> 00:23:24.660
where we're using underscores.


00:23:24.660 --> 00:23:28.960
We can manage that by setting aliases on each field.


00:23:28.960 --> 00:23:31.180
So saying that the user underscore name field


00:23:31.180 --> 00:23:34.200
has the alias user upscore N name.


00:23:34.200 --> 00:23:37.700
And then we can obviously export to a dictionary


00:23:37.700 --> 00:23:39.460
using those aliases if we wish.


00:23:39.460 --> 00:23:41.220
- That's cool.


00:23:41.220 --> 00:23:46.220
So you can program in Pythonic style classes,


00:23:46.220 --> 00:23:50.540
even if you're consuming, say a Java or C# API


00:23:50.540 --> 00:23:52.860
that clearly uses a different format


00:23:52.860 --> 00:23:54.780
or style for its naming.


00:23:54.780 --> 00:23:55.900
- Exactly.


00:23:55.900 --> 00:23:58.980
And you can then export again to,


00:23:58.980 --> 00:24:02.540
back to those aliases when you wanna go on


00:24:02.540 --> 00:24:06.140
to like pipe it on down your data processing flow


00:24:06.140 --> 00:24:07.660
or however you're gonna do it.


00:24:07.660 --> 00:24:09.380
And in fact, one of the things that will come up in future


00:24:09.380 --> 00:24:11.060
will be different aliases for import


00:24:11.060 --> 00:24:13.180
on the inside in way and the out way.


00:24:13.180 --> 00:24:15.820
But like until so far, there's just one,


00:24:15.820 --> 00:24:18.340
but yeah, that's powerful.


00:24:18.340 --> 00:24:21.860
And then you can exclude fields that have defaults.


00:24:21.860 --> 00:24:24.620
So if you're trying to save that data to a database


00:24:24.620 --> 00:24:26.500
and you don't wanna save more than you need to,


00:24:26.500 --> 00:24:29.100
you can exclude stuff where it has a default value


00:24:30.220 --> 00:24:33.460
and you can exclude fields which are none,


00:24:33.460 --> 00:24:34.700
which again is often the same thing,


00:24:34.700 --> 00:24:35.720
but there are subtle cases


00:24:35.720 --> 00:24:37.660
where those are different requirements.


00:24:37.660 --> 00:24:40.620
- And that also might really just,


00:24:40.620 --> 00:24:42.640
even if you're not saving it to a database,


00:24:42.640 --> 00:24:46.300
you know, that will lower the size of the JSON traffic


00:24:46.300 --> 00:24:48.540
between say microservices or something like that,


00:24:48.540 --> 00:24:51.140
if you don't need to send the defaults over,


00:24:51.140 --> 00:24:52.020
especially the nones,


00:24:52.020 --> 00:24:54.380
'cause they're probably gonna go to the thing they get


00:24:54.380 --> 00:24:56.780
and go, you know, give me the value


00:24:57.860 --> 00:25:00.520
or none in whatever language they're using, right?


00:25:00.520 --> 00:25:02.380
Something to that effect.


00:25:02.380 --> 00:25:03.520
So it'll be the same.


00:25:03.520 --> 00:25:04.520
Yeah.


00:25:04.520 --> 00:25:05.960
- We have complex stuff here.


00:25:05.960 --> 00:25:08.640
So we have exclude unset, exclude none,


00:25:08.640 --> 00:25:10.600
and exclude defaults.


00:25:10.600 --> 00:25:12.880
So you can decide exactly how you want to exclude it


00:25:12.880 --> 00:25:16.160
to get just the fields that are actually live,


00:25:16.160 --> 00:25:17.960
as it were, that have custom values.


00:25:17.960 --> 00:25:21.680
- Yeah, so you have this dict thing,


00:25:21.680 --> 00:25:22.520
which will turn a dictionary,


00:25:22.520 --> 00:25:24.520
and then you have the JSON one,


00:25:24.520 --> 00:25:25.800
which is interesting.


00:25:25.800 --> 00:25:27.520
We talked about that one.


00:25:27.520 --> 00:25:31.460
You also have copy, so is that like a shallow copy?


00:25:31.460 --> 00:25:34.720
If you want to clone it off or something?


00:25:34.720 --> 00:25:37.720
It can be a deep copy, but you can update some fields


00:25:37.720 --> 00:25:39.720
on the way through.


00:25:39.720 --> 00:25:44.020
There are multiple different contexts where you might want to do that,


00:25:44.020 --> 00:25:46.920
where you want different models where you can go and edit one of them


00:25:46.920 --> 00:25:48.920
and not damage the other one,


00:25:48.920 --> 00:25:52.980
or you want to modify a model as you're copying it.


00:25:52.980 --> 00:25:55.400
We also have...


00:25:55.400 --> 00:26:03.400
a setting on config that makes fields pseudo immutable.


00:26:03.400 --> 00:26:06.460
So it doesn't allow you to change that value,


00:26:06.460 --> 00:26:08.460
doesn't stop you changing stuff within that value


00:26:08.460 --> 00:26:10.460
because there's no way of doing that in Python.


00:26:10.460 --> 00:26:12.460
But that's another case where you might want to use copy


00:26:12.460 --> 00:26:15.100
because you've set your model up to be effectively static


00:26:15.100 --> 00:26:17.100
and you want to create a new one.


00:26:17.100 --> 00:26:19.100
If you're being super careful and strict,


00:26:19.100 --> 00:26:21.100
you would say, "I'm never going to modify my model.


00:26:21.100 --> 00:26:23.100
I'm just going to copy it when I want a new one."


00:26:23.100 --> 00:26:28.040
Yeah, perfect. Yeah, certain things you could enforce that they don't change like strings and numbers.


00:26:28.040 --> 00:26:33.320
But if it's a list, like the list can't point somewhere else, but what's in the list, you can't really do anything about that, right?


00:26:33.320 --> 00:26:35.320
Yeah.


00:26:35.320 --> 00:26:38.960
So another thing that I think is worth touching on that's interesting is,


00:26:38.960 --> 00:26:43.520
you know, there's some obvious things that are the types that can be set


00:26:43.520 --> 00:26:47.900
for the field types and then the data exchange conversion types,


00:26:47.900 --> 00:26:51.040
bools, integers, floats, strings, and so on.


00:26:51.040 --> 00:26:53.040
But then it gets further


00:26:53.040 --> 00:26:59.120
It gets more specialized down there as you go. So for example, you can have unions


00:26:59.120 --> 00:27:03.860
You can have frozen sets. You can have iterables callables


00:27:03.860 --> 00:27:09.280
Uh network addresses all kinds of stuff, right? Yeah, we try and support


00:27:09.280 --> 00:27:12.160
almost anything you can think of from the


00:27:12.160 --> 00:27:17.360
from the python standard library and then if you go on down we get to a whole bunch of things that that are even


00:27:17.760 --> 00:27:20.080
that aren't supported or don't have an obvious equivalent


00:27:20.080 --> 00:27:25.120
within the standard library, but where you go on down to...


00:27:25.120 --> 00:27:32.240
pedantic types on the right, so where you're looking is in the example,


00:27:32.240 --> 00:27:36.720
but pedantic types, then we get into things that don't exist within,


00:27:36.720 --> 00:27:41.200
or there isn't an obvious type for in pedantic in Python.


00:27:41.200 --> 00:27:44.160
There's a kind of subtle point here that like,


00:27:44.160 --> 00:27:48.200
Often, these types are used to enforce more validation.


00:27:48.200 --> 00:27:52.480
So what's returned is an existing Python type.


00:27:52.480 --> 00:27:56.040
So here we have file path, which returns a path,


00:27:56.040 --> 00:27:58.140
but it just guarantees that that file exists.


00:27:58.140 --> 00:28:00.640
And directory path, similarly, is just a path,


00:28:00.640 --> 00:28:02.480
but it will confirm that it is a directory.


00:28:02.480 --> 00:28:04.920
And email string just returns you a string,


00:28:04.920 --> 00:28:08.840
but it's validated that it's a legitimate email address.


00:28:08.840 --> 00:28:10.720
But then some do more complex stuff.


00:28:10.720 --> 00:28:12.720
So name email will return you,


00:28:12.720 --> 00:28:17.400
allow you to split out names and email addresses


00:28:17.400 --> 00:28:18.880
and more complex things.


00:28:18.880 --> 00:28:22.040
- Got credit cards, colors, URLs,


00:28:22.040 --> 00:28:23.800
all sorts of good stuff there, yeah.


00:28:23.800 --> 00:28:26.040
- Yes, so there's a Mexican bank called,


00:28:26.040 --> 00:28:28.480
excuse my pronunciation, Civenca,


00:28:28.480 --> 00:28:30.420
who use the credit card field


00:28:30.420 --> 00:28:33.520
for all of their validation of credit card numbers, so.


00:28:33.520 --> 00:28:36.080
- Yeah.


00:28:36.080 --> 00:28:37.300
Yeah, it's super interesting.


00:28:37.300 --> 00:28:39.200
And you think about how do you do this validation,


00:28:39.200 --> 00:28:40.760
how do you do these conversions yourself?


00:28:40.760 --> 00:28:42.920
not only do you have to figure that out,


00:28:42.920 --> 00:28:44.880
but then you've got to do it in the context


00:28:44.880 --> 00:28:46.720
of like a larger data conversion.


00:28:46.720 --> 00:28:49.820
And here you just say, this field is a type email


00:28:49.820 --> 00:28:52.580
and it either is an email


00:28:52.580 --> 00:28:54.760
or it's going to tell you that it's invalid, right?


00:28:54.760 --> 00:28:55.600
- Yeah.


00:28:55.600 --> 00:28:57.440
Yeah.


00:28:57.440 --> 00:28:58.260
- Yeah, I like this a lot.


00:28:58.260 --> 00:28:59.880
You know, one thing that it's,


00:28:59.880 --> 00:29:02.480
we've been talking about this pretty straightforward


00:29:02.480 --> 00:29:04.640
is using this for APIs, right?


00:29:04.640 --> 00:29:07.160
Like somebody who's doing a JSON post


00:29:07.160 --> 00:29:09.480
and you get that as a dictionary in your web framework


00:29:09.480 --> 00:29:12.380
and then you kind of validate it and convert it and so on.


00:29:12.380 --> 00:29:17.020
But it seems like you could even use this for like web forms


00:29:17.020 --> 00:29:18.660
and other type of things, right?


00:29:18.660 --> 00:29:22.460
Somebody submitting some kind of ATP post of a form


00:29:22.460 --> 00:29:24.180
and it comes over, right?


00:29:24.180 --> 00:29:26.720
If you want to say, these values are required,


00:29:26.720 --> 00:29:28.900
this one's an email and so on.


00:29:28.900 --> 00:29:30.560
- Yeah, so all of the form validation


00:29:30.560 --> 00:29:33.380
for multiple different projects I've built,


00:29:33.380 --> 00:29:35.180
some open source, lots proprietary,


00:29:35.180 --> 00:29:37.860
use Pylantic for form validation


00:29:37.860 --> 00:29:40.860
and use the error messages directly back to the user.


00:29:40.860 --> 00:29:42.780
I've got quite a lot of JavaScript


00:29:42.780 --> 00:29:45.980
that basically works with Pydantic to build forms


00:29:45.980 --> 00:29:49.180
and do validation and return that validation to the user.


00:29:49.180 --> 00:29:51.660
I've never quite gone far enough to really open source that


00:29:51.660 --> 00:29:54.820
and push it as a React plugin or something,


00:29:54.820 --> 00:29:56.980
but it wouldn't be hard to do.


00:29:56.980 --> 00:30:00.020
- So let me ask you this, and maybe when you say React,


00:30:00.020 --> 00:30:01.980
maybe that's enough of an answer already,


00:30:01.980 --> 00:30:06.940
but if it's a server-side processing form


00:30:06.940 --> 00:30:10.940
it's not a single page sort of friend and framework style


00:30:10.940 --> 00:30:12.660
of form submission.


00:30:12.660 --> 00:30:15.020
Often what you need to do is return back to them


00:30:15.020 --> 00:30:17.020
the wrong data, right?


00:30:17.020 --> 00:30:19.460
If they type in something that's not an email


00:30:19.460 --> 00:30:21.220
and over there it's not a number,


00:30:21.220 --> 00:30:24.820
you still wanna leave the form filled with that bad email


00:30:24.820 --> 00:30:26.420
and that thing that's not a number.


00:30:26.420 --> 00:30:29.640
So you can say, those are wrong, keep on typing them.


00:30:29.640 --> 00:30:34.100
Is there a way to make that kind of round tripping work


00:30:34.100 --> 00:30:35.060
with Pydantic?


00:30:35.060 --> 00:30:36.740
I've tried and haven't been able to do it,


00:30:36.740 --> 00:30:40.860
But if it's a front-end framework,


00:30:40.860 --> 00:30:42.460
it's easy to say, submit this form,


00:30:42.460 --> 00:30:43.900
catch the error and show the error


00:30:43.900 --> 00:30:45.300
'cause you're not actually leaving the page


00:30:45.300 --> 00:30:48.440
or clearing the form with a reload.


00:30:48.440 --> 00:30:49.700
- Yeah, the short answer is no,


00:30:49.700 --> 00:30:51.660
and it's something that's an issue of alpha v2


00:30:51.660 --> 00:30:55.580
to return the wrong value always


00:30:55.580 --> 00:30:57.580
in the context of each error.


00:30:57.580 --> 00:31:01.020
Often you kind of need it to make the error make sense,


00:31:01.020 --> 00:31:04.060
but at the moment it's generally not available


00:31:04.060 --> 00:31:05.580
and we will add it in v2.


00:31:05.580 --> 00:31:08.300
What I've done in React is obviously you've still got


00:31:08.300 --> 00:31:09.620
the values that were entered on the form,


00:31:09.620 --> 00:31:13.380
so you don't clear any of the inputs.


00:31:13.380 --> 00:31:16.060
You just add the errors to those fields


00:31:16.060 --> 00:31:18.220
and set the whatever it is, invalid header,


00:31:18.220 --> 00:31:19.660
so they're nice and red.


00:31:19.660 --> 00:31:20.500
- Yeah, exactly.


00:31:20.500 --> 00:31:22.780
So if it was a front-end framework like Reactor View,


00:31:22.780 --> 00:31:24.560
I can see this working perfectly


00:31:24.560 --> 00:31:26.820
as you try to submit it for a form.


00:31:26.820 --> 00:31:29.940
But if you got to round trip it with like a flask,


00:31:29.940 --> 00:31:32.720
a pyramid or Django form or something that doesn't have it,


00:31:32.720 --> 00:31:35.920
then the fact that it doesn't capture the data.


00:31:35.920 --> 00:31:37.080
I mean, I guess you could return back


00:31:37.080 --> 00:31:39.780
just the original posted dictionary, but yeah.


00:31:39.780 --> 00:31:41.680
- Yeah, so you have the original,


00:31:41.680 --> 00:31:44.640
yeah, like you say, normally there,


00:31:44.640 --> 00:31:48.560
it's not too many different levels


00:31:48.560 --> 00:31:52.880
and it's relatively simple to combine up the dictionary


00:31:52.880 --> 00:31:57.880
you got straight off the form submission with the errors.


00:31:57.880 --> 00:32:01.200
But yeah, you're right, it's something we should improve.


00:32:01.200 --> 00:32:02.240
- Yeah.


00:32:02.240 --> 00:32:03.480
- Well, I'm not necessarily that,


00:32:03.480 --> 00:32:05.520
I'm not sure that you necessarily need to improve it


00:32:05.520 --> 00:32:10.320
'cause it's mission is being fulfilled exactly how it is.


00:32:10.320 --> 00:32:11.280
And if it has this time,


00:32:11.280 --> 00:32:12.700
but well, sometimes it throws errors


00:32:12.700 --> 00:32:15.120
and sometimes it doesn't and like just report.


00:32:15.120 --> 00:32:17.240
I don't know, it seems like you could overly


00:32:17.240 --> 00:32:18.840
complicate it as well.


00:32:18.840 --> 00:32:21.300
- I think there's like a really difficult challenge


00:32:21.300 --> 00:32:23.840
in the tragedy of the commons


00:32:23.840 --> 00:32:26.540
in like someone wants a niche feature,


00:32:26.540 --> 00:32:27.760
someone else wants that feature,


00:32:27.760 --> 00:32:29.280
you get 10 people wanting that feature,


00:32:29.280 --> 00:32:30.920
you feel under overwhelming pressure


00:32:30.920 --> 00:32:34.160
to implement that feature, but you forget that there's,


00:32:34.160 --> 00:32:36.880
I forget, you know, there's like 6,000 people who started it


00:32:36.880 --> 00:32:40.960
but it's like 10, 12,000 projects that use Pydantic.


00:32:40.960 --> 00:32:42.200
Those people haven't asked for that.


00:32:42.200 --> 00:32:44.680
Do they want it or would they actively prefer


00:32:44.680 --> 00:32:47.920
that Pydantic was simpler, faster, smaller?


00:32:47.920 --> 00:32:48.760
- Exactly.


00:32:48.760 --> 00:32:49.580
- Because you don't need to implement that.


00:32:49.580 --> 00:32:52.400
- Right, part of the beauty of it is it's so simple, right?


00:32:52.400 --> 00:32:55.120
I do X, I get the value, I define the class,


00:32:55.120 --> 00:32:57.080
I star star, take the data.


00:32:57.080 --> 00:32:59.560
And it's either good or it's crashed, right?


00:32:59.560 --> 00:33:02.200
If it gets past that line, you should be happy.


00:33:02.200 --> 00:33:06.960
Yeah, and I think that I'm pretty determined to keep that stuff that simple.


00:33:06.960 --> 00:33:09.200
There are those who want to change it who say,


00:33:09.200 --> 00:33:11.200
"Initializing the class shouldn't do the validation,


00:33:11.200 --> 00:33:12.840
then you should call a validate method."


00:33:12.840 --> 00:33:14.680
I'm not into that at all.


00:33:14.680 --> 00:33:17.640
There's stuff where I'm definitely going to keep it simple


00:33:17.640 --> 00:33:19.560
and there's stuff where I'm really happy to add more things.


00:33:19.560 --> 00:33:21.560
So we were talking about custom types before.


00:33:21.560 --> 00:33:24.120
I'm really happy to add virtually, not virtually any,


00:33:24.120 --> 00:33:26.120
but a lot of custom types when someone wants it


00:33:26.120 --> 00:33:29.320
because if you don't need it, it just sits there


00:33:29.480 --> 00:33:31.880
and mostly doesn't affect people.


00:33:31.880 --> 00:33:33.920
- Right, if you don't specify a column


00:33:33.920 --> 00:33:35.760
or a field of that type, it doesn't matter.


00:33:35.760 --> 00:33:37.520
You'll never know it or care.


00:33:37.520 --> 00:33:38.960
Yeah. - Yeah.


00:33:38.960 --> 00:33:42.520
- So there's a couple of comments in the live stream.


00:33:42.520 --> 00:33:45.800
I think maybe we can go ahead and touch on them


00:33:45.800 --> 00:33:47.960
about sort of future plans.


00:33:47.960 --> 00:33:49.960
So you did mention that there's gonna be


00:33:49.960 --> 00:33:51.800
kind of a major upgrade of V2,


00:33:51.800 --> 00:33:54.280
and Carlos out there asks,


00:33:54.280 --> 00:33:56.740
is there any plans for Pydantic to give support


00:33:56.740 --> 00:33:59.720
for PySpark data frame scheme validation?


00:33:59.720 --> 00:34:02.300
Or, you know, let me ask more broadly,


00:34:02.300 --> 00:34:05.180
like any of the data science world integration


00:34:05.180 --> 00:34:07.340
with like pandas or other, you know,


00:34:07.340 --> 00:34:09.020
NumPy or other things like that.


00:34:09.020 --> 00:34:13.700
- There's been a lot of issues on NumPy arrays


00:34:13.700 --> 00:34:16.820
and like validating them using list types


00:34:16.820 --> 00:34:21.820
without going all the way to like Python list


00:34:21.820 --> 00:34:23.940
because that can have performance problems.


00:34:25.060 --> 00:34:26.760
I can't remember because it was a long time ago,


00:34:26.760 --> 00:34:29.880
but people, whoever it was, found a solution.


00:34:29.880 --> 00:34:32.800
And like, Pydantic is used a lot now in data science.


00:34:32.800 --> 00:34:35.020
If you look at the projects it's used in,


00:34:35.020 --> 00:34:36.420
by Uber and by Facebook,


00:34:36.420 --> 00:34:39.220
'cause they're like big machine learning projects.


00:34:39.220 --> 00:34:42.980
Fast, Facebook's Fast MRI library uses it.


00:34:42.980 --> 00:34:45.100
Like, it's used a reasonable amount


00:34:45.100 --> 00:34:48.420
in like big data validation pipelines.


00:34:48.420 --> 00:34:51.260
So I don't know about PySpark,


00:34:51.260 --> 00:34:53.980
so I'm not gonna be able to give a definitive answer


00:34:53.980 --> 00:34:56.900
If you create an issue, I'll endeavor to remember


00:34:56.900 --> 00:34:59.300
to look at it and have a look and give an answer.


00:34:59.300 --> 00:35:02.780
- You'll start your PySpark research project?


00:35:02.780 --> 00:35:03.620
- Yeah.


00:35:03.620 --> 00:35:10.540
- Nice, also from Carlos, what's the timeframe for V2?


00:35:10.540 --> 00:35:12.340
- Someone joked to me the other day


00:35:12.340 --> 00:35:14.180
that the release date was originally put down


00:35:14.180 --> 00:35:17.220
as the end of March 2020 and that didn't get reached


00:35:17.220 --> 00:35:21.060
and it's still, the short answer is that I need to,


00:35:21.060 --> 00:35:21.880
there are two problems.


00:35:21.880 --> 00:35:23.420
One is I need to set some time aside


00:35:23.420 --> 00:35:26.620
to sit there and build quite a lot of code.


00:35:26.620 --> 00:35:28.460
Second problem is the number of open PRs


00:35:28.460 --> 00:35:29.780
and the number of issues.


00:35:29.780 --> 00:35:33.300
I find it hard sometimes to bring myself


00:35:33.300 --> 00:35:35.500
to go and work on Pydantic when I have time off


00:35:35.500 --> 00:35:38.260
because a lot of it is like the troll of going through issues


00:35:38.260 --> 00:35:39.620
and reviewing pull requests.


00:35:39.620 --> 00:35:42.340
And when I'm not doing my day job of writing code,


00:35:42.340 --> 00:35:44.060
I want to write code on something fun


00:35:44.060 --> 00:35:46.580
and not have to review other people's code


00:35:46.580 --> 00:35:48.700
because I do that for a day job quite a lot.


00:35:48.700 --> 00:35:53.700
So I've had a bit of trouble getting my back-ending gear


00:35:53.700 --> 00:35:58.300
to go and work on Pydantic because I feel like


00:35:58.300 --> 00:36:01.340
there's 20 hours of reviewing other people's code


00:36:01.340 --> 00:36:03.100
before I can do anything fun.


00:36:03.100 --> 00:36:05.460
And I think one of the solutions to that


00:36:05.460 --> 00:36:06.820
is I'm just gonna start building V2


00:36:06.820 --> 00:36:08.380
and ignore some pull requests


00:36:08.380 --> 00:36:10.700
and might have to break some eggs to make an omelet,


00:36:10.700 --> 00:36:13.580
but I think that's better.


00:36:13.580 --> 00:36:14.500
- Okay, yeah.


00:36:14.500 --> 00:36:17.080
Well, and also in your defense,


00:36:17.080 --> 00:36:20.280
a lot of things were planned for March, 2020.


00:36:20.280 --> 00:36:22.640
- Yeah, that is true.


00:36:22.640 --> 00:36:24.160
I have sat at my desk in my office


00:36:24.160 --> 00:36:27.060
for a total of about eight hours since then.


00:36:27.060 --> 00:36:30.160
So I haven't been back to the office in London at all.


00:36:30.160 --> 00:36:33.920
So yeah, I would hope this year.


00:36:33.920 --> 00:36:34.760
- Yeah, cool.


00:36:34.760 --> 00:36:35.580
All right.


00:36:35.580 --> 00:36:38.480
And then related to that, Risky Chance asks,


00:36:38.480 --> 00:36:40.680
where should people who want to contribute


00:36:40.680 --> 00:36:41.720
to PyDendrix start?


00:36:41.720 --> 00:36:44.720
And I would help you kick off this conversation


00:36:44.720 --> 00:36:46.440
by just pointing out that you have tagged


00:36:46.440 --> 00:36:50.680
a bunch of issues as help wanted,


00:36:50.680 --> 00:36:52.680
and then also maybe reviewing PRs,


00:36:52.680 --> 00:36:54.480
but what else would you add to that?


00:36:54.480 --> 00:36:56.080
- I think the first thing I would say is,


00:36:56.080 --> 00:36:58.040
and I know this isn't the most fun thing to do,


00:36:58.040 --> 00:37:01.960
but if people could help with reviewing discussions


00:37:01.960 --> 00:37:04.560
and issues, that's a really--


00:37:04.560 --> 00:37:06.240
- A triage type stuff?


00:37:06.240 --> 00:37:09.280
- Yeah, but if you go onto discussions,


00:37:09.280 --> 00:37:12.000
we use the GitHub discussions,


00:37:12.000 --> 00:37:13.400
which maybe people don't even see,


00:37:13.400 --> 00:37:16.200
but these are all questions you can go in and answer


00:37:16.200 --> 00:37:18.760
if someone has a problem, lots of them aren't that complicated.


00:37:18.760 --> 00:37:21.400
I know that's perhaps not what risky chance meant


00:37:21.400 --> 00:37:23.820
in terms of writing code.


00:37:23.820 --> 00:37:26.160
And that's obviously, for some of us, where the fun lies.


00:37:26.160 --> 00:37:28.440
But these questions would be enormously helpful


00:37:28.440 --> 00:37:29.680
if people could have--


00:37:29.680 --> 00:37:32.000
you can see some of them are answered, and that's great.


00:37:32.000 --> 00:37:34.320
But there are others that aren't.


00:37:34.320 --> 00:37:38.760
And then, yeah, when I--


00:37:38.760 --> 00:37:41.260
reviewing pull requests would be the second most useful thing


00:37:41.260 --> 00:37:42.320
people could do.


00:37:42.320 --> 00:37:45.760
and then if there are unwanted issues,


00:37:45.760 --> 00:37:48.480
just checking that we're still on for it


00:37:48.480 --> 00:37:49.480
and it's the right time to do it.


00:37:49.480 --> 00:37:51.160
And then I do love submissions.


00:37:51.160 --> 00:37:53.760
I noticed today there were 200 and something people


00:37:53.760 --> 00:37:55.960
who've contributed to Pydantic,


00:37:55.960 --> 00:37:58.760
so I do do my best to support anyone who comes along,


00:37:58.760 --> 00:38:00.960
however inexperienced or experienced


00:38:00.960 --> 00:38:04.920
building features or fixing bugs, but yeah.


00:38:04.920 --> 00:38:08.480
Yeah, fantastic.


00:38:08.480 --> 00:38:10.320
All right, another thing I want to talk to you about,


00:38:10.320 --> 00:38:11.360
Is this the right one?


00:38:11.360 --> 00:38:14.200
I believe, no, the validating decorator.


00:38:14.200 --> 00:38:16.040
Well, let's talk about validators first.


00:38:16.040 --> 00:38:17.640
We touched on this a little bit.


00:38:17.640 --> 00:38:22.400
So one thing you can do is you can write functions


00:38:22.400 --> 00:38:26.680
that you decorate with this validator decorator


00:38:26.680 --> 00:38:29.120
and says, this is the function whose job is


00:38:29.120 --> 00:38:32.720
to do a deeper check on a field, right?


00:38:32.720 --> 00:38:34.360
So you can say, this is a validator for name,


00:38:34.360 --> 00:38:36.080
this is a validator for username


00:38:36.080 --> 00:38:38.580
or validator for email or whatever.


00:38:38.580 --> 00:38:43.620
And those functions are ways in which you can take better control over


00:38:43.620 --> 00:38:46.420
what is a valid value and stuff like that, right?


00:38:46.420 --> 00:38:49.460
Yeah, but you can do more. You can't just be stricter,


00:38:49.460 --> 00:38:51.580
as in raising error if it's not how you want it.


00:38:51.580 --> 00:38:57.660
You can also change the value that you're going to, that's come in.


00:38:57.660 --> 00:39:01.740
So you can see in the first case of name contains a space,


00:39:01.740 --> 00:39:04.500
we checked that the name doesn't contain a space as a dummy example,


00:39:04.500 --> 00:39:09.500
but we also return titles, so capitalize the first letter.


00:39:09.500 --> 00:39:12.220
So you can also change the value you're going to put in.


00:39:12.220 --> 00:39:15.540
So coming back to the date case we were hearing about earlier,


00:39:15.540 --> 00:39:19.220
if you knew your users were going to use some very specific date format


00:39:19.220 --> 00:39:23.740
of day of the week as a string, followed by day of the month,


00:39:23.740 --> 00:39:26.260
followed by year in Roman numerals,


00:39:26.260 --> 00:39:28.660
you could spot that with a regex,


00:39:28.660 --> 00:39:30.300
have your own logic to do the validation,


00:39:30.300 --> 00:39:33.220
and then if it's at any other date, pass it through to the normal


00:39:33.220 --> 00:39:36.900
gigantic logic, which will carry on and do its normal stuff on strings.


00:39:36.900 --> 00:39:40.740
Yeah, cool. Now, this stuff is pretty advanced,


00:39:40.740 --> 00:39:44.500
but you can also do simple stuff like set an inner class,


00:39:44.500 --> 00:39:47.780
which is a config, and just set things like


00:39:47.780 --> 00:39:53.140
any string strip off the white space or lowercase all the strings


00:39:53.140 --> 00:39:55.140
or stuff like that, right?


00:39:55.140 --> 00:39:57.780
Yeah, and there's allowMutation, which you've got to there,


00:39:57.780 --> 00:40:00.260
which is super helpful. That's where we can drop fields


00:40:00.260 --> 00:40:02.500
and be modified. There's extra there,


00:40:02.500 --> 00:40:04.900
which is something people often want, which is what do we do


00:40:04.900 --> 00:40:07.620
with extra fields that we haven't defined on our model?


00:40:07.620 --> 00:40:11.540
Is that an error? Do we just ignore them or do we allow them and just like


00:40:11.540 --> 00:40:16.100
bung them on the class and we won't have any type hints for them, but they are there if we want them.


00:40:16.100 --> 00:40:18.100
Yeah.


00:40:18.100 --> 00:40:22.660
Yeah, very cool. Okay, so the other thing I wanted to ask you about is really interesting because part of


00:40:22.660 --> 00:40:28.500
what I think makes Pydantic really interesting is its deep leveraging of type hints, right?


00:40:28.500 --> 00:40:32.100
And in Python, type hints are a suggestion.


00:40:32.100 --> 00:40:34.500
They're things that make our editors light up.


00:40:34.500 --> 00:40:37.300
They are things that if you really, really tried,


00:40:37.300 --> 00:40:38.500
I don't think most people do this,


00:40:38.500 --> 00:40:40.700
but you could run something like mypy against it,


00:40:40.700 --> 00:40:42.700
and it would tell you if it's accurate or not.


00:40:42.700 --> 00:40:46.500
I think most people just put it as there's extra information,


00:40:46.500 --> 00:40:50.200
maybe PyCharm or VS Code tells you you're doing it right,


00:40:50.200 --> 00:40:52.200
or gives you better autocomplete.


00:40:52.200 --> 00:40:56.900
But under almost no circumstance


00:40:56.900 --> 00:41:00.200
does having a function called add that says


00:41:00.200 --> 00:41:05.000
x colon int comma y colon int only work if you pass integers, right?


00:41:05.000 --> 00:41:07.880
You could pass strings to it and probably get a concatenated string


00:41:07.880 --> 00:41:09.880
out of that Python function.


00:41:09.880 --> 00:41:12.600
Because there's no, it's not like C++ or something where


00:41:12.600 --> 00:41:15.160
it compiles down and checks the thing, right?


00:41:15.160 --> 00:41:19.400
But you also have this validating decorator thing,


00:41:19.400 --> 00:41:22.360
which it seems to me like this will actually


00:41:22.360 --> 00:41:27.720
sort of add that runtime check for the types. Is that correct?


00:41:27.720 --> 00:41:30.120
That's exactly what it's designed to do.


00:41:30.120 --> 00:41:33.160
It's always been a kind of interest to me,


00:41:33.160 --> 00:41:36.520
almost a kind of, yeah, just to kind of experiment


00:41:36.520 --> 00:41:37.640
to see whether this is possible,


00:41:37.640 --> 00:41:43.800
whether we could have semi-strictly typed logic in Python.


00:41:43.800 --> 00:41:45.560
I should say before we go any further,


00:41:45.560 --> 00:41:48.360
this isn't to be used on every function.


00:41:48.360 --> 00:41:51.640
It's not like Rust where doing that validation


00:41:51.640 --> 00:41:52.600
actually makes it faster.


00:41:52.600 --> 00:41:55.400
This is going to make calling your function way, way slower


00:41:55.400 --> 00:41:57.080
because inside validate arguments,


00:41:57.080 --> 00:41:59.340
we're going to go off and do a whole bunch of logic


00:41:59.340 --> 00:42:01.080
to validate every field,


00:42:01.080 --> 00:42:03.380
but there are situations where it can be really useful


00:42:03.380 --> 00:42:07.140
and where creating that Pydantic model was a bit onerous,


00:42:07.140 --> 00:42:09.140
but where we can just bang on the decorator


00:42:09.140 --> 00:42:12.180
and get some validation kind of for free.


00:42:12.180 --> 00:42:15.720
Right, because the decorator basically does the same thing.


00:42:15.720 --> 00:42:18.220
I mean, sorry, the classes do the same thing


00:42:18.220 --> 00:42:19.920
as this decorator might,


00:42:19.920 --> 00:42:21.920
but instead of having a class, you have arguments.


00:42:21.920 --> 00:42:25.220
And under the hood, what validate arguments is doing


00:42:25.220 --> 00:42:30.220
is it's inspecting that function, taking out the arguments,


00:42:30.220 --> 00:42:32.820
building them into a Pynantic model,


00:42:32.820 --> 00:42:35.680
and then running the input into that Pynantic model,


00:42:35.680 --> 00:42:40.680
and then using the result to call the function.


00:42:40.680 --> 00:42:43.540
- Yeah, and that sounds like more work


00:42:43.540 --> 00:42:45.820
than just calling the function, for sure.


00:42:45.820 --> 00:42:47.900
It depends on how much it does, right?


00:42:47.900 --> 00:42:50.300
Does it cache that kind of,


00:42:50.300 --> 00:42:52.140
does it like cache the class that it creates


00:42:52.140 --> 00:42:52.980
when it decorates a function?


00:42:52.980 --> 00:42:56.740
- Same as we do in other places,


00:42:56.740 --> 00:42:59.480
but yes, it's still a lot more like


00:42:59.480 --> 00:43:01.480
pedantic fast for data validation,


00:43:01.480 --> 00:43:03.540
but it's data validation, not a compiler.


00:43:03.540 --> 00:43:06.980
- Yeah, so maybe this would make sense


00:43:06.980 --> 00:43:08.860
if I'm writing a data science library


00:43:08.860 --> 00:43:10.220
and at the very outer shell,


00:43:10.220 --> 00:43:11.600
I pass in a whole bunch of data,


00:43:11.600 --> 00:43:13.380
then it goes off to all sorts of places.


00:43:13.380 --> 00:43:16.600
Maybe it might make sense to put this on the boundary,


00:43:16.600 --> 00:43:19.860
entry point type of thing, but nowhere else.


00:43:19.860 --> 00:43:21.900
- Yeah, exactly, where someone's gonna find it


00:43:21.900 --> 00:43:25.020
much easier to see a pedantic error saying


00:43:25.020 --> 00:43:26.820
these fields were wrong rather than seeing


00:43:26.820 --> 00:43:28.900
some strange matrix that comes out the wrong shape


00:43:28.900 --> 00:43:32.540
because it passed in something as a string, not an int.


00:43:32.540 --> 00:43:37.100
- Or none type has no attribute such and such.


00:43:37.100 --> 00:43:38.140
- Yeah. - Whatever.


00:43:38.140 --> 00:43:40.940
Right, that standard error they always run into.


00:43:40.940 --> 00:43:44.360
Okay, yeah, that's pretty interesting.


00:43:44.360 --> 00:43:47.260
Let's talk a little bit about speed.


00:43:47.260 --> 00:43:49.260
You have talked about this a couple of times,


00:43:49.260 --> 00:43:53.980
but maybe it's just worth throwing up a simple example here


00:43:53.980 --> 00:43:55.260
to put them together.


00:43:55.260 --> 00:43:57.820
So we've got Pydantic, we've got Adders,


00:43:57.820 --> 00:43:59.900
we've got Validere, which I've never heard about,


00:43:59.900 --> 00:44:01.980
but very cool, Marshmallow,


00:44:01.980 --> 00:44:04.500
and a couple of others like Django REST Framework


00:44:04.500 --> 00:44:05.740
and Cerebus.


00:44:05.740 --> 00:44:10.660
So it has all of these in relative time


00:44:10.660 --> 00:44:13.060
to some benchmark code that you have,


00:44:13.060 --> 00:44:15.900
but it basically gives it as a percentage


00:44:15.900 --> 00:44:18.620
or a factor of performance, right?


00:44:18.620 --> 00:44:20.980
- Yeah, and look, the first thing I'll say is


00:44:20.980 --> 00:44:23.740
that there were lies, damn lies, and benchmarks.


00:44:23.740 --> 00:44:26.940
You might well get different results,


00:44:26.940 --> 00:44:30.220
but my impression from what I've seen is that


00:44:30.220 --> 00:44:32.380
Pydantic is as fast, if not faster,


00:44:32.380 --> 00:44:34.420
than the other ways of doing it in Python,


00:44:34.420 --> 00:44:37.660
short of writing your own custom code in each place


00:44:37.660 --> 00:44:40.740
to be like, yeah, to do manual validation,


00:44:40.740 --> 00:44:41.780
which is a massive pain.


00:44:41.780 --> 00:44:43.260
And if you're doing that, you probably wanna go


00:44:43.260 --> 00:44:44.540
and write it in a proper language,


00:44:44.540 --> 00:44:46.240
a proper compiled language anyway.


00:44:47.180 --> 00:44:50.560
- Right, right, or maybe just use Cython


00:44:50.560 --> 00:44:53.880
on some little section, something like that, right?


00:44:53.880 --> 00:44:56.400
- So all of Pydantic is compiled with Cython


00:44:56.400 --> 00:44:58.520
and is about twice as fast.


00:44:58.520 --> 00:44:59.760
If you install it with pip,


00:44:59.760 --> 00:45:02.960
you will get mostly the compiled version.


00:45:02.960 --> 00:45:07.640
There are binaries available for Windows, Mac and Linux,


00:45:07.640 --> 00:45:12.080
Windows 64-bit, not 32, and maybe some other extreme,


00:45:12.080 --> 00:45:14.360
and it will compile for other operating systems.


00:45:14.360 --> 00:45:18.760
So it's already faster than just calling Python.


00:45:18.760 --> 00:45:20.520
Well, I don't know about whether validation


00:45:20.520 --> 00:45:23.520
with Pydantic that's compiled is faster than raw Python,


00:45:23.520 --> 00:45:26.320
but like, it'll be of the same order of magnitude.


00:45:26.320 --> 00:45:27.520
- Yeah, yeah, fantastic.


00:45:27.520 --> 00:45:30.040
Okay, I didn't realize it was compiled with Cython.


00:45:30.040 --> 00:45:30.860
That's great.


00:45:30.860 --> 00:45:32.840
- Yeah, so-- - That's part of the magic,


00:45:32.840 --> 00:45:34.220
making it faster.


00:45:34.220 --> 00:45:38.120
- Yeah, so that was David Montague, a year and a half ago,


00:45:38.120 --> 00:45:39.560
put an enormous amount of effort into it,


00:45:39.560 --> 00:45:41.840
and yeah, about doubled the performance.


00:45:42.840 --> 00:45:45.240
So it's Python compiled with Cython


00:45:45.240 --> 00:45:47.400
rather than real Cython code.


00:45:47.400 --> 00:45:49.320
So it's not as C speed,


00:45:49.320 --> 00:45:52.120
but it's faster than just calling Python.


00:45:52.120 --> 00:45:53.760
- Yeah, absolutely.


00:45:53.760 --> 00:45:56.840
And Cython, taking the type hint information


00:45:56.840 --> 00:45:58.480
and working so well with it these days,


00:45:58.480 --> 00:46:00.800
it probably was easier than it used to be


00:46:00.800 --> 00:46:03.800
or didn't require as many changes as it might otherwise.


00:46:03.800 --> 00:46:08.160
- Yeah, I mean, I think it's an open question


00:46:08.160 --> 00:46:10.040
whether Cython is faster with type hints.


00:46:10.040 --> 00:46:12.400
It does, in places actually adding type hints


00:46:12.400 --> 00:46:14.800
makes it slower because it does its own checks


00:46:14.800 --> 00:46:16.880
that I think is a string when you've said it's a string.


00:46:16.880 --> 00:46:19.780
But yeah, I think it does use it in places.


00:46:19.780 --> 00:46:21.680
- Yeah, I was thinking more like you don't have to rewrite


00:46:21.680 --> 00:46:24.320
it in Cython, like you don't have to convert Python code


00:46:24.320 --> 00:46:27.080
to Cython code where it has its own sort of


00:46:27.080 --> 00:46:28.280
descriptor language.


00:46:28.280 --> 00:46:31.560
But like, if you have Python code that's type annotated,


00:46:31.560 --> 00:46:34.880
it'll take that and run with it these days.


00:46:34.880 --> 00:46:37.080
- I think it isn't any faster or any better


00:46:37.080 --> 00:46:38.600
because of the type ins much.


00:46:38.600 --> 00:46:40.160
Although someone out there is an expert


00:46:40.160 --> 00:46:41.760
and I don't wanna say that, so I'm not sure.


00:46:41.760 --> 00:46:43.360
- Yeah, okay.


00:46:43.360 --> 00:46:44.640
All right, another thing I want to touch on


00:46:44.640 --> 00:46:46.560
is the data model code generator.


00:46:46.560 --> 00:46:48.920
You want to tell us about this thing?


00:46:48.920 --> 00:46:50.760
- I haven't used it much, but yeah,


00:46:50.760 --> 00:46:53.900
so what we have on board right now is JSON Schema,


00:46:53.900 --> 00:46:58.900
which is Sebastian Ramirez implemented a couple of years ago


00:46:58.900 --> 00:47:01.920
when he was first starting out on FastAPI,


00:47:01.920 --> 00:47:04.040
and is one of the coolest features of FastAPI


00:47:04.040 --> 00:47:09.040
and Pydantic is that once you've created your model,


00:47:09.360 --> 00:47:12.440
you don't just get model and model validation,


00:47:12.440 --> 00:47:15.260
you also get a schema generated for your model.


00:47:15.260 --> 00:47:17.400
And in FastAPI, that's automatically created


00:47:17.400 --> 00:47:20.160
with Redock into really smart documentation.


00:47:20.160 --> 00:47:22.660
So you don't even have to think about documentation


00:47:22.660 --> 00:47:24.520
most of the time, if it's internal,


00:47:24.520 --> 00:47:28.200
or it's not widely used API,


00:47:28.200 --> 00:47:31.540
and even if it's widely used, add some doc strings,


00:47:31.540 --> 00:47:36.540
and you've got yourself amazing API documentation


00:47:36.540 --> 00:47:39.320
just straight from your model.


00:47:39.320 --> 00:47:42.680
and data model code generation as I understand it


00:47:42.680 --> 00:47:47.680
is generating those JSON schema models.


00:47:47.680 --> 00:47:49.200
Is that right?


00:47:49.200 --> 00:47:50.020
I mean, I haven't used it.


00:47:50.020 --> 00:47:50.860
- Yeah, I think so.


00:47:50.860 --> 00:47:53.980
It feels to me like it's the reverse


00:47:53.980 --> 00:47:57.360
of what you described from what Sebastian has created.


00:47:57.360 --> 00:48:00.600
Given one of these open API definitions,


00:48:00.600 --> 00:48:03.220
it will generate the Pydantic model for you.


00:48:03.220 --> 00:48:06.680
So if I was gonna consume an API,


00:48:08.300 --> 00:48:10.020
And I'm like, well, I got to write some


00:48:10.020 --> 00:48:11.460
Pydantic models to match it.


00:48:11.460 --> 00:48:13.220
Like you could run this thing to say, well,


00:48:13.220 --> 00:48:16.220
give me a good shot at getting pretty close.


00:48:16.220 --> 00:48:19.980
- I, yeah, I had it around the wrong way, but yeah,


00:48:19.980 --> 00:48:23.100
I think I, my instinct is I haven't used it,


00:48:23.100 --> 00:48:25.700
but that it gets you, it does 90% of the work for you.


00:48:25.700 --> 00:48:28.500
And then there's a bit of like manual tinkering


00:48:28.500 --> 00:48:31.180
around the edge to change some of the types I suspect,


00:48:31.180 --> 00:48:33.860
but like, yeah, really useful.


00:48:33.860 --> 00:48:35.900
- Yeah, and it supports different frameworks and stuff.


00:48:35.900 --> 00:48:37.740
And I haven't used it either, but it just seemed like


00:48:37.740 --> 00:48:40.220
it was a cool thing related to sort of quickly


00:48:40.220 --> 00:48:42.300
get people started if they've got something complex


00:48:42.300 --> 00:48:44.060
to do with Pydantic.


00:48:44.060 --> 00:48:47.640
So for example, I built this weather, real time,


00:48:47.640 --> 00:48:50.420
weather, live weather data service for one of my classes


00:48:50.420 --> 00:48:52.700
over at weather.talkpython.fm.


00:48:52.700 --> 00:48:57.140
I built that in FastAPI and it exchanges Pydantic models


00:48:57.140 --> 00:49:00.220
and all you gotta do in order to see the documentation


00:49:00.220 --> 00:49:03.780
is just go to slash docs and then it gives you


00:49:03.780 --> 00:49:05.180
the JSON schema.


00:49:05.180 --> 00:49:09.340
So presumably I could point that thing at this


00:49:09.340 --> 00:49:11.180
and then it would generate--


00:49:11.180 --> 00:49:12.300
- Yeah.


00:49:12.300 --> 00:49:15.140
- Exactly, and get a fairly complicated


00:49:15.140 --> 00:49:16.460
PyDenic model pre-built for me,


00:49:16.460 --> 00:49:18.760
which I think is pretty excellent.


00:49:18.760 --> 00:49:19.600
- Yeah.


00:49:19.600 --> 00:49:22.320
It's worth saying, maybe you disagree,


00:49:22.320 --> 00:49:26.140
but I think the re-doc version of the documentation


00:49:26.140 --> 00:49:28.700
or the auto docs is even smarter than that one.


00:49:28.700 --> 00:49:29.540
I don't know if you've got it.


00:49:29.540 --> 00:49:30.900
Yeah, that one I think is even smarter.


00:49:30.900 --> 00:49:32.360
- Oh yeah, this is a really nice one.


00:49:32.360 --> 00:49:33.780
I like this one a lot.


00:49:33.780 --> 00:49:35.780
- Yeah, it even gives you the responses there.


00:49:35.780 --> 00:49:37.820
It can be 200 or 422.


00:49:37.820 --> 00:49:39.160
And I did build that into there,


00:49:39.160 --> 00:49:41.040
but I didn't expect it to actually know.


00:49:41.040 --> 00:49:42.220
That's pretty interesting.


00:49:42.220 --> 00:49:43.700
- Yeah, it's cool.


00:49:43.700 --> 00:49:44.540
- Yeah, it's very cool.


00:49:44.540 --> 00:49:48.400
So they're both there, either /docs or /redoc.


00:49:48.400 --> 00:49:52.940
- Or you can switch one off or change the endpoints,


00:49:52.940 --> 00:49:54.060
but yeah.


00:49:54.060 --> 00:49:54.900
- Yeah, and by the way,


00:49:54.900 --> 00:49:57.660
if you're putting out a FastAPI,


00:49:57.660 --> 00:50:00.160
API and you don't want public documentation,


00:50:01.180 --> 00:50:05.180
make sure that you set the docs URL and the redocs URL to none


00:50:05.180 --> 00:50:08.660
when you're creating your app or your API instance.


00:50:08.660 --> 00:50:11.180
So yeah, that's always on unless you take action.


00:50:11.180 --> 00:50:13.300
So you better just let it. - Or you could do what I've done,


00:50:13.300 --> 00:50:16.100
which is protect it with authentication


00:50:16.100 --> 00:50:17.980
so the front-end developers can use it,


00:50:17.980 --> 00:50:19.300
but it's not publicly available.


00:50:19.300 --> 00:50:22.020
So if you're building like a React app,


00:50:22.020 --> 00:50:24.100
it's really useful to have your front-end engineers


00:50:24.100 --> 00:50:25.220
be able to go and see that stuff


00:50:25.220 --> 00:50:26.980
and understand what the fields are,


00:50:26.980 --> 00:50:29.140
but it's a bit of a weird thing to make public,


00:50:29.140 --> 00:50:31.600
even if there's nothing particularly sensitive.


00:50:31.600 --> 00:50:33.960
So yeah, you can put it behind authentication.


00:50:33.960 --> 00:50:36.040
- Yeah, yeah, very good.


00:50:36.040 --> 00:50:38.560
All right, you already talked about the PyCharm plugin,


00:50:38.560 --> 00:50:41.080
but maybe give us a sense for


00:50:41.080 --> 00:50:43.080
why do we need a PyCharm plugin?


00:50:43.080 --> 00:50:47.560
I have PyCharm, and if it has the type information,


00:50:47.560 --> 00:50:50.640
a lot of times it seems like it's already good to go.


00:50:50.640 --> 00:50:52.520
So what do I get from this PyCharm plugin?


00:50:52.520 --> 00:50:54.160
Like, why should I go put this in?


00:50:54.160 --> 00:50:55.600
- So once you've created your model,


00:50:55.600 --> 00:50:59.180
If we think about the example on the index page again,


00:50:59.180 --> 00:51:04.720
once we've created our model,


00:51:04.720 --> 00:51:08.000
accessing .friends or .id or .name will work


00:51:08.000 --> 00:51:13.000
and PyCharm will correctly give us information about,


00:51:13.000 --> 00:51:16.040
we'll say, okay, first name exists,


00:51:16.040 --> 00:51:18.720
like foobar name doesn't exist.


00:51:18.720 --> 00:51:21.680
It's a string, so it makes sense to add it to another string.


00:51:21.680 --> 00:51:24.520
But when we initialize a model,


00:51:24.520 --> 00:51:28.000
It doesn't know how, like the init function of Pydantic


00:51:28.000 --> 00:51:29.920
just looks like, take all of the things


00:51:29.920 --> 00:51:32.000
and pass them to some magic function.


00:51:32.000 --> 00:51:35.920
- It looks like star star KWR, good luck, go read the docs.


00:51:35.920 --> 00:51:37.440
- Exactly that.


00:51:37.440 --> 00:51:39.600
But this is where the PyCharm plugin comes in


00:51:39.600 --> 00:51:43.360
because it gives you documentation on the arguments.


00:51:43.360 --> 00:51:46.800
- Okay, so it looks at the fields and their types


00:51:46.800 --> 00:51:49.740
and says, well, these are actually keyword arguments


00:51:49.740 --> 00:51:52.200
to the constructor of the initializer.


00:51:52.200 --> 00:51:53.320
- Yeah.


00:51:53.320 --> 00:51:55.120
- Okay, yeah, got it.


00:51:55.120 --> 00:51:55.960
That's very cool.


00:51:55.960 --> 00:52:00.960
- And it will also, I don't even know what it does.


00:52:00.960 --> 00:52:03.180
I just use it the whole time and it works.


00:52:03.180 --> 00:52:04.900
You know those things, but you don't need to think about.


00:52:04.900 --> 00:52:05.740
- Yeah, cool.


00:52:05.740 --> 00:52:07.860
So it gives you auto-completion and type checking,


00:52:07.860 --> 00:52:11.220
which is cool for the initializer, right?


00:52:11.220 --> 00:52:13.420
So if you were to try to pass in something wrong,


00:52:13.420 --> 00:52:14.260
it would let you know.


00:52:14.260 --> 00:52:16.380
Also it says it supports refactoring.


00:52:16.380 --> 00:52:19.540
If you refactor the keyword.


00:52:19.540 --> 00:52:20.380
Yeah, go ahead.


00:52:20.380 --> 00:52:21.660
- One of the really useful things it does


00:52:21.660 --> 00:52:24.820
is when we talked about validators,


00:52:24.820 --> 00:52:26.740
which are done by a decorator,


00:52:26.740 --> 00:52:29.420
they are class methods very specifically


00:52:29.420 --> 00:52:31.860
because you might think that they're instance methods


00:52:31.860 --> 00:52:33.860
and you have access to self, you don't,


00:52:33.860 --> 00:52:36.880
'cause they're called before the model itself is initialized.


00:52:36.880 --> 00:52:41.300
So the first argument to them should be class CLS.


00:52:41.300 --> 00:52:44.060
It will automatically give you error if you put self,


00:52:44.060 --> 00:52:45.700
which is really helpful when you're creating


00:52:45.700 --> 00:52:47.820
those validators 'cause otherwise without it,


00:52:47.820 --> 00:52:49.940
PyCharm assumes it's an instance method,


00:52:49.940 --> 00:52:53.080
gives you self and then you get yourself into hot water


00:52:53.080 --> 00:52:56.820
when you access self.userid and it breaks.


00:52:56.820 --> 00:52:57.660
- Oh, interesting.


00:52:57.660 --> 00:52:59.380
Okay, yeah, that makes sense.


00:52:59.380 --> 00:53:02.940
Because it's converting and checking all the values


00:53:02.940 --> 00:53:04.580
and then it creates the object


00:53:04.580 --> 00:53:06.020
and assigns the fields, right?


00:53:06.020 --> 00:53:06.840
Okay.


00:53:06.840 --> 00:53:10.660
- Yeah, so we can access other values during validation


00:53:10.660 --> 00:53:13.160
from the values keyword argument to the validator,


00:53:13.160 --> 00:53:16.840
but not via like self.userid or whatever.


00:53:16.840 --> 00:53:17.680
- Yeah, cool.


00:53:17.680 --> 00:53:21.240
And Risky Chance loves that it works with aliases too.


00:53:21.240 --> 00:53:23.160
- Oh yeah, it does.


00:53:23.160 --> 00:53:24.280
It does lots of cool things.


00:53:24.280 --> 00:53:25.560
I'm really impressed by it.


00:53:25.560 --> 00:53:28.120
Yeah, it's one of the coolest things


00:53:28.120 --> 00:53:30.160
that come out of Pydantic.


00:53:30.160 --> 00:53:31.720
- Awesome, yeah, I've installed it


00:53:31.720 --> 00:53:34.640
and I'm like, I'm sure my Pydantic experience is better,


00:53:34.640 --> 00:53:36.720
but I just don't know what is built in


00:53:36.720 --> 00:53:38.040
and what is coming from this thing.


00:53:38.040 --> 00:53:41.760
- We're also used to PyCharm just working on so many things


00:53:41.760 --> 00:53:42.960
that you don't even notice,


00:53:42.960 --> 00:53:46.200
like, yeah, you only notice when it doesn't work, so.


00:53:46.200 --> 00:53:47.320
- Yeah, absolutely.


00:53:47.320 --> 00:53:49.840
So we're getting a little short on time,


00:53:49.840 --> 00:53:53.360
but I did want to ask you about Python DevTools,


00:53:53.360 --> 00:53:58.080
'cause you talked about having Pydantic work well


00:53:58.080 --> 00:54:01.040
with the DevTools as well.


00:54:01.040 --> 00:54:01.880
- Yes.


00:54:01.880 --> 00:54:03.520
- What are these?


00:54:03.520 --> 00:54:05.840
You're also the author of Python DevTools, yeah?


00:54:05.840 --> 00:54:08.040
- Yeah, so DevTools is, for me,


00:54:08.040 --> 00:54:11.000
it's just a debug print command that prints stuff pretty


00:54:11.000 --> 00:54:14.520
and gives it color and tells me what line it was printed on.


00:54:14.520 --> 00:54:16.200
And I use it the whole time in development


00:54:16.200 --> 00:54:17.360
instead of print.


00:54:17.360 --> 00:54:19.920
And obviously I wanted it to show me my


00:54:19.920 --> 00:54:23.520
Pydantic models in a pretty way.


00:54:23.520 --> 00:54:24.520
So it has integration.


00:54:24.520 --> 00:54:26.520
There were some hooks in DevTools


00:54:26.520 --> 00:54:29.480
that allow it to customize the way stuff's printed.


00:54:29.480 --> 00:54:31.960
And I actually know that the author of Rich,


00:54:31.960 --> 00:54:35.200
he's slightly frustratingly has used


00:54:35.200 --> 00:54:36.520
a different system all over again,


00:54:36.520 --> 00:54:37.880
but he's also supported Pydantic.


00:54:37.880 --> 00:54:40.980
So Pydantic will also print pretty with Rich


00:54:40.980 --> 00:54:42.560
as well as with DevTools.


00:54:42.560 --> 00:54:43.400
- Yeah, cool.


00:54:43.400 --> 00:54:44.240
Okay, really nice.


00:54:44.240 --> 00:54:48.600
Rich is a great TUI, Terminal User Interface


00:54:48.600 --> 00:54:51.400
library for Python.


00:54:51.400 --> 00:54:52.240
- Yeah, it's cool.


00:54:52.240 --> 00:54:53.560
It's different from DevTools.


00:54:53.560 --> 00:54:54.600
I wouldn't say they compete.


00:54:54.600 --> 00:54:55.960
DevTools is, for me, it's just,


00:54:55.960 --> 00:54:57.440
it does have some other things,


00:54:57.440 --> 00:54:59.200
some timing tools and some formatting,


00:54:59.200 --> 00:55:01.760
but for me, it's just the debug print command


00:55:01.760 --> 00:55:03.160
that Python never had.


00:55:03.160 --> 00:55:08.880
- So what's the Pydantic plugin here,


00:55:08.880 --> 00:55:10.600
or connection, rather, here?


00:55:10.600 --> 00:55:14.340
So if I debug out of DevTools a model,


00:55:14.340 --> 00:55:16.340
I get just a really nice representation?


00:55:16.340 --> 00:55:18.880
Yeah, exactly that.


00:55:18.880 --> 00:55:20.880
It's not showing it,


00:55:20.880 --> 00:55:22.880
it's because you're in the DevTools docs,


00:55:22.880 --> 00:55:24.880
there's some other docs in Atlantic,


00:55:24.880 --> 00:55:26.880
I'll give you an example.


00:55:26.880 --> 00:55:28.880
It'll give you a nice example if it expanded out


00:55:28.880 --> 00:55:30.880
rather than squashed into one line.


00:55:30.880 --> 00:55:32.880
So usage with DevTools is the last line.


00:55:32.880 --> 00:55:34.880
Got it.


00:55:34.880 --> 00:55:36.880
Yeah, so you see that, you see the user


00:55:36.880 --> 00:55:38.880
picked out nicely instead of, yeah,


00:55:38.880 --> 00:55:40.960
done like that.


00:55:40.960 --> 00:55:46.820
Yeah, I suppose that demonstrates its usage for me.


00:55:46.820 --> 00:55:50.200
- Yeah, perfect, that looks really good.


00:55:50.200 --> 00:55:54.520
It's nice to be able to just print out


00:55:54.520 --> 00:55:57.240
these sorts of things and see them really quickly.


00:55:57.240 --> 00:55:59.800
What's the just basic string representation


00:55:59.800 --> 00:56:00.800
of a Pydantic model?


00:56:00.800 --> 00:56:04.040
Like for example, if I'm in PyCharm and I hit a breakpoint,


00:56:04.040 --> 00:56:06.640
or I'm just curious what something is and I just print it,


00:56:06.640 --> 00:56:09.760
Like PyCharm will like put a little grayed out


00:56:09.760 --> 00:56:12.680
string and stir representation.


00:56:12.680 --> 00:56:13.520
- It's right there.


00:56:13.520 --> 00:56:14.800
I think that's the string representation


00:56:14.800 --> 00:56:16.440
you're looking at right there.


00:56:16.440 --> 00:56:17.260
- Yeah, perfect.


00:56:17.260 --> 00:56:19.320
So you get a really rich sort of view of it


00:56:19.320 --> 00:56:22.200
embedded in the editor or if you print it.


00:56:22.200 --> 00:56:23.200
- And if you use Repra,


00:56:23.200 --> 00:56:25.980
then you get basically wrapped in user.


00:56:25.980 --> 00:56:27.960
- All right, okay.


00:56:27.960 --> 00:56:30.080
So it gives you as if it were.


00:56:30.080 --> 00:56:30.920
- Yeah.


00:56:30.920 --> 00:56:33.320
- You're trying to construct it out of that data.


00:56:33.320 --> 00:56:34.460
- Yeah.


00:56:34.460 --> 00:56:35.300
- Okay.


00:56:36.200 --> 00:56:39.380
- Fantastic, well, you know, we've covered a bunch of things


00:56:39.380 --> 00:56:41.540
and I know there's a lot more.


00:56:41.540 --> 00:56:45.600
I don't recall whether we talked about this


00:56:45.600 --> 00:56:48.060
while we were recording or whether we talked about it before


00:56:48.060 --> 00:56:50.180
and we were just setting up what we wanted to talk about,


00:56:50.180 --> 00:56:52.740
but it's worth emphasizing that this is not just


00:56:52.740 --> 00:56:55.660
a FastAPI validation data exchange thing.


00:56:55.660 --> 00:56:56.980
It works really great.


00:56:56.980 --> 00:56:59.660
A lot of the stuff happens there, but if you're using Flask,


00:56:59.660 --> 00:57:02.460
if you're using Pyramid, if you're using,


00:57:02.460 --> 00:57:04.580
I don't know about Django so much


00:57:04.580 --> 00:57:05.420
because the models is not there.


00:57:05.420 --> 00:57:09.900
One of the things we haven't talked about as well is settings management, which


00:57:09.900 --> 00:57:16.620
uh pedantic has some pretty powerful features for and actually one of the things was added in 1.7 or 1.8 was like


00:57:16.620 --> 00:57:19.980
Basically a system for plugins to do even crazier stuff with settings


00:57:19.980 --> 00:57:26.380
So not just you loading them from environment variables and from dot m files, but also from docker secrets


00:57:26.380 --> 00:57:32.860
Now we have an interface to load them from kind of anywhere so you can build your own interface for for loading settings from from places


00:57:32.940 --> 00:57:37.940
but someone's built a Django settings tool with Pydantic


00:57:37.940 --> 00:57:41.140
to kind of validate your Django settings using Pydantic.


00:57:41.140 --> 00:57:43.660
But yeah, I think what's cool about Pydantic


00:57:43.660 --> 00:57:46.860
is it's not part of a kind of walled garden


00:57:46.860 --> 00:57:48.220
of tools that all fit together.


00:57:48.220 --> 00:57:50.260
Well, that have to be used with each other.


00:57:50.260 --> 00:57:51.460
It fits with Pydantic,


00:57:51.460 --> 00:57:53.780
but it's used in lots of other big projects,


00:57:53.780 --> 00:57:56.820
or you can just use it in Flask or in Django


00:57:56.820 --> 00:57:58.580
or wherever you like.


00:57:58.580 --> 00:58:01.780
- Right, if you're reading JSON files off a disk,


00:58:01.780 --> 00:58:03.380
it could totally make sense to use it,


00:58:03.380 --> 00:58:04.860
or you're doing screen scraping,


00:58:04.860 --> 00:58:08.300
potentially it makes, or just call API,


00:58:08.300 --> 00:58:09.900
but you're the client of that API,


00:58:09.900 --> 00:58:11.780
it could totally make sense to do that.


00:58:11.780 --> 00:58:12.620
- Yeah.


00:58:12.620 --> 00:58:14.140
- Yeah, so just want to point out,


00:58:14.140 --> 00:58:15.980
like it's super broadly applicable,


00:58:15.980 --> 00:58:19.740
not just where people see it being really used.


00:58:19.740 --> 00:58:22.820
And Nick H out there is definitely gonna try this


00:58:22.820 --> 00:58:24.220
with Django, so awesome.


00:58:24.220 --> 00:58:26.980
- That's cool.


00:58:26.980 --> 00:58:28.740
- Yeah, so let's wrap this up with just,


00:58:28.740 --> 00:58:33.620
And then we spoke a little bit about V2 and the timing.


00:58:33.620 --> 00:58:36.660
Like what are the major features that you think,


00:58:36.660 --> 00:58:37.580
like what are the highlights


00:58:37.580 --> 00:58:38.780
that people should look forward to?


00:58:38.780 --> 00:58:39.940
- We talked about major features,


00:58:39.940 --> 00:58:41.880
but there's a bigger problem at hand,


00:58:41.880 --> 00:58:45.940
which is that Python 3.10 at the moment in PEP,


00:58:45.940 --> 00:58:48.540
I'm gonna try and remind myself of the exact number,


00:58:48.540 --> 00:58:53.540
but like in PEP 6.9, no in 5.6.3,


00:58:53.540 --> 00:58:58.180
basically all type hints become strings


00:58:58.180 --> 00:58:59.340
instead of Python objects.


00:58:59.340 --> 00:59:02.540
And so, and like that's been available in future,


00:59:02.540 --> 00:59:03.380
as a future--


00:59:03.380 --> 00:59:06.740
- Right, is that a lazy evaluation of the annotation?


00:59:06.740 --> 00:59:09.220
- It's not even a lazy evaluation, it's a non-evaluation.


00:59:09.220 --> 00:59:11.700
And it seems like unless Python themselves,


00:59:11.700 --> 00:59:13.660
the core team are prepared to move on this


00:59:13.660 --> 00:59:15.820
and like be practical about things,


00:59:15.820 --> 00:59:20.340
it might be that Pydantic becomes either like hard to use


00:59:20.340 --> 00:59:22.060
or even not useful in 3.10.


00:59:22.060 --> 00:59:23.180
It sounds like--


00:59:23.180 --> 00:59:24.020
- Really?


00:59:24.020 --> 00:59:26.980
- Like there, I'm talking at the Python Summit


00:59:26.980 --> 00:59:31.980
in PyCon US in May in the language,


00:59:31.980 --> 00:59:33.260
in the bit where people discuss it,


00:59:33.260 --> 00:59:34.980
I'm gonna try and put this forward.


00:59:34.980 --> 00:59:37.140
But I had a conversation today,


00:59:37.140 --> 00:59:39.740
just before I came online now


00:59:39.740 --> 00:59:42.260
with someone who's created a pet that should fix this,


00:59:42.260 --> 00:59:44.660
but the current response from the core developers


00:59:44.660 --> 00:59:45.680
is to refuse it.


00:59:45.680 --> 00:59:49.420
So I'm really worried and frustrated that that might happen


00:59:49.420 --> 00:59:52.860
and lots of tools, FastAPI, Pydantic, Typer, and others,


00:59:52.860 --> 00:59:56.820
again, they get broken for the sake of principle effectively


00:59:56.820 --> 01:00:01.740
that type int should only be used for static type analysis.


01:00:01.740 --> 01:00:02.580
So we'll see what happens.


01:00:02.580 --> 01:00:05.000
And normally with open source, people find a way around,


01:00:05.000 --> 01:00:06.700
but I think that's really worrying.


01:00:06.700 --> 01:00:10.420
And I'll create an issue on Pydantic to track this properly,


01:00:10.420 --> 01:00:13.020
but it is something to be aware of.


01:00:13.020 --> 01:00:16.260
And it's something that I think those of us


01:00:16.260 --> 01:00:17.980
who use these libraries need to...


01:00:17.980 --> 01:00:21.300
It's very easy to wait until after something's released


01:00:21.300 --> 01:00:22.920
and then be frustrated.


01:00:22.920 --> 01:00:26.140
It's important sometimes to notice before they're released


01:00:26.140 --> 01:00:27.580
and make a point.


01:00:27.580 --> 01:00:29.140
- Wow, well, I'm really glad you pointed that out.


01:00:29.140 --> 01:00:30.100
I had no idea.


01:00:30.100 --> 01:00:32.540
I knew there was minor behind the scene changes


01:00:32.540 --> 01:00:36.220
from a consumer perspective of type annotations,


01:00:36.220 --> 01:00:39.460
but that sounds like there's more going on


01:00:39.460 --> 01:00:41.380
for libraries like this.


01:00:41.380 --> 01:00:44.820
- So there's a PR, there's a PEP that will fix this,


01:00:44.820 --> 01:00:49.420
which is PEP 649, which I have not yet read


01:00:49.420 --> 01:00:52.900
because I only got the email about it two hours ago.


01:00:52.900 --> 01:00:54.900
But if anyone's looking into it,


01:00:54.900 --> 01:00:58.060
I will create an issue on Pydantic to talk about this,


01:00:58.060 --> 01:01:01.260
but something like this needs to happen.


01:01:01.260 --> 01:01:03.940
Also, Larry emailed me an hour or two hours ago


01:01:03.940 --> 01:01:06.540
to talk about this, but this is a really big problem


01:01:06.540 --> 01:01:11.540
that we need to prevent breaking lots of cool stuff


01:01:11.540 --> 01:01:12.900
that's happening in Python.


01:01:12.900 --> 01:01:16.220
- All right, well, I agree.


01:01:16.220 --> 01:01:18.620
First impressions is I absolutely agree,


01:01:18.620 --> 01:01:21.500
'cause I do think what you guys are doing,


01:01:21.500 --> 01:01:22.940
what you're doing with Pydantic,


01:01:22.940 --> 01:01:24.580
what is happening with FastAPI,


01:01:24.580 --> 01:01:28.580
And these types of systems, it's a really fantastic direction


01:01:28.580 --> 01:01:33.500
and really building on top of the type annotation world.


01:01:33.500 --> 01:01:35.920
And I would hate to see that get squashed.


01:01:35.920 --> 01:01:37.580
What's incredible about it, just briefly,


01:01:37.580 --> 01:01:40.880
is that it's used by Microsoft in core bits of Office.


01:01:40.880 --> 01:01:44.920
It's used by Uber, by the NSA, by banks.


01:01:44.920 --> 01:01:47.100
It's used by JP Morgan.


01:01:47.100 --> 01:01:49.880
But it's also really easy to get started with at the very beginning.


01:01:49.880 --> 01:01:53.680
And it's wonderful for me that we can build open source code


01:01:53.680 --> 01:01:57.020
that can be useful to the biggest organizations in the world


01:01:57.020 --> 01:01:59.020
and to someone when they're first getting started,


01:01:59.020 --> 01:02:02.980
not this idea that it has to be dense and mainframe and impossible


01:02:02.980 --> 01:02:05.520
or like Mickey Mouse and not worth using.


01:02:05.520 --> 01:02:09.860
Like, FastAPI and Pydantic seem to be managing to be both.


01:02:09.860 --> 01:02:12.400
I agree. I think they are, absolutely.


01:02:12.400 --> 01:02:15.780
Well, congratulations on building something amazing.


01:02:15.780 --> 01:02:18.360
-Thank you very much, Michael. -And hopefully,


01:02:18.360 --> 01:02:21.160
649 keeps things rolling smooth.


01:02:21.160 --> 01:02:25.360
but hopefully that gets ironed out.


01:02:25.360 --> 01:02:27.040
All right, now we're pretty much out of time,


01:02:27.040 --> 01:02:27.960
but before I let you out of here,


01:02:27.960 --> 01:02:29.960
let me ask the final two questions.


01:02:29.960 --> 01:02:31.320
So if you're gonna write some code,


01:02:31.320 --> 01:02:34.880
if you're gonna work on Pydantic, what editor do you use?


01:02:34.880 --> 01:02:36.160
- I use PyCharm.


01:02:36.160 --> 01:02:40.640
- Right on, and the Pydantic plugin, I'm guessing?


01:02:40.640 --> 01:02:42.880
- And the Pydantic plugin, yeah.


01:02:42.880 --> 01:02:47.880
- Right on, and then if you've got a package out on PyPI


01:02:47.880 --> 01:02:50.220
that you think is interesting,


01:02:50.220 --> 01:02:51.660
maybe not the most popular, but you're like,


01:02:51.660 --> 01:02:53.260
"Oh, I ran across this thing that's amazing.


01:02:53.260 --> 01:02:54.860
You should know about it."


01:02:54.860 --> 01:02:57.140
- I should probably not break the rule


01:02:57.140 --> 01:02:59.180
and talk about my own, but like DevTools,


01:02:59.180 --> 01:03:01.140
which I talked about, is incredibly useful to me.


01:03:01.140 --> 01:03:04.380
And so I would spread the word a bit on that.


01:03:04.380 --> 01:03:05.880
Other than that, I just do a shout out


01:03:05.880 --> 01:03:07.900
to all of those packages that people don't see


01:03:07.900 --> 01:03:09.100
that are the bedrock of everything.


01:03:09.100 --> 01:03:12.140
So from coverage to Starlet, which is the other library


01:03:12.140 --> 01:03:14.020
that's the basis of FastAPI.


01:03:14.020 --> 01:03:15.860
Sebastian's great, and I mean no offense to him,


01:03:15.860 --> 01:03:17.900
but he stands on the shoulders of people


01:03:17.900 --> 01:03:19.460
who've done lots of other things,


01:03:19.460 --> 01:03:20.820
and they're really, really powerful.


01:03:20.820 --> 01:03:22.940
So I would spare a bit of time for them.


01:03:22.940 --> 01:03:24.740
If you're thinking of sponsoring someone,


01:03:24.740 --> 01:03:27.380
think about sponsoring Ned who does coverage


01:03:27.380 --> 01:03:30.980
or any of those other bits of pytest,


01:03:30.980 --> 01:03:34.060
all the workhorses that aren't particularly headline


01:03:34.060 --> 01:03:35.140
but are really, really valuable


01:03:35.140 --> 01:03:38.460
to all of our daily life writing code.


01:03:38.460 --> 01:03:42.740
- Yeah, and I'm gonna go with Vlad out there.


01:03:42.740 --> 01:03:45.220
He says, "Many of us know about PyData


01:03:45.220 --> 01:03:46.300
because of FastAPI."


01:03:46.300 --> 01:03:48.820
I agree, but FastAPI, as you pointed out,


01:03:48.820 --> 01:03:52.680
absolutely stands on top of Starlet,


01:03:52.680 --> 01:03:55.980
which there's just this whole chain of things


01:03:55.980 --> 01:03:58.200
that each one adds their own special sauce,


01:03:58.200 --> 01:04:00.240
but they're there because of--


01:04:00.240 --> 01:04:02.080
- But I should say again, FastAPI is awesome.


01:04:02.080 --> 01:04:03.160
I didn't use it initially.


01:04:03.160 --> 01:04:07.240
I'm a contributor to aiohttp, which is also really cool,


01:04:07.240 --> 01:04:09.000
but I've, over the last year,


01:04:09.000 --> 01:04:11.160
become a complete convert to FastAPI.


01:04:11.160 --> 01:04:14.360
I use it, it's my go-to tool now, so it's awesome.


01:04:14.360 --> 01:04:15.920
- Yeah, fantastic.


01:04:15.920 --> 01:04:18.720
All right, final call to action.


01:04:18.720 --> 01:04:20.840
people wanna check out PyDandic,


01:04:20.840 --> 01:04:22.520
maybe they wanna contribute to PyDandic,


01:04:22.520 --> 01:04:24.080
what do you tell them?


01:04:24.080 --> 01:04:26.760
- Just go and have a read through the docs


01:04:26.760 --> 01:04:28.800
and yeah, go from there.


01:04:28.800 --> 01:04:30.520
If you can make a tweak to the docs


01:04:30.520 --> 01:04:31.720
to make it easier to read,


01:04:31.720 --> 01:04:33.400
if you can answer someone's question


01:04:33.400 --> 01:04:36.680
or even create a feature, that's awesome.


01:04:36.680 --> 01:04:38.080
- Cool, all right.


01:04:38.080 --> 01:04:39.680
- And if I'm not there immediately


01:04:39.680 --> 01:04:41.360
and I don't reply for weeks, I'm sorry,


01:04:41.360 --> 01:04:43.080
and I promise to as soon as I can.


01:04:43.080 --> 01:04:46.400
- Fantastic, all right, Samuel, thanks for being on the show.


01:04:46.400 --> 01:04:49.080
It's been great to learn more and deep information


01:04:49.080 --> 01:04:51.160
about PyDandic 'cause it's so simple to use it.


01:04:51.160 --> 01:04:53.560
It's easy to just skim the surface.


01:04:53.560 --> 01:04:55.360
- Awesome, Michael, thank you very much.


01:04:55.360 --> 01:04:56.960
- Yeah, you bet, bye-bye.


01:04:56.960 --> 01:04:57.800
- Yes, bye.


01:04:57.800 --> 01:05:00.060
- Thanks everyone on the live stream.


01:05:00.060 --> 01:05:00.960
See you next time.


01:05:00.960 --> 01:05:10.960
[BLANK_AUDIO]

