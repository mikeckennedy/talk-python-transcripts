WEBVTT

00:00:00.000 --> 00:00:03.120
Hey YouTube, hey Jason.


00:00:03.120 --> 00:00:05.400
Hey, hi Michael.


00:00:05.400 --> 00:00:06.720
Hi, hi Jason's dog.


00:00:06.720 --> 00:00:08.080
What's your dog's name back there?


00:00:08.080 --> 00:00:10.600
That is Monsier Bleu.


00:00:10.600 --> 00:00:12.840
Monsier Bleu, ah, beautiful.


00:00:12.840 --> 00:00:14.120
Just hanging out, I love it.


00:00:14.120 --> 00:00:15.080
Yeah, he's a good boy.


00:00:15.080 --> 00:00:15.920
He's my co-worker.


00:00:15.920 --> 00:00:18.240
He's actually wearing a bow tie too.


00:00:18.240 --> 00:00:19.400
Fantastic, yeah.


00:00:19.400 --> 00:00:22.680
I have my dog, Rocket, who likes to hang out


00:00:22.680 --> 00:00:25.640
and be part of the podcast and other live streams


00:00:25.640 --> 00:00:26.400
periodically.


00:00:26.400 --> 00:00:27.800
And sometimes chew up random things


00:00:27.800 --> 00:00:29.360
in the background when I'm not paying attention


00:00:29.360 --> 00:00:31.860
that she shouldn't, but it's all good.


00:00:31.860 --> 00:00:32.800
Dogs are great.


00:00:32.800 --> 00:00:35.300
So welcome to the show.


00:00:35.300 --> 00:00:36.540
Everyone out there watching the live stream,


00:00:36.540 --> 00:00:38.900
please put your thoughts and comments in chat.


00:00:38.900 --> 00:00:41.140
I can already see Diego's put some in there


00:00:41.140 --> 00:00:42.660
and we'll try to make them part of the show


00:00:42.660 --> 00:00:46.440
when they find a place to fit them in in the topic.


00:00:46.440 --> 00:00:48.580
And with that, Jason, you ready?


00:00:48.580 --> 00:00:50.060
- Yeah, let's do this.


00:00:50.060 --> 00:00:51.040
- Yeah, for sure.


00:00:51.040 --> 00:00:54.580
Jason, welcome to Talk Python to Me.


00:00:54.580 --> 00:00:57.620
- Thank you for having me.


00:00:57.620 --> 00:01:00.100
- Yeah, it's great to have you here on the show.


00:01:00.100 --> 00:01:02.840
I'm looking forward to talking about a bunch of things


00:01:02.840 --> 00:01:07.420
I wish people taught you about Python sooner.


00:01:07.420 --> 00:01:09.600
I think there are many, many things


00:01:09.600 --> 00:01:11.000
that fall into that category.


00:01:11.000 --> 00:01:14.020
And part of that, I guess it's true with all languages,


00:01:14.020 --> 00:01:16.820
but I think it's maybe a little extra true in Python


00:01:16.820 --> 00:01:19.580
because getting started is so easy,


00:01:19.580 --> 00:01:20.820
but getting really good at it


00:01:20.820 --> 00:01:23.740
takes a lifetime sort of thing, you know?


00:01:23.740 --> 00:01:25.400
And so there's like this big mismatch


00:01:25.400 --> 00:01:29.960
of how accessible it feels, but then what you can get out of it


00:01:29.960 --> 00:01:30.840
if you go further.


00:01:30.840 --> 00:01:34.040
So I think that we'll touch on that going further apart maybe.


00:01:34.040 --> 00:01:35.800
Absolutely.


00:01:35.800 --> 00:01:37.040
Yeah, for sure.


00:01:37.040 --> 00:01:39.720
Now, before we get into all those things,


00:01:39.720 --> 00:01:41.040
let's start with your story.


00:01:41.040 --> 00:01:43.800
How did you get into programming in Python?


00:01:43.800 --> 00:01:45.880
Well, I got into programming by a route


00:01:45.880 --> 00:01:47.440
that I don't recommend to anybody.


00:01:47.440 --> 00:01:49.960
I fell down a staircase, hit my head on the banister,


00:01:49.960 --> 00:01:53.600
and ended all hopes of ever becoming a doctor.


00:01:53.600 --> 00:01:54.880
Oh.


00:01:54.880 --> 00:01:59.520
So went from 4.0, straight A student,


00:01:59.520 --> 00:02:01.040
college level reading in high school,


00:02:01.040 --> 00:02:02.360
to failing in pre-K material.


00:02:02.360 --> 00:02:04.760
Took me two extra years to climb back up


00:02:04.760 --> 00:02:06.960
where I was academically a bit longer


00:02:06.960 --> 00:02:08.400
after that for other things.


00:02:08.400 --> 00:02:10.880
But somewhere along the way,


00:02:10.880 --> 00:02:13.560
I discovered that I had a natural inclination


00:02:13.560 --> 00:02:14.880
towards an enact for coding.


00:02:14.880 --> 00:02:19.880
And got into that because I wanted to make games.


00:02:19.880 --> 00:02:22.760
I wanted to make educational games.


00:02:22.760 --> 00:02:23.880
They had been part of my recovery.


00:02:23.880 --> 00:02:25.380
I want to make games.


00:02:25.380 --> 00:02:26.720
So I learned how to code.


00:02:26.720 --> 00:02:29.820
And so I taught myself VB.net


00:02:29.820 --> 00:02:33.420
and then felt very constrained by the .net ecosystem


00:02:33.420 --> 00:02:35.820
and broke out into Python.


00:02:35.820 --> 00:02:39.260
And found my home, stayed put until I,


00:02:39.260 --> 00:02:41.720
well, wound up going to a bunch of other languages.


00:02:41.720 --> 00:02:45.900
I used Flash for quite some time, I used C++.


00:02:45.900 --> 00:02:47.500
I muck about in whatever's handy,


00:02:47.500 --> 00:02:51.200
but Python is definitely near to dear to my heart.


00:02:51.200 --> 00:02:53.200
- Yeah, absolutely.


00:02:53.200 --> 00:02:56.000
Well, if you started out in VB.net,


00:02:56.000 --> 00:02:57.600
I think it's a little less true these days,


00:02:57.600 --> 00:02:59.280
but in the earlier days,


00:02:59.280 --> 00:03:02.680
that was a really different ecosystem than Python, right?


00:03:02.680 --> 00:03:04.640
There was like, well, what is the framework


00:03:04.640 --> 00:03:06.680
for this thing that Microsoft recommends?


00:03:06.680 --> 00:03:07.800
Like, how do I do the web?


00:03:07.800 --> 00:03:09.800
I do ASP.net, 'cause that's what they provide me.


00:03:09.800 --> 00:03:10.720
How do I do database?


00:03:10.720 --> 00:03:12.920
I do this because that's what they provide me.


00:03:12.920 --> 00:03:14.360
And you come into Python, you're like,


00:03:14.360 --> 00:03:16.240
wait, there's a thousand different ways to do this.


00:03:16.240 --> 00:03:18.880
And I have to pick and decide, and I can mix and match.


00:03:18.880 --> 00:03:21.480
And it gets both amazing and like, I don't know.


00:03:21.480 --> 00:03:22.320
- Terrifying.


00:03:22.320 --> 00:03:25.360
yeah, it's terrible, like, what if I make the wrong choice?


00:03:25.360 --> 00:03:26.280
How do I decide?


00:03:26.280 --> 00:03:27.560
I have no basis, right?


00:03:27.560 --> 00:03:29.800
I'm both new, so I have no basis for deciding,


00:03:29.800 --> 00:03:32.200
but I also, I've got to decide to get started,


00:03:32.200 --> 00:03:33.160
so where do we go, right?


00:03:33.160 --> 00:03:34.680
Like, it's a different world.


00:03:34.680 --> 00:03:35.520
- It is.


00:03:35.520 --> 00:03:37.600
It definitely is.


00:03:37.600 --> 00:03:42.600
And I think where I first started running into trouble


00:03:42.600 --> 00:03:46.880
with the paradox that I wound up addressing in my book,


00:03:46.880 --> 00:03:47.720
we'll come back to that,


00:03:47.720 --> 00:03:50.040
but the paradox that a lot of people find themselves in


00:03:50.040 --> 00:03:54.060
like, I know all this stuff, but I don't know enough to do this


00:03:54.060 --> 00:03:57.480
thing. And so you wind up with this weird little gap in a lot


00:03:57.480 --> 00:03:59.780
of training material, because you have like the absolute basic


00:03:59.780 --> 00:04:02.340
elementary and the examples there are almost insultingly


00:04:02.340 --> 00:04:05.280
simplistic. It's like, oh, you just have to type this stuff


00:04:05.280 --> 00:04:09.000
into into into this file and run the file and look at that you


00:04:09.000 --> 00:04:11.980
have a hello world. Aren't you smart. And then you go all the


00:04:11.980 --> 00:04:13.820
way to the other extreme and it's something like super


00:04:13.820 --> 00:04:16.680
complicated. You don't understand any of it. And nobody


00:04:16.680 --> 00:04:19.860
sat and read wrote down here's how you structure a multi Python


00:04:19.860 --> 00:04:22.520
project in a way that's gonna at least when I started, that


00:04:22.520 --> 00:04:25.340
wasn't documented anywhere, like no one had ever written it down.


00:04:25.340 --> 00:04:28.380
So it's just like, what do I do now?


00:04:28.380 --> 00:04:32.260
Yeah, it's really tricky. A lot of the tutorials and stuff are


00:04:32.260 --> 00:04:35.860
like, you just put all this stuff into one file. And then


00:04:35.860 --> 00:04:39.420
it's magic. And you should never ever do that. Well, maybe in


00:04:39.420 --> 00:04:43.460
simple cases, but yeah, super in realistic apps, like, no


00:04:43.460 --> 00:04:46.260
realistic app belongs in one file, like, just like you


00:04:46.260 --> 00:04:48.420
wouldn't have one function or just like no functions, right?


00:04:48.420 --> 00:04:50.460
You're like, not really.


00:04:50.460 --> 00:04:52.620
That's not how you do it.


00:04:52.620 --> 00:04:54.140
So there is this--


00:04:54.140 --> 00:04:56.420
even when you're sort of hunting through tutorials,


00:04:56.420 --> 00:04:59.820
there is this mismatch of the simple way to show it,


00:04:59.820 --> 00:05:04.340
the simplest way to show it, and then maybe how you should.


00:05:04.340 --> 00:05:05.020
Yeah.


00:05:05.020 --> 00:05:06.620
Oh, yeah, exactly.


00:05:06.620 --> 00:05:10.700
The example I've given is that there's two types of book/article/tutorial


00:05:10.700 --> 00:05:12.500
out there.


00:05:12.500 --> 00:05:14.820
Here's basics of variables, boys and girls.


00:05:14.820 --> 00:05:17.380
And then the next level after that is,


00:05:17.380 --> 00:05:21.100
here's how to program a natural language recognition OCR AI


00:05:21.100 --> 00:05:22.500
machine learning on a Raspberry Pi


00:05:22.500 --> 00:05:25.020
and your grandmother's base are running on a potato battery.


00:05:25.020 --> 00:05:27.420
And there's nothing in between.


00:05:27.420 --> 00:05:28.260
- Yeah.


00:05:28.260 --> 00:05:30.380
Yeah, that's true.


00:05:30.380 --> 00:05:32.020
It does make it quite challenging.


00:05:32.020 --> 00:05:34.000
All right.


00:05:34.000 --> 00:05:34.840
How about now?


00:05:34.840 --> 00:05:36.300
What are you up to?


00:05:36.300 --> 00:05:37.940
- These days, oh gosh.


00:05:37.940 --> 00:05:41.340
I'm actually kind of veering these days more into,


00:05:41.340 --> 00:05:44.660
actually more into kind of the facilitation business


00:05:44.660 --> 00:05:46.700
analyst side of things more.


00:05:46.700 --> 00:05:48.700
Interestingly, in the last couple of years,


00:05:48.700 --> 00:05:52.020
that's become a point of particular interest.


00:05:52.020 --> 00:05:54.180
But in terms of coding, I'm working


00:05:54.180 --> 00:05:56.260
on some interesting projects at work,


00:05:56.260 --> 00:05:58.980
building an API for an internal project.


00:05:58.980 --> 00:06:03.140
And that's been fun getting to get my hands dirty


00:06:03.140 --> 00:06:05.460
with FastAPI and SQLAlchemy.


00:06:05.460 --> 00:06:10.100
And that's been fairly enjoyable.


00:06:10.100 --> 00:06:12.860
So that's been the majority of my programming bandwidth


00:06:12.860 --> 00:06:13.380
lately.


00:06:13.380 --> 00:06:15.740
But it's fun.


00:06:15.740 --> 00:06:18.020
it's the sort of project you hope you're going to get at work


00:06:18.020 --> 00:06:20.220
because it's an interesting topic,


00:06:20.220 --> 00:06:25.340
you have enough love--


00:06:25.340 --> 00:06:29.460
leeway, that's the word I'm looking for, enough leeway to do things right


00:06:29.460 --> 00:06:33.620
and do things to some degree your way if you can justify it well enough.


00:06:33.620 --> 00:06:36.820
I'm a tech lead on it, so I'm able to make sure


00:06:36.820 --> 00:06:39.980
we're making good decisions early and paying down technical debt


00:06:39.980 --> 00:06:41.900
and building something that's really, really cool.


00:06:41.900 --> 00:06:44.780
So it's a fun project I'm enjoying.


00:06:44.780 --> 00:06:48.940
- Yeah, those kinds of projects, they're fun,


00:06:48.940 --> 00:06:51.180
but they're also important, right?


00:06:51.180 --> 00:06:54.220
Like if your work, if you work,


00:06:54.220 --> 00:06:56.020
let me put it this way, if you work at a place


00:06:56.020 --> 00:06:57.500
where they say, you know, you need to use


00:06:57.500 --> 00:07:00.000
10 year old technology and there's no opportunity


00:07:00.000 --> 00:07:04.160
to try new things like FastAPI and others,


00:07:04.160 --> 00:07:07.020
what you end up with is a whole bunch of people


00:07:07.020 --> 00:07:09.400
who that work there who don't wanna learn


00:07:09.400 --> 00:07:12.400
any new technologies and are not deeply passionate


00:07:12.400 --> 00:07:13.920
about programming and it's kind of


00:07:13.920 --> 00:07:16.160
the self-fulfilling prophecy.


00:07:16.160 --> 00:07:18.280
And I think, you know, it's cool that the place


00:07:18.280 --> 00:07:20.960
you're working at allows that, right?


00:07:20.960 --> 00:07:25.020
Because I think it's one of the signs of a healthy tech,


00:07:25.020 --> 00:07:28.600
not necessarily a startup or whatever,


00:07:28.600 --> 00:07:31.080
but all these companies have like small software teams


00:07:31.080 --> 00:07:34.200
within it, it's a sign of a healthy small software team,


00:07:34.200 --> 00:07:36.280
even if it's just building internal software.


00:07:36.280 --> 00:07:37.120
- Oh, definitely, yeah.


00:07:37.120 --> 00:07:39.080
And you know, and there's a place for older technology


00:07:39.080 --> 00:07:42.500
well it's good to be well-versed in both and be able to move between it but I


00:07:42.500 --> 00:07:47.500
mean yeah if you're if you're just stuck in the past then you either like you


00:07:47.500 --> 00:07:51.200
said get a lot of people that are afraid of change or are really wanting that


00:07:51.200 --> 00:07:54.200
change and they're dissatisfied of the fact they can't get it but on the other


00:07:54.200 --> 00:07:57.080
hand if you just if you're only new technology you'll just spontaneously


00:07:57.080 --> 00:08:03.680
combust because you can't you know there's just there's so much constant


00:08:03.680 --> 00:08:07.680
invention and reinvention and research and unexpected bugs and blockers and


00:08:07.680 --> 00:08:09.040
and whatever, it's like, sometimes the nice thing


00:08:09.040 --> 00:08:11.520
about a 10 year old library is that there's less bugs


00:08:11.520 --> 00:08:13.600
because it's 10 years old.


00:08:13.600 --> 00:08:16.600
- You can find documentation about issues or whatever.


00:08:16.600 --> 00:08:19.300
You know, they have a term, it's like a term


00:08:19.300 --> 00:08:22.320
in the software industry about this constant churn


00:08:22.320 --> 00:08:24.400
that's like going too quick,


00:08:24.400 --> 00:08:26.760
and especially not appreciating stuff that's been around,


00:08:26.760 --> 00:08:27.960
it's called JavaScript.


00:08:27.960 --> 00:08:30.520
(laughing)


00:08:30.520 --> 00:08:33.000
- You're not wrong, JavaScript is the embodiment


00:08:33.000 --> 00:08:34.640
of shiny object syndrome.


00:08:34.640 --> 00:08:37.240
- It is, I'm not bashing on JavaScript per se,


00:08:37.240 --> 00:08:40.440
but the life cycle of some of these frameworks


00:08:40.440 --> 00:08:43.000
is just so brief, it's nuts.


00:08:43.000 --> 00:08:45.840
- Everybody wanted to use Deno for about 10 minutes,


00:08:45.840 --> 00:08:46.680
I remember that.


00:08:46.680 --> 00:08:49.080
There was a thousand articles a minute on Deno


00:08:49.080 --> 00:08:52.360
and now we've moved on to other things.


00:08:52.360 --> 00:08:55.840
Well, I mean, it's funny because you get a new technology,


00:08:55.840 --> 00:08:58.840
like, okay, the topic of the minute, ChatGPT,


00:08:58.840 --> 00:09:01.800
and everybody on LinkedIn is an expert in ChatGPT.


00:09:01.800 --> 00:09:02.640
Have you noticed that?


00:09:02.640 --> 00:09:04.080
Every other post is about ChatGPT.


00:09:04.080 --> 00:09:06.360
It's like, well, it's interesting,


00:09:06.360 --> 00:09:09.680
but it's just a bit early and the early adopters


00:09:09.680 --> 00:09:11.960
have a lot of egg they're still trying to wash off their face


00:09:11.960 --> 00:09:13.680
in the last six paths.


00:09:13.680 --> 00:09:16.080
So it's like, let's see what happens,


00:09:16.080 --> 00:09:18.820
but chances are this is just an early hiccup.


00:09:18.820 --> 00:09:22.040
- Yeah, for sure.


00:09:22.040 --> 00:09:24.560
So you mentioned FastAPI and SQLAlchemy


00:09:24.560 --> 00:09:27.800
and Yasser out there says SQLAlchemy is the best library.


00:09:27.800 --> 00:09:29.320
So SQLAlchemy is pretty great.


00:09:29.320 --> 00:09:33.160
And it's cool to see my Bayer and crew updated to 2.0


00:09:33.160 --> 00:09:35.880
and add async and await to it and stuff.


00:09:35.880 --> 00:09:40.800
But there's also, especially when you're in Pydantic world,


00:09:40.800 --> 00:09:42.220
say with FastAPI,


00:09:42.220 --> 00:09:46.680
you know, there's a SQL model


00:09:46.680 --> 00:09:49.200
also from Sebastian Ramirez that says,


00:09:49.200 --> 00:09:52.480
"Hey, we are already doing Pydantic for the API


00:09:52.480 --> 00:09:54.000
"or front end exchange."


00:09:54.000 --> 00:09:56.760
Like, what about making that your database?


00:09:56.760 --> 00:09:59.840
Did you all evaluate or consider SQL model?


00:09:59.840 --> 00:10:01.160
- I did.


00:10:01.160 --> 00:10:04.440
And it's one of those things like, this would be great.


00:10:04.440 --> 00:10:06.560
And I think we can move towards that later.


00:10:06.560 --> 00:10:09.040
But sometimes when you're paying down technical debt,


00:10:09.040 --> 00:10:11.120
you have to make a distinction between,


00:10:11.120 --> 00:10:13.920
do I want to make the monthly payment


00:10:13.920 --> 00:10:16.400
as if we're more than a monthly payment,


00:10:16.400 --> 00:10:19.200
or do I wanna try and pay it all off in one thing?


00:10:19.200 --> 00:10:21.840
And sometimes when you're having to budget that time,


00:10:21.840 --> 00:10:26.840
for us, it made the most sense to migrate from the 1.0


00:10:26.840 --> 00:10:29.480
that we were working with earlier on


00:10:29.480 --> 00:10:32.880
to using the SQLAlchemy 2.


00:10:32.880 --> 00:10:35.360
And so there was a relatively smaller set of changes


00:10:35.360 --> 00:10:36.200
that we needed to make.


00:10:36.200 --> 00:10:37.040
- I see.


00:10:37.040 --> 00:10:40.840
- Moving to something like a school model would have,


00:10:40.840 --> 00:10:43.560
would be great, but it would also require us


00:10:43.560 --> 00:10:45.320
to rewrite some major things.


00:10:45.320 --> 00:10:47.360
And so that's one of those things is like,


00:10:47.360 --> 00:10:48.880
well, this might be a good option.


00:10:48.880 --> 00:10:49.800
I mean, it looks really cool,


00:10:49.800 --> 00:10:51.760
but let's defer that for right now


00:10:51.760 --> 00:10:53.920
so that we can actually get some stuff done.


00:10:53.920 --> 00:10:55.320
It's a constant balancing act.


00:10:55.320 --> 00:10:57.840
Like do we pay down technical debt or build new features?


00:10:57.840 --> 00:10:59.440
And the answer is yes.


00:10:59.440 --> 00:11:01.160
You have to do both,


00:11:01.160 --> 00:11:03.480
but you have to keep it in balance.


00:11:03.480 --> 00:11:04.320
Pay down the credit card,


00:11:04.320 --> 00:11:06.560
but also make sure you're buying your groceries.


00:11:06.560 --> 00:11:09.100
- Yeah, absolutely.


00:11:09.100 --> 00:11:11.700
I feel like if you wanted to go that way,


00:11:11.700 --> 00:11:13.260
the change is pretty straightforward,


00:11:13.260 --> 00:11:15.320
but if you already have it all set up in the other way,


00:11:15.320 --> 00:11:17.800
again, it's like, eh, what is the value?


00:11:17.800 --> 00:11:22.800
Just one thing that kind of timely as of a couple days ago,


00:11:22.800 --> 00:11:26.940
let's see, as of two days ago,


00:11:26.940 --> 00:11:30.440
the Pydantic folks, Samuel Colvin and Terrence Dorsey


00:11:30.440 --> 00:11:33.840
posted, "Hey, we're excited to announce the first alpha


00:11:33.840 --> 00:11:35.240
of Pydantic v2."


00:11:35.240 --> 00:11:36.960
And I had Samuel on like a year ago


00:11:36.960 --> 00:11:39.440
to talk about what they were doing there.


00:11:39.440 --> 00:11:44.440
But the big news is, the headline news in here is


00:11:44.440 --> 00:11:48.000
they rewrote much of the core of Pydantic in Rust.


00:11:48.000 --> 00:11:52.480
And now Pydantic version two is five to 50 times faster.


00:11:52.480 --> 00:11:53.840
- Nice.


00:11:53.840 --> 00:11:55.040
- That's cool, right?


00:11:55.040 --> 00:11:56.680
- That's gorgeous.


00:11:56.680 --> 00:11:57.520
Thank you.


00:11:57.520 --> 00:11:59.000
This is just put more work on my plate.


00:11:59.000 --> 00:11:59.840
That's okay.


00:11:59.840 --> 00:12:01.600
(laughing)


00:12:01.600 --> 00:12:02.440
This'll be good.


00:12:02.440 --> 00:12:04.440
I'll have to bring this up at work.


00:12:04.440 --> 00:12:06.560
It's like, "Hey, we should look at this later."


00:12:06.560 --> 00:12:07.400
But-


00:12:07.400 --> 00:12:09.640
- Yeah, I mean, I don't think that there's any,


00:12:09.640 --> 00:12:11.840
I don't think anything will,


00:12:11.840 --> 00:12:14.740
obviously nothing will change for your SQLAlchemy side,


00:12:14.740 --> 00:12:15.880
but even for FastAPI,


00:12:15.880 --> 00:12:18.760
I'm sure that this is gonna get rolled in in a smooth way.


00:12:18.760 --> 00:12:21.920
But it does mean that all that data exchange


00:12:21.920 --> 00:12:23.280
should just go way, way faster,


00:12:23.280 --> 00:12:26.760
which for basically no effort on users of things


00:12:26.760 --> 00:12:30.440
like FastAPI, and SQL model, and Beanie, and all those.


00:12:30.440 --> 00:12:31.960
So that's cool news.


00:12:31.960 --> 00:12:32.920
- Yeah, definitely.


00:12:32.920 --> 00:12:33.760
That is neat.


00:12:33.760 --> 00:12:34.760
- Yeah.


00:12:34.760 --> 00:12:37.160
Other than the fact that if you do a lot of work


00:12:37.160 --> 00:12:39.440
in directly in Pydantic models,


00:12:39.440 --> 00:12:40.980
there might be a few small breaking changes.


00:12:40.980 --> 00:12:45.560
But let's talk about our things,


00:12:45.560 --> 00:12:48.880
the things we wish someone had explained to us sooner.


00:12:48.880 --> 00:12:50.360
- Yes.


00:12:50.360 --> 00:12:51.200
- I guess we can start with this.


00:12:51.200 --> 00:12:52.880
Like these things were motivated.


00:12:52.880 --> 00:12:54.720
We can come back and talk a bit more about this at the end,


00:12:54.720 --> 00:12:55.640
but they're motivated.


00:12:55.640 --> 00:13:00.480
This whole conversation was motivated by sort of this big,


00:13:00.480 --> 00:13:03.120
long book that you wrote here, "Dead Simple Python."


00:13:03.120 --> 00:13:04.480
Give people the elevator pitch and then we'll get to it.


00:13:04.480 --> 00:13:05.440
- Yeah, exactly.


00:13:05.440 --> 00:13:07.920
So "Dead Simple Python" is the book I wish I had.


00:13:07.920 --> 00:13:11.520
And yeah, it's, I get teased a lot.


00:13:11.520 --> 00:13:13.280
It's like dead simple and it's that thick,


00:13:13.280 --> 00:13:18.280
but it's dead simple in the same way that Python is obvious.


00:13:18.280 --> 00:13:20.600
It's obvious retrospectively.


00:13:20.600 --> 00:13:21.640
Things are dead simple.


00:13:21.640 --> 00:13:23.120
Once you understand it, you look back and go,


00:13:23.120 --> 00:13:26.040
Oh, okay, that click, that just makes sense.


00:13:26.040 --> 00:13:27.760
A lot of things in Python are like that.


00:13:27.760 --> 00:13:30.480
You look into it, it's like, that looks really complicated.


00:13:30.480 --> 00:13:32.160
How is this async supposed to work?


00:13:32.160 --> 00:13:34.760
And then you look back and go, oh, that's all?


00:13:34.760 --> 00:13:36.800
Okay, no, that's-- - Yeah, yeah, exactly.


00:13:36.800 --> 00:13:37.640
Why was I afraid?


00:13:37.640 --> 00:13:40.560
Why did I put off learning this for six months?


00:13:40.560 --> 00:13:41.400
- Exactly.


00:13:41.400 --> 00:13:43.760
It's, you know, things look more intimidating


00:13:43.760 --> 00:13:48.400
than they are in practice.


00:13:48.400 --> 00:13:52.880
But basically this is the book for those,


00:13:52.880 --> 00:13:56.440
already know another programming language.


00:13:56.440 --> 00:14:01.040
Or maybe they've even been working with Python for awhile


00:14:01.040 --> 00:14:04.240
like they're familiar with the basics. They do not want to


00:14:04.240 --> 00:14:07.640
have their hand held through the you know this is what a


00:14:07.640 --> 00:14:10.880
variable is and this is what a function is. I don't think


00:14:10.880 --> 00:14:13.360
they've been through this probably more times than they


00:14:13.360 --> 00:14:16.880
want to admit to and they want to get into what's different


00:14:16.880 --> 00:14:20.080
about Python and how to use Python as Python. I think


00:14:20.080 --> 00:14:28.080
I think that's kind of the core of the book is there's a big difference between Python code that works


00:14:28.080 --> 00:14:34.580
and Python code that makes the most of the language and its patterns, what we would refer to as "Pythonic code."


00:14:34.580 --> 00:14:40.080
And there's a big difference between the two because it's very tempting to come in and write Python as


00:14:40.080 --> 00:14:46.580
BB.net in my case because that's where I started, or write Python as C, or write Python as Java, or write Python as Ruby.


00:14:46.580 --> 00:14:51.580
and we wind up holding ourselves back and having really convoluted and hard to maintain code


00:14:51.580 --> 00:14:53.580
because we don't understand the patterns.


00:14:53.580 --> 00:14:58.080
So the approach I took with the book is, let me explain why we do things this way.


00:14:58.080 --> 00:15:05.080
Let's go all the way down into the internals and how this actually works under the hood.


00:15:05.080 --> 00:15:10.080
So by the time you get to the for loop, the with statement, the meta class or whatever,


00:15:10.080 --> 00:15:15.580
you're like, oh, I understand what this is, why it's there, how it's used, and when not to use it.


00:15:15.580 --> 00:15:19.340
Yeah, that's a great service.


00:15:19.340 --> 00:15:24.340
So you're saying if I created a class called like


00:15:24.340 --> 00:15:28.820
user factory and it implemented I user factory


00:15:28.820 --> 00:15:30.820
and then I would use dependency injects,


00:15:30.820 --> 00:15:32.140
I might be doing that wrong?


00:15:32.140 --> 00:15:34.560
- You might be writing C# in Python.


00:15:34.560 --> 00:15:37.820
- Yeah, indeed.


00:15:37.820 --> 00:15:39.020
- Yeah. - Right, indeed.


00:15:39.020 --> 00:15:39.860
All right, cool.


00:15:39.860 --> 00:15:41.980
So I like the idea of it.


00:15:41.980 --> 00:15:45.380
Let's talk, let's go through the topics.


00:15:45.380 --> 00:15:47.420
We both contributed a little bit, mostly.


00:15:47.420 --> 00:15:49.620
I'll throw in a few if we got extra time.


00:15:49.620 --> 00:15:51.620
The first one has to do with this,


00:15:51.620 --> 00:15:56.980
I guess, really early stage writing code,


00:15:56.980 --> 00:15:58.580
like how to create variables.


00:15:58.580 --> 00:16:00.660
What are the deals with types and variables,


00:16:00.660 --> 00:16:02.620
but also types and objects?


00:16:02.620 --> 00:16:03.500
Tell us about that.


00:16:03.500 --> 00:16:04.500
- Yeah, exactly.


00:16:04.500 --> 00:16:05.980
How names and values actually work.


00:16:05.980 --> 00:16:10.460
And this is something that I had to learn early,


00:16:10.460 --> 00:16:11.840
but I didn't fully understand.


00:16:11.840 --> 00:16:14.400
So when I first logged into the Python IRC room,


00:16:14.400 --> 00:16:16.800
back when I learned this language, you know,


00:16:16.800 --> 00:16:19.160
back in the cretaceous period,


00:16:19.160 --> 00:16:22.840
I logged in and I, you know,


00:16:22.840 --> 00:16:24.500
I'm coming from a strongly type background.


00:16:24.500 --> 00:16:27.320
So I'm saying, okay, so how do I declare a data type


00:16:27.320 --> 00:16:28.160
on a variable?


00:16:28.160 --> 00:16:29.280
'Cause I'm used to VB,


00:16:29.280 --> 00:16:31.240
like a dim and the name of the variable


00:16:31.240 --> 00:16:32.920
and the type equals whatever.


00:16:32.920 --> 00:16:34.800
How do I declare the type?


00:16:34.800 --> 00:16:36.040
This is before type hints existed.


00:16:36.040 --> 00:16:39.760
And one of the guys in the room goes, you're a data type.


00:16:39.760 --> 00:16:41.520
And I'm like, sorry, what?


00:16:41.520 --> 00:16:42.640
And then he goes on to explain,


00:16:42.640 --> 00:16:46.280
well, it doesn't quite work this way in Python,


00:16:46.280 --> 00:16:48.120
but I didn't realize just how different it was.


00:16:48.120 --> 00:16:50.440
So because I just sort of had this vague,


00:16:50.440 --> 00:16:53.520
like, oh, you just have the name equals the value of cool,


00:16:53.520 --> 00:16:55.000
type still seems kind of important.


00:16:55.000 --> 00:16:57.000
Maybe I should start doing Hungarian notation.


00:16:57.000 --> 00:16:57.840
Don't do that.


00:16:57.840 --> 00:16:58.660
(laughing)


00:16:58.660 --> 00:17:01.000
- That's Z, user name.


00:17:01.000 --> 00:17:02.640
- No, exactly.


00:17:02.640 --> 00:17:05.280
Exactly, int age or whatever.


00:17:05.280 --> 00:17:06.120
- Yeah.


00:17:06.120 --> 00:17:07.840
- And I thought I was being super clever and I wasn't,


00:17:07.840 --> 00:17:11.200
but eventually someone explained to me,


00:17:11.200 --> 00:17:12.440
I think it was actually Ned Batchelder,


00:17:12.440 --> 00:17:15.340
someone gave me the link to Ned Batchelder's talk on this,


00:17:15.340 --> 00:17:20.380
is that Python's variables work very differently


00:17:20.380 --> 00:17:21.700
than other languages,


00:17:21.700 --> 00:17:23.820
so much so that some smart alecks like to say,


00:17:23.820 --> 00:17:25.380
well, Python doesn't really have variables.


00:17:25.380 --> 00:17:28.620
Yes, it does, but they're variables in a different sense.


00:17:28.620 --> 00:17:32.420
You have names which are just like, they're like labels,


00:17:32.420 --> 00:17:33.940
and you can call it whatever you want,


00:17:33.940 --> 00:17:36.620
but a name has a scope, you know?


00:17:36.620 --> 00:17:39.020
So the name exists in the context of your whole program


00:17:39.020 --> 00:17:41.780
or in the context of your function or whatever.


00:17:41.780 --> 00:17:43.900
And a name can be bound to whatever you want.


00:17:43.900 --> 00:17:45.260
You imagine drawing, you know,


00:17:45.260 --> 00:17:49.100
basically having this label on a corkboard,


00:17:49.100 --> 00:17:51.220
think like a conspiracy theorist corkboard.


00:17:51.220 --> 00:17:53.340
You know, you have the tack and the label,


00:17:53.340 --> 00:17:54.540
and then you put a little string around it,


00:17:54.540 --> 00:17:58.340
and you tie that string to this other thing over here.


00:17:58.340 --> 00:18:00.060
And that's your value.


00:18:00.060 --> 00:18:01.800
Your value has a type.


00:18:01.800 --> 00:18:04.240
It has, it is one thing.


00:18:04.240 --> 00:18:05.820
It's a Boolean, or it is an integer,


00:18:05.820 --> 00:18:08.220
or it is a string, or it is a list.


00:18:08.220 --> 00:18:09.300
- We've all seen the error,


00:18:09.300 --> 00:18:13.380
cannot combine integer and string with plus operation.


00:18:13.380 --> 00:18:15.020
Like they know what they are, right?


00:18:15.020 --> 00:18:15.860
- Exactly.


00:18:15.860 --> 00:18:16.940
Those values know what they are.


00:18:16.940 --> 00:18:18.380
And that's something that throws people off


00:18:18.380 --> 00:18:20.380
coming from JavaScript where everything's weakly typed.


00:18:20.380 --> 00:18:21.740
It'll just try to coerce them together.


00:18:21.740 --> 00:18:23.700
Python says, "Hey, these two values are different.


00:18:23.700 --> 00:18:26.100
"I'm not gonna try and figure this out."


00:18:26.100 --> 00:18:29.100
But that's because it's working with the values.


00:18:29.100 --> 00:18:31.860
The values have type, but the values don't have scope.


00:18:31.860 --> 00:18:34.700
And this is where people get thrown off.


00:18:34.700 --> 00:18:39.700
because if you say, you know, let's say,


00:18:39.700 --> 00:18:42.060
I'm gonna use the example here, x equals spam.


00:18:42.060 --> 00:18:45.280
If you were to say z equals x,


00:18:45.280 --> 00:18:47.820
you're binding z to the same value as x.


00:18:47.820 --> 00:18:50.700
And then if you decide to change z, that works.


00:18:50.700 --> 00:18:52.140
X is unchanged, z is changed.


00:18:52.140 --> 00:18:54.480
You might think, oh, cool, okay, this is just,


00:18:54.480 --> 00:18:55.580
it just made a copy.


00:18:55.580 --> 00:18:58.800
Not exactly, because we have this whole thing


00:18:58.800 --> 00:19:01.100
about mutable and immutable types.


00:19:01.100 --> 00:19:03.140
Some things can't be changed.


00:19:03.140 --> 00:19:06.820
Boolean, an integer, a string, a tuple, they're not changed.


00:19:06.820 --> 00:19:09.500
The value is never modified in memory.


00:19:09.500 --> 00:19:12.020
A new thing is made instead.


00:19:12.020 --> 00:19:16.000
But then some, and by some I mean most,


00:19:16.000 --> 00:19:18.740
sorry about my clock,


00:19:18.740 --> 00:19:22.820
most types of Python, like lists and dictionaries


00:19:22.820 --> 00:19:24.200
and the objects that you're creating


00:19:24.200 --> 00:19:27.100
with your fancy little classes are mutable.


00:19:27.100 --> 00:19:30.700
So if you create a list or a dictionary


00:19:30.700 --> 00:19:33.580
and you bind that to two different names,


00:19:33.580 --> 00:19:37.020
you modify, you add a value to that list.


00:19:37.020 --> 00:19:38.340
It doesn't matter which of the names you use,


00:19:38.340 --> 00:19:42.500
you're modifying the value in memory, in place.


00:19:42.500 --> 00:19:45.500
And now that is accessible from either of those names.


00:19:45.500 --> 00:19:46.380
- Yeah.


00:19:46.380 --> 00:19:47.540
- And that can be confusing,


00:19:47.540 --> 00:19:49.060
especially when you start to understand


00:19:49.060 --> 00:19:50.600
that functions don't pass by value,


00:19:50.600 --> 00:19:52.140
they don't pass by reference,


00:19:52.140 --> 00:19:56.900
they just bind the value to the name of that argument.


00:19:56.900 --> 00:19:58.860
Pass by assignment is what we usually call it.


00:19:58.860 --> 00:20:00.980
So you're just having one more handle,


00:20:00.980 --> 00:20:03.500
one more alias pointing to that value in memory.


00:20:03.500 --> 00:20:05.940
So if you change on that argument,


00:20:05.940 --> 00:20:07.980
you're just changing your spot in memory.


00:20:07.980 --> 00:20:14.540
- Many languages have values that are like local


00:20:14.540 --> 00:20:17.060
and copied types of values.


00:20:17.060 --> 00:20:19.340
So you mentioned VB.net,


00:20:19.340 --> 00:20:22.300
which like the integer and float values,


00:20:22.300 --> 00:20:24.180
numbers and things like that.


00:20:24.180 --> 00:20:26.900
If you assign one, it's a copy of a thing.


00:20:26.900 --> 00:20:31.540
Whereas Python, literally everything is a pointer.


00:20:31.540 --> 00:20:36.220
This corkboard conspiracy theory thing.


00:20:36.220 --> 00:20:38.820
There's no concept of, oh, I create this on the stack,


00:20:38.820 --> 00:20:41.260
and when the function returns, it's gone.


00:20:41.260 --> 00:20:47.020
Everything is a-- even just an integer is a pi long star


00:20:47.020 --> 00:20:48.540
down in the runtime.


00:20:48.540 --> 00:20:52.180
And so that's a bit of a mental thing people


00:20:52.180 --> 00:20:55.940
got to get used to, just like how much--


00:20:55.940 --> 00:20:59.780
Because when you come from a language like C++ or something,


00:20:59.780 --> 00:21:02.880
pointers and these reference type of ideas


00:21:02.880 --> 00:21:04.760
are like right in your face, right?


00:21:04.760 --> 00:21:08.280
Like you see this, like I just said, pi long star,


00:21:08.280 --> 00:21:10.440
like the star means it points at things.


00:21:10.440 --> 00:21:12.440
Without the star, it's on the stack, right?


00:21:12.440 --> 00:21:15.520
It's a, you are way down in those details.


00:21:15.520 --> 00:21:17.920
Whereas in Python, you never see pointers.


00:21:17.920 --> 00:21:19.480
Like you could imagine, like there's no such,


00:21:19.480 --> 00:21:21.920
like we don't even have pointers in Python.


00:21:21.920 --> 00:21:24.240
But the irony is like literally everything


00:21:24.240 --> 00:21:28.360
is basically managed in that on the heap reference type


00:21:28.360 --> 00:21:29.580
style of work.


00:21:29.580 --> 00:21:30.420
So.


00:21:30.420 --> 00:21:31.240
- Exactly.


00:21:31.240 --> 00:21:32.800
- Yeah, that's something I wish I knew.


00:21:32.800 --> 00:21:34.280
- Sorry, go ahead.


00:21:34.280 --> 00:21:36.820
- No, I just wish I knew that earlier as well.


00:21:36.820 --> 00:21:37.660
Go ahead.


00:21:37.660 --> 00:21:40.240
- Yeah, and of course then people come from C++


00:21:40.240 --> 00:21:41.480
and say like, oh cool, that's easy.


00:21:41.480 --> 00:21:42.920
So it's all pointers.


00:21:42.920 --> 00:21:46.160
Well, once again, Python being Python, not quite.


00:21:46.160 --> 00:21:48.440
Because it's actually technically called a reference,


00:21:48.440 --> 00:21:50.040
not a pointer, and that's important


00:21:50.040 --> 00:21:53.840
because a Python reference or a Python value


00:21:53.840 --> 00:21:56.020
has two things.


00:21:56.020 --> 00:21:57.620
It has, yes, it does have a pointer,


00:21:57.620 --> 00:21:58.820
at least if we're talking about CPython,


00:21:58.820 --> 00:22:00.780
but it also has a reference counter,


00:22:00.780 --> 00:22:03.420
which is itself an integer, and that's adding overhead.


00:22:03.420 --> 00:22:06.140
So if you ever do actually go down


00:22:06.140 --> 00:22:08.100
and look at the sizes of things,


00:22:08.100 --> 00:22:10.860
you will notice that your base value


00:22:10.860 --> 00:22:15.860
has this additional overhead of two numbers.


00:22:15.860 --> 00:22:17.260
One of them is your pointer,


00:22:17.260 --> 00:22:20.980
and the other one is your reference counter,


00:22:20.980 --> 00:22:23.460
because it has a reference count in garbage collection.


00:22:23.460 --> 00:22:26.640
- Yeah, often a lot more, I think trying to,


00:22:26.640 --> 00:22:29.360
I guess I could check, but either an integer


00:22:29.360 --> 00:22:33.140
or a single character, I can't remember which,


00:22:33.140 --> 00:22:34.880
is 28 bytes, right?


00:22:34.880 --> 00:22:38.280
And that's in C, the single character


00:22:38.280 --> 00:22:39.920
would be one or two bytes,


00:22:39.920 --> 00:22:43.080
and the integer would be two, four, or eight, right?


00:22:43.080 --> 00:22:45.520
So there's just a big difference in the way you got to,


00:22:45.520 --> 00:22:47.680
sort of like the implications of that.


00:22:47.680 --> 00:22:50.040
Related to that, kind of moving on to the next,


00:22:51.240 --> 00:22:52.300
before we move on.


00:22:52.300 --> 00:22:53.540
The other thing that you mentioned,


00:22:53.540 --> 00:22:57.260
and I think is also a really big deal in this area,


00:22:57.260 --> 00:22:59.280
is the scope of a variable.


00:22:59.280 --> 00:23:01.660
And so in some languages,


00:23:01.660 --> 00:23:03.740
you have very fine-grained control


00:23:03.740 --> 00:23:06.780
of the lifetime of a variable by where you declare it.


00:23:06.780 --> 00:23:11.440
So for example, if you declare a variable in C++


00:23:11.440 --> 00:23:15.060
or VB.NET or whatever, in a if block,


00:23:15.060 --> 00:23:17.160
when you leave the if block, the thing goes away.


00:23:17.160 --> 00:23:19.320
Like if there's curly braces around it


00:23:19.320 --> 00:23:20.660
in a lot of languages,


00:23:20.660 --> 00:23:23.620
Like that is the lifetime of the variable,


00:23:23.620 --> 00:23:26.220
the innermost bracket of curly braces.


00:23:26.220 --> 00:23:30.620
Like outside of a loop, the thing goes away.


00:23:30.620 --> 00:23:31.940
In Python, we don't have that.


00:23:31.940 --> 00:23:35.420
And that's kind of the variable persists


00:23:35.420 --> 00:23:38.060
and lives afterwards, right?


00:23:38.060 --> 00:23:39.980
Which is interesting.


00:23:39.980 --> 00:23:40.820
- Yeah.


00:23:40.820 --> 00:23:41.820
- Difference.


00:23:41.820 --> 00:23:43.780
- Yeah, because the garbage collection


00:23:43.780 --> 00:23:45.880
is something you're never supposed to have to deal with.


00:23:45.880 --> 00:23:48.660
So even if you called delete on something,


00:23:48.660 --> 00:23:51.960
it's not necessarily guaranteed to be cleaned up when you expect


00:23:51.960 --> 00:23:55.380
it like the language is going to handle things when it when it


00:23:55.380 --> 00:23:59.660
sees fit for whatever reason. So yeah, there's only to my


00:23:59.660 --> 00:24:02.140
knowledge, there's only three, there's only actually three


00:24:02.140 --> 00:24:09.300
scopes in Python, there's global level, there's module level. And


00:24:09.300 --> 00:24:15.640
there's I need a Mac, it's a little Yeah, pedantic. And then


00:24:15.640 --> 00:24:16.640
you have function level.


00:24:16.640 --> 00:24:19.400
Classes are not their own scope.


00:24:19.400 --> 00:24:21.240
Classes actually do not--


00:24:21.240 --> 00:24:24.200
a class exists in the global level.


00:24:24.200 --> 00:24:26.520
And whenever you have an attribute sitting on a class


00:24:26.520 --> 00:24:29.600
or sitting on an instance, it's actually in a dictionary--


00:24:29.600 --> 00:24:31.600
unless using slots, I'm not going into that--


00:24:31.600 --> 00:24:34.840
actually sitting in a dictionary that is a part


00:24:34.840 --> 00:24:39.200
of that object in memory.


00:24:39.200 --> 00:24:41.320
>>Yep.


00:24:41.320 --> 00:24:42.080
It's special.


00:24:42.080 --> 00:24:43.520
But it works out.


00:24:43.520 --> 00:24:46.020
It's just something you gotta kind of get used to.


00:24:46.020 --> 00:24:47.120
- Definitely. - Yeah.


00:24:47.120 --> 00:24:50.320
All right, next one.


00:24:50.320 --> 00:24:52.020
Ducks.


00:24:52.020 --> 00:24:53.120
(duck quacks)


00:24:53.120 --> 00:24:55.620
(both laugh)


00:24:55.620 --> 00:24:56.760
- Duck typing, yeah.


00:24:56.760 --> 00:25:00.300
And it's, this is where I went haywire


00:25:00.300 --> 00:25:03.580
when I was doing that Hungarian notation I mentioned,


00:25:03.580 --> 00:25:05.180
'cause I'm thinking, I'm being so clever.


00:25:05.180 --> 00:25:07.480
I'm just putting the name of the,


00:25:07.480 --> 00:25:10.000
or the type in the name, and then I know it.


00:25:10.000 --> 00:25:15.120
But unfortunately, when you're coming from a strongly typed language, you're actually,


00:25:15.120 --> 00:25:21.280
it's easy to underestimate just how much strong typing can actually hold us back in some cases,


00:25:21.280 --> 00:25:25.040
because we start thinking about what a thing is rather than what it can do.


00:25:25.040 --> 00:25:28.400
And we see this in Java, like you have to have these complex inheritance patterns,


00:25:28.400 --> 00:25:35.040
because you want to be able to say, well, this thing is, it is this, this, it matches this interface,


00:25:35.040 --> 00:25:37.160
you know, it does this particular thing.


00:25:37.720 --> 00:25:41.480
Python's take is I really don't care what it is.


00:25:41.480 --> 00:25:43.720
As long as I can interact with it


00:25:43.720 --> 00:25:48.720
according to a particular kind of set of assumptions,


00:25:48.720 --> 00:25:51.880
then I don't care what it's really doing under the hood.


00:25:51.880 --> 00:25:53.720
And this can be really beneficial


00:25:53.720 --> 00:25:55.520
because it allows you to create new things


00:25:55.520 --> 00:25:57.840
that act like integers, even though they're not integers,


00:25:57.840 --> 00:26:00.040
or new things that act like Booleans that aren't Booleans,


00:26:00.040 --> 00:26:01.880
new things that act like strings that aren't strings.


00:26:01.880 --> 00:26:03.360
Python doesn't care.


00:26:03.360 --> 00:26:07.160
It's just interfacing with those objects


00:26:07.160 --> 00:26:10.800
on the basis of how it can use them


00:26:10.800 --> 00:26:15.640
and what certain things are going to return.


00:26:15.640 --> 00:26:17.000
That's all it cares about.


00:26:17.000 --> 00:26:22.880
So the concept of duck typing being it doesn't care whether it's a duck


00:26:22.880 --> 00:26:25.520
or a picture of a duck or a statue of a duck or a moose in a duck suit,


00:26:25.520 --> 00:26:27.960
as long as you can interact with it in the way it needs.


00:26:27.960 --> 00:26:29.720
It's good.


00:26:29.720 --> 00:26:31.320
Yeah, that's very funny.


00:26:31.320 --> 00:26:34.600
It talks like a duck and quacks like a duck and probably a duck.


00:26:34.600 --> 00:26:35.720
Yeah, exactly.


00:26:35.720 --> 00:26:37.640
- Yeah, it's very freeing once you get that


00:26:37.640 --> 00:26:38.880
because you don't have to muck about


00:26:38.880 --> 00:26:40.740
with all this weird inheritance anymore.


00:26:40.740 --> 00:26:44.220
It's like, well, it does what I need.


00:26:44.220 --> 00:26:46.520
And that's the important part.


00:26:46.520 --> 00:26:48.400
- There is certainly less inheritance


00:26:48.400 --> 00:26:51.280
and less complex hierarchies in Python.


00:26:51.280 --> 00:26:53.080
Not that there's not an important place


00:26:53.080 --> 00:26:55.800
for object-oriented programming in classes.


00:26:55.800 --> 00:26:57.800
They're just often simpler.


00:26:57.800 --> 00:27:00.920
- A lot more straightforward, definitely.


00:27:00.920 --> 00:27:03.560
And it frees us up to then,


00:27:03.560 --> 00:27:06.360
The saying I coined a couple of years ago


00:27:06.360 --> 00:27:10.120
during a conference talk was that you needed to find objects


00:27:10.120 --> 00:27:12.200
by their constituent data.


00:27:12.200 --> 00:27:14.940
So when you're writing a class or you're designing an object,


00:27:14.940 --> 00:27:18.440
you're thinking about what is it storing?


00:27:18.440 --> 00:27:23.240
Like what sort of state, if you think in a functional way,


00:27:23.240 --> 00:27:27.680
or what sort of data am I really putting in here?


00:27:27.680 --> 00:27:31.440
And you can design based off of that.


00:27:31.440 --> 00:27:33.320
And then you can think about, well,


00:27:33.320 --> 00:27:38.920
how do I want, how does the system need to interact with that data?


00:27:38.920 --> 00:27:42.500
But you don't really have to sit there and think about encapsulating behavior,


00:27:42.500 --> 00:27:43.640
because that's not really the point.


00:27:43.640 --> 00:27:48.220
The point is you think about, like with example I use is we always see the


00:27:48.220 --> 00:27:51.700
example of I'm going to create a class called cat and a class called dog and


00:27:51.700 --> 00:27:52.780
they inherit from animal.


00:27:52.780 --> 00:27:56.880
And that's actually a really lousy example we need to stop using because,


00:27:56.880 --> 00:28:00.500
um, that's starting from a concept of behavior.


00:28:00.540 --> 00:28:04.060
Well, it barks, it meows, it eats, it whatever.


00:28:04.060 --> 00:28:08.500
And in real systems, what we think about is,


00:28:08.500 --> 00:28:11.820
I have a, you know, someone designing a game.


00:28:11.820 --> 00:28:12.820
I have a monster.


00:28:12.820 --> 00:28:15.060
Okay, what is a monster?


00:28:15.060 --> 00:28:16.940
Well, it's a bad guy.


00:28:16.940 --> 00:28:18.420
No, no, no, no, not what it does.


00:28:18.420 --> 00:28:19.960
What is it?


00:28:19.960 --> 00:28:24.500
Well, it's a collection of statistics about the character,


00:28:24.500 --> 00:28:26.420
you know, like how much strength it has


00:28:26.420 --> 00:28:27.740
and how much health it has.


00:28:27.740 --> 00:28:32.740
okay, that is not a monster, that's an entity.


00:28:32.740 --> 00:28:38.140
You don't have to put what it's doing into that code,


00:28:38.140 --> 00:28:41.920
it is this collection of information.


00:28:41.920 --> 00:28:46.380
And when you shift your thinking to a data-first mindset


00:28:46.380 --> 00:28:49.580
about object-oriented, then you find that you can actually


00:28:49.580 --> 00:28:51.260
use it with functional paradigms


00:28:51.260 --> 00:28:53.660
that are sometimes a lot easier to reason about.


00:28:55.060 --> 00:28:58.600
- Yeah, the grouping together of data is an important part.


00:28:58.600 --> 00:29:03.340
I would say the most extreme example of duck typing


00:29:03.340 --> 00:29:08.340
in Python is maybe a couple areas,


00:29:08.340 --> 00:29:12.940
and they all seem to revolve around the magic methods


00:29:12.940 --> 00:29:15.340
or the Python data types, like the dunder methods, right?


00:29:15.340 --> 00:29:16.500
- I love those.


00:29:16.500 --> 00:29:17.380
- Yeah, I know.


00:29:17.380 --> 00:29:20.580
So I could have a function, which I could call,


00:29:20.580 --> 00:29:24.060
or I could have a class that implements dunder call,


00:29:24.060 --> 00:29:28.460
is a callable, but it's actually an instance of an object.


00:29:28.460 --> 00:29:30.980
But as far as Python is concerned, it doesn't matter.


00:29:30.980 --> 00:29:32.860
It can call it and pass parameters


00:29:32.860 --> 00:29:34.420
to the thing it called.


00:29:34.420 --> 00:29:38.100
And there's no real type that disambiguates those two things.


00:29:38.100 --> 00:29:39.300
Like, one is a function type.


00:29:39.300 --> 00:29:43.420
One is a class with a particular method on it.


00:29:43.420 --> 00:29:45.700
But they work just fine.


00:29:45.700 --> 00:29:49.100
And that's a pretty extreme example.


00:29:49.100 --> 00:29:52.740
Another one would be, I have a list I can iterate,


00:29:52.740 --> 00:29:56.740
or I have something that implements the iterator pattern


00:29:56.740 --> 00:29:58.100
through the dunder methods, right?


00:29:58.100 --> 00:30:01.140
Like the dunder iter and so on.


00:30:01.140 --> 00:30:03.220
- Right, well, yeah, one of the classes,


00:30:03.220 --> 00:30:07.380
one of the examples in the book I gave was like a cafe queue


00:30:07.380 --> 00:30:09.460
so a queue of customers in a line


00:30:09.460 --> 00:30:12.580
and I wrote it as an iterable


00:30:12.580 --> 00:30:15.460
but there was all this additional stuff in there.


00:30:15.460 --> 00:30:18.460
It wasn't just a basic list, there was more to it than that.


00:30:18.460 --> 00:30:21.980
But because I implemented as an iterable,


00:30:21.980 --> 00:30:24.820
I didn't care, I could use it like I could use a list.


00:30:24.820 --> 00:30:30.180
But it was able to do this additional work with the data


00:30:30.180 --> 00:30:35.180
behind the scenes that made it just easier to use the,


00:30:35.180 --> 00:30:38.660
to reason about this line of customers.


00:30:38.660 --> 00:30:40.740
- Right, then you get generator methods


00:30:40.740 --> 00:30:42.820
with the yield keyword and yield from


00:30:42.820 --> 00:30:45.020
and like all sorts of stuff.


00:30:45.020 --> 00:30:49.880
You get pytest fixtures that allow you to set up


00:30:49.880 --> 00:30:52.780
and tear down without actually writing,


00:30:52.780 --> 00:30:54.840
try finally blocks and all these things.


00:30:54.840 --> 00:30:56.720
A lot of interesting places.


00:30:56.720 --> 00:30:58.280
While I was thinking about this conversation


00:30:58.280 --> 00:30:59.640
and this topic in particular,


00:30:59.640 --> 00:31:01.780
I ran across an article called


00:31:01.780 --> 00:31:04.760
static duck typing in Python with protocols.


00:31:04.760 --> 00:31:07.660
How's that to like crash two ideas together?


00:31:07.660 --> 00:31:13.280
- Yeah, it's well, and it's,


00:31:13.280 --> 00:31:15.400
well, when we look at data types,


00:31:15.400 --> 00:31:18.680
it's like the way Python even does its data types is,


00:31:18.680 --> 00:31:22.320
Yeah, you can say that you want to say, okay, this is a list


00:31:22.320 --> 00:31:24.220
and you can type it as a list,


00:31:24.220 --> 00:31:28.080
but you can also just actually type it as an iterable


00:31:28.080 --> 00:31:31.360
and basically tell Python what you care about.


00:31:31.360 --> 00:31:33.720
Do you really care that it's a list?


00:31:33.720 --> 00:31:35.360
Probably not.


00:31:35.360 --> 00:31:37.360
You care that it's an iterable


00:31:37.360 --> 00:31:40.360
that you can work with similar to a list?


00:31:40.360 --> 00:31:41.600
And like, how are you gonna use it?


00:31:41.600 --> 00:31:42.640
That's what you ask yourself


00:31:42.640 --> 00:31:45.360
and you base your annotations around that.


00:31:45.360 --> 00:31:48.800
And so you can say, well, like here, measurement-like,


00:31:48.800 --> 00:31:52.440
I want it to be usable as a measurement.


00:31:52.440 --> 00:31:54.320
I don't really care what it is.


00:31:54.320 --> 00:31:56.400
It doesn't need to be this particular type of class.


00:31:56.400 --> 00:31:58.360
And so that's moving from, like we were talking about,


00:31:58.360 --> 00:32:01.400
moving from Java thinking into Python thinking is,


00:32:01.400 --> 00:32:04.840
well, it's not what it is, it's what it does.


00:32:04.840 --> 00:32:09.680
- Yeah, a lot of the types people put down are like,


00:32:09.680 --> 00:32:13.960
I need to treat it like some duck type in situation.


00:32:13.960 --> 00:32:17.480
So it needs to have these attributes about it.


00:32:17.480 --> 00:32:19.680
And so let's try to put that aspect of it


00:32:19.680 --> 00:32:23.440
into the formal static typing rather than earlier.


00:32:23.440 --> 00:32:25.680
Yeah.


00:32:25.680 --> 00:32:27.280
OK.


00:32:27.280 --> 00:32:30.280
Maybe a quick audience question or a bit of feedback


00:32:30.280 --> 00:32:31.960
here before we move on to the next one.


00:32:31.960 --> 00:32:32.800
It's relevant.


00:32:32.800 --> 00:32:34.720
Nick says, early in my Python journey,


00:32:34.720 --> 00:32:36.760
I wish I had gotten a better understanding of all


00:32:36.760 --> 00:32:39.640
the intricacies, differences, and use cases for various data


00:32:39.640 --> 00:32:43.600
structures, like set versus list, right?


00:32:43.600 --> 00:32:44.520
versus dictionary.


00:32:44.520 --> 00:32:46.140
And those are certainly,


00:32:46.140 --> 00:32:49.200
even if you've done programming before,


00:32:49.200 --> 00:32:51.220
maybe that environment language


00:32:51.220 --> 00:32:54.000
didn't deeply embrace these data structures.


00:32:54.000 --> 00:32:56.240
So certainly those are table stakes


00:32:56.240 --> 00:32:57.880
for being good at Python.


00:32:57.880 --> 00:32:59.580
- Yeah, absolutely.


00:32:59.580 --> 00:33:03.560
And use cases sits the nail on the head


00:33:03.560 --> 00:33:05.560
because it's like, what's the difference between them?


00:33:05.560 --> 00:33:07.320
Well, you know, it's a collection.


00:33:07.320 --> 00:33:09.720
And so maybe that's all you care about.


00:33:09.720 --> 00:33:14.720
But I find myself using all of them in different cases


00:33:14.720 --> 00:33:17.760
'cause it's like, all right, I never need to add


00:33:17.760 --> 00:33:20.220
or remove things from it, that's probably a tuple.


00:33:20.220 --> 00:33:24.320
Or I need to be able to hash it, use it as an immutable,


00:33:24.320 --> 00:33:25.160
that's a tuple.


00:33:25.160 --> 00:33:27.300
Or I need to be able to see what's in group A


00:33:27.300 --> 00:33:28.740
and not in group B, that's a set.


00:33:28.740 --> 00:33:31.040
Or I care about the order, that's a list.


00:33:31.040 --> 00:33:32.960
Or I wanna be able to associate two things,


00:33:32.960 --> 00:33:34.660
that's a dictionary.


00:33:34.660 --> 00:33:37.520
So knowing your different data structures is helpful.


00:33:37.520 --> 00:33:40.720
And it's tricky because Python's data structures


00:33:40.720 --> 00:33:42.000
aren't really all that unique,


00:33:42.000 --> 00:33:43.640
but they have different names


00:33:43.640 --> 00:33:45.440
than maybe you're used to in other languages.


00:33:45.440 --> 00:33:48.020
So you come across lists and what is that?


00:33:48.020 --> 00:33:51.760
Well, it's a C++ vector or a JavaScript array.


00:33:51.760 --> 00:33:57.520
Which is where it's helpful to come back to Python


00:33:57.520 --> 00:33:58.520
kind of with a fresh mind.


00:33:58.520 --> 00:34:00.520
It's like, what is this?


00:34:00.520 --> 00:34:02.820
Not assuming that things have the same names,


00:34:02.820 --> 00:34:05.720
but being prepared to get a different vocabulary.


00:34:05.720 --> 00:34:06.840
- Yeah, for sure.


00:34:06.840 --> 00:34:10.260
All right, what's next one?


00:34:10.260 --> 00:34:14.240
Iteration, iterables, iterators living.


00:34:14.240 --> 00:34:17.920
- Yes, yeah.


00:34:17.920 --> 00:34:20.440
I was working in some code last year


00:34:20.440 --> 00:34:22.240
and I came across something that just,


00:34:22.240 --> 00:34:25.120
I was, I cringed and then I laughed out loud


00:34:25.120 --> 00:34:27.660
because this was written,


00:34:27.660 --> 00:34:32.660
so this code was written by who I best guess


00:34:32.660 --> 00:34:34.680
university data scientists.


00:34:34.680 --> 00:34:39.000
So, you know, to their favor, this is not a software engineer.


00:34:39.000 --> 00:34:44.600
Um, and what they, what they had written and they could tell it had been


00:34:44.600 --> 00:34:46.560
a refactored a few times, but I am not kidding.


00:34:46.560 --> 00:34:50.200
They had said, all right, so I have this thing that it's iterable.


00:34:50.200 --> 00:34:52.360
It was already something that we could use in a loop.


00:34:52.360 --> 00:34:54.080
And we'll come back to what that is for anyone who's curious,


00:34:54.080 --> 00:34:55.720
but we have this iterable.


00:34:55.720 --> 00:34:58.400
I'm going to convert that into a list.


00:34:58.400 --> 00:35:02.120
By the way, we're talking about in this case, tens of thousands


00:35:02.120 --> 00:35:03.160
of items in that list.


00:35:03.160 --> 00:35:04.480
I'm going to convert that into a list.


00:35:04.480 --> 00:35:11.960
Then on the next line, they say for index comma value in


00:35:11.960 --> 00:35:14.960
enumerate, enumerate the thing that lets you get the indexes


00:35:14.960 --> 00:35:19.960
as well, enumerate that list. And then it says, you know, and


00:35:19.960 --> 00:35:24.400
then it accessed the value, again, inside the loop by going


00:35:24.400 --> 00:35:26.840
to the original list and accessing using the index.


00:35:26.840 --> 00:35:31.960
And I just sat there and I kind of half laugh half cry.


00:35:33.720 --> 00:35:38.240
there is so much, this is so convoluted. And I, all I had to


00:35:38.240 --> 00:35:42.040
do was take all that logic out and just say for item in


00:35:42.040 --> 00:35:46.600
original iterable, and then item was the thing. And, but what had


00:35:46.600 --> 00:35:48.960
happened was that they didn't understand what was really


00:35:48.960 --> 00:35:52.080
happening in a for loop, they were still thinking C, or C++.


00:35:52.080 --> 00:35:56.000
And the thing is that Python has these two magic methods called


00:35:56.000 --> 00:36:00.200
iter and next. Iter just says, give me the thing I can use that


00:36:00.200 --> 00:36:04.680
has the next operator that knows where it is in the list. I'm


00:36:04.680 --> 00:36:06.880
gonna leave it at that. And the next just says, give me the next


00:36:06.880 --> 00:36:10.760
item. Yeah, that's all it is. Just give me the next item. All


00:36:10.760 --> 00:36:15.080
a for loop ever does is it grabs that is it calls that next is


00:36:15.080 --> 00:36:16.680
like, give me the next thing. All right, good. I'm done. Give


00:36:16.680 --> 00:36:18.160
me the next thing. Give me the next thing. Give me the next


00:36:18.160 --> 00:36:21.240
thing. You can write entire classes that behave like this


00:36:21.240 --> 00:36:26.280
even generate the value at that moment. It's called lazy


00:36:26.280 --> 00:36:29.240
iteration, you can actually generate the next value when


00:36:29.240 --> 00:36:34.440
it's one and not a moment sooner, which means you only ever have one value in memory sometimes.


00:36:34.440 --> 00:36:35.440
Yeah.


00:36:35.440 --> 00:36:38.760
And then you can just put that in the for loop. And you come up with any arbitrary name


00:36:38.760 --> 00:36:44.200
for when you access it for each thing in iterable, name thing, whatever you want, and then use


00:36:44.200 --> 00:36:50.360
it directly in your code. And I wish someone had told me that a lot sooner. I've discovered


00:36:50.360 --> 00:36:53.200
that about three years into my journey. I'm like, Oh my gosh, I've been making lists out


00:36:53.200 --> 00:36:57.000
of everything. And I've been doing waste.


00:36:57.000 --> 00:37:00.540
- Yeah, and you know, the yield keyword,


00:37:00.540 --> 00:37:03.500
obviously is a super easy way to do that lazy iteration


00:37:03.500 --> 00:37:06.220
that you talk about, but it also is really important


00:37:06.220 --> 00:37:08.100
for things like databases, right?


00:37:08.100 --> 00:37:08.940
- Yeah.


00:37:08.940 --> 00:37:09.980
- Talk SQL alchemy, right?


00:37:09.980 --> 00:37:12.460
I'm gonna do a query, I could call the all method


00:37:12.460 --> 00:37:14.180
and turn it into an in-memory list,


00:37:14.180 --> 00:37:15.460
or I could, if I don't need that,


00:37:15.460 --> 00:37:17.100
I could just loop over it, right?


00:37:17.100 --> 00:37:19.180
And kind of read it cursor style,


00:37:19.180 --> 00:37:22.580
potentially stop talking to the database halfway through.


00:37:22.580 --> 00:37:23.420
- Exactly.


00:37:23.420 --> 00:37:24.240
Oh, I found what I needed,


00:37:24.240 --> 00:37:26.340
I don't need the rest of the data, exactly.


00:37:26.340 --> 00:37:27.780
Yeah, exactly.


00:37:27.780 --> 00:37:29.260
Interesting.


00:37:29.260 --> 00:37:31.540
Cool.


00:37:31.540 --> 00:37:35.660
Yeah, I think iteration is quite--


00:37:35.660 --> 00:37:39.660
it's settled, because there's only two types of loops


00:37:39.660 --> 00:37:40.860
in Python.


00:37:40.860 --> 00:37:43.980
And usually, we're using the for loops.


00:37:43.980 --> 00:37:50.180
But the variations, there's just so many of them, right?


00:37:50.180 --> 00:37:52.460
You can have your for loop that just goes over a thing.


00:37:52.460 --> 00:37:54.280
But what if you need the index like you described?


00:37:54.280 --> 00:37:55.400
Not for this improper use.


00:37:55.400 --> 00:37:57.880
but sometimes you actually still do need the index.


00:37:57.880 --> 00:38:01.760
So you could do enumerate of that thing and get a tuple,


00:38:01.760 --> 00:38:03.120
but you could take it to another level,


00:38:03.120 --> 00:38:05.280
do tuple unpacking and say like index,


00:38:05.280 --> 00:38:08.360
comma value in enumerate of things, right?


00:38:08.360 --> 00:38:09.480
And you get it back and you're just-


00:38:09.480 --> 00:38:11.320
- You can unpack a dictionary too.


00:38:11.320 --> 00:38:13.440
You can unpack a tuple with that in the dictionary.


00:38:13.440 --> 00:38:14.680
There's this whole library


00:38:14.680 --> 00:38:17.320
and it built in a Python called iter tools.


00:38:17.320 --> 00:38:20.200
And if you ever have, you know, 10 minutes over coffee,


00:38:20.200 --> 00:38:21.920
just pull up the documentation for iter tools


00:38:21.920 --> 00:38:22.840
and just kind of scroll through.


00:38:22.840 --> 00:38:24.160
There's some neat stuff.


00:38:24.160 --> 00:38:28.360
like you can, you can like, find every possible combination of


00:38:28.360 --> 00:38:31.000
three different lists. I just give it three different lists.


00:38:31.000 --> 00:38:32.720
And this is one that will take all three of them just give you


00:38:32.720 --> 00:38:35.520
every single possible combination of it actually use


00:38:35.520 --> 00:38:38.400
it in the book. And it's just there's all these neat things


00:38:38.400 --> 00:38:40.520
you can do with iterables. And some of them don't even have to


00:38:40.520 --> 00:38:43.080
stop there are infinite variables where you can just say


00:38:43.080 --> 00:38:49.040
I want to get this sequence repeating infinitely 123123123123123123.


00:38:49.040 --> 00:38:52.360
And two lines of code and you can have that repeating forever.


00:38:52.520 --> 00:38:54.880
And if you're using an old fashioned while loop


00:38:54.880 --> 00:38:57.280
or an old fashioned C++ style for loop,


00:38:57.280 --> 00:38:58.600
that would be multiple lines of code.


00:38:58.600 --> 00:39:00.440
Like, you don't have to keep track of the state


00:39:00.440 --> 00:39:02.000
and all that stuff.


00:39:02.000 --> 00:39:03.100
Python is two lines.


00:39:03.100 --> 00:39:05.760
- Yeah, it's amazing.


00:39:05.760 --> 00:39:07.400
Yeah, so there's a lot of depth,


00:39:07.400 --> 00:39:10.160
even though it seems so simple when you first look at it.


00:39:10.160 --> 00:39:14.720
Closely related to that are comprehensions.


00:39:14.720 --> 00:39:15.560
- Yes.


00:39:15.560 --> 00:39:17.260
- Like a list comprehension, right?


00:39:19.780 --> 00:39:22.820
People often see a list comprehension


00:39:22.820 --> 00:39:25.100
or a set comprehension and go, especially


00:39:25.100 --> 00:39:27.020
a list comprehension, they're like, oh, that's


00:39:27.020 --> 00:39:29.140
the same thing as a for loop.


00:39:29.140 --> 00:39:30.620
Before the for loop, I create a list.


00:39:30.620 --> 00:39:33.060
And then in the for loop, I add the thing to the list.


00:39:33.060 --> 00:39:35.020
And these are the same.


00:39:35.020 --> 00:39:38.260
They may have the same outcome, but they're not actually


00:39:38.260 --> 00:39:39.020
the same thing.


00:39:39.020 --> 00:39:41.940
The runtime performance is not the same.


00:39:41.940 --> 00:39:44.300
The bytecode implementation of those two things


00:39:44.300 --> 00:39:45.420
is not the same.


00:39:45.420 --> 00:39:47.860
This is like a nonstop debate I have on YouTube


00:39:47.860 --> 00:39:49.540
whenever I put a video and mention something


00:39:49.540 --> 00:39:50.700
about list comprehensions.


00:39:50.700 --> 00:39:52.240
They're like, that's just a for loop.


00:39:52.240 --> 00:39:53.980
It's not actually just a for loop.


00:39:53.980 --> 00:39:57.140
It's like a kind of accomplishing the same thing.


00:39:57.140 --> 00:40:00.540
But we now have for potentially 3.12,


00:40:00.540 --> 00:40:04.940
Carl Meyer put out a PEP 709


00:40:04.940 --> 00:40:07.820
called inlined list comprehensions,


00:40:07.820 --> 00:40:10.700
which are supposed to take some of the


00:40:10.700 --> 00:40:14.100
mostly invisible behind the scene implementation


00:40:14.100 --> 00:40:16.940
and make comprehensions two times faster.


00:40:16.940 --> 00:40:19.540
I believe they're already faster than this looping story


00:40:19.540 --> 00:40:21.980
I talked about, but this would make them faster still,


00:40:21.980 --> 00:40:23.860
which is pretty cool.


00:40:23.860 --> 00:40:25.120
Yeah.


00:40:25.120 --> 00:40:27.500
- Wow. How does this syntax work?


00:40:27.500 --> 00:40:28.340
I'm curious.


00:40:28.340 --> 00:40:29.160
Is this just like-


00:40:29.160 --> 00:40:30.620
- So the syntax is unchanged.


00:40:30.620 --> 00:40:33.560
Yeah. So here's the magic of list comprehensions.


00:40:33.560 --> 00:40:35.540
That's funky that people maybe aren't aware of.


00:40:35.540 --> 00:40:38.860
Is it, it used to actually create a list comprehension


00:40:38.860 --> 00:40:43.060
object that implemented the loop in a function.


00:40:43.060 --> 00:40:44.660
And then it called that function


00:40:44.660 --> 00:40:48.500
as if you'd nested a function to create the isolation


00:40:48.500 --> 00:40:49.700
of the list comprehension.


00:40:49.700 --> 00:40:52.620
So that created a stack frame, that created an object,


00:40:52.620 --> 00:40:55.620
then it did function in direction,


00:40:55.620 --> 00:40:57.740
and all those things made it slower than it needs to be.


00:40:57.740 --> 00:41:01.820
So now they create a new load fast


00:41:01.820 --> 00:41:03.460
and clear byte code operation


00:41:03.460 --> 00:41:05.540
that stores the state of the function,


00:41:05.540 --> 00:41:09.940
then does the list comprehension,


00:41:09.940 --> 00:41:12.900
and then pops it back off the stack to unwind it.


00:41:12.900 --> 00:41:15.380
So anyway, comprehensions are interesting.


00:41:15.380 --> 00:41:17.460
I just wanted to, this is like kind of a brand new thing


00:41:17.460 --> 00:41:18.380
- That's cool.


00:41:18.380 --> 00:41:21.540
- That's coming along that might be interesting for people.


00:41:21.540 --> 00:41:23.840
- Well, I think it's worth mentioning then


00:41:23.840 --> 00:41:26.140
that what a list comprehension really is.


00:41:26.140 --> 00:41:28.180
So like if I unpack it, 'cause people think,


00:41:28.180 --> 00:41:30.980
people use that term very loosely a lot of times,


00:41:30.980 --> 00:41:32.020
they say, "Well, it's a list comprehension."


00:41:32.020 --> 00:41:34.560
But what is a list comprehension?


00:41:34.560 --> 00:41:37.820
And if I unpack that, what it really is,


00:41:37.820 --> 00:41:42.820
is it is a generator expression


00:41:42.820 --> 00:41:45.980
that is being unpacked into a list.


00:41:45.980 --> 00:41:47.580
So what's a generator expression?


00:41:47.580 --> 00:41:49.380
A generator expression is a type of generator.


00:41:49.380 --> 00:41:50.820
What's a generator?


00:41:50.820 --> 00:41:55.140
A generator is a function or type of function


00:41:55.140 --> 00:41:57.660
that is itself iterable.


00:41:57.660 --> 00:42:02.260
So that's where this is critical,


00:42:02.260 --> 00:42:07.260
is that a generator, you can write a generator


00:42:07.260 --> 00:42:09.980
that when you call it,


00:42:09.980 --> 00:42:12.220
you mentioned that earlier, this yield keyword.


00:42:12.220 --> 00:42:15.720
And so you can do whatever you want in this function.


00:42:15.720 --> 00:42:17.960
You can write it however much logic you want.


00:42:17.960 --> 00:42:21.920
Every time you hit the yield statement, it will return that value,


00:42:21.920 --> 00:42:23.600
and then it's going to wait for the next call,


00:42:23.600 --> 00:42:28.160
the next iteration of it, like the next call to next on that generator.


00:42:28.160 --> 00:42:30.560
And then it's going to run through again until it hits a yield.


00:42:30.560 --> 00:42:33.800
And then it's going to stop, return that value, and wait again.


00:42:33.800 --> 00:42:36.600
And you can do some incredible things with these.


00:42:36.600 --> 00:42:42.300
But once you understand the generator, which are incredibly powerful tools,


00:42:42.300 --> 00:42:47.600
then you can write a generator expression, which is, I discovered later,


00:42:47.600 --> 00:42:51.200
a generator expression is to a generator as a lambda is to a function.


00:42:51.200 --> 00:42:53.400
It's an anonymous generator.


00:42:53.400 --> 00:42:55.500
That's all it is.


00:42:55.500 --> 00:43:00.700
So a lambda is just a very small inline anonymous function.


00:43:00.700 --> 00:43:04.000
It has the logic, it can take in some values, return some values.


00:43:04.000 --> 00:43:05.900
It's a lot simpler, a lot shorter.


00:43:06.400 --> 00:43:07.800
and you do it right in place.


00:43:07.800 --> 00:43:11.000
So you're not having to go off somewhere and write a different function and come back.


00:43:11.000 --> 00:43:14.700
That's why we have anonymous functions, so that we can just do it like,


00:43:14.700 --> 00:43:18.700
like you see there at the bottom, reduce and just some rules right there,


00:43:18.700 --> 00:43:20.200
instead of writing a separate function.


00:43:20.200 --> 00:43:22.100
GenerateExpression, same sort of thing.


00:43:22.100 --> 00:43:24.800
We're writing some generator logic.


00:43:24.800 --> 00:43:25.900
It's shorter.


00:43:25.900 --> 00:43:30.400
It's creating a generator, but it's just a lot smaller.


00:43:30.400 --> 00:43:34.200
And if you just wrap it in parentheses, you can use it as a generator.


00:43:35.300 --> 00:43:40.660
But when you change those parentheses to be square brackets, what happens is you're running that generator,


00:43:40.660 --> 00:43:44.140
and then you're loading all the values into the list.


00:43:44.140 --> 00:43:52.420
If you do it in curly braces, you're creating a set, or if you're doing the same thing, but you are...


00:43:52.420 --> 00:43:57.340
the return value in each step is a key value pair, then you're going to create a dictionary.


00:43:57.340 --> 00:44:01.460
But all you're really doing is unpacking that generator into a data structure.


00:44:01.980 --> 00:44:13.060
So sometimes you want to think when you're mucking about with these, do you really want the data structure when you're done? Or do you just want to go over the values? Because maybe you could generate a generator expression?


00:44:13.060 --> 00:44:30.860
Yeah, the difference is super subtle. Like you have square brackets, or do you have parentheses around the expression, but the effect or consequence of that is very significant at runtime, right? It's kind of like that example, you talked about putting everything in a list and looping over it or just looping over it, right?


00:44:31.740 --> 00:44:35.040
Exactly. And because these are these are these one liners and


00:44:35.040 --> 00:44:37.220
we as coders tend to get addicted to these one liners,


00:44:37.220 --> 00:44:39.660
it's like, Oh, look at all the cool things I could do. I have a


00:44:39.660 --> 00:44:42.300
couple examples in the book, some real list comprehensions


00:44:42.300 --> 00:44:44.660
I've come across, or some colleagues that might have come


00:44:44.660 --> 00:44:48.820
across where it's like, it's multiple lines. And that's,


00:44:48.820 --> 00:44:51.820
that's a bad list comprehension. That's a bad generator


00:44:51.820 --> 00:44:54.380
expression, just like you don't want to have a multi line lambda


00:44:54.380 --> 00:44:59.460
at that point, write a function. generator expressions and


00:44:59.460 --> 00:45:01.580
and lambdas are supposed to be these really small,


00:45:01.580 --> 00:45:03.580
short in place bits of logic.


00:45:03.580 --> 00:45:06.100
And if it's getting complicated,


00:45:06.100 --> 00:45:07.500
write the full size thing.


00:45:07.500 --> 00:45:09.140
It's a lot easier to debug.


00:45:09.140 --> 00:45:10.980
If nothing else is easy to debug,


00:45:10.980 --> 00:45:13.100
but it's also a lot easier to read.


00:45:13.100 --> 00:45:14.940
- It is, it is.


00:45:14.940 --> 00:45:18.520
Just while we're kind of ranting on these things,


00:45:18.520 --> 00:45:21.780
like I wish there was a way to specify a sort


00:45:21.780 --> 00:45:26.500
in these list comprehensions,


00:45:26.500 --> 00:45:29.620
generator expressions and maybe not the generators


00:45:29.620 --> 00:45:30.440
'cause that gets tricky.


00:45:30.440 --> 00:45:33.860
But so often I find myself, I'm doing a list comprehension


00:45:33.860 --> 00:45:35.820
and then I got to turn around and sort it.


00:45:35.820 --> 00:45:37.740
Like if it could just add that in there


00:45:37.740 --> 00:45:40.040
that would make me happy, but all right.


00:45:40.040 --> 00:45:45.040
Moving on, packaging, deciding on packaging


00:45:45.040 --> 00:45:46.780
and all that right up front.


00:45:46.780 --> 00:45:49.240
Actually, before we get to that, I guess the other one


00:45:49.240 --> 00:45:51.420
that you threw in here is virtual environments.


00:45:51.420 --> 00:45:52.260
Indeed. - Yeah.


00:45:52.260 --> 00:45:55.720
Virtual environments, use them.


00:45:55.720 --> 00:45:58.400
I avoided them for years because I thought,


00:45:58.400 --> 00:46:00.680
oh, these are scary, I don't understand them.


00:46:00.680 --> 00:46:01.920
They're not scary.


00:46:01.920 --> 00:46:04.400
I'm actually gonna hijack something I learned


00:46:04.400 --> 00:46:08.120
from one of my guests on my own podcast recently


00:46:08.120 --> 00:46:11.200
is what containers actually are, by the way.


00:46:11.200 --> 00:46:13.440
Docker containers, I swear this is relevant.


00:46:13.440 --> 00:46:15.520
You know what a Docker container actually is?


00:46:15.520 --> 00:46:17.640
Is it's the folder on your operating system.


00:46:17.640 --> 00:46:19.620
And it's just changing the root.


00:46:19.620 --> 00:46:20.460
So when you're working inside of it,


00:46:20.460 --> 00:46:22.480
it's just changing the root.


00:46:22.480 --> 00:46:24.280
There's a bunch of magic logic around that,


00:46:24.280 --> 00:46:25.120
but that's all it is.


00:46:25.120 --> 00:46:29.120
like it's pretending that that that that folder is the root,


00:46:29.120 --> 00:46:31.640
and it's running things accordingly. That's all a


00:46:31.640 --> 00:46:34.320
virtual environment really is doing either. So there's not a


00:46:34.320 --> 00:46:37.800
lot of Python about the path. Yeah, yeah, there's not a lot of


00:46:37.800 --> 00:46:39.600
difference in a virtual environment in the Docker image,


00:46:39.600 --> 00:46:42.840
like they're the same fundamental concept. So all


00:46:42.840 --> 00:46:45.360
you're doing is you're creating this little spot on your this


00:46:45.360 --> 00:46:48.960
little folder. And you're saying these are my Python packages.


00:46:48.960 --> 00:46:51.800
And unless you tell it otherwise, don't go looking


00:46:51.800 --> 00:46:57.720
anywhere else. These are the ones I want to use. And they're super easy to create. It's


00:46:57.720 --> 00:47:02.360
like one line to create a virtual environment. And it lets you maintain exactly the packages


00:47:02.360 --> 00:47:07.560
you want for that particular situation. And it's great.


00:47:07.560 --> 00:47:13.960
>> It is. Yeah. It's -- once you get used to it, it's great. I remember it being frustrating at


00:47:13.960 --> 00:47:18.040
the beginning. You're like, ah, I don't remember exactly how do I create the environment? How do


00:47:18.040 --> 00:47:18.940
How do I activate it?


00:47:18.940 --> 00:47:20.000
How do I know?


00:47:20.000 --> 00:47:21.420
Do I really need this?


00:47:21.420 --> 00:47:24.000
And yeah, I don't start any projects


00:47:24.000 --> 00:47:27.660
without having them as just straight up,


00:47:27.660 --> 00:47:29.660
using them right away.


00:47:29.660 --> 00:47:31.080
Like, absolutely.


00:47:31.080 --> 00:47:31.920
- Yeah.


00:47:31.920 --> 00:47:33.080
- I probably created for projects


00:47:33.080 --> 00:47:34.560
that don't even have external dependencies


00:47:34.560 --> 00:47:36.160
'cause I was just like on autopilot.


00:47:36.160 --> 00:47:37.160
Like, oh, actually I didn't need that,


00:47:37.160 --> 00:47:38.560
but whatever, it's still good to have.


00:47:38.560 --> 00:47:39.400
- Yeah, absolutely.


00:47:39.400 --> 00:47:41.720
It's to control which Python version you're using


00:47:41.720 --> 00:47:43.720
and then you can install whatever packages you want


00:47:43.720 --> 00:47:45.680
and you don't not worry about messing up your system


00:47:45.680 --> 00:47:48.080
for user scope packages.


00:47:48.080 --> 00:47:49.800
And a coworker recently said,


00:47:49.800 --> 00:47:52.040
"I dream of the day when I can actually remember


00:47:52.040 --> 00:47:53.080
"how to activate this."


00:47:53.080 --> 00:47:55.200
But it's actually really easy.


00:47:55.200 --> 00:47:59.440
So assuming you know the name of the folder,


00:47:59.440 --> 00:48:01.040
'cause you can pick the name of the folder


00:48:01.040 --> 00:48:02.640
you use for your virtual environment.


00:48:02.640 --> 00:48:05.040
Traditionally it's called like them, V-E-N-V.


00:48:05.040 --> 00:48:08.840
And here's the thing to remember,


00:48:08.840 --> 00:48:10.240
you don't actually have to activate


00:48:10.240 --> 00:48:11.360
your virtual environment.


00:48:11.360 --> 00:48:12.680
Put that in your mind for a moment.


00:48:12.680 --> 00:48:15.760
you can run things directly in the virtual environment.


00:48:15.760 --> 00:48:20.280
So in Unix systems like Linux and Mac, there's a bin folder.


00:48:20.280 --> 00:48:24.280
So vim/bin/ and then whatever Python,


00:48:24.280 --> 00:48:26.200
whatever Python executable you wanna run.


00:48:26.200 --> 00:48:27.400
It could be Python, it could be pip,


00:48:27.400 --> 00:48:29.640
it could be your own package.


00:48:29.640 --> 00:48:32.760
You can actually just navigate into that bin folder.


00:48:32.760 --> 00:48:36.240
And so I can say vim/bin/pip, and I've got the pip,


00:48:36.240 --> 00:48:40.000
and that knows to only work within its virtual environment.


00:48:40.000 --> 00:48:42.020
It's not gonna break out of that container.


00:48:42.020 --> 00:48:43.620
Once you understand that,


00:48:43.620 --> 00:48:47.060
here's where the activate script is, then bin activate.


00:48:47.060 --> 00:48:49.860
It lives in the bin file.


00:48:49.860 --> 00:48:52.060
And if you're on Windows,


00:48:52.060 --> 00:48:55.060
the only thing you're changing is you're going from bin


00:48:55.060 --> 00:48:57.020
to capital S scripts.


00:48:57.020 --> 00:49:00.060
And then the things have an ending of like either .bat


00:49:00.060 --> 00:49:04.220
or .ps1 depending on what shell you're using.


00:49:04.220 --> 00:49:07.340
But that's the structure of a virtual environment.


00:49:07.340 --> 00:49:10.020
And once you understand that, they're no longer scary.


00:49:10.020 --> 00:49:10.840
- Yeah.


00:49:10.840 --> 00:49:15.840
My RC file for my user profile on my Mac


00:49:15.840 --> 00:49:21.160
is just full of, here's the Python executable


00:49:21.160 --> 00:49:23.200
in some virtual environment, and here's the script


00:49:23.200 --> 00:49:26.460
and commands to send to it for little aliases and stuff.


00:49:26.460 --> 00:49:28.580
And none of those activate the virtual environments.


00:49:28.580 --> 00:49:31.620
They just run the Python in the virtual environment


00:49:31.620 --> 00:49:33.540
to make all the magic happen.


00:49:33.540 --> 00:49:37.480
Another thing I would recommend is people think about


00:49:38.880 --> 00:49:41.600
creating aliases that make virtual environments


00:49:41.600 --> 00:49:43.400
happier and easier to use.


00:49:43.400 --> 00:49:46.240
So for example, and you could do this in PowerShell


00:49:46.240 --> 00:49:48.640
on Windows, you can obviously do it near RcFiles


00:49:48.640 --> 00:49:50.080
on Mac and Linux.


00:49:50.080 --> 00:49:54.040
So for example, I have venv, which is for V-E-N-V,


00:49:54.040 --> 00:49:56.680
but I don't want it to accidentally change the directory


00:49:56.680 --> 00:49:58.520
and if you haven't, like whatever.


00:49:58.520 --> 00:49:59.640
I just have a short version,


00:49:59.640 --> 00:50:01.080
so I know it's something slightly different,


00:50:01.080 --> 00:50:02.880
but it'll go run the virtual environment


00:50:02.880 --> 00:50:06.520
and it'll always remember to add --prompt=."


00:50:06.520 --> 00:50:08.320
which will make the virtual environment


00:50:08.320 --> 00:50:09.860
not just be called V-E-N-V,


00:50:09.860 --> 00:50:13.180
but it'll be called the name of the project that it's in.


00:50:13.180 --> 00:50:15.460
So for example, if it's in like,


00:50:15.460 --> 00:50:17.540
talk Python, like the virtual environment,


00:50:17.540 --> 00:50:18.380
when I activate it,


00:50:18.380 --> 00:50:20.100
it will say it's the virtual environment, talk Python.


00:50:20.100 --> 00:50:21.020
Right?


00:50:21.020 --> 00:50:22.420
And then it activates it.


00:50:22.420 --> 00:50:24.220
And then I think,


00:50:24.220 --> 00:50:26.140
I think this is almost a bug in Python


00:50:26.140 --> 00:50:28.680
that most of the time,


00:50:28.680 --> 00:50:32.100
I would say like 49 weeks out of the year,


00:50:32.100 --> 00:50:33.420
when I create a virtual environment,


00:50:33.420 --> 00:50:34.980
the first thing I hear is warning,


00:50:34.980 --> 00:50:36.180
your pip is out of date.


00:50:37.460 --> 00:50:40.780
You know, like, okay, well, I'm starting a new project.


00:50:40.780 --> 00:50:42.100
How about we start with a new one?


00:50:42.100 --> 00:50:44.020
Let's just go with that right now, right?


00:50:44.020 --> 00:50:47.940
And so why, I just, that is, I always want the new one.


00:50:47.940 --> 00:50:50.500
I don't ever want the old one because this is a brand new.


00:50:50.500 --> 00:50:51.560
So I want the new one.


00:50:51.560 --> 00:50:53.500
Why don't we fix that?


00:50:53.500 --> 00:50:58.500
So my alias then says pip install -u pip setup tools, wheels,


00:50:58.500 --> 00:51:01.820
pip tools, et cetera, and just ditches that output.


00:51:01.820 --> 00:51:03.620
So like, yeah, right.


00:51:03.620 --> 00:51:04.900
Immediately, like I have,


00:51:04.900 --> 00:51:05.900
when I create a virtual environment,


00:51:05.900 --> 00:51:08.860
it's immediately active and it's immediately named the project


00:51:08.860 --> 00:51:11.340
and it's immediately up to date.


00:51:11.340 --> 00:51:13.900
So I don't see those silly warnings, at least for a while.


00:51:13.900 --> 00:51:17.300
And all I got to remember is type VNV, boom, and that's it.


00:51:17.300 --> 00:51:18.420
So if you get into this--


00:51:18.420 --> 00:51:19.900
if you just do a few little steps--


00:51:19.900 --> 00:51:20.900
I did this too.


00:51:20.900 --> 00:51:21.420
Yeah.


00:51:21.420 --> 00:51:22.780
Yeah, yeah, I imagine you did.


00:51:22.780 --> 00:51:27.180
And so I just strongly encourage people


00:51:27.180 --> 00:51:29.180
to somehow either do this in PowerShell


00:51:29.180 --> 00:51:30.820
or do this in their terminal setup,


00:51:30.820 --> 00:51:34.980
because that big, long thing to type, that's a hassle.


00:51:34.980 --> 00:51:37.020
Three letters is not a hassle.


00:51:37.020 --> 00:51:38.080
And it just makes it,


00:51:38.080 --> 00:51:40.400
there's something about lowering the friction


00:51:40.400 --> 00:51:41.940
that makes it really nice.


00:51:41.940 --> 00:51:43.800
- And there's tools you can also install that do it,


00:51:43.800 --> 00:51:46.140
but like I recommend just writing your own aliases too,


00:51:46.140 --> 00:51:48.060
because everyone's got a slightly different workflow


00:51:48.060 --> 00:51:49.460
and set of preferences anyway.


00:51:49.460 --> 00:51:51.420
That's why VIMP has so many options.


00:51:51.420 --> 00:51:55.340
So writing this yourself, it's super easy


00:51:55.340 --> 00:51:58.220
and it teaches you a bit about how it's working


00:51:58.220 --> 00:52:01.360
so that you're not surprised at the results.


00:52:01.360 --> 00:52:02.500
- Yeah, yeah.


00:52:02.500 --> 00:52:04.420
Indeed.


00:52:04.420 --> 00:52:06.780
Okay, now packaging.


00:52:06.780 --> 00:52:10.380
- Yes, and I'm gonna keep this one super short


00:52:10.380 --> 00:52:12.740
because it's a deep, deep, deep, deep, deep, deep,


00:52:12.740 --> 00:52:13.940
deep, deep rabbit hole.


00:52:13.940 --> 00:52:15.980
Figure out your packaging day one.


00:52:15.980 --> 00:52:18.460
Like you get, I will figure out packaging


00:52:18.460 --> 00:52:20.220
before I even figure out what I'm, you know,


00:52:20.220 --> 00:52:22.020
how I'm building stuff.


00:52:22.020 --> 00:52:26.520
I am just gonna set up a basic hello world


00:52:26.520 --> 00:52:28.700
and then I'm gonna get the packaging working


00:52:28.700 --> 00:52:31.640
because I actually, and I learned this the hard way.


00:52:31.640 --> 00:52:33.080
I built a project once.


00:52:33.080 --> 00:52:34.640
It took me one month.


00:52:34.640 --> 00:52:35.840
I was very happy with it.


00:52:35.840 --> 00:52:36.680
It was gorgeous.


00:52:36.680 --> 00:52:37.500
It was a game.


00:52:37.500 --> 00:52:39.800
You can actually find it online now.


00:52:39.800 --> 00:52:42.060
I was very happy with myself.


00:52:42.060 --> 00:52:43.160
And then I spent the next two years


00:52:43.160 --> 00:52:45.320
trying to package the darn thing.


00:52:45.320 --> 00:52:47.160
Turned out it was impossible to package


00:52:47.160 --> 00:52:48.320
because of certain assumptions


00:52:48.320 --> 00:52:50.360
that one of the libraries I was using made.


00:52:50.360 --> 00:52:52.100
Had I actually tried to package it from the beginning,


00:52:52.100 --> 00:52:53.720
I could have saved myself a heck of a lot of time


00:52:53.720 --> 00:52:55.340
and just used a different library.


00:52:55.340 --> 00:52:56.180
- Yeah.


00:52:56.180 --> 00:52:59.120
- So you figure it out from day one.


00:52:59.120 --> 00:53:02.240
And then the benefit you get to this is that


00:53:02.240 --> 00:53:04.600
then you are constantly,


00:53:04.600 --> 00:53:06.000
especially if you're doing out of place testing,


00:53:06.000 --> 00:53:08.640
which I strongly recommend, run your tests.


00:53:08.640 --> 00:53:10.840
Your tests should not be in your source holder.


00:53:10.840 --> 00:53:12.240
Put them separate.


00:53:12.240 --> 00:53:15.200
That's gonna force you to actually install your package


00:53:15.200 --> 00:53:16.220
into a virtual environment


00:53:16.220 --> 00:53:18.520
and then run the test against that package.


00:53:18.520 --> 00:53:19.920
This is not as scary as it sounds.


00:53:19.920 --> 00:53:21.160
I have a whole, by the way,


00:53:21.160 --> 00:53:23.280
if you go to my website, codemouse92.com,


00:53:23.280 --> 00:53:24.400
I've got a whole talk on this


00:53:24.400 --> 00:53:26.180
called "Escaping the Cardinal Cult."


00:53:26.180 --> 00:53:28.560
And I explain how these patterns work.


00:53:28.560 --> 00:53:31.760
But when you do it that way,


00:53:31.760 --> 00:53:33.800
That means from day one and ever onward,


00:53:33.800 --> 00:53:35.160
you are testing your packaging,


00:53:35.160 --> 00:53:36.920
you're testing your assumptions


00:53:36.920 --> 00:53:40.000
about the working directories and all that,


00:53:40.000 --> 00:53:42.520
and you are testing it in the same way


00:53:42.520 --> 00:53:45.000
that it's gonna be used on someone else's computer.


00:53:45.000 --> 00:53:47.160
So you never again have to have the thing of,


00:53:47.160 --> 00:53:49.040
well, it works on my machine,


00:53:49.040 --> 00:53:53.400
because all of your tests are depending


00:53:53.400 --> 00:53:55.580
on actually installing your package.


00:53:55.580 --> 00:53:58.560
So if something breaks, you bring in a dependency


00:53:58.560 --> 00:54:00.900
that just doesn't work with your packaging scheme,


00:54:00.900 --> 00:54:04.160
you know right away and you can make a decision about it.


00:54:04.160 --> 00:54:06.500
- Yeah, that's good advice.


00:54:06.500 --> 00:54:08.140
There's a lot of depth to the packaging thing.


00:54:08.140 --> 00:54:09.740
I had a whole panel on it.


00:54:09.740 --> 00:54:11.740
We're on talk Python not long ago.


00:54:11.740 --> 00:54:13.500
Definitely a lot there.


00:54:13.500 --> 00:54:14.340
- Oh yeah.


00:54:14.340 --> 00:54:15.500
Deep rabbit hole, but you know what?


00:54:15.500 --> 00:54:18.500
Don't copy pasta, don't copy paste.


00:54:18.500 --> 00:54:21.300
Find out what the things you're using are doing because.


00:54:21.300 --> 00:54:23.260
- Yeah.


00:54:23.260 --> 00:54:26.540
All right.


00:54:26.540 --> 00:54:27.980
Last one.


00:54:27.980 --> 00:54:29.580
- Yeah. - Concurrency.


00:54:29.580 --> 00:54:34.020
Concurrency, yes, which for years I heard concurrency,


00:54:34.020 --> 00:54:37.060
asynchrony, threading, parallelism, multiprocessing,


00:54:37.060 --> 00:54:40.600
I heard those all used as synonyms for one another.


00:54:40.600 --> 00:54:41.440
They're not.


00:54:41.440 --> 00:54:42.940
(laughs)


00:54:42.940 --> 00:54:46.040
Completely different things.


00:54:46.040 --> 00:54:49.380
So, and actually I have to thank the Go language


00:54:49.380 --> 00:54:51.260
for teaching me this.


00:54:51.260 --> 00:54:53.280
Thank you, Rob Pike for his talk.


00:54:53.280 --> 00:54:57.060
Concurrency and parallelism are not the same thing.


00:54:57.060 --> 00:54:58.680
But here's the thing to understand.


00:54:58.680 --> 00:55:03.320
concurrency is doing, you're switching between tasks.


00:55:03.320 --> 00:55:05.460
You're checking your phone and you're talking to your friend.


00:55:05.460 --> 00:55:07.000
Are you doing both at once?


00:55:07.000 --> 00:55:10.040
No, you're not reading stuff on Twitter


00:55:10.040 --> 00:55:11.760
and listening to what your friend says.


00:55:11.760 --> 00:55:16.200
You're actually switching between the two contexts rapidly.


00:55:16.200 --> 00:55:17.500
You're not really multitasking,


00:55:17.500 --> 00:55:19.720
you're just changing your focus fast enough


00:55:19.720 --> 00:55:21.720
that no one ever notices the difference.


00:55:21.720 --> 00:55:25.400
That's concurrency.


00:55:25.400 --> 00:55:29.660
So you have one CPU or potentially multiple


00:55:29.660 --> 00:55:31.300
are involved in this where people get confused.


00:55:31.300 --> 00:55:33.040
Python's nice because you're locked


00:55:33.040 --> 00:55:35.120
to one CPU for concurrency.


00:55:35.120 --> 00:55:38.320
So it's, I'm gonna work on this, then I'll work on this,


00:55:38.320 --> 00:55:39.680
then I'll work on this, then I'll work on this.


00:55:39.680 --> 00:55:41.900
It doesn't make your code faster.


00:55:41.900 --> 00:55:43.240
It'll never make your code faster.


00:55:43.240 --> 00:55:44.800
Just like multitasking will not make you get


00:55:44.800 --> 00:55:46.500
through your workday faster.


00:55:46.500 --> 00:55:48.700
What it's gonna do is it's gonna slow you down,


00:55:48.700 --> 00:55:53.280
but it doesn't look like, in some cases,


00:55:53.280 --> 00:55:55.020
it'll make your code look faster


00:55:55.020 --> 00:55:57.680
because while you're waiting on the user to type in their answer,


00:55:57.680 --> 00:55:59.260
this example I use in the book,


00:55:59.260 --> 00:56:02.100
while you're waiting on the user to type in their answer to a question,


00:56:02.100 --> 00:56:04.060
you're doing some math in the background.


00:56:04.060 --> 00:56:07.320
You're I/O blocked, you're waiting on something over which you have no control,


00:56:07.320 --> 00:56:09.480
you can do some other work while you wait.


00:56:09.480 --> 00:56:11.320
That's concurrency.


00:56:11.320 --> 00:56:15.020
And you can do that with asynchrony where Python's handling that multitasking,


00:56:15.020 --> 00:56:20.020
or you can do it with threading where the operating system is handling that multitasking.


00:56:20.020 --> 00:56:22.160
That's different than parallelism,


00:56:22.160 --> 00:56:25.040
which is where you're actually using different CPU cores


00:56:25.040 --> 00:56:28.580
and you're doing two things at the same time.


00:56:28.580 --> 00:56:30.400
Because you have two different CPUs,


00:56:30.400 --> 00:56:33.860
two different cores working in parallel


00:56:33.860 --> 00:56:35.520
and they're not depending on one another.


00:56:35.520 --> 00:56:36.360
They're not weighted,


00:56:36.360 --> 00:56:39.720
so you're doing multiple tasks at once.


00:56:39.720 --> 00:56:41.300
Both of them have overhead.


00:56:41.300 --> 00:56:43.240
Neither one is a silver bullet for performance.


00:56:43.240 --> 00:56:44.960
You're really gonna have to think a lot about it,


00:56:44.960 --> 00:56:47.840
but I actually like the GIL for this reason.


00:56:47.840 --> 00:56:48.840
Global Interpreter Lock,


00:56:48.840 --> 00:56:53.340
a much aligned thing that stops us from getting free multiprocess,


00:56:53.340 --> 00:56:56.640
free parallelism, free multiprocessing with every thread.


00:56:56.640 --> 00:57:00.740
Because this forces us to actually stop and think,


00:57:00.740 --> 00:57:02.340
which thing do I need?


00:57:02.340 --> 00:57:05.340
Do I need concurrency or do I need parallelism?


00:57:05.340 --> 00:57:08.440
Because you can get both in Python,


00:57:08.440 --> 00:57:11.740
but the GIL makes sure that you have to make a decision.


00:57:11.740 --> 00:57:14.140
Because if you want multiprocessing,


00:57:14.140 --> 00:57:15.940
you're going to have to create different processes,


00:57:15.940 --> 00:57:17.740
spin them off, manage them separately.


00:57:18.740 --> 00:57:21.820
There's more overhead, but you're gonna have to address


00:57:21.820 --> 00:57:23.940
all of those things of how do we share resources,


00:57:23.940 --> 00:57:26.300
which is a really snarly topic.


00:57:26.300 --> 00:57:28.060
And Python doesn't let you pretend


00:57:28.060 --> 00:57:29.300
that that's not gonna be an issue.


00:57:29.300 --> 00:57:31.300
It makes you think about that.


00:57:31.300 --> 00:57:34.080
- It does make you think about it.


00:57:34.080 --> 00:57:38.580
While you can't get more done,


00:57:38.580 --> 00:57:40.680
you can't make an individual thing go faster


00:57:40.680 --> 00:57:43.660
by using concurrency on it.


00:57:43.660 --> 00:57:46.100
You can start a bunch of things that run


00:57:46.100 --> 00:57:49.220
outside of your control and outside of your program,


00:57:49.220 --> 00:57:50.220
and then get them back, right?


00:57:50.220 --> 00:57:53.800
Like I could issue a web request to three API endpoints,


00:57:53.800 --> 00:57:57.020
all of them, and then start gathering up the answers


00:57:57.020 --> 00:57:59.420
if the first one comes back, right?


00:57:59.420 --> 00:58:00.740
You have to think about,


00:58:00.740 --> 00:58:03.460
I think the main thing to think about here is


00:58:03.460 --> 00:58:06.420
where am I waiting on something else


00:58:06.420 --> 00:58:09.820
when you're looking for the async and await type of benefits?


00:58:09.820 --> 00:58:12.020
Like am I waiting on a thing?


00:58:12.020 --> 00:58:13.900
Could I be doing something while I'm waiting?


00:58:13.900 --> 00:58:16.360
an async and await amount, it makes it super easy


00:58:16.360 --> 00:58:19.340
to do stuff while you're waiting.


00:58:19.340 --> 00:58:22.380
But the program itself is still constrained by the GIL.


00:58:22.380 --> 00:58:24.420
And often with async and await,


00:58:24.420 --> 00:58:27.880
there's not even a second thread involved, right?


00:58:27.880 --> 00:58:31.140
It's just slicing up, time slicing up the current thread.


00:58:31.140 --> 00:58:33.840
- Yeah, which I mean, technically is all that's going on


00:58:33.840 --> 00:58:34.840
with the threads anyway.


00:58:34.840 --> 00:58:35.940
Like when you have multiple threads,


00:58:35.940 --> 00:58:38.300
the operating system is now just doing the slicing up.


00:58:38.300 --> 00:58:40.480
You're still constrained to one process.


00:58:41.940 --> 00:58:43.260
then you need a separate process


00:58:43.260 --> 00:58:46.060
if you want to do multiple things.


00:58:46.060 --> 00:58:47.740
- Yeah, but like my machine has 10 cores.


00:58:47.740 --> 00:58:50.340
It will go across the cores according to OS,


00:58:50.340 --> 00:58:52.940
but the effect in Python because of the GIL


00:58:52.940 --> 00:58:54.700
means it doesn't actually make any difference.


00:58:54.700 --> 00:58:56.380
It's still the same, right?


00:58:56.380 --> 00:58:58.020
But if you get multi-processing, then for sure.


00:58:58.020 --> 00:58:59.540
So yeah, super, super interesting.


00:58:59.540 --> 00:59:03.220
I think one of the things people tell,


00:59:03.220 --> 00:59:04.860
I think people say two things.


00:59:04.860 --> 00:59:07.020
One, asynchronous programming is so hard


00:59:07.020 --> 00:59:08.140
you should never try it.


00:59:08.140 --> 00:59:09.460
I hear that all the time.


00:59:09.460 --> 00:59:11.160
It's so complicated, it's so hard,


00:59:11.160 --> 00:59:14.240
you're going to end up with race conditions, just don't try it.


00:59:14.240 --> 00:59:16.440
Mere mortals don't dare.


00:59:16.440 --> 00:59:19.520
They only regret.


00:59:19.520 --> 00:59:25.800
Maybe if you're doing like signaled events in C++


00:59:25.800 --> 00:59:31.120
across hardware notification--


00:59:31.120 --> 00:59:34.440
there are scenarios that are super, super tricky.


00:59:34.440 --> 00:59:37.920
Using async and await generally don't fall into that.


00:59:37.920 --> 00:59:40.720
You write regular code without changing the structure.


00:59:40.720 --> 00:59:43.640
You don't have to have callbacks and signals and locks.


00:59:43.640 --> 00:59:46.640
You just write regular code, or you have the async stuff


00:59:46.640 --> 00:59:47.880
you put away.


00:59:47.880 --> 00:59:49.960
It's kind of the end of the story.


00:59:49.960 --> 00:59:51.400
And it's not necessarily as simple


00:59:51.400 --> 00:59:52.920
as straight up regular programming,


00:59:52.920 --> 00:59:55.240
but it's like 10% more.


00:59:55.240 --> 00:59:57.280
It's not 10x more.


00:59:57.280 --> 00:59:59.800
And I think a lot of people for some--


00:59:59.800 --> 01:00:01.840
I don't understand why, but a lot of people,


01:00:01.840 --> 01:00:08.480
I think they want to feel like I've conquered this dragon.


01:00:08.480 --> 01:00:12.000
And if I'm gonna tell other people how to do it


01:00:12.000 --> 01:00:13.600
or what to do, the first thing I'm gonna tell them


01:00:13.600 --> 01:00:16.180
is how hard it is and how daunting it is.


01:00:16.180 --> 01:00:17.560
And like, yet I've conquered it


01:00:17.560 --> 01:00:19.080
and now I will help you, right?


01:00:19.080 --> 01:00:19.920
That doesn't do people favor.


01:00:19.920 --> 01:00:22.800
- Right, they wanna feel good about themselves.


01:00:22.800 --> 01:00:26.320
- I guess so, but I feel like threading and parallelism


01:00:26.320 --> 01:00:28.880
lands deeply in that space where people are like,


01:00:28.880 --> 01:00:30.240
oh, it's super hard.


01:00:30.240 --> 01:00:31.080
I can help you with that.


01:00:31.080 --> 01:00:32.840
- It's not, it really isn't.


01:00:32.840 --> 01:00:35.200
But where it's hard is you have to be prepared


01:00:35.200 --> 01:00:37.440
to really think about why do I need it?


01:00:37.440 --> 01:00:42.200
And if I can briefly say, I have two entire chapters


01:00:42.200 --> 01:00:45.320
in this book on that topic.


01:00:45.320 --> 01:00:47.380
And I pick one example, and it has nothing


01:00:47.380 --> 01:00:48.840
to do with waiting for a web page to download,


01:00:48.840 --> 01:00:50.680
because that is both overused and something


01:00:50.680 --> 01:00:52.120
that most of us don't need.


01:00:52.120 --> 01:00:55.320
And I apply synchrony.


01:00:55.320 --> 01:00:56.080
I apply threading.


01:00:56.080 --> 01:00:58.640
I apply parallelism.


01:00:58.640 --> 01:01:01.720
And you actually see all those little concerns of,


01:01:01.720 --> 01:01:04.800
how do you handle deadlocking, live locking?


01:01:04.800 --> 01:01:08.920
How do you handle starvation?


01:01:08.920 --> 01:01:11.200
How do you handle the producer-consumer problem?


01:01:11.200 --> 01:01:13.000
How do you handle the fact that, huh,


01:01:13.000 --> 01:01:15.720
I just added 15 multi-processing workers,


01:01:15.720 --> 01:01:17.640
and now this thing is way slower.


01:01:17.640 --> 01:01:18.680
Why?


01:01:18.680 --> 01:01:20.000
I go into all of that.


01:01:20.000 --> 01:01:22.200
And I think that's one thing I wanted to say


01:01:22.200 --> 01:01:25.280
is, when I was writing this book, that was the thing.


01:01:25.280 --> 01:01:27.520
That was my chief delight, was coming up


01:01:27.520 --> 01:01:30.280
with examples for all of the topics,


01:01:30.280 --> 01:01:32.640
from the simplest all the way to the most complicated,


01:01:32.640 --> 01:01:36.480
where I did not hold back on the relevant complexity.


01:01:36.480 --> 01:01:39.440
My list comprehensions were the snarliest list


01:01:39.440 --> 01:01:41.920
comprehensions you're ever gonna find in the tutorial.


01:01:41.920 --> 01:01:44.480
You know, my, and I have, I go into recursion.


01:01:44.480 --> 01:01:47.000
I go into, yes, I go into meta classes,


01:01:47.000 --> 01:01:48.040
whichever one's afraid of.


01:01:48.040 --> 01:01:49.760
I go into all of these things.


01:01:49.760 --> 01:01:53.960
I dig into them, but the complexity is always relevant.


01:01:53.960 --> 01:01:56.440
So you're only gonna get the complexity from the topic


01:01:56.440 --> 01:01:58.240
and you're gonna understand where all these bits


01:01:58.240 --> 01:02:00.160
and pieces interplay.


01:02:00.160 --> 01:02:05.160
But the complexity coming in from other irrelevant topics


01:02:05.160 --> 01:02:07.720
I try to keep to a minimum so you can really focus


01:02:07.720 --> 01:02:11.600
on understanding not just the happy path of coding,


01:02:11.600 --> 01:02:13.200
not just the happy path of like, okay,


01:02:13.200 --> 01:02:16.080
well, you can async this, look how easy that was.


01:02:16.080 --> 01:02:19.560
Well, it's not easy, but it's also not painfully hard.


01:02:19.560 --> 01:02:22.040
You just have to be prepared to think through


01:02:22.040 --> 01:02:26.120
those different factors.


01:02:26.120 --> 01:02:29.360
And so I focused a lot of time on really helping you learn


01:02:29.360 --> 01:02:31.000
how to think through those factors


01:02:31.000 --> 01:02:32.360
as it relates to your code.


01:02:32.360 --> 01:02:34.600
- Excellent.


01:02:34.600 --> 01:02:36.960
It sounds like a bit of the Einstein philosophy.


01:02:36.960 --> 01:02:39.520
Simple as possible, but not simpler.


01:02:39.520 --> 01:02:41.600
- Right, exactly.


01:02:41.600 --> 01:02:42.440
- Yeah, cool.


01:02:42.440 --> 01:02:44.080
I have no last thoughts on the async stuff.


01:02:44.080 --> 01:02:45.960
Like I think a sprinkling of async and await


01:02:45.960 --> 01:02:48.960
makes massive difference for a lot of scenarios.


01:02:48.960 --> 01:02:50.060
And that's pretty straightforward.


01:02:50.060 --> 01:02:51.520
If you're gonna try to write trio


01:02:51.520 --> 01:02:54.480
or some full on framework that deeply coordinates


01:02:54.480 --> 01:02:58.040
and understands it, like, yeah, that's super, super hard.


01:02:58.040 --> 01:03:01.760
Again, some of the signaling stories I talked about


01:03:01.760 --> 01:03:03.520
with C code, that's super hard.


01:03:03.520 --> 01:03:05.720
But this stuff, it's pretty approachable.


01:03:05.720 --> 01:03:08.640
So don't forget to check it out.


01:03:08.640 --> 01:03:10.480
All right.


01:03:10.480 --> 01:03:13.560
Well, I think that's it for our things we wish we knew.


01:03:13.560 --> 01:03:16.240
If we had more time, we could wish upon more things.


01:03:16.240 --> 01:03:17.440
But this pretty much--


01:03:17.440 --> 01:03:18.600
- Definitely.


01:03:18.600 --> 01:03:20.160
- Covers it, doesn't it?


01:03:20.160 --> 01:03:21.960
- Yeah, I think so.


01:03:21.960 --> 01:03:22.800
- Nice.


01:03:22.800 --> 01:03:23.640
All right, well, before you get out of here,


01:03:23.640 --> 01:03:25.280
let me ask you the final two questions.


01:03:25.280 --> 01:03:27.440
If you're gonna write some code,


01:03:27.440 --> 01:03:29.320
what editor to use?


01:03:29.320 --> 01:03:31.880
- Yeah, you know, for the longest time I was a VS Code guy.


01:03:31.880 --> 01:03:34.040
I still love it, but I broke down


01:03:34.040 --> 01:03:36.240
and I bought PyCharm Professional and I love that


01:03:36.240 --> 01:03:38.420
because I do a lot of refactoring


01:03:38.420 --> 01:03:41.040
and PyCharm saves my butt so much


01:03:41.040 --> 01:03:44.920
when it comes to refactoring that I fell in love with it.


01:03:44.920 --> 01:03:47.640
And I can't imagine working without it now.


01:03:47.640 --> 01:03:49.240
- I hear you. - So I'm spoiled.


01:03:49.240 --> 01:03:51.480
(laughing)


01:03:51.480 --> 01:03:54.480
- It does surprise me how people,


01:03:54.480 --> 01:03:56.720
not just a PyCharm comment, but in general,


01:03:56.720 --> 01:03:57.720
there's a lot of people who are like,


01:03:57.720 --> 01:04:00.400
oh, I don't really wanna get like a new computer


01:04:00.400 --> 01:04:04.020
or I don't really wanna pay 20 bucks for this thing.


01:04:04.020 --> 01:04:07.920
That would save you thousands of dollars worth of time


01:04:07.920 --> 01:04:10.720
as you go for it, you know, like, so I'm glad.


01:04:10.720 --> 01:04:12.640
- Splurge on your tools.


01:04:12.640 --> 01:04:14.360
As far as your budget will allow you,


01:04:14.360 --> 01:04:17.240
and I've been on both ends of that spectrum,


01:04:17.240 --> 01:04:19.160
as your budget allows you, splurge on your tools


01:04:19.160 --> 01:04:21.040
because they're what you're gonna be spending


01:04:21.040 --> 01:04:22.720
most of the day using anyway.


01:04:22.720 --> 01:04:24.040
And the last thing you want is something


01:04:24.040 --> 01:04:26.640
you're gonna be getting splinters on, so.


01:04:26.640 --> 01:04:27.960
- Indeed.


01:04:27.960 --> 01:04:30.400
And then notable PyPI package, something like,


01:04:30.400 --> 01:04:33.800
oh, this thing's awesome, I just ran across XYZ.


01:04:33.800 --> 01:04:36.280
- Oh, well, you know, I guess I have two.


01:04:36.280 --> 01:04:39.080
One would be, I think my favorite,


01:04:39.080 --> 01:04:40.840
and this has certainly gotten plenty of press,


01:04:40.840 --> 01:04:43.000
but I love it, it's the Hypothesis Testing Library.


01:04:43.000 --> 01:04:45.120
I love Hypothesis.


01:04:45.120 --> 01:04:46.600
Hypothesis is fantastic.


01:04:46.600 --> 01:04:48.900
It will revolutionize the way you write tests.


01:04:48.900 --> 01:04:53.380
It's not as scary as the documentation makes it look.


01:04:53.380 --> 01:04:56.320
If you click on what you can generate and how, start there.


01:04:56.320 --> 01:04:58.920
I go through the quick start guide and then go right to this.


01:04:58.920 --> 01:05:01.720
It's so cool because you just write these strategies.


01:05:01.720 --> 01:05:03.660
I'm like, "Okay, this is what


01:05:03.660 --> 01:05:06.480
my data is supposed to look like."


01:05:06.480 --> 01:05:09.840
Then your test is going to try and break your code.


01:05:09.840 --> 01:05:11.240
I love hypothesis.


01:05:11.240 --> 01:05:13.040
It's going to throw all sorts of garbage at you


01:05:13.040 --> 01:05:15.000
until it finds a way to break your code,


01:05:15.000 --> 01:05:16.020
and then it's going to go, "Hey,


01:05:16.020 --> 01:05:18.560
here's the simplest thing I could find that blew up your code."


01:05:18.560 --> 01:05:20.280
Fix it. Lovely.


01:05:20.280 --> 01:05:20.800
>> Nice.


01:05:20.800 --> 01:05:25.360
>> So much fun. The other favorite package I have is one of my own,


01:05:25.360 --> 01:05:27.800
I'm actually a branch detective.


01:05:27.800 --> 01:05:31.120
I built this at two jobs ago.


01:05:31.120 --> 01:05:35.480
And basically we had the problem


01:05:35.480 --> 01:05:37.400
where we had these diverging branches


01:05:37.400 --> 01:05:39.940
where we had no choice but to completely diverge them.


01:05:39.940 --> 01:05:41.840
And we were cherry picking back and forth.


01:05:41.840 --> 01:05:43.600
And there was always this,


01:05:43.600 --> 01:05:46.200
which commits are in this one that aren't in this one.


01:05:46.200 --> 01:05:47.280
When you're doing cherry picking


01:05:47.280 --> 01:05:50.440
your hashes are complete garbage now.


01:05:50.440 --> 01:05:52.720
So I built this tool that allows you to see


01:05:52.720 --> 01:05:55.300
what's in one branch that's not in another branch.


01:05:55.300 --> 01:05:57.620
any branch arbitrarily.


01:05:57.620 --> 01:05:59.700
You can specify date range.


01:05:59.700 --> 01:06:00.980
It knows how to handle cherry picks.


01:06:00.980 --> 01:06:03.880
It knows how to handle merge revisions or filter them out.


01:06:03.880 --> 01:06:07.000
And you can even pass it the dash M flag


01:06:07.000 --> 01:06:09.780
and just get this nice markdown.


01:06:09.780 --> 01:06:11.020
If you're using conventional commits,


01:06:11.020 --> 01:06:13.100
we'll just spit out this markdown


01:06:13.100 --> 01:06:15.220
that you can then copy and paste into your PR and say,


01:06:15.220 --> 01:06:19.020
hey, here's the summaries of the 26 commits


01:06:19.020 --> 01:06:20.020
I'm putting in here.


01:06:20.020 --> 01:06:23.440
So I use this every single day


01:06:23.440 --> 01:06:26.840
and I've improved it for every project I'm on so far.


01:06:26.840 --> 01:06:29.160
And I just, I love it.


01:06:29.160 --> 01:06:32.760
It's my favorite, one of my favorite things ever built.


01:06:32.760 --> 01:06:35.720
- So you kind of wrote set for get, right?


01:06:35.720 --> 01:06:38.000
Like you can say, what's in the set, subtract that set.


01:06:38.000 --> 01:06:39.120
Show me those things, yeah.


01:06:39.120 --> 01:06:41.920
- Exactly, like what's here, that's not there.


01:06:41.920 --> 01:06:42.760
- Yeah, cool.


01:06:42.760 --> 01:06:46.880
All right, Jason, well, thanks for being here.


01:06:46.880 --> 01:06:47.960
Final call to action.


01:06:47.960 --> 01:06:50.080
People will get their Python better, what do you tell them?


01:06:50.080 --> 01:06:52.920
- Yes, yeah, so Dead Simple Python


01:06:52.920 --> 01:06:57.000
available from wherever you buy books, but especially if you go to


01:06:57.000 --> 01:07:02.040
no starch.com, you can get this comes in ebook or in physical


01:07:02.040 --> 01:07:04.860
book form. And hey, you know what, I wrote it and I refer to


01:07:04.860 --> 01:07:07.800
it every single day because this is the book I wish I had had.


01:07:07.800 --> 01:07:11.840
And my favorite little feature of this is that I have a thing


01:07:11.840 --> 01:07:15.840
in the back with every single command for the debugger. Also


01:07:15.840 --> 01:07:18.840
have every single Dunder method is also documented in here,


01:07:18.840 --> 01:07:21.680
which even the Python docs didn't do that. This is the


01:07:21.680 --> 01:07:27.360
entire core language bar nothing explained for the existing coder. So


01:07:27.360 --> 01:07:32.440
check this out from no star stock. Awesome. Well thanks for taking the time for being


01:07:32.440 --> 01:07:36.440
here and enjoy the chat. Thank you so much it's been a pleasure. Yeah you bet.


01:07:36.440 --> 01:07:39.200
See you later.

