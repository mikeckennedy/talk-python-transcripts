WEBVTT

00:00:00.001 --> 00:00:04.220
>> Giovanni, welcome to Talk Python To Me.

00:00:04.220 --> 00:00:07.760
>> Hello, Michael. Thank you for having me on the show.

00:00:07.760 --> 00:00:10.420
>> Yeah. It's great to have you on the show.

00:00:10.420 --> 00:00:11.860
>> Thank you.

00:00:11.860 --> 00:00:17.380
>> Some people you learn about just from their public speaking or

00:00:17.380 --> 00:00:20.420
their writing and other people you meet through their projects.

00:00:20.420 --> 00:00:22.700
I got to know you through Granian,

00:00:22.700 --> 00:00:27.260
your Rust-based Python and other thing,

00:00:27.260 --> 00:00:29.000
web server that I thought was really awesome.

00:00:29.000 --> 00:00:33.240
Started playing with it and we started talking on GitHub around some ideas.

00:00:33.240 --> 00:00:35.900
Then here you are,

00:00:35.900 --> 00:00:38.000
sort of explore more, learn more about some of your frameworks

00:00:38.000 --> 00:00:39.320
that you'd created from.

00:00:39.320 --> 00:00:41.840
So I'm excited to talk about Emmet,

00:00:41.840 --> 00:00:44.240
Granian, and a bunch of other things that you built,

00:00:44.240 --> 00:00:47.760
all to go together in a big mix there.

00:00:47.760 --> 00:00:51.360
>> Yeah. I'm excited as well.

00:00:51.360 --> 00:00:52.600
>> Yeah. It should be a lot of fun.

00:00:52.600 --> 00:00:57.040
Before though, before we get into all the details of all that stuff,

00:00:57.040 --> 00:00:59.960
just tell us a bit about yourself.

00:00:59.960 --> 00:01:04.840
>> Yeah, sure. I'm Giovanni Barillari.

00:01:04.840 --> 00:01:08.880
I actually born in Italy,

00:01:08.880 --> 00:01:13.560
but today I'm living in Vienna, in Austria.

00:01:13.560 --> 00:01:17.360
I'm actually a physicist.

00:01:17.360 --> 00:01:21.600
Yeah, I graduated in physics at the university.

00:01:22.920 --> 00:01:29.200
But let's say I started working as a software engineer,

00:01:29.200 --> 00:01:38.000
focused especially on web software pretty soon after the university.

00:01:38.000 --> 00:01:41.920
So it's like 10 years something.

00:01:41.920 --> 00:01:44.440
I'm working as a software engineer,

00:01:44.440 --> 00:01:47.320
also as a cipher diabetic engineer.

00:01:47.320 --> 00:01:56.720
So let's just say I'm quite on the back-end side of the things usually.

00:01:56.720 --> 00:02:08.000
I actually started contributing to open source software projects,

00:02:08.000 --> 00:02:13.840
even before actually starting working as a software engineer.

00:02:14.360 --> 00:02:19.960
Particularly, I started contributing to the Web2Py project.

00:02:19.960 --> 00:02:26.760
Quite old project by Massimo Di Piero.

00:02:26.760 --> 00:02:34.200
Today I'm working as a cipher liability engineer for Sentry.

00:02:34.200 --> 00:02:41.160
I bet that pretty much of the people know about Sentry.

00:02:41.160 --> 00:02:44.360
>> Yeah, awesome.

00:02:44.360 --> 00:02:48.720
I didn't even know that you worked for Sentry until just a few minutes ago.

00:02:48.720 --> 00:02:49.760
That's pretty awesome.

00:02:49.760 --> 00:02:51.280
Obviously, people know Sentry,

00:02:51.280 --> 00:02:56.200
they're big supporters of the show and sponsor some of the episodes.

00:02:56.200 --> 00:03:00.160
But yeah, how's it like to work at Sentry? Must be fun.

00:03:00.160 --> 00:03:03.440
>> Well, it's super nice.

00:03:03.440 --> 00:03:06.000
A lot of talented people.

00:03:06.000 --> 00:03:07.560
They're super nice.

00:03:07.560 --> 00:03:10.480
It's a really nice environment to be within.

00:03:10.480 --> 00:03:13.080
So yeah, I'm super happy.

00:03:13.080 --> 00:03:14.640
>> Yeah, awesome.

00:03:14.640 --> 00:03:18.680
What does a software reliability engineer do?

00:03:18.680 --> 00:03:26.280
>> It might be a complicated question because actually,

00:03:26.280 --> 00:03:31.160
the original title comes from Google.

00:03:31.160 --> 00:03:41.640
So let's say is related to infrastructure and monitoring in software.

00:03:41.640 --> 00:03:44.880
So let's say to simplify that,

00:03:44.880 --> 00:03:54.640
it's about be sure that everything runs smoothly with no incidents and stuff like that.

00:03:54.640 --> 00:03:57.920
>> Make sure you can monitor bugs, slowdowns.

00:03:57.920 --> 00:03:58.760
>> Yeah.

00:03:58.760 --> 00:04:02.480
>> Work on failover type of situations, that kind of stuff.

00:04:02.480 --> 00:04:03.880
>> Exactly.

00:04:03.880 --> 00:04:09.560
>> I imagine you probably use Sentry to monitor Sentry for reliability.

00:04:09.560 --> 00:04:10.280
Is that right?

00:04:10.280 --> 00:04:15.560
>> Yes. We have this project called Sentry for Sentry.

00:04:15.560 --> 00:04:16.080
>> Okay.

00:04:16.080 --> 00:04:19.280
>> Which is like a separated Sentry instance that

00:04:19.280 --> 00:04:23.560
monitors the actual SaaS instance of Sentry.

00:04:23.560 --> 00:04:25.360
>> That's pretty interesting because of course,

00:04:25.360 --> 00:04:29.000
if Sentry went down, you're using it to monitor it.

00:04:29.000 --> 00:04:32.080
Everyone else uses Sentry to monitor their thing.

00:04:32.080 --> 00:04:35.520
It's not about when their code goes down, it doesn't affect it.

00:04:35.520 --> 00:04:36.920
But when your code goes down,

00:04:36.920 --> 00:04:39.320
it might actually affect your ability to know that it's down.

00:04:39.320 --> 00:04:41.080
So a separate copy that's filed.

00:04:41.080 --> 00:04:43.240
Okay, I hadn't even thought of that.

00:04:43.240 --> 00:04:46.680
>> Super cool. All right.

00:04:46.680 --> 00:04:48.320
Now, first of all,

00:04:48.320 --> 00:04:53.360
there's a little bit of love out in the audience for your whole larger project, Emmet.

00:04:53.360 --> 00:04:56.080
So Tshar says, "Did you say Emmet?

00:04:56.080 --> 00:04:57.640
Emmet is amazing."

00:04:57.640 --> 00:05:00.120
Which is super cool.

00:05:00.120 --> 00:05:04.000
Tools like that encourage him to work on his DevTool, which is really great.

00:05:04.000 --> 00:05:07.040
Before we get into the details of that though,

00:05:07.040 --> 00:05:12.080
why create another web framework?

00:05:12.080 --> 00:05:13.320
I don't mean this in a negative way.

00:05:13.320 --> 00:05:19.480
It's just like there's Flask and Django and then we have FastAPI.

00:05:19.480 --> 00:05:20.880
>> Yeah, there's a lot.

00:05:20.880 --> 00:05:23.160
>> Why not just go, "I'm just going to use this one."

00:05:23.160 --> 00:05:26.040
What inspired you to go, "I think I'll make one of them."

00:05:26.040 --> 00:05:32.640
>> So I think we should go back a bit in time

00:05:32.640 --> 00:05:39.640
because actually this year will be the 10th birthday of Emmet.

00:05:39.640 --> 00:05:43.160
So let's just say it's a long time.

00:05:43.160 --> 00:05:44.160
>> So it's not bad.

00:05:44.160 --> 00:05:45.160
>> It's out there.

00:05:45.160 --> 00:05:46.160
>> Okay. I see.

00:05:46.160 --> 00:05:47.160
>> Yeah.

00:05:48.160 --> 00:05:54.160
So originally it was released as...

00:05:54.160 --> 00:05:57.160
It had a different name.

00:05:57.160 --> 00:05:58.160
It was called Wepi.

00:05:58.160 --> 00:06:04.160
And I changed the name in 2020, I think,

00:06:04.160 --> 00:06:13.160
when I moved from synchronous paradigm to the asynchronous one.

00:06:14.160 --> 00:06:19.160
So let's say at the time I designed Wepi,

00:06:19.160 --> 00:06:23.160
so the original version in 2014,

00:06:23.160 --> 00:06:29.160
the main thing was about...

00:06:29.160 --> 00:06:39.160
So in that time, it was like the time of Ruby on Rails being super popular.

00:06:41.160 --> 00:06:47.160
And I originally started working in web development using Ruby on Rails.

00:06:47.160 --> 00:06:56.160
And when comparing, let's say, the amount of, let's say,

00:06:56.160 --> 00:07:02.160
batteries included in the box of Ruby on Rails to the Python ecosystem,

00:07:02.160 --> 00:07:07.160
so let's say that the major competitor at that point in time was Django.

00:07:08.160 --> 00:07:17.160
But let's say that the feeling I got from Django at that time

00:07:17.160 --> 00:07:20.160
compared to Ruby on Rails was completely different.

00:07:20.160 --> 00:07:32.160
In a sense that I found myself spending much more time on building stuff

00:07:32.160 --> 00:07:36.160
compared to Ruby on Rails.

00:07:37.160 --> 00:07:44.160
And this is also what brought me to the Web2Py project,

00:07:44.160 --> 00:07:47.160
Web2Py community, because it was, in a sense,

00:07:47.160 --> 00:07:58.160
pretty similar in some of the design decisions with RAR.

00:08:01.160 --> 00:08:08.160
But at the same time, once you start contributing to a web framework,

00:08:08.160 --> 00:08:14.160
you have time to dig into a lot of the internals and decisions.

00:08:14.160 --> 00:08:19.160
And so Web2Py at that time,

00:08:19.160 --> 00:08:26.160
so I used Web2Py to build the code behind my first startup, actually.

00:08:27.160 --> 00:08:33.160
And it had quite a lot of scaling issues at that time.

00:08:33.160 --> 00:08:41.160
So let's say at that point in time, I just, you know,

00:08:41.160 --> 00:08:44.160
was looking out for the options,

00:08:44.160 --> 00:08:51.160
and I started digging into the code internals of Django and also Flask.

00:08:54.160 --> 00:09:00.160
Which, I mean, I really loved the Flask approach of things,

00:09:00.160 --> 00:09:06.160
but at the same time, it was so micro.

00:09:06.160 --> 00:09:10.160
I mean, to build an actual project,

00:09:10.160 --> 00:09:15.160
it required to have tons of extensions and other pieces,

00:09:15.160 --> 00:09:19.160
let's say, other libraries to add it to the project.

00:09:21.160 --> 00:09:24.160
So yeah, I think I ended up just saying,

00:09:24.160 --> 00:09:30.160
"Okay, let's just rebuild Web2Py the way I want it."

00:09:30.160 --> 00:09:38.160
And that's eventually how WebP came out, and today I'm at...

00:09:38.160 --> 00:09:42.160
Yeah, that's pretty much the story behind it.

00:09:42.160 --> 00:09:45.160
- Okay. Yeah, I didn't realize it went that far back.

00:09:45.160 --> 00:09:47.160
How about Granian? Is that newer?

00:09:48.160 --> 00:09:52.160
- Yeah, Granian is, I think, like the first public release

00:09:52.160 --> 00:09:55.160
is like from one year ago or something.

00:09:55.160 --> 00:09:58.160
- Yeah, because I learned about Emmet through Granian,

00:09:58.160 --> 00:10:01.160
and I go, "Oh, it's kind of all probably all the same project."

00:10:01.160 --> 00:10:04.160
I didn't realize the history. Why the new name? Why Emmet?

00:10:04.160 --> 00:10:14.160
- So the thing was that to support, let's say,

00:10:14.160 --> 00:10:19.160
the upgrade between WebP and Emmet,

00:10:19.160 --> 00:10:22.160
so since all the interfaces have to be changed

00:10:22.160 --> 00:10:31.160
to support async code, the idea was to provide,

00:10:31.160 --> 00:10:36.160
let's say, a quick way to do that,

00:10:36.160 --> 00:10:40.160
meaning to make it possible for developers

00:10:40.160 --> 00:10:45.160
to install a new version of WebP

00:10:45.160 --> 00:10:50.160
and getting everything broken because of the new interfaces.

00:10:50.160 --> 00:10:55.160
So yeah, I just decided to change the interface

00:10:55.160 --> 00:10:58.160
and also changing the package name in order to say,

00:10:58.160 --> 00:11:02.160
"Okay, if you want to upgrade, you can upgrade safely.

00:11:02.160 --> 00:11:04.160
Otherwise, you can stick."

00:11:04.160 --> 00:11:07.160
- It's like a super mega version change.

00:11:07.160 --> 00:11:10.160
Not only do you change the version, but you change the name.

00:11:10.160 --> 00:11:13.160
- Yeah, exactly. - I see.

00:11:13.160 --> 00:11:15.160
That's interesting.

00:11:15.160 --> 00:11:20.160
All right, well, let's dive into it.

00:11:20.160 --> 00:11:27.160
So I like the title, Emmet, the Web Framework for Inventors.

00:11:27.160 --> 00:11:31.160
And maybe give us a sense of what are some of the core features

00:11:31.160 --> 00:11:36.160
of Emmet, and what are your goals with building it?

00:11:36.160 --> 00:11:44.160
- So the idea was to have all-in-one, let's say,

00:11:44.160 --> 00:11:48.160
framework to build web application,

00:11:48.160 --> 00:11:52.160
all-in-one, let's say, in a sense of, again,

00:11:52.160 --> 00:11:55.160
when the project actually started.

00:11:55.160 --> 00:11:59.160
So even 10 years after that,

00:11:59.160 --> 00:12:07.160
I still usually prefer to develop web projects

00:12:07.160 --> 00:12:10.160
without relying too much on front-end frameworks.

00:12:10.160 --> 00:12:16.160
So this is like a big, let's say, preamble to the thing.

00:12:16.160 --> 00:12:21.160
Like, this is originally from an era where, like,

00:12:21.160 --> 00:12:23.160
front-end web framework built exists.

00:12:23.160 --> 00:12:29.160
Like, I think it was just AngularJS and maybe Ember at that time.

00:12:29.160 --> 00:12:30.160
- Yeah.

00:12:30.160 --> 00:12:33.160
You're basically describing my life in 2024 still.

00:12:33.160 --> 00:12:36.160
I'm a big fan of the server-side frameworks, you know?

00:12:36.160 --> 00:12:37.160
- Exactly.

00:12:37.160 --> 00:12:43.160
Yeah, also because, like, it seems sometimes that we reinvent,

00:12:43.160 --> 00:12:48.160
like, a lot of stuff to catch up, like, the beginning.

00:12:48.160 --> 00:12:56.160
At the end, like, yeah, I felt like all of the theme about,

00:12:56.160 --> 00:12:59.160
you know, server-side rendering with front-end frameworks

00:12:59.160 --> 00:13:02.160
and server-side render components and all that kind of stuff.

00:13:02.160 --> 00:13:07.160
So sometimes it just feels, you know, we're getting back to the origins.

00:13:07.160 --> 00:13:10.160
But, yeah.

00:13:10.160 --> 00:13:17.160
So, yeah, the idea behind Emmet is to have, like,

00:13:17.160 --> 00:13:21.160
all-in-one solution to develop web applications.

00:13:21.160 --> 00:13:27.160
So you have all the standard features you have with a web framework,

00:13:27.160 --> 00:13:34.160
so, like, routing and middlewares and that kind of stuff.

00:13:34.160 --> 00:13:36.160
You have an ORM.

00:13:36.160 --> 00:13:45.160
You have a templating system plus a few, let's say, tools embedded within.

00:13:45.160 --> 00:13:50.160
So, for instance, it's very easy to use, I don't know, sessions

00:13:50.160 --> 00:13:55.160
or to have an authentication system.

00:13:55.160 --> 00:14:00.160
It's all, like, provided inside the box.

00:14:00.160 --> 00:14:05.160
So, yeah, the idea was to have, like, let's say, a battery of tools,

00:14:05.160 --> 00:14:09.160
like, in one place to do the most common things

00:14:09.160 --> 00:14:14.160
when you start developing a web application.

00:14:14.160 --> 00:14:16.160
Yeah, very nice.

00:14:16.160 --> 00:14:19.160
So, yeah, like you said, it has an ORM built in,

00:14:19.160 --> 00:14:25.160
and it feels, I guess, SQLAlchemy-ish in a sense,

00:14:25.160 --> 00:14:27.160
but not exactly the same.

00:14:27.160 --> 00:14:33.160
Or Django ORM would be, you know, another way in some ways there.

00:14:33.160 --> 00:14:43.160
Yeah, I think it's more near to, yeah, to SQLAlchemy in that sense.

00:14:43.160 --> 00:14:48.160
You tend to have, like, an API for using Python objects to build queries

00:14:48.160 --> 00:14:56.160
rather than, how to say, use, like, a lot of strings, attributes,

00:14:56.160 --> 00:15:03.160
like you usually tend to do in Django.

00:15:03.160 --> 00:15:10.160
Yeah, I mean, it's more close to SQLAlchemy in that sense.

00:15:10.160 --> 00:15:24.160
I think, like, the major difference with the ORMs out there is that

00:15:24.160 --> 00:15:29.160
the model class you define are not, like --

00:15:29.160 --> 00:15:36.160
so when you, for example, select records from the database,

00:15:36.160 --> 00:15:44.160
the single, let's say, rows you select are not instances of the model class.

00:15:44.160 --> 00:15:51.160
So let's say, like, the model class acts more like management class.

00:15:51.160 --> 00:15:54.160
Schema definition sort of thing.

00:15:54.160 --> 00:16:00.160
Yeah, I mean, it does, like, a lot of helpers on top of that.

00:16:00.160 --> 00:16:06.160
But, yeah, I think, like, it's definitely the major difference between, like,

00:16:06.160 --> 00:16:10.160
I think, like, the vast majority of ORMs out there for Python

00:16:10.160 --> 00:16:16.160
when you usually have, like, the model class, which is also, like,

00:16:16.160 --> 00:16:22.160
the class of all the records you select and work on from the database.

00:16:22.160 --> 00:16:26.160
Yeah, so what do you get back in this world here?

00:16:26.160 --> 00:16:27.160
Sorry?

00:16:27.160 --> 00:16:29.160
What do you get if you do a query?

00:16:29.160 --> 00:16:33.160
Like, in your example on the home page, you have a traveler.

00:16:33.160 --> 00:16:37.160
So what do you get back when you get a group of them, a set of them?

00:16:37.160 --> 00:16:40.160
So you get, like, a different class.

00:16:40.160 --> 00:16:44.160
So there's, like, a separated class.

00:16:44.160 --> 00:16:53.160
Every model has its -- it's called, like, row class.

00:16:53.160 --> 00:16:56.160
So it's an instance of that class.

00:16:56.160 --> 00:17:03.160
And this design, it's mostly made for two reasons.

00:17:03.160 --> 00:17:08.160
Like, the first one is performance, in a sense,

00:17:08.160 --> 00:17:18.160
meaning that when you select records or operate on records,

00:17:18.160 --> 00:17:23.160
it avoids to, you know, fulfill, like, all those objects

00:17:23.160 --> 00:17:29.160
with the actual model class attributes or functions or methods.

00:17:29.160 --> 00:17:31.160
And the validation and stuff, yeah.

00:17:31.160 --> 00:17:33.160
Yeah.

00:17:33.160 --> 00:17:43.160
And on the other hand was also to kind of remind to the developer

00:17:43.160 --> 00:17:49.160
that he is working with actual data from the database

00:17:49.160 --> 00:17:52.160
and not, like, real Python objects, in a sense.

00:17:52.160 --> 00:17:54.160
Yeah, yeah.

00:17:54.160 --> 00:17:58.160
Which is -- I think, like, in the years,

00:17:58.160 --> 00:18:06.160
is, like, the first reason why people tend to object against ORMs.

00:18:06.160 --> 00:18:12.160
So those two were the main reasons behind this design.

00:18:12.160 --> 00:18:16.160
It's something like, you know, in the between of an ORM

00:18:16.160 --> 00:18:20.160
and just some database abstraction layer.

00:18:20.160 --> 00:18:22.160
Yeah.

00:18:22.160 --> 00:18:24.160
Yeah, absolutely.

00:18:24.160 --> 00:18:26.160
I like the query syntax.

00:18:26.160 --> 00:18:28.160
You know, people visit the homepage,

00:18:28.160 --> 00:18:31.160
you'd see something like time travel dot where,

00:18:31.160 --> 00:18:35.160
then lambda of t goes to t dot return equal equal true.

00:18:35.160 --> 00:18:41.160
And while some of the ORMs let you write code

00:18:41.160 --> 00:18:46.160
in terms of, like, the class fields or whatever,

00:18:46.160 --> 00:18:50.160
it's never looked quite right because you're working with, say,

00:18:50.160 --> 00:18:53.160
the static value out of the class,

00:18:53.160 --> 00:18:55.160
whereas what you really are trying to talk about

00:18:55.160 --> 00:18:58.160
is the instance level of the record, right?

00:18:58.160 --> 00:19:02.160
So instead of saying t, you'd say time travel dot return,

00:19:02.160 --> 00:19:06.160
but you would never test that because it's the global value of it, right?

00:19:06.160 --> 00:19:07.160
And stuff like that.

00:19:07.160 --> 00:19:11.160
Or you just use strings, which is basically, in my mind, no good.

00:19:11.160 --> 00:19:15.160
But what's cool, you know, also, do you want to do an OR or an AND?

00:19:15.160 --> 00:19:18.160
And then what weird thing do you import to do the OR?

00:19:18.160 --> 00:19:21.160
And, like, you know, how do you wrap the query in it?

00:19:21.160 --> 00:19:23.160
All that kind of stuff, whereas if it's a lambda,

00:19:23.160 --> 00:19:25.160
you can just express the conditions.

00:19:25.160 --> 00:19:28.160
Yeah, yeah, that's pretty much the idea.

00:19:28.160 --> 00:19:33.160
So, like, to use, you know, special methods from Python objects

00:19:33.160 --> 00:19:39.160
and translate those expressions, like, actually SQL code.

00:19:39.160 --> 00:19:42.160
So, yeah.

00:19:42.160 --> 00:19:43.160
Nice.

00:19:43.160 --> 00:19:49.160
Yeah, for my apps, I have a combination of Beanie and Mongo Engine,

00:19:49.160 --> 00:19:52.160
depending on which one you're talking about.

00:19:52.160 --> 00:19:56.160
And for Mongo Engine, you do things that are pretty funky.

00:19:56.160 --> 00:20:02.160
Like, if you want to say greater than, you would say, like,

00:20:02.160 --> 00:20:06.160
time travel dot-- I don't know, it doesn't have a value, but age.

00:20:06.160 --> 00:20:07.160
Let's say there's an age.

00:20:07.160 --> 00:20:13.160
Like, time travel dot age underscore underscore gt equals value.

00:20:13.160 --> 00:20:17.160
And you're like, well, it's not equal to it,

00:20:17.160 --> 00:20:20.160
and it's not that-- that's not the name of it, but okay.

00:20:20.160 --> 00:20:22.160
I guess that means, you know what I mean?

00:20:22.160 --> 00:20:25.160
Like, there's a real weird way it's, like, jammed into a syntax,

00:20:25.160 --> 00:20:28.160
whereas, like, here you say greater than whatever, right?

00:20:28.160 --> 00:20:30.160
Yeah, yeah, yeah.

00:20:30.160 --> 00:20:36.160
It's like the same-- it's one of the things I dislike still today of Django

00:20:36.160 --> 00:20:40.160
or in that sense.

00:20:40.160 --> 00:20:46.160
I mean, it has, like, a lot more capabilities

00:20:46.160 --> 00:20:50.160
because, for instance, like, when you want to represent, like,

00:20:50.160 --> 00:20:58.160
complex queries, it tends to be more powerful in that sense,

00:20:58.160 --> 00:21:01.160
meaning that special methods are limited.

00:21:01.160 --> 00:21:07.160
So at some point, you start making, you know, custom methods.

00:21:07.160 --> 00:21:11.160
So, like, I don't know, starts with, for example--

00:21:11.160 --> 00:21:15.160
In a set, yeah, starts with or in this set or the set includes this

00:21:15.160 --> 00:21:17.160
and something like that, right?

00:21:17.160 --> 00:21:22.160
Exactly. So I think, yeah, there are pros and cons in both,

00:21:22.160 --> 00:21:24.160
let's say, approaches.

00:21:24.160 --> 00:21:26.160
Yeah, cool.

00:21:26.160 --> 00:21:29.160
All right, so we have a lot to talk about,

00:21:29.160 --> 00:21:31.160
even though all this code fits on one screen.

00:21:31.160 --> 00:21:33.160
The other part is to define an endpoint.

00:21:33.160 --> 00:21:35.160
This is about an API, right?

00:21:35.160 --> 00:21:39.160
So you have an async def, which is awesome, supports async and await,

00:21:39.160 --> 00:21:43.160
I think is super valuable.

00:21:43.160 --> 00:21:47.160
Yeah, one note is that the ORM is still synchronous.

00:21:47.160 --> 00:21:49.160
Yeah, yeah.

00:21:49.160 --> 00:21:50.160
So what about that?

00:21:50.160 --> 00:21:52.160
Are you planning on adding an async thing,

00:21:52.160 --> 00:21:55.160
or are you just saying it's just synchronous?

00:21:55.160 --> 00:22:00.160
So it's, like, a very long story in a sense because, like,

00:22:00.160 --> 00:22:08.160
I started asking myself the same question, like, several years ago.

00:22:08.160 --> 00:22:17.160
And I think, like, at some point, probably I will end up doing that

00:22:17.160 --> 00:22:22.160
in the same way SQLAlchemy did that,

00:22:22.160 --> 00:22:30.160
even if, like, I remember, like, a super nice blog post

00:22:30.160 --> 00:22:38.160
from the author of SQLAlchemy stating that asynchronous code

00:22:38.160 --> 00:22:46.160
and databases are not the best way to use that.

00:22:46.160 --> 00:22:50.160
So, yeah, let's say, like, in the last few years,

00:22:50.160 --> 00:22:59.160
I just, you know, waited in a way to see what everyone else was doing.

00:22:59.160 --> 00:23:06.160
But, yeah, I think, like, at some point, it will be inevitable in a sense.

00:23:06.160 --> 00:23:10.160
I just don't feel the time has come yet.

00:23:10.160 --> 00:23:12.160
So we'll see.

00:23:12.160 --> 00:23:14.160
Yeah, cool.

00:23:14.160 --> 00:23:20.160
And then I guess the last thing to talk about is you have a decorator app.route,

00:23:20.160 --> 00:23:22.160
pretty straightforward.

00:23:22.160 --> 00:23:28.160
But then you also have an @service.json.

00:23:28.160 --> 00:23:30.160
What's this decorator do?

00:23:30.160 --> 00:23:37.160
So you can think about that decorator, like, the service decorator,

00:23:37.160 --> 00:23:42.160
as, like, the JSONify function in Flask.

00:23:42.160 --> 00:23:43.160
Yeah.

00:23:43.160 --> 00:23:52.160
So, yeah, in Emmet, you have, like, both the JSON service and the XML service.

00:23:52.160 --> 00:23:58.160
Yeah, because, like, in old times, I had to write stuff to, you know,

00:23:58.160 --> 00:24:01.160
talk with XML and points and stuff like that.

00:24:01.160 --> 00:24:09.160
So, yeah, it's just, you know, an easy way to wrap and say everything

00:24:09.160 --> 00:24:16.160
that returns from this function, just serializing JSON or XML or whatever.

00:24:16.160 --> 00:24:19.160
If I return, rather than a response, just return a dictionary,

00:24:19.160 --> 00:24:22.160
and it'll do the serialization, right?

00:24:22.160 --> 00:24:23.160
Exactly.

00:24:23.160 --> 00:24:25.160
Nice.

00:24:25.160 --> 00:24:31.160
And the audience asks, "Does it generate an open API documentation?"

00:24:31.160 --> 00:24:34.160
Like, does it automatically generate documentation?

00:24:34.160 --> 00:24:40.160
So from standard routes, no.

00:24:40.160 --> 00:24:49.160
There's an extension, though, meaning that if you plan to design REST,

00:24:49.160 --> 00:24:54.160
let's say, APIs with Emmet, there's an extension for that.

00:24:54.160 --> 00:25:00.160
It's called Emmet REST, which, let's say, gives you, like,

00:25:00.160 --> 00:25:08.160
more tools to structure your routes and serialization

00:25:08.160 --> 00:25:11.160
and deserialization and all that kind of stuff.

00:25:11.160 --> 00:25:20.160
And that extension also brings open API documentation generation.

00:25:20.160 --> 00:25:25.160
Eventually, let's say, the open API documentation generation

00:25:25.160 --> 00:25:31.160
will come also to plain routes in Emmet,

00:25:31.160 --> 00:25:43.160
but there's quite a few design implied to do that, meaning that it's--

00:25:43.160 --> 00:25:49.160
So Emmet, it's, like, not designed to have a strong type system

00:25:49.160 --> 00:25:52.160
because, again, it comes from the days where, like--

00:25:52.160 --> 00:25:56.160
- It didn't exist. - Yeah.

00:25:56.160 --> 00:26:01.160
So let's say that, for instance, for frameworks like FastAPI,

00:26:01.160 --> 00:26:07.160
which are practically designed on top of something like Pydantic,

00:26:07.160 --> 00:26:12.160
so you have, like, a strong type system, so everything that comes in and out

00:26:12.160 --> 00:26:18.160
from the majority of routes you write has types,

00:26:18.160 --> 00:26:24.160
and so it's really easy for the framework to inspect the code

00:26:24.160 --> 00:26:29.160
and understand what's going on.

00:26:29.160 --> 00:26:34.160
On, let's say, general frameworks like Emmet, where you--

00:26:34.160 --> 00:26:39.160
I mean, you might have, like, I don't know, HTML routes

00:26:39.160 --> 00:26:43.160
or other kind of stuff going on.

00:26:43.160 --> 00:26:50.160
There's no, let's say, design behind that to support in the first play

00:26:50.160 --> 00:26:53.160
strong typing.

00:26:53.160 --> 00:27:02.160
So yeah, making open API documentation out of standard Emmet routes

00:27:02.160 --> 00:27:07.160
involves quite a lot of decisions.

00:27:07.160 --> 00:27:10.160
So yeah, we'll see. We'll see.

00:27:10.160 --> 00:27:13.160
Yeah, okay. Yeah, very cool.

00:27:13.160 --> 00:27:17.160
We'll come back and talk about Emmet REST in a minute.

00:27:17.160 --> 00:27:21.160
That's one of the fun things. It also has WebSocket support, right?

00:27:21.160 --> 00:27:24.160
Yep. Absolutely.

00:27:24.160 --> 00:27:27.160
WebSockets are these things that I'm always like, "Man, they're so cool,

00:27:27.160 --> 00:27:31.160
and you can do all this interesting stuff," and then I never, ever,

00:27:31.160 --> 00:27:35.160
ever have a use case for it in my world. I just haven't yet.

00:27:35.160 --> 00:27:39.160
So I'm like, "Well, they're very cool," but I don't have it yet.

00:27:39.160 --> 00:27:42.160
So I mean, I'm not building Slack.

00:27:42.160 --> 00:27:51.160
Yeah, the thing is that usually, like, when you work with WebSockets,

00:27:51.160 --> 00:27:59.160
it's also pretty common that you need, like, some broadcast facility.

00:27:59.160 --> 00:28:09.160
So usually you want to do channels or that kind of stuff,

00:28:09.160 --> 00:28:13.160
which usually tends to involve, like, other software, like you usually have

00:28:13.160 --> 00:28:17.160
Redis or something like that in order to--

00:28:17.160 --> 00:28:23.160
since Python is not exactly good in, let's say, managing threads

00:28:23.160 --> 00:28:32.160
or communicating across different processes, that's probably why it's not so easy

00:28:32.160 --> 00:28:38.160
in the Python world to actually rely on WebSockets a lot.

00:28:38.160 --> 00:28:42.160
I don't know. For instance, if you take, like, languages like, I don't know,

00:28:42.160 --> 00:28:48.160
Elixir or--yeah, you have, like, tons of stuff based on the fact that

00:28:48.160 --> 00:28:52.160
everything is actually communicating over Sockets.

00:28:52.160 --> 00:28:55.160
So, yeah.

00:28:55.160 --> 00:29:01.160
And I think, like, one single thing to say on WebSockets,

00:29:01.160 --> 00:29:09.160
it's I think Emmet is the only or one of the few frameworks that allows you

00:29:09.160 --> 00:29:13.160
to write middlewares with Sockets.

00:29:13.160 --> 00:29:19.160
So you can--so if you have, like, your chain of middlewares on the application,

00:29:19.160 --> 00:29:25.160
you can also define behaviors for the same middlewares to behave on WebSockets.

00:29:25.160 --> 00:29:28.160
So you can probably use, like, a lot of code.

00:29:28.160 --> 00:29:33.160
Like, I don't know, if you are in a WebSocket and need to talk with the database,

00:29:33.160 --> 00:29:37.160
you can use the same middleware for the database connection you use

00:29:37.160 --> 00:29:39.160
on the standard request.

00:29:39.160 --> 00:29:44.160
So I think that might be worth noting.

00:29:44.160 --> 00:29:46.160
Yeah, absolutely.

00:29:46.160 --> 00:29:50.160
Another thing that's interesting that I don't see in a lot of ORMs,

00:29:50.160 --> 00:29:55.160
they kind of just leave it to the--well, in SQL, so you write it,

00:29:55.160 --> 00:29:58.160
is aggregation, right?

00:29:58.160 --> 00:30:02.160
The aggregation stuff you have here is pretty interesting,

00:30:02.160 --> 00:30:06.160
where you do a bunch of calculation-type stuff in the database

00:30:06.160 --> 00:30:09.160
and then get sort of the results back, right?

00:30:09.160 --> 00:30:12.160
So here you can say, like, select--I'm talking about an event--like,

00:30:12.160 --> 00:30:16.160
event.location, get the counts, and then group by this thing,

00:30:16.160 --> 00:30:20.160
order by that, having these sort of--that's pretty unique.

00:30:20.160 --> 00:30:23.160
I don't see that in a lot of ORMs.

00:30:23.160 --> 00:30:28.160
Yeah, I think, like, you can do pretty much the same with the SQLAlchemy,

00:30:28.160 --> 00:30:35.160
but probably, like, the syntax is less sugary, let's say.

00:30:35.160 --> 00:30:43.160
Yeah, I mean, like, again, this design comes from the fact that

00:30:43.160 --> 00:30:47.160
with my first startup, we had to do, like, a lot of aggregation

00:30:47.160 --> 00:30:53.160
over the database, and so, yeah, that's why I wrote all of that,

00:30:53.160 --> 00:30:55.160
you know, to--

00:30:55.160 --> 00:30:56.160
Yeah, that's cool.

00:30:56.160 --> 00:30:58.160
--the same code.

00:30:58.160 --> 00:30:59.160
Yeah, nice.

00:30:59.160 --> 00:31:02.160
You know, I'm familiar with it from all the MongoDB stuff that I've done,

00:31:02.160 --> 00:31:03.160
like that--

00:31:03.160 --> 00:31:04.160
Yeah.

00:31:04.160 --> 00:31:05.160
--aggregation pipeline over there as well.

00:31:05.160 --> 00:31:06.160
Yeah, yeah, yeah.

00:31:06.160 --> 00:31:12.160
I'm also familiar, like, I'm not a huge fan of Mongo, though,

00:31:12.160 --> 00:31:19.160
probably because, like, being an SRE, like, making Mongo reliable

00:31:19.160 --> 00:31:23.160
is, like, a mess sometimes, so probably that's--

00:31:23.160 --> 00:31:27.160
I think it depends on how people rely on it, right?

00:31:27.160 --> 00:31:28.160
Yeah.

00:31:28.160 --> 00:31:30.160
For me, it's been absolutely--I've run my stuff on it for 10 years,

00:31:30.160 --> 00:31:32.160
and it's been perfect.

00:31:32.160 --> 00:31:38.160
However, that's because I use a lot of structured code to talk to Mongo

00:31:38.160 --> 00:31:40.160
from one tech stack, right?

00:31:40.160 --> 00:31:43.160
But if some people are just using dictionaries to talk to it,

00:31:43.160 --> 00:31:46.160
other people are using this framework, other people are using that framework,

00:31:46.160 --> 00:31:51.160
then the lack of a schema structure, I think, becomes a problem.

00:31:51.160 --> 00:31:55.160
So I think it really depends on how you use it.

00:31:55.160 --> 00:31:56.160
Yeah, absolutely.

00:31:56.160 --> 00:31:57.160
But, yeah, I hear what you're saying, for sure.

00:31:57.160 --> 00:32:00.160
I think that's not even necessarily a Mongo challenge.

00:32:00.160 --> 00:32:03.160
That's a document database challenge, generally, right?

00:32:03.160 --> 00:32:05.160
Yeah, yeah.

00:32:05.160 --> 00:32:09.160
Mongo is primarily the way people do document databases.

00:32:09.160 --> 00:32:15.160
Yeah, I tended to, like, use it, like, for separate stuff.

00:32:15.160 --> 00:32:20.160
So in several projects I worked on, I had, like, for instance,

00:32:20.160 --> 00:32:22.160
like the main database with Postgres, for instance,

00:32:22.160 --> 00:32:26.160
and, like, another database with Mongo for specific stuff, you know,

00:32:26.160 --> 00:32:29.160
maybe stuff you don't need transactions on,

00:32:29.160 --> 00:32:33.160
or maybe you want to store, like, time series data,

00:32:33.160 --> 00:32:35.160
or, you know, that kind of stuff.

00:32:35.160 --> 00:32:39.160
So for that, I think it's really cool.

00:32:39.160 --> 00:32:40.160
Yeah, nice.

00:32:40.160 --> 00:32:45.160
All right, I guess one final thing here that is worth covering,

00:32:45.160 --> 00:32:50.160
then I want to dive into a gradient as well, is the template syntax.

00:32:50.160 --> 00:32:54.160
So you've got your own template syntax that's --

00:32:54.160 --> 00:32:57.160
That's not a syntax.

00:32:57.160 --> 00:33:01.160
You tell people about it. You tell them about it.

00:33:01.160 --> 00:33:09.160
Yeah, so the template system embedded in Emmet is called Renoir,

00:33:09.160 --> 00:33:16.160
and the idea behind it is to don't have a syntax at all.

00:33:16.160 --> 00:33:24.160
So the idea behind Emmet template system was why --

00:33:24.160 --> 00:33:28.160
So the question I had is, like, was always, like,

00:33:28.160 --> 00:33:35.160
why do I have to learn a new language to write server-side rendered templates?

00:33:35.160 --> 00:33:36.160
Like, why cannot --

00:33:36.160 --> 00:33:38.160
And those languages are --

00:33:38.160 --> 00:33:42.160
Yeah, and they're very, very Python-like, but they're not Python.

00:33:42.160 --> 00:33:51.160
Exactly. So I just, you know, said, well, I guess I'll try to do just Python,

00:33:51.160 --> 00:33:56.160
you know, wrap it in the same brackets every other templating language has.

00:33:56.160 --> 00:34:00.160
But, yeah, so it's just plain Python.

00:34:00.160 --> 00:34:04.160
You can do pretty much everything you can do in Python.

00:34:04.160 --> 00:34:07.160
You can even do imports inside.

00:34:07.160 --> 00:34:12.160
Not that I suggest to do that, but you can -- still you can do that.

00:34:12.160 --> 00:34:15.160
You'll go crazy. Come on now.

00:34:15.160 --> 00:34:18.160
Exactly.

00:34:18.160 --> 00:34:27.160
The only, let's say, major difference from standard Python code is that you have to write the pass keyword

00:34:27.160 --> 00:34:30.160
after a block of code.

00:34:30.160 --> 00:34:42.160
So if you write, like, a for loop or an if statement, the template engine has to know when that block ends,

00:34:42.160 --> 00:34:47.160
given that Python relies on indentation to understand like that.

00:34:47.160 --> 00:34:52.160
But in templates, you don't have, like, the same indentation level you have in Python.

00:34:52.160 --> 00:34:59.160
So that's the only major difference from, you know, plain Python code.

00:34:59.160 --> 00:35:04.160
Plus a few, let's say, keyword added to the game.

00:35:04.160 --> 00:35:12.160
So you have extend and include in order to, you know, extend and include.

00:35:12.160 --> 00:35:16.160
So they're partial templates, let's say.

00:35:16.160 --> 00:35:20.160
And blocks. That's it.

00:35:20.160 --> 00:35:24.160
Right. Blocks for the layout sections, right?

00:35:24.160 --> 00:35:26.160
Yep, exactly.

00:35:26.160 --> 00:35:30.160
Yeah, that's really nice.

00:35:30.160 --> 00:35:35.160
I like the idea. I'm sure there are people listening that would be like, I would like to try this stuff out,

00:35:35.160 --> 00:35:40.160
but I've got 10,000 lines of Jinja.

00:35:40.160 --> 00:35:43.160
Or I've got 10,000 lines of Chameleon.

00:35:43.160 --> 00:35:51.160
Yeah, yeah, yeah. I mean, I'm working in the office with Armin Ronneker every day.

00:35:51.160 --> 00:35:59.160
So, yeah, I mean, the amount of Jinja code we have in Sentry is, like, huge.

00:35:59.160 --> 00:36:07.160
So, yeah, I perfectly, like, understand the point.

00:36:07.160 --> 00:36:15.160
I don't have, like, let's say, a marketing line for selling, you know, Renoir.

00:36:15.160 --> 00:36:30.160
It's just, you know, something that I -- so today I'm so -- I mean, I'm equitably familiar to Jinja templates and Renoir templates.

00:36:30.160 --> 00:36:43.160
I'd say it really depends on, you know, how you usually structure your application code.

00:36:43.160 --> 00:37:03.160
So I think, like, one good way to try out Renoir is if you tend to don't use a lot, like, Jinja filters or stuff like that.

00:37:03.160 --> 00:37:11.160
That might be a good case scenario to try out Renoir.

00:37:11.160 --> 00:37:25.160
But, of course, it has to be, like, a new project because, like, converting -- I mean, there's no sense into moving, you know, translating code from one system to another once you --

00:37:25.160 --> 00:37:27.160
It's not super different.

00:37:27.160 --> 00:37:35.160
So I think you, you know, change an end if to a pass, for example, or end for into a pass.

00:37:35.160 --> 00:37:42.160
I was thinking more, is there a way to use Jinja within Emmet?

00:37:42.160 --> 00:37:44.160
It's easier than using Renoir.

00:37:44.160 --> 00:37:45.160
Yeah.

00:37:45.160 --> 00:37:51.160
I mean, there's no plain -- there's no read extension for that.

00:37:51.160 --> 00:38:03.160
But, I mean, if you create, like, a Jinja instance over the Emmet application, you can call it, like, in your roots.

00:38:03.160 --> 00:38:05.160
You can even, like, create a middleware for that.

00:38:05.160 --> 00:38:09.160
So I think it's pretty easy also to set up Emmet to work with Jinja.

00:38:09.160 --> 00:38:10.160
Yeah, I would think so.

00:38:10.160 --> 00:38:21.160
I created a chameleon FastAPI, which lets you basically put a decorator on FastAPI endpoints, and it does chameleon template rendering with the dictionary instead of REST endpoints.

00:38:21.160 --> 00:38:24.160
It wasn't that -- you basically just have to juggle it from behind.

00:38:24.160 --> 00:38:29.160
So I imagine you could probably -- someone could create a Jinja decorator.

00:38:29.160 --> 00:38:35.160
Like, you have service.json, like a template.jinja or whatever, something like that, right?

00:38:35.160 --> 00:38:36.160
Probably.

00:38:36.160 --> 00:38:37.160
Yeah.

00:38:37.160 --> 00:38:38.160
Yeah, yeah, absolutely.

00:38:38.160 --> 00:38:40.160
That said, I'm not a fan of Jinja.

00:38:40.160 --> 00:38:41.160
I think it's overly complicated.

00:38:41.160 --> 00:38:44.160
So I'm not encouraging -- I'm not suggesting it.

00:38:44.160 --> 00:38:54.160
But the reality is, even as much as I've tried to fight against it, is that the majority of Python web HTML, dynamic HTML, is done in Jinja these days.

00:38:54.160 --> 00:38:55.160
Yeah.

00:38:55.160 --> 00:38:56.160
Which --

00:38:56.160 --> 00:38:57.160
Yeah, probably.

00:38:57.160 --> 00:38:58.160
Yeah.

00:38:58.160 --> 00:39:01.160
You kind of got to live in that space, even if you don't want to.

00:39:01.160 --> 00:39:02.160
All right.

00:39:02.160 --> 00:39:10.160
And let's talk about the thing that I opened -- I talked about at the opening is Granian.

00:39:10.160 --> 00:39:13.160
Where's Granian gone?

00:39:13.160 --> 00:39:14.160
There we go.

00:39:14.160 --> 00:39:21.160
So this is how, as I said, I got to learn about this framework and what you're doing and stuff with Granian.

00:39:21.160 --> 00:39:23.160
Tell us about Granian.

00:39:23.160 --> 00:39:29.160
And as a way to sort of kick this off, Cody, who I've had on the show before from Litestar, says, "Thanks for the work on Granian.

00:39:29.160 --> 00:39:31.160
I've had an excellent time using it with Litestar."

00:39:31.160 --> 00:39:33.160
Litestar is also awesome.

00:39:33.160 --> 00:39:36.160
Yeah, thanks to Cody.

00:39:36.160 --> 00:39:39.160
Yeah, so tell us about it.

00:39:39.160 --> 00:39:41.160
Yeah.

00:39:41.160 --> 00:39:50.160
So as the description suggests, it's just an HTTP server for Python optimization.

00:39:50.160 --> 00:40:06.160
So it's the same -- it has the same scope of UVCorn, GUnicorn, Hypercorn, and all that libraries.

00:40:06.160 --> 00:40:16.160
The main difference compared to every other HTTP server for Python application is that it's not written in Python.

00:40:16.160 --> 00:40:19.160
It's written in Rust.

00:40:19.160 --> 00:40:34.160
And it supports natively both VUSGI and ASGI, so both synchronous and asynchronous applications.

00:40:34.160 --> 00:40:40.160
Plus a new protocol I also wrote with Granian, which is called RSGI.

00:40:40.160 --> 00:40:47.160
But the only existing framework using it that I am aware of is Emmet, indeed.

00:40:47.160 --> 00:40:50.160
Okay.

00:40:50.160 --> 00:40:53.160
Yeah, I think there's a lot of things that are nice about this.

00:40:53.160 --> 00:41:02.160
And I have actually most of the things, including Talk Python itself, running on Granian, which is pretty cool.

00:41:02.160 --> 00:41:03.160
Cool.

00:41:03.160 --> 00:41:05.160
Yeah, absolutely.

00:41:05.160 --> 00:41:09.160
So single correct HTTP implementation.

00:41:09.160 --> 00:41:10.160
Sounds awesome.

00:41:10.160 --> 00:41:15.160
Support for version 1, 2, and 3, I guess, when it's ratified, right?

00:41:15.160 --> 00:41:31.160
Yeah, so HTTP/3, let's say -- so since Granian is actually based on a Rust library, which is called Hyper, which is a super cool library.

00:41:31.160 --> 00:41:36.160
It's like vastly adopted, like, everywhere in the world.

00:41:36.160 --> 00:41:44.160
Like, I don't know how many thousands -- hundreds of thousands of libraries in the Rust ecosystem use it.

00:41:44.160 --> 00:41:49.160
It is used in Cloudflare for a lot of their production systems.

00:41:49.160 --> 00:41:53.160
So super strong library.

00:41:53.160 --> 00:41:58.160
But, yes, it doesn't yet support HTTP/3.

00:41:58.160 --> 00:42:09.160
So, yeah, I guess when Hyper will support HTTP/3, that could be easily added also to Granian.

00:42:09.160 --> 00:42:10.160
Right.

00:42:10.160 --> 00:42:12.160
Right, that's cool.

00:42:12.160 --> 00:42:19.160
Yeah, with these things like Genocorn, you've then got to also integrate uvicorn workers, and you kind of have a lot of stuff at play, right?

00:42:19.160 --> 00:42:24.160
So here you've just got one thing, which is cool.

00:42:24.160 --> 00:42:43.160
Yeah, I mean, like, I tended to find annoying the fact that if you want, like, to squeeze out, like, performance out of uvicorn, you usually need to pile up different libraries together.

00:42:43.160 --> 00:42:55.160
Like, oh, wait, I need to add the HTTP tools dependency so it can use, like, the C written parsers for HTTP.

00:42:55.160 --> 00:43:03.160
Oh, wait, and probably I want some process management, so I need also Unicorn.

00:43:03.160 --> 00:43:10.160
Yeah, it's not super easy, like, for starters, at least.

00:43:10.160 --> 00:43:12.160
Yeah.

00:43:12.160 --> 00:43:21.160
And I guess maybe we should just set the stage a little bit for people that don't live and breathe Python web deployment topologies.

00:43:21.160 --> 00:43:40.160
So typically you would have something like Nginx or Caddy that the browser actually talks to, and then behind the scenes, you set up those, let's just say Nginx, to when there's a request for a dynamic content or Python-based content, as opposed to, like, a CSS file or something,

00:43:40.160 --> 00:43:52.160
then it will talk to this category of servers that then maybe is juggling multiple processes so that it can increase the scalability of your Python apps and stuff like that, right?

00:43:52.160 --> 00:43:59.160
So Granian lives in that sort of bubble behind Nginx typically, right?

00:43:59.160 --> 00:44:01.160
Use it other ways?

00:44:01.160 --> 00:44:09.160
Yes and no, meaning that you can also deploy it, like, on the edge.

00:44:09.160 --> 00:44:18.160
So I think it really depends how you structure, let's say, your code.

00:44:18.160 --> 00:44:44.160
So for instance, like, for Vue applications, like in Django, we tend to -- I mean, we often, like, offload, let's say, static file serving to Nginx, since we already have Nginx somewhere,

00:44:44.160 --> 00:44:59.160
relying on some, you know, headers we send to the response that Nginx actually parts and understand what to do.

00:44:59.160 --> 00:45:20.160
So if -- in general, if you don't need, like, that kind of optimization, let's say, you can still use Granian, like, even on the edge, because, I mean, it supports, like, SSL, it supports, like, HTTP/2 directly.

00:45:20.160 --> 00:45:35.160
So, I mean, having Nginx above Granian makes sense only if you want to root something out of Granian and not, you know, serve it from Granian.

00:45:35.160 --> 00:45:48.160
But, yeah, in general, I'd say that you can use it in both ways, like, behind Nginx or not, up to the specific needs of the application, let's say.

00:45:48.160 --> 00:45:57.160
Yeah. I have one Nginx Docker server container handling, like, 15 different apps.

00:45:57.160 --> 00:46:07.160
So, for me, that's kind of the setup. But typically, the SSL that I do is over Let's Encrypt using Certbot.

00:46:07.160 --> 00:46:12.160
How do I -- if I want to do HTTPS with Granian, how do I do it?

00:46:12.160 --> 00:46:26.160
I mean, you can keep, like, the Let's Encrypt and LACMESH generation thing, because Granian supports the sync up signal.

00:46:26.160 --> 00:46:41.160
So, whenever you need to refresh the certificate, you can issue async up to the Granian process, and that process will reload the workers picking up the new certificate.

00:46:41.160 --> 00:46:55.160
So, I think it's pretty straightforward. I mean, if you already manage, like, SSL certificates and, like, renewal chain and all that kind of stuff, it's pretty straightforward to do the same in Granian.

00:46:55.160 --> 00:47:06.160
You can just pass, you know, the paths to the certificates to the CLI command or even use environment variables, up to you.

00:47:06.160 --> 00:47:14.160
Gotcha. Okay. One thing that I thought was pretty interesting was the performance.

00:47:14.160 --> 00:47:24.160
Not necessarily that it's so, so, so much faster, but that it's so, so much more consistent. Do you want to talk about that a little bit?

00:47:24.160 --> 00:47:40.160
Yeah, so, I think if you want to show to the YouTube audience the comparison thing, you find the link in the bottom of the page.

00:47:40.160 --> 00:47:50.160
Because the first phase of benchmarks in the repository contains just benchmarks of Granian itself.

00:47:50.160 --> 00:47:56.160
Whereas in the versus page, you can find, like, comparison with other servers.

00:47:56.160 --> 00:48:23.160
So, the thing behind, let's say, the stable keyword I used into describing, like, the performance of Granian was about the fact that usually when people look at benchmarks,

00:48:23.160 --> 00:48:27.160
just look at the number of requests.

00:48:27.160 --> 00:48:32.160
Yeah, yeah, yeah. What's the max request per second you can get with this thing?

00:48:32.160 --> 00:48:43.160
Exactly. But another, like, very important value, at least to me, is the latency.

00:48:43.160 --> 00:48:56.160
Because you can still serve, like, a lot of requests in parallel, but the amount of time each request will take to be served, it's also, like, important.

00:48:56.160 --> 00:49:10.160
I mean, I can serve, like, a thousand requests per second, but if those requests take a second, or it takes, like, 10 milliseconds, it's, like, a huge difference for the end user.

00:49:10.160 --> 00:49:32.160
And so, the thing is that, at least from benchmarks, it appears that the way Granian works, which relies on having, like, all the network stacks separated from Python,

00:49:32.160 --> 00:49:54.160
so all the I/O, the real I/O part involving the network communication, is not tied to the Python interpreter, and so it doesn't suffer from the global interpreter lock and, you know, threads getting blocked between each other.

00:49:54.160 --> 00:50:23.160
It seems to make, like, Granian to be more, let's say, predictable in response time, meaning that both the average latency and the maximum latency you have in the benchmarks is much lower compared to other, let's say, implementations, other HTTP servers.

00:50:23.160 --> 00:50:36.160
So, yeah, it's not, like, super faster. It won't make, like, obviously, it won't make the Python code of your application faster.

00:50:36.160 --> 00:50:42.160
We could shut down all of our servers except for one $5 DigitalOcean server and just...

00:50:42.160 --> 00:50:56.160
Yeah, no, not really. But at least it should, you know, normalize, in a way, the response time of your application.

00:50:56.160 --> 00:51:02.160
Yeah, yeah, yeah. So, the standard deviation of the request time is way, way tighter.

00:51:02.160 --> 00:51:09.160
The distribution of the request time is way, way tighter, even though you do seem to have generally the fastest times.

00:51:09.160 --> 00:51:17.160
But if you look at the difference of the average times and the max times, the difference is a lot smaller.

00:51:17.160 --> 00:51:24.160
It's like, what, two and a half times variation versus some of the other ones are many.

00:51:24.160 --> 00:51:26.160
Yeah, 10x or something.

00:51:26.160 --> 00:51:29.160
Yeah, 100x for some of them. Yeah, yeah, absolutely.

00:51:29.160 --> 00:51:39.160
Okay. Yeah, that's what really I thought was pretty interesting is, you know, the super predictability of it.

00:51:39.160 --> 00:51:47.160
Yeah. One thing I want to ask you about is you did say it does this RSGI?

00:51:47.160 --> 00:51:54.160
Do you want to call it G? GSGI? The Granian server? No, whatever.

00:51:54.160 --> 00:51:59.160
No, it's like Rust server gateway interface.

00:51:59.160 --> 00:52:04.160
Yeah, yeah, yeah. That's what I figured. And you said Emmet uses this, which is awesome.

00:52:04.160 --> 00:52:10.160
What's the advantage? Is there a significant advantage to doing things differently rather than ASGI or something?

00:52:10.160 --> 00:52:16.160
Would it be worth things like Flask saying, "Hey, should we support this if we're running on top of Granian?"

00:52:16.160 --> 00:52:18.160
Or things like that's what I'm getting at.

00:52:18.160 --> 00:52:25.160
So I don't actually know if Flask today also supports asynchronous.

00:52:25.160 --> 00:52:27.160
With Quart they do.

00:52:27.160 --> 00:52:36.160
Okay. So Quart might take advantage of RSGI, meaning that it's still an asynchronous protocol.

00:52:36.160 --> 00:52:42.160
So you have to be in an asynchronous context to use RSGI.

00:52:42.160 --> 00:53:03.160
But the main difference, let's say, between ASGI and RSGI is that it's in the, how to say, the communication mechanism,

00:53:03.160 --> 00:53:07.160
or let's say the communication entities, meaning that...

00:53:07.160 --> 00:53:17.160
So in ASGI you usually have two methods, two awaitable methods, which are like send and receive.

00:53:17.160 --> 00:53:33.160
And you get or push, let's say, dictionaries to those methods, which are referred as messages.

00:53:33.160 --> 00:53:54.160
So you usually have a dictionary which has a type key, which contains the type of message, which might be, I don't know, HTTP request or HTTP body or WebSocket message.

00:53:54.160 --> 00:54:08.160
And all the intercommunication between the server and the application relies on those dictionaries with specific keys and strings.

00:54:08.160 --> 00:54:23.160
And since you have a single, let's say, interface to rely on that, and that interface is asynchronous,

00:54:23.160 --> 00:54:27.160
it also means you, it means two things.

00:54:27.160 --> 00:54:36.160
The first thing is that every time you want to say something to the server or to the client,

00:54:36.160 --> 00:54:46.160
you have to await for that message, even if there's no actually I/O involved in that operation.

00:54:46.160 --> 00:54:51.160
Right, which is a context switch and overhead and all of that stuff, right?

00:54:51.160 --> 00:54:54.160
Exactly. So for example, when you...

00:54:54.160 --> 00:55:01.160
So sending back a response in ASGI involves typically at least two messages.

00:55:01.160 --> 00:55:04.160
So the first one is to start the response.

00:55:04.160 --> 00:55:13.160
So you start the server with the response code and the headers you want to send back to the client.

00:55:13.160 --> 00:55:23.160
And the following message or messages are the body of that response.

00:55:23.160 --> 00:55:33.160
The fun fact is that the response start event doesn't involve any I/O at all.

00:55:33.160 --> 00:55:35.160
It doesn't use the network.

00:55:35.160 --> 00:55:46.160
So what happens in that is that you delaying the operation that you are supposed to do,

00:55:46.160 --> 00:55:52.160
which is just saying, OK, I'm going to send some data and these are the like...

00:55:52.160 --> 00:55:53.160
It's a fact check.

00:55:53.160 --> 00:56:01.160
Yeah. You're going to delay that operation to the next cycle of the event loop in your Python code.

00:56:01.160 --> 00:56:09.160
So that adds quite a lot of overhead.

00:56:09.160 --> 00:56:19.160
And I mean, I understand why the interface is made in this way, because it's super straightforward.

00:56:19.160 --> 00:56:22.160
It's very simple. You have the same interface to do everything.

00:56:22.160 --> 00:56:33.160
But at the same time, it feels very unperformant in a way because we are wasting like a ton of like...

00:56:33.160 --> 00:56:44.160
I don't understand why do we need to waste event loop cycles to do something that is actually synchronous code.

00:56:44.160 --> 00:56:46.160
Yeah, sure.

00:56:46.160 --> 00:57:01.160
And so, yeah, RSGI changed this in a way that you have interfaces which are synchronous or asynchronous,

00:57:01.160 --> 00:57:05.160
depending on what you're actually planning to do.

00:57:05.160 --> 00:57:10.160
For example, like if you have the entire body.

00:57:10.160 --> 00:57:21.160
So if your route returns a JSON stream, OK, you don't need to actually await for sending the body

00:57:21.160 --> 00:57:24.160
because you already have like all the bodies.

00:57:24.160 --> 00:57:26.160
Right, right. There's no I/O.

00:57:26.160 --> 00:57:27.160
Yeah.

00:57:27.160 --> 00:57:31.160
File, file, stream, pointer, whatever they said to return. Yeah.

00:57:31.160 --> 00:57:38.160
Exactly. So in that case, in RSGI, you can use a synchronous method to just move the body to the server

00:57:38.160 --> 00:57:42.160
and just let the response goes.

00:57:42.160 --> 00:57:48.160
Whereas if you want to stream content, then you can use a specific interface for that in RSGI,

00:57:48.160 --> 00:57:56.160
which is RESTfulStream, and that gives you like an interface to send chunks of body or iterate over something

00:57:56.160 --> 00:57:59.160
as you're supposed to do.

00:57:59.160 --> 00:58:02.160
So that's the major thing.

00:58:02.160 --> 00:58:13.160
The other thing, like the other reason why RSGI exists is that, yeah, ASGI is designed based on the fact

00:58:13.160 --> 00:58:23.160
that the network communication happens under Python, which is something that Granian can do because,

00:58:23.160 --> 00:58:28.160
can emulate because it supports ASGI.

00:58:28.160 --> 00:58:40.160
But that also makes, that also wastes, so if you have the chance to have a different implementation,

00:58:40.160 --> 00:58:47.160
that makes like things a lot more difficult to implement.

00:58:47.160 --> 00:58:52.160
Meaning reasoning, like if you were in Python, but you're actually in a different language.

00:58:52.160 --> 00:58:56.160
So yeah, that's the other reason why RSGI exists.

00:58:56.160 --> 00:58:59.160
Okay, yeah, that's very interesting.

00:58:59.160 --> 00:59:04.160
Yeah, maybe some of the other frameworks could look at that and go, well, if it's available, it's an option.

00:59:04.160 --> 00:59:08.160
Okay, a couple of things I want to talk about before we run out of time here.

00:59:08.160 --> 00:59:14.160
One is Jazzy Coder out in the audience asks, how did you validate your library following the correct spec?

00:59:14.160 --> 00:59:21.160
Did you reference the RFCs or another library or if you use, go down,

00:59:21.160 --> 00:59:28.160
like your principles of the Unix networking programming book and for a background interested in this approach,

00:59:28.160 --> 00:59:30.160
because I'm building my own WSGI server.

00:59:30.160 --> 00:59:33.160
Okay, cool.

00:59:33.160 --> 00:59:45.160
So the idea, so I mean, WSGI protocol is like documented in a pet.

00:59:45.160 --> 01:00:01.160
So I just implemented tests that respect what is defined into the original pet about WSGI with just an exception.

01:00:01.160 --> 01:00:15.160
So the only exception for Granian in WSGI protocol is that it's able to serve HTTP/2 over WSGI,

01:00:15.160 --> 01:00:17.160
which is not supposed to happen.

01:00:17.160 --> 01:00:21.160
But with Granian, you can serve your WSGI application directly with HTTP/2.

01:00:21.160 --> 01:00:23.160
Yeah.

01:00:23.160 --> 01:00:30.160
But yeah, that's the way I was sure to respect the protocol.

01:00:30.160 --> 01:00:32.160
How about like the HTTP/2 protocol?

01:00:32.160 --> 01:00:36.160
Are you using just a library that already has it all figured out?

01:00:36.160 --> 01:00:37.160
Yes, yes.

01:00:37.160 --> 01:00:47.160
I mean, reinventing the wheel, like also for HTTP handling was something I wasn't looking for.

01:00:47.160 --> 01:00:49.160
Yeah, I would want to hear that.

01:00:49.160 --> 01:00:53.160
Yeah, hyper is again, super battle tested.

01:00:53.160 --> 01:00:57.160
It's used by, I don't know, something like Cloudflare in production.

01:00:57.160 --> 01:01:00.160
And this is a rest crate or something like that?

01:01:00.160 --> 01:01:02.160
Yeah, exactly.

01:01:02.160 --> 01:01:04.160
Awesome. All right, very cool.

01:01:04.160 --> 01:01:18.160
The other thing I want to ask you about or just let you speak to real quick is there's a bunch of features like specifying the HTTP interface level.

01:01:18.160 --> 01:01:21.160
Do you want to restrict it to one or two?

01:01:21.160 --> 01:01:31.160
You might care because there was a vulnerability in HTTP/2 to create like some kind of too much work or too many retries or something recently.

01:01:31.160 --> 01:01:32.160
So maybe you want to switch it to one for a while.

01:01:32.160 --> 01:01:33.160
I don't know.

01:01:33.160 --> 01:01:35.160
Maybe talk about some of the...

01:01:35.160 --> 01:01:36.160
Yeah, go ahead.

01:01:36.160 --> 01:01:42.160
Fun fact, Granian wasn't affected by that because hyper, the library behind it, wasn't affected by that.

01:01:42.160 --> 01:01:44.160
Oh, nice. That's awesome.

01:01:44.160 --> 01:01:50.160
Yeah, I figured basically just in this case, you wait until hyper either fixes it or hyper is not a problem, right?

01:01:50.160 --> 01:01:51.160
Which is great.

01:01:51.160 --> 01:02:00.160
But maybe just talk about some of the things that we haven't touched on that are interesting, like blocking threads or threading mode or specifying the loop or so on.

01:02:00.160 --> 01:02:15.160
So, yeah, so in Granian, so since Granian has this unique architecture where you have an event loop running on the Rust side.

01:02:15.160 --> 01:02:43.160
So, for instance, if you're like deploying your ASGI application with Granian, you will have two event loops, like the Python one, the ones that runs your code and also a Rust event loop, which is actually the Tokyo runtime is another super popular crate in the Rust ecosystem.

01:02:43.160 --> 01:03:02.160
So, there are different ways to run the Rust runtime, meaning that Rust is not limited to having a single thread running the loop.

01:03:02.160 --> 01:03:13.160
And thus, you can have an event loop running on several different threads on the Rust side.

01:03:13.160 --> 01:03:34.160
And so, the threading mode option in Granian lets you specify that behavior, meaning that if you use the runtime option, you will end up having like multi-threaded runtimes on the Rust side.

01:03:34.160 --> 01:03:47.160
Whereas if you specify the workers option for the threading mode, it will still use a single threaded runtime also on the Rust side.

01:03:47.160 --> 01:03:57.160
If you say the runtime mode, did the workers themselves each get multiple threads? Is that how that works?

01:03:57.160 --> 01:04:10.160
Yes, exactly. So, in runtime mode, every worker has multi-threaded runtimes, whereas on the worker side, you have like the worker is also the runtime.

01:04:10.160 --> 01:04:12.160
Yeah, got it.

01:04:12.160 --> 01:04:22.160
And the option is there because depending on the load of your application, one of the two might work better.

01:04:22.160 --> 01:04:24.160
Sure.

01:04:24.160 --> 01:04:28.160
Depends on the I/O and CPU boundness of your application.

01:04:33.160 --> 01:04:43.160
I don't want to go into too much into this, but if I set threading mode to runtime, is it reasonable to have just one worker? Or does it still make sense to have multiple workers?

01:04:47.160 --> 01:04:59.160
So, the thing is that with a single worker, the workers will spawn their own Python interpreters.

01:04:59.160 --> 01:05:21.160
So, every worker is limited to the global interpreter lock, meaning that even if you spawn a single worker with, I don't know, 12 threads, those 12 threads will run in the Rust code.

01:05:21.160 --> 01:05:27.160
But they share a single Python runtime, which means all the things that that means.

01:05:27.160 --> 01:05:36.160
Exactly. So, the only way to scale... So, the workers is the way to scale, let's say, the Python code of your application.

01:05:36.160 --> 01:05:38.160
Okay.

01:05:38.160 --> 01:05:58.160
So, threads are useful to scale the Rust side of the things, meaning that this will be like the amount of threads used by Rust to handle your requests.

01:05:58.160 --> 01:06:22.160
For example, if your application runs, opens like tons of WebSocket, maybe you have like a WebSocket service, it might be helpful to spawn more threads for the Rust side, so it can actually handle more of those requests in the WebSocket land.

01:06:22.160 --> 01:06:43.160
And the blocking threads are mostly relevant only for the Busky protocol, meaning that the blocking threads are the amount of threads used by Granian to interact with Python code.

01:06:43.160 --> 01:07:03.160
So, on ASGI, since you will have like the event loop, there's not so much difference in how many threads you... how many blocking threads you spawn, because those blocking threads will still have to schedule stuff on the Python event loop.

01:07:03.160 --> 01:07:31.160
But on Busky, since you don't have... you're not limited to the main thread of Python, so if you're... I don't know, maybe your application is using... you're using CycloPG to connect to the database, and those libraries are able to release the global interpreter block.

01:07:31.160 --> 01:07:47.160
So, having multiple blocking threads on Busky might be helpful, still be helpful, because like all the code which doesn't involve the GIL will be able to run in Python.

01:07:47.160 --> 01:07:54.160
Right. Maybe one part, one thread, one request is waiting on a database call, which hits the network, which releases the GIL, for example, right?

01:07:54.160 --> 01:07:55.160
Exactly.

01:07:55.160 --> 01:08:02.160
Yeah, okay. What about this loop optimizations? This opt, no op?

01:08:02.160 --> 01:08:04.160
Yeah, that's...

01:08:04.160 --> 01:08:06.160
What kind of magic is in there?

01:08:06.160 --> 01:08:25.160
That's a bit complicated, meaning that I... so I think writing Runnion was super helpful for me, at least, to understand the internals of asyncIO in the Python world.

01:08:25.160 --> 01:08:37.160
And if I have to be honest, I don't really like how asyncIO is implemented behind Hoot, but anyway...

01:08:37.160 --> 01:08:50.160
I feel like you have to juggle, you have to be so aware of what loop is running, has a loop been created, is there a different one, have I got the wrong loop, like all of that stuff, it should be utterly transparent.

01:08:50.160 --> 01:09:03.160
And I should just tell Python, I want to run stuff in a loop. And I don't want to... it's not like I'm managing the memory or juggling the GC.

01:09:03.160 --> 01:09:10.160
I feel like asyncIO should be the same. You should say, I want to run stuff asynchronously, and maybe somewhere I've configured that, or maybe it's automatic, whatever.

01:09:10.160 --> 01:09:25.160
Just do any... you're always kind of like... for example, if you talk to the database asynchronously at the start of your web app, and then you use FastAPI, and you try to use it in your request there, it'll say, well, you're on the wrong event loop.

01:09:25.160 --> 01:09:31.160
It's like, well, why do I care about this? Just run it on the loop. You know what I mean?

01:09:31.160 --> 01:09:37.160
That's been a complaint of mine since 3.5, but hey, nobody asked me, so...

01:09:37.160 --> 01:09:47.160
Yeah, so... yeah, and those, let's say, optimizations are actually a few hacky parts.

01:09:47.160 --> 01:09:59.160
In fact, I think FastAPI doesn't work with loop optimization enabled with Grainium, because it skips...

01:09:59.160 --> 01:10:07.160
So those optimizations just skip one of the first iterations into running asynchronous code.

01:10:07.160 --> 01:10:22.160
I think going more deeper than this in details would be long and hard to follow, but let's just say it just keeps some steps in the task running in the other loop.

01:10:22.160 --> 01:10:30.160
Yeah, okay. You can do things like specify the SSL certificates and stuff. This one right here is pretty excellent. I mean, I don't know who worked on that one.

01:10:30.160 --> 01:10:37.160
I didn't work on it, but I inspired... I requested this one as the right way to put... that you can say the process name, which is nice.

01:10:37.160 --> 01:10:38.160
Yeah, yeah.

01:10:38.160 --> 01:10:44.160
If you're running multiple sites all on Grainium on the same server, so you can differentiate...

01:10:44.160 --> 01:10:45.160
Absolutely.

01:10:45.160 --> 01:10:47.160
Which one is using the memory again?

01:10:47.160 --> 01:10:53.160
And while we're looking at this, can I propose an idea and just get your feedback on it, get your thoughts?

01:10:53.160 --> 01:11:15.160
What about a lifetime management type of feature where you say, "After 10,000 requests, just recreate the worker," or "After an hour, recreate the worker," or something like that?

01:11:15.160 --> 01:11:18.160
Is this a thing that is in any interest to you?

01:11:18.160 --> 01:11:41.160
So I understand the need for that, especially for... I think it's one of those requests that is based on the fact of using Busgy, or at least it's coming more from the Django user lens.

01:11:41.160 --> 01:12:05.160
So I think making a lifetime, that kind of check would be kind of hard in a sense that there's a lot involved into the process management of Grainium,

01:12:05.160 --> 01:12:14.160
because you have the Python process, and then you have Python threads, and then you have the Rust threads, and then you have the runtimes.

01:12:14.160 --> 01:12:15.160
Yeah, yeah.

01:12:15.160 --> 01:12:21.160
So reasoning of lifetime probably, it's kind of hard.

01:12:21.160 --> 01:12:36.160
I think fixing a maximum number of requests per worker is something... Yeah, it can be done, let's say, pretty easily.

01:12:36.160 --> 01:12:48.160
Yeah, that issue is open by... There's an issue for that open by a few times, if I recall correctly.

01:12:48.160 --> 01:12:54.160
The thing is that in the prioritization queue...

01:12:54.160 --> 01:12:56.160
It's not a tough...

01:12:56.160 --> 01:13:15.160
At the moment, I'm talking with some people that propose their self to join as a contributor on Grainium, but let's say, at the moment, I'm still a single main contributor.

01:13:15.160 --> 01:13:22.160
So I need to make some priority queues into issues.

01:13:22.160 --> 01:13:31.160
Yeah, I think the one which is more requested right now is the access log.

01:13:31.160 --> 01:13:37.160
So I think that would be the next one, probably.

01:13:37.160 --> 01:13:42.160
Yeah, sure. I think honestly, that's more important, the access log than this one.

01:13:42.160 --> 01:13:55.160
Yeah, something changed in one of my apps, and it just all of a sudden slowly just keeps growing in memory, and I'm pretty sure I've not done anything to make those changes.

01:13:55.160 --> 01:14:01.160
And it's something in a third-party library, data access, database, or something else.

01:14:01.160 --> 01:14:07.160
I don't know what it is, but it's just... And it's fine, but it just consumes so much memory.

01:14:07.160 --> 01:14:17.160
So I need to set up some other thing to just say, "Look, after a day, just give it a refresh. Let it refresh itself."

01:14:17.160 --> 01:14:31.160
You know that with Sentry SDK now we have also profiling, so you can actually look into the stacks of memory allocations even live on your application.

01:14:31.160 --> 01:14:39.160
So if you need to debug something like that, you can try Distributed Tracing or something like that.

01:14:39.160 --> 01:14:45.160
I mean, Distributed Tracing is more about putting together different sources.

01:14:45.160 --> 01:14:53.160
This is profiling, like flame graphs and stuff to see where does your application...

01:14:53.160 --> 01:14:59.160
It's driving me crazy, and I would love to just do a PR to somewhere and just go, "Hey guys, this changed. Here's the problem."

01:14:59.160 --> 01:15:06.160
Or if it is my problem, and I just like, "There's nothing I really changed in the core of this thing, but it seems to have started going weird," then maybe I don't know.

01:15:06.160 --> 01:15:09.160
But anyway, it would be great. I'll have a look at it. Thanks.

01:15:09.160 --> 01:15:15.160
All right. What's next? What's next for Granian?

01:15:15.160 --> 01:15:31.160
Yeah, I think fulfilling a couple of feature requests like the access log, like the worker max request, or a few, let's say, minor things in that sense.

01:15:31.160 --> 01:15:45.160
I think in terms of major features, it's pretty solid at the moment as a server.

01:15:45.160 --> 01:15:57.160
After, let's say, the idea is after these feature requests, the idea was to...

01:15:57.160 --> 01:16:09.160
I mean, it's just an idea at the moment, but I'd like to try to add some features to the RSGI protocol.

01:16:09.160 --> 01:16:17.160
For example, we talked before about channels and WebSockets.

01:16:17.160 --> 01:16:32.160
As I said before, I find it very annoying every time I want to make even just a chat room, I need to put Redis there and manage Redis and whatever.

01:16:32.160 --> 01:16:38.160
And add that kind of complexity to my project.

01:16:38.160 --> 01:16:46.160
And so I was thinking about embedding some broadcasting features into the RSGI protocol.

01:16:46.160 --> 01:17:00.160
Because while all other servers for Python are written in Python, and so they're still bound to the process paradigm of Python,

01:17:00.160 --> 01:17:05.160
on the Rust side of things, that's not true anymore.

01:17:05.160 --> 01:17:17.160
So the idea would be to have something to broadcast messages between processes and even different granular servers.

01:17:17.160 --> 01:17:24.160
So yeah, that's what I have on my table at the moment.

01:17:24.160 --> 01:17:32.160
All right, well, excellent. And thanks for working on this. It's an excellent project.

01:17:32.160 --> 01:17:36.160
And it's really cool to see the innovation, like you were saying just there.

01:17:36.160 --> 01:17:44.160
If it's not in Python, if it could be in Rust, what would we change that would make that more capable even for the Python people, right?

01:17:44.160 --> 01:17:56.160
Yeah, exactly. And I think it's like the baseline philosophy of people like Samuel Colvin with the Pyantic project,

01:17:56.160 --> 01:18:12.160
to try to empower Python, keeping the simplicity and the syntax we all love about Python.

01:18:12.160 --> 01:18:24.160
But yeah, I mean, I think it's like a very good way of evolving even the Python language.

01:18:24.160 --> 01:18:28.160
Yeah, absolutely. You know, sometimes you'll hear people say Python is slow.

01:18:28.160 --> 01:18:32.160
And then in some sort of pure sense, that's true.

01:18:32.160 --> 01:18:37.160
But then you put it on top of things like Grandian, and all of a sudden, it's awesome, right?

01:18:37.160 --> 01:18:41.160
So thanks for playing your part in that.

01:18:41.160 --> 01:18:42.160
Thank you, too.

01:18:42.160 --> 01:18:46.160
Yeah, you bet. And thanks for coming on the show. See you next time.

01:18:46.160 --> 01:18:47.160
Thank you. Bye.

01:18:47.160 --> 01:18:48.160
Bye.

