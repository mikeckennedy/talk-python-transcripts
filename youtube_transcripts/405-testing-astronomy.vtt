WEBVTT

00:00:00.000 --> 00:00:06.560
>> James, welcome to the podcast. Welcome to YouTube. And talk Python in a moment.


00:00:06.560 --> 00:00:10.080
>> Thank you for having me, Michael. >> It's fantastic to have you here. We're


00:00:10.080 --> 00:00:14.920
going to have a great time. People out on the live stream, thank you for being here.


00:00:14.920 --> 00:00:18.120
If you've got comments, questions, throw them into the live stream. If you're watching later,


00:00:18.120 --> 00:00:23.320
thanks for watching later. All right. Ready to kick this off, James?


00:00:23.320 --> 00:00:27.280
>> Yes. >> Right on. James, welcome to talk Python


00:00:27.280 --> 00:00:34.560
Normally I talk Python to computers, Michael, but this will be a first.


00:00:34.560 --> 00:00:35.720
You are a human, right?


00:00:35.720 --> 00:00:36.720
I am.


00:00:36.720 --> 00:00:39.680
Well, you know, you've got to ask ChatGCP about that.


00:00:39.680 --> 00:00:40.680
We'll see.


00:00:40.680 --> 00:00:45.160
You know, there's a lot of people who are interested in talking about Python.


00:00:45.160 --> 00:00:49.560
When I first put this podcast together, I thought, well, who's going to be the target


00:00:49.560 --> 00:00:50.560
audience?


00:00:50.560 --> 00:00:53.280
I thought people were really into Python.


00:00:53.280 --> 00:00:56.280
People make things like Flask and stuff.


00:00:56.280 --> 00:01:00.940
kind of a big part of the world, but there's a ton of people who are scientists or just


00:01:00.940 --> 00:01:02.900
curious about programming who listen as well.


00:01:02.900 --> 00:01:07.740
So it really surprised me how many people you can talk Python to and how much they seem


00:01:07.740 --> 00:01:08.740
to appreciate it.


00:01:08.740 --> 00:01:09.740
So it's cool.


00:01:09.740 --> 00:01:10.740
Indeed.


00:01:10.740 --> 00:01:11.740
Indeed.


00:01:11.740 --> 00:01:16.260
Yeah, but I also spend a fair amount of time talking Python to computers as well.


00:01:16.260 --> 00:01:17.660
Sometimes more fun, sometimes more frustrating.


00:01:17.660 --> 00:01:19.060
You never know.


00:01:19.060 --> 00:01:21.460
Yes, we're familiar with that.


00:01:21.460 --> 00:01:22.460
I'm sure.


00:01:22.460 --> 00:01:23.460
I'm sure.


00:01:23.460 --> 00:01:30.700
this extra angle of it's not just talking to pure software, right, that lives in an


00:01:30.700 --> 00:01:36.240
internet API vacuum, but you have physical things, many, many physical


00:01:36.240 --> 00:01:42.340
things in radio astronomy and large arrays of telescopes and receivers and


00:01:42.340 --> 00:01:45.260
as we're going to talk about, lots of different things. And I think that's one


00:01:45.260 --> 00:01:50.780
of the really interesting aspects of this episode to talk to you is, you know,


00:01:50.780 --> 00:01:55.780
Python against real world things out there and real time as well.


00:01:55.780 --> 00:02:00.780
Yes, so I can talk a little bit about that.


00:02:00.780 --> 00:02:10.780
Yeah. So perhaps sort of to jump back and put the listeners in a bit of context, I work at the South African Radio Astronomy Observatory.


00:02:10.780 --> 00:02:17.340
Observatory and our sort of primary project is called Meerkat. It's a


00:02:17.340 --> 00:02:23.180
precursor of one of the world's biggest radio telescopes which is


00:02:23.180 --> 00:02:30.100
planned. So the project is called SKA, so it stands for Square


00:02:30.100 --> 00:02:34.620
Kilometer Array, which refers to the size of the collecting area of the telescope


00:02:34.620 --> 00:02:39.860
that will eventually be built. It's in its beginning stages now and that has a


00:02:39.860 --> 00:02:47.060
lot of moving parts. Right from the actual antennas that are pointing


00:02:47.060 --> 00:02:52.500
into the sky and recording radio emissions from the universe somewhere,


00:02:52.500 --> 00:02:58.300
through down to the point where a scientist actually sits down with a data


00:02:58.300 --> 00:03:02.500
product in order to to analyze and to write his paper that he's hoping to


00:03:02.500 --> 00:03:10.840
publish and win his Nobel Prize. And so everything from the


00:03:10.840 --> 00:03:15.560
beginning of the end there needs some software control and Python is the


00:03:15.560 --> 00:03:20.920
the sort of weapon of choice for all of those applications.


00:03:20.920 --> 00:03:25.920
Yeah it's pretty interesting to see what you're talking about, you gave a couple


00:03:25.920 --> 00:03:34.160
presentations at PyCon South Africa? ZD? That's right, yes. Last year. Yeah, fantastic. And people


00:03:34.160 --> 00:03:37.680
all of course link to those in the show notes and people can check them out. You got a lot of


00:03:37.680 --> 00:03:46.880
cool graphics and stuff there. I think the fact that you built this real-time aspect involving


00:03:46.880 --> 00:03:52.400
Python, which is not normal use perhaps, I think is really something that we're going to have a


00:03:52.400 --> 00:03:56.560
a good time talking about as well as just how do you test something like a


00:03:56.560 --> 00:04:02.640
large receiver array rather than you know is the user logged in the database


00:04:02.640 --> 00:04:07.000
yes or no and let's mock that out right this is both I think very similar and


00:04:07.000 --> 00:04:13.920
yet very different right yes it can be and there are there's a lot that you can


00:04:13.920 --> 00:04:17.200
do but there's also some interesting gotchas which we can talk


00:04:17.200 --> 00:04:23.940
about there. So I mean I don't know where you want to want to start. Well let's


00:04:23.940 --> 00:04:27.380
let's get a real quick introduction with you before we get too far


00:04:27.380 --> 00:04:31.700
down in this topic and so tell people how you got into programming and


00:04:31.700 --> 00:04:38.260
astronomy and all that kind of stuff. Well programming, well both of those have


00:04:38.260 --> 00:04:41.620
become, both of those started out as hobbies and they've sort of become my


00:04:41.620 --> 00:04:48.280
job, which means I don't do them as a hobby anymore, which is always fun. When I


00:04:48.280 --> 00:04:53.040
was younger in school I made the mistake during a summer holiday of telling my


00:04:53.040 --> 00:04:58.960
dad that I was bored and so he handed me a book and this book was


00:04:58.960 --> 00:05:06.700
Programming in C I think, I forget exactly and being young and naive I


00:05:06.700 --> 00:05:12.060
thought this was a great idea and started working my way through it.


00:05:12.060 --> 00:05:18.940
Since then I've been programming more or less continuously. It was sort of the


00:05:18.940 --> 00:05:22.500
mid to late 2000s that Python started to become more prominent and I picked that


00:05:22.500 --> 00:05:29.900
up and haven't looked back. Astronomy was also another hobby. In my student days I


00:05:29.900 --> 00:05:34.940
spent many South African, cold South African nights looking at the


00:05:34.940 --> 00:05:44.180
stars and a job opportunity opened up at Sareo to do electronic engineering, which was the


00:05:44.180 --> 00:05:47.460
field that I trained in university.


00:05:47.460 --> 00:05:54.220
That was about seven years ago and so I've been combining these sort of programming and


00:05:54.220 --> 00:06:01.180
electronic engineering and my astronomy hobby, which has shifted now into radio instead of


00:06:01.180 --> 00:06:02.180
optical.


00:06:02.180 --> 00:06:06.140
But yeah, I basically come from there.


00:06:06.140 --> 00:06:08.180
- Fantastic.


00:06:08.180 --> 00:06:11.580
I remember getting a book and see if they get on,


00:06:11.580 --> 00:06:13.780
I'm gonna learn programming and then read it like,


00:06:13.780 --> 00:06:15.340
okay, this, I know it's pretty young.


00:06:15.340 --> 00:06:17.800
Okay, this is a little bit much to bite off at the moment,


00:06:17.800 --> 00:06:19.720
but came back to as well.


00:06:19.720 --> 00:06:21.560
But that's how it was, right?


00:06:21.560 --> 00:06:26.340
We used to get books, free internet, YouTube,


00:06:26.340 --> 00:06:27.720
and where you just fired up and say,


00:06:27.720 --> 00:06:30.080
teach me programming in the next half hour.


00:06:30.080 --> 00:06:32.400
with listings of code and you have to type them in


00:06:32.400 --> 00:06:34.840
and then you miss a semicolon somewhere


00:06:34.840 --> 00:06:36.680
and scratch your head for half a day.


00:06:36.680 --> 00:06:37.500
(laughing)


00:06:37.500 --> 00:06:38.340
- That's right.


00:06:38.340 --> 00:06:40.280
- But I think that was a good preparation though.


00:06:40.280 --> 00:06:43.780
I mean, as great as Python is, it is somewhat high level


00:06:43.780 --> 00:06:46.260
and I think it's helpful to have a sort of a,


00:06:46.260 --> 00:06:48.440
even if you don't often work at that level,


00:06:48.440 --> 00:06:49.960
to have an understanding of what's going on


00:06:49.960 --> 00:06:51.240
at a slightly lower level.


00:06:51.240 --> 00:06:54.200
- It is, I think it's valuable to know


00:06:54.200 --> 00:06:56.280
and it's valuable to have that experience,


00:06:56.280 --> 00:06:58.880
but I'm also, even though I did it professionally


00:06:58.880 --> 00:07:03.760
a couple years. Happy that I'm not. I don't have to continuously work at that level, right?


00:07:03.760 --> 00:07:07.520
You can just be so more productive and higher level language on Python.


00:07:07.520 --> 00:07:08.520
Totally.


00:07:08.520 --> 00:07:17.360
Yeah. So I think you introduced this a little bit, but tell people about Serrao, this project.


00:07:17.360 --> 00:07:19.920
How'd you get to that place?


00:07:19.920 --> 00:07:27.160
Yeah. Serrao, well, I got there by responding to a job advert and interviewing and what


00:07:27.160 --> 00:07:36.640
have you. Sareo sort of started out as a response to the international kind of


00:07:36.640 --> 00:07:42.160
scientific project to build a square kilometer array telescope. The idea


00:07:42.160 --> 00:07:46.240
is to make it the most sensitive radio telescope that has ever been built and


00:07:46.240 --> 00:07:50.840
when you're doing that kind of project you want to build it in an ideal setting


00:07:50.840 --> 00:07:55.320
just like optical telescopes if you want to do proper science you want to do it


00:07:55.320 --> 00:07:58.480
far away from cities where there's no light pollution.


00:07:58.480 --> 00:08:00.580
Similarly, radio telescopes, you want to do them


00:08:00.580 --> 00:08:03.500
where there's no radio interference.


00:08:03.500 --> 00:08:06.200
So cell phones, TV signals, Wi-Fi, that kind of stuff.


00:08:06.200 --> 00:08:11.040
The Southern Hemisphere also has a bit of an advantage


00:08:11.040 --> 00:08:14.080
in that we can see parts of the galaxy


00:08:14.080 --> 00:08:15.740
that the Northern Hemisphere can't.


00:08:15.740 --> 00:08:20.740
And so, you know, as this project progressed,


00:08:20.740 --> 00:08:23.040
various sites were identified,


00:08:23.040 --> 00:08:27.380
and ultimately the decision was made to put part of the telescope in South Africa and


00:08:27.380 --> 00:08:29.400
part of it in Australia.


00:08:29.400 --> 00:08:36.680
And Sareo is really just the organization around developing the South African part of


00:08:36.680 --> 00:08:38.400
that telescope.


00:08:38.400 --> 00:08:40.520
So that's where we are.


00:08:40.520 --> 00:08:42.860
It's a very cool project.


00:08:42.860 --> 00:08:49.240
I think a square kilometer array of telescope, that's pretty impressive, right?


00:08:49.240 --> 00:08:56.600
Also something that's much easier to do with radio than with optical. Yes, so


00:08:56.600 --> 00:09:04.960
when it comes to telescopes bigger is better but there reaches a point of


00:09:04.960 --> 00:09:12.280
where building a bigger one becomes expensive and very difficult and


00:09:12.280 --> 00:09:19.040
so a trick that you can use in radio is called interferometry. So if you


00:09:19.040 --> 00:09:23.760
have, if you measure your radio waves at different points and you measure them in


00:09:23.760 --> 00:09:28.440
phase with each other or what they call coherently, then you can get away with


00:09:28.440 --> 00:09:35.900
with making a lot of smaller telescopes to build up the same kind of area which


00:09:35.900 --> 00:09:39.640
will give you the same effect as a bigger one but much cheaper


00:09:39.640 --> 00:09:44.220
because you can do a lot of smaller cheaper telescopes. That in a


00:09:44.220 --> 00:09:48.440
nutshell is really why these telescope arrays exist. It's very difficult to do


00:09:48.440 --> 00:09:55.240
that with optical telescopes because the wavelength is so short, the frequency is so high that


00:09:55.240 --> 00:10:01.700
getting the, it is possible, it can be done, but getting the signal coherent or in phase


00:10:01.700 --> 00:10:04.080
is very, very difficult.


00:10:04.080 --> 00:10:06.280
So that's why we do it in radio.


00:10:06.280 --> 00:10:10.920
Yeah, you don't have much time, there's not much of a gap between how you've got to coordinate


00:10:10.920 --> 00:10:14.080
the signals across the radio, but it's even worse in optical.


00:10:14.080 --> 00:10:16.640
Exactly, exactly.


00:10:16.640 --> 00:10:22.320
Nice. So people who listened to the episode about imaging the black hole, we


00:10:22.320 --> 00:10:26.740
talked a lot about that. So I don't necessarily need to think we need to


00:10:26.740 --> 00:10:31.960
cover too much depth about it. But one thing I think that people might find


00:10:31.960 --> 00:10:36.360
interesting is I think remember from your talk that you said this is part,


00:10:36.360 --> 00:10:40.160
some of the work that you're doing is part of the deep space network for


00:10:40.160 --> 00:10:49.120
communicating with, is that right, with NASA? The South African radio astronomy has its origins in


00:10:49.120 --> 00:10:55.480
the deep space network, so if you're trying to communicate with spacecraft that are outside of


00:10:55.480 --> 00:11:04.320
Earth orbit, you need a very powerful, something that looks a bit like a radio telescope, except


00:11:04.320 --> 00:11:09.000
that you're transmitting as well, because you need to be able to talk to the, you know, Voyager or


00:11:09.000 --> 00:11:12.980
or your Mars rover that's out there in space.


00:11:12.980 --> 00:11:15.660
But very inconveniently for scientific purposes,


00:11:15.660 --> 00:11:17.140
the Earth rotates.


00:11:17.140 --> 00:11:19.060
So for about a third of the day,


00:11:19.060 --> 00:11:23.220
if you have a telescope in California, for example,


00:11:23.220 --> 00:11:25.760
I think is where one of NASA's big ones are,


00:11:25.760 --> 00:11:31.500
half of the day you can't really talk to your spaceships.


00:11:31.500 --> 00:11:38.740
So NASA built a network of telescopes around the world


00:11:38.740 --> 00:11:42.720
and one was in Australia and one was here in South Africa.


00:11:42.720 --> 00:11:45.160
And some of the early Mars missions


00:11:45.160 --> 00:11:49.440
were actually used the telescope in South Africa


00:11:49.440 --> 00:11:52.160
for communication.


00:11:52.160 --> 00:11:59.040
But that was, I think in the 70s,


00:11:59.040 --> 00:12:00.760
I forget my history exactly,


00:12:00.760 --> 00:12:03.240
but they got a better one in Spain.


00:12:03.240 --> 00:12:06.680
And so the one in South Africa was kind of converted


00:12:06.680 --> 00:12:08.620
into a facility just for science.


00:12:08.620 --> 00:12:13.620
And it's been operated by our National Research Foundation,


00:12:13.620 --> 00:12:18.620
which evolved into Sareo for the last sort of few years.


00:12:18.620 --> 00:12:22.180
And that's what kind of gave us our leg up.


00:12:22.180 --> 00:12:23.020
- Yeah, exactly.


00:12:23.020 --> 00:12:25.060
That it was already built and it was there.


00:12:25.060 --> 00:12:26.420
And you're like, you know what?


00:12:26.420 --> 00:12:28.500
Instead of just let it, put it on mothballs,


00:12:28.500 --> 00:12:30.100
why don't you guys do science with it, right?


00:12:30.100 --> 00:12:30.940
That's cool.


00:12:30.940 --> 00:12:33.580
- And we've been using it quite well since then.


00:12:33.580 --> 00:12:36.380
They've done, I wouldn't say groundbreaking science.


00:12:36.380 --> 00:12:38.160
I don't know that any Nobel prizes have happened,


00:12:38.160 --> 00:12:41.120
but we have some good radio astronomers originating


00:12:41.120 --> 00:12:43.680
from South Africa that have used data from this telescope.


00:12:43.680 --> 00:12:45.720
So, yeah.


00:12:45.720 --> 00:12:46.640
>> Excellent.


00:12:46.640 --> 00:12:50.680
All right, let's talk about first the real-time aspect,


00:12:50.680 --> 00:12:53.840
this thing that you focus on called the correlator, right?


00:12:53.840 --> 00:12:57.200
And maybe give us this side of the story


00:12:57.200 --> 00:13:00.240
because I think this alone is pretty interesting,


00:13:00.240 --> 00:13:02.400
what you've built here with Python, you and your team.


00:13:02.400 --> 00:13:06.880
>> So, from a conceptual point of view,


00:13:06.880 --> 00:13:12.200
In the episode a few weeks ago where you interviewed Dr. Sarah Essoon, I don't know if I'm pronouncing


00:13:12.200 --> 00:13:18.800
her name correctly, the Event Horizon telescope worked by pointing different telescopes around


00:13:18.800 --> 00:13:23.040
the world at the same object.


00:13:23.040 --> 00:13:30.200
All radio telescopes arrays, whether they're very long baseline like what she used or much


00:13:30.200 --> 00:13:35.340
shorter, have something called a correlator and this is the thing that basically combines


00:13:35.340 --> 00:13:42.340
the signals from the individual telescopes in a way that enables downstream users, so


00:13:42.340 --> 00:13:52.420
scientists, to actually make sense of this data. So in order for that to work, the data


00:13:52.420 --> 00:13:58.800
needs to be in phase, it needs to be coherent, and at very long baselines they do this by


00:13:58.800 --> 00:14:03.660
having each station having their very own atomic clock to generate very precise reference


00:14:03.660 --> 00:14:04.580
signals.


00:14:04.580 --> 00:14:07.380
- As a reminder, sorry, just as a reminder


00:14:07.380 --> 00:14:09.780
for people maybe didn't hear that episode is,


00:14:09.780 --> 00:14:13.800
you know, the earth is curved, as we all know, hopefully,


00:14:13.800 --> 00:14:17.820
and the radio waves come in, and as it hits that sphere,


00:14:17.820 --> 00:14:19.460
they hit the different parts of the array,


00:14:19.460 --> 00:14:22.000
it's more spread out, it is even more exaggerated,


00:14:22.000 --> 00:14:23.920
but it hits the different parts of the array


00:14:23.920 --> 00:14:26.940
at different times, and so you have to offset


00:14:26.940 --> 00:14:28.180
those back in the signal to say,


00:14:28.180 --> 00:14:29.300
well, it came in at this angle,


00:14:29.300 --> 00:14:31.300
and it came in at this time, and the speed of light says,


00:14:31.300 --> 00:14:34.200
this one is, you know, a nanosecond behind that one,


00:14:34.200 --> 00:14:37.640
So you've got to figure out how to realign those so it looks


00:14:37.640 --> 00:14:41.140
like a flat surface that they hit all simultaneously to look


00:14:41.140 --> 00:14:43.080
like a single picture, right?


00:14:43.080 --> 00:14:43.640
>> Exactly.


00:14:43.640 --> 00:14:46.680
>> That's basically the job of this thing.


00:14:46.680 --> 00:14:51.760
>> So partially, you can do the first bit with just with geometry.


00:14:51.760 --> 00:14:54.200
We know what the rotation of the earth is.


00:14:54.200 --> 00:14:58.440
We know where our different telescopes are.


00:14:58.440 --> 00:15:02.240
And so we can calculate roughly what the time difference will be.


00:15:02.240 --> 00:15:04.760
The job of the correlator is once you've got those signals


00:15:04.760 --> 00:15:09.760
and you've applied your sort of rough delay offset


00:15:09.760 --> 00:15:11.760
to each of those signals,


00:15:11.760 --> 00:15:16.680
the correlator will find the correlations


00:15:16.680 --> 00:15:19.240
between the incoming signals


00:15:19.240 --> 00:15:22.000
simply by multiplying the signals together.


00:15:22.000 --> 00:15:23.920
Mathematically, it's not terribly complicated.


00:15:23.920 --> 00:15:28.920
It's really just multiplication of each pair of antennas.


00:15:28.920 --> 00:15:32.040
But it's with that, you may remember your,


00:15:32.040 --> 00:15:33.560
from your high school mathematics,


00:15:33.560 --> 00:15:35.140
the trigonometric identity.


00:15:35.140 --> 00:15:38.080
When you multiply two sine waves together,


00:15:38.080 --> 00:15:42.480
you get a sum and a difference product.


00:15:42.480 --> 00:15:44.240
And it's a similar kind of concept,


00:15:44.240 --> 00:15:48.960
applying to not just to abstract sine waves,


00:15:48.960 --> 00:15:52.400
but to radio waves that are, you know,


00:15:52.400 --> 00:15:53.820
have at various frequencies.


00:15:53.820 --> 00:15:57.840
The main engineering challenge is just doing this fast enough


00:15:57.840 --> 00:16:00.120
for practical purposes.


00:16:01.040 --> 00:16:04.920
So in the example of the Event Horizon Telescope


00:16:04.920 --> 00:16:07.560
with very long baseline interferometry,


00:16:07.560 --> 00:16:09.160
it's not possible to do it in real time


00:16:09.160 --> 00:16:11.880
because your individual elements are just too far apart.


00:16:11.880 --> 00:16:14.240
You can't get all the data together.


00:16:14.240 --> 00:16:15.680
So--


00:16:15.680 --> 00:16:19.020
- Not for math, but because the actual data quantity,


00:16:19.020 --> 00:16:22.000
getting them all back and forth across the world is--


00:16:22.000 --> 00:16:24.260
- Exactly, exactly.


00:16:24.260 --> 00:16:28.240
So there's specialized hardware that takes those signals


00:16:28.240 --> 00:16:31.840
and writes them basically just straight onto hard drives.


00:16:31.840 --> 00:16:36.520
Then these hard drives are physically taken to a central location.


00:16:36.520 --> 00:16:40.040
I think Sarah did talk about that in her episode.


00:16:40.040 --> 00:16:41.360
And then --


00:16:41.360 --> 00:16:44.760
>> It was Boston and maybe Cambridge and London.


00:16:44.760 --> 00:16:46.040
>> One was in Europe, yes.


00:16:46.040 --> 00:16:48.840
>> No, that's the Institute in Germany is what it was, I believe.


00:16:48.840 --> 00:16:50.140
>> That's right, yeah.


00:16:50.140 --> 00:16:52.680
One was in the States, one was in Europe.


00:16:52.680 --> 00:16:55.160
Yes, and so -- and then the same --


00:16:55.160 --> 00:16:57.520
well, similar equipment does the reverse process.


00:16:57.520 --> 00:17:00.640
It reads the data off and then it basically batch processes it.


00:17:00.640 --> 00:17:06.360
This happens in software, so you cross multiply all of the signals together.


00:17:06.360 --> 00:17:14.960
And that's great if you have a limited number of telescopes, you know,


00:17:14.960 --> 00:17:18.560
up to a few dozen or so as with Event Horizon Telescope.


00:17:18.560 --> 00:17:23.480
In the Meerkat case, we've got 64 of them and we're building a few more.


00:17:23.480 --> 00:17:26.820
And as it becomes the full square kilometer array,


00:17:26.820 --> 00:17:28.520
we're going to be talking about hundreds


00:17:28.520 --> 00:17:30.020
or possibly even thousands


00:17:30.020 --> 00:17:32.200
of individual telescope elements.


00:17:32.200 --> 00:17:34.740
So recording everything onto a hard drive


00:17:34.740 --> 00:17:36.780
at that data rate becomes impractical.


00:17:36.780 --> 00:17:40.900
So the approach that we take is we use


00:17:40.900 --> 00:17:43.440
what we call a real-time correlator.


00:17:43.440 --> 00:17:45.840
It processes and reduces the data


00:17:45.840 --> 00:17:49.820
as a sort of first stage in real-time, live,


00:17:49.820 --> 00:17:51.720
before recording to the disk.


00:17:51.720 --> 00:17:56.480
And as a part of that step, we integrate for a little while.


00:17:56.480 --> 00:18:00.240
So if you think about it from the point of view,


00:18:00.240 --> 00:18:02.680
if you've done some photography at nighttime,


00:18:02.680 --> 00:18:04.380
you want to do a long exposure,


00:18:04.380 --> 00:18:06.720
so you open your camera shutter for a long time


00:18:06.720 --> 00:18:09.920
to get more signal, it's very similar to that.


00:18:09.920 --> 00:18:12.760
So we would integrate over half a second or a second


00:18:12.760 --> 00:18:17.280
or eight seconds, and that gives you a much reduced,


00:18:17.280 --> 00:18:19.480
there's still a lot of data that comes out


00:18:19.480 --> 00:18:22.100
of the other side, but it's much, much smaller


00:18:22.100 --> 00:18:24.520
than if you were recording straight onto hard drives


00:18:24.520 --> 00:18:27.040
from the telescope the way that they do


00:18:27.040 --> 00:18:28.740
in Event Horizon Telescope.


00:18:28.740 --> 00:18:30.040
>> Right. That is interesting.


00:18:30.040 --> 00:18:31.500
I guess it is just like taking a picture,


00:18:31.500 --> 00:18:33.320
just a different frequency, right?


00:18:33.320 --> 00:18:34.600
But same basic idea?


00:18:34.600 --> 00:18:35.900
>> Exactly.


00:18:35.900 --> 00:18:38.340
Exactly.


00:18:38.340 --> 00:18:41.980
>> Nice. And so there's a lot of data coming through here.


00:18:41.980 --> 00:18:44.220
You talked about how Event Horizon couldn't even ship it


00:18:44.220 --> 00:18:47.440
around the world quick enough or, you know,


00:18:47.440 --> 00:18:49.920
even though they're very, very far apart, pretty remote.


00:18:49.920 --> 00:18:51.120
But there's a lot of data here.


00:18:51.120 --> 00:18:53.920
And so maybe give people a sense of the data center.


00:18:53.920 --> 00:18:57.840
Excuse me, give people a sense of the data center.


00:18:57.840 --> 00:19:00.080
And like, you've got this array of,


00:19:00.080 --> 00:19:02.240
I don't remember how many of these correlators,


00:19:02.240 --> 00:19:03.760
server, U1, slice.


00:19:03.760 --> 00:19:05.080
>> Yeah.


00:19:05.080 --> 00:19:07.840
>> It's not one corner, PC in the corner, is it?


00:19:07.840 --> 00:19:10.240
>> No, no.


00:19:10.240 --> 00:19:14.040
Although, the way the technology progresses, maybe one day.


00:19:14.640 --> 00:19:19.140
No, so our current generation correlator uses


00:19:19.140 --> 00:19:21.720
an FPGA based computing platform.


00:19:21.720 --> 00:19:24.740
We call it SCARAB.


00:19:24.740 --> 00:19:28.780
There's a bit of a tradition to name radio astronomy


00:19:28.780 --> 00:19:30.640
compute things after insects.


00:19:30.640 --> 00:19:33.240
So the previous generation one was called ROACH.


00:19:33.240 --> 00:19:35.560
This one is called SCARAB.


00:19:35.560 --> 00:19:40.420
They stand for something, reconfigurable open architecture


00:19:40.420 --> 00:19:42.720
for computing hardware, I think was the ROACH.


00:19:43.800 --> 00:19:47.560
And Scarab, the first three letters are S-K-A.


00:19:47.560 --> 00:19:50.040
Yeah, there we go, there's the Scarab.


00:19:50.040 --> 00:19:54.040
And what that is, is an FPGA is a field programmable


00:19:54.040 --> 00:19:56.240
gate array, so it's a little piece of reconfigurable


00:19:56.240 --> 00:20:01.240
silicon that has, it's like having a hardware


00:20:01.240 --> 00:20:04.040
accelerated signal processing.


00:20:04.040 --> 00:20:08.340
It's very fast, and it's wired straight into Ethernet


00:20:08.340 --> 00:20:11.560
for interconnect, so in our data center in the Karoo,


00:20:11.560 --> 00:20:14.040
In South Africa, we've got about 280


00:20:14.040 --> 00:20:17.020
of these individual scarabs,


00:20:17.020 --> 00:20:19.180
and each of them has a role to play


00:20:19.180 --> 00:20:21.240
in the signal processing pipeline.


00:20:21.240 --> 00:20:23.320
They talk to each other via ethernet,


00:20:23.320 --> 00:20:25.920
and they're controlled by a central master controller


00:20:25.920 --> 00:20:28.800
computer that runs Python.


00:20:28.800 --> 00:20:33.320
So it uses an asynchronous little routine


00:20:33.320 --> 00:20:37.240
to coordinate the activities of each of these scarabs.


00:20:37.240 --> 00:20:40.780
The processing parameters need to be updated


00:20:40.780 --> 00:20:41.660
from time to time.


00:20:41.660 --> 00:20:44.760
So for example, as the Earth turns,


00:20:44.760 --> 00:20:48.580
the geometric delay between a given pair of telescopes


00:20:48.580 --> 00:20:49.900
will change slightly,


00:20:49.900 --> 00:20:54.680
and so that gets updated periodically in the Scarab,


00:20:54.680 --> 00:20:57.900
so that it can carry on processing the data


00:20:57.900 --> 00:21:02.900
at the full rate that the telescope is taking data in.


00:21:02.900 --> 00:21:04.820
So to give you an idea of that,


00:21:07.900 --> 00:21:16.140
telescope is producing data at about 35 gigabit per second. 35 gigabit a second?


00:21:16.140 --> 00:21:25.780
Yeah, times 64. Yeah, that's a lot of data. After the processing, the


00:21:25.780 --> 00:21:30.580
other end of the correlator, so we get about four or five gigabit per second, so


00:21:30.580 --> 00:21:34.360
that's reduced due to kind of the long exposure effect, it's averaged over a


00:21:34.360 --> 00:21:39.880
a few seconds, so it's four or five gigabits per second out the other end, and then that


00:21:39.880 --> 00:21:45.380
gets stored on hard drives for processing and imaging so that scientists can do their


00:21:45.380 --> 00:21:48.540
science later on.


00:21:48.540 --> 00:21:50.380
But that's the initial stage of the signal processing pipeline.


00:21:50.380 --> 00:21:54.760
So you've got 64 of these running in concert.


00:21:54.760 --> 00:22:00.060
What does uptime in DevOps look like for you all?


00:22:00.060 --> 00:22:07.060
Is this continuously 24 hours a day recording or is it offline for a certain number of hours?


00:22:07.060 --> 00:22:08.540
Yes, it is.


00:22:08.540 --> 00:22:15.140
And the limiting fact I'm happy to say is usually not the correlator.


00:22:15.140 --> 00:22:18.620
We don't need all 280 scarabs to run.


00:22:18.620 --> 00:22:23.140
We can run with about 190 of them with full science capability, so there is capacity for


00:22:23.140 --> 00:22:24.860
spares.


00:22:24.860 --> 00:22:29.940
And when you have a system with this many moving parts, there is downtime.


00:22:29.940 --> 00:22:33.980
actually need to go and change the oil in the motors on the telescope and you


00:22:33.980 --> 00:22:40.460
know routine maintenance kinds of things like that. So I don't remember our


00:22:40.460 --> 00:22:46.820
numbers exactly but I believe it's above 75% of the time that the


00:22:46.820 --> 00:22:52.060
telescope is busy and doing science. This is more recent, it's only in the last


00:22:52.060 --> 00:22:55.820
sort of few years that the technology platform has become a bit more


00:22:55.820 --> 00:22:59.020
mature. In the early stages it was really still sort of engineering


00:22:59.020 --> 00:23:04.220
commissioning, but I think we're using above 75% of time now


00:23:04.220 --> 00:23:06.860
for actual science observations.


00:23:06.860 --> 00:23:08.160
>> That's pretty impressive


00:23:08.160 --> 00:23:10.660
for considering all the pieces involved.


00:23:10.660 --> 00:23:11.960
And what are these scarabs?


00:23:11.960 --> 00:23:13.780
Each one is basically assigned


00:23:13.780 --> 00:23:16.900
to an individual telescope part of the array?


00:23:16.900 --> 00:23:17.900
>> Partially.


00:23:17.900 --> 00:23:22.820
So the first one will do what is called channelization.


00:23:22.820 --> 00:23:28.180
So it's much easier to operate on narrow signals of, you know,


00:23:28.180 --> 00:23:29.780
very close to a sine wave.


00:23:29.780 --> 00:23:32.660
So the telescope will sample a little bit more


00:23:32.660 --> 00:23:34.500
than a gigahertz worth of bandwidth,


00:23:34.500 --> 00:23:36.780
and that will be chopped up into, you know,


00:23:36.780 --> 00:23:38.540
a few thousand channels.


00:23:38.540 --> 00:23:42.460
Then those channels will get sort of dished out,


00:23:42.460 --> 00:23:46.740
and another scarab later on will cross multiply


00:23:46.740 --> 00:23:49.140
the corresponding frequency channels


00:23:49.140 --> 00:23:51.640
from every single telescope together.


00:23:51.640 --> 00:23:53.140
So this architecture is called FX,


00:23:53.140 --> 00:23:55.140
so first frequency channelization,


00:23:55.140 --> 00:24:04.420
then cross-correlation, before you get your ultimate product which gets stored in the


00:24:04.420 --> 00:24:08.720
archive and on which then further science processing is done.


00:24:08.720 --> 00:24:12.800
People start to ask questions and draw graphs and things.


00:24:12.800 --> 00:24:13.800
Exactly.


00:24:13.800 --> 00:24:14.800
Yeah.


00:24:14.800 --> 00:24:20.520
So, one of the parts that you employ to make this run fast is, I think you said you use


00:24:20.520 --> 00:24:24.160
CUDA cores on NVIDIA GPUs or something like that, is that right?


00:24:24.160 --> 00:24:25.920
Do I remember this correctly?


00:24:25.920 --> 00:24:26.760
- Yes, that's right.


00:24:26.760 --> 00:24:31.680
So the Scarab that you showed on the screen,


00:24:31.680 --> 00:24:35.780
that's our previous, well, previous but current generation


00:24:35.780 --> 00:24:38.700
correlator is working on that platform.


00:24:38.700 --> 00:24:41.960
It has its pros and cons.


00:24:41.960 --> 00:24:43.760
It's kind of a bespoke piece of hardware.


00:24:43.760 --> 00:24:48.280
It is reconfigurable, but there are not that many customers


00:24:48.280 --> 00:24:51.400
for this particular board.


00:24:51.400 --> 00:24:52.720
The problem with doing your own hardware


00:24:52.720 --> 00:24:58.760
that it takes a lot of time, particularly if you're an organization that you want to


00:24:58.760 --> 00:25:01.220
do science.


00:25:01.220 --> 00:25:08.700
So for the next expansion of Meerkat, to build more antennas we need more processing capability


00:25:08.700 --> 00:25:11.000
to be able to handle more bandwidth.


00:25:11.000 --> 00:25:19.040
We've kind of figured out that where they are now, GPUs can do the work.


00:25:19.040 --> 00:25:22.520
GPUs have actually been powerful enough to do the work for a while now.


00:25:22.520 --> 00:25:29.680
The problem has actually been the memory bandwidth to actually get your


00:25:29.680 --> 00:25:34.680
data from your telescope onto your GPU to do the number crunching. So for


00:25:34.680 --> 00:25:40.920
Scarab it was very easy. It has some 40 gigabit Ethernet and that's wired


00:25:40.920 --> 00:25:45.000
straight into the FPGA, so there's no operating system taking its time, there's


00:25:45.000 --> 00:25:48.220
no PCI Express that needs to be negotiated.


00:25:48.220 --> 00:25:50.720
The data just comes straight off the network


00:25:50.720 --> 00:25:52.160
and it can do its processing.


00:25:52.160 --> 00:25:56.040
Previously computers were not fast enough


00:25:56.040 --> 00:25:58.580
to get the numbers on and off the card.


00:25:58.580 --> 00:26:01.940
But since PCIe 4 has become a thing


00:26:01.940 --> 00:26:06.940
and sort of the GeForce RTX 3000 series cards


00:26:06.940 --> 00:26:11.760
which we're using PCIe 4, we can do it on GPUs now.


00:26:11.760 --> 00:26:13.660
So we haven't deployed one yet.


00:26:13.660 --> 00:26:16.260
we, what I spoke about is the prototype


00:26:16.260 --> 00:26:17.360
that we've developed.


00:26:17.360 --> 00:26:20.860
But that's--


00:26:20.860 --> 00:26:23.860
- Part Python and part CUDA, right?


00:26:23.860 --> 00:26:25.140
- Yes, yes.


00:26:25.140 --> 00:26:27.780
So the CUDA is actually quite small.


00:26:27.780 --> 00:26:32.100
As I mentioned earlier, the processing is quite simple.


00:26:32.100 --> 00:26:36.500
So there's a stage for channelizing.


00:26:36.500 --> 00:26:39.340
So that uses a piece of math called a Fourier transform.


00:26:39.340 --> 00:26:41.300
And there's been years of research gone into that


00:26:41.300 --> 00:26:42.740
to make it very computationally efficient.


00:26:42.740 --> 00:26:46.900
very fast. The other part is simply multiplying lots of numbers together and


00:26:46.900 --> 00:26:51.180
that's something that GPUs are really really good at. So we've made good use of


00:26:51.180 --> 00:26:55.980
technology advances driven by things like AI and machine learning which


00:26:55.980 --> 00:27:00.180
relies on really large matrix multiplications. So we just piggyback


00:27:00.180 --> 00:27:04.500
off of that technology and the bonus is we don't have to develop our


00:27:04.500 --> 00:27:08.580
own hardware anymore which is nice. And those things are only getting faster


00:27:08.580 --> 00:27:15.380
right if you could have done it on a 3070 or whatever nvidia 3070 then you know it's getting


00:27:15.380 --> 00:27:19.620
faster and going to get easier and easier as things go you might need to give you a power


00:27:19.620 --> 00:27:25.940
generator to run one of those cards these days they're kind of insane but the the 30 series are


00:27:25.940 --> 00:27:31.780
a little bit easier than the 40 series to give you an idea in our prototype system we're using


00:27:31.780 --> 00:27:36.980
3070 TI's at the moment and one of those GPUs does the work of four scarabs.


00:27:36.980 --> 00:27:43.420
Wow. So it's the rate that technology moves forward. To be fair the scarab is


00:27:43.420 --> 00:27:49.220
about six or seven years old it was revolutionary at the time but you know


00:27:49.220 --> 00:27:54.460
commercial technology has moved forward a lot. Yeah it sure has. You talked, just a


00:27:54.460 --> 00:27:58.660
bit of a sidebar, you talked about the one of the challenges being getting the


00:27:58.660 --> 00:28:03.260
data in and out of the GPUs from a bandwidth perspective. Do things like


00:28:03.260 --> 00:28:09.220
systems on a chip and this Apple unified memory where the bandwidth, the memory of


00:28:09.220 --> 00:28:14.180
the CPU is the memory of the GPU, have you guys considered playing with


00:28:14.180 --> 00:28:22.900
that? Is that interesting? We have had a look. So Apple's model is


00:28:22.900 --> 00:28:27.860
something that's not really reached mainstream yet and Apple doesn't really


00:28:27.860 --> 00:28:33.020
sell a computer in a form factor that would be amenable to deployment in a


00:28:33.020 --> 00:28:36.140
data center environment. You have to put a bunch of minis on their edge or something.


00:28:36.140 --> 00:28:41.060
Exactly, yes. So it's something that we've got an eye on but we haven't


00:28:41.060 --> 00:28:45.500
got a usable kind of hardware prototype at this point. So we're currently


00:28:45.500 --> 00:28:51.740
using AMD EPYC platforms. They have lots of PCIe lanes and lots of memory


00:28:51.740 --> 00:29:00.940
channels so that lets you get data on and off from your network to your GPU


00:29:00.940 --> 00:29:11.460
very quickly and advances such as direct memory addressing and other such things


00:29:11.460 --> 00:29:16.180
I forget all the terminology now but basically the faster that you can get


00:29:16.180 --> 00:29:18.720
it off into the GPU's RAM


00:29:18.720 --> 00:29:21.340
so that the GPU can do its thing the better.


00:29:21.340 --> 00:29:23.360
>> Yeah. It's an interesting trade-off to consider


00:29:23.360 --> 00:29:27.560
because the GPUs, even in the new higher-end Apple stuff,


00:29:27.560 --> 00:29:29.800
it's still quite a bit slower than NVIDIA.


00:29:29.800 --> 00:29:35.400
But the memory is instant, so where's that trade-off


00:29:35.400 --> 00:29:37.080
across the line? It's going to be interesting


00:29:37.080 --> 00:29:38.980
as this kind of architecture evolves.


00:29:38.980 --> 00:29:41.820
>> Yeah. We've definitely got eyes on that,


00:29:41.820 --> 00:29:44.040
and we'll see how it goes.


00:29:45.320 --> 00:29:48.120
- All right, for doing the CUDA stuff,


00:29:48.120 --> 00:29:50.840
what's the Python side look like?


00:29:50.840 --> 00:29:53.640
Is that, what libraries are you using and stuff?


00:29:53.640 --> 00:29:58.520
- So the Python, that's got to kind of do every,


00:29:58.520 --> 00:30:01.240
so the GPUs are very good at crunching numbers,


00:30:01.240 --> 00:30:04.100
but they're not very good at anything else.


00:30:04.100 --> 00:30:07.320
So there's a lot of steps in that for a GPU


00:30:07.320 --> 00:30:10.120
to be able to do all of those calculations.


00:30:10.120 --> 00:30:13.840
You have a high-speed network, 100 gigabit, 200 gigabit.


00:30:15.040 --> 00:30:16.360
that's very fast.


00:30:16.360 --> 00:30:21.360
And so you need software to be able to


00:30:21.360 --> 00:30:24.880
run your network stack, receive data,


00:30:24.880 --> 00:30:26.440
and that comes into system RAM.


00:30:26.440 --> 00:30:29.140
You need to be able to DMA it into the GPU's memory.


00:30:29.140 --> 00:30:35.040
You need to be able to know when the work is finished


00:30:35.040 --> 00:30:36.920
so that you can copy the data back,


00:30:36.920 --> 00:30:42.360
packet that up in Ethernet packets again and send it out.


00:30:43.680 --> 00:30:47.240
And so there's a lot of things that we use in Python


00:30:47.240 --> 00:30:48.560
to enable that.


00:30:48.560 --> 00:30:53.360
The first and most sort of obvious one


00:30:53.360 --> 00:30:55.800
would be a library called PyCuda,


00:30:55.800 --> 00:30:59.400
which allows you to wrap up Cuda functions


00:30:59.400 --> 00:31:03.720
in a nice Python handle and interact with your GPU


00:31:03.720 --> 00:31:08.180
in a way that's more amenable to Python code.


00:31:08.180 --> 00:31:11.040
There we go, that's the one.


00:31:13.200 --> 00:31:14.040
- Yeah, very cool.


00:31:14.040 --> 00:31:16.760
- So, the other one,


00:31:16.760 --> 00:31:21.640
the thing that you've got to think about carefully then


00:31:21.640 --> 00:31:25.640
is coordinating your activities


00:31:25.640 --> 00:31:32.920
when your GPU is executing,


00:31:32.920 --> 00:31:37.120
CUDA calls the streams,


00:31:37.120 --> 00:31:39.320
if you're working in an OpenCL kind of abstraction,


00:31:39.320 --> 00:31:40.680
it calls it command queues.


00:31:41.640 --> 00:31:46.480
So you can, they work almost like threads on a computer.


00:31:46.480 --> 00:31:49.480
So you need to have some sort of way of coordinating


00:31:49.480 --> 00:31:53.060
so that when you start one calculation,


00:31:53.060 --> 00:31:54.520
you've got to make sure that the data is there,


00:31:54.520 --> 00:31:56.520
that it can work on it.


00:31:56.520 --> 00:31:59.060
And similarly, you don't want to start copying it back


00:31:59.060 --> 00:32:01.560
before the calculation has finished.


00:32:01.560 --> 00:32:04.820
So PyCuda makes this quite easy.


00:32:04.820 --> 00:32:08.320
You can use, I think, Nvidia calls it events.


00:32:08.320 --> 00:32:10.360
But they're basically semaphores and markers


00:32:10.360 --> 00:32:15.120
to help you to coordinate between your different threads


00:32:15.120 --> 00:32:18.880
for sending, processing, and receiving data from the GPU.


00:32:18.880 --> 00:32:21.180
And similarly getting it off the network


00:32:21.180 --> 00:32:22.520
and onto the network again.


00:32:22.520 --> 00:32:24.420
So, Paikuda is-- - Yeah, another thing


00:32:24.420 --> 00:32:27.000
that you spoke, yeah, Paikuda looks great.


00:32:27.000 --> 00:32:29.440
Another thing you spoke about that was pretty interesting


00:32:29.440 --> 00:32:32.640
is your use of async and await


00:32:32.640 --> 00:32:34.760
to do all the network stuff, - Yes.


00:32:34.760 --> 00:32:37.740
- which I think is, it's clearly a good choice


00:32:37.740 --> 00:32:40.280
and fits right here, but I feel like a lot of people


00:32:40.280 --> 00:32:43.900
So consider it fast enough or great enough.


00:32:43.900 --> 00:32:46.860
- Network, but not just that, also the GPU.


00:32:46.860 --> 00:32:51.860
So you have a few functions and they're running loops.


00:32:51.860 --> 00:32:57.240
So the way that we've structured our code,


00:32:57.240 --> 00:33:01.320
and I'll share a link with you,


00:33:01.320 --> 00:33:04.180
there's documentation in Read the Docs as well,


00:33:04.180 --> 00:33:07.820
explaining this.


00:33:07.820 --> 00:33:11.060
But we have one loop that just waits for traffic


00:33:11.060 --> 00:33:13.680
to come in off the network, bundles it up.


00:33:13.680 --> 00:33:15.380
And this is kind of one of the trick things


00:33:15.380 --> 00:33:18.440
you need to do things in batches.


00:33:18.440 --> 00:33:21.320
If you involve the Python interpreter,


00:33:21.320 --> 00:33:23.060
every time a packet hits the NIC,


00:33:23.060 --> 00:33:25.060
then it'll end up being very slow.


00:33:25.060 --> 00:33:27.740
So we have a lower level library written in C++


00:33:27.740 --> 00:33:29.260
that batches up a whole chunk


00:33:29.260 --> 00:33:33.700
in the order of about 100 or 200 megabytes worth of data.


00:33:33.700 --> 00:33:36.460
And you use that await keyword


00:33:36.460 --> 00:33:40.940
to let you know when there's a chunk of data ready.


00:33:40.940 --> 00:33:41.780
So when there's a chunk of data--


00:33:41.780 --> 00:33:43.520
- You wait until enough is buffered up


00:33:43.520 --> 00:33:45.940
and then you pull it back on the--


00:33:45.940 --> 00:33:46.780
- Exactly.


00:33:46.780 --> 00:33:48.220
- Or whatever, okay.


00:33:48.220 --> 00:33:51.840
- Exactly, so you mark that for upload,


00:33:51.840 --> 00:33:54.980
you put an event in the stream or the command queue,


00:33:54.980 --> 00:33:57.920
and let that run.


00:33:57.920 --> 00:33:59.980
And then in the next loop,


00:33:59.980 --> 00:34:03.260
you're using the await,


00:34:03.260 --> 00:34:05.460
so you're waiting for that event.


00:34:05.460 --> 00:34:11.860
and when you see that you know that the data is uploaded to the GPU, you trigger the processing,


00:34:11.860 --> 00:34:16.980
whichever processing task needs to happen, and put another event and then pass it on


00:34:16.980 --> 00:34:17.980
to the next.


00:34:17.980 --> 00:34:23.300
So the third loop waits for that final event, when it sees it, it knows that the processing


00:34:23.300 --> 00:34:32.060
is done and you can initiate the copy of the GPU RAM back to the system and then you can


00:34:32.060 --> 00:34:34.920
send and transmit that out on the network.


00:34:34.920 --> 00:34:37.760
So those two things working in tandem, yeah.


00:34:37.760 --> 00:34:41.880
- Yeah, I didn't expect the GPU to have this async interface


00:34:41.880 --> 00:34:43.040
but it does make a lot of sense.


00:34:43.040 --> 00:34:46.360
There's a lot of parallels within the GPU.


00:34:46.360 --> 00:34:49.360
- I don't think that it's natively in PyCuda.


00:34:49.360 --> 00:34:51.840
I think that's a wrapper that we've done around it.


00:34:51.840 --> 00:34:52.660
It's been a little while


00:34:52.660 --> 00:34:53.800
since I've touched that particular code


00:34:53.800 --> 00:34:57.200
but there's no reason that you can't do that at all.


00:34:57.200 --> 00:35:01.680
And it's approach that we find has been very, very useful.


00:35:01.680 --> 00:35:03.120
- Okay, but your assessment overall


00:35:03.120 --> 00:35:06.320
is that async and await, Python's async.io


00:35:06.320 --> 00:35:08.840
has been a solid choice for this whole platform.


00:35:08.840 --> 00:35:13.580
- I've seen this approach used in other places as well,


00:35:13.580 --> 00:35:18.680
even since before async.io has been part of core Python,


00:35:18.680 --> 00:35:20.740
using things like Flask or Tornado.


00:35:20.740 --> 00:35:24.640
So the approach, it's a very good approach,


00:35:24.640 --> 00:35:26.360
it's very helpful.


00:35:26.360 --> 00:35:28.080
Debugging async stuff when it goes wrong


00:35:28.080 --> 00:35:29.440
is a little bit more tricky,


00:35:29.440 --> 00:35:32.040
but when it works, it works very, very well.


00:35:32.040 --> 00:35:33.800
Yeah, that's for sure.


00:35:33.800 --> 00:35:36.360
You get the Heisenbergs, keep it in the science space.


00:35:36.360 --> 00:35:37.560
Okay, so--


00:35:37.560 --> 00:35:38.560
Exactly.


00:35:38.560 --> 00:35:42.520
Quick audience question, I think is gonna be interesting


00:35:42.520 --> 00:35:45.740
before we move on to the testing of this whole system.


00:35:45.740 --> 00:35:48.680
So out in the audience, Slovak asks,


00:35:48.680 --> 00:35:50.520
what do you think about simple distributed


00:35:50.520 --> 00:35:53.700
radio astronomy experiments for like citizen science?


00:35:53.700 --> 00:35:57.120
Are they possible?


00:35:57.120 --> 00:35:58.600
That's a very good question.


00:35:58.600 --> 00:36:01.560
Yes, they are.


00:36:01.560 --> 00:36:08.560
It's possible to do amateur radio astronomy using relatively affordable SDR dongles.


00:36:08.560 --> 00:36:13.000
SDR standing for software defined radio.


00:36:13.000 --> 00:36:15.340
It's been a little while since I've looked at this, I must confess.


00:36:15.340 --> 00:36:18.760
As I've mentioned earlier, since I do this professionally, I don't bother with it that


00:36:18.760 --> 00:36:19.760
much as a hobby anymore.


00:36:19.760 --> 00:36:22.080
You have a square kilometer array you're building.


00:36:22.080 --> 00:36:23.080
Exactly.


00:36:23.080 --> 00:36:25.440
I've got a big telescope at work.


00:36:25.440 --> 00:36:28.320
I don't need a small one at home.


00:36:28.320 --> 00:36:31.120
But you can do science.


00:36:31.120 --> 00:36:36.480
It's difficult in most practical cases because most people live in cities where there's a


00:36:36.480 --> 00:36:39.920
lot of interference.


00:36:39.920 --> 00:36:42.260
But it definitely can be done.


00:36:42.260 --> 00:36:47.500
One of the fun projects that I've seen has been using a satellite dish like what you


00:36:47.500 --> 00:36:54.520
would connect to satellite TV, but with a little bit of electronic knowledge.


00:36:54.520 --> 00:36:57.600
And you don't need a degree, you can just be on a hobbyist level to do that.


00:36:57.600 --> 00:37:03.600
You can build a square law receiver, so it's very much just, is there signal or isn't there,


00:37:03.600 --> 00:37:07.440
you're not going to be decoding any TV streams.


00:37:07.440 --> 00:37:11.080
But you can measure, for example, the temperature of the sun using this, and you can measure


00:37:11.080 --> 00:37:18.940
its angular dimensions by simply pointing it and then letting the sun drift through


00:37:18.940 --> 00:37:21.520
a few times.


00:37:21.520 --> 00:37:25.640
So there are fun projects that can be done.


00:37:25.640 --> 00:37:38.080
As to say whether it can be useful as citizen science, in other words, useful from a scientific


00:37:38.080 --> 00:37:43.280
point of view over more than just something interesting to do, I'd have to go and have


00:37:43.280 --> 00:37:44.280
a look.


00:37:44.280 --> 00:37:45.680
I'm not 100% sure.


00:37:45.680 --> 00:37:49.220
It's very difficult to get meaningful results without very, very expensive equipment.


00:37:49.220 --> 00:37:54.100
That's why we've got such expensive facilities being built.


00:37:54.100 --> 00:37:58.160
One thing you did point out, I can't remember which of the two talks it was, but you did


00:37:58.160 --> 00:38:05.700
say that you can go and rent at least optical telescopes remotely, right?


00:38:05.700 --> 00:38:14.140
Yes, so most optical telescopes are operated remotely, but a lot of ones that are commercially


00:38:14.140 --> 00:38:19.720
available as well, head over to telescopes.com and you can buy ones that can be electronically


00:38:19.720 --> 00:38:21.580
controlled.


00:38:21.580 --> 00:38:25.660
And those you can do interesting, is it telescopes or telescope.com?


00:38:25.660 --> 00:38:28.060
Yeah, that's the one.


00:38:28.060 --> 00:38:30.340
You can buy ones that are electronically controlled.


00:38:30.340 --> 00:38:33.060
And those can actually be useful for citizen science.


00:38:33.060 --> 00:38:42.420
There's a lot of, for example, astronomy organizations that do regular observations of variable stars


00:38:42.420 --> 00:38:48.180
or binary stars, and they rely a lot on data submitted by amateurs.


00:38:48.180 --> 00:38:54.660
any particular observation will not necessarily be that useful, but in aggregate thousands of


00:38:54.660 --> 00:39:02.100
these observations are very helpful for doing the science that they would be doing then.


00:39:02.100 --> 00:39:08.660
That could typically be run by university faculty and they would aggregate these observations over


00:39:08.660 --> 00:39:15.220
long periods of time from different locations to draw some scientific conclusions about what's


00:39:15.220 --> 00:39:22.980
happening with these stars. So yeah, it's a good question though. Yeah it is indeed. Thanks. So


00:39:22.980 --> 00:39:34.180
let's talk about the testing side. So you said that... Yeah, go ahead. Yeah, well just


00:39:34.180 --> 00:39:38.500
sorry to sort of jump the gun, but coming from my sort of engineering background,


00:39:38.500 --> 00:39:43.700
one of the sort of key questions that you've got to ask as an engineer is


00:39:45.140 --> 00:39:48.860
If you have specifications for a system to build, to design,


00:39:48.860 --> 00:39:51.240
at what point do you know that it's doing the thing


00:39:51.240 --> 00:39:52.420
that it's expected to do?


00:39:52.420 --> 00:39:56.840
So you've got a certain set of user requirements.


00:39:56.840 --> 00:39:59.320
The user needs to be able to have this level of sensitivity


00:39:59.320 --> 00:40:02.800
and this level of bandwidth and accuracy.


00:40:02.800 --> 00:40:04.120
- Less than the specified. - In terms of hard--


00:40:04.120 --> 00:40:05.460
- Or something, yeah.


00:40:05.460 --> 00:40:07.260
- Exactly, in terms of hard numbers.


00:40:07.260 --> 00:40:10.820
So you need to have some sort of way to prove


00:40:10.820 --> 00:40:12.700
that the system that you've designed and built


00:40:12.700 --> 00:40:14.740
is gonna meet those specifications.


00:40:14.740 --> 00:40:19.500
And so testing is a fundamental part of that.


00:40:19.500 --> 00:40:21.680
Sometimes you can prove by analysis,


00:40:21.680 --> 00:40:25.180
just by using maths and showing


00:40:25.180 --> 00:40:27.180
this is what the system is designed to do.


00:40:27.180 --> 00:40:30.740
But the first prize is if you can run a test and say,


00:40:30.740 --> 00:40:34.120
look, we've got a controlled set of inputs,


00:40:34.120 --> 00:40:35.620
we can measure the outputs,


00:40:35.620 --> 00:40:38.860
and we can determine from this that the system is doing


00:40:38.860 --> 00:40:42.020
what we said it is doing and how well it is.


00:40:42.020 --> 00:40:43.740
So what the noise level is


00:40:43.740 --> 00:40:50.940
what the sensitivity is, whatever the case is. And that's something that is


00:40:50.940 --> 00:40:58.040
often a little bit neglected in scientific projects, particularly


00:40:58.040 --> 00:41:02.140
astronomy, that's the one that I've got experience with, but other fields


00:41:02.140 --> 00:41:06.180
I've seen as well. Often physicists and astronomers are very, very clever and


00:41:06.180 --> 00:41:09.860
they're trained in a lot of fields. They tend to build their own instruments and


00:41:09.860 --> 00:41:16.300
hardware and write their own software. And it has a kind of amateurish


00:41:16.300 --> 00:41:22.740
aspect to it sometimes, not universally but this is the tendency, until it's


00:41:22.740 --> 00:41:28.180
more or less doing what the researcher wants and then he carries on. So many a


00:41:28.180 --> 00:41:32.580
software project has been written by a PhD student, he's generated some


00:41:32.580 --> 00:41:39.300
results and you know published his paper, gotten his PhD, but that's


00:41:39.300 --> 00:41:44.320
very difficult to scrutinize because the code is written by someone and the logic


00:41:44.320 --> 00:41:51.280
lives in someone's head. And so I'm kind of keen on this this concept of testing


00:41:51.280 --> 00:41:54.700
because I think it adds a level of rigor and transparency to the scientific


00:41:54.700 --> 00:41:59.400
process because if I've got tests in place then anyone can come along and


00:41:59.400 --> 00:42:03.740
look at how I've tested my instrument and you know criticize or


00:42:03.740 --> 00:42:09.100
evaluate whether it actually does what I what I say it does when I publish my


00:42:09.100 --> 00:42:13.100
research. So I think the concept is really important.


00:42:13.100 --> 00:42:21.580
I see too and it's in open source one of the important signals that people use


00:42:21.580 --> 00:42:25.900
when they go and look at a package they might consider like PyCuda or Pandas or


00:42:25.900 --> 00:42:33.100
whatever is does this thing have tests as part of its design? If I'm


00:42:33.100 --> 00:42:36.580
gonna depend on somebody else's library or if I'm a maintainer and I create a


00:42:36.580 --> 00:42:41.300
library and someone's going to send me a PR, how do I know whether their changes


00:42:41.300 --> 00:42:44.340
that they're suggesting to me broke something I didn't see coming, right?


00:42:44.340 --> 00:42:49.000
And having unit tests or some kind of test typically driven with pytest for


00:42:49.000 --> 00:42:55.540
Python is really important, not just supporting pillar of that project, but


00:42:55.540 --> 00:42:57.880
also a signal to others from the outside.


00:42:57.880 --> 00:42:59.360
Like this thing, people care about this.


00:42:59.360 --> 00:43:00.500
They've, they've verified it.


00:43:00.500 --> 00:43:01.560
They want to keep it strong.


00:43:02.260 --> 00:43:08.100
And it sounds to me like this might also be really important for science in the same way.


00:43:08.100 --> 00:43:13.660
You talked about people coming to review your work or to try to reproduce it.


00:43:13.660 --> 00:43:19.420
And if they see the test and they can run the test, it communicates something additional rather


00:43:19.420 --> 00:43:21.420
than just, "Well, I thought a lot about it.


00:43:21.420 --> 00:43:22.380
Here's my graph."


00:43:22.380 --> 00:43:24.140
>> Exactly, yes.


00:43:24.140 --> 00:43:29.560
You know, we want to do groundbreaking science and we want to be able to say


00:43:29.560 --> 00:43:34.160
that when we make observations that what we're seeing is real science and it's


00:43:34.160 --> 00:43:40.040
not just some sort of anomaly that we found in the telescope signal


00:43:40.040 --> 00:43:46.280
chain. And the presence of good tests helps with that because


00:43:46.280 --> 00:43:50.600
then we have rigorous testing that we can say look this is


00:43:50.600 --> 00:43:57.040
the performance characteristics of our system. It gives a


00:43:57.040 --> 00:44:01.280
little bit of extra confidence in your scientific results that way.


00:44:01.280 --> 00:44:05.680
Indeed, so how does this look different than like testing Flask or something, right?


00:44:05.680 --> 00:44:10.920
Because it's not exactly the same and you maybe are leaning on it a


00:44:10.920 --> 00:44:15.680
little bit more to communicate more information, not just pass or fail.


00:44:15.680 --> 00:44:22.720
There are a few things. In one sense, we do use unit tests in the


00:44:22.720 --> 00:44:28.320
same way that a lot of open source projects do.


00:44:28.320 --> 00:44:35.000
Does each individual component of my module do the thing that I've designed it to do?


00:44:35.000 --> 00:44:41.240
But if you go a little bit beyond that, the same sort of philosophy and application can


00:44:41.240 --> 00:44:45.480
be applied to systems as a whole.


00:44:45.480 --> 00:44:50.800
If you have a complicated system with a lot of different parts talking to each other,


00:44:50.800 --> 00:44:59.680
can be tricky to, a change that you make might not break if you look at it in


00:44:59.680 --> 00:45:04.040
isolation, but do those interfaces still work? If you're unit testing


00:45:04.040 --> 00:45:09.040
something, often you mock out whatever's at the end, so you'll


00:45:09.040 --> 00:45:13.080
pretend that you'll get a real response from a website when you do an API


00:45:13.080 --> 00:45:18.520
call, but if you've touched the code that actually handles that API call, then your


00:45:18.520 --> 00:45:25.480
unit test is not going to pick that up. So we've got a relatively rigorous


00:45:25.480 --> 00:45:33.440
process for what one might call integration testing. So an entire


00:45:33.440 --> 00:45:38.120
system gets set up in a simulated environment, but any input like it


00:45:38.120 --> 00:45:42.960
might get from a real telescope, and the ability to watch that


00:45:42.960 --> 00:45:48.160
output. And so we do that on a regular basis. We spin up an entire correlator


00:45:48.160 --> 00:45:55.160
in a system in the lab, give it a deterministic input, and so we can measure the output and


00:45:55.160 --> 00:46:01.160
determine whether or not it meets the criteria.


00:46:01.160 --> 00:46:09.160
Yeah, cool. Is this like a software emulator in Docker or is this an actual one of your


00:46:09.160 --> 00:46:14.160
1U FPGA things that's dedicated to this integration test?


00:46:14.160 --> 00:46:19.920
integration testing? It can be both, it can be both. So we've used the same


00:46:19.920 --> 00:46:27.720
approach to testing the old Scarab correlator. One of the


00:46:27.720 --> 00:46:33.720
Scarabs can be configured to emulate a telescope, so it can produce a signal


00:46:33.720 --> 00:46:40.440
similar to what a telescope might be, except not having astronomical signals


00:46:40.440 --> 00:46:44.320
in the data it would have a deterministic signal such as you know a


00:46:44.320 --> 00:46:50.200
normal frequency tone or just white noise depending on what kind of test we


00:46:50.200 --> 00:46:59.120
want to run on the... You don't replay the wow signal to it? We could but it's


00:46:59.120 --> 00:47:05.040
faster just to generate signals and you're not going to get a with a


00:47:05.040 --> 00:47:07.560
strongly deterministic signal in other words if you know exactly what you're


00:47:07.560 --> 00:47:11.960
putting in, you can see what you're getting out as well.


00:47:11.960 --> 00:47:17.360
The wow signal, not as useful for determining the noise level.


00:47:17.360 --> 00:47:19.040
More fun, not as useful.


00:47:19.040 --> 00:47:20.040
Yeah.


00:47:20.040 --> 00:47:27.640
So, one of the things you did is you changed some of the output from pytest to be more


00:47:27.640 --> 00:47:32.640
representative of talking about how you've met your requirements and stuff.


00:47:32.640 --> 00:47:35.320
Maybe tell folks about how that works.


00:47:35.320 --> 00:47:38.800
Yeah, so that was an interesting exercise


00:47:38.800 --> 00:47:42.640
because so Serraio uses a process


00:47:42.640 --> 00:47:43.780
called systems engineering,


00:47:43.780 --> 00:47:47.600
which was developed in Bell Labs, I think in the 40s.


00:47:47.600 --> 00:47:48.680
It was quite a while ago,


00:47:48.680 --> 00:47:49.820
and it's been strongly influenced


00:47:49.820 --> 00:47:53.640
by the sort of military processes.


00:47:53.640 --> 00:47:58.400
People in a software environment


00:47:58.400 --> 00:48:02.320
would recognize it as like a waterfall pattern


00:48:02.320 --> 00:48:04.780
where you'd have a big design up front.


00:48:04.780 --> 00:48:09.140
So you'd have a lengthy analysis of what the requirements


00:48:09.140 --> 00:48:14.140
of your system are, and allocated different performance


00:48:14.140 --> 00:48:16.260
characteristics to different components.


00:48:16.260 --> 00:48:18.540
And once you've done with the design,


00:48:18.540 --> 00:48:21.680
you need reams and reams of documentation to prove


00:48:21.680 --> 00:48:24.300
that your design meets the specifications as well.


00:48:24.300 --> 00:48:27.840
Graphs, tables, pictures, numbers,


00:48:27.840 --> 00:48:29.820
all of these kinds of things.


00:48:29.820 --> 00:48:32.760
pytest and other packages, there are other ones,


00:48:32.760 --> 00:48:35.340
but pytest is the one that we've used,


00:48:35.340 --> 00:48:36.980
has a much more simple output.


00:48:36.980 --> 00:48:39.660
In other words, it'll give you lots of details


00:48:39.660 --> 00:48:40.920
if something goes wrong.


00:48:40.920 --> 00:48:41.960
It'll give you a stack trace,


00:48:41.960 --> 00:48:43.660
it'll give you debug information


00:48:43.660 --> 00:48:46.260
of what the variables were at the time


00:48:46.260 --> 00:48:47.380
that there was a problem,


00:48:47.380 --> 00:48:49.700
or that the assertion didn't meet.


00:48:49.700 --> 00:48:51.000
But if everything passes,


00:48:51.000 --> 00:48:54.060
- It's all green.


00:48:54.060 --> 00:48:54.900
- Okay, we're good to go.


00:48:54.900 --> 00:48:55.740
- We're good to go.


00:48:55.740 --> 00:48:58.500
- Okay, the sensitivity is better than X,


00:48:58.500 --> 00:48:59.540
but how much better?


00:49:00.540 --> 00:49:05.500
and you know how does that vary with frequency and these kinds of things what we'd like to know and


00:49:05.500 --> 00:49:08.860
what we'd like to be able to present to the various stakeholders that are interested in the


00:49:08.860 --> 00:49:15.740
performance of the telescope. So we have a system, okay you need to zoom out a little bit there,


00:49:15.740 --> 00:49:20.780
and for those of you who are watching on YouTube I do apologize for the,


00:49:20.780 --> 00:49:25.660
it's difficult to put code on a screen in a way that's not going to put your audience to sleep.


00:49:25.660 --> 00:49:29.020
Yeah and I just grabbed this off of your talk just so we had something to like kind of be


00:49:29.020 --> 00:49:33.620
be talking about. You have this interesting reporting aspect that runs along with your


00:49:33.620 --> 00:49:41.100
test. Yes, so pytest has a plugin called ReportLog and that if you sort of squint


00:49:41.100 --> 00:49:46.260
at it and look a little bit carefully, it allows you to kind of record metadata as


00:49:46.260 --> 00:49:51.500
you're going along, so things that are happening in your test. So there's


00:49:51.500 --> 00:49:56.140
several things happening at once here and maybe if I could just take a step


00:49:56.140 --> 00:50:01.540
back this test that you've got up is a test of linearity. So what does


00:50:01.540 --> 00:50:08.180
that mean is that if I put in a signal X and I get an output Y, so if I put in a


00:50:08.180 --> 00:50:11.500
signal 2X I should get 2Y as the output so that they should be directly


00:50:11.500 --> 00:50:16.060
proportional to the other and if they're not then there's a non-linearity


00:50:16.060 --> 00:50:20.340
of some sort in the system. No system is perfectly linear so there will be some


00:50:20.340 --> 00:50:24.060
sort of margin for error. We don't have a specific spec on this particular


00:50:24.060 --> 00:50:32.140
linearity test, but it's a quick one to run because it takes only a few minutes and it


00:50:32.140 --> 00:50:38.540
can give us a sort of a first eyeball of are things working as we expect them to do.


00:50:38.540 --> 00:50:43.780
pytest, if for those of you who are not familiar with it, the tests are written in the same


00:50:43.780 --> 00:50:50.060
syntax as Python functions, except where the inputs of the function are either parameters


00:50:50.060 --> 00:50:55.460
of fixtures. So parameters can be, you know, if there's a parameter space over


00:50:55.460 --> 00:50:59.180
which your test will run, so in our case for example different numbers of


00:50:59.180 --> 00:51:03.420
frequency channels, different numbers of antennas, this one isn't parameterized, it


00:51:03.420 --> 00:51:09.020
uses only a few fixtures. The fixtures are things to ensure that you have a


00:51:09.020 --> 00:51:17.140
test that is reproducible. So in this case the correlator fixture gives us a


00:51:17.140 --> 00:51:21.940
correlator, it spins up in the test cluster that we've got in our lab


00:51:21.940 --> 00:51:27.740
and it gives, so the type into there gives you the hint that we're getting


00:51:27.740 --> 00:51:30.980
a remote control, so that little correlator object there gives us the


00:51:30.980 --> 00:51:36.220
ability to communicate with it and control it. The next one is a receiver,


00:51:36.220 --> 00:51:42.580
so that's, you know, if a correlator is running you need to be able to


00:51:42.580 --> 00:51:47.460
receive what it's outputting, so that you can compare it against whatever


00:51:47.460 --> 00:51:52.340
the spec is. And the third one is the PDF report. So the name is a bit of a


00:51:52.340 --> 00:51:58.900
misnomer. Initially I, so that little fixture is written using a module called


00:51:58.900 --> 00:52:03.540
PyLatex, so shout out to the authors of that one, it's very useful. And the


00:52:03.540 --> 00:52:08.460
best way to generate, you can generate PDFs directly from Python, but it's very


00:52:08.460 --> 00:52:12.500
low level and it's difficult, so we use LaTeX as a kind of intermediate step. To


00:52:12.500 --> 00:52:19.520
do the typesetting and PDF generation for that. So with that you can focus on


00:52:19.520 --> 00:52:24.400
actually just getting the content and then use LaTeX to arrange things


00:52:24.400 --> 00:52:27.760
and typeset and make sure that there's you know the lines wrap over and what


00:52:27.760 --> 00:52:35.600
have you. So that's the ultimately there the output will be a PDF with


00:52:35.600 --> 00:52:40.220
with a report of the test as it's run. So this is the configuration that we ran,


00:52:40.220 --> 00:52:41.860
and these are the steps that we followed,


00:52:41.860 --> 00:52:43.160
and these are our results.


00:52:43.160 --> 00:52:47.980
Version two of that uses an intermediate product,


00:52:47.980 --> 00:52:50.960
so instead of outputting a PDF straight away,


00:52:50.960 --> 00:52:52.220
we just serialize the data


00:52:52.220 --> 00:52:55.260
and put it into a little JSON dictionary.


00:52:55.260 --> 00:52:58.300
The reason for that is sometimes in LaTeX,


00:52:58.300 --> 00:53:00.140
you've gotta tweak your formatting or something like that,


00:53:00.140 --> 00:53:03.060
and it would be nice to not have to rerun the entire test


00:53:03.060 --> 00:53:06.020
just to change the font or update the heading,


00:53:06.020 --> 00:53:07.940
and so there's actually an intermediate step,


00:53:07.940 --> 00:53:09.620
and there's another step just later


00:53:09.620 --> 00:53:12.060
that takes that JSON, pauses it,


00:53:12.060 --> 00:53:14.060
and generates the PDF later.


00:53:14.060 --> 00:53:16.900
- Right, well, you can also ask questions about it, right?


00:53:16.900 --> 00:53:20.020
You can analyze the test JSON,


00:53:20.020 --> 00:53:23.080
and maybe draw averages over time,


00:53:23.080 --> 00:53:25.260
or here's how much it's varied


00:53:25.260 --> 00:53:27.140
as we've evolved our system, right?


00:53:27.140 --> 00:53:29.980
Not just pass/fail, what did this one look like?


00:53:29.980 --> 00:53:32.340
So JSON's pretty good. - Exactly.


00:53:32.340 --> 00:53:36.540
And when you incorporate this with other CI/CD tools,


00:53:37.420 --> 00:53:42.220
GitHub Actions or Jenkins or whatever the case is, you can do this repeatedly and then you have


00:53:42.220 --> 00:53:46.940
records of over time how your system has evolved versus what changes you've made


00:53:46.940 --> 00:53:54.940
and it makes it much easier to reason about and understand the performance of your system


00:53:54.940 --> 00:53:59.980
and how it changes over time. I think that's really neat. I don't see that being done very often


00:54:01.820 --> 00:54:07.660
at all and I think it's easy to look at this little bit of code that you put up in your


00:54:07.660 --> 00:54:11.260
presentation and say oh okay well that's pytest and here's a fixture and so on but like


00:54:11.260 --> 00:54:17.100
think about what those fixtures are doing you know one of those one of those fixtures maybe


00:54:17.100 --> 00:54:23.820
is controlling one of those one you FPGA machines to set it up right and then the other one is in


00:54:23.820 --> 00:54:28.620
our there's a lot of power and stuff going on with these little you know here's a variable


00:54:28.620 --> 00:54:30.700
- Exactly. - Or a correlator.


00:54:30.700 --> 00:54:31.540
- Exactly.


00:54:31.540 --> 00:54:32.900
Yeah, so you're right.


00:54:32.900 --> 00:54:35.100
There is a lot of code hidden behind here.


00:54:35.100 --> 00:54:38.300
But it's code that you're gonna run every time.


00:54:38.300 --> 00:54:40.180
So it doesn't matter what test you're doing,


00:54:40.180 --> 00:54:41.700
you're gonna wanna spin up a correlator.


00:54:41.700 --> 00:54:46.260
And whether it's an FPGA or a GPU,


00:54:46.260 --> 00:54:47.360
doesn't really matter.


00:54:47.360 --> 00:54:51.580
You wanna run through the same sort of steps


00:54:51.580 --> 00:54:52.860
so that your test is repeatable


00:54:52.860 --> 00:54:56.220
and that the result corresponds to the input


00:54:56.220 --> 00:54:57.360
that you give it.


00:54:57.360 --> 00:54:59.440
And so the pytest fixtures are great for that


00:54:59.440 --> 00:55:03.160
because once they allow you to get the boring stuff done,


00:55:03.160 --> 00:55:04.760
once you're confident that you're doing it right,


00:55:04.760 --> 00:55:06.360
then you can just keep doing it.


00:55:06.360 --> 00:55:11.600
So you use the same correlator fixture for every test,


00:55:11.600 --> 00:55:13.640
and if there's an update, if something changes,


00:55:13.640 --> 00:55:15.880
if there's a change to the hardware that you need,


00:55:15.880 --> 00:55:17.880
or the protocol that communicate with them,


00:55:17.880 --> 00:55:19.760
then you can update it just in one place,


00:55:19.760 --> 00:55:23.520
and all of your tests will benefit


00:55:23.520 --> 00:55:25.080
from that update straight away.


00:55:26.120 --> 00:55:29.400
Yeah, it's a very powerful aspect of pytest.


00:55:29.400 --> 00:55:31.300
You've taken it to quite a level here.


00:55:31.300 --> 00:55:35.560
- One of the things that I kind of wanted to,


00:55:35.560 --> 00:55:37.240
when I did the talk last year,


00:55:37.240 --> 00:55:38.840
that I wanted to put forward is that,


00:55:38.840 --> 00:55:41.840
you know, these concepts of testing,


00:55:41.840 --> 00:55:44.080
you can apply them to real world systems as well.


00:55:44.080 --> 00:55:46.400
So if you can talk to it,


00:55:46.400 --> 00:55:48.240
then you can use pytest to test it.


00:55:48.240 --> 00:55:51.640
If you can talk to it over the network,


00:55:51.640 --> 00:55:55.280
if a serial cable or USB or something like that,


00:55:55.280 --> 00:56:02.280
you can test actual hardware, make it do things, so that you can qualify it.


00:56:02.280 --> 00:56:10.620
It's not just restricted to little toy pieces of software, your flask or your tornado, or


00:56:10.620 --> 00:56:18.020
abstract conceptual things that live in the cloud somewhere. It can actually translate


00:56:18.020 --> 00:56:21.640
to real world things.


00:56:21.640 --> 00:56:25.880
People say when they talk about tests and stuff, they say, "Well, look, it is -- sometimes


00:56:25.880 --> 00:56:31.000
they say it is your documentation or it is the way you verify things are working."


00:56:31.000 --> 00:56:35.120
But when you get to the engineering and the science level and you're trying to verify


00:56:35.120 --> 00:56:39.960
physical things and stuff, it's cool to see how far you can push it to maybe even answer


00:56:39.960 --> 00:56:41.560
that question better, right?


00:56:41.560 --> 00:56:46.000
Like with this reporting, for example, over time.


00:56:46.000 --> 00:56:49.440
I think it makes it more transparent as well.


00:56:49.440 --> 00:56:53.480
In the open source community, we like to quote Linus' law a lot, we say with enough eyeballs


00:56:53.480 --> 00:56:55.640
all bugs are shallow.


00:56:55.640 --> 00:56:59.040
But if we're honest with ourselves, not everyone is going to go and read the code.


00:56:59.040 --> 00:57:04.000
But on the other hand, if you can see a graph of, this is the frequency response of the


00:57:04.000 --> 00:57:11.260
system, that makes it much easier for interested parties to actually interrogate and say, "Look,


00:57:11.260 --> 00:57:14.520
is this good or is it lacking in some aspects?"


00:57:14.520 --> 00:57:18.960
So from that point of view, I think it just increases the transparency and allows not


00:57:18.960 --> 00:57:22.380
only yourself but the sort of the general the wider scientific community


00:57:22.380 --> 00:57:28.880
to have more confidence in the in the performance of your of your telescope


00:57:28.880 --> 00:57:35.600
makes it more approachable to I think exactly yeah people maybe wouldn't read


00:57:35.600 --> 00:57:38.940
a unit test and what the heck are they supposed to make out of it anyway you


00:57:38.940 --> 00:57:44.800
know they may well get a graph that was generated by the unit test right exactly


00:57:44.800 --> 00:57:48.660
exactly yeah and this is it much more it's much easier for me to pass as well


00:57:48.660 --> 00:57:53.100
because you know I get to the office in the morning and you know the CI run is


00:57:53.100 --> 00:57:56.820
done overnight and I can see at a glance you know are things working the way that


00:57:56.820 --> 00:58:04.220
they should. Yeah cool. What has been the reaction from other scientists and


00:58:04.220 --> 00:58:11.660
engineers when you talked about this? How's this perceived broadly? It's been


00:58:11.660 --> 00:58:14.740
relatively positive. Scientists want to know when they can get time on the


00:58:14.740 --> 00:58:19.060
telescope and then I have to tell them well there's a committee that


00:58:19.060 --> 00:58:24.180
evaluates scientific proposals, we can't short-circuit that unfortunately.


00:58:24.180 --> 00:58:29.140
Beercat has gotten a lot of attention from scientists who are


00:58:29.140 --> 00:58:36.220
interested in radio astronomy, particularly fields like pulsars and


00:58:36.220 --> 00:58:42.420
another of our clients, is possibly the wrong word, but is the


00:58:42.420 --> 00:58:46.780
project called Breakthrough Listen. If you've heard of SETI, it's the


00:58:46.780 --> 00:58:51.180
same crowd that are trying to search for extraterrestrial intelligence. And


00:58:51.180 --> 00:58:59.220
sometimes they're interested in these kinds of things, sometimes not.


00:58:59.220 --> 00:59:02.940
Often it's a much shorter question of like, "Is it working and can I


00:59:02.940 --> 00:59:08.180
get some of the data?" If the answer of those two is yes, and


00:59:08.180 --> 00:59:11.340
they start looking at the data, then you know there's performance figures and


00:59:11.340 --> 00:59:15.420
and test results are sometimes more interesting to them.


00:59:15.420 --> 00:59:15.940
>> Sure.


00:59:15.940 --> 00:59:19.020
>> But generally it's quite well received.


00:59:19.020 --> 00:59:21.740
>> It seems like a cool idea to me.


00:59:21.740 --> 00:59:26.300
Do you have, you know, time on telescopes is really precious


00:59:26.300 --> 00:59:28.780
and rare, hard to come by.


00:59:28.780 --> 00:59:29.980
The more powerful the telescope,


00:59:29.980 --> 00:59:33.580
I imagine the more contention there is for that time.


00:59:33.580 --> 00:59:37.100
Is there a bunch of simulation and software and things


00:59:37.100 --> 00:59:39.500
that people can, that you can hand out to these folks


00:59:39.500 --> 00:59:43.380
so they can work with beforehand,


00:59:43.380 --> 00:59:45.100
so they become more prepared?


00:59:45.100 --> 00:59:52.260
- Yes, and well, it mostly consists,


00:59:52.260 --> 00:59:55.440
it depends on what you're interested in.


00:59:55.440 --> 00:59:58.940
Meerkat has an interesting architecture


00:59:58.940 --> 01:00:02.140
in that there are some of the clients


01:00:02.140 --> 01:00:05.860
that have hardware right on site


01:00:05.860 --> 01:00:08.620
that are subscribing to data and processing it in real time


01:00:08.620 --> 01:00:11.340
and Breakthrough Listen is one of them.


01:00:11.340 --> 01:00:14.460
You know, they're interested in very, very fast transient stuff.


01:00:14.460 --> 01:00:18.540
Other scientists are more, they're not in as much of a hurry.


01:00:18.540 --> 01:00:22.140
They're more interested in the end result, the output of the correlator.


01:00:22.140 --> 01:00:27.060
That has been through several stages of pre-processing.


01:00:27.060 --> 01:00:30.260
And it depends on what kind of science that they're doing.


01:00:30.260 --> 01:00:35.020
And so, as with most telescopes certainly, but scientific instruments


01:00:35.020 --> 01:00:38.480
in general, we keep all of the data from observations of past.


01:00:38.480 --> 01:00:43.360
Typically there's an embargo on that, so it could be a period of 12 to 24 months, to allow


01:00:43.360 --> 01:00:48.160
the original originating scientist of the observation enough time to do his analysis


01:00:48.160 --> 01:00:49.880
and publish his papers.


01:00:49.880 --> 01:00:54.760
But once that is lifted, then that data is available to basically anyone who wants to


01:00:54.760 --> 01:00:56.100
use it.


01:00:56.100 --> 01:01:01.160
So all that we need to do is contact us and we can give them access to historical data


01:01:01.160 --> 01:01:02.160
sets.


01:01:02.160 --> 01:01:07.720
And they can begin to test their algorithms on actual historical observations.


01:01:07.720 --> 01:01:15.120
Yeah, that seems good. Excellent. All right, a quick question, follow-up question here before we kind of wrap things up.


01:01:15.120 --> 01:01:20.180
James asks, what happens to the raw data? Talking about coming out the correlator, I suppose.


01:01:20.180 --> 01:01:26.940
How much of it is captured and stored versus processed down and then storing the result?


01:01:26.940 --> 01:01:30.000
Okay, so as I mentioned earlier,


01:01:30.000 --> 01:01:32.760
each


01:01:32.760 --> 01:01:34.760
telescope generates data at about


01:01:35.140 --> 01:01:46.760
35 gigabits per second. That is impractical to store. We have logic on site that will


01:01:46.760 --> 01:01:51.800
buffer up a few seconds worth of data and then they have algorithms that are searching


01:01:51.800 --> 01:01:56.240
through it for interesting things. And if there's something that they notice, there's


01:01:56.240 --> 01:02:00.320
a mechanism to dump that to disk, so just a few seconds at a time. And that happens


01:02:00.320 --> 01:02:04.640
a few times a year.


01:02:04.640 --> 01:02:07.960
Generally the most interesting pieces are a little bit more downstream.


01:02:07.960 --> 01:02:15.320
So 35 gigabits per second times 64 is a large number, so that's north of 2 terabits per


01:02:15.320 --> 01:02:19.560
second that the antennas themselves generate.


01:02:19.560 --> 01:02:24.420
The output of a 64 antenna correlator is about 4 gigabits per second.


01:02:24.420 --> 01:02:31.760
So you could ingest that on a Mac Mini if you somehow had a USB for to...


01:02:31.760 --> 01:02:34.760
Just somewhere there to keep plugging and unplugging drives really quickly.


01:02:34.760 --> 01:02:39.620
To Ethernet, yeah, you'd need to do it pretty quickly, but that is practical.


01:02:39.620 --> 01:02:42.420
That we have a storage cluster.


01:02:42.420 --> 01:02:46.760
So we have one on site in the desert in South Africa.


01:02:46.760 --> 01:02:51.760
It's relatively small, only about five petabytes, but that acts as a cache.


01:02:51.760 --> 01:02:56.040
And then there is a fiber link to Cape Town where we have a data center with a much larger


01:02:56.040 --> 01:02:58.320
archive.


01:02:58.320 --> 01:03:05.680
That uses an object store, I believe it's Ceph, which is also an open source thing.


01:03:05.680 --> 01:03:13.280
And I'm speaking a little bit outside of my expertise now, but that data is retained then,


01:03:13.280 --> 01:03:16.280
well so far in perpetuity, we haven't gotten to the stage where we need to start deleting


01:03:16.280 --> 01:03:21.640
old data yet, so we've got all of the observations that we've ever run.


01:03:21.640 --> 01:03:26.640
And they range in size, it depends on the observation, but sometimes they're a few gigabytes


01:03:26.640 --> 01:03:30.240
and sometimes they're sort of many terabytes in size.


01:03:30.240 --> 01:03:31.240
Cool.


01:03:31.240 --> 01:03:32.240
So, yeah.


01:03:32.240 --> 01:03:34.560
Yeah, it's a lot of data.


01:03:34.560 --> 01:03:38.800
You wouldn't store the two terabit per second though, that's too much.


01:03:38.800 --> 01:03:43.120
No, that's one of the reasons that the correlator exists, to sort of get that down to a manageable,


01:03:43.120 --> 01:03:44.560
useful level.


01:03:44.560 --> 01:03:45.560
Yeah.


01:03:45.560 --> 01:03:46.560
Indeed.


01:03:46.560 --> 01:03:47.560
All right.


01:03:47.560 --> 01:03:51.880
All right, well, anything else you want to add that we haven't talked about


01:03:51.880 --> 01:03:55.800
briefly about this testing side of things? We covered it pretty well.


01:03:55.800 --> 01:04:00.200
I think, so the one thing that we haven't kind of talked about is,


01:04:00.200 --> 01:04:05.160
we talked a little bit about earlier about the how critical the performance of this is,


01:04:05.160 --> 01:04:09.080
and one of the things that testing has really enabled is for us to


01:04:09.080 --> 01:04:13.800
optimize the performance of the system, and in a way that's I think not immediately obvious.


01:04:14.760 --> 01:04:22.040
If you have a first naive implementation of your signal processing algorithm that's easy to read,


01:04:22.040 --> 01:04:26.680
easy to reason about, it's not likely to be the fastest possible way to process the data.


01:04:26.680 --> 01:04:31.800
But it's good to have that, and then once you have that, then you can write a test for it.


01:04:31.800 --> 01:04:38.840
So you can compare a known input to a known output and see if your maths is correct. That way,


01:04:38.840 --> 01:04:44.280
when you iterate, perhaps we can change the memory access patterns or improve the


01:04:44.280 --> 01:04:46.020
of the coordination between the threads.


01:04:46.020 --> 01:04:47.820
It's very easy when you do that to make a mistake


01:04:47.820 --> 01:04:49.720
and start messing up your results.


01:04:49.720 --> 01:04:51.220
But when you have a unit test,


01:04:51.220 --> 01:04:53.400
and you start messing up results,


01:04:53.400 --> 01:04:54.960
you can catch it straight away.


01:04:54.960 --> 01:04:59.160
And so having that testing in place


01:04:59.160 --> 01:05:03.040
allows us a little bit of room to experiment


01:05:03.040 --> 01:05:05.160
to really push this to the limits


01:05:05.160 --> 01:05:07.440
of what these GPUs are capable of doing


01:05:07.440 --> 01:05:10.660
in terms of increasing bandwidth


01:05:10.660 --> 01:05:13.240
or more antennas that we can process


01:05:13.240 --> 01:05:14.900
or all these kinds of things.


01:05:14.900 --> 01:05:19.100
And you mentioned regressions earlier,


01:05:19.100 --> 01:05:21.300
that's also an excellent thing.


01:05:21.300 --> 01:05:23.300
So you're working on another part of a system


01:05:23.300 --> 01:05:27.060
and something breaks, having these tests in place


01:05:27.060 --> 01:05:28.840
will let you know we've messed something up,


01:05:28.840 --> 01:05:31.880
let's revert back and be a little bit more careful next time.


01:05:31.880 --> 01:05:34.460
So I think it's just a great concept.


01:05:34.460 --> 01:05:36.820
In industry, in science, in academia,


01:05:36.820 --> 01:05:40.480
everyone would benefit from having


01:05:40.480 --> 01:05:42.280
more and better tests in place.


01:05:42.280 --> 01:05:43.720
It's not a panacea.


01:05:43.720 --> 01:05:47.320
You're not gonna anticipate all possible failure modes


01:05:47.320 --> 01:05:50.480
in your tests, but it definitely helps catch


01:05:50.480 --> 01:05:52.280
many of the obvious ones.


01:05:52.280 --> 01:05:53.800
- Yeah, good advice.


01:05:53.800 --> 01:05:55.240
Testing science is tricky.


01:05:55.240 --> 01:05:58.420
It's usually a stream of numbers in some way.


01:05:58.420 --> 01:06:01.400
It's not, yes, there was a user, no, it came back none,


01:06:01.400 --> 01:06:02.800
or there was an exception.


01:06:02.800 --> 01:06:06.480
It's still shooting out a bunch of numbers.


01:06:06.480 --> 01:06:07.320
Are they good?


01:06:07.320 --> 01:06:08.940
Maybe they're better, I don't know, right?


01:06:08.940 --> 01:06:12.120
But having systems in place to record them,


01:06:12.120 --> 01:06:15.080
to test them and say, if it matches this curve


01:06:15.080 --> 01:06:17.720
within some tolerance, it's still good, right?


01:06:17.720 --> 01:06:18.880
- Yes.


01:06:18.880 --> 01:06:20.680
- It's really important in those areas


01:06:20.680 --> 01:06:25.240
because it's so hard to look at it and know what the deal is.


01:06:25.240 --> 01:06:26.080
- Exactly.


01:06:26.080 --> 01:06:28.120
And I mean, so it is a team effort.


01:06:28.120 --> 01:06:30.800
There's not necessarily any one person


01:06:30.800 --> 01:06:33.760
that's gonna have the experience to do all of these things.


01:06:33.760 --> 01:06:37.000
So the person who is a very experienced systems engineer


01:06:37.000 --> 01:06:39.920
who will know the methods


01:06:39.920 --> 01:06:41.520
by which we can evaluate the performance


01:06:41.520 --> 01:06:43.300
is not necessarily going to be the best coder.


01:06:43.300 --> 01:06:45.020
So that's why we have a large team


01:06:45.020 --> 01:06:48.300
in order to pull all of these things in.


01:06:48.300 --> 01:06:51.440
So yes, so shout out to my colleagues at Sereo.


01:06:51.440 --> 01:06:53.660
We're doing good work.


01:06:53.660 --> 01:06:55.620
Or at least I like to think we are.


01:06:55.620 --> 01:06:57.340
- It sure seems like it.


01:06:57.340 --> 01:06:59.700
Cool, all right, well, we're about out of time


01:06:59.700 --> 01:07:01.220
to talk more about this.


01:07:01.220 --> 01:07:02.740
So let me ask you the final two questions


01:07:02.740 --> 01:07:04.220
before you get out of here.


01:07:04.220 --> 01:07:06.100
If you're gonna write some Python code


01:07:06.100 --> 01:07:10.060
for this crazy big system you built,


01:07:10.060 --> 01:07:11.500
What editor do you use?


01:07:11.500 --> 01:07:13.540
- I'm a bit old school.


01:07:13.540 --> 01:07:15.000
I basically just use Vim.


01:07:15.000 --> 01:07:17.500
- Vim, right on.


01:07:17.500 --> 01:07:19.520
- I feel most comfortable in the terminal,


01:07:19.520 --> 01:07:21.840
so no fancy GUIs for me.


01:07:21.840 --> 01:07:23.060
- Yeah, there you go.


01:07:23.060 --> 01:07:25.460
And then notable PyPI package,


01:07:25.460 --> 01:07:27.060
do you wanna give a shout out to?


01:07:27.060 --> 01:07:31.900
- Well, a couple of ones that I've already mentioned.


01:07:31.900 --> 01:07:33.180
pytest is very important.


01:07:33.180 --> 01:07:38.180
PyCUDA has also been critical in our work so far.


01:07:39.540 --> 01:07:40.980
So yeah, shout out to those two.


01:07:40.980 --> 01:07:43.060
And thanks to open source community


01:07:43.060 --> 01:07:45.100
for providing that for us.


01:07:45.100 --> 01:07:47.740
- Yeah, it's really cool how much of these


01:07:47.740 --> 01:07:51.540
general open source projects are supporting science


01:07:51.540 --> 01:07:53.840
and other types of exploration.


01:07:53.840 --> 01:07:56.880
- Cool.


01:07:56.880 --> 01:07:58.780
- Yeah, okay, final call to action.


01:07:58.780 --> 01:08:01.760
People are interested in maybe adopting


01:08:01.760 --> 01:08:02.860
some of your practices.


01:08:02.860 --> 01:08:04.740
Maybe they wanna learn more about how you did this


01:08:04.740 --> 01:08:06.580
reporting in pytest.


01:08:06.580 --> 01:08:11.740
even as someone in the audience asks, you know, can they get access, how do they


01:08:11.740 --> 01:08:16.220
get access to the datasets potentially? What do you tell them?


01:08:16.220 --> 01:08:23.580
The datasets, well I hope you have a very big hard drive on your laptop.


01:08:23.580 --> 01:08:28.820
So if you go to sereo.ac.za there'll be a contact page and if you can send us a


01:08:28.820 --> 01:08:33.820
question and we'll make sure that it gets to the right person. I'm not sure


01:08:33.820 --> 01:08:40.460
what the procedure is for access for people outside, I can get to it when I want to, but


01:08:40.460 --> 01:08:42.460
then I'm inside the organization.


01:08:42.460 --> 01:08:46.300
But if you ask the question on our contact page, yeah, and then we'll send you to the


01:08:46.300 --> 01:08:48.360
right place.


01:08:48.360 --> 01:08:55.160
To learn more, I'll put the GitHub link to the software for the correlator.


01:08:55.160 --> 01:08:58.520
It's all there and the documentation is relatively good.


01:08:58.520 --> 01:08:59.880
If there's something that's missing,


01:08:59.880 --> 01:09:04.200
you're welcome to just raise an issue on the GitHub repo


01:09:04.200 --> 01:09:06.620
and then we'll see how we can help.


01:09:06.620 --> 01:09:07.600
- Excellent.


01:09:07.600 --> 01:09:08.880
Well, thanks for sharing your story


01:09:08.880 --> 01:09:10.440
and keep up the good work.


01:09:10.440 --> 01:09:12.600
- Michael, yeah, thanks very much.


01:09:12.600 --> 01:09:14.640
It's been great to be here.


01:09:14.640 --> 01:09:15.960
- Yeah, it has been great to talk to you.


01:09:15.960 --> 01:09:17.720
See you all later.


01:09:17.720 --> 01:09:18.540
- Cheers.

