WEBVTT

00:00:00.000 --> 00:00:04.160
Stanislav, welcome to Talk Python To Me.

00:00:04.160 --> 00:00:06.800
It's great to have you here.

00:00:06.800 --> 00:00:08.600
It's good to be here.

00:00:08.600 --> 00:00:10.200
Yeah, it's good to have you here.

00:00:10.200 --> 00:00:12.560
I wonder what version we're going to end up

00:00:12.560 --> 00:00:14.040
shipping of this episode.

00:00:14.040 --> 00:00:20.200
We're going to talk about API versions.

00:00:20.200 --> 00:00:21.040
API versions.

00:00:21.040 --> 00:00:23.400
API versions.

00:00:23.400 --> 00:00:26.360
It's good to have many of them, you know?

00:00:26.360 --> 00:00:29.480
Yeah, it's one of those problems that as soon as you

00:00:29.480 --> 00:00:33.040
create an API and people start to use it,

00:00:33.040 --> 00:00:36.640
they don't want to keep rewriting their code.

00:00:36.640 --> 00:00:40.720
But you need to evolve your API over time

00:00:40.720 --> 00:00:43.680
as it gets new features, as maybe more importantly,

00:00:43.680 --> 00:00:46.560
you realize, oh, that was a bad choice.

00:00:46.560 --> 00:00:47.600
How do you fix this?

00:00:47.600 --> 00:00:51.320
So that's kind of the theme of this episode.

00:00:51.320 --> 00:00:54.080
We're going to talk about concrete tools

00:00:54.080 --> 00:00:58.800
that you can use to add versioning to various API

00:00:58.800 --> 00:01:01.200
frameworks in Python and some of the ideas behind it.

00:01:01.200 --> 00:01:03.760
So it's going to be a ton of fun.

00:01:03.760 --> 00:01:07.080
Let's start, though, with your story.

00:01:07.080 --> 00:01:10.040
Tell us a bit about yourself.

00:01:10.040 --> 00:01:15.160
So previously, I have been a back-end engineer for six

00:01:15.160 --> 00:01:17.720
or even seven years now.

00:01:17.720 --> 00:01:22.720
But recently, I have shifted into infrastructure.

00:01:22.720 --> 00:01:25.200
Right now, I'm a platform engineering tech

00:01:25.200 --> 00:01:26.400
lead at Monite.

00:01:26.400 --> 00:01:29.960
What I do is I make architectural decisions.

00:01:29.960 --> 00:01:31.400
I mentor the teams.

00:01:31.400 --> 00:01:35.400
I help the teams with Python-specific questions.

00:01:35.400 --> 00:01:38.600
But mostly, I build Python-specific infrastructure.

00:01:38.600 --> 00:01:42.840
And my main job is making our business teams happy.

00:01:42.840 --> 00:01:43.320
Excellent.

00:01:43.320 --> 00:01:44.120
I try to do that--

00:01:44.120 --> 00:01:46.400
Sounds really--

00:01:46.400 --> 00:01:47.240
Yeah.

00:01:47.240 --> 00:01:50.720
I try to do that in my open source work as well.

00:01:50.720 --> 00:01:53.080
I like to make my own open source projects.

00:01:53.080 --> 00:01:55.720
I like to contribute to big projects, small projects.

00:01:55.720 --> 00:01:57.680
It's all over the place.

00:01:57.680 --> 00:02:00.240
And we're going to be mentioning one of them today.

00:02:00.240 --> 00:02:01.800
Yeah, you built a really cool library

00:02:01.800 --> 00:02:03.120
that we're going to talk about.

00:02:03.120 --> 00:02:04.840
And that'll be a lot of fun.

00:02:04.840 --> 00:02:05.840
It looks really useful.

00:02:05.840 --> 00:02:10.480
And some other third-party ones as well.

00:02:10.480 --> 00:02:13.560
So I wanted to ask you a little bit about,

00:02:13.560 --> 00:02:17.240
what is the difference between being a back-end software

00:02:17.240 --> 00:02:19.520
developer, which I think a lot of people

00:02:19.520 --> 00:02:21.920
get the sense of, like building APIs,

00:02:21.920 --> 00:02:27.680
building the back-end, at least, aspect of websites and so on,

00:02:27.680 --> 00:02:30.800
versus, say, building infrastructure in Python?

00:02:30.800 --> 00:02:31.880
What are these two worlds?

00:02:31.880 --> 00:02:32.800
How are they the same?

00:02:32.800 --> 00:02:35.120
How are they different?

00:02:35.120 --> 00:02:39.640
So when you're building them, especially when you're

00:02:39.640 --> 00:02:42.080
building products, it's very similar.

00:02:42.080 --> 00:02:45.320
However, in back-end, there is already a lot

00:02:45.320 --> 00:02:47.960
of infrastructure around you.

00:02:47.960 --> 00:02:50.920
There is already a lot of people who

00:02:50.920 --> 00:02:52.600
do portions of your job.

00:02:52.600 --> 00:02:55.560
So there are people who can sell your product.

00:02:55.560 --> 00:02:59.480
There are people who are thinking about how

00:02:59.480 --> 00:03:01.120
to move it forward, how to evolve it.

00:03:01.120 --> 00:03:05.600
There are people who are designing it, thinking about it.

00:03:05.600 --> 00:03:07.200
But when you're a platform engineer,

00:03:07.200 --> 00:03:09.280
you've got to do all of that yourself.

00:03:09.280 --> 00:03:13.880
And also, one big portion of any library framework

00:03:13.880 --> 00:03:17.600
or anything else, any developer tools development,

00:03:17.600 --> 00:03:20.480
is the fact that, unlike an API--

00:03:20.480 --> 00:03:22.840
well, a web API, a REST API, which

00:03:22.840 --> 00:03:29.760
has a very strict interface where the developer wouldn't

00:03:29.760 --> 00:03:32.560
be able to use it in a million ways,

00:03:32.560 --> 00:03:35.480
a library, especially in a language

00:03:35.480 --> 00:03:39.080
as introspectable as Python, the developers

00:03:39.080 --> 00:03:41.040
can do crazy things with your stuff.

00:03:41.040 --> 00:03:44.520
So you've got to think forward for all of these use cases.

00:03:44.520 --> 00:03:47.960
And you've got to be sure that you don't expose

00:03:47.960 --> 00:03:49.400
extra private interfaces.

00:03:49.400 --> 00:03:51.600
Because once you do expose them, it

00:03:51.600 --> 00:03:54.840
won't be nice to break them in the future.

00:03:54.840 --> 00:03:58.160
>>Yeah, absolutely.

00:03:58.160 --> 00:04:01.400
I guess it's a little more restricted with APIs

00:04:01.400 --> 00:04:03.560
than it is with handing out packages, right?

00:04:03.560 --> 00:04:07.600
Because people, they can just dive into the packages

00:04:07.600 --> 00:04:08.640
and do whatever you want.

00:04:08.640 --> 00:04:10.280
And the API is more or less limited

00:04:10.280 --> 00:04:15.280
by what the website's willing to process, right?

00:04:15.280 --> 00:04:16.360
Yep.

00:04:16.360 --> 00:04:19.640
On the flip side, you have code on the internet.

00:04:19.640 --> 00:04:22.640
And any time you have code on the internet,

00:04:22.640 --> 00:04:26.120
that's always a little stressful, right?

00:04:26.120 --> 00:04:28.240
Whatever is out there, it's incredible

00:04:28.240 --> 00:04:30.640
if you have a website, you pull up the logs,

00:04:30.640 --> 00:04:33.960
how much abuse your website is taking constantly.

00:04:33.960 --> 00:04:34.880
>>True.

00:04:34.880 --> 00:04:36.240
True.

00:04:36.240 --> 00:04:38.840
But I mean, the great thing about building packages

00:04:38.840 --> 00:04:42.360
is that you're not worried about what happens with them after.

00:04:42.360 --> 00:04:43.680
You just give them.

00:04:43.680 --> 00:04:46.280
And then if it breaks, it's not you.

00:04:46.280 --> 00:04:49.840
It's not on your servers, hopefully.

00:04:49.840 --> 00:04:53.760
But also, as I mentioned, you've got to both be its designer,

00:04:53.760 --> 00:04:59.400
you've got to sell it, you've got to talk people through that,

00:04:59.400 --> 00:05:00.960
you've got to document it.

00:05:00.960 --> 00:05:03.320
As a platform engineer, you do all of the parts

00:05:03.320 --> 00:05:06.320
that backend engineers are abstracted away from,

00:05:06.320 --> 00:05:11.080
or at least in most bigger companies, abstracted away from.

00:05:11.080 --> 00:05:11.920
>>Yeah.

00:05:11.920 --> 00:05:14.240
Yeah, super interesting.

00:05:14.240 --> 00:05:17.000
All right, let's talk about, I guess,

00:05:17.000 --> 00:05:20.080
one more thing for your introduction before we move on.

00:05:20.080 --> 00:05:24.280
You've worked on quite a few interesting projects here.

00:05:24.280 --> 00:05:26.640
So maybe give us just a little bit of background

00:05:26.640 --> 00:05:29.800
on some of your open source work.

00:05:29.800 --> 00:05:34.080
>>So I'll just talk about, I guess, the most popular ones.

00:05:34.080 --> 00:05:37.520
The coolest one was Pathwalk.

00:05:37.520 --> 00:05:39.640
If you remember, in Python, there is OSwalk,

00:05:39.640 --> 00:05:43.680
but then in Python 3.12, I added Pathwalk.

00:05:43.680 --> 00:05:46.800
I have also added the type-ins for that into TypeShed,

00:05:46.800 --> 00:05:48.520
I think some other things.

00:05:48.520 --> 00:05:52.600
And I am, I think, top 10 contributor of Tortoise ORM,

00:05:52.600 --> 00:05:57.600
the asynchronous ORM that claims to be the fastest,

00:05:57.600 --> 00:06:00.240
or at least one of the fastest in Python.

00:06:00.240 --> 00:06:02.480
And a few smaller projects,

00:06:02.480 --> 00:06:06.320
which I don't think there is anything particularly

00:06:06.320 --> 00:06:09.760
fun to talk about there.

00:06:09.760 --> 00:06:12.500
It's just mostly bug fixes and small features.

00:06:12.500 --> 00:06:14.800
But then my other projects,

00:06:14.800 --> 00:06:17.320
the ones that I maintain, are way cooler.

00:06:17.320 --> 00:06:20.360
For example, Pydantic Duality enables you to

00:06:20.360 --> 00:06:25.680
have multiple versions of your Pydantic models

00:06:25.680 --> 00:06:28.120
for almost free in terms of performance

00:06:28.120 --> 00:06:32.480
and without any code generation.

00:06:32.480 --> 00:06:35.360
And CADWIN, the project we're going to be discussing today,

00:06:35.360 --> 00:06:38.120
implements, I guess, the fullest

00:06:38.120 --> 00:06:40.920
and most sophisticated API versioning paradigm

00:06:40.920 --> 00:06:42.260
there is at this point.

00:06:42.260 --> 00:06:44.560
>>Excellent, yeah.

00:06:44.560 --> 00:06:45.400
>>A lot of cool stuff.

00:06:45.400 --> 00:06:46.480
>>Pydantic Duality looks, yeah,

00:06:46.480 --> 00:06:48.720
Pydantic Duality looks really, really cool.

00:06:48.720 --> 00:06:51.600
So a lot of neat stuff here.

00:06:51.600 --> 00:06:54.040
A lot of different ways people might know about you.

00:06:54.040 --> 00:06:57.000
So yeah, CADWIN's the one we're gonna be focusing on

00:06:57.000 --> 00:06:58.440
for here.

00:06:58.440 --> 00:07:02.800
So let's start with talking about APIs.

00:07:02.800 --> 00:07:06.440
You talked about API-first companies, what's that?

00:07:06.440 --> 00:07:13.200
>>So API-first company, just like any other term

00:07:13.200 --> 00:07:16.300
that gets popular, is a buzzword, obviously.

00:07:16.300 --> 00:07:19.680
But the truth behind it is,

00:07:19.680 --> 00:07:24.720
an API-first company is any company whose main product

00:07:24.720 --> 00:07:28.560
is an API and the SDKs associated with it.

00:07:28.560 --> 00:07:33.160
And as a result, API-first company has to document

00:07:33.160 --> 00:07:36.040
their API really thoroughly, think about their API,

00:07:36.040 --> 00:07:38.800
both the internal one and the external one,

00:07:38.800 --> 00:07:41.320
and take great care of that

00:07:41.320 --> 00:07:43.160
because it's their main product.

00:07:43.160 --> 00:07:48.160
So we have a lot of API-first companies right now,

00:07:48.160 --> 00:07:51.520
but with every year, new industries are joining.

00:07:51.520 --> 00:07:55.860
And if you ever heard of Open Banking, things like that,

00:07:55.860 --> 00:08:00.000
banks are going to join us soon.

00:08:00.000 --> 00:08:02.040
In some countries, they already have.

00:08:02.040 --> 00:08:07.040
And Monite is doing similar things

00:08:07.040 --> 00:08:11.080
and tries to bring that innovation, that Open Banking,

00:08:11.080 --> 00:08:14.680
and that API-first approach into banking.

00:08:14.680 --> 00:08:17.020
>>Yeah, so the company we work for, Monite,

00:08:18.560 --> 00:08:23.520
they build, you all build APIs to basically facilitate

00:08:23.520 --> 00:08:26.520
other people doing invoicing and bill pay in their apps.

00:08:26.520 --> 00:08:27.360
Is that correct?

00:08:27.360 --> 00:08:32.280
>>Yeah, you could call us a B2B2B company.

00:08:32.280 --> 00:08:35.840
'Cause essentially, many banks, many marketplaces

00:08:35.840 --> 00:08:40.600
are very outdated in terms of how they handle invoicing

00:08:40.600 --> 00:08:44.000
and payments, and we try to take all of that,

00:08:44.000 --> 00:08:47.280
combine that, and offer that as a white label product

00:08:47.280 --> 00:08:48.240
to them.

00:08:48.240 --> 00:08:52.160
So we do this for them, they integrate with us once,

00:08:52.160 --> 00:08:54.840
and then they forget it was ever a problem.

00:08:54.840 --> 00:08:59.280
They just give our product as their straight to their clients

00:08:59.280 --> 00:09:01.400
>>Yeah, that's excellent.

00:09:01.400 --> 00:09:05.840
So this seems like kind of in that category of API-first.

00:09:05.840 --> 00:09:08.000
>>Oh, yes.

00:09:08.000 --> 00:09:09.520
>>Yeah, okay.

00:09:09.520 --> 00:09:12.880
Yeah, it's cool that you have concrete experience with it,

00:09:12.880 --> 00:09:13.920
right, of course.

00:09:17.720 --> 00:09:22.040
So give us some of the laws.

00:09:22.040 --> 00:09:23.960
We coordinated a little bit beforehand,

00:09:23.960 --> 00:09:28.000
and there's some interesting laws for designing good APIs.

00:09:28.000 --> 00:09:31.400
Like one of them is the reverse Conway maneuver,

00:09:31.400 --> 00:09:34.920
which to me sounds like a jujitsu sort of move

00:09:34.920 --> 00:09:36.080
that you might try to pull.

00:09:36.080 --> 00:09:36.920
What is this?

00:09:36.920 --> 00:09:39.360
>>Oh, yes.

00:09:39.360 --> 00:09:43.040
So when you are designing any system,

00:09:43.040 --> 00:09:46.320
you gotta think about the way it's going to end up

00:09:46.320 --> 00:09:48.520
and the laws that are going to govern them.

00:09:48.520 --> 00:09:52.400
And Conway's law is one of the main laws that do that.

00:09:52.400 --> 00:09:55.400
To explain that to people in simple terms,

00:09:55.400 --> 00:09:58.120
if you have four teams designing a compiler,

00:09:58.120 --> 00:10:00.680
you're going to have a four-pass compiler.

00:10:00.680 --> 00:10:05.320
And essentially, the way you set up communications

00:10:05.320 --> 00:10:07.600
within your company, the way you set up your teams,

00:10:07.600 --> 00:10:11.000
your structure is going to be reflected in your product,

00:10:11.000 --> 00:10:12.520
and you can't do anything about it.

00:10:12.520 --> 00:10:15.040
You can spend money, you can coordinate people,

00:10:15.040 --> 00:10:18.680
but at some point, Conway's law is going to affect you

00:10:18.680 --> 00:10:21.120
and it's going to be harsh.

00:10:21.120 --> 00:10:25.800
So one of the ways to, I guess, go around it

00:10:25.800 --> 00:10:28.720
is to first think of an interface that you want to provide,

00:10:28.720 --> 00:10:31.240
and it applies to anything, not just APIs.

00:10:31.240 --> 00:10:33.720
API is just a really good example of that.

00:10:33.720 --> 00:10:36.480
And then design your company

00:10:36.480 --> 00:10:38.920
and the communications within your company,

00:10:38.920 --> 00:10:40.400
the teams within your company,

00:10:40.400 --> 00:10:44.480
to reflect the interfaces that you want to get in the end.

00:10:44.480 --> 00:10:45.920
And that's reverse Conway's law.

00:10:45.920 --> 00:10:48.440
- Okay, because your code and your APIs

00:10:48.440 --> 00:10:49.840
and all those things are going to reflect

00:10:49.840 --> 00:10:51.640
your company's structure and culture.

00:10:51.640 --> 00:10:54.840
So instead of having that being implicit,

00:10:54.840 --> 00:10:57.320
make it more explicit by saying,

00:10:57.320 --> 00:10:58.920
well, this is the end point that we want,

00:10:58.920 --> 00:11:01.320
the end result that we want.

00:11:01.320 --> 00:11:04.440
How do we work that backwards to end up,

00:11:04.440 --> 00:11:07.520
structuring teams or whatever to get this, right?

00:11:07.520 --> 00:11:08.880
- Precisely, yes.

00:11:08.880 --> 00:11:10.880
- Yeah, it is a little bit like Jujitsu.

00:11:10.880 --> 00:11:12.960
Anyway. (laughs)

00:11:12.960 --> 00:11:15.800
But there are more laws that do that.

00:11:15.800 --> 00:11:17.200
Of course, there is REST,

00:11:17.200 --> 00:11:20.000
which I guess not really laws, but principles,

00:11:20.000 --> 00:11:26.080
which most people, or at least most companies I saw,

00:11:26.080 --> 00:11:29.320
don't really like to follow it to the letter.

00:11:29.320 --> 00:11:31.640
But if you do, making,

00:11:31.640 --> 00:11:34.720
if you do follow REST,

00:11:34.720 --> 00:11:39.640
if you try to make your API as available as you can

00:11:39.640 --> 00:11:41.880
and as standardized as you can,

00:11:41.880 --> 00:11:43.480
then it's much easier for new people,

00:11:43.480 --> 00:11:45.160
especially junior developers to learn.

00:11:45.160 --> 00:11:47.280
And then that makes it much easier

00:11:47.280 --> 00:11:50.040
for your clients to integrate with you, which is great.

00:11:50.040 --> 00:11:54.400
There is also, there are also a few,

00:11:54.400 --> 00:11:55.880
I guess, more advanced things.

00:11:55.880 --> 00:11:58.120
For example, when you are designing an API,

00:11:58.120 --> 00:11:59.680
when you're doing microservices

00:11:59.680 --> 00:12:02.680
and when you have many services talking to each other,

00:12:02.680 --> 00:12:07.680
which in the end provide your final product

00:12:07.680 --> 00:12:09.840
to your customers,

00:12:09.840 --> 00:12:13.440
a good idea is to omit any internal APIs

00:12:13.440 --> 00:12:15.200
and make all of your APIs,

00:12:15.200 --> 00:12:18.140
or at least the majority of your APIs external.

00:12:18.140 --> 00:12:21.520
That is also one of the things about API-first.

00:12:21.520 --> 00:12:23.600
Once all of your APIs are external,

00:12:23.600 --> 00:12:28.000
it means that your clients will be able to build a product

00:12:28.000 --> 00:12:30.600
that is of similar quality to yours.

00:12:30.600 --> 00:12:33.240
We're using your APIs, using your data,

00:12:33.240 --> 00:12:36.640
which provides them with infinite capabilities of using you,

00:12:36.640 --> 00:12:38.320
which is great.

00:12:38.320 --> 00:12:39.880
- Yeah, that is great.

00:12:39.880 --> 00:12:42.760
It's certainly frustrating when you see,

00:12:42.760 --> 00:12:44.880
it's not on the API level,

00:12:44.880 --> 00:12:48.160
but you see things in like the iOS platform

00:12:48.160 --> 00:12:50.880
or in Windows or wherever, you're like,

00:12:50.880 --> 00:12:52.160
why can't I do this?

00:12:52.160 --> 00:12:54.920
Like, these are private things

00:12:54.920 --> 00:12:56.920
that either Apple or Microsoft or whoever

00:12:56.920 --> 00:12:58.320
are keeping to themselves

00:12:58.320 --> 00:13:01.640
and clearly are important for building apps,

00:13:01.640 --> 00:13:02.960
but you can't use them, right?

00:13:02.960 --> 00:13:06.600
So you're suggesting that by having basically

00:13:06.600 --> 00:13:08.160
whatever APIs you need,

00:13:08.160 --> 00:13:09.880
I guess there's probably limits, right?

00:13:09.880 --> 00:13:12.680
Like you don't want to expose, say, your like HR API

00:13:12.680 --> 00:13:14.360
if you're not an HR company, right?

00:13:14.360 --> 00:13:19.360
But in general, having your APIs just be all public, right?

00:13:19.360 --> 00:13:21.440
It probably makes them better as well

00:13:21.440 --> 00:13:23.480
because they just get so many more use cases.

00:13:23.480 --> 00:13:25.840
They get treated with things like versioning

00:13:25.840 --> 00:13:27.000
and stuff more seriously.

00:13:27.000 --> 00:13:28.240
- Exactly.

00:13:28.240 --> 00:13:30.360
- Yeah, yeah.

00:13:30.360 --> 00:13:31.320
Excellent.

00:13:31.320 --> 00:13:35.080
- But it's a complex topic that could span,

00:13:35.080 --> 00:13:36.640
you know, we could discuss it for hours,

00:13:36.640 --> 00:13:41.640
you know, which parts of your API do you make public?

00:13:41.640 --> 00:13:44.680
Which parts of your API do you start versioning?

00:13:44.680 --> 00:13:47.200
And if you're combining your APIs

00:13:47.200 --> 00:13:49.760
using a gateway or a federation, you know,

00:13:49.760 --> 00:13:53.440
it's a long story, but I guess with a federation,

00:13:53.440 --> 00:13:55.280
you wouldn't really make it public.

00:13:55.280 --> 00:13:57.840
- Sure.

00:13:57.840 --> 00:13:59.480
Well, let's dive into that a little bit.

00:13:59.480 --> 00:14:02.080
Let's talk about API versioning.

00:14:03.200 --> 00:14:05.800
We know what versioning is in Python.

00:14:05.800 --> 00:14:08.920
We have lock files.

00:14:08.920 --> 00:14:10.440
We pin the version.

00:14:10.440 --> 00:14:15.200
We might say we're using Pydantic 2.0.5

00:14:15.200 --> 00:14:16.560
or whatever it is.

00:14:16.560 --> 00:14:19.760
And that leaves the Pydantic team free

00:14:19.760 --> 00:14:21.080
to do whatever they want.

00:14:21.080 --> 00:14:22.920
And we can trust that our code

00:14:22.920 --> 00:14:24.600
is gonna stay the way it stayed.

00:14:24.600 --> 00:14:27.640
I guess API versioning is that,

00:14:27.640 --> 00:14:32.440
but for web endpoints rather than software links.

00:14:32.440 --> 00:14:37.440
- Yeah, and it's a little different though in some regards.

00:14:37.440 --> 00:14:42.160
For example, when you're packaging your, I don't know,

00:14:42.160 --> 00:14:45.360
software and you just send it to clients,

00:14:45.360 --> 00:14:49.200
thing is you need to have versions for every single thing.

00:14:49.200 --> 00:14:52.560
For example, if we are doing a bug fix

00:14:52.560 --> 00:14:54.240
and we need to ship that to our clients,

00:14:54.240 --> 00:14:56.120
that is going to be a separate version.

00:14:56.120 --> 00:14:59.280
But in web, when you're hosting it on a server

00:14:59.280 --> 00:15:02.600
and your clients just make requests to your servers,

00:15:02.600 --> 00:15:03.600
you don't need that.

00:15:03.600 --> 00:15:06.720
You don't need to ship bug fixes as separate versions.

00:15:06.720 --> 00:15:08.160
You can just ship them

00:15:08.160 --> 00:15:10.240
because they're not going to break anything for your clients

00:15:10.240 --> 00:15:12.480
and your clients will be able to automatically get them.

00:15:12.480 --> 00:15:14.840
Same goes for minor versions.

00:15:14.840 --> 00:15:17.200
Minor versions that just add features

00:15:17.200 --> 00:15:20.280
don't really need to be for a version on APIs.

00:15:20.280 --> 00:15:23.640
That leaves us with just major versions,

00:15:23.640 --> 00:15:27.120
which is why many companies like Stripe at Monite

00:15:27.120 --> 00:15:31.920
use dates for their versions

00:15:31.920 --> 00:15:33.080
because we don't really need

00:15:33.080 --> 00:15:36.080
all of the power of semantic versioning.

00:15:36.080 --> 00:15:36.920
- Yeah, yeah, sure.

00:15:36.920 --> 00:15:40.280
More calendar versioning because all you really need to say

00:15:40.280 --> 00:15:43.080
is this one is different than before, right?

00:15:43.080 --> 00:15:44.280
It doesn't-- - Exactly.

00:15:44.280 --> 00:15:47.600
- Stripe does a lot of interesting things.

00:15:47.600 --> 00:15:52.600
We're gonna talk a little bit about what they're up to.

00:15:52.600 --> 00:15:53.480
But you're right.

00:15:53.480 --> 00:15:56.040
When I think about APIs that I've created,

00:15:56.040 --> 00:16:00.440
sometimes I've had other versions, right?

00:16:00.440 --> 00:16:05.440
One of the main areas is in the apps that we have,

00:16:05.440 --> 00:16:08.720
over, is that the URL work?

00:16:08.720 --> 00:16:09.560
It does.

00:16:09.560 --> 00:16:11.240
In the apps for consuming the courses, right?

00:16:11.240 --> 00:16:16.200
We had two completely different versions of the app.

00:16:16.200 --> 00:16:19.240
One got completely rewrote it.

00:16:19.240 --> 00:16:22.520
And many of the API endpoints were just fine.

00:16:22.520 --> 00:16:24.680
We could just use them over,

00:16:24.680 --> 00:16:25.800
and it didn't have to change anything,

00:16:25.800 --> 00:16:27.680
but three or four were like,

00:16:27.680 --> 00:16:31.080
you know, this really would be better if it was different.

00:16:31.080 --> 00:16:35.680
And so added like a slash V2 or something in there, right?

00:16:35.680 --> 00:16:37.240
But really, really limited.

00:16:37.240 --> 00:16:38.760
So the thing that's interesting though

00:16:38.760 --> 00:16:40.600
that you point out here is like,

00:16:40.600 --> 00:16:44.960
until that happened, I'd shipped many, many versions

00:16:44.960 --> 00:16:47.560
of that API, and long as the schema didn't change,

00:16:47.560 --> 00:16:51.680
I didn't bother even specifying that it had a version, right?

00:16:51.680 --> 00:16:55.720
It was just like slash course, my courses

00:16:55.720 --> 00:16:56.600
or whatever it is, right?

00:16:56.600 --> 00:16:57.920
Like just give those to me.

00:16:57.920 --> 00:17:00.760
And long as it kept giving the courses back, it was good.

00:17:00.760 --> 00:17:02.760
- Exactly.

00:17:02.760 --> 00:17:04.280
And that's the thing.

00:17:04.280 --> 00:17:07.880
As long as you extend stuff, it's going to be fine.

00:17:07.880 --> 00:17:10.080
But as you mentioned in the beginning,

00:17:10.080 --> 00:17:12.720
you can't really do that forever.

00:17:12.720 --> 00:17:16.760
At some point you're going to make wrong design decisions.

00:17:16.760 --> 00:17:19.720
At some point, even if you did everything perfectly,

00:17:19.720 --> 00:17:22.800
your product is just going to evolve.

00:17:22.800 --> 00:17:23.640
It's just going to evolve.

00:17:23.640 --> 00:17:26.960
And then you'll need to use old endpoints that alter

00:17:26.960 --> 00:17:31.960
or get old data and extend them in some breaking ways.

00:17:31.960 --> 00:17:34.120
Of course, there are ways around it.

00:17:34.120 --> 00:17:35.980
You can use API evolution.

00:17:35.980 --> 00:17:38.740
You can just add fields constantly

00:17:38.740 --> 00:17:40.800
and duplicate the old functionality.

00:17:40.800 --> 00:17:45.480
But after a few such versions, your API will look terrible.

00:17:45.480 --> 00:17:46.320
- Yeah.

00:17:46.320 --> 00:17:47.920
- Which is why we use versioning.

00:17:47.920 --> 00:17:52.440
And which is why when your company's main product is an API

00:17:52.440 --> 00:17:54.720
when you are an API first company,

00:17:54.720 --> 00:17:57.980
you can't do anything without versioning.

00:17:57.980 --> 00:18:00.620
You can live for a short period of time.

00:18:00.620 --> 00:18:02.560
For example, a pre-series A company,

00:18:02.560 --> 00:18:06.240
I don't think should deal with versioning.

00:18:06.240 --> 00:18:09.680
But then after series A, after you gather, I don't know,

00:18:09.680 --> 00:18:13.200
15, 20 clients, it will be really hard

00:18:13.200 --> 00:18:15.520
to survive without versioning.

00:18:15.520 --> 00:18:19.040
- Yeah, and it's a really quick and easy way

00:18:19.040 --> 00:18:21.760
to make loyal customers angry

00:18:21.760 --> 00:18:25.960
by making changes to your API that just start breaking code.

00:18:25.960 --> 00:18:28.480
I remember.

00:18:28.480 --> 00:18:30.280
Yeah, go ahead.

00:18:30.280 --> 00:18:36.240
- And even if you wait for your clients,

00:18:36.240 --> 00:18:39.800
even if you warn them, it's still not nice

00:18:39.800 --> 00:18:41.800
when you're trying to use some API

00:18:41.800 --> 00:18:45.560
and then every three months or every month,

00:18:45.560 --> 00:18:46.760
it breaks everything.

00:18:46.760 --> 00:18:48.120
You don't do that. - Yeah, exactly.

00:18:48.120 --> 00:18:48.960
- Even with a--

00:18:48.960 --> 00:18:51.000
- You put in all the work to do the integration.

00:18:51.000 --> 00:18:53.000
You got it working, you tested it.

00:18:53.000 --> 00:18:56.320
Your job is, your product is not the integration.

00:18:56.320 --> 00:18:58.720
The integration facilitates what you're trying to build.

00:18:58.720 --> 00:19:01.080
And every time you gotta go back and rewrite that stuff,

00:19:01.080 --> 00:19:03.120
it's not great.

00:19:03.120 --> 00:19:07.400
I was working, I have MailChimp for our newsletter

00:19:07.400 --> 00:19:09.760
marketing side of stuff, the courses,

00:19:09.760 --> 00:19:12.280
and I've been using them for a long time.

00:19:12.280 --> 00:19:13.200
And I got a message like,

00:19:13.200 --> 00:19:17.120
hey, we're retiring this API you're using.

00:19:17.120 --> 00:19:20.000
And their API is dreadful.

00:19:20.000 --> 00:19:22.920
Like their Python library API is dreadful.

00:19:22.920 --> 00:19:26.440
It's like star args, star star KW args.

00:19:26.440 --> 00:19:27.760
You better pass the right things,

00:19:27.760 --> 00:19:30.560
but there's no enforcement or instruction

00:19:30.560 --> 00:19:31.880
about what goes in there, right?

00:19:31.880 --> 00:19:34.080
And so some random dictionary that was going in there

00:19:34.080 --> 00:19:37.120
was no longer right and had to be like recreated.

00:19:37.120 --> 00:19:39.560
So they just decided,

00:19:39.560 --> 00:19:40.760
we're gonna just take different stuff

00:19:40.760 --> 00:19:42.760
and we're just gonna shut down that endpoint.

00:19:42.760 --> 00:19:47.440
And when they did, all of the aspects of my website

00:19:47.440 --> 00:19:48.440
just started breaking.

00:19:48.440 --> 00:19:50.920
Like it wasn't crashing, but just anything around,

00:19:50.920 --> 00:19:52.240
hey, put me on your newsletter.

00:19:52.240 --> 00:19:53.800
Like, nope, you couldn't be on the newsletter.

00:19:53.800 --> 00:19:56.200
'Cause people started sending me message,

00:19:56.200 --> 00:19:58.320
Michael, I'm trying to sign up to be on the newsletter,

00:19:58.320 --> 00:20:01.680
but it just keeps saying that something went wrong

00:20:01.680 --> 00:20:02.800
with our site, we're sorry.

00:20:02.800 --> 00:20:05.160
I'm like, oh boy, go look.

00:20:05.160 --> 00:20:07.100
And they just turned off that endpoint.

00:20:07.100 --> 00:20:09.840
And it was just like, nope, not doing that anymore.

00:20:09.840 --> 00:20:11.760
And it was super frustrating.

00:20:11.760 --> 00:20:15.160
It took me eight hours to rewrite it.

00:20:15.160 --> 00:20:18.960
Because like I said, there was no real guidance on like,

00:20:18.960 --> 00:20:20.160
oh, you just pass the dictionary.

00:20:20.160 --> 00:20:22.520
Like, well, what goes in the dictionary?

00:20:22.520 --> 00:20:25.360
You know, it was like some word of one of the keys chain.

00:20:25.360 --> 00:20:26.720
I was so, it just took forever.

00:20:26.720 --> 00:20:27.840
It was frustrating.

00:20:27.840 --> 00:20:30.480
So what we're gonna talk about here

00:20:30.480 --> 00:20:33.360
is a lot about how does that,

00:20:33.360 --> 00:20:36.640
how do you not do, how do you not pull a MailChimp?

00:20:36.640 --> 00:20:39.780
How do you set it up so that your code keeps running?

00:20:39.780 --> 00:20:42.460
And you know, the reason why they did that is they're like,

00:20:42.460 --> 00:20:44.620
well, we feel like we wrote it wrong before.

00:20:44.620 --> 00:20:47.320
We wanna fix those to make it better,

00:20:47.320 --> 00:20:51.340
but we don't wanna maintain two versions, right?

00:20:51.340 --> 00:20:54.220
That's probably the heart of it.

00:20:54.220 --> 00:20:58.720
It is until you have half a million users of the old API.

00:20:58.720 --> 00:21:02.400
And how many of those, like, so for me,

00:21:02.400 --> 00:21:03.460
yeah, I was frustrated.

00:21:03.460 --> 00:21:04.380
Yeah, I'm like, all right, well,

00:21:04.380 --> 00:21:06.460
I had plans today for constructive work,

00:21:06.460 --> 00:21:09.340
I'm gonna go rewrite what I did four years ago,

00:21:09.340 --> 00:21:11.000
and then I'll do something again tomorrow.

00:21:11.000 --> 00:21:13.500
But okay, that's like a pretty good outcome.

00:21:13.500 --> 00:21:17.580
A more common outcome is probably,

00:21:17.580 --> 00:21:20.080
I hired a consultant to build me an app

00:21:20.080 --> 00:21:23.320
and integrate MailChimp, and they're gone.

00:21:23.320 --> 00:21:26.760
And now my thing that I built a year ago doesn't even work,

00:21:26.760 --> 00:21:29.140
and I don't have the skills.

00:21:29.140 --> 00:21:30.760
I gotta go hire somebody again

00:21:30.760 --> 00:21:32.580
to dig back in there and fix it, right?

00:21:32.580 --> 00:21:34.500
Like that would be really frustrating.

00:21:36.220 --> 00:21:37.060
- Yeah, that's crazy.

00:21:37.060 --> 00:21:40.100
And it could be devastating to some clients,

00:21:40.100 --> 00:21:42.180
especially if the changes are huge,

00:21:42.180 --> 00:21:43.980
especially if it's not just a single endpoint,

00:21:43.980 --> 00:21:47.160
or if there is only one endpoint,

00:21:47.160 --> 00:21:51.740
and it does a lot of things, then, oh my God, it's scary.

00:21:51.740 --> 00:21:53.300
- It is, it is.

00:21:53.300 --> 00:21:56.220
Before we move on to maybe some of the approaches,

00:21:56.220 --> 00:21:59.540
Alexi out in the audience says,

00:21:59.540 --> 00:22:02.220
"One more law, Hirem's law is also great.

00:22:02.220 --> 00:22:04.440
"With sufficient number of users of an API,

00:22:04.440 --> 00:22:07.840
"it does not matter what you promise in the contract.

00:22:07.840 --> 00:22:09.980
"All observable behaviors of your system

00:22:09.980 --> 00:22:12.180
"will be depended on by somebody."

00:22:12.180 --> 00:22:16.940
- It is one of my favorite laws about any system.

00:22:16.940 --> 00:22:19.300
- That's true. - Yeah, that is very true.

00:22:19.300 --> 00:22:21.100
And it's a scary law, you know,

00:22:21.100 --> 00:22:24.340
because at some point you'll have to version everything,

00:22:24.340 --> 00:22:29.020
which is why it's a good idea to make things,

00:22:30.180 --> 00:22:34.560
I guess, to describe all the behaviors

00:22:34.560 --> 00:22:39.360
and to try to handle all of the possible behaviors thoroughly

00:22:39.360 --> 00:22:42.880
so that you know what is going to become a part of it,

00:22:42.880 --> 00:22:45.640
because at some point you'll just not be able to stop it,

00:22:45.640 --> 00:22:49.920
and then you break something that was never intended to work

00:22:49.920 --> 00:22:51.520
and then 100 of your users are like,

00:22:51.520 --> 00:22:53.560
"Oh, we weren't using that.

00:22:53.560 --> 00:22:55.880
"It wasn't a bug, it was a feature for us."

00:22:55.880 --> 00:22:58.520
- Yeah, we needed that.

00:22:58.520 --> 00:23:01.380
We found that's the only way we could use it, yeah, for sure.

00:23:01.380 --> 00:23:03.460
All right, let's talk about some of the techniques.

00:23:03.460 --> 00:23:05.540
You've put together a nice thing here,

00:23:05.540 --> 00:23:08.580
like how to maintain hundreds of API versions and survive.

00:23:08.580 --> 00:23:12.760
What are some of the ways in which people version APIs?

00:23:12.760 --> 00:23:19.380
- So, first of all, it's really hard to really figure out

00:23:19.380 --> 00:23:24.820
how people do this and how to do it,

00:23:24.820 --> 00:23:28.100
because 90% of the time when you're going to be researching

00:23:28.100 --> 00:23:31.460
API versioning, what you're going to see is people

00:23:31.460 --> 00:23:34.500
having tough decisions between putting it into a header

00:23:34.500 --> 00:23:36.140
or putting it into a path.

00:23:36.140 --> 00:23:38.980
But then when you ask, "Well, how do you version?"

00:23:38.980 --> 00:23:40.640
Nobody really has an answer.

00:23:40.640 --> 00:23:43.080
Well, there are a few ways.

00:23:43.080 --> 00:23:47.220
First of all, you can go from the lowest level

00:23:47.220 --> 00:23:49.800
and version everything, including your database.

00:23:49.800 --> 00:23:53.380
You just make a separate copy of your app,

00:23:53.380 --> 00:23:55.140
you can host it on a separate server,

00:23:55.140 --> 00:23:57.680
even a separate Kubernetes namespace,

00:23:57.680 --> 00:23:58.860
and forget about it.

00:23:58.860 --> 00:24:01.560
And you have two completely separate apps,

00:24:01.560 --> 00:24:05.500
and now you need to have double the people

00:24:05.500 --> 00:24:10.040
for the maintenance, or at least a smaller separate team

00:24:10.040 --> 00:24:11.600
to maintain the second product.

00:24:11.600 --> 00:24:15.280
This approach is really nice if you have a product

00:24:15.280 --> 00:24:16.260
that cannot break.

00:24:16.260 --> 00:24:21.180
There needs to be zero possibility of that breaking.

00:24:21.180 --> 00:24:24.380
If you are on a nuclear power plant,

00:24:24.380 --> 00:24:25.580
you'll probably do that.

00:24:26.320 --> 00:24:31.320
You can't have the old one broken and the new one working.

00:24:31.320 --> 00:24:35.520
But it's the most expensive approach, obviously.

00:24:35.520 --> 00:24:38.360
You can, however, limit that.

00:24:38.360 --> 00:24:41.640
You can start versioning just the application,

00:24:41.640 --> 00:24:42.640
but not the database.

00:24:42.640 --> 00:24:45.480
Okay, now we have the same thing,

00:24:45.480 --> 00:24:47.560
a separate branch in our code, a separate,

00:24:47.560 --> 00:24:50.000
not in our code, in our repository,

00:24:50.000 --> 00:24:53.640
a separate Kubernetes namespace, whatever.

00:24:53.640 --> 00:24:56.220
But now it's still expensive.

00:24:56.220 --> 00:24:57.860
It's still a whole separate copy

00:24:57.860 --> 00:24:59.100
of everything you have built,

00:24:59.100 --> 00:25:02.120
and now you have to make sure that the new one

00:25:02.120 --> 00:25:04.220
or the old one doesn't break the database

00:25:04.220 --> 00:25:06.540
because the database might have changed,

00:25:06.540 --> 00:25:09.700
but one of the versions of code might not know about that.

00:25:09.700 --> 00:25:13.700
And then you realize that you go higher.

00:25:13.700 --> 00:25:18.260
- Yeah, the database aspect of it sounds especially tricky,

00:25:18.260 --> 00:25:19.920
especially a relational database

00:25:19.920 --> 00:25:21.940
with super strong schemas.

00:25:21.940 --> 00:25:24.880
Like, you know what, that used to be a VAR char,

00:25:24.880 --> 00:25:27.840
and now it's an int, and so, nope.

00:25:27.840 --> 00:25:29.880
It's just not gonna work, right?

00:25:29.880 --> 00:25:31.880
There's really little flexibility.

00:25:31.880 --> 00:25:34.960
So even if you run the two things in parallel,

00:25:34.960 --> 00:25:37.720
then you almost have to have two databases,

00:25:37.720 --> 00:25:40.000
and then like a mil points out,

00:25:40.000 --> 00:25:41.840
and then you have to sync the databases,

00:25:41.840 --> 00:25:44.140
and it's non-trivial.

00:25:44.140 --> 00:25:46.240
- Oh, yes.

00:25:46.240 --> 00:25:49.240
And then you start realizing, okay,

00:25:49.300 --> 00:25:52.140
why do I need a separate branch and a separate namespace?

00:25:52.140 --> 00:25:55.340
Let's just keep them within the same app,

00:25:55.340 --> 00:25:59.220
because as long as you have separate paths for this,

00:25:59.220 --> 00:26:01.600
even you can build separate swaggers from them,

00:26:01.600 --> 00:26:05.380
you can have them within the same branch,

00:26:05.380 --> 00:26:07.880
within the same repository, just in different directories,

00:26:07.880 --> 00:26:10.060
and you can just copy all of your code.

00:26:10.060 --> 00:26:13.180
And now I call that versioning by suffering

00:26:13.180 --> 00:26:16.620
because you think, oh, I'm going to version less this time.

00:26:16.620 --> 00:26:18.400
You know, now I'm not versioning the database.

00:26:18.400 --> 00:26:19.620
Now it's not a separate branch.

00:26:19.620 --> 00:26:23.940
It's gonna be much easier to, I don't know,

00:26:23.940 --> 00:26:26.220
make fixes in both places.

00:26:26.220 --> 00:26:30.020
But now you have to support both of the code bases.

00:26:30.020 --> 00:26:31.700
And once you update anything,

00:26:31.700 --> 00:26:33.400
any of the related resources,

00:26:33.400 --> 00:26:35.060
for example, the database models,

00:26:35.060 --> 00:26:36.380
you have to update them twice.

00:26:36.380 --> 00:26:38.060
If you update any of the dependencies,

00:26:38.060 --> 00:26:39.700
you have to update them twice.

00:26:39.700 --> 00:26:42.080
And that can get painful.

00:26:42.080 --> 00:26:43.400
And after a while,

00:26:43.400 --> 00:26:45.920
if you have more than two of these versions,

00:26:45.920 --> 00:26:47.060
you're going to be asking yourself,

00:26:47.060 --> 00:26:51.060
okay, what is the difference between these versions?

00:26:51.060 --> 00:26:52.300
And if you weren't careful

00:26:52.300 --> 00:26:54.100
with documentation and code review,

00:26:54.100 --> 00:26:56.600
oh, you're in for a treat.

00:26:56.600 --> 00:26:57.440
- Yeah.

00:26:57.440 --> 00:26:58.820
- But that's just the beginning.

00:26:58.820 --> 00:27:01.620
You can version much less.

00:27:01.620 --> 00:27:04.020
Now, instead of the whole directories,

00:27:04.020 --> 00:27:06.080
you can version just separate endpoints.

00:27:06.080 --> 00:27:09.880
And I think that's the way that I recommend for everyone.

00:27:09.880 --> 00:27:11.740
Everyone who is doing API versioning,

00:27:11.740 --> 00:27:14.020
who wants to be with the cool kids,

00:27:14.020 --> 00:27:16.100
I recommend this approach.

00:27:16.100 --> 00:27:19.420
As long as you are a small company or an individual

00:27:19.420 --> 00:27:22.500
and you want something really simple, that's a good way.

00:27:22.500 --> 00:27:25.060
You just copy a single endpoint that you have changed,

00:27:25.060 --> 00:27:27.220
create another schema for that,

00:27:27.220 --> 00:27:30.060
and then create another branch in your business logic,

00:27:30.060 --> 00:27:31.940
or maybe even no branch.

00:27:31.940 --> 00:27:35.340
That's even better, using the same business logic.

00:27:35.340 --> 00:27:37.580
But then at some point,

00:27:37.580 --> 00:27:39.460
once you want to support many versions

00:27:39.460 --> 00:27:43.500
or your versions become too different,

00:27:43.500 --> 00:27:45.140
that's where you get a problem.

00:27:45.140 --> 00:27:47.420
Because now all of a sudden you have all of these,

00:27:47.420 --> 00:27:49.660
oh, I have this endpoint in this version,

00:27:49.660 --> 00:27:50.860
that endpoint in that version.

00:27:50.860 --> 00:27:52.700
Oh, it's gonna be bad.

00:27:52.700 --> 00:27:53.540
- Yeah. - Really bad.

00:27:53.540 --> 00:27:54.360
- Yeah, yeah.

00:27:54.360 --> 00:27:55.940
We've been talking like there's the old version

00:27:55.940 --> 00:27:57.900
and the new version, but in practice,

00:27:57.900 --> 00:28:01.060
somebody starts to depend on the new version

00:28:01.060 --> 00:28:03.460
and then you evolve the new version and it just,

00:28:03.460 --> 00:28:07.860
it combinatorially explodes and it's out of control, yeah.

00:28:07.860 --> 00:28:10.100
- Precisely.

00:28:10.100 --> 00:28:12.540
So it's gonna be really bad for your developers.

00:28:12.540 --> 00:28:14.380
Your clients are going to be fine with it.

00:28:14.380 --> 00:28:15.740
Your developers are going to hate you,

00:28:15.740 --> 00:28:18.820
although not as bad as with the previous approach.

00:28:18.820 --> 00:28:24.060
Now, the next one you get to is you start thinking,

00:28:24.060 --> 00:28:28.220
okay, what if instead of duplicating all of that stuff,

00:28:28.220 --> 00:28:33.000
I am just going to change the schemas?

00:28:33.000 --> 00:28:35.100
So, okay, if I do need to rename my endpoint,

00:28:35.100 --> 00:28:36.340
I am going to duplicate it.

00:28:36.340 --> 00:28:37.700
But most of the time you're not.

00:28:37.700 --> 00:28:39.540
Most of the time you're just changing some field

00:28:39.540 --> 00:28:41.260
in some schema, you're renaming it,

00:28:41.260 --> 00:28:43.260
you're extending it, changing its type,

00:28:43.260 --> 00:28:44.140
stuff like that.

00:28:44.140 --> 00:28:46.420
That's like 90% of your use cases.

00:28:46.420 --> 00:28:48.540
Okay, what if we just change the schemas

00:28:48.540 --> 00:28:50.340
and then have some serializers?

00:28:50.340 --> 00:28:52.940
For example, Django,

00:28:52.940 --> 00:28:56.580
Django DRF loves that.

00:28:56.580 --> 00:28:59.500
They love the serializers and reserializers

00:28:59.500 --> 00:29:01.660
and you can just have a, each,

00:29:01.660 --> 00:29:04.100
we have five versions and version one serializes

00:29:04.100 --> 00:29:07.940
into version five, two serializes into version five,

00:29:07.940 --> 00:29:09.460
yada, yada, yada.

00:29:09.460 --> 00:29:12.460
And so our client sends us a request,

00:29:12.460 --> 00:29:14.620
we reserialize it into the correct version,

00:29:14.620 --> 00:29:17.460
then we return a response, we use the same business logic,

00:29:17.460 --> 00:29:20.220
and then we serialize it back into each version.

00:29:20.220 --> 00:29:24.020
Great, now we have solved all the problems

00:29:24.020 --> 00:29:25.460
of the previous approaches.

00:29:25.460 --> 00:29:28.660
Now, you need to realize that

00:29:28.660 --> 00:29:30.780
when you're doing something like this,

00:29:30.780 --> 00:29:33.580
you are in a little bit of danger

00:29:33.580 --> 00:29:36.860
of creating bugs in the new versions

00:29:36.860 --> 00:29:39.580
and these bugs cascading to the old versions,

00:29:40.460 --> 00:29:43.460
which hopefully you have tests to handle that.

00:29:43.460 --> 00:29:45.900
But at least your clients are happy

00:29:45.900 --> 00:29:48.700
because you can support versions for a long time

00:29:48.700 --> 00:29:50.580
and your developers are happy

00:29:50.580 --> 00:29:54.200
because the burden of support is now on the serializers,

00:29:54.200 --> 00:29:56.580
but you still have to support these serializers.

00:29:56.580 --> 00:29:57.660
It's still a lot of stuff.

00:29:57.660 --> 00:30:00.980
You still have to put every field in there

00:30:00.980 --> 00:30:05.180
and take care of any problems that happen.

00:30:05.180 --> 00:30:07.420
And each new version will change

00:30:07.420 --> 00:30:09.900
basically all of your serializers.

00:30:09.900 --> 00:30:11.820
A little bit, yes, but you won't be able

00:30:11.820 --> 00:30:13.180
to support 20 versions like that.

00:30:13.180 --> 00:30:14.340
It's going to be crazy.

00:30:14.340 --> 00:30:20.820
And now that's where we get to the final approaches,

00:30:20.820 --> 00:30:22.860
the approaches that I guess

00:30:22.860 --> 00:30:24.860
the most sophisticated in the industry.

00:30:24.860 --> 00:30:28.020
If you are making a backend for frontend,

00:30:28.020 --> 00:30:30.620
for your own frontend, then you can just use GraphQL.

00:30:30.620 --> 00:30:32.860
GraphQL basically requires no versioning,

00:30:32.860 --> 00:30:35.820
and that's one of the benefits of it.

00:30:36.900 --> 00:30:39.420
I would recommend that if you have developers

00:30:39.420 --> 00:30:42.420
that are good with GraphQL, that's great.

00:30:42.420 --> 00:30:44.820
You can omit versioning altogether.

00:30:44.820 --> 00:30:47.220
But if you're not, if it's a public API,

00:30:47.220 --> 00:30:51.360
then that's where Stripe's approach comes.

00:30:51.360 --> 00:30:52.780
I think they were the first ones

00:30:52.780 --> 00:30:55.860
to publish an article about that.

00:30:55.860 --> 00:30:58.280
It was Brander Leach, the author of this article.

00:30:58.280 --> 00:31:01.940
He has supported API versioning at Stripe for a while,

00:31:01.940 --> 00:31:06.780
and he has helped us with building our backend.

00:31:06.900 --> 00:31:08.820
API versioning approach.

00:31:08.820 --> 00:31:11.300
Essentially what Stripe did is said,

00:31:11.300 --> 00:31:13.820
okay, let's imagine that our developers

00:31:13.820 --> 00:31:15.900
are only supporting one version, the latest one,

00:31:15.900 --> 00:31:18.620
just like with serializers.

00:31:18.620 --> 00:31:22.180
But instead of serializing every version to the latest one,

00:31:22.180 --> 00:31:25.780
let's say that each version knows how to serialize

00:31:25.780 --> 00:31:27.120
into the next version.

00:31:27.120 --> 00:31:28.980
So let's say that-

00:31:28.980 --> 00:31:31.460
- Kind of like database migrations.

00:31:31.460 --> 00:31:32.300
- Exactly.

00:31:32.300 --> 00:31:37.300
So let's say that I return response from the latest version.

00:31:37.300 --> 00:31:41.940
This response, or at least they call them,

00:31:41.940 --> 00:31:44.140
I think, version gates.

00:31:44.140 --> 00:31:47.340
These version gates, the version gate for fifth version

00:31:47.340 --> 00:31:49.900
knows how to convert back my response back

00:31:49.900 --> 00:31:51.460
into the fourth version.

00:31:51.460 --> 00:31:53.520
The version gate for the fourth version

00:31:53.520 --> 00:31:56.380
knows how to convert it back into the third version.

00:31:56.380 --> 00:32:00.940
And all of a sudden you get simple version gates

00:32:00.940 --> 00:32:03.940
because if it's just field renaming in a single version,

00:32:03.940 --> 00:32:05.180
then it's just a single line.

00:32:05.180 --> 00:32:06.320
They're really simple.

00:32:06.320 --> 00:32:10.420
But at the same time, they're immutable

00:32:10.420 --> 00:32:11.580
because these version gates,

00:32:11.580 --> 00:32:13.480
they're not describing the whole schema.

00:32:13.480 --> 00:32:16.680
They're describing the difference between two versions.

00:32:16.680 --> 00:32:18.940
And because we know that we don't wanna

00:32:18.940 --> 00:32:20.620
change the old version,

00:32:20.620 --> 00:32:23.720
we want the old version to work,

00:32:23.720 --> 00:32:26.060
which is why the difference between version two

00:32:26.060 --> 00:32:27.780
and version three is going to stay.

00:32:27.780 --> 00:32:29.220
It's not going to change,

00:32:29.220 --> 00:32:31.740
which is why these converters are also immutable,

00:32:31.740 --> 00:32:35.060
which means that you don't need to spend much time

00:32:35.060 --> 00:32:35.920
supporting them.

00:32:35.920 --> 00:32:39.600
>>Right, once you get, if you're on version three

00:32:39.600 --> 00:32:42.340
and you get the transition from one to two set,

00:32:42.340 --> 00:32:44.700
like that's not gonna change ever, right?

00:32:44.700 --> 00:32:46.660
>>Exactly, precisely.

00:32:46.660 --> 00:32:49.620
Well, at some point you need it for optimizations

00:32:49.620 --> 00:32:52.020
or for returning extra data,

00:32:52.020 --> 00:32:55.780
but it's such a rare use case that I haven't seen it so far.

00:32:55.780 --> 00:32:58.740
And I hope that I won't.

00:32:58.740 --> 00:33:01.580
>>Yeah, so this is Stripe's approach.

00:33:01.580 --> 00:33:03.420
And one of the things that's really interesting

00:33:03.420 --> 00:33:05.820
that Stripe does and is laid out in this article

00:33:05.820 --> 00:33:08.920
that you're pretty stable here is,

00:33:08.920 --> 00:33:13.540
they also implicitly assign you a version

00:33:13.540 --> 00:33:15.380
when you first make a call,

00:33:15.380 --> 00:33:17.180
which was really interesting.

00:33:17.180 --> 00:33:19.880
And I use Stripe and I didn't realize

00:33:19.880 --> 00:33:22.220
that when I've made calls into Stripe

00:33:22.220 --> 00:33:24.460
that the first time you make a call,

00:33:24.460 --> 00:33:27.400
it pins you somewhere like on your user account

00:33:27.400 --> 00:33:30.180
on their side, pins you to that version of the API.

00:33:30.180 --> 00:33:32.140
And you never know you're on a different,

00:33:32.140 --> 00:33:34.000
you're on a particular version,

00:33:34.000 --> 00:33:36.460
but they keep you on that version.

00:33:36.460 --> 00:33:37.300
That's wild.

00:33:37.300 --> 00:33:38.120
>>That's great.

00:33:38.120 --> 00:33:41.900
Imagine you log in into Stripe, you make a call,

00:33:41.900 --> 00:33:44.900
and then every time you open a documentation

00:33:44.900 --> 00:33:47.220
in your account, you're going to see your version.

00:33:47.220 --> 00:33:48.060
Every time you make a call,

00:33:48.060 --> 00:33:50.740
you're going to get response from your version.

00:33:50.740 --> 00:33:54.060
And then because they keep versions for years,

00:33:54.060 --> 00:33:57.180
for example, we are using, I think,

00:33:57.180 --> 00:34:00.540
three or four year old version of Stripe's API,

00:34:00.540 --> 00:34:01.620
and they still keep it.

00:34:01.620 --> 00:34:04.860
According to this article, they keep all of their versions,

00:34:04.860 --> 00:34:06.900
all since the company's beginning.

00:34:06.900 --> 00:34:09.540
I'm not sure how old that is.

00:34:09.540 --> 00:34:13.820
Yeah, but still, they keep years worth of versions.

00:34:13.820 --> 00:34:16.360
That is very true.

00:34:16.360 --> 00:34:17.980
>>Now, you might see that as a negative.

00:34:17.980 --> 00:34:20.260
Like you might think, well, I'm pinned to this version.

00:34:20.260 --> 00:34:22.140
Like how do I escape the old version

00:34:22.140 --> 00:34:23.540
if I want the new version?

00:34:23.540 --> 00:34:25.300
But you can pass it in a header,

00:34:25.300 --> 00:34:27.060
or there's other ways to say,

00:34:27.060 --> 00:34:29.220
I explicitly choose something else.

00:34:29.220 --> 00:34:32.260
But by default, you're just, you're living in the past.

00:34:32.260 --> 00:34:35.220
>>Yeah, and that's really cool.

00:34:35.220 --> 00:34:36.800
You integrate, and then you live in the past

00:34:36.800 --> 00:34:37.740
for as long as you want.

00:34:37.740 --> 00:34:42.420
The thing is, yes, you can change it using a header.

00:34:42.420 --> 00:34:44.980
Monite has a similar structure.

00:34:44.980 --> 00:34:51.220
You can also change it in your partner's portal,

00:34:51.400 --> 00:34:54.880
and you can also, or I guess developer's portal,

00:34:54.880 --> 00:34:56.560
and you can also specify, for example,

00:34:56.560 --> 00:34:58.480
if you receive webhooks from Stripe,

00:34:58.480 --> 00:35:01.240
you can specify, okay, I want this webhook of this version

00:35:01.240 --> 00:35:02.940
and that webhook of that version.

00:35:02.940 --> 00:35:05.160
>>That's cool.

00:35:05.160 --> 00:35:08.560
>>And it's a really neat interface

00:35:08.560 --> 00:35:10.560
that if you don't want to think about versioning,

00:35:10.560 --> 00:35:12.360
you don't, you forget about it.

00:35:12.360 --> 00:35:14.000
But the second you want to,

00:35:14.000 --> 00:35:16.380
the second you want to have the latest API,

00:35:16.380 --> 00:35:20.560
they give you all the tools to work with it nicely.

00:35:20.560 --> 00:35:21.380
And that's the thing.

00:35:21.380 --> 00:35:26.380
This approach allows you to keep years worth of versions,

00:35:26.380 --> 00:35:29.540
or maybe even decades worth of versions, actually,

00:35:29.540 --> 00:35:33.400
without your developers getting overburdened,

00:35:33.400 --> 00:35:35.240
because there is still a single version

00:35:35.240 --> 00:35:36.280
of the business logic.

00:35:36.280 --> 00:35:37.920
They work on a single version of Schemas,

00:35:37.920 --> 00:35:39.520
and they just need to make sure

00:35:39.520 --> 00:35:41.480
that when they release a new version,

00:35:41.480 --> 00:35:43.720
they write a converter for it.

00:35:43.720 --> 00:35:45.040
And your clients are also happy

00:35:45.040 --> 00:35:47.520
because they never need to switch.

00:35:47.520 --> 00:35:49.000
>>Yeah, it sounds really nice.

00:35:49.000 --> 00:35:53.660
I suspect there's not a complete ability

00:35:53.660 --> 00:35:56.300
to just ignore the old versions,

00:35:56.300 --> 00:35:59.740
because maybe you want, in your new version,

00:35:59.740 --> 00:36:02.020
you're going to imagine this piece of data

00:36:02.020 --> 00:36:02.940
doesn't even exist,

00:36:02.940 --> 00:36:04.580
and we're going to remove it from the database.

00:36:04.580 --> 00:36:06.820
But if it needs to be there for the old ones,

00:36:06.820 --> 00:36:09.380
there's probably some level of,

00:36:09.380 --> 00:36:10.700
you're constrained a little bit,

00:36:10.700 --> 00:36:12.360
but it sounds a lot better still.

00:36:12.360 --> 00:36:16.340
>>Yeah, you're still constrained,

00:36:16.340 --> 00:36:21.340
but remember, API versioning, if we translate it,

00:36:21.340 --> 00:36:24.360
application programming interface versioning,

00:36:24.360 --> 00:36:25.880
we're not versioning the app,

00:36:25.880 --> 00:36:28.200
we're versioning the interface to the app.

00:36:28.200 --> 00:36:29.520
>>Yeah, so a lot of times it's like,

00:36:29.520 --> 00:36:32.000
what fields are we passing or something, right?

00:36:32.000 --> 00:36:32.840
Yeah.

00:36:32.840 --> 00:36:37.200
>>Yeah, so if you are trying to change the data

00:36:37.200 --> 00:36:39.240
between versions, if the data is different,

00:36:39.240 --> 00:36:40.980
entirely different, I mean,

00:36:40.980 --> 00:36:43.840
then you're probably not doing API versioning.

00:36:43.840 --> 00:36:46.240
Then you probably should be calling it

00:36:46.240 --> 00:36:47.520
application versioning.

00:36:47.520 --> 00:36:52.520
And actually, Stripe has, I guess, a hack for that too.

00:36:52.520 --> 00:36:58.180
If you take a look at their API, they still have a V1,

00:36:58.180 --> 00:37:02.000
but that's the thing, they don't use this V1.

00:37:02.000 --> 00:37:04.720
They use date-based versioning that is in the headers

00:37:04.720 --> 00:37:06.580
and their settings.

00:37:06.580 --> 00:37:10.700
But the V1 is precisely for this situation.

00:37:10.700 --> 00:37:13.660
If someday they will need to have something else,

00:37:13.660 --> 00:37:16.920
if someday they will need to break everything

00:37:16.920 --> 00:37:21.700
and change the data required or any other crazy changes,

00:37:21.700 --> 00:37:24.700
they will be able to do it using that V1.

00:37:24.700 --> 00:37:28.260
>>Yeah, yeah, it's just there in case, exactly.

00:37:28.260 --> 00:37:29.100
>>Yep.

00:37:29.100 --> 00:37:31.020
So yeah.

00:37:31.020 --> 00:37:32.640
>>Cool, all right, well, let's talk about your project.

00:37:32.640 --> 00:37:33.560
Let's talk about your project

00:37:33.560 --> 00:37:35.240
that makes this possible in Python,

00:37:35.240 --> 00:37:37.740
because the Stripe examples,

00:37:37.740 --> 00:37:40.140
I believe this is Ruby that they all have here, right?

00:37:40.140 --> 00:37:41.020
Which--

00:37:41.020 --> 00:37:42.260
>>It is.

00:37:42.260 --> 00:37:45.740
It is really nice to read until you try to understand it,

00:37:45.740 --> 00:37:48.580
until you try to understand what it actually does.

00:37:48.580 --> 00:37:49.420
And it's crazy.

00:37:49.420 --> 00:37:51.780
>>I know, when I was reading this today, I was like,

00:37:51.780 --> 00:37:52.620
you know, I'm pretty glad

00:37:52.620 --> 00:37:54.260
that I'm not writing Ruby right now.

00:37:54.260 --> 00:37:56.900
Okay, all right, let's talk about Python though.

00:37:56.900 --> 00:38:00.500
You've got a project called CAD1

00:38:00.500 --> 00:38:03.780
that takes the Stripe philosophy

00:38:03.780 --> 00:38:06.460
and applies it to versioning

00:38:06.460 --> 00:38:11.460
for the most popular API framework for Python, FastAPI.

00:38:11.660 --> 00:38:12.500
>>FastAPI.

00:38:12.500 --> 00:38:14.480
Tell us about it.

00:38:14.480 --> 00:38:18.300
>>Yeah, so here's the thing.

00:38:18.300 --> 00:38:20.000
When I started developing it,

00:38:20.000 --> 00:38:22.620
we were using versioning by suffering.

00:38:22.620 --> 00:38:25.140
So we were using directory copies,

00:38:25.140 --> 00:38:28.820
and none of us really enjoyed it,

00:38:28.820 --> 00:38:32.180
so there needed to be a solution.

00:38:32.180 --> 00:38:34.980
And I went to Stripe, I went to other companies,

00:38:34.980 --> 00:38:35.880
I spoke with them,

00:38:35.880 --> 00:38:40.020
I tried to understand the nitty-gritty details.

00:38:40.020 --> 00:38:44.660
As I mentioned, Brander Leach extended us huge help

00:38:44.660 --> 00:38:47.820
when he, I guess, described how he thinks

00:38:47.820 --> 00:38:50.220
about API versioning right now.

00:38:50.220 --> 00:38:51.760
And I built it.

00:38:51.760 --> 00:38:54.160
The first version was just like Stripe.

00:38:54.160 --> 00:38:58.580
It was exactly what Stripe did, you know, to the letter.

00:38:58.580 --> 00:39:00.540
But then at some point,

00:39:00.540 --> 00:39:02.780
we started applying it at Monite,

00:39:02.780 --> 00:39:07.140
and I realized, wow, Stripe had a lot of legacy.

00:39:07.140 --> 00:39:08.780
So they didn't implement some things.

00:39:08.780 --> 00:39:10.380
For example, in Stripe's article,

00:39:10.380 --> 00:39:15.380
you can see that they're not using any schema validation,

00:39:15.380 --> 00:39:18.600
or at least, how do I describe it?

00:39:18.600 --> 00:39:23.600
Their business logic just receives a hash map, a dictionary.

00:39:23.600 --> 00:39:28.380
It's not statically typed.

00:39:28.380 --> 00:39:30.100
But FastAPI uses Pydantic,

00:39:30.100 --> 00:39:32.140
so it's a bit more complex than that.

00:39:32.140 --> 00:39:34.580
Okay, we added support for that.

00:39:34.580 --> 00:39:35.920
It's a bit more complex.

00:39:35.920 --> 00:39:38.340
It's a bit more, I guess, sophisticated now.

00:39:38.340 --> 00:39:40.700
But then I also realized that Stripe,

00:39:40.700 --> 00:39:43.140
they don't migrate requests.

00:39:43.140 --> 00:39:44.820
They only migrate responses.

00:39:44.820 --> 00:39:47.040
Because a migration of a request

00:39:47.040 --> 00:39:50.380
is usually not just a breaking change,

00:39:50.380 --> 00:39:52.520
it's a change in a business logic.

00:39:52.520 --> 00:39:53.700
Because when you return a response,

00:39:53.700 --> 00:39:55.020
you can just return the whole thing,

00:39:55.020 --> 00:39:57.340
and then, you know, just play around with it.

00:39:57.340 --> 00:40:00.260
But when you are changing the request,

00:40:00.260 --> 00:40:02.360
your business logic also needs to change.

00:40:02.360 --> 00:40:05.020
And that's what they did.

00:40:05.020 --> 00:40:07.440
You know, they have extra ifs and extra, you know,

00:40:07.440 --> 00:40:09.900
levels of business logic to handle that.

00:40:09.900 --> 00:40:11.620
Well, apparently, it's not necessary.

00:40:11.620 --> 00:40:14.580
Apparently, requests are also migratable.

00:40:14.580 --> 00:40:18.420
And that's the second feature

00:40:18.420 --> 00:40:22.100
that greatly distinguishes us from Stripe.

00:40:22.100 --> 00:40:25.940
This thing can statically, well, by statically,

00:40:25.940 --> 00:40:28.460
I mean, it co-generates your schema

00:40:28.460 --> 00:40:30.100
so that you can see everything

00:40:30.100 --> 00:40:35.540
before you run your app.

00:40:35.540 --> 00:40:38.960
This thing can migrate both requests and responses,

00:40:38.960 --> 00:40:41.000
and it supports everything that Stripe does.

00:40:41.000 --> 00:40:44.860
And we have pretty big plans for extending it.

00:40:44.860 --> 00:40:47.680
And as an added bonus,

00:40:47.680 --> 00:40:50.920
we also have a pretty big documentation.

00:40:50.920 --> 00:40:54.360
Well, not compared to Django or FastAPI.

00:40:54.360 --> 00:40:56.760
Django is, you know, older than me,

00:40:56.760 --> 00:41:01.760
and FastAPI is really amazing for,

00:41:01.760 --> 00:41:04.080
how do I describe it?

00:41:05.120 --> 00:41:07.520
It's pretty amazing in terms of its documentation.

00:41:07.520 --> 00:41:10.680
Sebastian Ramirez is an expert at making tutorials.

00:41:10.680 --> 00:41:13.960
And if you take a look at our reference documentation

00:41:13.960 --> 00:41:17.880
to the left and our, how do I describe it?

00:41:17.880 --> 00:41:19.780
Recipes documentation,

00:41:19.780 --> 00:41:24.780
they basically describe to you every single use case

00:41:24.780 --> 00:41:28.320
that you could have with API versioning.

00:41:28.320 --> 00:41:30.240
Every single, you know,

00:41:30.240 --> 00:41:32.840
every single problem that you could solve with it.

00:41:32.840 --> 00:41:37.840
And then we try to apply our approach to it.

00:41:37.840 --> 00:41:40.140
So it's not just the framework.

00:41:40.140 --> 00:41:43.000
It's all the ways you could use the framework.

00:41:43.000 --> 00:41:45.520
Someday, hopefully we will also extend it

00:41:45.520 --> 00:41:48.520
beyond FastAPI and Pydantic.

00:41:48.520 --> 00:41:52.120
And we also have sections for theory,

00:41:52.120 --> 00:41:54.720
for people who are not Pythonistas,

00:41:54.720 --> 00:41:57.140
who just wanna learn how to do API versioning,

00:41:57.140 --> 00:41:59.960
but failed to find any resources.

00:41:59.960 --> 00:42:01.920
So Kadwin also becomes this, I guess,

00:42:01.920 --> 00:42:05.480
hub for API versioning resources

00:42:05.480 --> 00:42:07.960
and anything related to them.

00:42:07.960 --> 00:42:08.800
- Sure.

00:42:08.800 --> 00:42:10.800
It seems like it would probably be pretty easy

00:42:10.800 --> 00:42:13.560
to adapt to anything that uses Pydantic

00:42:13.560 --> 00:42:14.880
for its data exchange.

00:42:14.880 --> 00:42:16.080
- Oh, yes.

00:42:16.080 --> 00:42:16.920
- Yeah.

00:42:16.920 --> 00:42:18.840
So like, for example, in Flask,

00:42:18.840 --> 00:42:22.140
Flask doesn't do the model binding type stuff

00:42:22.140 --> 00:42:23.000
on the endpoint,

00:42:23.000 --> 00:42:25.240
but you can just take the input data

00:42:25.240 --> 00:42:28.440
and just star star it into a Pydantic model.

00:42:28.440 --> 00:42:31.100
And then, you know, now you're in Pydantic world, right?

00:42:31.100 --> 00:42:34.000
So it sounds like maybe something along those lines

00:42:34.000 --> 00:42:35.600
might be a good bridge.

00:42:35.600 --> 00:42:38.520
- Oh, yes, it can be.

00:42:38.520 --> 00:42:41.200
Though there's a lot of magic involved

00:42:41.200 --> 00:42:43.840
in trying to interface with FastAPI

00:42:43.840 --> 00:42:47.560
simply due to its internal complexity.

00:42:47.560 --> 00:42:48.400
- Sure.

00:42:48.400 --> 00:42:49.220
- But yeah.

00:42:49.220 --> 00:42:50.080
- All right, so some good questions,

00:42:50.080 --> 00:42:53.360
but I think they'll be somewhat answered

00:42:53.360 --> 00:42:57.520
if we just maybe talk us through your tutorial here.

00:42:57.520 --> 00:42:59.760
Like, what is it?

00:42:59.760 --> 00:43:02.220
How do we use Kadwin and how does it manifest?

00:43:02.220 --> 00:43:03.380
How does it work at runtime?

00:43:03.380 --> 00:43:04.220
Stuff like that.

00:43:04.220 --> 00:43:08.940
- So first, before using Kadwin,

00:43:08.940 --> 00:43:10.500
you know, you write your regular app,

00:43:10.500 --> 00:43:13.860
but then you just structure it a little bit differently.

00:43:13.860 --> 00:43:15.980
When you are versioning,

00:43:15.980 --> 00:43:20.980
you need a directory that you will consider versioned.

00:43:20.980 --> 00:43:24.940
So, and this directory will be duplicated for every version.

00:43:24.940 --> 00:43:28.900
No worries, you're not going to support the version code.

00:43:28.900 --> 00:43:31.400
It's going to be code generation all the way through.

00:43:31.400 --> 00:43:33.640
And you can use it to generate connectors

00:43:33.640 --> 00:43:34.720
for your application,

00:43:34.720 --> 00:43:38.240
or you could use it to generate schemas or enums,

00:43:38.240 --> 00:43:40.240
you know, the different version of them

00:43:40.240 --> 00:43:42.760
and anything else related to them.

00:43:42.760 --> 00:43:44.240
So you pick such a directory,

00:43:44.240 --> 00:43:47.560
you call it latest as for your latest version.

00:43:47.560 --> 00:43:51.440
Then you define a single version bundle.

00:43:51.440 --> 00:43:54.580
If you go a little bit down,

00:43:54.580 --> 00:43:57.940
you will see somewhere in here after defining versions.

00:43:57.940 --> 00:44:01.080
Yes, we define our version bundle with a single version,

00:44:01.080 --> 00:44:03.720
whichever version it is for you,

00:44:03.720 --> 00:44:05.700
whichever date it is for you.

00:44:05.700 --> 00:44:09.920
And then you run code generation.

00:44:09.920 --> 00:44:13.980
It generates basically empty, how do I describe it?

00:44:13.980 --> 00:44:17.160
It generates a directory

00:44:17.160 --> 00:44:19.640
that simply imports from your latest,

00:44:19.640 --> 00:44:23.880
and that's where you can start doing the magic.

00:44:23.880 --> 00:44:27.620
Now you just use our versioned app.

00:44:27.620 --> 00:44:31.700
If you take a look, we have a versioned API router,

00:44:31.700 --> 00:44:34.300
then you use the Katherine versioned app,

00:44:34.300 --> 00:44:37.300
you generate versioned,

00:44:37.300 --> 00:44:40.540
versioned, versioned, versioned.

00:44:40.540 --> 00:44:43.180
You generate versioned routers,

00:44:43.180 --> 00:44:45.380
and then it's going to generate

00:44:45.380 --> 00:44:47.780
a really nice swagger for them.

00:44:47.780 --> 00:44:51.780
If you open it somewhere, I think, yep, this one.

00:44:51.780 --> 00:44:54.560
So now your dashboard, the one on docs,

00:44:54.560 --> 00:44:56.320
is not the swagger page,

00:44:56.320 --> 00:44:59.120
but the dashboard of all your versions.

00:44:59.120 --> 00:45:00.040
And that's it.

00:45:00.040 --> 00:45:04.640
After that, you can simply repeat the steps above.

00:45:04.640 --> 00:45:09.640
So you write a migration, write that converter

00:45:09.640 --> 00:45:12.960
that describes the difference between the versions.

00:45:12.960 --> 00:45:15.100
We have it somewhere there.

00:45:15.100 --> 00:45:17.240
Let's see, yep.

00:45:17.240 --> 00:45:19.400
For example, if we had an address as a string

00:45:19.400 --> 00:45:21.600
and we want to change it to a list,

00:45:21.600 --> 00:45:24.240
we say, okay, schema, base user.

00:45:24.240 --> 00:45:27.680
- So for people listening, you have a user object,

00:45:27.680 --> 00:45:29.100
which is a Pydantic model.

00:45:29.100 --> 00:45:34.100
The user object in the initial version

00:45:34.100 --> 00:45:37.280
just had a field called address, which was a string.

00:45:37.280 --> 00:45:38.120
But you said, you know what?

00:45:38.120 --> 00:45:40.800
People might have multiple addresses that they live at,

00:45:40.800 --> 00:45:44.280
so let's make it a list of strings

00:45:44.280 --> 00:45:46.120
and make it address as, right?

00:45:46.120 --> 00:45:47.380
Which seems like a minor change,

00:45:47.380 --> 00:45:50.240
but clearly that's going to be a major problem

00:45:50.240 --> 00:45:52.280
for the things that assume there's an address

00:45:52.280 --> 00:45:54.080
and it's no longer there, right?

00:45:54.080 --> 00:45:57.740
So you create this version change derived class

00:45:57.740 --> 00:46:02.060
that has a upgrade, downgrade basically feature, right?

00:46:02.060 --> 00:46:05.280
- Yep, and so you just describe,

00:46:05.280 --> 00:46:11.440
you simply describe how to migrate your,

00:46:11.440 --> 00:46:14.440
how do I, you simply describe

00:46:14.440 --> 00:46:16.980
how do you migrate your schemas?

00:46:16.980 --> 00:46:18.940
How do you change your schema classes,

00:46:18.940 --> 00:46:21.360
your Pydantic models?

00:46:21.360 --> 00:46:26.360
And then you describe how you convert

00:46:26.360 --> 00:46:29.240
your requests and response, and that's it.

00:46:29.240 --> 00:46:32.520
This class is the only thing you write for the new versions.

00:46:32.520 --> 00:46:36.080
Then you run code generation, run your app, that's it.

00:46:36.080 --> 00:46:36.980
Everything works.

00:46:36.980 --> 00:46:40.560
- Yeah, that's super cool.

00:46:40.560 --> 00:46:43.240
So couple of questions that were,

00:46:43.240 --> 00:46:45.800
or comments that are interesting here is,

00:46:45.800 --> 00:46:49.740
Emil asks, is it like database migrations?

00:46:49.740 --> 00:46:51.780
And my friend points out, - It's really similar.

00:46:51.780 --> 00:46:54.540
- It's really, really similar to like Alembic, right?

00:46:54.540 --> 00:46:56.580
You say, generate me the changes.

00:46:56.580 --> 00:46:58.640
Alembic is a little different in that it looks

00:46:58.640 --> 00:47:00.580
at the two different database schemas

00:47:00.580 --> 00:47:04.420
and tries to actually write the migration code

00:47:04.420 --> 00:47:06.040
to do the DDL changes.

00:47:06.040 --> 00:47:08.420
But in principle, it's like every time

00:47:08.420 --> 00:47:11.000
there's a version change, there's some bit of code

00:47:11.000 --> 00:47:12.780
that is generated that will run.

00:47:12.780 --> 00:47:15.060
And then the other one is about,

00:47:15.060 --> 00:47:16.540
how does this affect performance?

00:47:16.540 --> 00:47:19.260
And I guess the only real performance change

00:47:19.260 --> 00:47:22.060
is like there'll be a couple of steps to the serialization,

00:47:22.060 --> 00:47:23.100
but they're often small.

00:47:23.100 --> 00:47:28.100
Like in this case, the new version takes the old data

00:47:28.100 --> 00:47:30.580
and says, well, we're just gonna have a list

00:47:30.580 --> 00:47:33.540
with one address, so we're gonna stick the one address

00:47:33.540 --> 00:47:36.900
into the list of addresses, and vice versa.

00:47:36.900 --> 00:47:39.280
You just set the address field to be the first thing

00:47:39.280 --> 00:47:40.120
in the address list.

00:47:40.120 --> 00:47:42.860
And like, that's a really low amount of code overhead

00:47:44.080 --> 00:47:45.280
to go back.

00:47:45.280 --> 00:47:47.240
Hopefully people are moving towards the new versions

00:47:47.240 --> 00:47:49.920
eventually, that kind of thing.

00:47:49.920 --> 00:47:52.360
But if they don't, then this code just runs

00:47:52.360 --> 00:47:54.960
to transform the dictionaries that goes back to it.

00:47:54.960 --> 00:48:00.280
- Yeah, but thing is, imagine you have like Stripe,

00:48:00.280 --> 00:48:02.800
I don't know, 13 years worth of versions.

00:48:02.800 --> 00:48:06.240
Now, if you are a successful company,

00:48:06.240 --> 00:48:09.440
and if you are alive, you are probably a successful company

00:48:09.440 --> 00:48:10.480
after 13 years.

00:48:10.480 --> 00:48:14.040
If you're a successful company, that most of your clients

00:48:14.040 --> 00:48:16.640
will probably be newer ones.

00:48:16.640 --> 00:48:19.840
You know, the longer you exist,

00:48:19.840 --> 00:48:21.720
the more clients you have, and the more clients you have,

00:48:21.720 --> 00:48:23.880
the more, you know, newer clients you have,

00:48:23.880 --> 00:48:27.200
the newer API versions they will use.

00:48:27.200 --> 00:48:29.560
And this means that most of your clients-

00:48:29.560 --> 00:48:33.640
- They might decide to, they might rewrite their own app

00:48:33.640 --> 00:48:34.980
and get a new version, right?

00:48:34.980 --> 00:48:38.400
Like they could upgrade their code,

00:48:38.400 --> 00:48:40.280
'cause their code's gonna be 13 years old

00:48:40.280 --> 00:48:41.560
or 12 years old at this point.

00:48:41.560 --> 00:48:43.480
They're like, they need to change too.

00:48:44.480 --> 00:48:49.480
- And so at some point, yes, your old client might,

00:48:49.480 --> 00:48:53.520
you know, from the very first version might request something

00:48:53.520 --> 00:48:56.000
and then we'll go through all converters.

00:48:56.000 --> 00:48:58.360
Well, not all, all converters that are related

00:48:58.360 --> 00:49:00.320
to the specific request and response.

00:49:00.320 --> 00:49:03.000
And that is probably going to be in the tens,

00:49:03.000 --> 00:49:05.800
not even in the hundreds, even after 13 years.

00:49:05.800 --> 00:49:08.920
But your clients from the latest versions

00:49:08.920 --> 00:49:12.320
or even from the middle versions will not suffer that.

00:49:13.280 --> 00:49:15.360
So the majority of your clients

00:49:15.360 --> 00:49:18.760
will actually see almost no performance difference.

00:49:18.760 --> 00:49:20.280
And even your old clients,

00:49:20.280 --> 00:49:24.360
even your clients for 13 years old will probably,

00:49:24.360 --> 00:49:26.000
even if they do see a performance difference,

00:49:26.000 --> 00:49:28.520
it's not going to be multiple orders.

00:49:28.520 --> 00:49:30.560
It's not going to be 2X, 3X,

00:49:30.560 --> 00:49:32.600
it's probably going to be maybe 20%,

00:49:32.600 --> 00:49:36.000
maybe even 10%, depending on how slow your app is.

00:49:36.000 --> 00:49:39.240
And that's considering how many years have passed

00:49:39.240 --> 00:49:41.640
is crazy fast.

00:49:41.640 --> 00:49:43.320
- Yeah, yeah, absolutely.

00:49:43.320 --> 00:49:44.720
That's very cool.

00:49:44.720 --> 00:49:47.280
So what about the URL?

00:49:47.280 --> 00:49:48.680
What about the endpoint?

00:49:48.680 --> 00:49:55.800
Do, how much do consumers of your API

00:49:55.800 --> 00:49:58.080
have to actually think about,

00:49:58.080 --> 00:50:00.840
I'm using this version or that version?

00:50:00.840 --> 00:50:04.240
Is it passed as a, is the version passed as a header,

00:50:04.240 --> 00:50:06.560
it's a query string, part of the URL?

00:50:06.560 --> 00:50:09.880
- The version is passed as a header.

00:50:10.720 --> 00:50:14.760
And Cadwin on by default requires it to be.

00:50:14.760 --> 00:50:18.000
But if you have some developer portal,

00:50:18.000 --> 00:50:21.640
if you wanna store your version in some database,

00:50:21.640 --> 00:50:25.560
then even though it's a little more advanced,

00:50:25.560 --> 00:50:27.880
you can write yourself your own middleware

00:50:27.880 --> 00:50:30.880
that will check if the client already has a version

00:50:30.880 --> 00:50:35.400
and then pick that version and put it into the context bar.

00:50:35.400 --> 00:50:37.040
And it's possible.

00:50:37.040 --> 00:50:40.280
So by default, you're going to have,

00:50:40.280 --> 00:50:45.280
no, no, no, middlewares are the more advanced sections,

00:50:45.280 --> 00:50:47.280
not in the tutorial.

00:50:47.280 --> 00:50:49.520
- This one has an, this other one

00:50:49.520 --> 00:50:50.520
we're gonna talk about in a section,

00:50:50.520 --> 00:50:52.080
has just an example of all,

00:50:52.080 --> 00:50:55.920
you basically just in fastAPI, when you create the app,

00:50:55.920 --> 00:50:58.280
like app equals fastAPI,

00:50:58.280 --> 00:51:02.040
you just say middleware equals a list of classes

00:51:02.040 --> 00:51:03.320
that implement these behaviors.

00:51:03.320 --> 00:51:04.920
So what you're suggesting is,

00:51:04.920 --> 00:51:06.080
like you just create a class

00:51:06.080 --> 00:51:09.280
and you pass it in at fastAPI startup.

00:51:09.280 --> 00:51:13.200
And it just goes, is there a version being passed to me?

00:51:13.200 --> 00:51:17.400
If not, let's see who the user is based on their API key,

00:51:17.400 --> 00:51:18.360
pull that from a database

00:51:18.360 --> 00:51:20.720
and maybe just set that header right there

00:51:20.720 --> 00:51:22.640
before the request and then let it fly, right?

00:51:22.640 --> 00:51:24.400
Something like that?

00:51:24.400 --> 00:51:27.520
- Yep, and then your API will essentially be Stripe-like

00:51:27.520 --> 00:51:29.040
where your client won't need to

00:51:29.040 --> 00:51:31.560
think about versioning at all.

00:51:31.560 --> 00:51:33.080
But by default, of course,

00:51:33.080 --> 00:51:35.800
the clients need to always pass it with a header,

00:51:35.800 --> 00:51:39.160
which might sound like something really,

00:51:39.160 --> 00:51:42.120
unnecessary and hard for the clients.

00:51:42.120 --> 00:51:44.080
But if you imagine that you're writing code,

00:51:44.080 --> 00:51:47.640
it's exceptionally easy to just put it into your,

00:51:47.640 --> 00:51:50.680
I don't know, requests or HTTPS client

00:51:50.680 --> 00:51:52.240
and forget about it.

00:51:52.240 --> 00:51:54.320
- Yeah, it is pretty easy.

00:51:54.320 --> 00:51:55.960
If you're consuming APIs

00:51:55.960 --> 00:51:57.640
in the fashion that we're talking about,

00:51:57.640 --> 00:52:01.560
you're probably already putting an API key

00:52:01.560 --> 00:52:06.560
or some kind of thing into the header as well, right?

00:52:06.560 --> 00:52:08.960
So you're already messing with the header anyway,

00:52:08.960 --> 00:52:10.040
just put another value in there.

00:52:10.040 --> 00:52:12.060
- Yep, precisely.

00:52:12.060 --> 00:52:14.480
- Yeah, very cool.

00:52:14.480 --> 00:52:20.480
All right, so right now this is a FastAPI thing,

00:52:20.480 --> 00:52:25.040
but you're considering opening it up to other areas,

00:52:25.040 --> 00:52:26.800
other platforms, other frameworks?

00:52:28.000 --> 00:52:30.760
- It has a, what is it called?

00:52:30.760 --> 00:52:32.560
Milestone for that,

00:52:32.560 --> 00:52:36.360
which I am planning to extend with tasks, with plans.

00:52:36.360 --> 00:52:39.960
First, it's like with Pydantic,

00:52:39.960 --> 00:52:42.120
at some point it separated the core

00:52:42.120 --> 00:52:44.640
when it was moving to Pydantic 2,

00:52:44.640 --> 00:52:47.120
and that's one of the plans for Kadwin.

00:52:47.120 --> 00:52:50.240
Separate the core without breaking the public interfaces.

00:52:50.240 --> 00:52:55.040
And then at some point use this core to build more Kadwins,

00:52:55.040 --> 00:52:57.080
Kadwin Django, Kadwin Flask, whatever.

00:52:57.920 --> 00:53:01.200
Or it doesn't even have to be a part of Kadwin.

00:53:01.200 --> 00:53:04.520
The approach is there, so anyone can use it.

00:53:04.520 --> 00:53:09.400
Because 99% of complexity in implementing Kadwin

00:53:09.400 --> 00:53:13.040
was actually figuring out these patterns

00:53:13.040 --> 00:53:15.200
and understanding how to do it.

00:53:15.200 --> 00:53:18.360
Because unlike a web app, unlike, I don't know,

00:53:18.360 --> 00:53:20.440
many apps that we develop daily,

00:53:20.440 --> 00:53:24.720
these things haven't been done.

00:53:24.720 --> 00:53:29.080
People have migrated stuff, but it was mostly,

00:53:29.080 --> 00:53:32.920
oh, change this dictionary without a proper DSL

00:53:32.920 --> 00:53:37.360
or without code generation, without the niceties

00:53:37.360 --> 00:53:40.600
that would make your IDs happy

00:53:40.600 --> 00:53:44.120
and that would make autocompletion happy.

00:53:44.120 --> 00:53:45.680
- Yeah, oh.

00:53:45.680 --> 00:53:49.200
Yeah, you are a contributor to TypeShed, which is awesome.

00:53:49.200 --> 00:53:50.040
- Oh, yes.

00:53:50.040 --> 00:53:53.600
- So you must care about conveying

00:53:53.600 --> 00:53:56.440
the type information of the different versions

00:53:56.440 --> 00:53:57.800
and stuff like that.

00:53:57.800 --> 00:53:58.920
That's tricky, right?

00:53:58.920 --> 00:54:01.360
And of course, working on FastAPI and Pydantic,

00:54:01.360 --> 00:54:02.440
those are very type.

00:54:02.440 --> 00:54:05.280
Oh, and the shirt says Type Hints for Life, I love it.

00:54:05.280 --> 00:54:06.640
I don't have any cool slogan on mine,

00:54:06.640 --> 00:54:08.720
I just have gray stripes.

00:54:08.720 --> 00:54:10.800
But I should, very cool.

00:54:10.800 --> 00:54:13.200
So yeah, wanna speak to the type hint,

00:54:13.200 --> 00:54:16.280
type information aspect of this whole thing?

00:54:16.280 --> 00:54:21.200
- Well, essentially, as I mentioned,

00:54:22.400 --> 00:54:25.800
Stripe did it using simply dictionaries

00:54:25.800 --> 00:54:30.800
and it was mostly untyped, as probably many people know.

00:54:30.800 --> 00:54:36.120
Stripe, after having so many problems with scalability

00:54:36.120 --> 00:54:40.120
in terms of the team scalability and problems with typing,

00:54:40.120 --> 00:54:45.480
they have decided to adopt Sorbet,

00:54:45.480 --> 00:54:47.680
well, not adopt, create Sorbet,

00:54:47.680 --> 00:54:51.520
which is essentially a type checker.

00:54:51.520 --> 00:54:56.520
It's like a type checker and DSL for Ruby for type hints,

00:54:56.520 --> 00:54:57.680
which is really nice.

00:54:57.680 --> 00:55:01.320
It has both a runtime component and a static component,

00:55:01.320 --> 00:55:02.560
as far as I remember.

00:55:02.560 --> 00:55:10.240
But they still, most of the time, work with untyped code,

00:55:10.240 --> 00:55:14.600
which essentially can lead to many errors.

00:55:14.600 --> 00:55:16.600
Kadwin tries to make sure

00:55:16.600 --> 00:55:18.840
that you still work with your schemas,

00:55:18.840 --> 00:55:20.560
you still know which schema you work with,

00:55:20.560 --> 00:55:21.960
it's always the latest.

00:55:21.960 --> 00:55:24.560
And Kadwin tries to make sure

00:55:24.560 --> 00:55:29.320
that you're not going to have any type errors

00:55:29.320 --> 00:55:31.200
if you don't want to.

00:55:31.200 --> 00:55:33.800
And you're going to have all of the niceties

00:55:33.800 --> 00:55:35.400
of having this dynamic

00:55:35.400 --> 00:55:41.440
request response conversion thing.

00:55:41.440 --> 00:55:44.480
So we're trying to take the best of both worlds,

00:55:44.480 --> 00:55:46.600
have you support very little code,

00:55:46.600 --> 00:55:50.120
but make sure that you can type hint everything

00:55:50.120 --> 00:55:52.760
without any issue and you're not going to have problems

00:55:52.760 --> 00:55:55.560
and your type checker is going to check everything for you.

00:55:55.560 --> 00:55:58.440
And your, I don't know, VS Code is going to see

00:55:58.440 --> 00:56:01.520
which fields something has, which types of things.

00:56:01.520 --> 00:56:02.360
- Yeah, excellent.

00:56:02.360 --> 00:56:07.360
One of the big problems with all the runtime modifications,

00:56:07.360 --> 00:56:09.960
one way you could have done this is that app startup,

00:56:09.960 --> 00:56:12.360
it could look at all of those things

00:56:12.360 --> 00:56:14.960
and it could just dynamically generate

00:56:14.960 --> 00:56:17.280
all the different versions and all the things

00:56:18.280 --> 00:56:22.080
using meta programming, but then the editor--

00:56:22.080 --> 00:56:24.000
- Yeah, and it does that.

00:56:24.000 --> 00:56:27.400
Yeah, it does that with the endpoints

00:56:27.400 --> 00:56:30.840
because endpoints are not, you know,

00:56:30.840 --> 00:56:33.240
your editors, they don't care about endpoints.

00:56:33.240 --> 00:56:34.080
- Exactly.

00:56:34.080 --> 00:56:36.840
- You never call your endpoint from your code.

00:56:36.840 --> 00:56:39.800
No, you usually call the business logic from it,

00:56:39.800 --> 00:56:41.400
which is why I decided to do it in runtime.

00:56:41.400 --> 00:56:43.240
You don't really need it.

00:56:43.240 --> 00:56:45.120
But for Schemas, yes.

00:56:45.120 --> 00:56:47.320
For Schemas, having them generated

00:56:47.320 --> 00:56:48.560
and then having people guessing

00:56:48.560 --> 00:56:53.120
and then having their IDs just put everything in red,

00:56:53.120 --> 00:56:54.920
that is horrible.

00:56:54.920 --> 00:56:56.840
I wouldn't want anyone to have that.

00:56:56.840 --> 00:56:58.800
- Yeah, yeah, I don't like it either.

00:56:58.800 --> 00:57:00.360
Not at all.

00:57:00.360 --> 00:57:03.800
It's right up there with the star, star, star, KW args.

00:57:03.800 --> 00:57:06.560
Have a good time guessing in my world.

00:57:06.560 --> 00:57:07.960
I don't like either of them.

00:57:07.960 --> 00:57:10.160
Awesome, all right.

00:57:10.160 --> 00:57:12.760
Well, let's just maybe touch real quickly

00:57:12.760 --> 00:57:16.360
on a couple of other choices that are out here.

00:57:16.360 --> 00:57:19.480
You know, Kadwin looks awesome, but we also have,

00:57:19.480 --> 00:57:22.120
for example, we have from Dean Way,

00:57:22.120 --> 00:57:23.720
we have FastAPI versioning,

00:57:23.720 --> 00:57:25.200
which has a very different philosophy.

00:57:25.200 --> 00:57:30.200
It has kind of the V1, the V2 style

00:57:30.200 --> 00:57:33.680
that you might maintain multiple versions of.

00:57:33.680 --> 00:57:36.200
You wanna just maybe speak to your thoughts

00:57:36.200 --> 00:57:39.080
on this one real quick and people can take that

00:57:39.080 --> 00:57:39.920
if they like this style.

00:57:39.920 --> 00:57:41.120
- It's a great library.

00:57:41.120 --> 00:57:44.480
And I think it's either the first or the most popular.

00:57:44.480 --> 00:57:45.600
It's definitely the most popular,

00:57:45.600 --> 00:57:47.880
but I think it might even be the first library

00:57:47.880 --> 00:57:50.400
in FastAPI to implement versioning,

00:57:50.400 --> 00:57:52.480
implement proper versioning.

00:57:52.480 --> 00:57:54.120
It has a few issues.

00:57:54.120 --> 00:57:58.560
First of all, it only, as far as I remember,

00:57:58.560 --> 00:58:02.920
it is mostly, how do I say it?

00:58:02.920 --> 00:58:04.360
It is mostly duplication-based,

00:58:04.360 --> 00:58:05.960
so it doesn't automate anything for you,

00:58:05.960 --> 00:58:07.800
which is a good thing if you know what you're doing

00:58:07.800 --> 00:58:10.960
and you're not going to have a lot of versions.

00:58:10.960 --> 00:58:14.200
But if you have 10 or 20 versions,

00:58:14.200 --> 00:58:16.400
if you wanna keep them for a long time,

00:58:16.400 --> 00:58:20.600
this is the endpoint copying approach that I mentioned,

00:58:20.600 --> 00:58:23.280
that with time is going to kill you,

00:58:23.280 --> 00:58:26.320
which is a problem here.

00:58:26.320 --> 00:58:31.240
The second problem is that it, as far as I understand,

00:58:31.240 --> 00:58:33.920
kind of recommends semantic versioning,

00:58:33.920 --> 00:58:35.920
though it doesn't bind you to it.

00:58:35.920 --> 00:58:37.840
You can use dates,

00:58:37.840 --> 00:58:40.200
though you will have to make sure that they're dates yourself

00:58:40.200 --> 00:58:43.800
and you can use just simple integers.

00:58:43.800 --> 00:58:46.240
So you're not bound by semantic versioning,

00:58:46.240 --> 00:58:48.800
but it has a few examples with that.

00:58:48.800 --> 00:58:51.560
Aside from these two, it's an amazing library.

00:58:51.560 --> 00:58:54.680
And for anyone who just wants to version a small app,

00:58:54.680 --> 00:58:57.000
just add a single version that is going to be,

00:58:57.000 --> 00:59:00.880
the old version is going to be deleted in like two months,

00:59:00.880 --> 00:59:03.520
use that, use FastAPI versioning.

00:59:03.520 --> 00:59:06.520
It's an amazing library and you don't need anything else.

00:59:06.520 --> 00:59:10.840
CADWIN is for use cases where you need to keep

00:59:10.840 --> 00:59:13.560
a larger number of versions,

00:59:13.560 --> 00:59:16.640
or if the changes between your versions are much trickier.

00:59:16.640 --> 00:59:19.480
- Sure, yeah, like this might be pretty good

00:59:19.480 --> 00:59:23.800
for my example I talked about with the courses app

00:59:23.800 --> 00:59:24.640
that we built, right?

00:59:24.640 --> 00:59:26.080
We literally have two versions.

00:59:26.080 --> 00:59:29.160
It's been around since 2018 and there's two versions.

00:59:29.160 --> 00:59:31.880
You know, like that would be a decorator

00:59:31.880 --> 00:59:33.800
and I'm probably good to go.

00:59:33.800 --> 00:59:36.080
I don't need to think too much about it.

00:59:36.080 --> 00:59:38.320
- Precisely, no code generation, no nothing.

00:59:38.320 --> 00:59:41.600
You just put it in and you go.

00:59:41.600 --> 00:59:43.680
- Yep, all right, another one.

00:59:43.680 --> 00:59:47.560
If you're a Flask person, you could have Flask rebar,

00:59:47.560 --> 00:59:51.360
which seems to have a real similar philosophy

00:59:51.360 --> 00:59:54.360
to what you just described, but you know, it works for Flask.

00:59:54.360 --> 01:00:01.800
- Oh, I feel like it's a little more complex than that.

01:00:01.800 --> 01:00:07.560
If I remember on us discussing that, let me pull that up.

01:00:10.440 --> 01:00:14.080
- Oh yes, no, it is also the parent point.

01:00:14.080 --> 01:00:18.720
So it also allows you to duplicate single endpoints

01:00:18.720 --> 01:00:23.720
and it also allows you to, how do I describe it?

01:00:23.720 --> 01:00:29.060
It also allows you to do arbitrary prefixes.

01:00:29.060 --> 01:00:31.840
So you can have integers, you can have dates,

01:00:31.840 --> 01:00:34.400
you can have, you know, whatever.

01:00:34.400 --> 01:00:36.440
- Old, new, whatever.

01:00:36.440 --> 01:00:38.080
- Yeah, old, new.

01:00:38.080 --> 01:00:39.680
I guess some people do that.

01:00:40.200 --> 01:00:42.920
(laughing)

01:00:42.920 --> 01:00:45.040
- Yeah, latest, latest.

01:00:45.040 --> 01:00:48.860
- Yeah, yeah, latest, latest, final, yes, exactly.

01:00:48.860 --> 01:00:53.600
- But yeah, it's really similar.

01:00:53.600 --> 01:00:55.680
- They probably use zipping up folders

01:00:55.680 --> 01:00:56.840
for version control as well.

01:00:56.840 --> 01:00:59.940
I'm just naming them by the date, final, final, final.

01:00:59.940 --> 01:01:05.080
- Yeah, let's not use Git, let's just copy them.

01:01:05.080 --> 01:01:07.120
And I mean, as per versioning,

01:01:07.120 --> 01:01:08.960
that's like a really good metaphor.

01:01:08.960 --> 01:01:12.560
If you are a person that just needs another version

01:01:12.560 --> 01:01:14.840
of their Google Doc, you wouldn't use Git.

01:01:14.840 --> 01:01:17.640
Well, unless you use Git for everything else.

01:01:17.640 --> 01:01:21.920
And same here, you don't need a huge combine

01:01:21.920 --> 01:01:23.680
for using Flask.

01:01:23.680 --> 01:01:26.840
And Flask usually, at least in my experience,

01:01:26.840 --> 01:01:30.040
tries to build simpler APIs and you wouldn't use,

01:01:30.040 --> 01:01:35.040
well, most companies that do API first don't use Flask.

01:01:35.280 --> 01:01:39.560
They try to do Django DRF or FastAPI,

01:01:39.560 --> 01:01:41.400
which is why this library seems

01:01:41.400 --> 01:01:42.900
like a perfect choice for that.

01:01:42.900 --> 01:01:45.720
- Yeah, yeah, indeed.

01:01:45.720 --> 01:01:46.680
It seems really nice.

01:01:46.680 --> 01:01:49.800
One of the things that, we were speaking of duplication,

01:01:49.800 --> 01:01:52.400
one of the things that they just jump right into

01:01:52.400 --> 01:01:57.040
to demonstrate here, and I imagine the FastAPI version one

01:01:57.040 --> 01:02:00.200
as well could do it, but there's one endpoint

01:02:00.200 --> 01:02:03.160
that doesn't change and there's one that is different.

01:02:03.160 --> 01:02:04.640
So they copy the one that's different,

01:02:04.640 --> 01:02:05.920
but for the one that doesn't change,

01:02:05.920 --> 01:02:09.560
they just put a V1 and a V2 decorator on that one

01:02:09.560 --> 01:02:12.120
and it remains unchanged basically, right?

01:02:12.120 --> 01:02:14.520
- Mm-hmm, mm-hmm, yep.

01:02:14.520 --> 01:02:16.360
But I mean,

01:02:16.360 --> 01:02:21.800
Kadwin tries to escape this kind of verbosity

01:02:21.800 --> 01:02:24.260
and essentially you have all endpoints everywhere

01:02:24.260 --> 01:02:26.560
and if you wanna omit some endpoint

01:02:26.560 --> 01:02:28.760
or change some endpoint or add some endpoint

01:02:28.760 --> 01:02:34.000
into the new version, you just add a version change

01:02:34.000 --> 01:02:38.120
and say, oh, this endpoint didn't exist

01:02:38.120 --> 01:02:39.720
in the old version, that's it.

01:02:39.720 --> 01:02:41.120
- Yeah, yeah, that's cool.

01:02:41.120 --> 01:02:44.120
Very cool, yeah, because if you had 20 of these,

01:02:44.120 --> 01:02:47.720
you'd have 20 decorators in a little function, right?

01:02:47.720 --> 01:02:48.560
That's where it starts to get--

01:02:48.560 --> 01:02:50.000
- That's what I'm saying, but I mean,

01:02:50.000 --> 01:02:51.880
not a huge issue for Flask.

01:02:51.880 --> 01:02:54.300
I haven't seen anyone building, I don't know,

01:02:54.300 --> 01:03:00.160
50 or 200 endpoints apps with Flask.

01:03:00.160 --> 01:03:03.880
I'm sure people do that, but I think it's the minority.

01:03:03.880 --> 01:03:07.080
- Sure, all right, other side of the fence,

01:03:07.080 --> 01:03:08.800
Django REST framework, DRF,

01:03:08.800 --> 01:03:10.640
you already mentioned them a little bit.

01:03:10.640 --> 01:03:14.680
And so Django, they already have like versioning

01:03:14.680 --> 01:03:17.640
built into the framework itself, right?

01:03:17.640 --> 01:03:21.520
- They have versioning interfaces built into.

01:03:21.520 --> 01:03:25.780
So like, it's not, they're not implementing versioning

01:03:25.780 --> 01:03:28.440
for you, but they give you all the tools

01:03:28.440 --> 01:03:30.080
to implement your own versioning.

01:03:30.080 --> 01:03:33.040
- Got it, yeah, okay, so they kind of have

01:03:33.040 --> 01:03:36.080
the building blocks for it, excellent.

01:03:36.080 --> 01:03:40.000
All right, well, I think we're pretty much out of time,

01:03:40.000 --> 01:03:42.840
but thank you for being here,

01:03:42.840 --> 01:03:44.480
this has been really interesting.

01:03:44.480 --> 01:03:47.360
- Oh, it was for me as well.

01:03:47.360 --> 01:03:49.120
Thank you for having me here.

01:03:49.120 --> 01:03:50.960
- Yeah, you've given everyone a lot to think about.

01:03:50.960 --> 01:03:54.320
You know, before we wrap it up, two quick things,

01:03:54.320 --> 01:04:01.280
notable PyPI package, I mean, we've already given

01:04:01.280 --> 01:04:03.880
Cadwin a shout out, anything else that like,

01:04:03.880 --> 01:04:06.200
oh, I came across this and it was super cool,

01:04:06.200 --> 01:04:08.280
maybe it deserves a little bit of a shout out,

01:04:08.280 --> 01:04:11.180
anything that like you use a lot that you would recommend?

01:04:11.180 --> 01:04:18.520
- So for us in our company, we started using

01:04:18.520 --> 01:04:20.680
one more package of mine,

01:04:20.680 --> 01:04:23.740
it's called ByteTest fixture classes.

01:04:23.740 --> 01:04:24.580
- Okay.

01:04:24.580 --> 01:04:27.200
- Essentially, when you are building groups of fixtures

01:04:27.200 --> 01:04:31.760
that create some objects for you to use in your tests,

01:04:31.760 --> 01:04:34.840
and then all of a sudden, one of your tests needs an object

01:04:34.840 --> 01:04:37.680
that's a little different, you know, just a little bit,

01:04:37.680 --> 01:04:40.680
and then everything just falls apart.

01:04:40.680 --> 01:04:45.680
Well, a factory fixture pattern that you can see in ByteTest

01:04:45.680 --> 01:04:50.020
allows you to, you know, make a function within a function

01:04:50.020 --> 01:04:55.020
and one of them is a fixture and that's all cool and nice,

01:04:55.320 --> 01:04:58.200
but then it's not typed.

01:04:58.200 --> 01:05:01.320
Yeah, you can, you know, you can use, you know,

01:05:01.320 --> 01:05:04.120
the callable syntax and then you're not going to have

01:05:04.120 --> 01:05:07.760
the keyword arguments there and otherwise,

01:05:07.760 --> 01:05:11.220
you can write a protocol and it's a lot of code.

01:05:11.220 --> 01:05:14.560
What ByteTest fixture classes does

01:05:14.560 --> 01:05:17.440
is it allows you to type everything there,

01:05:17.440 --> 01:05:21.360
so you write the same amount of code, but it's all typed

01:05:21.360 --> 01:05:25.020
and now you have, you can have groups of fixture classes

01:05:25.020 --> 01:05:28.520
building on top of each other, which is a nice pattern

01:05:28.520 --> 01:05:30.800
to have, but a really bad pattern to abuse.

01:05:30.800 --> 01:05:33.480
- Very cool.

01:05:33.480 --> 01:05:36.000
All right, well, nice, nice recommendation.

01:05:36.000 --> 01:05:36.920
People can check that out.

01:05:36.920 --> 01:05:39.480
Emil out in the audience already says,

01:05:39.480 --> 01:05:41.280
amazing thing, I'm already using it.

01:05:41.280 --> 01:05:46.360
So final call to action, people have APIs,

01:05:46.360 --> 01:05:48.640
they've listened to us talk for an hour and they're like,

01:05:48.640 --> 01:05:51.440
oh, we should be versioning our APIs.

01:05:51.440 --> 01:05:54.600
We probably should be doing something here.

01:05:54.600 --> 01:05:55.720
What do you recommend people do?

01:05:55.720 --> 01:05:56.780
How do they get started?

01:05:56.780 --> 01:05:58.060
How do they go further?

01:05:58.060 --> 01:06:02.320
- So first you need to decide whether your use case

01:06:02.320 --> 01:06:04.760
is simple, how many versions are you going to support?

01:06:04.760 --> 01:06:07.240
If you're not planning to support more than two versions,

01:06:07.240 --> 01:06:11.020
or if you are supporting versions only for your internal

01:06:11.020 --> 01:06:14.840
microservices or only for your front end,

01:06:14.840 --> 01:06:17.600
then consider using the simple tools,

01:06:17.600 --> 01:06:19.960
consider using the FastAPI versioning,

01:06:19.960 --> 01:06:23.340
you know, Flask, Raybar, things like that.

01:06:23.340 --> 01:06:27.800
But then once you realize that you need to support versions

01:06:27.800 --> 01:06:30.720
for months and you need three or more versions,

01:06:30.720 --> 01:06:35.000
and you're providing your versions as a public,

01:06:35.000 --> 01:06:36.880
you know, to the public,

01:06:36.880 --> 01:06:40.040
then I advise moving straight into CAD/WIN

01:06:40.040 --> 01:06:42.040
or CAD/WIN like frameworks.

01:06:42.040 --> 01:06:45.140
If you use FastAPI, you can just use CAD/WIN.

01:06:45.140 --> 01:06:47.140
It has a bit of a learning curve,

01:06:47.140 --> 01:06:49.000
but within making one version,

01:06:49.000 --> 01:06:51.280
you will realize just how simple it is.

01:06:51.280 --> 01:06:55.440
And if you're not using CAD/WIN, that's fine as well.

01:06:55.440 --> 01:06:58.860
I have all of the resources that I used to build it

01:06:58.860 --> 01:07:01.320
and all of the resources, you know,

01:07:01.320 --> 01:07:03.840
describing different ways of API versioning

01:07:03.840 --> 01:07:06.540
there in the repository in the theory section.

01:07:06.540 --> 01:07:07.920
So you can just read that.

01:07:07.920 --> 01:07:10.140
And even if you don't like that approach,

01:07:10.140 --> 01:07:12.300
we describe everything else there.

01:07:12.300 --> 01:07:14.920
So you'll be able to pick the one you like.

01:07:14.920 --> 01:07:17.100
But my personal recommendation,

01:07:17.100 --> 01:07:19.400
don't pick the directories, they're painful.

01:07:21.100 --> 01:07:24.340
- Awesome, really good advice, super cool project.

01:07:24.340 --> 01:07:26.580
So thank you for being here Stanislav,

01:07:26.580 --> 01:07:28.700
and talk to you later.

01:07:28.700 --> 01:07:30.900
- Talk to you later.

01:07:30.900 --> 01:07:34.500
[ monitoring background sound ]

