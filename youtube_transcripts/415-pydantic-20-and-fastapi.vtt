WEBVTT

00:00:00.000 --> 00:00:02.240
[END PLAYBACK]


00:00:02.240 --> 00:00:04.240
Super nice to see you here at PyCon.


00:00:04.240 --> 00:00:05.120
Welcome to the show.


00:00:05.120 --> 00:00:06.580
Thank you very much for having us.


00:00:06.580 --> 00:00:10.840
It's strange and exciting to do this live and to see you.


00:00:10.840 --> 00:00:11.560
Yes, I know.


00:00:11.560 --> 00:00:15.800
Normally, it's remote over screen share over half the world


00:00:15.800 --> 00:00:16.720
or something like that.


00:00:16.720 --> 00:00:17.400
And here we are.


00:00:17.400 --> 00:00:18.600
Yeah, and being able to talk with you directly.


00:00:18.600 --> 00:00:21.200
Also, with Samuel here, it's super cool, super cool


00:00:21.200 --> 00:00:22.680
to be here.


00:00:22.680 --> 00:00:23.760
Yeah, thank you very much.


00:00:23.760 --> 00:00:24.600
Yes, it's great to be here.


00:00:24.600 --> 00:00:25.960
It's really fun being at PyCon.


00:00:25.960 --> 00:00:28.200
And then doing this is like, yeah, even more fun.


00:00:28.200 --> 00:00:31.840
I've done my talk, so I'm much more relaxed than I would have been if it had been this


00:00:31.840 --> 00:00:32.840
time yesterday.


00:00:32.840 --> 00:00:36.700
I was just thinking, talking to someone else, one of the best parts about giving a talk


00:00:36.700 --> 00:00:39.420
is that when it's over, you can really relax.


00:00:39.420 --> 00:00:40.420
You know what I mean?


00:00:40.420 --> 00:00:42.140
You're like, "Okay, now I can enjoy the conference."


00:00:42.140 --> 00:00:43.140
Absolutely, yeah.


00:00:43.140 --> 00:00:45.540
And the parties, because you can't go too big on the parties if you've got to talk.


00:00:45.540 --> 00:00:47.140
I feel like all the best ones were last night.


00:00:47.140 --> 00:00:48.140
I'm afraid.


00:00:48.140 --> 00:00:51.820
We were at a pretty good one last night, weren't we?


00:00:51.820 --> 00:00:52.820
That was excellent.


00:00:52.820 --> 00:00:53.820
All right.


00:00:53.820 --> 00:00:56.340
Well, really good to have you both at the show.


00:00:56.340 --> 00:01:00.340
I guess you hardly need introductions.


00:01:00.340 --> 00:01:01.860
You both are doing such cool work.


00:01:01.860 --> 00:01:04.820
We've had you on the show several times each.


00:01:04.820 --> 00:01:07.040
So maybe just, let's start with a catch up.


00:01:07.040 --> 00:01:09.300
Like you both have lots of big news.


00:01:09.300 --> 00:01:11.140
Don't want to necessarily spoil too much,


00:01:11.140 --> 00:01:12.620
but you know, what have you been up to?


00:01:12.620 --> 00:01:15.780
- Yeah, so I raised money earlier this year.


00:01:15.780 --> 00:01:17.060
Well, it was all sorted last year.


00:01:17.060 --> 00:01:18.860
Money came in in January this year.


00:01:18.860 --> 00:01:21.180
Started a company around Pydantic.


00:01:21.180 --> 00:01:23.040
So I've been busy hiring.


00:01:23.040 --> 00:01:24.700
Got a team of seven now.


00:01:24.700 --> 00:01:26.660
One more going to join in June.


00:01:26.660 --> 00:01:29.040
And yeah, currently we're working full-time


00:01:29.040 --> 00:01:32.100
on Pydantic version two, getting that released.


00:01:32.100 --> 00:01:33.300
And then after that, we're gonna move on


00:01:33.300 --> 00:01:35.100
to the commercial plans,


00:01:35.100 --> 00:01:36.620
which I'm not talking about too much,


00:01:36.620 --> 00:01:39.220
mostly because they're up in the air a bit.


00:01:39.220 --> 00:01:40.980
Also because if you start talking about them,


00:01:40.980 --> 00:01:42.180
you have to finish talking about them.


00:01:42.180 --> 00:01:43.080
And then that's like,


00:01:43.080 --> 00:01:44.540
I'll just like take over the whole podcast.


00:01:44.540 --> 00:01:46.060
So I'll say that, yeah,


00:01:46.060 --> 00:01:47.620
working on Pydantic v2 for now,


00:01:47.620 --> 00:01:49.260
and then moving on soon.


00:01:49.260 --> 00:01:51.100
- First from the whole community, congratulations.


00:01:51.100 --> 00:01:52.500
You must be really thrilled.


00:01:52.500 --> 00:01:54.220
- Yeah, it's amazing.


00:01:54.220 --> 00:01:55.260
It's a very surreal, right?


00:01:55.260 --> 00:01:57.900
Because I was going to say, I had to see this coming.


00:01:57.900 --> 00:01:58.460
No, I didn't.


00:01:58.460 --> 00:02:02.860
I had, my plan had been to start a different company once


00:02:02.860 --> 00:02:03.940
Pydantic V2 was done.


00:02:03.940 --> 00:02:11.500
And then in November, I, Bogumil from Sequoia who Sebastian


00:02:11.500 --> 00:02:13.220
knew Sebastian recommended he chatted to me.


00:02:13.220 --> 00:02:15.620
We had a call, we had another call two weeks later.


00:02:15.620 --> 00:02:19.260
And then he said, let's have the final meeting with like a few more partners


00:02:19.260 --> 00:02:21.100
to decide whether to invest in two weeks time.


00:02:21.620 --> 00:02:24.220
So I thought, "Oh, I should probably go and speak to some other VCs."


00:02:24.220 --> 00:02:26.380
So Sebastian very kindly got me lots of intros.


00:02:26.380 --> 00:02:28.060
My girlfriend also got me some intros.


00:02:28.060 --> 00:02:32.460
I had like five meetings lined up and then the floodgates opened and I got


00:02:32.460 --> 00:02:35.540
another like 20 or so VCs emailing me being like, "Please, can I call?"


00:02:35.540 --> 00:02:38.620
Starting to hear about, "Oh, why are we not part of this?"


00:02:38.620 --> 00:02:39.020
Right.


00:02:39.020 --> 00:02:40.940
Then I got COVID.


00:02:40.940 --> 00:02:45.020
So I spent a week locked in the bedroom upstairs doing VC calls.


00:02:45.020 --> 00:02:47.980
Most of them with the camera off, feeling absolutely horrific.


00:02:48.740 --> 00:02:54.060
And yeah, and then came back full circle back and had the big call with Sequoia and took their money.


00:02:54.060 --> 00:02:56.380
So it was Sequoia that invested?


00:02:56.380 --> 00:02:56.580
Yeah.


00:02:56.580 --> 00:02:57.220
Wow.


00:02:57.220 --> 00:02:57.620
Awesome.


00:02:57.620 --> 00:02:59.340
That's a big name to have behind you.


00:02:59.340 --> 00:03:12.620
So Sequoia and Patek, who are the smaller VC, who are like French American, and then Irregular Expression, which is this really cool CTO network based kind of again, like New York and Paris, and then a bunch of angels.


00:03:12.620 --> 00:03:17.180
Yeah, last time we spoke, it was about Pydantic V2 and then all of this broke.


00:03:17.180 --> 00:03:22.520
And yeah, I feel like I'm just back up to as in problem was, although I was doing it


00:03:22.520 --> 00:03:26.800
to speed up, that was the, within two months of basically doing meetings and


00:03:26.800 --> 00:03:29.960
doing legals, so I think I've now got a team sufficiently that I'm like caught


00:03:29.960 --> 00:03:33.180
up to where I would have been if I had just sat there and written code all along.


00:03:33.180 --> 00:03:33.880
Yeah.


00:03:33.880 --> 00:03:36.680
That's how it goes, right?


00:03:36.680 --> 00:03:41.600
You gotta, you gotta put a little more sand in the gears to, to, to grow, I guess.


00:03:41.600 --> 00:03:43.520
And Sebastian, how about you?


00:03:43.520 --> 00:03:45.200
What do you, what have you been up to?


00:03:45.200 --> 00:03:45.640
How you been?


00:03:45.640 --> 00:03:46.600
Oh,


00:03:46.600 --> 00:03:48.160
I think I've been good.


00:03:48.160 --> 00:03:48.560
Yeah.


00:03:48.560 --> 00:03:54.400
Very excited about like what they are doing at Pydantic is like the team they are assembling is like just amazing.


00:03:54.400 --> 00:04:16.080
And like, yeah, just like recently working a bunch in FastAPI and like Dyper and actually like in also some of the low level things of FastAPI and also not just FastAPI, but like the things that go underneath right now, like one of the things that I am pushing for is having documentation of the API reference of the reference of


00:04:16.080 --> 00:04:20.040
of the each one of the parameters for what it is for each one of the methods, like all


00:04:20.040 --> 00:04:21.040
the stuff.


00:04:21.040 --> 00:04:22.040
Yeah.


00:04:22.040 --> 00:04:26.760
And I want to do it in a in a better way that is more maintainable and that I can test the


00:04:26.760 --> 00:04:31.880
actual documentation for those parameters and consistency between like, there's a bunch


00:04:31.880 --> 00:04:33.400
of things that I'm trying to do.


00:04:33.400 --> 00:04:37.520
And like, it also goes to the low levels of like, typing and interacting with the people


00:04:37.520 --> 00:04:42.640
that is handling typing and like all the stuff that is super cool, super exciting, but like,


00:04:42.640 --> 00:04:47.140
I think it can work and it can, it can make these things have like, you know,


00:04:47.140 --> 00:04:51.040
like the API reference for the tools is something that a lot of people have been


00:04:51.040 --> 00:04:57.540
requesting and like being able to have that in a way that is easy to maintain


00:04:57.540 --> 00:04:59.860
that can work well and that I can handle.


00:04:59.860 --> 00:05:01.860
Like, I think that's, that's super exciting on that side.


00:05:01.860 --> 00:05:05.780
And on the other side, of course, like the integration with Python TV too is super


00:05:05.780 --> 00:05:09.320
exciting now that they have like the first alpha available is like,


00:05:09.320 --> 00:05:10.780
it is, I mean,


00:05:11.700 --> 00:05:16.900
here you are going along working on FastAPI. Everyone I talked to was just universally


00:05:16.900 --> 00:05:21.220
impressed with it. You know, honestly, like I've never heard a bad thing about FastAPI.


00:05:21.220 --> 00:05:26.900
And people are really enjoying it. And then here comes Samuel, just changing the foundation,


00:05:26.900 --> 00:05:35.460
changing up finance. No, no, no, I'm just teasing. So how much work is that actually going to be to


00:05:35.460 --> 00:05:41.380
kind of, is it kind of nothing or is it some work? No, like there will be some work in FastAPI. The


00:05:41.380 --> 00:05:45.980
The thing is, for final users, it will be almost transparent.


00:05:45.980 --> 00:05:50.820
They will probably, if they are doing weird stuff,


00:05:50.820 --> 00:05:54.460
complex things that touches the corner cases or things like that,


00:05:54.460 --> 00:05:56.460
they will probably have to update some things.


00:05:56.460 --> 00:06:00.740
But for most of the use cases, it will be pretty much transparent for people.


00:06:00.740 --> 00:06:05.260
And they will just get the 10, 20x performance from Python TV 2.


00:06:05.260 --> 00:06:06.980
And also, like the...


00:06:06.980 --> 00:06:09.300
I was going to say, just on the performance, I'm sorry to interrupt you.


00:06:09.300 --> 00:06:11.460
One of the big things that we will be able to,


00:06:11.460 --> 00:06:14.540
you'll be able to drop from FastAPI is the,


00:06:14.540 --> 00:06:16.260
I'm gonna call it hack, but it's not your fault,


00:06:16.260 --> 00:06:17.100
it's my fault.


00:06:17.100 --> 00:06:18.340
(laughing)


00:06:18.340 --> 00:06:22.060
Of like, don't ask the type problem of serialization.


00:06:22.060 --> 00:06:24.300
So I think that the like speed up on serialization


00:06:24.300 --> 00:06:27.100
in FastAPI could exceed, like,


00:06:27.100 --> 00:06:27.940
could be even bigger than that.


00:06:27.940 --> 00:06:30.020
I don't know that yet, but I'm really hopeful


00:06:30.020 --> 00:06:32.100
for some like massive improvements


00:06:32.100 --> 00:06:35.860
because of fixes in Pydantic that make FastAPI


00:06:35.860 --> 00:06:37.380
simpler and more elegant.


00:06:37.380 --> 00:06:37.620
Yeah.


00:06:37.620 --> 00:06:42.400
And since they're turning off the lights, we we'll see how long we last year.


00:06:42.400 --> 00:06:45.160
We'll, we'll, we'll stay as long as we can.


00:06:45.160 --> 00:06:48.580
If you hear any noise in the background, that's because they're trying to tear


00:06:48.580 --> 00:06:51.620
down PyCon, but we're going to work around us.


00:06:51.620 --> 00:06:51.960
It's easy.


00:06:51.960 --> 00:06:53.280
We will not let it be torn out.


00:06:53.280 --> 00:06:54.100
It will live on.


00:06:54.100 --> 00:06:56.260
It's not because the Pydantic V2.


00:06:56.260 --> 00:07:02.300
So yeah, we may have to pause and move, but we'll, we'll find out anyway.


00:07:04.300 --> 00:07:07.500
From a user for Pydantic, Samuel,


00:07:07.500 --> 00:07:10.380
if you haven't gone and like deeply gone


00:07:10.380 --> 00:07:12.820
into like root object validation


00:07:12.820 --> 00:07:13.780
and all that kind of stuff,


00:07:13.780 --> 00:07:15.420
it's probably you won't even know, right?


00:07:15.420 --> 00:07:17.260
- So I think the hardest thing, yeah, you're right.


00:07:17.260 --> 00:07:20.140
The vast majority of your code will either continue to work


00:07:20.140 --> 00:07:21.320
or we'll have a,


00:07:21.320 --> 00:07:24.340
we'll have-- - I'm gonna crash it.


00:07:24.340 --> 00:07:26.060
- If you get run over by a forklift,


00:07:26.060 --> 00:07:27.700
it's gonna really slow down the development


00:07:27.700 --> 00:07:28.900
of Pydantic, by the way.


00:07:28.900 --> 00:07:32.540
- We're gonna have a mod tool


00:07:32.540 --> 00:07:34.620
to change the name of methods.


00:07:34.620 --> 00:07:39.100
So with luck, the vast majority of the changes


00:07:39.100 --> 00:07:40.220
should be automated.


00:07:40.220 --> 00:07:42.000
I suspect that, and I was saying this earlier


00:07:42.000 --> 00:07:45.500
in the open space, the hardest thing


00:07:45.500 --> 00:07:48.860
is probably going to be where your API subtly changes


00:07:48.860 --> 00:07:52.940
in its restrictions because of effectively edge cases


00:07:52.940 --> 00:07:54.020
that Pydantic has fixed.


00:07:54.020 --> 00:07:55.780
Like so for example, in Pydantic v1,


00:07:55.780 --> 00:08:00.020
we would coerce a int to a string.


00:08:00.020 --> 00:08:02.540
If you ever passed a string to a,


00:08:02.540 --> 00:08:05.460
an int to a string field, we would coerce it.


00:08:05.460 --> 00:08:07.220
I think that that's wrong and we shouldn't have done it,


00:08:07.220 --> 00:08:08.280
and so now we don't.


00:08:08.280 --> 00:08:09.420
But I was saying in the example,


00:08:09.420 --> 00:08:12.640
if for some reason you stored your IDs as strings,


00:08:12.640 --> 00:08:15.900
and therefore your API had the ID field as a string,


00:08:15.900 --> 00:08:17.500
but your user was just like,


00:08:17.500 --> 00:08:19.740
pumping them into your API as integers,


00:08:19.740 --> 00:08:21.260
'cause that seemed to make sense to them,


00:08:21.260 --> 00:08:22.380
then it's gonna break.


00:08:22.380 --> 00:08:24.540
And you probably haven't gotten a unit test that tests that


00:08:24.540 --> 00:08:26.700
because you know your ID field is a string.


00:08:26.700 --> 00:08:28.460
So I feel sorry for those people,


00:08:28.460 --> 00:08:33.460
And my biggest request would be if you're a user,


00:08:33.460 --> 00:08:35.620
try Pydantic v2 as soon as possible.


00:08:35.620 --> 00:08:37.880
I know if you use it via FastAPI, you can't yet,


00:08:37.880 --> 00:08:39.660
but like all the other libraries.


00:08:39.660 --> 00:08:42.540
But the sooner you can try it, the sooner you can tell us,


00:08:42.540 --> 00:08:44.540
and the more easily we can fix things.


00:08:44.540 --> 00:08:48.060
And we are prepared to add compatibility shims.


00:08:48.060 --> 00:08:49.820
- Okay, well, I mean, in Python,


00:08:49.820 --> 00:08:52.260
we have sort of a from futures import,


00:08:52.260 --> 00:08:55.140
well, there'd be from history import


00:08:55.140 --> 00:08:58.900
type of like reverse thing, just slow that down?


00:08:58.900 --> 00:09:00.860
Or is it going to be a deprecation or is it just


00:09:00.860 --> 00:09:03.140
- So we're doing deprecation warnings everywhere we can


00:09:03.140 --> 00:09:05.580
or deprecation errors saying this has gone away.


00:09:05.580 --> 00:09:08.120
You probably want to replace it with this thing.


00:09:08.120 --> 00:09:10.540
We're working really hard on that.


00:09:10.540 --> 00:09:13.580
We haven't got a like from future import or a


00:09:13.580 --> 00:09:14.420
- Yeah.


00:09:14.420 --> 00:09:17.700
- Or a compact layer yet for actual like validation logic.


00:09:17.700 --> 00:09:19.780
But if we have to, we will.


00:09:19.780 --> 00:09:20.700
- Yeah.


00:09:20.700 --> 00:09:22.220
Okay.


00:09:22.220 --> 00:09:23.340
You'll see, right?


00:09:23.340 --> 00:09:24.780
See how much screaming


00:09:24.780 --> 00:09:26.880
What we didn't want to do was try and guess


00:09:26.880 --> 00:09:29.400
at what the problems were and build a compatibility layer


00:09:29.400 --> 00:09:30.520
that people didn't need.


00:09:30.520 --> 00:09:31.360
- Yeah, of course.


00:09:31.360 --> 00:09:32.960
- So that's why we're doing it this way.


00:09:32.960 --> 00:09:34.480
- Yeah, that makes a lot of sense.


00:09:34.480 --> 00:09:37.440
You want to go as minimal, backward,


00:09:37.440 --> 00:09:40.840
trying to fill those gaps as possible, right?


00:09:40.840 --> 00:09:42.040
- And if I'm brutal about it,


00:09:42.040 --> 00:09:45.080
if, in certain name of big bank that use pedantic locks


00:09:45.080 --> 00:09:47.120
and never engage with the open source community,


00:09:47.120 --> 00:09:50.320
get stung by this, they never paid me a penny,


00:09:50.320 --> 00:09:53.880
and they've never engaged, then I'm sorry for them,


00:09:53.880 --> 00:09:58.180
But I'm not as sorry as I would be if they had come and reported an issue and tried to


00:09:58.180 --> 00:09:59.180
help along the way.


00:09:59.180 --> 00:10:00.180
Yeah, yeah.


00:10:00.180 --> 00:10:03.100
Can we work with you to smooth this over?


00:10:03.100 --> 00:10:05.980
And worst case, pin it.


00:10:05.980 --> 00:10:09.700
The Bidanic equal equal 1.10.


00:10:09.700 --> 00:10:13.700
I think we'll carry on supporting critical security fixes for a year.


00:10:13.700 --> 00:10:14.700
Okay.


00:10:14.700 --> 00:10:16.580
So there's something of an LTS type of thing you're thinking?


00:10:16.580 --> 00:10:17.580
Yeah.


00:10:17.580 --> 00:10:18.580
For a while we have to, right?


00:10:18.580 --> 00:10:19.580
For a while.


00:10:19.580 --> 00:10:20.580
And yeah, we'll see.


00:10:20.580 --> 00:10:22.700
Look at the download numbers and play it by ear.


00:10:22.700 --> 00:10:23.700
Yeah.


00:10:23.700 --> 00:10:24.700
Cool.


00:10:24.700 --> 00:10:30.380
While we're talking about compatibility, if people are doing a lot of the overriding functions


00:10:30.380 --> 00:10:34.860
and stuff in their Pydanic models, what should they expect?


00:10:34.860 --> 00:10:36.620
Too many changes or pretty similar?


00:10:36.620 --> 00:10:41.980
One of the biggest changes is that the init method of a model is now no longer called


00:10:41.980 --> 00:10:45.820
unless you literally call init.


00:10:45.820 --> 00:10:52.300
So if you call model validate or if your model is nested inside another model, init is no


00:10:52.300 --> 00:10:58.020
longer called. The solution for that is to use a wrap validator or a model validator.


00:10:58.020 --> 00:11:01.620
But that's going to be one of the like pain points for people. But there's just, it turns


00:11:01.620 --> 00:11:06.020
out with the rust API, it's literally impossible without a massive performance hit to do that.


00:11:06.020 --> 00:11:08.860
Yeah, sure. Makes sense.


00:11:08.860 --> 00:11:15.360
Sebastian, you know, how's do you already have a roadmap? Have you already tried the


00:11:15.360 --> 00:11:22.100
alpha on FastAPI? Like what's the story for you guys? So like, yeah, yeah.


00:11:22.100 --> 00:11:24.740
John, we have actually been interacting a lot


00:11:24.740 --> 00:11:26.540
with what are the changes that are needed,


00:11:26.540 --> 00:11:27.620
like what is it going to be?


00:11:27.620 --> 00:11:31.220
And like someone was saying, I have a lot of code


00:11:31.220 --> 00:11:32.980
that is quite hacky.


00:11:32.980 --> 00:11:35.700
I was actually surprised it didn't break much.


00:11:35.700 --> 00:11:37.420
It just really worked.


00:11:37.420 --> 00:11:40.380
And it's for this particular use case


00:11:40.380 --> 00:11:42.700
where you can have like, they are so loud,


00:11:42.700 --> 00:11:44.380
they really want to tear us down.


00:11:44.380 --> 00:11:46.620
- I know, we might have to be really silent.


00:11:46.620 --> 00:11:48.340
But let's finish this up, yeah.


00:11:48.340 --> 00:11:49.180
- So--


00:11:49.180 --> 00:11:50.340
- It's like concentration challenges.


00:11:50.340 --> 00:11:52.180
(laughing)


00:11:52.180 --> 00:11:54.540
Validation error, can it concentrate?


00:11:54.540 --> 00:11:59.100
So, imagine this use case where you have user model


00:11:59.100 --> 00:12:02.380
and then this, you wanna return this user model,


00:12:02.380 --> 00:12:04.900
but then you have an authenticated user model


00:12:04.900 --> 00:12:08.620
as you were showing in the talk, in the PyCon talk.


00:12:08.620 --> 00:12:10.620
And then this authenticated user model


00:12:10.620 --> 00:12:12.500
has a field that is a password.


00:12:12.500 --> 00:12:17.500
If you return that use, the authenticated user directly,


00:12:17.700 --> 00:12:20.460
FastAPI does a lot of tricks to make sure


00:12:20.460 --> 00:12:22.900
that what you receive in the client side


00:12:22.900 --> 00:12:25.140
is the actual user without the password.


00:12:25.140 --> 00:12:26.260
That is the thing that you declared


00:12:26.260 --> 00:12:27.820
that we were going to return.


00:12:27.820 --> 00:12:30.420
But by default, if you don't do it through FastAPI,


00:12:30.420 --> 00:12:32.540
but you do it with just plain Pydantic,


00:12:32.540 --> 00:12:33.380
it will just check like,


00:12:33.380 --> 00:12:34.980
hey, is this an instance of the other?


00:12:34.980 --> 00:12:37.660
And then it will include the field.


00:12:37.660 --> 00:12:41.860
Because, you know, because in thinking about types,


00:12:41.860 --> 00:12:42.700
it makes sense.


00:12:42.700 --> 00:12:44.640
Like, oh, this is a subclass of that,


00:12:44.640 --> 00:12:46.340
so it makes sense that it's valid.


00:12:46.340 --> 00:12:48.300
But when you think about data in an API,


00:12:48.300 --> 00:12:50.340
it doesn't make sense that it will include more data


00:12:50.340 --> 00:12:51.500
than what it should.


00:12:51.500 --> 00:12:52.500
- Right, right, right.


00:12:52.500 --> 00:12:57.300
'Cause you don't wanna either have a mass injection attack


00:12:57.300 --> 00:13:01.500
on the inbound data or an over exposure on the way out.


00:13:01.500 --> 00:13:03.300
- You know, give away the password from users.


00:13:03.300 --> 00:13:04.700
- Is that bad?


00:13:04.700 --> 00:13:05.700
- I think it's pretty bad.


00:13:05.700 --> 00:13:07.500
- Okay, yeah, all right.


00:13:07.500 --> 00:13:10.900
- You know, for example, some months ago or years


00:13:10.900 --> 00:13:13.800
or something, I remember that the Kaggle API


00:13:13.800 --> 00:13:17.500
was returning some of the hashes of the experiments.


00:13:17.500 --> 00:13:22.140
So like, you know, it's a mistake,


00:13:22.140 --> 00:13:26.060
but it's sad that it could end up just filtering more data


00:13:26.060 --> 00:13:27.220
than what it should be returning.


00:13:27.220 --> 00:13:28.940
And it's something that can happen very easily.


00:13:28.940 --> 00:13:31.700
It can happen very easily to FastAPI applications


00:13:31.700 --> 00:13:35.080
if people don't specify what is the response model,


00:13:35.080 --> 00:13:36.260
the thing that they want to return,


00:13:36.260 --> 00:13:38.580
and they just return a bunch of data directly.


00:13:38.580 --> 00:13:41.940
So FastAPI does a lot of things to make sure


00:13:41.940 --> 00:13:44.540
that when you declare a response model


00:13:44.540 --> 00:13:47.500
that should filter this data, the data is filtered.


00:13:47.500 --> 00:13:50.620
But that's a lot of code in FastAPI to make it compatible.


00:13:50.620 --> 00:13:53.020
With the new Pydantic V2, that's gonna be


00:13:53.020 --> 00:13:56.900
pretty much transparent, so that's amazing.


00:13:56.900 --> 00:13:57.740
- That is amazing, yeah.


00:13:57.740 --> 00:13:59.260
- There's gonna be a bunch of things


00:13:59.260 --> 00:14:02.580
that require some refactoring and also making sure


00:14:02.580 --> 00:14:05.860
that the Pydantic V1 and V2 are compatible


00:14:05.860 --> 00:14:07.340
at the same time in some way


00:14:07.340 --> 00:14:09.740
so that people can have a migration path.


00:14:10.900 --> 00:14:15.100
But yeah, we have been making sure that all the things


00:14:15.100 --> 00:14:17.100
that need to be changed or that need to be updated,


00:14:17.100 --> 00:14:19.100
or all the things that need to be exposed


00:14:19.100 --> 00:14:21.300
from the Pydantic side are actually available.


00:14:21.300 --> 00:14:22.620
- Yeah, it's awesome that you guys are working


00:14:22.620 --> 00:14:23.460
so closely together on this.


00:14:23.460 --> 00:14:24.280
- Yeah, yeah, yeah.


00:14:24.280 --> 00:14:25.120
- I mean, it's gonna make it.


00:14:25.120 --> 00:14:27.060
- Yeah, absolutely.


00:14:27.060 --> 00:14:29.420
- In my mind, these two projects are pretty closely tied.


00:14:29.420 --> 00:14:32.500
I know that they're not, but that's a big use case.


00:14:32.500 --> 00:14:34.780
- Yeah, I think that's true, and we know that FastAPI


00:14:34.780 --> 00:14:39.020
is by far our biggest dependent, but also Django Ninja,


00:14:39.020 --> 00:14:40.820
which is, I think, now second or third,


00:14:40.820 --> 00:14:44.380
maybe third after SQL model by stars.


00:14:44.380 --> 00:14:47.260
Is like Vitaly who maintains that has been engaging a lot


00:14:47.260 --> 00:14:48.380
with us on V2.


00:14:48.380 --> 00:14:50.820
So yeah, lots of other projects are interested in it.


00:14:50.820 --> 00:14:53.080
And I think, yeah, lots of people will be able


00:14:53.080 --> 00:14:54.940
to remove messy code because of that problem.


00:14:54.940 --> 00:14:57.480
But yeah, like the invariance


00:14:57.480 --> 00:14:59.060
of the response interface problem.


00:14:59.060 --> 00:14:59.900
- That's fantastic.


00:14:59.900 --> 00:15:02.020
- Coming back to your previous question about.


00:15:02.020 --> 00:15:02.840
- Before you go to that,


00:15:02.840 --> 00:15:04.820
I think we should probably find out what do you think?


00:15:04.820 --> 00:15:05.660
- Yeah, I think you might be right.


00:15:05.660 --> 00:15:07.940
- Yeah, not even necessarily, I think the audio may be okay,


00:15:07.940 --> 00:15:09.180
but just for a concentration,


00:15:09.180 --> 00:15:10.780
It's very loud with the trucks around us.


00:15:10.780 --> 00:15:12.540
- I feel like I'm on the deck of that aircraft carrier


00:15:12.540 --> 00:15:13.380
as they throw things off the side.


00:15:13.380 --> 00:15:15.580
- Yeah, okay, let's pause this for a moment.


00:15:15.580 --> 00:15:16.740
We'll be back, hold on.


00:15:16.740 --> 00:15:22.620
So we have survived the disassembly.


00:15:22.620 --> 00:15:24.720
We have returned to continue.


00:15:24.720 --> 00:15:29.060
And I think we were talking about the integration


00:15:29.060 --> 00:15:32.500
of FastAPI and Pydantic, and that was really cool.


00:15:32.500 --> 00:15:35.740
I think something I'd like to kind of move to real quick


00:15:35.740 --> 00:15:39.240
is this big announcement, alpha of version two.


00:15:39.240 --> 00:15:40.780
Samuel, last time you were on the show,


00:15:40.780 --> 00:15:44.040
we spoke about the plan for version two,


00:15:44.040 --> 00:15:47.580
and now you're at least in an alpha stage.


00:15:47.580 --> 00:15:49.500
Tell people where we are with this.


00:15:49.500 --> 00:15:52.180
- Yeah, so we're, yeah, we've had two alphas,


00:15:52.180 --> 00:15:53.780
maybe three alphas now out.


00:15:53.780 --> 00:15:57.780
We're basically pretty close to a feature freeze,


00:15:57.780 --> 00:16:01.180
and the plan is to release the package,


00:16:01.180 --> 00:16:02.740
release the beta, and effectively,


00:16:02.740 --> 00:16:05.620
we hope that we can then release the full release,


00:16:05.620 --> 00:16:08.220
say two weeks after that, but there'll be bugs


00:16:08.220 --> 00:16:09.700
and we'll fix them and we'll have more betas,


00:16:09.700 --> 00:16:11.820
but effectively once we get to beta,


00:16:11.820 --> 00:16:13.860
the plan is that active development


00:16:13.860 --> 00:16:15.740
is stopping bar fixing bugs.


00:16:15.740 --> 00:16:17.780
- Now it's performance and bugs, right?


00:16:17.780 --> 00:16:19.660
- Yeah, and obviously one of the big things will be


00:16:19.660 --> 00:16:21.580
once that's out, there'll be a lot more work on say,


00:16:21.580 --> 00:16:24.380
FastAPI, Django Ninja, et cetera, et cetera,


00:16:24.380 --> 00:16:26.540
and that might come back with we really need this thing.


00:16:26.540 --> 00:16:29.180
Either this is broken or we really need that


00:16:29.180 --> 00:16:32.980
to reduce the overhead of upgrading.


00:16:32.980 --> 00:16:35.780
One of the things I did for Pydantic 1.10,


00:16:35.780 --> 00:16:37.620
which was super valuable in beta,


00:16:37.620 --> 00:16:42.300
was to go through packages that use Pydantic,


00:16:42.300 --> 00:16:43.460
initially sorting by star,


00:16:43.460 --> 00:16:45.400
but then looking at what they actually do


00:16:45.400 --> 00:16:46.780
and trying to upgrade them.


00:16:46.780 --> 00:16:48.620
And that found me a bunch of bugs


00:16:48.620 --> 00:16:50.820
in either libraries or in Pydantic.


00:16:50.820 --> 00:16:53.660
So we're not promising we're gonna go


00:16:53.660 --> 00:16:56.260
and upgrade the whole of GitHub to Pydantic 3.2,


00:16:56.260 --> 00:17:00.780
but we'll do a bit of that mostly to try and find bugs.


00:17:00.780 --> 00:17:01.980
One of the things that would be really useful


00:17:01.980 --> 00:17:05.720
is if anyone has an application that uses Pydantic,


00:17:05.720 --> 00:17:08.480
preferably without FastAPI or another library,


00:17:08.480 --> 00:17:10.160
that they would like help upgrading,


00:17:10.160 --> 00:17:12.080
we would love to come and help.


00:17:12.080 --> 00:17:15.720
And it might be a really powerful way of us, again,


00:17:15.720 --> 00:17:18.640
seeing the real pain points and identifying bugs


00:17:18.640 --> 00:17:20.400
before we get to v2.


00:17:20.400 --> 00:17:22.720
- Yeah, and I guess another thing to mention


00:17:22.720 --> 00:17:23.960
that is a real headline,


00:17:23.960 --> 00:17:26.040
and I also wanna get your thoughts on this, Sebastian,


00:17:26.040 --> 00:17:28.760
is the performance numbers, right?


00:17:28.760 --> 00:17:32.360
I mean, you put out some pretty impressive performance numbers,


00:17:32.360 --> 00:17:34.640
and Sebastian gets to piggyback on that, right?


00:17:34.640 --> 00:17:38.240
Yeah, I mean, yeah, I'm really proud of it, right?


00:17:38.240 --> 00:17:42.920
- Yeah, you should be. - I think to go in a change of release,


00:17:42.920 --> 00:17:47.520
in a bump of release, to be in the ballpark of 22 times faster,


00:17:47.520 --> 00:17:50.240
not 22%, but 22 times faster,


00:17:50.240 --> 00:17:52.720
I don't know of another package that's made an upgrade


00:17:52.720 --> 00:17:54.800
of that kind of order of magnitude.


00:17:54.800 --> 00:17:58.400
What's crazy is it's not numerical computing, right?


00:17:58.400 --> 00:17:59.240
It's general purpose.


00:17:59.240 --> 00:18:01.600
If you look at the example I gave in my talk earlier,


00:18:01.600 --> 00:18:05.160
it's a completely standard Pydantic model with four fields.


00:18:05.160 --> 00:18:07.960
And that's where we're seeing that kind of like


00:18:07.960 --> 00:18:08.960
22 times speed up.


00:18:08.960 --> 00:18:10.400
So I think it's gonna be massive.


00:18:10.400 --> 00:18:13.160
I have my own cynicism about people who hype


00:18:13.160 --> 00:18:16.000
about performance as being the most important thing.


00:18:16.000 --> 00:18:18.200
I don't think most applications,


00:18:18.200 --> 00:18:20.300
it's actually the thing that matters most.


00:18:20.300 --> 00:18:23.480
But I think it matters, A, it matters to everyone,


00:18:23.480 --> 00:18:25.600
and everyone wants it to go in the same direction.


00:18:25.600 --> 00:18:27.920
And two, it matters to the whole world


00:18:27.920 --> 00:18:31.820
and to the whole community that we effectively reduce the energy that we,


00:18:31.820 --> 00:18:35.520
that we consume like doing compute basically.


00:18:35.520 --> 00:18:35.760
Right.


00:18:35.760 --> 00:18:36.960
That's absolutely true.


00:18:36.960 --> 00:18:41.520
And also, even if people don't actually need it, there's a group of people


00:18:41.520 --> 00:18:44.240
who are like, well, I'm going to leave for go because it's not fast enough,


00:18:44.240 --> 00:18:46.080
or I can't do enough concurrency or whatever.


00:18:46.080 --> 00:18:50.880
And if they don't have that feeling, even if they didn't actually need


00:18:50.880 --> 00:18:53.640
that percentage increase, that's still really good for the Python community.


00:18:53.760 --> 00:18:58.400
Even me, I was saying I had a gigabyte of data from web analytics


00:18:58.400 --> 00:19:02.160
that I needed to load into a Polars data frame.


00:19:02.160 --> 00:19:06.280
And for that, I needed to A, extract some attributes from nested fields


00:19:06.280 --> 00:19:08.960
and B, parse dates and things like that.


00:19:08.960 --> 00:19:13.880
And I used Pylantic V2 and it was vastly faster with V2.


00:19:13.880 --> 00:19:21.480
It went from like twiddling your thumbs to it happens virtually instantly.


00:19:21.480 --> 00:19:24.480
- That's fantastic. - And that'll be even more true


00:19:24.480 --> 00:19:27.320
when you have an order of magnitude or two orders of magnitude more data.


00:19:27.320 --> 00:19:29.480
Yeah, for sure. Sebastian, how about you?


00:19:29.480 --> 00:19:31.480
What's the knock-on effect for FastAPI?


00:19:31.480 --> 00:19:34.480
So, I think one of the coolest things is that


00:19:34.480 --> 00:19:37.480
people won't have to change the code to get that performance benefit.


00:19:37.480 --> 00:19:40.480
It's just going to be like a bump, suddenly.


00:19:40.480 --> 00:19:44.480
And because of the new ways that Pydantic can handle the data,


00:19:44.480 --> 00:19:47.480
we're going to be able to-- there's something that needs to be done in FastAPI,


00:19:47.480 --> 00:19:53.800
FastAPI, but we're going to be able to let the parsing of the data, let it, let


00:19:53.800 --> 00:19:57.640
that Pydantic handle that in the Rust side. So Pydantic will be able to just


00:19:57.640 --> 00:20:03.720
read the JSON bytes instead of reading them in the Python side and let Pydantic


00:20:03.720 --> 00:20:07.080
do that and then Pydantic give the models back to the rest of the code of


00:20:07.080 --> 00:20:11.040
FastAPI. That alone will boost performance a lot, but the fact that it's


00:20:11.040 --> 00:20:16.120
being done in Rust, in the Rust side, it's just gonna be amazing. Yeah. Like one of


00:20:16.120 --> 00:20:20.620
there are things that I want to do that is on the plans is to let users define


00:20:20.620 --> 00:20:24.520
how they want to serialize data and not have like, this is just like by default


00:20:24.520 --> 00:20:28.460
is just like, I don't think models and like it converts automatically to Jason,


00:20:28.460 --> 00:20:33.520
but I want to allow users to decide how to serialize the objects and the data so


00:20:33.520 --> 00:20:36.040
that they can this quite like data classes or something like that.


00:20:36.040 --> 00:20:38.840
Or yeah, for example, they can say like, Oh, I don't want to serialize with the


00:20:38.840 --> 00:20:40.340
standard Jason serializer.


00:20:40.340 --> 00:20:45.160
I want to serialize with our Jason, which is like the I see rust based.


00:20:45.540 --> 00:20:46.980
- Ah, got it. - ...to serialization.


00:20:46.980 --> 00:20:50.280
Or they can say, like, "I want Pydantic to be the one that serializes this


00:20:50.280 --> 00:20:53.180
because I know that this is just a model that can handle that."


00:20:53.180 --> 00:20:56.180
They can also, like, and this is one of the things that I think is super cool,


00:20:56.180 --> 00:21:00.480
they can also create, they will be able to create a way to say,


00:21:00.480 --> 00:21:03.820
"I want to serialize this response to XML,"


00:21:03.820 --> 00:21:05.580
or something like that, or to YAML,


00:21:05.580 --> 00:21:08.080
and to let Pydantic handle the validation,


00:21:08.080 --> 00:21:11.240
but then, like, do the serialization in a way that they can customize the whole thing


00:21:11.240 --> 00:21:14.140
without having to do it directly in the code.


00:21:14.140 --> 00:21:16.560
Maybe even some of these crazy stream buffer


00:21:16.560 --> 00:21:18.560
- Yeah, yeah, yeah. - type of protocols.


00:21:18.560 --> 00:21:21.060
- Protocol buffers with gRPC, - Protocol, that's it.


00:21:21.060 --> 00:21:23.960
or even message pack, or a bunch of these things that


00:21:23.960 --> 00:21:27.460
there's no obvious way and there's no native way


00:21:27.460 --> 00:21:29.460
to have support for that, for reading the data


00:21:29.460 --> 00:21:33.660
and for exporting the data, and that's one of the things that I have in plans.


00:21:33.660 --> 00:21:36.660
I'm probably saying too much and then I'm going to account all of this.


00:21:36.660 --> 00:21:39.340
And now they're like, "You know what? You promised this.


00:21:39.340 --> 00:21:40.840
You did promise it."


00:21:40.840 --> 00:21:41.840
Well...


00:21:41.840 --> 00:21:43.840
Can I just come back on serialization for a minute?


00:21:43.840 --> 00:21:44.840
Yeah, please.


00:21:44.840 --> 00:21:45.840
Yeah, so what we've...


00:21:45.840 --> 00:21:49.840
I've worked from October,


00:21:49.840 --> 00:21:52.840
putting to one side the whole funding round in the middle of it,


00:21:52.840 --> 00:21:54.840
was working solidly on serialization.


00:21:54.840 --> 00:21:55.840
So we have...


00:21:55.840 --> 00:21:57.840
There's almost as much code in Pydantic Core now


00:21:57.840 --> 00:21:59.840
for serialization as there is for validation.


00:21:59.840 --> 00:22:00.840
Yeah, wow.


00:22:00.840 --> 00:22:04.840
We can serialize directly to JSON


00:22:04.840 --> 00:22:06.840
using the same underlying library that...


00:22:06.840 --> 00:22:08.840
or JSON uses, using Serdy.


00:22:08.840 --> 00:22:09.840
But one of...


00:22:09.840 --> 00:22:14.720
And also we can, you can customize how your serialization goes on a per field


00:22:14.720 --> 00:22:17.940
basis rather than on a per type basis, which is like incredibly powerful.


00:22:17.940 --> 00:22:21.740
But we also allow you to effectively serialize to Python.


00:22:21.740 --> 00:22:26.820
So not just what used to be the dict method, but basically do JSONable Python.


00:22:26.820 --> 00:22:30.900
So you effectively set the mode when serializing to Python to JSON, and you


00:22:30.900 --> 00:22:35.900
will only get the like, whatever it is, seven primitive JSON types in Python,


00:22:35.900 --> 00:22:39.020
which is super valuable if you want your output to be XML, because then you know


00:22:39.020 --> 00:22:46.020
your XML encoder only needs to take in dictionaries, lists, ints, floats, none, bool.


00:22:46.020 --> 00:22:47.020
Yeah.


00:22:47.020 --> 00:22:50.260
Rather than whatever complex data you have.


00:22:50.260 --> 00:22:54.980
So there's an, yeah, I'm like super proud of lots of the advantages of serialization.


00:22:54.980 --> 00:22:59.580
My 45 minute talk earlier, I was able to touch about half of the big new features, which


00:22:59.580 --> 00:23:02.340
kind of talks about quite how much has changed.


00:23:02.340 --> 00:23:05.220
Yeah, that's really exciting.


00:23:05.220 --> 00:23:07.660
I think we definitely, I was saying earlier,


00:23:07.660 --> 00:23:09.140
if I had known how long it was gonna take,


00:23:09.140 --> 00:23:10.900
I would never have set out on this journey.


00:23:10.900 --> 00:23:13.740
So the best thing about it is I didn't think


00:23:13.740 --> 00:23:14.660
about how long it was gonna take


00:23:14.660 --> 00:23:17.420
because we didn't try and do a bit more.


00:23:17.420 --> 00:23:19.900
We tried to do everything, or I tried to do everything.


00:23:19.900 --> 00:23:21.860
And that's how it's disadvantaged.


00:23:21.860 --> 00:23:23.660
It's taken longer than we had hoped, but here we are.


00:23:23.660 --> 00:23:24.980
- But here you are, you're pretty much here.


00:23:24.980 --> 00:23:26.780
That's really good, that's really good.


00:23:26.780 --> 00:23:29.220
And so when you think about performance,


00:23:29.220 --> 00:23:31.860
obviously the 22 times faster is awesome.


00:23:31.860 --> 00:23:34.180
The FastAPI speedup is awesome.


00:23:34.180 --> 00:23:39.880
But if you do something like SQL model and FastAPI or beanie and FastAPI,


00:23:39.880 --> 00:23:43.560
you're getting on both ends, you're getting that beanie or the


00:23:43.560 --> 00:23:47.740
identic than if it's with the beanie integration and the fast.


00:23:47.740 --> 00:23:50.920
So you, you kind of putting.


00:23:50.920 --> 00:23:53.660
Hydanek in both those layers.


00:23:53.660 --> 00:23:57.200
And so those speedups are like twice as good or something like that.


00:23:57.200 --> 00:23:57.580
Yeah.


00:23:57.580 --> 00:23:57.820
Right.


00:23:57.820 --> 00:24:00.760
I think you, well, they're probably yeah.


00:24:01.200 --> 00:24:04.280
They're the same relatively, but more in absolute terms.


00:24:04.280 --> 00:24:06.120
- Yeah. - Yeah, absolutely.


00:24:06.120 --> 00:24:07.920
- So yeah, I think it's,


00:24:07.920 --> 00:24:11.800
the fact that so many things have been built upon Pydanic


00:24:11.800 --> 00:24:14.280
means you've just sped up a bunch of projects


00:24:14.280 --> 00:24:16.120
without them doing too much.


00:24:16.120 --> 00:24:17.400
- Yeah, we get the win.


00:24:17.400 --> 00:24:19.880
It's like CPython itself getting faster helps everyone.


00:24:19.880 --> 00:24:21.280
This is like the next layer down,


00:24:21.280 --> 00:24:24.080
but as a dependency of lots of packages,


00:24:24.080 --> 00:24:26.160
we get to speed up lots of the community


00:24:26.160 --> 00:24:30.200
with one package, like one person devoting a year to it.


00:24:30.200 --> 00:24:32.200
Does this surprise you to see all these projects coming out?


00:24:32.200 --> 00:24:34.960
Here's another project based on Pydantic plus,


00:24:34.960 --> 00:24:36.560
you know, name your other thing that it's integrated with.


00:24:36.560 --> 00:24:38.840
- It's been crazy, particularly in the machine learning space


00:24:38.840 --> 00:24:41.840
where, you know, LangChain, who are one of the big names


00:24:41.840 --> 00:24:45.240
right now in these big language models,


00:24:45.240 --> 00:24:48.480
large language models, all based on Pydantic, right?


00:24:48.480 --> 00:24:49.320
- Yeah.


00:24:49.320 --> 00:24:50.480
- You were saying, I think on Twitter,


00:24:50.480 --> 00:24:54.600
that OpenAPI use a bunch of FastAPI, right?


00:24:54.600 --> 00:24:55.840
- OpenAI?


00:24:55.840 --> 00:24:57.880
- Sorry, yeah, OpenAI, not OpenAPI.


00:24:57.880 --> 00:24:59.320
(laughing)


00:24:59.320 --> 00:25:02.260
Marvin from, I think, from Prefect is built on Pydantic again.


00:25:02.260 --> 00:25:08.400
So like the wave of machine learning stuff seems to have leveraged Pydantic a


00:25:08.400 --> 00:25:10.720
whole lot, DockerA being another big example.


00:25:10.720 --> 00:25:11.620
Yeah.


00:25:11.620 --> 00:25:12.160
Yeah.


00:25:12.160 --> 00:25:12.700
It's amazing.


00:25:12.700 --> 00:25:15.360
Some for Elastic and some other things as well.


00:25:15.360 --> 00:25:21.760
So coming back to you, Sebastian, you know, I'm sure one of the big things


00:25:21.760 --> 00:25:25.040
you're thinking going forward with FastAPI is like, how do you guys work


00:25:25.040 --> 00:25:26.680
together and make this a seamless change?


00:25:26.680 --> 00:25:27.780
What else you got?


00:25:27.780 --> 00:25:29.040
What else are you working on?


00:25:29.040 --> 00:25:30.560
What else do you see in the future?


00:25:30.560 --> 00:25:32.560
- I have a bunch of things.


00:25:32.560 --> 00:25:33.840
- Are they secret or can you tell us?


00:25:33.840 --> 00:25:35.240
- No, no, I can tell.


00:25:35.240 --> 00:25:36.680
Most of it I can tell.


00:25:36.680 --> 00:25:40.120
I just feel the accountability.


00:25:40.120 --> 00:25:41.680
But I can tell.


00:25:41.680 --> 00:25:44.160
So I have a bunch of projects.


00:25:44.160 --> 00:25:46.440
The funny thing is that in some way


00:25:46.440 --> 00:25:48.080
it's kind of a dependency graph


00:25:48.080 --> 00:25:50.000
of things that I should work on.


00:25:50.000 --> 00:25:52.240
So for example, I have this project generator


00:25:52.240 --> 00:25:55.440
for FastAPI to generate a project with a SQL database.


00:25:57.160 --> 00:25:59.080
I haven't updated it in a long time,


00:25:59.080 --> 00:26:00.400
and it uses SQLAlchemy.


00:26:00.400 --> 00:26:04.080
I built SQL model for that project, to use it there.


00:26:04.080 --> 00:26:05.280
But I haven't updated it there,


00:26:05.280 --> 00:26:07.880
because first I want to upgrade more things in SQL model,


00:26:07.880 --> 00:26:09.800
I want to finish the documentation,


00:26:09.800 --> 00:26:11.460
finish the story about migration.


00:26:11.460 --> 00:26:13.280
But then for the story about migration,


00:26:13.280 --> 00:26:15.400
I need Typer for SQL model.


00:26:15.400 --> 00:26:17.240
So I need to update things in Typer.


00:26:17.240 --> 00:26:20.120
And then for Typer, I want to add support for annotated,


00:26:20.120 --> 00:26:21.600
which is actually one of the big things,


00:26:21.600 --> 00:26:23.960
one of the recent big things in FastAPI,


00:26:23.960 --> 00:26:26.360
is that now there's support for annotated.


00:26:26.360 --> 00:26:29.500
So, annotated is this feature from Python,


00:26:29.500 --> 00:26:31.680
it's like standard Python typings.


00:26:31.680 --> 00:26:35.640
You import from typings, import annotated,


00:26:35.640 --> 00:26:38.160
and then you can use that to emit information


00:26:38.160 --> 00:26:41.560
to the types that you define for parameters.


00:26:41.560 --> 00:26:42.520
- Like what, I haven't used this.


00:26:42.520 --> 00:26:43.880
I love typing, I use it all the time,


00:26:43.880 --> 00:26:45.720
and here I'm learning more about typing.


00:26:45.720 --> 00:26:49.240
- The thing is, it exists there in the standard library,


00:26:49.240 --> 00:26:53.600
but it doesn't have like a canonical use in Python itself.


00:26:53.600 --> 00:26:56.880
it's there mainly for FastAPI and Pydantic to use it.


00:26:56.880 --> 00:26:59.040
You know, like, it's just that, like,


00:26:59.040 --> 00:27:01.840
I hadn't pushed for that before.


00:27:01.840 --> 00:27:05.000
But the thing is, you import from typings,


00:27:05.000 --> 00:27:07.400
import annotated, and then you create a function


00:27:07.400 --> 00:27:08.880
that takes like a username,


00:27:08.880 --> 00:27:12.280
and then this function will normally be of type string.


00:27:12.280 --> 00:27:15.680
So it will be, the parameter of the function


00:27:15.680 --> 00:27:18.640
will be username colon str.


00:27:18.640 --> 00:27:22.280
Now you can say username colon annotated,


00:27:22.280 --> 00:27:24.720
and then open square brackets as if it was like a list


00:27:24.720 --> 00:27:25.760
or like a dict or something.


00:27:25.760 --> 00:27:27.720
Open square brackets and then the first thing


00:27:27.720 --> 00:27:29.580
that you put there, that's the actual type.


00:27:29.580 --> 00:27:31.120
So you will say annotated string.


00:27:31.120 --> 00:27:31.960
- Ah, okay.


00:27:31.960 --> 00:27:34.480
- And then you can pass additional metadata afterwards.


00:27:34.480 --> 00:27:36.320
And the additional metadata is the thing


00:27:36.320 --> 00:27:38.000
that you will use to tell FastAPI


00:27:38.000 --> 00:27:39.800
this should be extracted from the query parameters


00:27:39.800 --> 00:27:42.200
or from the cookies or from headers.


00:27:42.200 --> 00:27:44.560
Before, and like up to recently in FastAPI,


00:27:44.560 --> 00:27:46.440
the only way to do that was using


00:27:46.440 --> 00:27:48.200
the default value of the parameter.


00:27:48.200 --> 00:27:50.520
- Right, you would set the default to like a depends


00:27:50.520 --> 00:27:53.620
- Yeah, it depends, or equals a cookie,


00:27:53.620 --> 00:27:55.520
or equals header, or something like that.


00:27:55.520 --> 00:27:58.120
And then FastAPI can take the information from that


00:27:58.120 --> 00:28:00.020
to give you the data in your function.


00:28:00.020 --> 00:28:02.660
But the thing is, if you call that function manually


00:28:02.660 --> 00:28:06.140
somewhere else, the editor and Python won't complain


00:28:06.140 --> 00:28:08.580
that you are not passing some parameter that is required.


00:28:08.580 --> 00:28:10.620
And then you're gonna end up with some strange value


00:28:10.620 --> 00:28:12.460
internally that is just for FastAPI.


00:28:12.460 --> 00:28:14.660
- Right, or the type checker complains,


00:28:14.660 --> 00:28:15.980
you're not passing a depends, like,


00:28:15.980 --> 00:28:18.060
no, I'm passing a string, that's what it's supposed to be.


00:28:18.060 --> 00:28:19.700
But that's some weird thing. - Yeah, exactly.


00:28:19.700 --> 00:28:20.700
- Exactly. - Yeah, okay.


00:28:20.700 --> 00:28:22.580
- So for those cases, having annotated,


00:28:22.580 --> 00:28:24.620
like all the type is exactly what it is,


00:28:24.620 --> 00:28:25.820
and if it has a default value,


00:28:25.820 --> 00:28:26.980
is the actual default value,


00:28:26.980 --> 00:28:31.980
instead of like some strange internal concept in FastAPI.


00:28:31.980 --> 00:28:35.820
And having support for that allows having like


00:28:35.820 --> 00:28:38.780
much better support for typings, for editors,


00:28:38.780 --> 00:28:40.300
auto-completion, inline errors, all these things,


00:28:40.300 --> 00:28:42.860
reusing the same functions in other places.


00:28:42.860 --> 00:28:46.340
And it will also, having support for that in Typer


00:28:46.340 --> 00:28:48.620
will allow users to have the same function


00:28:48.620 --> 00:28:52.080
being used for FastAPI and Typer,


00:28:52.080 --> 00:28:53.860
having the custom metadata necessary


00:28:53.860 --> 00:28:56.700
for each one of the parameters for FastAPI and for Typer,


00:28:56.700 --> 00:28:57.540
and things like that.


00:28:57.540 --> 00:28:59.260
So it's something that is super powerful


00:28:59.260 --> 00:29:00.580
and super interesting.


00:29:00.580 --> 00:29:01.980
- I'm gonna come in on annotated


00:29:01.980 --> 00:29:03.260
'cause I'm excited about it too.


00:29:03.260 --> 00:29:05.260
So, Pydantic v2, we use annotated


00:29:05.260 --> 00:29:06.900
for all of our custom types.


00:29:06.900 --> 00:29:11.300
So for example, positive int type is just annotated of int,


00:29:11.300 --> 00:29:13.780
and then we use the annotated types package,


00:29:13.780 --> 00:29:17.540
which is some reusable metadata for annotated.


00:29:17.540 --> 00:29:21.500
So we would use, like, positive int is annotated of int,


00:29:21.500 --> 00:29:23.620
and then greater than zero.


00:29:23.620 --> 00:29:26.580
And what's even cooler is that will be used


00:29:26.580 --> 00:29:28.940
by Pydantic, of course.


00:29:28.940 --> 00:29:31.660
Hypothesis is gonna get support for that pretty soon,


00:29:31.660 --> 00:29:33.820
so it will only pass a positive value in


00:29:33.820 --> 00:29:36.280
if it sees greater than zero there.


00:29:36.280 --> 00:29:39.140
And then Typer, I guess, could,


00:29:39.140 --> 00:29:40.740
even if it's still based on click,


00:29:40.740 --> 00:29:42.580
it can go and take that greater than


00:29:42.580 --> 00:29:45.940
and infer it as, you know, must be greater than zero.


00:29:45.940 --> 00:29:47.940
So I think it was one of the things that


00:29:47.940 --> 00:29:52.820
typing guys when they first created Annotated


00:29:52.820 --> 00:29:55.060
hoped was gonna build a rich network of


00:29:55.060 --> 00:29:58.500
of libraries that interchanged metadata.


00:29:58.500 --> 00:30:00.100
It's taken a bit longer than they expected,


00:30:00.100 --> 00:30:01.620
but we're getting there.


00:30:01.620 --> 00:30:03.700
- I hear the two of you are kind of doing that a little bit,


00:30:03.700 --> 00:30:05.340
right, that's cool.


00:30:05.340 --> 00:30:06.180
That's really cool.


00:30:06.180 --> 00:30:07.780
One of the areas where I feel like typing


00:30:07.780 --> 00:30:11.940
is a little janky is on ORMs and ODMs,


00:30:11.940 --> 00:30:14.260
when you define a class, you say, for example,


00:30:14.260 --> 00:30:20.660
It's like a SQLAlchemy column, or it's a beanie column, or something like that.


00:30:20.660 --> 00:30:27.580
And the type is it's a string column, but really it's a string, it's not a string column.


00:30:27.580 --> 00:30:34.460
And so there's this weirdness of using types to kind of drive behavior.


00:30:34.460 --> 00:30:36.140
That's a perfect case for using annotated.


00:30:36.140 --> 00:30:37.380
That's what I was thinking, yeah.


00:30:37.380 --> 00:30:42.300
What it doesn't do is the other case where there is a context where you'd want to get


00:30:42.300 --> 00:30:46.300
the column object of some sort rather than the integer in a row.


00:30:46.300 --> 00:30:51.300
So it does mean two different things, the kind of dot objects in the Django context,


00:30:51.300 --> 00:30:52.300
but yeah, absolutely.


00:30:52.300 --> 00:30:55.300
It's there precisely to solve this kind of problem.


00:30:55.300 --> 00:30:59.300
And it's also because, like, currently, as far as I remember, there's no way--


00:30:59.300 --> 00:31:03.300
so the thing is that this is all based on something called descriptors,


00:31:03.300 --> 00:31:08.300
and is that when you call, like, I don't know, classUser.name,


00:31:08.300 --> 00:31:10.300
it's actually the attribute in the class,


00:31:10.300 --> 00:31:13.940
But when you create an instance of that user, and then say user.name,


00:31:13.940 --> 00:31:15.940
that is the attribute on the actual instance.


00:31:15.940 --> 00:31:19.100
And the way that these ODMs or ORMs or these things work


00:31:19.100 --> 00:31:22.380
is that they have a special way to say, like,


00:31:22.380 --> 00:31:24.940
when someone calls the actual class, this is a different thing


00:31:24.940 --> 00:31:27.740
than when someone calls an instance attribute.


00:31:27.740 --> 00:31:31.020
- Right. It's sort of two behaviors. - Yeah, yeah.


00:31:31.020 --> 00:31:33.740
And it's super powerful. That's how SQLAlchemy works.


00:31:33.740 --> 00:31:37.020
And it's super powerful because then, like, all the queries and all the stuff


00:31:37.020 --> 00:31:40.380
is actually consistent with how Python works.


00:31:40.380 --> 00:31:42.700
And you can say, "greater than or equals to,"


00:31:42.700 --> 00:31:44.540
using Python syntax, which is great.


00:31:44.540 --> 00:31:47.100
But then, currently, as far as I know,


00:31:47.100 --> 00:31:48.780
there's no way to define that


00:31:48.780 --> 00:31:50.460
with type annotations in a standard way.


00:31:50.460 --> 00:31:54.380
I think it's something that will probably be improvable,


00:31:54.380 --> 00:31:55.500
but I think there's currently no way.


00:31:55.500 --> 00:31:56.860
There will probably be a way at some point,


00:31:56.860 --> 00:32:00.220
but to be able to say, "Hey, this equalAlchemy column


00:32:00.220 --> 00:32:03.420
is a column when it's accessed at the class level,


00:32:03.420 --> 00:32:05.980
but this is going to be a string when it's accessed at the date."


00:32:05.980 --> 00:32:06.980
I like that.


00:32:06.980 --> 00:32:07.980
Instance level.


00:32:07.980 --> 00:32:09.660
A scope level in the annotated, you know.


00:32:09.660 --> 00:32:10.660
Yeah, yeah, yeah.


00:32:10.660 --> 00:32:11.660
The class that's this and this and this.


00:32:11.660 --> 00:32:12.660
Yeah.


00:32:12.660 --> 00:32:13.660
And the instance is that and that.


00:32:13.660 --> 00:32:14.660
Yeah, that's really interesting.


00:32:14.660 --> 00:32:19.260
While we're talking types, and I know you both are really big fans because it's such


00:32:19.260 --> 00:32:24.340
a central part of both your libraries, what do you want to see coming?


00:32:24.340 --> 00:32:28.020
It feels like this is an area of Python changing fast, but is there something like, if they


00:32:28.020 --> 00:32:29.020
could just...


00:32:29.020 --> 00:32:31.940
And I have another question on types, by the way, after that.


00:32:31.940 --> 00:32:32.940
Fire me.


00:32:32.940 --> 00:32:36.060
So I gave a talk at the typing summit,


00:32:36.060 --> 00:32:37.660
asking for certain things.


00:32:37.660 --> 00:32:39.540
So now we're gonna test my


00:32:39.540 --> 00:32:41.160
can I remember PEP numbers challenge,


00:32:41.160 --> 00:32:44.740
which I'm gonna fail in, but PEP 472,


00:32:44.740 --> 00:32:47.860
is that keyword args to,


00:32:47.860 --> 00:32:51.980
so one option would be to allow keyword arguments


00:32:51.980 --> 00:32:55.580
to get item, which would make annotated even more powerful


00:32:55.580 --> 00:32:57.140
because then you could use keyword arguments


00:32:57.140 --> 00:32:59.020
to describe the meaning of your metadata,


00:32:59.020 --> 00:33:01.500
rather than having to have these kind of identifier types


00:33:01.500 --> 00:33:02.780
like greater than.


00:33:02.780 --> 00:33:07.420
One of the big things that I hope we're gonna persuade,


00:33:07.420 --> 00:33:08.960
so I think one of the things that's happened recently


00:33:08.960 --> 00:33:11.660
is that everyone gets that runtime use of type hints


00:33:11.660 --> 00:33:12.540
is a legitimate thing.


00:33:12.540 --> 00:33:13.700
They might not wanna do it themselves,


00:33:13.700 --> 00:33:16.100
but they get that it's a legitimate thing to do.


00:33:16.100 --> 00:33:17.540
- How much pushback was there


00:33:17.540 --> 00:33:19.340
when you first came out with PyTandric there?


00:33:19.340 --> 00:33:21.140
- I think we were like the black sheep of Python.


00:33:21.140 --> 00:33:22.420
I was a black sheep of Python.


00:33:22.420 --> 00:33:23.500
- This is supposed to have no meaning.


00:33:23.500 --> 00:33:24.340
What are you doing?


00:33:24.340 --> 00:33:26.020
You're doing it wrong.


00:33:26.020 --> 00:33:27.740
- And I think nowadays that's changed


00:33:27.740 --> 00:33:29.100
and everyone gets it's a real thing.


00:33:29.100 --> 00:33:32.180
So for example, the hash of a union is independent


00:33:32.180 --> 00:33:35.300
of the order of the members of the union.


00:33:35.300 --> 00:33:38.740
That makes sense in the context of static typing


00:33:38.740 --> 00:33:41.260
where the union of int float is exactly the same


00:33:41.260 --> 00:33:43.140
as the union of float int.


00:33:43.140 --> 00:33:44.380
It turns out in static typing,


00:33:44.380 --> 00:33:46.180
particularly when you're doing coercion,


00:33:46.180 --> 00:33:48.940
there are some cases where that is not the case.


00:33:48.940 --> 00:33:51.500
And so it's really difficult right now


00:33:51.500 --> 00:33:54.900
that effectively when you, unions are fine on their own,


00:33:54.900 --> 00:33:57.100
but if you have a union say within a string,


00:33:58.660 --> 00:34:02.220
the capital string square brackets,


00:34:02.220 --> 00:34:03.860
it will, the order will be,


00:34:03.860 --> 00:34:07.100
match the order that the first time you called that,


00:34:07.100 --> 00:34:08.620
not what you actually called,


00:34:08.620 --> 00:34:11.340
unless you use lowercase string when it is the right order,


00:34:11.340 --> 00:34:12.860
except there's a PR open right now


00:34:12.860 --> 00:34:14.860
to break it on string too.


00:34:14.860 --> 00:34:16.820
So, string as well.


00:34:16.820 --> 00:34:20.240
So anyway, we are on lowercase list as well.


00:34:20.240 --> 00:34:23.500
Anyway, so things like that,


00:34:23.500 --> 00:34:24.980
where I do think that like,


00:34:24.980 --> 00:34:26.440
we'll see what happens on that particular case,


00:34:26.440 --> 00:34:31.000
but I feel like the voice of people doing runtime


00:34:31.000 --> 00:34:34.000
use of types, we're not the only people,


00:34:34.000 --> 00:34:35.720
are being heard better, and like, yeah,


00:34:35.720 --> 00:34:38.240
I think things are gonna continue to improve.


00:34:38.240 --> 00:34:40.800
- Yeah, there was a PEP that proposed an optimization


00:34:40.800 --> 00:34:44.400
for typing that kind of broke the runtime behaviors


00:34:44.400 --> 00:34:46.720
of it a little bit for both of y'all.


00:34:46.720 --> 00:34:48.360
- Yeah, it did in some edge cases,


00:34:48.360 --> 00:34:52.080
and that's gonna be fixed soon by the successor pep.


00:34:52.080 --> 00:34:55.080
Absolutely, so that's really good.


00:34:55.080 --> 00:34:59.920
Generic alias is another thing that like kills us internally in Pydantic.


00:34:59.920 --> 00:35:05.240
I won't go into all of the details of it, but yeah, we would, it seemed what the


00:35:05.240 --> 00:35:09.400
high level takeaway is that the typing community seemed happy with the idea that


00:35:09.400 --> 00:35:12.920
they might make a change to typing to make it easier for us.


00:35:12.920 --> 00:35:15.760
And I think that's also for, for the Pydantic team to engage better.


00:35:15.760 --> 00:35:18.880
And instead of spending ages, problem is right.


00:35:18.880 --> 00:35:23.160
Like you have a problem, you see a solution in typing, you submit the PR,


00:35:23.240 --> 00:35:25.720
even if it gets accepted in a week, which it won't,


00:35:25.720 --> 00:35:28.000
you wait five years before we can remove the code


00:35:28.000 --> 00:35:29.600
that deals with the other case.


00:35:29.600 --> 00:35:31.560
So it's very tempting not to engage with typing,


00:35:31.560 --> 00:35:33.600
but just go and write the work around


00:35:33.600 --> 00:35:35.200
where we should be better Python citizens


00:35:35.200 --> 00:35:36.800
and go and submit the PR to CPython


00:35:36.800 --> 00:35:38.480
to try and fix it properly.


00:35:38.480 --> 00:35:43.080
- Yeah, what's your wishlist for typing?


00:35:43.080 --> 00:35:45.400
- So, well, the first thing is like this thing


00:35:45.400 --> 00:35:46.600
that I have been trying to work on


00:35:46.600 --> 00:35:49.080
and like trying to do to have like better ways


00:35:49.080 --> 00:35:50.640
to do documentation of the APIs


00:35:50.640 --> 00:35:53.300
that's also related to typing and to the annotations.


00:35:53.300 --> 00:35:55.400
Like, let's see if I can pull it off.


00:35:55.400 --> 00:35:57.940
The other thing is like, it's actually not that necessarily


00:35:57.940 --> 00:36:00.140
that related to the things that we have been talking about,


00:36:00.140 --> 00:36:04.020
but it's quite relevant for the data science


00:36:04.020 --> 00:36:06.080
and machine learning community.


00:36:06.080 --> 00:36:09.660
That is that there are many, many APIs for many libraries


00:36:09.660 --> 00:36:13.040
that decorate in some way, some function,


00:36:13.040 --> 00:36:16.500
and then the function is expected to give some types


00:36:16.500 --> 00:36:18.960
of values to the body of the function internally,


00:36:18.960 --> 00:36:22.660
but to be able to receive different types of values.


00:36:22.660 --> 00:36:26.060
That sounds a bit abstract, but that's the core idea


00:36:26.060 --> 00:36:29.980
that is replicated across several libraries.


00:36:29.980 --> 00:36:31.660
And this will apply, for example,


00:36:31.660 --> 00:36:33.420
to Ray, the distributed machine learning


00:36:33.420 --> 00:36:37.260
or computing system, to Dask, to, I think,


00:36:37.260 --> 00:36:38.820
Dagster also uses something like that,


00:36:38.820 --> 00:36:42.140
Monad, this system for deploying workloads


00:36:42.140 --> 00:36:43.540
and machine learning, and a thing like that


00:36:43.540 --> 00:36:45.260
also uses these types of ideas.


00:36:45.260 --> 00:36:47.900
So there are many of these libraries


00:36:47.900 --> 00:36:52.140
that the way that they are designed is that you create some function,


00:36:52.140 --> 00:36:55.900
and then you're going to tell something to call this function,


00:36:55.900 --> 00:36:59.400
and then in the function you say, "I want to expect this value,"


00:36:59.400 --> 00:37:02.400
and instead of you calling all the functions that will generate that value,


00:37:02.400 --> 00:37:06.400
you tell it, "Hey, distributed system blah blah blah,


00:37:06.400 --> 00:37:09.040
give me this value, execute this for me."


00:37:09.040 --> 00:37:13.100
But that means that you will have or no type annotations,


00:37:13.100 --> 00:37:16.640
or invalid type annotations, or red squiggly lines in some places,


00:37:16.640 --> 00:37:20.040
or no autocompletion or autocompletion for the wrong things,


00:37:20.040 --> 00:37:24.540
just because there's currently no way to define this specific thing of saying,


00:37:24.540 --> 00:37:27.580
"Hey, this function, after being decorated,


00:37:27.580 --> 00:37:30.640
is going to be able to receive a different type


00:37:30.640 --> 00:37:33.580
than what it's going to give to internal."


00:37:33.580 --> 00:37:35.340
So I think that's something that,


00:37:35.340 --> 00:37:38.440
and it's probably quite challenging and a big thing to tackle,


00:37:38.440 --> 00:37:41.640
but it's something that is replicated across several libraries,


00:37:41.640 --> 00:37:45.840
in particular for these things that do distributed processing of data.


00:37:45.840 --> 00:37:49.200
I think that's something that will be great to improve.


00:37:49.200 --> 00:37:52.400
Does paramspec fix some of that?


00:37:52.400 --> 00:38:00.360
It's very close, but the paramspec only does it for being able to sort of copy


00:38:00.360 --> 00:38:02.600
the params that come from one function to another.


00:38:02.600 --> 00:38:06.000
And actually, I use all that, for example, for asynchro and for other things


00:38:06.000 --> 00:38:10.480
to be able to get auto-completion for the decorated function


00:38:10.480 --> 00:38:13.320
or for the generated function or things like that.


00:38:13.320 --> 00:38:17.980
And the change will probably be somewhere around paramSpec


00:38:17.980 --> 00:38:20.980
to be able to say, not just the paramSpec,


00:38:20.980 --> 00:38:25.420
but this function will not only have the paramSpec,


00:38:25.420 --> 00:38:29.960
but will receive a modification like this of the parameters.


00:38:29.960 --> 00:38:31.960
Almost making paramSpec generic.


00:38:31.960 --> 00:38:36.360
All right.


00:38:36.360 --> 00:38:37.860
One more typing question.


00:38:37.860 --> 00:38:41.660
Do you all think typing is going too far with the generic stuff?


00:38:41.660 --> 00:38:45.160
and is it going too much like C++ and C# and Java,


00:38:45.160 --> 00:38:48.340
or is it still good?


00:38:48.340 --> 00:38:52.880
I think the way Python is growing is super interesting


00:38:52.880 --> 00:38:56.760
because we all have to agree that Python 3.12


00:38:56.760 --> 00:38:58.960
is not the same Python 2.7.


00:38:58.960 --> 00:39:01.760
- Yeah. - It's quite different.


00:39:01.760 --> 00:39:03.260
And I think it's different in a good way.


00:39:03.260 --> 00:39:08.760
The users are different and the focus of the runtime is different.


00:39:08.760 --> 00:39:11.220
And the things that we can do with types now,


00:39:11.220 --> 00:39:15.900
and the fact that in Python, we can access these types at runtime,


00:39:15.900 --> 00:39:20.140
which means, I don't know, I was always confused with the term "runtime."


00:39:20.140 --> 00:39:21.440
It's like, "What does that mean?"


00:39:21.440 --> 00:39:23.440
I think when you execute Python,


00:39:23.440 --> 00:39:26.980
the same Python code can inspect and see what are those types.


00:39:26.980 --> 00:39:28.560
That's what FastAPI and Python do.


00:39:28.560 --> 00:39:30.560
It's just seeing what are those types.


00:39:30.560 --> 00:39:31.780
We can do that in Python.


00:39:31.780 --> 00:39:34.900
You cannot do that in things like TypeScript,


00:39:34.900 --> 00:39:36.120
or you cannot do it in Java.


00:39:36.120 --> 00:39:37.580
You cannot do it in many other languages,


00:39:37.580 --> 00:39:39.460
get access to this typing information


00:39:39.460 --> 00:39:42.620
to be able to do additional things with that, like validation,


00:39:42.620 --> 00:39:45.260
data serialization, documentation, all that stuff.


00:39:45.260 --> 00:39:48.860
So I think that's, to start, that's super powerful in Python.


00:39:48.860 --> 00:39:54.700
The language in Python for typings is not as powerful as, for example, TypeScript.


00:39:54.700 --> 00:39:57.820
There is just like so much stuff that you can do with that.


00:39:57.820 --> 00:40:01.140
Nevertheless, I feel that in Python, it's just like,


00:40:01.140 --> 00:40:03.860
it's growing and it's growing organically.


00:40:03.860 --> 00:40:05.740
And like, we have growing pains, you know?


00:40:05.740 --> 00:40:07.020
Like, there are some things that are like,


00:40:07.020 --> 00:40:11.820
"Oh, this little thing here is slightly incorrectly named."


00:40:11.820 --> 00:40:15.820
But like, now there's a better way to do that in Python 3.10,


00:40:15.820 --> 00:40:19.020
so we don't care much about that slightly incorrect name,


00:40:19.020 --> 00:40:20.180
things like that.


00:40:20.180 --> 00:40:22.420
- Yeah, I feel like there's some tensions of people


00:40:22.420 --> 00:40:23.940
who are on the mypy side,


00:40:23.940 --> 00:40:26.180
and they want perfect validation of,


00:40:26.180 --> 00:40:28.340
"I want to prove my code hangs together


00:40:28.340 --> 00:40:30.220
"like a static compiler."


00:40:30.220 --> 00:40:32.480
And folks like you all, who are like,


00:40:32.480 --> 00:40:35.920
"We want to leverage typing to make it behave


00:40:35.920 --> 00:40:40.640
in interesting ways. And maybe that behavior expression doesn't exactly match what it looks


00:40:40.640 --> 00:40:46.640
statically like, but it is, everybody wants it, but it's, it's might trip up my pie. And I feel


00:40:46.640 --> 00:40:49.440
like there's this tension between those two things. That's kind of what I was thinking.


00:40:49.440 --> 00:40:56.320
I think there's a little bit of that, but at the same time, there's, is much less than you could


00:40:56.320 --> 00:41:01.680
imagine. There are so many people that are so close to, you know, core my pie and these things


00:41:01.680 --> 00:41:04.480
that are actually very excited about the things that we are doing.


00:41:04.480 --> 00:41:08.800
So, you know, it's actually quite friendly, all the communication.


00:41:08.800 --> 00:41:13.120
It's just that there are some people that just don't really care about runtime types,


00:41:13.120 --> 00:41:13.760
and that's fine.


00:41:13.760 --> 00:41:21.760
But I feel like it's much more closer together and much more stronger, the relationship, I think.


00:41:21.760 --> 00:41:22.880
Yeah, yeah, it's great.


00:41:22.880 --> 00:41:24.880
Yeah, I think actually we've gone in the...


00:41:24.880 --> 00:41:28.240
Typing's got better for someone who's not...


00:41:28.240 --> 00:41:31.440
Like, it's actually got less verbose, cleaner, easier to understand.


00:41:31.440 --> 00:41:33.540
and you don't have to import union,


00:41:33.540 --> 00:41:34.880
you can do pipe operator.


00:41:34.880 --> 00:41:37.180
You don't have to import list from typing,


00:41:37.180 --> 00:41:39.760
you can use list, which makes complete sense.


00:41:39.760 --> 00:41:41.380
Any is an unfortunate one,


00:41:41.380 --> 00:41:44.720
but I also understand why the any function,


00:41:44.720 --> 00:41:45.560
it would not make sense for the any function to be--


00:41:45.560 --> 00:41:48.320
- 'Cause I give up, I can't deal with this part, so yeah.


00:41:48.320 --> 00:41:51.760
- No, in general, I think it's got much better.


00:41:51.760 --> 00:41:55.040
I do think that the interchange between runtime,


00:41:55.040 --> 00:41:58.520
so there's a PEP open now to add to data class transforms,


00:41:58.520 --> 00:42:00.600
a converter function.


00:42:00.600 --> 00:42:06.860
I forget exactly how it works, but I think that is awareness in the static typing space


00:42:06.860 --> 00:42:11.600
that data gets converted when you construct something that looks like a data class.


00:42:11.600 --> 00:42:14.000
So no, I think it's really positive.


00:42:14.000 --> 00:42:18.680
I think we're incredibly lucky that we're, like I say, TypeScript is the other, in some


00:42:18.680 --> 00:42:23.060
ways the best untyped language typing system.


00:42:23.060 --> 00:42:26.320
But the fact that they're not available at runtime means we're killing it, I think.


00:42:26.320 --> 00:42:28.820
I spoke to someone who maintains a library


00:42:28.820 --> 00:42:32.360
that does type analysis at runtime in TypeScript,


00:42:32.360 --> 00:42:35.280
and all his types are strings.


00:42:35.280 --> 00:42:37.820
And they're valid TypeScript, but they're strings.


00:42:37.820 --> 00:42:39.780
And that's, you know,


00:42:39.780 --> 00:42:41.940
he was saying that doesn't matter and it's all fine.


00:42:41.940 --> 00:42:44.740
I tend to feel like it probably does a bit.


00:42:44.740 --> 00:42:46.740
We're really lucky to have them at runtime.


00:42:46.740 --> 00:42:47.820
Then you go to the other end


00:42:47.820 --> 00:42:49.400
where I've been writing a lot of Rust.


00:42:49.400 --> 00:42:51.520
I am like, Rust's great, it has many advances,


00:42:51.520 --> 00:42:53.200
but if you want to just get something done


00:42:53.200 --> 00:42:55.820
and not have to think too hard about what the types are,


00:42:55.820 --> 00:42:56.480
It's really nice.


00:42:56.480 --> 00:42:59.960
I write a lot of Python is untyped when I'm just trying to get something to, something to work.


00:42:59.960 --> 00:43:03.980
I'm not a, like everything must have a type on it kind of person.


00:43:03.980 --> 00:43:08.420
So no, I think we're in a really great place and I think most of the


00:43:08.420 --> 00:43:10.380
advantages are actually cleaning it up.


00:43:10.380 --> 00:43:21.740
So the new six something, six 49, the new generics syntax to me, 695.


00:43:24.920 --> 00:43:26.460
- There are two types of people in the world.


00:43:26.460 --> 00:43:27.920
There are people who know the names of their,


00:43:27.920 --> 00:43:31.160
numbers of their peps, and there's everyone saying.


00:43:31.160 --> 00:43:37.260
That for me cleans up generics, right?


00:43:37.260 --> 00:43:39.200
Yes, it's a fundamental change to the language.


00:43:39.200 --> 00:43:41.400
Yes, it makes the syntax of a function


00:43:41.400 --> 00:43:43.480
look a bit more like Rust or something,


00:43:43.480 --> 00:43:46.780
but if you look at it independently of our experience,


00:43:46.780 --> 00:43:50.280
it's a heck of a lot more elegant than importing Typefra.


00:43:50.280 --> 00:43:51.460
- All right, yeah, yeah.


00:43:51.460 --> 00:43:54.840
Let me ask you one that's purely theoretical,


00:43:54.840 --> 00:43:59.880
I don't think it'll get adopted, but we have int pipe none, we have optional of int.


00:43:59.880 --> 00:44:06.280
A lot of languages have question mark for nullable types. Like it could be int. You


00:44:06.280 --> 00:44:10.440
can even say like int. I'm not sure. Is it an int? It could be an int. It might be nullable.


00:44:10.440 --> 00:44:14.360
I don't know. Right? Or use int. It's an int. You just know. There's no question mark.


00:44:14.360 --> 00:44:19.720
And those types, what are your thoughts about like null collissing, you don't care?


00:44:19.720 --> 00:44:24.520
- I'm really happy with the new situation and not having the optional that isn't optional.


00:44:24.520 --> 00:44:27.600
That's been a problem for a long time, so not needing to use optional


00:44:27.600 --> 00:44:31.600
is being able to use pipe none is great.


00:44:31.600 --> 00:44:36.080
I actually think one of the things that's going to happen,


00:44:36.080 --> 00:44:39.800
particularly with the advent of the match syntax


00:44:39.800 --> 00:44:41.800
and with increased use of type dict,


00:44:41.800 --> 00:44:44.600
we're going to need a new union type


00:44:44.600 --> 00:44:47.400
that operates much more like an enum in Rust.


00:44:47.400 --> 00:44:51.800
So basically a union that keeps track of which member of the enum


00:44:51.800 --> 00:44:54.040
you have an instance of.


00:44:54.040 --> 00:44:59.000
I keep meaning to build a like package to demonstrate what I mean and I haven't got around to it


00:44:59.000 --> 00:45:03.160
But like if you have a union of type dicts, which is a legitimate thing to do


00:45:03.160 --> 00:45:08.520
It's effectively impossible without starting to do effectively validation to work out which member you're on


00:45:08.520 --> 00:45:13.320
So I think we need and it would be really neat if you could use a match expression to process each


00:45:13.320 --> 00:45:17.520
Branch of your union Sebastian


00:45:17.520 --> 00:45:22.640
You already say there


00:45:23.120 --> 00:45:26.480
No, but like, you know, like I feel that way.


00:45:26.480 --> 00:45:28.880
I was saying that like, I feel Python is just like growing


00:45:28.880 --> 00:45:31.080
and like the typing system is growing.


00:45:31.080 --> 00:45:32.960
I feel it's growing in a very healthy way


00:45:32.960 --> 00:45:37.240
because it's not, you know, it's not like just some academics


00:45:37.240 --> 00:45:39.480
hidden in some corner somewhere saying like,


00:45:39.480 --> 00:45:40.320
this is how it should be done.


00:45:40.320 --> 00:45:43.080
- I did my thesis on this type system and here we are.


00:45:43.080 --> 00:45:44.640
- And then like everyone should just use it.


00:45:44.640 --> 00:45:47.960
It's just like a lot of hearing everyone


00:45:47.960 --> 00:45:49.840
and just receiving the feedback from everyone


00:45:49.840 --> 00:45:52.360
and just like growing in the ways that it should grow.


00:45:52.360 --> 00:45:57.240
I think that's amazing. I think like we are, you know, it's like a kind of Renaissance,


00:45:57.240 --> 00:46:01.320
the health of like typing in Python and like how we can build all these things. I think that's


00:46:01.320 --> 00:46:05.560
amazing. I think it absolutely is. I think we're pretty much out of time. We've used up all the


00:46:05.560 --> 00:46:10.920
various places we've escaped to at a shutting down conference here. Final question for you both,


00:46:10.920 --> 00:46:14.520
just, you know, what's your big takeaway? What's the experience like here at PyCon? Like, how's it


00:46:14.520 --> 00:46:21.240
been 2023? For me, it's been amazing. It's my first PyCon in the US. Oh, it is? Yeah. Like I


00:46:21.240 --> 00:46:23.000
I have never been in a PyCon in the US.


00:46:23.000 --> 00:46:26.240
I have been in PyCons in many other places, but not in the US.


00:46:26.240 --> 00:46:31.920
And I got to put faces to so many handles in Twitter and GitHub.


00:46:31.920 --> 00:46:33.440
I got to meet you in person.


00:46:33.440 --> 00:46:34.080
That's amazing.


00:46:34.080 --> 00:46:34.960
- Wow, that's great.


00:46:34.960 --> 00:46:38.200
- And a bunch of other people that I only knew,


00:46:38.200 --> 00:46:40.400
just on the internet, a bunch of core developers.


00:46:40.400 --> 00:46:41.440
And that's so cool.


00:46:41.440 --> 00:46:42.240
They are so cool.


00:46:42.240 --> 00:46:45.720
I knew they were super cool, but just talking on Twitter


00:46:45.720 --> 00:46:48.360
and then seeing them in person, that's amazing.


00:46:48.360 --> 00:46:50.360
- It's my favorite part of the whole conference,


00:46:50.360 --> 00:46:53.520
It's just the people and getting together.


00:46:53.520 --> 00:46:54.360
- Definitely.


00:46:54.360 --> 00:46:57.600
I think I attended like two talks.


00:46:57.600 --> 00:46:58.440
- Yeah, yeah.


00:46:58.440 --> 00:47:00.800
- I was just on the hallways talking to everyone.


00:47:00.800 --> 00:47:01.800
- You feel the hallway traffic.


00:47:01.800 --> 00:47:04.400
- Yeah, yeah, I was all the way on the hallway traffic.


00:47:04.400 --> 00:47:05.920
- Awesome, well that's great.


00:47:05.920 --> 00:47:07.000
- Yeah, I absolutely love it.


00:47:07.000 --> 00:47:09.280
I remember Sebastian and I joined the Language Summit


00:47:09.280 --> 00:47:11.960
remotely two years ago, the year when there was no PyCon.


00:47:11.960 --> 00:47:14.920
And the most interesting bit of the like four hour Zoom call


00:47:14.920 --> 00:47:17.520
was the five minutes between talks when people just chatted.


00:47:17.520 --> 00:47:20.200
And I remember then thinking how cool PyCon must be


00:47:20.200 --> 00:47:24.080
to have that same group of people in a room rather than on a Zoom call.


00:47:24.080 --> 00:47:27.760
So, no, I love it. I think it's... I've really enjoyed it.


00:47:27.760 --> 00:47:30.080
Last year was my first year. This year is even more fun.


00:47:30.080 --> 00:47:31.000
Yeah, I really enjoy it.


00:47:31.000 --> 00:47:32.800
Awesome. Yeah, it's been great to meet you both in person.


00:47:32.800 --> 00:47:34.280
Of course, meeting you has been the best bit of all of it.


00:47:34.280 --> 00:47:35.400
Oh, thank you very much. No, no.


00:47:35.400 --> 00:47:37.880
It's been really great to spend some time with you all here.


00:47:37.880 --> 00:47:41.760
Thanks for coming on the podcast, part two now here to wrap things up.


00:47:41.760 --> 00:47:43.400
So, thanks for taking the time.


00:47:43.400 --> 00:47:45.600
And congrats both on the success of your projects.


00:47:45.600 --> 00:47:46.600
They're amazing.


00:47:46.600 --> 00:47:47.600
Thanks so much.


00:47:47.600 --> 00:47:49.000
Thank you very much. Thanks for having us.


00:47:49.000 --> 00:47:50.000
Thanks for seeing us.


00:47:50.000 --> 00:47:51.000
Yeah, bye guys.

