WEBVTT

00:00:00.000 --> 00:00:02.000
>> Hello, hello.


00:00:02.000 --> 00:00:04.000
Hey, Jesse.


00:00:04.000 --> 00:00:06.000
>> Hey, Michael.


00:00:06.000 --> 00:00:08.000
>> Great to have you here on the show.


00:00:08.000 --> 00:00:10.000
Welcome back to Talk Python to Me.


00:00:10.000 --> 00:00:12.000
>> Thanks a lot.


00:00:12.000 --> 00:00:14.000
>> Yeah, it has been a little while since you were on the show.


00:00:14.000 --> 00:00:16.000
You were the second guest ever.


00:00:16.000 --> 00:00:18.000
How about that?


00:00:18.000 --> 00:00:20.000
How cool is that?


00:00:20.000 --> 00:00:22.000
>> That's really cool.


00:00:22.000 --> 00:00:24.000
I knew it was a while ago.


00:00:24.000 --> 00:00:26.000
I think it was 2015.


00:00:26.000 --> 00:00:28.000
And we were talking about Python and MongoDB, which is a natural


00:00:28.000 --> 00:00:33.360
is a natural subject, but I didn't know it was so early in your career.


00:00:33.360 --> 00:00:36.840
Yeah, it was-- you really helped launch the podcast, so thanks for that.


00:00:36.840 --> 00:00:40.080
And then you also did a really popular episode


00:00:40.080 --> 00:00:42.880
about writing an excellent programming blog.


00:00:42.880 --> 00:00:46.840
And we talked about fun things like design patterns


00:00:46.840 --> 00:00:48.760
of writing for technical writing.


00:00:48.760 --> 00:00:50.000
That was really well received.


00:00:50.000 --> 00:00:56.560
So yeah, excellent to have you back.


00:00:56.560 --> 00:01:01.200
we're going to make it a little bit more modern than just five,


00:01:01.200 --> 00:01:02.600
six years ago, whatever that was.


00:01:02.600 --> 00:01:04.400
Yeah.


00:01:04.400 --> 00:01:04.900
Cool.


00:01:04.900 --> 00:01:06.400
So what have you been up to?


00:01:06.400 --> 00:01:09.040
Give us maybe a quick intro for people who don't know you


00:01:09.040 --> 00:01:12.680
and catch up on what you've been up to since then.


00:01:12.680 --> 00:01:16.840
Yeah, so you and I met because when I joined MongoDB


00:01:16.840 --> 00:01:22.200
around 2011, I was the Python evangelist, which is still


00:01:22.200 --> 00:01:25.600
my favorite job title of all time.


00:01:25.600 --> 00:01:32.680
And still at MongoDB, and I've been doing various sorts of engineering the whole time,


00:01:32.680 --> 00:01:41.680
I switched over to doing C and C++ and moved from doing Python client library work,


00:01:41.680 --> 00:01:47.640
I had been working on PyMongo, to working on the core MongoDB server,


00:01:47.640 --> 00:01:53.920
and helped develop the first version of serverless MongoDB,


00:01:53.920 --> 00:01:55.680
which is pay-as-you-go.


00:01:55.680 --> 00:02:01.080
And now I'm a researcher with MongoDB Labs,


00:02:01.080 --> 00:02:04.640
which is our tiny little research organization.


00:02:04.640 --> 00:02:09.920
And I'm looking at new products, cutting-edge techniques


00:02:09.920 --> 00:02:13.960
that we might want to adopt at MongoDB.


00:02:13.960 --> 00:02:16.320
All of those things sound super awesome.


00:02:16.320 --> 00:02:19.440
Maybe take them in order if I remember the right.


00:02:19.440 --> 00:02:21.840
So you worked on PyMongo, which is,


00:02:21.840 --> 00:02:23.440
if people use MongoDB at all,


00:02:23.440 --> 00:02:27.440
they basically either use PyMongo or Motor, right?


00:02:27.440 --> 00:02:28.600
- Right.


00:02:28.600 --> 00:02:29.720
- And did you also work on Motor?


00:02:29.720 --> 00:02:30.960
You did, right?


00:02:30.960 --> 00:02:35.960
- Yeah, I invented Motor and came up with the cute name.


00:02:35.960 --> 00:02:44.160
At the time, Tornado was the,


00:02:44.160 --> 00:02:49.160
the one of the major asynchronous Python servers.


00:02:49.160 --> 00:02:52.040
- Very ahead of its time in that sense.


00:02:52.040 --> 00:02:54.240
There's, you know, way before async and await


00:02:54.240 --> 00:02:56.440
and asyncio and all those things.


00:02:56.440 --> 00:02:57.280
- Yeah, that's right.


00:02:57.280 --> 00:02:58.760
It was extremely influential.


00:02:58.760 --> 00:03:03.760
And I wanted PyMongo to work well with Tornado.


00:03:03.760 --> 00:03:09.800
So I came up with this very complicated way


00:03:09.800 --> 00:03:12.760
to sort of asynchronize PyMongo


00:03:12.760 --> 00:03:15.400
and make it work with Tornado.


00:03:15.400 --> 00:03:20.100
And I combined Mongo with Tornado to come up with Motor.


00:03:20.100 --> 00:03:26.580
And it's still maintained, but not by me.


00:03:26.580 --> 00:03:29.800
And it's a good choice if you are,


00:03:29.800 --> 00:03:33.080
if you want that asynchronous API,


00:03:33.080 --> 00:03:34.780
it now supports async and await,


00:03:34.780 --> 00:03:38.460
and it now works with asyncio as well as Tornado.


00:03:38.460 --> 00:03:41.500
So if you have some reason for wanting


00:03:41.500 --> 00:03:43.300
to do async Python already,


00:03:43.300 --> 00:03:44.900
and then you want to connect to MongoDB


00:03:44.900 --> 00:03:47.900
without fear of blocking your application,


00:03:47.900 --> 00:03:52.140
then motor is the driver of choice.


00:03:52.140 --> 00:03:53.260
- Yeah, absolutely.


00:03:53.260 --> 00:03:54.940
And much like if you're using,


00:03:54.940 --> 00:03:57.300
if you're doing synchronous MongoDB stuff in Python,


00:03:57.300 --> 00:03:58.860
chances are using PyMongo.


00:03:58.860 --> 00:04:01.380
If you're doing async stuff, you're probably using motor.


00:04:01.380 --> 00:04:03.500
For example, the website you're looking at here


00:04:03.500 --> 00:04:06.380
is backed by MongoDB, that is top Python.


00:04:06.380 --> 00:04:09.580
And it uses Beanie,


00:04:09.580 --> 00:04:13.740
which does basically Pydantic and Async and Await


00:04:13.740 --> 00:04:15.500
plus MongoDB.


00:04:15.500 --> 00:04:18.980
But the way you work with it is you create a motor connection,


00:04:18.980 --> 00:04:21.380
motor client, and hand it off to the underlying framework.


00:04:21.380 --> 00:04:25.540
So really, it's still using your code.


00:04:25.540 --> 00:04:26.260
That's cool.


00:04:26.260 --> 00:04:27.460
That's neat.


00:04:27.460 --> 00:04:29.340
Yeah, pretty neat.


00:04:29.340 --> 00:04:33.900
So I imagine those are two really different worlds,


00:04:33.900 --> 00:04:41.380
building client libraries to talk to some semi black box type of system, like I send


00:04:41.380 --> 00:04:47.700
requests over the API to Mongo and it does its thing and I get a response, to switching


00:04:47.700 --> 00:04:51.620
and being inside that box, right?


00:04:51.620 --> 00:04:52.620
What's the...


00:04:52.620 --> 00:04:56.940
Maybe contrast those two worlds because I think they're probably pretty different.


00:04:56.940 --> 00:05:05.940
Yeah, the problem spaces are practically disjoint.


00:05:05.940 --> 00:05:09.940
When I was working on MongoDB drivers,


00:05:09.940 --> 00:05:15.940
I had a great deal of concern for making the API usable by application developers.


00:05:15.940 --> 00:05:21.940
A lot of my time was spent figuring out how to make a consistent experience


00:05:21.940 --> 00:05:30.740
experience for people who are using MongoDB from Python and also from JavaScript or C or PHP.


00:05:30.740 --> 00:05:36.740
These are completely different kinds of languages, but you need as much consistency as possible


00:05:36.740 --> 00:05:43.780
while still respecting the style of the language itself. And then, of course,


00:05:43.780 --> 00:05:49.140
since these are semantically versioned libraries, almost every decision you make is permanent.


00:05:51.700 --> 00:05:58.140
On the server side, on the other hand, I was mainly concerned with how to implement algorithms


00:05:58.140 --> 00:06:04.140
that solved tricky problems. And so we could change our minds every few years with sort


00:06:04.140 --> 00:06:10.060
of upgrade downgrade logic. It's complicated, but it's not permanent in the way that an


00:06:10.060 --> 00:06:15.460
API is. And a lot of the problems that it was handling on the server side, first of


00:06:15.460 --> 00:06:21.700
I was working with C++ in a half million light code base.


00:06:21.700 --> 00:06:24.740
So that was a great deal more complexity


00:06:24.740 --> 00:06:28.900
than I'd ever confronted before.


00:06:28.900 --> 00:06:32.580
>>And it's probably really super polished.


00:06:32.580 --> 00:06:36.900
And every little change probably has many, many knock-on effects


00:06:36.900 --> 00:06:38.980
that you've got to carefully think about.


00:06:38.980 --> 00:06:41.820
And you're like, ah, do we really need to check for that?


00:06:41.820 --> 00:06:42.860
Would this ever happen?


00:06:42.860 --> 00:06:45.820
or can we reorder those bytes?


00:06:45.820 --> 00:06:46.900
Probably it's fine.


00:06:46.900 --> 00:06:52.620
- There's a lot of hidden complexity


00:06:52.620 --> 00:06:54.940
that people who've been working on the server code


00:06:54.940 --> 00:06:58.100
is longer than I kept pointing out to me.


00:06:58.100 --> 00:07:01.860
Like, no, you can't just change this data structure.


00:07:01.860 --> 00:07:03.900
You have to take the following six locks


00:07:03.900 --> 00:07:06.200
before you can even think about touching that.


00:07:06.200 --> 00:07:11.820
And then interactions among the servers


00:07:11.820 --> 00:07:18.060
in a replica set or a sharded cluster are literally


00:07:18.060 --> 00:07:21.540
exponentially complex.


00:07:21.540 --> 00:07:23.580
>> Yeah, like n factorial type of thing.


00:07:23.580 --> 00:07:24.080
>> Right.


00:07:24.080 --> 00:07:27.660
>> OK.


00:07:27.660 --> 00:07:35.140
And C++ versus Python, that's a pretty big distinction there.


00:07:35.140 --> 00:07:39.500
>> Yeah, I had coded C++ right out of college.


00:07:39.500 --> 00:07:41.780
I thought I was going to be a 3D graphics guy working


00:07:41.780 --> 00:07:52.580
for Pixar, which never happened, but I had known C++ once upon a time. But C++ in the 90s is


00:07:52.580 --> 00:07:58.100
a completely different language from modern C++, so I had a lot of catching up to do.


00:07:58.100 --> 00:08:04.500
On the other hand, I really enjoyed the fact that you can make things run fast,


00:08:05.060 --> 00:08:07.540
And I hope that this is not offensive.


00:08:07.540 --> 00:08:17.760
But CPython has a very low ceiling for performance.


00:08:17.760 --> 00:08:20.980
And you can make algorithms more efficient,


00:08:20.980 --> 00:08:23.760
but you can't really make your code run all that fast.


00:08:23.760 --> 00:08:26.980
And I found it really enjoyable to write C++


00:08:26.980 --> 00:08:32.260
and have things finish in microseconds.


00:08:32.260 --> 00:08:35.260
Right, right. Near, about as fast as it gets,


00:08:35.260 --> 00:08:37.060
unless you're going to go do assembler.


00:08:37.060 --> 00:08:37.820
Yep.


00:08:37.820 --> 00:08:39.820
And then maybe not, maybe you still can't do the compiler.


00:08:39.820 --> 00:08:41.820
Probably not. Certainly not for me.


00:08:41.820 --> 00:08:46.060
Yeah, and who would want to write assembler, right?


00:08:46.060 --> 00:08:48.060
Especially, oh my gosh.


00:08:48.060 --> 00:08:52.100
No, I think the story with Python performance is interesting.


00:08:52.100 --> 00:08:54.900
A lot of times it's plenty fast for what people need to do,


00:08:54.900 --> 00:08:58.540
but if you're building a server, like a high-end database server,


00:08:58.540 --> 00:09:00.700
you know, those microseconds count.


00:09:00.700 --> 00:09:03.220
And that's a different world.


00:09:03.220 --> 00:09:05.680
It's a different trade-off, trading somewhat developer


00:09:05.680 --> 00:09:10.240
speed for performance and code speed.


00:09:10.240 --> 00:09:14.640
Although I do think we're getting some proper attention


00:09:14.640 --> 00:09:17.240
on Python speed in the last couple of years,


00:09:17.240 --> 00:09:19.880
and will for the next couple as well,


00:09:19.880 --> 00:09:24.120
with the faster CPython initiative and 3.10, 3.11,


00:09:24.120 --> 00:09:25.840
3.12, all that stuff.


00:09:25.840 --> 00:09:28.240
But it's still-- even the fast versions of those


00:09:28.240 --> 00:09:30.480
or not C++ type of speed.


00:09:30.480 --> 00:09:34.800
- Yeah, it's a fundamentally different way


00:09:34.800 --> 00:09:39.200
of executing code and they're never really going to overlap.


00:09:39.200 --> 00:09:43.920
- Yeah, yeah, maybe someday we'll get fully compiled Python.


00:09:43.920 --> 00:09:46.320
Who knows what the future holds, but until then.


00:09:46.320 --> 00:09:49.760
Long as it's interpreted, probably not.


00:09:49.760 --> 00:09:51.440
All right, the third thing you mentioned


00:09:51.440 --> 00:09:54.800
which sounds interesting as well is MongoDB Labs.


00:09:55.680 --> 00:10:00.480
Can you give us an example of some of the things that have come out of there or some of the types


00:10:00.480 --> 00:10:06.160
of problems you're researching, anything like that? How secret is the lab? Is it like a skunk's work


00:10:06.160 --> 00:10:13.520
at Lockheed Martin? Can you talk a little about it? >> I can certainly talk about it. It's


00:10:13.520 --> 00:10:22.160
small and fairly new, a couple of years old, about a dozen people, working on a number of things.


00:10:23.920 --> 00:10:28.320
One of them is streaming data processing,


00:10:28.320 --> 00:10:33.160
which I think we'll be able to announce quite a bit more


00:10:33.160 --> 00:10:35.920
about that soon.


00:10:35.920 --> 00:10:39.080
>>Is this like a high-speed time series data,


00:10:39.080 --> 00:10:44.500
like I'm hooked up to some kind of pipe to the NASDAQ


00:10:44.500 --> 00:10:45.400
or something like this?


00:10:45.400 --> 00:10:48.120
Or what's an example?


00:10:48.120 --> 00:10:57.480
Right, where you've got a source of data events, not necessarily stored in any database anywhere,


00:10:57.480 --> 00:11:06.680
but coming in as a continuous stream of events. And you want to connect stream processors in some


00:11:06.680 --> 00:11:14.760
sort of kind of network of pipes and nodes and eventually drop the results into MongoDB or


00:11:14.760 --> 00:11:18.600
or another data store or send it off to another service,


00:11:18.600 --> 00:11:24.520
MongoDB Labs has been a place where we can incubate


00:11:24.520 --> 00:11:28.280
some of those ideas and make them available


00:11:28.280 --> 00:11:31.320
in our developer data platform.


00:11:31.320 --> 00:11:34.800
- Yeah, okay.


00:11:34.800 --> 00:11:38.040
Sounds like a really cool place to work,


00:11:38.040 --> 00:11:39.440
just sort of playing with ideas


00:11:39.440 --> 00:11:42.400
and got the time and space to do that, right?


00:11:42.400 --> 00:11:47.820
Yeah, Labs has also been a place where we incubate cryptography ideas,


00:11:47.820 --> 00:11:50.740
like queryable encryption,


00:11:50.740 --> 00:11:56.580
where MongoDB doesn't know the contents of your data,


00:11:56.580 --> 00:11:58.780
but can nevertheless answer queries about it.


00:11:58.780 --> 00:12:07.000
I personally have been working on improving the debugging experience


00:12:07.000 --> 00:12:11.460
for people who are writing complex aggregation pipelines,


00:12:12.080 --> 00:12:14.480
And then what I'm working on right now


00:12:14.480 --> 00:12:18.480
is predictive scaling for Atlas.


00:12:18.480 --> 00:12:22.880
The idea is that a lot of customers


00:12:22.880 --> 00:12:26.360
have really regular weekly business cycles


00:12:26.360 --> 00:12:27.760
or daily business cycles.


00:12:27.760 --> 00:12:32.440
You might have Monday through Friday,


00:12:32.440 --> 00:12:38.360
traffic gradually increases around nine or 10 a.m.


00:12:38.360 --> 00:12:39.800
and then it drops off at the end of the day


00:12:39.800 --> 00:12:41.480
and then you have a huge spike at midnight


00:12:41.480 --> 00:12:43.660
when all of your nightly analytics queries go off


00:12:43.660 --> 00:12:46.560
and then the weekend is quiet.


00:12:46.560 --> 00:12:50.240
We should be able to detect those patterns


00:12:50.240 --> 00:12:52.560
and automatically scale you up and down so


00:12:52.560 --> 00:12:56.960
that you have the capacity you need just before you need it.


00:12:56.960 --> 00:13:00.100
And then you don't pay for it at a time when you predictably


00:13:00.100 --> 00:13:02.920
do not need it.


00:13:02.920 --> 00:13:04.900
Actual deployment of that idea, I


00:13:04.900 --> 00:13:06.520
have no idea how far off that is.


00:13:06.520 --> 00:13:08.960
But that's what's nice about labs


00:13:08.960 --> 00:13:13.960
is that we are working on things that the larger company


00:13:13.960 --> 00:13:16.960
doesn't have scheduled yet.


00:13:16.960 --> 00:13:19.000
- Yeah.


00:13:19.000 --> 00:13:21.000
And you can experiment, right?


00:13:21.000 --> 00:13:23.920
It's a lab.


00:13:23.920 --> 00:13:25.320
- Exactly.


00:13:25.320 --> 00:13:27.960
- Tell people about Atlas a little bit.


00:13:27.960 --> 00:13:30.880
You talked about your predictive scaling in Atlas.


00:13:30.880 --> 00:13:33.260
I imagine not everyone knows what that is.


00:13:33.260 --> 00:13:34.160
- Sure.


00:13:34.160 --> 00:13:38.180
Atlas is MongoDB's cloud services.


00:13:38.180 --> 00:13:43.180
and we originally launched it as a database as a service.


00:13:43.180 --> 00:13:49.180
So you decide how you want to deploy your database,


00:13:49.180 --> 00:13:51.380
a replica set or a sharded cluster,


00:13:51.380 --> 00:13:55.220
which cloud providers you want to use.


00:13:55.220 --> 00:13:58.020
We allow you to use multiple cloud providers


00:13:58.020 --> 00:14:04.260
and what size of server you need.


00:14:05.540 --> 00:14:10.540
And so we would manage backups and administration


00:14:10.540 --> 00:14:12.940
and that sort of thing, upgrades and so on.


00:14:12.940 --> 00:14:18.140
More recently, we've announced Atlas Serverless,


00:14:18.140 --> 00:14:19.220
which is pay as you go.


00:14:19.220 --> 00:14:21.660
So you no longer have to worry about


00:14:21.660 --> 00:14:24.500
how your database is deployed, what instance size,


00:14:24.500 --> 00:14:27.020
you don't need to do capacity planning.


00:14:27.020 --> 00:14:31.140
We just auto scale you and bill you for what you used.


00:14:31.140 --> 00:14:34.100
We've also got a few other services,


00:14:34.100 --> 00:14:35.540
which I'm not an expert in,


00:14:35.540 --> 00:14:37.740
but we've got Atlas Data Federation,


00:14:37.740 --> 00:14:41.200
which helps you move data among different services,


00:14:41.200 --> 00:14:43.700
both MongoDB services and other ones.


00:14:43.700 --> 00:14:51.060
And those are kind of the highlights as far as I'm aware.


00:14:51.060 --> 00:14:52.340
- Yeah, sounds good.


00:14:52.340 --> 00:14:57.500
All right, I'll put a link to the GitHub organization


00:14:57.500 --> 00:14:59.140
for MongoDB Labs up there.


00:14:59.140 --> 00:15:02.700
There's some cool looking repos


00:15:02.700 --> 00:15:05.060
and also some funny names like Covert Snooty.


00:15:05.060 --> 00:15:09.580
- We don't have to be professional over here, it's nice.


00:15:09.580 --> 00:15:12.060
- Exactly, you can just have fun with it.


00:15:12.060 --> 00:15:13.020
Yeah, excellent.


00:15:13.020 --> 00:15:18.660
All right, well, let's talk a little bit about databases


00:15:18.660 --> 00:15:21.900
in the broad sense, and then we can dive into


00:15:21.900 --> 00:15:25.020
the core ideas that I invited you here,


00:15:25.020 --> 00:15:26.380
which I guess is worth pointing out.


00:15:26.380 --> 00:15:30.260
The reason I knew about this and reached out to you


00:15:30.260 --> 00:15:34.380
was you gave a talk at PyCon 2023.


00:15:34.380 --> 00:15:35.860
Maybe tell us a bit about that experience


00:15:35.860 --> 00:15:37.760
before we jump into the databases.


00:15:37.760 --> 00:15:43.920
- It's really nice to have PyCon back after COVID.


00:15:43.920 --> 00:15:48.920
I went to PyCon at Salt Lake City last year and this year.


00:15:48.920 --> 00:15:52.460
And last year I spoke about


00:15:52.460 --> 00:15:55.660
modern concurrency patterns in Python.


00:15:55.660 --> 00:15:59.260
And this year I talked about consistency and isolation.


00:15:59.260 --> 00:16:03.660
And I also learned a lot.


00:16:03.660 --> 00:16:08.540
After being a C++ programmer and going to PyCon and being not sure what I was doing


00:16:08.540 --> 00:16:13.980
at PyCon anymore, this year I came as a researcher.


00:16:13.980 --> 00:16:18.820
And so the areas of my interests are essentially everything.


00:16:18.820 --> 00:16:26.260
And so I went to a bunch of talks and learned a bunch of stuff and renewed my love for being


00:16:26.260 --> 00:16:27.260
at PyCon.


00:16:27.260 --> 00:16:29.260
- Wow, that's excellent.


00:16:29.260 --> 00:16:34.540
- I wanted to talk about consistency and isolation


00:16:34.540 --> 00:16:39.540
at PyCon because these are fundamental database concepts.


00:16:39.540 --> 00:16:45.580
They are some of the hardest to learn


00:16:45.580 --> 00:16:48.360
that I've ever encountered in computer science.


00:16:48.360 --> 00:16:54.660
And I kind of think that most of the approaches are bad.


00:16:56.860 --> 00:16:59.360
You can read the fundamental papers,


00:16:59.360 --> 00:17:01.020
and you probably should,


00:17:01.020 --> 00:17:02.980
but reading the original papers


00:17:02.980 --> 00:17:04.740
is a very hard way to learn something,


00:17:04.740 --> 00:17:08.700
and they tend to be too concise and too abstract


00:17:08.700 --> 00:17:10.380
and not very well digested.


00:17:10.380 --> 00:17:16.060
And then maybe if I'd taken that databases


00:17:16.060 --> 00:17:18.500
elective in college and read the textbook,


00:17:18.500 --> 00:17:21.060
I would be in better shape, but I didn't.


00:17:21.060 --> 00:17:23.660
And then I joined a database company


00:17:23.660 --> 00:17:26.580
and I had to learn it on the job.


00:17:26.580 --> 00:17:31.540
So I came up with a few ways of thinking about it,


00:17:31.540 --> 00:17:33.360
which took me a few years.


00:17:33.360 --> 00:17:37.060
So I wanted to come to PyCon and share those


00:17:37.060 --> 00:17:41.100
and hopefully accelerate other people's learning.


00:17:41.100 --> 00:17:45.540
- Yeah, I imagine approach,


00:17:45.540 --> 00:17:49.780
everything about a conference like that is really different


00:17:49.780 --> 00:17:52.300
if you come with a researcher's mindset.


00:17:52.300 --> 00:17:55.060
You go hit all the expo booths and you're like,


00:17:55.060 --> 00:17:57.300
"All right, I need your ideas.


00:17:57.300 --> 00:18:02.300
"Tell me all about this," with a special focus, right?


00:18:02.300 --> 00:18:03.400
- Yeah.


00:18:03.400 --> 00:18:05.180
- Yeah, cool, all right.


00:18:05.180 --> 00:18:10.020
Let's talk databases, and I think we could start it


00:18:10.020 --> 00:18:13.480
with just, you know, not every database is the same.


00:18:13.480 --> 00:18:17.620
I think long ago, people, when they said database,


00:18:17.620 --> 00:18:20.500
they just meant relational database, right?


00:18:20.500 --> 00:18:24.580
And nowadays, there's more variety.


00:18:24.580 --> 00:18:28.700
And by nowadays, I'm thinking the last 15 years, right?


00:18:28.700 --> 00:18:30.540
It's not just today.


00:18:30.540 --> 00:18:35.420
But let's just maybe get a, just a quick


00:18:35.420 --> 00:18:36.900
high level landscape view


00:18:36.900 --> 00:18:38.360
of the different kinds of databases.


00:18:38.360 --> 00:18:43.360
So relational, that's probably what most people are using.


00:18:43.360 --> 00:18:46.420
Yeah, I'm gonna go just give us a rundown


00:18:46.420 --> 00:18:49.060
of your thoughts on how this category


00:18:49.060 --> 00:18:50.460
and just categorization goes.


00:18:50.460 --> 00:18:52.780
- Yeah, really? - Talks out of me, I guess.


00:18:52.780 --> 00:18:56.540
- Yeah, relational databases,


00:18:56.540 --> 00:19:00.620
which are made of tables of rows and columns,


00:19:00.620 --> 00:19:04.340
and you almost always query them with SQL,


00:19:04.340 --> 00:19:06.260
which is standardized,


00:19:06.260 --> 00:19:10.040
although every database has its own extensions,


00:19:10.040 --> 00:19:15.100
came to really dominate in the '90s.


00:19:15.100 --> 00:19:20.100
And they are great for a lot of reasons.


00:19:20.100 --> 00:19:22.100
for a lot of reasons.


00:19:22.100 --> 00:19:25.100
And I think everybody should know how to use them.


00:19:25.100 --> 00:19:31.100
But, you know, around the time that I joined MongoDB in 2011,


00:19:31.100 --> 00:19:33.100
something was happening, which is that


00:19:33.100 --> 00:19:38.100
the scale of data


00:19:38.100 --> 00:19:42.100
came to the point where you needed specialized approaches.


00:19:42.100 --> 00:19:46.100
And then another thing that was going on was that,


00:19:46.100 --> 00:19:49.100
sort of funny enough, object-oriented programming


00:19:49.100 --> 00:19:53.900
programming and relational databases had both come to dominate at the same time,


00:19:53.900 --> 00:19:59.020
and they work very, very poorly with each other. Yeah, that is funny, but that did happen.


00:19:59.020 --> 00:20:06.860
Because relational, I mean, a relation is sort of the object opposite of an object. Object-oriented


00:20:06.860 --> 00:20:13.180
programs are quite hierarchical and fairly flexible, and relations are not hierarchical


00:20:13.180 --> 00:20:14.820
and extremely inflexible.


00:20:14.820 --> 00:20:22.220
So we call that the impedance mismatch.


00:20:22.220 --> 00:20:24.180
I don't know if that's actually a helpful term.


00:20:24.180 --> 00:20:26.060
It's just-- it's bad.


00:20:26.060 --> 00:20:28.380
>>Victor: Yeah, the object-relational impedance


00:20:28.380 --> 00:20:30.380
mismatch, if people are familiar with that term.


00:20:30.380 --> 00:20:32.000
I haven't thought of that for a while,


00:20:32.000 --> 00:20:35.740
but yeah, that was a big concern often.


00:20:35.740 --> 00:20:36.260
>>Galen: Right.


00:20:40.420 --> 00:20:50.420
NoSQL was kind of a movement, and it encompassed a number of solutions to these problems.


00:20:50.420 --> 00:20:55.580
One of them is that NoSQL databases tend to be distributed.


00:20:55.580 --> 00:21:05.460
So, whereas, before I came to MongoDB, I was working with an Oracle database.


00:21:05.460 --> 00:21:10.460
And as load increased, we just needed to buy a bigger and bigger single box


00:21:10.460 --> 00:21:14.460
until we had like a million dollar refrigerator sized thing,


00:21:14.460 --> 00:21:16.460
which must never ever go down.


00:21:16.460 --> 00:21:25.460
And many of the NoSQL databases, including MongoDB, are distributed.


00:21:25.460 --> 00:21:30.460
So you can use a large number of smaller machines, which is much more economical.


00:21:30.460 --> 00:21:33.460
Much more cloud friendly.


00:21:33.460 --> 00:21:35.260
Much more cloud friendly.


00:21:35.260 --> 00:21:40.260
It's not only a good way to scale your CPU and RAM,


00:21:40.260 --> 00:21:42.820
but it's also a good way to ensure reliability


00:21:42.820 --> 00:21:45.900
in geo distribution.


00:21:45.900 --> 00:21:48.940
So we took advantage of all that.


00:21:48.940 --> 00:21:54.260
We kind of built in the distributed nature of it


00:21:54.260 --> 00:21:55.660
quite early.


00:21:55.660 --> 00:22:01.140
And a lot of the other NoSQL databases did as well.


00:22:01.140 --> 00:22:05.940
We're also a document database with the data format


00:22:05.940 --> 00:22:11.380
is a lot like JSON, and it's easily convertible to JSON.


00:22:11.380 --> 00:22:13.740
And that means that it's very familiar for people


00:22:13.740 --> 00:22:17.640
who write Python or JavaScript or anything like that.


00:22:17.640 --> 00:22:21.980
We store things that are a lot like dictionaries and lists.


00:22:21.980 --> 00:22:22.900
And--


00:22:22.900 --> 00:22:24.460
- They're API friendly, right?


00:22:24.460 --> 00:22:26.140
Like you're exchanging JSON.


00:22:26.140 --> 00:22:31.100
So you're 95% of the way there just on your API data exchange


00:22:31.100 --> 00:22:33.500
- Yeah, if you want to expose a MongoDB collection


00:22:33.500 --> 00:22:35.500
as something to a REST API,


00:22:35.500 --> 00:22:37.000
you can do that in a couple of lines


00:22:37.000 --> 00:22:40.800
because JSON and MongoDB data are so similar.


00:22:40.800 --> 00:22:42.840
- Yep.


00:22:42.840 --> 00:22:45.640
All right, so document databases


00:22:45.640 --> 00:22:47.940
is probably the best known NoSQL,


00:22:47.940 --> 00:22:51.000
but we also have key value stores


00:22:51.000 --> 00:22:53.700
and column-oriented databases.


00:22:53.700 --> 00:22:55.300
We're still trying to grok them.


00:22:55.300 --> 00:22:58.540
- Yeah, key value stores,


00:23:00.000 --> 00:23:04.180
are just like big dicks in the sky.


00:23:04.180 --> 00:23:08.480
And in exchange for that simplicity,


00:23:08.480 --> 00:23:11.560
they're usually extremely fast and extremely robust.


00:23:11.560 --> 00:23:15.620
Memcached for example.


00:23:15.620 --> 00:23:21.440
And column oriented databases,


00:23:21.440 --> 00:23:22.760
I'm still wrapping my head around.


00:23:22.760 --> 00:23:24.960
So I'm not gonna talk about that all that much,


00:23:24.960 --> 00:23:26.540
but it's my impression that they're good


00:23:26.540 --> 00:23:28.720
for giant analytics jobs


00:23:28.720 --> 00:23:32.280
where you tend to need to do a huge aggregation,


00:23:32.280 --> 00:23:34.720
like find the sum or the mean


00:23:34.720 --> 00:23:39.720
of a very large amount of consistent data.


00:23:39.720 --> 00:23:43.720
- Maybe Pandas is a good mental model


00:23:43.720 --> 00:23:46.380
or NumPy or something like that,


00:23:46.380 --> 00:23:48.200
where you say, I'm gonna apply this operation


00:23:48.200 --> 00:23:49.080
to this whole column


00:23:49.080 --> 00:23:51.420
and you don't want it on a per user basis.


00:23:51.420 --> 00:23:56.420
You wanna say, I want all the latency times as a thing.


00:23:57.240 --> 00:24:00.240
Right, that's a more natural thing to ask for


00:24:00.240 --> 00:24:03.120
instead of projecting out the latency


00:24:03.120 --> 00:24:05.360
where across all of them, that kind of thing.


00:24:05.360 --> 00:24:08.880
Graph databases, I think are also,


00:24:08.880 --> 00:24:10.540
seem to be going strong still.


00:24:10.540 --> 00:24:14.520
- Yeah, and this is an area where MongoDB hasn't,


00:24:14.520 --> 00:24:21.880
has kind of left it to our competitors for the moment.


00:24:21.880 --> 00:24:26.840
But graph databases are great at representing nodes


00:24:26.840 --> 00:24:28.240
that are connected by edges.


00:24:28.240 --> 00:24:32.040
So for example, a social network of people with friendships


00:24:32.040 --> 00:24:35.680
or a network of servers that are connected


00:24:35.680 --> 00:24:40.320
by ethernet cables and you wanna do queries


00:24:40.320 --> 00:24:43.360
like how closely connected is this to that?


00:24:43.360 --> 00:24:46.580
- Maybe even modeling like hierarchies


00:24:46.580 --> 00:24:50.360
within a large corporate organization or something.


00:24:50.360 --> 00:24:52.180
This person reports to that person


00:24:52.180 --> 00:24:53.920
and then those kinds of things.


00:24:55.840 --> 00:24:59.660
- Yeah, okay, so I think that sets the stage


00:24:59.660 --> 00:25:01.440
for a lot of what we're talking about.


00:25:01.440 --> 00:25:05.280
You know, what ones in terms of consistency and isolation,


00:25:05.280 --> 00:25:09.920
this applies to relational documents,


00:25:09.920 --> 00:25:12.440
probably not key value stores.


00:25:12.440 --> 00:25:14.120
I don't know about graph databases at all


00:25:14.120 --> 00:25:15.680
in terms of these.


00:25:15.680 --> 00:25:17.720
Which ones of these are kind of relevant


00:25:17.720 --> 00:25:20.080
to the main topic here?


00:25:20.080 --> 00:25:21.520
- Actually, it's interesting.


00:25:23.400 --> 00:25:29.840
So first of all, let's separate out that isolation


00:25:29.840 --> 00:25:32.280
is a way of--


00:25:32.280 --> 00:25:37.000
so even on a single machine, a database


00:25:37.000 --> 00:25:39.600
can run concurrent operations.


00:25:39.600 --> 00:25:42.080
So you could have two transactions


00:25:42.080 --> 00:25:45.040
that are going on at once, and their operations


00:25:45.040 --> 00:25:47.840
may be in some way interleaved.


00:25:47.840 --> 00:25:52.360
And if the database allows concurrency


00:25:52.360 --> 00:26:01.080
like this on a single machine, then that can reveal phenomena


00:26:01.080 --> 00:26:06.040
that you would not observe if concurrency were not allowed.


00:26:06.040 --> 00:26:09.400
And these phenomena are called anomalies.


00:26:09.400 --> 00:26:14.080
And these terms, phenomena and anomalies,


00:26:14.080 --> 00:26:18.560
go all the way back to the '80s, maybe to the 1970s,


00:26:18.560 --> 00:26:20.320
database theory.


00:26:20.320 --> 00:26:26.040
And there's nothing specific to relational or non-relational


00:26:26.040 --> 00:26:29.360
data to the SQL language or any other query language.


00:26:29.360 --> 00:26:32.960
So long as the database allows concurrency,


00:26:32.960 --> 00:26:36.120
then anomalies are possible.


00:26:36.120 --> 00:26:41.960
And so the database may choose to provide isolation levels


00:26:41.960 --> 00:26:44.400
to you.


00:26:44.400 --> 00:26:46.760
There are four isolation levels that people have probably


00:26:46.760 --> 00:26:50.520
heard of that are in the SQL standard.


00:26:50.520 --> 00:26:53.240
And so obviously they've got that connection


00:26:53.240 --> 00:26:55.760
to the relational model and the SQL language.


00:26:55.760 --> 00:27:00.420
But in my PyCon talk, I was just showing a key value store.


00:27:00.420 --> 00:27:02.280
- Yeah, that's right.


00:27:02.280 --> 00:27:06.720
You actually were kind of more or less


00:27:06.720 --> 00:27:09.840
writing the code for the different implementations


00:27:09.840 --> 00:27:12.980
or demonstrating the code for the different implementations


00:27:12.980 --> 00:27:15.600
of how you might do a key value store.


00:27:15.600 --> 00:27:18.100
So what you did was you said, let's imagine we just


00:27:18.100 --> 00:27:20.240
have a giant dictionary in memory,


00:27:20.240 --> 00:27:23.220
and that was our database, at least for a table


00:27:23.220 --> 00:27:24.140
or a collection, right?


00:27:24.140 --> 00:27:29.240
And then how do we model these isolation levels in Python code,


00:27:29.240 --> 00:27:30.080
right?


00:27:30.080 --> 00:27:31.000
Yeah, right, exactly.


00:27:31.000 --> 00:27:33.640
So there was no SQL involved.


00:27:33.640 --> 00:27:36.440
The data was just a dict.


00:27:36.440 --> 00:27:41.520
But it was showing how you could use Python locks to provide


00:27:41.520 --> 00:27:46.740
each of the four well-known isolation levels


00:27:46.740 --> 00:27:49.740
and allow concurrency.


00:27:49.740 --> 00:27:52.380
>> All right, so I interrupted you a tiny bit there.


00:27:52.380 --> 00:27:54.220
What are the four isolation levels?


00:27:54.220 --> 00:27:56.820
At least the SQL standard ones.


00:27:56.820 --> 00:27:59.500
>> Right, so there's read uncommitted,


00:27:59.500 --> 00:28:01.780
which is anything goes.


00:28:01.780 --> 00:28:02.580
>> YOLO.


00:28:02.580 --> 00:28:04.380
>> YOLO.


00:28:04.380 --> 00:28:06.420
Every operation that one transaction does


00:28:06.420 --> 00:28:08.780
is immediately visible to all the others,


00:28:08.780 --> 00:28:10.980
or may be visible to all the others,


00:28:10.980 --> 00:28:13.620
even if the transaction hasn't committed yet,


00:28:13.620 --> 00:28:15.580
even if it aborts later.


00:28:15.580 --> 00:28:16.420
- Right.


00:28:16.420 --> 00:28:21.740
- And so the concurrency is nakedly displayed


00:28:21.740 --> 00:28:23.620
to all of the clients.


00:28:23.620 --> 00:28:29.780
Basically, you don't see this in practice.


00:28:29.780 --> 00:28:36.820
Read committed is what people are much more accustomed to,


00:28:36.820 --> 00:28:40.980
where your transaction as it's going along


00:28:40.980 --> 00:28:44.620
may see the data change as other transactions commit,


00:28:44.620 --> 00:28:50.700
but then its own rights are only visible


00:28:50.700 --> 00:28:54.500
to other transactions all in one instant


00:28:54.500 --> 00:28:57.040
at the moment that your transaction commits.


00:28:57.040 --> 00:29:03.040
But of course, you could read the same value


00:29:03.040 --> 00:29:05.060
multiple times in a row and get different answers


00:29:05.060 --> 00:29:07.220
because other transactions are allowed to commit


00:29:07.220 --> 00:29:08.600
and modify it as you go.


00:29:08.600 --> 00:29:14.060
- Right, I imagine that that's a pretty common level.


00:29:14.060 --> 00:29:17.400
The read uncommitted is just chaos, right?


00:29:17.400 --> 00:29:22.100
It's like multi-threading without locks, basically.


00:29:22.100 --> 00:29:26.300
Without any locking mechanism or protection.


00:29:26.300 --> 00:29:28.280
While that it would be the fastest,


00:29:28.280 --> 00:29:32.400
it's probably too risky.


00:29:33.920 --> 00:29:38.260
But read committed, how common do you think that is?


00:29:38.260 --> 00:29:39.680
Read committed is quite prominent.


00:29:39.680 --> 00:29:42.800
It's the default for a number of the SQL databases.


00:29:42.800 --> 00:29:44.280
I don't remember which exactly.


00:29:44.280 --> 00:29:50.480
But people can live with it pretty happily.


00:29:50.480 --> 00:29:55.440
And to be honest, MongoDB's default is read uncommitted.


00:29:55.440 --> 00:30:01.280
If you write to the primary, other clients


00:30:01.280 --> 00:30:03.360
can see those rights immediately.


00:30:03.360 --> 00:30:07.640
There's no transaction by default.


00:30:07.640 --> 00:30:12.640
After all, you have to opt into transactions on MongoDB.


00:30:12.640 --> 00:30:13.520
And--


00:30:13.520 --> 00:30:17.360
- There are atomic changes you can make.


00:30:17.360 --> 00:30:21.760
Like you can use the set and push to set


00:30:21.760 --> 00:30:25.080
and those kinds of operators on a single document.


00:30:25.080 --> 00:30:28.100
But as soon as you start talking to two documents


00:30:28.100 --> 00:30:29.840
in the same collection or cross collection,


00:30:29.840 --> 00:30:31.440
then this is what you're talking about.


00:30:31.440 --> 00:30:33.360
There's no transaction, right?


00:30:33.360 --> 00:30:34.480
- Yeah, that's exactly right.


00:30:34.480 --> 00:30:36.840
And the document model does make it much more practical


00:30:36.840 --> 00:30:38.400
to do things without transactions


00:30:38.400 --> 00:30:42.040
because you can keep related data altogether


00:30:42.040 --> 00:30:45.360
in a single document and update it in one statement.


00:30:45.360 --> 00:30:46.200
- Yeah.


00:30:46.200 --> 00:30:48.040
- Whereas the relational model tends to kind of


00:30:48.040 --> 00:30:51.080
spray your data around and make it much more difficult


00:30:51.080 --> 00:30:56.080
to maintain whatever application invariance you want


00:30:58.520 --> 00:31:02.220
because you have to modify multiple rows at the same time.


00:31:02.220 --> 00:31:04.140
- Yeah.


00:31:04.140 --> 00:31:06.940
Yeah, multiple rows, multiple tables.


00:31:06.940 --> 00:31:09.300
Like there could be a many to many relationship


00:31:09.300 --> 00:31:12.740
that you're adding to or taking away from, right?


00:31:12.740 --> 00:31:17.300
Just to update part of some statement, yeah.


00:31:17.300 --> 00:31:18.140
- Right.


00:31:18.140 --> 00:31:21.740
- Okay, so read uncommitted, read committed.


00:31:21.740 --> 00:31:25.020
- The next one is serializable,


00:31:25.020 --> 00:31:28.020
which takes a while to wrap your head around,


00:31:28.020 --> 00:31:34.500
But with serializable isolation, there


00:31:34.500 --> 00:31:40.900
is a total order of operations that every client sees


00:31:40.900 --> 00:31:46.100
that is as if each transaction ran one at a time.


00:31:46.100 --> 00:31:53.540
And each one read at one moment of time


00:31:53.540 --> 00:31:55.500
and then committed at one moment of time.


00:31:55.500 --> 00:32:00.500
with no other transactions operations interleaved.


00:32:00.500 --> 00:32:04.120
So it's hard to explain.


00:32:04.120 --> 00:32:05.640
It's also extremely intuitive.


00:32:05.640 --> 00:32:07.540
It's almost what you would assume.


00:32:07.540 --> 00:32:10.240
It's kind of like assume that there was no concurrency.


00:32:10.240 --> 00:32:11.840
This is what it would look like.


00:32:11.840 --> 00:32:17.320
The pedantic detail here is that the order


00:32:17.320 --> 00:32:19.640
that the transactions appear to occur


00:32:19.640 --> 00:32:22.640
might not be exactly the order that you did them in


00:32:24.560 --> 00:32:28.360
for complicated implementation reasons.


00:32:28.360 --> 00:32:35.200
So if you have multiple different databases


00:32:35.200 --> 00:32:36.580
talking to each other,


00:32:36.580 --> 00:32:39.120
it might not be good enough for you


00:32:39.120 --> 00:32:41.000
because they might end up choosing


00:32:41.000 --> 00:32:42.320
different orders of operations.


00:32:42.320 --> 00:32:43.800
And so you can see anomalies there,


00:32:43.800 --> 00:32:48.800
but basically serializable is the highest isolation level


00:32:48.800 --> 00:32:53.040
that you're likely to need in a relational database.


00:32:54.160 --> 00:32:57.380
I feel like that might be the default


00:32:57.380 --> 00:32:59.180
for some of the relational databases.


00:32:59.180 --> 00:33:02.840
Not 100% sure.


00:33:02.840 --> 00:33:04.280
- I'm not 100% sure either.


00:33:04.280 --> 00:33:09.920
There's also a compromise less than serializable


00:33:09.920 --> 00:33:11.540
called repeatable read,


00:33:11.540 --> 00:33:17.480
which means that any single piece of data that you've read,


00:33:17.480 --> 00:33:20.240
you'll continue to see the same value for it


00:33:20.240 --> 00:33:23.640
for the duration of your transaction until you commit.


00:33:23.640 --> 00:33:28.240
And the way it's usually actually implemented


00:33:28.240 --> 00:33:31.600
is a slightly stronger level called snapshot isolation,


00:33:31.600 --> 00:33:34.200
where you just get a copy of the data


00:33:34.200 --> 00:33:36.560
at the point in time when you first


00:33:36.560 --> 00:33:39.640
started your transaction approximately.


00:33:39.640 --> 00:33:42.480
And you just read as if you are always reading


00:33:42.480 --> 00:33:45.600
from that version of the data until you commit.


00:33:45.600 --> 00:33:50.600
So snapshot isolation is what people usually actually mean


00:33:51.880 --> 00:33:55.280
by repeatable read and a lot of databases provided.


00:33:55.280 --> 00:33:57.980
And it's the default for MongoDB.


00:33:57.980 --> 00:34:00.060
When you start a transaction in MongoDB,


00:34:00.060 --> 00:34:02.880
you read from a version of the data


00:34:02.880 --> 00:34:05.280
for the rest of that transaction.


00:34:05.280 --> 00:34:06.500
- Okay, interesting.


00:34:06.500 --> 00:34:09.200
Yeah, you did say that MongoDB


00:34:09.200 --> 00:34:11.320
typically doesn't have transactions


00:34:11.320 --> 00:34:15.440
as its kind of recommended default way.


00:34:15.440 --> 00:34:17.200
You know, look at a lot of the tutorials and stuff,


00:34:17.200 --> 00:34:18.800
people are just making updates and so on.


00:34:18.800 --> 00:34:23.800
But this didn't come out originally with MongoDB,


00:34:23.800 --> 00:34:28.400
but at some point, what version did you all add transactions?


00:34:28.400 --> 00:34:29.360
Like actual transactions?


00:34:29.360 --> 00:34:31.000
- I wish I could remember.


00:34:31.000 --> 00:34:31.840
- Yeah, I don't remember either,


00:34:31.840 --> 00:34:34.680
but it was something like, oh, there we go, how about that?


00:34:34.680 --> 00:34:38.480
Something around four, I think version four-ish.


00:34:38.480 --> 00:34:39.320
That's it.


00:34:39.320 --> 00:34:41.480
We're on version six now, but that was quite a while ago.


00:34:41.480 --> 00:34:42.460
- Yeah.


00:34:42.460 --> 00:34:43.800
- Yeah.


00:34:43.800 --> 00:34:45.000
But you've got to pick.


00:34:45.000 --> 00:34:47.560
you've got to pick to go do those transactions


00:34:47.560 --> 00:34:50.560
in Mongo, for example.


00:34:50.560 --> 00:34:54.360
Whereas that's also true, say, for Postgres


00:34:54.360 --> 00:34:57.360
or Microsoft SQL Server, right?


00:34:57.360 --> 00:35:00.320
You've got to actually do the transactional stuff


00:35:00.320 --> 00:35:03.320
in whatever code you're using to talk to that as well.


00:35:03.320 --> 00:35:07.480
It's just more visible in a lot of the tutorials


00:35:07.480 --> 00:35:11.640
and examples for those libraries, I think.


00:35:11.640 --> 00:35:14.200
- Yeah, MongoDB in general has taken


00:35:14.200 --> 00:35:19.200
a more kind of show our guts to you approach


00:35:19.200 --> 00:35:24.440
where we early on the distributed nature of MongoDB,


00:35:24.440 --> 00:35:28.400
which was much more visible to our users


00:35:28.400 --> 00:35:33.400
than other databases and transactions now,


00:35:33.400 --> 00:35:37.240
we kind of show you the details


00:35:37.240 --> 00:35:40.820
a bit more than other databases do,


00:35:40.820 --> 00:35:44.780
but that actually allows you to write more reliable code.


00:35:44.780 --> 00:35:50.740
The interesting thing about an SQL interface


00:35:50.740 --> 00:35:54.900
is that you can start a transaction,


00:35:54.900 --> 00:35:59.320
do a bunch of writes, and then send the commit message.


00:35:59.320 --> 00:36:02.540
And if you get some sort of error, like a network error,


00:36:02.540 --> 00:36:07.540
perhaps you got disconnected or the server crashed,


00:36:07.540 --> 00:36:09.940
you don't know.


00:36:09.940 --> 00:36:12.820
But you don't know whether your transaction committed or not.


00:36:12.820 --> 00:36:14.300
And if you reconnect, you don't know


00:36:14.300 --> 00:36:16.900
whether you will see the data that you committed or not.


00:36:16.900 --> 00:36:22.180
This is somewhat difficult to handle,


00:36:22.180 --> 00:36:25.020
and most people aren't aware of it.


00:36:25.020 --> 00:36:32.260
The MongoDB transaction API makes you think about this.


00:36:32.260 --> 00:36:35.620
The drivers essentially have you pass a function


00:36:35.620 --> 00:36:38.620
in which executes the transaction code,


00:36:38.620 --> 00:36:41.780
and that it's automatically retried if the commit fails.


00:36:41.780 --> 00:36:44.260
And so we give you the mechanism


00:36:44.260 --> 00:36:47.240
to ensure reliable transaction commits.


00:36:47.240 --> 00:36:49.220
- I see.


00:36:49.220 --> 00:36:50.860
But it's more, yeah, sure.


00:36:50.860 --> 00:36:52.540
You can either be sure it happened


00:36:52.540 --> 00:36:55.940
or you have the mechanism to run it again in the API.


00:36:55.940 --> 00:36:56.780
- Exactly.


00:36:56.780 --> 00:36:57.620
- Yeah, okay.


00:36:57.620 --> 00:36:59.300
Interesting.


00:36:59.300 --> 00:37:02.700
So I guess one of the questions is,


00:37:02.700 --> 00:37:05.980
well, let's look at two aspects here.


00:37:05.980 --> 00:37:09.340
One of the things is you spoke about anomalies


00:37:09.340 --> 00:37:12.140
and what might go wrong.


00:37:12.140 --> 00:37:15.820
The read uncommitted, I think people can probably


00:37:15.820 --> 00:37:18.620
conceptualize that pretty well, right?


00:37:18.620 --> 00:37:23.380
It's just as multi-step transactions are happening,


00:37:23.380 --> 00:37:25.120
other ones are potentially running


00:37:25.120 --> 00:37:27.260
and you could read something either that transaction


00:37:27.260 --> 00:37:30.300
could roll back after you've carried on


00:37:30.300 --> 00:37:32.420
or you could have just had something


00:37:32.420 --> 00:37:35.380
of the equivalent of a race condition, right?


00:37:35.380 --> 00:37:41.320
So there's a term for that kind of anomaly.


00:37:41.320 --> 00:37:44.020
Each of these anomalies have terms, I've learned.


00:37:44.020 --> 00:37:45.300
Yeah.


00:37:45.300 --> 00:37:48.580
And you can definitely memorize them.


00:37:48.580 --> 00:37:53.700
And if you go to jepson.io, there's


00:37:53.700 --> 00:37:59.380
a lovely diagram of the relationship


00:37:59.380 --> 00:38:05.500
among all of the consistency and isolation levels.


00:38:05.500 --> 00:38:10.900
>> G-Y-P-S-U-M?


00:38:10.900 --> 00:38:16.020
>> That is J-E-P-S-E-N.io.


00:38:16.020 --> 00:38:17.300
>> Ah.


00:38:17.300 --> 00:38:18.380
>> Yeah.


00:38:18.380 --> 00:38:22.220
This is a researcher named Kyle Kingsbury,


00:38:22.220 --> 00:38:27.700
his website about consistency and isolation and testing.


00:38:27.700 --> 00:38:31.500
This is really-- this is the best place, I think,


00:38:31.500 --> 00:38:33.740
to go learn about this stuff.


00:38:33.740 --> 00:38:36.340
>>Here we go, yeah.


00:38:36.340 --> 00:38:37.180
OK.


00:38:37.180 --> 00:38:40.300
Yeah, there's a lot of cool visualization stuff here.


00:38:40.300 --> 00:38:43.560
>>Yeah, for those watching on the live stream,


00:38:43.560 --> 00:38:47.740
we've got a tree diagram up that shows


00:38:47.740 --> 00:38:50.580
all of the isolation levels, all of the consistency levels


00:38:50.580 --> 00:38:53.940
that are commonly used, and how they relate to each other


00:38:53.940 --> 00:39:02.100
terms of how, let's say, the serializable isolation is strictly stronger than read committed.


00:39:02.100 --> 00:39:19.300
Every anomaly that is prohibited by serializable is also prohibited by read committed.


00:39:20.100 --> 00:39:30.820
Got it. Okay. Interesting. Yeah, so maybe help us understand the read committed anomalies versus


00:39:30.820 --> 00:39:37.140
like the read uncommitted one is like it's full of them. But maybe help us understand some of


00:39:37.140 --> 00:39:41.620
the things that can go wrong or in the safer ones, like trying to decide between read committed and


00:39:41.620 --> 00:39:48.420
serializable, for example. Right. This was also my approach when I first started learning.


00:39:48.420 --> 00:39:49.420
[laughter]


00:39:49.420 --> 00:39:54.140
>> BD: was to try to memorize these things.


00:39:54.140 --> 00:39:58.380
And the reason why I'm not answering your question is that I don't think that this is


00:39:58.380 --> 00:39:59.380
the right approach.


00:39:59.380 --> 00:40:01.740
>> CB: Okay, what would you suggest?


00:40:01.740 --> 00:40:03.420
>> BD: Yeah.


00:40:03.420 --> 00:40:13.180
I think the right approach is to step back and ask, "Why do anomalies exist?"


00:40:13.180 --> 00:40:21.140
And the answer is, I've come to understand it, is that databases want to permit more


00:40:21.140 --> 00:40:28.780
concurrency so that you can get higher throughput with multiple transactions at once.


00:40:28.780 --> 00:40:30.580
But you've got to sacrifice something for that.


00:40:30.580 --> 00:40:32.740
What you've got to sacrifice is isolation.


00:40:32.740 --> 00:40:36.700
Some of these anomalies have to appear.


00:40:36.700 --> 00:40:39.420
And so why is that?


00:40:39.420 --> 00:40:41.420
Why do you have to make that trade-off?


00:40:41.420 --> 00:40:58.420
The short answer is that databases prevent anomalies by in some way locking pieces of data to prevent one transaction from modifying or even reading it if another transaction has modified or read it.


00:40:58.420 --> 00:41:02.420
And so the more things you lock, the less concurrency is permitted.


00:41:02.420 --> 00:41:12.520
And if you want to understand that in detail for each of the isolation levels and each


00:41:12.520 --> 00:41:21.960
of the anomalies, you could watch the video of my PyCon talk, which goes through like


00:41:21.960 --> 00:41:29.140
20 or 30 line long Python implementations of databases that provide each of these isolation


00:41:29.140 --> 00:41:30.140
levels.


00:41:30.140 --> 00:41:35.720
why they need different amounts of locking. You can see why they permit


00:41:35.720 --> 00:41:43.420
different levels of concurrency. You can start to get a feel for what amount of


00:41:43.420 --> 00:41:49.740
concurrency each of them permits, and also what sort of anomalies each of them


00:41:49.740 --> 00:41:59.340
permits. And with that in mind, for me at least, thinking about how these things


00:41:59.340 --> 00:42:05.740
are actually implemented gave me a much made it much easier for me to then memorize.


00:42:05.740 --> 00:42:13.180
Okay read committed provides phantom reads. Why is that? What does that mean?


00:42:13.180 --> 00:42:18.860
Now I understand that because I understand how the how on implementation might work.


00:42:18.860 --> 00:42:27.100
Yeah I think that makes a lot of sense. That really is the relationship that people should


00:42:27.100 --> 00:42:31.140
understand, right, that there's an inverse relationship between


00:42:31.140 --> 00:42:37.260
sort of the data consistency and the lack of these anomalies, and


00:42:37.260 --> 00:42:42.140
how much you can handle scale and concurrency, right? The


00:42:42.140 --> 00:42:46.180
stricter, the more consistent the data is, the less scale that


00:42:46.180 --> 00:42:50.700
you get. Right. And so where, where do you live? Can you get


00:42:50.700 --> 00:42:54.840
to points where the database actually like locks up and kind


00:42:54.840 --> 00:42:57.240
of a deadlock situation?


00:42:57.240 --> 00:42:58.480
>> Yes.


00:42:58.480 --> 00:43:01.400
And I show one of those in my PyCon talk.


00:43:01.400 --> 00:43:04.680
The serializable level of isolation


00:43:04.680 --> 00:43:06.040
is particularly prone to this.


00:43:06.040 --> 00:43:10.320
Basically, if-- and I do this all with Star Trek memes.


00:43:10.320 --> 00:43:17.360
So I show an example where Sulu reads one piece of data


00:43:17.360 --> 00:43:21.000
and something which--


00:43:21.000 --> 00:43:24.560
they're fighting over who gets to check out the shuttle


00:43:24.560 --> 00:43:27.760
to go to surface for a shore leave.


00:43:27.760 --> 00:43:32.080
And Sulu checks if Uhura has the shuttle, and he sees no.


00:43:32.080 --> 00:43:34.440
But then Uhura starts a transaction


00:43:34.440 --> 00:43:36.880
and checks if Sulu has the shuttle.


00:43:36.880 --> 00:43:38.560
The answer is also no.


00:43:38.560 --> 00:43:43.040
So each of them tries to then check out the shuttle.


00:43:43.040 --> 00:43:48.120
But since they have each locked the row


00:43:48.120 --> 00:43:52.880
that the other needs to modify, they then deadlock.


00:43:52.880 --> 00:43:57.000
This then gets into fancy old database theory


00:43:57.000 --> 00:43:59.340
of deadlock detection and resolution,


00:43:59.340 --> 00:44:02.320
which is the subject of many textbooks.


00:44:02.320 --> 00:44:06.880
But essentially, you're probably going to block


00:44:06.880 --> 00:44:09.540
for some period of time,


00:44:09.540 --> 00:44:12.200
and then a deadlock detector will come along


00:44:12.200 --> 00:44:14.560
and abort one of the transactions


00:44:14.560 --> 00:44:16.120
to allow the other to continue.


00:44:16.120 --> 00:44:21.000
- Right, making your code more complex,


00:44:21.000 --> 00:44:22.560
harder to work with, right?


00:44:22.560 --> 00:44:26.720
And now your code needs to be able to handle this situation.


00:44:26.720 --> 00:44:28.840
If you are awarded due to deadlock,


00:44:28.840 --> 00:44:31.040
should you retry that transaction or not?


00:44:31.040 --> 00:44:33.720
That's now something that the developer


00:44:33.720 --> 00:44:36.200
needs to make a decision about.


00:44:36.200 --> 00:44:37.640
>> Yeah.


00:44:37.640 --> 00:44:39.000
OK.


00:44:39.000 --> 00:44:41.680
So all of this that we've discussed so far


00:44:41.680 --> 00:44:47.960
has to do with one or more database servers that just--


00:44:47.960 --> 00:44:50.920
the requirement is that it allows concurrent queries


00:44:50.920 --> 00:44:53.240
and updates and all that.


00:44:53.240 --> 00:44:58.040
On the other side, we might have some kind


00:44:58.040 --> 00:45:02.540
of distributed topology with in MongoDB case,


00:45:02.540 --> 00:45:04.840
we have both replication and sharding,


00:45:04.840 --> 00:45:07.760
which maybe worth touching on those things.


00:45:07.760 --> 00:45:10.880
But in a lot of scale out situations,


00:45:10.880 --> 00:45:14.320
you have some sort of data spread around


00:45:14.320 --> 00:45:15.800
some kind of distributed database,


00:45:15.800 --> 00:45:20.800
or even you'll see like geo-replicated data


00:45:20.800 --> 00:45:25.800
I want to have my data replicated in Asia and the US


00:45:25.800 --> 00:45:29.800
so that we can run our server-side code near data


00:45:29.800 --> 00:45:31.800
for those different users, right?


00:45:31.800 --> 00:45:35.800
- Right. - And that's the consistency,


00:45:35.800 --> 00:45:39.800
not the isolation side of your talk, right?


00:45:39.800 --> 00:45:42.800
- That's right. So to review,


00:45:42.800 --> 00:45:47.800
isolation is a response to anomalies caused by concurrency


00:45:47.800 --> 00:45:58.320
concurrency on one machine, and then consistency is a response to anomalies that are due to


00:45:58.320 --> 00:46:04.080
replication in a distributed database.


00:46:04.080 --> 00:46:10.240
So the distributed database, you always write to one of the nodes or you read from one of


00:46:10.240 --> 00:46:14.560
the nodes for any particular operation.


00:46:14.560 --> 00:46:19.240
And there are different rules about, is there only one leader that can take writes or can


00:46:19.240 --> 00:46:22.160
any node take writes?


00:46:22.160 --> 00:46:24.880
Is there, can you only read from the leader?


00:46:24.880 --> 00:46:26.000
Can you read from any node?


00:46:26.000 --> 00:46:28.120
Can you only read from some of the nodes?


00:46:28.120 --> 00:46:37.000
But no matter what database you're using, you always read or write to some nodes and


00:46:37.000 --> 00:46:41.360
then they replicate writes to other nodes.


00:46:41.360 --> 00:46:44.480
And so there's always a lag because that replication


00:46:44.480 --> 00:46:47.560
takes time.


00:46:47.560 --> 00:46:50.760
So the most obvious example is if you write to the leader


00:46:50.760 --> 00:46:52.680
and then immediately read from the follower,


00:46:52.680 --> 00:46:58.640
the data that you just wrote may or may not be there yet.


00:46:58.640 --> 00:47:04.520
So that's the source of inconsistencies.


00:47:04.520 --> 00:47:10.760
And those inconsistencies are called anomalies as well.


00:47:10.760 --> 00:47:14.460
And then there are multiple isolation levels,


00:47:14.460 --> 00:47:16.200
sorry, consistency levels,


00:47:16.200 --> 00:47:21.220
which allow or prevent various of those.


00:47:21.220 --> 00:47:25.960
This is not standardized by the way.


00:47:25.960 --> 00:47:29.720
So here you're going to see different terms


00:47:29.720 --> 00:47:32.440
and then even more upsetting,


00:47:32.440 --> 00:47:33.640
you'll see some of the same terms,


00:47:33.640 --> 00:47:35.400
but they mean different things


00:47:35.400 --> 00:47:38.320
depending on which database documentation you're using


00:47:38.320 --> 00:47:39.800
or which paper you're reading.


00:47:39.800 --> 00:47:45.680
So I talked about three levels, eventual consistency,


00:47:45.680 --> 00:47:50.840
causal consistency, and linearizability in my talk,


00:47:50.840 --> 00:47:53.200
which I think is kind of a good sample.


00:47:53.200 --> 00:47:59.000
But this area of computer science


00:47:59.000 --> 00:48:06.880
is a lot less paved than isolation is.


00:48:06.880 --> 00:48:08.040
Yeah, I agree with that.


00:48:08.040 --> 00:48:10.720
And it also seems to me like it really matters


00:48:10.720 --> 00:48:15.440
for the particular database server that you're using,


00:48:15.440 --> 00:48:20.000
what its flavor of distributed means, right?


00:48:20.000 --> 00:48:23.480
Like my understanding from MongoDB is replication


00:48:23.480 --> 00:48:28.120
is largely about reliability, failover, uptime,


00:48:28.120 --> 00:48:30.200
but the possibility of reading from a replica


00:48:30.200 --> 00:48:32.080
for some read scaling.


00:48:32.080 --> 00:48:32.920
- Exactly.


00:48:32.920 --> 00:48:34.700
- Whereas you might have another one,


00:48:34.700 --> 00:48:36.280
kind of with the example that I talked about


00:48:36.280 --> 00:48:41.280
with like, we want our data located in multiple geographies


00:48:41.280 --> 00:48:43.320
and all of them are kind of the local database


00:48:43.320 --> 00:48:45.400
for those areas.


00:48:45.400 --> 00:48:47.340
And so the types of issues you run into


00:48:47.340 --> 00:48:49.020
as well as the words you use,


00:48:49.020 --> 00:48:52.280
they probably vary somewhat, right?


00:48:52.280 --> 00:48:56.080
Because you're kind of solving different problems.


00:48:56.080 --> 00:49:01.760
Well, we both know the MongoDB one pretty well.


00:49:01.760 --> 00:49:05.260
So maybe give us the story on like a replica set,


00:49:05.260 --> 00:49:09.220
which is, all of you talk about it.


00:49:09.220 --> 00:49:10.060
- Yeah.


00:49:10.060 --> 00:49:11.660
- What's the motivation of replica set


00:49:11.660 --> 00:49:14.860
and what are the challenges and different modes there?


00:49:14.860 --> 00:49:19.860
- Yeah, so 90%, 95% of people use MongoDB


00:49:19.860 --> 00:49:24.780
deploy it as a three node replica set.


00:49:24.780 --> 00:49:32.340
And 90 to 95% of the time, as you said,


00:49:33.500 --> 00:49:36.960
their goal is failover.


00:49:36.960 --> 00:49:43.280
That if the primary goes down,


00:49:43.280 --> 00:49:47.100
they want a very recent hot copy of their data available


00:49:47.100 --> 00:49:49.500
in a secondary, which will be promoted to primary


00:49:49.500 --> 00:49:52.140
as quickly as possible.


00:49:52.140 --> 00:49:59.460
And if you're writing to and reading from the primary,


00:50:02.740 --> 00:50:04.940
Somewhat surprisingly, you can still see anomalies


00:50:04.940 --> 00:50:08.340
because there could be a failover


00:50:08.340 --> 00:50:11.420
in between the time that you wrote to the primary


00:50:11.420 --> 00:50:13.060
and the time that you do that read,


00:50:13.060 --> 00:50:15.660
you might be reading from a different member


00:50:15.660 --> 00:50:17.820
which didn't get the copy.


00:50:17.820 --> 00:50:22.720
And so we've changed the default


00:50:22.720 --> 00:50:24.420
within the last few years, I think,


00:50:24.420 --> 00:50:30.180
to make every right wait


00:50:30.180 --> 00:50:33.420
to be replicated to a majority of the members.


00:50:33.420 --> 00:50:37.820
So that-- and then we've got a protocol that ensures that


00:50:37.820 --> 00:50:39.860
whoever becomes primary after a failover,


00:50:39.860 --> 00:50:42.020
therefore, is guaranteed to have that data.


00:50:42.020 --> 00:50:51.420
So you are-- with that setup, you're pretty well


00:50:51.420 --> 00:50:54.260
protected from anomalies.


00:50:54.260 --> 00:50:58.580
I'm sure that pedants and stress testers


00:50:58.580 --> 00:51:00.000
have found exceptions to those.


00:51:00.000 --> 00:51:01.580
So I'm not going to make any promises.


00:51:01.580 --> 00:51:04.340
But read or write for the primary--


00:51:04.340 --> 00:51:07.160
>>Maybe if your write to the primary


00:51:07.160 --> 00:51:09.660
is the thing that takes it down, potentially.


00:51:09.660 --> 00:51:12.220
Something really, really instantaneous almost.


00:51:12.220 --> 00:51:14.260
But yeah.


00:51:14.260 --> 00:51:15.780
>>There are always edge cases.


00:51:15.780 --> 00:51:17.060
>>Yeah, potentially.


00:51:17.060 --> 00:51:17.580
Yeah.


00:51:17.580 --> 00:51:18.420
OK.


00:51:18.420 --> 00:51:20.700
>>The real inconsistencies that you start to see


00:51:20.700 --> 00:51:23.380
is if you do secondary reads.


00:51:23.380 --> 00:51:26.380
So if you read from a follower, that


00:51:26.380 --> 00:51:31.580
can be useful because you're shifting load from the primary


00:51:31.580 --> 00:51:36.340
or maybe the follower is located at a lower latency location


00:51:36.340 --> 00:51:39.060
on Earth to you.


00:51:39.060 --> 00:51:41.500
But it's always going to have some degree of lag


00:51:41.500 --> 00:51:44.500
compared to the primary.


00:51:44.500 --> 00:51:47.220
So by default, you're going to get


00:51:47.220 --> 00:51:51.120
what we call eventual consistency.


00:51:51.120 --> 00:51:54.860
Any write that occurs on the primary


00:51:54.860 --> 00:51:58.780
that gets acknowledged by a majority of the members


00:51:58.780 --> 00:52:02.140
will eventually be replicated to all of the members.


00:52:02.140 --> 00:52:05.260
So all of the members will pass through the same series


00:52:05.260 --> 00:52:11.460
of states as the primary does, at least the same set of states


00:52:11.460 --> 00:52:14.740
that the primary got majority acknowledgment of,


00:52:14.740 --> 00:52:16.060
to be extremely technical.


00:52:16.060 --> 00:52:22.300
But if you read from the primary and then a secondary


00:52:22.300 --> 00:52:23.900
and then a different secondary, you'll


00:52:23.900 --> 00:52:25.900
It's like you're jumping around in time


00:52:25.900 --> 00:52:28.780
because you'll always be reading a different version of the data


00:52:28.780 --> 00:52:31.420
and some of those versions will be older


00:52:31.420 --> 00:52:33.420
than the last version that you saw.


00:52:33.420 --> 00:52:37.420
In MongoDB, in order to make that happen,


00:52:37.420 --> 00:52:42.060
you've got to pass extra flags opting into this read


00:52:42.060 --> 00:52:45.420
from secondary thing, right, in the driver?


00:52:45.420 --> 00:52:46.460
Yes, that's right.


00:52:46.460 --> 00:52:49.820
We call that read preference and there are a bunch of options,


00:52:49.820 --> 00:52:51.740
but the default is just to read from the primary


00:52:51.740 --> 00:52:54.460
not see a lot of inconsistencies.


00:52:54.460 --> 00:52:56.140
- Okay.


00:52:56.140 --> 00:52:59.200
So you mentioned a couple,


00:52:59.200 --> 00:53:02.780
this is the eventual consistency issue.


00:53:02.780 --> 00:53:04.620
What are some of the other consistencies


00:53:04.620 --> 00:53:05.940
that you talked about?


00:53:05.940 --> 00:53:08.540
- So there's causal consistency,


00:53:08.540 --> 00:53:12.260
which I think is quite nice.


00:53:12.260 --> 00:53:17.260
You can get it in MongoDB by using the sessions API.


00:53:21.500 --> 00:53:26.500
And causal consistency ensures that every write that you do


00:53:26.500 --> 00:53:32.420
and everything affected by that write,


00:53:32.420 --> 00:53:35.020
you will be able to read its consequences.


00:53:35.020 --> 00:53:40.400
And here again, I think talking about the implementation


00:53:40.400 --> 00:53:42.300
really makes things a lot clearer than talking about


00:53:42.300 --> 00:53:45.500
like the abstract mathematical definition.


00:53:45.500 --> 00:53:48.420
So here's the way MongoDB does it.


00:53:50.260 --> 00:53:53.680
You connect a client, you do an update.


00:53:53.680 --> 00:53:57.820
The primary applies the update,


00:53:57.820 --> 00:54:02.340
sends it to, waits for a majority of members


00:54:02.340 --> 00:54:03.740
to acknowledge it.


00:54:03.740 --> 00:54:06.100
And then the primary also increments a counter.


00:54:06.100 --> 00:54:10.900
So let's say that counter is now, has the value four.


00:54:10.900 --> 00:54:13.980
And so it replies to the client and says,


00:54:13.980 --> 00:54:17.720
"Your update succeeded and the counter value is now four."


00:54:18.860 --> 00:54:20.940
Now you can read from a secondary,


00:54:20.940 --> 00:54:24.620
you can say, I want to read some value,


00:54:24.620 --> 00:54:27.540
but don't reply until your counter is at least four.


00:54:27.540 --> 00:54:31.020
Now in the background,


00:54:31.020 --> 00:54:33.440
secondaries are replicating from the primary,


00:54:33.440 --> 00:54:38.080
and they're also replicating the primary's counter value.


00:54:38.080 --> 00:54:42.900
And so only when they get to the number four or past,


00:54:42.900 --> 00:54:44.620
do they reply to your query.


00:54:44.620 --> 00:54:46.100
And they're also guaranteed at that point


00:54:46.100 --> 00:54:47.460
to have applied to that update


00:54:47.460 --> 00:54:50.260
that you just sent to the primary.


00:54:50.260 --> 00:54:51.100
- Okay.


00:54:51.100 --> 00:54:54.580
Yeah, that's a really cool solution.


00:54:54.580 --> 00:54:57.060
One of the problems, if you'll read from secondaries


00:54:57.060 --> 00:55:00.020
is imagine you're going to create a new account,


00:55:00.020 --> 00:55:01.440
let's say on a website.


00:55:01.440 --> 00:55:04.020
Go in there and say, here's my information.


00:55:04.020 --> 00:55:06.580
Yes, my password has a lowercase and uppercase


00:55:06.580 --> 00:55:09.860
and a special number and whatever, right?


00:55:09.860 --> 00:55:13.660
Say create, it inserts it into the primary,


00:55:13.660 --> 00:55:16.580
it responds, redirects back to the server and says,


00:55:16.580 --> 00:55:19.580
you're on your account page, let me just pull back


00:55:19.580 --> 00:55:21.640
from the database who you are to show your details


00:55:21.640 --> 00:55:22.820
on the page.


00:55:22.820 --> 00:55:26.980
And if, you know, that's basically instant, right?


00:55:26.980 --> 00:55:28.740
Down to ping time to the server.


00:55:28.740 --> 00:55:31.540
And you could potentially end up in a situation


00:55:31.540 --> 00:55:33.260
where you've just created an account,


00:55:33.260 --> 00:55:37.780
but then you hit a replica that has yet to receive that.


00:55:37.780 --> 00:55:40.620
So what you're saying is, if we use this concept


00:55:40.620 --> 00:55:45.620
of sessions, we'll get some kind of point in time marker


00:55:46.160 --> 00:55:50.520
that we're gonna wait until just MongoDB behind the scenes


00:55:50.520 --> 00:55:52.400
will basically block and say,


00:55:52.400 --> 00:55:55.320
we're still waiting on that answer, hold on for who it is


00:55:55.320 --> 00:55:59.920
until that replica makes that point in time or further.


00:55:59.920 --> 00:56:00.760
- Exactly.


00:56:00.760 --> 00:56:04.380
- Okay, yeah, that's excellent.


00:56:04.380 --> 00:56:08.320
Question from the audience from Marwan says,


00:56:08.320 --> 00:56:11.420
how do you keep the counter store consistent


00:56:11.420 --> 00:56:13.960
if you need to replicate it across regions?


00:56:15.440 --> 00:56:21.880
So the counter at any given moment in time


00:56:21.880 --> 00:56:24.160
will have different values on different replicas.


00:56:24.160 --> 00:56:27.040
But that's actually its purpose, is


00:56:27.040 --> 00:56:31.880
that it represents how caught up each of the members


00:56:31.880 --> 00:56:39.240
is on their shared sequence of operations.


00:56:39.240 --> 00:56:42.440
Once you have replicated a given operation,


00:56:42.440 --> 00:56:46.440
you've also updated your counter value to the counter value


00:56:46.440 --> 00:56:49.400
that the primary had when it did that operation.


00:56:49.400 --> 00:56:50.840
And so you're now consistent,


00:56:50.840 --> 00:56:52.640
but the primary may be ahead of that as well.


00:56:52.640 --> 00:56:57.000
Like there's never any absolute truth.


00:56:57.000 --> 00:56:59.280
There's only a sequence of operations


00:56:59.280 --> 00:57:00.480
in your position in it.


00:57:00.480 --> 00:57:03.480
- I think another important piece of information here


00:57:03.480 --> 00:57:05.360
is that you're writing to the leader.


00:57:05.360 --> 00:57:08.280
The leader always knows what its point in time number is


00:57:08.280 --> 00:57:09.640
and it can increment that.


00:57:09.640 --> 00:57:10.480
- That's right.


00:57:10.480 --> 00:57:13.240
And so that thing's always gonna be consistent


00:57:13.240 --> 00:57:15.880
and auto-incrementing forward.


00:57:15.880 --> 00:57:19.880
It's just a matter of how caught up are the replicas, right?


00:57:19.880 --> 00:57:21.120
- Exactly.


00:57:21.120 --> 00:57:25.760
And if you want the MongoDB terms for these,


00:57:25.760 --> 00:57:28.440
that sequence of operations is the op log


00:57:28.440 --> 00:57:31.380
and that counter is the op time.


00:57:31.380 --> 00:57:33.000
- Okay, yeah.


00:57:33.000 --> 00:57:34.540
And that's basically that op log.


00:57:34.540 --> 00:57:37.680
That's the thing that gets pushed to the replicas


00:57:37.680 --> 00:57:40.360
and is copied as it goes, yeah?


00:57:40.360 --> 00:57:41.200
- Exactly.


00:57:41.200 --> 00:57:43.880
- Which brings us a little bit back full circle


00:57:43.880 --> 00:57:46.960
to your talking about like these time series stream data.


00:57:46.960 --> 00:57:49.840
It's kind of like replicating across these clusters.


00:57:49.840 --> 00:57:52.160
- Yeah, that's right.


00:57:52.160 --> 00:57:57.160
The Oplog is the original streaming data at MongoDB


00:57:57.160 --> 00:57:59.680
and people have done all sorts of hacks on top of it.


00:57:59.680 --> 00:58:04.680
And we're making that kind of mechanism more and more general


00:58:04.680 --> 00:58:08.400
so you can do all sorts of different things


00:58:08.400 --> 00:58:09.920
with streams of operations.


00:58:09.920 --> 00:58:13.000
>> Cool.


00:58:13.000 --> 00:58:18.800
All right, well, do you think we've covered it, Jesse?


00:58:18.800 --> 00:58:19.440
>> The final--


00:58:19.440 --> 00:58:20.600
>> What did we miss then?


00:58:20.600 --> 00:58:24.280
What should we throw in here before we call it done?


00:58:24.280 --> 00:58:27.520
>> We can mention the final consistency level, which


00:58:27.520 --> 00:58:29.280
is called linearizability.


00:58:29.280 --> 00:58:34.640
And it's pretty easy to understand.


00:58:34.640 --> 00:58:37.760
If you do an operation and then you


00:58:37.760 --> 00:58:42.640
try to read the results of what you just did from any member,


00:58:42.640 --> 00:58:46.540
you are guaranteed to see that result.


00:58:46.540 --> 00:58:51.520
It's pretty much the strictest level of consistency,


00:58:51.520 --> 00:58:53.480
but it's also quite expensive and slow.


00:58:53.480 --> 00:58:57.720
So MongoDB does provide this, but it


00:58:57.720 --> 00:59:00.520
requires a lot of machination behind the scenes.


00:59:00.520 --> 00:59:03.360
So don't use it unless you need to.


00:59:03.360 --> 00:59:04.760
But if you do need it for something


00:59:04.760 --> 00:59:10.760
like if you're updating users password, where you want


00:59:10.760 --> 00:59:15.160
to make sure that every attempt to read that password


00:59:15.160 --> 00:59:17.320
will always get the freshest copy,


00:59:17.320 --> 00:59:22.920
then linearizability is the consistency level to use.


00:59:22.920 --> 00:59:25.040
Excellent.


00:59:25.040 --> 00:59:29.120
Well, I think they all sound pretty straightforward,


00:59:29.120 --> 00:59:33.080
but the consequences of choosing these different levels


00:59:33.080 --> 00:59:34.840
and then what that means for how you write code


00:59:34.840 --> 00:59:38.220
around those systems, it's pretty complex.


00:59:38.220 --> 00:59:40.240
And it also just this whole conversation


00:59:40.240 --> 00:59:44.600
has made me appreciate how much databases serve


00:59:44.600 --> 00:59:47.840
as the actual concurrency coordinators


00:59:47.840 --> 00:59:49.520
of modern applications.


00:59:49.520 --> 00:59:52.120
- That is a great point.


00:59:52.120 --> 00:59:56.720
- Yeah, I mean, you can write web apps or APIs or queues


00:59:56.720 --> 01:00:00.140
and just kind of almost forget that concurrency is happening


01:00:00.140 --> 01:00:01.600
and you just talk to the database


01:00:01.600 --> 01:00:04.000
And how can you forget that?


01:00:04.000 --> 01:00:06.000
Because it falls upon the database


01:00:06.000 --> 01:00:08.360
to keep this stuff hanging together.


01:00:08.360 --> 01:00:09.960
- Yep.


01:00:09.960 --> 01:00:10.800
- Cool.


01:00:10.800 --> 01:00:14.080
- So I think in the show notes or wherever,


01:00:14.080 --> 01:00:16.800
we should drop a link to a blog post that I wrote,


01:00:16.800 --> 01:00:20.520
which has a link to lots of papers


01:00:20.520 --> 01:00:22.600
and other places where you can learn more,


01:00:22.600 --> 01:00:27.240
because this is a very hard topic to learn,


01:00:27.240 --> 01:00:29.780
especially from a podcast or a conference talk.


01:00:30.800 --> 01:00:35.440
you need to read multiple times, maybe make flashcards.


01:00:35.440 --> 01:00:39.720
But I kind of hope that this way of talking about things


01:00:39.720 --> 01:00:43.440
where we focus on--


01:00:43.440 --> 01:00:46.760
yeah, right there.


01:00:46.760 --> 01:00:49.560
I think this way of talking about things where we think of,


01:00:49.560 --> 01:00:56.120
OK, isolation is a way of hiding the consequences of concurrency


01:00:56.120 --> 01:00:57.880
and consistency is a way of hiding


01:00:57.880 --> 01:01:00.680
the consequences of replication.


01:01:00.680 --> 01:01:03.440
That was a useful breakthrough for me,


01:01:03.440 --> 01:01:06.280
and so I hope it's useful for other people too.


01:01:06.280 --> 01:01:07.520
- Yeah, I'm sure it will be.


01:01:07.520 --> 01:01:10.560
And I'll definitely link this article in the show notes


01:01:10.560 --> 01:01:13.600
along with the consistency diagrams


01:01:13.600 --> 01:01:15.600
and all the other things.


01:01:15.600 --> 01:01:16.520
- Great.


01:01:16.520 --> 01:01:17.360
- Yeah, cool.


01:01:17.360 --> 01:01:19.240
All right, Jesse, thank you for being here.


01:01:19.240 --> 01:01:22.160
It's been really great to have you back on the show.


01:01:22.160 --> 01:01:23.480
- Thanks a lot, Michael.


01:01:23.480 --> 01:01:25.480
- Yeah, yeah, thanks for coming.


01:01:25.480 --> 01:01:26.320
See ya.


01:01:26.320 --> 01:01:36.320
[BLANK_AUDIO]

