WEBVTT

00:00:00.001 --> 00:00:05.000
>> Charlie, welcome back to Talk Python to Me. How are you doing?

00:00:05.000 --> 00:00:08.000
>> I'm good. Thanks so much for having me back. It's always a pleasure to be on here.

00:00:08.000 --> 00:00:17.000
>> Well, you are certainly making waves in the Python space these days with all of your projects and their fastness.

00:00:17.000 --> 00:00:21.000
I think you're known as the fast Python guy these days.

00:00:21.000 --> 00:00:25.000
Oh, that's not fast enough. We've got to use something from Astral.

00:00:25.000 --> 00:00:28.000
>> The fast Python tooling guy, maybe.

00:00:28.000 --> 00:00:35.000
>> Yeah, exactly. So interesting. We spoke, I think you've been on twice before, is that right?

00:00:35.000 --> 00:00:44.000
>> I think so, yeah. I came on once to talk about Ruff, and then I came on in March shortly after we did the first public release of uv.

00:00:44.000 --> 00:00:55.000
>> Right, right. And uv at that time, I'll let you tell people what uv is, but for those who know, it was kind of in the, it has pip-like features.

00:00:55.000 --> 00:01:06.000
And now it's got another layer to the onion or another shell to it. And that's actually why I invited you back, because there's a lot of interesting things to talk about there.

00:01:06.000 --> 00:01:09.000
>> Yeah, maybe like several more layers too.

00:01:09.000 --> 00:01:14.000
>> Okay, well, all right. Well, let's hear about them.

00:01:14.000 --> 00:01:30.000
So first of all, I guess, not everyone, believe it or not, not everyone listened to that first Ruff interview, R-U-F-F interview, and those kinds of things.

00:01:30.000 --> 00:01:37.000
So I suppose, maybe quick introductions to you, to Astral. How'd you get to where you are?

00:01:37.000 --> 00:01:49.000
>> Yeah, totally. Yeah, yeah, yeah. So I've been working on Python tooling full-time for a little under two years at this point.

00:01:49.000 --> 00:02:06.000
And my journey, I've been writing Python professionally for a long time, but my journey with Python tooling started with Ruff, which is a very fast Python linter, code formatter, and code transformation tool.

00:02:06.000 --> 00:02:13.000
And the sort of foundational idea of Ruff was, can we make really fast Python tooling?

00:02:13.000 --> 00:02:20.000
And so Ruff is written in Rust, but you don't need to have Rust installed or know anything about Rust to use it.

00:02:20.000 --> 00:02:23.000
You can just install it with pip or with whatever you're using.

00:02:23.000 --> 00:02:37.000
And that whole sort of story for me started from just working with Python a lot and asking if we could build sort of different Python tooling by using languages like Rust.

00:02:37.000 --> 00:02:46.000
So, you know, the first version of Ruff was very minimal, but it's grown from then to have, I don't know, something like 800 plus rules.

00:02:46.000 --> 00:02:52.000
If you've used tools like Lake 8 or Pylint in the past, Ruff can do similar things.

00:02:52.000 --> 00:02:55.000
So discover issues with your code without running it.

00:02:55.000 --> 00:02:57.000
It can also fix them automatically.

00:02:57.000 --> 00:03:05.000
And then if you've used tools like Black in the past for code formatting, Ruff can do a similar thing too, where it automatically formats your code.

00:03:05.000 --> 00:03:08.000
So that was how I first got started in Python tooling.

00:03:08.000 --> 00:03:13.000
And also how I first ended up on Talk Python was people were very interested in this when it came out.

00:03:13.000 --> 00:03:23.000
And I think it broke a lot of people's minds in the sense that it really changed what was possible.

00:03:23.000 --> 00:03:26.000
You know, maybe an analogy.

00:03:26.000 --> 00:03:36.000
So if you have unit tests, but to run the unit test takes 30 minutes, there's no one who doesn't just want to kill time, who's going to say, "I made a small change.

00:03:36.000 --> 00:03:39.000
Let me run the test and see how that change did."

00:03:39.000 --> 00:03:49.000
But if the test run in 50 milliseconds, you could just set up a thing to just run the test every time code changes and just have a green, red, and white.

00:03:49.000 --> 00:03:54.000
And I feel like Ruff did that for linting and formatting.

00:03:54.000 --> 00:04:05.000
For me, for example, I have it just run Ruff on, if I ask PyCharm to reformat the code, it uses Ruff to do that.

00:04:05.000 --> 00:04:09.000
Or you can check the box to say, "Run it when I hit save," because you won't notice a difference.

00:04:09.000 --> 00:04:11.000
You know what I mean?

00:04:11.000 --> 00:04:17.000
Yeah, I think that's been one of the really interesting things about working on tooling with the focus on performance has been,

00:04:17.000 --> 00:04:24.000
if you build things that are way, way faster than what currently exists, not just a little bit, but significantly faster,

00:04:24.000 --> 00:04:27.000
the ergonomics of the tool just change a lot.

00:04:27.000 --> 00:04:32.000
So maybe things that you only ran in CI before, you can now run locally.

00:04:32.000 --> 00:04:39.000
Maybe things that you now run locally, you can run on save as opposed to on commit or on explicit command.

00:04:39.000 --> 00:04:44.000
So that's been a big part of what we've seen with Ruff.

00:04:44.000 --> 00:04:52.000
And the other big piece, apart from performance, that I think we sort of accidentally made a lot of progress on with Ruff

00:04:52.000 --> 00:04:59.000
was just trying to make things simpler by bundling more stuff together.

00:04:59.000 --> 00:05:04.000
Because Ruff can do a lot of different things, and so you don't need to chain together as many tools

00:05:04.000 --> 00:05:08.000
to get the kind of setup that you might want to have in your Python projects.

00:05:08.000 --> 00:05:17.000
And so a lot of the things we've built with Ruff and with UV, they've had these kind of dual goals of being much faster,

00:05:17.000 --> 00:05:21.000
hopefully bringing in some interesting new features and functionality,

00:05:21.000 --> 00:05:28.000
but also trying to reduce a little bit of the fragmentation in the tooling and make it easier for people,

00:05:28.000 --> 00:05:33.000
especially for newcomers who are writing Python for the first time, to kind of get started.

00:05:33.000 --> 00:05:39.000
And we have, well, you have announcements. I have things to discuss with you about them,

00:05:39.000 --> 00:05:44.000
about making that even easier. So that's why some of the big features of UV,

00:05:44.000 --> 00:05:47.000
for example, what if I don't have Python? Not a problem.

00:05:47.000 --> 00:05:50.000
So that's pretty exciting, I think.

00:05:50.000 --> 00:05:51.000
Yeah.

00:05:51.000 --> 00:05:56.000
Yeah, we'll get into that. But I do want to just not get too far past it,

00:05:56.000 --> 00:06:01.000
because even though this episode is not about Ruff, two things.

00:06:01.000 --> 00:06:10.000
One, a theme of Astrals is we're going to take some tools or some kind of concept that's been around for a long time,

00:06:10.000 --> 00:06:15.000
redo it in Rust, but also not just, well, we ported over the code,

00:06:15.000 --> 00:06:18.000
but rethink some of the algorithms and some of the assumptions.

00:06:18.000 --> 00:06:24.000
And I think that's also a lot of what makes it faster, like the way uv works with caching and things like that.

00:06:24.000 --> 00:06:26.000
Yep.

00:06:26.000 --> 00:06:31.000
And there's been a lot of excitement and positivity about that.

00:06:31.000 --> 00:06:37.000
But I think there's also been a little suspicion of, wait a minute, if we write this in Rust,

00:06:37.000 --> 00:06:41.000
is it really for Python people, by Python people?

00:06:41.000 --> 00:06:47.000
Like, what's your take? I have some thoughts that are, I don't see it as a negative,

00:06:47.000 --> 00:06:54.000
but I think it's interesting just to discuss where does Rust actually belong here?

00:06:54.000 --> 00:07:04.000
Yeah, I mean, I think the way I view it is that just like Python itself is implemented in C,

00:07:04.000 --> 00:07:10.000
it makes some sense for the underlying tooling that people are using to be written in a different language

00:07:10.000 --> 00:07:18.000
if it means that you can ultimately build tools that are better, at least on some metrics that people care about.

00:07:18.000 --> 00:07:25.000
So for me, I sometimes view what we're doing as, we put all this investment into this tooling,

00:07:25.000 --> 00:07:30.000
we write all this stuff in Rust, which in theory incurs some cost for us.

00:07:30.000 --> 00:07:35.000
Maybe we move a little bit more slowly, maybe it's harder.

00:07:35.000 --> 00:07:41.000
And in doing so, we kind of give all these people who are running these commands hundreds of times a day

00:07:41.000 --> 00:07:43.000
a big boost in how they work.

00:07:43.000 --> 00:07:48.000
And they can keep writing Python, but have a better and better experience writing Python.

00:07:48.000 --> 00:07:53.000
So I don't think it actually really says anything personally.

00:07:53.000 --> 00:07:57.000
I don't really think it says anything about Python that we write the tooling in Rust.

00:07:57.000 --> 00:08:00.000
Because sometimes people will criticize Python for that,

00:08:00.000 --> 00:08:04.000
but different languages are useful and good for different things.

00:08:04.000 --> 00:08:07.000
And Python is an incredibly productive language.

00:08:07.000 --> 00:08:09.000
It's growing more and more every year.

00:08:09.000 --> 00:08:11.000
People love writing it.

00:08:11.000 --> 00:08:16.000
But maybe it's not the best language to write, a super high performance package manager.

00:08:16.000 --> 00:08:18.000
And that's totally fine, because we're going to do that.

00:08:18.000 --> 00:08:22.000
And everyone who's writing Python can benefit from it and can leverage it.

00:08:22.000 --> 00:08:31.000
I do think that one interesting piece here that we got a lot of skepticism around early on was like,

00:08:31.000 --> 00:08:37.000
how can people in the Python community contribute to this if it's not written in Python?

00:08:37.000 --> 00:08:40.000
How do you have a sustainable contributor base?

00:08:40.000 --> 00:08:47.000
And the interesting thing for me is I actually think we've had a really strong contributor base over time.

00:08:47.000 --> 00:08:53.000
We have, I don't know, somewhere between 400 and 500 contributors total maybe in Ruf.

00:08:53.000 --> 00:08:58.000
Most of those are one or two small, one or two commits, maybe just one or two time committers.

00:08:58.000 --> 00:09:02.000
But a lot of people have come to Ruf and said, I want to learn Rust.

00:09:02.000 --> 00:09:04.000
I come from the Python ecosystem.

00:09:04.000 --> 00:09:09.000
There's a part of this that's sort of native to what I know, which is the Python language, the Python semantics.

00:09:09.000 --> 00:09:13.000
And it's an entry point for me to learn Rust from other people who come from Python.

00:09:13.000 --> 00:09:18.000
So I think there is certainly a cost to engaging and a cost for contributors,

00:09:18.000 --> 00:09:22.000
because most of our users don't know Rust.

00:09:22.000 --> 00:09:27.000
But I don't think it's as steep as people would expect.

00:09:27.000 --> 00:09:35.000
And I think over time we have been able to grow a pretty healthy contributor base of many people who have never written Rust before.

00:09:35.000 --> 00:09:37.000
Yeah, I agree.

00:09:37.000 --> 00:09:43.000
And I was thinking the same thing that you pointed out, that Python itself is written in C.

00:09:43.000 --> 00:09:48.000
Generally speaking, of course, there's multiple runtimes and so on and so on.

00:09:48.000 --> 00:09:52.000
But CPython, the one that we generally use, is written in C.

00:09:52.000 --> 00:09:58.000
And I don't see why there should be an allegiance to C over Rust or anything.

00:09:58.000 --> 00:10:06.000
And a lot of the data science tools are written in C or Fortran even, something really wild like that.

00:10:06.000 --> 00:10:11.000
And Python is a way to kind of expose them and make them more accessible, more useful,

00:10:11.000 --> 00:10:14.000
and make people more productive on top of those.

00:10:14.000 --> 00:10:16.000
That's a native code.

00:10:16.000 --> 00:10:17.000
Yeah, yeah.

00:10:17.000 --> 00:10:21.000
A third example would be Jupyter, JupyterLab, Jupyter Notebook, all those things.

00:10:21.000 --> 00:10:28.000
When you talk to the contributors of those projects, they're down in TypeScript and JavaScript most of their day.

00:10:28.000 --> 00:10:32.000
So the data science folks don't have to write TypeScript and JavaScript.

00:10:32.000 --> 00:10:36.000
They just work in the tooling that's on the front end.

00:10:36.000 --> 00:10:41.000
And so it's kind of like, to me, it's kind of like, let's take one for the team.

00:10:41.000 --> 00:10:42.000
Yeah.

00:10:42.000 --> 00:10:45.000
We'll do this so we all benefit, but you don't have to.

00:10:45.000 --> 00:10:46.000
You don't have to do it.

00:10:46.000 --> 00:10:57.000
I actually think it's one of the real strengths of Python is the interoperability around native code and extension modules.

00:10:57.000 --> 00:11:05.000
It's actually a big part of Python, and it's a big part of why Python has succeeded.

00:11:05.000 --> 00:11:07.000
And I think that will actually become more--

00:11:07.000 --> 00:11:09.000
I mean, this is sort of going off on a tangent a little bit,

00:11:09.000 --> 00:11:16.000
but I think that will become a bigger and bigger part of what Python looks like and what it looks like to work with Python.

00:11:16.000 --> 00:11:22.000
Because I think Rust can actually play an interesting role here, because at least from my perspective,

00:11:22.000 --> 00:11:24.000
I do not have a systems programming background.

00:11:24.000 --> 00:11:30.000
I've definitely not written any C professionally.

00:11:30.000 --> 00:11:34.000
I don't think I've ever really written any C++.

00:11:34.000 --> 00:11:39.000
And Rust was my first sort of foray into that kind of programming.

00:11:39.000 --> 00:11:45.000
And I think, at least for me personally, I found it much more accessible.

00:11:45.000 --> 00:11:50.000
And so I think Rust and Python actually have this interesting story where Rust, to some degree,

00:11:50.000 --> 00:11:58.000
is this kind of like superpower low-level layer that you can drop into and then expose with a Python CLI forever in a consume.

00:11:58.000 --> 00:12:04.000
So anyway, my prediction is I think that will only become more and more of a part of what Python looks like.

00:12:04.000 --> 00:12:06.000
And I think that's actually a good thing.

00:12:06.000 --> 00:12:09.000
Yeah, I do too. I do too.

00:12:09.000 --> 00:12:14.000
Jake out in the audience, Jake Callahan, who says in another comment, "Great timing.

00:12:14.000 --> 00:12:17.000
I just released a video on these changes yesterday, so that's awesome."

00:12:17.000 --> 00:12:22.000
But said, "The progress made in Ruff and uv sensor introductions clearly demonstrates

00:12:22.000 --> 00:12:27.000
that there's a strong contributor base, even when it's based on Rust, right?"

00:12:27.000 --> 00:12:28.000
Yeah.

00:12:28.000 --> 00:12:29.000
I think another thing that--

00:12:29.000 --> 00:12:34.000
I'm not trying to dismiss that it's hard to learn Rust, because I actually think it is pretty hard to learn Rust.

00:12:34.000 --> 00:12:36.000
And I think the learning curve is pretty steep.

00:12:36.000 --> 00:12:41.000
But I think the thing we found is there are people who are interested and who want to do it.

00:12:41.000 --> 00:12:44.000
Sure. Sure. Agreed.

00:12:44.000 --> 00:12:53.000
I think another thing that it shows, regardless of Rust or not, is if it's your full-time job,

00:12:53.000 --> 00:12:58.000
and there's funding and a team, rather than part-time work,

00:12:58.000 --> 00:13:03.000
it can go many times faster towards a goal than before.

00:13:03.000 --> 00:13:05.000
I'm sure you've felt that way.

00:13:05.000 --> 00:13:10.000
Yeah. We're in a very unique-- I mean, not completely unique, but fairly unique position

00:13:10.000 --> 00:13:16.000
whereby we can fund people full-time to work on this stuff.

00:13:16.000 --> 00:13:23.000
It's actually just kind of wild to look at how much-- not to sort of talk up our own work,

00:13:23.000 --> 00:13:28.000
but just how much you can accomplish in a relatively short period of time with that level of--

00:13:28.000 --> 00:13:33.000
when people are kind of unlocked to work in that way and work on those kinds of problems.

00:13:33.000 --> 00:13:40.000
So just thinking-- it's like the amount of time we've been able to put into Ruff and UV

00:13:40.000 --> 00:13:43.000
is sort of hard to fathom for some open-source projects.

00:13:43.000 --> 00:13:45.000
It's like, "Wow, that's incredible."

00:13:45.000 --> 00:13:49.000
But from the perspective of a company, it's actually quite reasonable,

00:13:49.000 --> 00:13:52.000
and in fact, not even that much.

00:13:52.000 --> 00:13:56.000
So I think it's pretty-- the leverage that you have with open-source,

00:13:56.000 --> 00:14:01.000
when people are able to invest in it and really focus on it, is pretty amazing

00:14:01.000 --> 00:14:04.000
because we work on these things, we improve these things,

00:14:04.000 --> 00:14:08.000
and they ship out to, I don't know, millions of users or whatever it is,

00:14:08.000 --> 00:14:12.000
and really can provide a huge boost to the ecosystem.

00:14:12.000 --> 00:14:15.000
So yeah, being able to work on this stuff full-time,

00:14:15.000 --> 00:14:18.000
that was actually something that I decided pretty early on with Ruff,

00:14:18.000 --> 00:14:21.000
was the project was growing more and more popular,

00:14:21.000 --> 00:14:27.000
and I was like, "I don't know if I can keep up with this if I don't work on it full-time."

00:14:27.000 --> 00:14:31.000
And so I'm at least going to see where that goes.

00:14:31.000 --> 00:14:34.000
It's possible, right? Here you are.

00:14:34.000 --> 00:14:36.000
I mean, it is, but yeah, it's like--

00:14:36.000 --> 00:14:39.000
I mean, I just feel like-- I just have a lot of respect for people

00:14:39.000 --> 00:14:45.000
who commit significant amounts of their time to open-source alongside everything else.

00:14:45.000 --> 00:14:50.000
Because, yeah, I mean, it's an amazing thing, but it's also very challenging.

00:14:50.000 --> 00:14:54.000
- Oh, it definitely is. - And it's 24/7.

00:14:54.000 --> 00:15:00.000
Well, I think it's really positive that there's a group of people

00:15:00.000 --> 00:15:07.000
putting their full effort into especially the uv side of things.

00:15:07.000 --> 00:15:10.000
That's going to make a dent.

00:15:10.000 --> 00:15:18.000
Yeah, I mean, I think the other thing that's been cool about building this as a company

00:15:18.000 --> 00:15:24.000
is that we've been able to bring in a lot of people from outside of Python

00:15:24.000 --> 00:15:27.000
to come and work on Python tooling.

00:15:27.000 --> 00:15:30.000
And I think that's a really healthy thing for the ecosystem,

00:15:30.000 --> 00:15:36.000
because not only are these people, I think, really talented and really great,

00:15:36.000 --> 00:15:39.000
but they also bring very different ideas and experiences.

00:15:39.000 --> 00:15:41.000
And so we have a lot of cross-pollination on the team.

00:15:41.000 --> 00:15:46.000
The team's kind of a mix of people who fall everywhere on the spectrum of--

00:15:46.000 --> 00:15:48.000
or axes, I guess, probably not a spectrum--

00:15:48.000 --> 00:15:51.000
of how much Rust experience, how much Python experience they have.

00:15:51.000 --> 00:15:56.000
Some of them have mostly worked in TypeScript and the JavaScript ecosystem.

00:15:56.000 --> 00:15:59.000
So that was sort of an intentional thing for me when thinking about building a team

00:15:59.000 --> 00:16:02.000
to work on this stuff was I want to have some people on the team

00:16:02.000 --> 00:16:06.000
who are super deep Python experts, and I want to have some people

00:16:06.000 --> 00:16:09.000
who bring a totally different perspective to the problems.

00:16:09.000 --> 00:16:15.000
So that's been another very cool piece of putting together a team to work on this stuff.

00:16:15.000 --> 00:16:17.000
I think that's a great perspective.

00:16:17.000 --> 00:16:21.000
All right, one thing before we move on is talk about uv proper.

00:16:21.000 --> 00:16:23.000
Closing the loop here.

00:16:23.000 --> 00:16:27.000
You mentioned those rules, those 800 Lint rules.

00:16:27.000 --> 00:16:34.000
And this resource you have over at docs.astral.sh/ruff/rules is awesome.

00:16:34.000 --> 00:16:40.000
So even if you don't use Ruff, you care about, say, PEP 8 naming or something,

00:16:40.000 --> 00:16:47.000
you get a warning from Flake 8 or whatever, and it says "Under function name."

00:16:47.000 --> 00:16:50.000
What is this error, right? What is this thing?

00:16:50.000 --> 00:16:56.000
And then you've got each one of these rules has a "What is this? Why is it bad?

00:16:56.000 --> 00:17:01.000
How did you change it? Here's the bad version. Here's the good version."

00:17:01.000 --> 00:17:04.000
And so on. And I think this is just a really good resource.

00:17:04.000 --> 00:17:06.000
I know you all put a ton of time into it.

00:17:06.000 --> 00:17:08.000
I appreciate you calling that out. Yeah, it takes a lot of time.

00:17:08.000 --> 00:17:12.000
Once you cover all the rules, maintaining it incrementally is slightly easier.

00:17:12.000 --> 00:17:15.000
But when we started this, we had a few hundred rules.

00:17:15.000 --> 00:17:21.000
And so it was a lot of contributors who contributed us getting to full coverage here.

00:17:21.000 --> 00:17:25.000
It's almost like the Wikipedia of Lint rules or something.

00:17:25.000 --> 00:17:29.000
Yeah, I guess maybe one thing I'll say is we have a lot of rules,

00:17:29.000 --> 00:17:31.000
but you don't have to use them all.

00:17:31.000 --> 00:17:34.000
And the default rule set is actually pretty small.

00:17:34.000 --> 00:17:37.000
So even when I work on projects, I don't necessarily enable all the rules.

00:17:37.000 --> 00:17:39.000
I typically enable a couple subsets.

00:17:39.000 --> 00:17:44.000
So I just think sometimes it can be intimidating to imagine 800 rules being applied over your code base.

00:17:44.000 --> 00:17:46.000
So the default rule set is pretty small.

00:17:46.000 --> 00:17:52.000
It covers things like unused imports, things that are pretty common and relatively unobjectionable.

00:17:52.000 --> 00:17:57.000
And then we have all these different categories for ways that you can level up the level of coverage.

00:17:57.000 --> 00:18:02.000
Yeah. I take pretty much the defaults as well on all my projects,

00:18:02.000 --> 00:18:09.000
except for wider lines of code, more columns.

00:18:09.000 --> 00:18:10.000
Yeah.

00:18:10.000 --> 00:18:15.000
On a 32-inch monitor, 80 columns is just a little corner.

00:18:15.000 --> 00:18:17.000
We actually took that out of the defaults.

00:18:17.000 --> 00:18:19.000
Did you? Oh, beautiful.

00:18:19.000 --> 00:18:24.000
I don't need a rough.toml or whatever it was I was putting in there for a configuration.

00:18:24.000 --> 00:18:25.000
Yeah, we got rid of that.

00:18:25.000 --> 00:18:31.000
Because the thinking there is if you have long lines, they should generally be handled by a formatter, not a linter.

00:18:31.000 --> 00:18:34.000
So by default, we don't enforce that.

00:18:34.000 --> 00:18:35.000
Okay. Interesting.

00:18:35.000 --> 00:18:40.000
And then the single quotes versus double quotes, which we discussed on GitHub, I remember.

00:18:40.000 --> 00:18:42.000
I think we talked about it last time.

00:18:42.000 --> 00:18:43.000
Yeah, probably.

00:18:43.000 --> 00:18:44.000
Yeah.

00:18:44.000 --> 00:18:47.000
I talked about that with everyone.

00:18:47.000 --> 00:18:50.000
Yeah, and Miguel also agrees here.

00:18:50.000 --> 00:18:51.000
Amazing docs.

00:18:51.000 --> 00:18:52.000
The rules are top-notch.

00:18:52.000 --> 00:18:53.000
Nice work.

00:18:53.000 --> 00:18:55.000
I appreciate that.

00:18:55.000 --> 00:18:56.000
Okay.

00:18:56.000 --> 00:19:00.000
So I know we're going to talk EV, but Kishore does have a good question out there.

00:19:00.000 --> 00:19:04.000
And I don't know if speak to it or don't speak to it.

00:19:04.000 --> 00:19:08.000
Are there plans for Ruff to become a Pylance alternative?

00:19:08.000 --> 00:19:11.000
So a language server of some sort.

00:19:11.000 --> 00:19:14.000
Is this anything you're willing to talk about?

00:19:14.000 --> 00:19:18.000
I mean, yeah, I think that's an interesting thing that we'll consider.

00:19:18.000 --> 00:19:25.000
It's not something that we are committed to doing or committed not to doing, building a language server.

00:19:25.000 --> 00:19:30.000
I would say that's probably a few steps away from where we are today.

00:19:30.000 --> 00:19:37.000
Because before we would build a language server, we would probably build something like a type checker.

00:19:37.000 --> 00:19:43.000
Something that could deal with type inference and better understand the relationships between different parts of your code.

00:19:43.000 --> 00:19:49.000
I view that as like, it's not strictly a prerequisite to building a language server, but I view that as a little bit more of a path.

00:19:49.000 --> 00:19:51.000
More mypy?

00:19:51.000 --> 00:19:53.000
Yeah, more mypy.

00:19:53.000 --> 00:19:59.000
I think there's a lot of interesting stuff around building a, well, first of all, of course, there's building a type checker.

00:19:59.000 --> 00:20:04.000
But there's also building what I would call a type-aware linter.

00:20:04.000 --> 00:20:10.000
You could imagine that Ruff itself could actually get a lot more powerful if it could do all sorts of type inference.

00:20:10.000 --> 00:20:13.000
We have some rules that are only supposed to activate on dictionaries.

00:20:13.000 --> 00:20:20.000
And we do some sort of bad local type inference and heuristics to figure out if we think a variable is a dictionary.

00:20:20.000 --> 00:20:24.000
Like if you call not get on it, it might be a dictionary, right?

00:20:24.000 --> 00:20:27.000
So if we knew, there's just a lot of interesting things we could do.

00:20:27.000 --> 00:20:28.000
We could build a much better tool.

00:20:28.000 --> 00:20:31.000
So it's not just about building a type checker.

00:20:31.000 --> 00:20:35.000
It's also about how can we build a much better linter and sort of like set of tools.

00:20:35.000 --> 00:20:37.000
But yeah, we're thinking about that a lot.

00:20:37.000 --> 00:20:44.000
There's a lot of discussion happening about that, both internally and publicly on the repo and the Discord.

00:20:44.000 --> 00:20:48.000
We're thinking a lot about sort of type inference and how to evolve Ruff in that direction.

00:20:48.000 --> 00:20:51.000
So yeah, language server may be something we can do eventually.

00:20:51.000 --> 00:20:54.000
It's obviously a huge undertaking.

00:20:54.000 --> 00:21:02.000
And we want to make sure that like anything we decide to build, we feel a lot of conviction, you know, that it can be great.

00:21:02.000 --> 00:21:08.000
Because it's not, doesn't necessarily make sense for us to try and build something that we think is like 5% better than what's out there.

00:21:08.000 --> 00:21:11.000
It's very hard to get users to switch to something that's 5% better.

00:21:11.000 --> 00:21:16.000
So, you know, when we look at the opportunity set, we're kind of thinking about where can we have a big impact?

00:21:16.000 --> 00:21:18.000
What do users really want?

00:21:18.000 --> 00:21:25.000
You know, cross-referenced against where do we think there's opportunity to build something that would be an improvement in ways that users care about?

00:21:25.000 --> 00:21:27.000
So yeah, very interesting.

00:21:27.000 --> 00:21:29.000
Not something we're focused on right now.

00:21:29.000 --> 00:21:30.000
The language server piece at least.

00:21:30.000 --> 00:21:31.000
Yeah.

00:21:31.000 --> 00:21:33.000
You guys are going to need at least a few weeks to get to that, huh?

00:21:33.000 --> 00:21:35.000
We're going to need a few weeks to get to language server.

00:21:35.000 --> 00:21:36.000
Yeah.

00:21:36.000 --> 00:21:37.000
All right.

00:21:37.000 --> 00:21:40.000
Ivan out there in the audience says, "Excellent tool.

00:21:40.000 --> 00:21:42.000
Ruff and uv have changed my life."

00:21:42.000 --> 00:21:43.000
I've talked about Ruff.

00:21:43.000 --> 00:21:44.000
That's very nice.

00:21:44.000 --> 00:21:45.000
Yeah.

00:21:45.000 --> 00:21:49.000
UV, maybe a quick summary for what it is.

00:21:49.000 --> 00:21:55.000
And then we could talk about your post, which adds layers of features and capabilities as we get started.

00:21:55.000 --> 00:21:57.000
Yeah, totally.

00:21:57.000 --> 00:22:03.000
So I came on the show back in March, and we talked a bit about what uv was at the time.

00:22:03.000 --> 00:22:07.000
We released uv in mid-February, so that was a couple weeks after.

00:22:07.000 --> 00:22:11.000
And uv is our Python packaging tool.

00:22:11.000 --> 00:22:22.000
And it's built under a lot of the same sort of design goals as we had for Ruff.

00:22:22.000 --> 00:22:25.000
So we wanted it to be extremely fast.

00:22:25.000 --> 00:22:33.000
We wanted it to try and bundle a few more things together so that you could use fewer tools to work with Python and be productive with Python.

00:22:33.000 --> 00:22:36.000
And we wanted it to be really easy to adopt.

00:22:36.000 --> 00:22:39.000
That was another principle that we thought about a lot.

00:22:39.000 --> 00:22:47.000
So when we released uv in February, it was framed as a pip alternative.

00:22:47.000 --> 00:22:58.000
So the idea was if you've used pip before, pip install, pip uninstall, or tools like pip compile or pip sync, it should be really familiar to you.

00:22:58.000 --> 00:23:04.000
So the API that we started with was like uv pip install, uv pip uninstall, uv pip compile.

00:23:04.000 --> 00:23:07.000
And it was meant to kind of mirror the pip API.

00:23:07.000 --> 00:23:15.000
And the idea there was we wanted it to hopefully be immediately obvious to people how this tool works and what it does.

00:23:15.000 --> 00:23:18.000
And also, I guess, to some degree, what it doesn't do.

00:23:18.000 --> 00:23:25.000
So we released that in February, and it grew extremely fast.

00:23:25.000 --> 00:23:34.000
It's just the adoption, both in terms of raw numbers and just the companies that we talked to that are using it, very quickly, a lot of people were using it.

00:23:34.000 --> 00:23:36.000
I consider it a big success.

00:23:36.000 --> 00:23:38.000
I'm really happy with how that went.

00:23:38.000 --> 00:23:45.000
But it was also, I think, a pretty small-- it was sort of a small portion of what we wanted to build for packaging.

00:23:45.000 --> 00:23:49.000
Ultimately, we weren't trying to build just a faster pip.

00:23:49.000 --> 00:23:55.000
I think that's a really good starting point for a couple of reasons.

00:23:55.000 --> 00:23:58.000
One, much easier for people to adopt.

00:23:58.000 --> 00:24:05.000
Two, it required us to build a lot of the fundamental pieces that you need for Python packaging.

00:24:05.000 --> 00:24:15.000
In order to build a pip alternative, we had to be able to resolve Python dependencies, install Python packages, understand virtual environments, manipulate all those things.

00:24:15.000 --> 00:24:23.000
We had to implement a bunch of standards around introspecting, build distributions and source distributions and virtual environments.

00:24:23.000 --> 00:24:30.000
So we had to invest in all these things that I view as kind of like fundamental primitives of working with Python packaging.

00:24:30.000 --> 00:24:41.000
But the ultimate goal for us was always, we want to build something that's like a single static binary that you download and install, that just gives you everything you need to be productive with Python.

00:24:41.000 --> 00:24:46.000
And from that perspective, a pip alternative is pretty low level.

00:24:46.000 --> 00:24:54.000
And we wanted to build something that was a little bit more high level, something that can install Python for you, something that can manage the virtual environment for you,

00:24:54.000 --> 00:25:02.000
something where you just do run this file and it figures out the dependencies, installs them, it creates the environments and it runs this file in the environment.

00:25:02.000 --> 00:25:04.000
That is what we wanted to build.

00:25:04.000 --> 00:25:07.000
So that's what we've been building up to over the past couple of months.

00:25:07.000 --> 00:25:10.000
Yeah, amazing.

00:25:10.000 --> 00:25:15.000
Of course, you've got to have the uv pip features as a foundation, right?

00:25:15.000 --> 00:25:19.000
Because even if you don't, kind of like we talked earlier,

00:25:19.000 --> 00:25:29.000
even if you don't expose it directly as a CLI thing from a project management perspective, it's needed, right?

00:25:29.000 --> 00:25:30.000
Yeah.

00:25:30.000 --> 00:25:36.000
And it's part of meeting people where they are to a certain degree.

00:25:36.000 --> 00:25:39.000
Everyone has workflows that are built around pip.

00:25:39.000 --> 00:25:46.000
Even people that have other packaging workflows, often those workflows are actually built around pip commands.

00:25:46.000 --> 00:25:49.000
And like I said, I view those as a little bit low level.

00:25:49.000 --> 00:25:58.000
With pip, the operations are kind of like install this package into this environment, as opposed to here are my dependencies, make sure the world is in sync with my dependencies.

00:25:58.000 --> 00:26:00.000
That's what I would consider to be a little bit more high level.

00:26:00.000 --> 00:26:04.000
So we built and released that pip interface in February.

00:26:04.000 --> 00:26:09.000
And since then, it's basically been hammered by users.

00:26:09.000 --> 00:26:18.000
So it's just gotten better and better because they find problems with it and then report them and it just gets better, it gets faster, it's more feature complete.

00:26:18.000 --> 00:26:21.000
So we've had a few months to kind of improve it and build on top of it too.

00:26:21.000 --> 00:26:31.000
Yeah, that's one of the benefits of such it taking hold so much and people using it so much is they hit the little edge cases all the time.

00:26:31.000 --> 00:26:33.000
Yeah, a lot of edge cases.

00:26:33.000 --> 00:26:36.000
Yeah, my bad.

00:26:36.000 --> 00:26:52.000
Yeah, but it's super fun, like set of problems to work on, by the way, and like really different from rough to like, yeah, rough is more like a compiler.

00:26:52.000 --> 00:26:57.000
I would say like we have like a parser and a lexer, you know, all that kind of stuff.

00:26:57.000 --> 00:27:02.000
And with UV, it's a lot more, how do we do IO really fast?

00:27:02.000 --> 00:27:05.000
Like we have a lot of networking, we're like reading and writing from disk a lot.

00:27:05.000 --> 00:27:12.000
There's a lot of interfacing with standards, a lot of interfacing with the registry, everything's async.

00:27:12.000 --> 00:27:15.000
So it's just like a very different set of problems.

00:27:15.000 --> 00:27:19.000
And it's fun to get to kind of work on both of them because they're just really different.

00:27:19.000 --> 00:27:21.000
Yeah, I'm sure they're both fun projects.

00:27:21.000 --> 00:27:27.000
And there's some really good ideas and questions in the audience, but we're not ready for them.

00:27:27.000 --> 00:27:42.000
So I think when we spoke back in March, one of the things we discussed is how you structured the CLI API in a way to leave space.

00:27:42.000 --> 00:27:47.000
So for example, it's not uv install package, it's uv pip install package.

00:27:47.000 --> 00:27:55.000
And it's not uv compile --update for dependence, it's uv pip compile or whatever the command is.

00:27:55.000 --> 00:27:59.000
I have it alias to a couple of letters and I never think about it again.

00:27:59.000 --> 00:28:05.000
But something that's, you've left space in the CLI with these subcommands.

00:28:05.000 --> 00:28:10.000
And I think now we're starting to see why you left space.

00:28:10.000 --> 00:28:15.000
Yeah, that was pretty controversial at the time and users really hated it.

00:28:15.000 --> 00:28:21.000
I mean, they still used it, but it was a lot of people complained about it.

00:28:21.000 --> 00:28:27.000
I even found myself saying, maybe we should stop doing this.

00:28:27.000 --> 00:28:32.000
Maybe we should just give up because people were complaining and I was annoyed by it and stuff.

00:28:32.000 --> 00:28:38.000
But yeah, it's either a huge, obviously, it's either a terrible mistake or it was genius.

00:28:38.000 --> 00:28:44.000
I don't actually know, but what it did was, one effect, which I said before,

00:28:44.000 --> 00:28:49.000
was it immediately conveyed the rough shape of the commands, like uv pip install.

00:28:49.000 --> 00:28:54.000
And then if you've used pip install, you know that the next argument is like a package name or a requirements file.

00:28:54.000 --> 00:29:02.000
But the other thing it did is it left space in the CLI for these new APIs that are sort of first class uv APIs.

00:29:02.000 --> 00:29:08.000
So instead of doing uv install, when we released in February, it was uv pip install,

00:29:08.000 --> 00:29:15.000
which meant that today, this new set of APIs that we launched, let's see, two weeks ago, I think today.

00:29:15.000 --> 00:29:19.000
Scroll up, is there a date? There you go, August 20th.

00:29:19.000 --> 00:29:25.000
So this new set of APIs that we released are uv lock, uv sync, uv run.

00:29:25.000 --> 00:29:31.000
They can all be top level because they're really the first class uv workflows.

00:29:31.000 --> 00:29:38.000
The pip API, by the way, still 100% there and we're going to invest in it a lot and continue maintaining it

00:29:38.000 --> 00:29:42.000
because that is how most people use uv.

00:29:42.000 --> 00:29:45.000
And maybe eventually we want that to be less true, right?

00:29:45.000 --> 00:29:49.000
We hope more and more people use the new stuff, but we're going to keep building that.

00:29:49.000 --> 00:29:55.000
But for projects that can, we now have this new interface that if you can fit into it,

00:29:55.000 --> 00:29:57.000
it's just sort of more powerful and does more for you.

00:29:57.000 --> 00:30:04.000
So we saved space in the CLI exactly for this reason, which is we had a bunch of stuff we knew we wanted to build.

00:30:04.000 --> 00:30:10.000
And if we polluted, well, not polluted is the wrong word, but if we polluted the interface with uv install.

00:30:10.000 --> 00:30:13.000
- Clogged, if you clogged it. - Yeah.

00:30:13.000 --> 00:30:17.000
If we lost all that space to those existing commands, it would make things harder.

00:30:17.000 --> 00:30:22.000
So I think it's worked. It's done. It's had the intended effect for us.

00:30:22.000 --> 00:30:27.000
It kept the space open. It let people use it, conveyed how it works.

00:30:27.000 --> 00:30:29.000
And now they kind of exist alongside each other.

00:30:29.000 --> 00:30:32.000
And the pip API, you can kind of use them together in certain ways.

00:30:32.000 --> 00:30:37.000
And when you use them together, you sort of realize that the pip API is more low level.

00:30:37.000 --> 00:30:42.000
It's like the new APIs, you have a PyProject.toml file with your requirements in it,

00:30:42.000 --> 00:30:47.000
and you just run uv sync and it will resolve them, create a lock file, install them in a virtual environment.

00:30:47.000 --> 00:30:51.000
It's like one command. You could then modify the virtual environment.

00:30:51.000 --> 00:30:55.000
You could do uv pip install, blah, blah, blah, and start making edits to it.

00:30:55.000 --> 00:30:59.000
That kind of illustrates what I mean by it's like a low level pip API

00:30:59.000 --> 00:31:02.000
is where you're kind of manually manipulating things versus these higher level APIs

00:31:02.000 --> 00:31:07.000
where you tell us what your dependencies are and then we figure everything out for you.

00:31:07.000 --> 00:31:15.000
Yeah, that's excellent. Just one comment on the, it's too many words or it's too long or whatever.

00:31:15.000 --> 00:31:19.000
Like I hinted at before, I just have aliases for these.

00:31:19.000 --> 00:31:26.000
So for example, I just type PIR and that means uv pip install -r requirements.txt.

00:31:26.000 --> 00:31:30.000
I don't care if it's uv pip that or it's pip install dash, like whatever.

00:31:30.000 --> 00:31:34.000
I don't want to type any of those. So it's just three PIRs, let's go.

00:31:34.000 --> 00:31:38.000
And I've got three or four of those, one to make virtual environments with UV

00:31:38.000 --> 00:31:42.000
and a couple of things like that, and one to compile the changes.

00:31:42.000 --> 00:31:48.000
For me, I look up the docs, I go, "Okay, well, here's how I'm going to shorten that

00:31:48.000 --> 00:31:52.000
to something I never think about again."

00:31:52.000 --> 00:31:56.000
That's totally fine.

00:31:56.000 --> 00:32:00.000
I guess the workflow for new people.

00:32:00.000 --> 00:32:04.000
Maybe that's a good place to talk about the features here.

00:32:04.000 --> 00:32:06.000
There's a lot here.

00:32:06.000 --> 00:32:11.000
One of the things that, even though it's number three on the list of four things,

00:32:11.000 --> 00:32:21.000
is the Python command. So uv python install, uv python list, all of those kinds of things.

00:32:21.000 --> 00:32:26.000
Maybe we should start there because without that, we don't have any Python.

00:32:26.000 --> 00:32:31.000
Although that runs implicitly under some circumstances, right?

00:32:31.000 --> 00:32:38.000
Correct. Part of what we wanted to do with this release was make uv self-bootstrapping,

00:32:38.000 --> 00:32:44.000
which sounds complicated, but the idea there is if you don't have Python installed,

00:32:44.000 --> 00:32:47.000
UV doesn't depend on Python, it's just a binary.

00:32:47.000 --> 00:32:53.000
So you download it, and then when you run a command like uv VM, and you give us a Python version,

00:32:53.000 --> 00:32:56.000
if you don't have any Python installed, if you don't have that version installed,

00:32:56.000 --> 00:32:58.000
we will download and install it for you.

00:32:58.000 --> 00:33:01.000
So you can sort of seamlessly run these commands without worrying about

00:33:01.000 --> 00:33:05.000
how do I install Python, where is my Python, etc., etc.

00:33:05.000 --> 00:33:11.000
Which means that we can achieve this really cool experience where the whole set of commands

00:33:11.000 --> 00:33:16.000
you need to create a Python application are like, you curl install UV,

00:33:16.000 --> 00:33:21.000
and then you just run like uv init --python, and we create a project for you,

00:33:21.000 --> 00:33:24.000
we download and install that version of Python, you can just start running things.

00:33:24.000 --> 00:33:27.000
You don't have to think about how do I install Python, how do I get it on my machine,

00:33:27.000 --> 00:33:29.000
do I have the versions I need, anything like that.

00:33:29.000 --> 00:33:33.000
So you can obviously turn this stuff off, right, and you can use your own,

00:33:33.000 --> 00:33:36.000
it also respects Pythons that you have on your machine already.

00:33:36.000 --> 00:33:40.000
But part of the goal was we wanted to get to this, I won't call it the holy grail,

00:33:40.000 --> 00:33:44.000
but this experience of you just download the binary, you do uv run,

00:33:44.000 --> 00:33:47.000
and everything just works.

00:33:47.000 --> 00:33:49.000
So that was a big part of it.

00:33:49.000 --> 00:33:54.000
And if you look at the full list of things that we put in this release,

00:33:54.000 --> 00:33:58.000
there's kind of a lot of stuff, right?

00:33:58.000 --> 00:34:03.000
There's like four bullets of things that each of those could be like a big release.

00:34:03.000 --> 00:34:08.000
One is the Python installation, one is we have this sort of tool install,

00:34:08.000 --> 00:34:12.000
kind of like PIPX, so if you want to install Ruff globally,

00:34:12.000 --> 00:34:15.000
you can do uv tool install Ruff, and we'll install it for you,

00:34:15.000 --> 00:34:17.000
it'll get put in your path, everything like that.

00:34:17.000 --> 00:34:20.000
We have these project management APIs that I've hinted at a little bit

00:34:20.000 --> 00:34:24.000
throughout this conversation, like uv run, uv lock, uv sync.

00:34:24.000 --> 00:34:25.000
Yeah, we'll get into it.

00:34:25.000 --> 00:34:28.000
Yeah, we have this thing around script execution.

00:34:28.000 --> 00:34:32.000
So for a long time, I thought that these would actually all be separate releases,

00:34:32.000 --> 00:34:36.000
that we would do like a staggered series of releases.

00:34:36.000 --> 00:34:39.000
And I was excited about that because, well, first of all, that's always fun.

00:34:39.000 --> 00:34:42.000
Like you kind of like have a bunch of things and you're like shipping

00:34:42.000 --> 00:34:44.000
like one week, one week, one week, and everyone's like,

00:34:44.000 --> 00:34:46.000
oh my gosh, we're shipping so much stuff.

00:34:46.000 --> 00:34:49.000
But the thing we found was like, they're all kind of interconnected

00:34:49.000 --> 00:34:50.000
in subtle ways.

00:34:50.000 --> 00:34:53.000
And like the project management and the tool API,

00:34:53.000 --> 00:34:56.000
they're just not as interesting if you don't have like the Python API.

00:34:56.000 --> 00:34:59.000
Like they are interesting, but the fact that we have the complete story

00:34:59.000 --> 00:35:02.000
of like you do uv run and we install Python,

00:35:02.000 --> 00:35:04.000
we've resolved your dependencies, we install your dependencies,

00:35:04.000 --> 00:35:07.000
we run the command in the environment, like that whole picture,

00:35:07.000 --> 00:35:09.000
like everything's a little bit interconnected.

00:35:09.000 --> 00:35:12.000
So that's how this release came to be so much stuff is we had this vision

00:35:12.000 --> 00:35:14.000
for what we wanted the full stories to be,

00:35:14.000 --> 00:35:17.000
and they all became somewhat interconnected.

00:35:17.000 --> 00:35:19.000
And in the end, they're all like individually,

00:35:19.000 --> 00:35:22.000
I think really powerful things, but they kind of come together

00:35:22.000 --> 00:35:26.000
to give this what we want this Python experience to be.

00:35:26.000 --> 00:35:29.000
And we're not like totally there yet, you know, we're missing stuff for sure.

00:35:29.000 --> 00:35:33.000
But this was our attempt to capture kind of a couple different workflows

00:35:33.000 --> 00:35:38.000
that are intertwined in different ways.

00:35:38.000 --> 00:35:41.000
Yeah, I see how they all interconnect,

00:35:41.000 --> 00:35:46.000
but they are also interesting on their own.

00:35:46.000 --> 00:35:47.000
Yes.

00:35:47.000 --> 00:35:49.000
The Python installation thing is interesting.

00:35:49.000 --> 00:35:51.000
And usable on their own, by the way.

00:35:51.000 --> 00:35:52.000
Yeah, exactly.

00:35:52.000 --> 00:35:55.000
They're all independently, you just had one of those,

00:35:55.000 --> 00:35:57.000
you'd be like, that's pretty cool.

00:35:57.000 --> 00:35:58.000
Okay, I like that.

00:35:58.000 --> 00:36:00.000
That's pretty cool.

00:36:00.000 --> 00:36:03.000
So let's talk just a bit more about the Python one.

00:36:03.000 --> 00:36:09.000
So there's analogies here to other tools that people may know,

00:36:09.000 --> 00:36:13.000
and the closest one for this would be Pyenv, do you think?

00:36:13.000 --> 00:36:14.000
Yeah, probably.

00:36:14.000 --> 00:36:17.000
It's like there are obviously differences,

00:36:17.000 --> 00:36:21.000
but that's a very popular one that a lot of people know.

00:36:21.000 --> 00:36:23.000
Yeah, I'm not saying they're identical,

00:36:23.000 --> 00:36:28.000
but it fulfills a role that a lot of people were solving with it.

00:36:28.000 --> 00:36:31.000
Now, when I tried to do Pyenv,

00:36:31.000 --> 00:36:33.000
I don't remember what I was doing wrong,

00:36:33.000 --> 00:36:35.000
but this was the early days of Apple Silicon,

00:36:35.000 --> 00:36:42.000
and maybe I had the Intel X64 version of Homebrew,

00:36:42.000 --> 00:36:46.000
but I had the build tools for ARM, I can't remember.

00:36:46.000 --> 00:36:49.000
Yeah, trying to do something under Rosetta or something.

00:36:49.000 --> 00:36:53.000
Yeah, and I couldn't get it to install anything with Pyenv,

00:36:53.000 --> 00:36:57.000
because it would download it, it would try to compile it,

00:36:57.000 --> 00:36:59.000
then there'd be some weird compiler bug,

00:36:59.000 --> 00:37:02.000
and I'm like, "You know what? I'm not debugging the source of...

00:37:02.000 --> 00:37:04.000
I'm just not debugging this. I'm out.

00:37:04.000 --> 00:37:06.000
I'm just going to go download it."

00:37:06.000 --> 00:37:11.000
And also, I compile Python for some of the server stuff I'm doing,

00:37:11.000 --> 00:37:13.000
and it takes a while.

00:37:13.000 --> 00:37:16.000
It's not that fast.

00:37:16.000 --> 00:37:18.000
And when I get it from you guys,

00:37:18.000 --> 00:37:24.000
if I say, "UV Python install 3.12" or something, boom, I get it.

00:37:24.000 --> 00:37:27.000
In your standard style, it's fast.

00:37:27.000 --> 00:37:29.000
How is it fast?

00:37:29.000 --> 00:37:31.000
Yeah, so that comes down to a fundamental difference

00:37:31.000 --> 00:37:34.000
between what we're doing and what Py...

00:37:34.000 --> 00:37:36.000
I don't know if it's Pyenv or Pyenv, by the way.

00:37:36.000 --> 00:37:38.000
I think it's Pyenv, by the way.

00:37:38.000 --> 00:37:40.000
Okay, so I'm just going to say that, because what I'm used to.

00:37:40.000 --> 00:37:41.000
Let's go with that.

00:37:41.000 --> 00:37:43.000
If I do the other, I will mess up.

00:37:43.000 --> 00:37:47.000
So the way that Pyenv typically works is...

00:37:47.000 --> 00:37:49.000
It's a great tool, a lot of people use it.

00:37:49.000 --> 00:37:51.000
It's building Python from source, and there are trade-offs around this,

00:37:51.000 --> 00:37:55.000
but the idea is it will build the version of Python that you need.

00:37:55.000 --> 00:37:59.000
What we're doing is we're building a top-up project

00:37:59.000 --> 00:38:01.000
called Python Build Standalone,

00:38:01.000 --> 00:38:05.000
originally created by Greg Sork.

00:38:05.000 --> 00:38:07.000
And that's a project that we've started contributing to,

00:38:07.000 --> 00:38:10.000
so I think I did the last two releases, maybe.

00:38:10.000 --> 00:38:13.000
But the idea here is we have these standalone,

00:38:13.000 --> 00:38:16.000
easily redistributable Python builds.

00:38:16.000 --> 00:38:19.000
And when we do a release, it will create Python builds

00:38:19.000 --> 00:38:23.000
for a bunch of Linux architectures for macOS,

00:38:23.000 --> 00:38:26.000
for Windows, on all the different Python versions.

00:38:26.000 --> 00:38:30.000
And it will also run a bunch of optimizations over them.

00:38:30.000 --> 00:38:31.000
So it will do...

00:38:31.000 --> 00:38:34.000
These acronyms, it's not important that you understand them,

00:38:34.000 --> 00:38:36.000
but it can do link time optimization, or LTO,

00:38:36.000 --> 00:38:39.000
and profile guided optimization, PGO.

00:38:39.000 --> 00:38:41.000
So we build all the binaries in advance.

00:38:41.000 --> 00:38:42.000
That's pretty impressive.

00:38:42.000 --> 00:38:45.000
Yeah, that all happens in advance.

00:38:45.000 --> 00:38:47.000
So if you go to the releases page here,

00:38:47.000 --> 00:38:50.000
like scroll up a little bit,

00:38:50.000 --> 00:38:53.000
and just click the latest release,

00:38:53.000 --> 00:38:56.000
you'll see all the...

00:38:56.000 --> 00:38:58.000
Yeah, like 773 artifacts.

00:38:58.000 --> 00:39:01.000
That's like 773 Python builds.

00:39:01.000 --> 00:39:03.000
So it's a lot of different Pythons.

00:39:03.000 --> 00:39:05.000
Yeah, yeah, it's a lot of different Python builds.

00:39:05.000 --> 00:39:06.000
Yeah, 773 different...

00:39:06.000 --> 00:39:08.000
So we build all this stuff,

00:39:08.000 --> 00:39:10.000
and then when you run Python install,

00:39:10.000 --> 00:39:11.000
we figure out the correct...

00:39:11.000 --> 00:39:13.000
See, we have like R, and we have all this stuff.

00:39:13.000 --> 00:39:15.000
So then we figure out the correct Python for your machine,

00:39:15.000 --> 00:39:17.000
we just download and unzip it.

00:39:17.000 --> 00:39:20.000
The same way you get a wheel is the way you get this.

00:39:20.000 --> 00:39:22.000
Yeah, I mean, it's actually the same code pretty much

00:39:22.000 --> 00:39:23.000
like under the hood for us, right?

00:39:23.000 --> 00:39:26.000
It's like we stream and unzip it down into disk.

00:39:26.000 --> 00:39:28.000
And that's great.

00:39:28.000 --> 00:39:30.000
It's like super fast.

00:39:30.000 --> 00:39:31.000
It's also...

00:39:31.000 --> 00:39:34.000
They're already optimized, like PyPI by default

00:39:34.000 --> 00:39:36.000
does not compile with optimizations.

00:39:36.000 --> 00:39:37.000
You can compile with optimizations,

00:39:37.000 --> 00:39:39.000
but it's not what it does by default.

00:39:39.000 --> 00:39:42.000
So these will be noticeably faster

00:39:42.000 --> 00:39:45.000
than what you would get by default with PyM.

00:39:45.000 --> 00:39:47.000
There are some downsides,

00:39:47.000 --> 00:39:49.000
like some people like to build from source, right?

00:39:49.000 --> 00:39:51.000
They like to have effectively the full chain

00:39:51.000 --> 00:39:53.000
of reproducibility in the build.

00:39:53.000 --> 00:39:55.000
And now you're kind of trusting us

00:39:55.000 --> 00:39:56.000
to give you your Pythons.

00:39:56.000 --> 00:39:58.000
So that is a downside to some people.

00:39:58.000 --> 00:40:00.000
Yeah, but then the next thing you do

00:40:00.000 --> 00:40:01.000
is you pip install something

00:40:01.000 --> 00:40:04.000
that has a binary wheel anyway, so...

00:40:04.000 --> 00:40:07.000
Yeah, yeah, no, that is true.

00:40:07.000 --> 00:40:11.000
There are also a couple of quirks with these builds

00:40:11.000 --> 00:40:13.000
that we're working on a little bit.

00:40:13.000 --> 00:40:15.000
Some of it has to do with licensing,

00:40:15.000 --> 00:40:18.000
the fact that you want to have kind of a statically...

00:40:18.000 --> 00:40:20.000
You want to have a self-contained Python,

00:40:20.000 --> 00:40:22.000
and there are some things in there

00:40:22.000 --> 00:40:24.000
that require licensing changes.

00:40:24.000 --> 00:40:26.000
So, you know, it uses all...

00:40:26.000 --> 00:40:27.000
There are some slight deviations

00:40:27.000 --> 00:40:29.000
from what you would get with building from source

00:40:29.000 --> 00:40:31.000
from CPython, and those are documented

00:40:31.000 --> 00:40:33.000
in Python build standalone.

00:40:33.000 --> 00:40:35.000
But, you know, the general idea is

00:40:35.000 --> 00:40:37.000
we pre-build and pre-optimize these Pythons,

00:40:37.000 --> 00:40:40.000
and then we download them on demand

00:40:40.000 --> 00:40:42.000
and it makes it really fast.

00:40:42.000 --> 00:40:44.000
Awesome.

00:40:44.000 --> 00:40:50.000
When I go to python.org and download a DMG package

00:40:50.000 --> 00:40:52.000
or an MSI for Windows or whatever,

00:40:52.000 --> 00:40:54.000
it runs this installer process

00:40:54.000 --> 00:40:55.000
that takes a good long while,

00:40:55.000 --> 00:40:58.000
and, you know, Jake just pointed out

00:40:58.000 --> 00:40:59.000
a similar experience I had.

00:40:59.000 --> 00:41:00.000
He says it took me less than two seconds

00:41:00.000 --> 00:41:02.000
to install 3.10.

00:41:02.000 --> 00:41:03.000
Yeah.

00:41:03.000 --> 00:41:04.000
Same thing for 3.12.

00:41:04.000 --> 00:41:05.000
So what is...

00:41:05.000 --> 00:41:07.000
Are we missing anything

00:41:07.000 --> 00:41:10.000
compared to running a proper installer

00:41:10.000 --> 00:41:12.000
that seems to take 20 seconds

00:41:12.000 --> 00:41:13.000
even on a fast computer?

00:41:13.000 --> 00:41:15.000
I think those installers also have to do

00:41:15.000 --> 00:41:18.000
some operations from source, most likely,

00:41:18.000 --> 00:41:21.000
because they're not shipping...

00:41:21.000 --> 00:41:24.000
I could be wrong about that.

00:41:24.000 --> 00:41:26.000
I haven't looked at them closely,

00:41:26.000 --> 00:41:30.000
but Python in general, like, see...

00:41:30.000 --> 00:41:33.000
Like, you know, python.org does not distribute

00:41:33.000 --> 00:41:36.000
these kind of pre-built binary distributions

00:41:36.000 --> 00:41:39.000
for all these different architectures.

00:41:39.000 --> 00:41:42.000
And there's interest in doing that,

00:41:42.000 --> 00:41:45.000
and I'm also interested in doing that.

00:41:45.000 --> 00:41:47.000
But, you know, it needs to be...

00:41:47.000 --> 00:41:49.000
You know, there are some things

00:41:49.000 --> 00:41:50.000
that need to be decided,

00:41:50.000 --> 00:41:53.000
standards that potentially need to be set.

00:41:53.000 --> 00:41:55.000
So, you know, it's possible that eventually

00:41:55.000 --> 00:42:00.000
we can just grab these basically from python.org.

00:42:00.000 --> 00:42:05.000
I think our PyPy downloads come from python.org,

00:42:05.000 --> 00:42:06.000
if I'm not mistaken.

00:42:06.000 --> 00:42:07.000
PyPy, that is.

00:42:07.000 --> 00:42:10.000
Or it actually might come from pypy.org.

00:42:10.000 --> 00:42:12.000
Now I can't remember.

00:42:12.000 --> 00:42:14.000
Okay, anyway, those come from some sort

00:42:14.000 --> 00:42:15.000
of official source.

00:42:15.000 --> 00:42:17.000
Yeah, yeah, yeah.

00:42:17.000 --> 00:42:20.000
So, yeah, maybe eventually.

00:42:20.000 --> 00:42:22.000
But for now, yeah, we're using Python build standalone,

00:42:22.000 --> 00:42:24.000
and we've just been trying to grow our familiarity

00:42:24.000 --> 00:42:26.000
with the project, too.

00:42:26.000 --> 00:42:29.000
Right. Okay, so let's give people a sense here.

00:42:29.000 --> 00:42:31.000
Like, they do not have Python at all,

00:42:31.000 --> 00:42:33.000
or they can't count on having Python

00:42:33.000 --> 00:42:35.000
or the right version of Python.

00:42:35.000 --> 00:42:39.000
They can run a single shell command to get UV,

00:42:39.000 --> 00:42:41.000
which uv can then manage itself.

00:42:41.000 --> 00:42:44.000
They could pipx install the uv.

00:42:44.000 --> 00:42:45.000
Can you homebrew?

00:42:45.000 --> 00:42:46.000
Yeah.

00:42:46.000 --> 00:42:47.000
What other way?

00:42:47.000 --> 00:42:49.000
Yeah, you can get uv on your machine however you want.

00:42:49.000 --> 00:42:54.000
Like, uv doesn't need to be in the virtual environment

00:42:54.000 --> 00:42:55.000
that it's manipulating.

00:42:55.000 --> 00:42:57.000
It can just be anywhere on your machine,

00:42:57.000 --> 00:42:58.000
and it can operate on any environment.

00:42:58.000 --> 00:43:00.000
It's an external tool sort of deal, yeah.

00:43:00.000 --> 00:43:01.000
Yeah, yeah.

00:43:01.000 --> 00:43:03.000
So you can install it with pip.

00:43:03.000 --> 00:43:07.000
We have our own standalone installers that you can curl.

00:43:07.000 --> 00:43:09.000
It's on homebrew, right?

00:43:09.000 --> 00:43:11.000
You can install it with pipx.

00:43:11.000 --> 00:43:13.000
You can install it however you want.

00:43:13.000 --> 00:43:15.000
And then ultimately, it can operate on any environment

00:43:15.000 --> 00:43:16.000
on your machine.

00:43:16.000 --> 00:43:18.000
So I actually don't recommend installing it

00:43:18.000 --> 00:43:19.000
in a virtual environment.

00:43:19.000 --> 00:43:21.000
I recommend installing it globally.

00:43:21.000 --> 00:43:22.000
Yeah, that's how I have it as well.

00:43:22.000 --> 00:43:23.000
And you're kind of working from there.

00:43:23.000 --> 00:43:24.000
Yeah.

00:43:24.000 --> 00:43:26.000
I believe I have pipx installed.

00:43:26.000 --> 00:43:28.000
Because anything that falls into that category for me

00:43:28.000 --> 00:43:29.000
goes under pipx, at least for now.

00:43:29.000 --> 00:43:30.000
Yeah.

00:43:30.000 --> 00:43:32.000
We'll talk about that in a minute.

00:43:32.000 --> 00:43:35.000
I mean, one interesting thing is if you use our installers,

00:43:35.000 --> 00:43:39.000
like the curl installers, then you get access

00:43:39.000 --> 00:43:40.000
to self-updates.

00:43:40.000 --> 00:43:44.000
So you can run uv self-update, and we will update

00:43:44.000 --> 00:43:46.000
to the latest version.

00:43:46.000 --> 00:43:47.000
That's right.

00:43:47.000 --> 00:43:48.000
Because I tried to--

00:43:48.000 --> 00:43:49.000
We can't really do that if you--

00:43:49.000 --> 00:43:50.000
Yeah.

00:43:50.000 --> 00:43:51.000
We can't do that if you installed through a different

00:43:51.000 --> 00:43:53.000
package manager, because we don't really know

00:43:53.000 --> 00:43:56.000
how it was installed.

00:43:56.000 --> 00:43:58.000
So if you install it through the installer, right,

00:43:58.000 --> 00:44:01.000
you get a receipt that we understand where we installed it

00:44:01.000 --> 00:44:03.000
and all that kind of stuff.

00:44:03.000 --> 00:44:07.000
So that's one benefit, but you're not required

00:44:07.000 --> 00:44:09.000
to do that, of course.

00:44:09.000 --> 00:44:10.000
Sure.

00:44:10.000 --> 00:44:12.000
I ran into that when I just wanted to see what it would do

00:44:12.000 --> 00:44:13.000
if I ran a self-update.

00:44:13.000 --> 00:44:16.000
And it said, you installed this from a package manager

00:44:16.000 --> 00:44:18.000
type thing, so go do that thing.

00:44:18.000 --> 00:44:19.000
But that's fine.

00:44:19.000 --> 00:44:20.000
I have automation for all those things,

00:44:20.000 --> 00:44:22.000
so it's not a big deal.

00:44:22.000 --> 00:44:25.000
So to give people a sense, once uv is on your system

00:44:25.000 --> 00:44:29.000
and in the path, you can say uv venv --python

00:44:29.000 --> 00:44:33.000
and put some variation of a Python version.

00:44:33.000 --> 00:44:38.000
And if you have it, great, it'll use it, right,

00:44:38.000 --> 00:44:39.000
to create the virtual environment.

00:44:39.000 --> 00:44:41.000
If you don't have it, it will then do this

00:44:41.000 --> 00:44:45.000
two-second download install deal, assuming you have fiber,

00:44:45.000 --> 00:44:48.000
and then create a virtual environment based on it, right?

00:44:48.000 --> 00:44:49.000
Yep, that's right.

00:44:49.000 --> 00:44:51.000
And you can turn that off, but that is the default behavior.

00:44:51.000 --> 00:44:52.000
Yeah, that's awesome.

00:44:52.000 --> 00:44:56.000
And you can also pass commands like managed only,

00:44:56.000 --> 00:44:59.000
I think it is, or something like that, where you say

00:44:59.000 --> 00:45:03.000
don't use the system Python, even if it exists.

00:45:03.000 --> 00:45:05.000
Yeah, only use the Pythons that uv will install,

00:45:05.000 --> 00:45:07.000
or only use the Pythons that are on my machine,

00:45:07.000 --> 00:45:08.000
ignore UV's Pythons.

00:45:08.000 --> 00:45:10.000
There's some customizations around that.

00:45:10.000 --> 00:45:12.000
Right, you could do the opposite.

00:45:12.000 --> 00:45:15.000
I will also say this version, by the way,

00:45:15.000 --> 00:45:21.000
this version format request thing is so hard.

00:45:21.000 --> 00:45:24.000
Yeah, it's just like, you'd just be shocked

00:45:24.000 --> 00:45:27.000
how much engineering work has gone into understanding

00:45:27.000 --> 00:45:29.000
those requests, and then discovering all the Pythons

00:45:29.000 --> 00:45:30.000
on your machine.

00:45:30.000 --> 00:45:33.000
And the discovering all the Pythons on your machine

00:45:33.000 --> 00:45:36.000
part problem, by the way, is a problem that a bunch

00:45:36.000 --> 00:45:38.000
of tools have had to solve.

00:45:38.000 --> 00:45:42.000
And we've talked with the VS Code team about

00:45:42.000 --> 00:45:45.000
fast Python discovery, because there's just so many

00:45:45.000 --> 00:45:48.000
different places that it could be, and on Windows,

00:45:48.000 --> 00:45:51.000
it's also totally different than on Unix.

00:45:51.000 --> 00:45:55.000
So anyway, a lot of work has gone into that.

00:45:55.000 --> 00:45:58.000
But it's kind of hilariously flexible now.

00:45:58.000 --> 00:46:03.000
You can say CPython greater than or equal to 3.12,

00:46:03.000 --> 00:46:05.000
and then we'll look for CPython rather than PyPy,

00:46:05.000 --> 00:46:07.000
rather than GrailPy, or whatever.

00:46:07.000 --> 00:46:10.000
So anyway, a lot of work has gone into that.

00:46:10.000 --> 00:46:13.000
What if I just say UV, V, E, and V,

00:46:13.000 --> 00:46:15.000
and I have no Python whatsoever?

00:46:15.000 --> 00:46:20.000
I think we would install the latest Python.

00:46:20.000 --> 00:46:23.000
Would you just go, yeah, just do a latest,

00:46:23.000 --> 00:46:24.000
like maybe a--

00:46:24.000 --> 00:46:26.000
I think that would count as any Python.

00:46:26.000 --> 00:46:27.000
--inclusive ----Python space three.

00:46:27.000 --> 00:46:28.000
Yeah.

00:46:28.000 --> 00:46:30.000
I think that would count as give me any Python

00:46:30.000 --> 00:46:34.000
from the list of downloads, and then we sort by version.

00:46:34.000 --> 00:46:36.000
So I think you would effectively get the latest

00:46:36.000 --> 00:46:38.000
compatible version.

00:46:38.000 --> 00:46:40.000
But now you're kind of quizzing me a little bit,

00:46:40.000 --> 00:46:41.000
so I'm going to--

00:46:41.000 --> 00:46:42.000
No, I don't mean to be quizzing you.

00:46:42.000 --> 00:46:45.000
No, I'm just kidding.

00:46:45.000 --> 00:46:48.000
All right, so we'll move on.

00:46:48.000 --> 00:46:51.000
I know there's so much more, and we don't have a ton of time

00:46:51.000 --> 00:46:52.000
to get it.

00:46:52.000 --> 00:46:55.000
But I just pulled up my warp terminal,

00:46:55.000 --> 00:46:58.000
and I typed uv Python list.

00:46:58.000 --> 00:47:01.000
And it shows me a bunch of options for ARM64,

00:47:01.000 --> 00:47:08.000
for macOS, 3.12.5, 3.12.0, 3.11.9, 3.10.3, 8,

00:47:08.000 --> 00:47:09.000
and so on that I could pick.

00:47:10.000 --> 00:47:19.000
However, I'm just wondering where your cutting edge needle

00:47:19.000 --> 00:47:22.000
setting is going to go here.

00:47:22.000 --> 00:47:24.000
I don't see a 3.13.

00:47:24.000 --> 00:47:25.000
Yeah, we're working on it.

00:47:25.000 --> 00:47:26.000
We're working on it.

00:47:26.000 --> 00:47:28.000
We're working on it.

00:47:28.000 --> 00:47:30.000
And one of the things that is tricky about any of these

00:47:30.000 --> 00:47:34.000
package manager stories is if I homebrew it,

00:47:34.000 --> 00:47:37.000
I'll see that there's a new Python.

00:47:37.000 --> 00:47:39.000
Especially a major release.

00:47:39.000 --> 00:47:41.000
But I might have to wait a week before it's available

00:47:41.000 --> 00:47:43.000
on homebrew.

00:47:43.000 --> 00:47:45.000
But homebrew will auto-update it.

00:47:45.000 --> 00:47:47.000
But if I install it from the installer from python.org,

00:47:47.000 --> 00:47:49.000
it won't auto-update it.

00:47:49.000 --> 00:47:51.000
There's always a little drawback.

00:47:51.000 --> 00:47:53.000
And so when I saw this feature, I'm like,

00:47:53.000 --> 00:47:57.000
"Well, if this thing could just really soon have the newest one,

00:47:57.000 --> 00:47:59.000
that would just be icing on the cake."

00:47:59.000 --> 00:48:04.000
So what is your policy on how quickly to adopt new things,

00:48:04.000 --> 00:48:08.000
how quickly to adopt release candidates and betas

00:48:08.000 --> 00:48:09.000
and things like that?

00:48:09.000 --> 00:48:13.000
Yeah, like with 3.13, I mean, I would like to have it out

00:48:13.000 --> 00:48:15.000
as soon as there's an RC.

00:48:15.000 --> 00:48:17.000
That's what I would like to do.

00:48:17.000 --> 00:48:19.000
Okay.

00:48:19.000 --> 00:48:25.000
Our policy or our goal is to make sure that it's out

00:48:25.000 --> 00:48:27.000
before the stable release.

00:48:27.000 --> 00:48:31.000
So we would like to not be lagging on the stable release.

00:48:31.000 --> 00:48:38.000
And we view the minor releases in Python similarly

00:48:38.000 --> 00:48:39.000
and rough historically.

00:48:39.000 --> 00:48:42.000
We'll be like, "Okay, we want to make sure that we support

00:48:42.000 --> 00:48:45.000
all the 3.12 language features before 3.12 is stable."

00:48:45.000 --> 00:48:48.000
And there were a bunch of language features in 3.12.

00:48:48.000 --> 00:48:50.000
There was some new grammar.

00:48:50.000 --> 00:48:51.000
There were new typing features.

00:48:51.000 --> 00:48:54.000
And so the goal there, again, was the goal is to have it out

00:48:54.000 --> 00:48:55.000
by the time it's stable.

00:48:55.000 --> 00:48:58.000
So that's typically the contract we try and uphold.

00:48:58.000 --> 00:49:00.000
And that's still our plan for 3.13.

00:49:00.000 --> 00:49:01.000
Okay, awesome.

00:49:01.000 --> 00:49:02.000
Yeah, good to know.

00:49:02.000 --> 00:49:03.000
Yeah.

00:49:03.000 --> 00:49:07.000
Jay Geller says, "It would be nice to have an option

00:49:07.000 --> 00:49:09.000
to install pre-release builds."

00:49:09.000 --> 00:49:12.000
And Tushar says, "The thing is, Python build standalone

00:49:12.000 --> 00:49:14.000
builds 600 releases per version number.

00:49:14.000 --> 00:49:16.000
Having that run daily is too much.

00:49:16.000 --> 00:49:19.000
But if anyone could do some interesting caching,

00:49:19.000 --> 00:49:22.000
surely the Astral folks could do some sweet caching."

00:49:22.000 --> 00:49:23.000
It's kind of amazing, though.

00:49:23.000 --> 00:49:24.000
That project runs.

00:49:24.000 --> 00:49:26.000
It's not like we don't own it.

00:49:26.000 --> 00:49:27.000
It's not under our order.

00:49:27.000 --> 00:49:31.000
That project runs completely for free on GitHub Actions.

00:49:31.000 --> 00:49:32.000
Wow.

00:49:32.000 --> 00:49:34.000
Isn't that kind of remarkable?

00:49:34.000 --> 00:49:37.000
Yeah, GitHub is ridiculous.

00:49:37.000 --> 00:49:38.000
Yeah.

00:49:38.000 --> 00:49:40.000
So anyway, that's kind of just cool.

00:49:40.000 --> 00:49:42.000
How much traffic it handles and how much data.

00:49:42.000 --> 00:49:44.000
Yeah, they're pretty awesome.

00:49:44.000 --> 00:49:48.000
Okay, so if you don't have Python, you can also,

00:49:48.000 --> 00:49:49.000
you don't have to do a VNV.

00:49:49.000 --> 00:49:53.000
You can just say, "UV Python install," give it a version,

00:49:53.000 --> 00:49:54.000
and then you'll just have that.

00:49:54.000 --> 00:49:57.000
That's what Jake and I were referring to earlier.

00:49:57.000 --> 00:49:59.000
But you can also create a VNV.

00:49:59.000 --> 00:50:03.000
And this is sort of a philosophy that I'm getting.

00:50:03.000 --> 00:50:06.000
And sorry, someone said this earlier,

00:50:06.000 --> 00:50:08.000
but it scrolled off the livestream comments,

00:50:08.000 --> 00:50:13.000
that this prefer or require virtual environments by default

00:50:13.000 --> 00:50:17.000
rather than prefer to try to jam stuff into system Python

00:50:17.000 --> 00:50:19.000
or the core Python.

00:50:19.000 --> 00:50:21.000
And then it could be a virtual environment

00:50:21.000 --> 00:50:23.000
if you really know the incantations.

00:50:23.000 --> 00:50:25.000
Yeah, yeah.

00:50:25.000 --> 00:50:26.000
That's probably like, you know,

00:50:26.000 --> 00:50:29.000
when we did the release in February,

00:50:29.000 --> 00:50:33.000
we tried to steer pretty closely to the way pip behaves

00:50:33.000 --> 00:50:35.000
to make it easy for people.

00:50:35.000 --> 00:50:37.000
But we did pick a few battles

00:50:37.000 --> 00:50:40.000
where we wanted to intentionally diverge.

00:50:40.000 --> 00:50:42.000
And this was one of the bigger ones,

00:50:42.000 --> 00:50:46.000
which is uv by default requires a virtual environment.

00:50:46.000 --> 00:50:48.000
So if you try and uv pip install and there's no,

00:50:48.000 --> 00:50:49.000
we can't find a virtual environment

00:50:49.000 --> 00:50:51.000
in the current directory or an active virtual environment,

00:50:51.000 --> 00:50:53.000
we'll throw an error.

00:50:53.000 --> 00:50:56.000
And you can opt out of that by passing a system flag.

00:50:56.000 --> 00:50:59.000
But unlike pip, right, it's opt out.

00:50:59.000 --> 00:51:02.000
So you have to, by default, it uses a virtual environment

00:51:02.000 --> 00:51:05.000
and you can escape from that if you want to intentionally.

00:51:05.000 --> 00:51:12.000
So we're trying to, like with these APIs too,

00:51:12.000 --> 00:51:15.000
like these are all virtual environment.

00:51:15.000 --> 00:51:18.000
Well, the tool stuff, it is, but in a different way,

00:51:18.000 --> 00:51:20.000
like uv run, uv lock, uv sync.

00:51:20.000 --> 00:51:22.000
These all create a virtual environment

00:51:22.000 --> 00:51:24.000
in the project directory where the project is defined

00:51:24.000 --> 00:51:26.000
by a PyProject toml.

00:51:26.000 --> 00:51:28.000
So if you run uv run in that directory,

00:51:28.000 --> 00:51:31.000
it will look at the dependencies, resolve them,

00:51:31.000 --> 00:51:33.000
create a lock file, create a virtual environment,

00:51:33.000 --> 00:51:36.000
install their locked versions into the virtual environment,

00:51:36.000 --> 00:51:37.000
run the command.

00:51:37.000 --> 00:51:41.000
And it does that every time, but it's so fast that we,

00:51:41.000 --> 00:51:44.000
well, hopefully so fast that we can do it.

00:51:44.000 --> 00:51:46.000
So like if the dependencies haven't changed,

00:51:46.000 --> 00:51:48.000
it will still make sure that everything's up to date.

00:51:48.000 --> 00:51:50.000
So if you just use uv run, we try and keep

00:51:50.000 --> 00:51:52.000
the whole environment in sync for you.

00:51:52.000 --> 00:51:54.000
And you don't have to think about how do I manage

00:51:54.000 --> 00:51:55.000
my environment?

00:51:55.000 --> 00:51:56.000
How do I activate it?

00:51:56.000 --> 00:51:58.000
How do I install stuff?

00:51:58.000 --> 00:52:03.000
But we're pretty like, we're pretty pro virtual environment.

00:52:03.000 --> 00:52:09.000
And one thing I want to do, and it's sometimes hard

00:52:09.000 --> 00:52:12.000
to hold these lines because you have users who come to you

00:52:12.000 --> 00:52:14.000
and want something really different.

00:52:14.000 --> 00:52:18.000
And it can be hard not to say yes to a lot of the things

00:52:18.000 --> 00:52:20.000
that users want.

00:52:20.000 --> 00:52:25.000
But some lines, I think we have to hold because they,

00:52:25.000 --> 00:52:27.000
if we can see it on them, sorry, I'm making it sound

00:52:27.000 --> 00:52:30.000
like a battle, but if we can see it on them,

00:52:30.000 --> 00:52:33.000
it just limits the things we can do in the future.

00:52:33.000 --> 00:52:35.000
Like if we make things too flexible,

00:52:35.000 --> 00:52:37.000
it limits some of the things, some of the possibilities

00:52:37.000 --> 00:52:39.000
of what we can do in the future.

00:52:39.000 --> 00:52:41.000
And like one thing that I kind of want to change

00:52:41.000 --> 00:52:45.000
the perception around is like, I think virtual environments

00:52:45.000 --> 00:52:48.000
are like, they're here to stay really.

00:52:48.000 --> 00:52:53.000
And I am, so we like embrace them, but I want to change

00:52:53.000 --> 00:52:57.000
some of how people like think about virtual environments.

00:52:57.000 --> 00:52:58.000
In particular, I want to change this whole idea

00:52:58.000 --> 00:53:00.000
of like activating a virtual environment.

00:53:00.000 --> 00:53:03.000
Like I want it to feel more like node modules,

00:53:03.000 --> 00:53:07.000
which people don't necessarily think, you know,

00:53:07.000 --> 00:53:08.000
highly of node modules.

00:53:08.000 --> 00:53:10.000
Like I think when people think of node modules,

00:53:10.000 --> 00:53:11.000
they think of a huge node modules folder

00:53:11.000 --> 00:53:13.000
with like a ton of bloat.

00:53:13.000 --> 00:53:16.000
But the idea there is like when you're in a project,

00:53:16.000 --> 00:53:19.000
you just sort of run commands and all the packages

00:53:19.000 --> 00:53:20.000
just get installed there.

00:53:20.000 --> 00:53:21.000
And it just runs in the correct environment

00:53:21.000 --> 00:53:22.000
with the correct dependencies.

00:53:22.000 --> 00:53:24.000
And that's actually what I kind of want.

00:53:24.000 --> 00:53:26.000
That's actually what I want Python to feel like is,

00:53:26.000 --> 00:53:27.000
yeah, there's a virtual environment,

00:53:27.000 --> 00:53:29.000
but it's actually just kind of like the directories of,

00:53:29.000 --> 00:53:31.000
you know, it's kind of just like full of packages,

00:53:31.000 --> 00:53:32.000
full of your dependencies.

00:53:32.000 --> 00:53:33.000
And it just, you just use the right one

00:53:33.000 --> 00:53:35.000
at the right points in time.

00:53:35.000 --> 00:53:39.000
So that's part of the shift that I want us

00:53:39.000 --> 00:53:40.000
to move towards a little bit.

00:53:40.000 --> 00:53:42.000
And it's part of why we're very virtual environment first

00:53:42.000 --> 00:53:44.000
and why we put the virtual environment right

00:53:44.000 --> 00:53:46.000
in the project in a specific known place.

00:53:46.000 --> 00:53:49.000
Because we want to get away a little bit

00:53:49.000 --> 00:53:51.000
from this idea of where's the environment?

00:53:51.000 --> 00:53:52.000
How do I activate it?

00:53:52.000 --> 00:53:54.000
Do I have the wrong one activated?

00:53:54.000 --> 00:53:57.000
I want it to feel a little bit more like it

00:53:57.000 --> 00:54:00.000
is just sort of native to how the project works.

00:54:00.000 --> 00:54:02.000
- If you're in the context of that thing,

00:54:02.000 --> 00:54:04.000
then it just uses the right one.

00:54:04.000 --> 00:54:06.000
Do you have intentions to do something?

00:54:06.000 --> 00:54:07.000
I can't remember the path,

00:54:07.000 --> 00:54:11.000
but something to the effect where if you're in a directory

00:54:11.000 --> 00:54:13.000
and there's no PyProject, TML or virtual environment,

00:54:13.000 --> 00:54:16.000
but if you went up one or two, or both,

00:54:16.000 --> 00:54:19.000
would it fall to that one or would it just go?

00:54:19.000 --> 00:54:21.000
- We do do that with uv run.

00:54:21.000 --> 00:54:25.000
So with uv run, we sort of find the root of the project

00:54:25.000 --> 00:54:27.000
and we'll look up at parent directories.

00:54:27.000 --> 00:54:31.000
But we don't, but if you just run Python,

00:54:31.000 --> 00:54:32.000
you know, blah, blah, blah,

00:54:32.000 --> 00:54:35.000
obviously we don't hook into anything there.

00:54:35.000 --> 00:54:38.000
And so, you know, like with a lot of other things,

00:54:38.000 --> 00:54:40.000
like with uv run, uv lock, uv sync,

00:54:40.000 --> 00:54:41.000
we create a virtual environment.

00:54:41.000 --> 00:54:43.000
If you use our commands, it's kind of just like,

00:54:43.000 --> 00:54:44.000
everything just works,

00:54:44.000 --> 00:54:46.000
but you can also just activate the virtual environment

00:54:46.000 --> 00:54:48.000
and do whatever you want,

00:54:48.000 --> 00:54:50.000
because we're kind of trying to embrace the fact

00:54:50.000 --> 00:54:51.000
that virtual environments are like,

00:54:51.000 --> 00:54:54.000
everyone knows, not everyone knows how to use them,

00:54:54.000 --> 00:54:56.000
but people are familiar with them.

00:54:56.000 --> 00:55:00.000
Editors and tooling revolve around them.

00:55:00.000 --> 00:55:05.000
So things that try to eject from virtual environments

00:55:05.000 --> 00:55:08.000
tend to cause a lot of problems for editors and workflows.

00:55:08.000 --> 00:55:10.000
So part of embracing virtual environments, I think again,

00:55:10.000 --> 00:55:14.000
is like meeting the ecosystem where it is a little bit

00:55:14.000 --> 00:55:15.000
and being like, okay,

00:55:15.000 --> 00:55:16.000
the fact that we use virtual environments

00:55:16.000 --> 00:55:18.000
and they're just like in your project means that

00:55:18.000 --> 00:55:21.000
you don't need like a special like editor integration

00:55:21.000 --> 00:55:23.000
to use UV, like, you know,

00:55:23.000 --> 00:55:26.000
like PyCharm will just like let you use that virtual environment

00:55:26.000 --> 00:55:28.000
which is a normal virtual environment,

00:55:28.000 --> 00:55:29.000
from this perspective.

00:55:29.000 --> 00:55:31.000
So that's, again, part of what we're trying to do

00:55:31.000 --> 00:55:34.000
is like build things that just work for people

00:55:34.000 --> 00:55:36.000
and try and embrace, you know,

00:55:36.000 --> 00:55:39.000
the standards and the conventions while also, you know,

00:55:39.000 --> 00:55:41.000
maybe influencing or changing parts of them

00:55:41.000 --> 00:55:46.000
that we think could be improved

00:55:46.000 --> 00:55:48.000
or could be made more user-friendly.

00:55:48.000 --> 00:55:49.000
- Yeah.

00:55:49.000 --> 00:55:51.000
I don't know why I didn't book you

00:55:51.000 --> 00:55:53.000
for a two and a half hour podcast,

00:55:53.000 --> 00:55:54.000
'cause that's what we're gonna need.

00:55:54.000 --> 00:55:56.000
So Vincent from Comcast says,

00:55:56.000 --> 00:55:58.000
"UV run is such a game changer.

00:55:58.000 --> 00:56:01.000
"He may work on a Jupyter runner for that this week."

00:56:01.000 --> 00:56:03.000
Feels like such a game changer, which is awesome.

00:56:03.000 --> 00:56:04.000
- Cool.

00:56:04.000 --> 00:56:06.000
Yeah, there's a lot of cool ideas too around this sort of,

00:56:06.000 --> 00:56:07.000
sorry, go ahead.

00:56:07.000 --> 00:56:09.000
- Well, I was gonna say, with that in mind,

00:56:09.000 --> 00:56:14.000
let's dive into this whole project management stuff here.

00:56:14.000 --> 00:56:16.000
Right?

00:56:16.000 --> 00:56:19.000
I think this is one of the three big pieces

00:56:19.000 --> 00:56:21.000
of functionality that comes through.

00:56:21.000 --> 00:56:22.000
And you've been talking about

00:56:24.000 --> 00:56:27.000
this sort of, some of the features like uv run and so on,

00:56:27.000 --> 00:56:30.000
but let's talk through, let's talk through,

00:56:30.000 --> 00:56:31.000
- Yeah.

00:56:31.000 --> 00:56:32.000
- I wanna create a new project.

00:56:32.000 --> 00:56:33.000
- Yeah.

00:56:33.000 --> 00:56:34.000
- Yeah, I wanna create a project.

00:56:34.000 --> 00:56:36.000
I don't have the Python installed.

00:56:36.000 --> 00:56:38.000
It's a new project.

00:56:38.000 --> 00:56:40.000
I wanna create a pyproject.toml,

00:56:40.000 --> 00:56:42.000
but I don't even remember the format for that.

00:56:42.000 --> 00:56:43.000
- Yep.

00:56:43.000 --> 00:56:44.000
- Let's go.

00:56:44.000 --> 00:56:45.000
How's that work?

00:56:45.000 --> 00:56:47.000
- So we have like a series of commands

00:56:47.000 --> 00:56:50.000
that kind of manage the project lifecycle for you.

00:56:50.000 --> 00:56:53.000
So you can run uv init to create a new project.

00:56:53.000 --> 00:56:56.000
And it has a couple of flags based on

00:56:56.000 --> 00:56:57.000
whether you wanna build like a library

00:56:57.000 --> 00:56:59.000
or a command line application,

00:56:59.000 --> 00:57:02.000
whether you want it to be structured as like a Python package

00:57:02.000 --> 00:57:05.000
or just kind of, maybe it's just an application

00:57:05.000 --> 00:57:06.000
that you're running on your machine.

00:57:06.000 --> 00:57:09.000
But uv init will create the project.

00:57:09.000 --> 00:57:12.000
You can then run uv add, flask, uv add, FastAPI,

00:57:12.000 --> 00:57:14.000
whatever to add dependencies.

00:57:14.000 --> 00:57:15.000
And when you run uv add,

00:57:15.000 --> 00:57:17.000
it will automatically generate the lock file

00:57:17.000 --> 00:57:19.000
and sync the dependencies to your system.

00:57:20.000 --> 00:57:23.000
So we do have commands like uv lock

00:57:23.000 --> 00:57:25.000
to generate the lock file and uv sync

00:57:25.000 --> 00:57:28.000
to download the correct dependencies

00:57:28.000 --> 00:57:29.000
into your environment.

00:57:29.000 --> 00:57:31.000
But you can also just kind of use these lifecycle commands

00:57:31.000 --> 00:57:33.000
and uv will make sure that everything's

00:57:33.000 --> 00:57:34.000
in the right state as you go.

00:57:34.000 --> 00:57:37.000
So you can run uv add, uv run.

00:57:37.000 --> 00:57:40.000
If you do uv run and then Python, blah, blah, blah,

00:57:40.000 --> 00:57:43.000
it's, you know, what happens behind the scenes

00:57:43.000 --> 00:57:45.000
is we resolve the dependencies.

00:57:45.000 --> 00:57:46.000
We make sure the environment's up to date

00:57:46.000 --> 00:57:48.000
and then we run that command in the environment.

00:57:48.000 --> 00:57:52.000
So the whole lifecycle of working with your project

00:57:52.000 --> 00:57:54.000
can be managed through uv init, uv add,

00:57:54.000 --> 00:57:57.000
UV remove, uv run.

00:57:57.000 --> 00:57:59.000
There's a lot that goes into that.

00:57:59.000 --> 00:58:03.000
And there's also a lot of kind of powerful features

00:58:03.000 --> 00:58:04.000
built in here too.

00:58:04.000 --> 00:58:09.000
Like when you run uv run, it accepts a flag --with.

00:58:09.000 --> 00:58:13.000
So you can do uv run --with and put a dependency there.

00:58:13.000 --> 00:58:16.000
And it will basically just download that

00:58:16.000 --> 00:58:19.000
put it in an ephemeral virtual environment

00:58:19.000 --> 00:58:21.000
and make it available for the command.

00:58:21.000 --> 00:58:24.000
So you can just pull in one-off dependencies

00:58:24.000 --> 00:58:25.000
as you need to run things.

00:58:25.000 --> 00:58:29.000
Like I never actually think about activating environments anymore.

00:58:29.000 --> 00:58:32.000
Like most of the time when I'm running Python commands

00:58:32.000 --> 00:58:35.000
to run one-off tooling, I'm running, you know,

00:58:35.000 --> 00:58:38.000
UV run --with requirements and I give it a requirements file

00:58:38.000 --> 00:58:41.000
and then, you know, I pass the name of the file I want to run.

00:58:41.000 --> 00:58:44.000
And like, it just like builds the thing you need

00:58:44.000 --> 00:58:47.000
and runs the command and throws it away.

00:58:47.000 --> 00:58:49.000
And because you have, again, we were talking

00:58:49.000 --> 00:58:51.000
at the beginning of this episode about how like really fast tools

00:58:51.000 --> 00:58:53.000
change the ergonomics.

00:58:53.000 --> 00:58:55.000
Like part of what we're trying to build here is like

00:58:55.000 --> 00:58:58.000
if we have this packaging system that's really fast,

00:58:58.000 --> 00:59:01.000
especially for like repeated operations,

00:59:01.000 --> 00:59:05.000
like I need to keep pulling in, you know,

00:59:05.000 --> 00:59:07.000
I've downloaded this package before and you download it again

00:59:07.000 --> 00:59:08.000
and use it for this one command.

00:59:08.000 --> 00:59:10.000
Like we can just like throw away virtual environments

00:59:10.000 --> 00:59:12.000
and create new virtual environments, you know,

00:59:12.000 --> 00:59:13.000
in like in milliseconds.

00:59:13.000 --> 00:59:14.000
Yeah.

00:59:14.000 --> 00:59:20.000
So if this was a Python-MVENV sort of install,

00:59:20.000 --> 00:59:22.000
it would be way too much overhead.

00:59:22.000 --> 00:59:23.000
Yeah.

00:59:24.000 --> 00:59:27.000
And so, you know, we can just like even like a bunch

00:59:27.000 --> 00:59:29.000
of dependencies, like after they've been installed

00:59:29.000 --> 00:59:31.000
on your machine already, it's really, really fast

00:59:31.000 --> 00:59:33.000
just to pull these things together, use them

00:59:33.000 --> 00:59:35.000
and throw them away.

00:59:35.000 --> 00:59:40.000
So there's just a lot of things that we can do.

00:59:40.000 --> 00:59:42.000
And I think even like looking forward to the future,

00:59:42.000 --> 00:59:44.000
there's a lot of things we can do because we have this

00:59:44.000 --> 00:59:46.000
like performance foundation.

00:59:46.000 --> 00:59:50.000
Like, you know, I'm thinking about what if you want

00:59:50.000 --> 00:59:52.000
to test code on like a bunch of different Python versions.

00:59:52.000 --> 00:59:53.000
Yeah.

00:59:53.000 --> 00:59:57.000
And maybe you don't want to like have to keep destroying

00:59:57.000 --> 00:59:59.000
and recreating your virtual environment

00:59:59.000 --> 01:00:00.000
or something like that.

01:00:00.000 --> 01:00:02.000
Like there's just a whole lot of stuff that we can build

01:00:02.000 --> 01:00:04.000
that would be really hard to imagine if you didn't have

01:00:04.000 --> 01:00:07.000
a really fast tool.

01:00:07.000 --> 01:00:08.000
Yeah.

01:00:08.000 --> 01:00:14.000
It definitely changes what's possible.

01:00:14.000 --> 01:00:16.000
Tushar out there put out an example that is very near

01:00:16.000 --> 01:00:18.000
and dear to my heart.

01:00:18.000 --> 01:00:19.000
You know what would be great?

01:00:19.000 --> 01:00:23.000
If uv could build standalone binaries and embed Python

01:00:23.000 --> 01:00:24.000
into them.

01:00:24.000 --> 01:00:25.000
Yeah.

01:00:25.000 --> 01:00:27.000
That's an interesting space.

01:00:27.000 --> 01:00:29.000
It's not something we've built anything around, but yeah.

01:00:29.000 --> 01:00:31.000
I know it's being described there.

01:00:31.000 --> 01:00:36.000
I think what I've seen most of the things do is they'll

01:00:36.000 --> 01:00:40.000
do something like zip up a virtual environment or site

01:00:40.000 --> 01:00:44.000
packages or something and then put that in a binary.

01:00:44.000 --> 01:00:47.000
And then when you run it, it'll spit that out or maybe

01:00:47.000 --> 01:00:51.000
do a memory mapped sort of magic to try to map into that

01:00:51.000 --> 01:00:55.000
and unzip it into memory or all sorts of weirdness.

01:00:55.000 --> 01:01:01.000
And I think really for this to be easy, somewhere along

01:01:01.000 --> 01:01:03.000
the way, I could be wrong, not a core developer,

01:01:03.000 --> 01:01:08.000
but I feel like Python's import behavior needs to be able

01:01:08.000 --> 01:01:14.000
to import from an embedded resource in a compiled binary

01:01:14.000 --> 01:01:18.000
rather than stick in a binary and have the binary do weird

01:01:18.000 --> 01:01:20.000
things where it fakes out the path.

01:01:20.000 --> 01:01:22.000
Because there's always something that falls apart.

01:01:22.000 --> 01:01:25.000
But if the pip itself says, "Okay, we can import from

01:01:25.000 --> 01:01:29.000
a memory stream and not just from file system,"

01:01:29.000 --> 01:01:32.000
then these things would be like, "Oh, well, if that's the case,

01:01:32.000 --> 01:01:34.000
here's how you just embed those and off it goes."

01:01:34.000 --> 01:01:37.000
It'd be more like Go or say, "Here's your one thing,

01:01:37.000 --> 01:01:38.000
you run it." You know what I mean?

01:01:38.000 --> 01:01:41.000
Yeah. Yeah. There's definitely interesting stuff to explore

01:01:41.000 --> 01:01:45.000
there. And there's some interesting tools that exist already

01:01:45.000 --> 01:01:49.000
to try to facilitate some of those things.

01:01:49.000 --> 01:01:52.000
It's also, we've invested time in yet though.

01:01:52.000 --> 01:01:53.000
Yep. All right.

01:01:53.000 --> 01:01:55.000
Yeah, I was thinking PyApp is similar.

01:01:55.000 --> 01:01:57.000
Yeah. Yeah. PyApp is definitely. I've used PyApp before.

01:01:57.000 --> 01:01:59.000
Actually, I have an app running on my system right now.

01:01:59.000 --> 01:02:02.000
It's in a little menu bar thing that's a PyApp app.

01:02:02.000 --> 01:02:04.000
And it works well. It does work well.

01:02:04.000 --> 01:02:05.000
Yep.

01:02:05.000 --> 01:02:07.000
Okay.

01:02:07.000 --> 01:02:12.000
So the project API is kind of like, if you've used like poetry

01:02:12.000 --> 01:02:16.000
or PDM, these tools that are oriented around working

01:02:16.000 --> 01:02:19.000
on a project. And you have a PyProject toml that defines

01:02:19.000 --> 01:02:23.000
your dependencies and you might have some sort of structure.

01:02:23.000 --> 01:02:25.000
It's based around that kind of workflow of working

01:02:25.000 --> 01:02:29.000
on a project, which is, that's like one way that people

01:02:29.000 --> 01:02:31.000
work with Python, but there's a lot of ways, there's a lot

01:02:31.000 --> 01:02:33.000
of things that people do with Python, which is why we have

01:02:33.000 --> 01:02:36.000
a couple of different APIs. Right. So we also have this.

01:02:36.000 --> 01:02:37.000
Yeah.

01:02:37.000 --> 01:02:42.000
This tool API, like uv tool install, uv tool run,

01:02:42.000 --> 01:02:46.000
which we've aliased to UVX. These are for running.

01:02:46.000 --> 01:02:48.000
This is interesting. Yeah.

01:02:48.000 --> 01:02:51.000
Yeah. These are for running like one-off, not one-off commands,

01:02:51.000 --> 01:02:53.000
but like things that you want installed globally.

01:02:53.000 --> 01:02:56.000
So like you might want rough installed globally

01:02:56.000 --> 01:02:58.000
on your machine so you can run it on a bunch of different

01:02:58.000 --> 01:03:02.000
projects. We call those like tools and you install them,

01:03:02.000 --> 01:03:05.000
you know, similar if you've used PipX before, we install

01:03:05.000 --> 01:03:10.000
them into dedicated environments and put them on your path.

01:03:10.000 --> 01:03:12.000
And there's a lot of really cool stuff here.

01:03:12.000 --> 01:03:15.000
Like I now use UVX all the time when I want to run things.

01:03:15.000 --> 01:03:20.000
So I'll do like UVX rough check and that translates

01:03:20.000 --> 01:03:24.000
to uv tool run rough, you know, run the check command.

01:03:24.000 --> 01:03:26.000
Behind the scenes, what it does is it finds latest version

01:03:26.000 --> 01:03:29.000
of rough, it creates an environment with that version,

01:03:29.000 --> 01:03:33.000
and then it runs the command using the rough binary in there.

01:03:33.000 --> 01:03:37.000
And there's really no overhead to that if you're kind

01:03:37.000 --> 01:03:42.000
of running it repeatedly. So, you know, this is oriented

01:03:42.000 --> 01:03:45.000
around like a different way of working with Python

01:03:45.000 --> 01:03:47.000
where you have these tools that you need to run

01:03:47.000 --> 01:03:50.000
on your machine and you use them for different things.

01:03:50.000 --> 01:03:53.000
So we have like the project interface for working

01:03:53.000 --> 01:03:55.000
on a project, and then we have the tool interface

01:03:55.000 --> 01:03:58.000
for running Python, you know, command line tools.

01:03:58.000 --> 01:04:04.000
- Yeah. So UVX run, well, UVX is the run version.

01:04:04.000 --> 01:04:05.000
- Yeah.

01:04:05.000 --> 01:04:08.000
- And you've also got the install.

01:04:08.000 --> 01:04:11.000
I have some thoughts of when I might do one or the other,

01:04:11.000 --> 01:04:15.000
but the uv tool install seems like something you might

01:04:15.000 --> 01:04:18.000
want to run and have around and have autocomplete

01:04:18.000 --> 01:04:22.000
in your shell. So I could type ru tab and get rough,

01:04:22.000 --> 01:04:24.000
or I could uv tool install.

01:04:24.000 --> 01:04:26.000
- Yeah. I think for things you're going to run repeatedly,

01:04:26.000 --> 01:04:28.000
it makes a lot of sense to install them.

01:04:28.000 --> 01:04:34.000
Also, if you have, like if you ran uv tool install rough,

01:04:34.000 --> 01:04:37.000
and then you ran like UVX rough, we would use

01:04:37.000 --> 01:04:40.000
the installed version. So if you already have the tool

01:04:40.000 --> 01:04:42.000
installed, we'll still pull the installed version,

01:04:42.000 --> 01:04:45.000
assuming it's compatible with the version request

01:04:45.000 --> 01:04:49.000
that you made. So like, yeah, I generally like uv tool

01:04:49.000 --> 01:04:51.000
install things that I'm going to run, you know,

01:04:51.000 --> 01:04:54.000
multiple times. The other really nice thing about uv tool

01:04:54.000 --> 01:04:58.000
install is we have uv tool upgrade. So you can do like

01:04:58.000 --> 01:05:01.000
UV tool upgrade --all, and we'll upgrade

01:05:01.000 --> 01:05:03.000
all the installed tools. So you don't have to think

01:05:03.000 --> 01:05:05.000
about like, which tools do I have installed?

01:05:05.000 --> 01:05:07.000
Like what versions are they at? Are they out of date?

01:05:07.000 --> 01:05:08.000
- Yeah. I love it.

01:05:08.000 --> 01:05:10.000
- So, you know, it kind of gives you a way to manage

01:05:10.000 --> 01:05:13.000
all the Python tools that you're using at a kind of

01:05:13.000 --> 01:05:16.000
global level. So, you know, we have a lot of commands

01:05:16.000 --> 01:05:19.000
like in our docs, we have a lot of like automation tooling

01:05:19.000 --> 01:05:21.000
built around Python, like, you know, rough and uv are

01:05:21.000 --> 01:05:23.000
written in Rust, but a lot of our like documentation

01:05:23.000 --> 01:05:26.000
tooling, like we have a lot of scripting in Python.

01:05:26.000 --> 01:05:30.000
And all of our docs now in the doc string at the top

01:05:30.000 --> 01:05:33.000
have like the UVX command that you run to like run

01:05:33.000 --> 01:05:36.000
the script. And so I just like copy that and paste that

01:05:36.000 --> 01:05:39.000
and then the script just runs with all of its dependencies.

01:05:39.000 --> 01:05:46.000
So it's like, it's just super, it's just very, very

01:05:46.000 --> 01:05:49.000
convenient, I think, like all these APIs and the way

01:05:49.000 --> 01:05:53.000
they come together. And there's a lot, I know it's a lot

01:05:53.000 --> 01:05:56.000
of different stuff. And that was actually my biggest fear

01:05:56.000 --> 01:05:59.000
with this release was it's hard to succinctly explain

01:05:59.000 --> 01:06:03.000
what this release is, because it's a lot of different

01:06:03.000 --> 01:06:06.000
things. And it's not like when we released uv in February,

01:06:06.000 --> 01:06:09.000
when we released uv in February, it's like, this is a new

01:06:09.000 --> 01:06:17.000
tool, if you know pip, it's a succinct way like what

01:06:17.000 --> 01:06:21.000
we're doing. And in this release, it's like, it's actually

01:06:21.000 --> 01:06:23.000
like a lot of different stuff that comes together to

01:06:23.000 --> 01:06:26.000
tell what I think is a very coherent story. But it's

01:06:26.000 --> 01:06:30.000
hard to succinctly explain exactly what, you know,

01:06:30.000 --> 01:06:36.000
what we did. And I was very, like the response to it,

01:06:36.000 --> 01:06:41.000
I was really heartened, you know, to see that people

01:06:41.000 --> 01:06:44.000
were, people were like getting it. And they were

01:06:44.000 --> 01:06:46.000
getting different parts of it. Like different parts

01:06:46.000 --> 01:06:49.000
of it, we're speaking to different people. Because

01:06:49.000 --> 01:06:51.000
I actually think different parts of it are like relevant

01:06:51.000 --> 01:06:53.000
to different ways that people work with Python.

01:06:53.000 --> 01:06:55.000
So a lot of people were excited about, you know,

01:06:55.000 --> 01:06:58.000
the lock files, the uv run, a lot of people were

01:06:58.000 --> 01:07:00.000
excited about the fact that we have this like scripting

01:07:00.000 --> 01:07:03.000
API. So you can like have these standalone scripts,

01:07:03.000 --> 01:07:05.000
where the dependencies are embedded in them. And if

01:07:05.000 --> 01:07:08.000
you do uv run that script, you know, we just resolve

01:07:08.000 --> 01:07:11.000
the dependencies, download, download them and run

01:07:11.000 --> 01:07:13.000
the command with those dependencies available, run

01:07:13.000 --> 01:07:14.000
the script with those dependencies available. So you

01:07:14.000 --> 01:07:18.000
can have these like hermetic Python scripts. You know,

01:07:18.000 --> 01:07:20.000
we had the Python install API. So there were just

01:07:20.000 --> 01:07:21.000
different things that were resonating with people,

01:07:21.000 --> 01:07:24.000
which I think is what made me happiest in the response

01:07:24.000 --> 01:07:25.000
to it.

01:07:25.000 --> 01:07:29.000
Did you read, I'm sure you read Armen's, "Rye and UV

01:07:29.000 --> 01:07:32.000
August is harvest season for Python packaging."

01:07:32.000 --> 01:07:33.000
Yeah.

01:07:33.000 --> 01:07:37.000
Yeah, that's a pretty positive take and a pretty

01:07:37.000 --> 01:07:41.000
wide ranging recommendation there. It's pretty

01:07:41.000 --> 01:07:42.000
interesting.

01:07:42.000 --> 01:07:44.000
Yeah, the relationship with Rye is something we get

01:07:44.000 --> 01:07:49.000
a lot of questions about. And, you know, I think

01:07:49.000 --> 01:07:54.000
like, when we, you know, when we took over Rye, the

01:07:54.000 --> 01:07:57.000
goal was always like, we want to build uv up until

01:07:57.000 --> 01:08:00.000
to be a suitable replacement that people can migrate

01:08:00.000 --> 01:08:05.000
from Rye to uv. But, and we're getting further

01:08:05.000 --> 01:08:07.000
along that path, but there's still like things we're

01:08:07.000 --> 01:08:10.000
missing. We don't plan on like deprecating Rye

01:08:10.000 --> 01:08:12.000
anytime soon, but all of our like new feature

01:08:12.000 --> 01:08:15.000
development is really happening in uv and Rye, it's

01:08:15.000 --> 01:08:17.000
mostly like bug fixes, like keeping things up to

01:08:17.000 --> 01:08:22.000
date. So, you know, Rye has actually benefited a lot

01:08:22.000 --> 01:08:24.000
from uv because it uses uv under the hood. So like

01:08:24.000 --> 01:08:27.000
Rye has just gotten like there's new features,

01:08:27.000 --> 01:08:30.000
there's, you know, it's gotten faster. But, you

01:08:30.000 --> 01:08:32.000
know, our goal is really to like find the things

01:08:32.000 --> 01:08:34.000
that are missing from Rye and make sure we can

01:08:34.000 --> 01:08:36.000
support them in uv.

01:08:36.000 --> 01:08:40.000
Yeah. Last one we've got to cover here is,

01:08:40.000 --> 01:08:43.000
"Yovhini points out single file scripts with

01:08:43.000 --> 01:08:45.000
dependencies." That's the last one, the script

01:08:45.000 --> 01:08:50.000
execution. So, yeah, this is a huge problem. One

01:08:50.000 --> 01:08:53.000
of the reasons I think Tushar was suggesting it

01:08:53.000 --> 01:08:56.000
and I'm also really excited about it is if you

01:08:56.000 --> 01:08:59.000
could bundle your code into an application, one

01:08:59.000 --> 01:09:01.000
of the benefits is you don't have to have a

01:09:01.000 --> 01:09:05.000
conversation with everyone that runs it. How to

01:09:05.000 --> 01:09:07.000
do virtual environments, how to do package

01:09:07.000 --> 01:09:09.000
management, all this kind of stuff. You just say

01:09:09.000 --> 01:09:13.000
run, click it or whatever. And somewhat short of

01:09:13.000 --> 01:09:16.000
that is I want to give you just a script of some

01:09:16.000 --> 01:09:21.000
sort. And just say run this, right? Here's the

01:09:21.000 --> 01:09:24.000
script, you have an example.py, just run that.

01:09:24.000 --> 01:09:28.000
But if you put some sort of magical incantation

01:09:28.000 --> 01:09:32.000
which is backed by a PEP to say what it actually

01:09:32.000 --> 01:09:37.000
requires, then uv --script something,

01:09:37.000 --> 01:09:39.000
it'll just see that and go, okay, or uv run

01:09:39.000 --> 01:09:43.000
rather, it'll see that, install the pieces

01:09:43.000 --> 01:09:46.000
ephemerally, right? And run. That's pretty cool.

01:09:46.000 --> 01:09:47.000
Yeah, exactly.

01:09:47.000 --> 01:09:49.000
As kind of our last thing before we run out of time.

01:09:49.000 --> 01:09:53.000
This is backed by a pep. I think it's 723, if I

01:09:53.000 --> 01:09:56.000
recall correctly. So this is like a standardized,

01:09:56.000 --> 01:10:01.000
this syntax at the top of the file is standardized.

01:10:01.000 --> 01:10:02.000
Might not be mentioned.

01:10:02.000 --> 01:10:04.000
Yeah, there's a bunch of PEP conversations, but

01:10:04.000 --> 01:10:06.000
not the one.

01:10:06.000 --> 01:10:08.000
Yeah, we sometimes try and like shy away from

01:10:08.000 --> 01:10:10.000
talking about user-facing features in terms of

01:10:10.000 --> 01:10:12.000
peps.

01:10:12.000 --> 01:10:13.000
Yeah.

01:10:13.000 --> 01:10:14.000
It's because it's not --

01:10:14.000 --> 01:10:15.000
There you go, 723, that's it.

01:10:15.000 --> 01:10:19.000
Yeah, okay, well, there it is. But anyway, the

01:10:19.000 --> 01:10:21.000
idea here is like you can declare the dependencies

01:10:21.000 --> 01:10:24.000
for the script right in the script. And then when

01:10:24.000 --> 01:10:28.000
you do uv run that script, we read that dependency

01:10:28.000 --> 01:10:30.000
data and we run the script in an environment with

01:10:30.000 --> 01:10:36.000
those dependencies. So the other, I think, really

01:10:36.000 --> 01:10:42.000
cool piece here is I talked before about uv add.

01:10:42.000 --> 01:10:44.000
So if you're in a project with a Py Project

01:10:44.000 --> 01:10:48.000
toml, you can do like uv add vast API or whatever.

01:10:48.000 --> 01:10:51.000
But you can also do that for scripts. So if you

01:10:51.000 --> 01:10:54.000
scroll, if you look for like uv add dash dash

01:10:54.000 --> 01:10:58.000
script, so you're referred to this like magical

01:10:58.000 --> 01:11:00.000
incantation at the top. We will actually like

01:11:00.000 --> 01:11:03.000
create that for you. So if you do uv add dash dash

01:11:03.000 --> 01:11:06.000
script, and then the script name and the dependencies,

01:11:06.000 --> 01:11:08.000
like we'll actually just like put that stuff in

01:11:08.000 --> 01:11:10.000
there for you. So you don't actually have to

01:11:10.000 --> 01:11:12.000
like remember how to do that. Like you can just

01:11:12.000 --> 01:11:15.000
do uv run --script, and we will actually

01:11:15.000 --> 01:11:18.000
like populate that field. So you can create a

01:11:18.000 --> 01:11:20.000
script, you can manage the dependencies in it

01:11:20.000 --> 01:11:24.000
with UV, you can run it. This is like super

01:11:24.000 --> 01:11:26.000
useful. There's some interesting conversations

01:11:26.000 --> 01:11:29.000
happening now too around like what if we want to

01:11:29.000 --> 01:11:32.000
have a lock file for these? Because it's a little

01:11:32.000 --> 01:11:34.000
bit different, right? This is the list of

01:11:34.000 --> 01:11:36.000
dependencies. It's not the list of resolved

01:11:36.000 --> 01:11:38.000
versions. So if you wanted to have like full

01:11:38.000 --> 01:11:41.000
reproducibility, you probably want to lock file.

01:11:41.000 --> 01:11:46.000
And not just these things versions, but they're

01:11:46.000 --> 01:11:48.000
the transitive closure of all the dependencies.

01:11:48.000 --> 01:11:51.000
Correct. You know, everything they depend on.

01:11:51.000 --> 01:11:54.000
Yeah. So, you know, we do that for projects.

01:11:54.000 --> 01:11:56.000
Like if you do uv lock in a project, we create

01:11:56.000 --> 01:11:58.000
this lock file. That's all the transitive

01:11:58.000 --> 01:12:01.000
dependencies. It locks the exact URLs, the

01:12:01.000 --> 01:12:04.000
files, the hashes, the versions, everything. We

01:12:04.000 --> 01:12:06.000
don't do that right now for scripts, just because

01:12:06.000 --> 01:12:10.000
there's no, there isn't really a place to put it.

01:12:10.000 --> 01:12:11.000
But we're kind of thinking about...

01:12:11.000 --> 01:12:13.000
Have you considered the Windows registry?

01:12:13.000 --> 01:12:15.000
I mean, you could always just like integrate

01:12:15.000 --> 01:12:17.000
that and import that over to Mac and Linux.

01:12:17.000 --> 01:12:18.000
That'd be fine.

01:12:18.000 --> 01:12:20.000
Yeah. Just put everything in the Windows

01:12:20.000 --> 01:12:21.000
registry.

01:12:21.000 --> 01:12:23.000
Yeah. That's a winning idea.

01:12:23.000 --> 01:12:24.000
Yeah.

01:12:24.000 --> 01:12:25.000
No, I totally get it.

01:12:25.000 --> 01:12:27.000
Yeah. I mean, the other thing that's interesting

01:12:27.000 --> 01:12:28.000
too is like the notebooks, like people are

01:12:28.000 --> 01:12:30.000
thinking about how can we add this kind of

01:12:30.000 --> 01:12:33.000
functionality to notebooks and, you know, being

01:12:33.000 --> 01:12:36.000
able to declare the dependencies for a notebook

01:12:36.000 --> 01:12:38.000
right in the notebook, being able to unlock

01:12:38.000 --> 01:12:40.000
them too. There's a lot of cool stuff that we

01:12:40.000 --> 01:12:42.000
can build now that we have all these primitives

01:12:42.000 --> 01:12:44.000
connected.

01:12:44.000 --> 01:12:46.000
Yeah, for sure. I mean, you could do something

01:12:46.000 --> 01:12:48.000
like take a hash of the file and then use that

01:12:48.000 --> 01:12:51.000
hash as the name and long as the file doesn't

01:12:51.000 --> 01:12:53.000
change, it'll run the same. I don't know.

01:12:53.000 --> 01:12:54.000
Yeah.

01:12:54.000 --> 01:12:58.000
Yeah. I'll leave that to you all.

01:12:58.000 --> 01:13:00.000
So I think, I mean, we didn't even talk about

01:13:00.000 --> 01:13:02.000
the speed for some of these things and there's

01:13:02.000 --> 01:13:04.000
a whole lot of stuff here, but.

01:13:04.000 --> 01:13:06.000
There's a lot of good stories to tell about

01:13:06.000 --> 01:13:09.000
how we made some of these things. The problems

01:13:09.000 --> 01:13:11.000
we had to solve to like really some of this

01:13:11.000 --> 01:13:15.000
stuff, but they'll make for, you know, if I

01:13:15.000 --> 01:13:17.000
dream, they'll make for good blog posts. In

01:13:17.000 --> 01:13:19.000
reality, they'll probably make for good Twitter

01:13:19.000 --> 01:13:21.000
threads.

01:13:21.000 --> 01:13:24.000
Absolutely. All right. Well, Charlie, thanks

01:13:24.000 --> 01:13:27.000
for being here. Maybe give us a final thoughts

01:13:27.000 --> 01:13:30.000
and words for folks who are interested in this

01:13:30.000 --> 01:13:32.000
new layer of uv.

01:13:32.000 --> 01:13:37.000
Yeah. I mean, I think like this is, this release

01:13:37.000 --> 01:13:39.000
is really different from the previous release

01:13:39.000 --> 01:13:41.000
in part because we designed and built a lot

01:13:41.000 --> 01:13:45.000
of stuff that's pretty new for people and also

01:13:45.000 --> 01:13:48.000
requires people to change their workflows in a

01:13:48.000 --> 01:13:50.000
lot of cases. Like the previous release, it was

01:13:50.000 --> 01:13:52.000
like, this is a lot like pip, so kind of just

01:13:52.000 --> 01:13:54.000
drop it in. And now it's like, here's a bunch

01:13:54.000 --> 01:13:56.000
of ways to use these tools. If you were, it

01:13:56.000 --> 01:13:58.000
does require you to work a certain way and kind

01:13:58.000 --> 01:14:00.000
of think a certain way, but we think it's really

01:14:00.000 --> 01:14:03.000
powerful. And that's all stuff we're like kind

01:14:03.000 --> 01:14:05.000
of trying to figure out. Right. So we're very

01:14:05.000 --> 01:14:08.000
eager for, you know, I'm sure, I'm sure all this

01:14:08.000 --> 01:14:11.000
stuff will change and I'm just eager for like,

01:14:11.000 --> 01:14:12.000
like every release, I'm just excited to have it

01:14:12.000 --> 01:14:14.000
out, have people testing it, have people using

01:14:14.000 --> 01:14:17.000
it so we can get feedback. And so, you know, I

01:14:17.000 --> 01:14:20.000
would love for you to try it out. I'd love you

01:14:20.000 --> 01:14:22.000
even more for you to come file issues about the

01:14:22.000 --> 01:14:24.000
things that don't work so we can make it better

01:14:24.000 --> 01:14:29.000
but I think we have a really cool foundation

01:14:29.000 --> 01:14:31.000
here. We can build a lot of things that hopefully

01:14:31.000 --> 01:14:35.000
make working with Python a lot, you know, a lot

01:14:35.000 --> 01:14:38.000
easier in the sense that the tools kind of get

01:14:38.000 --> 01:14:41.000
out of your way rather than getting in your way.

01:14:41.000 --> 01:14:44.000
So yeah, that'll be our focus for the next, for

01:14:44.000 --> 01:14:46.000
the next while is seeing how people are using

01:14:46.000 --> 01:14:47.000
this stuff and seeing where we can make it

01:14:47.000 --> 01:14:51.000
better. Well, I think it's pretty awesome. We

01:14:51.000 --> 01:14:54.000
all are up to big fan of uv so happy to see

01:14:54.000 --> 01:14:57.000
the project. Thank you. And always happy to

01:14:57.000 --> 01:15:00.000
have you on. So thank you. Yeah. See you later.

01:15:00.000 --> 01:15:02.000
Bye.

