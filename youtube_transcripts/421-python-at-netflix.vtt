WEBVTT

00:00:00.000 --> 00:00:04.600
- Hey, Soren. Hey, I'm Jeeth. - Hello, Michael.


00:00:04.600 --> 00:00:09.280
- Hello, Michael. - Welcome to Talk Python, you guys.


00:00:09.280 --> 00:00:14.640
It's excellent to have you here. - Thank you very much. I'm a big fan, so it's


00:00:14.640 --> 00:00:19.400
very nice to be on the show, actually. - Awesome, yeah. We've got to meet a couple


00:00:19.400 --> 00:00:25.160
times at PyCon, which is honestly one of my favorite purposes of PyCon is to meet people


00:00:25.160 --> 00:00:28.520
and just hang out and have those experiences.


00:00:28.520 --> 00:00:31.000
Yeah, absolutely.


00:00:31.000 --> 00:00:34.000
Yeah, and nice to have you on the show, Zorin.


00:00:34.000 --> 00:00:36.720
Yeah, I'm a big fan as well.


00:00:36.720 --> 00:00:37.560
Thank you very much.


00:00:37.560 --> 00:00:39.760
That's very kind of both of you.


00:00:39.760 --> 00:00:44.960
So we're going to talk about a pretty awesome tech company,


00:00:44.960 --> 00:00:45.460
I think.


00:00:45.460 --> 00:00:47.120
Netflix, you both work at Netflix.


00:00:47.120 --> 00:00:48.660
And people who are watching the video,


00:00:48.660 --> 00:00:51.800
you're coming to us from the Netflix headquarters, which


00:00:51.800 --> 00:00:54.440
I've got the chance to be there for some Python


00:00:54.440 --> 00:00:56.680
stuff going on there before as well.


00:00:56.680 --> 00:00:59.640
Got cool posters and movie studio feel.


00:00:59.640 --> 00:01:03.080
So that's the backdrop you both have going on,


00:01:03.080 --> 00:01:04.880
which is excellent.


00:01:04.880 --> 00:01:05.720
- Yeah, yeah.


00:01:05.720 --> 00:01:09.040
It's pretty nice to work at Netflix.


00:01:09.040 --> 00:01:11.000
It's a very good company.


00:01:11.000 --> 00:01:12.700
I'm very happy.


00:01:12.700 --> 00:01:14.660
- Well, a lot of Python we're gonna learn.


00:01:14.660 --> 00:01:15.680
- Yes, yeah.


00:01:15.680 --> 00:01:17.280
We do use a lot of Python, yeah.


00:01:17.280 --> 00:01:19.600
- Excellent.


00:01:19.600 --> 00:01:21.440
So we're gonna talk about Python and Netflix,


00:01:21.440 --> 00:01:23.960
a wide ranging survey of


00:01:23.960 --> 00:01:26.440
A lot of projects you all have created, how you're using it,


00:01:26.440 --> 00:01:30.160
some other ones that both of you personally created,


00:01:30.160 --> 00:01:32.680
either tied to or not tied to Netflix.


00:01:32.680 --> 00:01:36.400
But I think people are gonna really enjoy this look


00:01:36.400 --> 00:01:38.200
inside what you all got going on.


00:01:38.200 --> 00:01:39.440
Before we get to that though,


00:01:39.440 --> 00:01:40.900
let's start with your stories.


00:01:40.900 --> 00:01:44.880
Quick introduction, how'd you get here working on Python?


00:01:44.880 --> 00:01:46.180
Soren, you wanna go first?


00:01:46.180 --> 00:01:49.340
- Yeah.


00:01:49.340 --> 00:01:51.520
Yeah, so I was


00:01:53.680 --> 00:01:57.440
hooked into programming ever since I saw my first computer.


00:01:57.440 --> 00:01:59.840
I was 13 in middle school.


00:01:59.840 --> 00:02:01.560
It was an Amstrad CPC.


00:02:01.560 --> 00:02:05.160
Right, that was the thing I wanted to do.


00:02:05.160 --> 00:02:09.440
So yeah, I started programming as a hobby at first.


00:02:09.440 --> 00:02:13.480
And fun fact, way back then, later on in high school,


00:02:13.480 --> 00:02:14.880
one of my math teachers told me,


00:02:14.880 --> 00:02:16.240
"Hey, do something real.


00:02:16.240 --> 00:02:17.440
"Don't do programming.


00:02:17.440 --> 00:02:19.200
"It's like a dead end.


00:02:19.200 --> 00:02:21.640
"You won't be able to find a job."


00:02:21.640 --> 00:02:23.520
(laughing)


00:02:23.520 --> 00:02:28.880
Did they tell you things like these drag and drop visual tools


00:02:28.880 --> 00:02:34.520
are going to replace all the programmers and the low code of the '80s and '90s,


00:02:34.520 --> 00:02:35.020
maybe?


00:02:35.020 --> 00:02:35.520
Yeah.


00:02:35.520 --> 00:02:42.880
You know, back then, I guess it was very-- well,


00:02:42.880 --> 00:02:45.040
didn't seem that obvious, yeah.


00:02:45.040 --> 00:02:46.440
Yeah.


00:02:46.440 --> 00:02:50.480
And then, yeah, I decided to go computer science anyway,


00:02:50.480 --> 00:02:53.600
because that's what I wanted to do.


00:02:53.600 --> 00:02:56.480
And then I spent the vast majority of my career


00:02:56.480 --> 00:03:00.280
in a language that is not very much known or used,


00:03:00.280 --> 00:03:02.360
I think, iPhone.


00:03:02.360 --> 00:03:06.640
So I spent more than a decade doing iPhone mostly.


00:03:06.640 --> 00:03:11.680
And then I discovered Python once I joined LinkedIn in 2011.


00:03:11.680 --> 00:03:17.800
And that's when I got hooked and decided to do more and more


00:03:17.800 --> 00:03:18.960
things Python.


00:03:18.960 --> 00:03:23.640
And now at Netflix, even more so trying to support


00:03:23.640 --> 00:03:25.620
net Python across the board.


00:03:25.620 --> 00:03:27.400
- Yeah.


00:03:27.400 --> 00:03:30.640
You're kind of doing meta Python in the sense that


00:03:30.640 --> 00:03:33.700
your team does a lot of stuff to facilitate


00:03:33.700 --> 00:03:35.920
other people doing Python too, right?


00:03:35.920 --> 00:03:36.960
- Exactly, yes.


00:03:36.960 --> 00:03:40.200
- Yeah, that's our team at Netflix.


00:03:40.200 --> 00:03:42.440
Like we enable other Python developers


00:03:42.440 --> 00:03:45.060
to be more productive by building tools


00:03:45.060 --> 00:03:46.920
or building the infrastructure necessary


00:03:46.920 --> 00:03:51.440
to ship their code faster or build their products sooner,


00:03:51.440 --> 00:03:53.000
things like that.


00:03:53.000 --> 00:03:54.500
- Yeah, cool.


00:03:54.500 --> 00:03:56.400
How about you, Amjith?


00:03:56.400 --> 00:04:01.400
- Oh, I got introduced to programming in high school.


00:04:01.400 --> 00:04:06.320
We had like one hour of computer lab every week.


00:04:06.320 --> 00:04:10.080
I got to learn GW basic, that was my first language.


00:04:10.080 --> 00:04:12.920
It was fantastic, I still have fond memories


00:04:12.920 --> 00:04:15.820
of like trying to draw circles on the screen.


00:04:16.720 --> 00:04:21.020
And then I went to college, I learned C and C++.


00:04:21.020 --> 00:04:23.400
I liked those, but then after I got a job,


00:04:23.400 --> 00:04:26.060
I wanted to learn how to be a better programmer.


00:04:26.060 --> 00:04:26.900
And somebody mentioned,


00:04:26.900 --> 00:04:28.600
"Oh, functional programming is the bee's knees.


00:04:28.600 --> 00:04:30.800
"You should actually, if you learn how to


00:04:30.800 --> 00:04:31.740
"do functional programming,


00:04:31.740 --> 00:04:33.500
"your general programming will get better.


00:04:33.500 --> 00:04:35.980
"And the best language to learn functional programming


00:04:35.980 --> 00:04:37.120
"is Haskell."


00:04:37.120 --> 00:04:40.120
And so I took a book called "Learn You a Haskell."


00:04:40.120 --> 00:04:42.340
And then I went through the first few chapters.


00:04:42.340 --> 00:04:44.000
And it was mind-blowing.


00:04:44.000 --> 00:04:46.040
It was a really fantastic language.


00:04:46.040 --> 00:04:48.880
and I got first introduced to a concept of REPL


00:04:48.880 --> 00:04:51.960
and like trying out like little snippets in the interpreter


00:04:51.960 --> 00:04:53.680
and getting answers and it was fantastic.


00:04:53.680 --> 00:04:57.160
And I got introduced to list comprehension in Haskell


00:04:57.160 --> 00:04:59.200
and it was just mind blowing.


00:04:59.200 --> 00:05:01.440
It's like, you know, without having to write


00:05:01.440 --> 00:05:03.600
like five lines of for loop, you could just,


00:05:03.600 --> 00:05:05.680
it's a single line thing.


00:05:05.680 --> 00:05:09.160
And I quickly realized that, you know,


00:05:09.160 --> 00:05:12.520
you can't find actual jobs writing Haskell


00:05:12.520 --> 00:05:13.720
or at least, you know, not,


00:05:13.720 --> 00:05:16.060
(laughs)


00:05:16.060 --> 00:05:18.720
So I figured out like what's a language


00:05:18.720 --> 00:05:21.760
that has list comprehension that is actually employable,


00:05:21.760 --> 00:05:24.200
you know, that I could find jobs in.


00:05:24.200 --> 00:05:26.040
And that's how I found Python


00:05:26.040 --> 00:05:29.280
because I came to Python because of list comprehension.


00:05:29.280 --> 00:05:30.120
- Oh, awesome.


00:05:30.120 --> 00:05:30.940
- Yeah. - Okay.


00:05:30.940 --> 00:05:34.160
Learn You a Haskell for Great Good,


00:05:34.160 --> 00:05:35.920
a beginner's guide, is that the book?


00:05:35.920 --> 00:05:37.040
- That is the book, yeah.


00:05:37.040 --> 00:05:40.080
And it's actually still available online for free


00:05:40.080 --> 00:05:42.640
that anybody could read, I'm fairly certain.


00:05:42.640 --> 00:05:45.400
And I actually bought like a paper copy of the book.


00:05:45.400 --> 00:05:46.780
It's a good book.


00:05:46.780 --> 00:05:49.740
Yeah, it's a fun one to go through.


00:05:49.740 --> 00:05:52.640
- Yeah, it looks like it's really got


00:05:52.640 --> 00:05:54.280
a playful nature to it.


00:05:54.280 --> 00:05:55.680
- Yeah, exactly, yeah.


00:05:55.680 --> 00:05:59.400
- You know, your thoughts about less comprehensions


00:05:59.400 --> 00:06:01.840
really connects with me as well.


00:06:01.840 --> 00:06:05.320
I guess my first exposure to something like that


00:06:05.320 --> 00:06:08.600
was Link, L-I-N-Q and C#, which is,


00:06:08.600 --> 00:06:11.440
it's honestly, I think it's better


00:06:11.440 --> 00:06:12.600
than Python less comprehensions.


00:06:12.600 --> 00:06:15.480
which Python had out just a little bit more.


00:06:15.480 --> 00:06:16.560
- Nice. - Little bit.


00:06:16.560 --> 00:06:18.200
Just one or two things more.


00:06:18.200 --> 00:06:21.080
For example, wouldn't it be nice in a list comprehension


00:06:21.080 --> 00:06:22.740
if you could specify a sort?


00:06:22.740 --> 00:06:26.640
Because I find myself often doing a list comprehension


00:06:26.640 --> 00:06:29.840
and then sorting the thing in the end afterwards.


00:06:29.840 --> 00:06:31.840
But if you could just say, order by,


00:06:31.840 --> 00:06:33.180
and give it an expression,


00:06:33.180 --> 00:06:37.000
like you would pass a lambda over to a, you know.


00:06:37.000 --> 00:06:40.040
So just there's room for more.


00:06:40.040 --> 00:06:43.120
What PEP do I need to write to get sort in a list comprehension?


00:06:43.120 --> 00:06:44.840
I don't know, but I want it.


00:06:44.840 --> 00:06:46.200
Anyway, yeah.


00:06:46.200 --> 00:06:50.520
So I really think that that's a cool language feature.


00:06:50.520 --> 00:06:52.440
And it's also one of the areas that they're


00:06:52.440 --> 00:06:58.360
applying some of these speedups in the faster CPython work that's coming.


00:06:58.360 --> 00:07:03.080
They're doing list comprehensions for isolation purposes in Python 3


00:07:03.080 --> 00:07:08.320
are basically hidden function calls with their own stack frame and variables


00:07:08.320 --> 00:07:10.640
that you don't actually see, right?


00:07:10.640 --> 00:07:12.840
You don't write it, but that's kind of the execution level.


00:07:12.840 --> 00:07:14.680
And now they're inlining those to make them


00:07:14.680 --> 00:07:16.920
a little bit faster, maybe twice as fast?


00:07:16.920 --> 00:07:18.760
I don't know.


00:07:18.760 --> 00:07:21.840
- Yeah, I think the faster Python team is doing


00:07:21.840 --> 00:07:23.400
a fantastic job.


00:07:23.400 --> 00:07:25.280
There was a talk that I attended at PyCon,


00:07:25.280 --> 00:07:26.760
not this year, but the previous year,


00:07:26.760 --> 00:07:28.080
where they introduced Switchcase,


00:07:28.080 --> 00:07:31.640
how they were doing the case statements.


00:07:31.640 --> 00:07:34.880
It's not the exact Switchcase, but coming from C and C++,


00:07:34.880 --> 00:07:36.320
I knew what Switchcases are.


00:07:36.320 --> 00:07:39.800
And when I saw what is possible with the pattern matching,


00:07:39.800 --> 00:07:41.840
like structural pattern matching in Python,


00:07:41.840 --> 00:07:45.880
it's like, take Switchcase and then turn it up to 11.


00:07:45.880 --> 00:07:47.160
And that's what this is.


00:07:47.160 --> 00:07:47.960
And you're right.


00:07:47.960 --> 00:07:49.880
I mean, there is always more that can be done.


00:07:49.880 --> 00:07:53.640
But I think it's going in a great direction, I think.


00:07:53.640 --> 00:07:54.400
It's fantastic.


00:07:54.400 --> 00:07:56.240
Yeah, let's talk about that.


00:07:56.240 --> 00:07:59.760
We're going to dive into the details of Netflix and stuff.


00:07:59.760 --> 00:08:04.680
But just this whole Python 3.11, 3.12,


00:08:04.680 --> 00:08:09.080
These are really big performance improvements coming along.


00:08:09.080 --> 00:08:12.040
Are you able yet to take advantage of those at Netflix?


00:08:12.040 --> 00:08:14.520
And is that making a big difference?


00:08:14.520 --> 00:08:16.560
Are you guys still running 3.8?


00:08:16.560 --> 00:08:19.800
Or are you more closer to the cutting edge


00:08:19.800 --> 00:08:21.240
in terms of releases?


00:08:21.240 --> 00:08:25.080
- So I think one of the advantages here at Netflix


00:08:25.080 --> 00:08:29.320
is that every team has the freedom to choose the tools


00:08:29.320 --> 00:08:30.400
that they need to use.


00:08:30.400 --> 00:08:34.260
And it's great and also kind of painful


00:08:34.260 --> 00:08:36.820
for central teams because now there's a bifurcation


00:08:36.820 --> 00:08:39.540
of all kinds of different versions out there.


00:08:39.540 --> 00:08:41.860
But where I'm going with this is that every team


00:08:41.860 --> 00:08:44.500
is allowed to choose what they need to use


00:08:44.500 --> 00:08:45.740
in order to get their job done.


00:08:45.740 --> 00:08:49.060
And so my previous team, we were at the cutting edge.


00:08:49.060 --> 00:08:52.500
We used 3.11 or we still use 3.11 in the project


00:08:52.500 --> 00:08:55.540
that we built and the services that we use.


00:08:55.540 --> 00:08:56.940
And it is a nice boost.


00:08:56.940 --> 00:08:59.540
We could certainly see, so for instance,


00:08:59.540 --> 00:09:01.580
there is a periodic job that runs


00:09:01.580 --> 00:09:04.060
and it's like a sort of a cron job


00:09:04.060 --> 00:09:05.620
that runs every five minutes or so.


00:09:05.620 --> 00:09:07.760
And we had put in like so much optimization


00:09:07.760 --> 00:09:09.860
so that it will actually finish within the five minutes


00:09:09.860 --> 00:09:12.820
because we were doing a lot of data crunching and so forth.


00:09:12.820 --> 00:09:16.460
And just so we don't like stack up the cron tasks.


00:09:16.460 --> 00:09:19.140
But when we switched from, I think from,


00:09:19.140 --> 00:09:21.580
like we did jump from 3.9 to 3.11 directly.


00:09:21.580 --> 00:09:24.860
We did not like go to 3.10, but then when we jumped,


00:09:24.860 --> 00:09:26.020
it felt like, you know,


00:09:26.020 --> 00:09:28.460
things that were taking like four minutes,


00:09:28.460 --> 00:09:30.600
were now finishing in like two minutes.


00:09:30.600 --> 00:09:34.760
And it was like a huge improvement that you could see


00:09:34.760 --> 00:09:37.520
and it felt very rewarding to see that.


00:09:37.520 --> 00:09:38.360
So yeah, absolutely.


00:09:38.360 --> 00:09:40.520
So every team gets to choose what they want to use


00:09:40.520 --> 00:09:43.360
and our job as a central Python team


00:09:43.360 --> 00:09:45.480
that Zorin and I are currently part of


00:09:45.480 --> 00:09:48.760
is to try and enable people to use that,


00:09:48.760 --> 00:09:50.500
use whatever is the latest that is available.


00:09:50.500 --> 00:09:53.760
So whatever internal tools that we have,


00:09:53.760 --> 00:09:56.760
we have to make sure that it actually gets exercised


00:09:56.760 --> 00:09:59.560
in the latest Python version that got released


00:09:59.560 --> 00:10:03.280
and make sure that everything is building and deploying


00:10:03.280 --> 00:10:06.040
as they are supposed to do and so on.


00:10:06.040 --> 00:10:07.240
- Okay, excellent.


00:10:07.240 --> 00:10:09.160
That's pretty cool, that story of speeding up


00:10:09.160 --> 00:10:10.580
your cron jobs.


00:10:10.580 --> 00:10:11.480
- Yeah.


00:10:11.480 --> 00:10:14.600
- That's non-trivial and it probably wasn't a lot of work


00:10:14.600 --> 00:10:16.100
to move from 3.9 to 3.11.


00:10:16.100 --> 00:10:18.000
I know my upgrade path was,


00:10:18.000 --> 00:10:21.120
rebuild some virtual environments on the server


00:10:21.120 --> 00:10:22.520
and now we're good to go.


00:10:22.520 --> 00:10:24.040
- Exactly, yep, yeah.


00:10:24.040 --> 00:10:26.640
- Yeah.


00:10:26.640 --> 00:10:28.240
So, Orin, anything you wanna add about that?


00:10:28.240 --> 00:10:30.520
3.11, faster CPython, Slime.


00:10:30.520 --> 00:10:35.520
- Oh yeah, so yeah, absolutely, it's so much faster.


00:10:35.520 --> 00:10:39.320
The main issue when upgrading is the lack of wheels


00:10:39.320 --> 00:10:42.160
if you're stuck on older libraries.


00:10:42.160 --> 00:10:44.560
But we do have a few numbers,


00:10:44.560 --> 00:10:47.320
like the most used right now is Python 3.10


00:10:47.320 --> 00:10:50.240
across the board, it will depend on the team,


00:10:50.240 --> 00:10:53.000
everybody is upgrading at their own pace.


00:10:53.000 --> 00:10:58.000
And 3.11 is starting to grow a bit.


00:10:58.000 --> 00:11:03.400
grow a bit. But yeah, most used right now is 3.10 static.


00:11:03.400 --> 00:11:09.040
Honestly, that sounds really quite good for for a company the


00:11:09.040 --> 00:11:12.680
size of Netflix and how much Python you're doing. Like that's


00:11:12.680 --> 00:11:14.760
pretty close to pushing the envelope.


00:11:14.760 --> 00:11:21.360
Yeah, yeah. There are still some teams that are sort of stuck on


00:11:21.360 --> 00:11:25.880
three eight or three seven, I want to say, simply because they


00:11:25.920 --> 00:11:30.640
provide a platform that allows data scientists to write their code.


00:11:30.640 --> 00:11:37.520
And they have this pre-built image with all of the necessary libraries pre-installed in


00:11:37.520 --> 00:11:38.520
there.


00:11:38.520 --> 00:11:43.480
And so they have a pretty tight control over which libraries will get upgraded on what


00:11:43.480 --> 00:11:44.680
cadence and so on.


00:11:44.680 --> 00:11:49.400
And so for them, I think they're still running on 3.7.


00:11:49.400 --> 00:11:53.000
I'm sure when they switch to 3.10 or 3.11,


00:11:53.000 --> 00:11:56.200
it's going to be a screaming fast improvement.


00:11:56.200 --> 00:11:59.480
So looking forward to that migration to happen.


00:11:59.480 --> 00:12:00.320
- Yeah, excellent.


00:12:00.320 --> 00:12:02.480
- Yeah, this number I cited is very static, right?


00:12:02.480 --> 00:12:06.840
It's a number of preferred pythons across repos,


00:12:06.840 --> 00:12:09.840
but yeah, dynamically, right?


00:12:09.840 --> 00:12:11.400
Like you may have lots of instances


00:12:11.400 --> 00:12:15.200
who still run on 3.7 and they will massively move to,


00:12:15.200 --> 00:12:19.280
so that team is moving from 3.7 to 3.10, for example.


00:12:19.280 --> 00:12:19.780
Yeah.


00:12:19.780 --> 00:12:21.140
Okay.


00:12:21.140 --> 00:12:24.380
Yeah.


00:12:24.380 --> 00:12:24.880
Very cool.


00:12:24.880 --> 00:12:26.700
All right.


00:12:26.700 --> 00:12:34.640
Well, let's, let's start by talking about kind of the, the broad story of Python at Netflix.


00:12:34.640 --> 00:12:44.640
Um, maybe we could start with what you all do day to day in terms of like, what's your role?


00:12:44.880 --> 00:12:48.440
How do you, 'cause you kind of support other people's Python


00:12:48.440 --> 00:12:49.680
as I hinted before.


00:12:49.680 --> 00:12:51.640
So maybe we can get a sense of what you all do day to day.


00:12:51.640 --> 00:12:54.560
And then we'll, Amjith, you wrote a nice blog article


00:12:54.560 --> 00:12:58.640
that's a big broad viewer survey


00:12:58.640 --> 00:13:01.000
of how Python's being used in all these different places.


00:13:01.000 --> 00:13:03.840
So maybe start with what you all do day to day on your team


00:13:03.840 --> 00:13:05.280
and then we'll go into that.


00:13:05.280 --> 00:13:06.240
- Yeah, sure thing.


00:13:06.240 --> 00:13:09.680
I've been with Netflix for about six years now.


00:13:09.680 --> 00:13:12.360
And previously I was in a different team


00:13:12.360 --> 00:13:17.360
And we were doing failovers, which was a way of running,


00:13:17.360 --> 00:13:20.020
if Netflix ever goes down in one of the AWS regions,


00:13:20.020 --> 00:13:21.760
we are the team that gets paged in


00:13:21.760 --> 00:13:24.420
and we go and move all the traffic from that region


00:13:24.420 --> 00:13:27.260
to another other two regions that we run in.


00:13:27.260 --> 00:13:30.420
So that's what I was doing up until like February


00:13:30.420 --> 00:13:31.260
of this year.


00:13:31.260 --> 00:13:34.960
- Let me just take a step back real quick with you.


00:13:34.960 --> 00:13:38.660
Netflix is kind of all in on AWS, right?


00:13:38.660 --> 00:13:40.700
Like there's been a lot of stories


00:13:40.700 --> 00:13:44.980
about how you all have set loose the chaos monkey


00:13:44.980 --> 00:13:47.940
into your data centers and how you worked on failover


00:13:47.940 --> 00:13:49.740
from AWS regions.


00:13:49.740 --> 00:13:53.740
And so I don't know if you all are the largest users of AWS,


00:13:53.740 --> 00:13:56.180
but certainly one of the more interesting,


00:13:56.180 --> 00:13:59.580
complicated deployments out there, right?


00:13:59.580 --> 00:14:02.140
- Yeah, so I think we were the earliest adopters


00:14:02.140 --> 00:14:04.940
of cloud computing when AWS first came out.


00:14:04.940 --> 00:14:09.460
And so AWS has used us as the poster child for,


00:14:09.460 --> 00:14:14.540
see big companies can run in cloud and you don't have to be on-prem. And so we


00:14:14.540 --> 00:14:19.140
think of them as partners, not so much as you know like this client-owner


00:14:19.140 --> 00:14:24.860
relationship or anything like that. So we consider AWS as our business partners


00:14:24.860 --> 00:14:32.660
and yes we are full in on AWS and Chaos Monkey even now, yes it is it functions


00:14:32.660 --> 00:14:37.940
in AWS like it goes around and just inside our VPC it does terminate


00:14:37.940 --> 00:14:41.820
instances occasionally or not occasionally, like once every day, one


00:14:41.820 --> 00:14:48.340
instance every day on every service. So that is so wild. I mean, obviously, you


00:14:48.340 --> 00:14:53.100
don't want to set it loose on other people's AWS instances, right? Yeah, but


00:14:53.100 --> 00:14:57.180
no, that's a really interesting way to force people to think about developers


00:14:57.180 --> 00:15:04.820
and infrastructure folks to think about what happens if the cloud somehow your


00:15:04.820 --> 00:15:07.700
server dies, it may be sending the clouds fall, right? It's just like, okay, there's


00:15:07.700 --> 00:15:10.820
a Linux machine running and that thing died, it could have been running anywhere.


00:15:10.820 --> 00:15:13.020
It happened to be in AWS.


00:15:13.020 --> 00:15:17.940
But to force them to think about outgoing, like we will, it's not an eventuality, this


00:15:17.940 --> 00:15:18.940
will happen.


00:15:18.940 --> 00:15:20.260
And so you plan for it.


00:15:20.260 --> 00:15:21.260
Yeah.


00:15:21.260 --> 00:15:25.660
So it's even more than just the idea of like, it will happen.


00:15:25.660 --> 00:15:26.940
So we plan for it thing.


00:15:26.940 --> 00:15:30.500
It's more like, you know, it's a way of building software where you need to build software


00:15:30.500 --> 00:15:33.820
that's resilient and has enough fallbacks built in.


00:15:33.820 --> 00:15:37.480
And so for instance, if you are not able to reach the database, do you have a cache in


00:15:37.480 --> 00:15:42.440
front that can sort of keep the thing going for the few network calls that are failing


00:15:42.440 --> 00:15:44.700
to reach the database?


00:15:44.700 --> 00:15:50.380
Those are like basic common things, paradigms that have become commonplace nowadays in software


00:15:50.380 --> 00:15:58.720
development where building fallbacks automatically is like standard practice these days.


00:15:58.720 --> 00:16:03.720
But when Chaos Monkey was created, which was about 10 years ago, these were like new concepts


00:16:03.720 --> 00:16:08.680
that people were not using. And it was assumed that once you have a server and you put your


00:16:08.680 --> 00:16:13.240
software on the server and you run it, it's basically done until you do the next deploy,


00:16:13.240 --> 00:16:21.160
which takes another month or so to refresh that code. But that all changed once we went to cloud,


00:16:21.160 --> 00:16:25.560
where we started doing deployments on a daily basis or maybe even more hourly basis and things


00:16:25.560 --> 00:16:30.360
like that. And so when you are doing that, when you are shutting down one server with an old


00:16:30.360 --> 00:16:34.840
version and bringing up the new server with the new version, how are you going to make sure that


00:16:34.840 --> 00:16:40.520
the connections are not going to fall and how are you going to make sure that the network


00:16:40.520 --> 00:16:47.080
continuity continues and so forth. So yeah, Chaos Monkey was just introduced as a way to ensure that


00:16:47.080 --> 00:16:53.640
people are building software in a way that is resilient and this is just a way to sort of


00:16:54.200 --> 00:17:01.160
test that on an ongoing basis. Yeah, it's quite an operational challenge. I mean, I don't recall


00:17:01.160 --> 00:17:05.320
seeing Netflix saying, "Our scheduled maintenance is coming up on Sunday. We'll be down for five


00:17:05.320 --> 00:17:12.600
hours." Not acceptable, is it? It just makes you laugh to even think about it. Especially not on a


00:17:12.600 --> 00:17:19.240
Sunday. I've even seen government sites, I can't remember which government it was, saying that the


00:17:19.240 --> 00:17:23.880
website was closed, like the website had business hours. That's a different deal. Like, you came at


00:17:23.880 --> 00:17:25.540
Like, oh, he can't come here right now.


00:17:25.540 --> 00:17:26.240
It's like, what?


00:17:26.240 --> 00:17:26.900
It's the web.


00:17:26.900 --> 00:17:28.860
I don't understand what's going on.


00:17:28.860 --> 00:17:32.040
All right, so let's go through this blog post


00:17:32.040 --> 00:17:34.980
that you wrote here entitled just Python at Netflix


00:17:34.980 --> 00:17:37.340
on the Netflix technology blog.


00:17:37.340 --> 00:17:41.220
Yeah, so you wrote this in preparation of PyCon.


00:17:41.220 --> 00:17:43.540
This is PyCon 2023?


00:17:43.540 --> 00:17:45.220
No, this was 2019, actually.


00:17:45.220 --> 00:17:50.460
So this is old by at least two or three years now.


00:17:50.460 --> 00:17:52.100
So yeah.


00:17:52.100 --> 00:17:54.540
- Okay, yeah, you had pointed out before we press record


00:17:54.540 --> 00:17:56.100
that some of these projects mentioned here


00:17:56.100 --> 00:17:59.060
that used to be internal things are now also open source.


00:17:59.060 --> 00:18:01.740
So there's a little more access to these


00:18:01.740 --> 00:18:03.700
than the blog posts might indicate.


00:18:03.700 --> 00:18:05.260
- That's right, yes.


00:18:05.260 --> 00:18:07.660
Yeah, some of the things that are mentioned here, yes,


00:18:07.660 --> 00:18:09.660
they have been open source since then.


00:18:09.660 --> 00:18:11.800
So specifically the one that I remember right now


00:18:11.800 --> 00:18:15.780
is Metaflow, which is a infrastructure,


00:18:15.780 --> 00:18:20.660
it's like a platform orchestration infrastructure framework


00:18:20.660 --> 00:18:24.620
that is used by our machine learning organization


00:18:24.620 --> 00:18:27.780
where scientists would try and build their model


00:18:27.780 --> 00:18:30.420
or they use existing models from like XGBoost


00:18:30.420 --> 00:18:34.760
or like tons of other Python libraries.


00:18:34.760 --> 00:18:38.940
And their interest and their expertise


00:18:38.940 --> 00:18:42.580
lies in crafting those models, training those models


00:18:42.580 --> 00:18:45.360
and building the correct algorithm


00:18:45.360 --> 00:18:47.300
to do the predictions and so on.


00:18:47.300 --> 00:18:49.540
They are not so interested in like,


00:18:49.540 --> 00:18:51.400
making sure that enough compute is available


00:18:51.400 --> 00:18:53.760
to run these models, or they're not interested


00:18:53.760 --> 00:18:55.280
in making sure that the plumbing works


00:18:55.280 --> 00:18:58.000
or this model's data is now going to the next step


00:18:58.000 --> 00:19:01.200
of this algorithm, or even like getting it deployed


00:19:01.200 --> 00:19:03.560
and making it available in the production environment.


00:19:03.560 --> 00:19:08.560
So that's all that abstraction is taken care of by Metaflow.


00:19:08.560 --> 00:19:12.440
So Metaflow is the project that was mentioned here


00:19:12.440 --> 00:19:14.280
and that allows you to make it easy


00:19:14.280 --> 00:19:17.720
for machine learning folks to get their system running


00:19:17.720 --> 00:19:21.240
as well as deploying it out to production.


00:19:21.240 --> 00:19:23.360
And now that is now open sourced


00:19:23.360 --> 00:19:26.440
and it is available for folks to use.


00:19:26.440 --> 00:19:27.920
And I think some other companies have actually


00:19:27.920 --> 00:19:30.320
adopted to using that as well.


00:19:30.320 --> 00:19:36.880
- Operate like a DevOps automation for machine learning.


00:19:36.880 --> 00:19:40.080
So the people they're writing,


00:19:40.080 --> 00:19:41.440
creating the models and the data scientists


00:19:41.440 --> 00:19:43.800
don't have to also be DevOps people.


00:19:43.800 --> 00:19:46.200
- Right, it's slightly more than DevOps as well


00:19:46.200 --> 00:19:48.300
because it also does the pipelining work


00:19:48.300 --> 00:19:50.700
to make it possible for someone to, you know,


00:19:50.700 --> 00:19:55.140
bring the data from this database and load it in.


00:19:55.140 --> 00:19:56.920
All of that work is already taken care of,


00:19:56.920 --> 00:19:59.260
or at least there are libraries that are built into Metaflow


00:19:59.260 --> 00:20:01.140
that makes it possible to bring those in.


00:20:01.140 --> 00:20:03.420
And then it allows you to also do orchestration.


00:20:03.420 --> 00:20:06.340
So for instance, machine learning models typically happen


00:20:06.340 --> 00:20:08.260
in multi steps and multi stages.


00:20:08.260 --> 00:20:10.260
And so the data gets processed by this function,


00:20:10.260 --> 00:20:12.060
and then it gets moved on to this other function,


00:20:12.060 --> 00:20:15.020
and then it gets moved on to this other thing and so forth.


00:20:15.020 --> 00:20:16.680
And so it does the plumbing to make sure


00:20:16.680 --> 00:20:19.420
that the data can flow through this topology


00:20:19.420 --> 00:20:22.780
and actually produce results and so on.


00:20:22.780 --> 00:20:24.700
- Yeah, yeah, you probably have enough data


00:20:24.700 --> 00:20:26.940
that that's a lot of data to move, so.


00:20:26.940 --> 00:20:28.740
(laughing)


00:20:28.740 --> 00:20:30.120
All right, quick question from the audience


00:20:30.120 --> 00:20:31.700
before we dive into the topics here.


00:20:31.700 --> 00:20:33.660
Diego asks, "On such a big platform


00:20:33.660 --> 00:20:35.120
"with so many software engineers


00:20:35.120 --> 00:20:36.440
"with different coding practices,


00:20:36.440 --> 00:20:39.620
"do you all get together and follow some set norms


00:20:39.620 --> 00:20:43.580
"by Netflix or is it more team by team basis?"


00:20:44.900 --> 00:20:46.800
It is very much team by team basis.


00:20:46.800 --> 00:20:50.780
So each team has their style and the areas that they focus on.


00:20:50.780 --> 00:20:53.500
So for instance, like machine learning engineers


00:20:53.500 --> 00:20:56.260
are not going to care too much about like,


00:20:56.260 --> 00:20:58.420
how do I make this like production grade,


00:20:58.420 --> 00:21:03.420
like super heavily fortified or whatever.


00:21:03.420 --> 00:21:05.220
And security engineers might be focusing


00:21:05.220 --> 00:21:07.300
on completely different things.


00:21:07.300 --> 00:21:08.820
So it is different.


00:21:08.820 --> 00:21:10.700
But at the same time, I do want to mention


00:21:10.700 --> 00:21:13.460
that there are certain norms that are common


00:21:13.460 --> 00:21:15.280
across the entire company where, you know,


00:21:15.280 --> 00:21:17.120
so for instance, Chaos Monkey is one of those things


00:21:17.120 --> 00:21:21.200
where since Netflix operates in a way where, you know,


00:21:21.200 --> 00:21:24.260
every team is given the freedom to choose


00:21:24.260 --> 00:21:26.760
and operate the way they see fit,


00:21:26.760 --> 00:21:29.980
there is no edict that can come from a VP or a president


00:21:29.980 --> 00:21:31.800
that says like, you must write code in this way,


00:21:31.800 --> 00:21:33.300
like that doesn't happen.


00:21:33.300 --> 00:21:36.100
And so what that means is how are you going to enforce,


00:21:36.100 --> 00:21:38.320
like, you know, you have to write resilient software


00:21:38.320 --> 00:21:40.780
or how are you going to make sure that your software


00:21:40.780 --> 00:21:42.520
will continue to run if one of the servers


00:21:42.520 --> 00:21:45.120
out of the hundred servers has gone down.


00:21:45.120 --> 00:21:47.360
And so there is not a good way to enforce that.


00:21:47.360 --> 00:21:50.640
And Chaos Monkey was created as a way to enforce that,


00:21:50.640 --> 00:21:53.200
which is, yes, we're not going to be able to tell you


00:21:53.200 --> 00:21:54.160
how to write software,


00:21:54.160 --> 00:21:56.640
but this particular service that exists,


00:21:56.640 --> 00:21:58.500
it's going to go around killing servers.


00:21:58.500 --> 00:22:00.240
And so you better make sure that your software


00:22:00.240 --> 00:22:03.600
is actually resilient to servers going down.


00:22:03.600 --> 00:22:06.880
So that's a way in which we influence people


00:22:06.880 --> 00:22:09.480
to produce the right outcome


00:22:09.480 --> 00:22:11.180
without telling them how to do it.


00:22:12.200 --> 00:22:16.560
- I see, so sort of you agree on a common principle


00:22:16.560 --> 00:22:20.320
of design for failure and design for resiliency


00:22:20.320 --> 00:22:23.240
and then it's up to people how to make that happen.


00:22:23.240 --> 00:22:27.680
- Yes, and also we have the concept of paved paths


00:22:27.680 --> 00:22:30.720
or paved road, which is we have certain libraries


00:22:30.720 --> 00:22:34.080
that are made to operate within our infrastructure.


00:22:34.080 --> 00:22:35.680
So there is an internal discovery tool


00:22:35.680 --> 00:22:37.420
and there is an internal metrics collection tool


00:22:37.420 --> 00:22:40.920
and there is an internal, you know,


00:22:40.920 --> 00:22:43.420
like a failure recovery tool and so forth.


00:22:43.420 --> 00:22:47.880
And these libraries that are provided in these languages,


00:22:47.880 --> 00:22:49.540
they make it really that simple


00:22:49.540 --> 00:22:52.340
to just integrate with these services.


00:22:52.340 --> 00:22:56.180
And so it makes it the obvious choice


00:22:56.180 --> 00:22:57.840
for people to start using those libraries


00:22:57.840 --> 00:23:01.180
rather than, you know, paving their own path, for instance.


00:23:01.180 --> 00:23:04.140
So we try and make it as easy as possible


00:23:04.140 --> 00:23:05.180
to do the right thing.


00:23:05.180 --> 00:23:09.460
And so people generally fall into that paved road solutions


00:23:09.460 --> 00:23:11.260
that we have.


00:23:11.260 --> 00:23:12.180
Excellent.


00:23:12.180 --> 00:23:15.340
And we try to make it also, now especially,


00:23:15.340 --> 00:23:21.820
as a central Python team, to promote good practices.


00:23:21.820 --> 00:23:24.060
Like you should have a pipeline.


00:23:24.060 --> 00:23:25.780
You should choose a release strategy.


00:23:25.780 --> 00:23:29.740
You should have tests.


00:23:29.740 --> 00:23:31.980
And we help.


00:23:31.980 --> 00:23:34.060
If you don't, we can help you set that up


00:23:34.060 --> 00:23:38.060
and choose a good release strategy for you.


00:23:38.060 --> 00:23:42.260
- Excellent, yeah, that's really good.


00:23:42.260 --> 00:23:44.300
So let's dive into this blog post.


00:23:44.300 --> 00:23:45.700
Now it was written by Amjit,


00:23:45.700 --> 00:23:49.580
but Soren, jump in as well as we talk about, please.


00:23:49.580 --> 00:23:54.580
So the first one is related to bandwidth,


00:23:54.580 --> 00:23:57.260
to some way, like delivering the content.


00:23:57.260 --> 00:24:00.100
And there's some interesting articles and stuff.


00:24:00.100 --> 00:24:02.100
It says, "How much of the internet's bandwidth


00:24:02.100 --> 00:24:03.180
"does Netflix use?"


00:24:03.180 --> 00:24:05.300
And I don't know how accurate this is,


00:24:05.300 --> 00:24:07.340
but maybe give us a sense of like,


00:24:07.340 --> 00:24:09.260
you got to have a lot of traffic, right?


00:24:09.260 --> 00:24:12.220
- Yes, so I think when I first joined Netflix,


00:24:12.220 --> 00:24:14.900
I was told that we use about one third


00:24:14.900 --> 00:24:16.820
of all of internet's bandwidth,


00:24:16.820 --> 00:24:18.420
but that was back in 2017.


00:24:18.420 --> 00:24:20.720
So things have changed quite a bit since then.


00:24:20.720 --> 00:24:27.420
But I think that our use of bandwidth


00:24:27.420 --> 00:24:30.480
is slightly interesting in the sense,


00:24:31.540 --> 00:24:33.700
The actual-- when somebody goes to their website


00:24:33.700 --> 00:24:36.180
and they're browsing around, all of that data


00:24:36.180 --> 00:24:38.540
is served directly from AWS servers.


00:24:38.540 --> 00:24:40.820
And so we have servers running in AWS


00:24:40.820 --> 00:24:42.860
that does the search functionality, the thumbs up,


00:24:42.860 --> 00:24:45.020
the thumbs down, the--


00:24:45.020 --> 00:24:48.060
you're selecting something and reading the review


00:24:48.060 --> 00:24:51.260
or looking at related things and whatnot.


00:24:51.260 --> 00:24:53.980
But as soon as they click on the Play button


00:24:53.980 --> 00:24:56.740
on a particular video, the actual video file


00:24:56.740 --> 00:24:59.260
itself is not streaming from AWS.


00:24:59.260 --> 00:25:02.740
But instead, it's coming from a CDN called Open Connect.


00:25:02.740 --> 00:25:08.540
And this is a proprietary thing that we built,


00:25:08.540 --> 00:25:13.140
where we ship these CDNs to various internet exchanges


00:25:13.140 --> 00:25:16.300
that are already filled with the right videos.


00:25:16.300 --> 00:25:20.460
And they get populated with the correct videos


00:25:20.460 --> 00:25:23.380
that are getting released overnight or on a regular


00:25:23.380 --> 00:25:24.860
basis.


00:25:24.860 --> 00:25:27.140
The reason we do that is because we want the videos


00:25:27.140 --> 00:25:30.820
stream from the closest possible place for the end user.


00:25:30.820 --> 00:25:36.060
And so when an end user in Florida clicks on it, it's coming from an internet exchange


00:25:36.060 --> 00:25:37.540
that is located in Florida.


00:25:37.540 --> 00:25:42.020
And that's why you don't see a lot of buffering when videos are playing from Netflix is because


00:25:42.020 --> 00:25:48.140
there's, you know, it's inside their network to a large extent.


00:25:48.140 --> 00:25:51.780
So that's our Open Connect team and that's what they do.


00:25:51.780 --> 00:25:52.780
And yeah.


00:25:52.780 --> 00:25:53.780
Yeah.


00:25:53.780 --> 00:25:55.280
Yeah.


00:25:55.280 --> 00:25:56.440
CDNs are awesome.


00:25:56.440 --> 00:25:58.720
And they really are just-- they're


00:25:58.720 --> 00:26:01.240
kind of a bit of magic performance dust


00:26:01.240 --> 00:26:04.160
you can sprinkle on sites.


00:26:04.160 --> 00:26:09.480
That works for CSS and JavaScript and stuff.


00:26:09.480 --> 00:26:11.320
But when it comes to large content,


00:26:11.320 --> 00:26:13.760
then it makes all the difference.


00:26:13.760 --> 00:26:18.040
So in the blog post you write--


00:26:18.040 --> 00:26:18.760
let's see.


00:26:22.640 --> 00:26:28.340
Yeah, it says various software systems are needed to design, build, and operate the CDN infrastructure,


00:26:28.340 --> 00:26:31.640
and a big part of them are written in Python.


00:26:31.640 --> 00:26:36.140
The network devices that underlie a large portion of it are mostly managed by Python.


00:26:36.140 --> 00:26:42.340
So give us a sense of where Python fits in this OpenConnect CDN that you all run.


00:26:42.340 --> 00:26:47.840
Sure. Yeah, so the CDNs themselves run like high-performance code to stream the video.


00:26:47.840 --> 00:26:50.540
Obviously, that software is not written in Python.


00:26:50.540 --> 00:26:53.660
But all the software that orchestrates and makes sure


00:26:53.660 --> 00:26:55.660
that these CDNs are remaining healthy,


00:26:55.660 --> 00:26:59.340
getting metrics out of them, as well as managing them


00:26:59.340 --> 00:27:02.660
and forecasting what sort of videos


00:27:02.660 --> 00:27:06.700
are going to be going into these CDNs and so forth,


00:27:06.700 --> 00:27:09.420
those are all orchestrated using Python applications.


00:27:09.420 --> 00:27:11.180
So these are all internal tools.


00:27:11.180 --> 00:27:12.620
There's an OC tools team.


00:27:12.620 --> 00:27:15.180
OC stands for the Open Connect, which is the name of the CDN.


00:27:15.180 --> 00:27:17.740
And OC tools team is the one that builds that,


00:27:17.740 --> 00:27:20.060
And they use quite a lot of Python


00:27:20.060 --> 00:27:24.780
for not just tracking our CDNs, but also


00:27:24.780 --> 00:27:29.420
for projecting which videos and what shapes


00:27:29.420 --> 00:27:30.620
they should be going into.


00:27:30.620 --> 00:27:32.540
So for instance, to give you a quick example,


00:27:32.540 --> 00:27:34.620
if we are launching, let's say, Stranger Things,


00:27:34.620 --> 00:27:37.260
like the newest season, we know for a fact


00:27:37.260 --> 00:27:39.580
that these videos are going to be--


00:27:39.580 --> 00:27:42.900
that they're either going to be streamed 90% of the time


00:27:42.900 --> 00:27:45.900
from television, like a 4K definition television,


00:27:45.900 --> 00:27:48.300
or people are going to be watching on their iPhone.


00:27:48.300 --> 00:27:51.940
So all these videos get encoded in different formats,


00:27:51.940 --> 00:27:53.660
like for different resolutions.


00:27:53.660 --> 00:27:56.060
And how much do we put into the CDNs


00:27:56.060 --> 00:27:57.780
and how do we get them prepared?


00:27:57.780 --> 00:27:59.380
Do we need like multiple copies


00:27:59.380 --> 00:28:01.860
so that multiple streams can be read


00:28:01.860 --> 00:28:05.860
without having to have contention and so on?


00:28:05.860 --> 00:28:07.860
So things like those kinds of projections,


00:28:07.860 --> 00:28:11.420
those are all done using Python applications.


00:28:11.420 --> 00:28:14.300
- Yeah, you probably can't put every version


00:28:14.300 --> 00:28:18.900
of every video at every location all the time, right?


00:28:18.900 --> 00:28:19.780
I don't know how much that is,


00:28:19.780 --> 00:28:22.100
but that's a large amount of video content,


00:28:22.100 --> 00:28:23.620
large load of files.


00:28:23.620 --> 00:28:25.700
So you probably gotta predict, right?


00:28:25.700 --> 00:28:28.600
These we can fall back to letting them stream


00:28:28.600 --> 00:28:30.940
from some higher upstream thing,


00:28:30.940 --> 00:28:33.380
but then it'll get cached after it gets viewed a little bit,


00:28:33.380 --> 00:28:35.980
but these were pre-loading, right?


00:28:35.980 --> 00:28:37.100
- Yeah, yeah.


00:28:37.100 --> 00:28:38.980
Actually, Zorin used to work in the team


00:28:38.980 --> 00:28:43.100
that did all the encoding in different shapes and sizes,


00:28:43.100 --> 00:28:44.940
And they use quite a bit of Python as well.


00:28:44.940 --> 00:28:49.340
And he'd be able to tell you more about that stuff.


00:28:49.340 --> 00:28:51.580
Yeah, did you just have a huge office,


00:28:51.580 --> 00:28:53.380
like a whole building full of GPUs,


00:28:53.380 --> 00:28:57.020
and just go in the whole time?


00:28:57.020 --> 00:28:58.100
Encoding is a lot of work.


00:28:58.100 --> 00:28:59.300
Tell us about this.


00:28:59.300 --> 00:29:00.900
Yeah, encoding is a lot of work.


00:29:00.900 --> 00:29:03.100
That was my original start here.


00:29:03.100 --> 00:29:04.580
And we do a lot of Python as well.


00:29:04.580 --> 00:29:06.220
And yeah, we sum it up.


00:29:06.220 --> 00:29:11.300
We kind of try and scour, scavenge as many instances


00:29:11.300 --> 00:29:12.700
that we can put our hands on.


00:29:12.700 --> 00:29:16.700
So if we have any, say, AWS reservations,


00:29:16.700 --> 00:29:20.100
but it so happens that nobody's using right now,


00:29:20.100 --> 00:29:26.100
we come and grab them and spawn our workers dynamically


00:29:26.100 --> 00:29:28.580
and as much as we can.


00:29:28.580 --> 00:29:29.140
Interesting.


00:29:29.140 --> 00:29:32.660
Almost like grid computing, like steady at home?


00:29:32.660 --> 00:29:33.160
Yeah.


00:29:33.160 --> 00:29:33.660
Exactly.


00:29:33.660 --> 00:29:34.500
Like steady at home.


00:29:34.500 --> 00:29:36.380
Yeah.


00:29:36.380 --> 00:29:39.260
And if we do have something like that is high priority,


00:29:39.260 --> 00:29:42.300
well, there's not enough workers laying around,


00:29:42.300 --> 00:29:46.100
then we can go and get some on the spot market,


00:29:46.100 --> 00:29:52.180
or, well, get to grab more reservations if need be.


00:29:52.180 --> 00:29:56.100
So that is the encoding is basically


00:29:56.100 --> 00:30:00.780
take these big master files, right, like these originals,


00:30:00.780 --> 00:30:04.140
and we encode them for every single variation where


00:30:04.140 --> 00:30:06.260
it makes sense, like for this TV, for that phone,


00:30:06.260 --> 00:30:08.620
for Android phone, iOS phone.


00:30:08.620 --> 00:30:15.260
What is the product of all the different resolutions


00:30:15.260 --> 00:30:16.260
and different platforms?


00:30:16.260 --> 00:30:19.100
How many video files do you have to make for--


00:30:19.100 --> 00:30:23.300
how many formats do you have to have for one movie?


00:30:23.300 --> 00:30:27.420
That changes per need.


00:30:27.420 --> 00:30:31.380
And we kind of keep fine tuning how--


00:30:31.380 --> 00:30:37.780
we want the smallest files with the best quality, right?


00:30:37.780 --> 00:30:38.940
So that keeps evolving.


00:30:38.940 --> 00:30:41.260
And sometimes we re-encode the full catalog,


00:30:41.260 --> 00:30:45.420
because now we have a better way of encoding, say,


00:30:45.420 --> 00:30:50.140
anime things versus action movies versus--


00:30:50.140 --> 00:30:50.640
I see.


00:30:50.640 --> 00:30:53.720
You might choose a different encoder for a cartoon-like


00:30:53.720 --> 00:30:59.580
thing versus the planet Earth type of video.


00:30:59.580 --> 00:31:00.580
Yes.


00:31:00.580 --> 00:31:01.660
OK.


00:31:01.660 --> 00:31:03.420
Yeah, and all of this, basically,


00:31:03.420 --> 00:31:07.780
by way of a product of all of this ends up on Open Connect.


00:31:07.780 --> 00:31:09.980
I mean, S3, but also Open Connect.


00:31:09.980 --> 00:31:11.220
- Yeah, yep.


00:31:11.220 --> 00:31:15.820
- And one thing in there that is mentioned on my team,


00:31:15.820 --> 00:31:17.780
very interesting project called D-Math.


00:31:17.780 --> 00:31:20.300
So that is written in Python, it's machine learning.


00:31:20.300 --> 00:31:23.260
And once you have encoded, right?


00:31:23.260 --> 00:31:26.740
Like let's say you're trying a new way of encoding


00:31:26.740 --> 00:31:29.020
to make the files even smaller, right?


00:31:29.020 --> 00:31:32.980
You wanna know during, while you're researching, right?


00:31:32.980 --> 00:31:37.180
you want to know, did you come up with a very good,


00:31:37.180 --> 00:31:38.740
better encoder than before?


00:31:38.740 --> 00:31:41.740
So VMAF is like a little bot that


00:31:41.740 --> 00:31:45.980
will look at the encoded new file


00:31:45.980 --> 00:31:49.260
and give it a human-like score.


00:31:49.260 --> 00:31:53.540
Like, what quality would the human assess this to be?


00:31:53.540 --> 00:31:58.460
And it has to be basically excellent quality,


00:31:58.460 --> 00:32:05.140
get a high score, I think 90 out of 100, roughly, to pass.


00:32:05.140 --> 00:32:08.260
And then this is better, right?


00:32:08.260 --> 00:32:11.380
Like we have a smaller file, but the quality is still excellent.


00:32:11.380 --> 00:32:16.340
Imperceptibly, it's as good as before, but just a file smaller.


00:32:16.340 --> 00:32:20.900
So then we could decide and re-encode the full catalog with that new--


00:32:20.900 --> 00:32:21.400
I see.


00:32:21.400 --> 00:32:22.500
That's really interesting.


00:32:22.500 --> 00:32:24.940
So what you're telling me is you have an AI that you just


00:32:24.940 --> 00:32:27.340
make watch Netflix movies all the time.


00:32:27.340 --> 00:32:28.340
All the time.


00:32:28.340 --> 00:32:30.180
All the time.


00:32:30.180 --> 00:32:33.980
And we have other AIs that watch the whole catalog, for example,


00:32:33.980 --> 00:32:40.340
and find where text appears, say, so that when we put subtitles,


00:32:40.340 --> 00:32:45.940
we can move them up or down to not put text on text.


00:32:45.940 --> 00:32:49.580
And all kinds of metadata, like where can we find landscapes?


00:32:49.580 --> 00:32:51.900
Where does Brad Pitt show up?


00:32:51.900 --> 00:32:54.860
Things like that.


00:32:54.860 --> 00:32:55.460
Incredible.


00:32:55.460 --> 00:32:56.740
I had no idea.


00:32:56.740 --> 00:32:59.540
People are always full of a lot of surprises.


00:32:59.540 --> 00:33:02.580
I think the VMAF software that's written in Python,


00:33:02.580 --> 00:33:04.980
I believe that is open source, right, Zoran?


00:33:04.980 --> 00:33:06.940
It is open source, yes.


00:33:06.940 --> 00:33:10.580
And I think it's one of the Emmy Award winning software.


00:33:10.580 --> 00:33:12.860
I did not know that software could win Emmy awards


00:33:12.860 --> 00:33:13.700
before this one.


00:33:13.700 --> 00:33:20.340
And it apparently won an Emmy award for something.


00:33:20.340 --> 00:33:22.740
Videography or something.


00:33:22.740 --> 00:33:24.420
Probably, yeah.


00:33:24.420 --> 00:33:25.380
Wow.


00:33:25.380 --> 00:33:27.260
That's awesome.


00:33:27.260 --> 00:33:32.020
All right, the next major section is demand engineering.


00:33:32.020 --> 00:33:34.300
This is kind of like DevOps type stuff, right?


00:33:34.300 --> 00:33:37.260
Keeping things running, capacity planning.


00:33:37.260 --> 00:33:41.100
Yes, that is exactly right.


00:33:41.100 --> 00:33:42.980
That was the team that I was in previously.


00:33:42.980 --> 00:33:45.380
And the regional failovers is the one


00:33:45.380 --> 00:33:48.380
where I mentioned where you could transfer traffic


00:33:48.380 --> 00:33:50.700
from one of the AWS regions into the other two regions.


00:33:50.700 --> 00:33:54.100
So we run in three separate AWS regions.


00:33:54.100 --> 00:33:56.840
And any time any of those regions is having a difficulty,


00:33:56.840 --> 00:33:59.180
we can easily move the traffic to the other two regions


00:33:59.180 --> 00:34:01.980
without users even noticing that there was a glitch


00:34:01.980 --> 00:34:06.380
or any kind of issue there.


00:34:06.380 --> 00:34:07.580
- How long does it take?


00:34:07.580 --> 00:34:09.920
If you say you've got to move 50% of the traffic


00:34:09.920 --> 00:34:14.920
out of US East Virginia to somewhere else,


00:34:14.920 --> 00:34:18.300
is that hours, minutes?


00:34:18.300 --> 00:34:21.380
- So the fastest we have done is,


00:34:21.380 --> 00:34:24.180
So on average, it takes about seven minutes


00:34:24.180 --> 00:34:25.620
to do all of that.


00:34:25.620 --> 00:34:26.720
And that was our target.


00:34:26.720 --> 00:34:28.780
So when I first joined, I was given as a target.


00:34:28.780 --> 00:34:30.780
It used to be around 45 minutes at the time.


00:34:30.780 --> 00:34:34.620
And we built some interesting things


00:34:34.620 --> 00:34:36.840
to make it possible to run it inside seven minutes.


00:34:36.840 --> 00:34:39.940
But the fastest we've done is like around five minutes


00:34:39.940 --> 00:34:41.540
in like an emergency where,


00:34:41.540 --> 00:34:43.540
oh God, the entire region is tanked


00:34:43.540 --> 00:34:46.620
and people in the US are not happy about this.


00:34:46.620 --> 00:34:48.380
Let's move as fast as we can


00:34:48.380 --> 00:34:50.380
and we can do it in five minutes.


00:34:51.300 --> 00:34:54.260
Doesn't happen often, but you know when it happens,


00:34:54.260 --> 00:34:57.400
especially when AWS Virginia goes down,


00:34:57.400 --> 00:34:59.980
because a quarter of the internet stops working.


00:34:59.980 --> 00:35:01.220
(laughing)


00:35:01.220 --> 00:35:04.380
- Sure, but it's not just AWS that goes down.


00:35:04.380 --> 00:35:05.940
Sometimes-- - No, no, I know.


00:35:05.940 --> 00:35:08.100
- Sometimes we shoot ourselves in the foot.


00:35:08.100 --> 00:35:13.060
So one of the interesting things to make sure


00:35:13.060 --> 00:35:15.060
that we release software that is safe


00:35:15.060 --> 00:35:18.940
is we do something called regionally staggered releases.


00:35:18.940 --> 00:35:23.340
And so when a new software or when a new version gets released,


00:35:23.340 --> 00:35:26.580
since it's like hundreds of microservices that are running inside of Netflix


00:35:26.580 --> 00:35:29.740
to make it all possible, every service will deploy.


00:35:29.740 --> 00:35:33.180
And when they start to deploy, they deploy it into a single region,


00:35:33.180 --> 00:35:35.540
wait about like five to 10 minutes to make sure that, you know,


00:35:35.540 --> 00:35:37.820
nothing bad has happened, and then they proceed to the next one


00:35:37.820 --> 00:35:39.220
and then the next one.


00:35:39.220 --> 00:35:44.220
And so when they release it to the first region, they can either,


00:35:44.220 --> 00:35:46.740
if they find out that it's bad,


00:35:46.740 --> 00:35:49.140
they can either quickly roll it back,


00:35:49.140 --> 00:35:51.340
or we could just evacuate out of that region,


00:35:51.340 --> 00:35:53.740
because we can do that in under seven minutes.


00:35:53.740 --> 00:35:56.280
And so if the rollback takes longer than seven minutes,


00:35:56.280 --> 00:35:58.700
then a call will be made by the core team,


00:35:58.700 --> 00:36:00.460
which will say, "Let's evacuate out.


00:36:00.460 --> 00:36:02.580
"We haven't figured out what the problem is."


00:36:02.580 --> 00:36:05.820
So, and then we evacuate, and then we'll debug,


00:36:05.820 --> 00:36:08.100
oh, which service did I release,


00:36:08.100 --> 00:36:10.460
and what do we need to roll back, and so on.


00:36:10.460 --> 00:36:12.940
Because there are hundreds of services


00:36:12.940 --> 00:36:14.780
that are simultaneously releasing at the same time.


00:36:14.780 --> 00:36:16.660
So it's like quickly trying to identify


00:36:16.660 --> 00:36:18.260
which service that we need to roll back


00:36:18.260 --> 00:36:19.580
can sometimes be tricky.


00:36:19.580 --> 00:36:22.700
So we have used failovers for that as well.


00:36:22.700 --> 00:36:24.900
So it's not just AWS's fault.


00:36:24.900 --> 00:36:25.860
- Yeah, sure.


00:36:25.860 --> 00:36:27.780
And I don't mean to pick on AWS


00:36:27.780 --> 00:36:30.180
because all of these data centers go down.


00:36:30.180 --> 00:36:33.420
The difference is when AWS goes down,


00:36:33.420 --> 00:36:34.740
it's like the internet goes down.


00:36:34.740 --> 00:36:38.100
You know, it's like the observability of it is so high


00:36:38.100 --> 00:36:40.340
'cause so much runs on there.


00:36:40.340 --> 00:36:41.740
It's like that in CloudFlare.


00:36:41.740 --> 00:36:42.700
When they go down to you, you're like,


00:36:42.700 --> 00:36:43.820
Oh, I see everything's broken.


00:36:43.820 --> 00:36:45.940
OK.


00:36:45.940 --> 00:36:48.940
Yeah, when sites go down in production,


00:36:48.940 --> 00:36:53.580
even for places way smaller than Netflix, it's really stressful.


00:36:53.580 --> 00:36:57.660
And you might make it worse by trying to fix it.


00:36:57.660 --> 00:36:59.860
So the ability to just go, let's buy ourselves


00:36:59.860 --> 00:37:01.220
some time to figure this out.


00:37:01.220 --> 00:37:02.460
And just get everyone out.


00:37:02.460 --> 00:37:03.420
And then we're going to look at it.


00:37:03.420 --> 00:37:04.760
And then we can bring them back.


00:37:04.760 --> 00:37:05.780
That's pretty cool.


00:37:05.780 --> 00:37:08.620
You did write an article called "How Netflix Does Failovers


00:37:08.620 --> 00:37:10.980
in Seven Minutes Flat," which I'll put in the show notes


00:37:10.980 --> 00:37:13.340
so people can read more about that if they want.


00:37:13.340 --> 00:37:20.620
So this demand engineering side, you talk about,


00:37:20.620 --> 00:37:25.460
obviously, tools are primarily built in Python there.


00:37:25.460 --> 00:37:29.860
You've got some NumPy and SciPy, and even the bPython shell.


00:37:29.860 --> 00:37:32.260
Tell us about some of the Python stuff going on here.


00:37:32.260 --> 00:37:35.440
- So before I joined Netflix,


00:37:35.440 --> 00:37:39.020
when I actually first started learning Python,


00:37:39.020 --> 00:37:41.960
I loved the REPL, but I always felt like the REPL


00:37:41.960 --> 00:37:43.360
did not have auto-completion in it.


00:37:43.360 --> 00:37:46.740
And that like bPython is a alternate REPL for Python


00:37:46.740 --> 00:37:49.820
that provides you with like auto-completion


00:37:49.820 --> 00:37:51.600
and syntax highlighting and all that stuff.


00:37:51.600 --> 00:37:54.480
So I'm a huge fan of bPython.


00:37:54.480 --> 00:37:58.420
And so one of the things that we have done,


00:37:58.420 --> 00:38:01.080
like demand engineering specifically is, you know,


00:38:01.080 --> 00:38:04.460
we get paged and we have to go in and try and rescue


00:38:05.680 --> 00:38:09.320
or traffic out of that region into the other two regions.


00:38:09.320 --> 00:38:12.800
And sometimes our software itself will not work


00:38:12.800 --> 00:38:14.820
because if an entire region is down,


00:38:14.820 --> 00:38:16.600
let's say it's because of a network connectivity issue


00:38:16.600 --> 00:38:20.600
or something, then the things that we call out to


00:38:20.600 --> 00:38:24.520
in order to make these changes to scale up the other regions


00:38:24.520 --> 00:38:27.660
and like evacuate and make DNS changes or whatever,


00:38:27.660 --> 00:38:28.760
that itself might be broken.


00:38:28.760 --> 00:38:32.240
And when that's broken, like literally SSH into the box


00:38:32.240 --> 00:38:36.060
and we will open up like a shell, Python shell,


00:38:36.060 --> 00:38:38.720
and do whatever we need to do.


00:38:38.720 --> 00:38:41.320
That has not happened in like the last four years,


00:38:41.320 --> 00:38:43.960
I would say, but you know, six years ago,


00:38:43.960 --> 00:38:47.000
yeah, that was the thing that we used to do.


00:38:47.000 --> 00:38:48.840
And I wanted to call out bPython specifically


00:38:48.840 --> 00:38:50.240
in this particular case,


00:38:50.240 --> 00:38:53.900
because it was so much more useful than trying to remember,


00:38:53.900 --> 00:38:56.040
oh, I remember I wrote this function, like what is it?


00:38:56.040 --> 00:38:57.600
Like, instead of like opening my IDE


00:38:57.600 --> 00:38:59.000
to try to find out what that function is,


00:38:59.000 --> 00:39:00.200
like I just import the module,


00:39:00.200 --> 00:39:01.480
and then I do the module.


00:39:01.480 --> 00:39:03.640
And it lists me all the functions.


00:39:03.640 --> 00:39:04.960
And I could invoke it.


00:39:04.960 --> 00:39:08.120
And it's such a time saver.


00:39:08.120 --> 00:39:09.800
- Yeah, the Python REPL is cool,


00:39:09.800 --> 00:39:14.800
but it leaves a lot to be desired in terms of history.


00:39:14.800 --> 00:39:17.360
Or even if you want to edit a function


00:39:17.360 --> 00:39:22.360
that is five lines long, it's hard to get through.


00:39:22.360 --> 00:39:27.640
Another one is PT Python that I'm also a fan of that one.


00:39:27.640 --> 00:39:30.320
They're kind of the same category, right?


00:39:30.320 --> 00:39:32.920
- Yeah, yeah, Prompt Toolkit,


00:39:32.920 --> 00:39:35.560
the one that powered PT Python,


00:39:35.560 --> 00:39:37.200
written by Jonathan Slenders actually,


00:39:37.200 --> 00:39:40.400
and it's like a fantastic library.


00:39:40.400 --> 00:39:43.920
I took kudos to Jonathan for doing that.


00:39:43.920 --> 00:39:45.720
It's a fantastic library.


00:39:45.720 --> 00:39:47.240
- Yeah, awesome.


00:39:47.240 --> 00:39:52.240
So, you got a particular enhancement there for your REPL?


00:39:52.240 --> 00:39:57.160
- Sorry, say that one more time.


00:39:57.160 --> 00:39:59.920
I was asking Soren if he's got a--


00:39:59.920 --> 00:40:00.920
you use either of those.


00:40:00.920 --> 00:40:02.420
You got any recommendation for one


00:40:02.420 --> 00:40:06.320
of these extended Python REPLs?


00:40:06.320 --> 00:40:14.520
So I'm not that big of a user of REPLs in the terminal.


00:40:14.520 --> 00:40:18.120
We do ask questions for generating new projects,


00:40:18.120 --> 00:40:18.640
et cetera.


00:40:18.640 --> 00:40:21.040
I'm much more of a PyCharm user myself.


00:40:21.040 --> 00:40:24.600
Well, as you bring that up, one of the really nice Python


00:40:24.600 --> 00:40:27.400
Ripples is what I guess it's called probably the Python


00:40:27.400 --> 00:40:30.600
console in PyCharm.


00:40:30.600 --> 00:40:32.800
Because if you go to that, you get the Python ripple,


00:40:32.800 --> 00:40:35.960
but you get PyCharm's autocomplete and type


00:40:35.960 --> 00:40:38.760
consistency, and it automatically


00:40:38.760 --> 00:40:40.560
modifies the path to import your project.


00:40:40.560 --> 00:40:44.360
So yeah, you got one in there.


00:40:44.360 --> 00:40:45.800
That one's yours, huh?


00:40:45.800 --> 00:40:51.320
Let's see, the core team, alerting and statistical work.


00:40:51.320 --> 00:40:53.240
What's this one about?


00:40:53.240 --> 00:40:55.080
Core team is our frontline SRE.


00:40:55.080 --> 00:40:58.240
So demand team is like building tools


00:40:58.240 --> 00:41:01.260
that the core team will leverage to get us out of trouble.


00:41:01.260 --> 00:41:02.800
So core team is the one that,


00:41:02.800 --> 00:41:06.280
anytime there is like they monitor a lot of metrics,


00:41:06.280 --> 00:41:07.720
not just streaming metrics,


00:41:07.720 --> 00:41:09.960
but also things like error rates


00:41:09.960 --> 00:41:11.600
between services that are happening


00:41:11.600 --> 00:41:16.040
and how many requests are successfully coming back


00:41:16.040 --> 00:41:17.640
and so forth.


00:41:17.640 --> 00:41:21.360
So they obviously use Python to kind of keep tabs on,


00:41:21.360 --> 00:41:24.000
Like obviously a person can be sitting in front of a dashboard


00:41:24.000 --> 00:41:26.480
just monitoring it themselves.


00:41:26.480 --> 00:41:28.400
So they use quite a bit of Python


00:41:28.400 --> 00:41:32.200
to analyze the data from all of the hundreds of microservices


00:41:32.200 --> 00:41:34.400
in between them, the interprocess communication that


00:41:34.400 --> 00:41:36.560
actually happens, and the metrics that come through,


00:41:36.560 --> 00:41:37.600
and so forth.


00:41:37.600 --> 00:41:39.920
So they use Python for alerting.


00:41:39.920 --> 00:41:42.920
And so actually, they use the monitoring--


00:41:42.920 --> 00:41:45.200
the next section that's right there


00:41:45.200 --> 00:41:47.960
is the monitoring, alerting, and auto-remediation.


00:41:47.960 --> 00:41:51.120
We have an internal observability organization


00:41:51.120 --> 00:41:55.040
that has built our own time series database


00:41:55.040 --> 00:42:00.040
that's not in Python, but it's open source called Atlas.


00:42:00.040 --> 00:42:05.040
And that uses, that collects all of the time series data


00:42:05.040 --> 00:42:06.560
from all of these services,


00:42:06.560 --> 00:42:10.720
and then they try and do alerting and remediation,


00:42:10.720 --> 00:42:11.560
auto remediation.


00:42:11.560 --> 00:42:14.000
So when a particular alert condition is met,


00:42:14.000 --> 00:42:17.640
you can run a small Python script


00:42:17.640 --> 00:42:20.520
inside of a framework called Winston


00:42:20.520 --> 00:42:22.320
that's again internal, that


00:42:22.320 --> 00:42:24.000
allows you to do more complicated things.


00:42:24.000 --> 00:42:27.000
So for instance, if you have this one bad instance in


00:42:27.000 --> 00:42:31.000
like this collection of 20 instances,


00:42:31.000 --> 00:42:34.040
instead of a user going and terminating that instance,


00:42:34.040 --> 00:42:36.960
you can now automate that by writing a script that says,


00:42:36.960 --> 00:42:42.320
automatically restart that instance or just kill it and so on.


00:42:42.320 --> 00:42:46.080
>> Cool. That's part of the auto remediation of it.


00:42:46.080 --> 00:42:48.360
It says it's built on G Unicorn,


00:42:48.360 --> 00:42:51.520
Flask and Flask Rest Plus.


00:42:51.520 --> 00:42:53.640
I'm familiar with the first batch,


00:42:53.640 --> 00:42:55.540
but the Flask Rest Plus,


00:42:55.540 --> 00:42:58.040
this is an extension for Flask that adds


00:42:58.040 --> 00:43:00.400
support for quickly building REST APIs.


00:43:00.400 --> 00:43:01.880
Okay, interesting.


00:43:01.880 --> 00:43:04.320
>> Because Flask itself already does REST.


00:43:04.320 --> 00:43:06.260
So REST Plus I think provides things


00:43:06.260 --> 00:43:08.760
like Swagger endpoints automatically,


00:43:08.760 --> 00:43:12.320
so you could try it out on the browser and so on.


00:43:12.320 --> 00:43:15.360
I have not used Flask Rest Plus myself,


00:43:15.360 --> 00:43:17.580
but that team uses it quite a bit.


00:43:17.580 --> 00:43:25.180
Yeah, cool. Probably some of the some similarities to like what FastAPI kind of brings in addition to standard flask I'd imagine.


00:43:25.180 --> 00:43:26.180
Exactly, yeah.


00:43:26.180 --> 00:43:30.680
Do you use more FastAPI nowadays?


00:43:30.680 --> 00:43:31.480
Yes.


00:43:31.480 --> 00:43:31.980
Oh, yeah?


00:43:31.980 --> 00:43:36.680
Yeah, we're using quite a bit of FastAPI in most of our internal tools actually.


00:43:36.680 --> 00:43:44.880
Yeah, it just from reading through this article, it sounds like there's a lot of APIs and just a lot of connectivity through.


00:43:45.380 --> 00:43:47.720
There's probably a lot of JSON going around.


00:43:47.720 --> 00:43:49.000
Yes.


00:43:49.000 --> 00:43:53.320
Yeah, so some of the heavier data stuff


00:43:53.320 --> 00:43:58.700
or high streaming services that are in the streaming path


00:43:58.700 --> 00:44:00.680
are all typically written in Java.


00:44:00.680 --> 00:44:02.420
And for enterprise communication,


00:44:02.420 --> 00:44:06.160
they use gRPC, and that uses protobuf to communicate


00:44:06.160 --> 00:44:06.760
and so forth.


00:44:06.760 --> 00:44:11.080
But most of our internal tools that are written in Python


00:44:11.080 --> 00:44:14.040
either use JSON directly, or sometimes they


00:44:14.040 --> 00:44:15.900
need to talk to a gRPC service.


00:44:15.900 --> 00:44:20.940
And so they use Python gRPC to get the work done.


00:44:20.940 --> 00:44:22.080
Cool.


00:44:22.080 --> 00:44:24.460
Maybe we'll have some time to come back to gRPC.


00:44:24.460 --> 00:44:25.500
I'm not sure.


00:44:25.500 --> 00:44:27.340
We've got a lot of things to talk about here.


00:44:27.340 --> 00:44:30.340
Yeah, we don't have to go through every section here.


00:44:30.340 --> 00:44:31.140
No, I know.


00:44:31.140 --> 00:44:33.340
There's just so many interesting angles, right?


00:44:33.340 --> 00:44:37.560
And so the next one here is information security,


00:44:37.560 --> 00:44:40.500
which obviously--


00:44:40.500 --> 00:44:42.300
if you just put anything on the internet


00:44:42.300 --> 00:44:45.780
and just tail the log of it within minutes.


00:44:45.780 --> 00:44:49.180
You'll see a request for wpadmin.php.


00:44:49.180 --> 00:44:52.140
Like it's already just constantly being,


00:44:52.140 --> 00:44:55.660
people are just after it, right?


00:44:55.660 --> 00:44:57.040
- Yep, yep.


00:44:57.040 --> 00:44:59.060
- One of the things you have here that looks interesting


00:44:59.060 --> 00:45:02.060
is security monkey written in Python,


00:45:02.060 --> 00:45:05.260
which is I guess like chaos monkey, but.


00:45:05.260 --> 00:45:07.300
- It is kind of like chaos monkey.


00:45:07.300 --> 00:45:09.860
I think this project may have been archived


00:45:09.860 --> 00:45:13.900
or it's not actively in development,


00:45:13.900 --> 00:45:17.840
it tries to scan our infrastructure for unsafe practices.


00:45:17.840 --> 00:45:20.540
That's like an umbrella term to try to add


00:45:20.540 --> 00:45:23.560
like whatever is like good practices


00:45:23.560 --> 00:45:27.080
that should exist from the security standpoint.


00:45:27.080 --> 00:45:30.100
- Yeah, okay, so people can check it out.


00:45:30.100 --> 00:45:32.080
Maybe it's not totally active anymore,


00:45:32.080 --> 00:45:34.240
but they can take it as inspiration, right?


00:45:34.240 --> 00:45:36.040
- Yeah, like back in 2019,


00:45:36.040 --> 00:45:37.800
it was one of our most active projects,


00:45:37.800 --> 00:45:42.120
But apparently, 2023 is a different world.


00:45:42.120 --> 00:45:43.400
It is a different world.


00:45:43.400 --> 00:45:46.720
And one of the areas in which 2023 is a different world


00:45:46.720 --> 00:45:50.440
is really the AI/ML side.


00:45:50.440 --> 00:45:52.640
And you all are doing a lot of stuff


00:45:52.640 --> 00:45:56.320
with personalization algorithms, recommendation engines,


00:45:56.320 --> 00:45:57.200
machine learning.


00:45:57.200 --> 00:46:00.640
And you talked about Metaflow, which is now available.


00:46:00.640 --> 00:46:02.560
Yeah.


00:46:02.560 --> 00:46:04.200
Yeah.


00:46:04.200 --> 00:46:05.920
Yeah, the personalization one, I think


00:46:05.920 --> 00:46:08.020
we've just mentioned a bunch of things


00:46:08.020 --> 00:46:09.680
that we use from the open source world here.


00:46:09.680 --> 00:46:14.060
So I think XGBoost is a library that does machine learning.


00:46:14.060 --> 00:46:17.080
So personally, I am not in this field.


00:46:17.080 --> 00:46:19.000
So I just went and interviewed the team


00:46:19.000 --> 00:46:21.480
and asked them to give me a blurb.


00:46:21.480 --> 00:46:24.240
So I wouldn't be able to talk in detail


00:46:24.240 --> 00:46:26.480
about any of the personalization stuff here,


00:46:26.480 --> 00:46:29.260
but yeah, this is just a showcase


00:46:29.260 --> 00:46:33.860
of how much this team relies on Python


00:46:33.860 --> 00:46:35.560
and the open source ecosystem


00:46:35.560 --> 00:46:38.260
that comes with Python in general.


00:46:38.260 --> 00:46:40.700
So it's like heavy users of Panda,


00:46:40.700 --> 00:46:45.020
TensorFlow and PyTorch and so on, yeah.


00:46:45.020 --> 00:46:46.000
- Cool.


00:46:46.000 --> 00:46:48.340
So let me ask you, is it,


00:46:48.340 --> 00:46:54.180
both of your team supports Python developers


00:46:54.180 --> 00:46:57.460
and Python applications indirectly in that way,


00:46:57.460 --> 00:47:00.740
but is it different to support the data scientists


00:47:00.740 --> 00:47:03.260
than it is to support say software developers?


00:47:03.260 --> 00:47:06.020
Like, do you have to think about that differently?


00:47:06.020 --> 00:47:06.860
How so?


00:47:06.860 --> 00:47:09.580
- Yes, yes, we do have like a team that is dedicated


00:47:09.580 --> 00:47:11.340
to supporting all the data scientists.


00:47:11.340 --> 00:47:12.980
And we are like a team that supports a team


00:47:12.980 --> 00:47:14.620
who supports the data scientists.


00:47:14.620 --> 00:47:17.280
(both laughing)


00:47:17.280 --> 00:47:22.280
So yeah, we were definitely like now in 2023,


00:47:22.280 --> 00:47:25.500
you know, betting more on Python.


00:47:25.500 --> 00:47:29.620
Before Python was more, if it makes sense for you


00:47:29.620 --> 00:47:31.620
because of freedom and responsibility,


00:47:31.620 --> 00:47:35.540
If it makes sense to use Python in your team, you use Python.


00:47:35.540 --> 00:47:37.300
And now we're trying to provide basically


00:47:37.300 --> 00:47:38.700
like a better paved path.


00:47:38.700 --> 00:47:43.500
This is me and MG with this new team that we started.


00:47:43.500 --> 00:47:46.220
We're trying to kind of enhance this paved path better


00:47:46.220 --> 00:47:48.700
and better for all of these teams.


00:47:48.700 --> 00:47:53.060
And it's hard to know all the specifics


00:47:53.060 --> 00:47:55.620
in every single team, but we're trying


00:47:55.620 --> 00:47:58.460
to provide them with as good practices


00:47:58.460 --> 00:48:00.260
and automation as possible.


00:48:00.260 --> 00:48:07.060
So I think you asked, like, how is it different supporting one versus the other?


00:48:07.060 --> 00:48:09.060
I think the...


00:48:09.060 --> 00:48:10.460
So we built...


00:48:10.460 --> 00:48:14.860
So when we first started the team, we met with 10 different organizations inside of


00:48:14.860 --> 00:48:17.420
Netflix to find out, like, how they use Python.


00:48:17.420 --> 00:48:23.660
And we found that there were some commonalities, but the way, for instance, like, algorithms


00:48:23.660 --> 00:48:28.380
engineering uses Python is very different from the way a SRE team uses Python.


00:48:28.380 --> 00:48:32.940
And it's very, very different from how our animation studio uses Python.


00:48:32.940 --> 00:48:39.300
So like our VFX animation uses Python in a way where they, once they start, like this


00:48:39.300 --> 00:48:44.820
is apparently common in all of the movie industry, which is once they start a particular project,


00:48:44.820 --> 00:48:48.260
whatever they have chosen at the start of that project, they will stick to it until


00:48:48.260 --> 00:48:49.520
that project is completed.


00:48:49.520 --> 00:48:54.080
So if that movie takes two years to finish, you cannot upgrade anything inside of that


00:48:54.080 --> 00:48:58.200
particular hermetically sealed environment,


00:48:58.200 --> 00:48:59.860
development environment that you have.


00:48:59.860 --> 00:49:01.720
So that is very different from another,


00:49:01.720 --> 00:49:04.560
like a machine learning person who's interested in like,


00:49:04.560 --> 00:49:06.480
I just want to write my algorithm.


00:49:06.480 --> 00:49:08.720
Like I don't care about how pip works


00:49:08.720 --> 00:49:10.720
or like how I pip install.


00:49:10.720 --> 00:49:12.760
I don't want to worry about like virtual environments


00:49:12.760 --> 00:49:14.020
and things like that.


00:49:14.020 --> 00:49:15.800
Whereas a person who's writing internal tools,


00:49:15.800 --> 00:49:18.760
they want to like, you know, own the entire tool chain.


00:49:18.760 --> 00:49:22.000
It's like, I not only want to maintain virtual environment,


00:49:22.000 --> 00:49:24.680
I also want this thing to work with a front end


00:49:24.680 --> 00:49:26.200
that is written in React.


00:49:26.200 --> 00:49:28.680
And so I would like you to be able to make it possible


00:49:28.680 --> 00:49:33.240
to do NPM and pip to coexist and live together.


00:49:33.240 --> 00:49:34.760
That's not a hard thing to do,


00:49:34.760 --> 00:49:37.120
but it's one of those things where it's like,


00:49:37.120 --> 00:49:38.840
if I'm trying to solve a problem,


00:49:38.840 --> 00:49:41.880
let's say I'm bringing in Python dependency locking


00:49:41.880 --> 00:49:44.920
as a mechanism to help these web developers, right?


00:49:44.920 --> 00:49:47.840
Because they don't want to automatically upgrade


00:49:47.840 --> 00:49:49.340
anytime they build their system


00:49:49.340 --> 00:49:51.720
and suddenly break in production.


00:49:51.720 --> 00:49:55.300
Now that might be completely useless


00:49:55.300 --> 00:49:57.360
for someone who's working in machine learning.


00:49:57.360 --> 00:50:00.400
And so they're like, why are you solving that problem?


00:50:00.400 --> 00:50:03.240
You bringing locking to packaging


00:50:03.240 --> 00:50:04.520
doesn't help me in any way.


00:50:04.520 --> 00:50:05.520
Why are you wasting your time?


00:50:05.520 --> 00:50:08.400
And so we had to sort of build personas


00:50:08.400 --> 00:50:11.860
for various ways in which Python is used inside of Netflix


00:50:11.860 --> 00:50:13.960
so that when we are working on a particular feature,


00:50:13.960 --> 00:50:16.560
we can tell them, we are now targeting this persona.


00:50:16.560 --> 00:50:18.880
We are working towards making life easy


00:50:18.880 --> 00:50:20.360
for animation engineers.


00:50:20.360 --> 00:50:22.880
So if it doesn't work for you, that's fine.


00:50:22.880 --> 00:50:23.720
That's fine.


00:50:23.720 --> 00:50:24.540
We will get to you.


00:50:24.540 --> 00:50:26.600
It's just that our persona that we're targeting right now


00:50:26.600 --> 00:50:27.760
is not yours.


00:50:27.760 --> 00:50:30.180
So that's how it's different, I'd say.


00:50:30.180 --> 00:50:36.300
- Yeah, data scientists have a lot less legacy code


00:50:36.300 --> 00:50:37.800
that's just still cranking along


00:50:37.800 --> 00:50:39.800
because a lot of times once they get,


00:50:39.800 --> 00:50:40.840
they discover an insight,


00:50:40.840 --> 00:50:42.420
they don't need to run it again, right?


00:50:42.420 --> 00:50:44.320
Or the algorithms are changing so fast,


00:50:44.320 --> 00:50:48.160
they can just, well, now we're using large language models


00:50:48.160 --> 00:50:50.600
instead of whatever.


00:50:50.600 --> 00:50:52.200
- Yeah, there you go, yeah.


00:50:52.200 --> 00:50:53.760
- Yeah.


00:50:53.760 --> 00:50:56.080
Whereas once you get a web app running,


00:50:56.080 --> 00:50:57.400
you might not touch that thing


00:50:57.400 --> 00:50:58.640
if it doesn't need touching, right?


00:50:58.640 --> 00:51:00.040
So you just-- - Exactly, yeah.


00:51:00.040 --> 00:51:02.280
- Stability is what you need there.


00:51:02.280 --> 00:51:06.080
Cool, all right, maybe a quick bit more.


00:51:06.080 --> 00:51:13.040
Yeah, it's, Soren, anything else you wanna call out


00:51:13.040 --> 00:51:16.160
out of this article before we move on?


00:51:16.160 --> 00:51:17.920
We're running out of time, honestly,


00:51:17.920 --> 00:51:28.420
Yeah, but no, no, I think this was a great article, but yeah, a few things.


00:51:28.420 --> 00:51:32.300
With regard to this, let's just leave people with this idea that we only touched on a small


00:51:32.300 --> 00:51:37.060
part of what is laid out here and all the projects and all the ways in which it's being


00:51:37.060 --> 00:51:38.060
used.


00:51:38.060 --> 00:51:42.020
So certainly check out the article just called Python at Netflix that I'll put in the show


00:51:42.020 --> 00:51:43.020
notes.


00:51:43.020 --> 00:51:46.700
It's hard to cover it all in just one hour.


00:51:46.700 --> 00:51:48.660
It sure is.


00:51:48.660 --> 00:51:52.820
So let's maybe talk for a minute here about this project


00:51:52.820 --> 00:51:54.740
that you're involved with, Soren.


00:51:54.740 --> 00:51:57.020
Not this one.


00:51:57.020 --> 00:51:57.540
This one.


00:51:57.540 --> 00:52:03.460
And I'm just too called Portable Python.


00:52:03.460 --> 00:52:06.300
I not long ago had Nathaniel Smith


00:52:06.300 --> 00:52:09.900
on to talk about PEP 711, distributing Python binaries


00:52:09.900 --> 00:52:15.780
and maybe treating CPython runtimes as wheels almost.


00:52:15.780 --> 00:52:19.900
And you guys also have a way that you've been using


00:52:19.900 --> 00:52:22.400
for a while internally to package up Python


00:52:22.400 --> 00:52:23.860
into something that can run as well


00:52:23.860 --> 00:52:25.700
called Portable Python, which is open source.


00:52:25.700 --> 00:52:27.500
You wanna talk a bit about that?


00:52:27.500 --> 00:52:28.820
- Yes.


00:52:28.820 --> 00:52:32.420
Yeah, so that is indeed the PEP 711.


00:52:32.420 --> 00:52:34.880
I discovered it by listening to your podcast.


00:52:34.880 --> 00:52:38.460
Right around PyCon, I think, yes.


00:52:38.460 --> 00:52:39.980
It would be very interesting to see


00:52:39.980 --> 00:52:44.280
if we could partner up once this is.


00:52:44.280 --> 00:52:49.280
So portable Python is, we want to provide Python,


00:52:49.280 --> 00:52:52.360
of course, to all Python developers inside, right?


00:52:52.360 --> 00:52:56.000
You can always grab your own Python via all kinds of ways,


00:52:56.000 --> 00:52:58.560
right, PyEnv, Docker image, et cetera,


00:52:58.560 --> 00:53:03.480
but we also provide builds, right, of Python inside


00:53:03.480 --> 00:53:05.960
to be used internally.


00:53:05.960 --> 00:53:09.080
So portable Python is trying to solve, adjust that.


00:53:09.080 --> 00:53:11.000
Well, one particular issue,


00:53:11.000 --> 00:53:15.600
how do you go and distribute Python on laptops?


00:53:15.600 --> 00:53:20.240
So the end goal is we want to provide a tarball, just


00:53:20.240 --> 00:53:25.360
like that Pep says, like a wheel, a tarball that you can


00:53:25.360 --> 00:53:30.240
download and drop somewhere, typically in a user's own


00:53:30.240 --> 00:53:34.800
folder, tilde slash, myPythons.


00:53:34.800 --> 00:53:37.080
And we wanted to work from there.


00:53:37.080 --> 00:53:40.800
So you could use PyEnv for that, but with PyEnv,


00:53:40.800 --> 00:53:42.800
you need to wait for it to build.


00:53:42.800 --> 00:53:45.720
And we want to basically build it ahead of time


00:53:45.720 --> 00:53:47.380
and as soon as it's available


00:53:47.380 --> 00:53:50.200
and make it available internally.


00:53:50.200 --> 00:53:52.280
So what Portable Python is designed to do


00:53:52.280 --> 00:53:54.200
is to do such a build,


00:53:54.200 --> 00:53:55.600
which we call portable,


00:53:55.600 --> 00:53:59.600
and drop it in our factory.


00:53:59.600 --> 00:54:02.440
And then our tooling can just go fetch that real quick,


00:54:02.440 --> 00:54:04.440
unzip, and it's ready to go.


00:54:04.440 --> 00:54:09.440
- So your tooling, the Portable Python tooling,


00:54:09.440 --> 00:54:12.200
basically says I'm on this platform,


00:54:12.200 --> 00:54:15.200
so I'm on macOS and it's Apple Silicon.


00:54:15.200 --> 00:54:18.120
So here's the, and they want this version of Python.


00:54:18.120 --> 00:54:21.640
So that means this binary, let's go grab it.


00:54:21.640 --> 00:54:23.040
- Right, right.


00:54:23.040 --> 00:54:26.720
So Portable Python is invoked by our building machinery.


00:54:26.720 --> 00:54:31.720
There's one worker on macOS, X86, macOS M1,


00:54:31.720 --> 00:54:37.760
Linux, X86, Linux, ARM64, right?


00:54:38.440 --> 00:54:44.600
and there's some external internal tooling that kind of detects that the new open source


00:54:44.600 --> 00:54:50.760
version is available using Portable Python. So Portable Python can report you what is the latest


00:54:50.760 --> 00:54:58.360
3.11 for example by looking at the ftp.python.org basically. Okay so the latest is 3.11.3. Let's see


00:54:58.360 --> 00:55:03.880
do we have it internally? No. Okay let's kick off a build. So we kick off one build for M1,


00:55:03.880 --> 00:55:10.840
one built for Linux, etc. And we, with portable Python, with its configuration, we say we want


00:55:10.840 --> 00:55:16.680
OpenSSL, that version, we want SQLite, that version, and portable Python goes ahead and


00:55:16.680 --> 00:55:20.680
does the build, produces a tarball, we take that tarball and publish it.


00:55:20.680 --> 00:55:25.480
That's interesting. So you can control a little bit some of the internals as well,


00:55:25.480 --> 00:55:29.400
like the OpenSSL version and SQLite version, maybe a bit more carefully?


00:55:30.120 --> 00:55:39.960
Yes. And since it's written in Python, it's able to also inspect, say, any Python. You could run


00:55:39.960 --> 00:55:45.400
portable Python, inspect path to this installation, and it will tell you, "Okay, it has a CSL,


00:55:45.400 --> 00:55:55.080
that version, SQLite, that version. Does it use Homebrew, shared libraries, or what?" It can


00:55:55.080 --> 00:55:56.960
and report on that.


00:55:56.960 --> 00:56:02.840
And what it can also,


00:56:02.840 --> 00:56:06.480
oh yeah, it generates a thing that I find very important,


00:56:06.480 --> 00:56:08.640
like a little file that says,


00:56:08.640 --> 00:56:10.360
it's called manifest.yaml.


00:56:10.360 --> 00:56:12.560
So every time it builds anything,


00:56:12.560 --> 00:56:15.080
it generates a lot that manifest.yaml


00:56:15.080 --> 00:56:18.800
where it says, well, I did a build with dash dash,


00:56:18.800 --> 00:56:21.500
you know, LTO optimization, dash dash,


00:56:21.500 --> 00:56:24.040
like it says everything that was used


00:56:24.040 --> 00:56:28.520
to inform what the build had and which worker it ran on,


00:56:28.520 --> 00:56:31.120
what time, what was the platform,


00:56:31.120 --> 00:56:33.360
like a little bit of metadata which sometimes--


00:56:33.360 --> 00:56:36.200
- So you could even see things like what C compiler


00:56:36.200 --> 00:56:39.000
optimization flags were enabled when you created it,


00:56:39.000 --> 00:56:40.420
for example, right?


00:56:40.420 --> 00:56:41.260
- Yes.


00:56:41.260 --> 00:56:43.840
- And there is one additional thing.


00:56:43.840 --> 00:56:46.240
So Portable Python does not install Python


00:56:46.240 --> 00:56:49.240
on your system for you, so it is a builder.


00:56:49.240 --> 00:56:51.880
So it builds them and produces tarballs


00:56:51.880 --> 00:56:53.720
that can be used in a standalone manner.


00:56:53.720 --> 00:56:56.600
And so if you want to bring Python onto your system,


00:56:56.600 --> 00:56:58.120
you just download the tarball


00:56:58.120 --> 00:57:03.000
from our internal artifact storage and then expand it.


00:57:03.000 --> 00:57:05.540
And that we have another tool that automatically does that.


00:57:05.540 --> 00:57:09.760
And so when somebody bootstraps a brand new Python project


00:57:09.760 --> 00:57:12.400
and they say, I would like to use 3.11.3,


00:57:12.400 --> 00:57:15.480
which 3.11.4, I think that got released yesterday,


00:57:15.480 --> 00:57:18.680
then we will already have a binary ready for them


00:57:18.680 --> 00:57:22.040
that is in the artifactory, in our internal artifactory.


00:57:22.040 --> 00:57:25.280
And when they run their build for the very first time,


00:57:25.280 --> 00:57:27.960
it will bring the appropriate Python version


00:57:27.960 --> 00:57:30.320
that they have specified in either pyproject.toml


00:57:30.320 --> 00:57:33.380
or in their talks.ini or somewhere.


00:57:33.380 --> 00:57:36.200
And it will bring that appropriate Python,


00:57:36.200 --> 00:57:38.600
install it or expand it in a known location,


00:57:38.600 --> 00:57:41.000
and it will use that for their building their project


00:57:41.000 --> 00:57:41.840
and so forth.


00:57:41.840 --> 00:57:44.040
So this is, it's a way to make it easy


00:57:44.040 --> 00:57:46.520
for people to not have to manage their Python


00:57:46.520 --> 00:57:49.160
on their laptop individually.


00:57:49.160 --> 00:57:54.160
And also, this can build Python with a specific prefix.


00:57:54.160 --> 00:57:57.600
So on servers, on our internal servers,


00:57:57.600 --> 00:58:00.600
what we do is we install Python in a specific location.


00:58:00.600 --> 00:58:02.680
Like we always put it inside, let's say, for example,


00:58:02.680 --> 00:58:05.120
slash apps slash Python, for example.


00:58:05.120 --> 00:58:07.640
It will build it in a way that it makes it easy


00:58:07.640 --> 00:58:08.800
for Debian to be built.


00:58:08.800 --> 00:58:10.600
And when you install the Debian,


00:58:10.600 --> 00:58:13.640
it will put the Python in a specific location.


00:58:13.640 --> 00:58:15.720
And also it has other benefits,


00:58:15.720 --> 00:58:19.560
such as it tries to make the Python binary


00:58:19.560 --> 00:58:20.960
as small as possible,


00:58:20.960 --> 00:58:22.680
because we're trying to deploy it out


00:58:22.680 --> 00:58:26.180
to like hundreds of thousands or 100,000 servers.


00:58:26.180 --> 00:58:28.320
So we would try to reduce the amount


00:58:28.320 --> 00:58:31.600
that we need to put on that server.


00:58:31.600 --> 00:58:34.520
It does that, like I think the final product


00:58:34.520 --> 00:58:36.520
that Zorin checked yesterday,


00:58:36.520 --> 00:58:38.080
I believe it was only 50 megabytes


00:58:38.080 --> 00:58:41.200
compared to what other like PyEN


00:58:41.200 --> 00:58:44.080
and other things are producing, which was 200 megabytes.


00:58:44.080 --> 00:58:47.040
So it does it by a few tricks.


00:58:47.040 --> 00:58:50.520
Like it removes the test folder, because once you have built it,


00:58:50.520 --> 00:58:52.720
having the test folder as part of your final artifact


00:58:52.720 --> 00:58:54.520
makes no sense.


00:58:54.520 --> 00:58:56.600
That was like 100 megabytes savings right there.


00:58:56.600 --> 00:58:57.800
So things like that.


00:58:57.800 --> 00:58:59.280
There's some optimizations that we do


00:58:59.280 --> 00:59:02.240
that is custom for our work.


00:59:02.240 --> 00:59:04.800
>>Yeah, that's a really interesting system.


00:59:04.800 --> 00:59:11.440
I think there's increasing momentum


00:59:11.440 --> 00:59:16.440
around having some kind of tool that is outside of Python


00:59:16.440 --> 00:59:18.400
for managing Python, right?


00:59:18.400 --> 00:59:22.960
So far, primarily what we've had is things like Pip, PipX,


00:59:22.960 --> 00:59:25.000
so when you have a project called Pickley,


00:59:25.000 --> 00:59:27.560
it's all about like, okay, you have Python,


00:59:27.560 --> 00:59:28.880
now how do you go forward?


00:59:28.880 --> 00:59:31.520
But I think a lot of people are realizing like,


00:59:31.520 --> 00:59:34.040
wait, that assumption that I have Python, now what?


00:59:34.040 --> 00:59:35.820
Is not a great assumption, right?


00:59:35.820 --> 00:59:39.080
And so people are starting to look at tools like RustUp,


00:59:39.080 --> 00:59:41.580
which actually is kind of like pip,


00:59:41.580 --> 00:59:44.740
but it brings Rust also over.


00:59:44.740 --> 00:59:46.820
Yeah, so we're gonna see something there, I think.


00:59:46.820 --> 00:59:49.020
I don't know what it is, but it'll be interesting.


00:59:49.020 --> 00:59:51.740
- Yeah, did you see the one, Rai?


00:59:51.740 --> 00:59:55.740
Rai is the package manager that Armin wrote.


00:59:55.740 --> 00:59:58.860
- Yep, yeah, from Armin Roenacker, yep.


00:59:58.860 --> 01:00:02.020
- Yeah, that brings Python for you.


01:00:02.020 --> 01:00:07.020
His inspiration is from Rust up, apparently.


01:00:07.060 --> 01:00:09.700
So Rai is actually written in Rust,


01:00:09.700 --> 01:00:14.420
and it does all the things that Poetry and PDM


01:00:14.420 --> 01:00:15.580
and other package managers does.


01:00:15.580 --> 01:00:18.300
But in addition to that, it also brings Python for you.


01:00:18.300 --> 01:00:23.180
And it's using a different Python called Standalone Python,


01:00:23.180 --> 01:00:25.660
or something that you already had a link for, I forgot.


01:00:25.660 --> 01:00:28.820
But it brings Python from there to expand it


01:00:28.820 --> 01:00:31.220
into your system.


01:00:31.220 --> 01:00:32.340
Yeah, Python builds standalone.


01:00:32.340 --> 01:00:34.380
That's the project that it uses.


01:00:34.380 --> 01:00:36.260
- Yep, okay.


01:00:36.260 --> 01:00:37.220
- Yeah, I've heard of that.


01:00:37.220 --> 01:00:39.660
I haven't done anything with it, but it looks interesting.


01:00:39.660 --> 01:00:40.500
- Yeah.


01:00:40.500 --> 01:00:41.320
- All right, I think we have time,


01:00:41.320 --> 01:00:42.280
we're getting short on time here.


01:00:42.280 --> 01:00:44.620
I think we have time for one more really quick thing,


01:00:44.620 --> 01:00:48.500
something that you're participating in, Amjith.


01:00:48.500 --> 01:00:50.100
And Saurabh, I don't know if you are as well,


01:00:50.100 --> 01:00:52.060
but command line database clients


01:00:52.060 --> 01:00:54.480
with auto-complete and syntax highlighting.


01:00:54.480 --> 01:00:57.300
Tell us about this, this looks cool.


01:00:57.300 --> 01:00:59.780
- Yeah, this is just my personal project


01:00:59.780 --> 01:01:03.740
that I wrote before, this was a while back.


01:01:03.740 --> 01:01:08.140
But the idea is at the time I was trying to learn Postgres


01:01:08.140 --> 01:01:10.140
and I didn't know how to do,


01:01:10.140 --> 01:01:13.460
like I was learning Postgres and I was using PSQL to do this


01:01:13.460 --> 01:01:16.560
and every time I come to like a table,


01:01:16.560 --> 01:01:18.180
I'd be like, oh, what columns were there?


01:01:18.180 --> 01:01:19.940
I forgot the exact name of the column


01:01:19.940 --> 01:01:22.500
and I tried to find it and so forth.


01:01:22.500 --> 01:01:26.860
And so finally, I broke down and decided to write


01:01:26.860 --> 01:01:31.420
like a shell for Postgres called PGCLI


01:01:31.420 --> 01:01:32.860
that uses actually Prompt Toolkit,


01:01:32.860 --> 01:01:36.080
like the same toolkit that's used by PT Python.


01:01:36.080 --> 01:01:40.180
- I was gonna say, it looks a lot like PT Python.


01:01:40.180 --> 01:01:42.260
It's got that Emacs mode.


01:01:42.260 --> 01:01:43.220
- Yep.


01:01:43.220 --> 01:01:44.980
- You've got autocomplete for basically


01:01:44.980 --> 01:01:48.660
the whole SQL language, but also the database schema


01:01:48.660 --> 01:01:50.020
that you're connected to, right?


01:01:50.020 --> 01:01:50.900
- Yes, that is correct.


01:01:50.900 --> 01:01:54.060
So it reads the tables and the columns in that database,


01:01:54.060 --> 01:01:55.300
and then it tries to autocomplete


01:01:55.300 --> 01:01:57.060
as part of the SQL statement.


01:01:57.060 --> 01:02:00.180
So after a WHERE clause, it'll only suggest columns,


01:02:00.180 --> 01:02:03.900
and after a from clause, it'll only suggest tables and so on.


01:02:03.900 --> 01:02:05.220
Wow, OK.


01:02:05.220 --> 01:02:08.980
And after PGCLI, people wanted something for MySQL,


01:02:08.980 --> 01:02:10.780
so I created MyCLI.


01:02:10.780 --> 01:02:14.540
And then Microsoft came over and said,


01:02:14.540 --> 01:02:16.560
we would like to fork PGCLI to make one


01:02:16.560 --> 01:02:19.540
for Microsoft's MS SQL Server.


01:02:19.540 --> 01:02:22.580
So they did that themselves.


01:02:22.580 --> 01:02:25.660
So they took PGCLI source code, and then they created that.


01:02:25.660 --> 01:02:29.140
And then another person created LightCLI,


01:02:29.140 --> 01:02:30.260
which is for SQLite.


01:02:30.260 --> 01:02:33.100
And yeah, and there's other things now.


01:02:33.100 --> 01:02:34.740
iRedis is like for a Redis client


01:02:34.740 --> 01:02:36.400
that's similar to these things,


01:02:36.400 --> 01:02:37.980
but there's a lot more,


01:02:37.980 --> 01:02:42.340
like more friendlier shells for databases in general.


01:02:42.340 --> 01:02:43.180
- Excellent.


01:02:43.180 --> 01:02:44.100
All right, this looks really cool.


01:02:44.100 --> 01:02:45.620
I think.


01:02:45.620 --> 01:02:47.760
- Yeah, this has got nothing to do with Netflix.


01:02:47.760 --> 01:02:50.500
It's mostly just like, hey, it's my personal project.


01:02:50.500 --> 01:02:53.220
And you know, just what I do in my free time


01:02:53.220 --> 01:02:54.700
sort of a thing.


01:02:54.700 --> 01:02:55.740
- Yeah.


01:02:55.740 --> 01:02:58.000
Well, it looks really helpful for people


01:02:58.000 --> 01:03:03.000
because talking to databases just in your terminal,


01:03:03.000 --> 01:03:03.920
it can be tricky, right?


01:03:03.920 --> 01:03:07.760
And having auto-complete, especially not so much


01:03:07.760 --> 01:03:10.000
the select and where people get that pretty quick,


01:03:10.000 --> 01:03:12.440
but the database schema understanding


01:03:12.440 --> 01:03:14.420
keeps you in your flow pretty well.


01:03:14.420 --> 01:03:15.600
- Right, yeah.


01:03:15.600 --> 01:03:17.720
Again, inspired by BPython actually.


01:03:17.720 --> 01:03:19.440
Took inspiration from them.


01:03:19.440 --> 01:03:20.600
- Yeah, excellent.


01:03:20.600 --> 01:03:23.080
All right, well, that'll be in the show notes as well.


01:03:23.080 --> 01:03:25.720
Guys, I think that is it for time that we have today.


01:03:25.720 --> 01:03:28.200
So we're going to have to wrap it up with the final two


01:03:28.200 --> 01:03:31.840
questions here and recommendations.


01:03:31.840 --> 01:03:34.760
Let's start with PyPI project.


01:03:34.760 --> 01:03:36.300
Not necessarily the most popular one,


01:03:36.300 --> 01:03:37.920
but something that you're like, oh, this is awesome.


01:03:37.920 --> 01:03:39.360
People should know about it.


01:03:39.360 --> 01:03:42.240
Soren, got a recommendation for folks?


01:03:42.240 --> 01:03:43.440
I'm going to say PICLI.


01:03:43.440 --> 01:03:44.960
Go check out PICLI.


01:03:44.960 --> 01:03:45.480
PICLI.


01:03:45.480 --> 01:03:49.520
OK, so give us the elevator pitch on PICLI.


01:03:49.520 --> 01:03:55.680
It's a CLI tool that allows you to install other CLI tools.


01:03:55.680 --> 01:03:58.580
very similar to PIPX in that sense.


01:03:58.580 --> 01:04:00.720
But the main difference is being that


01:04:00.720 --> 01:04:03.260
if you quickly install Poetry,


01:04:03.260 --> 01:04:04.460
every time you run Poetry,


01:04:04.460 --> 01:04:07.620
it will keep itself up to date in the background.


01:04:07.620 --> 01:04:11.460
So it will keep self-upgrading by default.


01:04:11.460 --> 01:04:13.060
You can tell it also not to do that,


01:04:13.060 --> 01:04:17.500
but it's main useful thing.


01:04:17.500 --> 01:04:18.540
- Cool, so when you launch it,


01:04:18.540 --> 01:04:22.300
basically you're launching like a shim that says,


01:04:22.300 --> 01:04:24.420
"Run this," and then the background check for update,


01:04:24.420 --> 01:04:27.140
And when it exits, if there's an update, just update it.


01:04:27.140 --> 01:04:29.620
- Yes, you can take a look at the little shell script,


01:04:29.620 --> 01:04:33.420
shell wrapper that it wraps it with, yes.


01:04:33.420 --> 01:04:34.860
- All right, Pickly, awesome.


01:04:34.860 --> 01:04:37.620
Amjith?


01:04:37.620 --> 01:04:42.620
- Oh, I guess I could plug again for BPython,


01:04:42.620 --> 01:04:45.060
like good design aesthetics.


01:04:45.060 --> 01:04:47.780
I think, yeah, it's an overall better shell


01:04:47.780 --> 01:04:49.540
than Python shell.


01:04:49.540 --> 01:04:50.360
- Yeah.


01:04:50.360 --> 01:04:51.820
- Oh, actually, PDB++,


01:04:51.820 --> 01:04:53.660
that's the one that I would actually recommend.


01:04:53.660 --> 01:05:02.660
So if you ever use PDB and you wish that PDB had auto-completion, it's PDBPP in PyPy.


01:05:02.660 --> 01:05:05.220
You don't have to change your thing at all.


01:05:05.220 --> 01:05:08.180
All you have to do is pip install PDBPP.


01:05:08.180 --> 01:05:13.900
And then anytime you do a breakpoint and it stops you there, you can do like a variable


01:05:13.900 --> 01:05:16.060
dot and it'll give you auto-completion.


01:05:16.060 --> 01:05:17.220
And yeah, I don't know.


01:05:17.220 --> 01:05:18.220
I'm a huge fan of auto-completion.


01:05:18.220 --> 01:05:22.020
- Yeah, I was gonna say, you and I are kindred spirits.


01:05:22.020 --> 01:05:23.980
I am all about the auto-complete.


01:05:23.980 --> 01:05:25.260
I'm like, this tool is broken


01:05:25.260 --> 01:05:27.420
if it doesn't give me auto-complete.


01:05:27.420 --> 01:05:29.200
Because it sends you into the documentation,


01:05:29.200 --> 01:05:30.320
you'll be like, oh, I need to create


01:05:30.320 --> 01:05:32.420
one of these client libraries.


01:05:32.420 --> 01:05:33.260
What does it take?


01:05:33.260 --> 01:05:35.060
Oh, star args, star star, KW args.


01:05:35.060 --> 01:05:36.860
Great, now what am I supposed to do, right?


01:05:36.860 --> 01:05:40.120
Like, you know, the auto-complete,


01:05:40.120 --> 01:05:42.040
it really makes you more productive.


01:05:42.040 --> 01:05:45.340
All right, and then if you're gonna write some Python code,


01:05:45.340 --> 01:05:48.140
what editor, if you're not in the ripple, are you using?


01:05:48.140 --> 01:05:52.140
For me, PyCharm.


01:05:52.140 --> 01:05:59.140
PyCharm is the sublime text and VI if I'm ss-hitching somewhere.


01:05:59.140 --> 01:06:01.140
Excellent. And Amjit?


01:06:01.140 --> 01:06:06.140
Vim all the way. Even if I don't know how to quit it, I can restart my computer.


01:06:06.140 --> 01:06:13.140
That is the source of, the endless source of jokes.


01:06:13.140 --> 01:06:18.420
I saw some laptop, a picture of a laptop and it was just smashed to pieces and it said


01:06:18.420 --> 01:06:20.140
finally figured out how to quit Vim.


01:06:20.140 --> 01:06:28.620
For the longest time actually I had colon Q as a way to quit out of PGCLI because I


01:06:28.620 --> 01:06:33.220
would, you know, by instinct just kept hitting colon Q and yeah.


01:06:33.220 --> 01:06:34.900
That's amazing.


01:06:34.900 --> 01:06:39.020
All right you guys, well it's been great to have you on the show.


01:06:39.020 --> 01:06:40.140
Thanks for being here.


01:06:40.140 --> 01:06:43.820
for giving us this look at what you're all doing up over at Netflix and in your personal


01:06:43.820 --> 01:06:44.820
projects.


01:06:44.820 --> 01:06:46.180
Yeah, thank you, Michael.


01:06:46.180 --> 01:06:52.140
I just would like to mention that we have a lot of jobs at Netflix that require Python.


01:06:52.140 --> 01:06:56.700
So if you are at all interested, please go to jobs.netflix.com and type in Python and


01:06:56.700 --> 01:07:00.660
you should get all of the Python job openings that are available.


01:07:00.660 --> 01:07:02.740
Yeah, there's a wide variety.


01:07:02.740 --> 01:07:04.900
If you want to do infrastructure stuff, there's that.


01:07:04.900 --> 01:07:07.740
If you want to do data science, there's that, right?


01:07:07.740 --> 01:07:08.740
Like a lot of colors.


01:07:08.740 --> 01:07:18.740
course. Yes. Absolutely. All right. Have a great day guys. Thank you. Bye. Bye.

