WEBVTT

00:00:00.000 --> 00:00:04.320
- Well, welcome back to Talk Python to Me.


00:00:04.320 --> 00:00:05.960
- Thank you, it's good to be here.


00:00:05.960 --> 00:00:08.720
- Man, it's fantastic to have you here.


00:00:08.720 --> 00:00:11.120
Really looking forward to talking about the progress


00:00:11.120 --> 00:00:15.280
you've made on Rich and Textual and your company,


00:00:15.280 --> 00:00:17.280
which is pretty fantastic.


00:00:17.280 --> 00:00:19.200
The show is not specifically about that,


00:00:19.200 --> 00:00:21.560
it's more about all these fantastic lessons


00:00:21.560 --> 00:00:23.460
that you've learned while building it,


00:00:23.460 --> 00:00:26.240
but of course we'll get a chance to talk about it


00:00:26.240 --> 00:00:28.360
and give some updates too, I'm sure.


00:00:28.360 --> 00:00:30.160
- Cool, sounds good to me.


00:00:30.160 --> 00:00:32.640
- Yeah, well, normally I ask folks


00:00:32.640 --> 00:00:36.520
how they got into programming and whatnot.


00:00:36.520 --> 00:00:38.680
People, if they wanna hear that story,


00:00:38.680 --> 00:00:42.520
they can go back and check out your episode 336


00:00:42.520 --> 00:00:47.040
on Talk Python way back, way back last year,


00:00:47.040 --> 00:00:47.880
about a year ago.


00:00:47.880 --> 00:00:50.360
- It's a lifetime ago.


00:00:50.360 --> 00:00:52.440
- I know, in terms of what's happened


00:00:52.440 --> 00:00:54.180
with your projects and stuff,


00:00:54.180 --> 00:00:55.600
it really is kind of a lifetime ago.


00:00:55.600 --> 00:00:57.680
So what I wanna ask you instead is,


00:00:57.680 --> 00:00:59.600
What have you been up to the last year?


00:00:59.600 --> 00:01:00.760
Give us an update.


00:01:00.760 --> 00:01:05.040
- Yeah, okay, so I founded textualize.io,


00:01:05.040 --> 00:01:07.560
a new startup.


00:01:07.560 --> 00:01:10.640
I've hired developers and we're very busy


00:01:10.640 --> 00:01:14.520
working on textual, and it's come on really well.


00:01:14.520 --> 00:01:15.720
It's amazing.


00:01:15.720 --> 00:01:17.080
There's more than I thought it would do,


00:01:17.080 --> 00:01:18.100
to be honest with you.


00:01:18.100 --> 00:01:19.740
Oh, textualize.io.


00:01:19.740 --> 00:01:21.800
(laughing)


00:01:21.800 --> 00:01:24.660
- Yeah, textualize, there we go.


00:01:24.660 --> 00:01:26.160
The other one's for sale if you want it.


00:01:26.160 --> 00:01:29.640
I get that all the time, sorry.


00:01:29.640 --> 00:01:34.160
Yeah, so you've been working on Textualize and you actually got some investments and


00:01:34.160 --> 00:01:37.520
you're hiring and amazing.


00:01:37.520 --> 00:01:39.040
I'm so happy for you.


00:01:39.040 --> 00:01:40.040
Thank you.


00:01:40.040 --> 00:01:41.040
Yeah, it wasâ€¦


00:01:41.040 --> 00:01:44.200
And yet when I first heard that I'm like, well, what is the business model?


00:01:44.200 --> 00:01:45.200
What is the business model here?


00:01:45.200 --> 00:01:47.760
Like what are you all working towards?


00:01:47.760 --> 00:01:50.120
Like you just leverage the terminal, right?


00:01:50.120 --> 00:01:51.120
Even more.


00:01:51.120 --> 00:01:52.120
Yeah, that's right.


00:01:52.120 --> 00:01:55.120
So that's a very reasonable question that everyone asks.


00:01:55.120 --> 00:02:00.460
So the first part is textual, which will be open source and distributed just like any


00:02:00.460 --> 00:02:01.960
other open source project.


00:02:01.960 --> 00:02:09.240
But we will add on this commercial service where you can take those textual apps and


00:02:09.240 --> 00:02:11.160
then you can put them in the web.


00:02:11.160 --> 00:02:17.440
And then when they're on the web, we can charge companies and organizations a monthly fee


00:02:17.440 --> 00:02:24.000
for various services such as accounts and things and maybe payment portals and things.


00:02:24.000 --> 00:02:28.640
But it will be a very generous free tier for hobbyists


00:02:28.640 --> 00:02:32.240
and for open source projects that want to do the same.


00:02:32.240 --> 00:02:33.440
- Fantastic.


00:02:33.440 --> 00:02:37.400
So we have SaaS, or Software as a Service.


00:02:37.400 --> 00:02:41.760
We have PaaS, P-A-A-S, for Platform as a Service.


00:02:41.760 --> 00:02:45.440
And the whole style of apps from textual


00:02:45.440 --> 00:02:47.580
and to a lesser degree rich,


00:02:47.580 --> 00:02:52.040
often go under the terminology of TUI,


00:02:52.040 --> 00:02:53.920
a text user interface, right?


00:02:53.920 --> 00:02:58.920
So TUI as a service, TAS, T-A-S.


00:02:58.920 --> 00:03:01.880
Are you creating a new as a service?


00:03:01.880 --> 00:03:03.240
- Yeah, I kind of like it.


00:03:03.240 --> 00:03:07.520
TAS, you get, you know, in tech we love our acronyms.


00:03:07.520 --> 00:03:10.880
So if I don't invent at least one, I'll be disappointed.


00:03:10.880 --> 00:03:12.000
- That's right, that's right.


00:03:12.000 --> 00:03:15.120
And if they can have like, you know, multiple cases, right?


00:03:15.120 --> 00:03:18.640
Like a capital T-A-S, then I think it's gonna be great.


00:03:18.640 --> 00:03:22.240
Yeah, it's one of the better types of acronyms.


00:03:22.240 --> 00:03:23.320
- Yeah, yeah.


00:03:23.320 --> 00:03:24.320
Fantastic.


00:03:24.320 --> 00:03:26.120
Now, I think this is great.


00:03:26.120 --> 00:03:32.320
And you know, there's one of the things I'm really fascinated about, and for a long time


00:03:32.320 --> 00:03:38.900
I've been trying to pay attention to and highlight, is how do people go from open source project


00:03:38.900 --> 00:03:40.120
to business?


00:03:40.120 --> 00:03:46.120
And when I first started the podcast and really started to think about these things, it seemed


00:03:46.120 --> 00:03:47.980
like there was not that many great answers.


00:03:47.980 --> 00:03:52.720
It felt like a lot of, well, here's my PayPal donation link or something.


00:03:52.720 --> 00:03:58.240
And it just seemed like, well, okay, that might feel good as a thanks, but you cannot


00:03:58.240 --> 00:04:04.760
make that your job to say, buy me a coffee most of the time.


00:04:04.760 --> 00:04:07.280
There's a lot of progress lately, isn't there?


00:04:07.280 --> 00:04:12.020
Yeah, from GitHub sponsors and similar programs.


00:04:12.020 --> 00:04:19.400
You can get sponsorship and it can be enough to live on.


00:04:19.400 --> 00:04:24.200
It's not easy, the type of projects that get sponsored are the ones which are super critical


00:04:24.200 --> 00:04:25.200
to businesses.


00:04:25.200 --> 00:04:32.480
And in that case, companies don't mind donating $300 a month, and if you get enough of those,


00:04:32.480 --> 00:04:36.080
you could live on it, and some people certainly do.


00:04:36.080 --> 00:04:41.000
But I don't think it's practical for most people.


00:04:41.000 --> 00:04:47.360
Even if your open source project is widely used and popular, it might not bring in enough


00:04:47.360 --> 00:04:51.280
sponsorship to live on, unfortunately.


00:04:51.280 --> 00:04:52.640
>> Yeah, unfortunately.


00:04:52.640 --> 00:04:59.440
And so I do think GitHub sponsors really is kind of that done right.


00:04:59.440 --> 00:05:04.160
You know, it's recurring, it's automatic.


00:05:04.160 --> 00:05:08.200
It has a social signal benefit, right?


00:05:08.200 --> 00:05:11.060
Like you can see who is sponsoring which projects.


00:05:11.060 --> 00:05:15.560
So if you're an organization, right, like you could say, "Oh, look, our company sponsors


00:05:15.560 --> 00:05:17.600
that project or whatever.


00:05:17.600 --> 00:05:19.400
- Yeah, it's very well done.


00:05:19.400 --> 00:05:22.960
Actually, I've got no problems with it's done.


00:05:22.960 --> 00:05:25.240
You can, like I said, you can contribute every month


00:05:25.240 --> 00:05:27.040
or you can contribute a one-off


00:05:27.040 --> 00:05:29.640
and you can get your name mentioned on the project


00:05:29.640 --> 00:05:34.160
and the author of the project can offer various perks.


00:05:34.160 --> 00:05:37.140
So I think it's nicely done.


00:05:37.140 --> 00:05:42.780
- The other one that I see really,


00:05:42.780 --> 00:05:44.360
this might be the most popular one


00:05:44.360 --> 00:05:49.360
is take an open source thing and then take away,


00:05:49.360 --> 00:05:52.780
help alleviate or completely solve


00:05:52.780 --> 00:05:56.700
the operational side of things, right?


00:05:56.700 --> 00:06:00.980
For example, we have MongoDB and then they have Atlas,


00:06:00.980 --> 00:06:03.980
which lets you push a button and manage your cluster


00:06:03.980 --> 00:06:07.500
automatically inside your own AWS or Azure account.


00:06:07.500 --> 00:06:11.300
We've got Streamlit, which just got acquired,


00:06:11.300 --> 00:06:13.620
has a lot of similarities to what you're doing.


00:06:13.620 --> 00:06:15.820
You know, it's like, it's got an open source version,


00:06:15.820 --> 00:06:18.980
you can create these dashboards, it's really cool.


00:06:18.980 --> 00:06:20.660
But then what, how do you put them on the internet?


00:06:20.660 --> 00:06:22.320
How do you maintain them?


00:06:22.320 --> 00:06:24.420
Right, and then, well, guess what?


00:06:24.420 --> 00:06:27.060
There's a paid tier that just runs it


00:06:27.060 --> 00:06:29.060
in our cloud for you, right?


00:06:29.060 --> 00:06:30.880
So it seems like a really great,


00:06:30.880 --> 00:06:34.180
really great path to proceed down


00:06:34.180 --> 00:06:35.820
for what you're doing here.


00:06:35.820 --> 00:06:37.300
- Yeah, that's right.


00:06:37.300 --> 00:06:39.780
They've got time for it, it's called OpenCore.


00:06:40.700 --> 00:06:45.300
So you use the open source part to drive adoption.


00:06:45.300 --> 00:06:49.900
And then you can use that to sell some related services,


00:06:49.900 --> 00:06:52.940
which will just make life easier for businesses and things.


00:06:52.940 --> 00:06:55.740
'Cause there's a long history of businesses


00:06:55.740 --> 00:06:57.820
making use of open source projects


00:06:57.820 --> 00:07:00.920
and making a lot of money out of it.


00:07:00.920 --> 00:07:05.660
But they haven't really put that money in to the business.


00:07:05.660 --> 00:07:08.060
So if the people that are building and maintaining


00:07:08.060 --> 00:07:12.060
these open source projects can also build side businesses


00:07:12.060 --> 00:07:14.540
around the open source project,


00:07:14.540 --> 00:07:18.120
then everyone benefits because your code gets maintained


00:07:18.120 --> 00:07:20.060
for the indefinite future


00:07:20.060 --> 00:07:23.320
and people can make a living from it.


00:07:23.320 --> 00:07:26.700
- Yeah, if you would otherwise have to hire somebody


00:07:26.700 --> 00:07:30.680
to manage a Kubernetes cluster or whatever,


00:07:30.680 --> 00:07:32.760
and instead you can pay $20 a month,


00:07:32.760 --> 00:07:34.720
like that's a real good deal.


00:07:34.720 --> 00:07:37.180
- Exactly, and you don't want to have to solve


00:07:37.180 --> 00:07:39.860
all these problems individually for everyone that uses it,


00:07:39.860 --> 00:07:42.420
it's actually far better for someone


00:07:42.420 --> 00:07:45.420
to solve it once and for all, or at least reduce


00:07:45.420 --> 00:07:49.380
the footprint for maintenance.


00:07:49.380 --> 00:07:51.820
- Yeah, who else better to figure out


00:07:51.820 --> 00:07:53.220
how to put it in the cloud than people


00:07:53.220 --> 00:07:54.740
who are creating it, right?


00:07:54.740 --> 00:07:56.220
- Yeah, exactly, yeah.


00:07:56.220 --> 00:07:57.120
- Yeah, for sure.


00:07:57.120 --> 00:08:00.700
Okay, so fantastic.


00:08:00.700 --> 00:08:02.740
I'm looking forward to Tui as a service


00:08:02.740 --> 00:08:05.620
to come on strong here, that's great.


00:08:06.860 --> 00:08:10.620
So maybe before we jump into the lessons learned,


00:08:10.620 --> 00:08:14.620
just tell people about what textual is


00:08:14.620 --> 00:08:17.700
and then textual is built upon rich.


00:08:17.700 --> 00:08:20.020
So give us the quick rundown on,


00:08:20.020 --> 00:08:23.060
take whichever order you think is better


00:08:23.060 --> 00:08:25.420
to go first, rich or textual.


00:08:25.420 --> 00:08:29.140
- I think rich, I'll go in chronological order.


00:08:29.140 --> 00:08:34.140
So I started rich, gosh, it must be like three years now.


00:08:34.700 --> 00:08:38.660
And the idea was to be able to write color text,


00:08:38.660 --> 00:08:41.700
the terminal, in a nice, elegant way,


00:08:41.700 --> 00:08:45.980
and also be able to build on that with larger components.


00:08:45.980 --> 00:08:48.100
So we've got things like tables,


00:08:48.100 --> 00:08:51.940
we've got progress bars, we've got log messages,


00:08:51.940 --> 00:08:54.140
panels, all sorts of things.


00:08:54.140 --> 00:08:57.980
And they're all using the same core rendering technology,


00:08:57.980 --> 00:09:00.380
which basically takes your objects


00:09:00.380 --> 00:09:04.660
and then turns it into ANSI codes and text.


00:09:04.660 --> 00:09:08.220
And that got fairly popular, shall we say.


00:09:08.220 --> 00:09:09.060
I was surprised.


00:09:09.060 --> 00:09:09.900
- I would say.


00:09:09.900 --> 00:09:11.940
I would say so too.


00:09:11.940 --> 00:09:15.700
- Yeah, it's in pip now, which still blows me away


00:09:15.700 --> 00:09:19.100
because that means that virtually every Python developer


00:09:19.100 --> 00:09:24.100
is running my code, which also scares me just a little bit.


00:09:24.100 --> 00:09:28.300
- That's right, because I mean, if you have Python,


00:09:28.300 --> 00:09:30.020
you have pip, so you have rich.


00:09:30.020 --> 00:09:34.580
Is it a package with pip as a dependency


00:09:34.580 --> 00:09:36.300
Or is it vendored in?


00:09:36.300 --> 00:09:38.780
It's vendored, because you've got a chicken and egg


00:09:38.780 --> 00:09:40.140
problem with pip.


00:09:40.140 --> 00:09:42.060
Because pip is how you get the things, right?


00:09:42.060 --> 00:09:42.420
Exactly.


00:09:42.420 --> 00:09:42.820
Exactly.


00:09:42.820 --> 00:09:43.900
So everything is vendored.


00:09:43.900 --> 00:09:48.140
PIP is just one project with lots of vendored projects


00:09:48.140 --> 00:09:49.660
inside of it.


00:09:49.660 --> 00:09:50.860
Yeah.


00:09:50.860 --> 00:09:51.900
OK.


00:09:51.900 --> 00:09:52.620
Yeah, fantastic.


00:09:52.620 --> 00:09:56.820
So Rich-- yeah, for people who haven't seen it in action,


00:09:56.820 --> 00:10:00.740
it's not just like Colorama or something,


00:10:00.740 --> 00:10:02.700
which I'm a big fan of Colorama.


00:10:02.700 --> 00:10:05.000
But that's just about how do I make this line,


00:10:05.000 --> 00:10:06.200
this color or whatever.


00:10:06.200 --> 00:10:11.200
But you're talking about like tables with auto,


00:10:11.200 --> 00:10:14.760
you know, auto ellipsing and all sorts of really,


00:10:14.760 --> 00:10:17.200
really powerful content, right?


00:10:17.200 --> 00:10:19.880
- Yeah, and some things which you might take for granted


00:10:19.880 --> 00:10:22.280
in the browser, like text wrapping,


00:10:22.280 --> 00:10:25.060
that wasn't easy to do prior to Rich.


00:10:25.060 --> 00:10:28.560
They're just more complex than you might think.


00:10:28.560 --> 00:10:32.260
Things like emoji and Chinese characters.


00:10:32.260 --> 00:10:34.740
Those take up two cells in the terminal.


00:10:34.740 --> 00:10:37.900
If you use the built-in text wrap module,


00:10:37.900 --> 00:10:39.160
that won't account for that,


00:10:39.160 --> 00:10:42.100
and your text wrapping will be misaligned.


00:10:42.100 --> 00:10:46.020
So I wanted to solve those kind of problems.


00:10:46.020 --> 00:10:47.340
I just wanted to be effortless.


00:10:47.340 --> 00:10:49.860
You just say, "Print this text,"


00:10:49.860 --> 00:10:51.020
and it'll wrap it for you,


00:10:51.020 --> 00:10:53.520
which generally makes it a lot more readable.


00:10:53.520 --> 00:10:56.300
- Yeah, absolutely.


00:10:56.300 --> 00:10:58.740
- So there's a lot going on there.


00:10:58.740 --> 00:10:59.740
- I would say so.


00:11:01.860 --> 00:11:04.300
I don't know how many projects are using rich now,


00:11:04.300 --> 00:11:06.100
but it's--


00:11:06.100 --> 00:11:07.500
there constantly seems to be like,


00:11:07.500 --> 00:11:09.220
and now this has rich support.


00:11:09.220 --> 00:11:13.740
So it has a much better output, or it's more understandable,


00:11:13.740 --> 00:11:14.900
or whatever, right?


00:11:14.900 --> 00:11:16.260
A lot of cool things happen.


00:11:16.260 --> 00:11:16.980
Yeah.


00:11:16.980 --> 00:11:21.260
And I'm delighted every time I read one of those.


00:11:21.260 --> 00:11:24.340
I do try to make it quite easy to drop things in.


00:11:24.340 --> 00:11:27.740
For instance, if you're printing out Python data structures,


00:11:27.740 --> 00:11:30.380
you can use a rich method, and you'll


00:11:30.380 --> 00:11:35.340
get pretty printing and colorizing built in.


00:11:35.340 --> 00:11:37.540
And things like exception handling,


00:11:37.540 --> 00:11:41.980
we've got very pretty exceptions that show you snippets of code


00:11:41.980 --> 00:11:47.220
and can highlight the line where the error occurred.


00:11:47.220 --> 00:11:49.020
And you can add those with just a few lines.


00:11:49.020 --> 00:11:51.260
So I think that's kind of pushing adoption


00:11:51.260 --> 00:11:54.900
is the fact that there is very low barrier to entry.


00:11:54.900 --> 00:11:55.860
Yeah.


00:11:55.860 --> 00:11:57.180
And it's just beautiful, right?


00:11:57.180 --> 00:11:58.740
It's easy to make beautiful UIs.


00:11:58.740 --> 00:12:03.940
And if you make it easy for people to make nice looking things, they want to use it.


00:12:03.940 --> 00:12:09.700
I mean, it's not as used as much these days, but think of when Bootstrap came on the scene,


00:12:09.700 --> 00:12:15.740
you know, eight years ago or 10 years, whatever it was, 10 years ago, everything started to


00:12:15.740 --> 00:12:19.180
look like Bootstrap because you could just apply this magic and like, oh, everything


00:12:19.180 --> 00:12:21.060
looks like professional, but we're not professional.


00:12:21.060 --> 00:12:24.420
And I feel like Rich is a little bit like that for 2E's.


00:12:24.420 --> 00:12:27.180
Yeah, I think so.


00:12:27.180 --> 00:12:33.020
Because it was very difficult to add pretty formatting prior to rich.


00:12:33.020 --> 00:12:38.300
I mean, there were libraries that existed, but they didn't integrate very well.


00:12:38.300 --> 00:12:42.740
Rich kind of combines all of that functionality together.


00:12:42.740 --> 00:12:46.900
So it's very easy to add pretty content.


00:12:46.900 --> 00:12:50.260
And it's not just pretty for pretty sake.


00:12:50.260 --> 00:12:53.020
Pretty can also mean more readable.


00:12:53.020 --> 00:12:57.820
You know, as developers, we get presented with pages and pages of content that we learn


00:12:57.820 --> 00:13:02.420
to decipher and pick out meaning.


00:13:02.420 --> 00:13:06.700
But we can do that much quicker if there's been some forethought into how it's presented


00:13:06.700 --> 00:13:08.100
and rendered in the terminal.


00:13:08.100 --> 00:13:11.620
And Rich does give you that capability.


00:13:11.620 --> 00:13:16.340
Yeah, absolutely.


00:13:16.340 --> 00:13:18.460
Jamie out in the audience says, "I love Rich.


00:13:18.460 --> 00:13:20.220
Rich Traceback is so helpful."


00:13:20.220 --> 00:13:23.420
Can you just quickly touch on the traceback?


00:13:23.420 --> 00:13:25.980
And then also, Demetrius is asking about,


00:13:25.980 --> 00:13:28.860
is this for Jupyter, is it only a thing for Linux terminals?


00:13:28.860 --> 00:13:32.580
And maybe sort of touch on those two things,


00:13:32.580 --> 00:13:35.420
and we'll talk textual.


00:13:35.420 --> 00:13:38.740
- Tracebacks, yeah, you can install a traceback handler,


00:13:38.740 --> 00:13:42.660
and it will capture unhandled tracebacks


00:13:42.660 --> 00:13:46.000
and present them nicely in the terminal.


00:13:47.460 --> 00:13:50.380
What was the other question?


00:13:50.380 --> 00:13:51.620
Where does this apply?


00:13:51.620 --> 00:13:52.740
Can I use this on Windows?


00:13:52.740 --> 00:13:53.580
Can I use it on Mac?


00:13:53.580 --> 00:13:54.700
Is it for Jupyter?


00:13:54.700 --> 00:13:56.100
What is this?


00:13:56.100 --> 00:13:57.060
Pretty much everywhere.


00:13:57.060 --> 00:13:59.340
So you can use it on all the major platforms--


00:13:59.340 --> 00:14:01.660
Linux, Mac, and Windows.


00:14:01.660 --> 00:14:04.180
And yes, it does work in Jupyter.


00:14:04.180 --> 00:14:10.300
So it'll convert the ANSI codes to HTML automatically.


00:14:10.300 --> 00:14:13.100
That's actually the most impressive thing to me.


00:14:13.100 --> 00:14:14.740
That must be a lot of work to maintain


00:14:14.740 --> 00:14:17.480
all these different output destinations?


00:14:17.480 --> 00:14:21.420
- The terminal is not too bad.


00:14:21.420 --> 00:14:24.260
So macOS and Linux are frankly the same


00:14:24.260 --> 00:14:25.560
as far as I'm concerned.


00:14:25.560 --> 00:14:31.220
Windows has a number of tweaks and hacks


00:14:31.220 --> 00:14:34.540
because we have this, there's two windows basically.


00:14:34.540 --> 00:14:37.140
Newer Windows has virtual terminal sequences


00:14:37.140 --> 00:14:40.660
which make it just like the Linux and Mac terminal


00:14:40.660 --> 00:14:42.320
and that's terrific.


00:14:42.320 --> 00:14:45.040
But we also support the older style terminal,


00:14:45.040 --> 00:14:47.480
which is quite limited.


00:14:47.480 --> 00:14:48.320
And there are a few--


00:14:48.320 --> 00:14:52.480
- Right, right, the cmd.exe is not nearly as powerful


00:14:52.480 --> 00:14:53.320
as the new terminal.


00:14:53.320 --> 00:14:54.840
- No, it's not.


00:14:54.840 --> 00:14:59.520
So we have to make some compromises and some sacrifices.


00:14:59.520 --> 00:15:03.160
It works, it's usable, it won't look quite as pretty.


00:15:03.160 --> 00:15:07.000
But there's a lot of people using that out there,


00:15:07.000 --> 00:15:08.840
so it's important to maintain.


00:15:08.840 --> 00:15:10.360
- Yeah, you can't really drop it.


00:15:10.360 --> 00:15:11.200
- Yeah.


00:15:11.200 --> 00:15:12.720
Can't drop it.


00:15:12.720 --> 00:15:15.600
OK, so then the other thing that's


00:15:15.600 --> 00:15:21.000
more directly related to your article and to your business,


00:15:21.000 --> 00:15:25.120
although obviously one's a building block, so same.


00:15:25.120 --> 00:15:26.360
It's Textual.


00:15:26.360 --> 00:15:27.440
Yeah.


00:15:27.440 --> 00:15:30.520
So Rich was for writing static content


00:15:30.520 --> 00:15:34.160
into your terminal, your scroll back buffer.


00:15:34.160 --> 00:15:36.440
What Textual does is it uses Rich,


00:15:36.440 --> 00:15:38.240
but it completely takes over your terminal


00:15:38.240 --> 00:15:40.640
to create an application.


00:15:40.640 --> 00:15:46.760
You don't see a command prompt, but textual will handle key presses and mouse movements


00:15:46.760 --> 00:15:53.900
and it will render quite sophisticated applications which look more like web apps than the previous


00:15:53.900 --> 00:15:56.440
generation of 2Es.


00:15:56.440 --> 00:16:02.140
But under the hood, it's using the same code that renders tables in Rich.


00:16:02.140 --> 00:16:04.460
It's kind of a, I call it a rendering engine.


00:16:04.460 --> 00:16:11.220
designed to take sort of abstract data and then turn it into what I call segments, which


00:16:11.220 --> 00:16:15.620
are basically a piece of text with a style.


00:16:15.620 --> 00:16:16.620
It's pretty amazing.


00:16:16.620 --> 00:16:22.500
You know, if you look at the UI, it's got, it really does feel a bit like a web app.


00:16:22.500 --> 00:16:27.900
It has, say, like a title bar across the top and, you know, this isn't just like text you


00:16:27.900 --> 00:16:29.540
printed out on the top of the app.


00:16:29.540 --> 00:16:30.540
No.


00:16:30.540 --> 00:16:33.420
It's stuck to the top like a nav bar, I guess, is the right word.


00:16:33.420 --> 00:16:36.960
where you have these different widgets you can put in line,


00:16:36.960 --> 00:16:38.760
like code highlighting.


00:16:38.760 --> 00:16:44.080
You've got text widgets with scrolling within scrolling.


00:16:44.080 --> 00:16:48.280
You've got animated sidebars that pop out.


00:16:48.280 --> 00:16:49.920
All these cool different aspects, right?


00:16:49.920 --> 00:16:53.800
Even a hotkey support for D to toggle dark and light mode


00:16:53.800 --> 00:16:55.160
if you want.


00:16:55.160 --> 00:16:56.160
Yeah.


00:16:56.160 --> 00:16:58.480
We've even got data tables now, which are pretty cool.


00:16:58.480 --> 00:17:01.280
They look kind of like little Excel Windows type


00:17:01.280 --> 00:17:03.400
of spreadsheets, which you can put lots of data in.


00:17:03.400 --> 00:17:13.200
in. So it is, my background is as a web developer basically. So I wanted to make something which


00:17:13.200 --> 00:17:17.920
anyone who knows how to use the web, which is pretty much everyone, they would be comfortable


00:17:17.920 --> 00:17:22.280
using one of these applications. You could just sit them down in front of it and they'll


00:17:22.280 --> 00:17:26.320
know exactly what to do. They'll know that this is a menu, they can click that. Here's


00:17:26.320 --> 00:17:30.320
a scroll bar, they'll know how to use the scroll bar. It'll work with a mouse wheel


00:17:30.320 --> 00:17:34.040
or two fingered scroll on a trackpad.


00:17:34.040 --> 00:17:36.080
It'll just be very, very familiar.


00:17:36.080 --> 00:17:39.160
But at the same time, I also want to keep it


00:17:39.160 --> 00:17:42.440
keyboard focused, because one of the benefits of a TUI


00:17:42.440 --> 00:17:46.080
is it doesn't interrupt your flow.


00:17:46.080 --> 00:17:49.060
You know, you can be at the terminal typing commands,


00:17:49.060 --> 00:17:52.560
enter into a TUI, and you could work with that


00:17:52.560 --> 00:17:54.600
and use the keyboard, and they can drop back


00:17:54.600 --> 00:17:56.440
straight into the command line.


00:17:56.440 --> 00:17:59.960
So it's kind of this marriage of the command line


00:17:59.960 --> 00:18:06.960
and more sophisticated applications which work a lot like desktop and web.


00:18:06.960 --> 00:18:13.160
Yeah. Previously when people wanted to create apps like this, one, it was very difficult


00:18:13.160 --> 00:18:18.460
to do. But if they wanted to come somewhat close to these types of things, they would


00:18:18.460 --> 00:18:22.080
use a library called Curses or something like that, right?


00:18:22.080 --> 00:18:28.880
Yeah. And Curses has been around for a long time, I think decades. I can't remember off


00:18:28.880 --> 00:18:32.880
top of my head, but I think from the 90s it came around.


00:18:32.880 --> 00:18:36.440
And people have done some very cool things with it


00:18:36.440 --> 00:18:40.020
and there have been attempts to improve upon it.


00:18:40.020 --> 00:18:42.260
But I think still it does take,


00:18:42.260 --> 00:18:44.040
you have to be very well motivated


00:18:44.040 --> 00:18:47.140
to create an application with curses


00:18:47.140 --> 00:18:47.980
'cause you're gonna have to deal


00:18:47.980 --> 00:18:52.480
with some quite archaic issues.


00:18:52.480 --> 00:18:54.880
- Yeah, I haven't done a ton with it,


00:18:54.880 --> 00:18:58.760
but it feels to me like the equivalent of saying


00:18:58.760 --> 00:19:02.280
like textual versus curses would be like,


00:19:02.280 --> 00:19:04.940
you could either use something like Pygame


00:19:04.940 --> 00:19:06.640
where you can give some sprites


00:19:06.640 --> 00:19:08.560
and they can move around the screen,


00:19:08.560 --> 00:19:13.240
or you could fire up OpenGL or DirectX or Metal


00:19:13.240 --> 00:19:16.920
and you could start rendering pixels on your own.


00:19:16.920 --> 00:19:19.240
You could accomplish the same UI,


00:19:19.240 --> 00:19:21.320
but one is tremendously difficult.


00:19:21.320 --> 00:19:24.560
The other one kind of gives you much higher level


00:19:24.560 --> 00:19:26.960
building blocks to accomplish the same thing.


00:19:26.960 --> 00:19:27.760
Yeah, exactly.


00:19:27.760 --> 00:19:30.240
So a textual is more abstract.


00:19:30.240 --> 00:19:32.960
You don't have to plot individual characters.


00:19:32.960 --> 00:19:37.280
You just say, put a text box in this part of the screen


00:19:37.280 --> 00:19:39.440
and a button in this part of the screen.


00:19:39.440 --> 00:19:42.440
And textual handles the rest.


00:19:42.440 --> 00:19:48.720
So it's less archaic aspects of terminals


00:19:48.720 --> 00:19:52.080
that go back decades that you have to think about.


00:19:52.080 --> 00:19:55.640
Let the framework handle it and handle the differences, right?


00:19:55.640 --> 00:19:56.440
Yeah, exactly.


00:19:56.440 --> 00:19:58.320
That's what computing should be.


00:19:58.320 --> 00:20:00.840
It should make your life easier.


00:20:00.840 --> 00:20:04.560
You shouldn't have to think about decades old data.


00:20:04.560 --> 00:20:06.700
You know, you hear in science people


00:20:06.700 --> 00:20:09.800
talking about standing on the shoulders of giants,


00:20:09.800 --> 00:20:12.360
of building on Einstein, and whatever.


00:20:12.360 --> 00:20:14.960
There's nothing else that stands on the shoulders


00:20:14.960 --> 00:20:17.680
of previous work like software.


00:20:17.680 --> 00:20:20.880
It's just layers and layers and layers.


00:20:20.880 --> 00:20:22.680
We don't have to think about that anymore.


00:20:22.680 --> 00:20:25.480
We now have a different set of concepts to think in.


00:20:25.480 --> 00:20:27.880
Now let's go build, you know?


00:20:27.880 --> 00:20:30.600
>> Yeah, yeah, which is fine for the most part,


00:20:30.600 --> 00:20:33.300
as long as you don't ever have to look behind the curtain.


00:20:33.300 --> 00:20:37.880
You know, it's the same with any piece of computing.


00:20:37.880 --> 00:20:40.480
It presents a nice clean interface,


00:20:40.480 --> 00:20:41.700
but there's a lot of effort to get there.


00:20:41.700 --> 00:20:44.240
It's like an iceberg.


00:20:44.240 --> 00:20:45.640
You only see the very tip of it,


00:20:45.640 --> 00:20:48.980
but two thirds are like below the water level.


00:20:48.980 --> 00:20:52.400
>> Yeah, absolutely.


00:20:54.800 --> 00:20:58.160
Basically, if it becomes a leaky abstraction, right?


00:20:58.160 --> 00:21:00.520
And then you've got to deal with the underlying layer,


00:21:00.520 --> 00:21:01.840
but not exactly.


00:21:01.840 --> 00:21:02.800
Anyway.


00:21:02.800 --> 00:21:03.620
- Exactly.


00:21:03.620 --> 00:21:04.920
- All right.


00:21:04.920 --> 00:21:07.280
Last question, and then we'll move off.


00:21:07.280 --> 00:21:10.120
Talk about the lessons.


00:21:10.120 --> 00:21:14.280
Luca asks, "Will textual have a polyfill for blank,


00:21:14.280 --> 00:21:16.880
"like manual text blinking in terms


00:21:16.880 --> 00:21:18.720
"which don't support it or, you know?"


00:21:18.720 --> 00:21:20.440
But basically, I guess more interesting,


00:21:20.440 --> 00:21:23.040
does it have polyfills and like other ways


00:21:23.040 --> 00:21:26.720
to make stuff happen that's not naturally supported?


00:21:26.720 --> 00:21:29.960
- Yeah, you know, it could quite easily.


00:21:29.960 --> 00:21:32.620
You could set up a timer, you call setInterval,


00:21:32.620 --> 00:21:36.160
which would toggle something to show the blink


00:21:36.160 --> 00:21:37.380
or hide the blink.


00:21:37.380 --> 00:21:40.440
I don't think I want to support it in Textual


00:21:40.440 --> 00:21:42.800
'cause I don't want Textual apps to be blinking.


00:21:42.800 --> 00:21:46.040
It's a terrible user interface for the most part.


00:21:46.040 --> 00:21:48.840
The exception would be a cursor.


00:21:48.840 --> 00:21:50.440
Sometimes you want a cursor to flash


00:21:50.440 --> 00:21:52.820
so you can see where it is.


00:21:52.820 --> 00:21:56.260
I think I might leave that one up to developer to implement.


00:21:56.260 --> 00:21:58.380
And it probably is a two-line job.


00:21:58.380 --> 00:22:08.340
- I can see a future where some movie has a fake hacker UI


00:22:08.340 --> 00:22:09.940
implemented in Textual.


00:22:09.940 --> 00:22:12.580
And they probably have a blank thing about when something's


00:22:12.580 --> 00:22:14.060
going to blow up going on.


00:22:14.060 --> 00:22:15.460
All right, let's move on.


00:22:15.460 --> 00:22:16.620
Let's go through your lessons.


00:22:16.620 --> 00:22:20.900
So this is what you've been building,


00:22:20.900 --> 00:22:21.740
what you are building.


00:22:21.740 --> 00:22:24.700
and obviously worked on Rich for a long time.


00:22:24.700 --> 00:22:28.180
You've worked, you and your colleagues at the company


00:22:28.180 --> 00:22:29.520
for a year now.


00:22:29.520 --> 00:22:32.260
So tell us about the lessons.


00:22:32.260 --> 00:22:33.380
Let's go through these.


00:22:33.380 --> 00:22:39.540
- Yeah, okay, so terminals are fast.


00:22:39.540 --> 00:22:42.060
This might surprise people and I can understand why.


00:22:42.060 --> 00:22:43.240
- It surprised me.


00:22:43.240 --> 00:22:45.340
- Yeah, 'cause when you use a terminal,


00:22:45.340 --> 00:22:46.520
you type a few characters


00:22:46.520 --> 00:22:47.940
and the characters appear on screen,


00:22:47.940 --> 00:22:50.980
you hit return, you know, half a second later,


00:22:50.980 --> 00:22:53.500
you'll get a response with some text.


00:22:53.500 --> 00:22:56.420
And you don't think of terminals as being fast,


00:22:56.420 --> 00:22:58.500
but nowadays they're built on the same technology


00:22:58.500 --> 00:23:00.340
that runs video games.


00:23:00.340 --> 00:23:03.860
So it uses the GPU to update the terminal


00:23:03.860 --> 00:23:08.860
with new characters which have a background and a foreground.


00:23:08.860 --> 00:23:13.620
And it turns out that if you can write updates


00:23:13.620 --> 00:23:16.560
at 60 frames a second from the Python code,


00:23:16.560 --> 00:23:18.540
the terminal will happily display it.


00:23:20.320 --> 00:23:22.840
I was surprised at how smooth it was.


00:23:22.840 --> 00:23:25.960
We had 60 frames per second animation of something


00:23:25.960 --> 00:23:30.000
moving across the screen, and it looked silky smooth.


00:23:30.000 --> 00:23:35.800
And that was updating the entire screen, like every frame.


00:23:35.800 --> 00:23:37.080
Wow.


00:23:37.080 --> 00:23:40.920
Yeah, I'm really impressed with the fact


00:23:40.920 --> 00:23:44.680
that so many of these terminals are hardware accelerated,


00:23:44.680 --> 00:23:46.120
like GPU accelerated.


00:23:46.120 --> 00:23:48.160
And I'm just poking around--


00:23:48.160 --> 00:23:49.640
what am I running here right now?


00:23:49.640 --> 00:23:57.860
running iTerm, and has all these settings for GPU render redraws, and basically the


00:23:57.860 --> 00:24:00.360
maximum frame rate.


00:24:00.360 --> 00:24:09.500
And so things like this, it's just-- you would never expect to go find hardware acceleration


00:24:09.500 --> 00:24:11.220
features inside the terminals.


00:24:11.220 --> 00:24:12.220
But they have them.


00:24:12.220 --> 00:24:13.780
They do, yeah.


00:24:13.780 --> 00:24:18.860
And it's quite strange, because not much software takes advantage of that.


00:24:18.860 --> 00:24:22.180
I mean, your day-to-day work at the terminal,


00:24:22.180 --> 00:24:23.420
it doesn't need to be fast.


00:24:23.420 --> 00:24:25.020
It really doesn't.


00:24:25.020 --> 00:24:29.300
As long as it can add new data within a second,


00:24:29.300 --> 00:24:31.380
you're probably quite happy.


00:24:31.380 --> 00:24:33.860
So these terminals have been getting faster


00:24:33.860 --> 00:24:35.420
and faster and faster.


00:24:35.420 --> 00:24:38.220
And some of them, like I use Kitty


00:24:38.220 --> 00:24:40.940
and something called Westerm,


00:24:40.940 --> 00:24:42.460
and those are incredibly fast.


00:24:42.460 --> 00:24:46.920
They're really optimized at getting things on the screen.


00:24:48.140 --> 00:24:50.060
But most software--


00:24:50.060 --> 00:24:51.620
Yes, Kiddy's excellent.


00:24:51.620 --> 00:24:52.620
It's super fast.


00:24:52.620 --> 00:24:55.060
But most software doesn't need it.


00:24:55.060 --> 00:24:59.540
It's like you use Vim or Htop.


00:24:59.540 --> 00:25:02.940
Htop updates once a second.


00:25:02.940 --> 00:25:05.500
So it's like the developers of these terminals


00:25:05.500 --> 00:25:08.140
are making it faster and faster and faster.


00:25:08.140 --> 00:25:11.740
But there's very little software that makes use of it,


00:25:11.740 --> 00:25:14.540
except for like sort of hobbyist demos


00:25:14.540 --> 00:25:17.260
where they do like video to text things.


00:25:17.260 --> 00:25:21.100
So you can see your face that's made up with ASCII characters,


00:25:21.100 --> 00:25:22.740
which is fun.


00:25:22.740 --> 00:25:25.900
But you don't think-- that's not really productivity software.


00:25:25.900 --> 00:25:29.300
So I was very pleased that when I started working on Textual


00:25:29.300 --> 00:25:34.100
that it wasn't a bottleneck.


00:25:34.100 --> 00:25:36.500
If I could write things fast enough to terminal,


00:25:36.500 --> 00:25:40.700
the terminal would happily accept it and render it.


00:25:40.700 --> 00:25:41.740
Yeah.


00:25:41.740 --> 00:25:46.300
So that opens the possibility for so many things


00:25:46.300 --> 00:25:49.700
if you can get high frame rates.


00:25:49.700 --> 00:25:54.060
You know, and the iTerm default was limit frames


00:25:54.060 --> 00:25:55.940
to 60 frames a second.


00:25:55.940 --> 00:25:58.620
60 frames a second, that's plenty fine


00:25:58.620 --> 00:26:00.940
for really smooth animations.


00:26:00.940 --> 00:26:01.780
- Yeah, yeah.


00:26:01.780 --> 00:26:03.100
- And you know, I think it's probably


00:26:03.100 --> 00:26:06.060
what my LCD monitor is stuck at, right?


00:26:06.060 --> 00:26:09.820
So that's as fast as you're gonna see it basically anyway.


00:26:09.820 --> 00:26:11.820
- That's it, and it can't,


00:26:11.820 --> 00:26:14.260
there's not much use in it being any faster


00:26:14.260 --> 00:26:17.220
because in order to see greater than 60 frames a second,


00:26:17.220 --> 00:26:19.980
you have to have something that's moving


00:26:19.980 --> 00:26:22.900
at greater than 60 frames a second.


00:26:22.900 --> 00:26:27.060
And generally, you don't want things


00:26:27.060 --> 00:26:29.660
flying about your terminal,


00:26:29.660 --> 00:26:31.660
unless maybe you're making a video game.


00:26:31.660 --> 00:26:34.500
We use animation quite sparingly


00:26:34.500 --> 00:26:39.660
for nice kind of things like when a panel slides in,


00:26:39.660 --> 00:26:44.180
the sidebar pops in, it's quite smooth.


00:26:44.180 --> 00:26:47.860
We can also use it for fades, so we can set the opacity


00:26:47.860 --> 00:26:51.820
of a block of text and have it fade away and fade in again.


00:26:51.820 --> 00:26:53.620
And that's sometimes quite useful


00:26:53.620 --> 00:26:56.660
if you want to draw the user's attention


00:26:56.660 --> 00:26:59.300
to the fact that you've added a new item


00:26:59.300 --> 00:27:01.980
rather than having it appear immediately.


00:27:01.980 --> 00:27:03.620
It'll fade in.


00:27:03.620 --> 00:27:06.340
So we can use animation in those places.


00:27:06.340 --> 00:27:10.580
But again, it doesn't need to be anywhere near


00:27:10.580 --> 00:27:11.840
60 frames a second.


00:27:13.200 --> 00:27:15.400
No, it doesn't have to, but I do agree that


00:27:15.400 --> 00:27:19.240
little bits of animation are super important


00:27:19.240 --> 00:27:23.920
for making, for highlighting things


00:27:23.920 --> 00:27:26.680
that people need to pay attention to without much effort.


00:27:26.680 --> 00:27:29.440
And it doesn't have to be so bright colored


00:27:29.440 --> 00:27:31.280
or right in the way, right?


00:27:31.280 --> 00:27:34.240
If you just have a little thing slide down that says,


00:27:34.240 --> 00:27:36.720
you know, this job is finished


00:27:36.720 --> 00:27:38.520
while the other work is happening or whatever,


00:27:38.520 --> 00:27:40.280
like that's really nice.


00:27:40.280 --> 00:27:43.720
And you have a video here in this article,


00:27:43.720 --> 00:27:47.560
the seven things article that we'll link to, obviously.


00:27:47.560 --> 00:27:51.320
And it shows you running this thing called basic pie.


00:27:51.320 --> 00:27:53.280
Is this included with textual or is it?


00:27:53.280 --> 00:27:57.640
- Yeah, that's one of our sandbox apps.


00:27:57.640 --> 00:27:59.440
So whenever we're testing something,


00:27:59.440 --> 00:28:01.560
we just put it in basic.pie.


00:28:01.560 --> 00:28:05.760
So it shows off like a number of the features we've got.


00:28:05.760 --> 00:28:06.720
I think that video is quite old.


00:28:06.720 --> 00:28:08.320
We've got some more cool stuff.


00:28:08.320 --> 00:28:11.040
- I'm sure you do.


00:28:11.040 --> 00:28:12.780
But one of the things that's really nice


00:28:12.780 --> 00:28:15.560
is it shows a lot of the animations.


00:28:15.560 --> 00:28:19.240
And one of the animations is changing the theme.


00:28:19.240 --> 00:28:22.140
Another one is to pop out the side navigation.


00:28:22.140 --> 00:28:24.440
And those are really nice, right?


00:28:24.440 --> 00:28:27.620
The fact that that happens at a frame rate fast enough


00:28:27.620 --> 00:28:29.240
that it looks completely smooth


00:28:29.240 --> 00:28:32.320
means it doesn't just look like some terminal app


00:28:32.320 --> 00:28:35.160
where a thing clicks in and then it clicks out.


00:28:35.160 --> 00:28:39.480
it actually feels really nice and polished.


00:28:39.480 --> 00:28:40.240
Yeah.


00:28:40.240 --> 00:28:40.840
Yeah.


00:28:40.840 --> 00:28:42.600
We've kind of identified--


00:28:42.600 --> 00:28:46.120
there's like a sliding scale of animation.


00:28:46.120 --> 00:28:48.800
At one end, you've got the scroll bars.


00:28:48.800 --> 00:28:51.120
It might not be obvious, but those animate.


00:28:51.120 --> 00:28:55.680
So if you click below it, it'll scroll smoothly downwards.


00:28:55.680 --> 00:28:57.160
And also, it'll filter--


00:28:57.160 --> 00:29:00.720
when you click and drag, it'll filter frames


00:29:00.720 --> 00:29:03.200
between the motion of the mouse.


00:29:03.200 --> 00:29:05.880
and it makes the scrolling look a lot more smooth.


00:29:05.880 --> 00:29:09.280
So that's not obvious, but that is a use of animation.


00:29:09.280 --> 00:29:10.480
And at that end of the scale,


00:29:10.480 --> 00:29:15.120
I think most people would agree that's good, that's a bonus.


00:29:15.120 --> 00:29:15.940
At the other end of the scale,


00:29:15.940 --> 00:29:18.440
we've got things which are a bit gratuitous,


00:29:18.440 --> 00:29:20.560
like the sidebar.


00:29:20.560 --> 00:29:23.200
I like it, but some people might think,


00:29:23.200 --> 00:29:25.280
I don't want to be distracted by this animation.


00:29:25.280 --> 00:29:27.680
I just want it to appear instantly.


00:29:27.680 --> 00:29:31.980
I want it to feel more snappy rather than animated.


00:29:31.980 --> 00:29:33.000
So I think what we're gonna do


00:29:33.000 --> 00:29:36.480
is we're going to have a switch where you can decide as a user


00:29:36.480 --> 00:29:38.960
what kind of animation you like.


00:29:38.960 --> 00:29:41.520
If you just want the scroll bars,


00:29:41.520 --> 00:29:43.480
you can set it to be quite low.


00:29:43.480 --> 00:29:46.800
And that would make the sidebar pop in instantly and disappear


00:29:46.800 --> 00:29:48.240
instantly.


00:29:48.240 --> 00:29:49.640
But if you love the animation, you


00:29:49.640 --> 00:29:51.640
can just whack it up to the maximum.


00:29:51.640 --> 00:29:53.520
And then it will use animation wherever


00:29:53.520 --> 00:29:57.160
it can for fading and sliding, et cetera.


00:29:57.160 --> 00:29:59.400
Fantastic.


00:29:59.400 --> 00:30:02.600
So for example, with a scroll bar,


00:30:02.600 --> 00:30:04.920
That's not actually the terminal scrolling it.


00:30:04.920 --> 00:30:09.560
That's textual redrawing the screen and reprocessing it.


00:30:09.560 --> 00:30:12.920
If it's not smooth, if it just goes clunk, clunk, clunk,


00:30:12.920 --> 00:30:17.080
it's super hard to track when I scroll down,


00:30:17.080 --> 00:30:21.440
where do I continue from and that kind of stuff, right?


00:30:21.440 --> 00:30:24.320
It's not just there to make it feel good or feel smooth.


00:30:24.320 --> 00:30:27.560
It really has important-- - It's not just icons.


00:30:27.560 --> 00:30:31.400
- Yeah, yeah, exactly. - If you press the page down,


00:30:31.400 --> 00:30:33.100
If it was to jump down instantly,


00:30:33.100 --> 00:30:38.080
you wouldn't be able to find your place in the text again.


00:30:38.080 --> 00:30:39.520
Your eye would just,


00:30:39.520 --> 00:30:42.880
we'd have to like focus in to find where you're reading.


00:30:42.880 --> 00:30:47.160
But if it scrolls in over say 300 milliseconds,


00:30:47.160 --> 00:30:50.420
your eye tends to follow where you were reading.


00:30:50.420 --> 00:30:53.720
So you move your eye, you follow the animation,


00:30:53.720 --> 00:30:55.920
and then you're sort of reading again from the top.


00:30:55.920 --> 00:30:58.040
And that's actually beneficial.


00:30:58.040 --> 00:30:59.240
It's not just eye candy.


00:30:59.240 --> 00:31:04.160
It's not just a gratuitous use of a feature, you know?


00:31:04.160 --> 00:31:05.000
- Yeah, absolutely.


00:31:05.000 --> 00:31:06.600
It's very, very helpful.


00:31:06.600 --> 00:31:09.840
So you talked about all of this happening


00:31:09.840 --> 00:31:12.140
without flickering in the terminal.


00:31:12.140 --> 00:31:16.120
And we already discussed the GPU accelerated,


00:31:16.120 --> 00:31:17.600
hardware accelerated aspects,


00:31:17.600 --> 00:31:20.360
but you said also that's not necessarily enough.


00:31:20.360 --> 00:31:24.600
So there's a couple of tricks that you highlight here.


00:31:24.600 --> 00:31:29.600
Yeah, so the protocol of terminals


00:31:29.600 --> 00:31:31.800
came about over many decades


00:31:31.800 --> 00:31:35.520
and it wasn't designed to avoid flickering.


00:31:35.520 --> 00:31:38.400
I think when people built the protocol--


00:31:38.400 --> 00:31:40.560
They never imagined what you would be trying to do with it.


00:31:40.560 --> 00:31:42.480
No, they didn't think someone was gonna be animating it


00:31:42.480 --> 00:31:44.160
at 60 frames a second.


00:31:44.160 --> 00:31:49.000
So there's no, well, there's very little help


00:31:49.000 --> 00:31:50.760
to reduce flicker.


00:31:50.760 --> 00:31:53.400
So there's a few things that you can do.


00:31:53.400 --> 00:31:58.360
One I've discovered is it's better to overwrite content


00:31:58.360 --> 00:31:59.760
without clearing it.


00:31:59.760 --> 00:32:02.480
So if you want to animate, say a piece of text,


00:32:02.480 --> 00:32:05.680
make it move, you might think I'll clear this text


00:32:05.680 --> 00:32:07.760
and it'll draw on top of it.


00:32:07.760 --> 00:32:11.080
But what that does is it'll introduce a potential


00:32:11.080 --> 00:32:14.160
for a frame where you see where it's cleared.


00:32:14.160 --> 00:32:16.560
And then you see the frame where it's updated


00:32:16.560 --> 00:32:18.520
and that'll cause a flicker.


00:32:18.520 --> 00:32:22.440
So if you just overwrite the content without clearing it,


00:32:22.440 --> 00:32:25.420
then that reduces the chance of flickering.


00:32:25.420 --> 00:32:28.560
- Yeah, I've also seen sometimes


00:32:28.560 --> 00:32:30.360
some of these like progress bars


00:32:30.360 --> 00:32:33.480
or the like little tables updating,


00:32:33.480 --> 00:32:36.000
they seem to write new whole sections


00:32:36.000 --> 00:32:38.520
and it's like filling your history


00:32:38.520 --> 00:32:40.960
with every frame, you know,


00:32:40.960 --> 00:32:44.160
your terminal history is like full of every frame


00:32:44.160 --> 00:32:46.680
and stuff like that if you start to resize it


00:32:46.680 --> 00:32:48.880
and there's all this weird stuff that happens


00:32:48.880 --> 00:32:50.880
if you're not actually overriding it.


00:32:50.880 --> 00:32:54.400
Well, textual goes into what's called application mode.


00:32:54.400 --> 00:32:56.480
This is a feature of terminals.


00:32:56.480 --> 00:32:57.920
So when you're in application mode,


00:32:57.920 --> 00:33:00.680
you don't have a scroll back buffer.


00:33:00.680 --> 00:33:03.160
The scroll back buffer has that problem.


00:33:03.160 --> 00:33:05.320
It'll tend to fill up with garbage


00:33:05.320 --> 00:33:08.080
if you're trying to animate things.


00:33:08.080 --> 00:33:10.280
And it's also quicker because the terminal doesn't


00:33:10.280 --> 00:33:14.920
have to worry about appending data and moving it, et cetera.


00:33:14.920 --> 00:33:19.840
So textual goes into application mode.


00:33:19.840 --> 00:33:24.240
and it's generally much faster and able to reduce that flickering.


00:33:24.240 --> 00:33:28.240
- Trick two? - The trick two.


00:33:28.240 --> 00:33:34.040
So, one of the problems with the protocol


00:33:34.040 --> 00:33:37.040
is that it's not aware of flickering,


00:33:37.040 --> 00:33:39.240
it doesn't know when to paint the screen.


00:33:39.240 --> 00:33:43.240
So, you're sending it data, it needs to know when to update the screen.


00:33:43.240 --> 00:33:47.040
If you write lots of small pieces of data,


00:33:47.040 --> 00:33:48.640
say you're going to update a character over here,


00:33:48.640 --> 00:33:53.320
you're gonna update a progress bar here, it might update a few of them and then


00:33:53.320 --> 00:33:57.720
paint the screen and then update some others and paint the screen and it's


00:33:57.720 --> 00:34:02.520
that brief moment where you've got half an update which is what causes flicker.


00:34:02.520 --> 00:34:08.160
So what I've discovered is if you batch all your updates into one write, so you


00:34:08.160 --> 00:34:12.720
used write to standard output the ones rather than you know several writes,


00:34:12.720 --> 00:34:17.440
that will reduce the potential flicker quite a bit.


00:34:17.440 --> 00:34:18.960
- Interesting.


00:34:18.960 --> 00:34:22.520
Of course it would, and I've never really thought about it.


00:34:22.520 --> 00:34:27.520
When you're doing regular pixel-based graphics programming,


00:34:27.520 --> 00:34:31.520
you know, OpenGL, DirectX, those types of things,


00:34:31.520 --> 00:34:34.440
they often set up what's called a double-buffered mode,


00:34:34.440 --> 00:34:37.000
where you actually draw the screen on a hidden piece,


00:34:37.000 --> 00:34:40.280
and then you swap that to be in one V-sync


00:34:40.280 --> 00:34:45.200
to be the screen so you don't see the pieces streaming in


00:34:45.200 --> 00:34:45.840
as it goes.


00:34:45.840 --> 00:34:48.920
And this is the same equivalent thing for terminals, huh?


00:34:48.920 --> 00:34:50.240
It's like double-buffered.


00:34:50.240 --> 00:34:51.700
You write to it like a whole thing,


00:34:51.700 --> 00:34:53.200
and then you make it the screen.


00:34:53.200 --> 00:34:55.200
It's a very similar concept.


00:34:55.200 --> 00:34:57.280
The terminal doesn't give you that.


00:34:57.280 --> 00:34:58.880
It doesn't have an invisible buffer


00:34:58.880 --> 00:35:01.560
that you can take your time to draw to.


00:35:01.560 --> 00:35:04.040
So you have to implement that yourself.


00:35:04.040 --> 00:35:07.440
But yeah, essentially, we're implementing a double buffer.


00:35:07.440 --> 00:35:09.120
Yeah, very interesting.


00:35:09.120 --> 00:35:12.480
And the third one has to do with synchronized output.


00:35:12.480 --> 00:35:13.680
Yeah.


00:35:13.680 --> 00:35:16.600
So doing the one write thing, that's very helpful.


00:35:16.600 --> 00:35:19.080
But there's also a fairly recent addition


00:35:19.080 --> 00:35:22.080
to the protocol which helps with this.


00:35:22.080 --> 00:35:25.240
Basically, you write an escape code which says,


00:35:25.240 --> 00:35:26.680
I am beginning an update.


00:35:26.680 --> 00:35:28.240
And then you write your data.


00:35:28.240 --> 00:35:30.280
And then you write another escape code which says,


00:35:30.280 --> 00:35:32.040
I've finished the update.


00:35:32.040 --> 00:35:34.600
And between those two escape codes,


00:35:34.600 --> 00:35:35.800
the terminal won't update.


00:35:35.800 --> 00:35:38.320
It will only update at the very last moment.


00:35:38.320 --> 00:35:42.000
So that's kind of accomplishing the same thing


00:35:42.000 --> 00:35:44.320
as the double buffer, but there's


00:35:44.320 --> 00:35:46.440
protocol support for it.


00:35:46.440 --> 00:35:49.920
So we do both because not all terminals support


00:35:49.920 --> 00:35:51.920
these new escape codes.


00:35:51.920 --> 00:35:54.400
So by doing both, we can ensure that it's


00:35:54.400 --> 00:35:59.920
flicker-free on newer terminals and older terminals.


00:35:59.920 --> 00:36:01.360
Fantastic.


00:36:01.360 --> 00:36:03.800
Speaking of different terminals, Kim in the audience


00:36:03.800 --> 00:36:06.600
asks, is application mode that you talked about earlier


00:36:06.600 --> 00:36:11.600
with the buffer, a universal across all the terminals.


00:36:11.600 --> 00:36:12.600
- It is, yeah.


00:36:12.600 --> 00:36:13.920
It's been around for a long time.


00:36:13.920 --> 00:36:16.340
If you've used H top or anything like it


00:36:16.340 --> 00:36:18.440
or a full screen terminal app,


00:36:18.440 --> 00:36:19.880
that'll use application mode.


00:36:19.880 --> 00:36:21.640
- Yeah.


00:36:21.640 --> 00:36:26.720
Final question while we're on this performance thing.


00:36:26.720 --> 00:36:28.720
When will we see Doom implemented?


00:36:28.720 --> 00:36:32.040
- People keep asking that.


00:36:32.040 --> 00:36:32.880
I don't know.


00:36:32.880 --> 00:36:33.960
It might happen.


00:36:33.960 --> 00:36:35.240
I think it has to happen.


00:36:35.240 --> 00:36:38.440
I mean, Doom runs virtually everywhere.


00:36:38.440 --> 00:36:39.400
- It does.


00:36:39.400 --> 00:36:42.480
- Yeah, maybe the first Doom, maybe not Doom Eternal.


00:36:42.480 --> 00:36:44.960
- Yeah, yeah, now we're thinking the original Doom,


00:36:44.960 --> 00:36:48.160
that really was amazing, right after Castle Wolfenstein.


00:36:48.160 --> 00:36:49.040
Very good stuff.


00:36:49.040 --> 00:36:50.120
- Yeah, I loved it.


00:36:50.120 --> 00:36:52.600
- All right, so that was all some really interesting stuff


00:36:52.600 --> 00:36:56.160
about terminals, but you also have some other


00:36:56.160 --> 00:36:59.700
recommendations and discoveries that are pretty awesome,


00:36:59.700 --> 00:37:01.960
even if you're doing other types of programming.


00:37:01.960 --> 00:37:04.280
And one of them is dict views.


00:37:04.280 --> 00:37:05.120
- Yeah.


00:37:05.120 --> 00:37:06.960
Apparently I used dictviews a lot,


00:37:06.960 --> 00:37:09.120
but I didn't really know they had a special name.


00:37:09.120 --> 00:37:12.320
Tell us what are dictviews and then why are they useful?


00:37:12.320 --> 00:37:16.720
- So dictviews are the object returned from a dictionary


00:37:16.720 --> 00:37:20.880
when you call items or keys.


00:37:20.880 --> 00:37:24.160
And I think almost all Python developers have used this,


00:37:24.160 --> 00:37:26.760
but we tend to use them to iterate over


00:37:26.760 --> 00:37:28.940
to get the keys and the items.


00:37:28.940 --> 00:37:32.600
What you might not know is these are special objects.


00:37:32.600 --> 00:37:34.560
They're not just simple iterables.


00:37:34.560 --> 00:37:38.920
and they act a lot like sets, which kind of makes sense.


00:37:38.920 --> 00:37:41.240
Because if you've got a dictionary,


00:37:41.240 --> 00:37:42.600
the keys are all unique.


00:37:42.600 --> 00:37:45.160
So you can't have a repeating key.


00:37:45.160 --> 00:37:48.440
So if you've got a key view, it's set-like,


00:37:48.440 --> 00:37:52.240
which means you can do set-like operations on it.


00:37:52.240 --> 00:37:53.160
And--


00:37:53.160 --> 00:37:54.360
- Asking the quick question, like,


00:37:54.360 --> 00:37:57.120
is this thing I'm about to add in here or not?


00:37:57.120 --> 00:37:58.000
Something like that, right?


00:37:58.000 --> 00:37:59.080
- Yeah, yeah.


00:37:59.080 --> 00:38:03.520
And you can take two different,


00:38:03.520 --> 00:38:06.700
you can take a set and a key view and combine them


00:38:06.700 --> 00:38:08.020
and see the intersection,


00:38:08.020 --> 00:38:12.000
see what keys are common in both or neither.


00:38:12.000 --> 00:38:15.820
And those type of operations turned out to be very useful


00:38:15.820 --> 00:38:18.000
for what I was using it for.


00:38:18.000 --> 00:38:20.240
And to be honest, I think this might be the first time


00:38:20.240 --> 00:38:22.440
I've ever used that in Angular.


00:38:22.440 --> 00:38:25.140
It's one of the things that you read about in the notes


00:38:25.140 --> 00:38:27.680
for the latest Python and you think,


00:38:27.680 --> 00:38:29.480
I can't imagine I'll ever use that.


00:38:29.480 --> 00:38:32.120
And I didn't for years,


00:38:32.120 --> 00:38:36.480
But then I had a problem where in Textual,


00:38:36.480 --> 00:38:38.680
when we do a new update via CSS,


00:38:38.680 --> 00:38:40.520
we've got two different data structures,


00:38:40.520 --> 00:38:42.720
one with the old positions of things


00:38:42.720 --> 00:38:44.920
and then one with the new positions of things.


00:38:44.920 --> 00:38:47.720
And what we want to do is compare those two data structures


00:38:47.720 --> 00:38:51.620
and find the things which have moved or have changed size.


00:38:51.620 --> 00:38:54.440
And I started writing code for this


00:38:54.440 --> 00:38:57.120
and it wasn't straightforward code.


00:38:57.120 --> 00:38:59.840
It was a couple of hours in, I had written a lot of code


00:38:59.840 --> 00:39:00.920
and I think, "No, that's a bit too slow.


00:39:00.920 --> 00:39:03.600
It's a bit too awkward.


00:39:03.600 --> 00:39:06.560
And only then did I remember the fact


00:39:06.560 --> 00:39:10.640
that you could use these key views as set operations.


00:39:10.640 --> 00:39:13.720
And the code turned out to be almost a one-liner.


00:39:13.720 --> 00:39:18.360
And I was so happy about this.


00:39:18.360 --> 00:39:22.080
I forgot the fact I'd spent two hours writing code


00:39:22.080 --> 00:39:24.680
that I would just delete it.


00:39:24.680 --> 00:39:27.240
Let me give people an example here who are listening.


00:39:27.240 --> 00:39:28.800
So if you check out the blog post,


00:39:28.800 --> 00:39:30.000
there's a nice code example.


00:39:30.000 --> 00:39:35.440
And the UI of Textual is made up of all these widgets.


00:39:35.440 --> 00:39:37.600
They've got names like header, footer, and sidebar.


00:39:37.600 --> 00:39:42.120
And they have boundaries and regions, rectangles.


00:39:42.120 --> 00:39:44.680
And as the UI changes, you might only


00:39:44.680 --> 00:39:47.160
want to redraw the delta, not the whole thing,


00:39:47.160 --> 00:39:49.120
for performance reasons.


00:39:49.120 --> 00:39:51.920
And so given the old view and the new view,


00:39:51.920 --> 00:39:54.700
the question is, well, what widgets have changed?


00:39:54.700 --> 00:39:58.680
And so you just say, renderMap.items,


00:39:58.680 --> 00:40:04.360
caret or symmetric difference with other newer framed items.


00:40:04.360 --> 00:40:06.320
And that tells you these are the pieces that


00:40:06.320 --> 00:40:08.280
have to be redrawn, right?


00:40:08.280 --> 00:40:10.560
Yeah, that gets exactly the information needed.


00:40:10.560 --> 00:40:14.120
That tells me which things are new,


00:40:14.120 --> 00:40:16.080
which things have been removed, and then which


00:40:16.080 --> 00:40:17.960
things have changed position.


00:40:17.960 --> 00:40:20.480
And those three types of things are the things


00:40:20.480 --> 00:40:22.440
that I need to redraw on the screen.


00:40:22.440 --> 00:40:24.600
And it's a one-liner.


00:40:24.600 --> 00:40:27.720
And I get that information for free


00:40:27.720 --> 00:40:29.480
because it is very fast.


00:40:29.480 --> 00:40:33.680
It runs at the C level and produces just information


00:40:33.680 --> 00:40:35.560
that I needed.


00:40:35.560 --> 00:40:37.200
>> Yeah.


00:40:37.200 --> 00:40:40.120
Honestly, this surprises me that this is possible.


00:40:40.120 --> 00:40:42.720
I would totally expect that with .keys


00:40:42.720 --> 00:40:45.320
because keys have to be set like.


00:40:45.320 --> 00:40:47.560
But items, you could have the same item


00:40:47.560 --> 00:40:49.920
assigned to different keys all over the place and stuff.


00:40:49.920 --> 00:40:51.560
So it's a little interesting here.


00:40:51.560 --> 00:40:55.880
>> The item is, you know, obviously the key plus the value.


00:40:55.880 --> 00:40:57.800
So together, they're unique.


00:40:57.800 --> 00:40:58.640
The values are not unique.


00:40:58.640 --> 00:40:59.600
- Oh, I see, that's right,


00:40:59.600 --> 00:41:02.200
'cause that's a tuple of a key.


00:41:02.200 --> 00:41:03.360
I see.


00:41:03.360 --> 00:41:04.760
Got it, okay.


00:41:04.760 --> 00:41:06.640
- So the keys are guaranteed to be unique, therefore.


00:41:06.640 --> 00:41:08.680
- Yeah, that's, therefore, yeah,


00:41:08.680 --> 00:41:09.880
whatever you add to it,


00:41:09.880 --> 00:41:13.640
it's not gonna make it less unique by adding stuff.


00:41:13.640 --> 00:41:15.320
More possible differences.


00:41:15.320 --> 00:41:17.720
All right, so not totally related to this,


00:41:17.720 --> 00:41:20.560
but I gotta ask it 'cause it's just so meta.


00:41:20.560 --> 00:41:21.720
Andrew out in the audience asks,


00:41:21.720 --> 00:41:25.360
can you embed a terminal within a textual app?


00:41:25.360 --> 00:41:27.200
I've been asked this a few times.


00:41:27.200 --> 00:41:29.360
I'm just wondering what people want to use this for.


00:41:29.360 --> 00:41:32.680
But in theory, it should be possible.


00:41:32.680 --> 00:41:35.120
It means I'd have to write a software layer which


00:41:35.120 --> 00:41:38.680
interpreted all the escape codes and then translated that


00:41:38.680 --> 00:41:41.960
to a region of a textual app.


00:41:41.960 --> 00:41:44.720
But in theory, yes, it's possible.


00:41:44.720 --> 00:41:45.920
Will we do it?


00:41:45.920 --> 00:41:47.800
Maybe one day.


00:41:47.800 --> 00:41:51.720
It's not the highest on the priority, but maybe.


00:41:51.720 --> 00:41:52.200
Yeah, maybe.


00:41:52.200 --> 00:41:54.600
OK, very interesting.


00:41:54.600 --> 00:41:59.600
Is there something like a textual.contrib?


00:41:59.600 --> 00:42:02.480
These extras that people put in,


00:42:02.480 --> 00:42:05.600
like there's Django contrib and there's other contribs.


00:42:05.600 --> 00:42:08.520
- Yeah, not currently, but I'm really hoping


00:42:08.520 --> 00:42:11.240
that the community takes it and starts building things.


00:42:11.240 --> 00:42:14.560
So you could search PyPy for textual_


00:42:14.560 --> 00:42:17.720
and get lots of widget libraries and various add-ons.


00:42:17.720 --> 00:42:23.040
- Is there like a plugin or extension aspect?


00:42:23.040 --> 00:42:28.040
- Yes, so the widgets are designed to be built that way.


00:42:28.040 --> 00:42:32.380
Widgets are like independent portions of the screen


00:42:32.380 --> 00:42:35.040
that can handle events and things and updates.


00:42:35.040 --> 00:42:37.880
And those can be bundled up into separate libraries,


00:42:37.880 --> 00:42:39.780
third party libraries.


00:42:39.780 --> 00:42:42.340
So that would be the easiest way to implement something.


00:42:42.340 --> 00:42:45.640
You could implement anything you wish,


00:42:45.640 --> 00:42:47.620
like a full IDE if you wanted to,


00:42:47.620 --> 00:42:51.000
and just import it as a Python library.


00:42:51.000 --> 00:42:51.840
- Sure.


00:42:51.840 --> 00:43:00.160
All right, related to using DictViews for speed, it's really hard to beat caching for


00:43:00.160 --> 00:43:01.640
speed isn't it?


00:43:01.640 --> 00:43:08.920
Yeah, caching is awesome and it's one of the things which allows textual to be fast.


00:43:08.920 --> 00:43:13.560
So LRU cache, I think a lot of people have used it but maybe not appreciated how fast


00:43:13.560 --> 00:43:15.640
it is.


00:43:15.640 --> 00:43:21.560
The caching and generating the key is done at the C level, so it's super fast and you


00:43:21.560 --> 00:43:24.800
you can use it for quite small functions.


00:43:24.800 --> 00:43:28.080
We've got a lot of calculations which are pretty quick.


00:43:28.080 --> 00:43:31.520
You know, they're well under milliseconds,


00:43:31.520 --> 00:43:34.080
they're like fractions of a millisecond.


00:43:34.080 --> 00:43:35.320
But we do them a lot of times.


00:43:35.320 --> 00:43:37.680
So we might do them like 10,000 times.


00:43:37.680 --> 00:43:41.500
But if we introduce the LRU cache,


00:43:41.500 --> 00:43:45.060
the time it takes to do those function calls


00:43:45.060 --> 00:43:47.000
becomes the time it takes to essentially


00:43:47.000 --> 00:43:48.680
do a dictionary lookup.


00:43:48.680 --> 00:43:51.200
And then they become very fast.


00:43:51.200 --> 00:43:57.640
So that led to quite surprising speed ups.


00:43:57.640 --> 00:43:59.520
>>Yeah, so you have an example here


00:43:59.520 --> 00:44:06.640
that you talk about where you're given a couple of regions,


00:44:06.640 --> 00:44:11.840
and you do the intersection of those two,


00:44:11.840 --> 00:44:15.040
a region being like a rectangle-like thing.


00:44:15.040 --> 00:44:18.920
You've got to figure out, well, which is the top left most?


00:44:18.920 --> 00:44:21.680
And like all those, there's a bunch of comparisons


00:44:21.680 --> 00:44:25.800
to find the overlapping rectangle if it exists, right?


00:44:25.800 --> 00:44:30.480
- Yeah, so it's not very complicated, it's not very slow.


00:44:30.480 --> 00:44:32.240
It's just doing sort of arithmetic


00:44:32.240 --> 00:44:33.920
and it's working on local variables.


00:44:33.920 --> 00:44:35.440
That's generally the fastest kind of code


00:44:35.440 --> 00:44:37.600
you can expect from Python.


00:44:37.600 --> 00:44:42.480
You also, you create a region object


00:44:42.480 --> 00:44:44.280
which has to reserve some memory.


00:44:44.280 --> 00:44:46.840
But if you put the LRU cache on it,


00:44:46.840 --> 00:44:49.740
that becomes a DIC lookup, so it becomes very fast.


00:44:49.740 --> 00:44:54.280
And the type of calculations we're doing,


00:44:54.280 --> 00:44:57.840
we often do the same ones many, many times.


00:44:57.840 --> 00:45:01.240
So we'll use the same two values to find the intersection.


00:45:01.240 --> 00:45:03.840
Like that the first time you update the screen,


00:45:03.840 --> 00:45:05.480
you calculate some intersections,


00:45:05.480 --> 00:45:08.560
and the second time maybe one or two items is moved,


00:45:08.560 --> 00:45:11.380
but most of the same calculations are done again.


00:45:11.380 --> 00:45:14.580
So LRU cache ensures that


00:45:14.580 --> 00:45:16.320
you don't do those calculations again.


00:45:16.320 --> 00:45:18.840
you just pick them out of a dictionary.


00:45:18.840 --> 00:45:20.600
And yeah, big wins.


00:45:20.600 --> 00:45:23.880
And it's so easy to just copy that one line


00:45:23.880 --> 00:45:25.080
and everything works.


00:45:25.080 --> 00:45:30.640
- Yeah, also it's kind of related


00:45:30.640 --> 00:45:32.180
to what we're gonna get to here,


00:45:32.180 --> 00:45:35.840
but this kind of code is fantastic


00:45:35.840 --> 00:45:38.100
because in terms of caching,


00:45:38.100 --> 00:45:41.820
'cause it doesn't really depend on something


00:45:41.820 --> 00:45:43.320
that could change behind the scenes.


00:45:43.320 --> 00:45:45.820
It doesn't have hold of like weird pointers


00:45:45.820 --> 00:45:49.980
that could change in other ways.


00:45:49.980 --> 00:45:53.840
And so it's very, very deterministic.


00:45:53.840 --> 00:45:56.340
It's going to give you the same answer every time.


00:45:56.340 --> 00:46:00.060
And it's not like the cache is going to get weirdly stale,


00:46:00.060 --> 00:46:01.380
right?


00:46:01.380 --> 00:46:02.380
Yeah, exactly.


00:46:02.380 --> 00:46:05.900
So it's an immutable object.


00:46:05.900 --> 00:46:09.340
I think region is actually a named tuple.


00:46:09.340 --> 00:46:11.620
And you get all those benefits.


00:46:11.620 --> 00:46:13.340
There's no side effects.


00:46:13.340 --> 00:46:14.700
You can write these functions that


00:46:14.700 --> 00:46:19.740
got an input and an output and it doesn't depend on any other state and when you have


00:46:19.740 --> 00:46:26.180
that kind of function, I think they call it a pure function, caching works beautifully.


00:46:26.180 --> 00:46:28.780
There's no hidden surprises.


00:46:28.780 --> 00:46:33.620
And also I think it makes your code more easy to reason about.


00:46:33.620 --> 00:46:36.180
You can trace it, you know, just manually.


00:46:36.180 --> 00:46:41.580
You can tell what's going on just by looking at one function.


00:46:41.580 --> 00:46:43.820
You can see the full story.


00:46:43.820 --> 00:46:44.660
- Sure.


00:46:44.660 --> 00:46:46.380
- Yeah, immutable objects.


00:46:46.380 --> 00:46:49.260
If your code can use immutable objects,


00:46:49.260 --> 00:46:51.780
I think you should favor it.


00:46:51.780 --> 00:46:52.780
It doesn't always make sense,


00:46:52.780 --> 00:46:54.980
but immutable is definitely best.


00:46:54.980 --> 00:46:58.380
- Yeah, definitely easy to reason about.


00:46:58.380 --> 00:47:01.420
Kim in the audience says,


00:47:01.420 --> 00:47:03.900
"Presumably the memory cost of caching


00:47:03.900 --> 00:47:05.500
"many frequently called functions


00:47:05.500 --> 00:47:08.860
"isn't a big issue on a reasonable machine."


00:47:08.860 --> 00:47:09.700
- Yeah.


00:47:09.700 --> 00:47:11.900
- Maybe it's worth pointing out the max size parameter


00:47:11.900 --> 00:47:13.660
you pass to the LRU cache.


00:47:13.660 --> 00:47:16.260
That's right, so you set a maximum size


00:47:16.260 --> 00:47:18.380
and if you add more items than that,


00:47:18.380 --> 00:47:21.000
it'll throw out the oldest one.


00:47:21.000 --> 00:47:23.260
So you can define the set,


00:47:23.260 --> 00:47:26.140
the maximum size that you will record.


00:47:26.140 --> 00:47:28.340
And it depends on how you use it.


00:47:28.340 --> 00:47:34.240
If you tend to have like a common set of calculations


00:47:34.240 --> 00:47:36.620
which you're doing repeatedly,


00:47:36.620 --> 00:47:40.220
and those will kind of be in the cache most of the time.


00:47:40.220 --> 00:47:41.760
And then you might have some calculations


00:47:41.760 --> 00:47:43.140
which happen infrequently,


00:47:43.140 --> 00:47:47.060
you know, combinations of input and output.


00:47:47.060 --> 00:47:50.140
And then those get recalculated occasionally.


00:47:50.140 --> 00:47:51.820
But it's still a big win.


00:47:51.820 --> 00:47:57.300
And for 4096 items for that, the region's named Tuple.


00:47:57.300 --> 00:47:58.980
It's quite small.


00:47:58.980 --> 00:48:03.980
So that keeps the memory usage to something reasonable.


00:48:03.980 --> 00:48:05.900
Yeah, very cool.


00:48:05.900 --> 00:48:11.980
I did want to highlight this project called Async Cache.


00:48:11.980 --> 00:48:14.620
Because I think--


00:48:14.620 --> 00:48:16.260
I haven't checked lately, but I think


00:48:16.260 --> 00:48:20.020
that LRU cache is only for synchronous functions?


00:48:20.020 --> 00:48:21.420
- I think so, yeah.


00:48:21.420 --> 00:48:22.700
- Yeah, I think so too.


00:48:22.700 --> 00:48:23.620
Maybe it's been upgraded.


00:48:23.620 --> 00:48:24.500
I haven't checked.


00:48:24.500 --> 00:48:28.260
But let's just-- if it's still true,


00:48:28.260 --> 00:48:31.300
there's this project called AsyncCache,


00:48:31.300 --> 00:48:37.620
which has nearly the same UI, but applies to async functions.


00:48:37.620 --> 00:48:41.260
So basically, the decorator has to return a function, which


00:48:41.260 --> 00:48:45.020
is first checks the cache and then calls the function.


00:48:45.020 --> 00:48:47.620
For the async version, that has to be an async function


00:48:47.620 --> 00:48:51.900
returned out of the decorator, hence the difference, right?


00:48:51.900 --> 00:48:55.060
And so this async cache has something really similar,


00:48:55.060 --> 00:48:58.420
where you can have a LRU cache where you set the max size.


00:48:58.420 --> 00:49:00.100
Or you can also have a time to live,


00:49:00.100 --> 00:49:05.860
like I only want these results to stick around for 60 seconds.


00:49:05.860 --> 00:49:08.540
It also has a bunch of other interesting features


00:49:08.540 --> 00:49:13.100
that you can bring in, like works on ORM objects,


00:49:13.100 --> 00:49:14.620
request objects, a bunch of other things.


00:49:14.620 --> 00:49:18.020
It has like sort of custom support for custom types


00:49:18.020 --> 00:49:22.320
that are, you know, one of the things that this needs here


00:49:22.320 --> 00:49:24.540
is I think it's hashable.


00:49:24.540 --> 00:49:27.220
I think you have to have hashable arguments


00:49:27.220 --> 00:49:28.600
for LRU cache, yeah.


00:49:28.600 --> 00:49:32.460
- Yeah, that strikes me as something very useful.


00:49:32.460 --> 00:49:35.700
If you've got a calculation which does some awaits


00:49:35.700 --> 00:49:37.580
and you want to cache it, then yeah,


00:49:37.580 --> 00:49:39.860
That looks like a fantastic project.


00:49:39.860 --> 00:49:41.980
- Yeah, not super popular.


00:49:41.980 --> 00:49:44.540
People can check it out, but it looks pretty useful.


00:49:44.540 --> 00:49:46.620
Okay, we kind of touched on this already,


00:49:46.620 --> 00:49:48.360
so maybe we won't go too much into it,


00:49:48.360 --> 00:49:52.780
but just one of the actual lessons you said


00:49:52.780 --> 00:49:55.900
is immutability is definitely a good thing.


00:49:55.900 --> 00:49:58.620
So we can get this from tuples, named tuples,


00:49:58.620 --> 00:50:00.620
which are like better tuples.


00:50:00.620 --> 00:50:04.500
You know, you can address them by a variable type


00:50:04.500 --> 00:50:06.600
or frozen data classes.


00:50:06.600 --> 00:50:10.600
- Yeah, I tend to think immutable first.


00:50:10.600 --> 00:50:13.200
So I'll prefer to make my objects immutable.


00:50:13.200 --> 00:50:16.320
And only when I think that's gonna become a hindrance


00:50:16.320 --> 00:50:18.460
do I make them mutable.


00:50:18.460 --> 00:50:21.520
And that's, I think, I started doing that a few years ago


00:50:21.520 --> 00:50:23.240
and I think that's benefited my code.


00:50:23.240 --> 00:50:25.500
So I'd recommend immutable objects.


00:50:25.500 --> 00:50:29.400
- Yeah, and then if you're out there doing


00:50:29.400 --> 00:50:32.840
gigantic, which many of us are these days,


00:50:34.040 --> 00:50:38.440
it has faux immutability, which is kind of like it.


00:50:38.440 --> 00:50:41.120
It takes a shot at making things immutable.


00:50:41.120 --> 00:50:43.840
And you can just say a lab mutation false


00:50:43.840 --> 00:50:46.040
as the config for your Pydantic model,


00:50:46.040 --> 00:50:48.760
which is pretty fantastic.


00:50:48.760 --> 00:50:50.960
- Yeah, I think Python doesn't support


00:50:50.960 --> 00:50:54.300
true immutability, immutability.


00:50:54.300 --> 00:50:57.240
If you really wanted to, you could do some horrible hack


00:50:57.240 --> 00:50:59.900
to change an object, which should be immutable.


00:51:01.280 --> 00:51:03.240
But you know, like Python's philosophies,


00:51:03.240 --> 00:51:04.320
we're all adults here, right?


00:51:04.320 --> 00:51:07.020
So don't do crazy things like that.


00:51:07.020 --> 00:51:12.960
- And even for languages that have like the word const


00:51:12.960 --> 00:51:16.220
and stuff, it still doesn't necessarily mean


00:51:16.220 --> 00:51:18.400
what you think it means.


00:51:18.400 --> 00:51:20.360
There's a little bit of Monty Python going on.


00:51:20.360 --> 00:51:23.760
No, princess bride sort of thing going on there


00:51:23.760 --> 00:51:27.720
where, okay, so this object says it can't be mutable


00:51:27.720 --> 00:51:29.520
and it has pointers to other objects.


00:51:29.520 --> 00:51:31.440
And so sure, you can't reassign those pointers,


00:51:31.440 --> 00:51:33.000
but that thing points to something


00:51:33.000 --> 00:51:35.000
which points to something, which internally you


00:51:35.000 --> 00:51:36.600
call a function which changes.


00:51:36.600 --> 00:51:37.460
You know what I mean?


00:51:37.460 --> 00:51:42.160
Like, to get true immutability is super hard and super


00:51:42.160 --> 00:51:42.680
restrictive.


00:51:42.680 --> 00:51:43.280
So--


00:51:43.280 --> 00:51:44.720
Super hard, yeah.


00:51:44.720 --> 00:51:48.320
So Python isn't too bad in that respect.


00:51:48.320 --> 00:51:52.760
It's definitely safer than C, C++, et cetera.


00:51:52.760 --> 00:51:54.480
That's for sure.


00:51:54.480 --> 00:51:56.000
OK, immutability is good.


00:51:56.000 --> 00:51:58.480
So is Unicode art.


00:51:58.480 --> 00:52:00.640
What the heck is this?


00:52:00.640 --> 00:52:03.680
So in the textual code, there's quite a lot


00:52:03.680 --> 00:52:08.080
of functions like this, which are kind of geometric.


00:52:08.080 --> 00:52:10.800
So it might divide something into two or--


00:52:10.800 --> 00:52:12.880
Yeah, it's always doing visual things, right?


00:52:12.880 --> 00:52:14.080
Quite a lot of visual things.


00:52:14.080 --> 00:52:16.200
So here we've got an example.


00:52:16.200 --> 00:52:18.000
It's a function which takes a region


00:52:18.000 --> 00:52:20.880
and splits it into four by making two--


00:52:20.880 --> 00:52:23.560
making a horizontal and a vertical cut.


00:52:23.560 --> 00:52:28.200
And that's quite hard to express in English succinctly.


00:52:28.200 --> 00:52:31.640
I mean, you can do it, but it'll take you like a big paragraph.


00:52:31.640 --> 00:52:36.120
But if you create something like this, this kind of Unicode art


00:52:36.120 --> 00:52:39.120
using various box characters, you


00:52:39.120 --> 00:52:43.600
can draw a diagram to show what you're doing.


00:52:43.600 --> 00:52:46.760
And if you're coming to that code later,


00:52:46.760 --> 00:52:49.480
that just makes it really obvious at a glance


00:52:49.480 --> 00:52:51.000
what it's doing.


00:52:51.000 --> 00:52:56.080
So I'm a big fan of that kind of Unicode art.


00:52:56.080 --> 00:53:01.000
And I use an application called Monodraw, which is macOS only,


00:53:01.000 --> 00:53:02.480
but there are similar applications


00:53:02.480 --> 00:53:04.960
for other platforms.


00:53:04.960 --> 00:53:08.120
And yeah, I use it wherever I can, also


00:53:08.120 --> 00:53:11.160
because it's kind of fun.


00:53:11.160 --> 00:53:16.000
It has got a powerful ASCII art editor designed for the Mac.


00:53:16.000 --> 00:53:19.520
It costs money, $9 and $10.


00:53:19.520 --> 00:53:21.080
I love that it has educational pricing,


00:53:21.080 --> 00:53:24.600
but it only costs $10.


00:53:24.600 --> 00:53:25.680
That's kind of cool.


00:53:25.680 --> 00:53:29.120
But yeah, it's pretty neat.


00:53:29.120 --> 00:53:32.720
I guess you have little arrows and boxes.


00:53:32.720 --> 00:53:37.080
And just like you might draw with PowerPoint or Keynote


00:53:37.080 --> 00:53:39.280
or something like that as kind of your--


00:53:39.280 --> 00:53:41.560
let me put together a visual graphic.


00:53:41.560 --> 00:53:43.960
But the output is ASCII art.


00:53:43.960 --> 00:53:46.720
Yeah, and it's kind of like a vector graphic type thing.


00:53:46.720 --> 00:53:50.680
So if you draw a box, you can click on the box and drag it.


00:53:50.680 --> 00:53:52.640
It's not like a bitmap.


00:53:52.640 --> 00:53:53.280
So I find it--


00:53:53.280 --> 00:53:54.120
Oh, that's fantastic.


00:53:54.120 --> 00:53:58.040
Yeah, it's quite powerful.


00:53:58.040 --> 00:54:00.520
I hope the authors made a fortune out of it, frankly,


00:54:00.520 --> 00:54:03.160
because I love it.


00:54:03.160 --> 00:54:04.400
So what is the output like?


00:54:04.400 --> 00:54:06.920
You output to clipboard?


00:54:06.920 --> 00:54:08.520
Yeah, you can cut and paste it.


00:54:08.520 --> 00:54:09.680
You can output to clipboard.


00:54:09.680 --> 00:54:11.360
You can write it to a text file.


00:54:11.360 --> 00:54:15.640
I usually cut and paste it directly into Python code.


00:54:15.640 --> 00:54:16.720
Yeah, of course.


00:54:16.720 --> 00:54:17.640
So that's really cool.


00:54:17.640 --> 00:54:19.880
It also made me think of something that's not exactly


00:54:19.880 --> 00:54:23.240
the same purpose, but balsamic.


00:54:23.240 --> 00:54:27.040
I don't know if you're familiar with Balsamiq, which is really great for developing UIs.


00:54:27.040 --> 00:54:30.040
I don't know if they have a gallery or something.


00:54:30.040 --> 00:54:34.840
They need some more graphics on this thing here.


00:54:34.840 --> 00:54:37.440
>> Yeah, I've used Balsamiq for a while.


00:54:37.440 --> 00:54:39.800
It's been around for a long time, hasn't it?


00:54:39.800 --> 00:54:41.080
>> It's been around forever, yeah.


00:54:41.080 --> 00:54:47.800
But it basically lets you create UIs that look almost like as if they were created using


00:54:47.800 --> 00:54:48.800
ASCII art.


00:54:48.800 --> 00:54:52.640
Not quite, but it's an interesting goal.


00:54:52.640 --> 00:54:59.480
I did also want to highlight the most useful piece of ASCII art.


00:54:59.480 --> 00:55:03.280
To be clear, all of this discussion is what goes in the comments, right?


00:55:03.280 --> 00:55:06.960
What goes in the code comments or the doc strings?


00:55:06.960 --> 00:55:12.360
The one for the object allocator in Python.


00:55:12.360 --> 00:55:18.280
So if you look in obmalloc.c in CPython,


00:55:18.280 --> 00:55:23.440
there's all this fairly intense looking code


00:55:23.440 --> 00:55:29.720
for allocating memory when it's particular CPython objects,


00:55:29.720 --> 00:55:34.640
like a pyobject or pylong or whatever.


00:55:34.640 --> 00:55:36.680
If you scroll down to the section here,


00:55:36.680 --> 00:55:40.920
around line 777, it has a paragraph.


00:55:40.920 --> 00:55:43.400
It says, "An object allocator for Python.


00:55:43.400 --> 00:55:45.120
Here's an introduction to the layers


00:55:45.120 --> 00:55:47.800
of Python's memory architecture, et cetera."


00:55:47.800 --> 00:55:50.000
And instead of having an essay in here,


00:55:50.000 --> 00:55:52.600
it has this incredible graphic


00:55:52.600 --> 00:55:56.520
that is like vertically aligned and shows you,


00:55:56.520 --> 00:55:59.060
here's where we allocate things like integers and lists,


00:55:59.060 --> 00:56:02.880
and here's Python core non-object memory allocation,


00:56:02.880 --> 00:56:05.400
and here's how it relates down to the OS


00:56:05.400 --> 00:56:06.960
into actual hardware.


00:56:06.960 --> 00:56:08.520
What do you think of this?


00:56:08.520 --> 00:56:09.640
- That's pretty awesome.


00:56:09.640 --> 00:56:10.760
A lot of respect to the author


00:56:10.760 --> 00:56:13.400
because I'm fairly sure they didn't use Monodraw.


00:56:13.400 --> 00:56:15.320
I think they did that by hand,


00:56:15.320 --> 00:56:18.640
you know, typing the characters and spaces and everything.


00:56:18.640 --> 00:56:20.080
So yeah, it's pretty awesome.


00:56:20.080 --> 00:56:22.800
- Yeah, I think this is really fantastic.


00:56:22.800 --> 00:56:25.520
I was trying to piece together,


00:56:25.520 --> 00:56:27.480
you know, I did a course on Python memory


00:56:27.480 --> 00:56:28.680
and I was trying to piece together like,


00:56:28.680 --> 00:56:32.160
well, how do I visually represent how it is described


00:56:32.160 --> 00:56:33.200
that the memory works?


00:56:33.200 --> 00:56:34.920
And I'm like, well, let me go look in the source code.


00:56:34.920 --> 00:56:38.120
And I was looking at this like, there's an actual picture here.


00:56:38.120 --> 00:56:39.080
This is amazing.


00:56:39.080 --> 00:56:40.280
I can't believe it.


00:56:40.280 --> 00:56:41.560
So, so neat.


00:56:41.560 --> 00:56:42.840
Yeah.


00:56:42.840 --> 00:56:45.120
So anyway, if people need a concrete example


00:56:45.120 --> 00:56:47.160
of the type of stuff you're talking about,


00:56:47.160 --> 00:56:49.440
here's one that's pretty close to home.


00:56:49.440 --> 00:56:51.400
We all use it every day and we didn't know.


00:56:51.400 --> 00:56:51.900
>> Cool.


00:56:51.900 --> 00:56:56.720
>> Fractions.


00:56:56.720 --> 00:56:59.840
I was always amazed at the fact that 0.1 plus 0.1 plus 0.1


00:56:59.840 --> 00:57:01.440
is not equal to 0.3.


00:57:01.440 --> 00:57:03.200
I learned that in school and it was,


00:57:03.200 --> 00:57:04.560
but for some reason it's not.


00:57:04.560 --> 00:57:05.760
What do you think?


00:57:05.760 --> 00:57:07.800
- Yeah, so this is a problem that goes,


00:57:07.800 --> 00:57:11.320
this is not just Python, it's pretty much any language


00:57:11.320 --> 00:57:12.580
which uses floats and doubles,


00:57:12.580 --> 00:57:14.480
which is like almost all of them.


00:57:14.480 --> 00:57:18.160
And it trips up beginners and experienced developers.


00:57:18.160 --> 00:57:20.200
It tripped up me when I was working on textual,


00:57:20.200 --> 00:57:23.320
we have lots of code which will divide the screen


00:57:23.320 --> 00:57:24.840
into various proportions.


00:57:24.840 --> 00:57:27.960
So you might have a third and then a two thirds


00:57:27.960 --> 00:57:31.000
and you might divide the height into sevenths.


00:57:31.000 --> 00:57:33.000
And what I found was that when I use floats,


00:57:33.000 --> 00:57:34.500
got a lot of rounding error.


00:57:34.500 --> 00:57:36.080
Actually, not a lot of rounding error,


00:57:36.080 --> 00:57:37.760
but occasional rounding error, which


00:57:37.760 --> 00:57:41.920
means it wouldn't draw a line or it wouldn't draw a column.


00:57:41.920 --> 00:57:45.160
Because this kind of issue where the rounding error


00:57:45.160 --> 00:57:48.760
is compounded, and then it's been rounded down


00:57:48.760 --> 00:57:51.360
to the nearest character.


00:57:51.360 --> 00:57:52.680
Right.


00:57:52.680 --> 00:57:55.240
You've got to talk in little block pieces anyway.


00:57:55.240 --> 00:57:57.440
And if it just misses it, right?


00:57:57.440 --> 00:58:00.360
If it just misses it by 0.0000001,


00:58:00.360 --> 00:58:03.480
then you'll be a whole character out.


00:58:03.480 --> 00:58:06.400
And I did come up with various ways of solving this


00:58:06.400 --> 00:58:08.880
where I used integers rather than floats


00:58:08.880 --> 00:58:11.960
and kept track of the error,


00:58:11.960 --> 00:58:14.320
which I think is the standard approach of doing it,


00:58:14.320 --> 00:58:15.560
but it was quite tricky code


00:58:15.560 --> 00:58:19.840
and I'd get it wrong too frequently.


00:58:19.840 --> 00:58:22.000
But then I remembered fractions.


00:58:22.000 --> 00:58:25.880
So fractions, they behave just like numbers,


00:58:25.880 --> 00:58:29.520
but they start out life as a numerator and denominator.


00:58:29.520 --> 00:58:33.080
So you have fraction 1, 2 equals 1/2.


00:58:33.080 --> 00:58:35.840
And the great thing about fractions in the standard


00:58:35.840 --> 00:58:38.520
library is they don't suffer from that rounding error.


00:58:38.520 --> 00:58:45.920
So if you have 3 1/10, it'll add up to 3/10 exactly


00:58:45.920 --> 00:58:48.080
with no rounding error.


00:58:48.080 --> 00:58:51.160
And it makes that kind of code, which I do a lot of in


00:58:51.160 --> 00:58:54.000
Textual, to be much simpler.


00:58:54.000 --> 00:58:58.480
So I was very happy when I re-remembered it, because I


00:58:58.480 --> 00:59:02.820
must have known years ago and thought, "Why do I need fractions?"


00:59:02.820 --> 00:59:03.820
Yeah, exactly.


00:59:03.820 --> 00:59:04.820
Yeah.


00:59:04.820 --> 00:59:06.740
This is not elementary school.


00:59:06.740 --> 00:59:07.740
I don't need this.


00:59:07.740 --> 00:59:08.740
Go on.


00:59:08.740 --> 00:59:09.740
A lot of Python is like that.


00:59:09.740 --> 00:59:10.740
We can just say point one.


00:59:10.740 --> 00:59:11.740
Yeah.


00:59:11.740 --> 00:59:15.980
So you learn that you think, "Well, that's probably useful to mathematicians or something


00:59:15.980 --> 00:59:18.980
or someone else, not to me."


00:59:18.980 --> 00:59:23.620
But if you work long enough, you'll eventually find a problem where that is actually the


00:59:23.620 --> 00:59:25.740
perfect solution for it.


00:59:25.740 --> 00:59:26.740
Yeah.


00:59:26.740 --> 00:59:28.140
I didn't know about these either.


00:59:28.140 --> 00:59:34.740
I see comments in the audience as well, like, fractions, what is this madness?


00:59:34.740 --> 00:59:39.460
So you're telling us that you can only work in rational numbers, not, you know, irrational


00:59:39.460 --> 00:59:40.820
numbers like pi and e.


00:59:40.820 --> 00:59:46.020
We can't have, can't have, yeah, columns that are e wide.


00:59:46.020 --> 00:59:48.700
No, no, you can't.


00:59:48.700 --> 00:59:52.300
Or pi high, you know.


00:59:52.300 --> 00:59:53.300
It's pi by e.


00:59:53.300 --> 00:59:54.300
No, it's cut off.


00:59:54.300 --> 00:59:55.300
Darn it.


00:59:55.300 --> 00:59:56.300
Yeah.


00:59:56.300 --> 00:59:58.620
- The cool thing is that fractions,


00:59:58.620 --> 01:00:00.260
you can drop in replacements to floats.


01:00:00.260 --> 01:00:01.360
So if you've written some code


01:00:01.360 --> 01:00:03.700
which was previously using floats,


01:00:03.700 --> 01:00:05.880
and then you pass in fractions,


01:00:05.880 --> 01:00:07.320
everything will work as normal,


01:00:07.320 --> 01:00:09.340
except you'll not get the round here.


01:00:09.340 --> 01:00:11.300
So it's really kind of beautiful.


01:00:11.300 --> 01:00:13.500
- Okay, so you're saying the fraction library


01:00:13.500 --> 01:00:17.060
supports things like division, multiplication, additions,


01:00:17.060 --> 01:00:20.660
and basically would duck typing behave the same?


01:00:20.660 --> 01:00:23.660
- Yes, duck typing is a rational number.


01:00:23.660 --> 01:00:26.340
So anywhere where you use a float, fractional work.


01:00:26.340 --> 01:00:31.420
I learned about that.


01:00:31.420 --> 01:00:33.180
Amazing.


01:00:33.180 --> 01:00:34.100
Let's see.


01:00:34.100 --> 01:00:35.480
Emojis are hard.


01:00:35.480 --> 01:00:37.020
You talked a little bit about things


01:00:37.020 --> 01:00:39.980
that take up different sizes and Unicode and whatnot.


01:00:39.980 --> 01:00:40.820
Yeah.


01:00:40.820 --> 01:00:41.540
Yeah.


01:00:41.540 --> 01:00:47.860
So when I started Textualize and I got my first employee,


01:00:47.860 --> 01:00:49.900
I thought, this is a problem that I want to tackle


01:00:49.900 --> 01:00:54.140
because it has been bugging me for two whole years.


01:00:54.140 --> 01:00:55.940
And the problem is basically this,


01:00:55.940 --> 01:00:59.620
that some characters will take up two cells in the terminal,


01:00:59.620 --> 01:01:00.860
they're double wide,


01:01:00.860 --> 01:01:03.040
and some characters will take up one cell.


01:01:03.040 --> 01:01:05.220
And if you want to do any kind of formatting,


01:01:05.220 --> 01:01:08.380
say to draw a line or a panel around it,


01:01:08.380 --> 01:01:10.540
you need to know exactly how many cells


01:01:10.540 --> 01:01:13.260
a piece of text will take up.


01:01:13.260 --> 01:01:15.580
And it sounds like a simple problem,


01:01:15.580 --> 01:01:18.840
all you need to do is know how many cells


01:01:18.840 --> 01:01:19.780
a character will take up.


01:01:19.780 --> 01:01:23.700
you might have a function which takes a character and returns either one or two.


01:01:23.700 --> 01:01:32.820
And in essence that's what rich does, but at some characters you can't know


01:01:32.820 --> 01:01:36.580
because they will render differently on different terminals, they'll render


01:01:36.580 --> 01:01:43.740
differently on iTerm and Windows and Linux and it gets even more complicated.


01:01:43.740 --> 01:01:51.420
you can get multiple characters, sorry, multiple, what's the, multiple code points in a character.


01:01:51.420 --> 01:01:56.020
So you might have something like a flag and a flag has like a two letter character code


01:01:56.020 --> 01:01:59.700
and another character code which tells you this is a flag.


01:01:59.700 --> 01:02:04.300
So if you iterate over that you get three code points.


01:02:04.300 --> 01:02:09.740
So you have to know, first of all, how everything works together and there's quite a lot of


01:02:09.740 --> 01:02:11.100
those type of characters.


01:02:11.100 --> 01:02:15.900
I can't imagine how tricky it is to be done inside Unicode.


01:02:15.900 --> 01:02:19.140
Yeah, yeah, it's crazy.


01:02:19.140 --> 01:02:21.540
This is very, very complex.


01:02:21.540 --> 01:02:23.820
And we thought, well, we'll just do it.


01:02:23.820 --> 01:02:25.540
We'll just apply some engineering effort


01:02:25.540 --> 01:02:27.620
and just do it.


01:02:27.620 --> 01:02:29.700
But we discovered that it was impossible to know,


01:02:29.700 --> 01:02:32.180
because you can't tell how the terminal is going


01:02:32.180 --> 01:02:34.340
to render these Unicode.


01:02:34.340 --> 01:02:35.580
It might do it correctly.


01:02:35.580 --> 01:02:38.340
It might actually render a single character.


01:02:38.340 --> 01:02:41.940
If the terminal is not aware of multi-code point emojis,


01:02:41.940 --> 01:02:45.580
then you might get three characters.


01:02:45.580 --> 01:02:48.100
They might render as nothing, or they


01:02:48.100 --> 01:02:52.100
might render as three double-width characters.


01:02:52.100 --> 01:02:53.700
They might not even render properly,


01:02:53.700 --> 01:02:57.580
so they might overlap the following character.


01:02:57.580 --> 01:02:59.100
Some number of boxes.


01:02:59.100 --> 01:03:02.540
Yeah, it's just every terminal did it differently.


01:03:02.540 --> 01:03:05.020
Not only the terminal, it was platform dependent.


01:03:05.020 --> 01:03:08.260
So if the terminal used the Unicode database


01:03:08.260 --> 01:03:14.820
on the operating system, then you'd get different results if it shipped its own copy of the


01:03:14.820 --> 01:03:15.820
Unicode database.


01:03:15.820 --> 01:03:21.700
And it just turned out it was impossible to know how many characters.


01:03:21.700 --> 01:03:23.780
So what do you do?


01:03:23.780 --> 01:03:29.180
Well there's a subset up to about Unicode 9 where things seem to be mostly sane, most


01:03:29.180 --> 01:03:31.060
terminal support.


01:03:31.060 --> 01:03:33.420
So if you use those, those are fine.


01:03:33.420 --> 01:03:36.740
But after that, it becomes unreliable.


01:03:36.740 --> 01:03:45.080
If you have flags and multi-code point characters, then it might not work.


01:03:45.080 --> 01:03:49.960
It might cause the alignment of tables and panels to be out.


01:03:49.960 --> 01:03:55.720
You know, the end character might be shifted out by one and it just comes up so frequently


01:03:55.720 --> 01:03:59.200
and I would solve it if I could.


01:03:59.200 --> 01:04:05.440
But as far as I can tell, there is no reasonable solution which will work across all platforms


01:04:05.440 --> 01:04:08.480
Too many unknowns, right?


01:04:08.480 --> 01:04:11.520
Too many unknowns, yeah.


01:04:11.520 --> 01:04:15.080
It's a crazy thing, but it kind of makes sense because these Unicode characters came out


01:04:15.080 --> 01:04:20.640
in the last few years and operating systems and terminals haven't caught up and they haven't


01:04:20.640 --> 01:04:23.520
agreed on how to render them.


01:04:23.520 --> 01:04:27.480
So it's a frustrating situation.


01:04:27.480 --> 01:04:29.160
But I'm sure there is.


01:04:29.160 --> 01:04:34.560
Yeah, if you look at some of the nerd fonts, for example,


01:04:34.560 --> 01:04:36.560
when I--


01:04:36.560 --> 01:04:40.920
at nerdfonts.com, you look at some of these, what is possible?


01:04:40.920 --> 01:04:46.520
I think here, you have these colored arrows.


01:04:46.520 --> 01:04:49.000
And do they have--


01:04:49.000 --> 01:04:52.640
if you go over to Oh My Posh, which I don't really


01:04:52.640 --> 01:04:53.720
have time to talk about.


01:04:53.720 --> 01:04:56.640
But if you look at the themes that are in here,


01:04:56.640 --> 01:04:59.040
the different themes that you can pick,


01:04:59.040 --> 01:05:07.700
and just some of the effects, like a character that looks like a git branch with an arrow


01:05:07.700 --> 01:05:13.880
in it. How are you supposed to decide how big that is? Or how is some of this stuff


01:05:13.880 --> 01:05:16.120
accomplished? It's just mind-blowing.


01:05:16.120 --> 01:05:24.680
I don't know how they represent those characters. I wonder if they reuse existing characters.


01:05:24.680 --> 01:05:29.240
When I saw that, I was like, "Okay, I don't know how this is possible."


01:05:29.240 --> 01:05:31.680
Rounded edges and all sorts of stuff.


01:05:31.680 --> 01:05:40.200
I'm trying to find one where it's like a sparkly fade from one character to the next.


01:05:40.200 --> 01:05:46.080
These things over on the omyposh.dev themes, if I thought about your job to figure out


01:05:46.080 --> 01:05:51.720
what is that supposed to look like, I don't know, I would just give up.


01:05:51.720 --> 01:05:56.440
They're really impressive and really useful, but this one, for example, the cert theme,


01:05:56.440 --> 01:06:00.760
where it's got little dots that fade from one to the next.


01:06:00.760 --> 01:06:01.760
I just don't know.


01:06:01.760 --> 01:06:07.760
Amazing, but how are you supposed to know, right?


01:06:07.760 --> 01:06:09.520
Cool.


01:06:09.520 --> 01:06:11.280
All right.


01:06:11.280 --> 01:06:14.820
Those are your lessons.


01:06:14.820 --> 01:06:15.820
Very cool stuff.


01:06:15.820 --> 01:06:19.600
I really appreciate you coming on to talk about the seven lessons.


01:06:19.600 --> 01:06:20.600
Terminals are fast.


01:06:20.600 --> 01:06:22.600
Dict views are amazing.


01:06:22.600 --> 01:06:23.880
LRU cache is fast.


01:06:23.880 --> 01:06:24.860
Immutable is good.


01:06:24.860 --> 01:06:26.000
Unicode R is good.


01:06:26.000 --> 01:06:28.040
Fractions are good.


01:06:28.040 --> 01:06:30.680
Emoji is bad.


01:06:30.680 --> 01:06:31.760
Does that summarize it?


01:06:31.760 --> 01:06:35.160
>>That about, yeah, in a nutshell.


01:06:35.160 --> 01:06:38.040
>>Oh, let's wrap it up with one more thing real quick here.


01:06:38.040 --> 01:06:39.640
Let me see if I can find it.


01:06:39.640 --> 01:06:40.120
This one?


01:06:40.120 --> 01:06:41.280
There we go.


01:06:41.280 --> 01:06:45.520
So one of the-- sort of bringing it full circle back around.


01:06:45.520 --> 01:06:48.520
One of the cool things to make terminals nicer


01:06:48.520 --> 01:06:52.560
that you've talked about recently is rich-cli.


01:06:52.560 --> 01:06:54.720
You want to close out the show and just tell us


01:06:54.720 --> 01:06:56.240
what rich-cli is?


01:06:56.240 --> 01:06:56.740
Sure.


01:06:56.740 --> 01:06:58.720
So as you know, rich is a library.


01:06:58.720 --> 01:07:03.400
And rich-cli is a CLI interface for that library.


01:07:03.400 --> 01:07:07.680
So most of what rich can do is exposed by rich-cli.


01:07:07.680 --> 01:07:11.320
So you can cat most file formats,


01:07:11.320 --> 01:07:13.320
and they'll be nicely syntax highlighted.


01:07:13.320 --> 01:07:16.480
And you'll have line numbers and guidelines


01:07:16.480 --> 01:07:17.840
and all sorts of things.


01:07:17.840 --> 01:07:21.220
And you can do things like add panels.


01:07:21.220 --> 01:07:24.180
You can format text.


01:07:24.180 --> 01:07:27.700
What else does-- a whole bunch of other features.


01:07:27.700 --> 01:07:31.980
Yeah, so for example, if I had a JSON document on the terminal,


01:07:31.980 --> 01:07:33.260
I could type--


01:07:33.260 --> 01:07:36.260
I could open it in some terminal-based editor,


01:07:36.260 --> 01:07:37.660
think SSH somewhere.


01:07:37.660 --> 01:07:41.580
Or I could just type "more" or "cat," the name of it,


01:07:41.580 --> 01:07:44.860
and it would print out just plain text


01:07:44.860 --> 01:07:46.020
of whatever is on the inside.


01:07:46.020 --> 01:07:55.060
Now I could type "rich" the file name and I get highlighted, colorized, formatted content


01:07:55.060 --> 01:07:58.900
for like CSV and JSON and all those kind of things, right?


01:07:58.900 --> 01:07:59.900
Yeah, yeah.


01:07:59.900 --> 01:08:05.020
So the rich, the JSON example is quite good because that will decode the JSON.


01:08:05.020 --> 01:08:09.140
So if you've got like compressed JSON with no white space, it makes it impossible to


01:08:09.140 --> 01:08:10.140
read.


01:08:10.140 --> 01:08:14.340
Rich will decode it and it will also format it and...


01:08:14.340 --> 01:08:15.340
I see.


01:08:15.340 --> 01:08:18.580
Pretty Prince it, exactly.


01:08:18.580 --> 01:08:25.860
And it'll do markdown, it'll do a reasonable job of rendering markdown and it'll take CSV


01:08:25.860 --> 01:08:31.300
files and it'll turn those into nice rich tables and if your output is quite large you


01:08:31.300 --> 01:08:37.140
can add --pager and that'll put it in a nice pager where you can scroll up and down with


01:08:37.140 --> 01:08:39.980
scroll bars and do page up, page down, etc.


01:08:39.980 --> 01:08:44.160
So it's kind of like a toolbox for fancy, rich formatting


01:08:44.160 --> 01:08:47.520
of all sorts of different data types.


01:08:47.520 --> 01:08:49.880
Yeah, definitely a cool project.


01:08:49.880 --> 01:08:52.120
And I know you're concerned about emojis,


01:08:52.120 --> 01:08:54.440
but Paul in the audience says, fortunately, Doom


01:08:54.440 --> 01:08:55.840
does not require emojis.


01:08:55.840 --> 01:08:57.800
So it's still on the table.


01:08:57.800 --> 01:08:58.600
I suppose not, yeah.


01:08:58.600 --> 01:09:03.380
That's right.


01:09:03.380 --> 01:09:06.240
All right, well, fantastic lessons.


01:09:06.240 --> 01:09:08.480
Thanks for sharing all of your experience.


01:09:08.480 --> 01:09:10.560
Final two questions before you get out of here.


01:09:10.560 --> 01:09:12.520
If you're going to write some Python code, work on rich,


01:09:12.520 --> 01:09:14.400
what editor are you using these days?


01:09:14.400 --> 01:09:16.280
It's not so meta that you're using textual


01:09:16.280 --> 01:09:17.800
to write textual yet, is it?


01:09:17.800 --> 01:09:20.920
- No, maybe one day, but no, I use VS Code


01:09:20.920 --> 01:09:25.440
and I quite like it, I'm comfortable with it.


01:09:25.440 --> 01:09:30.440
My colleague uses, what's the editor by JetBrains?


01:09:30.440 --> 01:09:31.440
- PyCharm.


01:09:31.440 --> 01:09:34.560
- PyCharm, and he's very proficient at PyCharm.


01:09:34.560 --> 01:09:35.880
And to be honest with you, I am jealous


01:09:35.880 --> 01:09:37.200
of some of the features of PyCharm.


01:09:37.200 --> 01:09:40.280
it does some really cool things.


01:09:40.280 --> 01:09:44.160
So I'm kind of tempted to try PyCharm.


01:09:44.160 --> 01:09:45.240
Looking over the shoulder.


01:09:45.240 --> 01:09:45.740
Awesome.


01:09:45.740 --> 01:09:46.400
Yeah.


01:09:46.400 --> 01:09:46.900
Very cool.


01:09:46.900 --> 01:09:49.200
And then notable PyPI package.


01:09:49.200 --> 01:09:51.840
I mean, we've touched on some good ones


01:09:51.840 --> 01:09:54.400
that start or end with rich.


01:09:54.400 --> 01:09:56.640
But anything else you run across that you're like,


01:09:56.640 --> 01:09:57.720
oh, this is fantastic.


01:09:57.720 --> 01:10:00.080
People should check this out.


01:10:00.080 --> 01:10:01.000
Oh, gosh.


01:10:01.000 --> 01:10:02.880
There's so many at once.


01:10:02.880 --> 01:10:06.360
I'm drawing a blank.


01:10:06.360 --> 01:10:08.680
I should have prepared one in advance.


01:10:08.680 --> 01:10:10.280
- How about one that you use


01:10:10.280 --> 01:10:12.920
that makes rich work well or something?


01:10:12.920 --> 01:10:16.280
- Well, there's Prompt Toolkit.


01:10:16.280 --> 01:10:19.720
So I owe Prompt Toolkit a big debt of gratitude


01:10:19.720 --> 01:10:22.240
because when I was figuring out the textual stuff,


01:10:22.240 --> 01:10:26.000
I looked at the Prompt Toolkit source code,


01:10:26.000 --> 01:10:27.320
which is a great thing about open source


01:10:27.320 --> 01:10:29.480
that you can look at other people's code.


01:10:29.480 --> 01:10:31.280
And it is very good.


01:10:31.280 --> 01:10:32.560
It helped me understand things


01:10:32.560 --> 01:10:35.800
and it still does things which textual doesn't do yet.


01:10:35.800 --> 01:10:38.640
So I think Prompt Toolkit is an excellent project.


01:10:38.640 --> 01:10:41.280
And if you haven't used it, you should definitely check it out.


01:10:41.280 --> 01:10:42.520
Yeah, Prompt Toolkit's interesting.


01:10:42.520 --> 01:10:44.360
You'll be typing along, and all of a sudden,


01:10:44.360 --> 01:10:46.960
there's like a combo dropdown box,


01:10:46.960 --> 01:10:49.800
like a select right in the middle of your terminal,


01:10:49.800 --> 01:10:51.120
and then you just carry on.


01:10:51.120 --> 01:10:52.160
Yeah, it makes things--


01:10:52.160 --> 01:10:53.400
I think it's used in IPython.


01:10:53.400 --> 01:10:57.840
It makes that much nicer, much more friendly.


01:10:57.840 --> 01:10:59.720
Absolutely.


01:10:59.720 --> 01:11:02.160
All right, well, final call to action.


01:11:02.160 --> 01:11:05.400
People want to do stuff with rich text rule,


01:11:05.400 --> 01:11:07.880
maybe take some of these lessons and run with them.


01:11:07.880 --> 01:11:10.160
What do you tell them, Will?


01:11:10.160 --> 01:11:11.880
- Yeah, check out the website,


01:11:11.880 --> 01:11:13.920
check out my Twitter profile,


01:11:13.920 --> 01:11:15.280
and if you have any questions,


01:11:15.280 --> 01:11:16.920
feel free to ping them over to me.


01:11:16.920 --> 01:11:18.640
I'm always happy to talk to people


01:11:18.640 --> 01:11:21.560
about Python-related things.


01:11:21.560 --> 01:11:22.400
- Yeah, fantastic.


01:11:22.400 --> 01:11:25.040
And of course, I'll list the link to the article


01:11:25.040 --> 01:11:26.680
with your list of topics there,


01:11:26.680 --> 01:11:28.160
so people can check that out.


01:11:28.160 --> 01:11:29.000
- Cool.


01:11:29.000 --> 01:11:29.820
- Thank you so much for being here.


01:11:29.820 --> 01:11:30.660
- Thanks, Michael. - It's been great


01:11:30.660 --> 01:11:31.500
to catch up with you.


01:11:31.500 --> 01:11:32.320
- Thank you. - You bet.


01:11:32.320 --> 01:11:33.160
- Take care. - Bye.


01:11:33.160 --> 01:11:33.980
- Bye-bye.


01:11:33.980 --> 01:11:43.980
[BLANK_AUDIO]

