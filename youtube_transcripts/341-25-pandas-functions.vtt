WEBVTT

00:00:00.000 --> 00:00:04.080
- Bex, welcome to Talk Python to Me.


00:00:04.080 --> 00:00:04.920
- Hello, Michael.


00:00:04.920 --> 00:00:06.120
Thanks for having me.


00:00:06.120 --> 00:00:09.840
- Hey, it's fantastic to have you here on the show.


00:00:09.840 --> 00:00:14.760
Your article, 25 pandas functions that you didn't know


00:00:14.760 --> 00:00:18.100
or probably don't know, I guess, as we'll see,


00:00:18.100 --> 00:00:20.040
that really caught my attention.


00:00:20.040 --> 00:00:22.120
Honestly, I don't know many of them,


00:00:22.120 --> 00:00:24.520
so I learned a bunch by watching it.


00:00:24.520 --> 00:00:28.840
You know, I do spend more time on the web side of Python


00:00:28.840 --> 00:00:34.200
the data-based side of Python that I do on the data science, but certainly Pandas is


00:00:34.200 --> 00:00:39.960
a super important part of Python these days. And honestly, the whole data science side


00:00:39.960 --> 00:00:42.400
is the fastest growing part of Python.


00:00:42.400 --> 00:00:48.440
Yes. Yes. Yeah. Pandas is like one of the first libraries that you will be introducing


00:00:48.440 --> 00:00:54.480
any beginner Python, or in any beginner data science course. And it's amazing how much


00:00:54.480 --> 00:00:58.480
it has grown since it was first launched.


00:00:58.480 --> 00:01:03.100
And the funny thing about the article is that before writing it, I also didn't know most


00:01:03.100 --> 00:01:07.280
of the functions.


00:01:07.280 --> 00:01:13.960
I would always get annoyed by people who use some complex functions and I just wanted to


00:01:13.960 --> 00:01:17.240
know how they worked and explain it to my audience.


00:01:17.240 --> 00:01:22.880
So that was the idea of the article, both me and the audience learning.


00:01:22.880 --> 00:01:26.920
- Yeah, that's the little bit of secret


00:01:26.920 --> 00:01:29.400
behind these types of things, behind the tutorials,


00:01:29.400 --> 00:01:32.760
behind articles, behind podcasts, and even behind courses.


00:01:32.760 --> 00:01:35.080
Is a lot of times we dive into them


00:01:35.080 --> 00:01:37.300
because we're like, oh, I really want to learn these things


00:01:37.300 --> 00:01:40.580
and just let me, you know, put it in a format


00:01:40.580 --> 00:01:42.180
I can present to the rest of the world


00:01:42.180 --> 00:01:44.080
and help everyone else out, right?


00:01:44.080 --> 00:01:45.680
- Yeah, yeah.


00:01:45.680 --> 00:01:46.520
- Awesome.


00:01:46.520 --> 00:01:49.380
Yeah, before we get into this,


00:01:49.380 --> 00:01:50.640
I want to talk about your articles


00:01:50.640 --> 00:01:52.080
and some Kaggle competitions


00:01:52.080 --> 00:01:55.200
and then we'll dive into the 25 functions.


00:01:55.200 --> 00:01:57.040
But let's start with your story.


00:01:57.040 --> 00:01:59.480
How'd you get into programming in Python?


00:01:59.480 --> 00:02:03.280
- Yeah, right after I finished high school,


00:02:03.280 --> 00:02:06.600
I got interested in web development.


00:02:06.600 --> 00:02:08.520
I learned some HTML and CSS,


00:02:08.520 --> 00:02:13.440
and I was hoping to get things to be more exciting,


00:02:13.440 --> 00:02:16.720
but after some time, I just got bored


00:02:16.720 --> 00:02:19.300
because I'm really into math,


00:02:19.300 --> 00:02:22.580
And web development had nothing to do with math,


00:02:22.580 --> 00:02:24.420
so it was very boring.


00:02:24.420 --> 00:02:26.340
So I switched to learning Python,


00:02:26.340 --> 00:02:30.700
learned it for a while and discovered that data science


00:02:30.700 --> 00:02:34.060
is mostly connected to math and statistics.


00:02:34.060 --> 00:02:38.500
So I just bought a really good course


00:02:38.500 --> 00:02:41.380
and that's how it started.


00:02:41.380 --> 00:02:42.780
- Yeah, that's fantastic.


00:02:42.780 --> 00:02:44.760
You know, I think people do often feel like


00:02:44.760 --> 00:02:47.820
you have to be really good at math to be good at programming.


00:02:47.820 --> 00:02:50.320
And honestly, most of programming


00:02:50.320 --> 00:02:52.780
has very little to do with math.


00:02:52.780 --> 00:02:54.180
- Yes, yes, of course.


00:02:54.180 --> 00:02:55.580
- But data science does.


00:02:55.580 --> 00:02:57.540
So data science is unique in this way.


00:02:57.540 --> 00:02:59.300
I mean, I guess computational science, right?


00:02:59.300 --> 00:03:03.460
If you're an astrophysicist, you do a lot of math as well.


00:03:03.460 --> 00:03:06.120
But for most of us,


00:03:06.120 --> 00:03:08.260
math is just a structured way of thinking


00:03:08.260 --> 00:03:09.820
and we have structured programs


00:03:09.820 --> 00:03:12.020
and that's kind of the end of the relationship there.


00:03:12.020 --> 00:03:17.020
But for, if someone is out there and they really love math


00:03:17.540 --> 00:03:18.620
and they wanna take it farther,


00:03:18.620 --> 00:03:19.940
but they wanna do that in computers.


00:03:19.940 --> 00:03:21.620
It sounds like recommending data science


00:03:21.620 --> 00:03:23.020
might be the right path.


00:03:23.020 --> 00:03:24.460
- Yeah, of course.


00:03:24.460 --> 00:03:26.860
Yeah, it's how, it's very really beautiful


00:03:26.860 --> 00:03:31.500
how software and math connect together in data science


00:03:31.500 --> 00:03:34.060
and what kind of things it can achieve


00:03:34.060 --> 00:03:36.980
like for neural networks and state-of-the-art


00:03:36.980 --> 00:03:38.380
machine learning algorithms.


00:03:38.380 --> 00:03:40.180
It's really amazing.


00:03:40.180 --> 00:03:41.180
- Yeah.


00:03:41.180 --> 00:03:45.140
It's one of these areas that's just growing so fast


00:03:45.140 --> 00:03:47.500
and there's such big advancements.


00:03:47.500 --> 00:03:52.060
You look at, I think back to when I was in college


00:03:52.060 --> 00:03:57.060
and we talked about artificial intelligence and AI


00:03:57.060 --> 00:03:59.400
and it was all about the Turing test.


00:03:59.400 --> 00:04:04.420
Could you get a chat bot that would trick a human


00:04:04.420 --> 00:04:07.820
into thinking that it was an actual other human?


00:04:07.820 --> 00:04:11.740
And it never really seemed to come into reality.


00:04:11.740 --> 00:04:15.020
It always seemed like, oh, it's kind of always 30 years out.


00:04:15.020 --> 00:04:18.040
And then all of a sudden we have self-driving cars


00:04:18.040 --> 00:04:19.620
and we have Google Co-Pilot.


00:04:19.620 --> 00:04:22.420
And it's just the step jump


00:04:22.420 --> 00:04:24.900
over the last couple of years has been amazing.


00:04:24.900 --> 00:04:26.980
- Yeah, I was also amazed by Google Co-Pilot.


00:04:26.980 --> 00:04:29.540
Like right after it was launched,


00:04:29.540 --> 00:04:33.660
I wrote an article on it, like as a kind of intro


00:04:33.660 --> 00:04:34.820
and it really took off.


00:04:34.820 --> 00:04:36.960
Like so many people were interested in it.


00:04:36.960 --> 00:04:41.520
Like it received like more than 50,000 views, the article.


00:04:41.520 --> 00:04:42.360
- Yeah. - Yeah.


00:04:42.360 --> 00:04:44.240
A lot of people were amazed by it.


00:04:44.240 --> 00:04:46.100
- Absolutely, I'm amazed by it as well.


00:04:46.100 --> 00:04:48.280
I think it is amazing.


00:04:48.280 --> 00:04:52.220
It's also bringing to light some interesting,


00:04:52.220 --> 00:04:57.260
almost legal and philosophical things, right?


00:04:57.260 --> 00:04:59.360
If people put code on GitHub,


00:04:59.360 --> 00:05:02.200
they didn't necessarily intend to train an AI with it.


00:05:02.200 --> 00:05:05.040
If they put code on GitHub that's under GPL,


00:05:05.040 --> 00:05:08.440
well, what the AI knows, is that now GPL


00:05:08.440 --> 00:05:10.040
or is that completely, you know,


00:05:10.040 --> 00:05:11.880
can that be used in closed source?


00:05:11.880 --> 00:05:12.880
These are not known, right?


00:05:12.880 --> 00:05:16.400
These are interesting questions.


00:05:16.400 --> 00:05:17.800
Yeah, but I don't think we're gonna answer,


00:05:17.800 --> 00:05:20.900
we're not gonna completely fill them out today.


00:05:20.900 --> 00:05:24.760
Let's focus on something more, a little smaller.


00:05:24.760 --> 00:05:26.540
So you mentioned your articles


00:05:26.540 --> 00:05:28.580
and you've been doing a lot of writing.


00:05:28.580 --> 00:05:33.100
So you're a top 10 writer in artificial intelligence on Medium.


00:05:33.100 --> 00:05:37.600
Yeah, and you're also a Kaggle master.


00:05:37.600 --> 00:05:38.440
- Yeah, yeah.


00:05:38.440 --> 00:05:40.920
- Yeah, let's talk about those two things for a little bit.


00:05:40.920 --> 00:05:43.220
Give us a sense of the stuff that you write about on Medium


00:05:43.220 --> 00:05:44.860
and maybe some of your favorite articles


00:05:44.860 --> 00:05:47.180
before we dive into this one.


00:05:47.180 --> 00:05:50.060
- I started writing on Medium a year ago.


00:05:50.060 --> 00:05:52.520
It was just purely for educational purposes.


00:05:52.520 --> 00:05:56.060
I really liked how, like,


00:05:56.060 --> 00:05:58.180
what the things you learn will be like,


00:05:58.180 --> 00:06:01.720
will be locked into your brain by writing about them.


00:06:01.720 --> 00:06:05.260
So it was a really amazing way to learn something new.


00:06:05.260 --> 00:06:10.260
But as it, as my number of articles grew,


00:06:10.520 --> 00:06:13.900
like my audience grew and I met a lot of people.


00:06:13.900 --> 00:06:18.520
It opened a lot of doors for me writing.


00:06:18.520 --> 00:06:22.280
And the most important of all,


00:06:22.280 --> 00:06:25.840
I am more confident about my knowledge than ever before.


00:06:25.840 --> 00:06:27.040
- That's fantastic.


00:06:27.040 --> 00:06:29.320
I really like that you point out that it opened doors


00:06:29.320 --> 00:06:34.320
because so many people feel like I'm not ready to write,


00:06:34.320 --> 00:06:37.620
I'm not ready to speak at a user group or a conference,


00:06:37.620 --> 00:06:39.960
or I'm not ready to appear on a podcast


00:06:39.960 --> 00:06:41.440
or any of these sorts of ways


00:06:41.440 --> 00:06:43.360
where you put yourself out there, right?


00:06:43.360 --> 00:06:44.440
- Yeah, yeah.


00:06:44.440 --> 00:06:46.280
- But when you do that,


00:06:46.280 --> 00:06:49.440
the act of doing that pushes you to grow


00:06:49.440 --> 00:06:52.200
and it also opens doors to people.


00:06:52.200 --> 00:06:54.320
You know, if you're out there and you're genuine,


00:06:54.320 --> 00:06:56.840
you don't have to be an absolute expert in everything.


00:06:56.840 --> 00:06:58.640
You just have to be excited and interested


00:06:58.640 --> 00:07:00.340
and other people who are excited want to talk to you


00:07:00.340 --> 00:07:01.840
and work on something with you, right?


00:07:01.840 --> 00:07:03.160
- Yes, yes.


00:07:03.160 --> 00:07:05.280
You just have to be one step ahead of your audience


00:07:05.280 --> 00:07:06.620
and that's it.


00:07:06.620 --> 00:07:07.460
- Right.


00:07:07.460 --> 00:07:08.480
- When you write articles.


00:07:08.480 --> 00:07:09.320
- That's right.


00:07:09.320 --> 00:07:14.320
- Yeah, I usually like, I really admire people


00:07:14.320 --> 00:07:20.760
who do like do competitions on Kaggle for a while.


00:07:20.760 --> 00:07:23.480
And I really had this like imposter syndrome.


00:07:23.480 --> 00:07:25.280
I couldn't join the competitions


00:07:25.280 --> 00:07:27.240
because I thought that they would be like,


00:07:27.240 --> 00:07:29.040
"Oh, you're not gonna be able to do it."


00:07:29.040 --> 00:07:30.840
And I was like, "No, I'm not gonna do it."


00:07:30.840 --> 00:07:32.840
And then I was like, "Oh, I'm not gonna do it."


00:07:32.840 --> 00:07:34.680
And then I was like, "Oh, I'm not gonna do it."


00:07:34.680 --> 00:07:36.160
And then I was like, "Oh, I'm not gonna do it."


00:07:36.160 --> 00:07:37.880
And then I was like, "Oh, I'm not gonna do it."


00:07:37.880 --> 00:07:43.880
because I thought that they were too complex, that I had a lot of things to learn before I joined them.


00:07:43.880 --> 00:07:54.380
I still do, but after I joined the tabular playground competitions, I learned that I can do it.


00:07:54.380 --> 00:07:59.880
So I started posting my articles in the form of notebooks on Kaggle as well,


00:07:59.880 --> 00:08:06.380
which started getting a lot of views and really nice comments from the audience.


00:08:06.380 --> 00:08:11.980
And you know, the community on Kaggle is even more amazing than on Medium.


00:08:11.980 --> 00:08:16.380
For an article that gets like read by thousands of people on Medium,


00:08:16.380 --> 00:08:18.780
I usually receive like one or two comments.


00:08:18.780 --> 00:08:22.580
But if you write, if you post the same article as a notebook on Kaggle,


00:08:22.580 --> 00:08:30.180
like the audience loves it because Kaggle is mostly suited for this kind of tutorials.


00:08:30.180 --> 00:08:33.180
And I usually receive like 30 or 40 comments.


00:08:33.180 --> 00:08:38.340
And it's really amazing as a writer to be part of that kind of community.


00:08:38.340 --> 00:08:40.020
Yeah, that's really amazing.


00:08:40.020 --> 00:08:40.660
I had no idea.


00:08:40.660 --> 00:08:45.020
I didn't realize you could post on Kaggle, but I guess you kind of post your


00:08:45.020 --> 00:08:47.620
solutions and then have a conversation around them sort of, right?


00:08:47.620 --> 00:08:47.980
Yes.


00:08:47.980 --> 00:08:48.300
Yes.


00:08:48.300 --> 00:08:48.660
Yes.


00:08:48.660 --> 00:08:50.860
Okay.


00:08:50.860 --> 00:08:51.460
Awesome.


00:08:51.460 --> 00:08:53.660
People want to get started with Kaggle.


00:08:53.660 --> 00:08:55.180
You know, what, what do they need to do?


00:08:55.180 --> 00:08:59.020
Like maybe before we've dropped this topic, like if people haven't done


00:08:59.020 --> 00:09:02.340
stuff with Kaggle yet, but they maybe want to use it to learn what's your advice there?


00:09:02.340 --> 00:09:10.280
Yeah, right after you create an account, they have a whole suite of courses, free courses


00:09:10.280 --> 00:09:11.720
you can take.


00:09:11.720 --> 00:09:19.200
I think those are the very best, very good starting points for any beginner.


00:09:19.200 --> 00:09:25.800
And also they have like two or three beginner level competitions, so you don't get intimidated


00:09:25.800 --> 00:09:28.920
by those grandmasters or masters.


00:09:28.920 --> 00:09:35.120
And they're just simple data sets you can work with, and you just have to submit your


00:09:35.120 --> 00:09:41.480
predictions and just get a score, and nothing too complex.


00:09:41.480 --> 00:09:43.560
And that's really the amazing part of Kaggle.


00:09:43.560 --> 00:09:50.160
That's why those three competitions, I think they have like 100,000 people competing at


00:09:50.160 --> 00:09:53.680
any single time in any time.


00:09:53.680 --> 00:09:55.640
That's wild.


00:09:55.640 --> 00:09:57.240
One of the challenges when you're learning


00:09:57.240 --> 00:10:01.920
is finding a structured problem to approach, right?


00:10:01.920 --> 00:10:05.720
In maybe in the web world,


00:10:05.720 --> 00:10:08.160
people try to build things that are too ambitious.


00:10:08.160 --> 00:10:09.840
They're like, oh, I want to build Airbnb.


00:10:09.840 --> 00:10:10.860
You're like, whoa, whoa, whoa, whoa.


00:10:10.860 --> 00:10:12.800
You don't really hardly understand CSS.


00:10:12.800 --> 00:10:15.400
Let's take it down a notch and let's go slow


00:10:15.400 --> 00:10:18.260
and we'll get a right-sized problem for you to address.


00:10:18.260 --> 00:10:19.760
Data science has the same problem,


00:10:19.760 --> 00:10:21.420
but I think it has another aspect,


00:10:21.420 --> 00:10:25.360
which is, and you need the data to start from, right?


00:10:25.360 --> 00:10:28.940
And I feel like Kaggle helps in bringing


00:10:28.940 --> 00:10:30.280
that kind of stuff over.


00:10:30.280 --> 00:10:35.900
- Yeah, Kaggle has an amazing list of datasets.


00:10:35.900 --> 00:10:41.260
I almost always use Kaggle datasets for my articles


00:10:41.260 --> 00:10:43.820
because most of them are digestible


00:10:43.820 --> 00:10:47.140
and small enough for people to get an advantage of.


00:10:47.140 --> 00:10:48.660
- Yeah, awesome.


00:10:48.660 --> 00:10:52.220
A question from the audience from Brandon Bennett asks,


00:10:52.220 --> 00:10:54.900
are Kaggle competitions just machine learning


00:10:54.900 --> 00:10:57.620
and artificial intelligence related or are there other types?


00:10:57.620 --> 00:11:03.020
Yeah, Kaggle competitions are only AI or data science related.


00:11:03.020 --> 00:11:04.020
Yeah, okay.


00:11:04.020 --> 00:11:12.180
So, for example, the latest one launched on Kaggle, I think is about finding the cuteness


00:11:12.180 --> 00:11:14.180
quotient of pets.


00:11:14.180 --> 00:11:20.860
It was, yeah, yeah, you just, you just take in like thousands of images and you process


00:11:20.860 --> 00:11:29.420
them with Python or R and the neural network learns the structure and learns the cuteness


00:11:29.420 --> 00:11:34.100
quotient and just spits out a new quotient for any new image you get.


00:11:34.100 --> 00:11:35.100
That's amazing.


00:11:35.100 --> 00:11:41.340
So it used to be, here's a machine learning model that can answer, is it a cat or a dog?


00:11:41.340 --> 00:11:44.420
And now it's giving you a cuteness score.


00:11:44.420 --> 00:11:47.740
I can definitely see my daughter getting into data science with this one.


00:11:47.740 --> 00:11:50.640
She's all about pets and cats and dogs.


00:11:50.640 --> 00:11:54.140
And I personally want to put a vote out there


00:11:54.140 --> 00:11:58.720
for the golden cocker, the golden retriever


00:11:58.720 --> 00:12:00.120
mixed with the cocker spaniel.


00:12:00.120 --> 00:12:01.640
Boy, those things are cute.


00:12:01.640 --> 00:12:03.480
Okay, so that's Kaggle.


00:12:03.480 --> 00:12:05.560
Sounds really great for learning.


00:12:05.560 --> 00:12:11.200
And I suspect knowing something about pandas will pay off


00:12:11.200 --> 00:12:12.760
in Kaggle and stuff, right?


00:12:12.760 --> 00:12:16.140
Like it's such a foundational aspect.


00:12:16.140 --> 00:12:20.180
- Yeah, pandas are used excessively.


00:12:20.180 --> 00:12:21.380
- It is.


00:12:21.380 --> 00:12:24.660
And I feel like pandas is one of those things


00:12:24.660 --> 00:12:27.820
that you could learn it really quickly.


00:12:27.820 --> 00:12:30.920
You could learn to do stuff with pandas in a day.


00:12:30.920 --> 00:12:33.120
But then in a year,


00:12:33.120 --> 00:12:35.860
you could still be learning stuff about pandas.


00:12:35.860 --> 00:12:38.420
If you use it every day for a year, you know what I mean?


00:12:38.420 --> 00:12:40.180
- Yes, yes, yes.


00:12:40.180 --> 00:12:44.800
Yeah, most data science libraries are just very vast.


00:12:44.800 --> 00:12:47.240
there are a lot of functionalities and most of the time,


00:12:47.240 --> 00:12:51.200
like you can get around by learning like 10 or 15%


00:12:51.200 --> 00:12:52.840
of all those functions.


00:12:52.840 --> 00:12:56.680
But when you really need to get something like really rare


00:12:56.680 --> 00:13:00.240
edge cases or unique cases, you really need to know


00:13:00.240 --> 00:13:03.600
some of those rare functions that are buried


00:13:03.600 --> 00:13:06.280
in the documentation, just so that you don't have


00:13:06.280 --> 00:13:08.160
to reinvent the wheel.


00:13:08.160 --> 00:13:12.960
- Yeah, in Python, we speak about Pythonic code.


00:13:12.960 --> 00:13:15.900
There's code that we could write that might be code


00:13:15.900 --> 00:13:18.780
that runs, but it looks like it comes from Java


00:13:18.780 --> 00:13:20.380
or it looks like it comes from C


00:13:20.380 --> 00:13:22.460
and somebody just got it working.


00:13:22.460 --> 00:13:25.260
And I suspect you have the same thing in data science


00:13:25.260 --> 00:13:28.060
and around pandas is like, yeah, you technically could do


00:13:28.060 --> 00:13:31.780
this with pandas, but why don't you just call this function?


00:13:31.780 --> 00:13:34.100
And probably the answer is, well, I didn't know


00:13:34.100 --> 00:13:35.140
that function existed.


00:13:35.140 --> 00:13:37.360
Of course I would have called it if I had known to do it,


00:13:37.360 --> 00:13:38.840
but I just didn't know, right?


00:13:38.840 --> 00:13:39.680
I'm new.


00:13:41.740 --> 00:13:43.340
- Yeah, so hopefully we can shine a light


00:13:43.340 --> 00:13:45.180
on some of those things that you can do.


00:13:45.180 --> 00:13:47.020
I mean, for example,


00:13:47.020 --> 00:13:48.940
not that we'll necessarily cover it in your article,


00:13:48.940 --> 00:13:52.220
but if you're doing a for loop with a data frame,


00:13:52.220 --> 00:13:53.740
you're probably doing it wrong, right?


00:13:53.740 --> 00:13:55.340
- Yeah, yeah, yeah.


00:13:55.340 --> 00:13:58.340
The golden rule is to never use loops,


00:13:58.340 --> 00:14:00.200
like teach loops completely.


00:14:00.200 --> 00:14:02.900
- Yeah, that's pretty interesting.


00:14:02.900 --> 00:14:05.180
It definitely takes a different way of thinking,


00:14:05.180 --> 00:14:09.100
sort of set-based processing and passing in expressions


00:14:09.100 --> 00:14:11.860
of lambdas to various places and whatnot.


00:14:11.860 --> 00:14:12.700
- Yeah.


00:14:12.700 --> 00:14:13.540
- Maps and whatnot.


00:14:13.540 --> 00:14:16.100
Okay, we're gonna talk about some of those.


00:14:16.100 --> 00:14:18.900
So let's dive in.


00:14:18.900 --> 00:14:20.900
First of all, how'd you pick these 25?


00:14:20.900 --> 00:14:23.420
Were these just 25 that you saw people use


00:14:23.420 --> 00:14:24.260
and they were interesting?


00:14:24.260 --> 00:14:25.600
And you're like, I didn't even know that existed


00:14:25.600 --> 00:14:27.860
or what was your philosophy here?


00:14:27.860 --> 00:14:30.220
- Yeah, for this kind of articles,


00:14:30.220 --> 00:14:33.820
I usually go to the API reference of the documentation.


00:14:33.820 --> 00:14:36.020
It just lists every single class and functionality


00:14:36.020 --> 00:14:38.460
of some library, the API reference.


00:14:38.460 --> 00:14:42.260
and I just read them one by one,


00:14:42.260 --> 00:14:46.620
decide which one of those is gonna be beneficial to me


00:14:46.620 --> 00:14:48.460
and possibly for my audience,


00:14:48.460 --> 00:14:52.220
and I just pick them out one by one.


00:14:52.220 --> 00:14:53.060
- Yeah, that's really cool.


00:14:53.060 --> 00:14:54.900
I love to discover these types of things.


00:14:54.900 --> 00:14:58.340
So why don't you kick it off with number one?


00:14:58.340 --> 00:14:59.860
What's number one here?


00:14:59.860 --> 00:15:01.900
- The first one is Excel Writer.


00:15:01.900 --> 00:15:06.900
It's a class for writing to Excel sheets.


00:15:07.260 --> 00:15:09.020
if you have multiple data frames,


00:15:09.020 --> 00:15:12.060
you can write to Excel sheets as separate tabs


00:15:12.060 --> 00:15:13.280
with separate sheets.


00:15:13.280 --> 00:15:16.820
The pandas has usually,


00:15:16.820 --> 00:15:19.540
the data frames have this to Excel function,


00:15:19.540 --> 00:15:23.440
but if you give it the Excel write to instance,


00:15:23.440 --> 00:15:25.780
it's gonna write it to a separate sheet.


00:15:25.780 --> 00:15:28.340
It's gonna enable you to write to separate sheets.


00:15:28.340 --> 00:15:30.360
- Yeah, this is super neat.


00:15:30.360 --> 00:15:32.060
So in your example here,


00:15:32.060 --> 00:15:34.860
which of course we'll link to the article


00:15:34.860 --> 00:15:35.940
and people can check out,


00:15:35.940 --> 00:15:37.300
they all have a bunch of code samples


00:15:37.300 --> 00:15:39.260
under each one of these.


00:15:39.260 --> 00:15:43.540
You've got two data frames, two pandas data frames,


00:15:43.540 --> 00:15:46.580
and you wanna put them into some kind of Excel spreadsheet.


00:15:46.580 --> 00:15:47.800
So you create one of these writers.


00:15:47.800 --> 00:15:50.380
This is the function you're talking about.


00:15:50.380 --> 00:15:52.740
And then you go to the data frame, you say to Excel,


00:15:52.740 --> 00:15:54.500
and you give it the writer and a sheet name.


00:15:54.500 --> 00:15:57.220
And you can do that for each data frame,


00:15:57.220 --> 00:15:58.260
you give it different sheet names,


00:15:58.260 --> 00:16:00.260
and it just piles up along the bottom, right?


00:16:00.260 --> 00:16:01.100
- Yeah, yeah.


00:16:01.100 --> 00:16:03.740
It's really neat.


00:16:03.740 --> 00:16:05.380
- It's ridiculously simple, right?


00:16:05.380 --> 00:16:09.140
It's like given the data frames, it's three lines of code.


00:16:09.140 --> 00:16:09.980
- If you didn't know this.


00:16:09.980 --> 00:16:11.260
- To create an Excel file and write it, yeah?


00:16:11.260 --> 00:16:12.380
- Yeah, if you didn't know this,


00:16:12.380 --> 00:16:14.660
you'd have to create two separate Excel files


00:16:14.660 --> 00:16:17.820
and just add them together later manually,


00:16:17.820 --> 00:16:19.940
which is not programmatic.


00:16:19.940 --> 00:16:22.460
- Right, or maybe you say you don't know


00:16:22.460 --> 00:16:24.020
that you can write to Excel.


00:16:24.020 --> 00:16:26.820
I mean, I'm pretty sure I could write to CSV.


00:16:26.820 --> 00:16:27.640
- Yeah.


00:16:27.640 --> 00:16:28.860
- And there's multiple levels, right?


00:16:28.860 --> 00:16:31.980
Like one level is like, I'm gonna write it line by line,


00:16:31.980 --> 00:16:33.980
putting the commas in there myself.


00:16:33.980 --> 00:16:36.500
Another one could be the right CSV, right?


00:16:36.500 --> 00:16:38.380
Read CSV, write CSV.


00:16:38.380 --> 00:16:40.340
But this one is like more structured, right?


00:16:40.340 --> 00:16:42.860
And then you could possibly use some of the


00:16:42.860 --> 00:16:46.300
more advanced tooling to do things like stylize


00:16:46.300 --> 00:16:48.960
or highlight aspects of it or whatever, right?


00:16:48.960 --> 00:16:51.060
Like pi open Excel or something like that.


00:16:51.060 --> 00:16:56.580
Now for this one, you talk about,


00:16:56.580 --> 00:16:58.940
it says that you need to have the right


00:16:58.940 --> 00:17:02.740
supporting libraries there, right?


00:17:02.740 --> 00:17:06.540
you for example, have to have different libraries.


00:17:06.540 --> 00:17:07.820
I can't remember which one it was.


00:17:07.820 --> 00:17:09.160
I think it was open pi.


00:17:09.160 --> 00:17:10.300
- Open pi Excel.


00:17:10.300 --> 00:17:11.140
- Open pi Excel.


00:17:11.140 --> 00:17:12.460
Yeah, that's it right here.


00:17:12.460 --> 00:17:13.300
- Yeah, yeah.


00:17:13.300 --> 00:17:14.120
- I think it was in here.


00:17:14.120 --> 00:17:14.960
- Yeah, yeah, yeah.


00:17:14.960 --> 00:17:17.820
- Open pi Excel if you wanna work with XLS files.


00:17:17.820 --> 00:17:20.220
And there's other ones as well, right?


00:17:20.220 --> 00:17:21.820
- Otherwise you'll get an error.


00:17:21.820 --> 00:17:23.880
- Yeah, right.


00:17:23.880 --> 00:17:27.740
So basically Pandas delegates to this library


00:17:27.740 --> 00:17:30.500
which actually understands Excel and writes to it.


00:17:30.500 --> 00:17:31.880
- Yes, yes, yeah.


00:17:31.880 --> 00:17:33.840
Another one, I think it was this one.


00:17:33.840 --> 00:17:37.220
Here, is it this one?


00:17:37.220 --> 00:17:40.540
Yeah, there's another one where it talks about


00:17:40.540 --> 00:17:44.560
using FSSpec.


00:17:44.560 --> 00:17:46.240
And this caught my attention as like,


00:17:46.240 --> 00:17:48.640
oh wow, this is way more flexible


00:17:48.640 --> 00:17:53.320
because I'm not sure people are aware of what FSSpec is.


00:17:53.320 --> 00:17:54.880
Are you familiar with FSSpec?


00:17:54.880 --> 00:17:55.880
- No, no.


00:17:55.880 --> 00:17:59.240
- So FSSpec is this library


00:17:59.240 --> 00:18:02.480
that allows you to treat different destinations


00:18:02.480 --> 00:18:04.840
as Python file systems, like, you know,


00:18:04.840 --> 00:18:07.640
with open some file name, instead of file name,


00:18:07.640 --> 00:18:09.680
you can do all sorts of stuff.


00:18:09.680 --> 00:18:14.680
So let me see if I can find some of the documentation here


00:18:14.680 --> 00:18:18.120
of the things that it can go to.


00:18:18.120 --> 00:18:21.440
Integrates with a bunch of different places,


00:18:21.440 --> 00:18:26.440
but I'm not sure which one it goes to,


00:18:26.840 --> 00:18:31.520
but it goes to places like S3 storage and FTP


00:18:31.520 --> 00:18:34.180
and database and zip files


00:18:34.180 --> 00:18:37.740
and all of these types of crazy things.


00:18:37.740 --> 00:18:39.520
And even there's caching I guess is right.


00:18:39.520 --> 00:18:42.520
So this Excel writer,


00:18:42.520 --> 00:18:44.140
while it already sounds really interesting


00:18:44.140 --> 00:18:45.520
because it writes to Excel,


00:18:45.520 --> 00:18:48.480
like destination of these Excel files,


00:18:48.480 --> 00:18:52.000
like this could be an Excel file in a database or something.


00:18:52.000 --> 00:18:55.400
With basically hardly any changes to the code.


00:18:55.400 --> 00:18:56.900
- Yes, yes.


00:18:56.900 --> 00:18:58.920
- Yeah, that's super cool.


00:18:58.920 --> 00:19:01.440
So good one to kick it off there.


00:19:01.440 --> 00:19:03.120
A lot going on.


00:19:03.120 --> 00:19:05.640
The next one is pipe, right?


00:19:05.640 --> 00:19:06.480
- Yeah.


00:19:06.480 --> 00:19:11.460
- Yeah, there's like a lumberjack looking dude


00:19:11.460 --> 00:19:13.360
smoking pipe there, that's very cool.


00:19:13.360 --> 00:19:14.280
- Yeah.


00:19:14.280 --> 00:19:15.920
- Yeah, tell us about pipe.


00:19:15.920 --> 00:19:19.200
- Yeah, so when you do data analysis,


00:19:19.200 --> 00:19:20.640
like most of the time,


00:19:20.640 --> 00:19:24.120
the data you'll be dealing with will be like not clean.


00:19:24.120 --> 00:19:26.560
you have to perform some operations.


00:19:26.560 --> 00:19:31.760
And Pype really offers a way to just package


00:19:31.760 --> 00:19:35.900
all those operations into a single line of code


00:19:35.900 --> 00:19:40.240
or into a single block of code.


00:19:40.240 --> 00:19:43.640
It's kind of like a scalar and pipelines,


00:19:43.640 --> 00:19:47.200
where you just have to run as only single line of code


00:19:47.200 --> 00:19:51.760
and it just performs several operations at the same time.


00:19:51.760 --> 00:19:54.720
It's really just a neat way to do data cleaning.


00:19:54.720 --> 00:19:58.840
- Right, and it's what's called a fluent API.


00:19:58.840 --> 00:20:01.120
So if I call data frame dot pipe,


00:20:01.120 --> 00:20:03.320
what comes back is another data frame.


00:20:03.320 --> 00:20:05.000
And then I could call dot pipe on it again


00:20:05.000 --> 00:20:08.920
and then dot pipe and dot pipe and chain those together,


00:20:08.920 --> 00:20:11.760
applying different operations and transformations.


00:20:11.760 --> 00:20:14.120
It's almost like a MapReduce


00:20:14.120 --> 00:20:16.680
or aggregation framework type of thing here, right?


00:20:16.680 --> 00:20:18.520
It's pretty flexible, I would think.


00:20:18.520 --> 00:20:21.680
- It's just like pandas in all its entirety.


00:20:21.680 --> 00:20:25.100
like the amazing, one of the amazing features of pandas


00:20:25.100 --> 00:20:27.900
like consistency, consistency, consistency.


00:20:27.900 --> 00:20:29.400
- Yeah, yeah, yeah.


00:20:29.400 --> 00:20:30.240
I really like it.


00:20:30.240 --> 00:20:31.380
It looks super neat.


00:20:31.380 --> 00:20:36.280
So you need to do transformations on a data frame


00:20:36.280 --> 00:20:39.200
with custom functions and get answers out.


00:20:39.200 --> 00:20:40.040
Yeah.


00:20:40.040 --> 00:20:42.740
Another thing that you pointed out here is that


00:20:42.740 --> 00:20:46.020
as part of this, you know,


00:20:46.020 --> 00:20:47.800
you could apply it to the whole data frame


00:20:47.800 --> 00:20:50.300
or you could pass a set of columns.


00:20:50.300 --> 00:20:51.140
- Yes.


00:20:51.140 --> 00:20:54.340
So right as what you're piping across, what does that do?


00:20:54.340 --> 00:20:56.660
That reduces the result to just those,


00:20:56.660 --> 00:20:59.360
if you pass in three things, just those three columns.


00:20:59.360 --> 00:21:03.300
- Yeah, these two functions remove outliers


00:21:03.300 --> 00:21:08.300
and code categoricals are functions that accept arguments.


00:21:08.300 --> 00:21:10.220
And when you pass it to pipe,


00:21:10.220 --> 00:21:13.100
you just have to pass the function name,


00:21:13.100 --> 00:21:14.620
which means you can pass the arguments.


00:21:14.620 --> 00:21:17.980
So to pass the arguments, actually,


00:21:17.980 --> 00:21:21.480
you just have to provide them after the comma.


00:21:21.480 --> 00:21:23.600
So this remove outliers function


00:21:23.600 --> 00:21:26.160
just accepts one argument as a list


00:21:26.160 --> 00:21:29.400
and it performs like outlier removal


00:21:29.400 --> 00:21:31.640
and just returns the whole data frame.


00:21:31.640 --> 00:21:32.480
- I see.


00:21:32.480 --> 00:21:34.000
So you can pass,


00:21:34.000 --> 00:21:36.040
like your function might take the data frame


00:21:36.040 --> 00:21:38.080
but it might also take additional information.


00:21:38.080 --> 00:21:41.280
Like I want to exclude things that are over $100


00:21:41.280 --> 00:21:42.600
and just throw them away.


00:21:42.600 --> 00:21:44.120
Well, you gotta pass that 100 in


00:21:44.120 --> 00:21:45.680
because it needs to know 100


00:21:45.680 --> 00:21:47.480
versus some other cutoff value, right?


00:21:47.480 --> 00:21:49.080
- Got it. - Yes, yes.


00:21:49.080 --> 00:21:50.380
- Okay, cool.


00:21:50.380 --> 00:21:53.560
And you say it resembles scikit-learn pipelines,


00:21:53.560 --> 00:21:55.360
which is, yeah, that's pretty cool.


00:21:55.360 --> 00:22:01.480
All right, we're up to number three, factorize.


00:22:01.480 --> 00:22:02.440
- Yeah.


00:22:02.440 --> 00:22:04.560
- Tell us about this one.


00:22:04.560 --> 00:22:06.640
- In machine learning, as you know,


00:22:06.640 --> 00:22:10.240
algorithms only accept numerical data,


00:22:10.240 --> 00:22:14.280
and most real-world data sets contain categoricals,


00:22:14.280 --> 00:22:17.400
which means like there are like a class one,


00:22:17.400 --> 00:22:18.840
class two or class three,


00:22:18.840 --> 00:22:22.240
and you have to encode them like to numeric,


00:22:22.240 --> 00:22:24.040
like zero, one, two, three,


00:22:24.040 --> 00:22:26.320
or using like one hundred encoder


00:22:26.320 --> 00:22:28.320
or label encoder in scikit-learn,


00:22:28.320 --> 00:22:30.960
but you can do that in pandas as well.


00:22:30.960 --> 00:22:34.560
You just have to pass the column to factorize


00:22:34.560 --> 00:22:38.920
and it just encodes them with numericals for each class.


00:22:38.920 --> 00:22:39.740
- I see.


00:22:39.740 --> 00:22:42.920
So let me see if I can give an audio friendly example


00:22:42.920 --> 00:22:44.840
for listeners here.


00:22:44.840 --> 00:22:48.720
If we've got something that says a data framework,


00:22:48.720 --> 00:22:52.280
one of the pieces is what the weather was like,


00:22:52.280 --> 00:22:57.280
sunny, rainy, sun, rain, snow, clouds, something like that.


00:22:57.280 --> 00:23:01.760
You can't feed sun to the machine learning model.


00:23:01.760 --> 00:23:03.520
You gotta give it a number, right?


00:23:03.520 --> 00:23:06.280
So this will convert that to like zero for sun


00:23:06.280 --> 00:23:09.160
and everywhere sun appeared, you would now have a zero,


00:23:09.160 --> 00:23:12.160
one for rain, everywhere there was a rain and so on.


00:23:12.160 --> 00:23:14.420
So it just does that, figures out how many different


00:23:14.420 --> 00:23:17.140
categories there are, and then it gives them a number


00:23:17.140 --> 00:23:19.300
that can be sent off to machine learning, right?


00:23:19.300 --> 00:23:20.140
- Yes, yes.


00:23:20.140 --> 00:23:21.300
You explained it there.


00:23:21.300 --> 00:23:23.140
- Awesome.


00:23:23.140 --> 00:23:23.960
See, I'm learning, right?


00:23:23.960 --> 00:23:26.100
I'm just following along with you here.


00:23:26.100 --> 00:23:27.540
Awesome.


00:23:27.540 --> 00:23:29.020
Okay, that's a really cool one.


00:23:29.020 --> 00:23:31.980
This next one seems a little bit crazy,


00:23:31.980 --> 00:23:33.620
but it looks very useful.


00:23:33.620 --> 00:23:34.500
Explode, right?


00:23:34.500 --> 00:23:35.340
What is explode?


00:23:35.340 --> 00:23:37.020
- Yes, yeah.


00:23:37.020 --> 00:23:39.260
As you know, like survey data,


00:23:39.260 --> 00:23:41.620
surveys usually contain questions


00:23:41.620 --> 00:23:49.500
are multiple choice, you can just pick a lot of like more than one answer to one question


00:23:49.500 --> 00:23:51.620
and that's recorded as one answer.


00:23:51.620 --> 00:23:57.380
So you just going to end up with this kind of list in a single cell of the table.


00:23:57.380 --> 00:24:04.900
Like a question, if you have a question one and the user just picks the answers A, B,


00:24:04.900 --> 00:24:09.940
C, it's going to end up A, B, C is going to end up as a list in a single cell of a table.


00:24:09.940 --> 00:24:10.940
Right.


00:24:10.940 --> 00:24:13.700
For an example here, you have a series that has one


00:24:13.700 --> 00:24:15.020
and then six and then seven.


00:24:15.020 --> 00:24:17.140
And then the fourth element is a list


00:24:17.140 --> 00:24:18.340
of three other numbers.


00:24:18.340 --> 00:24:19.180
And you're like, wait a minute,


00:24:19.180 --> 00:24:22.340
those are not supposed to just be multi-dimensional.


00:24:22.340 --> 00:24:23.980
I want a straight series, right?


00:24:23.980 --> 00:24:24.820
- Yes, yes.


00:24:24.820 --> 00:24:26.300
You want a straight series.


00:24:26.300 --> 00:24:28.740
And when you call explode on this series,


00:24:28.740 --> 00:24:32.140
it's gonna just expand the series vertically


00:24:32.140 --> 00:24:33.980
and just gonna fill up,


00:24:33.980 --> 00:24:38.100
just takes the elements of the single cell lists


00:24:38.100 --> 00:24:40.700
and just expands them vertically.


00:24:40.700 --> 00:24:43.680
- Okay, yeah, these are the types of things


00:24:43.680 --> 00:24:45.460
that you were talking about with loops, right?


00:24:45.460 --> 00:24:47.540
Like it would be real easy to go through and say,


00:24:47.540 --> 00:24:48.980
I'm gonna build up a new data frame


00:24:48.980 --> 00:24:50.800
and if I see a list instead of a number,


00:24:50.800 --> 00:24:52.640
I'm gonna just start appending those from the list


00:24:52.640 --> 00:24:55.660
with an inner loop and then we'll carry on, right?


00:24:55.660 --> 00:24:58.180
And here you've literally done it in one line.


00:24:58.180 --> 00:25:00.000
- Yeah, yeah, this would be crazy complex


00:25:00.000 --> 00:25:01.400
if you did it like manually.


00:25:01.400 --> 00:25:04.780
- Right, and honestly slower, right?


00:25:04.780 --> 00:25:07.140
Because a lot of this is probably implemented in C,


00:25:07.140 --> 00:25:10.100
whereas you would be doing it at the Python layer.


00:25:10.100 --> 00:25:12.500
- Yeah, yeah, it's gonna be very slow.


00:25:12.500 --> 00:25:15.020
- All right, another question from Brandon out there,


00:25:15.020 --> 00:25:17.260
glad he's here in the live stream.


00:25:17.260 --> 00:25:20.880
How would I apply explode to the entire data frame?


00:25:20.880 --> 00:25:23.560
I'm guessing he's thinking about maybe


00:25:23.560 --> 00:25:25.200
if you had multiple columns


00:25:25.200 --> 00:25:27.660
and they each potentially had this.


00:25:27.660 --> 00:25:29.380
- I don't think that's possible.


00:25:29.380 --> 00:25:30.220
- Yeah.


00:25:30.220 --> 00:25:31.860
- I don't think pandas allows that.


00:25:31.860 --> 00:25:34.980
- Yeah, okay, so it's gotta be on a series,


00:25:34.980 --> 00:25:37.020
not on a data frame. - Yeah, all as equal.


00:25:37.020 --> 00:25:38.120
- Right, got it, okay.


00:25:39.620 --> 00:25:42.980
- Cool, so these are fun names that stand out.


00:25:42.980 --> 00:25:45.060
- Yeah, very fun names, yeah.


00:25:45.060 --> 00:25:47.020
- Yeah, and you pick some cool pictures, right?


00:25:47.020 --> 00:25:48.260
- Yeah, yeah.


00:25:48.260 --> 00:25:50.180
- All right, so what's the next one?


00:25:50.180 --> 00:25:51.020
- Squeeze.


00:25:51.020 --> 00:25:52.500
- Squeeze.


00:25:52.500 --> 00:25:54.080
- Yeah, as you can see,


00:25:54.080 --> 00:25:58.660
like there is some conditional operators


00:25:58.660 --> 00:26:02.940
return like real, like data frames,


00:26:02.940 --> 00:26:03.940
even it's a single cell,


00:26:03.940 --> 00:26:06.980
like as you can see this from the subset set,


00:26:07.860 --> 00:26:10.500
we are just asking the diamonds data frame


00:26:10.500 --> 00:26:14.940
to return all diamonds that are priced below $1


00:26:14.940 --> 00:26:19.940
and it just returns a single result, which is 326.


00:26:19.940 --> 00:26:22.020
But it's returned as a data frame,


00:26:22.020 --> 00:26:24.020
which is not comfortable to work with,


00:26:24.020 --> 00:26:25.820
like a single cell data frame.


00:26:25.820 --> 00:26:27.820
- Right, because Panda doesn't know ahead of time


00:26:27.820 --> 00:26:31.340
that a .luck call is gonna result in a single item.


00:26:31.340 --> 00:26:32.980
This happens a lot in databases too.


00:26:32.980 --> 00:26:37.100
You do a query and the result is actually a single thing,


00:26:37.100 --> 00:26:39.380
but the framework has no way to know


00:26:39.380 --> 00:26:42.100
that the data is structured in a way that's unique


00:26:42.100 --> 00:26:43.240
or that's a one thing.


00:26:43.240 --> 00:26:46.660
And I suspect that's common here with data frames as well.


00:26:46.660 --> 00:26:49.000
You're structured, like I know this is gonna give me


00:26:49.000 --> 00:26:50.360
the one answer.


00:26:50.360 --> 00:26:52.580
- Yeah, but it just reduces the whole table.


00:26:52.580 --> 00:26:53.420
- Yeah, yeah, you're like,


00:26:53.420 --> 00:26:54.860
"God, well now I gotta like dig in


00:26:54.860 --> 00:26:57.260
and say, give me the first row, first column."


00:26:57.260 --> 00:26:58.140
Yeah, okay.


00:26:58.140 --> 00:26:59.700
So Squeeze helps fix this?


00:26:59.700 --> 00:27:03.420
- Yeah, you just call this Squeeze on a single cell


00:27:03.420 --> 00:27:04.620
data frame or series,


00:27:04.620 --> 00:27:07.740
and just it removes all the dimensionality


00:27:07.740 --> 00:27:09.840
and just returns the number.


00:27:09.840 --> 00:27:11.300
- Interesting, that's cool.


00:27:11.300 --> 00:27:13.280
What happens if I call it on one


00:27:13.280 --> 00:27:15.580
that's got more than one item, do you know?


00:27:15.580 --> 00:27:16.860
Does it just give you the first


00:27:16.860 --> 00:27:19.300
or does it freak out and let you know?


00:27:19.300 --> 00:27:21.460
- Yeah, I think I never tried that.


00:27:21.460 --> 00:27:23.020
(laughs)


00:27:23.020 --> 00:27:24.420
Yeah, I never tried that.


00:27:24.420 --> 00:27:25.540
- Yeah, don't do that, right?


00:27:25.540 --> 00:27:29.820
It's like, maybe if you just actually want the first answer,


00:27:29.820 --> 00:27:31.860
maybe it's okay, but it also might give you an exception.


00:27:31.860 --> 00:27:34.060
- You might be fine to try it now.


00:27:34.060 --> 00:27:35.660
- Yeah, exactly.


00:27:35.660 --> 00:27:37.620
Cool, so the next one has to do


00:27:37.620 --> 00:27:40.280
with finding things in a range, right?


00:27:40.280 --> 00:27:41.480
- Yeah, between, yeah.


00:27:41.480 --> 00:27:44.680
Yeah, it's like, just the name suggests,


00:27:44.680 --> 00:27:47.500
like you wanna take all the rows


00:27:47.500 --> 00:27:50.340
that are in between some range.


00:27:50.340 --> 00:27:52.940
For example, here in the code example,


00:27:52.940 --> 00:27:55.540
I'm choosing all diamonds that are priced


00:27:55.540 --> 00:27:58.840
between $3,500 and $3,700.


00:27:58.840 --> 00:28:03.360
- Nice, so of course you could do this


00:28:03.360 --> 00:28:05.240
probably as an expression.


00:28:05.240 --> 00:28:06.080
- Yeah.


00:28:06.080 --> 00:28:08.040
- You could definitely do this as a loop.


00:28:08.040 --> 00:28:08.880
- Yeah, yeah.


00:28:08.880 --> 00:28:11.120
- But both of those are slower, I'm sure,


00:28:11.120 --> 00:28:13.480
'cause they're not implemented internally, right?


00:28:13.480 --> 00:28:14.640
- Yeah, less elegant.


00:28:14.640 --> 00:28:18.660
This one is better and faster and shorter.


00:28:18.660 --> 00:28:20.720
- Yeah, one of the things,


00:28:20.720 --> 00:28:23.440
the third parameter you can pass here to between,


00:28:23.440 --> 00:28:25.640
in addition to like the lower bound and upper bound,


00:28:25.640 --> 00:28:28.800
is whether or not it includes the endpoints, right?


00:28:28.800 --> 00:28:30.040
- Yes, yes.


00:28:30.040 --> 00:28:33.320
Yeah, this one is inclusive is neither,


00:28:33.320 --> 00:28:36.400
So it's like a open set.


00:28:36.400 --> 00:28:38.360
- Nice.


00:28:38.360 --> 00:28:39.620
Another thing that I've seen here,


00:28:39.620 --> 00:28:42.160
which is not one of your 25, but it looks nice.


00:28:42.160 --> 00:28:47.160
I'm used to visualizing, quickly visualizing a data frame


00:28:47.160 --> 00:28:49.880
when I get it back with head or tail.


00:28:49.880 --> 00:28:51.000
And I wanna know like, okay,


00:28:51.000 --> 00:28:52.840
kind of what did I get back here?


00:28:52.840 --> 00:28:54.120
Show me the front, that'll be good.


00:28:54.120 --> 00:28:55.920
Do a head or let's go to the end


00:28:55.920 --> 00:28:56.960
and see what happened at the end.


00:28:56.960 --> 00:28:58.360
But here you have dot sample.


00:28:58.360 --> 00:28:59.600
That's interesting.


00:28:59.600 --> 00:29:02.200
- Yeah, I usually, I use it often


00:29:02.200 --> 00:29:05.620
because some data sets have like ordering,


00:29:05.620 --> 00:29:08.680
for example, time series data sets.


00:29:08.680 --> 00:29:13.080
And the first few rows might be not too representative


00:29:13.080 --> 00:29:14.600
of the whole data frame.


00:29:14.600 --> 00:29:19.060
So I just call sample with like five or 10 rows


00:29:19.060 --> 00:29:21.600
and that randomly samples the data set


00:29:21.600 --> 00:29:24.840
and usually sometimes that shows the,


00:29:24.840 --> 00:29:27.960
that represents the data set better than head or tail.


00:29:27.960 --> 00:29:29.400
- Right, exactly.


00:29:29.400 --> 00:29:31.360
And so it just kind of randomly picks some stuff


00:29:31.360 --> 00:29:34.340
throughout the dataset to show you what's going on, right?


00:29:34.340 --> 00:29:36.320
For large datasets, that's really handy.


00:29:36.320 --> 00:29:37.160
Nice to know.


00:29:37.160 --> 00:29:42.320
So the next one has to do with, I'm guessing,


00:29:42.320 --> 00:29:46.420
like when you're doing matrix multiplication and vectors


00:29:46.420 --> 00:29:49.280
and like truly doing math,


00:29:49.280 --> 00:29:51.280
most of the time I would expect this to show up.


00:29:51.280 --> 00:29:53.520
- Yeah, most of the time, yes.


00:29:53.520 --> 00:29:55.520
Yeah, transpose, yeah.


00:29:55.520 --> 00:29:56.360
- Yeah.


00:29:56.360 --> 00:29:57.800
- It's time for transpose.


00:29:57.800 --> 00:30:03.160
I usually, you usually don't do math or metrics multiplication in pandas.


00:30:03.160 --> 00:30:10.640
You'll do it in NumPy, but this one I use it mostly for when you, on the result of describe.


00:30:10.640 --> 00:30:15.720
You see here, describe returns the axis inverted.


00:30:15.720 --> 00:30:19.400
So the five number summary is given as rows.


00:30:21.000 --> 00:30:23.480
And that's really a problem when you have multiple columns


00:30:23.480 --> 00:30:28.320
because the dataset starts to expand horizontally,


00:30:28.320 --> 00:30:33.320
which makes you scroll to the right,


00:30:33.320 --> 00:30:34.160
which you don't want.


00:30:34.160 --> 00:30:35.360
- Right, so when you do describe,


00:30:35.360 --> 00:30:37.000
you get things like given a dataset,


00:30:37.000 --> 00:30:40.700
it'll say, here's the count of this index,


00:30:40.700 --> 00:30:42.080
the mean of this index,


00:30:42.080 --> 00:30:46.080
or this value of a column,


00:30:46.080 --> 00:30:47.640
standard deviation and so on.


00:30:47.640 --> 00:30:49.880
And the number of options there is unbounded,


00:30:49.880 --> 00:30:52.640
but the fact that it goes count mean standard deviation


00:30:52.640 --> 00:30:54.840
minimum and then a few more things that's fixed


00:30:54.840 --> 00:30:55.720
and that fits pretty well.


00:30:55.720 --> 00:30:59.680
So you're saying if you transpose or like flip the rows


00:30:59.680 --> 00:31:02.240
and columns so that you make it go vertical


00:31:02.240 --> 00:31:04.680
instead of across, that's an easier way to look at it.


00:31:04.680 --> 00:31:05.840
- Yeah, yeah.


00:31:05.840 --> 00:31:08.060
- Yeah, I agree.


00:31:08.060 --> 00:31:08.900
- Yeah.


00:31:08.900 --> 00:31:10.200
- And it's as easy as saying dot T.


00:31:10.200 --> 00:31:11.840
So it's not too hard to do, right?


00:31:11.840 --> 00:31:12.680
You might as well.


00:31:12.680 --> 00:31:14.400
- Yeah, it's an attribute, yeah.


00:31:14.400 --> 00:31:15.280
- Yeah, cool.


00:31:15.280 --> 00:31:18.640
All right, yeah, that's a really good one.


00:31:19.560 --> 00:31:21.720
So you're saying if I'm gonna do


00:31:21.720 --> 00:31:23.880
like some kind of matrix multiplication stuff,


00:31:23.880 --> 00:31:25.200
I should not do it in pandas,


00:31:25.200 --> 00:31:26.840
I should just stick to NumPy?


00:31:26.840 --> 00:31:27.680
- Yeah, yeah, yeah.


00:31:27.680 --> 00:31:30.840
NumPy is like purely for mathematical purposes


00:31:30.840 --> 00:31:32.920
and it's much faster than pandas.


00:31:32.920 --> 00:31:34.760
- Yeah.


00:31:34.760 --> 00:31:37.800
I suspect that NumPy has a good transpose as well, but.


00:31:37.800 --> 00:31:39.080
- Yeah, yeah.


00:31:39.080 --> 00:31:41.080
It has the same attribute.


00:31:41.080 --> 00:31:42.680
- Interesting, okay.


00:31:42.680 --> 00:31:45.380
Yeah, there's a lot of synergy between those two libraries.


00:31:45.380 --> 00:31:48.040
So the next one has to do with styling things


00:31:48.040 --> 00:31:49.880
and how they look, right?


00:31:49.880 --> 00:31:52.460
One of the things that's cool about Pandas


00:31:52.460 --> 00:31:55.680
is it mixes well with Jupyter Notebooks


00:31:55.680 --> 00:31:58.600
and Jupyter Notebooks have a nice sort of explore the data


00:31:58.600 --> 00:31:59.480
and let's see what's going on.


00:31:59.480 --> 00:32:00.560
Let me just look at it, right?


00:32:00.560 --> 00:32:03.620
So this styler thing, that style attribute


00:32:03.620 --> 00:32:06.600
helps you with that, right?


00:32:06.600 --> 00:32:10.360
- Yeah, here like it takes advantage of that,


00:32:10.360 --> 00:32:14.400
the fact that Jupyter uses HTML and CSS under the hood.


00:32:15.280 --> 00:32:18.200
So you can take advantage of that


00:32:18.200 --> 00:32:20.880
and use some HTML and CSS knowledge


00:32:20.880 --> 00:32:23.440
to style your data frame based on some


00:32:23.440 --> 00:32:25.960
like I found it loops or conditionals.


00:32:25.960 --> 00:32:29.880
Here, for example, after you take the transports


00:32:29.880 --> 00:32:34.720
of the describe, you can just highlight the maximums


00:32:34.720 --> 00:32:39.720
of each row or column using the highlight.max function.


00:32:39.720 --> 00:32:42.400
Yeah, the pandas offers a lot of functions


00:32:42.400 --> 00:32:44.240
after the style attribute.


00:32:44.240 --> 00:32:47.920
you can just, you can use the built-in functions


00:32:47.920 --> 00:32:51.840
or you can come up with some custom logic


00:32:51.840 --> 00:32:54.740
to style your data frame using HTML and CSS.


00:32:54.740 --> 00:32:56.240
- Okay.


00:32:56.240 --> 00:32:57.160
Yeah, this is great.


00:32:57.160 --> 00:33:02.160
So you can say, for example, here .style.highlight_max


00:33:02.160 --> 00:33:04.400
and then you give it some CSS values


00:33:04.400 --> 00:33:06.160
like color is dark red or something like that, right?


00:33:06.160 --> 00:33:07.000
- Yeah, yeah.


00:33:07.000 --> 00:33:11.520
So like, you just don't have to look at the raw numbers.


00:33:11.520 --> 00:33:15.120
it just shows you the most important metrics


00:33:15.120 --> 00:33:16.900
or the ones that you want.


00:33:16.900 --> 00:33:19.980
It's really useful when you have like multiple columns,


00:33:19.980 --> 00:33:22.380
you just don't wanna have to,


00:33:22.380 --> 00:33:24.920
you just don't wanna look at all those crazy numbers


00:33:24.920 --> 00:33:27.960
and you just use some.


00:33:27.960 --> 00:33:31.000
- Yeah, like a real reasonable


00:33:31.000 --> 00:33:33.120
or maybe straightforward thing you might start up


00:33:33.120 --> 00:33:33.960
by doing this.


00:33:33.960 --> 00:33:35.040
Well, let me just sort it.


00:33:35.040 --> 00:33:36.800
We'll sort it so the highest one's at the top,


00:33:36.800 --> 00:33:41.080
but in this example, you've got multiple columns


00:33:41.080 --> 00:33:44.200
And the max of one column is in one value,


00:33:44.200 --> 00:33:45.840
but it's a different row


00:33:45.840 --> 00:33:48.280
for a different attribute of it, right?


00:33:48.280 --> 00:33:50.720
And so sorting it is gonna do nothing


00:33:50.720 --> 00:33:53.080
except for like, if you come up


00:33:53.080 --> 00:33:54.160
with a whole bunch of variation,


00:33:54.160 --> 00:33:56.600
then try to look at it and a little bit of color,


00:33:56.600 --> 00:33:58.160
a little bit of picture goes a long ways.


00:33:58.160 --> 00:34:00.320
- Yeah, yeah, visual.


00:34:00.320 --> 00:34:01.360
- Yeah, absolutely.


00:34:01.360 --> 00:34:06.000
Yeah, the second example you have here in your article


00:34:06.000 --> 00:34:07.160
is the one you wanna do, Ans.


00:34:07.160 --> 00:34:08.160
This looks great.


00:34:08.160 --> 00:34:09.000
Tell us about that.


00:34:09.000 --> 00:34:10.880
- Yeah, this one is like background gradients.


00:34:10.880 --> 00:34:15.880
So it just colors each cell of the column


00:34:15.880 --> 00:34:18.160
based on its magnitude.


00:34:18.160 --> 00:34:21.920
It's kind of like a few palettes,


00:34:21.920 --> 00:34:24.240
like it's kind of like continuous palette.


00:34:24.240 --> 00:34:28.360
It just shows where the maximum or the minimums are


00:34:28.360 --> 00:34:31.440
and just how they compare to each other.


00:34:31.440 --> 00:34:34.280
- Yeah, it's almost like if you could do a heat map


00:34:34.280 --> 00:34:36.040
in an Excel table,


00:34:36.040 --> 00:34:38.540
by making the cells different colors, right?


00:34:38.540 --> 00:34:40.920
- You can pass in a color map and all sorts of stuff


00:34:40.920 --> 00:34:42.280
to control how that looks.


00:34:42.280 --> 00:34:43.120
- Yeah, yeah.


00:34:43.120 --> 00:34:44.980
- Yeah, cool, I like it.


00:34:44.980 --> 00:34:45.820
This is great.


00:34:45.820 --> 00:34:48.620
You know, it's one of these things where, again,


00:34:48.620 --> 00:34:51.460
one line of code and you can dramatically improve


00:34:51.460 --> 00:34:54.000
the presentation value or the informational value


00:34:54.000 --> 00:34:55.440
of what you're looking at, right?


00:34:55.440 --> 00:34:58.000
- Yeah, yeah.


00:34:58.000 --> 00:34:59.940
- Nice, all right.


00:34:59.940 --> 00:35:02.480
I feel like that's similar to your number nine.


00:35:02.480 --> 00:35:06.400
- Yeah, this one is Panasonic options.


00:35:06.400 --> 00:35:09.080
like it's kind of settings of your phone.


00:35:09.080 --> 00:35:11.500
You just set them globally and it applies


00:35:11.500 --> 00:35:14.320
to all the data frames, series and all the functions


00:35:14.320 --> 00:35:17.620
that you're gonna be using inside the project


00:35:17.620 --> 00:35:20.100
or inside the session of Jupyter Notebook.


00:35:20.100 --> 00:35:24.420
- Yeah, so if you wanna have some sort of


00:35:24.420 --> 00:35:28.100
number of columns that are shown


00:35:28.100 --> 00:35:29.940
or some kind of color or something like that,


00:35:29.940 --> 00:35:32.060
you can just set that up at the beginning.


00:35:32.060 --> 00:35:34.580
- Yeah, yeah, you just don't have to call them


00:35:34.580 --> 00:35:37.220
every single time or change them every single time.


00:35:37.220 --> 00:35:40.580
It's just a shorthand of way of doing things


00:35:40.580 --> 00:35:43.020
like setting global settings.


00:35:43.020 --> 00:35:45.740
- Yeah, you could probably even do something like


00:35:45.740 --> 00:35:48.900
have a little JSON file that describes the look and feel


00:35:48.900 --> 00:35:49.960
of what you're doing.


00:35:49.960 --> 00:35:53.500
Just the first line, just load it up and set it


00:35:53.500 --> 00:35:56.700
and then go from there, something to that effect, right?


00:35:56.700 --> 00:35:57.540
- Yeah, yeah.


00:35:57.540 --> 00:35:59.500
- Yeah, so you don't have to completely fill


00:35:59.500 --> 00:36:03.100
the first few lines of your notebook with like setup code.


00:36:03.100 --> 00:36:05.600
- Yeah, for example, one of those examples is like


00:36:05.600 --> 00:36:08.780
display max rows.


00:36:08.780 --> 00:36:13.500
If you set it to five and you just call the data frame,


00:36:13.500 --> 00:36:15.820
it's gonna only show the first five rows.


00:36:15.820 --> 00:36:18.700
So you don't have to call .hat every time.


00:36:18.700 --> 00:36:19.940
- Oh, I see.


00:36:19.940 --> 00:36:21.120
That's interesting, yeah.


00:36:21.120 --> 00:36:23.380
'Cause of course, if there's enough rows,


00:36:23.380 --> 00:36:24.780
it won't print the whole thing out, right?


00:36:24.780 --> 00:36:25.860
Probably. - Yeah.


00:36:25.860 --> 00:36:27.420
- Yeah, you don't wanna print 10 million rows


00:36:27.420 --> 00:36:29.740
and completely lock up the system, yeah.


00:36:29.740 --> 00:36:31.500
- Yeah, yeah, yeah, that's gonna...


00:36:32.900 --> 00:36:34.860
- Cool, oh, and another one that's kind of nice


00:36:34.860 --> 00:36:37.060
is display precision.


00:36:37.060 --> 00:36:42.060
And if you set that, you won't see the 1.27e to the five,


00:36:42.060 --> 00:36:43.780
or whatever, right?


00:36:43.780 --> 00:36:46.780
- Yeah, it's really annoying when you're working


00:36:46.780 --> 00:36:49.560
with math functions.


00:36:49.560 --> 00:36:52.920
It just keeps giving in scientific notation


00:36:52.920 --> 00:36:55.540
when you just want to see the first


00:36:55.540 --> 00:36:57.780
or fourth or fifth decimal places.


00:36:57.780 --> 00:36:59.820
- Yeah, scientific notation is great


00:36:59.820 --> 00:37:01.380
when you're dealing with huge numbers


00:37:01.380 --> 00:37:03.300
are tremendously small numbers, right?


00:37:03.300 --> 00:37:06.120
Like how many meters across is an atom?


00:37:06.120 --> 00:37:08.740
Okay, so you're gonna need a E to something.


00:37:08.740 --> 00:37:11.300
But for human beings, often,


00:37:11.300 --> 00:37:12.740
you wanna just look at the number and go,


00:37:12.740 --> 00:37:16.740
yeah, that's a million, not like 1.2 E to the six or seven,


00:37:16.740 --> 00:37:17.580
whatever.


00:37:17.580 --> 00:37:19.740
- Yeah, yeah, that's gonna be really annoying.


00:37:19.740 --> 00:37:20.780
- That's cool.


00:37:20.780 --> 00:37:22.620
And this is just one of those options you can set up


00:37:22.620 --> 00:37:24.980
and it just globally applies to that notebook.


00:37:24.980 --> 00:37:25.820
- Yeah, yeah.


00:37:25.820 --> 00:37:29.340
- So another thing that's interesting about pandas


00:37:29.340 --> 00:37:34.340
is the columns have types usually, but not always?


00:37:34.340 --> 00:37:37.020
- Yeah.


00:37:37.020 --> 00:37:41.260
Yeah, it's one of those like beginning level things


00:37:41.260 --> 00:37:44.420
that you will encounter, but it can get really annoying


00:37:44.420 --> 00:37:48.040
if the data types are incorrect for your column.


00:37:48.040 --> 00:37:52.260
The most important one is the object data type.


00:37:52.260 --> 00:37:54.260
- Right, that's like, I don't really know,


00:37:54.260 --> 00:37:55.740
so we're just gonna store it.


00:37:55.740 --> 00:37:59.260
- Yeah, yeah, I'm just gonna put it inside of an object


00:37:59.260 --> 00:38:04.260
and objects are like, object data type is the worst one.


00:38:04.260 --> 00:38:07.540
It also limits the functionality of pandas


00:38:07.540 --> 00:38:09.700
and it's also the most memory consuming.


00:38:09.700 --> 00:38:13.860
- Right, so the next function,


00:38:13.860 --> 00:38:15.860
what number are we on here, number 10?


00:38:15.860 --> 00:38:16.700
- 10, yes.


00:38:16.700 --> 00:38:20.540
- In the hit list is convert_dtypes,


00:38:20.540 --> 00:38:22.740
as in convert data types.


00:38:22.740 --> 00:38:25.900
- Yeah, it just, when you call it on the whole data frame,


00:38:25.900 --> 00:38:30.260
It just, it tries to infer the correct data type


00:38:30.260 --> 00:38:31.240
for each column.


00:38:31.240 --> 00:38:37.260
It's either, if it's a float or integer or string like that.


00:38:37.260 --> 00:38:40.580
- Yeah, so your example, you're reading a CSV file


00:38:40.580 --> 00:38:44.300
and some of the columns are detected correctly like floats,


00:38:44.300 --> 00:38:45.620
but others get this object.


00:38:45.620 --> 00:38:47.580
But after calling convertDtypes, it's like, you know what?


00:38:47.580 --> 00:38:48.980
No, those are strings.


00:38:48.980 --> 00:38:49.820
- Yeah, yeah.


00:38:49.820 --> 00:38:53.500
But it can handle date times


00:38:53.500 --> 00:38:56.500
because there are so many daytime formats


00:38:56.500 --> 00:38:59.800
and pandas can't possibly know all of them.


00:38:59.800 --> 00:39:01.580
- Why are date times so hard?


00:39:01.580 --> 00:39:03.760
It really shouldn't be, but they really are.


00:39:03.760 --> 00:39:04.960
It's crazy.


00:39:04.960 --> 00:39:07.740
And then you throw in time zones and you'll forget it.


00:39:07.740 --> 00:39:08.580
Okay.


00:39:08.580 --> 00:39:11.140
And throw in daylight savings and all these other things.


00:39:11.140 --> 00:39:11.980
- Oh yeah, yeah, yeah.


00:39:11.980 --> 00:39:13.300
That's crazy.


00:39:13.300 --> 00:39:15.180
Yeah, daylight saving is crazy.


00:39:15.180 --> 00:39:18.020
- Yeah, I suspect some of the Kaggle stuff,


00:39:18.020 --> 00:39:19.100
part of the challenge is like,


00:39:19.100 --> 00:39:22.060
normalize these dates because who knows


00:39:22.060 --> 00:39:23.860
or something along those lines.


00:39:23.860 --> 00:39:26.340
- Time zones are like total mess.


00:39:26.340 --> 00:39:28.300
- Yeah, for sure.


00:39:28.300 --> 00:39:33.300
So related to converting the data types is to select them.


00:39:33.300 --> 00:39:37.460
Yeah, which is a way to filter what's in there.


00:39:37.460 --> 00:39:41.220
Like you can filter by column or rows or even a condition,


00:39:41.220 --> 00:39:44.180
but this is saying like, I only want the strings


00:39:44.180 --> 00:39:46.300
or I only want the numbers, right?


00:39:46.300 --> 00:39:49.340
- Yeah, while doing machine learning,


00:39:49.340 --> 00:39:53.220
you have to apply certain pre-processing functions


00:39:53.220 --> 00:39:55.140
to only a subsets of the data frame,


00:39:55.140 --> 00:39:58.320
like only on categoricals or only numerics.


00:39:58.320 --> 00:40:01.740
So this function will become very handy.


00:40:01.740 --> 00:40:05.480
You just wanna, you just pass the data type


00:40:05.480 --> 00:40:10.280
as a using NumPy, and it just gives all the subset


00:40:10.280 --> 00:40:12.840
of the data frame with that data type.


00:40:12.840 --> 00:40:15.960
- Nice, so you would say like data frame dot select


00:40:15.960 --> 00:40:18.720
data types and then include equals NP number.


00:40:18.720 --> 00:40:21.600
And now instantly the resulting data frame


00:40:21.600 --> 00:40:23.960
is a subset that only has numbers, right?


00:40:23.960 --> 00:40:25.100
- Yes.


00:40:25.100 --> 00:40:25.940
- That's cool.


00:40:25.940 --> 00:40:27.780
And then also you point out that you can do the reverse,


00:40:27.780 --> 00:40:30.880
just like give you just the other,


00:40:30.880 --> 00:40:33.800
like just the informational bits,


00:40:33.800 --> 00:40:35.360
like categories and stuff.


00:40:35.360 --> 00:40:36.320
- Categories.


00:40:36.320 --> 00:40:37.880
- Yeah, yeah.


00:40:37.880 --> 00:40:39.920
Cool, by saying exclude.


00:40:39.920 --> 00:40:41.180
- Yeah.


00:40:41.180 --> 00:40:42.020
- Very nice.


00:40:42.020 --> 00:40:45.520
Okay, well, we just missed it with the Halloween here.


00:40:45.520 --> 00:40:47.240
- Yeah, yeah, mask.


00:40:47.240 --> 00:40:48.080
- But mask.


00:40:48.080 --> 00:40:50.520
You know, you've got a cool picture of like a mask here,


00:40:50.520 --> 00:40:54.400
but mask is number 12.


00:40:54.400 --> 00:40:55.240
- 12.


00:40:55.240 --> 00:40:56.760
- That's about it.


00:40:56.760 --> 00:40:59.280
- Yeah, it's a conditional.


00:40:59.280 --> 00:41:04.000
You can use it on series or data frames,


00:41:04.000 --> 00:41:08.480
and it just returns the subset of the data


00:41:08.480 --> 00:41:10.360
where some condition is true.


00:41:10.360 --> 00:41:13.760
- Yeah, okay.


00:41:13.760 --> 00:41:17.080
So yeah, in this example here,


00:41:17.080 --> 00:41:18.880
you've got a bunch of ages.


00:41:18.880 --> 00:41:20.240
- Yeah.


00:41:20.240 --> 00:41:25.240
And I wanna take all those rows


00:41:25.240 --> 00:41:29.360
that are beyond 60 or below 50


00:41:29.360 --> 00:41:31.760
and convert those values to NAND.


00:41:31.760 --> 00:41:32.600
- Got it.


00:41:32.600 --> 00:41:35.120
Okay, so this is like an in-place update


00:41:35.120 --> 00:41:36.360
or I guess it replaces,


00:41:36.360 --> 00:41:39.400
creates another one that is like as if you updated it


00:41:39.400 --> 00:41:42.560
and it finds all the stuff that's,


00:41:42.560 --> 00:41:45.040
I guess, outside of your range


00:41:45.040 --> 00:41:47.080
and it applies this other value, right?


00:41:47.080 --> 00:41:48.840
Like if it's stuff that's outside of this range,


00:41:48.840 --> 00:41:50.580
in this case, you're gonna set it to not a number,


00:41:50.580 --> 00:41:55.580
but it could be set to zero or max or anything.


00:41:55.580 --> 00:41:56.680
- Yeah.


00:41:56.680 --> 00:41:57.960
- Cool.


00:41:57.960 --> 00:41:58.800
All right.


00:41:58.800 --> 00:42:00.800
A very good one.


00:42:00.800 --> 00:42:03.320
Similar, I guess, is min and max.


00:42:03.320 --> 00:42:04.160
And then some of these,


00:42:04.160 --> 00:42:06.720
as we get a little farther down your recommendations,


00:42:06.720 --> 00:42:08.700
I like them.


00:42:08.700 --> 00:42:11.240
They're not just, oh, here, you can apply this function,


00:42:11.240 --> 00:42:14.320
but apply it in this scenario or this context


00:42:14.320 --> 00:42:15.640
get an interesting outcome, right?


00:42:15.640 --> 00:42:18.000
So that's what number 13 is like.


00:42:18.000 --> 00:42:21.320
Min and max along columns axis.


00:42:21.320 --> 00:42:22.560
- Yeah, yeah.


00:42:22.560 --> 00:42:26.960
So usually when you call min and max on a column,


00:42:26.960 --> 00:42:30.840
it just returns the minimum or maximum of that column.


00:42:30.840 --> 00:42:33.520
But sometimes you want it to row wise,


00:42:33.520 --> 00:42:36.880
like it just treats rows as columns


00:42:36.880 --> 00:42:40.760
and it gives min and max across the rows.


00:42:40.760 --> 00:42:46.920
that's usually useful and a handy way of doing something that would take a lot of code if you're


00:42:46.920 --> 00:42:52.680
done manually. Yeah, another one of these tricks that or techniques that lets you avoid looping,


00:42:52.680 --> 00:42:58.920
right? Yeah, here I show a good example of like comparing four different libraries on five data


00:42:58.920 --> 00:43:07.640
sets and you want the best performance on each data set so you have to find the best score across


00:43:07.640 --> 00:43:15.080
the rows. Right, exactly. So the columns are the different libraries like XGBoost,


00:43:15.080 --> 00:43:19.640
CatBoost, scikit-learn and so on being applied to the same data set. And you want to go for


00:43:19.640 --> 00:43:25.640
row one, what one did the best? Row two, what one did the best? Yeah. Yeah. Yeah. Very nice.


00:43:25.640 --> 00:43:35.040
Deep down manually. Yeah. Cool. All right. Number 14, n largest and n smallest. Yeah,


00:43:35.040 --> 00:43:39.200
We're just talking about those max or minimums.


00:43:39.200 --> 00:43:44.200
So, and largest, when you pass a number and a column name,


00:43:44.200 --> 00:43:48.080
it just returns the data frame that contains the smallest


00:43:48.080 --> 00:43:52.020
or largest and rows of that column.


00:43:52.020 --> 00:43:55.880
- Nice, so if I were to call min or max,


00:43:55.880 --> 00:43:57.360
that would give me the smallest


00:43:57.360 --> 00:43:59.760
or the largest one respectively, right?


00:43:59.760 --> 00:44:00.600
- Yes.


00:44:00.600 --> 00:44:02.720
- But a really interesting or common question you might have


00:44:02.720 --> 00:44:07.720
is like, what are the top 10 selling products this month?


00:44:07.720 --> 00:44:08.720
Right?


00:44:08.720 --> 00:44:11.840
And this lets you just say, enlarges 10,


00:44:11.840 --> 00:44:14.040
and then you pick the column on which to judge it.


00:44:14.040 --> 00:44:15.520
Here you have price, right?


00:44:15.520 --> 00:44:16.340
- Yeah, yeah.


00:44:16.340 --> 00:44:19.200
Five most expensive diamonds in the diamonds dataset.


00:44:19.200 --> 00:44:20.600
- Yeah.


00:44:20.600 --> 00:44:23.120
Yeah, again, one of these things that, you know,


00:44:23.120 --> 00:44:24.760
no more looping or any of that stuff,


00:44:24.760 --> 00:44:27.680
no more if statements, just call it, right?


00:44:27.680 --> 00:44:28.520
- Yeah.


00:44:28.520 --> 00:44:31.520
This one is like the five cheapest, most cheapest diamonds.


00:44:31.520 --> 00:44:32.360
- Hmm.


00:44:32.360 --> 00:44:33.200
- Yeah.


00:44:33.200 --> 00:44:34.020
- Yeah.


00:44:34.020 --> 00:44:34.860
Yeah.


00:44:34.860 --> 00:44:35.700
Yeah.


00:44:35.700 --> 00:44:37.560
So in smallest, in largest, fantastic.


00:44:37.560 --> 00:44:43.320
Also, sometimes when you're asking for a minimum


00:44:43.320 --> 00:44:45.920
or maximum thing, you don't actually want the minimum


00:44:45.920 --> 00:44:48.320
or maximum, you want to know where that is


00:44:48.320 --> 00:44:49.680
'cause you're going to get that thing back


00:44:49.680 --> 00:44:51.980
and say, I need that whole row


00:44:51.980 --> 00:44:54.240
'cause I want to learn more information about it, right?


00:44:54.240 --> 00:44:56.120
But if you said, well, what's the minimum price?


00:44:56.120 --> 00:44:56.960
It's seven.


00:44:56.960 --> 00:44:58.400
Like, oh, okay, great.


00:44:58.400 --> 00:45:00.040
Now do I need to like loop through


00:45:00.040 --> 00:45:02.080
until I find the thing that has seven in it, right?


00:45:02.080 --> 00:45:02.920
Something like this.


00:45:02.920 --> 00:45:05.080
So you've got a recommendation for that.


00:45:05.080 --> 00:45:06.040
- Yeah, yeah.


00:45:06.040 --> 00:45:08.840
The IDXMAN is IDXMIN.


00:45:08.840 --> 00:45:12.860
This returns the index values of minimum or max


00:45:12.860 --> 00:45:15.680
so that you can look at the row


00:45:15.680 --> 00:45:18.960
that they are stored at or the column.


00:45:18.960 --> 00:45:20.860
- Yeah, fantastic.


00:45:20.860 --> 00:45:21.700
- Yeah.


00:45:21.700 --> 00:45:24.920
- So here's the row that contains the minimum price.


00:45:24.920 --> 00:45:25.760
I love it.


00:45:25.760 --> 00:45:26.580
- Yeah.


00:45:26.580 --> 00:45:27.420
- Really nice.


00:45:27.420 --> 00:45:30.260
So many of these are really easy to apply, right?


00:45:30.260 --> 00:45:36.700
Like it's not a lot of research to learn how to apply IDX MAX.


00:45:36.700 --> 00:45:38.020
But at the same time--


00:45:38.020 --> 00:45:41.460
or IDX MAX-- but at the same time, knowing that it exists,


00:45:41.460 --> 00:45:43.500
now all of a sudden you can use it really easily.


00:45:43.500 --> 00:45:46.500
But you probably wouldn't have known to look for it, right?


00:45:46.500 --> 00:45:47.500
Yeah.


00:45:47.500 --> 00:45:49.060
Yeah.


00:45:49.060 --> 00:45:49.900
Cool.


00:45:49.900 --> 00:45:53.700
You know, people often talk about differences


00:45:53.700 --> 00:45:56.900
between beginner developers and expert developers.


00:45:56.900 --> 00:46:01.340
And I think a lot of times beginners look at folks like you


00:46:01.340 --> 00:46:02.380
who have a lot of experience,


00:46:02.380 --> 00:46:04.780
they're like, oh, this guy is so incredibly smart


00:46:04.780 --> 00:46:06.940
and he just has this way of solving these problems.


00:46:06.940 --> 00:46:07.780
It's so amazing.


00:46:07.780 --> 00:46:11.380
And to some degree, that's probably true.


00:46:11.380 --> 00:46:13.780
But a lot of it is like just building up layers


00:46:13.780 --> 00:46:18.100
and layers of these like, oh, I know I can use ID max,


00:46:18.100 --> 00:46:20.540
IDX max, I know that I can use N largest.


00:46:20.540 --> 00:46:21.900
And you just sort of pile them together


00:46:21.900 --> 00:46:25.180
and then like, bam, like the solution becomes easier


00:46:25.180 --> 00:46:26.780
'cause you have these little building blocks, right?


00:46:26.780 --> 00:46:30.060
So it's, I think it's really valuable for people.


00:46:30.060 --> 00:46:34.620
- Yeah, I usually think that the biggest difference


00:46:34.620 --> 00:46:37.860
between a beginner level and a more experienced programmer


00:46:37.860 --> 00:46:41.580
is just like, just how much time they spend


00:46:41.580 --> 00:46:43.340
on the documentation, you know?


00:46:43.340 --> 00:46:44.180
- Yeah, yeah.


00:46:44.180 --> 00:46:45.060
- Yeah, if you read the docs,


00:46:45.060 --> 00:46:46.700
like if you patiently read the docs,


00:46:46.700 --> 00:46:50.220
you're just gonna become really good user


00:46:50.220 --> 00:46:52.940
of that particular tool or library.


00:46:52.940 --> 00:46:55.380
- I agree, but there's just more,


00:46:55.380 --> 00:46:58.920
you understand it better, you know more


00:46:58.920 --> 00:46:59.900
of what it has to offer.


00:46:59.900 --> 00:47:02.900
So it's like, it's less you've got to reinvent.


00:47:02.900 --> 00:47:04.180
- Yeah. - All right.


00:47:04.180 --> 00:47:07.380
This, I talked about how you have something


00:47:07.380 --> 00:47:10.180
that may be well-known, but then applying it in a scenario.


00:47:10.180 --> 00:47:14.440
And this number 16 is value counts with drop in a false.


00:47:14.440 --> 00:47:15.540
What's this one about?


00:47:15.540 --> 00:47:21.260
- Yeah.


00:47:21.260 --> 00:47:22.420
Can you hear me?


00:47:22.420 --> 00:47:23.240
- Yeah, sorry.


00:47:23.240 --> 00:47:24.740
I think it cut out just for a second there.


00:47:24.740 --> 00:47:27.900
So yeah, tell us about this number 16 one here.


00:47:27.900 --> 00:47:32.900
- Yeah, when you have a series with like categoricals,


00:47:32.900 --> 00:47:36.060
you just wanna see their proportions


00:47:36.060 --> 00:47:39.420
or their numbers as a whole in the total series.


00:47:39.420 --> 00:47:43.460
And that usually doesn't include the null values.


00:47:43.460 --> 00:47:47.340
So you have to call is null and chain it with some


00:47:47.340 --> 00:47:52.340
so that you learn the number of NADs in that column.


00:47:52.940 --> 00:47:55.500
but you can do it efficiently with value counts


00:47:55.500 --> 00:47:58.320
with setting, by setting drop NA to false,


00:47:58.320 --> 00:48:02.940
which includes the proportions of the null values as well.


00:48:02.940 --> 00:48:04.020
- Nice.


00:48:04.020 --> 00:48:07.940
Yeah, so it just gives you basically a percentage


00:48:07.940 --> 00:48:09.500
as a ratio here.


00:48:09.500 --> 00:48:13.740
It's just a ratio of the number of the different categories


00:48:13.740 --> 00:48:15.260
that have appeared here, right?


00:48:15.260 --> 00:48:16.100
So very cool.


00:48:16.100 --> 00:48:17.340
And now just not a number is included.


00:48:17.340 --> 00:48:18.260
That's great.


00:48:18.260 --> 00:48:20.080
- Yeah, then you can decide.


00:48:20.080 --> 00:48:20.920
- Yeah.


00:48:22.040 --> 00:48:26.080
- Cool, all right, number 17, clip.


00:48:26.080 --> 00:48:26.920
This is a good one.


00:48:26.920 --> 00:48:27.740
- Clip, yeah.


00:48:27.740 --> 00:48:29.080
Yeah, clip is good.


00:48:29.080 --> 00:48:33.600
- Yeah, for data that exceeds, I don't know,


00:48:33.600 --> 00:48:35.640
maybe a range, maybe it's supposed,


00:48:35.640 --> 00:48:38.080
some instrument's supposed to collect zero to 100


00:48:38.080 --> 00:48:42.120
and it goes crazy and goes outside of 100.


00:48:42.120 --> 00:48:47.120
- Yeah, for example, here we go back to the ages example


00:48:47.120 --> 00:48:51.360
where I just wanna have ages between like 18 or 60,


00:48:51.360 --> 00:48:55.280
18 and 60, and I want to exclude all those values.


00:48:55.280 --> 00:48:58.000
And when you call clip with those custom values,


00:48:58.000 --> 00:49:02.060
it just gonna impose those hard limits on the whole series.


00:49:02.060 --> 00:49:06.920
- Right, so it'll replace the ones that are over


00:49:06.920 --> 00:49:08.240
with the maximum that you set,


00:49:08.240 --> 00:49:09.320
and the ones that are too low,


00:49:09.320 --> 00:49:11.520
it'll bring them up to the minimum, right?


00:49:11.520 --> 00:49:13.040
- Yeah.


00:49:13.040 --> 00:49:16.040
- Very cool, again, against the whole data set, not looping.


00:49:16.040 --> 00:49:19.520
- Yeah, yeah, yeah, only one column at a time.


00:49:19.520 --> 00:49:23.560
- Yeah, we talked about how difficult time is,


00:49:23.560 --> 00:49:27.920
but you do have some recommendations for doing,


00:49:27.920 --> 00:49:30.280
searching for data that appears at a certain time


00:49:30.280 --> 00:49:31.880
or in a time range, right?


00:49:31.880 --> 00:49:33.720
- Yeah. - What's number 18?


00:49:33.720 --> 00:49:36.120
- Yeah, this one is like a subsetting


00:49:36.120 --> 00:49:38.080
of rows of the data frame


00:49:38.080 --> 00:49:42.400
at some particular time of the day,


00:49:42.400 --> 00:49:45.960
like any time of the day, but you like, for example,


00:49:45.960 --> 00:49:50.960
three o'clock, nine 30, 10 30, or any time that you want.


00:49:50.960 --> 00:49:54.520
You're just going to take all those rows and return them.


00:49:54.520 --> 00:49:55.600
We're using at time.


00:49:55.600 --> 00:49:58.360
- Yeah. That's super easy, right?


00:49:58.360 --> 00:50:02.080
Just pass it at time and you literally specify


00:50:02.080 --> 00:50:04.000
- Yeah.


00:50:04.000 --> 00:50:07.000
- Like 15 colon zero zero as a string.


00:50:07.000 --> 00:50:11.640
- Like a real conversation or messaging.


00:50:11.640 --> 00:50:15.200
- And then the other one, which is also interesting


00:50:15.200 --> 00:50:19.040
between time, right? Like what happened in the morning, for example?


00:50:19.040 --> 00:50:26.640
Yeah, yeah. Like what are those sales that happened in the morning or after midnight


00:50:26.640 --> 00:50:31.560
or during some particular interval? This one is really handy to do that.


00:50:31.560 --> 00:50:36.240
Yeah. So super easy. Just data frame dot between time or is that a series?


00:50:36.240 --> 00:50:39.680
Yeah. No, no, no. It doesn't. It doesn't matter.


00:50:39.680 --> 00:50:40.680
Okay.


00:50:40.680 --> 00:50:45.680
It usually has to be, it has to have a daytime index.


00:50:45.680 --> 00:50:47.080
That's it.


00:50:47.080 --> 00:50:48.640
- Got it.


00:50:48.640 --> 00:50:49.480
Yeah, okay.


00:50:49.480 --> 00:50:52.280
So then just pass in strings like nine colon 45


00:50:52.280 --> 00:50:54.400
to 12 colon zero zero.


00:50:54.400 --> 00:50:56.360
And you know, that's like a late morning or something.


00:50:56.360 --> 00:50:57.200
Beautiful.


00:50:57.200 --> 00:51:01.400
The next one here has to do with time series.


00:51:01.400 --> 00:51:02.240
Number 19.


00:51:02.240 --> 00:51:03.060
- Yeah, yeah, again, time series.


00:51:03.060 --> 00:51:03.900
- Date range.


00:51:03.900 --> 00:51:04.720
Tell us about this.


00:51:04.720 --> 00:51:09.480
- Well, this one is like, stands for business date range.


00:51:09.480 --> 00:51:10.680
business date range.


00:51:10.680 --> 00:51:15.240
So like pandas internally built in,


00:51:15.240 --> 00:51:19.320
built into calendars, like it just,


00:51:19.320 --> 00:51:23.220
when you wanna, how can I say?


00:51:23.220 --> 00:51:26.080
When you wanna index the data frame you want,


00:51:26.080 --> 00:51:27.860
time series data frame,


00:51:27.860 --> 00:51:30.880
you wanna include only like working days.


00:51:30.880 --> 00:51:34.020
Like you wanna exclude all the weekdays, weekends.


00:51:34.020 --> 00:51:36.920
And you can do that for every single of the year,


00:51:36.920 --> 00:51:38.200
for every single week of the year,


00:51:38.200 --> 00:51:41.380
because you can possibly know which days are weekends.


00:51:41.380 --> 00:51:44.120
So when you call the date range,


00:51:44.120 --> 00:51:49.120
it just takes, it just indexes the data frame


00:51:49.120 --> 00:51:52.680
using only weekdays.


00:51:52.680 --> 00:51:56.320
And also it excludes the holidays, I think.


00:51:56.320 --> 00:51:57.160
- Oh my gosh.


00:51:57.160 --> 00:51:58.680
I was just wondering about holidays.


00:51:58.680 --> 00:52:00.560
Like there's another wrinkle in there.


00:52:00.560 --> 00:52:01.400
- Yeah, yeah.


00:52:01.400 --> 00:52:03.920
- But already things like leap year and stuff like that


00:52:03.920 --> 00:52:05.880
is built into this, I would imagine.


00:52:05.880 --> 00:52:07.360
So this is super cool.


00:52:07.360 --> 00:52:08.480
- Yeah, this is very important


00:52:08.480 --> 00:52:10.700
for when you are doing time series forecasting


00:52:10.700 --> 00:52:13.440
or analysis analysis,


00:52:13.440 --> 00:52:16.280
because like, or working with stocks


00:52:16.280 --> 00:52:19.400
because stocks are only traded on weekdays


00:52:19.400 --> 00:52:21.060
and not on holidays.


00:52:21.060 --> 00:52:23.400
So it will be very important.


00:52:23.400 --> 00:52:25.480
- Or even if you do in like traffic analysis,


00:52:25.480 --> 00:52:27.200
you wanna understand accidents


00:52:27.200 --> 00:52:30.040
that are a result of rush hour, right?


00:52:30.040 --> 00:52:32.000
You wouldn't wanna look on a weekend.


00:52:32.000 --> 00:52:32.820
- Yeah.


00:52:32.820 --> 00:52:33.920
- Yeah.


00:52:33.920 --> 00:52:36.520
All right, the next one has to do with correlation,


00:52:36.520 --> 00:52:37.520
Auto-correlation.


00:52:37.520 --> 00:52:44.280
Yeah, I don't do much with time series.


00:52:44.280 --> 00:52:45.640
You're going to have to tell us about this one.


00:52:45.640 --> 00:52:46.640
What's going on here?


00:52:46.640 --> 00:52:54.720
Yeah, for example, this is usually how the autocorrelation of a series or time series


00:52:54.720 --> 00:53:00.240
tells the predictability of the time series with itself.


00:53:00.240 --> 00:53:01.960
Do you know about correlation coefficient?


00:53:01.960 --> 00:53:02.960
Yeah, exactly.


00:53:02.960 --> 00:53:07.340
it tells you how much the model matches the actual data.


00:53:07.340 --> 00:53:11.540
Like it's 97% likely that the model will predict the stuff coming up.


00:53:11.540 --> 00:53:14.420
It could be linear or more complicated, but that's something like that.


00:53:14.420 --> 00:53:14.620
Yeah.


00:53:14.620 --> 00:53:15.500
Yeah.


00:53:15.500 --> 00:53:22.060
The gist of this is that if a time series has a high autocorrelation with itself,


00:53:22.060 --> 00:53:24.620
it means you can predict it more easily.


00:53:24.620 --> 00:53:26.500
Yeah.


00:53:26.500 --> 00:53:26.860
Yeah.


00:53:26.860 --> 00:53:30.860
It's how, basically how predictable or unpredictable is this thing?


00:53:30.860 --> 00:53:31.140
Yeah.


00:53:31.420 --> 00:53:34.180
There's a lot of details about autocorrelation


00:53:34.180 --> 00:53:39.180
and it has very many applications in time series.


00:53:39.180 --> 00:53:42.100
But the gist is that,


00:53:42.100 --> 00:53:45.220
it shows you how much predictability it has


00:53:45.220 --> 00:53:47.700
at each interval.


00:53:47.700 --> 00:53:49.260
- Nice, cool.


00:53:49.260 --> 00:53:51.760
It sounds very useful if you're doing that kind of stuff.


00:53:51.760 --> 00:53:54.860
Number 21, hasNans.


00:53:54.860 --> 00:53:58.180
- Yeah, it's also an attribute.


00:53:58.180 --> 00:53:59.860
You just call it on a series


00:53:59.860 --> 00:54:02.660
and it returns true or false.


00:54:02.660 --> 00:54:04.520
If you have, it returns true


00:54:04.520 --> 00:54:07.240
if you have at least one missing value in a series.


00:54:07.240 --> 00:54:10.700
- Yeah, so there was this quote,


00:54:10.700 --> 00:54:13.940
I remember who it's attributed to, sorry,


00:54:13.940 --> 00:54:15.980
that says something to the effect of


00:54:15.980 --> 00:54:20.460
like data cleanup and data wrangling


00:54:20.460 --> 00:54:23.900
is not the dirty work, it is the work of data science.


00:54:23.900 --> 00:54:25.020
Like to get everything ready


00:54:25.020 --> 00:54:27.220
and then you just like hit it with the magic at the end,


00:54:27.220 --> 00:54:28.060
right? - Yeah.


00:54:28.060 --> 00:54:29.780
- And this feels like that lands right in that realm


00:54:29.780 --> 00:54:33.380
is like given some data frame or series,


00:54:33.380 --> 00:54:36.020
does it have not a numbers or is it all good?


00:54:36.020 --> 00:54:36.860
- Yeah, yeah.


00:54:36.860 --> 00:54:40.580
Missing values is like a huge problem in machine learning.


00:54:40.580 --> 00:54:44.780
Most scikit-learn algorithms don't accept missing values.


00:54:44.780 --> 00:54:47.300
So you either have to drop them


00:54:47.300 --> 00:54:49.920
or impute them using some techniques.


00:54:49.920 --> 00:54:54.840
And this one is very handy to detect those missing values.


00:54:54.840 --> 00:54:56.620
- Right, I suspect this is the first test.


00:54:56.620 --> 00:54:58.820
Like if it has not a numbers


00:54:58.820 --> 00:55:00.260
and then we're gonna go do stuff.


00:55:00.260 --> 00:55:03.180
But if it says false, then you're good to go, just roll.


00:55:03.180 --> 00:55:04.740
- Yeah, yeah. - Go with that.


00:55:04.740 --> 00:55:06.540
- But it usually turns true.


00:55:06.540 --> 00:55:09.340
- Unfortunately.


00:55:09.340 --> 00:55:12.300
Are you familiar with the missing no?


00:55:12.300 --> 00:55:13.620
Let me...


00:55:13.620 --> 00:55:14.980
- Yeah, yeah.


00:55:14.980 --> 00:55:18.060
- This is another thing that sort of came to mind


00:55:18.060 --> 00:55:21.340
is like this whole thing, this missing no package


00:55:21.340 --> 00:55:24.140
as in like no numbers.


00:55:24.140 --> 00:55:26.740
So a way to not just answer yes or no,


00:55:26.740 --> 00:55:27.820
but to get visualizations.


00:55:27.820 --> 00:55:29.020
Have you used this?


00:55:29.020 --> 00:55:29.860
- Yeah, yeah.


00:55:29.860 --> 00:55:31.760
I also wrote an article on it, I think.


00:55:31.760 --> 00:55:33.360
- Okay, well, yeah, so definitely.


00:55:33.360 --> 00:55:34.340
That's awesome.


00:55:34.340 --> 00:55:36.220
Things like this sound really useful to me.


00:55:36.220 --> 00:55:37.060
They seem like-


00:55:37.060 --> 00:55:39.940
- Yeah, I really like that missingness matrix.


00:55:39.940 --> 00:55:43.860
It just shows the reasons why missing values are correlated,


00:55:43.860 --> 00:55:47.460
how missing values are correlated with other columns.


00:55:47.460 --> 00:55:48.300
- Right.


00:55:48.300 --> 00:55:50.780
Is it a whole bunch of missing data in one row?


00:55:50.780 --> 00:55:51.620
- Yeah.


00:55:51.620 --> 00:55:52.440
- And then it's all good?


00:55:52.440 --> 00:55:53.740
Or is it interspersed?


00:55:53.740 --> 00:55:55.100
Like this one's missing the birthday,


00:55:55.100 --> 00:55:57.180
but that one's missing the name or something like that.


00:55:57.180 --> 00:55:58.020
- Right, yeah.


00:55:58.020 --> 00:55:59.980
- It's a really good package.


00:55:59.980 --> 00:56:01.540
- Yeah, fantastic.


00:56:01.540 --> 00:56:04.980
All right, at number 22, at and iat.


00:56:04.980 --> 00:56:09.860
- Yeah, this one is like a faster versions


00:56:09.860 --> 00:56:11.780
of lock and iloc.


00:56:11.780 --> 00:56:16.780
It just enables you to index your data frame.


00:56:16.780 --> 00:56:19.380
But this one is specifically designed


00:56:19.380 --> 00:56:22.500
for retrieving single value conditionals.


00:56:22.500 --> 00:56:27.020
- Nice, it's almost like an array index.


00:56:27.020 --> 00:56:29.260
- Yeah. - A little bit.


00:56:29.260 --> 00:56:31.460
What's the difference between at and iat?


00:56:31.460 --> 00:56:35.980
- Using at, you can use like column labels,


00:56:35.980 --> 00:56:40.260
like as you can see here, we are using cut and an index,


00:56:40.260 --> 00:56:44.220
but iat, you have to know the index of that column.


00:56:44.220 --> 00:56:46.420
- I see, so with at, it would be like row


00:56:46.420 --> 00:56:50.500
and then column name, where iat is row and column number.


00:56:50.500 --> 00:56:52.500
So it's probably less flexible.


00:56:52.500 --> 00:56:54.060
You gotta know that cut is four


00:56:54.060 --> 00:56:55.900
because it could be moved around


00:56:55.900 --> 00:56:57.700
as people are creating or inserting data.


00:56:57.700 --> 00:56:58.540
- Yeah. - Got it.


00:56:58.540 --> 00:56:59.820
- Yeah. - Yeah.


00:56:59.820 --> 00:57:00.660
- Nice.


00:57:00.660 --> 00:57:03.820
Okay, agsort as in aggregation.


00:57:03.820 --> 00:57:04.660
Yeah?


00:57:04.660 --> 00:57:06.300
- Yeah. - No, argsort, sorry.


00:57:06.300 --> 00:57:07.860
Misread argsort.


00:57:07.860 --> 00:57:09.340
- Yeah.


00:57:09.340 --> 00:57:12.420
This one just returns the indices


00:57:12.420 --> 00:57:15.020
that would sort a data frame.


00:57:15.020 --> 00:57:15.900
- Okay.


00:57:15.900 --> 00:57:17.380
- Based on some column.


00:57:17.380 --> 00:57:20.340
So during data analysis,


00:57:20.340 --> 00:57:22.300
you sometimes want the indices,


00:57:22.300 --> 00:57:23.700
not the actual sorted data,


00:57:23.700 --> 00:57:27.520
so that you can use those indices in multiple times over.


00:57:27.520 --> 00:57:30.840
- Got it, so you get the sorted,


00:57:30.840 --> 00:57:34.080
say I wanna sort by the total bill,


00:57:34.080 --> 00:57:37.600
but then give me the indexes as if it was sorted,


00:57:37.600 --> 00:57:38.520
but don't actually change it.


00:57:38.520 --> 00:57:41.120
So then you could go and then request data


00:57:41.120 --> 00:57:42.440
off those indexes, got it.


00:57:42.440 --> 00:57:43.720
- Yeah, yeah.


00:57:43.720 --> 00:57:46.160
- Nice, all right, we're closing in on the end


00:57:46.160 --> 00:57:49.040
and we've brought in the cat, the cat accessor.


00:57:49.040 --> 00:57:51.720
- Cat accessor, yeah, I should have put an image here.


00:57:51.720 --> 00:57:53.560
- Yeah, there would have been some kind of cool cat


00:57:53.560 --> 00:57:59.880
put in there. Yeah, yeah, yeah. As you know, like pandas enables you to perform some like


00:57:59.880 --> 00:58:06.520
data type specific functions like there is DT accessor for date time and also


00:58:06.520 --> 00:58:12.840
and also str for strings and this one is for strictly for categorical purposes.


00:58:12.840 --> 00:58:21.080
It has like a large suite of categorical functions that makes it easier to work on


00:58:21.800 --> 00:58:24.840
categories, ordinals, or nominal data.


00:58:24.840 --> 00:58:27.800
>> Okay. Yeah, fantastic.


00:58:27.800 --> 00:58:34.120
Let's bring it to the 25th with group by nth.


00:58:34.120 --> 00:58:36.800
>> Yeah. This one is less useful,


00:58:36.800 --> 00:58:39.920
used in very rare edge cases.


00:58:39.920 --> 00:58:42.560
When you group by some column,


00:58:42.560 --> 00:58:44.840
possibly a categorical column,


00:58:44.840 --> 00:58:49.160
you want to look at those rows or groups.


00:58:49.160 --> 00:58:54.160
and calling nth on the grouped data frame


00:58:54.160 --> 00:58:59.520
just returns that nth row of that groups, of each group.


00:58:59.520 --> 00:59:02.780
- Got it, okay.


00:59:02.780 --> 00:59:04.500
Yeah, that looks really cool.


00:59:04.500 --> 00:59:05.380
- Yeah.


00:59:05.380 --> 00:59:07.820
- All right, well, that's it for our list.


00:59:07.820 --> 00:59:09.320
Hopefully people out there listening


00:59:09.320 --> 00:59:12.600
have definitely learned something.


00:59:12.600 --> 00:59:14.180
Now, your title was,


00:59:14.180 --> 00:59:16.580
just to put a little disclaimer in here for everyone,


00:59:16.580 --> 00:59:19.660
25 Panda functions you didn't know existed.


00:59:19.660 --> 00:59:21.660
Pipe, key guarantee equals 0.8.


00:59:21.660 --> 00:59:25.020
So you had this 80% likelihood.


00:59:25.020 --> 00:59:25.860
I love it.


00:59:25.860 --> 00:59:27.740
That's a little bit of a stats.


00:59:27.740 --> 00:59:28.580
- Yeah, yeah.


00:59:28.580 --> 00:59:32.180
No one complained about that, so I think that was right.


00:59:32.180 --> 00:59:33.080
- Yeah.


00:59:33.080 --> 00:59:33.920
It sounds about right.


00:59:33.920 --> 00:59:36.260
It seems like there's a lot of neat use cases here


00:59:36.260 --> 00:59:37.940
that people can find.


00:59:37.940 --> 00:59:38.780
- Yeah.


00:59:38.780 --> 00:59:42.340
- These are your 25 that you found interesting.


00:59:42.340 --> 00:59:44.460
Other people might find them as well, but.


00:59:44.460 --> 00:59:45.300
- Yeah, yeah.


00:59:45.300 --> 00:59:48.900
you know, these are the kinds of, oh, so many, yeah.


00:59:48.900 --> 00:59:49.740
- Yeah, yeah.


00:59:49.740 --> 00:59:50.780
- These are the types of things though


00:59:50.780 --> 00:59:52.340
that people can say, all right,


00:59:52.340 --> 00:59:55.820
today I'm gonna try to work with number one


00:59:55.820 --> 00:59:57.580
as I'm doing my data analysis and stuff.


00:59:57.580 --> 01:00:00.280
I just, I know I'm gonna be doing some Excel stuff.


01:00:00.280 --> 01:00:02.260
So let's do the Excel writer one.


01:00:02.260 --> 01:00:03.880
And then, you know, maybe later it's like,


01:00:03.880 --> 01:00:06.660
oh, I know I'm doing survey type of data.


01:00:06.660 --> 01:00:10.000
So let me work with explode and just try to, you know,


01:00:10.000 --> 01:00:11.540
if you work these in one at a time,


01:00:11.540 --> 01:00:13.900
eventually they become part of your tool chest.


01:00:13.900 --> 01:00:16.420
and they're good, right?


01:00:16.420 --> 01:00:19.360
- Yeah, yeah, and just expanding our tool set and skills.


01:00:19.360 --> 01:00:21.620
- Yeah, I think so.


01:00:21.620 --> 01:00:24.700
I think part of the trick is to make sure


01:00:24.700 --> 01:00:26.580
that you apply it a little bit, right?


01:00:26.580 --> 01:00:27.500
I mean, you know, they're out there,


01:00:27.500 --> 01:00:30.340
but just as you use them, like bring them in.


01:00:30.340 --> 01:00:34.940
- Yeah, it just saves you time and resources.


01:00:34.940 --> 01:00:36.240
- Awesome.


01:00:36.240 --> 01:00:38.700
Yeah, half the battle is just knowing that it exists, right?


01:00:38.700 --> 01:00:40.180
It's not necessarily hard to use.


01:00:40.180 --> 01:00:42.260
It's like, I just didn't know this was even an option.


01:00:42.260 --> 01:00:43.820
- Yeah, yeah, yeah, it's a real,


01:00:43.820 --> 01:00:45.340
all of these are very easy to use.


01:00:45.340 --> 01:00:47.260
You just know that they exist.


01:00:47.260 --> 01:00:49.860
- Yeah, I feel like so much of Pandas is that way,


01:00:49.860 --> 01:00:51.500
but they're so, it's hard to know


01:00:51.500 --> 01:00:53.620
'cause there's so much to do there.


01:00:53.620 --> 01:00:54.460
It's cool.


01:00:54.460 --> 01:00:55.300
- Yeah.


01:00:55.300 --> 01:00:56.260
- Out the live stream, Brandon,


01:00:56.260 --> 01:00:57.660
just wanted, now we're kind of done,


01:00:57.660 --> 01:00:58.840
I wanted to throw out, he said,


01:00:58.840 --> 01:01:01.260
"Very helpful, thank you for the article, Bex."


01:01:01.260 --> 01:01:03.700
That's cool. - Yeah, yeah, you're welcome.


01:01:03.700 --> 01:01:05.460
- Yeah, I agree, yeah, thanks for doing this one.


01:01:05.460 --> 01:01:06.480
I do wanna point out,


01:01:06.480 --> 01:01:08.620
we certainly don't have time to cover it,


01:01:08.620 --> 01:01:10.660
but let me pull it up here


01:01:10.660 --> 01:01:13.260
so I can make sure it goes in the links as well.


01:01:13.260 --> 01:01:15.340
You did the same thing for NumPy, right?


01:01:15.340 --> 01:01:16.760
And you also were a little more,


01:01:16.760 --> 01:01:18.600
I gotta say you're a little more confident here.


01:01:18.600 --> 01:01:21.820
Your P of guarantee equals 0.85 instead of 0.8.


01:01:21.820 --> 01:01:24.740
- Yeah, yeah, because NumPy functions


01:01:24.740 --> 01:01:26.720
are a little bit harder to understand.


01:01:26.720 --> 01:01:30.580
That's why most of them don't bother to learn those,


01:01:30.580 --> 01:01:31.480
most people.


01:01:31.480 --> 01:01:33.160
So I was a bit confident


01:01:33.160 --> 01:01:35.960
because I also didn't know most of these functions.


01:01:35.960 --> 01:01:37.840
That's why I was a bit more confident.


01:01:37.840 --> 01:01:39.680
- Yeah, fantastic.


01:01:39.680 --> 01:01:41.580
- All right, so if people like this flow


01:01:41.580 --> 01:01:43.160
and they wanna kinda go a little deeper


01:01:43.160 --> 01:01:45.480
and go into the NumPy layer, they can check that out.


01:01:45.480 --> 01:01:47.760
They can also check out a bunch of your other writing.


01:01:47.760 --> 01:01:48.920
- Yeah, yeah, yeah.


01:01:48.920 --> 01:01:49.760
- Cool.


01:01:49.760 --> 01:01:51.720
- (indistinct)


01:01:51.720 --> 01:01:54.180
- Okay, right on for, that's getting great.


01:01:54.180 --> 01:01:57.240
All right, anything else you wanna add to this article


01:01:57.240 --> 01:02:00.680
before we call it good on that topic?


01:02:00.680 --> 01:02:02.720
- No, no, I think we covered everything.


01:02:02.720 --> 01:02:04.400
- Yeah, we covered it well, I think it was fun.


01:02:04.400 --> 01:02:05.240
- Yeah, it was fun.


01:02:05.240 --> 01:02:07.600
- All right, now before you get out of here,


01:02:07.600 --> 01:02:11.780
There's the two questions you've got to answer.


01:02:11.780 --> 01:02:13.660
If you're gonna write some Python code,


01:02:13.660 --> 01:02:15.620
what editor do you use?


01:02:15.620 --> 01:02:17.220
What are you gonna use?


01:02:17.220 --> 01:02:20.300
- For data analysis, I usually use JupyterLab.


01:02:20.300 --> 01:02:25.900
But if I have to do pure Python, that's always PyCharm.


01:02:25.900 --> 01:02:26.820
I love it.


01:02:26.820 --> 01:02:28.860
- Yeah, awesome, that's a good combo.


01:02:28.860 --> 01:02:29.700
- Yeah.


01:02:29.700 --> 01:02:33.500
- Then notable PyPI package.


01:02:33.500 --> 01:02:35.500
Something, it doesn't have to be something super popular,


01:02:35.500 --> 01:02:36.700
but something that you ran across


01:02:36.700 --> 01:02:38.700
that people are like, you're like,


01:02:38.700 --> 01:02:39.980
people should know about this.


01:02:39.980 --> 01:02:41.660
This is something I learned about.


01:02:41.660 --> 01:02:42.920
- Mm-hmm, yeah.


01:02:42.920 --> 01:02:48.940
- Got it, one you want to suggest for us?


01:02:48.940 --> 01:02:49.820
Any package?


01:02:49.820 --> 01:02:52.580
- My favorite package?


01:02:52.580 --> 01:02:53.420
- Yeah, yeah.


01:02:53.420 --> 01:02:59.740
- So, well, I recently come across with UMAP.


01:02:59.740 --> 01:03:01.820
- UMAP?


01:03:01.820 --> 01:03:05.540
- Yeah, it's for dimensionality reduction, UMAP Python.


01:03:05.540 --> 01:03:06.380
- Yeah.


01:03:06.380 --> 01:03:07.220
- That's fun.


01:03:07.220 --> 01:03:12.220
- Yeah, it's usually used for like very large datasets


01:03:12.220 --> 01:03:17.420
to project them to 2D so that you can visualize them.


01:03:17.420 --> 01:03:18.460
- Right, okay.


01:03:18.460 --> 01:03:19.300
Awesome.


01:03:19.300 --> 01:03:22.740
- Yeah, this one is a really useful package.


01:03:22.740 --> 01:03:27.740
- Nice, so definitely people are trying to project down


01:03:27.740 --> 01:03:28.740
to 2D.


01:03:28.740 --> 01:03:29.580
I mean, that's one of the problems, right?


01:03:29.580 --> 01:03:32.020
Is how do you look at some of this stuff that's,


01:03:32.020 --> 01:03:35.020
How do you look at some of this stuff that's...


01:03:35.020 --> 01:03:38.020
- Like 100 dimensional or 200 dimensions.


01:03:38.020 --> 01:03:39.020
You just can't visualize.


01:03:39.020 --> 01:03:43.020
- I don't even have any idea at all how to do 100 dimensions.


01:03:43.020 --> 01:03:47.020
I remember we were doing some work with like complex analysis


01:03:47.020 --> 01:03:51.020
and two dimensional, but each dimension was complex numbers.


01:03:51.020 --> 01:03:53.020
So four dimensional, that was a challenge.


01:03:53.020 --> 01:03:56.020
I have no idea how to approach 100.


01:03:56.020 --> 01:03:57.020
- Yeah, yeah, yeah, yeah.


01:03:57.020 --> 01:03:58.020
No one does.


01:03:58.020 --> 01:04:00.020
That's why these kinds of dimensional


01:04:00.020 --> 01:04:02.020
reduction techniques exist.


01:04:02.020 --> 01:04:03.020
Yeah, fantastic.


01:04:03.020 --> 01:04:05.020
And of course, important machine learning and stuff, right?


01:04:05.020 --> 01:04:10.020
There's like dimensions that you can just throw away because they don't actually contribute to the predictions and stuff, right?


01:04:10.020 --> 01:04:11.020
Yeah, yeah.


01:04:11.020 --> 01:04:14.020
Yeah, UMAP does that excellently.


01:04:14.020 --> 01:04:15.020
Super.


01:04:15.020 --> 01:04:16.020
All right, Bex.


01:04:16.020 --> 01:04:18.020
Thank you for being here.


01:04:18.020 --> 01:04:19.020
Final call to action.


01:04:19.020 --> 01:04:23.020
People want to get deeper in Pandas, maybe learn more about some of your articles.


01:04:23.020 --> 01:04:25.020
You know, what do you tell them?


01:04:25.020 --> 01:04:30.020
Well, as I said, just first take the documentation.


01:04:30.020 --> 01:04:33.380
You know, the documentation is usually,


01:04:33.380 --> 01:04:34.940
it should be your first choice.


01:04:34.940 --> 01:04:38.040
It's the best place to learn about a library.


01:04:38.040 --> 01:04:42.560
- Awesome, yeah, it takes a little dedication,


01:04:42.560 --> 01:04:44.900
but go through it and find out what it has to offer


01:04:44.900 --> 01:04:46.180
and go from there, right?


01:04:46.180 --> 01:04:47.500
- Yeah, it's a bit hard to read,


01:04:47.500 --> 01:04:50.300
but documentation is always,


01:04:50.300 --> 01:04:54.460
gives the best information about the library


01:04:54.460 --> 01:04:56.960
because it's written by the package creators.


01:04:56.960 --> 01:04:59.800
So they know their library the best.


01:04:59.800 --> 01:05:01.040
- Yeah, for sure.


01:05:01.040 --> 01:05:01.880
- Yeah.


01:05:01.880 --> 01:05:03.200
- All right, well, thank you for being here.


01:05:03.200 --> 01:05:04.520
Thanks for writing the article and sharing it with us.


01:05:04.520 --> 01:05:05.360
- Thanks for having me.


01:05:05.360 --> 01:05:06.200
- Yeah, you bet.


01:05:06.200 --> 01:05:07.080
Bye.

