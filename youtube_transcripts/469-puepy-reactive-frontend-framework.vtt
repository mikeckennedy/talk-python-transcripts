WEBVTT

00:00:00.001 --> 00:00:05.000
>> Ken, welcome to Talk Python to Me.

00:00:05.000 --> 00:00:07.000
>> Hi, good to be here.

00:00:07.000 --> 00:00:19.000
>> Excellent to have you here. It's a topic that's near and dear to my heart, and I know for many people as well, building cool websites, but more Python, less JavaScript.

00:00:19.000 --> 00:00:27.000
Not hating on JavaScript, but why do we need to learn a sixth language to work on websites? There's already so many, HTML, CSS, etc., etc.

00:00:27.000 --> 00:00:38.000
In the world, we should be able to pick the language we like and build websites with it, but somehow it's gotten itself into a place where you pick part of the language you like and then the rest you do in JavaScript.

00:00:38.000 --> 00:00:42.000
But we'll see how that goes.

00:00:42.000 --> 00:00:50.000
>> Running Python in the browser has always been a little dream of mine, ever since I first started programming in JavaScript.

00:00:50.000 --> 00:00:52.000
>> Yeah, that's awesome.

00:00:52.000 --> 00:01:01.000
>> We had traditionally things like Emscripten and some of those transpilers, right? Like Sculpt and others.

00:01:01.000 --> 00:01:17.000
>> Sculpt, Transcript, Brython, not Transpiler, but Transpiler. Brython kind of does the same thing as PyScript. It just runs the whole CPython in JavaScript, which is wild.

00:01:17.000 --> 00:01:30.000
>> It's super wild, and I guess there's a requisite shout out to the birth and death of JavaScript talk, which gives you really good insight. It seems like you've seen that talk as well.

00:01:30.000 --> 00:01:32.000
>> No, but I have heard about it.

00:01:32.000 --> 00:01:37.000
>> It's worth the 15 minutes. It's both funny, but also very insightful.

00:01:37.000 --> 00:01:51.000
All right, so we're going to talk about a front-end framework that you've built that is Vue.js-like, but runs on top of Python in the browser, which is awesome, on the client side.

00:01:51.000 --> 00:01:53.000
>> On the client side.

00:01:53.000 --> 00:02:02.000
>> On the client side, very important. That's the big thing. Before we get to that, though, just tell people a bit about yourself. Who's Ken?

00:02:02.000 --> 00:02:20.000
>> Yeah, my name's Ken Kender. I've been developing Python software for 24, 25 years, something like that. Ever since Red Hat's installer crashed, and I saw the stack trace and opened up a file, and I could just read the code.

00:02:20.000 --> 00:02:38.000
That was my introduction to Python, and I never looked back. Mostly I've been writing line of business, software as a service kind of code, and I've always wanted to short-circuit that and bring it to the browser.

00:02:38.000 --> 00:02:47.000
>> Yeah. What are you using now for the line of business stuff? Is that Flask on the back end, or is it Node on the back end, or what are we talking here?

00:02:47.000 --> 00:03:03.000
>> At my real job, it's all Python on the back end, and then our front end is actually a Vue.js app that I wrote originally, and then some professional front-end developers kind of took it over and rewrote it.

00:03:03.000 --> 00:03:06.000
>> Yeah, cool. Now it has eight compilation steps.

00:03:06.000 --> 00:03:07.000
>> Yes.

00:03:07.000 --> 00:03:09.000
>> Prepare yourself.

00:03:09.000 --> 00:03:22.000
>> But it compiles into semi-native apps for mobile, and there's a Chrome extension involved. So we're doing a good job with it.

00:03:22.000 --> 00:03:35.000
>> Yeah, that's awesome. Look, there's a ton of websites built primarily with JavaScript, and many of them are good, some of them are bad, but there's also plenty of bad websites written in Python.

00:03:35.000 --> 00:03:46.000
Like I said, not hating on JavaScript so much as just saying, "Why does every programmer in language have to reduce to JavaScript?" That seems like a weird situation.

00:03:46.000 --> 00:03:59.000
There's other frameworks that are making progress here. For example, Blazor in the .NET C# space is actually -- I haven't done anything with it, but it's a super interesting idea, and it's not that different.

00:03:59.000 --> 00:04:03.000
So not the only crazy person.

00:04:03.000 --> 00:04:15.000
Blazor uses WebAssembly, just like PyScript, which is what I built my stuff on top of, and WebAssembly is about what it sounds like.

00:04:15.000 --> 00:04:23.000
It's mature enough now, and it's supported by all major modern browsers.

00:04:23.000 --> 00:04:37.000
And since there is no JavaScript layer, really -- I mean, there's some kind of JavaScript shims involved, if you want to think of it that way, but it's not like your Python code is being transpiled to JavaScript.

00:04:37.000 --> 00:04:39.000
It's actual Python.

00:04:39.000 --> 00:04:55.000
Right, right, right. We're going to talk about that. It's super interesting. There's interop in the sense that there's C interop in Python now back into the JavaScript layer that you can have, but that's not the same as this other language is interpreting.

00:04:55.000 --> 00:05:00.000
It's running the interpreter, right? So it's kind of natively, as much as you get in the front end, natively there.

00:05:00.000 --> 00:05:06.000
I kind of want to walk people through some of the technologies to get us started here.

00:05:06.000 --> 00:05:07.000
Sure.

00:05:07.000 --> 00:05:18.000
So there's -- we've already given a shout out to PyScript. We talked about Vue. I think PyScript is the foundation. Vue is maybe the motivation.

00:05:18.000 --> 00:05:20.000
Let's start with PyScript.

00:05:20.000 --> 00:05:27.000
Got their website pull up here, and what I'm learning is that I can have a REPL on my homepage.

00:05:27.000 --> 00:05:33.000
Actually, I know I can do more than that, but that's sort of what they're demonstrating right now.

00:05:33.000 --> 00:05:38.000
Yeah, you can do a lot more than that. You have kind of two choices with PyScript.

00:05:38.000 --> 00:06:01.000
You can run Pyodide, which is a lower level, if you want to think of it that way, Python in the browser project, and that is basically full CPython with some minor changes necessary, but you get basically the whole standard library.

00:06:01.000 --> 00:06:13.000
You can install packages from PyPy or PyPI, however you pronounce it, and those download just as you download the website.

00:06:13.000 --> 00:06:20.000
That's probably your best bet if you just want a true Python experience.

00:06:20.000 --> 00:06:40.000
PyScript, though, also includes a micro Python version, and the micro Python, if you're not familiar with it, it's mostly designed for micro controllers or like Raspberry Pi kind of environments where you have very limited resources,

00:06:40.000 --> 00:06:56.000
but because it is so truncated relative to real Python, it downloads very nicely in the browser. It's actually it plus PyScript ends up being smaller than a lot of JavaScript frameworks.

00:06:56.000 --> 00:07:01.000
Yeah, which is incredible, and this is a huge thing that is unlocked.

00:07:01.000 --> 00:07:07.000
Honestly, kind of the stuff that you're pursuing on a much bigger scale, I think.

00:07:07.000 --> 00:07:14.000
Micro Python, as the name suggests, and I've had Damian and others on to talk about micro Python.

00:07:14.000 --> 00:07:16.000
It's real micro.

00:07:16.000 --> 00:07:20.000
I'll hold up a little device here, like this thing in my hand.

00:07:20.000 --> 00:07:36.000
This little chip that is probably the size of my thumb costs like 20 bucks, and this runs full micro Python, manages the DNS on my network and stuff like that, like ad blockers and whatnot, and that little tiny thing.

00:07:36.000 --> 00:07:41.000
But the restriction is how much storage does it have? A couple of megs.

00:07:41.000 --> 00:07:44.000
How much RAM does it have? Probably similar.

00:07:44.000 --> 00:07:46.000
I don't know.

00:07:46.000 --> 00:07:58.000
The goal was to be a very small kernel of Python with micro Python, not let you do Tkinter, pandas, etc, etc, etc.

00:07:58.000 --> 00:08:08.000
And so PyScript choosing to support both of these means you can kind of take Pyodide and get full Python, in a sense, as much as you can.

00:08:08.000 --> 00:08:15.000
Or you can do micro Python and restrict yourself to a smaller set, but you get a much lighter weight experience, right?

00:08:15.000 --> 00:08:17.000
Yeah.

00:08:17.000 --> 00:08:25.000
If you've ever used transpiling, micro Python is still a real big upgrade over that.

00:08:25.000 --> 00:08:35.000
Because you are getting almost all the Python syntax and most of the libraries that you're likely to use just rendering website.

00:08:35.000 --> 00:08:36.000
Right.

00:08:36.000 --> 00:08:39.000
Okay, so a lot of the standard library is still there.

00:08:39.000 --> 00:08:43.000
But maybe things like networking or whatever that don't make sense.

00:08:43.000 --> 00:08:50.000
I wouldn't say a lot of it is like a good example is the regular expression module is there.

00:08:50.000 --> 00:08:58.000
But when I first wrote the router for PuePy, the regular expressions that I was using weren't supported in the micro Python.

00:08:58.000 --> 00:08:59.000
I see.

00:08:59.000 --> 00:09:02.000
Limited, limited regular expression.

00:09:02.000 --> 00:09:04.000
You went too big on your regular expressions.

00:09:04.000 --> 00:09:05.000
I did, yeah.

00:09:05.000 --> 00:09:06.000
I see.

00:09:06.000 --> 00:09:07.000
Okay, interesting.

00:09:07.000 --> 00:09:08.000
Yeah, we'll talk about routing.

00:09:08.000 --> 00:09:10.000
That'll be fun.

00:09:10.000 --> 00:09:29.000
Okay, so if somebody were to, you know, which we're on the topic of these two, like if someone were to think about building a website, maybe internally for their company, would you suggest that they use Pyodide as the foundation or micro Python because you can pick when you run PyScript?

00:09:29.000 --> 00:09:42.000
Yeah, I mean, if it's for your company, and it's an internal tool, probably most users downloading it are going to have plenty of bandwidth and normal machines.

00:09:42.000 --> 00:09:46.000
So there's really no reason not to use Pyodide.

00:09:46.000 --> 00:09:48.000
Yeah, yeah, sure.

00:09:48.000 --> 00:09:52.000
Better errors with it.

00:09:52.000 --> 00:10:02.000
There's little things that'll just, you're used to coding like data classes are missing from micro Python, but you could use either.

00:10:02.000 --> 00:10:03.000
Okay.

00:10:03.000 --> 00:10:10.000
Yeah, let's see if it will show us how big, how big is this thing?

00:10:10.000 --> 00:10:11.000
It doesn't want to.

00:10:11.000 --> 00:10:13.000
I could just get this, it's a jQuery terminal.

00:10:13.000 --> 00:10:14.000
How about that?

00:10:14.000 --> 00:10:18.000
If I click on the link in Pyodide, very cool.

00:10:18.000 --> 00:10:20.000
But yeah, how big is maybe 10 megs?

00:10:20.000 --> 00:10:22.000
Is that, did you say that's right?

00:10:22.000 --> 00:10:32.000
I think it actually, yeah, like I made a little example app for our purposes.

00:10:32.000 --> 00:10:34.000
And I used Pyodide.

00:10:34.000 --> 00:10:41.000
Now I am pulling in SQLite, which is part of it, that adds some space.

00:10:41.000 --> 00:10:49.000
One of the benefits though of using Pyodide is you can just grab a lot of the libraries and they'll work, right?

00:10:49.000 --> 00:11:04.000
Yeah, I don't know if it's PyScript doing it or Pyodide upstream, but they do make you say that you need certain libraries and then they're available for import after you kind of declare them.

00:11:04.000 --> 00:11:11.000
Right, and when you initially set up the PyScript environment, there's a way where you kind of set the environment as it loads, right?

00:11:11.000 --> 00:11:12.000
Yeah.

00:11:12.000 --> 00:11:13.000
Yeah, okay.

00:11:13.000 --> 00:11:15.000
You can do a runtime too.

00:11:15.000 --> 00:11:17.000
Okay.

00:11:17.000 --> 00:11:19.000
All right, cool.

00:11:19.000 --> 00:11:25.000
So we've got PyScript, which lets us do Python in the browser, which is awesome.

00:11:25.000 --> 00:11:28.000
And we've got these two foundations.

00:11:28.000 --> 00:11:33.000
We've got Pyodide, which is great for its compatibility, I guess.

00:11:33.000 --> 00:11:46.000
But PyScript, which if I was going to build a SaaS product where lots and lots of people were visiting kind of interactive bits, maybe you consider writing that in MicroPython because it's just less overwhelming.

00:11:46.000 --> 00:11:49.000
Less overhead for the world, I don't know.

00:11:49.000 --> 00:11:50.000
Depends.

00:11:50.000 --> 00:11:57.000
I would especially consider MicroPython for a page that loads as a normal web page.

00:11:57.000 --> 00:12:02.000
Yeah, if it's a landing page sort of thing, yeah, absolutely.

00:12:02.000 --> 00:12:18.000
Or even just if it's like one of the CRUD pages, like let's say that you have a traditional sort of Django app or whatever where you've done server side routing and you only want interactivity on the edit page.

00:12:18.000 --> 00:12:22.000
And for the view and the list, you're fine with normal templates.

00:12:22.000 --> 00:12:27.000
I mean, you could just use MicroPython where you need it then.

00:12:27.000 --> 00:12:36.000
But if you're building a single page app and you want everything downloaded up front, maybe that 10 megs is worth it.

00:12:36.000 --> 00:12:42.000
Yeah, you know, perhaps because you can put aggressive caching on it, put it over CDN.

00:12:42.000 --> 00:12:49.000
A lot of times when you pull it up, it'll say, you know, loaded from cache, things like that, right?

00:12:49.000 --> 00:12:50.000
Yeah.

00:12:50.000 --> 00:12:52.000
Let's see if I can.

00:12:52.000 --> 00:12:59.000
On PyScript, let's see what happens here if we go to the network and pull this in.

00:12:59.000 --> 00:13:00.000
Oh, look at that.

00:13:00.000 --> 00:13:05.000
They're using MicroPython there, but yeah, all this stuff is coming out of disk cache.

00:13:05.000 --> 00:13:08.000
Seven milliseconds to pull that up, right?

00:13:08.000 --> 00:13:14.000
So another thing I just saw looking at the PyScript source there is that it had a service worker.

00:13:14.000 --> 00:13:19.000
And service workers kind of indicate maybe progressive web app, right?

00:13:19.000 --> 00:13:22.000
Let's see if I click on this.

00:13:22.000 --> 00:13:24.000
Not quite, but partially.

00:13:24.000 --> 00:13:28.000
Partially a progressive web app on PyScript.net.

00:13:28.000 --> 00:13:32.000
I know you're familiar with these, and it might be an interesting way to deploy.

00:13:32.000 --> 00:13:35.000
You know, you talked about the internal apps, right?

00:13:35.000 --> 00:13:39.000
Instead of just putting links, maybe you install it as a progressive web app, right?

00:13:39.000 --> 00:13:40.000
Yeah.

00:13:40.000 --> 00:13:46.000
I mean, I haven't made a progressive web app in PyScript yet.

00:13:46.000 --> 00:13:49.000
But there's others who have done it.

00:13:49.000 --> 00:13:55.000
Yeah, I've done it, and I have an example up where I don't think it runs anymore because PyScript's changed so much.

00:13:55.000 --> 00:14:01.000
But I even got it to install as an app on the home screen of my iPad.

00:14:01.000 --> 00:14:02.000
You click it, it launches.

00:14:02.000 --> 00:14:04.000
It looks like a full-blown app.

00:14:04.000 --> 00:14:08.000
Nobody would know the difference, but it's PyScript-based.

00:14:08.000 --> 00:14:14.000
Yeah, I'll try to link the video about that in the show notes.

00:14:14.000 --> 00:14:22.000
Yeah, if you're running a SaaS, that's a really compelling option because then you also skip out on the App Store review process.

00:14:22.000 --> 00:14:24.000
Oh, my gosh.

00:14:24.000 --> 00:14:26.000
Forking over something.

00:14:26.000 --> 00:14:30.000
Yeah, like you've got to carve off a piece of your soul to get through App Store review.

00:14:30.000 --> 00:14:35.000
It's not a fun experience, let me tell you.

00:14:35.000 --> 00:14:42.000
I've been through the ringer four or five times, mostly in the Apple App Store, but also in the Google App Store with our courses app.

00:14:42.000 --> 00:14:45.000
Not fun.

00:14:45.000 --> 00:14:47.000
Progressive web app, letting you skip that.

00:14:47.000 --> 00:14:49.000
100% behind that idea.

00:14:49.000 --> 00:14:53.000
That's PyScript, which is super awesome.

00:14:53.000 --> 00:14:56.000
But let me just make a comment here to get your thoughts about this.

00:14:56.000 --> 00:15:00.000
When I go to PyScript.net, I'm a big fan of this project, the people behind it.

00:15:00.000 --> 00:15:15.000
But when I get here, what it shows me, what it basically communicates to me at least, is you, dear visitor, can have Python in your browser.

00:15:15.000 --> 00:15:19.000
And so, for example, here is your REPL.

00:15:19.000 --> 00:15:23.000
You just type Python in the terminal, that thing that comes up, that read about print loop.

00:15:23.000 --> 00:15:31.000
You just get the REPL, and now I can type. I could do x equals 7, y equals 2, x plus y is 9.

00:15:31.000 --> 00:15:35.000
That's interesting, and it shows the power.

00:15:35.000 --> 00:15:39.000
But as a web developer, I don't want to develop a REPL.

00:15:39.000 --> 00:15:45.000
I want to develop web applications like input boxes, and images, and grids.

00:15:45.000 --> 00:15:48.000
And if I interact with this, it changes that, and so on.

00:15:48.000 --> 00:16:00.000
I want a front-end UI experience with my Python in the browser, not just the equivalent of the console in JavaScript.

00:16:00.000 --> 00:16:04.000
Yeah, that's my desire, too.

00:16:04.000 --> 00:16:12.000
Something I really like about Vue, React does this, but I don't have as much React experience, is reactivity.

00:16:12.000 --> 00:16:27.000
Where if the state of your page or your component changes, it redraws the UI and patches the DOM, the elements in the browser, in real time.

00:16:27.000 --> 00:16:34.000
Where you don't need to think about, oh, let's say one state changed, and that affects five widgets.

00:16:34.000 --> 00:16:37.000
So I need to go redraw those five widgets.

00:16:37.000 --> 00:16:40.000
It all just kind of happens automatically.

00:16:40.000 --> 00:16:44.000
And there's nothing like that built into PyScript itself.

00:16:44.000 --> 00:16:52.000
So PewPy kind of lives on top of PyScript and adds that layer and just other conveniences that I would want.

00:16:52.000 --> 00:16:54.000
Yeah, absolutely.

00:16:54.000 --> 00:16:58.000
And event handlers, right, as well.

00:16:58.000 --> 00:17:02.000
So really a lot of neat stuff.

00:17:02.000 --> 00:17:03.000
And that is very nice about Vue.

00:17:03.000 --> 00:17:04.000
I like that as well.

00:17:04.000 --> 00:17:08.000
The data binding and the reactivity, where you can just say, here is a dictionary.

00:17:08.000 --> 00:17:14.000
I make changes to the values of that dictionary, that JSON object, and other parts of my UI are using it.

00:17:14.000 --> 00:17:17.000
Just also make those change.

00:17:17.000 --> 00:17:23.000
Or if I bound it to an input and somebody starts typing, propagate that back to the rest of the app, right?

00:17:23.000 --> 00:17:24.000
Right.

00:17:24.000 --> 00:17:26.000
And you've got reusable components.

00:17:26.000 --> 00:17:34.000
So if you make the perfect foreign key lookup widget, you can just reuse it all over your application.

00:17:34.000 --> 00:17:37.000
And reusing it is really easy.

00:17:37.000 --> 00:17:39.000
It just becomes a little HTML tag in Vue.

00:17:39.000 --> 00:17:42.000
Kind of like Web Components, if you've used those.

00:17:42.000 --> 00:17:48.000
Those didn't really catch on that well, did they, compared to how -- I think they should have caught on better, maybe.

00:17:48.000 --> 00:17:52.000
I think there's kind of a little movement behind them now.

00:17:52.000 --> 00:17:58.000
Maybe because people are so -- I mean, not to come down on any projects,

00:17:58.000 --> 00:18:09.000
but I think there's a desire to have more stable development tools, and all the JavaScript stuff changes one day to the next.

00:18:09.000 --> 00:18:15.000
Like you go get a cup of coffee, and then you need to upgrade all your node dependencies.

00:18:15.000 --> 00:18:23.000
So with Web Components, like, you really only need to upgrade the components you use.

00:18:23.000 --> 00:18:27.000
And Web Components are how I see you using PuePy, too.

00:18:27.000 --> 00:18:29.000
Okay. Very interesting.

00:18:29.000 --> 00:18:32.000
So that brings us to PuePy.

00:18:32.000 --> 00:18:37.000
The name is like Vue, but for Python, so Pew and then Pie, right?

00:18:37.000 --> 00:18:40.000
Is that where the origin is? Am I getting this right?

00:18:40.000 --> 00:18:42.000
That is the origin.

00:18:42.000 --> 00:18:44.000
Awesome.

00:18:44.000 --> 00:18:50.000
Okay, so here I land on PuePy.dev, and I see a red button with a minus and a green button with a plus.

00:18:50.000 --> 00:18:54.000
And I can just click on these, and it does the reactivity, and it does the changing.

00:18:54.000 --> 00:18:59.000
There's no navigation, but there's not really directly much JavaScript, is there?

00:18:59.000 --> 00:19:03.000
What is happening here? Tell us about this project.

00:19:03.000 --> 00:19:11.000
So on your screen, if you have it pulled up, you'll see code directly below the counter,

00:19:11.000 --> 00:19:18.000
and that is the code that is running the site you're seeing with just a little bit of boilerplate that's missing.

00:19:18.000 --> 00:19:22.000
And it sounds very -- yeah, just a tiny, tiny bit.

00:19:22.000 --> 00:19:27.000
It looks very familiar to a Vue.js app startup, right?

00:19:27.000 --> 00:19:30.000
Yeah, especially Vue 2.

00:19:30.000 --> 00:19:39.000
I never upgraded to Vue 3 while I was working on Vue stuff before handing off my current project.

00:19:39.000 --> 00:19:46.000
Yeah, there's -- you'll see that initial function defines state when the page loads.

00:19:46.000 --> 00:19:55.000
Populate defines the layout and DOM elements, and then there's two event handlers that update the state.

00:19:55.000 --> 00:19:58.000
And as the state updates, the DOM is updated.

00:19:58.000 --> 00:20:00.000
Yeah, awesome.

00:20:00.000 --> 00:20:06.000
And it looks -- yeah, you combined functions, Python functions, as the event handler,

00:20:06.000 --> 00:20:13.000
and you just say -- go to the button and say onClick equals your Python function.

00:20:13.000 --> 00:20:20.000
And then in that function, you say state bracket currentValue from the dictionary.

00:20:20.000 --> 00:20:23.000
You can increment it, like plus or minus it in this case,

00:20:23.000 --> 00:20:31.000
and that reactivity propagates back to the text box or the span in there that shows that information, right?

00:20:31.000 --> 00:20:35.000
That's kind of the full lifecycle in a pretty simple little bit of code.

00:20:35.000 --> 00:20:38.000
Yeah, that's the snippet.

00:20:38.000 --> 00:20:41.000
That's the basic idea, yeah.

00:20:41.000 --> 00:20:47.000
Let's see about the old network here.

00:20:47.000 --> 00:20:49.000
What do we get if I pull this up?

00:20:49.000 --> 00:20:51.000
A couple things that I think are interesting.

00:20:51.000 --> 00:20:56.000
I pull up the network tools, and I just pull up Pupy.dev.

00:20:56.000 --> 00:20:58.000
The whole page -- I don't know how far away this is.

00:20:58.000 --> 00:21:01.000
Do you know where this is hosted?

00:21:01.000 --> 00:21:03.000
It's on GitHub pages, so I can't --

00:21:03.000 --> 00:21:05.000
Okay, so it's on the Internet.

00:21:05.000 --> 00:21:07.000
Okay, awesome.

00:21:07.000 --> 00:21:12.000
All right, so it loads in -- because I was thinking about, well, it's the ping time and stuff.

00:21:12.000 --> 00:21:22.000
So it loaded in 155 milliseconds, and then it processed the DOM content in 144 milliseconds, which is -- that's good.

00:21:22.000 --> 00:21:25.000
That's in a realm that people don't really perceive, right?

00:21:25.000 --> 00:21:27.000
Not really.

00:21:27.000 --> 00:21:34.000
And it looks like you're doing MicroPython here, which is -- how big is our MicroPython?

00:21:34.000 --> 00:21:37.000
It is 1.6 megs.

00:21:37.000 --> 00:21:39.000
No, no, that's the age, sorry.

00:21:39.000 --> 00:21:40.000
Where's the content length?

00:21:40.000 --> 00:21:41.000
There it is.

00:21:41.000 --> 00:21:42.000
188K.

00:21:42.000 --> 00:21:43.000
189K.

00:21:43.000 --> 00:21:45.000
That's pretty good.

00:21:45.000 --> 00:21:51.000
There's some stuff that was downloaded that you'll also see over there, like the PewPy wheel.

00:21:51.000 --> 00:21:53.000
Yeah, sure.

00:21:53.000 --> 00:21:57.000
Which -- I mean, hold on to what you just said there.

00:21:57.000 --> 00:22:00.000
The PewPy wheel was downloaded, okay?

00:22:00.000 --> 00:22:02.000
So talk about that.

00:22:02.000 --> 00:22:05.000
Like, this is not even the source, right?

00:22:05.000 --> 00:22:09.000
This is -- the distribution.

00:22:09.000 --> 00:22:12.000
I mean, probably in there it has the source, but --

00:22:12.000 --> 00:22:16.000
Yeah, I mean, a wheel file is just a zip file of the source.

00:22:16.000 --> 00:22:19.000
Yeah.

00:22:19.000 --> 00:22:25.000
It could have binary goodies in there as well, I suppose, but this one's platform neutral, so it's not likely.

00:22:25.000 --> 00:22:32.000
But this is basically like taking something off PyPI and pip installing it, but for your website.

00:22:32.000 --> 00:22:36.000
For your front end, you would basically pip install it, right?

00:22:36.000 --> 00:22:37.000
Yeah.

00:22:37.000 --> 00:22:44.000
Now, I would like to have it work that way, but for MicroPython you don't get the full pip.

00:22:44.000 --> 00:22:45.000
Right, right, right.

00:22:45.000 --> 00:22:48.000
MicroPython has a funky way of working with its dependencies.

00:22:48.000 --> 00:22:54.000
I don't remember exactly how I got it working with this little thing, but it has three or four dependencies.

00:22:54.000 --> 00:22:59.000
My little 32-bit little chip thing.

00:22:59.000 --> 00:23:07.000
But I do remember that it was like, "Ah, my intuition around pip wasn't quite working."

00:23:07.000 --> 00:23:08.000
Okay.

00:23:08.000 --> 00:23:16.000
So, I mean, if you said -- if you went to somebody and said, "We have an interactive web page and it's 189K plus a little bit,"

00:23:16.000 --> 00:23:19.000
like, that's fine, right?

00:23:19.000 --> 00:23:23.000
On a CDN, no one's going to have a problem with that amount of data.

00:23:23.000 --> 00:23:24.000
Yeah.

00:23:24.000 --> 00:23:26.000
The other thing -- go ahead.

00:23:26.000 --> 00:23:31.000
That absolutely competes with what a typical JavaScript framework would require.

00:23:31.000 --> 00:23:32.000
Yeah.

00:23:32.000 --> 00:23:45.000
And the other thing worth noting here is PyPi, its wheel comes from disk cache as well as MicroPython WebAssembly, right?

00:23:45.000 --> 00:23:52.000
So once I hit this -- like, for example, now looking at the processing times, it's 62 milliseconds and 50 milliseconds.

00:23:52.000 --> 00:23:53.000
Right?

00:23:53.000 --> 00:23:54.000
That's ridiculous.

00:23:54.000 --> 00:23:55.000
That's awesome.

00:23:55.000 --> 00:23:56.000
So --

00:23:56.000 --> 00:24:06.000
Yeah, I mean, I don't know how fast your computer is, but I haven't been bothered by any of the performance I've seen from PyScript.

00:24:06.000 --> 00:24:08.000
Yeah, no, it's super fast.

00:24:08.000 --> 00:24:20.000
It's down to a point where there have been statements like, "Well, it'd be cool if you could use something like Pyodide, but it's just so slow.

00:24:20.000 --> 00:24:28.000
It takes five seconds for the page to come up or whatever on the early days," and you can't really assume that that's acceptable to people.

00:24:28.000 --> 00:24:35.000
But 150 milliseconds, 60 milliseconds here and there, that's blink of an eye type stuff.

00:24:35.000 --> 00:24:37.000
You're good to go with that, right?

00:24:37.000 --> 00:24:49.000
Yeah, I mean, I probably wouldn't use it for, like, WebGL kind of stuff or anything that needs to be super performant, but most business software is just fine with these.

00:24:49.000 --> 00:24:50.000
Right.

00:24:50.000 --> 00:24:58.000
And even, you know, like, that is a runtime performance versus app initialization performance conversation, isn't it?

00:24:58.000 --> 00:24:59.000
Yeah.

00:24:59.000 --> 00:25:03.000
Yeah, so let's talk a bit about that.

00:25:03.000 --> 00:25:05.000
What is this good for and what is it bad for?

00:25:05.000 --> 00:25:23.000
Well, I mean, I think it's good for -- it's most good for, especially with MicroPython, those kind of use cases where you have business logic that is presentation-relevant.

00:25:23.000 --> 00:25:29.000
Like, you have a form, and what is shown on the form depends on what's already entered.

00:25:29.000 --> 00:25:37.000
You know, that's the kind of stuff you would have done with jQuery back in the day, and you could do it very easily with PewPy.

00:25:37.000 --> 00:25:40.000
You could do kind of basic CRUD work.

00:25:40.000 --> 00:25:42.000
You could do data visualization.

00:25:42.000 --> 00:25:50.000
And also just any time that you want a full Python environment in the browser, obviously it's a good choice.

00:25:50.000 --> 00:26:06.000
It's probably not a great choice if you don't already know and love Python, because if you're a JavaScript developer, you know, why would you lose all the tooling?

00:26:06.000 --> 00:26:13.000
For that matter, if you like a lot of tooling, you know, there's no Chrome debugger for PyScript.

00:26:13.000 --> 00:26:16.000
You just get your trace back.

00:26:16.000 --> 00:26:17.000
Can you print?

00:26:17.000 --> 00:26:18.000
Can you print a console?

00:26:18.000 --> 00:26:21.000
You can print, and normal Python print statements go to console.

00:26:21.000 --> 00:26:23.000
That's what you get.

00:26:23.000 --> 00:26:24.000
You're good.

00:26:24.000 --> 00:26:28.000
You know, honestly, though, you probably could bring in some of these libraries.

00:26:28.000 --> 00:26:29.000
Oh, gosh, I can't remember.

00:26:29.000 --> 00:26:39.000
There's a couple that are really nice that you can bring in and change the print statement, or they'll do much richer output of, like, the state of an object.

00:26:39.000 --> 00:26:42.000
They'll traverse the graph, or they'll give better information about it.

00:26:42.000 --> 00:26:47.000
So you might be able to get those print statements a little bit supercharged, but they're still print statements, right?

00:26:47.000 --> 00:26:48.000
Yeah.

00:26:48.000 --> 00:26:56.000
I mean, hopefully one day you can run, like, a remote debugger into PyCharm or something, too, but yeah.

00:26:56.000 --> 00:26:58.000
That would be cool.

00:26:58.000 --> 00:27:01.000
We'll get the PyCharm folks on that and just connect to the front end.

00:27:01.000 --> 00:27:03.000
Look, they do it with JavaScript.

00:27:03.000 --> 00:27:04.000
Yeah.

00:27:04.000 --> 00:27:05.000
Right?

00:27:05.000 --> 00:27:10.000
And also, you know, PyCharm supports remote debugging, so.

00:27:10.000 --> 00:27:12.000
Let's put them together.

00:27:12.000 --> 00:27:15.000
Yep.

00:27:15.000 --> 00:27:22.000
All right, so one of the things that does jump out at me when I see this here is the populate method.

00:27:22.000 --> 00:27:33.000
So the way you create this interactive app that has the plus and minus increment or decrement or things is you create a class called CounterPage, DerivationPage.

00:27:33.000 --> 00:27:41.000
When it initializes itself, it sets sort of the variables to their default values and creates them.

00:27:41.000 --> 00:27:58.000
You know, increment can change them, decrement can change them, but then there's this populate method that says, "With some kind of DOM element," like, "With div," with this class, "With t.button as this text," and it's a vent hooks this.

00:27:58.000 --> 00:28:06.000
So you're expressing the UI of that little section, not the whole page, but that little section in Python code.

00:28:06.000 --> 00:28:09.000
Want to tell us about how that goes?

00:28:09.000 --> 00:28:25.000
Yeah, so, you know, the kind of two approaches that you can have toward building a DOM, building not even a DOM but just any UI is like a templated language, which is usually real popular on the web.

00:28:25.000 --> 00:28:34.000
And I have experimented with embedding Jinja to templates, and it works sort of on Pyodide.

00:28:34.000 --> 00:28:44.000
What I decided on is my preferred method is using context managers to specify nesting.

00:28:44.000 --> 00:29:07.000
So in the example you're looking at, there's a div tag, and then there's two buttons and a span, and they're nested in the div tag, and the context manager tells the -- well, tells the UI -- you're telling the UI to Pupy using context managers.

00:29:07.000 --> 00:29:24.000
So every time you want to nest more elements, you use another with statement, and that way you can use if statements, for loops, just normal Python code, and the deeper you're into your context managers, the more nested you are.

00:29:24.000 --> 00:29:38.000
Right. So in this case, you say with div, and then you create a button, a span, and a button. Basically, anything that gets created while within that context manager just goes to the children of the thing that was put into the context, right?

00:29:38.000 --> 00:29:45.000
Right, exactly. And for that matter, you could also nest more Pupy components using --

00:29:45.000 --> 00:30:00.000
Oh, interesting. Okay. And what does a Pupy component look like? Is it just a class, or is there -- how do we make one of the -- or is it just a function that also does context manager stuff? What's the deal?

00:30:00.000 --> 00:30:18.000
I do have some examples of them, but, yeah, a component -- a page is a component, but a component is any reusable chunk of code with that state and population that you can use and reuse throughout your application.

00:30:18.000 --> 00:30:24.000
Right. Let's see if I can find some examples.

00:30:24.000 --> 00:30:30.000
You also can run those examples on PyScript.com right in your browser.

00:30:30.000 --> 00:30:38.000
Oh, that's right. Yeah. So, yeah, maybe tell people just about that capability. I'll link to the tutorials there.

00:30:38.000 --> 00:30:57.000
Yeah, I mean, PyScript.com is a really cool project, also from Anaconda, I believe, where it's kind of like all those million JavaScript IDEs in your browser. ID is maybe a strong word, but you can edit the code and then run it right in your browser.

00:30:57.000 --> 00:31:09.000
Just like you can see, there's the list of files. You can edit the files. You can fork other people's work and edit them. It's very convenient.

00:31:09.000 --> 00:31:22.000
Nice. Yeah, so here you have a component defined with the decorator. Called it a card, and you've got three little UI cards on there, and they have their populate thing that I guess that you would expect?

00:31:22.000 --> 00:31:23.000
Yeah.

00:31:23.000 --> 00:31:29.000
Yeah, and then you can just now create the cards as if you're creating any other DOM element, right?

00:31:29.000 --> 00:31:47.000
Right, exactly. You're also seeing slots where there's a card header and then the card body. And so if you have a component where there's multiple... In Jinja, these would be like template inheritance.

00:31:47.000 --> 00:32:01.000
But if you have a component where you want to insert code from wherever you're using the component into where the component renders, that's what slots do. Again, a lot like Vue.

00:32:01.000 --> 00:32:11.000
Sure. So it sounds to me like if I had lots of Vue experience, but at one point I created some apps with Vue, but it's been a while. I'm sure that Vue doesn't look much like that anymore.

00:32:11.000 --> 00:32:14.000
Yeah, it's changed a lot.

00:32:14.000 --> 00:32:19.000
Yeah, but if you had that experience, it would carry over to PuePy pretty well, right?

00:32:19.000 --> 00:32:23.000
Yeah. I mean, I would hope you wouldn't need that experience either, but yeah.

00:32:23.000 --> 00:32:31.000
Sure. Yeah, you could just learn it from the PuePy perspective, but if you already knew it, like, hey, that's kind of nice, right?

00:32:31.000 --> 00:32:39.000
Yeah. If you know React or web components, that also would probably carry over.

00:32:39.000 --> 00:33:00.000
Sure. Okay. So one of the things that you talked about was a single page app. And I'm sure there's plenty of people out there who know what a single page app is or a SPA, but there's probably a lot of people who are coming from not a web developer areas that are like, what is that again?

00:33:00.000 --> 00:33:06.000
I want to talk about the router, but I think we need to talk about a single page app before we can talk routers. All right. What is this?

00:33:06.000 --> 00:33:27.000
Yeah. Well, you need a router to do it, but a single page app is instead of having that request response cycle where the server renders HTML, and then you go to a new page and the server renders the new HTML, and then you go to another page and the server renders that.

00:33:27.000 --> 00:33:52.000
A single page app works where it loads the page, and then when you click on a button or click on a link, the software in the client in your browser re-renders the page based on the link you clicked without ever talking to the server. Or if it does talk to the server, it's just kind of an API call to figure out what data it wants to render on the page.

00:33:52.000 --> 00:34:17.000
But the page itself and the structure is not done through server calls. It's not done through redrawing the page or navigating, even though sometimes you'll see the URL change. It might not actually go anywhere. Right? That might just be something so you kind of know where it is so you can bookmark and deep link into it, but it doesn't actually make the browser go, right?

00:34:17.000 --> 00:34:40.000
>> Yeah. That's the gist. I mean, one telltale sign of kind of an older SPA is if all the URLs, like if it's index.html or something, but then the meat of the URL is after the hash. So it's, you know, example.com/ and then a hash, and then the hash tells you everything about the URL.

00:34:40.000 --> 00:34:41.000
>> Right. Right.

00:34:41.000 --> 00:34:46.000
>> That's a telltale sign that it's an SPA, an older one that used that.

00:34:46.000 --> 00:34:47.000
>> Okay.

00:34:47.000 --> 00:34:55.000
>> Because then the client is looking at what's after the hash and deciding what it wants to render. And by client, I mean the website.

00:34:55.000 --> 00:35:16.000
>> Okay.

00:35:16.000 --> 00:35:19.000
>> And that's called a router, right?

00:35:19.000 --> 00:35:20.000
>> Right.

00:35:20.000 --> 00:35:23.000
>> And you guys have a router, right? So that's pretty awesome.

00:35:23.000 --> 00:35:29.000
>> There is a router. It's not as powerful as one in Flask or Django, but it gets the job done.

00:35:29.000 --> 00:35:52.000
>> Okay. Let's see. Here we go. Router. There's a bunch of really nice -- a nice tutorial walkthrough. I went through most of these up to basically here more or less earlier today. And yeah, tell us about how you set up this router and how this works.

00:35:52.000 --> 00:36:12.000
>> Well, you're looking at a link component. That's probably not real interesting. But if you scroll down, when you define pages, there it is. App.page is a decorator. That's how you're telling PuePy that you've made a page. And the default page is the one that renders if there is no route.

00:36:12.000 --> 00:36:28.000
But you'll also see above it, pet page, where just like with Flask, the URL is in the decorator. So it's saying if you go to pet and then there's a pet ID, use that class to render the page.

00:36:28.000 --> 00:36:43.000
>> And does that -- I can put that whole URL without the hash in there and it will find it? So I can just say my server/pet/dog or whatever the thing's ID is, and it will invoke the router instead of the browser?

00:36:43.000 --> 00:37:12.000
>> Well, there's two routing options. One is that hash I mentioned. And that's easiest to set up. Because you don't then require any changes on the server. If you have a server you want -- like if you have a Django project, let's say, and you want a single page app, how that has to work is whenever the browser opens a URL, Django, if it's a URL for the single page app,

00:37:12.000 --> 00:37:37.000
needs to return the single page app and not try to process the URL on server side. So there's some tricks to doing that. I think there's actually a couple Django packages now that do that. But you're essentially just putting a wild card up. So maybe example.com/app and then anything after that URL renders the exact same page as if it were indexed on HTML.

00:37:37.000 --> 00:37:42.000
>> I see. Which would you recommend? The hash or the server hack?

00:37:42.000 --> 00:37:47.000
>> Well, the hash doesn't require any server hack. So that's convenient.

00:37:47.000 --> 00:37:51.000
>> Yeah. It probably doesn't require any server communications either, right?

00:37:51.000 --> 00:37:54.000
>> It doesn't require -- I mean, no, it doesn't require --

00:37:54.000 --> 00:37:55.000
>> Not directly.

00:37:55.000 --> 00:38:24.000
>> You can just have a static HTML website that works fine doing that. If you want cleaner URLs, you want to use what's called HTML5 history mode. And that's where there's an API you can hook into on the browser and navigate around. And it'll look exactly like a normal website where you're changing the URL, but the page isn't actually reloading.

00:38:24.000 --> 00:38:31.000
Then when you reload, you need that server hack to make sure it always serves the same page.

00:38:31.000 --> 00:38:51.000
>> Got it. So in effect, that would be what's sometimes called deep linking, right? Where it doesn't just load up the front page of the spa and you click around and get back. But if you were on this page with these details and that's contained in the URL, you could bookmark it and come back and it should come back to that setup, right?

00:38:51.000 --> 00:38:55.000
>> Yeah. I mean, you have to test that to make sure you did it right.

00:38:55.000 --> 00:38:56.000
>> Yeah, of course.

00:38:56.000 --> 00:39:08.000
>> You browse around the site and it all seems fine. And then you come back and reload later and you get a 404 because you haven't configured your server to always go to the SPA.

00:39:08.000 --> 00:39:10.000
>> Okay. Interesting.

00:39:10.000 --> 00:39:36.000
What about working with external data and from the front end that usually means APIs, something like that, right? Can I use some of our standard code that we would for like HTTPX or requests or things along those lines to call out? Or how do I call out from this?

00:39:36.000 --> 00:39:56.000
>> So networking is where it gets a little messy because the browser doesn't let you just have untrammeled access to open whatever sockets you want. You have to work within either web sockets or requests. And the best way to do that is using PyScripts fetch function.

00:39:56.000 --> 00:39:57.000
>> Okay.

00:39:57.000 --> 00:40:04.000
>> That wraps the browser fetch, which is the new XML HTTP request.

00:40:04.000 --> 00:40:17.000
>> Got it. So basically you kind of do an Ajax thing in the browser and then pick it back up from there. Maybe you get some JSON back, but then you could maybe use the JSON module to process it or...

00:40:17.000 --> 00:40:22.000
>> Ajax or web sockets are basically your choices.

00:40:22.000 --> 00:40:46.000
>> Okay. In the PyPI library example, you have beautiful soup for parsing data. The example that you run, you can run it and it'll show you... Actually, that's a pretty interesting example. Maybe it's worth giving a shout out to is I think it's this one perhaps is to go and refresh the thing.

00:40:46.000 --> 00:41:05.000
It will actually go and you can give it some part of HTML, some HTML like I don't know, just make up some. See how forgiving this is. So you give it any HTML, some basic page data that you have.

00:41:05.000 --> 00:41:29.000
And in here, when you run this, it'll use beautiful soup to parse it. And then the output at the bottom is that populate thing. So it'll basically recreate that DOM structure, take an HTML file or HTML content and convert it to the component style of PyPI, right?

00:41:29.000 --> 00:41:51.000
>> Yeah. I kind of made that as a little utility because I might go have some HTML that I really want to render that can be part of my web app. And rather than going line by line and trying to figure out how to generate that programmatically in Python, you can paste it into here and get your Python back.

00:41:51.000 --> 00:42:09.000
>> Does it even do classes? >> Yeah. >> So it knows all about the attributes. Yeah, it sure does. That's pretty awesome. So maybe you could do something like write out an important chunk of HTML with all the tooling, PyCharm or VS Code or whatever, copy paste.

00:42:09.000 --> 00:42:16.000
>> Yeah. >> And then get it here, right? Like an accelerated way to generate the first bit of structure and then just tweak it from here.

00:42:16.000 --> 00:42:27.000
>> Maybe you don't like writing HTML or don't know how to and you ask ChatGPT to write some for you and then you copy and paste it into here and see how it works.

00:42:27.000 --> 00:42:42.000
>> Yeah, that's a totally reasonable thing. Chat GPT is pretty good at writing HTML. It does make up stuff. Like if you say use this framework or that framework like Bootstrap or Tailwind or something. But it'll still get you pretty close.

00:42:42.000 --> 00:42:56.000
>> Yeah, it's decent. >> Yeah. I've used it before. It was pretty excellent. Let's see. What? Let me rerun this whole thing here.

00:42:56.000 --> 00:43:12.000
What other things you want to give a shout out to? I guess maybe the refs concept here is worth talking about because this is an interesting challenge that people could run into.

00:43:12.000 --> 00:43:34.000
>> Yeah. This is the same -- this is a problem that would happen in Vue as well where as that state changes, as your application state changes, that populate function that defines your DOM runs on every single state change unless you -- you can override that.

00:43:34.000 --> 00:44:02.000
Maybe there's a state that isn't important and you can turn that off. But that's the default. And so what that means is every time that you have a state change, the DOM could be different and if the DOM is different and it patches the DOM, that means that the browser might have -- let's say you're typing in an input element and the input element moves.

00:44:02.000 --> 00:44:22.000
You would lose focus on that element. And that's the example that you see in this demo. So if you give it a ref, that does two things. One, it identifies within that component. It's kind of like an ID, but it's local to the component. It's not a document wide ID.

00:44:22.000 --> 00:44:40.000
It identifies it so that when it comes time to patch the DOM, it will reuse that HTML tag, that element in the DOM, and only update the attributes on it and the elements around it.

00:44:40.000 --> 00:44:52.000
So you get ultimately a smoother browser experience because it's being a little more intelligent about how it wants to patch the DOM.

00:44:52.000 --> 00:45:10.000
Right. So in your example, there's an input. And as you start typing into it with the naive straightforward way, the thing reruns, but it regenerates the DOM in a way that completely blasts away that text input.

00:45:10.000 --> 00:45:22.000
It puts it back, but as you type, now the thing goes click, click, click, because -- or beep, beep, beep, because it's no longer focused on there. Because that's not actually the same text box. It's a new one with the same value, right?

00:45:22.000 --> 00:45:32.000
And so in order to say, no, this thing is permanent, leave it here. Don't recreate it for whatever reason. Maybe you could use that for performance, right? If you had a big grid that didn't change.

00:45:32.000 --> 00:45:54.000
Yeah, it would probably help with performance. You also can use it to just reference those components elsewhere in your code. Like if you have an event handler and you want to get at a DOM element that's rendered, you can reference self.refs, use the reference as a dictionary key, and that gets you the component.

00:45:54.000 --> 00:46:15.000
Yeah, sure. All right, so I really recommend that people come check out this tutorial. It's got a bunch of neat pieces. And not just necessarily jump it in here into the PyScript runner, but on the documentation, which is somewhere. I found it somewhere. There you go.

00:46:15.000 --> 00:46:27.000
There's actually a really nice walkthrough. You start here, you click, take me to the next one, see that example run, right? At docs.py.dev, walk through the tutorial. That's really quite nice there.

00:46:27.000 --> 00:46:38.000
Thanks, I hope it's nice. Send me any feedback if it's not, because it's hard to write a tutorial for something you made yourself and understand pretty well.

00:46:38.000 --> 00:46:45.000
Yeah, that's a good point, right? Because you know how it's supposed to look.

00:46:45.000 --> 00:46:51.000
Yeah, it's hard to evacuate that assumed knowledge from your context.

00:46:51.000 --> 00:47:12.000
Yeah, exactly. Okay, so this looks like a pretty well polished framework. It's still at its super, super early stages. So I guess a couple questions. One, contributors, PRs welcome. What's the thoughts there?

00:47:12.000 --> 00:47:17.000
Yeah, absolutely. That's why it's on GitHub.

00:47:17.000 --> 00:47:27.000
Yeah, and if people want to try to build with it, they can give it a try and maybe they'll discover an issue and put it on the GitHub repo or something like that.

00:47:27.000 --> 00:47:37.000
Yeah, it'd be cool. And then towards that end, what is its readiness for use?

00:47:37.000 --> 00:47:53.000
If somebody said, I want to be all in on Python, I think PyScript's awesome. What's the stability look like? Where would you classify it? Is it an experimental stage? Is it a beta? What is it?

00:47:53.000 --> 00:48:13.000
If you're someone who is comfortable using a relatively new project that has one contributor on GitHub, I think you know who you are. If you took this and you try to bring it to a review board of a Fortune 500 company, I don't think they would go for it.

00:48:13.000 --> 00:48:15.000
They might.

00:48:15.000 --> 00:48:20.000
They might just try to get smuggled in. They might. They can almost fork it.

00:48:20.000 --> 00:48:33.000
Exactly. That's what I was going to say. That's why they might, because while there's not a huge team behind it, they could fork it and say, look, this is important enough for us that we'll take it over effectively if we have to.

00:48:33.000 --> 00:48:38.000
It's also just not that much code.

00:48:38.000 --> 00:48:52.000
I've been kind of working on it on and off in my free time for like six months, but the volume of code, I don't know how many lines there are off the top of my head, but there's like four main files.

00:48:52.000 --> 00:48:57.000
They're relatively straightforward. Most of the heavy lifting is with PyScript.

00:48:57.000 --> 00:48:59.000
Yeah.

00:48:59.000 --> 00:49:10.000
The sense of stability and breaking, I can't promise that I won't break anything, but I think it's pretty deliberately laid out.

00:49:10.000 --> 00:49:20.000
Like I said, one complaint I have about the Node.js world is how aggressively everything gets broken every six months.

00:49:20.000 --> 00:49:26.000
So I have some PTSD from that, and I'm not looking to recreate it myself.

00:49:26.000 --> 00:49:34.000
No more left pad. That's not even the problem. The problem is just that it's the constant change of this version changes.

00:49:34.000 --> 00:49:43.000
And it also happens in CSS frameworks like, oh, we've got bootstrap six, and I know five was awesome, and you wrote a bunch of stuff in it, but we're completely redoing it because it's better now.

00:49:43.000 --> 00:49:52.000
It's like, it would be even better if I didn't have to start over or get pinned in the past or whatever.

00:49:52.000 --> 00:50:02.000
I think if you're living in that world, like it's fine because you get up every day and you eat, breathe, sleep.

00:50:02.000 --> 00:50:07.000
Everything in your world is this Node front end framework, and it's your full time job.

00:50:07.000 --> 00:50:16.000
You can keep up with it. But if you're like me and it's just something you did, and then six months later you need to revisit it, it's too much.

00:50:16.000 --> 00:50:19.000
Yeah. Yeah, well said.

00:50:19.000 --> 00:50:28.000
Okay. Last QPi question. Where are you going from here? What do you got next in mind?

00:50:28.000 --> 00:50:40.000
The testing is basically just Python unit tests. I'm not really, I don't have any automated testing for how it behaves in different browsers.

00:50:40.000 --> 00:50:45.000
It's fine. Code runs the same in all browsers. Don't worry about it.

00:50:45.000 --> 00:50:49.000
Well, I mean, it might with iScript, but...

00:50:49.000 --> 00:51:00.000
No, it's getting better. It used to be really bad, but I'm just now dealing with the issue like, this video will play back on every single browser except this particular one on this particular OS. Like, great.

00:51:00.000 --> 00:51:01.000
Right.

00:51:01.000 --> 00:51:03.000
Okay. It's that kind of stuff, right?

00:51:03.000 --> 00:51:06.000
I can't solve that kind of stuff for you, but...

00:51:06.000 --> 00:51:07.000
No, no, no.

00:51:07.000 --> 00:51:16.000
The actual Python language is going to be the same. Maybe not for JavaScript APIs you import.

00:51:16.000 --> 00:51:24.000
Yeah. Well, to a large degree, you're basically built upon the stability or lack thereof of MicroPython, which has been pretty stable.

00:51:24.000 --> 00:51:35.000
Yeah. MicroPython's great. Pionine's great. Yeah, I would like to get some playwright tests to actually do proper end-to-end testing instead of just unit tests.

00:51:35.000 --> 00:51:43.000
I think probably some direct support for progressive web apps would be helpful.

00:51:43.000 --> 00:51:44.000
100%.

00:51:44.000 --> 00:51:47.000
Helpful for everyone.

00:51:47.000 --> 00:51:57.000
I would like to have some kind of example on how to hook it up to like a Django or Flask backend.

00:51:57.000 --> 00:52:05.000
No, that's not usually the scope for a front-end framework, but I kind of like the batteries included approach to development.

00:52:05.000 --> 00:52:10.000
Sure. You know, you talked about the progressive web apps, and I think they're great.

00:52:10.000 --> 00:52:17.000
I think it'd be, like I've already said, I think it's completely possible to do with PyScript because I've done it on iOS.

00:52:17.000 --> 00:52:25.000
But, and I think it is great, the challenge with progressive web apps is the, how do I get it in my dock?

00:52:25.000 --> 00:52:29.000
How do I install this thing, like for real, in a discoverable way?

00:52:29.000 --> 00:52:44.000
You know, I can come over on some of these things, I can like right-click on it and say, for example, if I right-click on a GitHub page, I can install GitHub, which means it will install as a progressive web app.

00:52:44.000 --> 00:52:52.000
But if I go to PyScript and right-click, it'll say create shortcut, which if I say open as a window, kind of looks like it, but it's not.

00:52:52.000 --> 00:53:02.000
And just like, that's not an end user experience, right? That's a dev user experience, I think.

00:53:02.000 --> 00:53:05.000
Yeah.

00:53:05.000 --> 00:53:09.000
But that's not for you to solve. I mean, that's a problem with progressive web apps globally.

00:53:09.000 --> 00:53:18.000
Yeah, that's nothing to do with your project, but it would be nice if there was like a really nice way to click this, here's how it goes in your dock or your taskbar and like.

00:53:18.000 --> 00:53:31.000
Yeah, I think the problem that they're butting up against is that the people who make browsers are keenly aware of how spammy websites get.

00:53:31.000 --> 00:53:41.000
So they don't want to have it be where you visit like a newspaper and the newspaper prompts you to install the newspaper.

00:53:41.000 --> 00:53:52.000
So having that easily self-documenting install process is not there for the desktop. You have to actually go click add shortcut and then it works.

00:53:52.000 --> 00:54:01.000
The Safari folks, I've talked Apple down a little bit from their really horrible app store review experiences they put on people.

00:54:01.000 --> 00:54:12.000
But the Safari browser, which I don't generally use, but they've got a really nice install this, go to file, add to dock, and then that experience.

00:54:12.000 --> 00:54:16.000
The lifecycle of using that app once you've done it is real nice.

00:54:16.000 --> 00:54:23.000
Add to dock is I want this app as an applicant thing where my other apps are. That's pretty good.

00:54:23.000 --> 00:54:32.000
Yeah, I've installed Google's old chat app, which I still use as a progressive web app using Safari on my desktop.

00:54:32.000 --> 00:54:42.000
And it's great. It's just like another application that I've downloaded and installed. It's Safari, which is fine.

00:54:42.000 --> 00:54:47.000
Yeah, as long as it stays in its little container, it doesn't infect my Vivaldi experience.

00:54:47.000 --> 00:54:58.000
No, I have Proton Drive, Gmail, Google Contacts, Google Calendar, some of the e-commerce stuff that I have to do.

00:54:58.000 --> 00:55:08.000
I've got the analytics, my email, newsletter app. I've got YouTube, YouTube Music. All those things are all installed that way these days for me, and it's really, really nice.

00:55:08.000 --> 00:55:11.000
It beats having all those electron apps running.

00:55:11.000 --> 00:55:19.000
It does. However, I don't see any reason why this stuff wouldn't work for Electron as well.

00:55:19.000 --> 00:55:34.000
You can ship your Electron app with a HTML page, and then you can just put this iScript and PuePy art as part of your HTML, and it's on the client side. It should just run in Chrome just fine.

00:55:34.000 --> 00:55:39.000
It should. I don't know what the process for that would be.

00:55:39.000 --> 00:55:49.000
The developer in me says make it a PWA, but I'm sure there's some business cases for making it a .app file. It feels more real.

00:55:49.000 --> 00:56:02.000
Well, maybe data storage, maybe access to OS features. I know that's getting better, but it's running natively on the machine. You can do whatever you need to do, so possibly.

00:56:02.000 --> 00:56:16.000
That might get a little messy in terms of importing those features once into JavaScript and then from JavaScript into PuePy.

00:56:16.000 --> 00:56:23.000
Yeah, you might have to have a multi-layer interop type thing that's a little bit funky.

00:56:23.000 --> 00:56:37.000
Yeah. My suspicion is that most people making Electron apps have a team that does front-end work, and probably that front-end work is going to be in JavaScript.

00:56:37.000 --> 00:56:40.000
Right. Yeah, probably. Some framework there.

00:56:40.000 --> 00:56:49.000
All right, awesome. I think PuePy has got a lot of potential. That's why I invited you on the show to talk about it, because it's very interesting.

00:56:49.000 --> 00:56:58.000
Honestly, it's this kind of stuff I would love to see when I visit PyScript and not a REPL, because that's not what most people do.

00:56:58.000 --> 00:57:05.000
I know PyScript's a little more data science-focused, but even for them, they more have a notebook experience generally.

00:57:05.000 --> 00:57:17.000
All right. I do have a question, though. I noticed when I was going through the documentation here for your PuePy docs that it says "powered by JetBrains right side."

00:57:17.000 --> 00:57:30.000
Tell me about that. I've not used this, but it's like a new IDE for creating documentation and testing and stuff. What do you think about this? Now you've got to play with it a little.

00:57:30.000 --> 00:57:39.000
Well, you're basically just calling out laziness on my behalf, because all the real Python projects are using something awesome like Sphinx.

00:57:39.000 --> 00:57:48.000
I have the JetBrains all products license, so I just saw that and tried downloading it.

00:57:48.000 --> 00:57:55.000
It works well. There's zero setup. You just open it up and start typing in Markdown.

00:57:55.000 --> 00:58:03.000
It's clean and polished. If you have a JetBrains license, you might as well try it out.

00:58:03.000 --> 00:58:13.000
But I expect that if people start contributing to the documentation, I'll need to switch to something more community-oriented.

00:58:13.000 --> 00:58:18.000
I can't remember. I feel like right side might integrate with some of those frameworks like Sphinx.

00:58:18.000 --> 00:58:23.000
But I'm asking about all this because I've not used it at all, so I don't really know.

00:58:23.000 --> 00:58:36.000
It's kind of its own framework. It supports Markdown, but it has its own little HTML-ish thing for making tabs and glossaries and all that.

00:58:36.000 --> 00:58:50.000
Yeah, excellent. Okay. And then I guess anything else you want to give a shout out to or talk about on the PewPi side of things when we wrap up our show?

00:58:50.000 --> 00:58:54.000
I would kind of like to give a shout out just to the PyScript people.

00:58:54.000 --> 00:59:02.000
I've gotten stuck a few times and headed over to their Discord server, and they're always really friendly.

00:59:02.000 --> 00:59:08.000
They run little meetups on Zoom with the community, and they've been great.

00:59:08.000 --> 00:59:11.000
I wouldn't have been able to do this without their help.

00:59:11.000 --> 00:59:14.000
Yeah, awesome. They have been helpful for me as well.

00:59:14.000 --> 00:59:21.000
All right. And then notable PyPI project library?

00:59:21.000 --> 00:59:29.000
Completely unrelated, but there is a project called PGQer.

00:59:29.000 --> 00:59:31.000
There you have it pulled up on GitHub.

00:59:31.000 --> 00:59:49.000
And if you want something kind of like Celery, but you don't want to have to install Celery and install a broker and figure out your Celery installation and make maybe even another Docker container for your workers, this is great.

00:59:49.000 --> 00:59:59.000
It uses some Postgres and some Notify features that are built right into Postgres, and you get a simple task queue.

00:59:59.000 --> 01:00:03.000
I've tried it. It works great.

01:00:03.000 --> 01:00:12.000
Probably Celery is still "better" for complex needs, but if you just want something simple, this is great.

01:00:12.000 --> 01:00:16.000
Yeah, it's cool. I mean, the truth is most of us have not complex needs, simple needs.

01:00:16.000 --> 01:00:24.000
And then bringing that kind of stuff in just makes it way more complicated from a DevOps perspective, right?

01:00:24.000 --> 01:00:29.000
I'm already talking to a database. I'm already talking to Postgres. What if I could just use it?

01:00:29.000 --> 01:00:35.000
There's a lot to learn with Celery. It's a whole project unto itself.

01:00:35.000 --> 01:00:42.000
Sure. Yeah, over at DocPython, I've got a MongoQueuer equivalent.

01:00:42.000 --> 01:00:49.000
Because you scale out the worker processes, right? So it's not enough to just have them running.

01:00:49.000 --> 01:00:55.000
You want a little more durability in case for some reason the server restarts, but there's still work to be done.

01:00:55.000 --> 01:01:00.000
You just come back and look, "Oh look, there's some unprocessed work in the database. Let's do that."

01:01:00.000 --> 01:01:03.000
It's not quite as nice as this, I think.

01:01:03.000 --> 01:01:11.000
But I suppose if it said send an email and it had sent the email, but it hadn't acknowledged it sent the email yet,

01:01:11.000 --> 01:01:16.000
and you restart the server at that very moment, the person's probably getting a second email.

01:01:16.000 --> 01:01:20.000
But there's a really, really small chance of these types of things.

01:01:20.000 --> 01:01:25.000
It's much more common to re-index these things or whatever.

01:01:25.000 --> 01:01:33.000
I think actually with PGQer, because it's Postgres, you would get strong consistency.

01:01:33.000 --> 01:01:37.000
So the chance of that duplicate email would be low.

01:01:37.000 --> 01:01:46.000
Well, but imagine this, if you do a transaction and you go to start, let's say, I'm going to move the work into running,

01:01:46.000 --> 01:01:51.000
and then if you shut it down, that transaction's going to roll back and it'll probably go back to ready to run.

01:01:51.000 --> 01:01:54.000
I mean, how do you deal with it?

01:01:54.000 --> 01:02:01.000
It almost comes back to the poison message thing of like celery and message queues, which is really very tricky.

01:02:01.000 --> 01:02:07.000
Sending an email, the thing is, you can't put that in your transaction.

01:02:07.000 --> 01:02:09.000
Yeah, exactly.

01:02:09.000 --> 01:02:15.000
Well, a few things have tried to recall email, but in general, email doesn't support rollback.

01:02:15.000 --> 01:02:19.000
No, that might be a good feature for SendGrid to consider.

01:02:19.000 --> 01:02:22.000
Yeah, that would be very cool.

01:02:22.000 --> 01:02:28.000
One thing you can kind of do in those situations, if you happen to have like Redis or something available,

01:02:28.000 --> 01:02:34.000
is if you -- the content of the email is going to be exactly the same.

01:02:34.000 --> 01:02:43.000
So if you just hash the email to identify it somehow, like combination of the email content and who it's for,

01:02:43.000 --> 01:02:48.000
and then you get a hash of that, then you can have a little Redis key,

01:02:48.000 --> 01:02:53.000
and if that Redis key is set, the email has been sent and you can discard the task.

01:02:53.000 --> 01:02:57.000
You just put that right next to where you've actually sent the email.

01:02:57.000 --> 01:03:01.000
The chance that it's going to crash in between those two is pretty low.

01:03:01.000 --> 01:03:02.000
It's extremely low. Yeah, exactly.

01:03:02.000 --> 01:03:09.000
So things like this, things like that solution you talked about, while not bank-level bulletproof,

01:03:09.000 --> 01:03:15.000
most of us don't want to suffer through that level of durability, right?

01:03:15.000 --> 01:03:17.000
So very cool project.

01:03:17.000 --> 01:03:18.000
Yeah, I like it.

01:03:18.000 --> 01:03:20.000
Awesome.

01:03:20.000 --> 01:03:23.000
All right, Ken, final call to action.

01:03:23.000 --> 01:03:27.000
People are like, "Oh, my gosh, front-end Python."

01:03:27.000 --> 01:03:29.000
What do they do?

01:03:29.000 --> 01:03:34.000
Well, I don't want to oversell it as solving all your problems, but if you want to check it out,

01:03:34.000 --> 01:03:36.000
PewPi might need spelling out.

01:03:36.000 --> 01:03:42.000
It's P-U-E-P-Y dot dev.

01:03:42.000 --> 01:03:47.000
Excellent. And I love the initiative.

01:03:47.000 --> 01:03:49.000
Happy to shine a light on the project.

01:03:49.000 --> 01:03:50.000
I would like to see it grow.

01:03:50.000 --> 01:03:52.000
Awesome. Thanks for having me on.

01:03:52.000 --> 01:03:54.000
Yeah, thanks for being on the show. Bye.

01:03:54.000 --> 01:03:56.000
Bye.

