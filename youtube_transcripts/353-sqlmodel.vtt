WEBVTT

00:00:00.000 --> 00:00:04.540
- Sebastian, welcome back to Talk Python To Me.


00:00:04.540 --> 00:00:05.380
- Thank you very much.


00:00:05.380 --> 00:00:06.800
Thank you for inviting me.


00:00:06.800 --> 00:00:09.860
- Yeah, it's great to have you back.


00:00:09.860 --> 00:00:13.880
When you were on the show, we were talking about FastAPI


00:00:13.880 --> 00:00:16.640
and it seemed like so much had happened.


00:00:16.640 --> 00:00:18.080
You've done so much and now there's like


00:00:18.080 --> 00:00:19.760
all these other frameworks that you've built


00:00:19.760 --> 00:00:22.760
and all sorts of exciting things, right?


00:00:22.760 --> 00:00:25.240
- Yeah, very, very exciting stuff.


00:00:25.240 --> 00:00:28.440
It's like very exciting because Python is getting so excited.


00:00:28.440 --> 00:00:31.000
- Well, it's very exciting, has always been exciting,


00:00:31.000 --> 00:00:33.040
but there's so many new things


00:00:33.040 --> 00:00:35.640
that it's great to build things with them.


00:00:35.640 --> 00:00:38.760
- It's interesting, I feel like your frameworks


00:00:38.760 --> 00:00:41.820
more than many take advantage of


00:00:41.820 --> 00:00:45.520
and almost depend upon the latest aspects of Python.


00:00:45.520 --> 00:00:47.000
- Yeah, yeah, absolutely.


00:00:47.000 --> 00:00:51.640
Like someone made a meme at some point on Twitter


00:00:51.640 --> 00:00:54.080
about this guy that was like,


00:00:54.080 --> 00:00:56.120
pen pineapple apple pen,


00:00:56.120 --> 00:00:59.980
and it was like type annotations and another library


00:00:59.980 --> 00:01:02.760
and just put them together and that's what I'm building.


00:01:02.760 --> 00:01:04.160
Yeah, it's pretty accurate.


00:01:04.160 --> 00:01:05.520
- Yeah, absolutely.


00:01:05.520 --> 00:01:08.760
You know, there's, as a community,


00:01:08.760 --> 00:01:11.840
we sort of muddled our way through


00:01:11.840 --> 00:01:14.200
the Python two to three transition


00:01:14.200 --> 00:01:17.000
and it took a lot longer than even Guido


00:01:17.000 --> 00:01:20.460
and everyone, many other people expected it to take.


00:01:20.460 --> 00:01:22.920
But now that we're on the other side of it,


00:01:22.920 --> 00:01:24.200
stuff like what you're creating


00:01:24.200 --> 00:01:26.460
and other people are creating,


00:01:26.460 --> 00:01:29.200
that's what would have been possible


00:01:29.200 --> 00:01:30.600
had we gone sooner, right?


00:01:30.600 --> 00:01:33.200
But now it's like, no, everyone's putting their effort


00:01:33.200 --> 00:01:36.000
into these new ideas and these new aspects


00:01:36.000 --> 00:01:37.640
that are now possible.


00:01:37.640 --> 00:01:38.980
- Yeah, yeah. - I think it's great.


00:01:38.980 --> 00:01:39.960
- Yeah, absolutely.


00:01:39.960 --> 00:01:44.120
And I feel like the way Python is growing


00:01:44.120 --> 00:01:46.440
and improving is amazing.


00:01:46.440 --> 00:01:48.740
Like, you know, there are some growing pains,


00:01:48.740 --> 00:01:51.080
like as with any project or with anything,


00:01:51.080 --> 00:01:54.240
but like, so like it's been able to grow


00:01:54.240 --> 00:01:56.040
in the directions that are needed


00:01:56.040 --> 00:01:58.680
and to support all the things that users are needing.


00:01:58.680 --> 00:02:01.360
And like, we can do very cool stuff


00:02:01.360 --> 00:02:03.640
that will not even be possible in other languages.


00:02:03.640 --> 00:02:06.120
And it's, I don't know, for me, it's pretty exciting.


00:02:06.120 --> 00:02:07.600
- Yeah.


00:02:07.600 --> 00:02:09.000
Same as for me as well.


00:02:09.000 --> 00:02:10.440
It just gets more exciting.


00:02:10.440 --> 00:02:13.840
I think, you know, you could see it,


00:02:13.840 --> 00:02:15.920
you just keep working the same thing and it just keeps,


00:02:15.920 --> 00:02:17.360
ah, well, I've been doing that for a long time.


00:02:17.360 --> 00:02:19.060
I need to change, but I don't feel that way at all.


00:02:19.060 --> 00:02:22.540
I feel like every day there's something new and amazing


00:02:22.540 --> 00:02:27.260
and still the possibility for more incredible things to come


00:02:27.260 --> 00:02:29.500
is certainly out there, right?


00:02:29.500 --> 00:02:31.260
I don't feel like we've hit the limit


00:02:31.260 --> 00:02:34.160
of what it's possible for framework authors like you


00:02:34.160 --> 00:02:37.340
to build or for the core devs to make Python do.


00:02:37.340 --> 00:02:40.900
You know, there's the whole performance resurgence thing


00:02:40.900 --> 00:02:44.340
that Guido van Rossum and Mark Shannon are doing,


00:02:44.340 --> 00:02:48.020
that Sam Gill did, that Anthony Shaw is doing,


00:02:48.020 --> 00:02:49.620
and others.


00:02:49.620 --> 00:02:50.780
Yeah, I think there's--


00:02:50.780 --> 00:02:51.860
it's good, right?


00:02:51.860 --> 00:02:52.700
- Yeah, it's amazing.


00:02:52.700 --> 00:02:57.500
And I feel like how the energy between the community


00:02:57.500 --> 00:03:01.420
and the core developers and like editors


00:03:01.420 --> 00:03:03.860
and all the tooling, like all growing together


00:03:03.860 --> 00:03:05.500
and all supporting each other,


00:03:05.500 --> 00:03:08.900
like helps each other part to grow more and better.


00:03:08.900 --> 00:03:10.820
And it's so exciting.


00:03:10.820 --> 00:03:11.660
- Yeah, absolutely.


00:03:11.660 --> 00:03:12.500
- You know, to get like, for example,


00:03:12.500 --> 00:03:15.340
like support for very recent things


00:03:15.340 --> 00:03:18.220
and have been able to use them right away in editors.


00:03:18.220 --> 00:03:19.420
It's like, ah, so cool.


00:03:19.420 --> 00:03:22.420
- It is absolutely cool.


00:03:22.420 --> 00:03:26.580
And yeah, the editors are definitely coming along as well.


00:03:26.580 --> 00:03:31.060
Now, before we get into your latest project, SQL Model,


00:03:31.060 --> 00:03:32.700
which is very exciting,


00:03:32.700 --> 00:03:35.940
let's just get a quick update on you.


00:03:35.940 --> 00:03:37.580
You know, you told us the story


00:03:37.580 --> 00:03:39.100
how you got in programming Python before,


00:03:39.100 --> 00:03:40.260
so we're not gonna ask you that again,


00:03:40.260 --> 00:03:41.100
but what have you been up to


00:03:41.100 --> 00:03:43.340
since you were on the show last?


00:03:43.340 --> 00:03:46.540
So when I was on the show last,


00:03:46.540 --> 00:03:48.780
we were talking about FastAPI, right?


00:03:48.780 --> 00:03:49.620
- Yes.


00:03:49.620 --> 00:03:52.180
- And Typer already existed, if I'm not wrong, right?


00:03:52.180 --> 00:03:54.060
- Yeah, I think those were the two things


00:03:54.060 --> 00:03:54.900
you had built in FastAPI.


00:03:54.900 --> 00:03:56.780
- Okay, okay, yeah.


00:03:56.780 --> 00:04:00.360
- Had FastAPI made it to the top three web frameworks yet?


00:04:00.360 --> 00:04:03.180
I'm not sure if it had, but it was right around that time.


00:04:03.180 --> 00:04:04.020
Yeah, that's incredible.


00:04:04.020 --> 00:04:05.820
- I think it was very close to that point.


00:04:05.820 --> 00:04:09.380
That was mind-blowing that people were being able


00:04:09.380 --> 00:04:11.780
to use it so much and adopt it so much,


00:04:11.780 --> 00:04:15.060
and when it came out in the surveys like that,


00:04:15.060 --> 00:04:16.700
it was super cool.


00:04:16.700 --> 00:04:18.600
- Yeah. - Yeah, super exciting.


00:04:18.600 --> 00:04:24.360
And yeah, I don't know, I have been trying to focus,


00:04:24.360 --> 00:04:26.220
I have always been trying to focus


00:04:26.220 --> 00:04:29.660
on whatever is the next thing that I can work on


00:04:29.660 --> 00:04:33.580
that will have the biggest impact, that can help the most.


00:04:33.580 --> 00:04:37.460
And I end up just changing areas


00:04:37.460 --> 00:04:39.980
and trying to improve different areas and different things.


00:04:39.980 --> 00:04:44.700
And recently that I was working with SQL databases,


00:04:44.700 --> 00:04:48.060
well, recently, I don't know, some months ago,


00:04:48.060 --> 00:04:49.460
that I was working with SQL databases


00:04:49.460 --> 00:04:51.540
and I was working some of the existing libraries


00:04:51.540 --> 00:04:54.460
and I wanted to have like all the benefits


00:04:54.460 --> 00:04:56.140
of the new features of Python.


00:04:56.140 --> 00:05:01.580
But I wasn't able to have like as much things as I could


00:05:01.580 --> 00:05:04.060
because most of these libraries were built


00:05:04.060 --> 00:05:06.660
before we had all these new features.


00:05:06.660 --> 00:05:08.140
So I wanted to be able to get that


00:05:08.140 --> 00:05:12.220
and I figured that the best way to build it


00:05:12.220 --> 00:05:14.340
was applying the ideas that I had


00:05:14.340 --> 00:05:16.640
and the learnings that I had from the other tools


00:05:16.640 --> 00:05:17.480
and from the other things


00:05:17.480 --> 00:05:19.340
and just like put the thing together


00:05:19.340 --> 00:05:21.460
because there were some libraries


00:05:21.460 --> 00:05:23.260
that were trying to do similar things,


00:05:23.260 --> 00:05:26.020
but like I feel like there was still a bit more


00:05:26.020 --> 00:05:26.860
that could be done.


00:05:26.860 --> 00:05:29.180
So yeah, I was just like trying to get that


00:05:29.180 --> 00:05:32.180
and that's how it ended up starting.


00:05:32.180 --> 00:05:34.020
- Yeah, fantastic.


00:05:34.020 --> 00:05:37.900
Now I feel like SQL model,


00:05:37.900 --> 00:05:39.460
I don't know for sure, I'm asking you,


00:05:39.460 --> 00:05:42.580
but it seems to me looking in from the outside


00:05:42.580 --> 00:05:44.740
that SQL model was something like,


00:05:44.740 --> 00:05:48.700
I need a good ORM for FastAPI.


00:05:48.700 --> 00:05:52.820
And the things out there didn't click for you


00:05:52.820 --> 00:05:53.660
in the way that you wanted it to.


00:05:53.660 --> 00:05:54.780
So you're like, I'm gonna build something


00:05:54.780 --> 00:05:57.860
that fits with this, right?


00:05:57.860 --> 00:06:01.460
- Yeah, so it's like, the good thing with FastAPI


00:06:01.460 --> 00:06:06.460
is that it doesn't have any need for a tightly coupling it


00:06:06.860 --> 00:06:09.060
with any ORM, with any database,


00:06:09.060 --> 00:06:10.740
or it can be used with anything.


00:06:10.740 --> 00:06:15.700
But still, there are some things that might not be


00:06:15.700 --> 00:06:20.100
as convenient in the ORM itself, like if you use it alone.


00:06:20.100 --> 00:06:20.940
And for example, with FastAPI,


00:06:20.940 --> 00:06:23.940
that you use it to declare all the data models,


00:06:23.940 --> 00:06:26.660
all the shapes of the data that you want to receive


00:06:26.660 --> 00:06:27.980
and that you want to send back,


00:06:27.980 --> 00:06:29.820
and to do like all the data validation,


00:06:29.820 --> 00:06:31.620
documentation serialization.


00:06:31.620 --> 00:06:35.500
Then you declare a bunch of those data models with Bidantic.


00:06:35.500 --> 00:06:37.580
but at the same time, you will end up declaring,


00:06:37.580 --> 00:06:40.960
duplicating a lot of that information in a separate ORM,


00:06:40.960 --> 00:06:43.260
just to connect to the database


00:06:43.260 --> 00:06:46.300
and to handle the database stuff with Python objects.


00:06:46.300 --> 00:06:48.380
But then you have to duplicate the information


00:06:48.380 --> 00:06:49.620
in two different ways.


00:06:49.620 --> 00:06:52.280
And that's what was like,


00:06:52.280 --> 00:06:55.240
it was not the best developer experience, I guess.


00:06:55.240 --> 00:06:59.340
And I was trying to make it a bit more user-friendly,


00:06:59.340 --> 00:07:02.780
a bit more developer-friendly, I guess would be the word,


00:07:02.780 --> 00:07:05.780
to work with databases and data models


00:07:05.780 --> 00:07:08.400
and avoid all that duplication information.


00:07:08.400 --> 00:07:11.080
And at the same time, make it as easy as possible


00:07:11.080 --> 00:07:13.380
to write the code just using the same standard type


00:07:13.380 --> 00:07:16.580
annotations and just using the same intuitive things


00:07:16.580 --> 00:07:17.820
that we can already use.


00:07:17.820 --> 00:07:21.780
And that's the point that I was trying to hit.


00:07:21.780 --> 00:07:25.740
- For people to see how that clicks together,


00:07:25.740 --> 00:07:30.220
I know 12% of the community who builds web APIs


00:07:30.220 --> 00:07:31.860
and frameworks is using FastAPI,


00:07:31.860 --> 00:07:34.900
but there's a decent person out there


00:07:34.900 --> 00:07:38.540
who maybe haven't heard or looked into FastAPI.


00:07:38.540 --> 00:07:41.260
Maybe they've heard about it, but they don't know the pieces.


00:07:41.260 --> 00:07:44.020
Maybe given that that's some of the motivation,


00:07:44.020 --> 00:07:49.020
maybe give us a sense of how do you build data models


00:07:49.020 --> 00:07:52.580
that match your APIs and how do you do things


00:07:52.580 --> 00:07:56.660
like generate the open, the swagger documentation


00:07:56.660 --> 00:07:58.340
and stuff like that?


00:07:58.340 --> 00:08:02.420
set the stage for why just straight SQLAlchemy


00:08:02.420 --> 00:08:06.860
or some other standard, you know, pony ORM


00:08:06.860 --> 00:08:09.460
or something like that didn't just directly map over


00:08:09.460 --> 00:08:11.380
to how FastAPI works.


00:08:11.380 --> 00:08:12.200
- Awesome.


00:08:12.200 --> 00:08:15.700
So like just a very quick intro to FastAPI,


00:08:15.700 --> 00:08:16.860
it's a web framework,


00:08:16.860 --> 00:08:19.980
but it's focused a lot on building web APIs.


00:08:19.980 --> 00:08:22.980
And the main idea is that using the standard type


00:08:22.980 --> 00:08:24.500
annotations or type hints.


00:08:24.500 --> 00:08:26.140
So the way that you in a function,


00:08:26.140 --> 00:08:29.240
you declare what is the type of some particular variable.


00:08:29.240 --> 00:08:31.400
Using that same information,


00:08:31.400 --> 00:08:33.640
that same information by default will give you


00:08:33.640 --> 00:08:35.980
some certainty that the code is correct


00:08:35.980 --> 00:08:37.400
and will give you the completion


00:08:37.400 --> 00:08:39.600
and inline errors in the editor.


00:08:39.600 --> 00:08:43.320
FastAPI uses that same information to do data validation


00:08:43.320 --> 00:08:45.760
of the data that you receive in the web API


00:08:45.760 --> 00:08:48.120
and to do data serialization of the data


00:08:48.120 --> 00:08:50.120
that you are returning back


00:08:50.120 --> 00:08:52.160
and to do automatic documentation.


00:08:52.160 --> 00:08:54.160
This is all based on a bunch of standards,


00:08:54.160 --> 00:08:56.880
OpenAPI, JSON schema, and a bunch of other things.


00:08:56.880 --> 00:08:59.540
And because it's based on these open standards,


00:08:59.540 --> 00:09:02.800
then it can generate and it can also provide a Swagger UI,


00:09:02.800 --> 00:09:06.460
as you were saying, which is this web user interface


00:09:06.460 --> 00:09:09.360
that shows all the information of the API,


00:09:09.360 --> 00:09:12.320
all the end points, what are the data shapes


00:09:12.320 --> 00:09:14.760
that you can send, and you can actually interact


00:09:14.760 --> 00:09:19.020
with the API directly from the browser


00:09:19.020 --> 00:09:23.560
without having to go to some documentation site


00:09:23.560 --> 00:09:26.100
and then update and the wiki gets updated


00:09:26.100 --> 00:09:27.100
and things like that.


00:09:27.100 --> 00:09:28.200
- Yeah, absolutely.


00:09:28.200 --> 00:09:32.800
I built a weather service API for one of my courses.


00:09:32.800 --> 00:09:34.120
This has limited data.


00:09:34.120 --> 00:09:36.920
People don't try to use this for actual weather service.


00:09:36.920 --> 00:09:39.600
But it's a FastAPI,


00:09:39.600 --> 00:09:42.000
and in addition to all the other cool things it does,


00:09:42.000 --> 00:09:44.600
like quickly generates the stuff it needs to,


00:09:44.600 --> 00:09:46.200
you can just go to slash docs


00:09:46.200 --> 00:09:49.140
and it'll give you the schemas,


00:09:49.140 --> 00:09:52.860
it'll give you the API endpoints,


00:09:52.860 --> 00:09:56.700
the values that go in, the return value, all of this.


00:09:56.700 --> 00:09:58.880
I guess the most important aspect of this


00:09:58.880 --> 00:10:00.940
is probably Pydantic, correct?


00:10:00.940 --> 00:10:01.780
- Yes, absolutely.


00:10:01.780 --> 00:10:02.940
- Like the most important part.


00:10:02.940 --> 00:10:04.380
You define your stuff in Pydantic models


00:10:04.380 --> 00:10:07.100
and then that drives so many of these things.


00:10:07.100 --> 00:10:09.780
- Yeah, so FastAPI is built on top of two tools.


00:10:09.780 --> 00:10:11.620
Pydantic does all the data stuff,


00:10:11.620 --> 00:10:13.820
data validation, serialization, documentation,


00:10:13.820 --> 00:10:15.860
and Stableit does all the web stuff.


00:10:15.860 --> 00:10:17.860
And FastAPI just puts them together


00:10:17.860 --> 00:10:19.140
in a way that they work together


00:10:19.140 --> 00:10:21.480
and adds some extra things on top.


00:10:21.480 --> 00:10:23.040
But Pydantic is the thing that powers


00:10:23.040 --> 00:10:24.200
all these data validation


00:10:24.200 --> 00:10:26.160
and all these automatic documentation.


00:10:26.160 --> 00:10:31.720
Pydantic is also based on the same type annotations,


00:10:31.720 --> 00:10:33.160
the standard Python type annotations.


00:10:33.160 --> 00:10:35.040
So you can just like use the same intuition


00:10:35.040 --> 00:10:37.560
that you will have for a standard Python


00:10:37.560 --> 00:10:41.800
and then get all these data processing with Pydantic.


00:10:41.800 --> 00:10:42.840
- Yeah.


00:10:42.840 --> 00:10:47.840
And FastAPI does several things with the Pydantic models.


00:10:47.840 --> 00:10:51.400
It does model binding.


00:10:51.400 --> 00:10:53.960
I guess I'll call it, that term's not super common


00:10:53.960 --> 00:10:57.140
in the Python world, but you can just say,


00:10:57.140 --> 00:11:01.500
my API function or web function takes this model


00:11:01.500 --> 00:11:05.280
and then fastAPI will create the Pydantic model


00:11:05.280 --> 00:11:06.840
and set the values and do the validation.


00:11:06.840 --> 00:11:09.320
And then also the return value,


00:11:09.320 --> 00:11:12.360
you can say will drive this documentation and so on.


00:11:12.360 --> 00:11:13.920
So the reason I wanted to set the stage


00:11:13.920 --> 00:11:17.680
so much around Pydantic is that's one of the core elements


00:11:17.680 --> 00:11:19.120
of SQL model, right?


00:11:19.120 --> 00:11:21.240
And not just using that library,


00:11:21.240 --> 00:11:26.240
but so that it can be used as the models in FastAPI, right?


00:11:26.240 --> 00:11:28.680
- Yes, exactly.


00:11:28.680 --> 00:11:30.480
So SQL model is a library,


00:11:30.480 --> 00:11:32.760
what they usually call an ORM.


00:11:32.760 --> 00:11:34.520
And if you don't know what an ORM is,


00:11:34.520 --> 00:11:38.180
it's just a library to connect a SQL database


00:11:38.180 --> 00:11:40.840
with Python objects and classes.


00:11:40.840 --> 00:11:42.520
I don't know why we use the term ORM.


00:11:42.520 --> 00:11:44.720
I feel it's a bit abstract.


00:11:44.720 --> 00:11:47.120
But it's just a library to connect SQL databases


00:11:47.120 --> 00:11:49.520
with Python objects and classes.


00:11:49.520 --> 00:11:54.420
And the thing with SQL model is that it does a lot of work


00:11:54.420 --> 00:11:57.180
inside so that each model that you create


00:11:57.180 --> 00:12:00.060
is already a Pydantic model.


00:12:00.060 --> 00:12:02.540
It's not that it internally uses a Pydantic model


00:12:02.540 --> 00:12:05.260
or internally creates some additional Pydantic model,


00:12:05.260 --> 00:12:09.600
is that each model is itself a Pydantic model.


00:12:09.600 --> 00:12:10.940
- Yeah.


00:12:10.940 --> 00:12:12.340
- And at the same time,


00:12:12.340 --> 00:12:14.960
so SQL models is built on top of Pydantic


00:12:14.960 --> 00:12:18.020
for again, data processing, validation, all this stuff.


00:12:18.020 --> 00:12:20.220
and another library that does all the work


00:12:20.220 --> 00:12:21.920
to communicate with SQL databases,


00:12:21.920 --> 00:12:23.320
which is called SQLAlchemy.


00:12:23.320 --> 00:12:25.720
And each one of these models


00:12:25.720 --> 00:12:28.640
is both Pydantic and SQLAlchemy.


00:12:28.640 --> 00:12:31.600
- Yeah, it's an interesting marriage


00:12:31.600 --> 00:12:35.080
between Pydantic and SQLAlchemy.


00:12:35.080 --> 00:12:38.360
Much of the way that you work with it


00:12:38.360 --> 00:12:39.800
would be very familiar to people


00:12:39.800 --> 00:12:42.300
who do SQLAlchemy today, right?


00:12:42.300 --> 00:12:44.480
- Yes, that's the idea,


00:12:44.480 --> 00:12:46.240
that it will be very familiar for people


00:12:46.240 --> 00:12:48.160
that is already working with by that tick


00:12:48.160 --> 00:12:49.840
probably because they are using FastAPI.


00:12:49.840 --> 00:12:51.560
But at the same time, you will be very familiar


00:12:51.560 --> 00:12:53.520
for people working with SQL model


00:12:53.520 --> 00:12:57.980
because it's just the same look and feel.


00:12:57.980 --> 00:13:02.160
Yeah, and it's indeed a strange marriage


00:13:02.160 --> 00:13:04.680
because these two libraries are so different


00:13:04.680 --> 00:13:07.400
that getting them to connect and work together


00:13:07.400 --> 00:13:10.080
in the very different ways they are built,


00:13:10.080 --> 00:13:12.440
it was very, very strange.


00:13:12.440 --> 00:13:14.800
But they actually ended up like working quite well.


00:13:14.800 --> 00:13:18.080
- Yeah, I imagine that it was pretty tricky.


00:13:18.080 --> 00:13:22.680
Anytime that you get in the middle of an ORM and its model,


00:13:22.680 --> 00:13:25.800
I've tried to do that with other frameworks and said,


00:13:25.800 --> 00:13:27.760
oh, it would be great if I could say,


00:13:27.760 --> 00:13:30.800
use inheritance in this way on my model


00:13:30.800 --> 00:13:32.260
so that there's not duplication.


00:13:32.260 --> 00:13:34.680
Like, oh no, no, no, you can't do that


00:13:34.680 --> 00:13:39.280
because the thing really depends upon the exact class


00:13:39.280 --> 00:13:42.720
that derives from it's sort of like ORM base class.


00:13:42.720 --> 00:13:46.400
that's what it uses for its determining


00:13:46.400 --> 00:13:49.520
what columns are there and so on, right?


00:13:49.520 --> 00:13:51.600
- Yeah, it was so crazy.


00:13:51.600 --> 00:13:53.720
I spent so much time in the movie


00:13:53.720 --> 00:13:56.640
and trying to figure out what was happening underneath


00:13:56.640 --> 00:14:00.960
and studying so much about like the black magic in Python,


00:14:00.960 --> 00:14:02.680
the stuff that I always feared,


00:14:02.680 --> 00:14:04.600
like all the meta classes and stuff


00:14:04.600 --> 00:14:06.360
and all that weird stuff.


00:14:06.360 --> 00:14:08.040
I studied so much of that to be able


00:14:08.040 --> 00:14:10.200
to mix these things together.


00:14:10.200 --> 00:14:11.880
But yeah, like, because they do things


00:14:11.880 --> 00:14:13.440
in a very different way.


00:14:13.440 --> 00:14:16.160
At the same time, that's facilitated,


00:14:16.160 --> 00:14:20.460
allowing one thing to do its job


00:14:20.460 --> 00:14:23.000
and the other thing to do its own job


00:14:23.000 --> 00:14:25.000
in their own particular ways.


00:14:25.000 --> 00:14:28.600
So yeah, it was fun.


00:14:28.600 --> 00:14:30.040
- Yeah, very cool.


00:14:30.040 --> 00:14:31.560
Whenever I think about an ORM,


00:14:31.560 --> 00:14:36.560
the thing that I first go to focus on is the Python classes.


00:14:36.560 --> 00:14:41.000
Because for me, the whole point of the ORM


00:14:41.000 --> 00:14:44.600
is to let me talk to my database through those classes


00:14:44.600 --> 00:14:47.460
and model my application through those classes, right?


00:14:47.460 --> 00:14:50.480
So let's maybe get started by talking about


00:14:50.480 --> 00:14:55.480
how do I create a class, a model, a SQL model model


00:14:55.480 --> 00:15:00.500
here that is both a Pydantic model


00:15:00.500 --> 00:15:03.800
and a SQLAlchemy-like model.


00:15:03.800 --> 00:15:06.040
I'm gonna talk us through what does it look like?


00:15:06.040 --> 00:15:06.860
- Cool.


00:15:06.860 --> 00:15:08.760
So from SQL model,


00:15:08.760 --> 00:15:11.920
you will import this class SQL model.


00:15:11.920 --> 00:15:15.560
And SQL model, you inherit from this class.


00:15:15.560 --> 00:15:18.560
You can, for example, create a class hero.


00:15:18.560 --> 00:15:22.840
And then let's jump to the internal parts of that.


00:15:22.840 --> 00:15:26.080
Then you will define some attributes for this class hero.


00:15:26.080 --> 00:15:28.560
For example, you could say that it has an ID


00:15:28.560 --> 00:15:30.320
and that this ID will be an integer.


00:15:30.320 --> 00:15:31.720
The way you declare that is


00:15:31.720 --> 00:15:34.040
with standard Python type annotations.


00:15:34.040 --> 00:15:37.200
You could say that it has a name and it's a string.


00:15:37.200 --> 00:15:38.960
- If you are familiar with Pydantic,


00:15:38.960 --> 00:15:42.440
it basically could exactly be a Pydantic model.


00:15:42.440 --> 00:15:43.280
- Yeah, yeah.


00:15:43.280 --> 00:15:46.680
- In the simple case, right?


00:15:46.680 --> 00:15:47.520
In the...


00:15:47.520 --> 00:15:48.360
- Yeah, yeah, exactly.


00:15:48.360 --> 00:15:49.180
In the...


00:15:49.180 --> 00:15:51.720
- It really is just an integer and it just has a number.


00:15:51.720 --> 00:15:53.400
You don't have to make it auto increment


00:15:53.400 --> 00:15:55.200
or any weird stuff like that, right?


00:15:55.200 --> 00:15:56.040
- Exactly.


00:15:56.040 --> 00:15:56.880
In the simplest cases,


00:15:56.880 --> 00:16:00.800
it will look just exactly like a Pydantic model.


00:16:00.800 --> 00:16:05.320
And in fact, it will be a Pydantic model.


00:16:05.320 --> 00:16:07.960
And then for some particular cases


00:16:07.960 --> 00:16:10.760
where you need to add a little bit of extra information


00:16:10.760 --> 00:16:13.840
to tell SQL model and SQLAlchemy underneath


00:16:13.840 --> 00:16:16.560
to tell it, hey, this does this thing with the database,


00:16:16.560 --> 00:16:18.360
then you can pass additional parameters


00:16:18.360 --> 00:16:20.080
and additional configurations.


00:16:20.080 --> 00:16:24.400
So for example, when you create the ID of this class,


00:16:24.400 --> 00:16:26.040
this will be the ID of the table


00:16:26.040 --> 00:16:28.200
and it has to be a primary key.


00:16:28.200 --> 00:16:31.120
So then you can use the function field to say,


00:16:31.120 --> 00:16:34.700
hey, this is still has a default value of none,


00:16:34.700 --> 00:16:37.240
but I need this particular field


00:16:37.240 --> 00:16:40.040
or this particular attribute or this particular column,


00:16:40.040 --> 00:16:40.980
however you wanna call it.


00:16:40.980 --> 00:16:43.540
I need this to be the primary key.


00:16:43.540 --> 00:16:45.560
And then that information is passed through


00:16:45.560 --> 00:16:48.160
to SQLAlchemy underneath,


00:16:48.160 --> 00:16:50.360
which is the one that does all the work.


00:16:50.360 --> 00:16:52.600
And there's something particularly interesting here


00:16:52.600 --> 00:16:53.720
is that you are saying,


00:16:53.720 --> 00:16:56.560
hey, this has a default value of none


00:16:56.560 --> 00:17:01.560
and that none default value will be used by Pydantic


00:17:01.560 --> 00:17:03.720
in the Pydantic side of things.


00:17:03.720 --> 00:17:05.520
but at the same time it will be used


00:17:05.520 --> 00:17:07.600
in the SQL side of things.


00:17:07.600 --> 00:17:10.840
So in the database, this will have also


00:17:10.840 --> 00:17:12.680
a particular default value.


00:17:12.680 --> 00:17:14.240
In the case of the primary key,


00:17:14.240 --> 00:17:16.040
it's just because when you create a model


00:17:16.040 --> 00:17:19.040
you still don't know what the primary key is.


00:17:19.040 --> 00:17:21.920
- Most of the time the database generates that.


00:17:21.920 --> 00:17:26.340
You could say your primary key could be your email address,


00:17:26.340 --> 00:17:28.920
but it's common to have it just auto-generated


00:17:28.920 --> 00:17:32.520
by the database, a UUID or auto-increment integer


00:17:32.520 --> 00:17:33.720
or something like that.


00:17:33.720 --> 00:17:34.560
- Exactly.


00:17:34.560 --> 00:17:37.440
So for those cases, you want to have the type annotations


00:17:37.440 --> 00:17:41.480
very precise so that your code can tell you,


00:17:41.480 --> 00:17:43.840
hey, this could be known at some point.


00:17:43.840 --> 00:17:45.520
That's just a particular detail.


00:17:45.520 --> 00:17:47.560
But the thing is, important thing is


00:17:47.560 --> 00:17:49.560
that you use standard type annotations


00:17:49.560 --> 00:17:51.040
to declare attributes.


00:17:51.040 --> 00:17:55.680
And then these will be mapped to the data model in Pydantic,


00:17:55.680 --> 00:17:58.000
but at the same time will be mapped to the table


00:17:58.000 --> 00:17:59.780
in the SQL database.


00:18:01.200 --> 00:18:04.680
- Nice, so it kind of behaves in the two ways.


00:18:04.680 --> 00:18:08.940
And that means that what you put into your database


00:18:08.940 --> 00:18:12.940
is pretty much what your API model is as well, right?


00:18:12.940 --> 00:18:14.660
- Exactly, exactly.


00:18:14.660 --> 00:18:16.660
That's the idea.


00:18:16.660 --> 00:18:20.120
Like in the most basic situation,


00:18:20.120 --> 00:18:24.500
the cool thing is that with this approach


00:18:24.500 --> 00:18:29.500
and with this tool, you can then create additional models


00:18:29.540 --> 00:18:33.980
that don't map to one particular table in the database,


00:18:33.980 --> 00:18:38.660
but are just for handling data in the API.


00:18:38.660 --> 00:18:41.260
For example, if you have an API


00:18:41.260 --> 00:18:43.700
that receives data to create a user,


00:18:43.700 --> 00:18:46.740
it will probably receive a password from the user.


00:18:46.740 --> 00:18:48.780
You will have the username and the password.


00:18:48.780 --> 00:18:50.980
And you want to be able to have that information


00:18:50.980 --> 00:18:53.580
in the model that you want to receive in the API,


00:18:53.580 --> 00:18:56.140
but you don't want to save the password


00:18:56.140 --> 00:18:58.420
as plain text in the database.


00:18:58.420 --> 00:19:00.220
- You don't, isn't that the easiest way?


00:19:00.220 --> 00:19:02.980
I get these warnings from these various sites,


00:19:02.980 --> 00:19:04.700
like, oh, your password can't be more


00:19:04.700 --> 00:19:07.180
than eight characters long, because,


00:19:07.180 --> 00:19:09.060
no, yeah, please don't save it in the database.


00:19:09.060 --> 00:19:10.660
That's a really interesting scenario, right?


00:19:10.660 --> 00:19:12.700
You need to receive it on one end,


00:19:12.700 --> 00:19:15.420
but you must not put it into the database.


00:19:15.420 --> 00:19:16.260
- Exactly.


00:19:16.260 --> 00:19:17.900
- You must not carry on.


00:19:17.900 --> 00:19:21.820
- And for example, and then, in that same situation,


00:19:21.820 --> 00:19:24.260
you create the user and you want to return the information


00:19:24.260 --> 00:19:27.100
of the user back to whatever is the client.


00:19:27.100 --> 00:19:29.420
you don't want to return the plain text password.


00:19:29.420 --> 00:19:31.200
You want to say, "Hey, this is the username,"


00:19:31.200 --> 00:19:32.900
but like, that's it.


00:19:32.900 --> 00:19:34.060
- Yeah, probably not.


00:19:34.060 --> 00:19:36.140
It's very unlikely that you want to return the hash as well.


00:19:36.140 --> 00:19:38.100
You just, you don't want it to return at all, right?


00:19:38.100 --> 00:19:40.460
- Yeah, exactly. - How do you handle that?


00:19:40.460 --> 00:19:42.780
- So for these particular cases


00:19:42.780 --> 00:19:44.740
is where SQL model will shine


00:19:44.740 --> 00:19:47.580
because you can create one base model


00:19:47.580 --> 00:19:49.340
that will have like all the base attributes.


00:19:49.340 --> 00:19:51.900
For example, it could have the name, the last name,


00:19:51.900 --> 00:19:54.860
the address, the email, blah, blah, blah.


00:19:54.860 --> 00:19:57.720
And then you can inherit from that model


00:19:57.720 --> 00:20:01.160
and then have different models for the particular use cases.


00:20:01.160 --> 00:20:02.580
For example, for creating data,


00:20:02.580 --> 00:20:04.580
so you will have a plain text password


00:20:04.580 --> 00:20:06.660
and for a returning data,


00:20:06.660 --> 00:20:08.500
you will have no password at all.


00:20:08.500 --> 00:20:10.740
But then one of these models will be the actual model


00:20:10.740 --> 00:20:12.300
that's facing the database.


00:20:12.300 --> 00:20:14.220
The one that reflects the information in the database.


00:20:14.220 --> 00:20:17.600
And this one is the one that will have the hashed password.


00:20:17.600 --> 00:20:20.860
But you didn't have to duplicate all the information


00:20:20.860 --> 00:20:22.420
for the model because they all inherit


00:20:22.420 --> 00:20:24.340
from the same base model.


00:20:24.340 --> 00:20:26.760
- Is that the section that I got on the screen here


00:20:26.760 --> 00:20:29.380
that says multiple models with FastAPI?


00:20:29.380 --> 00:20:30.420
Like how you do that?


00:20:30.420 --> 00:20:32.120
Okay. - Yes, exactly.


00:20:32.120 --> 00:20:34.180
- Yeah, so the idea is obviously


00:20:34.180 --> 00:20:36.540
you have got some shared information about the user,


00:20:36.540 --> 00:20:39.300
like the email and their name and stuff.


00:20:39.300 --> 00:20:41.220
You wanna share that, probably their ID,


00:20:41.220 --> 00:20:44.020
but you don't wanna share, say, their,


00:20:44.020 --> 00:20:46.300
like you said, the password


00:20:46.300 --> 00:20:49.220
or whether or not they're an admin on the site


00:20:49.220 --> 00:20:51.900
or those kinds of things you probably don't want to exchange


00:20:51.900 --> 00:20:53.860
over the API, right?


00:20:53.860 --> 00:20:58.860
- Exactly, and if you need to duplicate all the information


00:20:58.860 --> 00:21:01.020
for each one of these particular models,


00:21:01.020 --> 00:21:02.880
there's a high chance that at some point,


00:21:02.880 --> 00:21:04.340
whenever you refactoring the code,


00:21:04.340 --> 00:21:08.220
some part will be out of sync.


00:21:08.220 --> 00:21:09.640
And then you will have a bunch of errors


00:21:09.640 --> 00:21:12.300
and a bunch of bugs that are very difficult to detect.


00:21:12.300 --> 00:21:14.500
When you have duplication of code


00:21:14.500 --> 00:21:17.060
and you have to synchronize it by hand,


00:21:17.060 --> 00:21:20.340
it creates a lot of potential bugs


00:21:20.340 --> 00:21:22.100
that are very difficult to detect.


00:21:22.100 --> 00:21:40.100
So in the way you do your models, this is pretty neat. One of the things that you do is you've got your model hierarchy, you've got SQL model, which is the base class of all the things that interact with SQL model.


00:21:40.100 --> 00:21:44.260
And those are typically the classes that you create


00:21:44.260 --> 00:21:47.220
that would be like SQLAlchemy or Django or M models.


00:21:47.220 --> 00:21:49.580
But in your world, you can have inheritance.


00:21:49.580 --> 00:21:51.580
And then somewhere in that hierarchy,


00:21:51.580 --> 00:21:55.020
you set table equals true as you create the class.


00:21:55.020 --> 00:21:58.340
So it's not necessarily that just,


00:21:58.340 --> 00:22:00.820
oh, you derive from this class, so that's a table.


00:22:00.820 --> 00:22:02.300
It gives you more flexibility and go,


00:22:02.300 --> 00:22:04.460
this part is a table, that part is a table.


00:22:04.460 --> 00:22:05.940
Like in the scenario we were talking about,


00:22:05.940 --> 00:22:09.320
you have a base user where there's a name


00:22:09.320 --> 00:22:11.600
and a password, a hash password and stuff.


00:22:11.600 --> 00:22:14.200
No, sorry.


00:22:14.200 --> 00:22:15.160
You wouldn't want to put that,


00:22:15.160 --> 00:22:17.740
but you would put like your shared stuff


00:22:17.740 --> 00:22:18.580
into the base class.


00:22:18.580 --> 00:22:21.420
- Yeah, like name, last name, address, email, I don't know.


00:22:21.420 --> 00:22:22.940
- And then the thing that derives from it,


00:22:22.940 --> 00:22:24.780
user would derive from like user base,


00:22:24.780 --> 00:22:26.340
which would say like, "Typical is true,"


00:22:26.340 --> 00:22:28.600
and it could have its secrets there.


00:22:28.600 --> 00:22:29.740
- Exactly, exactly.


00:22:29.740 --> 00:22:30.580
- Okay.


00:22:30.580 --> 00:22:32.240
- We don't have this private bit.


00:22:32.240 --> 00:22:35.140
- So that makes a lot of sense inbound.


00:22:35.140 --> 00:22:36.740
What about outbound?


00:22:36.740 --> 00:22:39.580
So I've got a FastAPI endpoint,


00:22:39.580 --> 00:22:41.920
it could even be Flask or whatever, right?


00:22:41.920 --> 00:22:43.420
And I've done a query to the database


00:22:43.420 --> 00:22:45.980
and I get the table version that has the secrets.


00:22:45.980 --> 00:22:49.100
I can easily go to FastAPI and say


00:22:49.100 --> 00:22:51.020
the response model is the base thing.


00:22:51.020 --> 00:22:53.100
So the documentation is right.


00:22:53.100 --> 00:22:55.340
But if I go to the object that I got from the database


00:22:55.340 --> 00:22:57.780
and I say as dictionary or to dictionary,


00:22:57.780 --> 00:22:59.540
I forgot exactly what the right term is,


00:22:59.540 --> 00:23:02.100
but the thing that sends it back,


00:23:02.100 --> 00:23:04.780
it's gonna include everything in it, isn't it?


00:23:04.780 --> 00:23:09.460
So this is one of those particular details of FastAPI


00:23:09.460 --> 00:23:12.020
that I think people in many cases miss.


00:23:12.020 --> 00:23:15.020
And is that in FastAPI, you can say,


00:23:15.020 --> 00:23:16.940
hey, this is the response model.


00:23:16.940 --> 00:23:19.660
So this is the model that I want you to use


00:23:19.660 --> 00:23:22.060
for the data that I'm sending back.


00:23:22.060 --> 00:23:26.980
The most obvious result of that


00:23:26.980 --> 00:23:28.540
is that in the automatic documentation,


00:23:28.540 --> 00:23:32.260
you will get the schema of what is the response data.


00:23:32.260 --> 00:23:34.260
And that is like the most obvious and visible.


00:23:34.260 --> 00:23:38.180
But FastAPI will also use that same model


00:23:38.180 --> 00:23:40.300
to filter out the data.


00:23:40.300 --> 00:23:41.300
So if you say,


00:23:41.300 --> 00:23:42.140
- Okay.


00:23:42.140 --> 00:23:47.140
- If you say the response model is a user out, for example,


00:23:47.140 --> 00:23:49.020
and the class user out,


00:23:49.020 --> 00:23:51.700
which is a pedantic class or something like that,


00:23:51.700 --> 00:23:56.580
this class user out doesn't include the hashed password.


00:23:56.580 --> 00:23:59.340
From the function, you can return an object


00:23:59.340 --> 00:24:01.860
that includes the hashed password


00:24:01.860 --> 00:24:04.140
or a dictionary that includes the hashed password,


00:24:04.140 --> 00:24:06.380
but FastAPI will omit that field


00:24:06.380 --> 00:24:09.180
and FastAPI will only return the particular fields


00:24:09.180 --> 00:24:12.220
that were defined in the response model


00:24:12.220 --> 00:24:14.980
that you say that will be returned.


00:24:14.980 --> 00:24:18.940
- Okay, I did not know that that also affected


00:24:18.940 --> 00:24:21.780
the outbound data, not just the documentation.


00:24:21.780 --> 00:24:23.340
That's pretty interesting.


00:24:23.340 --> 00:24:27.380
- Yeah, and in fact, that's, in many cases,


00:24:27.380 --> 00:24:31.580
people ask why does FastAPI use this parameter,


00:24:31.580 --> 00:24:35.060
response model instead of using the return type annotation.


00:24:35.060 --> 00:24:37.100
Because in Python, when you create a function,


00:24:37.100 --> 00:24:40.220
you can define what are the types of the parameters


00:24:40.220 --> 00:24:42.140
that the function receives, and you can also define what is


00:24:42.140 --> 00:24:44.500
the return of that particular function.


00:24:44.500 --> 00:24:49.100
If FastAPI use the return value and say,


00:24:49.100 --> 00:24:51.460
"Hey, the return value is this user out," but then


00:24:51.460 --> 00:24:53.780
the object that you were returning from


00:24:53.780 --> 00:24:57.220
that particular function was a different object,


00:24:57.220 --> 00:24:59.180
then the editor will complain,


00:24:59.180 --> 00:25:02.820
the tooling and the tools that detect those typing errors,


00:25:02.820 --> 00:25:04.780
like mypy, will complain and they will detect,


00:25:04.780 --> 00:25:06.660
"Hey, you're saying that you're returning something,


00:25:06.660 --> 00:25:09.460
but you're returning a completely different thing."


00:25:09.460 --> 00:25:13.420
So that's the reason why the return type is not what is used


00:25:13.420 --> 00:25:15.100
to extract that information.


00:25:15.100 --> 00:25:19.100
And instead it uses this particular configuration response model


00:25:19.100 --> 00:25:21.100
because it's used for filtering data.


00:25:21.100 --> 00:25:22.380
Right, okay, interesting.


00:25:22.380 --> 00:25:25.700
So for people who don't know, haven't seen this in action,


00:25:25.700 --> 00:25:30.700
you put a decorator like an app.orapi.get, for example,


00:25:30.700 --> 00:25:32.700
just like you would say in Flask or something,


00:25:32.700 --> 00:25:33.780
and you say, here's the URL,


00:25:33.780 --> 00:25:36.740
but then you also may put response model


00:25:36.740 --> 00:25:39.540
equals some Pydantic type in fastAPI,


00:25:39.540 --> 00:25:41.620
and that drives the Swagger documentation.


00:25:41.620 --> 00:25:44.100
And I am learning now, drives the filtering


00:25:44.100 --> 00:25:46.460
of the allowed return values as well,


00:25:46.460 --> 00:25:47.860
which is pretty excellent.


00:25:47.860 --> 00:25:50.820
- Yeah, in fact, it will also validate the data.


00:25:50.820 --> 00:25:54.260
So if you're saying, hey, this will return this data,


00:25:54.260 --> 00:25:57.060
and then whatever you're returning doesn't include that,


00:25:57.060 --> 00:26:00.760
that will actually be an error on the server


00:26:00.760 --> 00:26:03.160
because you are saying that the contract


00:26:03.160 --> 00:26:04.520
is that I will return this data,


00:26:04.520 --> 00:26:07.040
but then suddenly you are not returning it.


00:26:07.040 --> 00:26:09.560
Then it will raise an error inside of the server


00:26:09.560 --> 00:26:10.380
and it will tell you,


00:26:10.380 --> 00:26:12.040
"Hey, the data that you're sending is incorrect.


00:26:12.040 --> 00:26:13.760
So there's something going on here.


00:26:13.760 --> 00:26:15.200
There's something wrong with your code


00:26:15.200 --> 00:26:17.600
because you're sending something invalid


00:26:17.600 --> 00:26:19.920
from what you say that you are going to send."


00:26:19.920 --> 00:26:21.040
- That's pretty fantastic.


00:26:21.040 --> 00:26:23.120
Okay, I didn't realize it made such great,


00:26:23.120 --> 00:26:25.120
and I think that's a really important point.


00:26:25.120 --> 00:26:27.120
And I think that's a really important point.


00:26:27.120 --> 00:26:29.120
And I think that's a really important point.


00:26:29.120 --> 00:26:31.120
And I think that's a really important point.


00:26:31.120 --> 00:26:33.120
And I think that's a really important point.


00:26:33.120 --> 00:26:35.120
And I think that's a really important point.


00:26:35.120 --> 00:26:37.120
And I think that's a really important point.


00:26:37.120 --> 00:26:39.120
And I think that's a really important point.


00:26:39.120 --> 00:26:41.120
And I think that's a really important point.


00:26:41.120 --> 00:26:43.120
And I think that's a really important point.


00:26:43.120 --> 00:26:45.120
And I think that's a really important point.


00:26:45.120 --> 00:26:47.120
And I think that's a really important point.


00:26:47.120 --> 00:26:49.120
And I think that's a really important point.


00:26:49.120 --> 00:26:51.120
And I think that's a really important point.


00:26:51.120 --> 00:26:56.120
on FastAPI, I think FastAPI is absolutely a great thing.


00:26:56.120 --> 00:26:57.560
- And Sandy.


00:26:57.560 --> 00:26:59.840
- Yeah, also very much.


00:26:59.840 --> 00:27:06.800
Poppin says, I have a question,


00:27:06.800 --> 00:27:09.000
if the data schema is complex


00:27:09.000 --> 00:27:11.240
and has nested JSON structure,


00:27:11.240 --> 00:27:12.960
in what case would you validate?


00:27:12.960 --> 00:27:17.960
It's pretty straightforward to just nest the Pydantic,


00:27:17.960 --> 00:27:20.720
but this brings us, if you're gonna be in a world


00:27:20.720 --> 00:27:22.960
where you're nesting Pydantic things,


00:27:22.960 --> 00:27:25.360
you may wanna save them to the database.


00:27:25.360 --> 00:27:28.020
What's the story on relationships?


00:27:28.020 --> 00:27:31.440
And this basically, I've received some data


00:27:31.440 --> 00:27:33.080
that is like nested related data.


00:27:33.080 --> 00:27:35.000
What do I do in SQL model?


00:27:35.000 --> 00:27:40.160
- So if you need to receive some complex data structure


00:27:40.160 --> 00:27:41.780
and you need to extract the information,


00:27:41.780 --> 00:27:45.000
you can declare models with Pydantic


00:27:45.000 --> 00:27:48.360
or with SQLAlchemy, sorry, with SQL model


00:27:48.360 --> 00:27:49.960
saying that, hey, this is just a data model


00:27:49.960 --> 00:27:53.400
and then you can manually extract the sub components


00:27:53.400 --> 00:27:55.800
and then just add them to the database independently


00:27:55.800 --> 00:27:57.000
or something like that.


00:27:57.000 --> 00:28:00.080
There wouldn't be a straightforward way to say like,


00:28:00.080 --> 00:28:02.160
hey, I received this giant JSON


00:28:02.160 --> 00:28:05.000
and automatically generate a bunch of different models


00:28:05.000 --> 00:28:08.520
that don't exist yet or something like that.


00:28:08.520 --> 00:28:12.120
Or to automatically infer where to put each information,


00:28:12.120 --> 00:28:14.400
it wouldn't be as straightforward.


00:28:14.400 --> 00:28:19.400
Like it will have a lot of different design possibilities.


00:28:19.480 --> 00:28:22.040
So it will be easy to get it wrong.


00:28:22.040 --> 00:28:24.700
So the way that you will do it is that you define


00:28:24.700 --> 00:28:27.240
the complex data ship that you want to receive.


00:28:27.240 --> 00:28:28.560
And then once you take it,


00:28:28.560 --> 00:28:31.520
you just extract each part of the information


00:28:31.520 --> 00:28:36.520
and each particular object or each particular data point


00:28:36.520 --> 00:28:40.260
that you want to then say to the database.


00:28:40.260 --> 00:28:43.900
Now to return data to the user,


00:28:43.900 --> 00:28:47.120
with SQL model, you can have relationships


00:28:47.120 --> 00:28:50.060
and relationships between different tables


00:28:50.060 --> 00:28:51.960
and have like automatic joins and all that stuff.


00:28:51.960 --> 00:28:54.520
This is all thanks again to SQLAlchemy,


00:28:54.520 --> 00:28:56.440
which is the thing that works underneath.


00:28:56.440 --> 00:28:58.080
- It already models that, yeah.


00:28:58.080 --> 00:28:58.920
- Yeah, exactly.


00:28:58.920 --> 00:29:02.520
But then you can use that information


00:29:02.520 --> 00:29:05.080
and you can just like declare the models.


00:29:05.080 --> 00:29:07.760
And this again works well with this idea


00:29:07.760 --> 00:29:09.600
of having narratives to be able to declare,


00:29:09.600 --> 00:29:11.480
hey, I want to return this model


00:29:11.480 --> 00:29:16.480
and I want it to include this particular relationship model.


00:29:17.000 --> 00:29:19.600
So it will include the information from all our tables


00:29:19.600 --> 00:29:21.080
and it will just extract that information


00:29:21.080 --> 00:29:23.200
and return it to the client.


00:29:23.200 --> 00:29:25.680
- That's really cool.


00:29:25.680 --> 00:29:28.880
What about lazy loading?


00:29:28.880 --> 00:29:30.760
I'll ask this in two aspects.


00:29:30.760 --> 00:29:32.280
If I've got a relationship,


00:29:32.280 --> 00:29:37.280
I can do a join or a subquery load on it in SQLAlchemy


00:29:37.280 --> 00:29:41.080
so that if I know I'm gonna be traversing that relationship,


00:29:41.080 --> 00:29:42.600
I don't end up with a dreaded


00:29:42.600 --> 00:29:44.280
N plus one performance problem


00:29:44.280 --> 00:29:45.640
where I thought I was doing one query


00:29:45.640 --> 00:29:47.940
I'm doing 51 queries if I got a,


00:29:47.940 --> 00:29:49.640
- Yeah.


00:29:49.640 --> 00:29:52.180
- 51 or 50 results back, something like that.


00:29:52.180 --> 00:29:58.760
Is that support flow through SQL model as well, the joins?


00:29:58.760 --> 00:30:01.160
- Yeah, so the thing is that SQL model


00:30:01.160 --> 00:30:03.960
actually just like exposes the same interface


00:30:03.960 --> 00:30:05.320
as SQLAlchemy because it's actually


00:30:05.320 --> 00:30:07.560
just using SQLAlchemy underneath.


00:30:07.560 --> 00:30:09.880
And SQLAlchemy supports everything,


00:30:09.880 --> 00:30:11.840
including like a lazy loading.


00:30:11.840 --> 00:30:13.280
SQLAlchemy actually supports things


00:30:13.280 --> 00:30:15.760
that are not supported by many other ORMs,


00:30:15.760 --> 00:30:19.920
like I forgot the name,


00:30:19.920 --> 00:30:21.440
having primary keys that are composed


00:30:21.440 --> 00:30:24.080
of different, of several columns.


00:30:24.080 --> 00:30:26.360
- Composite indexes and composite keys, yeah.


00:30:26.360 --> 00:30:27.860
- Composite keys, yeah.


00:30:27.860 --> 00:30:32.120
There's a bunch of things that SQLAlchemy supports,


00:30:32.120 --> 00:30:34.160
and if SQLAlchemy supports them,


00:30:34.160 --> 00:30:37.760
then the SQL model automatically supports them,


00:30:37.760 --> 00:30:40.120
because SQL model is just inheriting directly


00:30:40.120 --> 00:30:42.160
from SQLAlchemy.


00:30:42.160 --> 00:30:43.520
- Yeah, that's really cool.


00:30:43.520 --> 00:30:47.980
Now, the question I was thinking about is,


00:30:47.980 --> 00:30:51.560
if I have a result from the database


00:30:51.560 --> 00:30:54.100
that has relationships, a relationship,


00:30:54.100 --> 00:30:58.260
and I return it from a FastAPI endpoint,


00:30:58.260 --> 00:31:01.560
is that going to go and start iterating the relationship?


00:31:01.560 --> 00:31:06.000
Do I need to be worried about N plus one problems


00:31:06.000 --> 00:31:08.680
by returning these models


00:31:08.680 --> 00:31:12.360
that then are getting serialized in eager ways.


00:31:12.360 --> 00:31:13.200
- Yeah.


00:31:13.200 --> 00:31:15.200
- It's like tracing through all the relationships


00:31:15.200 --> 00:31:17.560
so it can build a whole JSON to pull back out.


00:31:17.560 --> 00:31:20.400
- Yeah, and then return the whole database in a single file.


00:31:20.400 --> 00:31:21.240
- Yes, exactly.


00:31:21.240 --> 00:31:22.440
Wow, that took a while.


00:31:22.440 --> 00:31:24.520
That's so long. - That was so painful.


00:31:24.520 --> 00:31:27.040
Yeah, now by default,


00:31:27.040 --> 00:31:32.040
a FastAPI and SQL model won't include relationships


00:31:32.040 --> 00:31:35.000
in models, won't include them in the data


00:31:35.000 --> 00:31:37.240
that is returned back.


00:31:37.240 --> 00:31:39.480
But if you need to include some of those,


00:31:39.480 --> 00:31:41.720
you can declare again, using inheritance,


00:31:41.720 --> 00:31:44.920
you can declare a different model that defines,


00:31:44.920 --> 00:31:47.360
hey, this relationship, this particular attribute,


00:31:47.360 --> 00:31:48.920
this should be included.


00:31:48.920 --> 00:31:51.760
And that way you can define that particular one


00:31:51.760 --> 00:31:54.200
in the specific endpoints that you want to include


00:31:54.200 --> 00:31:57.640
the information in the resulting value.


00:31:57.640 --> 00:32:01.720
That will work to a force SQL model


00:32:01.720 --> 00:32:05.400
and to force a FastAPI SQL model


00:32:05.400 --> 00:32:09.220
to do all the N plus one queries


00:32:09.220 --> 00:32:12.120
and to just extract information and send it back.


00:32:12.120 --> 00:32:14.880
But if you are returning that data


00:32:14.880 --> 00:32:16.080
including the relationships,


00:32:16.080 --> 00:32:21.080
you will probably want to eagerly load that information,


00:32:21.080 --> 00:32:24.200
which is something that is supported by SQL model


00:32:24.200 --> 00:32:26.240
and via SQL.


00:32:26.240 --> 00:32:28.240
So you will load the information that you need


00:32:28.240 --> 00:32:29.460
including the relationships,


00:32:29.460 --> 00:32:31.760
and then you just return that object directly


00:32:31.760 --> 00:32:32.840
and you define the model,


00:32:32.840 --> 00:32:35.100
hey, I want this to include the relationships.


00:32:35.100 --> 00:32:36.620
So it will just like include the information


00:32:36.620 --> 00:32:37.720
that is already there.


00:32:37.720 --> 00:32:41.740
- I can see that this N plus one issue is


00:32:41.740 --> 00:32:43.940
without the join or eager load


00:32:43.940 --> 00:32:46.620
is happening through a profiler.


00:32:46.620 --> 00:32:51.300
If I was doing this in something like Django or Pyramid,


00:32:51.300 --> 00:32:54.420
I could look into the debug toolbar


00:32:54.420 --> 00:32:57.100
and it'll actually show me the SQLAlchemy statements


00:32:57.100 --> 00:32:57.920
that are running.


00:32:57.920 --> 00:33:00.420
It'll be like, why are there 50 queries on this page?


00:33:00.420 --> 00:33:03.700
That's harder I suspect in FastAPI,


00:33:03.700 --> 00:33:06.140
especially if it's operating in API mode


00:33:06.140 --> 00:33:09.420
where it doesn't have debug toolbars and stuff like that.


00:33:09.420 --> 00:33:12.900
Probably one way you could see it is to say


00:33:12.900 --> 00:33:15.460
echo equals true on the engine.


00:33:15.460 --> 00:33:16.620
- Yeah, exactly, exactly.


00:33:16.620 --> 00:33:21.620
Because FastAPI is not integrated with any database


00:33:21.620 --> 00:33:25.580
and SQL Model just makes it super easy to work with FastAPI


00:33:25.580 --> 00:33:28.460
but SQL Model could be used with any other framework.


00:33:28.460 --> 00:33:29.540
And that was the intention.


00:33:29.540 --> 00:33:31.380
SQL Model doesn't depend on FastAPI,


00:33:31.380 --> 00:33:33.500
FastAPI doesn't depend on SQL Model.


00:33:33.500 --> 00:33:35.140
They just integrate very well.


00:33:35.140 --> 00:33:37.640
But then you could just enable the,


00:33:37.640 --> 00:33:40.100
the little thing with SQLAlchemy


00:33:40.100 --> 00:33:43.540
that will then show all the particular SQL statements


00:33:43.540 --> 00:33:45.040
and show you, hey, this is what is running.


00:33:45.040 --> 00:33:46.340
This is what is happening.


00:33:46.340 --> 00:33:48.100
- Right, yeah.


00:33:48.100 --> 00:33:50.220
So if you're connecting to the database,


00:33:50.220 --> 00:33:53.980
then this is a SQLAlchemy thing,


00:33:53.980 --> 00:33:56.480
but obviously it'll flow through, right?


00:33:56.480 --> 00:33:58.620
You just say, when you create the engine,


00:33:58.620 --> 00:33:59.660
you give it the connection string,


00:33:59.660 --> 00:34:01.540
you can say echo equals true.


00:34:01.540 --> 00:34:04.740
And if you are doing queries that are doing a bunch


00:34:04.740 --> 00:34:08.620
of indirect behind the scene, lazy queries for you,


00:34:08.620 --> 00:34:12.100
your console window, your terminal, whatever,


00:34:12.100 --> 00:34:13.860
is just gonna blow up with query.


00:34:13.860 --> 00:34:17.460
You're like, why is so much SQL screaming by, right?


00:34:17.460 --> 00:34:18.700
- Yeah, exactly.


00:34:18.700 --> 00:34:19.540
- Yeah. - Exactly.


00:34:19.540 --> 00:34:20.660
That's how it'll work.


00:34:20.660 --> 00:34:25.540
- Let's talk about editor support really quick.


00:34:25.540 --> 00:34:28.500
So one of the things that's really nice about Pydantic


00:34:28.500 --> 00:34:32.420
is it requires you to state the types,


00:34:32.420 --> 00:34:34.680
whether those are fundamental types,


00:34:34.680 --> 00:34:38.100
whether those are nullable types like optional of int,


00:34:38.100 --> 00:34:42.580
or they're nested types like a user contains


00:34:42.580 --> 00:34:44.980
an address, identic model.


00:34:44.980 --> 00:34:46.560
All of those scenarios result


00:34:46.560 --> 00:34:49.400
in really good editor support, right?


00:34:49.400 --> 00:34:51.620
- Yeah, yeah, exactly.


00:34:51.620 --> 00:34:53.540
- What's the story for editors in SQL model?


00:34:53.540 --> 00:34:55.180
That's something you specifically call out


00:34:55.180 --> 00:34:57.140
about how that has good support there.


00:34:57.140 --> 00:34:59.740
So if you check the source code for SQL model,


00:34:59.740 --> 00:35:02.500
it's actually super short,


00:35:02.500 --> 00:35:05.580
but it's just like a bunch of a lot of tricks together.


00:35:05.580 --> 00:35:07.380
And many of those tricks are actually


00:35:07.380 --> 00:35:09.500
about type annotations,


00:35:09.500 --> 00:35:12.940
because the thing that allows your editor


00:35:12.940 --> 00:35:15.580
to provide you auto-completion and the inline errors


00:35:15.580 --> 00:35:17.340
are the declarations of these types,


00:35:17.340 --> 00:35:19.540
the type annotations or type hints.


00:35:19.540 --> 00:35:23.640
And SQL model does a lot of internal work


00:35:23.640 --> 00:35:27.040
so that whenever you use any part of SQL model,


00:35:27.040 --> 00:35:30.580
you will get that type information in your editor.


00:35:30.580 --> 00:35:33.360
For example, if you query some model,


00:35:33.360 --> 00:35:37.600
query some table to get data from the database,


00:35:37.600 --> 00:35:40.000
the result that you get back,


00:35:40.000 --> 00:35:41.160
the object that you get back,


00:35:41.160 --> 00:35:44.100
will have internally all that type information.


00:35:44.100 --> 00:35:46.000
So the editor will be able to provide you


00:35:46.000 --> 00:35:48.520
with all the active completion and all the inline errors


00:35:48.520 --> 00:35:50.440
and all those things.


00:35:50.440 --> 00:35:56.320
SQL model, in fact, sacrifices some of the more advanced


00:35:56.920 --> 00:36:00.480
or obscure or sophisticated use cases


00:36:00.480 --> 00:36:02.120
that SQLAlchemy supports,


00:36:02.120 --> 00:36:07.800
and sacrifices those to instead get like very good


00:36:07.800 --> 00:36:10.720
auto-completion and inline errors everywhere in the code.


00:36:10.720 --> 00:36:17.080
And this is another thing that includes in SQL


00:36:17.080 --> 00:36:21.160
is that it uses some draft standards


00:36:21.160 --> 00:36:23.160
that are not even implemented yet,


00:36:23.160 --> 00:36:24.480
that are not even like, I don't know,


00:36:24.480 --> 00:36:28.440
are not part of the standards, official standards yet,


00:36:28.440 --> 00:36:31.420
but they are already supported by some editors.


00:36:31.420 --> 00:36:34.400
For example, Visual Studio Code already supports


00:36:34.400 --> 00:36:36.640
providing auto-completion when you are creating


00:36:36.640 --> 00:36:39.880
a new instance of a particular class,


00:36:39.880 --> 00:36:41.840
for the particular class of a mode.


00:36:41.840 --> 00:36:46.440
Having this auto-completion is not very, very easy to do


00:36:46.440 --> 00:36:49.080
with other tools because the editor doesn't have


00:36:49.080 --> 00:36:52.720
any information about what are the parameters


00:36:52.720 --> 00:36:53.880
that you can pass, what are the arguments


00:36:53.880 --> 00:36:56.120
- Right, when you create a Pydantic model,


00:36:56.120 --> 00:36:59.320
it doesn't in any way indicate,


00:36:59.320 --> 00:37:01.880
here is the constructor or initializer,


00:37:01.880 --> 00:37:03.560
and here are the keyword arguments


00:37:03.560 --> 00:37:05.200
that happen to be all the,


00:37:05.200 --> 00:37:08.520
what look like static values, static fields, yeah.


00:37:08.520 --> 00:37:11.480
- We'll just say like, keyword arguments,


00:37:11.480 --> 00:37:13.880
or like data, star, star, something like that.


00:37:13.880 --> 00:37:15.080
- Yeah.


00:37:15.080 --> 00:37:17.680
I always think, thanks for nothing when I see that.


00:37:17.680 --> 00:37:19.120
- Yeah, exactly.


00:37:19.120 --> 00:37:23.440
Well, actually, Pydantic 1.9 includes this same trick.


00:37:23.440 --> 00:37:26.960
So now you get auto completion in Visual Studio Code.


00:37:26.960 --> 00:37:29.720
In PyCharm, you already have the auto completion


00:37:29.720 --> 00:37:33.440
with Pydantic because they have a plugin for Pydantic


00:37:33.440 --> 00:37:35.200
to provide the auto completion for those things,


00:37:35.200 --> 00:37:37.120
but it requires this particular plugin.


00:37:37.120 --> 00:37:38.760
Now with this extension,


00:37:38.760 --> 00:37:40.960
you can get also auto completion in VS Code.


00:37:40.960 --> 00:37:43.720
And with the same extension without needing any plugin,


00:37:43.720 --> 00:37:45.640
you get auto completion for SQL model


00:37:45.640 --> 00:37:46.980
in Visual Studio Code.


00:37:46.980 --> 00:37:50.240
I think the people from PyCharm were also checking out


00:37:50.240 --> 00:37:52.880
to maybe support the same standard,


00:37:52.880 --> 00:37:57.320
which will allow PyCharm to provide automatic auto-completion


00:37:57.320 --> 00:38:01.160
for SQL model and other libraries like Pydantic


00:38:01.160 --> 00:38:03.360
and others.


00:38:03.360 --> 00:38:05.240
- Sure, yeah, that's great.


00:38:05.240 --> 00:38:10.240
Definitely the widespread use of Pydantic effectively


00:38:10.240 --> 00:38:12.320
is forcing everyone to go like,


00:38:12.320 --> 00:38:14.020
all right, how can we make this work better


00:38:14.020 --> 00:38:15.760
on the creation side?


00:38:15.760 --> 00:38:20.320
So RJL out there has a comment,


00:38:20.320 --> 00:38:22.080
which then leads me to an interesting question.


00:38:22.080 --> 00:38:26.640
I'm old fashioned, I use direct SQL statements, no ORM, I really need to take the time to go down


00:38:26.640 --> 00:38:35.600
this route. Indeed, I do think so. It's certainly worthwhile. Maybe, what are your thoughts on


00:38:35.600 --> 00:38:41.680
using straight SQL versus not, then I'll ask my question. So I think, you know, like it just,


00:38:41.680 --> 00:38:49.040
it's a lot about taste and how people prefer to code. There's a lot of people that are so


00:38:49.040 --> 00:38:54.880
comfortable with SQL and that can do so many things with SQL very easily that it's just


00:38:54.880 --> 00:39:02.560
more efficient to just use SQL directly. For me, some of the advantages with ORMs is that I get


00:39:02.560 --> 00:39:07.040
inline errors, that I get auto-completion for what is the name of the attribute. If I forget


00:39:07.040 --> 00:39:14.240
that I say secret_name, the editor will auto-complete that for me. But if I'm typing


00:39:14.240 --> 00:39:17.960
that inside of just a long string in Python using SQL,


00:39:17.960 --> 00:39:20.560
then I have to remember because no one will tell me


00:39:20.560 --> 00:39:22.640
that I have a syntax error in my SQL


00:39:22.640 --> 00:39:24.920
or that I'm using an attribute that doesn't exist.


00:39:24.920 --> 00:39:26.840
- Yeah, one of the things that actually blew my mind


00:39:26.840 --> 00:39:30.240
is PyCharm, if you set it up to,


00:39:30.240 --> 00:39:34.280
if you basically connect the database to your project,


00:39:34.280 --> 00:39:36.520
it'll give you autocomplete and error checking


00:39:36.520 --> 00:39:39.560
inside strings inside Python for your schema.


00:39:39.560 --> 00:39:40.620
- That's super cool.


00:39:40.620 --> 00:39:42.160
- Which is amazing.


00:39:42.160 --> 00:39:45.440
That said, I never do that because to me,


00:39:45.440 --> 00:39:46.840
one of the things that is super valuable,


00:39:46.840 --> 00:39:48.560
one is this auto-complete,


00:39:48.560 --> 00:39:50.960
the other is refactoring as well.


00:39:50.960 --> 00:39:52.720
Like, oh, did we change the name of that?


00:39:52.720 --> 00:39:55.460
Well, oh, there was that one query we didn't update


00:39:55.460 --> 00:39:56.860
and now it crashes in production,


00:39:56.860 --> 00:39:59.840
but only sometimes when it hits this case.


00:39:59.840 --> 00:40:03.780
And, you know, it's just the way it sticks together


00:40:03.780 --> 00:40:06.680
and stays consistent to me seems a lot stronger


00:40:06.680 --> 00:40:08.120
if you're using models as well.


00:40:08.120 --> 00:40:10.240
And also the ability to swap backends, right?


00:40:10.240 --> 00:40:12.700
the way you do parameterized queries


00:40:12.700 --> 00:40:15.280
is different across different database backends.


00:40:15.280 --> 00:40:16.120
- Yeah. - Right.


00:40:16.120 --> 00:40:18.020
- Also, if you write SQL by hand,


00:40:18.020 --> 00:40:19.760
then you have to be super careful


00:40:19.760 --> 00:40:21.600
and probably you have to be a SQL wizard


00:40:21.600 --> 00:40:25.200
and know how to sanitize all the data that you're putting


00:40:25.200 --> 00:40:29.480
or otherwise you could end up in nasty situations.


00:40:29.480 --> 00:40:33.060
But given that, and saying that,


00:40:33.060 --> 00:40:34.800
there's a lot of people that prefer,


00:40:34.800 --> 00:40:37.960
really prefer writing SQL directly.


00:40:37.960 --> 00:40:40.000
The same author of Pydantic,


00:40:40.000 --> 00:40:42.180
which SQL model is based on,


00:40:42.180 --> 00:40:44.100
prefers to write SQL directly.


00:40:44.100 --> 00:40:47.260
Unlike he's using FastAPI and everything,


00:40:47.260 --> 00:40:49.000
but it's just more comfortable to him.


00:40:49.000 --> 00:40:53.800
And the author of "Py and Psycopg,"


00:40:53.800 --> 00:40:57.040
the driver for PostgreSQL,


00:40:57.040 --> 00:40:58.520
he just uses SQL directly.


00:40:58.520 --> 00:41:00.680
It's just like more comfortable for him.


00:41:00.680 --> 00:41:02.640
He uses FastAPI a lot, but still,


00:41:02.640 --> 00:41:03.840
like it's just more comfortable.


00:41:03.840 --> 00:41:06.600
So I guess like it depends a lot on like the taste.


00:41:06.600 --> 00:41:09.600
For me, I depend a lot on the tooling


00:41:09.600 --> 00:41:11.900
and editor support and refactoring as you were saying,


00:41:11.900 --> 00:41:15.340
like if I change a name, I know that it's changed everywhere


00:41:15.340 --> 00:41:17.620
because I won't remember,


00:41:17.620 --> 00:41:20.780
I won't remember where did I made this mistake, so yeah.


00:41:20.780 --> 00:41:23.140
- Yeah, absolutely.


00:41:23.140 --> 00:41:26.940
So Martin in the audience asked an interesting question,


00:41:26.940 --> 00:41:29.220
down here is a better example.


00:41:29.220 --> 00:41:35.260
One of the challenges of ORMs is to make set-based operations


00:41:35.260 --> 00:41:37.460
apply back to the database.


00:41:37.460 --> 00:41:40.320
Like I wanna change this field.


00:41:40.320 --> 00:41:44.020
Like I want to set a is on sale flag to true


00:41:44.020 --> 00:41:49.020
for all products where the price is less than $10.


00:41:49.020 --> 00:41:52.160
Right, where I'm not going to pull,


00:41:52.160 --> 00:41:54.560
I don't wanna go, let me query all products


00:41:54.560 --> 00:41:56.260
whose price are less than $10,


00:41:56.260 --> 00:41:58.560
change it on the object and then push those changes.


00:41:58.560 --> 00:42:01.740
I wanna push the, I just wanna say,


00:42:01.740 --> 00:42:04.860
update where this set that, you know what I mean?


00:42:04.860 --> 00:42:05.700
- Yeah, yeah.


00:42:05.700 --> 00:42:07.840
- What's the story about that with SQL model?


00:42:07.840 --> 00:42:10.100
'Cause that's one of the things that can really


00:42:10.100 --> 00:42:12.920
just hammer productivity or speed, I guess,


00:42:12.920 --> 00:42:15.220
is that you've got to like pull back a whole bunch of stuff


00:42:15.220 --> 00:42:18.740
to just make sort of consistent changes across them.


00:42:18.740 --> 00:42:19.660
You know what I'm saying?


00:42:19.660 --> 00:42:20.500
- Yeah, yeah.


00:42:20.500 --> 00:42:21.880
Like this is one of the use cases


00:42:21.880 --> 00:42:26.060
where you will want to interact directly with SQLAlchemy.


00:42:26.060 --> 00:42:27.580
And you can do that through SQL model,


00:42:27.580 --> 00:42:31.500
but you can write like queries as complex as you want


00:42:31.500 --> 00:42:33.940
through SQL model,


00:42:33.940 --> 00:42:36.380
but just using pure SQLAlchemy underneath


00:42:36.380 --> 00:42:41.380
and you can use very advanced things with SQL.


00:42:41.380 --> 00:42:45.300
SQL model focuses a lot on the simplest


00:42:45.300 --> 00:42:47.540
and most common use cases


00:42:47.540 --> 00:42:51.060
and providing the best developer experience


00:42:51.060 --> 00:42:56.060
and certainty that the code is as error-free as possible


00:42:56.060 --> 00:42:57.740
because you have all these type annotations


00:42:57.740 --> 00:42:58.780
and all these type checks.


00:42:58.780 --> 00:43:01.660
But for any case that is a little bit more advanced,


00:43:01.660 --> 00:43:04.660
you can just drop down directly to SQLAlchemy.


00:43:04.660 --> 00:43:07.260
And because SQLModel is just pure SQLAlchemy,


00:43:07.260 --> 00:43:09.900
the models are themselves just SQLAlchemy.


00:43:09.900 --> 00:43:12.420
So you can just use SQLAlchemy directly with it.


00:43:12.420 --> 00:43:14.740
In fact, you could use one of these models


00:43:14.740 --> 00:43:19.540
with a SQLAlchemy engine directly, and it would work.


00:43:19.540 --> 00:43:20.780
- Interesting, okay.


00:43:20.780 --> 00:43:24.060
Sky points out in the audience


00:43:24.060 --> 00:43:25.260
that you were too humble to call out.


00:43:25.260 --> 00:43:28.020
The PR that got that autocomplete for VS Code


00:43:28.020 --> 00:43:30.460
was actually for Bitandic, but it was by you.


00:43:30.460 --> 00:43:34.040
So well done, way to keep moving forward on both fronts.


00:43:34.040 --> 00:43:39.940
Let's see, so what about performance?


00:43:39.940 --> 00:43:45.880
There's extra goodness in the validation


00:43:45.880 --> 00:43:48.160
and the type conversions and stuff like that


00:43:48.160 --> 00:43:52.480
of say, Pydantic, but is there a large overhead


00:43:52.480 --> 00:43:57.480
for using this say over SQLAlchemy over say, raw SQL?


00:43:58.160 --> 00:44:00.460
- Yeah, well, so when you use, when you use,


00:44:00.460 --> 00:44:02.420
when you declare a model and you say,


00:44:02.420 --> 00:44:05.460
hey, this is a table model.


00:44:05.460 --> 00:44:08.340
So this is like the equivalent of a SQLAlchemy model.


00:44:08.340 --> 00:44:11.260
Then a lot of the validation and that stuff


00:44:11.260 --> 00:44:12.620
with Pydantic is overwritten.


00:44:12.620 --> 00:44:13.700
So when you create a model,


00:44:13.700 --> 00:44:16.180
it will not be validated on creation


00:44:16.180 --> 00:44:17.540
for that particular table


00:44:17.540 --> 00:44:21.220
because this will be handled directly by SQLAlchemy.


00:44:21.220 --> 00:44:22.420
And for example, with SQLAlchemy,


00:44:22.420 --> 00:44:25.740
you can create an instance of a model


00:44:25.740 --> 00:44:28.180
without setting all the attributes.


00:44:28.180 --> 00:44:31.180
And then you can set the attributes manually afterwards.


00:44:31.180 --> 00:44:33.660
If Pydantic was doing validation for that,


00:44:33.660 --> 00:44:35.660
like that will explode and that will say,


00:44:35.660 --> 00:44:36.860
hey, this is invalid.


00:44:36.860 --> 00:44:40.580
So when you are working with SQLAlchemy alone,


00:44:40.580 --> 00:44:43.100
well, like with the SQL parts alone through SQL model,


00:44:43.100 --> 00:44:45.260
then it's just like using SQLAlchemy directly.


00:44:45.260 --> 00:44:46.980
When you are using-- - Okay, so it's not really


00:44:46.980 --> 00:44:48.740
any different in terms of,


00:44:48.740 --> 00:44:51.940
whatever SQLAlchemy does, this does in terms of performance.


00:44:51.940 --> 00:44:54.100
- Exactly, exactly. - Okay, got it.


00:44:54.100 --> 00:44:55.800
It just has like...


00:44:55.800 --> 00:44:59.400
And actually, the code is so slim, it's so little


00:44:59.400 --> 00:45:04.100
that whatever is the overhead, I will think it will be negligible.


00:45:04.100 --> 00:45:10.280
At the same time, I'm not optimizing for squeezing the maximum performance,


00:45:10.280 --> 00:45:13.880
but for getting the maximum correctness in the code


00:45:13.880 --> 00:45:15.920
and the best developer experience,


00:45:15.920 --> 00:45:22.120
because I feel it helps a lot more to be a lot faster as a developer,


00:45:22.120 --> 00:45:25.080
building the tool and making sure that it's all correct


00:45:25.080 --> 00:45:28.080
than having the code super fast, but very difficult to debug


00:45:28.080 --> 00:45:30.420
and to understand and to write correctly.


00:45:30.420 --> 00:45:36.120
So I guess you just got to decide,


00:45:36.120 --> 00:45:39.040
is an ORM the right fit at all?


00:45:39.040 --> 00:45:41.420
And if yes, then this is a pretty good choice


00:45:41.420 --> 00:45:42.760
if you like this API.


00:45:42.760 --> 00:45:44.960
Yeah, exactly. And yeah, absolutely.


00:45:44.960 --> 00:45:49.380
If you were needing the maximum performance that you can get,


00:45:49.380 --> 00:45:53.580
you will probably end up just getting an async drive


00:45:53.580 --> 00:45:55.580
directly and just writing SQL directly


00:45:55.580 --> 00:45:59.840
for the particular endpoint that needs this extra boost in performance.


00:45:59.840 --> 00:46:01.840
But for most of the other cases,


00:46:01.840 --> 00:46:05.280
this will probably help making sure that the code is correct


00:46:05.280 --> 00:46:07.780
and making sure that you can write code quickly


00:46:07.780 --> 00:46:10.980
and be done with the feature that you're implementing.


00:46:10.980 --> 00:46:12.660
Right on.


00:46:12.660 --> 00:46:16.260
I've got one more thing I want to talk to you about.


00:46:16.260 --> 00:46:18.780
And then I've got, I did a Twitter,


00:46:18.780 --> 00:46:20.260
hey, I'm talking to Sebastian.


00:46:20.260 --> 00:46:23.180
Let's, what are the questions we should be asking?


00:46:23.180 --> 00:46:24.740
And I got a bunch of great ones on Twitter.


00:46:24.740 --> 00:46:26.900
So I do want to touch on those as well.


00:46:26.900 --> 00:46:27.740
- Nice.


00:46:27.740 --> 00:46:29.900
- One of the things though that you spoke about


00:46:29.900 --> 00:46:33.500
is the ability of having,


00:46:33.500 --> 00:46:36.700
this is just generally true for SQLAlchemy.


00:46:36.700 --> 00:46:40.140
These models, they are tied back to a,


00:46:40.140 --> 00:46:42.420
what's called a session or a unit of work


00:46:42.420 --> 00:46:43.420
to do with the database.


00:46:43.420 --> 00:46:46.940
and you can't do a query, get a record,


00:46:46.940 --> 00:46:49.340
and then go from a separate situation


00:46:49.340 --> 00:46:51.540
and try to jam it back into,


00:46:51.540 --> 00:46:54.640
it's gotta be stuck to the session that it comes from, right?


00:46:54.640 --> 00:46:56.620
So you don't share the models across sessions,


00:46:56.620 --> 00:46:58.000
but one of the things that would be nice


00:46:58.000 --> 00:46:59.940
is just to have a single one.


00:46:59.940 --> 00:47:03.800
And so FastAPI has a dependency injection system


00:47:03.800 --> 00:47:08.260
that you talked about can be used for basically


00:47:08.260 --> 00:47:11.940
always providing one and only one session


00:47:11.940 --> 00:47:15.580
to an API endpoint or a web endpoint


00:47:15.580 --> 00:47:19.060
that then could be the database management unit,


00:47:19.060 --> 00:47:20.540
like creating a unit of work


00:47:20.540 --> 00:47:23.100
that is the lifetime of the request, basically.


00:47:23.100 --> 00:47:24.320
Wanna talk about that?


00:47:24.320 --> 00:47:25.260
- Yeah, exactly.


00:47:25.260 --> 00:47:27.580
I think you described it perfectly.


00:47:27.580 --> 00:47:30.060
I don't know what else can I add on top of this, right?


00:47:30.060 --> 00:47:31.660
So this is the dependency injection system.


00:47:31.660 --> 00:47:33.380
It's just like you declare some function


00:47:33.380 --> 00:47:35.580
and FastAPI will make sure to run that function


00:47:35.580 --> 00:47:37.460
and provide the value to all the things


00:47:37.460 --> 00:47:40.220
that need that value.


00:47:40.220 --> 00:47:42.920
for one particular request.


00:47:42.920 --> 00:47:44.880
- Right, this has nothing to do with the database,


00:47:44.880 --> 00:47:45.920
by the way, this could be anything.


00:47:45.920 --> 00:47:48.000
It could be a logging framework, whatever, right?


00:47:48.000 --> 00:47:52.200
- Exactly, so this is very useful for doing logging,


00:47:52.200 --> 00:47:55.280
for doing authentication, for doing authorization,


00:47:55.280 --> 00:47:57.500
withdrawals, and like whatnot.


00:47:57.500 --> 00:48:01.940
For doing logging, for setting up things


00:48:01.940 --> 00:48:04.040
that log stuff to remote servers,


00:48:04.040 --> 00:48:06.760
like Sentry or like Datalog, or I don't know,


00:48:06.760 --> 00:48:09.080
for all those things that you need to do,


00:48:09.080 --> 00:48:12.800
And that can be-- and there is some logic that


00:48:12.800 --> 00:48:14.880
needs to be shared and that could


00:48:14.880 --> 00:48:16.840
run before the request is handled


00:48:16.840 --> 00:48:19.760
and maybe after the request is done.


00:48:19.760 --> 00:48:21.720
And then you can share this information.


00:48:21.720 --> 00:48:23.740
So in many frameworks, there is a concept


00:48:23.740 --> 00:48:25.480
of a middleware, which is something


00:48:25.480 --> 00:48:27.840
that runs before the request and after the request.


00:48:27.840 --> 00:48:30.840
But then you have to run this thing for every request.


00:48:30.840 --> 00:48:33.200
With dependencies, with this dependency injection system,


00:48:33.200 --> 00:48:35.720
you can define exactly where you want it to run.


00:48:35.720 --> 00:48:37.700
And you can define, I want this to be run


00:48:37.700 --> 00:48:41.380
with a group of endpoints or with a group of operations


00:48:41.380 --> 00:48:45.220
as I used to call them, or for just one particular endpoint


00:48:45.220 --> 00:48:47.340
or for a bunch of endpoints.


00:48:47.340 --> 00:48:51.740
And with this system, you can extract


00:48:51.740 --> 00:48:53.660
and you can generate whatever it is


00:48:53.660 --> 00:48:56.060
that you need to generate for the particular request.


00:48:56.060 --> 00:48:58.340
And the good thing about the independence injection system


00:48:58.340 --> 00:49:00.780
is that if you're extracting information from the request,


00:49:00.780 --> 00:49:03.220
for example, from a header,


00:49:03.220 --> 00:49:05.620
then this information will be also extracted


00:49:05.620 --> 00:49:08.340
and included with FastAPI, with all the open API


00:49:08.340 --> 00:49:09.260
and all these standards.


00:49:09.260 --> 00:49:11.060
So you will get that information


00:49:11.060 --> 00:49:14.380
in the automatically generated user interface


00:49:14.380 --> 00:49:15.520
to explore the API.


00:49:15.520 --> 00:49:18.420
- Yeah, very cool.


00:49:18.420 --> 00:49:20.420
So what steps do I have to take


00:49:20.420 --> 00:49:25.300
to do dependency injection to get that session to show up?


00:49:25.300 --> 00:49:26.820
I remember you had it in the documentation,


00:49:26.820 --> 00:49:29.060
but I don't remember where it is right now.


00:49:29.060 --> 00:49:34.060
- So I think for the particular case of SQL model,


00:49:34.500 --> 00:49:38.260
even though FastAPI and SQL model are independent,


00:49:38.260 --> 00:49:41.260
are made to be very compatible with that independent,


00:49:41.260 --> 00:49:46.060
I have a lot of documentation about writing applications


00:49:46.060 --> 00:49:49.440
with FastAPI and SQL model in the SQL model docs.


00:49:49.440 --> 00:49:52.420
The way that you will, the way that we will do it,


00:49:52.420 --> 00:49:55.540
the way that you will handle a FastAPI dependency


00:49:55.540 --> 00:49:58.740
in general is that from FastAPI,


00:49:58.740 --> 00:50:02.820
you import this special function depends,


00:50:02.820 --> 00:50:03.660
to start with that.


00:50:03.660 --> 00:50:05.940
And then you create some function


00:50:05.940 --> 00:50:07.420
that will return some value.


00:50:07.420 --> 00:50:09.540
This function will have the same style


00:50:09.540 --> 00:50:13.780
as any other function that handles a particular request.


00:50:13.780 --> 00:50:16.980
So it can have some parameters with some types


00:50:16.980 --> 00:50:18.580
and those that information will be extracted


00:50:18.580 --> 00:50:19.580
from the request.


00:50:19.580 --> 00:50:20.860
And it just returns something.


00:50:20.860 --> 00:50:23.400
This is just plain old function.


00:50:23.400 --> 00:50:25.940
And then you pass this, this function is,


00:50:25.940 --> 00:50:27.860
this is what will be the dependency.


00:50:27.860 --> 00:50:31.980
Then you pass that function as a parameter to depends.


00:50:31.980 --> 00:50:34.260
and then you put depends as the default value


00:50:34.260 --> 00:50:37.460
of some parameter in your main function


00:50:37.460 --> 00:50:39.380
that is handling the request.


00:50:39.380 --> 00:50:41.680
- I see, so you could say session equals,


00:50:41.680 --> 00:50:43.580
like depends here's some function


00:50:43.580 --> 00:50:45.220
that I'll call to create the session.


00:50:45.220 --> 00:50:47.020
- Session equals depends,


00:50:47.020 --> 00:50:49.060
I'm calling depends with the function


00:50:49.060 --> 00:50:52.140
that is named get session or something like that.


00:50:52.140 --> 00:50:55.820
- Do you have a way to see both sides of that


00:50:55.820 --> 00:50:57.180
with dependency injection?


00:50:57.180 --> 00:50:58.700
So does it just return the value


00:50:58.700 --> 00:50:59.980
or can you like create a session


00:50:59.980 --> 00:51:02.400
and then yield the value and then keep processing


00:51:02.400 --> 00:51:04.260
or something along those lines.


00:51:04.260 --> 00:51:06.140
- Exactly like that.


00:51:06.140 --> 00:51:08.500
You can create a session that you can yield the value.


00:51:08.500 --> 00:51:12.140
And then after the request is done,


00:51:12.140 --> 00:51:13.780
you can continue doing more stuff


00:51:13.780 --> 00:51:16.060
after yielding that particular session.


00:51:16.060 --> 00:51:17.620
So you can create a session,


00:51:17.620 --> 00:51:21.020
give the session from the dependency,


00:51:21.020 --> 00:51:23.540
and then the main code that will handle the request


00:51:23.540 --> 00:51:25.100
will have that session.


00:51:25.100 --> 00:51:26.860
And then the same dependency can take care


00:51:26.860 --> 00:51:28.620
of closing the session after.


00:51:28.620 --> 00:51:32.900
- Right, exactly, try yield session, finally close it,


00:51:32.900 --> 00:51:34.420
maybe like if there's no exception,


00:51:34.420 --> 00:51:35.980
commit it, something like that.


00:51:35.980 --> 00:51:36.820
- Exactly.


00:51:36.820 --> 00:51:39.300
- Okay, that's pretty flexible.


00:51:39.300 --> 00:51:41.740
- Yeah, and in the main code that you have,


00:51:41.740 --> 00:51:44.220
you don't have to take care about creating the session


00:51:44.220 --> 00:51:46.780
or closing it or making sure that there are no exceptions


00:51:46.780 --> 00:51:49.160
because you can do all that stuff in the dependency


00:51:49.160 --> 00:51:52.980
and share that logic throughout your code.


00:51:52.980 --> 00:51:55.020
And the other thing is that dependencies


00:51:55.020 --> 00:51:59.040
can themselves depend on other dependencies.


00:51:59.040 --> 00:52:01.000
So you can create a dependency


00:52:01.000 --> 00:52:03.500
that gets the session for the database.


00:52:03.500 --> 00:52:06.040
And then you can use that in another dependency


00:52:06.040 --> 00:52:10.160
that gets the current user and extracts from the header


00:52:10.160 --> 00:52:12.000
from the authentication token or whatever,


00:52:12.000 --> 00:52:13.320
extract the user ID,


00:52:13.320 --> 00:52:15.080
then gets the user ID from the database


00:52:15.080 --> 00:52:17.280
and then returns the current user.


00:52:17.280 --> 00:52:18.920
So that you have a whole dependency


00:52:18.920 --> 00:52:21.400
that just takes care of returning the current user


00:52:21.400 --> 00:52:23.280
and making sure that it's authenticated.


00:52:23.280 --> 00:52:27.600
And then in all your, and you can reuse that code


00:52:27.600 --> 00:52:31.000
in all your endpoints or in all the main functions


00:52:31.000 --> 00:52:32.080
that handle the requests.


00:52:32.080 --> 00:52:34.480
And all those functions will be able to just get


00:52:34.480 --> 00:52:37.680
the current user right away without having to


00:52:37.680 --> 00:52:40.280
have all the logic to extract the information,


00:52:40.280 --> 00:52:42.120
process the token, all that stuff.


00:52:42.120 --> 00:52:43.720
- Sure, this is very neat.


00:52:43.720 --> 00:52:47.600
I haven't used this enough during my work with FastAPI,


00:52:47.600 --> 00:52:49.440
so I gotta check this out.


00:52:49.440 --> 00:52:52.960
All right, now let's do a bit of a lightning round here


00:52:52.960 --> 00:52:54.640
of the Twitter questions,


00:52:54.640 --> 00:52:56.960
because I've seen some of these questions


00:52:56.960 --> 00:52:57.800
come up in the live chat,


00:52:57.800 --> 00:52:59.600
but I also think I pulled out these ones


00:52:59.600 --> 00:53:01.880
that I thought people put on Twitter that were pretty good.


00:53:01.880 --> 00:53:05.200
So, Lemat Webster says,


00:53:05.200 --> 00:53:07.800
"Any plans to ramp or replace Alembic


00:53:07.800 --> 00:53:11.560
"to make migrations more developer friendly?"


00:53:11.560 --> 00:53:15.040
So, first of all, migrations,


00:53:15.040 --> 00:53:17.400
you've got to keep your database in sync with your models,


00:53:17.400 --> 00:53:19.920
otherwise, SQLAlchemy and hence SQL model


00:53:19.920 --> 00:53:23.100
will freak out about that 'cause it's gonna be a problem.


00:53:23.100 --> 00:53:28.720
But Alembic is, while it works, is a little bit hard


00:53:28.720 --> 00:53:30.420
to say like, here's all the models you need


00:53:30.420 --> 00:53:32.820
to pay attention to, and here's the scenario where you run.


00:53:32.820 --> 00:53:34.460
It's a little bit clunky.


00:53:34.460 --> 00:53:37.140
It works well, but it's not super smooth.


00:53:37.140 --> 00:53:39.340
And I think that's what Matt's asking here.


00:53:39.340 --> 00:53:42.860
- Yeah, so Alembic is the official tool


00:53:42.860 --> 00:53:45.060
from SQLAlchemy to do the migrations.


00:53:45.060 --> 00:53:47.500
And because SQL model is itself


00:53:47.500 --> 00:53:49.580
also just SQLAlchemy underneath,


00:53:49.580 --> 00:53:51.900
Alembic works with it perfectly.


00:53:51.900 --> 00:53:53.220
Alembic is a great tool.


00:53:53.220 --> 00:53:56.440
It's super advanced and helps a lot.


00:53:56.440 --> 00:53:58.580
It can even generate automatic migration,


00:53:58.580 --> 00:53:59.860
some things like that.


00:53:59.860 --> 00:54:02.700
I think the main problem with Alembic is that


00:54:02.700 --> 00:54:04.540
in some cases it's not as intuitive.


00:54:04.540 --> 00:54:07.020
So yes, what I want to do at some point


00:54:07.020 --> 00:54:09.140
is to wrap a bit of Alembic.


00:54:09.140 --> 00:54:10.900
I will replace it because it's already doing


00:54:10.900 --> 00:54:13.020
a magnificent job,


00:54:13.020 --> 00:54:15.860
but, and it will be super difficult to write


00:54:15.860 --> 00:54:17.980
all that logic and all that work


00:54:17.980 --> 00:54:20.820
that my buddy has been doing for a very long time


00:54:20.820 --> 00:54:22.180
with SQL Model and Lemmick.


00:54:22.180 --> 00:54:24.660
I will wrap it and I will try to add a bit more


00:54:24.660 --> 00:54:28.620
of documentation to explain how to handle the simplest cases


00:54:28.620 --> 00:54:30.620
which is the same that I'm doing with SQL Model.


00:54:30.620 --> 00:54:31.940
If you need something more complex


00:54:31.940 --> 00:54:34.180
then you will probably just go to a Lemmick directly


00:54:34.180 --> 00:54:36.460
or to SQLAlchemy directly.


00:54:36.460 --> 00:54:39.500
- Related to this, not Twitter question, Michael question.


00:54:39.500 --> 00:54:44.500
What about, do you have any thoughts about testing code


00:54:45.340 --> 00:54:50.100
using these models and stuff like fake data


00:54:50.100 --> 00:54:52.020
or mocking out the database


00:54:52.020 --> 00:54:54.260
beyond just the standard stuff you would do to SQLAlchemy.


00:54:54.260 --> 00:54:56.300
Like, is there anything special about SQL model


00:54:56.300 --> 00:55:00.380
that makes testing it easier or different than SQLAlchemy?


00:55:00.380 --> 00:55:03.900
- No, the testing will be pretty similar to SQLAlchemy.


00:55:03.900 --> 00:55:07.100
Yes, I just have like a bunch of documentation


00:55:07.100 --> 00:55:09.580
of how to do testing and even how to do testing


00:55:09.580 --> 00:55:12.260
with FastAPI applications using SQLAlchemy


00:55:12.260 --> 00:55:15.720
and how to, for example, use a SQLite database


00:55:15.720 --> 00:55:18.220
for testing that could be run on memory


00:55:18.220 --> 00:55:20.060
instead of the production database


00:55:20.060 --> 00:55:22.740
that could be PostgreSQL or MySQL or whatever.


00:55:22.740 --> 00:55:24.860
- Just change the connection string to the engine


00:55:24.860 --> 00:55:26.180
and let it go. - Exactly.


00:55:26.180 --> 00:55:27.820
- Yeah, okay. - And then make it run


00:55:27.820 --> 00:55:30.860
with a database in memory


00:55:30.860 --> 00:55:33.140
and then make it work correctly with--


00:55:33.140 --> 00:55:36.420
- So something like a pytest fixture


00:55:36.420 --> 00:55:38.360
that initializes the database,


00:55:38.360 --> 00:55:39.880
but you just use colon memory colon


00:55:39.880 --> 00:55:40.860
for the connection string


00:55:40.860 --> 00:55:42.900
so that it just goes away.


00:55:42.900 --> 00:55:44.340
- Yes, exactly like that.


00:55:44.340 --> 00:55:46.020
It's documented exactly like that.


00:55:46.020 --> 00:55:47.540
- All right, right on.


00:55:47.540 --> 00:55:49.300
All right, Ricky Lim says,


00:55:49.300 --> 00:55:51.900
"Would SQL model be part of, maybe should,


00:55:51.900 --> 00:55:55.300
"could be part of the standard Python library?"


00:55:55.300 --> 00:55:56.140
I have some thoughts on this,


00:55:56.140 --> 00:55:57.460
but I wanna hear your thoughts first.


00:55:57.460 --> 00:55:59.660
I have some historical perspective on this,


00:55:59.660 --> 00:56:00.940
but I wanna hear your thoughts on this first.


00:56:00.940 --> 00:56:05.740
- Okay, so no, it will not be part of the standard library.


00:56:05.740 --> 00:56:09.580
Ideally, it will not be part of the standard library


00:56:09.580 --> 00:56:12.800
because if it was part of the standard library,


00:56:12.800 --> 00:56:14.320
it will mean that it will be available


00:56:14.320 --> 00:56:17.260
in Python 3.13 or something.


00:56:17.260 --> 00:56:20.980
And then users of Python 3.10 right now


00:56:20.980 --> 00:56:23.060
will not be able to use it on one side.


00:56:23.060 --> 00:56:25.420
On the other side, having more stuff


00:56:25.420 --> 00:56:28.940
in the Python standard library adds more inconvenience


00:56:28.940 --> 00:56:31.100
and more burden to the core maintainers,


00:56:31.100 --> 00:56:32.900
to the core developers of Python,


00:56:32.900 --> 00:56:35.180
which makes it even more difficult for them


00:56:35.180 --> 00:56:36.780
to continue supporting Python


00:56:36.780 --> 00:56:38.340
and all the different versions.


00:56:38.340 --> 00:56:43.340
And it will also complicate things for Bread Cannon


00:56:43.340 --> 00:56:47.820
that is trying to figure out a way to slim down Python


00:56:47.820 --> 00:56:49.020
so that you can, for example,


00:56:49.020 --> 00:56:51.180
run it directly on the web browser.


00:56:51.180 --> 00:56:52.700
- How do we build it in WebAssembly?


00:56:52.700 --> 00:56:53.540
This doesn't help.


00:56:53.540 --> 00:56:54.540
- Yes, WebAssembly.


00:56:54.540 --> 00:56:56.940
And you know, Bread Cannon and Kristen Haines


00:56:56.940 --> 00:56:58.580
have been doing a very cool job.


00:56:58.580 --> 00:57:00.100
It's very exciting.


00:57:00.100 --> 00:57:02.620
But a lot of that will probably require,


00:57:02.620 --> 00:57:05.620
actually is leaning down a bit, the standard library.


00:57:05.620 --> 00:57:07.980
As far as I understand, but I'm not, no explanation.


00:57:07.980 --> 00:57:10.680
I imagine a world where we have,


00:57:10.680 --> 00:57:14.100
I don't know what the right word for it is,


00:57:14.100 --> 00:57:16.580
but there's like a standard


00:57:16.580 --> 00:57:21.460
cross environment Python,


00:57:21.460 --> 00:57:25.460
minimum set of language features of standard library


00:57:25.460 --> 00:57:26.940
where things like,


00:57:26.940 --> 00:57:30.660
you know, stuff that talks on the network


00:57:30.660 --> 00:57:32.740
or does UI things or whatever,


00:57:32.740 --> 00:57:36.660
just that is not part of this like minimum subset of Python


00:57:36.660 --> 00:57:40.120
that we're guaranteed to have so that we can put it on


00:57:40.120 --> 00:57:42.900
WebAssembly, we can put it on mobile devices,


00:57:42.900 --> 00:57:44.660
we can put it on servers.


00:57:44.660 --> 00:57:47.420
And as long as you program to this minimum set,


00:57:47.420 --> 00:57:51.200
your place where your Python can exist is broader,


00:57:51.200 --> 00:57:53.200
you know, like MicroPython potentially.


00:57:53.200 --> 00:57:56.740
I think that that's the trend,


00:57:56.740 --> 00:57:59.100
not the trend towards putting more stuff there.


00:57:59.100 --> 00:58:00.340
- Yeah, exactly.


00:58:00.340 --> 00:58:01.820
Absolutely, absolutely.


00:58:01.820 --> 00:58:03.940
And it's fun that it's already happening.


00:58:03.940 --> 00:58:05.740
MicroPython is already that,


00:58:05.740 --> 00:58:08.640
It's just that it cannot say it's a standard Python


00:58:08.640 --> 00:58:10.940
because it has to link down a bunch of things.


00:58:10.940 --> 00:58:13.780
But being able to have a microcontroller


00:58:13.780 --> 00:58:17.260
and write code in Python that is running the microcontroller,


00:58:17.260 --> 00:58:19.400
that's amazing, that's mind-blowing.


00:58:19.400 --> 00:58:21.060
- Yeah, the most mind-blowing thing for me


00:58:21.060 --> 00:58:24.660
is that you can hook a Lambda expression


00:58:24.660 --> 00:58:27.120
directly to a hardware interrupt.


00:58:27.120 --> 00:58:28.700
(both laughing)


00:58:28.700 --> 00:58:31.100
It's like, what, you can do what?


00:58:31.100 --> 00:58:32.260
That's amazing.


00:58:32.260 --> 00:58:34.460
The historical perspective that I wanted to bring up here


00:58:34.460 --> 00:58:38.180
I believe the core developers actually considered this for requests,


00:58:38.180 --> 00:58:42.220
and they decided that no, they're not going to put it request in the standard library


00:58:42.220 --> 00:58:47.780
to replace URL lib, because it would limit requests ability to grow.


00:58:47.780 --> 00:58:49.780
Like changes could only come once a year.


00:58:49.780 --> 00:58:53.580
It couldn't come three times a week if there was important changes, right?


00:58:53.580 --> 00:58:56.580
Like the speed of development would be hindered.


00:58:56.580 --> 00:58:58.580
So they said, you know what? No, we don't want that.


00:58:58.580 --> 00:59:00.180
Yeah.


00:59:00.780 --> 00:59:05.020
- Yep, all right. Next, Dimitri Figo says,


00:59:05.020 --> 00:59:07.320
"Are you considering working on generating


00:59:07.320 --> 00:59:10.660
TypeScript declaration files based on what's defined


00:59:10.660 --> 00:59:12.460
on the FastAPI backend?"


00:59:12.460 --> 00:59:14.260
That was that documentation I showed


00:59:14.260 --> 00:59:16.260
where it has the schema and all that,


00:59:16.260 --> 00:59:17.540
and like the endpoints.


00:59:17.540 --> 00:59:21.740
- Yeah, so to make it, to explain it a little more,


00:59:21.740 --> 00:59:24.440
when you go to the automatic interactive documentation


00:59:24.440 --> 00:59:28.940
for the API, that is all based on this standard schema


00:59:30.120 --> 00:59:32.480
of the API called OpenAPI.


00:59:32.480 --> 00:59:35.880
This is just a huge JSON that defines all the data shapes


00:59:35.880 --> 00:59:38.080
that you're using, all the endpoints, everything.


00:59:38.080 --> 00:59:40.440
But that same thing, because it's a standard,


00:59:40.440 --> 00:59:42.960
then you can use that same thing to generate code


00:59:42.960 --> 00:59:46.600
for clients that communicate with your backend.


00:59:46.600 --> 00:59:49.800
And in fact, there's a bunch of client generators


00:59:49.800 --> 00:59:52.040
for many languages, including TypeScript.


00:59:52.040 --> 00:59:54.000
And I have used them, I have used some of them,


00:59:54.000 --> 00:59:56.760
and they are actually very, very good.


00:59:56.760 --> 01:00:01.760
Like you can achieve things like defining in the backend,


01:00:01.760 --> 01:00:03.680
where are the data shapes that you're using?


01:00:03.680 --> 01:00:05.600
Then you update something,


01:00:05.600 --> 01:00:08.440
and then you regenerate the client in the frontend.


01:00:08.440 --> 01:00:09.680
And now after that,


01:00:09.680 --> 01:00:12.060
the frontend team will be able to have access


01:00:12.060 --> 01:00:15.080
to this new API endpoint without the completion


01:00:15.080 --> 01:00:16.720
in their editor and everything.


01:00:16.720 --> 01:00:18.640
It works very well.


01:00:18.640 --> 01:00:19.680
It's super exciting.


01:00:19.680 --> 01:00:22.980
I just haven't had the time to document


01:00:22.980 --> 01:00:26.880
like the whole recipe to make it work.


01:00:26.880 --> 01:00:28.400
But it's already there, it's already working


01:00:28.400 --> 01:00:32.340
and it already does a great job.


01:00:32.340 --> 01:00:35.200
- Yeah, maybe somebody wanted to contribute a PR


01:00:35.200 --> 01:00:37.820
or do some help there, they could, right?


01:00:37.820 --> 01:00:41.260
- Yeah, and you know, like even a blog post


01:00:41.260 --> 01:00:44.680
will just like, that will be a lot faster to get out


01:00:44.680 --> 01:00:47.600
and that will help a lot and a lot of people.


01:00:47.600 --> 01:00:48.600
- Indeed.


01:00:48.600 --> 01:00:51.880
Zach Code says, "I'd love to hear how you approach


01:00:51.880 --> 01:00:53.800
figuring out the integration with SQLAlchemy.


01:00:53.800 --> 01:00:57.520
I mean, we talked a bit about this, but yeah.


01:00:57.520 --> 01:01:01.200
Any other lessons you've learned from basically getting


01:01:01.200 --> 01:01:04.040
in the middle of SQLAlchemy and all of that it does?


01:01:04.040 --> 01:01:07.280
- Yeah, it's very interesting that SQLAlchemy


01:01:07.280 --> 01:01:10.400
was created at a time where like, it was,


01:01:10.400 --> 01:01:12.840
I don't know, Python 2.something,


01:01:12.840 --> 01:01:14.760
there were no context managers.


01:01:14.760 --> 01:01:17.560
So that thing that you do in a with block,


01:01:17.560 --> 01:01:20.720
that you say with something, something,


01:01:20.720 --> 01:01:21.800
as blah, blah, blah.


01:01:21.800 --> 01:01:25.560
And then inside of that, you pull code that was not available in Python.


01:01:25.560 --> 01:01:26.400
That didn't exist.


01:01:26.400 --> 01:01:28.680
SQLAlchemy was made before that.


01:01:28.680 --> 01:01:30.840
So SQLAlchemy had to do a lot of.


01:01:30.840 --> 01:01:36.120
Eh, sophisticated tricks to make everything work and then getting down


01:01:36.120 --> 01:01:38.760
inside of it and trying to understand that.


01:01:38.760 --> 01:01:41.880
And it's like, why is this thing doing this?


01:01:41.880 --> 01:01:42.960
I'm working like this.


01:01:42.960 --> 01:01:44.800
And it's because of those, all those things.


01:01:44.800 --> 01:01:49.200
Eh, I think I ended up like learning a lot about those little details.


01:01:49.200 --> 01:01:52.120
and a lot about how classes work internally


01:01:52.120 --> 01:01:55.220
and how a class is an instance of what


01:01:55.220 --> 01:01:58.020
and all those things and how you can configure all that.


01:01:58.020 --> 01:02:03.140
But the idea with SQL model is to make it super easy


01:02:03.140 --> 01:02:05.440
for you to use it without having to deal


01:02:05.440 --> 01:02:07.080
with all the internal complexity.


01:02:07.080 --> 01:02:08.280
- Yeah, you don't have to know,


01:02:08.280 --> 01:02:10.320
only you had to know and go through it.


01:02:10.320 --> 01:02:11.680
So I think it's worth pointing out,


01:02:11.680 --> 01:02:13.480
I did have Mike Bayer on the show recently


01:02:13.480 --> 01:02:16.840
to talk about SQLAlchemy 2.0


01:02:16.840 --> 01:02:19.720
and how they're moving to have basically


01:02:19.720 --> 01:02:22.900
the client side view of that be everything


01:02:22.900 --> 01:02:26.440
as a context manager and sort of change that up a bit.


01:02:26.440 --> 01:02:30.380
So how close is this to the 2.0 model


01:02:30.380 --> 01:02:32.820
or is it the 1.0 model API?


01:02:32.820 --> 01:02:36.360
- Yeah, so Mike Bayer did a lot of work


01:02:36.360 --> 01:02:39.980
to make the compatibility transition as easy as possible.


01:02:39.980 --> 01:02:44.060
And SQLAlchemy, the latest available version, which is 1.4,


01:02:44.060 --> 01:02:47.060
it's compatible with the previous style


01:02:47.060 --> 01:02:48.540
and with the new style.


01:02:48.540 --> 01:02:51.020
So code that is written with the new style


01:02:51.020 --> 01:02:53.780
will be compatible with SQLAlchemy 2.


01:02:53.780 --> 01:02:55.100
whatever and above.


01:02:55.100 --> 01:02:57.840
SQL model is based on this new style.


01:02:57.840 --> 01:02:59.900
So if you, for example,


01:02:59.900 --> 01:03:02.160
if you have an old application with SQLAlchemy,


01:03:02.160 --> 01:03:03.420
the first thing that you will want to do


01:03:03.420 --> 01:03:06.260
is to migrate to SQLAlchemy 1.4


01:03:06.260 --> 01:03:09.980
and make sure that it's compatible with the new style


01:03:09.980 --> 01:03:12.840
and make sure that you don't have any warnings.


01:03:12.840 --> 01:03:14.080
That's the main thing that you will do


01:03:14.080 --> 01:03:15.120
to make sure that it's compatible.


01:03:15.120 --> 01:03:18.480
And then after that, you can migrate to SQL mode.


01:03:18.480 --> 01:03:19.880
The migration is also super simple.


01:03:19.880 --> 01:03:21.640
It's just like changing some classes


01:03:21.640 --> 01:03:23.680
for type annotations, but yeah.


01:03:23.680 --> 01:03:25.560
- Yeah, absolutely.


01:03:25.560 --> 01:03:28.040
There was a question.


01:03:28.040 --> 01:03:32.120
So the question by Python at Night was,


01:03:32.120 --> 01:03:34.560
what would the level of effort or benefit, if any,


01:03:34.560 --> 01:03:37.200
of converting SQLAlchemy models and schemas


01:03:37.200 --> 01:03:38.880
to SQL model?


01:03:38.880 --> 01:03:41.000
Sounds like the effort is small


01:03:41.000 --> 01:03:44.660
And the benefit is all the features we spoke about, right?


01:03:44.660 --> 01:03:45.980
- Yeah, exactly.


01:03:45.980 --> 01:03:46.820
- Yeah, okay.


01:03:46.820 --> 01:03:49.400
Would you recommend it?


01:03:49.400 --> 01:03:52.440
I mean, people are using SQLAlchemy,


01:03:52.440 --> 01:03:54.160
they're like, you know, I'd really would like to have


01:03:54.160 --> 01:03:55.760
some of that Pydantic magic.


01:03:55.760 --> 01:03:57.360
Like, when would you say, okay,


01:03:57.360 --> 01:04:01.120
the trouble of making a change is sufficient?


01:04:01.120 --> 01:04:02.760
- So right now-- - The benefit is sufficient.


01:04:02.760 --> 01:04:07.760
- Yeah, like, so if it was me, I would just use it right away.


01:04:07.760 --> 01:04:10.820
Right now, it's in version 0.0 point something.


01:04:10.820 --> 01:04:15.820
I will release 0.1.0 once I have 100% of test coverage.


01:04:15.820 --> 01:04:20.460
Right now is 97%, just because I'm not freak out about that.


01:04:20.460 --> 01:04:23.700
But like most of it should already work.


01:04:23.700 --> 01:04:25.220
It's actually very simple.


01:04:25.220 --> 01:04:29.220
And if anything, like the work that it does


01:04:29.220 --> 01:04:31.700
is actually very small because underneath


01:04:31.700 --> 01:04:35.460
it's all done by Atlantic and SQLAlchemy.


01:04:35.460 --> 01:04:38.680
If anything went wrong, you could also just like switch back


01:04:38.680 --> 01:04:40.220
to SQLAlchemy directly.


01:04:40.220 --> 01:04:41.060
It's just that--


01:04:41.060 --> 01:04:42.860
- Basically change your class back


01:04:42.860 --> 01:04:46.020
to derive from SQLAlchemyBase and you're good to go.


01:04:46.020 --> 01:04:46.860
- Yeah.


01:04:46.860 --> 01:04:49.180
The benefit that you will get is out of completion


01:04:49.180 --> 01:04:51.500
and inline errors everywhere where you are using


01:04:51.500 --> 01:04:54.180
these classes that you will normally not get.


01:04:54.180 --> 01:04:57.620
- And the integration with response model.


01:04:57.620 --> 01:04:59.620
- Yes, of course, integration with response models.


01:04:59.620 --> 01:05:02.100
Yeah, actually that's a lot of code that you will save


01:05:02.100 --> 01:05:05.340
if you can share that with Pydantic and with SQLModel.


01:05:05.340 --> 01:05:07.980
Just make sure that you follow all the information


01:05:07.980 --> 01:05:11.060
about how to pin and how to upgrade versions


01:05:11.060 --> 01:05:15.560
because it's very detailed how you should go about that


01:05:15.560 --> 01:05:18.220
because as things are still changing


01:05:18.220 --> 01:05:23.020
and it still has like a little bit of extra testing to do,


01:05:23.020 --> 01:05:26.100
you should be careful about how to pin.


01:05:26.100 --> 01:05:29.380
Just not install like whatever version comes,


01:05:29.380 --> 01:05:31.260
just make sure that you pin the right version,


01:05:31.260 --> 01:05:34.180
you have tests, and then when you upgrade,


01:05:34.180 --> 01:05:35.900
you make sure that the tests are pausing


01:05:35.900 --> 01:05:38.920
and then you can upgrade the version.


01:05:38.920 --> 01:05:40.660
- Yeah, good advice.


01:05:40.660 --> 01:05:44.660
Already talked about that one.


01:05:44.660 --> 01:05:51.180
So Lado asks, "Are you going to stretch


01:05:51.180 --> 01:05:53.780
modern Python conventions from the backend part?"


01:05:53.780 --> 01:05:54.620
Which you already did.


01:05:54.620 --> 01:05:59.620
We talked about using the types and stuff for model binding.


01:05:59.620 --> 01:06:03.520
"To Python challenging front end as well,


01:06:03.520 --> 01:06:06.860
Should we expect something like ReactyPy,


01:06:06.860 --> 01:06:08.560
like React, but in Python?


01:06:08.560 --> 01:06:11.720
Do you care about the frontend


01:06:11.720 --> 01:06:13.320
in the sense that you have any intention


01:06:13.320 --> 01:06:14.820
to build stuff for it?


01:06:14.820 --> 01:06:16.520
- Yes, I care a lot about frontend,


01:06:16.520 --> 01:06:19.480
and I have actually, I think I started in that,


01:06:19.480 --> 01:06:22.040
and I have worked with Angular, UI, Vue.js,


01:06:22.040 --> 01:06:23.260
and like all the stuff.


01:06:23.260 --> 01:06:28.800
I think it will be amazing to be able to write Python


01:06:28.800 --> 01:06:30.840
to write Python for frontend,


01:06:30.840 --> 01:06:33.960
but if someone is gonna make that happen at some point,


01:06:33.960 --> 01:06:36.280
they're probably Brett Tanner and Christian Haynes


01:06:36.280 --> 01:06:38.840
making WebAssembly work for Python.


01:06:38.840 --> 01:06:41.040
- Yeah, you need the runtime there first


01:06:41.040 --> 01:06:43.960
and then it'll go much more easily.


01:06:43.960 --> 01:06:46.020
I absolutely think that it is,


01:06:46.020 --> 01:06:49.320
it's not quite negligence,


01:06:49.320 --> 01:06:51.920
but it's close that the browser makers


01:06:51.920 --> 01:06:55.260
don't package other runtimes


01:06:55.260 --> 01:06:57.440
that are WebAssembly compatible, right?


01:06:57.440 --> 01:07:00.240
Like they should go to Ruby,


01:07:00.240 --> 01:07:03.000
they should go to Java, they should go to .NET,


01:07:03.000 --> 01:07:05.480
and they should go to Python and say,


01:07:05.480 --> 01:07:09.440
are you willing to provide us a runtime that does X, Y, and Z


01:07:09.440 --> 01:07:11.280
that we can integrate in a generic way


01:07:11.280 --> 01:07:14.280
that we can include in our browser


01:07:14.280 --> 01:07:16.080
so you don't have to say,


01:07:16.080 --> 01:07:18.840
oh, well, you can't use these other advanced things


01:07:18.840 --> 01:07:20.840
'cause the WebAssembly download is 10 megs.


01:07:20.840 --> 01:07:25.840
Well, if Firefox, Chrome, and Safari all shipped


01:07:25.840 --> 01:07:29.800
five of those, the five most common languages as binaries,


01:07:29.800 --> 01:07:32.960
like you would just have it and it would just be this website.


01:07:32.960 --> 01:07:34.440
Why does this not happen?


01:07:34.440 --> 01:07:37.640
So, but that's the real problem to ReactyPy


01:07:37.640 --> 01:07:39.840
is that that's not there, right?


01:07:39.840 --> 01:07:40.720
- Yeah.


01:07:40.720 --> 01:07:43.280
- All right, Quazi says,


01:07:43.280 --> 01:07:46.120
what is he doing to address the bus factor?


01:07:46.120 --> 01:07:48.340
That is if you get hit by a bus


01:07:48.340 --> 01:07:50.600
and then related to that in the audience,


01:07:50.600 --> 01:07:52.040
Prashant Rana says,


01:07:52.040 --> 01:07:55.840
will you include a moderator to the project


01:07:55.840 --> 01:07:58.280
so it can become a community driven project


01:07:58.280 --> 01:08:00.160
and there's less burden on you?


01:08:00.160 --> 01:08:02.440
I think those are kind of similar questions


01:08:02.440 --> 01:08:04.720
from a different perspective.


01:08:04.720 --> 01:08:07.880
- Yeah, so the thing is, for most of these projects,


01:08:07.880 --> 01:08:09.920
like most of the work can already be done


01:08:09.920 --> 01:08:11.280
a lot by the community.


01:08:11.280 --> 01:08:15.240
It's not that the work cannot be done.


01:08:15.240 --> 01:08:19.960
I just want to simply enable a bunch of permissions


01:08:19.960 --> 01:08:23.560
to a lot of people to just go and merge pull requests


01:08:23.560 --> 01:08:27.860
very quickly because I like to make sure


01:08:27.860 --> 01:08:28.860
that everything works.


01:08:28.860 --> 01:08:32.580
For example, yesterday, for yesterday's FastAPI release,


01:08:32.580 --> 01:08:35.760
it had like four approvals, the pull request,


01:08:35.760 --> 01:08:38.060
but still it had a couple of bugs


01:08:38.060 --> 01:08:40.980
and a couple of things that needed to be solved.


01:08:40.980 --> 01:08:43.260
And like, I need to be able,


01:08:43.260 --> 01:08:47.020
I need to make sure that the code quality is still kept


01:08:47.020 --> 01:08:48.580
and that everything is working correctly.


01:08:48.580 --> 01:08:51.500
So for now, I'm still like making sure


01:08:51.500 --> 01:08:53.560
that I review each one of the pull requests.


01:08:53.560 --> 01:08:57.020
But if people went and checked those pull requests


01:08:57.020 --> 01:08:59.460
and review the code and it tested it


01:08:59.460 --> 01:09:00.940
and like made sure, hey, this is working


01:09:00.940 --> 01:09:03.900
and I'm using it and it's working in my application


01:09:03.900 --> 01:09:04.740
or things like that.


01:09:04.740 --> 01:09:06.460
That will of course help a lot.


01:09:06.460 --> 01:09:11.120
Yeah, like of course that will help a lot.


01:09:11.120 --> 01:09:13.580
- That's great.


01:09:13.580 --> 01:09:16.900
I mean, obviously it's open source, people can fork it.


01:09:16.900 --> 01:09:18.820
They can run with it.


01:09:18.820 --> 01:09:20.260
If you actually got hit by a bus,


01:09:20.260 --> 01:09:21.700
I think FastAPI would keep going.


01:09:21.700 --> 01:09:23.140
There would just be a figuring out of like,


01:09:23.140 --> 01:09:24.940
all right, well, where's it gonna send her back around


01:09:24.940 --> 01:09:26.340
before it settles down?


01:09:26.340 --> 01:09:27.860
- Yeah, exactly. - Not that everyone's,


01:09:27.860 --> 01:09:32.300
I think, obviously, these questions are a reflection


01:09:32.300 --> 01:09:34.580
of how significant the impact you're having


01:09:34.580 --> 01:09:35.980
on the community is, right?


01:09:35.980 --> 01:09:39.340
- Yeah, and you know, like, I find the boss factor fun.


01:09:39.340 --> 01:09:42.740
I have been wanting to write a blog post about that


01:09:42.740 --> 01:09:44.820
for a while, because I think the boss factor


01:09:44.820 --> 01:09:49.260
is something that works a lot for investors,


01:09:49.260 --> 01:09:53.940
or for founders that are not developers,


01:09:53.940 --> 01:09:55.900
and they are like associating with someone


01:09:55.900 --> 01:09:59.740
is the only one that knows the product, but they want to be the owners of half of it.


01:09:59.740 --> 01:10:02.380
And if this person dies, they just lose all their investment.


01:10:02.380 --> 01:10:03.900
But when you're working with one of these people.


01:10:03.900 --> 01:10:05.500
- They can't keep it going, yeah, absolutely.


01:10:05.500 --> 01:10:11.420
- Yeah, like, you know, like, for example, many of the projects from Encode is mainly Tom Christie,


01:10:11.420 --> 01:10:17.900
which is one person. The maintainer of Flask, which is huge, is mainly David Lord. And he's


01:10:17.900 --> 01:10:22.300
just like, suffering through all of this and through all the abuse from the developers and


01:10:22.300 --> 01:10:24.340
and doing like a lot of the work.


01:10:24.340 --> 01:10:25.660
And probably like, I don't know,


01:10:25.660 --> 01:10:27.140
I think he has like another contributor


01:10:27.140 --> 01:10:27.980
or something like that.


01:10:27.980 --> 01:10:30.660
In the case of FastAPI, there's people like Marcelo


01:10:30.660 --> 01:10:32.020
that is helping a lot.


01:10:32.020 --> 01:10:34.020
And even Samuel Coping is also helping.


01:10:34.020 --> 01:10:39.580
That helps a lot with keeping the community,


01:10:39.580 --> 01:10:41.420
maintaining it and like doing all the work


01:10:41.420 --> 01:10:43.480
that is needed to be done underneath.


01:10:43.480 --> 01:10:49.500
But that doesn't really affect how it's working.


01:10:49.500 --> 01:10:52.460
how it's working, you know?


01:10:52.460 --> 01:10:57.220
Like the fact that the repository is not in another


01:10:57.220 --> 01:11:01.020
GitHub owner, in a GitHub organization or something like


01:11:01.020 --> 01:11:03.380
that, it's just because it's easier to handle.


01:11:03.380 --> 01:11:05.740
But at the same time, there's a lot of people that are


01:11:05.740 --> 01:11:09.820
already contributing and that's the work that actually


01:11:09.820 --> 01:11:11.100
makes a--


01:11:11.100 --> 01:11:12.740
- That's the stuff that matters, yeah.


01:11:12.740 --> 01:11:13.580
- Exactly.


01:11:13.580 --> 01:11:14.420
- Absolutely.


01:11:14.420 --> 01:11:16.540
Lupi, just by the way, out there also says,


01:11:16.540 --> 01:11:19.420
Just want to say thanks to you.


01:11:19.420 --> 01:11:22.760
So your work is so important and just great.


01:11:22.760 --> 01:11:25.080
So yeah, definitely a lot of people out there loving it.


01:11:25.080 --> 01:11:27.060
Okay, let's keep going.


01:11:27.060 --> 01:11:32.560
Back to SQL model, roadmap for the future.


01:11:32.560 --> 01:11:34.120
What are the plans?


01:11:34.120 --> 01:11:38.360
- So migrations, I want to have a small wrapper


01:11:38.360 --> 01:11:41.520
to have a common line interface built on top of Typer


01:11:41.520 --> 01:11:42.760
so that you can get a good completion


01:11:42.760 --> 01:11:45.200
in the terminal as well.


01:11:45.200 --> 01:11:47.820
to have migrations based on Alembic


01:11:47.820 --> 01:11:52.820
to a documentation for using async with SQL mode.


01:11:52.820 --> 01:11:56.860
Async is already supported by SQLAlchemy.


01:11:56.860 --> 01:11:58.520
- Yeah, and that's a new thing, right?


01:11:58.520 --> 01:12:02.240
That is, you've got to create now an async client


01:12:02.240 --> 01:12:03.440
or an async session rather.


01:12:03.440 --> 01:12:06.680
So I think it is sort of a regular session in SQLAlchemy,


01:12:06.680 --> 01:12:09.040
but that's one of the 2.0 big changes


01:12:09.040 --> 01:12:10.600
that Mike just pushed out.


01:12:10.600 --> 01:12:12.680
So that flows through for you?


01:12:12.680 --> 01:12:13.520
- Yeah, yeah.


01:12:13.520 --> 01:12:14.600
Like you can already use it.


01:12:14.600 --> 01:12:17.040
In fact, there's people using it in applications,


01:12:17.040 --> 01:12:18.940
in production applications right now.


01:12:18.940 --> 01:12:22.180
But it's just that I don't have it documented yet.


01:12:22.180 --> 01:12:25.980
SQLAlchemy already supports both the normal,


01:12:25.980 --> 01:12:28.660
the blocking interface, the regular interface,


01:12:28.660 --> 01:12:30.540
and the async interface.


01:12:30.540 --> 01:12:33.080
And you can already use it with SQL model as well.


01:12:33.080 --> 01:12:34.940
I want to document all that.


01:12:34.940 --> 01:12:35.780
- Right.


01:12:35.780 --> 01:12:37.380
So what you should do is you should just change


01:12:37.380 --> 01:12:39.740
your dependency injection based on whether you have


01:12:39.740 --> 01:12:43.300
a def method or an async def method in FastAPI,


01:12:43.300 --> 01:12:46.300
and either create an async client or async session rather,


01:12:46.300 --> 01:12:49.260
or regular session, and then boom, off you go, right?


01:12:49.260 --> 01:12:52.020
- And that is one of the things that I think is so smart


01:12:52.020 --> 01:12:55.000
about the design of SQLAlchemy, that SQL model inheritance,


01:12:55.000 --> 01:12:58.180
is that the thing that handles if it's async or not


01:12:58.180 --> 01:13:01.100
is the engine, not the models themselves.


01:13:01.100 --> 01:13:05.880
So you can use the same models even if it's async or not.


01:13:05.880 --> 01:13:08.800
- Yeah, I agree, very nice.


01:13:12.260 --> 01:13:13.980
Good question by Lars, but I'm gonna keep going


01:13:13.980 --> 01:13:16.100
'cause we're short.


01:13:16.100 --> 01:13:18.620
David Smith asks, "Are there plans to add async?"


01:13:18.620 --> 01:13:19.660
I think the question is,


01:13:19.660 --> 01:13:21.620
are there plans to document async?


01:13:21.620 --> 01:13:23.580
- Yeah, exactly. - That's probably right.


01:13:23.580 --> 01:13:26.660
We kind of touched on this one


01:13:26.660 --> 01:13:29.340
about whether you should use it for an existing,


01:13:29.340 --> 01:13:32.620
like should you be migrating, and we touched on that one.


01:13:32.620 --> 01:13:34.340
I think Brandon Brainer,


01:13:34.340 --> 01:13:37.180
who I think I saw on the audience, yeah, earlier.


01:13:37.180 --> 01:13:38.340
Hey, Brandon, asks,


01:13:38.340 --> 01:13:40.660
"Could you go ahead and make no SQL model?"


01:13:40.660 --> 01:13:45.660
This is a chance for me to mention Beanie out there.


01:13:45.660 --> 01:13:47.240
I wanted to kind of ask you


01:13:47.240 --> 01:13:50.080
if you'd had a chance to look at this.


01:13:50.080 --> 01:13:52.420
What's my best link for this?


01:13:52.420 --> 01:13:54.720
There it is.


01:13:54.720 --> 01:13:56.460
So Roman Wright also was out in the audience.


01:13:56.460 --> 01:13:57.840
I saw them.


01:13:57.840 --> 01:14:01.660
So Beanie is a ODM like for MongoDB,


01:14:01.660 --> 01:14:05.780
but also basically very similar based on Pydantic.


01:14:05.780 --> 01:14:07.400
And so I thought it was a,


01:14:07.400 --> 01:14:10.160
this immediately came to mind when I thought about


01:14:10.160 --> 01:14:13.740
SQL model is like, well, here's the MongoDB version


01:14:13.740 --> 01:14:16.020
that also tries to do the same thing.


01:14:16.020 --> 01:14:18.380
Have you thought about a NoSQL story?


01:14:18.380 --> 01:14:19.300
Have you looked at Beanie?


01:14:19.300 --> 01:14:20.360
What are your thoughts here?


01:14:20.360 --> 01:14:22.900
- Yeah, I really like both.


01:14:22.900 --> 01:14:27.460
There are two alternatives for MongoDB with Bidantic.


01:14:27.460 --> 01:14:30.300
One is Beanie, the other one is Oathmantic.


01:14:30.300 --> 01:14:32.580
I think they are both doing a great job.


01:14:32.580 --> 01:14:36.100
I like this particular thing about Oathmantic


01:14:36.100 --> 01:14:37.820
is that it uses the same style,


01:14:37.820 --> 01:14:39.620
the interface of SQLAlchemy


01:14:39.620 --> 01:14:43.140
that the thing that decides if it's async or not


01:14:43.140 --> 01:14:45.140
is the engine and not the model,


01:14:45.140 --> 01:14:48.420
which means that it will probably be easier to implement


01:14:48.420 --> 01:14:52.300
because both Beanie and Automatic, both are async.


01:14:52.300 --> 01:14:58.820
But having the engine being the one that is async or not


01:14:58.820 --> 01:15:03.700
will allow implementing a regular or blocking version of it


01:15:03.700 --> 01:15:06.740
so that you could have MongoDB models


01:15:06.740 --> 01:15:09.780
that are shared and reused for async code


01:15:09.780 --> 01:15:11.980
and for blocking code in the same application.


01:15:11.980 --> 01:15:15.540
So you can migrate more slowly or things like that.


01:15:15.540 --> 01:15:17.780
But I think both are doing a great job


01:15:17.780 --> 01:15:20.180
and have a very nice interface


01:15:20.180 --> 01:15:22.660
that is very close to Pythonic.


01:15:22.660 --> 01:15:24.060
- Yeah, just as a sidebar,


01:15:24.060 --> 01:15:28.060
I do wish it was easier in Python


01:15:28.060 --> 01:15:31.260
to convert an async call to a synchronous call,


01:15:31.260 --> 01:15:33.460
knowing that it would block.


01:15:33.460 --> 01:15:37.780
just go like, okay, here's a async method.


01:15:37.780 --> 01:15:42.020
If I could just go dot wait or dot result


01:15:42.020 --> 01:15:43.380
or something and just make it execute


01:15:43.380 --> 01:15:45.740
and basically stop the async running from there.


01:15:45.740 --> 01:15:48.620
Then you could just do the query like dot,


01:15:48.620 --> 01:15:50.020
like give me the answer, right?


01:15:50.020 --> 01:15:51.540
Whereas it's a little more tricky.


01:15:51.540 --> 01:15:53.140
You've got to get it like in the loop


01:15:53.140 --> 01:15:55.180
and run the loop to completion and stuff like that.


01:15:55.180 --> 01:15:58.300
- Yeah, but you know, like that's why I just built a asyncer


01:15:58.300 --> 01:16:00.340
which is built on top of any IO.


01:16:00.340 --> 01:16:06.060
And the idea is that you have this function asyncify


01:16:06.060 --> 01:16:09.140
and the function syncify just to do that.


01:16:09.140 --> 01:16:13.140
So you can pass one function that is async,


01:16:13.140 --> 01:16:19.100
and it will be run inside of the main event loop in async way.


01:16:19.100 --> 01:16:21.660
Or you can say, asyncify this thing,


01:16:21.660 --> 01:16:25.140
and it will run the blocking function in a thread pool


01:16:25.140 --> 01:16:28.060
so that it's not blocking the main event loop and all


01:16:28.060 --> 01:16:28.620
this stuff.


01:16:28.620 --> 01:16:30.620
But it's actually, the work is actually all done


01:16:30.620 --> 01:16:31.580
by Any.io.


01:16:31.580 --> 01:16:33.620
It's again, just doing the same thing


01:16:33.620 --> 01:16:35.860
of getting type annotations and auto completion


01:16:35.860 --> 01:16:36.700
and all the stuff on top of the thing


01:16:36.700 --> 01:16:38.820
that is actually doing the work.


01:16:38.820 --> 01:16:41.260
- Yeah, I definitely came across this not long ago


01:16:41.260 --> 01:16:42.340
and it looks very exciting.


01:16:42.340 --> 01:16:43.460
And I wanted to talk to you about it,


01:16:43.460 --> 01:16:45.780
but as you can see, we're way over time already


01:16:45.780 --> 01:16:46.620
for just our main things.


01:16:46.620 --> 01:16:48.820
Let's go back to it, but maybe next time you're on,


01:16:48.820 --> 01:16:51.780
we could just talk about async stuff all day.


01:16:51.780 --> 01:16:53.220
Mike out there asks,


01:16:53.220 --> 01:16:56.420
"What is the risk of using it in production?"


01:16:56.420 --> 01:16:59.060
The risk is the risk that you have


01:16:59.060 --> 01:17:01.920
for using any software in production.


01:17:01.920 --> 01:17:04.300
- Maybe rephrase it.


01:17:04.300 --> 01:17:07.700
So what is the readiness for production, I guess,


01:17:07.700 --> 01:17:10.140
is probably what he was thinking.


01:17:10.140 --> 01:17:12.700
- Yeah, so the thing is, most of the work


01:17:12.700 --> 01:17:14.460
is done by Pagliantic and SQLAlchemy,


01:17:14.460 --> 01:17:16.900
and they have been used for years,


01:17:16.900 --> 01:17:18.820
and they are doing an amazing job,


01:17:18.820 --> 01:17:21.300
and they are already used by a lot of tools.


01:17:21.300 --> 01:17:25.420
SQLModel only does a little bit of extra stuff on top,


01:17:25.420 --> 01:17:27.260
just so that you're gonna need all the type annotations.


01:17:27.260 --> 01:17:29.380
Most of the work is done by those.


01:17:29.380 --> 01:17:34.380
The other thing is that the test coverage is at 97%.


01:17:34.380 --> 01:17:36.140
So you have some certainty


01:17:36.140 --> 01:17:38.900
that it's working as intended at least.


01:17:38.900 --> 01:17:41.300
I want to have it at 100%


01:17:41.300 --> 01:17:44.800
and I want to have tests in continuous integration


01:17:44.800 --> 01:17:46.500
with several databases,


01:17:46.500 --> 01:17:49.620
because right now the tests are only run in SQLite.


01:17:49.620 --> 01:17:51.780
But you know that all the SQL stuff


01:17:51.780 --> 01:17:53.060
is actually done by SQLAlchemy,


01:17:53.060 --> 01:17:55.780
which is already tested in all the databases.


01:17:55.780 --> 01:18:00.420
So, you know, like there's this trade-off


01:18:00.420 --> 01:18:03.020
of trying this thing that still has


01:18:03.020 --> 01:18:04.880
a little bit of extra stuff to do.


01:18:04.880 --> 01:18:08.180
But most of the extra things that I will do


01:18:08.180 --> 01:18:11.060
on top of SQL model are actually documentation.


01:18:11.060 --> 01:18:13.180
Not that much code changes.


01:18:13.180 --> 01:18:15.260
- And the ability to flip from one to the other


01:18:15.260 --> 01:18:17.700
pretty quickly means if you had to say,


01:18:17.700 --> 01:18:19.620
"Oh no, this isn't working out, we're switching back."


01:18:19.620 --> 01:18:22.380
It's not like, "Oh, well, you're completely rewriting it."


01:18:22.380 --> 01:18:23.500
- Yeah. - It's not that much work.


01:18:23.500 --> 01:18:25.460
- You just have to make sure that you pin the versions


01:18:25.460 --> 01:18:28.780
and you upgrade correctly, but otherwise it should work.


01:18:28.780 --> 01:18:31.940
And you will get more certainty about the code correctness


01:18:31.940 --> 01:18:34.460
because you have all the type help.


01:18:34.460 --> 01:18:36.120
So yeah. - Yep.


01:18:36.120 --> 01:18:37.920
All right, we got one question left.


01:18:37.920 --> 01:18:42.740
You have this ability to take


01:18:42.740 --> 01:18:46.860
what are often somewhat existing APIs


01:18:46.860 --> 01:18:50.580
and then improve them in ways


01:18:50.580 --> 01:18:52.360
that people really connect with, right?


01:18:52.360 --> 01:18:56.180
Like FastAPI didn't start from open TCP socket


01:18:56.180 --> 01:18:57.140
and let's start from there.


01:18:57.140 --> 01:18:59.560
It started on top of Starlet, right?


01:18:59.560 --> 01:19:01.880
Like you already mentioned Tom Christie.


01:19:01.880 --> 01:19:04.660
This is on top of two very important libraries


01:19:04.660 --> 01:19:08.540
that they should go together, but didn't.


01:19:08.540 --> 01:19:11.200
So the question Pierre asks is,


01:19:11.200 --> 01:19:13.500
how did you learn to sort of come up with APIs


01:19:13.500 --> 01:19:14.600
like you have?


01:19:14.600 --> 01:19:18.000
Like what's your recipe for building this?


01:19:18.000 --> 01:19:22.040
- I think the thing is that I have been always


01:19:22.040 --> 01:19:24.140
trying to solve a problem.


01:19:24.140 --> 01:19:26.980
And I have always trying to improve


01:19:26.980 --> 01:19:29.300
my own developer experience and to improve the way


01:19:29.300 --> 01:19:31.220
that things work for me.


01:19:31.220 --> 01:19:33.860
And like, I have ended up just like trying to understand


01:19:33.860 --> 01:19:36.020
what is the best way to achieve those things.


01:19:36.020 --> 01:19:39.180
And at some point I ended up learning a little bit


01:19:39.180 --> 01:19:40.780
of type annotations.


01:19:40.780 --> 01:19:43.560
And I realized that, hey, this can be super powerful.


01:19:43.560 --> 01:19:44.940
I can reuse it for different things.


01:19:44.940 --> 01:19:47.460
And after looking and looking for different frameworks


01:19:47.460 --> 01:19:50.220
that did what I wanted, I ended up like saying like,


01:19:50.220 --> 01:19:53.980
OK, I just have to build this because it doesn't exist yet.


01:19:53.980 --> 01:19:57.020
But it was just like trying to achieve getting the thing


01:19:57.020 --> 01:19:57.940
that I want.


01:19:57.940 --> 01:20:03.300
For example, I wouldn't go and build a NoSQL model for MongoDB


01:20:03.300 --> 01:20:05.260
because there's already Beanie and Nodemantic.


01:20:05.260 --> 01:20:08.580
They are already solving the problem.


01:20:08.580 --> 01:20:11.540
I tried to avoid building new things.


01:20:11.540 --> 01:20:14.460
But when there's the case that nothing is really


01:20:14.460 --> 01:20:17.260
solving the thing that I want to have,


01:20:17.260 --> 01:20:19.980
I go and try to build it.


01:20:19.980 --> 01:20:23.700
The other thing is, I think one of the main features


01:20:23.700 --> 01:20:26.140
about these tools is just the documentation.


01:20:26.140 --> 01:20:28.900
And I guess like the only thing about that


01:20:28.900 --> 01:20:32.860
is that I write it as I will have liked to learn


01:20:32.860 --> 01:20:35.880
those things when I was just starting,


01:20:35.880 --> 01:20:39.140
I'm not struggling to understand where all these things.


01:20:39.140 --> 01:20:40.620
And I always have in mind like,


01:20:40.620 --> 01:20:44.940
how will the newbie learn the thing and understand it?


01:20:44.940 --> 01:20:47.780
I guess that's probably the main thing that I'm trying to,


01:20:47.780 --> 01:20:50.520
to make it as easy to use as possible.


01:20:50.520 --> 01:20:53.640
- Yeah, I feel there's a strong blend of like,


01:20:53.640 --> 01:20:55.940
let's take the new things that are really useful


01:20:55.940 --> 01:20:57.180
that maybe not everyone's using


01:20:57.180 --> 01:20:58.460
and make them very accessible,


01:20:58.460 --> 01:21:01.500
make them very easy and default and so on, yeah.


01:21:01.500 --> 01:21:03.780
- Yeah, that's the value spirit, I think.


01:21:03.780 --> 01:21:05.360
- Yeah, absolutely.


01:21:05.360 --> 01:21:08.300
All right, well, that's all the questions.


01:21:08.300 --> 01:21:09.340
We've been going a little bit long,


01:21:09.340 --> 01:21:11.260
but I really appreciate the time.


01:21:11.260 --> 01:21:15.020
Let's just real quickly ask you the final two questions


01:21:15.020 --> 01:21:16.320
and let you get out of here.


01:21:16.320 --> 01:21:17.160
All right. - Awesome.


01:21:17.160 --> 01:21:19.580
So if you're gonna write some Python code,


01:21:19.580 --> 01:21:21.540
work on SQL model or something else,


01:21:21.540 --> 01:21:23.340
what editor do you use these days?


01:21:23.340 --> 01:21:27.160
- I think the both main editors,


01:21:27.160 --> 01:21:30.480
Visual Studio Code and Python are doing an amazing job


01:21:30.480 --> 01:21:32.220
at supporting all these tools.


01:21:32.220 --> 01:21:37.220
Right now my main one is Visual Studio Code,


01:21:37.220 --> 01:21:39.740
but yeah, I will just--


01:21:39.740 --> 01:21:41.480
- Yeah, right on.


01:21:41.480 --> 01:21:43.280
Okay, very good, very good.


01:21:43.280 --> 01:21:45.320
And then notable PyPI packages,


01:21:45.320 --> 01:21:46.920
I feel like we touched on these a little bit, but--


01:21:46.920 --> 01:21:48.200
- Yeah, we just mentioned them,


01:21:48.200 --> 01:21:52.440
Oathmantic and Beanie for doing the same SQL model stuff,


01:21:52.440 --> 01:21:54.280
but for MongoDB.


01:21:54.280 --> 01:21:55.120
- Yeah, right on.


01:21:55.120 --> 01:21:57.320
I agree, those are both great.


01:21:57.320 --> 01:21:59.840
All right, Sebastian, it was great to have you back


01:21:59.840 --> 01:22:02.780
and congratulations on SQL model.


01:22:02.780 --> 01:22:04.120
Maybe next time we'll talk async.


01:22:04.120 --> 01:22:05.020
What do you think?


01:22:05.020 --> 01:22:06.080
- Awesome, sounds great.


01:22:06.080 --> 01:22:07.560
Thank you very much, Michael, for inviting me.


01:22:07.560 --> 01:22:10.200
Thank you everyone for staying this long.

