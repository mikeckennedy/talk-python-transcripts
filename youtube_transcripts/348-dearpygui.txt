00:00:00 Jonathan, Preston, welcome to Talk Python To Me.

00:00:04 - Glad to be here.

00:00:05 - Hey, it's great to have you guys here.

00:00:08 I'm very excited to talk about GUIs and UI frameworks and stuff like that.

00:00:15 I think Python needs more of it and we're building some cool projects, cool frameworks there.

00:00:21 It'll be fun to talk about it.

00:00:26 We're gonna talk about DeerPyGUI, which is one of these frameworks that's not over-involved with too much going on and tries to have a quick getting started story, right?

00:00:38 - That is correct.

00:00:40 - Right on.

00:00:41 Yeah, I'm really looking forward to talking about it.

00:00:42 Before we do though, let's just get into your stories and hear a little bit about, since there's both of you, maybe not too extended, but Jonathan, how'd you get into programming in Python?

00:00:51 - So I got into programming when I was around 13 years old.

00:00:59 my stepdad and mom got me a C++ for Dummies book.

00:01:03 - Okay.

00:01:04 - And worked with that for a while until, just kind of as a hobby project, or as a hobby thing.

00:01:12 And once I got to college, I went into mechanical engineering, which is also where I met Preston.

00:01:20 And there, they typically like to use MATLAB, which everybody knows isn't a real programming language, because the indices start at one.

00:01:30 But as an alternative to that, came across Python.

00:01:35 You know, it had a lot of the same features, actually a lot more features than MATLAB, and it was free, so didn't have to pay for the MATLAB license.

00:01:49 - MATLAB's expensive.

00:01:50 For people who haven't messed with it, it's like really expensive outside the student story.

00:01:56 >> It is, and you have to use their entire environment and everything just to use it.

00:02:03 Aside from that, on top of that, with the Raspberry Pi, it's into electronics and things like that.

00:02:12 The Raspberry Pi are able to control the GPIO pins using Python.

00:02:17 Naturally, I just started playing with Python from there.

00:02:22 That's pretty much where Python came into my picture.

00:02:25 - Yeah, really cool.

00:02:27 So you said you were in chemical engineering?

00:02:29 Is that what it was?

00:02:29 - Mechanical.

00:02:30 - Mechanical, okay.

00:02:31 I was in chemical for a little while, and they said that, I asked if I could take a C++ class.

00:02:37 They said, "You can as an elective, "but you have to take Fortran "'cause that's gonna be the most important language "you'll ever learn," I thought.

00:02:42 - Wow. - I'm just jealous.

00:02:43 I mean, MATLAB is not that amazing, but I'll tell you what, it's better than Fortran.

00:02:47 - That is very true.

00:02:48 We occasionally have to use Fortran at work with some of our FEA programs, and finite element analysis programs with Abacus, you're able to extend it with Fortran.

00:02:58 So occasionally we have to look at a little bit of Fortran to do that.

00:03:01 And it's ugly.

00:03:02 Yeah, for sure.

00:03:04 Preston, how about you?

00:03:06 Mine was mostly junior year in college, MATLAB course.

00:03:11 Incidentally enough, that's why it's not a real programming language, right?

00:03:14 So I moved from that directly into Python about when I started my first job And just kind of started working with C++ after that.

00:03:23 And then kind of tailed into a little bit of C, not much.

00:03:30 Right on.

00:03:30 What are you all doing now?

00:03:32 Sounds like still engineering work.

00:03:35 Yeah, both doing engineering.

00:03:36 So I'm doing mechanical engineering.

00:03:38 I do design on threaded connectors, foil and gas industry.

00:03:44 mainly designing the seals and threads that hold production tubing together down hole that actually sends the oil up through the well.

00:03:55 Wow.

00:03:56 So you must be talking about a lot of pressure, talking about materials that would like to destroy rubber and other things as well, possibly.

00:04:06 Yeah, so I guess that tails into coding.

00:04:09 Mainly, I use most of Python to just extend out, like we were talking about for scripting and stuff like that.

00:04:17 Yeah, right on.

00:04:19 Jonathan, how about you?

00:04:20 So I started out in the same position and slowly moved into the software side of things.

00:04:28 A lot of that's working with Preston and some of the other mechanical engineers on extending some of those applications like Abacus and that's using Python or extending AutoCAD and C++.

00:04:42 So there's that side of the day-to-day work.

00:04:44 And then the other side is we actually have some internal software that we work on, one for inspecting connections without contact, so using lasers and robot arms and all that stuff to basically just take measurements instead of having to go out and manually do it.

00:05:05 This is great.

00:05:06 Be on an assembly line.

00:05:08 And most of that's in C++ and C.

00:05:12 We do use our library, DeerPiGUI, for a lot of the prototyping and some of the tooling for the project.

00:05:20 But--

00:05:21 >> That's cool.

00:05:21 >> --more projects in C and C++.

00:05:24 >> Sure.

00:05:25 I don't think I've really covered mechanical engineering on Talk Python properly.

00:05:31 What's the story with software automation and that kind of stuff?

00:05:35 that mostly using programs like, sounds like this Abacus one, versus writing your own software and doing your own automation?

00:05:43 - Right.

00:05:44 A large part of mechanical engineering is, at least in our field, is stress analysis and computational fluid dynamics, fluid flow type problems.

00:05:57 And as far as software goes, it's usually in relation to that, like Abacus is, as an example, a software package for stress analysis.

00:06:08 And then there's other ones, OpenFoam.

00:06:11 - Yeah, OpenFoam.

00:06:12 You wrote some solvers at your first job for that.

00:06:14 - Yeah, that's correct.

00:06:17 We took some electives while we were in college and some of those were for writing these solvers.

00:06:23 And most of those you could write whatever you want.

00:06:25 Those professors didn't actually care.

00:06:26 And a lot of times I wrote it in Python or most of the time it was Python, I would say.

00:06:31 - Yeah, yeah.

00:06:32 What's the story for packages, you know, PyPI type of things in your space?

00:06:38 - As far as what we used or what we used?

00:06:40 - Yeah, is there a lot of stuff out there?

00:06:42 I know, for example, astronomy is filled with libraries like Astropy and whatnot that people could just grab and use.

00:06:50 - For mechanical engineering, I don't know if there's, I mean, NumPy or NumPy, you know, But as far as specific to mechanical engineering, I really don't think there's any.

00:07:04 There may be a few FEA solvers, but I don't think they're maintained or well documented for sure.

00:07:09 - Right.

00:07:10 - Would you say any?

00:07:11 - We typically found that a lot of engineers end up staying in the MATLAB realm and not really venturing into any more hardcore languages.

00:07:22 So they end up using all, because a lot of them want symbolic math, like integration and ODE solvers and all of that.

00:07:34 It's all right there in MATLAB.

00:07:36 And then the companies typically pay for it.

00:07:38 So you're kind of in that realm.

00:07:40 - Right, and once some group gets embedded in there, it's just gonna stay in that space unless somebody takes some effort to get it out.

00:07:47 All right, awesome.

00:07:48 Thanks for that background.

00:07:49 Although we're not here exactly to talk about deep dive in mechanical engineering, it is cool to get a look.

00:07:55 So let's talk about this.

00:07:59 Let's talk about your project, DeerPi GUI.

00:08:02 So when I think of the GUI, graphical user interface space in Python, well, there's TK Enter, there's PyQt, there's a few other things, but they all have some kind of oddity about them.

00:08:23 There's not like one framework that people just like, yeah, we're just gonna use that thing.

00:08:26 It's not like Swift and Objective-C, Cocoa controls would be in say a iOS app or something, where it's really clear, just generally use that one.

00:08:37 So I guess, where did you guys get started working on GUIs in Python?

00:08:43 And then what was the goal with the DeerPi GUI?

00:08:47 Like where does it stand out?

00:08:48 Where does it fit in this space?

00:08:50 - All right, so I got started in UIs working at one of my internships while I was in school.

00:08:58 And we were using this package, which I think I already mentioned once, OpenFOAM for CFD.

00:09:05 And it didn't have a front-end interface at all.

00:09:10 It was a C++ solver that just--

00:09:13 pretty sure just output text files in the end.

00:09:15 I don't remember.

00:09:16 It's been about six, seven years.

00:09:19 So started to use--

00:09:21 wanted to build a UI so that the other engineers could use it.

00:09:24 And at that time, I was just getting into it.

00:09:26 So I used Tkinter because it comes with Python.

00:09:31 And then also used VTK, if I remember correctly.

00:09:37 And I would say that's the first experience I had with it.

00:09:41 And then our senior design project--

00:09:44 I'd be impressed if we're also on the same team for that--

00:09:47 was to build an arc welding 3D printer.

00:09:52 OK.

00:09:53 So it actually created things by doing arc welding?

00:09:57 >> Right.

00:09:58 >> Rather than printing some other sort of material out of it?

00:10:02 >> Correct.

00:10:02 Yeah, it was a MIG welder.

00:10:05 I was on the software side of that.

00:10:07 Preston was on a lot more of the physical side.

00:10:09 >> We should put him in the software for now.

00:10:10 >> So anyway, that was the goal of the project.

00:10:15 And we used some open source slicing software.

00:10:19 I don't remember-- it was like Slic3D or--

00:10:21 >> But it's 3 for the E.

00:10:23 Yeah, Slicer, and it had three for the E.

00:10:26 And we basically modified that and ran it in a headless mode and built a UI on top of it using the Kinter.

00:10:34 And I want to say we used Pygame to be able to access OpenGL.

00:10:39 And at the time, we were using Legacy OpenGL.

00:10:41 That was our first experience with, I guess, graphics APIs.

00:10:47 >>Yeah.

00:10:47 >>Which--

00:10:48 >>Yeah, OpenGL is pretty neat.

00:10:51 it was certainly good when it first came out, it was as good as anything else, but I feel like it hasn't been getting the same amount of growth and adoption, maybe some of the other frameworks, DirectX and Metal and so on.

00:11:05 - Right, and a lot of that, we've been using it, DeerPi GUI uses DirectX, Metal and OpenGL at the moment.

00:11:15 And so we've been using a lot of them over the last few years.

00:11:20 And the biggest reason for that is just that the hardware's changed since those APIs were created and they no longer directly match the hardware.

00:11:33 - Right.

00:11:33 - Yeah.

00:11:36 - Yeah, so DeerPi GUI came out of trying to basically build something better than direct OpenGL access.

00:11:48 What'd you say?

00:11:50 or direct framework access?

00:11:52 Not quite.

00:11:54 It came more out of a...

00:11:56 So, I guess going back to answering where DPG itself came from.

00:12:02 We had a previous project that we worked on, a commercial project called Engineer Sandbox, that was...

00:12:08 The program had an embedded Python interpreter in it, and you basically created little mechanical engineering apps and we could create one in, I don't know, an hour or two.

00:12:24 And it was just this collection of apps.

00:12:26 And over time, it started to get a little annoying to have to recompile it, essentially before we added Python.

00:12:34 We added Python because we were getting tired of recompiling it every time we wanted to add an app or modify something and have to redeploy.

00:12:42 So from there we embedded Python and it was very limited.

00:12:48 You were able to create a few small apps.

00:12:51 It really wasn't a full GUI library.

00:12:55 And what happened is we were trying to sell it.

00:12:59 It didn't really work out.

00:13:01 We could never really catch traction.

00:13:02 We had some users and customers, but most people weren't really interested in it.

00:13:08 And developers aren't really interested in paying for libraries or any SDK.

00:13:13 Most of them, they just want it to be free.

00:13:16 So that just kind of fell out.

00:13:19 And we gave up on that after about--

00:13:20 >>Luis: That's a tough place to be, right?

00:13:21 You want to put a lot of energy into building tools and making stuff for people.

00:13:26 But how do you put enough time into it, right?

00:13:30 If people just want it to be free, I mean--

00:13:34 - Maybe what we gotta do is, maybe the world is the VS Code model where there's large companies that have other motivations for creating it rather than directly funding through that.

00:13:47 But that's a deeper conversation.

00:13:50 - Selling to developers in the easy is the key point there.

00:13:54 - Yeah, for sure.

00:13:56 - We did keep it in-house and we continue, we still have apps written in it at our day job.

00:14:00 And we ended up revisiting it because it didn't do everything we wanted to do.

00:14:05 And we said, well, this time let's target developers from the beginning.

00:14:08 So it's not going to be very limited.

00:14:10 It's going to be-- you should be able to do most things you can do in any other UI library.

00:14:15 And on top of that, make it free.

00:14:17 And that's kind of where your PyGUI came from.

00:14:21 And between those stages, we had came across the library I'mGUI or mGUI, which I'm not sure if you're familiar with.

00:14:30 But--

00:14:31 Yeah, I'm not familiar with it.

00:14:32 What is this?

00:14:34 - It is a-- - IMGUI.

00:14:36 - It is an extremely popular immediate mode graphical user interface for real-time applications.

00:14:44 It's--

00:14:47 - C++.

00:14:48 - Usually used--

00:14:49 - C++.

00:14:49 - Yes, it's C++.

00:14:50 - Yeah, yeah, yeah.

00:14:52 - But it's kind of a weird, I mean, it's an immediate mode interface and there's not many, I would say there is no Python user interface that's like that.

00:15:01 - Right.

00:15:06 So maybe we should talk about the different modes real quick since you bring it up is immediate mode versus retained mode.

00:15:13 What's the, what are those two worlds like?

00:15:17 What does that mean?

00:15:19 - Well, I take this one.

00:15:21 So I don't want the internet to jump on me here because there's a lot of, a little bit of argument there.

00:15:29 a few key points, I think, that really make it stand out.

00:15:32 One of those is that the state is not retained.

00:15:38 So if you have a slider that controls a float, you don't have to basically have a float stored on your side and a float stored in the UI, and you're constantly having to deal with keeping them up to date and things like that.

00:15:54 Instead, the library itself doesn't store that at all.

00:15:59 Now, the way it's implemented is a little different.

00:16:01 But I'm talking about from the user side of using an immediate mode library.

00:16:05 It doesn't retain any state.

00:16:08 The other big thing is that, at least with--

00:16:13 especially with onGUI, is the UI items and widgets are submitted every frame, so 60 times a second.

00:16:20 And that gives you a credible amount of dynamicism, I guess you'd call that, to be able to do a lot of things.

00:16:28 And you can completely redo the UI on a per frame basis.

00:16:31 >> Yeah, as opposed to something where maybe you say a text box goes here and a button goes there, and then set the text to the button.

00:16:42 And then the button knows what its text is.

00:16:44 This is almost like a game loop type thing, where each time, whatever the frame rate is, 50, 60, 200 frames a second, it's like, draw the UI, draw the UI, draw the UI, right?

00:16:57 - Yep, and that's-- - It's really interesting that that kind of 60 frames a second can lead into what we just put in a few weeks ago, talking about not redrawing the GUI every 60, every frame.

00:17:09 - Right, that's a good point.

00:17:11 One of the issues we had, especially early on with some users complaining is, well, do you need to update everything every frame, 60 times a second.

00:17:20 So we did recently add in 1.1 the ability to basically only update if there is some user input, whether that's moving the mouse, resizing the window, things like that, because a lot of people, they complain.

00:17:34 >> Well, it helps a lot to be more energy conscious with having your GUI run all the time.

00:17:39 >> Right, which you might care about, say, on a laptop or a tablet, but less so if you're plugged into the wall.

00:17:47 - Correct.

00:17:48 - Yeah, interesting.

00:17:49 Yeah, and even some of the new, what are they, ProRes displays for like the new MacBooks and stuff.

00:17:56 Like the entire display will slow down if stuff is not happening.

00:18:00 And I wonder if maybe, if you had a GUI app that was running, refreshing the screen a lot, maybe it would prevent it from actually going into a slower mode, you know?

00:18:14 - Yeah, something to look into, how the variable refresh rate plays into the software actually rendering.

00:18:20 - Yeah, yeah, yeah.

00:18:21 I don't really work at that level, so I don't really know for sure, but it's kind of all in the same space a little bit, right?

00:18:27 Cool, okay, so it looks to me like that some of the, there's some similarities from the IAMGUI in terms of the UI look and feel, but then you've got the retained mode versus immediate mode and things like that.

00:18:42 What's the relationship between these?

00:18:44 >> So, I'm GUI itself just outputs, you can read as read me, but outputs an optimized vertex buffer.

00:18:53 It sends basically the coordinates and everything needed to draw the UI, but it is up to you to take that and actually do something with it and render it.

00:19:02 So, we use I'm GUI to basically create those vertex buffers.

00:19:08 As far as the retain mode stuff, Originally, we were kind of doing more of a one-to-one wrapping with that library.

00:19:16 And we started to hit some performance issues with Python itself, just because, I mean, 60 times a second, if you're having to do a lot of conversions between, you know, maybe the Python types and the underlying C types, you know, that can slow things down.

00:19:34 Also, just the GIL gets in the way with a lot of different things.

00:19:39 So what we did with the retain mode is we basically just kind of created a barrier between that where we do go against the immediate mode style thing and we have --

00:19:50 we do keep up with things like the underlying values, just the floats, the, you know, the ints, the strings, whatever it is.

00:19:58 So it kind of goes back to a more retain mode, which is what every other library is that, you know, most Python users would be used to.

00:20:07 The float actually stores a-- or sorry, an input text has its underlying string, and you can get that value, set that value.

00:20:15 >>Yeah, a lot of UI code, you don't even need to have necessarily some variable that holds the thing, right?

00:20:24 You might just put it in the button, and if you need it back, you could get it from the button, potentially, right?

00:20:29 >>And that's how it works.

00:20:32 I guess one of the only other things that's kind of neat is underneath, it is just a raw--

00:20:38 I'm pretty sure probably using Smart Pointer.

00:20:40 And you can actually link a lot of these widgets together to where they're truly controlling the same value.

00:20:45 And you can get some pretty cool effects with that to where directly moving--

00:20:52 this slider is updating the plot.

00:20:54 And there's not some update code that's having to happen or any callbacks.

00:20:59 It's just that they're truly the same value.

00:21:01 And because we're updating 60 times a second, you're able to see those changes live, which is pretty neat.

00:21:07 And you can create some pretty cool stuff with that.

00:21:09 - Yeah, that's fantastic.

00:21:10 Before we jump into some of the details, if you visit the GitHub page, which of course I'll link to, let's maybe just talk through some of the features, I guess.

00:21:21 I was gonna go to the gallery, but maybe the features is a better place to start.

00:21:25 You guys have this engineering background.

00:21:29 It feels like a lot of what this creates and allows us to build real easily, has this engineering sort of visualizing aspect to it.

00:21:39 Right?

00:21:40 - Right.

00:21:41 - Yeah, yeah.

00:21:42 So maybe talk us through some of the features and things you can do.

00:21:45 So for example, one of the things you have, you can see right at the top of the feature section is the IAM plot stuff, which looks like really interactive and dynamic, all plots and graphs and pie charts and so on.

00:22:00 - Right.

00:22:01 >> It's another immediate mode interface that a guy that wrote it, Evan Peasant, I'm not sure how to pronounce his last name, who also happens to be located here in Houston, wrote it on top of AMGUI and tried to model that immediate mode interface.

00:22:18 So again, you get all the same dynamic features that you get with AMGUI itself.

00:22:24 And that's why you can see on here a lot of the, just how crazy dynamic it looks, right?

00:22:29 the live querying and everything you see there.

00:22:34 And obviously, we, again, built on top of it because we have to go from that immediate mode to retain mode style.

00:22:41 And I mean, you have multiple axes.

00:22:45 You have drag and drop support, custom drag and drop support.

00:22:51 There's a lot of series you don't see there.

00:22:53 Candlesticks, shaded series, stem plots.

00:22:59 >> What looks really good is this one down here that has this full zoomed out graph and then a graph below it, that as you pan around and zoom in, you can actually, it's like a high level and then a low level or zoomed in detailed view, what you're exploring there.

00:23:20 >> Yeah. That's pretty cool feature.

00:23:23 We actually have that in the demo as well.

00:23:24 That's actually not technically built in.

00:23:26 >> Well, yeah. That's a query region, So you have to set up another plot with the same data.

00:23:32 - Yeah, cool.

00:23:33 Also looks like they have animations and stuff.

00:23:37 The one below it, sort of just cruising by without any interaction.

00:23:41 So are you able to just sort of feed it live data and it just keeps refreshing, I guess 60 frames a second or something?

00:23:47 - Yeah, I mean, that's exactly how it's working because it's again, already updating 60 times a second.

00:23:52 All you're doing is changing the data And just by default, you basically get an animation.

00:23:58 >>Right, right.

00:23:59 If the data changes, it's going to re-render it no matter what.

00:24:02 And so then it gets a different picture, right?

00:24:04 >>It's worth noting that it's only 60 frames a second.

00:24:08 If you use VSync with your screen, it actually runs as fast as your screen can run.

00:24:13 So 144 to whatever hertz your monitor is on.

00:24:17 >>Interesting.

00:24:18 >>Depends on your GPU and everything else.

00:24:20 >>Yeah.

00:24:20 >>You have full control of the render loop.

00:24:23 So you can actually slow it to whatever exact frame resolution you want.

00:24:26 You could 30, whatever you want.

00:24:27 >>Right, right.

00:24:28 You probably can't exceed your monitor, but you could slow it down or do something, right?

00:24:33 If you need to--

00:24:35 >>Well, you can.

00:24:35 It just won't--

00:24:37 >>I mean, the effect of people seeing it, they won't see it in your eyes.

00:24:41 >>Right, yeah.

00:24:42 >>And that, yeah.

00:24:42 That's really cool.

00:24:43 Cross-platform.

00:24:47 >>There are some cases--

00:24:48 yeah, it is cross-platform.

00:24:50 But I was going back there.

00:24:51 There are some cases where we will turn Vsync off to just test how fast certain things are happening.

00:24:57 >> Right, because you want to know what's the performance upper limit of this, regardless of the screen, right?

00:25:04 >> Right, and a lot of people love to send us messages with that while they're trying to do something like update a texture or something as fast as they can, and trying to get 300 or 400 frames a second.

00:25:16 So it's pretty neat to see that.

00:25:18 >> Yeah, that's fantastic.

00:25:21 So let's see, what else should I highlight in here?

00:25:25 These are all, there's a bunch of graphs.

00:25:26 I think people really just need to go see them, but there's nice heat map looking things.

00:25:31 There's some statistical stuff.

00:25:33 I mean, anything else you wanna kinda shout out on the--

00:25:36 - Yeah, there's some candlesticks.

00:25:38 We've seen some great interaction with some APIs through some actual cryptocurrency interfaces people have done.

00:25:45 They've made crypto wallets, which is pretty cool.

00:25:47 We've seen some of that.

00:25:48 - Yeah, so we've seen probably maybe 10 of those.

00:25:49 So it is a lot of people seem interested in that.

00:25:53 - Interesting.

00:25:54 Yeah, so people are using DeerPi GUI to build something like a dashboard trader application.

00:26:02 - A lot of dashboards, yeah.

00:26:04 - Okay.

00:26:05 - I'm seeing a lot.

00:26:06 - Yeah, I think that's maybe, we can pull in a comment from the audience, Mr. Hypermagnetic, hey, good to see you again.

00:26:13 There's always been curious why not use HTML for desktop GUIs.

00:26:18 And then also adds that these are definitely nice looking graphs and user interface, which is cool.

00:26:23 Maybe I'll let you all take a shot at answering that question for you.

00:26:28 And I'll--

00:26:29 - Why not use HTML?

00:26:32 Can you go for that one or?

00:26:36 - I mean, if you want that, if not, I could throw something out there as well, 'cause I do as well.

00:26:41 - I mean, you could, I guess.

00:26:47 I mean, I know that's kind of what--

00:26:51 - We've got a ton of electron apps.

00:26:53 - I don't know how to answer that one.

00:26:54 - We got a ton of electron apps that fit that realm.

00:26:58 - That's what I was gonna bring up with electron.

00:26:59 - We got VS Code and other things, Slack and whatnot.

00:27:03 I think there's a couple areas that you would care about.

00:27:08 One is you probably are not gonna be getting 300 frames a second refresh rate with HTML, right?

00:27:16 There's a lot of layers in there.

00:27:18 If you wanna take advantage of the GPUs in like deep ways, right, if you wanna push a mesh of objects in there and then have them re-rendered, right, that's not really what HTML is for.

00:27:32 And then, yeah, I think the sort of native integration also gets tricky, right?

00:27:38 I don't know about Jirapai GUI, but you wanna integrate with the menu bar and other stuff, right?

00:27:43 Like it's not exact.

00:27:46 You need the hardware access.

00:27:48 Now, you can use WebGL, but basically, you'd be using HTML just to create that GL canvas.

00:27:56 And then after that, it's the same thing as what we're doing now.

00:28:01 So you could do that.

00:28:01 I think we have some sample projects where we use that.

00:28:05 And you can get 60 frames a second higher.

00:28:07 But again, you're just using HTML just to get to the canvas.

00:28:10 And then after that, the HTML's gone.

00:28:13 - Yeah. - We're not using it for anything.

00:28:15 - Let me see here if I can get a quick read on, say like a VS Code here, hold on.

00:28:21 Little activity monitor doesn't update very quickly.

00:28:28 So for example, like I just launched VS Code and it's doing nothing.

00:28:32 And there's one, two, three, four, five, six, seven, eight, nine, 10 processes running VS Code, which quick math across those looks like something like 350 megs of RAM, which is, I don't know what Jeep I GUI would take, but I suspect it would be far lower than that.

00:28:52 - It should be much lower.

00:28:53 - Yeah.

00:28:54 - And that's another thing too, by offering, you know, by having to run through the browser, I mean, there's your tech stat becomes, you know, considerably deeper when we're trying to be as light as possible.

00:29:06 - Yeah.

00:29:07 Yeah.

00:29:08 If you want to do a lot of the stuff that we're seeing on the screen here, you're almost down to rendering directly on Canvas.

00:29:13 And then at that point, there's not a huge value for the HTML side of thing, because you're just drawing pixels anyway.

00:29:20 So to sort of wrap that up, Mr. Hypermagnetic says, right, I've seen performance issues with Electron versus more native apps.

00:29:28 Antonio out there-- hey, Antonio, good to see you--

00:29:31 loves these plotting features.

00:29:33 He's also in the oil and gas industry, so very, very cool.

00:29:36 - Great.

00:29:37 And following up on that, John says, there's also a limitation to threading and concurrency, which you definitely have more control, right?

00:29:46 Like multi-processing and so on.

00:29:49 It's pretty neat.

00:29:50 Although Python itself is not known for its massive taking advantage of multi-core stuff because of the GIL.

00:29:57 Still, you've got a little more flexibility.

00:30:00 Cool, it's always interesting to think about.

00:30:03 Now, let's see, let's scroll down and look through a few more of these pictures here.

00:30:07 So you've got this node editor.

00:30:11 And this node sounds like a sort of core thing in this UI framework.

00:30:17 Tell us about that.

00:30:19 >>That's another one of those libraries that somebody had built on top of on GUI.

00:30:26 It's usually just a single file.

00:30:28 I mean, they're pretty light.

00:30:31 And a lot of people made some really cool stuff with that.

00:30:36 'cause you could put any widget that's in the UI library in these nodes and--

00:30:41 - So let me take a shot at trying to describe what this looks like for people listening.

00:30:45 You can check it out under node editor on the GitHub page.

00:30:48 So you've got, it almost looks like a database diagram where you've got relationships between these nodes, but instead of just having table info, you can have things like you've got graphs, You've got XY values, you've got other little bits of computation and stuff that are visually in the nodes that are also connected together.

00:31:12 That looks pretty cool.

00:31:14 - Kind of like a data flow thing, which is the actual picture you're looking at is a tool we built here at work to prototype some of the systems that we were working on here.

00:31:25 So we took a little piece of that as the snapshot.

00:31:27 - Right on.

00:31:30 But yeah, it's a pretty cool feature.

00:31:32 A lot of people do a lot of cool things with it.

00:31:35 - So it was the idea I could build a little section that will take in some, like let's say, fluid flow rate and then apply some algorithm and visualize that, but then it also has an output value that can be passed on to some other part of a simulation that's also shown up there and stuff.

00:31:53 Is that my understanding right?

00:31:55 - That's it.

00:31:56 And you can redirect the inputs from one to the output of the other for whatever widget that are being connected, whether it be a slider, and end to input, or radio box, any of those.

00:32:12 >> And it's a pretty low level.

00:32:14 Some of this stuff can be a little bit misleading when you look at it and say, well, it looks like it should just come right out of the box.

00:32:21 And most of these are not.

00:32:23 For instance, this node editor that you're looking at, in general, you create these nodes.

00:32:28 and when a user tries to grab one of the pins and link it to another one, the callback is ran and it's up to the actual user to decide whether to make that link, where it's given information about where it came from, where it's trying to connect.

00:32:42 It's really up to the user to make something with it.

00:32:45 It's pretty low level and you'll notice that with a lot of these, even in the plots, they're low level and it's meant for the user to wrap on top of and build more complex functionality because we want it to be as generic as possible.

00:32:58 - Yeah, fantastic.

00:33:01 All right, there's an example of Tetris, like who doesn't love Tetris, of course.

00:33:06 And then what is this last one here?

00:33:11 Several tools to help developers.

00:33:13 - There's a lot of built-in tools.

00:33:17 - Like, is this like tab views and list views and stuff like that, or what are we talking about?

00:33:24 - As an example, you know, like you create, Whenever you go to create the UI, you may create a window and then add a group and then a collapsing header and then a button, and you have this parent relationship.

00:33:34 You know, one of the tools is the item registry.

00:33:37 And if you just type in the command, show item registry, you get this basically tree view where you can look through all the items in your UI, click on it, see information about the state of it.

00:33:49 You know, is it visible?

00:33:50 Is it clicked on?

00:33:51 Is it hovered?

00:33:52 You know, that's one of them.

00:33:54 - Most of these use for debugging.

00:33:55 - Yeah, it's mostly debugging.

00:33:57 Yeah, it's tricky to get a view into that kind of stuff in the UI, right?

00:34:02 Obviously, you can print out something or set a breakpoint and see it.

00:34:05 But a lot of times, they're hierarchical and whatnot.

00:34:10 And the right visualization of that makes a big difference.

00:34:13 Another great one is to say, if you're loading a texture or a couple of textures into the texture registry, preparing them to be added to a widget, you can use the texture registry to actually go in and inspect your different resources like you can preview it before you actually use it.

00:34:30 >> That's really cool.

00:34:31 >> Yeah.

00:34:32 >> Same thing with fonts.

00:34:33 You can inspect fonts and other things like that.

00:34:35 >> Is DeerPi GUI primarily focused on 2D UIs, or does it have a 3D component?

00:34:42 >> So currently it's 2D, but we are working on a 3D engine to go with it.

00:34:49 >> All right.

00:34:51 And the UI won't be 3D, but there will be 3D widgets.

00:34:55 And we kind of have support for that now, but it's not hardware accelerated.

00:34:59 The actual 3D engine we're working on will be.

00:35:01 >>Yeah, cool.

00:35:02 So for example, like all these charts that are on the GitHub page that are active and moving, I can totally imagine that one of those spherical or it's modeling spikes that represent peaks of some kind of measurement all over the place.

00:35:16 And you want to look at it from different directions and whatnot.

00:35:19 So yeah, I can see where it comes from.

00:35:21 - Yeah, and I think at the bottom of the readme, you can kind of see some examples of users that have already kind of skipped ahead and hacked into the edit to some 3D work.

00:35:31 - Yeah, for sure.

00:35:33 There's a gallery section that people should check out.

00:35:35 One of the things I really like to do when I hear about a new UI framework or some tool that does UI graphical stuff is to just go look at the screenshots and go, what, I want my app to look like this?

00:35:48 Maybe that looks pretty cool.

00:35:50 Let me take the time to learn it.

00:35:51 Honestly, it kind of blows my mind.

00:35:53 There's a lot of UI frameworks out there that don't have a single screenshot of what, like what's your whole job is to build pictures.

00:36:02 Like show us some pictures.

00:36:04 - Yeah, imagine.

00:36:05 - Really important gallery part of it.

00:36:07 - Like the user's listening right now, you have to imagine.

00:36:10 - Yeah, the gallery is looking really good.

00:36:12 So one, it looks like almost, the first one is almost like an auto can thing.

00:36:16 It looks like some kind of turbine or something is there.

00:36:20 Maybe you know more about it.

00:36:21 You guys can say a little bit.

00:36:23 - One of the users made it.

00:36:24 Wasn't sure what they were working on.

00:36:26 We helped them a little bit with getting access to the underlying OpenGL context, 'cause that was on Linux, but not sure what they were working on past that.

00:36:36 - Yeah, it looks cool, doesn't it?

00:36:38 All right.

00:36:39 This next one looks like some kind of modeling system.

00:36:44 Another one of those user saw a user with it.

00:36:47 We snapped the photo and again, no idea what they were doing with it.

00:36:50 Just looked cool.

00:36:51 - Yeah, it definitely looks cool.

00:36:55 Bunch of left-hand side, right-hand side elements here.

00:37:00 It almost looks like it could be modeling some sort of machine learning thing, but I don't think so.

00:37:07 Yeah, definitely some kind of interesting model here.

00:37:11 - It might've been.

00:37:13 Some really nice visualizers here for, it looks like maybe looking at some astronomy stuff, which is great.

00:37:24 And then a game and some more drawing tools.

00:37:28 Yeah, here, is this maybe a ray tracing?

00:37:30 - No, that was just a Fong, just a Fong render that we were working on when testing some of the earlier versions of the 3D engine we're working on.

00:37:42 - Okay.

00:37:43 - So that's just some of the early prototypes and we thought it was a pretty neat picture to do and you can do that now if you just kinda, like that other user did, just kinda hack in and get access to the OpenGL context or GroundDirectX.

00:37:57 - Okay, so one of the things that sounds like you can do is work with your PyGUI, but when maybe there's some low-level thing you need to do, like a shader context or some weird graphical thing, If it's not directly supported, you can just go, all right, let me just get straight to the GL context object or structure and just do some OpenGL stuff on it.

00:38:22 Is that right?

00:38:23 Or metal?

00:38:24 - That's correct.

00:38:25 And for now, that's kind of the way it's done.

00:38:28 But one of the things that we've been working on and a lot of the users have been around a while know this is, like I said, right now, the backends are for Windows, we're using DirectX 11.

00:38:38 For Linux, we're using OpenGL.

00:38:40 on for Mac were using Metal.

00:38:43 Well, that was early on.

00:38:45 That was probably a bad decision.

00:38:46 So now we've been working on replacing the back end with Vulkan across the board.

00:38:51 And part of that would be that we'd be able to directly support giving users access to the GPU there.

00:38:57 Because one of the things with the library is we do want it to be cross-platform and not have to change the code--

00:39:03 pretty much not have to change the code at all across the platform.

00:39:07 And right now, with us using different back ends, we wanted to expose access to compute shaders.

00:39:12 Or when you're on Windows, you'd have to write in HLSL.

00:39:14 When you're in Mac, you'd have to write it in whatever the language is, Metal.

00:39:19 And then in OpenGL, you'd GLSL.

00:39:22 So by switching to the Vulkan back end, we're going to be able to expose that and use the same thing across the board.

00:39:29 And that's part of one of the big things that we've been working on.

00:39:34 And it's taking a lot of time.

00:39:37 and the 3D engine itself is also going to be written in Vulkan.

00:39:40 >> Okay. That's super cool.

00:39:42 >> You can see pictures of that too by the way.

00:39:45 >> Okay. Where do I find those?

00:39:47 >> If you go to the very top, you might have to actually click on my name, but it's DeerPi3D.

00:39:53 >> Got it. Okay. So it's a separate repo up there.

00:39:57 >> It will be combined. It's just while we're prototyping.

00:39:59 >> Sure. Right here.

00:40:02 By the way, nice customized GitHub profile.

00:40:06 You know, your nice read me looks good.

00:40:09 Yeah, here you go.

00:40:10 So the DeerPi GUI 3D engine.

00:40:13 Pretty neat.

00:40:15 Look at that.

00:40:16 Yeah, you do have some cool pictures in here.

00:40:18 - So that will be the type of stuff you can choose for your new stuff.

00:40:21 Yeah, that's true 3D real time.

00:40:24 - Yeah.

00:40:25 So let's go back just for a minute on this, this cross-platform business.

00:40:31 'Cause I think this is worth thinking about.

00:40:34 First of all, I was really impressed that you had support for DirectX and Metal and OpenGL, because that means on Windows, you get the best option there, which is DirectX on macOS, especially in the new Apple Silicon ones.

00:40:53 If you wanna take advantage of the GPUs that are built in there, the best way to do that is Metal and so on, right?

00:41:01 But yeah, those APIs are super different.

00:41:04 So if you're going to expose them, say here, let me just hand you the low level context and talk straight to it.

00:41:11 Well, you're kind of setting them up for getting locked into one or the other, plus also having to learn Metal and or learn DirectX and all that, right?

00:41:21 - Right, and again, that's part of the reason we are switching to Vulkan.

00:41:25 We will leave those backends as legacy.

00:41:27 Yes, legacy is a bad word, but you'll be able to switch to those backends.

00:41:32 But if you're really wanting to do the low level stuff and wanting to access the 3D engine, you will have to use Vulkan.

00:41:38 Yeah.

00:41:39 So tell people about what this Vulkan thing is.

00:41:41 I mean, I've heard of it as a way to have--

00:41:43 it's like one API that talks both DirectX and Metal and OpenGL or something like that.

00:41:48 Is that sort of the deal?

00:41:50 So OpenGL, DirectX 11, and I guess that's the two main ones are the older--

00:41:58 I guess the previous generation graphics APIs.

00:42:01 And those are used to--

00:42:04 they go through the driver, and they talk to your GPU directly.

00:42:09 And like I said earlier on in this, that basically the hardware has changed considerably since those APIs were designed.

00:42:19 Very, very different.

00:42:20 So it's a lot more work on the driver developers to have to go from, here's how the hardware works, to here's the API we had.

00:42:29 The move over the last five or six years has been towards these lower level graphics APIs like Metal, DirectX 12, and Vulkan.

00:42:41 These are considerably lower level.

00:42:44 As an example, to get a triangle on the screen in DirectX 11, it's maybe 300 lines of code, in OpenGL it's maybe 100, if that.

00:42:53 To do it in Vulkan, you're easily at 1,000, just getting a triangle on the screen.

00:42:57 Really?

00:42:58 I was already feeling bad that it was 300 in DirectX.

00:43:01 And I mean, I can just remember the OpenGL code.

00:43:04 Set the scale, set the transform, set the viewport, all of those things.

00:43:11 It's not easy programming type of work.

00:43:13 So Vulkan is even lower than that, huh?

00:43:16 Right.

00:43:16 Vulkan and DirectX 12 are really your lowest level.

00:43:19 But DirectX 12 is just Windows.

00:43:24 And with these APIs, I mean, you're able to utilize so much more in terms of what your GPU is capable of.

00:43:31 But you have to manage a lot more.

00:43:33 And that's part of why that even the 3D engine and us switching the back end is taking as long as it is because the driver developers do a lot less for those APIs.

00:43:45 Things like, as an example, in DirectX and OpenGL, you can say I need a texture and load it with data.

00:43:54 And that's it, you can do that as many times as you want.

00:43:56 And Vulkan and DirectX 12, there's a max number of times you can do that.

00:44:01 I think it's the low numbers, maybe 4,000 allocations.

00:44:04 So it's up to you to instead, allocate one big block, manage it yourself and not keep doing that, as an example.

00:44:14 - Right, you end up with those sort of maps, right?

00:44:17 Where like this square is the actual whole picture of something else, but to the right of it might be some other thing that you load all into one texture and you kind of viewport into it or something.

00:44:29 Yeah.

00:44:30 - Yeah, another one of those things.

00:44:32 It could be fun, but also you pull your hair out 'cause another one of the things that the new APIs have changed is actually having to synchronize between the GPU and CPU and DirectX and OpenGL when you say, you know, swap the buffers, execute this draw, whatever you're doing.

00:44:52 your main loop where you're doing that, you don't have to wait till it's finished.

00:44:58 It's automatically synchronized between the GPU and CPU.

00:45:01 >> I see.

00:45:01 >> With the new APIs, that's not the case.

00:45:03 You typically have to actually add in barriers and fences between the different operations, and just a lot of stuff.

00:45:11 You typically have more than one frame processing at a time.

00:45:15 You can actually utilize multi-processing, which is a problem right now with Python because of the GIL.

00:45:21 So even though Vulkan has that, you can't really utilize it yet.

00:45:24 So yeah.

00:45:27 - Maybe the no-gil stuff will gain traction and it won't be a problem anymore.

00:45:32 One can hope.

00:45:33 So when I'm looking at this Vulkan page here, I see Windows, Switch, Stadia, Linux, Android.

00:45:38 I don't see macOS.

00:45:40 Is it still support Mac or what's the story there?

00:45:43 - So yeah, you said the MoltenVK is a layer on top of Metal so that you can use it for Mac.

00:45:52 It's not directly supported.

00:45:54 I mean, you know how Apple is.

00:45:55 You gotta use Objective-C.

00:45:57 They don't want you using C++.

00:45:58 It's not as supported.

00:45:59 It's the same thing.

00:46:00 They deprecated OpenGL, and as of right now, there is no direct support for Vulkan.

00:46:05 So Molten VK is the--

00:46:08 - See, it's like an intermediate layer between Metal and Vulkan.

00:46:11 - Right.

00:46:12 - Got it, okay.

00:46:13 - Talk about possibly leaving Metal in as a support.

00:46:17 - Yeah.

00:46:19 - Possibility to, I'm leaving.

00:46:21 - It breaks your perfect abstraction though.

00:46:24 - Yes.

00:46:25 - What are you gonna do though?

00:46:28 Pretty cool.

00:46:29 - Metal's already doing that right now.

00:46:30 Some of the formats for the textures aren't supported.

00:46:33 - That's a good point.

00:46:34 - Which is a little annoying.

00:46:36 - Yeah, everyone's a snowflake over in the Mac world, right?

00:46:39 - That is correct.

00:46:41 - As I say on my Mac, okay.

00:46:42 Let's see, one of the things I liked when I was looking through here is you've got a nice getting started tutorial.

00:46:50 Maybe we could talk just a little bit about just what the code looks like to get some stuff on the screen.

00:46:54 But you also have some video tutorials.

00:46:58 Jonathan, I know you put some of these together.

00:47:01 Not sure.

00:47:02 - A while back, they're a little outdated.

00:47:04 They're 06, 06, which is pretty old, but we need to recreate them soon.

00:47:12 - Sure, well, as someone who creates a bunch of videos, They're very tricky to keep them in sync.

00:47:19 You can't just edit a few words or change a thing here.

00:47:22 It's different.

00:47:23 But yeah, so people want to learn through the video style they can go through and sort of watch some of these and get a sense of simple plotting, or working with tabs and stuff like that, right?

00:47:35 >>Most of the things are there.

00:47:38 Documentation still is a bit-- both with video tutorials and our readme, it's still a little bit lacking.

00:47:44 there's still some stuff that's undocumented that we're having to add, but that's part of the point of the demo is you can see how all those, most of the features are there and you can kind of see how to code them.

00:47:54 But that's no excuse for us not continuing to improve the docs.

00:47:59 - Well, that's true, but also contributing to the docs and contributing a tutorial or something like that, that's also a good way for people to contribute, right?

00:48:10 - Right, that is a very good way.

00:48:12 Are you all open to having contributors and PRs and other things along those lines?

00:48:17 - Yeah, absolutely. - I have a bunch of PRs and welcome to join the Discord.

00:48:22 We're in there all the time talking with people about when they're working on different spots in the API.

00:48:27 - It's a, the problem is, you know, most of the users are Python users and libraries are written in C and Objective-C and things like that.

00:48:35 So there's kind of a little bit of a disconnect there where a lot of users would like to help, but you know, when they go over to the library and see it's that, they go, oh, nevermind.

00:48:44 - You know what, actually, I wanted to work on a Python project.

00:48:46 Well, I mean, we have this problem in a lot of the very popular places.

00:48:49 Like people wanna contribute to Python itself, and often that means C, not Python.

00:48:54 And go, darn it.

00:48:55 People wanna contribute to Jupyter, but a lot of times that means JavaScript, not Python.

00:49:01 They go, come on.

00:49:02 But yeah, that's kinda what it means to build tools sometimes, I guess.

00:49:09 You guys have the demo kind of fired up on your screen here.

00:49:12 Maybe you want to just talk us through a couple of the highlights and how we get this thing going.

00:49:17 - Sure.

00:49:18 - Got to keep in mind that not everyone can see what we're seeing, but we'll, yeah.

00:49:22 - Yeah, so you can kind of see the demo.

00:49:24 And we modeled this after on GUI's demo and some of the other demos we saw people doing similar things where you can kind of see all the different features.

00:49:32 - So if I pip install DeerPi GUI, does this come in a run to just get this going?

00:49:37 It's one of the modules you have import deerpygui.deerpygui and then you have import deerpygui.demo and there's just one command show demo.

00:49:45 - Right, so you could even do that from a REPL if you wanted, right?

00:49:51 - Yeah, you can and do that right.

00:49:53 So you can kind of see a lot of different widgets, just your typical UI widgets that you have.

00:49:58 - Yeah, go back to the widgets real quick for a sec.

00:50:00 Yeah, so you've got a lot of nice ones.

00:50:03 You've got buttons, you've got check boxes, You've got radio buttons, you know, like you can only select one versus check boxes.

00:50:10 You've got drop down combo boxes, text, text with placeholder hint, I guess.

00:50:19 One of the areas that you have a lot of UIs around is the slider, what do you call them, slider floats, slider ints.

00:50:27 It's like a thing that has a number, but then as you slot, you can not just type in it, but you can drag it around and actually scale it.

00:50:35 You know, I see this a lot in the Adobe tools like Audition, you can go in if you wanna change something, you can sort of click on a number and just move the mouse instead of typing to the number.

00:50:47 Yeah, yeah, this is good looking stuff.

00:50:51 - There's a lot of these color things, 'cause again, this is really meant for a lot of 3D engines and content creation, a lot of color maps and things like that.

00:51:05 Let's see what else.

00:51:07 Text input, a lot of stuff here.

00:51:08 And remember how I told you a lot of the backends are the same exact numbers.

00:51:11 So you can get things automatically like this.

00:51:13 All of these are linked together.

00:51:15 - All right, so what you're doing, there's like three text boxes.

00:51:19 One that's plain text and two that are passwords.

00:51:22 And as you type in one, they all, I mean, it's not real practical for passwords, but as you type in one, it'll show you in the different.

00:51:29 - So we're showing different flags, just different flags.

00:51:33 - Yeah, how do you create that binding between them?

00:51:35 - That's what I was telling you, there's no actual binding.

00:51:38 They're truly the same value underneath.

00:51:40 - Okay.

00:51:41 - Whenever you get to create this, say you call this item, password one, when you go to create the second one, you can specify a source as password one, and it will just, rather than have its own value, it will just truly use a pointer to the other one.

00:51:55 And that's why all these--

00:51:56 - Yeah, yeah, that's really cool.

00:51:56 So that's how they stay in sync, 'cause they are the same thing.

00:52:00 - It's nice, it's free.

00:52:01 - Yeah, exactly.

00:52:02 - It's free, it doesn't cost anything.

00:52:03 There's no callback that has to run.

00:52:05 A lot of basic simple plots.

00:52:09 Yeah.

00:52:10 For just-- it's pretty simple stuff.

00:52:12 Let's see.

00:52:12 There's a whole bunch of things.

00:52:15 Yeah.

00:52:15 Again, these are linked in the same way.

00:52:18 OK.

00:52:18 Yeah.

00:52:20 Yeah, so I encourage people, if they want to think about this framework, is create a virtual environment, pip install deerpygui, and then do the import command to run the demo, right?

00:52:32 Yeah.

00:52:32 - Really? - Date pickers.

00:52:35 But some of the cooler ones that you wanted to see, I mean, I could show these.

00:52:38 These are all pretty typical in most UI libraries.

00:52:40 - Not that.

00:52:41 - Some of the ones-- - There's the knobs.

00:52:44 - That's true.

00:52:45 Some of the ones, I guess, we have a table API, which--

00:52:49 - Oh, that's nice looking.

00:52:51 - Pretty cool.

00:52:52 You're able to, you know, these examples are just showing text, but you could put any widget, you could put plots, you can do all kinds of stuff.

00:52:59 - So yeah, with the table one, probably people think about it, Like probably it'd be called a grid in a lot of frameworks, right?

00:53:07 It's kind of a read only Excel type of view, but very colorful and nice.

00:53:11 - These aren't read only.

00:53:12 These can be any widget you want.

00:53:14 They're more layout like.

00:53:16 - Oh, so you can put like a graph in one of the cells.

00:53:19 - You can put a block, you can put a node editor, you can put anything you want in these.

00:53:23 - It's best to think about like a table as more or less a layout, essentially just giving you columns and rows where you can put anything in it.

00:53:29 - Oh yeah, okay.

00:53:29 That makes sense.

00:53:30 - Yeah, we need to see here this sorting one, you can kind of see, we've got a checkbox in here.

00:53:36 I think there's an input, you know, different things.

00:53:39 - Yeah.

00:53:40 - Tables is cool.

00:53:41 Like I said, I mean, there's tons of plots.

00:53:43 - Yeah, there's a lot.

00:53:44 - Anyone can look at the demo.

00:53:46 There's, and we have that example that you saw on the...

00:53:49 - Oh yeah, you even have that detail, high level of the detail graph in there.

00:53:55 That's cool.

00:53:55 Do you have trees?

00:53:57 - We do.

00:54:00 layout containers as far as you mean like.

00:54:03 >> Yeah, exactly.

00:54:05 >> That's very cool.

00:54:08 >> I like it.

00:54:09 >> A lot of stuff with textures and the high-performance type stuff.

00:54:12 For those that haven't seen, let's see, where's that?

00:54:17 The node editor.

00:54:19 Those that are unfamiliar with that, I ran out of room here.

00:54:27 - Yeah, that node editor is exactly what I expected, right?

00:54:30 So you've got these three little boxes with different bits of information or graphs and you just drag and connect them.

00:54:35 And yeah, that's fantastic.

00:54:37 - And you can put any widget in the library in these.

00:54:40 So it's not limited to just a small subset.

00:54:43 And then again, with the drawing API, your typical stuff that you're used to and other drawing APIs, being able to draw a line, a box, a cube, things like that.

00:54:51 And then also some support for a lot of 3D operations operations, things like perspective divide and depth clipping and all that to help support these type things.

00:55:04 >> Right, right.

00:55:05 Very cool.

00:55:06 All right, let's maybe round out our conversation here by talking a bit about, just give us a sense on what it looks like to write some code.

00:55:16 So I'm guessing there's not a graphical designer type thing like Xcode storyboard or whatever.

00:55:26 - Right, we're not big fans of those.

00:55:28 - Yeah, so you do this through code, you sort of build up your UI through code and layout elements like for example, table and whatnot.

00:55:36 You guys wanna, I mean, don't just recode 'cause that's not gonna work over audio, but maybe just give us a sense of, you know, how do I get like a text box and a button or something on the screen?

00:55:49 What is the code story look like?

00:55:52 We talked about the 100 lines of OpenGL or whatever.

00:55:55 - Right, so pretty much every DPG app, you just import DPG, we do it as DPG most of the time.

00:56:02 From there you'll create a context which basically sets up the onGUI context, sets up onNodes, sets up our internal context with all the different settings and state.

00:56:15 - Right, probably.

00:56:16 Oftentimes these lower level frameworks, they have to go and get some context from the graphics card itself and like kind of get that from the operating system.

00:56:28 And I'm sure that kind of wraps that stuff all up, right?

00:56:32 - Absolutely.

00:56:33 And then from there you typically create the viewport.

00:56:35 And again, that's platform specific.

00:56:37 On Win32 we're using Win32, we're using X11 on Linux and on map reason, Kerio or whatever it is.

00:56:44 We don't have a touch that one in about a year.

00:56:47 - You got it working.

00:56:48 - From there you-

00:56:49 - Decided to stay away from it.

00:56:50 got it working and walked away from it for a while.

00:56:52 - That's cool.

00:56:53 So the viewport is basically like an empty window?

00:56:56 - Right, it's your actual operating system window.

00:56:59 - Got it, okay.

00:57:00 - We call it a viewport.

00:57:02 And from there you can create something like a window, there's these root objects, a window is like the GUI window that you see below, the blue window that you would see on our demo, things like that.

00:57:13 They're kind of floating windows within the main viewport.

00:57:16 From there to just add something like a text widget, It's dpg add text, dpg add button, dpg add input text, whatever the widget is.

00:57:26 And you kind of compose the hierarchy of, I guess, parent-child relationship with context managers is kind of the way that it's recommended.

00:57:36 So yeah, because--

00:57:38 I see.

00:57:38 So if I'm going to create a window, one of the windows, one of multiple possible windows, instead of creating a window object and say window add this or that, you would create a context manager do a bunch of ads, and then it all just goes to that window.

00:57:53 Right.

00:57:54 And we're not object-oriented, which kind of also sets us apart here.

00:58:00 But if you weren't using the context manager, that same operation would be dpg add window, and it returns either an ID, or you can put the ID in with the keyword tag equals whatever your ID is.

00:58:13 Then you would push to the container stack, and then when you're done adding items, you pop it back off.

00:58:19 The context manager handles that for you.

00:58:21 - Right.

00:58:21 - So it's adding the window, pushing it and popping it.

00:58:24 And if you wanted to do something, like I said, it's not object oriented.

00:58:27 So when you do add button, you don't get a button back, you get a handle to the internal button.

00:58:34 And then you use that handle, you can store it, just say B equals dbg add button.

00:58:40 And then all the various commands, you would use that handle to control it.

00:58:46 like if you want to say get the check state of a checkbox.

00:58:50 >> Right. Get value.

00:58:51 >> Yeah.

00:58:52 >> Or configure everything you did when you started off, you can modify later on using configure item and then you just pass in handle and go from there.

00:59:01 >> Cool. Is there an event loop type of thing?

00:59:05 >> There is. So after you've created the viewport and you add your widgets, you would do setup DeerPi GUI and what that runs is, that starts up the second thread.

00:59:15 We have two threads, we have the rendering thread running, and then we have a callback thread where all the Python's happening.

00:59:22 So that's what set up DeerPi GUI does.

00:59:23 ShowViewport actually shows the viewport, starts basically the platform-specific event loop.

00:59:30 From there, start DeerPi GUI.

00:59:33 That is your event loop.

00:59:34 If you actually wanna see the event loop, you would just do while is DeerPi GUI running, render DeerPi GUI frame.

00:59:42 And you can do everything you want inside of there.

00:59:44 And then when you're completely done, you destroy the context.

00:59:46 - Sure, very cool.

00:59:48 Looks super straightforward.

00:59:50 One thing that I don't see here is the callbacks.

00:59:55 So like when the slider slides or the button clicks, is there some way to hook that action?

01:00:01 Like obviously the save button is gonna need some.

01:00:03 - Yep, it's a callback.

01:00:06 It's a keyword for callback.

01:00:08 And basically it can have three arguments, the sender, which will send you the ID the item they called the callback.

01:00:15 The second one is app data, which for us that can be either the value or if the callbacks related to window resizing, it'll be the new size.

01:00:26 It's data that DPG send you.

01:00:29 Then the third argument, user data, is user can pretty much put anything they want, then it'll get passed through.

01:00:36 It's useful for a lot of people that are creating OOP wrappings around the library.

01:00:41 >> Yeah, nice. Is there one callback that handles all the events and then you do like a switch statement or do I hook like you can have as many callbacks as you want and then like a window size change callback or something like that? No you can it's really up to the user you can have a different callback for every one or you can have one master callback where you just check the sender and do different operations based on you know what called the callback so you kind of have a little bit of freedom there. We do have callbacks you can attach to inputs such as the mouse or the keyboard or The window resize like you mentioned we have callbacks you can set up for that. So yeah It is nice to be able to say When this button gets clicked do this and that makes it real simple, but there's also times that you might want to I Want to capture all the button clicks and then do some common thing regardless of which button gets clicked All right. It's nice to have that flexibility to go either way That's the biggest thing.

01:01:37 We try to be as flexible as possible and allow really geared towards a lot of people wanting to wrap and create their own kind of interfaces.

01:01:45 So there's a lot of freedom in some of the stuff we do.

01:01:48 So I noticed that you have this--

01:01:50 you call it the viewport--

01:01:51 this window that comes out of the operating system.

01:01:55 And then the DeerPi GUI windows sort of live in that space.

01:01:59 Is there a way to kind of simulate it looking almost like the DeerPi GUI window is the whole thing?

01:02:05 could I not show the title bar of the window and then like maximize the inner window to fill it?

01:02:13 - Right, you can undecorate the viewport.

01:02:15 There are settings for that.

01:02:17 And then we have a command that set primary window and you can basically set one of the, one of your mvwindows to be the primary one and it'll fill the whole viewport.

01:02:26 - Yeah, okay.

01:02:27 - And you get that, but you can't necessarily move them.

01:02:28 When you do that, you can't have multiple viewports at the moment.

01:02:32 We're still working on that.

01:02:33 - Sure, yeah, I know that makes sense.

01:02:36 Is there like modal dialogues and that kind of stuff in there?

01:02:40 - There is modal dialogues, there is file dialogues.

01:02:44 You know, a lot of people still tend to just import to Kinter and use their file dialogue 'cause a lot of people don't like ours.

01:02:50 - So right click context menus.

01:02:52 - Yes.

01:02:53 - Oh yeah, okay.

01:02:54 Yeah, it looks great.

01:02:56 Like I said, people who are possibly interested should check out the gallery on the GitHub page.

01:03:00 That's a good litmus test What does it look like?

01:03:04 Do you want to use it?

01:03:05 I think it looks pretty good.

01:03:06 I like it.

01:03:07 Yeah, for sure.

01:03:09 Let's see, we're getting close to the end here.

01:03:13 One thing, we talked a lot about the future stuff already.

01:03:19 So maybe we don't really need to go into that.

01:03:22 We've got the Vulkan backend, the 3D engine and stuff like that.

01:03:27 One of the things that I always want to do with a GUI is put it into my taskbar or put it into my macOS dock.

01:03:35 And I want to be able to give a binary thing to a user and not tell them about virtual environments and pip install and all that.

01:03:42 What's the deployment story about giving somebody a distributable version of this app?

01:03:47 - So a lot of users have used, you know, some of the tools, Py, was it Py2?

01:03:52 - Py installer or Py2.

01:03:54 - Things like that.

01:03:55 We did early on when we first started the project, had a batch file and some batch files that packaged it up for you.

01:04:04 Actually created the executable and everything so we could hand them around here, embedded the Python interpreter and everything.

01:04:09 We did remove those, but we do eventually plan on adding them back.

01:04:13 >> Okay.

01:04:14 >> We really don't like having dependencies on other libraries.

01:04:17 Even though users are using that now, we would like to bring back those.

01:04:20 >> Right. Have just a native.

01:04:22 >> Right. It wouldn't be that hard. We already do that when we develop it.

01:04:25 We are using an embedded version of Python in an executable.

01:04:29 We're not actually using this, what is it?

01:04:33 This utils and we're not using any of that.

01:04:37 We're actually just using the Python C API directly and embedding it.

01:04:41 >> Yeah, cool. As a sidebar, one of the things I really think would benefit Python as a community is if there was just a built-in Python-M package.

01:04:57 >> Absolutely.

01:04:58 build executable or whatever, and out the other side comes a .app, a binary Linux app, or a .exe.

01:05:05 And you just hand it out, right?

01:05:08 There's so many scenarios where people would like a tool that they would like to be able to share.

01:05:14 And I feel like it's a bit of a chicken and egg thing.

01:05:16 Like, well, people aren't doing that very frequently.

01:05:19 So why do we need that feature?

01:05:21 Well, they're not doing it 'cause it's so super hard and fragile, right?

01:05:24 If it were as easy as pushing a button, I think maybe people will do it more.

01:05:29 So I don't know, anyway.

01:05:31 - Absolutely, that was one of the original reasons for our engineer sandbox project way early on is we did do the tools in Python, but we couldn't hand them to people.

01:05:39 We had to tell them, well, you gotta install Python and then pip install this.

01:05:42 So the idea of that one was we were able to just hand them that.

01:05:45 - Yeah, yeah, that's very good.

01:05:47 Maybe a little bit wrap up on the audience side, Mr. Hypermagnetic once again says, "Very nice design and similar to small JS libraries." Yeah, nice.

01:05:55 - Appreciate it. - Looks good.

01:05:57 All right, last thing, you know, I always am interested how these projects gain traction, how people find time and energy to put into them. And one of the ways is for companies that use them or people that use them to sponsor you guys, right?

01:06:15 So you guys have a sponsor option here, which is part of the GitHub sponsor story, right?

01:06:24 - Right.

01:06:25 - I think that's actually a pretty big deal 'cause it used to just be like, well, we just put a PayPal donate button or something on there, right?

01:06:32 Which is fine and all, but this is a little more.

01:06:35 - It is an awesome feature that they, I guess Microsoft added.

01:06:38 - Yeah.

01:06:40 - I assume that they're the ones that did it.

01:06:40 Yeah, it's pretty good.

01:06:41 We do have the GitHub sponsors, OpenCollected and the BuyMeACoffee, whatever it is.

01:06:49 - Yeah, cool.

01:06:52 Yeah, so this is a part-time project for you guys, not full-time.

01:06:56 It sounds like you're doing mechanical engineering work full-time, and then also this both at work, but then also bringing it out to the community a little bit.

01:07:06 - That is correct.

01:07:06 If it directly applies to something we're doing at work, a bug or something, we'll add it here.

01:07:10 But for the most part, it is at home at night, after our families are in bed and working on it there.

01:07:17 - A labor of love.

01:07:18 Awesome.

01:07:19 - That is correct.

01:07:21 - All right.

01:07:21 Well, very cool work.

01:07:25 Again, I think it's great to see more UI frameworks and more UI innovation in the Python space.

01:07:31 So thanks for doing that.

01:07:34 Now, before we get out of here, let me ask you all the final two questions.

01:07:40 If you're going to write some Python code, what editor do you use?

01:07:44 Typically PyCharm.

01:07:46 Yeah, pretty much PyCharm.

01:07:48 Right on.

01:07:49 Try a few, but--

01:07:50 Yeah, sure.

01:07:51 And then a notable PyPI package, something you've run across, like, oh, this is awesome, people should know about.

01:07:57 - Typically, just NumPy is about the only one, NumPy is about the only one I use.

01:08:04 We like to reinvent the wheel.

01:08:06 - Yeah.

01:08:06 Fewer dependencies, right on.

01:08:09 Anthony out in the audience says, I'm guessing, question mark, does DeerPythonGUI play nicely with third-party libs like Nutca, PyInstaller, and so on?

01:08:23 - PyInstaller, I know it does.

01:08:25 Nutca, I do not believe it does.

01:08:28 And then NumPy or anything that supports the buffer protocol you can use in a lot of our functions.

01:08:35 - Cool.

01:08:36 What about Cython or something like that, if people wanna make a--

01:08:39 - No, because we're directly writing to the CPython API, the other implementations of Python don't play nicely at the moment.

01:08:49 - Okay, got it.

01:08:51 Cool, cool.

01:08:52 All right, well, very nice work.

01:08:54 Final call to action, people wanna get started with DeerPi GUI or maybe give back to it.

01:09:00 Sorry, Anthony says it was a statement.

01:09:02 Not a question.

01:09:05 Thanks, Anthony.

01:09:06 (laughing)

01:09:08 And yeah, final call to action, people wanna get started with DeerPi GUI.

01:09:12 What do they do?

01:09:13 - Just pip install and run the demo on the readme.

01:09:17 You can also join our Discord server.

01:09:19 There's about a thousand users in there.

01:09:20 - Go through the read the docs for sure.

01:09:22 - Read the docs.

01:09:23 Contributing would be nice.

01:09:25 We're still in the middle of refactoring a lot of things internally, so it may be a little hard.

01:09:30 But other than that, also just sponsoring really helps out.

01:09:33 Makes it worth it.

01:09:33 - Yeah, awesome.

01:09:36 Well, Jonathan, Preston, thanks for being here.

01:09:40 - Appreciate it.

01:09:41 - Yeah, you bet.

01:09:42 And thanks everyone for watching.

01:09:43 If you enjoyed this, you wanna get notified when it goes live again, be sure to press subscribe and catch you next time.

