WEBVTT

00:00:00.000 --> 00:00:05.000
- Brett, welcome back to Talk Python To Me.


00:00:05.000 --> 00:00:06.880
You've been here a time or two?


00:00:06.880 --> 00:00:08.480
Always great to have you here.


00:00:08.480 --> 00:00:10.200
- Well, thanks for having me yet again, Michael.


00:00:10.200 --> 00:00:12.920
I'm glad I've not worn out my welcome quite yet.


00:00:12.920 --> 00:00:14.680
- You always have so much cool stuff going on


00:00:14.680 --> 00:00:17.180
and so many interesting perspectives.


00:00:17.180 --> 00:00:21.000
- Some would call them interesting,


00:00:21.000 --> 00:00:22.680
whether that's a positive or negative,


00:00:22.680 --> 00:00:25.000
is still open to interpretation.


00:00:25.000 --> 00:00:26.880
- May you program in interesting times,


00:00:26.880 --> 00:00:28.920
as the old ancient proverb goes.


00:00:29.040 --> 00:00:29.880
- Mm-hmm.


00:00:29.880 --> 00:00:34.660
- So, been here a bunch of times,


00:00:34.660 --> 00:00:36.840
but real quick, just tell people a bit about yourself


00:00:36.840 --> 00:00:38.240
before we jump in.


00:00:38.240 --> 00:00:40.440
- Sure.


00:00:40.440 --> 00:00:41.320
- Just in case they don't know you.


00:00:41.320 --> 00:00:43.280
- Yeah, name's Brett Cannon.


00:00:43.280 --> 00:00:45.560
I live in Vancouver on the unceded territories


00:00:45.560 --> 00:00:47.240
of the Squamish, Tsleil-Waututh,


00:00:47.240 --> 00:00:48.940
and Musqueam First Nations.


00:00:48.940 --> 00:00:52.120
I am currently the dev manager


00:00:52.120 --> 00:00:54.960
for the Python extension in VS Code.


00:00:54.960 --> 00:00:58.640
I am serving my fifth and, as of now,


00:00:58.640 --> 00:01:01.240
final term on the Python Steering Council.


00:01:01.240 --> 00:01:03.300
I'm stepping down just 'cause,


00:01:03.300 --> 00:01:04.700
when we first created the Steering Council,


00:01:04.700 --> 00:01:07.180
I said five years seemed like a good term limit.


00:01:07.180 --> 00:01:08.400
We actually don't have term limits,


00:01:08.400 --> 00:01:10.680
but I figured I'd stick to my word.


00:01:10.680 --> 00:01:13.800
And I'm also the social core developer.


00:01:13.800 --> 00:01:16.480
I've been doing it for just over 20 years.


00:01:16.480 --> 00:01:19.400
Lucky for me, I got my first commit bit


00:01:19.400 --> 00:01:20.640
right after the, sorry,


00:01:20.640 --> 00:01:22.760
my first commit bit after the first PyCon,


00:01:22.760 --> 00:01:24.640
so I get to use the PyCon anniversaries


00:01:24.640 --> 00:01:27.160
as a way to keep track of that, so that's convenient.


00:01:27.160 --> 00:01:28.000
- Yeah.


00:01:28.000 --> 00:01:30.640
- That's kind of the biggies.


00:01:30.640 --> 00:01:32.160
Have a cat. - Yeah.


00:01:32.160 --> 00:01:33.920
Something about VS Code is that,


00:01:33.920 --> 00:01:36.240
I've heard that word, it's an editor, right?


00:01:36.240 --> 00:01:37.080
- Yeah, I know.


00:01:37.080 --> 00:01:38.880
Someday you'll say you use it,


00:01:38.880 --> 00:01:41.220
and I'll be very happy that day.


00:01:41.220 --> 00:01:42.640
- I had it open today.


00:01:42.640 --> 00:01:45.200
- Oh, all right, well, I'm happy today then.


00:01:45.200 --> 00:01:46.480
- Yes, indeed.


00:01:46.480 --> 00:01:48.240
No, awesome.


00:01:48.240 --> 00:01:49.840
So many cool things you got going on.


00:01:49.840 --> 00:01:53.200
And despite all of that background


00:01:53.200 --> 00:01:56.000
in Steering Council, Core Dev,


00:01:56.000 --> 00:01:58.960
here, this time, you're here to give us


00:01:58.960 --> 00:02:03.360
diet advice, eating advice, something about sugar.


00:02:03.360 --> 00:02:04.680
What is it?


00:02:04.680 --> 00:02:09.040
- Yeah, so, just a slight story behind all this.


00:02:09.040 --> 00:02:14.920
So my wife was taking the certificate in data science course


00:02:14.920 --> 00:02:17.200
at the University of British Columbia,


00:02:17.200 --> 00:02:19.760
which is actually our alma mater and where we met.


00:02:20.720 --> 00:02:25.280
And she was doing her homework


00:02:25.280 --> 00:02:29.040
in a JupyterLab notebook through the browser


00:02:29.040 --> 00:02:30.200
via JupyterHub.


00:02:30.200 --> 00:02:32.880
And she stopped doing the homework to go,


00:02:32.880 --> 00:02:34.600
I can't remember if it was lunch or dinner,


00:02:34.600 --> 00:02:36.280
but basically stepped away for like an hour or so.


00:02:36.280 --> 00:02:37.800
And then she came back,


00:02:37.800 --> 00:02:41.000
and the run buttons on the cells weren't working anymore.


00:02:41.000 --> 00:02:42.400
I was like, well, what's going on?


00:02:42.400 --> 00:02:43.840
And I looked, and it's like, oh, well,


00:02:43.840 --> 00:02:45.280
you got disconnected from the server.


00:02:45.280 --> 00:02:48.040
I said, well, isn't that happening in the browser?


00:02:48.040 --> 00:02:51.600
Like, no, Python doesn't run in the browser right now.


00:02:51.600 --> 00:02:52.440
It's not a thing.


00:02:52.440 --> 00:02:53.280
I'm like, oh, okay.


00:02:53.280 --> 00:02:57.000
And then I think about a day or two later


00:02:57.000 --> 00:02:58.320
after she'd thought about it a bit,


00:02:58.320 --> 00:02:59.520
we were in the car,


00:02:59.520 --> 00:03:01.920
and I still remember the exact location in Vancouver


00:03:01.920 --> 00:03:03.040
where this occurred.


00:03:03.040 --> 00:03:06.120
My wife said, you know, you should probably fix that problem


00:03:06.120 --> 00:03:07.480
of Python not working in the browser.


00:03:07.480 --> 00:03:09.440
And I explained like what WebAssembly was


00:03:09.440 --> 00:03:11.320
and how big of a thing that would be


00:03:11.320 --> 00:03:13.160
to make that all happen and all that.


00:03:13.160 --> 00:03:16.080
And she literally took about a beat to wait and said,


00:03:16.080 --> 00:03:18.000
no, you should go fix that.


00:03:18.000 --> 00:03:22.280
So part of that led me down the road


00:03:22.280 --> 00:03:24.440
of trying to figure out


00:03:24.440 --> 00:03:27.240
what the minimum viable Python was, right?


00:03:27.240 --> 00:03:29.240
Like what is the minimal amount of Python


00:03:29.240 --> 00:03:31.720
I would have to implement in the browser


00:03:31.720 --> 00:03:36.280
or in WebAssembly in this case to make Python work?


00:03:36.280 --> 00:03:39.000
And I realized that, you know,


00:03:39.000 --> 00:03:40.520
a decent amount of Python is actually


00:03:40.520 --> 00:03:42.160
what's called syntactic sugar,


00:03:42.160 --> 00:03:45.280
which is really just syntax that you could actually


00:03:45.280 --> 00:03:50.080
devolve and unravel into other syntax of a language


00:03:50.080 --> 00:03:52.680
and have it do the exact same thing, right?


00:03:52.680 --> 00:03:55.800
It's just basically syntax as a shortcut.


00:03:55.800 --> 00:03:59.520
And so I ended up going on this very long journey,


00:03:59.520 --> 00:04:01.840
unexpectedly long,


00:04:01.840 --> 00:04:04.280
of trying to go through all the Python syntax


00:04:04.280 --> 00:04:07.120
and trying to figure out which parts of the syntax


00:04:07.120 --> 00:04:10.440
was like crucial and you couldn't actually re-implement it


00:04:10.440 --> 00:04:12.120
in pure Python itself,


00:04:12.120 --> 00:04:14.760
and which parts you could actually just


00:04:14.760 --> 00:04:16.760
make it work with Python code itself.


00:04:16.760 --> 00:04:18.000
With the idea that at the end,


00:04:18.000 --> 00:04:21.200
it would have basically a list of the bits of Python


00:04:21.200 --> 00:04:23.680
that an interpreter would have to implement


00:04:23.680 --> 00:04:25.080
and the other bits of syntax


00:04:25.080 --> 00:04:27.520
where you could run some tool over it ahead of time,


00:04:27.520 --> 00:04:28.920
it would just translate from Python


00:04:28.920 --> 00:04:30.440
to different Python code.


00:04:30.440 --> 00:04:31.600
And in that way, I would just know


00:04:31.600 --> 00:04:34.000
what the exact target would have to be.


00:04:34.000 --> 00:04:36.600
It might not run very fast, don't get me wrong,


00:04:36.600 --> 00:04:39.480
but it would at least be a very clear definition


00:04:39.480 --> 00:04:41.800
of kind of what you have to have


00:04:41.800 --> 00:04:43.560
to really call something Python


00:04:43.560 --> 00:04:46.240
'cause everything else you could kind of just work around.


00:04:46.240 --> 00:04:50.120
- Right, so the standard Python syntax we expect still works,


00:04:50.120 --> 00:04:53.760
but how much do you have to work behind the scenes


00:04:53.760 --> 00:04:54.600
to make that happen?


00:04:54.600 --> 00:04:56.720
So examples that come to mind for me


00:04:56.720 --> 00:05:00.360
are context managers, the with block.


00:05:00.360 --> 00:05:03.360
Awesome, I love them, but we have try finally,


00:05:03.360 --> 00:05:07.400
and you could simulate a context manager effectively


00:05:07.400 --> 00:05:11.080
with maybe a try finally, maybe an accepts in there as well,


00:05:11.080 --> 00:05:15.200
but you don't actually need with in the language


00:05:15.200 --> 00:05:16.960
to accomplish what it does, right?


00:05:16.960 --> 00:05:19.080
- Yeah, decorators are also another really good example,


00:05:19.080 --> 00:05:24.080
right, like where the concepts for that syntax predates it.


00:05:24.080 --> 00:05:26.920
And it happened to just be something


00:05:26.920 --> 00:05:29.600
where Python core development team


00:05:29.600 --> 00:05:32.480
looked at where people were in terms of development


00:05:32.480 --> 00:05:35.360
and what they needed from Python and realized,


00:05:35.360 --> 00:05:40.040
you know what, that common pattern that people are doing


00:05:40.040 --> 00:05:43.160
would actually be, would be very well served


00:05:43.160 --> 00:05:44.440
via a piece of syntax.


00:05:44.440 --> 00:05:45.480
So why don't we just do that?


00:05:45.480 --> 00:05:47.440
Why don't we introduce that piece of syntax,


00:05:47.440 --> 00:05:48.280
make these up?


00:05:48.280 --> 00:05:49.760
As you said, with context managers,


00:05:49.760 --> 00:05:51.400
we're a perfect example, right?


00:05:51.400 --> 00:05:54.680
Where before, if you wanted to do the right thing


00:05:54.680 --> 00:05:59.160
when you opened a file, is you call the open function


00:05:59.160 --> 00:06:01.240
for your file, assign it to a variable,


00:06:01.240 --> 00:06:04.840
do your try block of everything you wanna do with the file,


00:06:04.840 --> 00:06:07.160
and then in the finally part of the try finally,


00:06:07.160 --> 00:06:08.720
close that file.


00:06:08.720 --> 00:06:11.080
Which, I mean, if you just think about it


00:06:11.080 --> 00:06:14.640
compared to a with statement is four lines,


00:06:14.640 --> 00:06:16.320
assuming you're doing reasonable formatting


00:06:16.320 --> 00:06:19.360
for the assignment, the try, the finally,


00:06:19.360 --> 00:06:23.160
then the close call, versus the single with open


00:06:23.160 --> 00:06:25.280
to get the exact same effect.


00:06:25.280 --> 00:06:26.120
- Yeah.


00:06:26.120 --> 00:06:29.120
And then you've also got the possibility


00:06:29.120 --> 00:06:30.600
that the context manager,


00:06:30.600 --> 00:06:32.680
the thing that's used in the with block,


00:06:32.680 --> 00:06:35.880
can do something different if there's an exception, right?


00:06:35.880 --> 00:06:37.560
Like if there's an exception, it could say,


00:06:37.560 --> 00:06:38.720
if it's a database transaction,


00:06:38.720 --> 00:06:40.920
it could roll back the transaction automatically.


00:06:40.920 --> 00:06:42.880
Rather, if there's no exception,


00:06:42.880 --> 00:06:45.000
it could commit it automatically.


00:06:45.000 --> 00:06:46.720
- Right, but there's no real magic there


00:06:46.720 --> 00:06:47.640
if you think about it in the end.


00:06:47.640 --> 00:06:50.080
You could have written that all up by hand.


00:06:50.080 --> 00:06:51.400
It just would have been cumbersome.


00:06:51.400 --> 00:06:53.240
But that makes the with statement


00:06:53.240 --> 00:06:54.680
very much a piece of syntactic sugar


00:06:54.680 --> 00:06:57.160
where you could totally write it out,


00:06:57.160 --> 00:06:59.160
get the exact same semantic outcome.


00:06:59.160 --> 00:07:03.400
- Probably similar performance as well, maybe.


00:07:03.400 --> 00:07:05.800
- Yeah, I think it depends.


00:07:07.000 --> 00:07:08.440
It really depends on the syntax, right?


00:07:08.440 --> 00:07:10.440
Like how complicated it is,


00:07:10.440 --> 00:07:12.160
how much of it's gonna call into,


00:07:12.160 --> 00:07:14.120
at least in CPython's case, into the C code


00:07:14.120 --> 00:07:15.640
and stay in the C code,


00:07:15.640 --> 00:07:18.520
versus not like with context managers,


00:07:18.520 --> 00:07:20.320
it probably won't just because the point


00:07:20.320 --> 00:07:22.000
is you're gonna call that dunder enter method


00:07:22.000 --> 00:07:23.360
or that dunder exit method.


00:07:23.360 --> 00:07:24.600
So you're calling Python code,


00:07:24.600 --> 00:07:27.120
so no real, probably big shift.


00:07:27.120 --> 00:07:31.360
But for stuff that we'll probably cover in this podcast,


00:07:31.360 --> 00:07:33.640
there are other bits that go into the C code


00:07:33.640 --> 00:07:35.000
and stay in the C code.


00:07:35.000 --> 00:07:38.000
And when that happens, stuff can go really, really fast.


00:07:38.000 --> 00:07:38.840
Especially with all the work


00:07:38.840 --> 00:07:41.720
the Faster CPython team's done around stuff and all that.


00:07:41.720 --> 00:07:43.640
So the point is you can just start


00:07:43.640 --> 00:07:45.680
to just kind of leap into C code,


00:07:45.680 --> 00:07:47.840
stay there and get stuff done way faster,


00:07:47.840 --> 00:07:49.840
comparative to writing out by hand


00:07:49.840 --> 00:07:51.600
where if you're staying in the Python world,


00:07:51.600 --> 00:07:53.160
it can just take a bit longer.


00:07:53.160 --> 00:07:57.720
- Yeah, so sugar, the word sugar,


00:07:57.720 --> 00:07:58.920
I think it's a good one here.


00:07:58.920 --> 00:08:01.720
I love like these ideas like code smells,


00:08:01.720 --> 00:08:03.200
code sugar, all the things.


00:08:04.200 --> 00:08:08.240
It makes it sound a little frivolous, maybe.


00:08:08.240 --> 00:08:11.080
Like a little, it's nice to have it,


00:08:11.080 --> 00:08:12.640
sweetens it up, you don't really need it.


00:08:12.640 --> 00:08:14.960
But I do think having these different constructs,


00:08:14.960 --> 00:08:17.480
like when you see a with block,


00:08:17.480 --> 00:08:20.200
it instantly conveys meaning.


00:08:20.200 --> 00:08:21.520
It means we're gonna create a thing,


00:08:21.520 --> 00:08:24.440
we have a cleanup section, we don't have to deal with it.


00:08:24.440 --> 00:08:27.160
As opposed to if you see a try except finally,


00:08:27.160 --> 00:08:29.240
you have to read it and process it.


00:08:29.240 --> 00:08:31.120
Okay, does it actually do the things


00:08:31.120 --> 00:08:31.960
that would be accomplished?


00:08:31.960 --> 00:08:35.360
I think these sugars let you also think,


00:08:35.360 --> 00:08:36.320
not just write less good,


00:08:36.320 --> 00:08:39.720
but think in different levels of abstraction.


00:08:39.720 --> 00:08:41.440
- Yeah, I mean, as you said,


00:08:41.440 --> 00:08:44.920
the use of the word sugar is meant to mean


00:08:44.920 --> 00:08:46.120
something sweet, something nice.


00:08:46.120 --> 00:08:48.440
It's a treat, it's a bonus.


00:08:48.440 --> 00:08:51.440
So from the perspective of if you didn't have it,


00:08:51.440 --> 00:08:52.400
you could still accomplish it.


00:08:52.400 --> 00:08:57.400
But that can potentially, in a way, as you suggested,


00:08:57.400 --> 00:09:01.140
not quite denote the benefit of it, right?


00:09:01.140 --> 00:09:03.320
Like if we think of sugar in terms of


00:09:03.320 --> 00:09:04.840
not something good for your diet.


00:09:04.840 --> 00:09:06.920
- Yeah, what is your perspective on sugar?


00:09:06.920 --> 00:09:09.400
Are you a fan of desserts or are you trying to cut it out?


00:09:09.400 --> 00:09:10.440
- Yeah, exactly.


00:09:10.440 --> 00:09:13.120
So, but yeah, I mean, the hope is


00:09:13.120 --> 00:09:16.240
whenever we add syntax to Python,


00:09:16.240 --> 00:09:18.120
it's for everyone's general benefit, right?


00:09:18.120 --> 00:09:19.680
This is why we don't do it very often.


00:09:19.680 --> 00:09:22.600
And when we do do it, it's a very thoughtful discussion,


00:09:22.600 --> 00:09:26.760
very long discussion, sometimes contentious discussion.


00:09:26.760 --> 00:09:29.640
Walrus Operator is the famous one for that.


00:09:29.640 --> 00:09:32.020
- I don't understand the contention of the Walrus Operator.


00:09:32.020 --> 00:09:35.740
It's such a small change to the language.


00:09:35.740 --> 00:09:37.540
There's so many other things that are bigger changes


00:09:37.540 --> 00:09:38.420
that could have been battles,


00:09:38.420 --> 00:09:40.860
but I guess it just came to a head at that point


00:09:40.860 --> 00:09:42.140
or something, right?


00:09:42.140 --> 00:09:44.060
- Yeah, I mean, for those of you who don't know,


00:09:44.060 --> 00:09:46.380
the Walrus Operator is the thing that pushed Guido


00:09:46.380 --> 00:09:48.620
kind of over the edge to finally step down


00:09:48.620 --> 00:09:51.100
as being the dictator for life.


00:09:51.100 --> 00:09:55.340
And it was just due to the veracity of the opposition to it


00:09:55.340 --> 00:09:59.540
and just how basically angry it made people.


00:09:59.540 --> 00:10:01.500
And you're right, it's very small.


00:10:01.500 --> 00:10:04.020
And to be honest, I've used it and I like it.


00:10:04.020 --> 00:10:04.860
I get use out of it.


00:10:04.860 --> 00:10:08.020
It means I use it for its purpose,


00:10:08.020 --> 00:10:11.340
which was to add some basic syntax for those situations


00:10:11.340 --> 00:10:12.780
where you always have that assignment,


00:10:12.780 --> 00:10:15.500
and then you do something like an if or something,


00:10:15.500 --> 00:10:17.300
and then you're gonna do something,


00:10:17.300 --> 00:10:18.940
like just be able to inline certain things


00:10:18.940 --> 00:10:20.780
to just do the right thing.


00:10:20.780 --> 00:10:24.300
It's not a huge thing, but it's a nice thing.


00:10:24.300 --> 00:10:26.300
And in that case, I don't know.


00:10:26.300 --> 00:10:29.780
Honestly, a lot of people got really concerned


00:10:29.780 --> 00:10:33.340
that they didn't see the usefulness enough,


00:10:33.340 --> 00:10:37.020
that they thought it was gonna be a slippery slope,


00:10:37.020 --> 00:10:39.840
or people are always very concerned


00:10:39.840 --> 00:10:41.820
about Python getting too big


00:10:41.820 --> 00:10:44.300
and that's no longer fitting in their brain.


00:10:44.300 --> 00:10:48.140
- Yeah, maybe it was kind of the last straw sort of thing,


00:10:48.140 --> 00:10:50.020
rather than like maybe stuff came before


00:10:50.020 --> 00:10:51.180
and they're like, all right, that's it.


00:10:51.180 --> 00:10:54.620
And now the Walrus, the Walrus, like, I don't know.


00:10:54.620 --> 00:10:55.460
- I don't know.


00:10:55.460 --> 00:10:56.580
I mean, I don't think people realize


00:10:56.580 --> 00:10:58.060
that we actually cut syntax out


00:10:58.060 --> 00:11:00.620
when we moved from Python 2 to Python 3, right?


00:11:00.620 --> 00:11:01.460
Like there was actual-- - Yeah, that was all


00:11:01.460 --> 00:11:02.620
kind of brewing.


00:11:02.620 --> 00:11:04.060
- Yeah, like the backticks went away.


00:11:04.060 --> 00:11:05.900
Like no one knows about backticks anymore,


00:11:05.900 --> 00:11:07.980
but we used to have syntax for using backticks,


00:11:07.980 --> 00:11:10.580
and that's gone now.


00:11:10.580 --> 00:11:13.720
So it's not like it's always been a add, add, add.


00:11:13.720 --> 00:11:16.220
But I think it's just one of these things


00:11:16.220 --> 00:11:17.440
where it's just people were very concerned


00:11:17.440 --> 00:11:19.680
that Python would get too big, too complicated,


00:11:19.680 --> 00:11:22.280
and it wouldn't be fully understandable.


00:11:22.280 --> 00:11:25.300
I will say whenever we do this,


00:11:25.300 --> 00:11:28.260
we very much consider how easy it would be


00:11:28.260 --> 00:11:30.740
to understand if you saw it for the first time


00:11:30.740 --> 00:11:32.900
and never received any instruction about it, right?


00:11:32.900 --> 00:11:35.820
Like I would argue that Walrus Operator is a bit obvious


00:11:35.820 --> 00:11:38.620
if you look at the code around it of what it does.


00:11:38.620 --> 00:11:41.660
And so you can probably figure out what it does


00:11:41.660 --> 00:11:43.380
without being told ahead of time


00:11:43.380 --> 00:11:45.980
versus other syntax in other languages


00:11:45.980 --> 00:11:48.860
where we go, I have no clue what this does.


00:11:48.860 --> 00:11:49.700
- Right, exactly.


00:11:49.700 --> 00:11:53.500
- Like why does plus plus and C do different things


00:11:53.500 --> 00:11:54.820
if it's in the front or the back,


00:11:54.820 --> 00:11:56.500
and what's the difference, right?


00:11:56.500 --> 00:11:58.900
Like unless you know prefix versus suffix,


00:11:58.900 --> 00:12:01.720
increment, and the difference in terms of referencing


00:12:01.720 --> 00:12:03.900
the pointer and all this crazy stuff,


00:12:03.900 --> 00:12:05.900
like you're not gonna necessarily pick up on the difference


00:12:05.900 --> 00:12:06.820
unless you run your code,


00:12:06.820 --> 00:12:08.180
versus something where you can just look at it


00:12:08.180 --> 00:12:10.580
and just learn on the spot.


00:12:10.580 --> 00:12:12.020
- Yeah.


00:12:12.020 --> 00:12:16.460
Well, I wanna give you all a bit of a compliment, I guess,


00:12:16.460 --> 00:12:18.900
or encouragement.


00:12:18.900 --> 00:12:23.180
I think the Python language is not changing too fast.


00:12:23.180 --> 00:12:26.940
I think the stability over time is really good.


00:12:26.940 --> 00:12:28.660
You compare that to other languages.


00:12:28.660 --> 00:12:31.480
I mean, here's one that's kind of close to home for you


00:12:31.480 --> 00:12:33.260
since you're at Microsoft, like C#.


00:12:33.260 --> 00:12:36.580
I feel like that language, it's pretty nice,


00:12:36.580 --> 00:12:37.580
at least in the early days.


00:12:37.580 --> 00:12:41.960
And now there's a whole team who are employed.


00:12:41.960 --> 00:12:43.400
You don't have to make any comment, I know you work there,


00:12:43.400 --> 00:12:45.780
but there's a whole team who's employed


00:12:45.780 --> 00:12:49.140
to like shepherd that language.


00:12:49.140 --> 00:12:50.620
And I feel like there's a feeling


00:12:50.620 --> 00:12:53.300
that they always need to have some new language features


00:12:53.300 --> 00:12:56.220
because it's their job to have language features.


00:12:56.220 --> 00:12:58.940
And there's just like a constant kind of trend,


00:12:58.940 --> 00:13:00.860
like for properties, like we have properties,


00:13:00.860 --> 00:13:01.700
they have properties.


00:13:01.700 --> 00:13:03.500
But I think there's four to five different ways


00:13:03.500 --> 00:13:07.020
that properties in C# that have evolved over time.


00:13:07.020 --> 00:13:08.900
And you're just like, yes, a little better,


00:13:08.900 --> 00:13:10.620
but it's why do we have so many ways


00:13:10.620 --> 00:13:11.820
if you're gonna be that, right?


00:13:11.820 --> 00:13:15.860
And so when I at least look at Python


00:13:15.860 --> 00:13:19.940
compared to like my background in C++ or in C#


00:13:19.940 --> 00:13:24.180
or JavaScript, I feel like it's comfortable.


00:13:24.180 --> 00:13:26.700
It's not stale, but it's not,


00:13:26.700 --> 00:13:28.740
we don't have five ways to do properties.


00:13:28.740 --> 00:13:32.460
You know, and that's a good thing.


00:13:32.460 --> 00:13:34.060
Even if there's a better way to do it,


00:13:34.060 --> 00:13:36.340
it might not be worth having two to three ways


00:13:36.340 --> 00:13:39.140
just for that, for a slight advantage.


00:13:39.140 --> 00:13:41.380
- Well, thank you for the kind words.


00:13:41.380 --> 00:13:44.980
Yeah, I mean, we do have, the Zen of Python


00:13:44.980 --> 00:13:46.740
does kind of outline the general guidelines


00:13:46.740 --> 00:13:48.260
we try to follow when doing,


00:13:48.260 --> 00:13:50.300
making these discussions, decisions.


00:13:50.300 --> 00:13:52.460
For those who've never read the Zen of Python,


00:13:52.460 --> 00:13:55.620
just run import this from the REPL and you'll find it.


00:13:55.620 --> 00:14:00.220
And yeah, it's just the way it's designed, right?


00:14:00.220 --> 00:14:03.020
Hopefully there's one,


00:14:03.020 --> 00:14:06.420
hopefully only one obvious way to do anything.


00:14:06.420 --> 00:14:08.820
And so it's just something we've kind of leaned into.


00:14:08.820 --> 00:14:11.020
Now, granted, things shift,


00:14:11.020 --> 00:14:12.700
like I'm sure someone will point out


00:14:12.700 --> 00:14:15.700
the myriad of ways you can format a string now,


00:14:15.700 --> 00:14:17.300
but a lot of that's backwards compatibility


00:14:17.300 --> 00:14:18.580
and just realizing, you know what?


00:14:18.580 --> 00:14:19.740
We just have to accept the fact


00:14:19.740 --> 00:14:23.020
the first way we got it is no longer


00:14:23.020 --> 00:14:24.820
the best way we can think of.


00:14:24.820 --> 00:14:27.900
And it's enough of a jump from using string interpolation


00:14:27.900 --> 00:14:30.460
with the percent sign to using f-strings


00:14:30.460 --> 00:14:33.820
that it was worth adding a second way.


00:14:33.820 --> 00:14:37.780
Now, maybe someday we'll take out string interpolation.


00:14:37.780 --> 00:14:40.620
I doubt it 'cause it just works and it's just sitting there


00:14:40.620 --> 00:14:43.140
and it's not worth breaking really old code.


00:14:43.140 --> 00:14:46.700
But I mean, yeah, it's just the way we approach things.


00:14:46.700 --> 00:14:47.780
And luckily most people like it.


00:14:47.780 --> 00:14:49.580
And I think that's kind of why some people always freak out


00:14:49.580 --> 00:14:51.700
is they're always afraid somehow


00:14:51.700 --> 00:14:53.820
we're gonna go downhill from here


00:14:53.820 --> 00:14:55.300
and it's just the start of things


00:14:55.300 --> 00:14:57.140
or somehow Python is gonna be harder to learn.


00:14:57.140 --> 00:14:58.860
Well, we very much try to make sure


00:14:58.860 --> 00:15:01.380
Python is a gradual curve of learning, right?


00:15:01.380 --> 00:15:03.540
The basics are very straightforward and good.


00:15:03.540 --> 00:15:04.900
And as you get into more advanced things


00:15:04.900 --> 00:15:06.180
like the match statement, right?


00:15:06.180 --> 00:15:08.460
Like you'll be able to see it and understand it


00:15:08.460 --> 00:15:09.300
and it'll make sense,


00:15:09.300 --> 00:15:11.020
but not something you'll necessarily learn


00:15:11.020 --> 00:15:12.260
the first month or two,


00:15:12.260 --> 00:15:14.100
but it's there for when you do need it, right?


00:15:14.100 --> 00:15:15.980
Like we very much try to make sure


00:15:15.980 --> 00:15:19.700
that everything makes sense on a curve


00:15:19.700 --> 00:15:20.740
from beginner to advanced


00:15:20.740 --> 00:15:22.940
and try to make sure the language is useful to everyone


00:15:22.940 --> 00:15:25.300
from both a beginner to advanced user.


00:15:25.300 --> 00:15:28.140
It's tricky, but I'd like to do a decent job.


00:15:28.140 --> 00:15:29.100
- I think you are.


00:15:29.100 --> 00:15:32.260
I think one of Python's really,


00:15:32.260 --> 00:15:34.900
one of its powers is that you can be super effective with it


00:15:34.900 --> 00:15:37.980
with a really partial understanding of what it is.


00:15:37.980 --> 00:15:38.980
- Yeah.


00:15:38.980 --> 00:15:39.820
- Right?


00:15:39.820 --> 00:15:41.780
You don't have to understand namespaces, classes,


00:15:41.780 --> 00:15:44.020
async, et cetera, et cetera.


00:15:44.020 --> 00:15:44.860
You just like, well,


00:15:44.860 --> 00:15:45.980
I think I can write these four lines


00:15:45.980 --> 00:15:48.060
in a, without even a function


00:15:48.060 --> 00:15:50.340
and I'll get a cool graph that'll show my work


00:15:50.340 --> 00:15:51.220
or whatever, right?


00:15:51.220 --> 00:15:52.180
- Yep, exactly.


00:15:52.180 --> 00:15:53.020
- Yep.


00:15:53.020 --> 00:15:56.220
So, and I think I have a pretty partial understanding


00:15:56.220 --> 00:15:57.060
of the match statement.


00:15:57.060 --> 00:15:59.380
I know it can get pretty advanced


00:15:59.380 --> 00:16:01.300
in like how it captures and changes values,


00:16:01.300 --> 00:16:03.500
but I wrote one yesterday with a partial understanding.


00:16:03.500 --> 00:16:04.340
It went great.


00:16:04.340 --> 00:16:05.180
- Nice.


00:16:05.180 --> 00:16:06.820
- Yeah, indeed.


00:16:06.820 --> 00:16:07.660
All right.


00:16:07.660 --> 00:16:09.620
Before we move on though,


00:16:09.620 --> 00:16:12.660
gotta go back to your opening


00:16:12.660 --> 00:16:15.580
because you said,


00:16:15.580 --> 00:16:17.260
"I created this to understand,


00:16:17.260 --> 00:16:20.060
like if I were to solve that problem,"


00:16:20.060 --> 00:16:21.780
your wife had about like,


00:16:21.780 --> 00:16:23.500
"You gotta fix that thing about the browser."


00:16:23.500 --> 00:16:25.500
And I know there's some folks in Texas


00:16:25.500 --> 00:16:26.860
who have thoughts on this as well,


00:16:26.860 --> 00:16:28.260
on the PyScript team.


00:16:28.260 --> 00:16:33.820
But is this a project you're actively working on


00:16:33.820 --> 00:16:36.700
or just a, let me gather up,


00:16:36.700 --> 00:16:38.700
do some research and deep thinking


00:16:38.700 --> 00:16:41.100
about what is actually in the language


00:16:41.100 --> 00:16:42.300
that would have to carry over


00:16:42.300 --> 00:16:44.020
or what is this?


00:16:44.020 --> 00:16:48.300
- No, it's not an active project of mine at the moment.


00:16:48.300 --> 00:16:51.780
It ended up being mostly just an exercise


00:16:51.780 --> 00:16:54.060
and just snowballed into a thing


00:16:54.060 --> 00:16:56.700
where I just didn't wanna stop until I completed it.


00:16:56.700 --> 00:16:57.540
- Yeah.


00:16:57.540 --> 00:17:01.660
How do you feel about the MicroPython,


00:17:01.660 --> 00:17:04.740
PyScript angle of approaching this?


00:17:04.740 --> 00:17:06.940
- Yeah, I mean, I think it's great.


00:17:06.940 --> 00:17:08.820
I mean, that was the other hopeful benefit


00:17:08.820 --> 00:17:10.460
about all of this,


00:17:10.460 --> 00:17:15.100
is trying to nail down the definition of what Python is.


00:17:15.100 --> 00:17:15.940
- Yeah.


00:17:15.940 --> 00:17:18.100
- 'Cause I've heard those arguments


00:17:18.100 --> 00:17:19.260
made against MicroPython,


00:17:19.260 --> 00:17:20.380
that it's not quite Python


00:17:20.380 --> 00:17:22.420
'cause it doesn't quite run all the syntax


00:17:22.420 --> 00:17:25.060
or it doesn't have the entire standard library.


00:17:25.060 --> 00:17:27.140
I've gotten into arguments with people online


00:17:27.140 --> 00:17:30.220
where they got very upset when I suggested


00:17:30.220 --> 00:17:32.340
that the REPL was an optional part of Python


00:17:32.340 --> 00:17:34.620
and actually not a requirement.


00:17:34.620 --> 00:17:39.620
And so I just viewed it as a learning experience for me,


00:17:40.420 --> 00:17:42.780
hopefully a learning experience for others as well.


00:17:42.780 --> 00:17:45.900
And then after that was just trying to hopefully clarify,


00:17:45.900 --> 00:17:48.260
like, look, this is truly what you have to have


00:17:48.260 --> 00:17:49.460
to really be Python.


00:17:49.460 --> 00:17:50.900
Like you literally cannot implement


00:17:50.900 --> 00:17:53.140
the rest of the language without this,


00:17:53.140 --> 00:17:55.060
but everything else, you could totally just do it yourself.


00:17:55.060 --> 00:17:58.200
You could totally just write your tool to make it all work.


00:17:58.200 --> 00:17:59.660
And as long as this existed,


00:17:59.660 --> 00:18:02.100
you could totally get by with it.


00:18:02.100 --> 00:18:03.980
And so that's kind of where I ended up.


00:18:03.980 --> 00:18:07.300
I, luckily the tooling around WebAssembly


00:18:07.300 --> 00:18:08.260
got far enough along,


00:18:08.260 --> 00:18:10.260
Pyodites continue to do well in the browser.


00:18:10.260 --> 00:18:12.700
I've been working on the WebAssembly,


00:18:12.700 --> 00:18:15.300
the system interface Wazzy side of things,


00:18:15.300 --> 00:18:16.940
and that's been going pretty well.


00:18:16.940 --> 00:18:19.980
So that's at least taking care of itself.


00:18:19.980 --> 00:18:23.980
So I've ultimately not tackled the huge problem


00:18:23.980 --> 00:18:26.580
of trying to re-implement Python from scratch,


00:18:26.580 --> 00:18:29.460
probably in Rust, just in a minimal fashion


00:18:29.460 --> 00:18:31.860
to try to make it work better in the browser.


00:18:31.860 --> 00:18:34.820
That's probably a project for when I retire.


00:18:34.820 --> 00:18:38.300
And I suspect that's at least a decade out, if not more.


00:18:38.300 --> 00:18:40.340
So that's probably gonna be put on the back burner


00:18:40.340 --> 00:18:41.180
for a while.


00:18:41.180 --> 00:18:42.000
- Right, yeah.


00:18:42.000 --> 00:18:43.340
You could all install BPython


00:18:43.340 --> 00:18:45.380
and run Brett Python built in Rust.


00:18:45.380 --> 00:18:46.380
- Yeah, there you go.


00:18:46.380 --> 00:18:49.220
(laughing)


00:18:49.220 --> 00:18:53.740
- Rust does seem to be having quite the influence,


00:18:53.740 --> 00:18:57.260
an outsized influence for how popular Rust is


00:18:57.260 --> 00:18:58.860
in terms of the number of developers,


00:18:58.860 --> 00:19:02.540
but it seems to be really leaving its mark on Python


00:19:02.540 --> 00:19:05.980
and other areas as well these days.


00:19:05.980 --> 00:19:09.780
- Yeah, well, I mean, I will fully admit I have bias


00:19:09.780 --> 00:19:12.220
'cause I am a fan and I do like using the language,


00:19:12.220 --> 00:19:14.300
but it's one of those things where


00:19:14.300 --> 00:19:16.460
if you've been living in the C and C++ world


00:19:16.460 --> 00:19:18.020
and it never was that satisfying to you,


00:19:18.020 --> 00:19:19.880
but you had to be there for whatever reason,


00:19:19.880 --> 00:19:22.660
and then you discover Rust and it does things


00:19:22.660 --> 00:19:26.580
that saves you from very chronic set of problems.


00:19:26.580 --> 00:19:27.820
Yeah, including yourself.


00:19:32.640 --> 00:19:37.640
You would hope that people would notice and latch onto it.


00:19:37.640 --> 00:19:39.280
I think that's basically what's happened


00:19:39.280 --> 00:19:41.320
is people have just discovered that,


00:19:41.320 --> 00:19:44.960
oh yeah, this is useful and good.


00:19:44.960 --> 00:19:47.600
There's enough C and C++ code in the Python community


00:19:47.600 --> 00:19:50.040
due to C, Python, C API


00:19:50.040 --> 00:19:53.200
that I think there's just a nice cross-section.


00:19:53.200 --> 00:19:54.360
I think it's just one of these things


00:19:54.360 --> 00:19:56.720
where people have just gone like,


00:19:56.720 --> 00:19:59.560
well, I've gotta do the system level programming anyway,


00:19:59.560 --> 00:20:02.480
so I might as well use something that seems like a better--


00:20:02.480 --> 00:20:04.160
- A little more modern. - A little more modern.


00:20:04.160 --> 00:20:05.600
Yeah, a bit more modern.


00:20:05.600 --> 00:20:08.000
And so I think that's kind of what's happened here.


00:20:08.000 --> 00:20:09.340
- That makes sense.


00:20:09.340 --> 00:20:11.720
All right, let's talk about the sugar.


00:20:11.720 --> 00:20:13.040
- Okay.


00:20:13.040 --> 00:20:16.160
- So I think we covered pretty much what syntactic sugar is.


00:20:16.160 --> 00:20:20.640
And yeah, you started this whole thing out saying


00:20:20.640 --> 00:20:24.760
the goal of this is really to kind of nail down


00:20:24.760 --> 00:20:26.240
that minimum Python.


00:20:26.240 --> 00:20:28.360
And I agree that the REPL is optional.


00:20:28.360 --> 00:20:32.600
I like the REPL, but just so I can also get mail.


00:20:32.600 --> 00:20:36.240
I like the language,


00:20:36.240 --> 00:20:38.320
like you can't take away these features


00:20:38.320 --> 00:20:40.600
once you add them, right?


00:20:40.600 --> 00:20:45.080
And so it's like, what could you survive with as a minimum?


00:20:45.080 --> 00:20:48.840
And then you can kind of like, what's the extras?


00:20:48.840 --> 00:20:50.560
- Yeah, what could you build up from there?


00:20:50.560 --> 00:20:51.440
- Yes, exactly.


00:20:51.440 --> 00:20:55.440
And the final destination maybe being CPython proper.


00:20:55.440 --> 00:20:57.560
Yeah.


00:20:57.560 --> 00:21:02.560
So you've got a whole bunch of different aspects of Python


00:21:02.560 --> 00:21:06.760
that you are unraveling in this syntactic sugar.


00:21:06.760 --> 00:21:09.440
And basically to highlight what's actually happening,


00:21:09.440 --> 00:21:12.600
how much of this is going on as you've already laid out.


00:21:12.600 --> 00:21:15.200
So I wanna point out that I'll link to,


00:21:15.200 --> 00:21:17.280
I don't know how many articles you've got here,


00:21:17.280 --> 00:21:18.120
but two years.


00:21:18.120 --> 00:21:19.920
- Over 20, I think.


00:21:19.920 --> 00:21:22.600
- Yeah, like looking like close to 30, maybe.


00:21:22.600 --> 00:21:24.080
I don't know, just eyeballing it.


00:21:24.080 --> 00:21:25.440
There's a lot there.


00:21:25.440 --> 00:21:29.160
So I think I've picked us, you know, half of those hours,


00:21:29.160 --> 00:21:32.440
some reasonable subset that we can talk about.


00:21:32.440 --> 00:21:34.120
And there's some code and stuff in here.


00:21:34.120 --> 00:21:36.000
So we'll kind of have like,


00:21:36.000 --> 00:21:38.640
my thought was we could just talk about kind of like,


00:21:38.640 --> 00:21:39.840
what is the essence of this?


00:21:39.840 --> 00:21:42.760
Like what's really happening when you do attribute access?


00:21:42.760 --> 00:21:45.640
What's really happening when you write the word pass


00:21:45.640 --> 00:21:49.400
or use a with block that we've talked about a little bit.


00:21:49.400 --> 00:21:52.840
So the first one here is unraveling attribute access


00:21:52.840 --> 00:21:53.680
in Python.


00:21:54.840 --> 00:21:57.080
You wanna tell us a bit about what actually happens


00:21:57.080 --> 00:22:00.800
if you just say, you know, like object dot attribute?


00:22:00.800 --> 00:22:02.000
It seems so simple, Brett.


00:22:02.000 --> 00:22:04.560
There's just one dot.


00:22:04.560 --> 00:22:05.680
What's the big deal?


00:22:05.680 --> 00:22:08.560
- Yeah, why doesn't this just, what's there to talk about?


00:22:08.560 --> 00:22:12.360
I mean, when I just do something dot something,


00:22:12.360 --> 00:22:15.320
magically I get back what I expected.


00:22:15.320 --> 00:22:17.820
But there's actually a lot going on there, right?


00:22:17.820 --> 00:22:22.120
And it comes down to multiple layers,


00:22:22.120 --> 00:22:24.680
but it's all ties around Python's object model, right?


00:22:24.680 --> 00:22:28.840
How do all, 'cause I always find this weird to say,


00:22:28.840 --> 00:22:30.240
but Python's more object oriented,


00:22:30.240 --> 00:22:31.880
in my opinion, than Java, right?


00:22:31.880 --> 00:22:35.040
Java has these primitive types like ints and floats


00:22:35.040 --> 00:22:37.720
that have to get boxed and unboxed to fake,


00:22:37.720 --> 00:22:40.480
to make them look like an object to Java itself.


00:22:40.480 --> 00:22:41.360
Python doesn't have that.


00:22:41.360 --> 00:22:42.360
Everything is an object.


00:22:42.360 --> 00:22:43.480
A function is an object.


00:22:43.480 --> 00:22:44.760
An integer is an object.


00:22:44.760 --> 00:22:45.800
- True is an object.


00:22:45.800 --> 00:22:47.140
Seven is an object.


00:22:47.140 --> 00:22:47.980
- Exactly.


00:22:47.980 --> 00:22:49.800
There's nothing you can name in Python


00:22:49.800 --> 00:22:51.640
that's not somehow an object.


00:22:51.640 --> 00:22:52.480
- Yep.


00:22:52.480 --> 00:22:54.920
- So this idea of attributes and all this


00:22:54.920 --> 00:22:58.040
permeates all the way down into the object model,


00:22:58.040 --> 00:23:02.240
which once again, defines kind of everything in a way.


00:23:02.240 --> 00:23:04.840
So the key thing here is there's kind of two parts to it.


00:23:04.840 --> 00:23:07.160
It's how do you look up,


00:23:07.160 --> 00:23:11.640
how do you look up based on inheritance,


00:23:11.640 --> 00:23:15.080
what thing is going to service the call asking


00:23:15.080 --> 00:23:18.600
what is this attributes value basically,


00:23:18.600 --> 00:23:21.760
or what object is bound to this name for the attribute?


00:23:21.760 --> 00:23:24.560
And after that is what methods are gonna get called


00:23:24.560 --> 00:23:25.780
to make that happen?


00:23:25.780 --> 00:23:28.000
'Cause effectively, almost everything in Python


00:23:28.000 --> 00:23:32.240
at the end of the day leads to a method call


00:23:32.240 --> 00:23:33.560
or a function call.


00:23:33.560 --> 00:23:34.400
- Yeah.


00:23:34.400 --> 00:23:38.360
First of all, it leads to a lot of times to an op code,


00:23:38.360 --> 00:23:40.320
which leads to a method call, right?


00:23:40.320 --> 00:23:42.800
A Python bytecode thing.


00:23:42.800 --> 00:23:45.640
And I think it's maybe also worth pointing out,


00:23:45.640 --> 00:23:48.760
like have you point out to everyone listening is,


00:23:48.760 --> 00:23:51.600
Python compiles to this intermediate language


00:23:51.600 --> 00:23:55.200
like Java and .NET compile to intermediate languages.


00:23:55.200 --> 00:23:58.280
It's just what happens then, right?


00:23:58.280 --> 00:23:59.200
Like in those other ones,


00:23:59.200 --> 00:24:01.240
they JIT compile to machine instructions.


00:24:01.240 --> 00:24:03.560
Here it goes through like the big C eval loop


00:24:03.560 --> 00:24:06.680
and delegates to some internal C operations.


00:24:06.680 --> 00:24:08.480
And a lot of these unravelings,


00:24:08.480 --> 00:24:11.720
like kind of look at what happens at that step, right?


00:24:11.720 --> 00:24:14.320
- Yeah, so, yeah.


00:24:14.320 --> 00:24:17.360
So CPython itself is an interpreter, right?


00:24:17.360 --> 00:24:20.760
So what happens is when you load up your Python code


00:24:20.760 --> 00:24:22.960
is Python parses it,


00:24:22.960 --> 00:24:26.400
creates what's called an abstract syntax tree or AST.


00:24:26.400 --> 00:24:29.240
It then takes that AST, does some stuff with it,


00:24:29.240 --> 00:24:33.320
and then it compiles it down to Python bytecode.


00:24:33.320 --> 00:24:37.000
I actually gave a talk on this at PyCon Canada,


00:24:37.000 --> 00:24:38.640
way back when for those who are interested,


00:24:38.640 --> 00:24:43.040
that basically goes from the steps of literally source code


00:24:43.040 --> 00:24:46.240
all the way to execution, if you want more detail.


00:24:46.240 --> 00:24:50.600
But effectively, yeah, we can pile it down to bytecode


00:24:50.600 --> 00:24:55.440
of our own design to then execute in more or less


00:24:55.440 --> 00:24:58.600
what's a big for loop in C.


00:24:58.600 --> 00:24:59.920
- That is really big for loop.


00:24:59.920 --> 00:25:00.920
- Very big for loop.


00:25:00.920 --> 00:25:03.280
And it's gotten a bit fancier


00:25:03.280 --> 00:25:04.920
thanks to the faster CPython team, right?


00:25:04.920 --> 00:25:08.080
Like there's now kind of like lower level opcodes


00:25:08.080 --> 00:25:09.560
that are very type specific


00:25:09.560 --> 00:25:12.360
and we actually auto generate the loop now,


00:25:12.360 --> 00:25:16.040
thanks to them so that it's easier to maintain


00:25:16.040 --> 00:25:17.040
and make tweaks to.


00:25:17.880 --> 00:25:20.680
But essentially it's literally just a set of instructions


00:25:20.680 --> 00:25:21.520
that are extreme,


00:25:21.520 --> 00:25:26.520
that kind of encompass key bits of semantics in Python.


00:25:26.520 --> 00:25:32.080
So for instance, for attribute access,


00:25:32.080 --> 00:25:36.160
there's literally a opcode called load adder, right?


00:25:36.160 --> 00:25:37.920
Where on the execution stack,


00:25:37.920 --> 00:25:40.200
you basically push the object you care about,


00:25:40.200 --> 00:25:41.760
the name of the thing you want,


00:25:41.760 --> 00:25:43.920
and then you just call load adder on it


00:25:43.920 --> 00:25:47.440
and it'll just look it up.


00:25:47.440 --> 00:25:49.280
Actually, technically, I guess it doesn't push the name on it


00:25:49.280 --> 00:25:52.200
that's technically stored in the function.


00:25:52.200 --> 00:25:55.480
There's little details on kind of hand-waving over,


00:25:55.480 --> 00:25:58.480
literally hand-waving if you're watching the live stream,


00:25:58.480 --> 00:26:01.280
but effectively you push the object you want,


00:26:01.280 --> 00:26:02.240
you call load adder,


00:26:02.240 --> 00:26:06.200
give it an argument of what attribute it wants,


00:26:06.200 --> 00:26:08.040
and then load adder opcode behind the scenes


00:26:08.040 --> 00:26:09.200
is the thing that does all the magic


00:26:09.200 --> 00:26:12.120
of calling everything you'd expect, et cetera, et cetera.


00:26:12.120 --> 00:26:13.440
- Yeah, excellent.


00:26:13.440 --> 00:26:15.960
And to view that, a lot of times what you'll do


00:26:15.960 --> 00:26:18.480
is you'll just use the dis module.


00:26:18.480 --> 00:26:20.760
So if people haven't used dis, you can just,


00:26:20.760 --> 00:26:24.800
dis.dis, a lot of disrespect on this function,


00:26:24.800 --> 00:26:29.040
and then it tells you what the opcodes it's made of are.


00:26:29.040 --> 00:26:30.160
- Yeah, exactly.


00:26:30.160 --> 00:26:31.560
I mean, dis is short for disassemble.


00:26:31.560 --> 00:26:33.840
So literally you can pass it a function


00:26:33.840 --> 00:26:36.160
and it will effectively disassemble


00:26:36.160 --> 00:26:39.960
what the function does into the bytecode,


00:26:39.960 --> 00:26:43.280
which is just stored as an attribute of bytes


00:26:43.280 --> 00:26:44.880
on the function object


00:26:44.880 --> 00:26:47.920
and printed out nicely 'cause the dis module


00:26:47.920 --> 00:26:51.360
knows how to map the bytes to what the opcode's name is


00:26:51.360 --> 00:26:53.360
and just gives it a nice way to look at


00:26:53.360 --> 00:26:55.240
and actually read and understand it.


00:26:55.240 --> 00:26:56.880
- Yeah.


00:26:56.880 --> 00:27:01.680
Okay, and so then in this example, you said,


00:27:01.680 --> 00:27:03.400
"Look, here's the case statement


00:27:03.400 --> 00:27:07.960
"in that tremendous for loop switch thing


00:27:07.960 --> 00:27:09.640
"that does the execution.


00:27:09.640 --> 00:27:12.000
"What do we do if we see load adder?"


00:27:12.000 --> 00:27:17.000
And ultimately it comes down to this pyobject_get adder.


00:27:17.000 --> 00:27:19.920
So it seems so simple.


00:27:19.920 --> 00:27:23.040
You just object.attribute, object.field, whatever.


00:27:23.040 --> 00:27:25.560
But it turns out there's just so many variations


00:27:25.560 --> 00:27:27.200
and so much going on down here.


00:27:27.200 --> 00:27:30.200
And I don't necessarily want you to go through


00:27:30.200 --> 00:27:32.000
all the details 'cause it's pretty,


00:27:32.000 --> 00:27:33.440
some of it's pretty intense C


00:27:33.440 --> 00:27:36.000
and a lot of it, optimizations and stuff.


00:27:36.000 --> 00:27:39.520
But just give people a sense of what actually happens


00:27:39.520 --> 00:27:43.320
down in the guts when you try to do it.


00:27:43.320 --> 00:27:46.480
- Well, so in the case of attribute access,


00:27:46.480 --> 00:27:48.880
that effectively ends up calling


00:27:48.880 --> 00:27:51.240
the get adder built-in function.


00:27:51.240 --> 00:27:55.800
And in that case, it needs to check


00:27:55.800 --> 00:27:57.520
how many arguments it gets to start.


00:27:57.520 --> 00:27:58.680
Did you give it two arguments


00:27:58.680 --> 00:27:59.840
or did you give it three arguments


00:27:59.840 --> 00:28:01.960
so you return a default value


00:28:01.960 --> 00:28:04.520
if the attribute doesn't exist?


00:28:04.520 --> 00:28:05.640
And then at the C level,


00:28:05.640 --> 00:28:07.920
we have to check what you gave it


00:28:07.920 --> 00:28:11.600
because just like a Python level,


00:28:11.600 --> 00:28:15.680
or the C code all types to what's called the toPy object,


00:28:15.680 --> 00:28:18.240
which is basically a massive struct in C


00:28:18.240 --> 00:28:21.600
that represents any and all Python objects.


00:28:21.600 --> 00:28:23.040
So even at the C level,


00:28:23.040 --> 00:28:28.040
we don't know if you gave us a string or an integer


00:28:28.040 --> 00:28:31.120
or what did you give us for the name


00:28:31.120 --> 00:28:32.760
of the attribute that you want.


00:28:32.760 --> 00:28:34.800
So we gotta do that, right?


00:28:34.800 --> 00:28:37.080
And so there's just basic,


00:28:37.080 --> 00:28:40.960
like just safety checks to go like, nope.


00:28:40.960 --> 00:28:45.600
Like if you call get adder with wanting the attribute 42,


00:28:45.600 --> 00:28:48.360
which is a number, it's gonna throw a type error.


00:28:48.360 --> 00:28:49.960
Well, that code's gotta exist somewhere


00:28:49.960 --> 00:28:52.560
and this is where it exists, right?


00:28:52.560 --> 00:28:55.880
And then effectively just bubbles all down to the C API


00:28:55.880 --> 00:28:58.560
where a lot of this stuff gets exposed in its own way.


00:28:58.560 --> 00:28:59.960
And specifically in this case,


00:28:59.960 --> 00:29:02.920
ends up calling PyObject get adder.


00:29:02.920 --> 00:29:05.360
- Yeah, and I think another thing


00:29:05.360 --> 00:29:07.080
that's pretty interesting here is,


00:29:07.080 --> 00:29:12.040
it's not always just a value, right?


00:29:12.040 --> 00:29:15.600
That object.adder, that adder could be a property.


00:29:15.600 --> 00:29:17.360
That adder could be a descriptor,


00:29:17.360 --> 00:29:21.280
which I guess is a generalization of a property.


00:29:21.280 --> 00:29:22.880
It could be on the class type,


00:29:22.880 --> 00:29:25.080
but not on the instance types, you gotta find that.


00:29:25.080 --> 00:29:26.960
It could be on the instant type overriding,


00:29:26.960 --> 00:29:27.920
but only there, right?


00:29:27.920 --> 00:29:29.360
Like it could not exist.


00:29:29.360 --> 00:29:32.640
All of these scenarios you gotta go through.


00:29:32.640 --> 00:29:36.680
And so it really emphasizes how much


00:29:36.680 --> 00:29:38.880
is actually going on in the runtime


00:29:38.880 --> 00:29:43.480
while this single simple line seems to be running, right?


00:29:43.480 --> 00:29:46.120
- Yeah, I mean, in the simple case, right?


00:29:46.120 --> 00:29:48.240
Hitting the dots, not complicated.


00:29:48.240 --> 00:29:50.960
Like in general, what you end up doing


00:29:50.960 --> 00:29:53.280
is you have your object, you hit dot,


00:29:53.280 --> 00:29:56.640
and what it does is it looks in the dunderdict attribute


00:29:56.640 --> 00:30:00.160
of the object and there's a key matching that to rename


00:30:00.160 --> 00:30:02.560
and it just gets the thing in the dictionary and that's it.


00:30:02.560 --> 00:30:03.760
You're done.


00:30:03.760 --> 00:30:05.760
But as you alluded to,


00:30:05.760 --> 00:30:08.640
how the heck do you even get to that basic case


00:30:08.640 --> 00:30:12.120
or those more complicated cases, as you said, descriptors,


00:30:12.120 --> 00:30:15.920
right, which are how we actually implement properties


00:30:15.920 --> 00:30:20.520
or if it's on the class versus the instance


00:30:20.520 --> 00:30:23.320
and what happens if there's inheritance


00:30:23.320 --> 00:30:25.920
or multiple inheritance


00:30:25.920 --> 00:30:28.240
or dunder get adder was defined, right?


00:30:28.240 --> 00:30:31.360
Like basically almost all of this ends up flowing through


00:30:32.200 --> 00:30:33.480
the get adder built-in,


00:30:33.480 --> 00:30:35.920
which effectively ends up calling the appropriate


00:30:35.920 --> 00:30:38.760
dunder get attribute method off of an object.


00:30:38.760 --> 00:30:42.880
And this is one of those bare level kind of things, right?


00:30:42.880 --> 00:30:46.480
Where you have to implement this to make Python work.


00:30:46.480 --> 00:30:49.520
You have to basically implement the get adder built-in


00:30:49.520 --> 00:30:51.520
and it has to understand how objects are structured


00:30:51.520 --> 00:30:56.040
underneath the hood to know how basically methods


00:30:56.040 --> 00:30:57.400
and stuff are attached to an object.


00:30:57.400 --> 00:30:58.880
You really can't fake that.


00:30:58.880 --> 00:31:01.360
There's no way to not kind of have that


00:31:01.360 --> 00:31:04.960
as a low level detail that you can just unravel.


00:31:04.960 --> 00:31:07.040
It has to be implemented by the interpreter.


00:31:07.040 --> 00:31:09.640
And in this case, effectively,


00:31:09.640 --> 00:31:12.440
the way Python does things is it knows the order.


00:31:12.440 --> 00:31:15.200
You can always actually call the MRO method on any object


00:31:15.200 --> 00:31:18.080
and it will return you the method resolution order.


00:31:18.080 --> 00:31:20.040
And effectively what Python's doing


00:31:20.040 --> 00:31:24.920
is if it checks on something to see if it has it or not,


00:31:24.920 --> 00:31:26.640
it will effectively end up calling


00:31:26.640 --> 00:31:30.880
the dunder get attribute object, method, sorry, on object.


00:31:30.880 --> 00:31:32.720
That's usually where it bottoms out.


00:31:32.720 --> 00:31:35.160
And unless you happen to have a dunder get adder,


00:31:35.160 --> 00:31:38.240
if that fails, but that's only in the failure case.


00:31:38.240 --> 00:31:39.520
But really in the end,


00:31:39.520 --> 00:31:43.720
almost everything passes through object.dunder get attribute.


00:31:43.720 --> 00:31:45.280
And that's really where all this ends up going.


00:31:45.280 --> 00:31:48.000
But as you said, there's a lot of little twists and turns.


00:31:48.000 --> 00:31:49.680
- Yeah, a lot of these internals,


00:31:49.680 --> 00:31:54.440
you'll see the method resolution order calls


00:31:54.440 --> 00:31:57.800
and it's all about, well, there's a lot of classes


00:31:57.800 --> 00:32:00.480
and a lot of objects, they can override things


00:32:00.480 --> 00:32:01.760
and they can override operators.


00:32:01.760 --> 00:32:05.040
And so there's a lot of navigation to just figure it out,


00:32:05.040 --> 00:32:08.480
not just calling these get adder type of things,


00:32:08.480 --> 00:32:12.960
but like what level does that even supposed to happen on


00:32:12.960 --> 00:32:14.760
given what I'm working with, right?


00:32:14.760 --> 00:32:15.720
- Yeah, exactly.


00:32:15.720 --> 00:32:19.000
And I think this is a good example.


00:32:19.000 --> 00:32:21.320
And the reason I started with this,


00:32:21.320 --> 00:32:22.800
it's so fundamental, right?


00:32:22.800 --> 00:32:25.360
Like how do you unravel something


00:32:25.360 --> 00:32:27.200
if you don't know how to even get an attribute


00:32:27.200 --> 00:32:28.040
off of something?


00:32:28.040 --> 00:32:30.160
So this is why this was the very first post in this series.


00:32:30.160 --> 00:32:32.800
And partially why I went into such detail


00:32:32.800 --> 00:32:34.920
on how to figure all this out, right?


00:32:34.920 --> 00:32:37.000
Like kind of one, this is almost a template


00:32:37.000 --> 00:32:38.960
for anyone else who wanted to go exploring on their own.


00:32:38.960 --> 00:32:40.480
But I think it's also a good example


00:32:40.480 --> 00:32:44.240
of how much complexity and flexibility


00:32:44.240 --> 00:32:49.240
Python hides from users in order to make the simple work,


00:32:49.240 --> 00:32:50.480
but give you the flexibility


00:32:50.480 --> 00:32:52.720
to make the complicated possible, right?


00:32:52.720 --> 00:32:53.560
- Yeah.


00:32:53.560 --> 00:32:57.960
- Like for the vast majority of any of us for our code,


00:32:57.960 --> 00:33:00.520
it just does what you would think it would do


00:33:00.520 --> 00:33:01.960
and it's pretty straightforward.


00:33:01.960 --> 00:33:05.920
But as soon as you get into the fancy world of descriptors


00:33:05.920 --> 00:33:07.600
or gender-coordinated-- - SQLAlchemy.


00:33:07.600 --> 00:33:08.440
- Yeah.


00:33:08.440 --> 00:33:09.280
- I can both have a value


00:33:09.280 --> 00:33:11.360
or I can do a database query with the same thing.


00:33:11.360 --> 00:33:12.600
How is that possible, right?


00:33:12.600 --> 00:33:13.440
Yeah.


00:33:13.440 --> 00:33:14.400
- You want that magic?


00:33:14.400 --> 00:33:15.720
Language has to support it somehow.


00:33:15.720 --> 00:33:20.640
And it requires a lot of finesse and thinking through


00:33:20.640 --> 00:33:23.960
and a lot of mechanisms that generally get hidden from you.


00:33:23.960 --> 00:33:26.480
But someone's got to write that code somewhere.


00:33:26.480 --> 00:33:28.440
And in this case, it's a Python


00:33:28.440 --> 00:33:33.080
and this kind of outlines how that all happens.


00:33:33.080 --> 00:33:35.240
And it's surprisingly complicated.


00:33:35.240 --> 00:33:36.440
It's not horrible.


00:33:36.440 --> 00:33:38.440
- That was my main takeaway too.


00:33:38.440 --> 00:33:40.280
- Yeah, I mean, you can totally read it and follow it.


00:33:40.280 --> 00:33:42.200
I don't wanna scare anyone saying it's so complex


00:33:42.200 --> 00:33:43.040
you can't follow it.


00:33:43.040 --> 00:33:45.880
It's just, it's not just a simple,


00:33:45.880 --> 00:33:48.660
like two if statements and you're done.


00:33:48.660 --> 00:33:51.840
It's like, no, there's subtlety to it


00:33:51.840 --> 00:33:56.840
to make sure the common semantics makes sense to people.


00:33:56.840 --> 00:33:58.200
It's not gonna trip people up


00:33:58.200 --> 00:34:00.400
because it's doing something weird, right?


00:34:00.400 --> 00:34:02.560
There's a lot of thought that goes into these semantics


00:34:02.560 --> 00:34:05.760
to make sure it makes sense for the common case.


00:34:05.760 --> 00:34:10.000
- Another takeaway I got from looking at this is,


00:34:10.000 --> 00:34:12.120
wow, it's nice that dictionaries are fast.


00:34:12.120 --> 00:34:14.560
And how fast are they to make this possible


00:34:14.560 --> 00:34:17.600
to lean on them so much to make this happen?


00:34:17.600 --> 00:34:19.720
- Yeah, I mean, I will say when Guido


00:34:19.720 --> 00:34:21.800
chose to use dictionaries as the namespace,


00:34:21.800 --> 00:34:24.680
it was kind of a unique decision at the time.


00:34:24.680 --> 00:34:27.040
It might still be, honestly.


00:34:27.040 --> 00:34:32.040
But it did simplify some things conceptually


00:34:32.040 --> 00:34:37.400
and also made it so that any wins in how dictionaries work


00:34:37.400 --> 00:34:41.960
is just a massive win universally across the language.


00:34:41.960 --> 00:34:46.080
Right, like if you make dictionaries work in any way better,


00:34:46.080 --> 00:34:49.360
you not only make it work when you just,


00:34:49.360 --> 00:34:53.120
you personally use it as a data structure, as a container,


00:34:53.120 --> 00:34:55.920
but also literally every attribute access


00:34:55.920 --> 00:34:57.040
will get faster, right?


00:34:57.040 --> 00:35:00.360
Like there's a reason why it's so fine-tuned


00:35:00.360 --> 00:35:02.240
and why we don't really touch it very much


00:35:02.240 --> 00:35:05.500
'cause it's been tweaked over the decades


00:35:05.500 --> 00:35:09.240
by a lot of people to be extremely fast


00:35:09.240 --> 00:35:11.460
and for good reason.


00:35:11.460 --> 00:35:13.440
- Yep, indeed.


00:35:13.440 --> 00:35:14.740
One final thought on this.


00:35:15.180 --> 00:35:20.180
You know, you think of optimizing both the memory


00:35:20.180 --> 00:35:21.860
and also the performance a little bit


00:35:21.860 --> 00:35:24.000
by doing things like slots on your classes


00:35:24.000 --> 00:35:26.060
to maybe like short-circuit some of this.


00:35:26.060 --> 00:35:31.180
It feels like somewhere in this world


00:35:31.180 --> 00:35:33.820
lives like some kind of massive optimization


00:35:33.820 --> 00:35:38.540
that maybe, if you said, for this class,


00:35:38.540 --> 00:35:40.920
I'm gonna give up some flexibility,


00:35:40.920 --> 00:35:43.060
is there some way attribute reads and writes


00:35:43.060 --> 00:35:45.540
could get lots faster?


00:35:45.540 --> 00:35:46.900
I don't know, what are you,


00:35:46.900 --> 00:35:48.820
I'm sure this has gone round and round.


00:35:48.820 --> 00:35:51.180
It's such a hot, it's just involved


00:35:51.180 --> 00:35:54.340
in almost every line of Python code and stuff like this.


00:35:54.340 --> 00:35:56.860
- Oh yeah, and this plays into


00:35:56.860 --> 00:35:59.380
what the Faster CPython team has been doing,


00:35:59.380 --> 00:36:03.940
trying to make things faster by looking at


00:36:03.940 --> 00:36:09.700
what the patterns are and if you can just skip stuff.


00:36:09.700 --> 00:36:12.220
How do you short-circuit this thing?


00:36:12.220 --> 00:36:14.660
Can you go like, well, I just know this object


00:36:14.660 --> 00:36:16.020
always look this way.


00:36:16.020 --> 00:36:17.420
Like this was some of the stuff


00:36:17.420 --> 00:36:20.140
that the self-programming language team


00:36:20.140 --> 00:36:25.140
at UC Santa Barbara did, I think in the 70s, maybe 80s.


00:36:25.140 --> 00:36:28.760
I'm just like, well, if we know the layout of the object


00:36:28.760 --> 00:36:30.380
is gonna be consistent.


00:36:30.380 --> 00:36:33.220
- Yeah, can we go seven bytes in and get four bytes?


00:36:33.220 --> 00:36:34.060
That kind of thing, right?


00:36:34.060 --> 00:36:36.780
- Exactly, and you just kind of have to,


00:36:36.780 --> 00:36:39.300
and you start to be able to calculate the shortcuts


00:36:39.300 --> 00:36:41.020
and go like, hey, did anything change


00:36:41.020 --> 00:36:43.100
from the last time I made this assumption?


00:36:43.100 --> 00:36:45.300
No, okay, well then I can use my assumption that's right.


00:36:45.300 --> 00:36:48.340
- Nobody's mocked it, nobody's dynamically messed with it.


00:36:48.340 --> 00:36:51.660
Like maybe it is just a plain thing


00:36:51.660 --> 00:36:54.100
until somebody puts it into an edge case,


00:36:54.100 --> 00:36:56.020
is there a short circuit, right?


00:36:56.020 --> 00:37:00.100
- Yeah, and I mean, I don't wanna go off on a tangent,


00:37:00.100 --> 00:37:01.500
but I mean--


00:37:01.500 --> 00:37:03.500
- Well, I'm one of 17 topics here, Brad.


00:37:03.500 --> 00:37:05.100
Like, no problem, we got lots of time.


00:37:05.100 --> 00:37:08.620
- I have thought about like, after doing this,


00:37:08.620 --> 00:37:12.900
what, is there something syntactic here to add, right?


00:37:12.900 --> 00:37:17.180
Is there a way to kind of come up with a,


00:37:17.180 --> 00:37:20.660
effectively a class definition that's way simpler


00:37:20.660 --> 00:37:22.580
for the really common cases


00:37:22.580 --> 00:37:26.540
that could be optimized extremely fast


00:37:26.540 --> 00:37:30.140
because you give away some flexibility


00:37:30.140 --> 00:37:33.500
and then the interpreter can make assumptions,


00:37:33.500 --> 00:37:37.540
PyPy can make assumptions, et cetera, et cetera.


00:37:37.540 --> 00:37:39.700
And would there be enough wins on that


00:37:39.700 --> 00:37:41.300
to warrant doing it, right?


00:37:41.300 --> 00:37:44.860
Like, could we take the concept of kind of a data class


00:37:44.860 --> 00:37:49.620
that was just data roughly or something along those lines


00:37:49.620 --> 00:37:52.340
and just what could we get out of it


00:37:52.340 --> 00:37:54.980
and what kind of perf wins could we get out of it?


00:37:54.980 --> 00:37:55.820
And would it be worth it?


00:37:55.820 --> 00:37:58.580
Would it be worth adding syntax to the language


00:37:58.580 --> 00:38:00.500
for that case?


00:38:00.500 --> 00:38:04.180
If you look at Mojo, for instance, they have a struct


00:38:04.180 --> 00:38:07.220
and that struct works in a very specific way for performance


00:38:07.220 --> 00:38:09.940
because when you say like this thing can't have new


00:38:09.940 --> 00:38:13.340
attributes, which you can do with slots.


00:38:13.340 --> 00:38:15.460
And for those of you who don't know what slots are,


00:38:15.460 --> 00:38:18.260
if you define a dunder slots attribute on your class,


00:38:18.260 --> 00:38:19.500
you're effectively telling Python,


00:38:19.500 --> 00:38:21.540
don't create a dictionary for me,


00:38:21.540 --> 00:38:24.140
just create effectively a list underneath.


00:38:24.140 --> 00:38:25.860
It's technically a C array.


00:38:25.860 --> 00:38:27.740
And when I need to access something,


00:38:27.740 --> 00:38:30.140
just get it off this array.


00:38:30.140 --> 00:38:31.060
So there's no dictionary.


00:38:31.060 --> 00:38:33.020
You can skip all that dictionary overhead.


00:38:33.020 --> 00:38:35.700
Plus you shrink the memory because now the only amount


00:38:35.700 --> 00:38:38.420
of memory you need is that array for pointers


00:38:38.420 --> 00:38:41.260
to the PI objects and not the dictionary,


00:38:41.260 --> 00:38:43.580
which grows and shrinks and who knows


00:38:43.580 --> 00:38:44.740
what size it's gonna be.


00:38:44.740 --> 00:38:48.540
If we had that built in syntactically,


00:38:48.540 --> 00:38:50.220
would that be beneficial to people or not?


00:38:50.220 --> 00:38:53.300
And I have a prototype in Python code


00:38:53.300 --> 00:38:54.660
of what I'm thinking of.


00:38:54.660 --> 00:38:58.940
I did a blog post on this earlier this year


00:38:58.940 --> 00:39:00.900
to try to feel out people in the community


00:39:00.900 --> 00:39:03.540
and what they thought in terms of restrictions


00:39:03.540 --> 00:39:05.660
and would that be too much or too little.


00:39:05.660 --> 00:39:09.460
I've subsequently prototyped what I wanted


00:39:09.460 --> 00:39:12.900
and there'll be a followup blog post


00:39:12.900 --> 00:39:15.620
about this is where it sits now, what do people think?


00:39:15.620 --> 00:39:17.100
And do people think this is worth trying


00:39:17.100 --> 00:39:19.780
to get syntax for, just don't worry about it.


00:39:19.780 --> 00:39:22.700
It's too close to data classes or what?


00:39:22.700 --> 00:39:26.260
- Maybe it could be a keyword to the data class decorator


00:39:26.260 --> 00:39:28.180
that just makes it behave differently.


00:39:28.180 --> 00:39:30.500
- Yeah, but so unfortunately the tricky bit with that


00:39:30.500 --> 00:39:32.220
is it's still flowing through Python code, right?


00:39:32.220 --> 00:39:34.660
Data classes is still just a module in the standard library.


00:39:34.660 --> 00:39:37.420
So you can't, it's really hard to optimize that stuff


00:39:37.420 --> 00:39:40.300
without syntax to specifically say,


00:39:40.300 --> 00:39:41.940
hey, this will be different.


00:39:41.940 --> 00:39:43.300
You get to treat it differently


00:39:43.300 --> 00:39:45.300
and we can literally lock it down


00:39:45.300 --> 00:39:47.220
by literally creating a different type of object


00:39:47.220 --> 00:39:50.420
at the C level that just literally doesn't give you access.


00:39:50.420 --> 00:39:52.580
Tuples are a good example.


00:39:52.580 --> 00:39:55.620
Tuples at the C level very much just don't implement


00:39:55.620 --> 00:39:57.260
the stuff that let you mutate it.


00:39:57.260 --> 00:40:00.620
What happens if we wanna do that for classes?


00:40:00.620 --> 00:40:02.140
How do you do frozen data classes?


00:40:02.140 --> 00:40:04.340
It's a ton of properties.


00:40:04.340 --> 00:40:06.020
But what happens if we had a way to just say,


00:40:06.020 --> 00:40:08.500
yep, nope, we're just literally not giving you access.


00:40:08.500 --> 00:40:10.300
Would that, how much faster could that be?


00:40:10.300 --> 00:40:13.220
Like, I don't know, but I suspect it would be


00:40:13.220 --> 00:40:14.140
decently faster.


00:40:14.140 --> 00:40:16.660
- Yeah, computers are surprisingly fast.


00:40:16.660 --> 00:40:17.940
Dictionaries are surprisingly fast,


00:40:17.940 --> 00:40:22.020
but there's a lot of stuff here that could be skipped


00:40:22.020 --> 00:40:26.020
and I think might be, to me, I had the same thought


00:40:26.020 --> 00:40:28.460
at least, probably not with the level of sophistication


00:40:28.460 --> 00:40:31.020
you did, but like, wow, there's some way to sort of do


00:40:31.020 --> 00:40:34.580
more of a C style, just like we know the structure


00:40:34.580 --> 00:40:35.900
and the offsets.


00:40:35.900 --> 00:40:36.740
- Yeah.


00:40:36.740 --> 00:40:39.300
- Like for a restricted set, because that restricted set


00:40:39.300 --> 00:40:41.540
is mostly what people do actually do in Python.


00:40:41.540 --> 00:40:45.820
They don't go crazy dynamic with stuff coming and going,


00:40:45.820 --> 00:40:47.820
like sometimes, but not usually.


00:40:47.820 --> 00:40:51.300
- Yeah, I mean, you can go read my original blog posts


00:40:51.300 --> 00:40:52.540
and if you follow me on Mastodon,


00:40:52.540 --> 00:40:54.580
you can see the follow-up conversations.


00:40:54.580 --> 00:40:58.020
But like the original thing, if you've been a long time


00:40:58.020 --> 00:41:02.260
Java user, you'll know the acronym POJO,


00:41:02.260 --> 00:41:06.300
plain old Java object, is effectively the equivalent


00:41:06.300 --> 00:41:07.780
for Python.


00:41:07.780 --> 00:41:09.580
Some people love that idea, some people are like,


00:41:09.580 --> 00:41:13.700
I really need methods, I can't not have methods


00:41:13.700 --> 00:41:14.820
kind of thing.


00:41:14.820 --> 00:41:17.220
It really depends on what people are after


00:41:17.220 --> 00:41:20.260
and what they think makes sense.


00:41:20.260 --> 00:41:21.980
But there will be a follow-up blog post,


00:41:21.980 --> 00:41:24.140
so if you follow my blog, you'll eventually see


00:41:24.140 --> 00:41:26.640
what this hopefully all leads to, which may be nowhere


00:41:26.640 --> 00:41:29.300
beyond what I put up on PyPI, but who knows,


00:41:29.300 --> 00:41:32.100
maybe it'll become syntax someday.


00:41:32.100 --> 00:41:35.140
It really depends on how the community reacts to it.


00:41:35.140 --> 00:41:38.180
- Cool, well, I didn't know you were looking into that,


00:41:38.180 --> 00:41:39.700
so very interesting.


00:41:39.700 --> 00:41:42.620
Next one, let's move on to something that also seems


00:41:42.620 --> 00:41:45.320
pretty straightforward, is A minus B.


00:41:45.320 --> 00:41:49.380
- Yeah, right.


00:41:49.380 --> 00:41:51.260
Yeah, exactly, you think it makes, yeah,


00:41:51.260 --> 00:41:53.500
how hard can A minus B be, right?


00:41:53.500 --> 00:41:58.200
Like two objects just subtracting from one another, right?


00:41:58.200 --> 00:41:59.360
We all know how this works.


00:41:59.360 --> 00:42:01.120
There's, I mean, there's an opcode just called


00:42:01.120 --> 00:42:03.900
binary subtract, just like there's a binary add,


00:42:03.900 --> 00:42:05.740
a binary multiply, a binary divide.


00:42:05.740 --> 00:42:07.240
- You put the numbers on the register,


00:42:07.240 --> 00:42:10.560
you do the instruction set on the CPU,


00:42:10.560 --> 00:42:12.040
and you're good to go.


00:42:12.040 --> 00:42:13.800
- Yeah, hey, I know what five minus three is,


00:42:13.800 --> 00:42:15.880
how much work can it be to make that work in Python?


00:42:15.880 --> 00:42:17.120
(Lyle laughs)


00:42:17.120 --> 00:42:19.880
- Oh yeah, the numbers happen to be arbitrarily large,


00:42:19.880 --> 00:42:22.000
and sometimes they're not numbers, sometimes they're


00:42:22.000 --> 00:42:24.820
matrices or strings or, oh boy, okay.


00:42:24.820 --> 00:42:28.300
- Exactly, and subtraction's not communicative,


00:42:28.300 --> 00:42:30.380
so order matters here, so yeah,


00:42:30.380 --> 00:42:32.820
it gets surprisingly complicated very quickly.


00:42:32.820 --> 00:42:36.020
- Yeah.


00:42:36.020 --> 00:42:39.100
- So, yeah, from a conceptual level, yeah,


00:42:39.100 --> 00:42:40.460
it seems simple, but when you figure out


00:42:40.460 --> 00:42:43.860
what that opcode actually does, it becomes way fancier.


00:42:43.860 --> 00:42:46.740
- Yeah, and so as you dig into this,


00:42:46.740 --> 00:42:50.460
you start to realize, like, okay, so this is actually


00:42:50.460 --> 00:42:55.380
controlled by the dunder sub operator on the type, right?


00:42:55.380 --> 00:42:56.780
And then how do you get that method?


00:42:56.780 --> 00:43:00.300
Well, this is the method resolution order on that type,


00:43:00.300 --> 00:43:02.820
so you gotta start navigating that,


00:43:02.820 --> 00:43:05.460
and that gets pretty interesting, right?


00:43:05.460 --> 00:43:08.100
- Yeah, well, and let's be clear here,


00:43:08.100 --> 00:43:10.460
you're a bit foreshadowing because you said,


00:43:10.460 --> 00:43:12.300
oh, you called the dunder sub, yeah,


00:43:12.300 --> 00:43:15.540
to start, if that works, right?


00:43:15.540 --> 00:43:19.180
Like, there's some, for a lot of these things,


00:43:19.180 --> 00:43:21.500
there's lots of fallback to, once again,


00:43:21.500 --> 00:43:24.580
give you that flexibility to make things work as necessary.


00:43:24.580 --> 00:43:26.340
So for a lot of things in Python,


00:43:26.340 --> 00:43:29.780
you can return the not implemented singleton,


00:43:29.780 --> 00:43:31.460
which you may have, some people may have noticed


00:43:31.460 --> 00:43:33.820
and wondered what the hell is this thing for,


00:43:33.820 --> 00:43:36.940
and it's a singleton to signal to Python that,


00:43:36.940 --> 00:43:40.520
hey, it's not that an error happened,


00:43:40.520 --> 00:43:42.780
it's just, I just don't know how to handle this, right?


00:43:42.780 --> 00:43:46.460
So, for instance, if, let's say you have


00:43:46.460 --> 00:43:49.220
left-hand side minus right-hand side, right?


00:43:49.220 --> 00:43:52.700
So the first step is you check to see


00:43:52.700 --> 00:43:57.620
if the left-hand side has a dunder sub method, okay?


00:43:57.620 --> 00:44:02.620
If it does, you can call that with left-hand side.dundersub


00:44:02.620 --> 00:44:04.280
and pass in right-hand side.


00:44:04.280 --> 00:44:08.460
Well, that method has the option to do something


00:44:08.460 --> 00:44:10.700
and return a value, and that's what left-hand side


00:44:10.700 --> 00:44:12.460
minus right-hand side becomes,


00:44:12.460 --> 00:44:14.620
or it can return not implemented and say,


00:44:14.620 --> 00:44:17.420
just tell Python, nope, I don't know how to do this,


00:44:17.420 --> 00:44:19.480
probably should ask someone else, right?


00:44:19.480 --> 00:44:23.340
And then this adds an extra little wrinkle now,


00:44:23.340 --> 00:44:25.140
because suddenly when you do that, that says,


00:44:25.140 --> 00:44:26.420
okay, well, you know what?


00:44:26.420 --> 00:44:27.820
Let's give the right-hand side a try.


00:44:27.820 --> 00:44:30.100
Maybe the right-hand side knows how to do


00:44:30.100 --> 00:44:31.660
left-hand side minus right-hand side.


00:44:31.660 --> 00:44:33.300
It might not be the front thing,


00:44:33.300 --> 00:44:35.220
but it might just magically know, right?


00:44:35.220 --> 00:44:38.900
So in this case, for instance,


00:44:38.900 --> 00:44:43.660
let's say you have, you could have something of


00:44:43.660 --> 00:44:46.100
your fancy object minus four,


00:44:46.100 --> 00:44:48.620
which would be your dunder sub method.


00:44:48.620 --> 00:44:51.220
And so you know how to handle integers and it works.


00:44:51.220 --> 00:44:54.820
But what happens if it's four minus your object?


00:44:54.820 --> 00:44:56.580
- Yeah, four doesn't know what to do.


00:44:56.580 --> 00:44:58.380
- Yeah, four's never seen your thing before.


00:44:58.380 --> 00:44:59.860
I don't know what the heck to do here.


00:44:59.860 --> 00:45:04.740
So in that case, four would return not implemented,


00:45:04.740 --> 00:45:06.620
saying, I don't know what to do here.


00:45:06.620 --> 00:45:08.700
Good luck to you, maybe you'll figure it out.


00:45:08.700 --> 00:45:12.060
And in this case, your object dunder rsub


00:45:12.060 --> 00:45:13.300
would get called with four.


00:45:13.300 --> 00:45:15.100
And then maybe you'll be able to say like,


00:45:15.100 --> 00:45:17.020
hey, I might not be on the left-hand side,


00:45:17.020 --> 00:45:19.500
but I know how to handle myself on the right-hand side


00:45:19.500 --> 00:45:20.900
and I can make this work.


00:45:20.900 --> 00:45:24.500
So we try to make sure that even if some other objects


00:45:24.500 --> 00:45:26.180
don't know how to work with you,


00:45:26.180 --> 00:45:28.700
as if you're involved, there's at least the opportunity


00:45:28.700 --> 00:45:30.620
for you to make it work.


00:45:30.620 --> 00:45:32.260
- Yeah, that's pretty interesting.


00:45:32.260 --> 00:45:33.100
- Yes.


00:45:33.100 --> 00:45:35.820
- An example could be like the number four constant


00:45:35.820 --> 00:45:37.700
minus a vector.


00:45:37.700 --> 00:45:39.900
It's meant to be like a mathematical vector.


00:45:39.900 --> 00:45:41.180
And it's like, okay, we just subtract that


00:45:41.180 --> 00:45:42.780
from every dimension, right?


00:45:42.780 --> 00:45:44.860
And that would be totally reasonable,


00:45:44.860 --> 00:45:46.740
but the four has no idea how to do that.


00:45:46.740 --> 00:45:47.580
- Yes.


00:45:47.580 --> 00:45:48.420
- Yeah.


00:45:48.420 --> 00:45:49.820
- And this is still the simple case.


00:45:49.820 --> 00:45:50.660
- Yeah.


00:45:50.660 --> 00:45:56.460
- So if I'll need a,


00:45:56.460 --> 00:45:57.780
I need a slight refresher on this one,


00:45:57.780 --> 00:46:02.780
but effectively there's scenarios here


00:46:02.780 --> 00:46:09.420
where you call the right-hand side first


00:46:09.420 --> 00:46:14.420
if it's, I can't remember if it is.


00:46:14.420 --> 00:46:19.620
- The left-hand side one can say,


00:46:19.620 --> 00:46:21.460
I don't know what to do with this object, I think,


00:46:21.460 --> 00:46:24.660
and return and not implement it from the subtract.


00:46:24.660 --> 00:46:25.500
- Right.


00:46:25.500 --> 00:46:26.340
- Something like that, right?


00:46:26.340 --> 00:46:28.260
- There's also subtle optimization


00:46:28.260 --> 00:46:33.260
in these binary operators where if it is a direct subclass


00:46:33.260 --> 00:46:38.100
of the other object, you get first dibs.


00:46:38.100 --> 00:46:39.340
- Oh, right, right, right.


00:46:39.340 --> 00:46:41.100
- So that's the thing.


00:46:41.100 --> 00:46:42.220
So once again-


00:46:42.220 --> 00:46:43.900
- Yeah, there's a lot of spam and bacon


00:46:43.900 --> 00:46:46.740
and vegetable spam and stuff that you did in here


00:46:46.740 --> 00:46:48.180
that people can check out.


00:46:48.180 --> 00:46:49.260
- It gets surprisingly complicated,


00:46:49.260 --> 00:46:50.580
but the thing here basically,


00:46:50.580 --> 00:46:53.580
this is, let's say you have a left-hand side


00:46:53.580 --> 00:46:54.580
and a right-hand side, right?


00:46:54.580 --> 00:46:57.660
Once again, left-hand side minus right-hand side.


00:46:57.660 --> 00:46:59.580
Left-hand side might be an integer.


00:46:59.580 --> 00:47:03.940
Your right-hand side though might be a subclass of integer,


00:47:03.940 --> 00:47:06.180
like fancy integer, okay?


00:47:07.460 --> 00:47:12.180
Now, if you do int minus fancy int,


00:47:12.180 --> 00:47:15.340
it will understand how to do it because you're a subclass.


00:47:15.340 --> 00:47:16.580
So it's just gonna do it,


00:47:16.580 --> 00:47:19.180
and it'll just do the math and return you whatever it is.


00:47:19.180 --> 00:47:23.340
So like if you did five minus fancy three,


00:47:23.340 --> 00:47:26.380
five's gonna return the integer two.


00:47:26.380 --> 00:47:29.700
But maybe that's not what you want with your fancy int.


00:47:29.700 --> 00:47:32.820
Maybe you'd rather get fancy int two.


00:47:32.820 --> 00:47:35.260
So how does Python make sure that you get that opportunity


00:47:35.260 --> 00:47:36.620
if you happen to be on the right-hand side


00:47:36.620 --> 00:47:38.340
instead of the left-hand side?


00:47:38.340 --> 00:47:41.380
Well, in that case, Python checks first.


00:47:41.380 --> 00:47:43.140
Okay, I have a left-hand side


00:47:43.140 --> 00:47:44.860
and a right-hand side for subtraction.


00:47:44.860 --> 00:47:47.740
Is the right-hand side a direct subclass


00:47:47.740 --> 00:47:49.100
of the left-hand side?


00:47:49.100 --> 00:47:50.380
If that's true, then you know what?


00:47:50.380 --> 00:47:53.940
I'm gonna give the right-hand side a chance first


00:47:53.940 --> 00:47:56.220
so that they can return their subclass


00:47:56.220 --> 00:47:58.500
and not have the left-hand side kind of just blindly


00:47:58.500 --> 00:48:00.900
not realize that it's a different type


00:48:00.900 --> 00:48:01.860
and return something else.


00:48:01.860 --> 00:48:06.860
So that when it's, as I said, five minus fancy three,


00:48:06.860 --> 00:48:09.260
we actually get fancy three the first chance


00:48:09.260 --> 00:48:12.380
instead of five so that you have the chance


00:48:12.380 --> 00:48:14.380
to return fancy two like you wanted


00:48:14.380 --> 00:48:16.540
and not have five itself return.


00:48:16.540 --> 00:48:17.940
- Boring too, yeah.


00:48:17.940 --> 00:48:21.020
So I think one example that comes to mind


00:48:21.020 --> 00:48:26.020
that I think might be relevant would be working with units.


00:48:26.020 --> 00:48:29.420
So we've got cool libraries like Pint and others


00:48:29.420 --> 00:48:33.060
where you can say, this is not just the number five,


00:48:33.060 --> 00:48:35.180
but this is five kilograms.


00:48:35.180 --> 00:48:38.100
And if I subtract 100 milligrams from it,


00:48:38.100 --> 00:48:42.460
it's not negative 95, it's four point whatever,


00:48:42.460 --> 00:48:45.220
nine five or whatever it turns out to be.


00:48:45.220 --> 00:48:48.260
And so in this case, if you took a regular number


00:48:48.260 --> 00:48:50.440
and one of these numbers with units,


00:48:50.440 --> 00:48:53.300
you could get a number with units back potentially.


00:48:53.300 --> 00:48:55.260
- Yeah, that's a very good example, right?


00:48:55.260 --> 00:48:59.380
This is where those, once again, very simple syntax


00:48:59.380 --> 00:49:02.500
that in the common case and in your general use day to day


00:49:02.500 --> 00:49:04.060
makes total sense and happens,


00:49:04.060 --> 00:49:06.820
has some really important but subtle,


00:49:06.820 --> 00:49:09.140
if you don't know about them, semantics


00:49:09.140 --> 00:49:14.140
to make sure that those reasonable expectations are met.


00:49:14.140 --> 00:49:16.940
I totally didn't even think about this


00:49:16.940 --> 00:49:18.820
when I was writing this blog post.


00:49:18.820 --> 00:49:22.140
I'm like, oh yeah, God, that's a good point.


00:49:22.140 --> 00:49:24.820
I do wanna make sure that I get my special version


00:49:24.820 --> 00:49:27.580
of everything when I happen to be on the right hand side,


00:49:27.580 --> 00:49:30.740
just 'cause I happen to be written on the right hand side.


00:49:30.740 --> 00:49:32.460
Plus is a really good example in this one, right?


00:49:32.460 --> 00:49:34.980
Like you could have written A plus B or B plus A,


00:49:34.980 --> 00:49:36.300
makes zero difference.


00:49:36.300 --> 00:49:38.760
I mean, that operator is supposed to be communicative.


00:49:38.760 --> 00:49:40.960
So it can be totally just dumb luck


00:49:40.960 --> 00:49:43.100
based on how I just happened to be thinking that day,


00:49:43.100 --> 00:49:44.100
what I put on the left side


00:49:44.100 --> 00:49:45.820
and what I put on the right side.


00:49:45.820 --> 00:49:47.500
And that would suddenly make a difference.


00:49:47.500 --> 00:49:49.260
And in this case, it just helps make sure


00:49:49.260 --> 00:49:53.180
that what you would think is the priority order


00:49:53.180 --> 00:49:55.780
of who you'd want to handle this for you,


00:49:55.780 --> 00:49:57.020
gets that priority.


00:49:57.020 --> 00:50:00.340
But once again, it's a thing you just never think about


00:50:00.340 --> 00:50:02.020
day to day, but in actuality,


00:50:02.020 --> 00:50:03.700
when you think about the really key ways


00:50:03.700 --> 00:50:06.740
that Python operates, makes a surprising difference.


00:50:06.740 --> 00:50:11.260
- Yeah, that seemingly leakiness at the language of like,


00:50:11.260 --> 00:50:12.540
well, sometimes it gives you the right answer,


00:50:12.540 --> 00:50:14.660
sometimes it doesn't, depending on how you add.


00:50:14.660 --> 00:50:15.980
People wouldn't love that.


00:50:15.980 --> 00:50:18.740
- Yeah, and then the last bit of subtlety on that one


00:50:18.740 --> 00:50:23.940
is this only happens if,


00:50:25.100 --> 00:50:28.420
by the way, dunder sub and dunder rsub are different.


00:50:28.420 --> 00:50:31.540
So that's another check we do because at the C level,


00:50:31.540 --> 00:50:33.700
they're actually equivalent.


00:50:33.700 --> 00:50:37.020
Like there is no left side versus right side thing here.


00:50:37.020 --> 00:50:39.620
So we actually check to make sure we don't waste our time


00:50:39.620 --> 00:50:41.260
asking you, hey, can you do this


00:50:41.260 --> 00:50:43.380
and get back not implemented,


00:50:43.380 --> 00:50:44.580
and then calling it a reverse


00:50:44.580 --> 00:50:45.800
and getting the exact same result


00:50:45.800 --> 00:50:48.420
because underneath it all is the exact same method.


00:50:48.420 --> 00:50:49.260
- Right.


00:50:49.260 --> 00:50:51.500
- So it's one of those fun things of,


00:50:51.500 --> 00:50:53.700
once again, lots of little things here to try to optimize,


00:50:53.700 --> 00:50:55.860
as you said, as best we can,


00:50:55.860 --> 00:50:57.580
and in this case, it's one of those,


00:50:57.580 --> 00:50:59.340
well, if we know you're not gonna work this way


00:50:59.340 --> 00:51:00.180
with the exact same method,


00:51:00.180 --> 00:51:01.580
then we just swap the order of the stuff.


00:51:01.580 --> 00:51:02.740
Why are we gonna ask you again?


00:51:02.740 --> 00:51:04.300
So we just skip that.


00:51:04.300 --> 00:51:05.940
So it's a minor thing,


00:51:05.940 --> 00:51:10.380
but semantics are there to try to help with the performance.


00:51:10.380 --> 00:51:13.940
- I think as people go through your series here,


00:51:13.940 --> 00:51:16.260
I think they're gonna get a deep appreciation


00:51:16.260 --> 00:51:19.740
for edge cases and subtlety.


00:51:19.740 --> 00:51:21.700
- Yeah, yeah.


00:51:21.700 --> 00:51:23.260
- What do you have over the last few days?


00:51:23.260 --> 00:51:24.180
- I learned a lot.


00:51:24.180 --> 00:51:26.140
I mean, it was one of the reasons I finished it


00:51:26.140 --> 00:51:27.500
is I finished the series as well,


00:51:27.500 --> 00:51:30.140
even though I, partway through, went like,


00:51:30.140 --> 00:51:30.980
yeah, you know what?


00:51:30.980 --> 00:51:33.380
I'm not gonna implement Python from scratch,


00:51:33.380 --> 00:51:36.860
but I was learning enough and it was fun.


00:51:36.860 --> 00:51:39.380
Like I got to dive a bit deep.


00:51:39.380 --> 00:51:40.940
I got to ask the Python core team,


00:51:40.940 --> 00:51:43.980
it was like from people, primarily Guido,


00:51:43.980 --> 00:51:46.380
who obviously were there when these decisions were made,


00:51:46.380 --> 00:51:47.900
like, why this way?


00:51:47.900 --> 00:51:50.500
Like, why did we choose this?


00:51:50.620 --> 00:51:53.780
And just trying to understand,


00:51:53.780 --> 00:51:56.940
somewhat historically, how did these things happen?


00:51:56.940 --> 00:52:01.660
Like, I think a lot of people don't realize


00:52:01.660 --> 00:52:02.620
how old Python is, right?


00:52:02.620 --> 00:52:05.220
Like February of 1991 is when Python came out.


00:52:05.220 --> 00:52:07.340
It predates Linux going public.


00:52:07.340 --> 00:52:09.260
Like people really forget that fact.


00:52:09.260 --> 00:52:12.580
It's been around for over 32 years.


00:52:12.580 --> 00:52:14.420
Decisions were made a long time ago,


00:52:14.420 --> 00:52:16.940
and I know everyone got all upset


00:52:16.940 --> 00:52:18.620
over the two to three transition,


00:52:18.620 --> 00:52:19.620
and some people still get upset


00:52:19.620 --> 00:52:21.260
whenever we push new changes or whatever,


00:52:21.260 --> 00:52:22.100
but do realize--


00:52:22.100 --> 00:52:24.660
- I can't believe you just canceled 3.7.


00:52:24.660 --> 00:52:25.700
I like that version.


00:52:25.700 --> 00:52:33.020
- But the key thing here is the core concepts still work.


00:52:33.020 --> 00:52:37.420
Subtraction still works, right?


00:52:37.420 --> 00:52:38.860
From the way it worked back then,


00:52:38.860 --> 00:52:40.540
there's not been a massive upheaval here.


00:52:40.540 --> 00:52:42.940
It's just a lot of us end up using stuff


00:52:42.940 --> 00:52:44.780
that's kind of fancy,


00:52:44.780 --> 00:52:47.180
and sometimes the fancy stuff gets a little tweaks and stuff,


00:52:47.180 --> 00:52:48.580
but the really core low-level stuff


00:52:48.580 --> 00:52:50.940
really hasn't shifted very much.


00:52:50.940 --> 00:52:53.940
So if at all, depending on your view--


00:52:53.940 --> 00:52:55.820
- To give people a sense of the timing,


00:52:55.820 --> 00:52:59.740
the release of Python predates by a couple of years


00:52:59.740 --> 00:53:02.260
the release of the web, right?


00:53:02.260 --> 00:53:04.340
The web was '93, I think.


00:53:04.340 --> 00:53:05.820
And so, yeah.


00:53:05.820 --> 00:53:08.060
- Yeah, one of the early browsers was actually,


00:53:08.060 --> 00:53:11.220
Guido was writing in Python and TK.


00:53:11.220 --> 00:53:12.420
- Incredible. - Gradle.


00:53:12.420 --> 00:53:18.060
- So we talked about simple things like thing.value,


00:53:18.900 --> 00:53:20.420
A minus B.


00:53:20.420 --> 00:53:22.100
The next simple one is the import statement,


00:53:22.100 --> 00:53:23.420
'cause imports are simple.


00:53:23.420 --> 00:53:26.020
Honestly, I think imports are,


00:53:26.020 --> 00:53:29.620
if you come from a compiled language,


00:53:29.620 --> 00:53:32.820
you've really gotta change your mindset, right?


00:53:32.820 --> 00:53:35.180
And so I think this one actually is maybe the opposite


00:53:35.180 --> 00:53:36.700
end of that spectrum a little.


00:53:36.700 --> 00:53:39.980
- Oh yes, I will fully out some of my coworkers


00:53:39.980 --> 00:53:44.180
who are, because VS Code is written in TypeScript


00:53:44.180 --> 00:53:45.460
as an Electron app,


00:53:46.220 --> 00:53:49.020
so they live in TypeScript all day long.


00:53:49.020 --> 00:53:51.700
The fact that Python's imports work the way they are


00:53:51.700 --> 00:53:53.820
in terms of flexibility and just the way it works,


00:53:53.820 --> 00:53:55.820
and you're not just specifying file paths to everything,


00:53:55.820 --> 00:53:57.740
just really throws them for a loop,


00:53:57.740 --> 00:54:00.060
and they go like, "Why is it so complicated?"


00:54:00.060 --> 00:54:03.020
Once again, the flexibility that Python gives you


00:54:03.020 --> 00:54:05.260
where the base case, normal case,


00:54:05.260 --> 00:54:06.980
of if you just do things the way,


00:54:06.980 --> 00:54:12.500
it's Python code and directory kind of thing just works,


00:54:12.500 --> 00:54:16.860
versus I can also import something from a URL if I want,


00:54:16.860 --> 00:54:18.100
that's totally optional.


00:54:18.100 --> 00:54:21.100
I could keep all my code in a SQLite database


00:54:21.100 --> 00:54:24.180
and import from there, totally possible, right?


00:54:24.180 --> 00:54:25.940
So it's one of these things, once again,


00:54:25.940 --> 00:54:29.820
where if you're coming from a Python mindset


00:54:29.820 --> 00:54:33.460
of just what makes sense, it all just works.


00:54:33.460 --> 00:54:35.420
I realize when you come in with an outside perspective,


00:54:35.420 --> 00:54:37.100
it can look kind of crazy,


00:54:37.100 --> 00:54:38.420
but you also have to understand


00:54:38.420 --> 00:54:42.100
that a lot of the designs were made A, decades ago,


00:54:42.100 --> 00:54:44.660
and B, there's a lot of flexibility there


00:54:44.660 --> 00:54:47.340
that you may or may not be taking advantage of,


00:54:47.340 --> 00:54:48.700
but there are others who are,


00:54:48.700 --> 00:54:50.660
and so that's kind of why it exists that way.


00:54:50.660 --> 00:54:51.500
- Yeah, indeed.


00:54:51.500 --> 00:54:55.340
- And yes, this posts, yeah.


00:54:55.340 --> 00:54:57.980
So for those of you who don't know,


00:54:57.980 --> 00:55:00.780
I actually am responsible for import lib


00:55:00.780 --> 00:55:04.220
and re-implementing Python's import system in Python itself.


00:55:04.220 --> 00:55:09.220
And so I know these details a little too well.


00:55:09.220 --> 00:55:10.860
Yeah, so.


00:55:10.860 --> 00:55:12.820
- Still have nightmares about some of them?


00:55:12.820 --> 00:55:13.940
- No, luckily.


00:55:13.940 --> 00:55:19.260
Luckily, import lib, in terms of actual import itself,


00:55:19.260 --> 00:55:22.260
like I'm ignoring import lib.resources


00:55:22.260 --> 00:55:23.700
or import lib.metadata.


00:55:23.700 --> 00:55:27.200
Jason Coons mainly manages those modules.


00:55:27.200 --> 00:55:30.620
It's been stable enough for long enough now


00:55:30.620 --> 00:55:32.940
that there's no real crazy surprises anymore.


00:55:32.940 --> 00:55:34.900
Honestly, the biggest headache


00:55:34.900 --> 00:55:38.100
is people doing imports in their threads.


00:55:38.100 --> 00:55:40.020
So my word of advice to everyone,


00:55:40.020 --> 00:55:41.540
don't do imports in threads.


00:55:41.540 --> 00:55:43.180
If you're gonna do imports,


00:55:43.180 --> 00:55:45.100
do them on your main thread up front,


00:55:45.100 --> 00:55:46.740
then spawn your threads.


00:55:46.740 --> 00:55:50.140
Don't do imports as a side effect of anything either.


00:55:50.140 --> 00:55:52.540
Right, it's circular imports, same thing.


00:55:52.540 --> 00:55:55.780
It's just, just don't.


00:55:55.780 --> 00:55:57.900
Your life will be so much easier.


00:55:57.900 --> 00:56:00.060
But that's honestly where any of the bug reports


00:56:00.060 --> 00:56:01.060
that ever come in come from,


00:56:01.060 --> 00:56:03.260
is due to either circular imports


00:56:03.260 --> 00:56:04.300
and people wondering why,


00:56:04.300 --> 00:56:08.020
or weird race conditions with threads on imports


00:56:08.020 --> 00:56:10.260
and just trying to get the locking down


00:56:10.260 --> 00:56:12.420
such that things lead to the right outcome.


00:56:12.420 --> 00:56:17.020
Actually 3.12 almost got held up a little bit


00:56:17.020 --> 00:56:18.660
due to a slight memory leak


00:56:18.660 --> 00:56:23.660
from the newest version of tracking imports via threads.


00:56:23.660 --> 00:56:27.100
There was a slight leak of basically an empty dictionary


00:56:27.100 --> 00:56:28.740
every time you did an important thread


00:56:28.740 --> 00:56:29.740
and we didn't wanna have that leak.


00:56:29.740 --> 00:56:32.260
So we cleaned it up, but yeah,


00:56:32.260 --> 00:56:34.220
it was a lot of subtlety.


00:56:34.220 --> 00:56:35.500
- Oh, we've got lots of memory, Brett.


00:56:35.500 --> 00:56:37.980
We don't need to worry about those things anymore.


00:56:37.980 --> 00:56:39.140
No, just kidding.


00:56:39.140 --> 00:56:41.500
- Yeah, there's no reason everyone gets excited


00:56:41.500 --> 00:56:45.300
every time Apple launches a new M chip, right?


00:56:45.300 --> 00:56:47.140
We've had enough processing power


00:56:47.140 --> 00:56:51.340
since we got someone on the moon with hemihertz.


00:56:51.340 --> 00:56:52.620
- Exactly.


00:56:52.620 --> 00:56:54.020
No one needs more than seven hertz.


00:56:54.020 --> 00:56:56.460
You know the favorite fan saying, no, just kidding.


00:56:56.460 --> 00:57:01.660
So, you know, one of the real big differences, I think,


00:57:01.660 --> 00:57:04.060
here is that like import runs code, right?


00:57:04.060 --> 00:57:08.420
Like rather than tells the compiler,


00:57:08.420 --> 00:57:10.380
these things are in scope if you want them,


00:57:10.380 --> 00:57:12.380
but no, it's like running code.


00:57:12.380 --> 00:57:16.060
And if people are wondering where that weird


00:57:16.060 --> 00:57:18.940
dunder name equals dunder main,


00:57:18.940 --> 00:57:21.940
so you don't run too much code during imports


00:57:21.940 --> 00:57:23.820
and those sorts of things, right?


00:57:23.820 --> 00:57:25.700
- Yeah, actually, and this is an interesting case


00:57:25.700 --> 00:57:30.460
where it's very much syntactic sugar,


00:57:30.460 --> 00:57:32.380
but it's also very much syntactic sugar


00:57:32.380 --> 00:57:34.660
actually for the byte code.


00:57:34.660 --> 00:57:39.660
So the thing here is when you do import spam, right?


00:57:39.660 --> 00:57:41.700
Or whatever module you want to import,


00:57:41.700 --> 00:57:43.620
it effectively ends up being a call


00:57:43.620 --> 00:57:46.020
to the dunder import built-in function


00:57:46.020 --> 00:57:47.560
where it passes in spam as the name,


00:57:47.560 --> 00:57:50.300
and then it passes in all the globals and the locals


00:57:50.300 --> 00:57:55.220
for where it gets called for name resolution


00:57:55.220 --> 00:57:57.380
and stuff like this is where you do relative imports


00:57:57.380 --> 00:57:58.660
with dot, you know?


00:57:58.660 --> 00:58:00.140
- Yeah, exactly.


00:58:00.140 --> 00:58:01.940
Why are all these arguments going to import?


00:58:01.940 --> 00:58:05.620
You just need to know where A, A.py or the package A lives,


00:58:05.620 --> 00:58:08.180
and you're good to go until you say,


00:58:08.180 --> 00:58:11.700
you know, dot, dot this or from dot.


00:58:11.700 --> 00:58:14.220
- Yeah, from dot, dot A import B kind of stuff.


00:58:14.220 --> 00:58:16.220
Like there's a surprising amount of information


00:58:16.220 --> 00:58:18.700
you need to pass in to do those kinds of resolutions


00:58:18.700 --> 00:58:21.780
and such from imports, right?


00:58:21.780 --> 00:58:24.220
All that kind of thing to make sure those things all exist


00:58:24.220 --> 00:58:27.540
'cause what you're effectively doing in a from import


00:58:27.540 --> 00:58:28.780
is if you list multiple ones,


00:58:28.780 --> 00:58:30.740
you're basically importing the module


00:58:30.740 --> 00:58:32.220
that those things are in and then making sure


00:58:32.220 --> 00:58:34.420
that attribute gets set on the thing you're wanting


00:58:34.420 --> 00:58:37.860
so that you can then grab it later and all sorts of stuff.


00:58:37.860 --> 00:58:41.820
But the other key thing is the dunder import function


00:58:41.820 --> 00:58:45.340
is structured to kind of make the upcode easier, right?


00:58:45.340 --> 00:58:47.660
'Cause it's very structured to just push things


00:58:47.660 --> 00:58:50.620
onto the stack that Python's executing


00:58:50.620 --> 00:58:52.500
and then make the call to dunder import


00:58:52.500 --> 00:58:55.220
where it's just like, yeah, everything's already there.


00:58:55.220 --> 00:58:57.760
But it's also why it's so funky.


00:58:57.760 --> 00:59:00.140
You should never call it directly in your own code, right?


00:59:00.140 --> 00:59:02.140
Like dunder imports very much,


00:59:02.140 --> 00:59:04.260
it's borderline implementation detail


00:59:04.260 --> 00:59:05.100
on this kind of thing.


00:59:05.100 --> 00:59:08.180
This is why you should use import lib dot import module,


00:59:08.180 --> 00:59:10.180
right, that function exists specifically


00:59:10.180 --> 00:59:12.900
and I designed it specifically for those cases


00:59:12.900 --> 00:59:14.940
where you need to do dynamic imports


00:59:14.940 --> 00:59:17.340
and you want a very clean, simple API


00:59:17.340 --> 00:59:20.180
because like the return type for dunder import


00:59:20.180 --> 00:59:23.440
very much is designed for the upcode


00:59:23.440 --> 00:59:27.300
so that whether you're doing an import something


00:59:27.300 --> 00:59:30.080
or from something import other thing, right?


00:59:30.080 --> 00:59:32.540
Like the return value makes sense


00:59:32.540 --> 00:59:34.000
or that for the bytecode level


00:59:34.000 --> 00:59:36.060
does not make sense for human beings, right?


00:59:36.060 --> 00:59:38.740
So once again, do not call dunder import directly.


00:59:38.740 --> 00:59:41.980
You should always be calling import lib dot import module


00:59:41.980 --> 00:59:43.980
if you need something dynamically to import.


00:59:43.980 --> 00:59:46.160
- Or just use the word import.


00:59:46.160 --> 00:59:47.740
- Yeah, or just import.


00:59:47.740 --> 00:59:48.780
- Yeah, just import.


00:59:48.780 --> 00:59:53.480
Yeah, right up here you have all the different variations.


00:59:53.480 --> 00:59:55.420
Like what does it mean to say from thing,


00:59:55.420 --> 00:59:58.440
import something as, or just import something


00:59:58.440 --> 00:59:59.980
or relative imports.


00:59:59.980 --> 01:00:02.780
So people can see all the different,


01:00:02.780 --> 01:00:05.420
again, back to that flexibility that you talked about.


01:00:05.420 --> 01:00:08.420
- Exactly, so it's definitely one of these things though


01:00:08.420 --> 01:00:10.740
where in the end it effectively just boils down


01:00:10.740 --> 01:00:12.380
to a function call, right?


01:00:12.380 --> 01:00:16.260
That piece of syntax of import really is just a function call


01:00:16.260 --> 01:00:18.620
with an assignment in the end.


01:00:18.620 --> 01:00:20.220
- Yeah. - And it's really all it is.


01:00:20.220 --> 01:00:24.580
It's the unraveling, all the trickery


01:00:24.580 --> 01:00:26.180
is really behind the dunder import function


01:00:26.180 --> 01:00:29.620
but the actual syntax is not crazy actually.


01:00:29.620 --> 01:00:31.340
But it literally is a function call.


01:00:31.340 --> 01:00:34.180
You can fully re-implement import.


01:00:34.180 --> 01:00:35.500
Yeah, but just calling dunder import


01:00:35.500 --> 01:00:38.100
and just doing the proper assignment.


01:00:38.100 --> 01:00:38.940
- Nice.


01:00:38.940 --> 01:00:42.060
Some confirmation of your advice out there.


01:00:42.060 --> 01:00:43.780
Nathan says, my data science professor


01:00:43.780 --> 01:00:46.740
always says the same thing, import first, which is good.


01:00:46.740 --> 01:00:52.580
But also, is there a way to remove syntactical sugar


01:00:52.580 --> 01:00:55.820
on an example but not fully through disassembly?


01:00:56.940 --> 01:01:01.940
- Yeah, I mean, so you can actually write a tool


01:01:01.940 --> 01:01:05.860
that will take Python syntax and unravel it.


01:01:05.860 --> 01:01:08.260
I actually started it but it was just too much of a headache


01:01:08.260 --> 01:01:10.740
'cause there's so many variations and edge cases


01:01:10.740 --> 01:01:11.580
and all that stuff to handle


01:01:11.580 --> 01:01:14.540
and there was no package out there


01:01:14.540 --> 01:01:18.140
that quite did what I needed it to do


01:01:18.140 --> 01:01:19.420
to make my life easier.


01:01:19.420 --> 01:01:22.580
- Yeah, what's the canonical destination, right?


01:01:23.260 --> 01:01:28.260
If I undo a with statement on a lock,


01:01:28.260 --> 01:01:30.860
how far do I wanna go back?


01:01:30.860 --> 01:01:34.700
- Yeah, well, and I can understand people


01:01:34.700 --> 01:01:36.860
wanting to do it to maybe learn,


01:01:36.860 --> 01:01:39.420
but I mean, it's gonna be a learning thing,


01:01:39.420 --> 01:01:41.820
not really a performance thing.


01:01:41.820 --> 01:01:43.860
- It might be slower, right?


01:01:43.860 --> 01:01:46.420
Because some of this stuff is happening at the C level.


01:01:46.420 --> 01:01:47.460
- No, yeah, exactly.


01:01:47.460 --> 01:01:51.580
If you go back to our A plus B example,


01:01:51.580 --> 01:01:53.620
it actually definitely will be slower


01:01:53.620 --> 01:02:01.580
as things happen in Python because once again,


01:02:01.580 --> 01:02:04.620
with the speed performance improvements


01:02:04.620 --> 01:02:05.940
that have been going in,


01:02:05.940 --> 01:02:08.980
the bytecode is able to go like,


01:02:08.980 --> 01:02:11.300
all right, is this an int and an int?


01:02:11.300 --> 01:02:13.980
Okay, well, then we know exactly how to do integer math,


01:02:13.980 --> 01:02:15.540
let's just do it, right?


01:02:15.540 --> 01:02:17.900
And then it can add cards in and go like,


01:02:17.900 --> 01:02:19.780
okay, quick check, A, B, yes, okay,


01:02:19.780 --> 01:02:24.580
do the binary int add thing, right?


01:02:24.580 --> 01:02:28.380
Where it just very obviously does that.


01:02:28.380 --> 01:02:30.460
But if you unravel it, you can't do that


01:02:30.460 --> 01:02:32.420
'cause now you're just doing method calls, right?


01:02:32.420 --> 01:02:34.100
You can't hide those details anymore


01:02:34.100 --> 01:02:35.940
and put all that stuff. - Exactly.


01:02:35.940 --> 01:02:37.420
- But yeah, but to answer the question,


01:02:37.420 --> 01:02:39.780
you totally could write a tool to do this


01:02:39.780 --> 01:02:43.380
and I kinda started one and it just wasn't fun,


01:02:43.380 --> 01:02:46.900
so I just stopped 'cause I just had a thing.


01:02:46.900 --> 01:02:49.580
- Sometimes you see this in the editor as well


01:02:49.580 --> 01:02:51.420
when editors will give you previews.


01:02:51.420 --> 01:02:54.900
So for example, if you use optional of a thing


01:02:54.900 --> 01:02:57.900
or thing, pipe, none,


01:02:57.900 --> 01:03:00.300
and then you hover over it in the editor,


01:03:00.300 --> 01:03:02.540
even if you used optional, it'll say thing, pipe, none


01:03:02.540 --> 01:03:05.020
because it's like, those mean the same thing,


01:03:05.020 --> 01:03:07.100
I'm gonna just represent them in one way.


01:03:07.100 --> 01:03:11.140
Yeah, yeah, interesting.


01:03:11.140 --> 01:03:12.660
Okay, we have a bunch more things to cover,


01:03:12.660 --> 01:03:14.220
but we don't have really any time.


01:03:14.220 --> 01:03:15.940
My goal with this, having you on here


01:03:15.940 --> 01:03:16.780
to talk about this stuff,


01:03:16.780 --> 01:03:18.740
is really kinda like to highlight the whole series


01:03:18.740 --> 01:03:20.140
and people should go,


01:03:20.140 --> 01:03:21.420
and we've been kinda hand-waving


01:03:21.420 --> 01:03:25.100
'cause reading C code on air is not ideal.


01:03:25.100 --> 01:03:26.100
- No. - But I think it'd be


01:03:26.100 --> 01:03:28.300
a whole other idea, but really to highlight


01:03:28.300 --> 01:03:30.260
your whole series and people can just dive


01:03:30.260 --> 01:03:33.860
into this pretty deep and I think they'll have


01:03:33.860 --> 01:03:36.060
a much better appreciation for when you write


01:03:36.060 --> 01:03:38.300
this one line, oh my goodness,


01:03:38.300 --> 01:03:40.180
this is actually what's happening.


01:03:40.180 --> 01:03:44.300
- And how I actually found a bug in Python, thanks to it.


01:03:44.300 --> 01:03:46.540
- Okay, tell us quick about that.


01:03:46.540 --> 01:03:51.420
- Well, I mean, it's covered in the in-place


01:03:51.420 --> 01:03:55.500
binary operator, augmented assignment post.


01:03:55.500 --> 01:03:58.260
So you know how you can do A plus equals B


01:03:58.260 --> 01:04:01.420
and it's like doing A equals A plus B?


01:04:01.420 --> 01:04:02.820
- Yeah.


01:04:02.820 --> 01:04:05.540
- Yeah, so it turned out it was broken for PAL.


01:04:05.540 --> 01:04:08.740
So when you could do A star star B,


01:04:08.740 --> 01:04:11.220
that's A to the B power.


01:04:11.220 --> 01:04:13.460
Yeah, it turned out the semantics were busted


01:04:13.460 --> 01:04:15.540
for star star equals.


01:04:15.540 --> 01:04:16.580
- Wow, okay.


01:04:16.580 --> 01:04:18.700
- And no one had ever noticed 'cause obviously


01:04:18.700 --> 01:04:21.140
people do not write custom implementations


01:04:21.140 --> 01:04:26.140
of Thunder PAL 'cause effectively what turned out was,


01:04:26.140 --> 01:04:29.500
and someone actually discovered it and reported it,


01:04:29.500 --> 01:04:30.900
I just didn't know about it,


01:04:30.900 --> 01:04:35.700
that basically when you did that,


01:04:35.700 --> 01:04:38.900
so the in-place augmented assignment,


01:04:38.900 --> 01:04:43.220
there's I versions of everything like I add,


01:04:43.220 --> 01:04:47.580
Thunder I add, Thunder I mul, Thunder I PAL, right?


01:04:47.580 --> 01:04:49.620
Turns out for all of them, they did the right thing


01:04:49.620 --> 01:04:52.500
except for power where it would check for I PAL.


01:04:52.500 --> 01:04:56.140
And I mean, in all these scenarios,


01:04:56.140 --> 01:04:59.780
because A plus equals B is the same as A equals A plus B,


01:04:59.780 --> 01:05:03.420
if the I version returns not implemented,


01:05:03.420 --> 01:05:06.220
it falls back to just doing the binary operator


01:05:06.220 --> 01:05:08.580
and then doing the assignment, right?


01:05:08.580 --> 01:05:11.340
So like if I plus, so I plus equals B,


01:05:12.340 --> 01:05:16.260
unravels to A dot I PAL,


01:05:16.260 --> 01:05:20.780
A dot Thunder I PAL with B as an argument,


01:05:20.780 --> 01:05:22.220
if that returns not implemented,


01:05:22.220 --> 01:05:25.300
then it devolves into A plus B,


01:05:25.300 --> 01:05:27.060
A equals the result of that, right?


01:05:27.060 --> 01:05:31.540
In the PAL case, if you return not implemented


01:05:31.540 --> 01:05:34.860
on Thunder I PAL, it didn't fall back to PAL, Thunder PAL.


01:05:34.860 --> 01:05:36.700
- Okay.


01:05:36.700 --> 01:05:37.540
- It just--


01:05:37.540 --> 01:05:39.300
- It just crashed, so I don't know what to do here.


01:05:39.300 --> 01:05:40.220
- It was just an exception.


01:05:40.220 --> 01:05:41.660
It's like, yeah, no.


01:05:41.660 --> 01:05:43.660
- I suppose that's better than the wrong answer.


01:05:43.660 --> 01:05:46.980
Like actually, the square of nine is 18.


01:05:46.980 --> 01:05:48.580
- It really, it threw me for a loop


01:05:48.580 --> 01:05:51.540
because I wrote code to verify all my unraveling


01:05:51.540 --> 01:05:55.380
and for the augmented assignment for PAL


01:05:55.380 --> 01:05:56.540
just kept not working.


01:05:56.540 --> 01:05:57.940
It was like, what the heck's going on?


01:05:57.940 --> 01:05:58.780
And then I had to dig into the C code.


01:05:58.780 --> 01:05:59.620
- What am I doing wrong here?


01:05:59.620 --> 01:06:01.300
- And it was like, wait a second,


01:06:01.300 --> 01:06:03.140
that code unravels calling this C code,


01:06:03.140 --> 01:06:04.300
calling this C code.


01:06:04.300 --> 01:06:09.820
And it didn't check that return value.


01:06:09.820 --> 01:06:11.420
And calling it under IPAL, it's like,


01:06:11.420 --> 01:06:12.660
well, did return not implemented?


01:06:12.660 --> 01:06:14.820
And if it did, then we've got to try the other version.


01:06:14.820 --> 01:06:15.660
It just didn't.


01:06:15.660 --> 01:06:18.740
It's just like, oh, no, it's just the value just got returned.


01:06:18.740 --> 01:06:20.700
It just didn't even check.


01:06:20.700 --> 01:06:23.540
And I think we figured out it happened


01:06:23.540 --> 01:06:26.500
when the third argument to PAL got added


01:06:26.500 --> 01:06:28.100
and it was just someone overlooked it.


01:06:28.100 --> 01:06:28.940
- I see, yeah.


01:06:28.940 --> 01:06:31.540
- But it's been sitting there for years.


01:06:31.540 --> 01:06:32.860
- I mean, you don't want it to be overlooked,


01:06:32.860 --> 01:06:34.940
but yeah, you're looking through these things,


01:06:34.940 --> 01:06:37.420
you can tell that they're pretty subtle.


01:06:37.420 --> 01:06:39.700
There's a lot going on in the different special cases.


01:06:39.700 --> 01:06:42.940
So I can see it wouldn't hit you in the face


01:06:42.940 --> 01:06:45.020
that you necessarily missed something right away.


01:06:45.020 --> 01:06:46.980
- Exactly, yeah.


01:06:46.980 --> 01:06:48.740
I don't fault anyone at all.


01:06:48.740 --> 01:06:50.700
I think we were just missing a test case somewhere


01:06:50.700 --> 01:06:52.300
to make sure that that happened.


01:06:52.300 --> 01:06:56.620
And once again, I don't think people define


01:06:56.620 --> 01:06:59.700
their own custom PAL operator for their types.


01:06:59.700 --> 01:07:01.300
- There's a whole bunch of mathematicians going,


01:07:01.300 --> 01:07:02.140
but we do.


01:07:02.140 --> 01:07:02.980
- We do.


01:07:02.980 --> 01:07:03.820
(laughing)


01:07:03.820 --> 01:07:05.300
- Or physicists or something.


01:07:05.300 --> 01:07:06.140
- Yep.


01:07:06.140 --> 01:07:07.540
- All right, we're pretty much out of time


01:07:07.540 --> 01:07:08.780
to go any deeper on this.


01:07:08.780 --> 01:07:09.980
And I think that, that's all right,


01:07:09.980 --> 01:07:11.300
I think people got a really good sense


01:07:11.300 --> 01:07:16.300
of what's happening, what you mean with your series here.


01:07:16.300 --> 01:07:18.220
And hopefully they're inspired to go check it out.


01:07:18.220 --> 01:07:20.940
But I do, while I have this import stuff on the screen,


01:07:20.940 --> 01:07:23.300
and you've done so much work with Importlib,


01:07:23.300 --> 01:07:29.940
will there ever be a time where hot reload type of stuff


01:07:29.940 --> 01:07:34.420
is a thing, like I edit this file in this web app,


01:07:34.420 --> 01:07:36.740
and it's got this project, it's been running,


01:07:36.740 --> 01:07:40.700
and I just, maybe could we have a file watcher


01:07:40.700 --> 01:07:43.500
trigger this module to re-import?


01:07:43.500 --> 01:07:44.860
Not necessarily saying it's a good idea,


01:07:44.860 --> 01:07:45.860
but have you--


01:07:45.860 --> 01:07:49.180
- Do you mean like, you want automatic import lib.reload?


01:07:49.180 --> 01:07:53.340
- Yes, or even like the lib reload stuff,


01:07:53.340 --> 01:07:55.700
a lot of times you can do it,


01:07:55.700 --> 01:07:57.460
but it's kind of discouraged because,


01:07:57.460 --> 01:07:59.660
I think largely because of the side effects,


01:07:59.660 --> 01:08:00.700
what can happen there, or--


01:08:00.700 --> 01:08:03.180
- No, so to be very specific,


01:08:03.180 --> 01:08:04.660
if you call a module,


01:08:04.660 --> 01:08:06.780
if you call import lib.reload on a module,


01:08:06.780 --> 01:08:10.460
it effectively reruns import on that module.


01:08:10.460 --> 01:08:15.100
The problem is, is all the references you have to objects,


01:08:15.100 --> 01:08:16.460
don't change.


01:08:16.460 --> 01:08:17.300
- Yeah, exactly.


01:08:17.300 --> 01:08:21.140
- So if you got something out of that module,


01:08:21.140 --> 01:08:23.260
like let's say there's a global dictionary


01:08:23.260 --> 01:08:25.460
that you stored a reference to a way that you expected--


01:08:25.460 --> 01:08:27.860
- Right, or a function or a class, maybe.


01:08:27.860 --> 01:08:28.700
- Exactly.


01:08:28.700 --> 01:08:29.540
- Yeah.


01:08:29.540 --> 01:08:30.820
- And then you call reload,


01:08:30.820 --> 01:08:33.660
everyone else in the future is gonna get the new module,


01:08:33.660 --> 01:08:35.600
and they'll get the new version of all the things


01:08:35.600 --> 01:08:36.740
that were in that module,


01:08:36.740 --> 01:08:38.380
but all that stuff you still have reference to do,


01:08:38.380 --> 01:08:41.020
that didn't get magically taken away or garbage collected,


01:08:41.020 --> 01:08:42.580
and we can't really necessarily swap it


01:08:42.580 --> 01:08:43.420
underneath you either,


01:08:43.420 --> 01:08:45.620
'cause the whole type could have changed.


01:08:45.620 --> 01:08:46.460
- Right, right, right.


01:08:46.460 --> 01:08:49.200
- So, I mean, if you really wanted to set up


01:08:49.200 --> 01:08:52.460
your own import system that does file monitoring


01:08:52.460 --> 01:08:54.260
and automatic calls import lib.reload,


01:08:54.260 --> 01:08:55.380
you could totally do that today.


01:08:55.380 --> 01:08:57.180
There's nothing stopping you,


01:08:57.180 --> 01:09:00.780
but you have to just be very aware that--


01:09:00.780 --> 01:09:03.500
- Only sometimes will it have a good effect.


01:09:03.500 --> 01:09:05.660
- Yeah, it'll have an effect, yeah.


01:09:05.660 --> 01:09:08.340
It's just whether it's gonna do what you expect,


01:09:08.340 --> 01:09:12.300
and that's why import lib.reload is discouraged,


01:09:12.300 --> 01:09:14.900
because people often don't quite understand


01:09:14.900 --> 01:09:19.840
the side effects and the things you have to watch out for


01:09:19.840 --> 01:09:23.200
to understand that it's gonna do what you expect.


01:09:23.200 --> 01:09:28.200
And yeah, especially when you import, do from imports,


01:09:28.200 --> 01:09:30.740
right, 'cause then you're getting the direct objects


01:09:30.740 --> 01:09:32.700
off the module instead of the module itself,


01:09:32.700 --> 01:09:36.260
'cause if it doesn't in place reimport,


01:09:36.260 --> 01:09:41.260
so if you did import spam and you reloaded spam,


01:09:41.260 --> 01:09:44.460
the attributes off of spam will now be the new stuff,


01:09:44.460 --> 01:09:47.140
'cause we actually changed that dictionary in place.


01:09:47.140 --> 01:09:51.380
But if you did from spam import function,


01:09:51.380 --> 01:09:52.900
function is not gonna change.


01:09:52.900 --> 01:09:55.820
There's another reason why I always tell everybody,


01:09:55.820 --> 01:09:59.580
don't import the objects from a module,


01:09:59.580 --> 01:10:01.220
import to the module, right?


01:10:01.220 --> 01:10:03.180
I find it, I personally find it more readable,


01:10:03.180 --> 01:10:04.220
'cause I can look at the code,


01:10:04.220 --> 01:10:05.220
no matter where I am in the file,


01:10:05.220 --> 01:10:07.180
and know where that function came from.


01:10:07.180 --> 01:10:08.620
It's not from this module, it's from somewhere else.


01:10:08.620 --> 01:10:09.460
- I am always with you.


01:10:09.460 --> 01:10:13.740
I'm almost never from thing import other thing.


01:10:13.740 --> 01:10:16.340
- Yeah, unless it's a deep module in a package,


01:10:16.340 --> 01:10:17.340
in which case that makes sense,


01:10:17.340 --> 01:10:20.980
'cause you'll still do module.thing.


01:10:20.980 --> 01:10:21.820
- Right, right.


01:10:21.820 --> 01:10:22.660
Well, even though I have that,


01:10:22.660 --> 01:10:25.260
if it's like four levels deep, I'll do the first three,


01:10:25.260 --> 01:10:26.700
and then from the first three,


01:10:26.700 --> 01:10:29.100
import the last step of the module,


01:10:29.100 --> 01:10:31.860
so you can say like data layer dot, you know.


01:10:31.860 --> 01:10:32.700
- Exactly.


01:10:32.700 --> 01:10:33.860
- Update rather than just update.


01:10:33.860 --> 01:10:34.820
Like, well, what does update mean?


01:10:34.820 --> 01:10:35.740
I don't know.


01:10:35.740 --> 01:10:36.900
- Exactly, yeah.


01:10:36.900 --> 01:10:39.380
I mean, the canonical example is random.


01:10:39.380 --> 01:10:41.460
You see the function random in your code.


01:10:41.460 --> 01:10:42.780
Whose random is that?


01:10:42.780 --> 01:10:44.100
Is that from the random module?


01:10:44.100 --> 01:10:45.500
Is that from NumPy?


01:10:45.500 --> 01:10:46.820
Did you implement random?


01:10:46.820 --> 01:10:48.820
Whose random is that?


01:10:48.820 --> 01:10:49.660
- Yeah. - You just don't know.


01:10:49.660 --> 01:10:52.340
- But if you saw np.random, you'd know.


01:10:52.340 --> 01:10:53.460
- Exactly.


01:10:53.460 --> 01:10:55.220
- Yeah. - If you know what np was.


01:10:57.660 --> 01:10:58.860
- If you did, of course.


01:10:58.860 --> 01:11:04.420
All right, well, Brett, I guess,


01:11:04.420 --> 01:11:07.020
give you a chance to kind of summarize


01:11:07.020 --> 01:11:10.420
final, final thoughts here on your Syntactic Sugar series,


01:11:10.420 --> 01:11:13.220
and tell people how to get it and stuff.


01:11:13.220 --> 01:11:14.820
- Yeah, I mean, you can go to my blog.


01:11:14.820 --> 01:11:16.140
It's on snarky.ca.


01:11:16.140 --> 01:11:18.140
It has the tag Syntactic Sugar.


01:11:18.140 --> 01:11:20.700
I'm sure Michael will include it in the show notes.


01:11:20.700 --> 01:11:24.100
Don't feel the need to read all of it,


01:11:24.100 --> 01:11:28.340
but do look at least the first one or two,


01:11:28.340 --> 01:11:30.100
because I do go into more detail


01:11:30.100 --> 01:11:32.500
on how you can kind of go exploring on your own


01:11:32.500 --> 01:11:36.100
in way more detail in those posts than I do towards the end,


01:11:36.100 --> 01:11:38.300
'cause I'll be honest, I've lost a bit of steam


01:11:38.300 --> 01:11:41.940
in diving into all the deep layers.


01:11:41.940 --> 01:11:45.420
I wanted to get the blog post series done after two years.


01:11:45.420 --> 01:11:47.700
It was one of those, okay, go look at the earlier ones.


01:11:47.700 --> 01:11:50.620
They'll explain how to figure out how to go from syntax


01:11:50.620 --> 01:11:52.620
to the byte code to the C code,


01:11:52.620 --> 01:11:54.780
and then know where to look in the C code,


01:11:54.780 --> 01:11:57.020
which by the way, you don't have to understand the C code.


01:11:57.020 --> 01:11:59.620
It's not, A, it's not crazy C code,


01:11:59.620 --> 01:12:01.500
but it's also not necessarily critical.


01:12:01.500 --> 01:12:04.780
I do try to write down the Python equivalents for everything


01:12:04.780 --> 01:12:06.780
so it's there if you do understand C,


01:12:06.780 --> 01:12:09.220
but don't feel intimidated if you don't.


01:12:09.220 --> 01:12:11.380
And hopefully you just find it interesting, right?


01:12:11.380 --> 01:12:13.420
Like you've always wondered how the heck does this work?


01:12:13.420 --> 01:12:16.980
If it's in the blog post,


01:12:16.980 --> 01:12:18.620
you'll be able to have a better understanding,


01:12:18.620 --> 01:12:20.400
hopefully, of how things work, 'cause as I said,


01:12:20.400 --> 01:12:22.700
I honestly even learned some details that I forgot


01:12:22.700 --> 01:12:25.060
or never even knew about some of the semantics


01:12:25.060 --> 01:12:28.580
behind Python and how things actually work


01:12:28.580 --> 01:12:29.620
underneath the hood, and it just gave me


01:12:29.620 --> 01:12:31.220
a better understanding to understand.


01:12:31.220 --> 01:12:33.940
When things do and don't happen the way I expect.


01:12:33.940 --> 01:12:36.340
And just honestly appreciate all the work


01:12:36.340 --> 01:12:38.340
everyone's put into language over the decades


01:12:38.340 --> 01:12:41.060
to make it all seemingly seem simple,


01:12:41.060 --> 01:12:42.780
and yet it's surprisingly complex.


01:12:42.780 --> 01:12:46.060
- Yeah, I don't think you need to read them all either,


01:12:46.060 --> 01:12:48.380
as somebody who read most of them the last couple days.


01:12:48.380 --> 01:12:49.780
- No, you don't.


01:12:49.780 --> 01:12:52.300
- If you're a completionist, go for it.


01:12:52.300 --> 01:12:53.840
But yes, you definitely do not need to.


01:12:53.840 --> 01:12:56.040
- But I do think going through it,


01:12:56.040 --> 01:12:57.560
pick out the ones, there's a whole bunch


01:12:57.560 --> 01:12:59.260
of different topics, pick out the ones that are,


01:12:59.260 --> 01:13:01.020
you're like, oh, I did always wonder how that one worked.


01:13:01.020 --> 01:13:04.820
And pretty much, with the exception of PaaS,


01:13:04.820 --> 01:13:07.420
I think you'll be like, oh my gosh,


01:13:07.420 --> 01:13:09.480
I had no idea what was involved here.


01:13:09.480 --> 01:13:11.280
- Yeah, PaaS was very much just a,


01:13:11.280 --> 01:13:13.820
I had a checklist of every piece of syntax


01:13:13.820 --> 01:13:18.040
and every single keyword, and the blog post on PaaS,


01:13:18.040 --> 01:13:20.080
I think is like three sentences,


01:13:20.080 --> 01:13:21.220
and half of it's saying this is gonna be


01:13:21.220 --> 01:13:23.420
the shortest post in this whole series.


01:13:23.420 --> 01:13:25.240
Yeah.


01:13:25.240 --> 01:13:27.440
- Yeah, it was contending with the dot, dot, dot,


01:13:27.440 --> 01:13:28.560
which we haven't even had a chance


01:13:28.560 --> 01:13:30.960
to talk about ellipsis versus PaaS,


01:13:30.960 --> 01:13:32.720
but I think we're out of time, Brett.


01:13:32.720 --> 01:13:35.920
So thanks for being here.


01:13:35.920 --> 01:13:37.480
Thanks for all you do.


01:13:37.480 --> 01:13:42.360
I mean, steering council, core dev, author,


01:13:42.360 --> 01:13:45.960
VS Code, et cetera, a lot of contributions.


01:13:45.960 --> 01:13:47.960
- Thanks, thanks for having me back on yet again,


01:13:47.960 --> 01:13:50.320
and hopefully I've not worn out my welcome still.


01:13:50.320 --> 01:13:52.680
- No, you're already thinking about


01:13:52.680 --> 01:13:56.160
what next WebAssembly Rust thing we'll get together on.


01:13:56.160 --> 01:13:58.880
Thanks for being here, see you later.


01:13:58.880 --> 01:13:59.840
- Thanks, Michael.


01:13:59.840 --> 01:14:00.680
- Yep.


01:14:00.680 --> 01:14:29.440
Thank you.

