WEBVTT

00:00:00.000 --> 00:00:07.000
Anna Lena, welcome back to Talk Python to Me. It's awesome to have you here.


00:00:07.000 --> 00:00:10.000
Thanks for having me again.


00:00:10.000 --> 00:00:13.000
Yeah, it's always good to have you on the show.


00:00:13.000 --> 00:00:19.000
We had you on several times before.


00:00:19.000 --> 00:00:24.000
We talked about testing and mocking out dependencies in Python.


00:00:24.000 --> 00:00:27.000
And the very first time was, this is quite a while ago.


00:00:27.000 --> 00:00:33.000
Way back in 2018, we talked about the magical universe.


00:00:33.000 --> 00:00:39.000
100 days of Python by learning through Harry Potter themed problems, which is very fun.


00:00:39.000 --> 00:00:42.000
I learned so much in that project. It was really nice.


00:00:42.000 --> 00:00:46.000
I can still recommend it to anyone to do this 100 days of code.


00:00:46.000 --> 00:00:49.000
Yeah, it's super fun.


00:00:49.000 --> 00:00:59.000
So let's maybe do a quick catch up before we dive into Python packaging, comparisons and positioning.


00:00:59.000 --> 00:01:02.000
What have you been up to?


00:01:02.000 --> 00:01:06.000
So I'm still a machine learning engineer. I'm in a German company.


00:01:06.000 --> 00:01:11.000
I think I was there last time as well. It's called Innovex.


00:01:11.000 --> 00:01:15.000
And we do all kinds of machine learning projects with customers.


00:01:15.000 --> 00:01:22.000
So I rotate from project to project. Right now I'm working at a company called Babbel.


00:01:22.000 --> 00:01:24.000
Not sure if you heard of that.


00:01:24.000 --> 00:01:29.000
It's really a fantastic company since they enable users to learn new languages.


00:01:29.000 --> 00:01:38.000
And I'm working in the speech recognition team, which I like a lot since talking is such an important part of learning a new language.


00:01:38.000 --> 00:01:45.000
And I'm there as a senior machine learning engineer and helping them build their product, develop it further.


00:01:45.000 --> 00:01:47.000
And I really love it there.


00:01:47.000 --> 00:01:51.000
Yeah, that sounds like such a fun problem to be working on.


00:01:51.000 --> 00:01:54.000
And machine learning is evolving so quickly, right?


00:01:54.000 --> 00:01:56.000
Yes, it is.


00:01:56.000 --> 00:01:58.000
Are you?


00:01:58.000 --> 00:02:00.000
Sorry, go ahead.


00:02:00.000 --> 00:02:07.000
With the generative AI, there's so much going on, so much you can do that it's hard to keep track of what's happening sometimes.


00:02:07.000 --> 00:02:12.000
Yeah, it seems like as soon as you have it figured out, something new comes along.


00:02:12.000 --> 00:02:17.000
Are you able to talk about what libraries you're using for that project?


00:02:17.000 --> 00:02:19.000
No, I don't think so.


00:02:19.000 --> 00:02:21.000
Yeah, okay, no worries.


00:02:21.000 --> 00:02:27.000
I checked before that I'm allowed to say that I work on speech recognition, but that's basically it.


00:02:27.000 --> 00:02:33.000
So, okay, I'm going to guess it probably has something to do with Python, but we'll leave it there.


00:02:33.000 --> 00:02:35.000
I won't put you on the spot. Awesome.


00:02:35.000 --> 00:02:39.000
So, and that's not a surprise, right, to say people are doing machine learning with Python.


00:02:39.000 --> 00:02:44.000
That's by far the most popular way to do it these days.


00:02:44.000 --> 00:02:52.000
Cool. Well, again, that sounds like a super fun thing to be working on right on the cutting edge.


00:02:52.000 --> 00:02:56.000
Understanding spoken word is especially tricky, right?


00:02:56.000 --> 00:02:57.000
Yeah.


00:02:57.000 --> 00:03:02.000
For me, it's also so nice since I use the software myself to learn a language.


00:03:02.000 --> 00:03:07.000
And working on something that is useful not only for you, but for so many people,


00:03:07.000 --> 00:03:12.000
since it can be so hard to learn a different language, that's really nice.


00:03:12.000 --> 00:03:14.000
Yeah, it's really fun to work on software.


00:03:14.000 --> 00:03:18.000
It's more fun to work on software that you know many other people are using.


00:03:18.000 --> 00:03:20.000
It's a special kind of joy, I think.


00:03:20.000 --> 00:03:22.000
Yeah, absolutely.


00:03:22.000 --> 00:03:29.000
Would you say that projects that you work on have to use Python dependencies and virtual environments and stuff?


00:03:29.000 --> 00:03:30.000
Yes, so much.


00:03:30.000 --> 00:03:36.000
That's actually also why I did this talk in the beginning, or why I started working on the talk on this topic,


00:03:36.000 --> 00:03:42.000
since I was in a different project, and the people there asked me, "Okay, which packaging tool should we use?"


00:03:42.000 --> 00:03:45.000
And I was like, "Wow, this is so difficult. I cannot even answer it."


00:03:45.000 --> 00:03:51.000
Since I know that there are so many tools out there, I didn't have a good overview of them.


00:03:51.000 --> 00:03:59.000
And also, especially not of the differences and what they are good for, what they can do, what they are not good for.


00:03:59.000 --> 00:04:07.000
And then I started digging into the topic, and I was like, "Wow, this is just so complex and so many different tools."


00:04:07.000 --> 00:04:11.000
And yeah, it was really time for a good overview.


00:04:11.000 --> 00:04:14.000
And I think you did a really fantastic job writing this up.


00:04:14.000 --> 00:04:17.000
And you did it in two varieties, right?


00:04:17.000 --> 00:04:27.000
You have the article on your blog, and then you also have â€“ you gave a talk at PyCon DE, right?


00:04:27.000 --> 00:04:29.000
So, depending on how people want to experience it.


00:04:29.000 --> 00:04:34.000
Yeah, I also gave one at EuroPython, which is a more updated version, I guess,


00:04:34.000 --> 00:04:39.000
since Rai came out after I gave the talk at the German PyCon.


00:04:39.000 --> 00:04:47.000
So, the new video from EuroPython, which is not on YouTube yet, it also features Rai.


00:04:47.000 --> 00:04:49.000
Cool. Yeah, we'll talk about Rai.


00:04:49.000 --> 00:04:54.000
Yeah. This is crazy, since it already shows that in a few months,


00:04:54.000 --> 00:04:59.000
there was another change and another tool came up, which is so popular now.


00:04:59.000 --> 00:05:02.000
Yeah.


00:05:02.000 --> 00:05:10.000
Yeah, it's only a few months old, your PyCon DE talk, and it's already a little outdated, right?


00:05:10.000 --> 00:05:13.000
That highlights what you're talking about, doesn't it?


00:05:13.000 --> 00:05:19.000
Well, let's start by thinking about Python from a beginner's perspective.


00:05:19.000 --> 00:05:27.000
Because one of the first things that people are like, "Okay, Python is awesome."


00:05:27.000 --> 00:05:31.000
Whether they're a machine learning engineer who wants to use PyTorch,


00:05:31.000 --> 00:05:36.000
they're a web developer who is all excited about FastAPI or whatever,


00:05:36.000 --> 00:05:46.000
one of the huge powers of Python is that you have almost half a million libraries on PyPI.org to work with.


00:05:46.000 --> 00:05:51.000
If you pick one of them, it's awesome.


00:05:51.000 --> 00:05:58.000
It says, "Okay, this somewhere requires, for example, FastAPI requires Python 3.7 or above."


00:05:58.000 --> 00:06:00.000
That's a pretty low bar these days.


00:06:00.000 --> 00:06:03.000
But there's already two things you have to deal with.


00:06:03.000 --> 00:06:11.000
FastAPI, the package, the version of it so it can't clash, and the version of Python that it runs on.


00:06:11.000 --> 00:06:17.000
Somehow, as a beginner, you have to figure out, "Okay, how do I put all these things together?"


00:06:17.000 --> 00:06:19.000
How do you get started with these environments?


00:06:19.000 --> 00:06:21.000
Maybe speak to that just a little bit.


00:06:21.000 --> 00:06:24.000
Yeah, I think that's a good starting point.


00:06:24.000 --> 00:06:31.000
Especially when you begin, I remember that for me, the concept of a virtual environment already was really confusing.


00:06:31.000 --> 00:06:34.000
Although it's such a simple thing to understand.


00:06:34.000 --> 00:06:39.000
Then to go from there, maybe how you install packages in the best way.


00:06:39.000 --> 00:06:43.000
I think it's always a good idea to start with a virtual environment.


00:06:43.000 --> 00:06:51.000
Since then you have your dependencies in this nice little box or environment where it's isolated from the rest.


00:06:51.000 --> 00:07:00.000
And you do not have these dependency issues between different projects you might have or might work on that require the same package but in a different version.


00:07:00.000 --> 00:07:06.000
So you can create this virtual environment or maybe the local environment.


00:07:06.000 --> 00:07:09.000
There's also this new variant.


00:07:09.000 --> 00:07:11.000
And then you can install packages there.


00:07:11.000 --> 00:07:20.000
So for example, with the FastAPI you just showed, you could use pip to install it, given that you have the right Python version.


00:07:20.000 --> 00:07:26.000
Yeah, wow, this already shows right now since this is already the next category, right?


00:07:26.000 --> 00:07:28.000
Python version management.


00:07:28.000 --> 00:07:30.000
Yeah, it can be quite confusing.


00:07:30.000 --> 00:07:38.000
You need the right Python version, which you can handle using a tool or different tools are available for that.


00:07:38.000 --> 00:07:42.000
Then you need to be able to install the package with pip, for example, or another tool.


00:07:42.000 --> 00:07:51.000
And it would be nice or it's always nice to have a virtual environment for your different projects, which you will also need a tool for.


00:07:51.000 --> 00:07:53.000
Yeah, of course.


00:07:53.000 --> 00:07:57.000
So I guess it's already three things just if you want to get started.


00:07:57.000 --> 00:08:03.000
Yeah, yeah. So in your article, in your talk, you broke it down into five different categories.


00:08:03.000 --> 00:08:05.000
These tools might work in, right?


00:08:05.000 --> 00:08:12.000
And depending on the tool chain you choose, you might need to use two or three different tools just to get started, right?


00:08:12.000 --> 00:08:15.000
Or you use one tool that can do it all.


00:08:15.000 --> 00:08:21.000
I think that for most would be the ultimate goal, I guess, that we have this single one tool.


00:08:21.000 --> 00:08:33.000
And I remember that you had this panel on packaging, right, where you also talked about the difficulties of creating this tool and why it is so hard to do that in Python.


00:08:33.000 --> 00:08:37.000
And yeah, so I identified five main categories.


00:08:37.000 --> 00:08:41.000
One is Python version management, which we just mentioned already.


00:08:41.000 --> 00:08:47.000
Then you have environment management where you can create, manage your virtual environments.


00:08:47.000 --> 00:08:57.000
We have package management, which is basically about installing packages and upgrading them when you need a new version.


00:08:57.000 --> 00:09:09.000
And then when it comes to packaging, I first thought, okay, there's just packaging, but there's actually also tools that can just do the package build step.


00:09:09.000 --> 00:09:12.000
And then there are tools that just do the publishing.


00:09:12.000 --> 00:09:16.000
So I split it up into two categories, one for building and one for publishing.


00:09:16.000 --> 00:09:18.000
Yeah, I think that makes sense.


00:09:18.000 --> 00:09:23.000
Yeah, the publishing stuff people have less exposure to, right?


00:09:23.000 --> 00:09:25.000
That's farther down the line.


00:09:25.000 --> 00:09:27.000
You're not really a beginner at that point.


00:09:27.000 --> 00:09:29.000
Not usually, anyway.


00:09:29.000 --> 00:09:30.000
Yeah, absolutely.


00:09:30.000 --> 00:09:41.000
But I think since many of the tools that do the building step also do the publishing step, you most of the time are going to use a tool that could do it anyway.


00:09:41.000 --> 00:09:43.000
Sure, sure.


00:09:43.000 --> 00:09:44.000
I guess, yeah.


00:09:44.000 --> 00:09:47.000
A bit of real-time follow-up from the audience here.


00:09:47.000 --> 00:09:53.000
Tushar says, "Actually, the EuroPython videos came out just yesterday."


00:09:53.000 --> 00:09:54.000
Oh, that's so nice.


00:09:54.000 --> 00:09:55.000
Yeah.


00:09:55.000 --> 00:09:56.000
Great.


00:09:56.000 --> 00:09:58.000
Yeah, we can link it in the show notes.


00:09:58.000 --> 00:09:59.000
Yeah, we absolutely can.


00:09:59.000 --> 00:10:00.000
Cool.


00:10:00.000 --> 00:10:01.000
Thanks for letting us know.


00:10:01.000 --> 00:10:05.000
So we've already started talking about the categorization here.


00:10:05.000 --> 00:10:11.000
And I'll give a quick shout-out to some of the tools.


00:10:11.000 --> 00:10:17.000
Obviously, pip is involved, virtualenv, but also virtualenv.


00:10:17.000 --> 00:10:22.000
Then you might start talking about, well, some of the tools that do more, like you talked about.


00:10:22.000 --> 00:10:25.000
So maybe Poetry, PDM, Hatch, Rai.


00:10:25.000 --> 00:10:31.000
But stuff people might not know about too much is Maturian or Ensconce.


00:10:31.000 --> 00:10:34.000
There's a wide-ranging set of tools.


00:10:34.000 --> 00:10:46.000
And what you did really nicely in your article and talk is you said, "These five categories, let's create Venn diagrams and put into the overlaps the various tools."


00:10:46.000 --> 00:10:56.000
Like, "PDM can do package publishing and building and environment management and package management, not Python version management."


00:10:56.000 --> 00:10:59.000
So that's kind of the way that you evaluated.


00:10:59.000 --> 00:11:01.000
That's the unbiased aspect, right?


00:11:01.000 --> 00:11:08.000
Is that you're like, "Okay, let's just create some categories and create some ways to evaluate how full-featured or how good is this?"


00:11:08.000 --> 00:11:11.000
And then you go through it, right?


00:11:11.000 --> 00:11:18.000
Yeah, there's actually one step further for the packaging tools like Hatch and PDM Poetry and so on.


00:11:18.000 --> 00:11:21.000
I also thought about features.


00:11:21.000 --> 00:11:32.000
And if you scroll down, there's like a feature list and things I thought about what should these tools be able to do or how do they differ?


00:11:32.000 --> 00:11:35.000
For example, yeah, that's the one.


00:11:35.000 --> 00:11:41.000
So one is if it allows you to manage your dependencies and if it resolves and locks dependencies.


00:11:41.000 --> 00:11:46.000
Since there are some tools like Hatch, which cannot do that at the moment.


00:11:46.000 --> 00:11:49.000
I know that it's supposed to do it in the future.


00:11:49.000 --> 00:11:55.000
But if you want that functionality, then for example, you might not want to use Hatch at the moment.


00:11:55.000 --> 00:12:00.000
And then there's also a large number of peps on packaging.


00:12:00.000 --> 00:12:03.000
But I picked out two specific ones.


00:12:03.000 --> 00:12:13.000
One on editable installs, which I think can be quite useful, especially if you develop your package yourself and you want to install it in editable mode.


00:12:13.000 --> 00:12:16.000
Maybe it's good to mention what this is.


00:12:16.000 --> 00:12:18.000
Tell people why you care about that.


00:12:18.000 --> 00:12:19.000
Yeah, exactly.


00:12:19.000 --> 00:12:31.000
So if you develop your project yourself and you want to make sure that during development, the changes to your package are directly reflected in your environment.


00:12:31.000 --> 00:12:39.000
You would install the package with pip install minus E for the editable flag and the name of the package.


00:12:39.000 --> 00:12:44.000
And then you do not have to reinstall it every time you make a change.


00:12:44.000 --> 00:12:46.000
And this is very useful.


00:12:46.000 --> 00:13:08.000
And then there is one PEP on how to specify your project metadata in the pyproject.toml file, which is like the basic file you need when you specify or create a package where you put all your general information, the name of the package, the website, your author name and so on.


00:13:08.000 --> 00:13:12.000
But also the dependencies, you can define scripts there.


00:13:12.000 --> 00:13:24.000
And there's one tool, namely poetry, which has its own way of defining the metadata, I think because it was developed before this PEP was accepted.


00:13:24.000 --> 00:13:30.000
And they also promised to change it at some point, but they still haven't done that.


00:13:30.000 --> 00:13:44.000
And so I guess that's also something at least you should be aware of when you choose a tool like poetry that it might have a few differences in how to specify it in the pyproject.toml file.


00:13:44.000 --> 00:13:47.000
Yeah, I'd like to hear your thoughts.


00:13:47.000 --> 00:13:56.000
To me, it seems like a lot of these tools like poetry or flit or others, as their own thing, they're pretty self-contained.


00:13:56.000 --> 00:14:05.000
And they kind of do the job for most things you need to do for your package management, project management, installing.


00:14:05.000 --> 00:14:07.000
Hash doesn't lock.


00:14:07.000 --> 00:14:13.000
As long as you kind of stick to them, you're more or less, you can solve all the problems you need with one.


00:14:13.000 --> 00:14:18.000
But choosing, figure out how to choose which one is really hard.


00:14:18.000 --> 00:14:26.000
And kind of like with your Rai example is the reason you chose one six months ago, there might be a better choice now.


00:14:26.000 --> 00:14:30.000
So it's good to see them side by side, don't you think?


00:14:30.000 --> 00:14:31.000
Yes, absolutely.


00:14:31.000 --> 00:14:36.000
And also, that's why I wanted to do the unbiased evaluation.


00:14:36.000 --> 00:14:40.000
There's often personal preference that comes in with packaging tools.


00:14:40.000 --> 00:14:48.000
For example, one of my colleagues, like hates might be a strong word, but he very strongly dislikes poetry.


00:14:48.000 --> 00:14:58.000
Since in the past, they once did an update or a new version and it broke something in the older versions, but they did not tell the users beforehand.


00:14:58.000 --> 00:15:02.000
And several people got very upset.


00:15:02.000 --> 00:15:06.000
And they just said, okay, I'm not using poetry anymore.


00:15:06.000 --> 00:15:15.000
And now if you were then in a team with people and you choose a tool and one of them says like, no, we are not going to use poetry.


00:15:15.000 --> 00:15:20.000
Then, yeah, this is also has also an influence on people.


00:15:20.000 --> 00:15:30.000
So I think having an unbiased view of these tools can be very difficult since it's often also a team decision that if you're already used to using a tool,


00:15:30.000 --> 00:15:33.000
it might be easier to just use that in your team.


00:15:33.000 --> 00:15:42.000
Or if something is already working for you, then it might not be worth putting an effort to learn or get caught up with a new tool.


00:15:42.000 --> 00:15:48.000
Yeah, you don't have to necessarily keep switching to the newest, shiniest one of these, right?


00:15:48.000 --> 00:15:53.000
Like if it's working for you, whatever you're doing, it may be that's fine, right?


00:15:53.000 --> 00:15:54.000
Yeah.


00:15:54.000 --> 00:16:01.000
So before we get into this, many of these things we're going to talk about don't come with Python itself.


00:16:01.000 --> 00:16:05.000
We have pip, we have venv, and set of tools.


00:16:05.000 --> 00:16:10.000
And I think that that's it out of this big long list of things.


00:16:10.000 --> 00:16:17.000
Do you have a preference or a tendency to stick with what comes with Python so you don't have to install other things?


00:16:17.000 --> 00:16:23.000
Or do you see the advantages of these external tools to be greater and worth it?


00:16:23.000 --> 00:16:24.000
I do see the use.


00:16:24.000 --> 00:16:28.000
And sometimes for me, although I've created so many virtual environments,


00:16:28.000 --> 00:16:34.000
I sometimes cannot remember how I need to call venv correctly to create a new virtual environment.


00:16:34.000 --> 00:16:40.000
And with virtualenv, it's just virtualenv and then the name of the environment.


00:16:40.000 --> 00:16:41.000
And it's just simpler.


00:16:41.000 --> 00:16:43.000
And I can remember that.


00:16:43.000 --> 00:16:49.000
So sometimes it can be that easy that it makes it more useful, I guess.


00:16:49.000 --> 00:16:50.000
Yeah.


00:16:50.000 --> 00:16:51.000
Yeah.


00:16:51.000 --> 00:16:53.000
Sometimes also, yeah.


00:16:53.000 --> 00:16:59.000
Other tools, they solve a different problem that's not really related.


00:16:59.000 --> 00:17:05.000
Like pipx and pyenv, there's no real Python equivalent to that.


00:17:05.000 --> 00:17:06.000
No, that's true.


00:17:06.000 --> 00:17:07.000
Yeah.


00:17:07.000 --> 00:17:09.000
Yeah.


00:17:09.000 --> 00:17:10.000
All right.


00:17:10.000 --> 00:17:18.000
Well, let's go through and I guess talk about probably one that people do less but is also really important.


00:17:18.000 --> 00:17:23.000
Not package management, but Python management.


00:17:23.000 --> 00:17:26.000
Want to tell us about that one?


00:17:26.000 --> 00:17:27.000
Yeah, absolutely.


00:17:27.000 --> 00:17:28.000
Okay.


00:17:28.000 --> 00:17:36.000
So Python version management, I always included a short definition since there are no proper definitions of these categories.


00:17:36.000 --> 00:17:38.000
It's just what I thought would be useful.


00:17:38.000 --> 00:17:47.000
So for me, Python version management means that the tool is able to install Python versions and lets you switch between them easily.


00:17:47.000 --> 00:17:50.000
And yeah, most popular for that is pyenv.


00:17:50.000 --> 00:17:54.000
And it's also one of the few tools actually that can do that.


00:17:54.000 --> 00:17:58.000
You can also do Python version management with Conda.


00:17:58.000 --> 00:18:01.000
And then there's Rhino, which can do it and also PyFlow.


00:18:01.000 --> 00:18:07.000
But PyFlow is, I excluded it from my list since it's not actively developed anymore.


00:18:07.000 --> 00:18:08.000
It's still in the Venn diagram.


00:18:08.000 --> 00:18:13.000
But yeah, I'm not sure if it's that up to date anymore.


00:18:13.000 --> 00:18:21.000
But yeah, you can just with pyenv, for example, you can say pyenv install and then like 3.10.4.


00:18:21.000 --> 00:18:27.000
And we'll get the version of Python and install it on your system.


00:18:27.000 --> 00:18:32.000
And then you can just switch between the different versions you have installed.


00:18:32.000 --> 00:18:35.000
And yeah, this can be useful in many different ways.


00:18:35.000 --> 00:18:47.000
For example, if you have projects that support multiple Python versions, or maybe you just want to install the newest one and check out a few of the features it has to offer.


00:18:47.000 --> 00:18:56.000
Yeah, it can just be nice to be able to switch between the versions yourself or set them for your current shell session and so on.


00:18:56.000 --> 00:19:05.000
Yeah, and this starts to get us into an interesting philosophy here.


00:19:05.000 --> 00:19:13.000
Many of these tools kind of take over your day-to-day flow of working with your code and the tools.


00:19:13.000 --> 00:19:20.000
So for example, pyenv, you do pyenv local, pyenv global.


00:19:20.000 --> 00:19:24.000
I guess maybe even more with things like hatch and flit and so on.


00:19:24.000 --> 00:19:37.000
Instead of just saying Python my code or Python -m something, you would say like flit run something, right?


00:19:37.000 --> 00:19:38.000
Yes.


00:19:38.000 --> 00:19:47.000
And it sort of, you got to adopt its way of working on the terminal a little bit to get the most value out of it, right?


00:19:47.000 --> 00:19:51.000
Yes. And that's also something I found confusing in the beginning.


00:19:51.000 --> 00:20:01.000
I remember that when I used Poetry for the first time, I didn't really understand why I couldn't run my package or my code anymore with Python.


00:20:01.000 --> 00:20:07.000
But I always had to put poetry run Python, myscript.py.


00:20:07.000 --> 00:20:20.000
And once you understand that this enables the tool to run your code within a virtual environment for you with all the dependencies installed and you do not have to do anything,


00:20:20.000 --> 00:20:23.000
then it made click for me and it made sense.


00:20:23.000 --> 00:20:31.000
But in the beginning, I was thinking that it was just more complicated and I didn't really see the point.


00:20:31.000 --> 00:20:36.000
Yeah. And going back to the beginner type of thing, right?


00:20:36.000 --> 00:20:43.000
This is, it helps you in a lot of ways, but it's also a new thing that you have to learn in order to get started, right?


00:20:43.000 --> 00:20:52.000
It alleviates the need to say, well, now you know the VENV command, you don't just run it, you say Python-M and then you activate it.


00:20:52.000 --> 00:20:55.000
And it's different on Windows. I don't know why it's different on Windows, but it just is.


00:20:55.000 --> 00:21:01.000
So you just do that, you know, but at the same time, you now have to learn a slightly different way to run it.


00:21:01.000 --> 00:21:05.000
And so I think that that's an interesting trade-off that a lot of these tools make.


00:21:05.000 --> 00:21:14.000
Another thing that I think about when I think about these tools is like you were saying you can't just run your Python code


00:21:14.000 --> 00:21:21.000
because a lot of times this management of the dependencies and the environment,


00:21:21.000 --> 00:21:28.000
that often lives in some kind of hidden place in your user profile or somewhere, right?


00:21:28.000 --> 00:21:35.000
Whereas if I say Python-M VENV, it makes a folder wherever I run that.


00:21:35.000 --> 00:21:36.000
And so I can activate it.


00:21:36.000 --> 00:21:45.000
So for example, if one of these tools were to make the environment locally instead of in some kind of obscure location it finds,


00:21:45.000 --> 00:21:49.000
then I could still just activate it and do regular Python things.


00:21:49.000 --> 00:22:00.000
But if it hides it from me, then I'm required basically for any practical reason to like go through its terminal commands, its shell, CLI, right?


00:22:00.000 --> 00:22:01.000
Yeah.


00:22:01.000 --> 00:22:08.000
Is that something you considered? Like which ones have overrides to put them locally or do it by default?


00:22:08.000 --> 00:22:10.000
Is that anything you considered here?


00:22:10.000 --> 00:22:16.000
No, actually I did not. But that's a very good point for an extension of the post to consider that.


00:22:16.000 --> 00:22:26.000
I just got used to just calling, for example, with Poetry, you can just say Poetry shell and then it will activate the virtual environment for you, right?


00:22:26.000 --> 00:22:32.000
So it's just, I guess, getting used to a different way of activating your virtual environment.


00:22:32.000 --> 00:22:46.000
So that worked well for me, but I think it's just, yeah, it depends on how much you have used the other virtual environment functionalities before.


00:22:46.000 --> 00:22:55.000
For me, it wasn't that hard to switch, I guess, since I work a lot with packages and yeah, then it can be very convenient.


00:22:55.000 --> 00:23:07.000
I totally agree. I guess what I didn't really say before, and I was talking about like using the new CLI stuff is when you're doing this for yourself, you kind of adopt one and you get used to it and you're like, "All right, this is great."


00:23:07.000 --> 00:23:17.000
But if I'm following, say, a tutorial on some docs, it'll say, you know, "Okay, activate the virtual environment this way." You're like, "Wait, that's not how I do it."


00:23:17.000 --> 00:23:20.000
You know, "Now run Python." "Wait, that's not how I run it."


00:23:20.000 --> 00:23:29.000
And so, you know, this putting it together of like, "I know what I'm doing and I see what the thing tells me to do, but how do you make sure that those are lining up?"


00:23:29.000 --> 00:23:39.000
And if there's a local environment that's kind of equivalent, like you could sort of follow the steps and it might still work. It's kind of what I was thinking.


00:23:39.000 --> 00:23:46.000
Yeah, I think that's a very useful idea. I will put that on my list of things to look at.


00:23:46.000 --> 00:23:49.000
This could be your PyCon US talk.


00:23:49.000 --> 00:24:06.000
Yeah, I actually have an idea for PyCon US next year already, which I want to work on. I did a lot of packaging work for the last months, but I really want to keep this post updated since I find it useful myself.


00:24:06.000 --> 00:24:17.000
And I was asked by so many people after the talks and also at my company now, many people ask me, "Which tool am I supposed to use now?" And we have these requirements and so on.


00:24:17.000 --> 00:24:25.000
And running, like having the virtual environments somewhere where you can activate them also yourself, I think that's a very useful thing to do.


00:24:25.000 --> 00:24:32.000
I never thought about this following a tutorial point of view, but it is very important for learners, I guess.


00:24:32.000 --> 00:24:46.000
Yeah, especially when you're a beginner. Yeah, absolutely. It's also worth pointing out there are some tools that you just didn't really evaluate because you didn't quite necessarily see that they fit totally in the picture, like pip-tools, which I'm a big fan of actually.


00:24:46.000 --> 00:24:54.000
But also Mike Fiedler out there asked, "Was pyenv-virtualenv evaluated as well?"


00:24:54.000 --> 00:24:59.000
No, it wasn't. I should write that down. I will do that right now.


00:24:59.000 --> 00:25:04.000
Yeah, I can guess, but I have no experience with pyenv-virtualenv.


00:25:04.000 --> 00:25:05.000
Me neither.


00:25:05.000 --> 00:25:08.000
But the speaking of it is tricky.


00:25:08.000 --> 00:25:15.000
But I think I put pip-tools in the very end of the post into the categories of tools which don't really fit in.


00:25:15.000 --> 00:25:31.000
Also, TOX is there and the author of TOX, which can be used or which I only knew from testing, where it allows you during testing to specify different Python versions, which you want to run your tests with.


00:25:31.000 --> 00:25:38.000
But TOX also can be used to handle virtual environments. And I was completely unaware of that.


00:25:38.000 --> 00:25:48.000
But it's still not complete, the picture with the five categories, but it's already complicated enough, I guess.


00:25:48.000 --> 00:26:02.000
Yeah, I don't know how much value it adds to really say, "We're going to completely cover everything," because part of the value is making a few recommendations as well, I think.


00:26:02.000 --> 00:26:03.000
Yes.


00:26:03.000 --> 00:26:11.000
Not just going, "Here's a complete list," because that sounds more like an awesome list of packaging, which maybe that exists, I don't know.


00:26:11.000 --> 00:26:18.000
Maybe that's also a good point to add for everyone that wants the solution now.


00:26:18.000 --> 00:26:23.000
I do not have the solution. I cannot give you the best tool.


00:26:23.000 --> 00:26:29.000
It really depends on what you want to do, what your team is doing, what your personal preferences are.


00:26:29.000 --> 00:26:36.000
Hopefully, at some point, we might have the one tool which can do everything and is adopted by most people.


00:26:36.000 --> 00:26:43.000
But at the moment, lots of these tools are really used and also can be useful.


00:26:43.000 --> 00:26:49.000
Yeah. There's so many variations. There's more variations, not fewer.


00:26:49.000 --> 00:26:53.000
So I would like to see that too, but it is tricky.


00:26:53.000 --> 00:27:03.000
And there's so many. I think another one of the challenges to think about that I know I've seen previously around, say, for example, pipenv versus some of the other tools,


00:27:03.000 --> 00:27:09.000
where are you building a library that you want others to use, or are you building an application?


00:27:09.000 --> 00:27:10.000
Yes.


00:27:10.000 --> 00:27:15.000
Because if you over-constrain, say, your lock file, no one can use your library.


00:27:15.000 --> 00:27:19.000
But that's exactly what you want for your application, so it's totally stable.


00:27:19.000 --> 00:27:27.000
These kinds of tensions are in there, and so it could also be pick the right tool for the right situation.


00:27:27.000 --> 00:27:28.000
Absolutely.


00:27:28.000 --> 00:27:38.000
I actually, in the beginning, when I first worked on the talk, like it is 45 minutes long, which is the longest time slot you can get at PyCon.


00:27:38.000 --> 00:27:48.000
And I had this point with applications versus library in it, but I really had to get rid of stuff since it was way too long.


00:27:48.000 --> 00:27:59.000
And it was really hard to decide what to talk about and what not, since there are so many points to consider that it can be hard to boil down to the most important facts.


00:27:59.000 --> 00:28:02.000
Yeah. All right. Let's talk about...


00:28:02.000 --> 00:28:03.000
I also had...


00:28:03.000 --> 00:28:04.000
Go ahead. Sorry.


00:28:04.000 --> 00:28:12.000
No, I just was thinking that I also had live demos in the talk in the beginning for the different tools, but that also took up way too much time.


00:28:12.000 --> 00:28:17.000
But it can be fun to play around with them to get to know them better.


00:28:17.000 --> 00:28:18.000
It's super fun.


00:28:18.000 --> 00:28:26.000
The live demos that involve downloading stuff from the Internet are scary, though, because it conferences the Internet can be pretty sketchy sometimes.


00:28:26.000 --> 00:28:28.000
Yeah, that's true.


00:28:28.000 --> 00:28:42.000
All right. So the first area was virtual environment management, and that's tools like VNV, also virtual NV, PIPV, which we just talked about, Conda, and then even Raya.


00:28:42.000 --> 00:28:48.000
So let's maybe talk about some of these. You sort of compare...


00:28:48.000 --> 00:28:53.000
We talked a bit about using VNV versus virtual ENV.


00:28:53.000 --> 00:29:03.000
I've always just stuck with the built-in one for the reason that it's built-in, but it sounds like you use virtual ENV more. What do you find better about it?


00:29:03.000 --> 00:29:08.000
It's both, actually. Sometimes I use one and sometimes the other.


00:29:08.000 --> 00:29:13.000
Yeah. I actually don't really know why.


00:29:13.000 --> 00:29:20.000
My understanding is virtual ENV is faster, but it's not something I'm doing a ton of.


00:29:20.000 --> 00:29:26.000
So it's like I'll set one up for a project and then I'm good to go. So it doesn't really motivate me.


00:29:26.000 --> 00:29:37.000
One area that I think is important to cover is maybe the files that specify your project and your dependencies and dependency restrictions.


00:29:37.000 --> 00:29:38.000
Maybe let's do that.


00:29:38.000 --> 00:29:50.000
Yeah. So traditionally there's been this requirements.txt, which is just lines in a text file, but there's been in almost all of these tools a move towards pyproject.toml.


00:29:50.000 --> 00:30:02.000
Exactly. So I think that's a very important point to know about if you talk about packaging in general, that you have one file, which is pyproject.toml.


00:30:02.000 --> 00:30:09.000
For me, toml was in the beginning of a new config language or format I didn't know about.


00:30:09.000 --> 00:30:15.000
So it's like you have YAML files and JSON files and toml is this other format, which is quite simple.


00:30:15.000 --> 00:30:25.000
And it was decided to use the toml format. And in the PEP for pyproject.toml, where it was introduced, they also discussed the different formats.


00:30:25.000 --> 00:30:32.000
So it's quite an interesting read. And yeah, this is the central file in your package.


00:30:32.000 --> 00:30:41.000
I already mentioned that you put like general information there, like the name of the package, the author names, where the readme is and so on.


00:30:41.000 --> 00:30:47.000
But it allows you to do very complex things as well. Now you can configure tools there.


00:30:47.000 --> 00:30:55.000
Like if you want to do formatting with black or style checks and so on, you can define that there.


00:30:55.000 --> 00:31:01.000
Yeah. And you can put your dependencies, what you mentioned there.


00:31:01.000 --> 00:31:08.000
Then some tools allow you even to specify different virtual environments and how they should look like.


00:31:08.000 --> 00:31:20.000
You can define scripts that you want to run. And then, for example, if you always run your pytest tests, you can have like a command,


00:31:20.000 --> 00:31:28.000
Hatch run test or Poetry run test and it would run the test for you and maybe also do the coverage report and so on.


00:31:28.000 --> 00:31:32.000
Yeah. In your article, you link over to the pandas pyproject.toml.


00:31:32.000 --> 00:31:38.000
And that thing has a lot of stuff going on, as you would imagine from such a project as pandas.


00:31:38.000 --> 00:31:50.000
But you can even specify like project URLs, entry points for just running a command on the terminal.


00:31:50.000 --> 00:32:00.000
Things like if you want to use AWS, you could pip install bracket AWS and that actually brings in a whole list of potential dependencies or GCP.


00:32:00.000 --> 00:32:06.000
Yeah, pretty comprehensive. Way more than just a list of dependencies.


00:32:06.000 --> 00:32:14.000
You know, if you stay there, that is also an important point that in the pyproject.toml file, you define which build backend you use.


00:32:14.000 --> 00:32:24.000
So this would then be where you, for example, maybe have poetry or hatchling or setup tools and so on.


00:32:24.000 --> 00:32:32.000
So which tool you want to use to really do the building step in the back behind the curtain.


00:32:32.000 --> 00:32:34.000
How do you say that? Yeah, you know what I mean?


00:32:34.000 --> 00:32:42.000
Yeah, exactly. Yeah. And yeah, here's the build system that it's got here.


00:32:42.000 --> 00:32:47.000
Build backend is mesonpy for this particular one. Interesting.


00:32:47.000 --> 00:32:54.000
Yeah. So this is it's less important if you have a pure Python thing.


00:32:54.000 --> 00:32:57.000
Right. Although it's still potentially relevant for building the wheel.


00:32:57.000 --> 00:33:09.000
But if you've got a really complex like a rust integration or a C++ integration, then how that all happens when you say build, you want to have a lot of control over that. Right.


00:33:09.000 --> 00:33:20.000
And also, if you use a tool like poetry, it will set the build backend to poetry, I guess, automatically, which most of the tools do.


00:33:20.000 --> 00:33:27.000
Most of the tools decide which build backend to use. Only PDM is a tool which allows the user to choose the build backends freely.


00:33:27.000 --> 00:33:36.000
I think Hatch uses hatchling and poetry uses poetry, I guess. I don't know about the others, actually.


00:33:36.000 --> 00:33:43.000
Sure. OK. We've been talking for a little while now. We finally come to the thing the person wants to do.


00:33:43.000 --> 00:33:50.000
Pip install a package. Right. Exactly. So that is package management.


00:33:50.000 --> 00:33:56.000
So there are several tools that allow you to download and install libraries and their dependencies.


00:33:56.000 --> 00:34:09.000
And the major one, which everyone knows, I guess, is pip. But there's also pip X or you could use conda to install packages, but also poetry, for example, like one of these packaging tools.


00:34:09.000 --> 00:34:17.000
And it will download the library for you and install all the dependencies automatically.


00:34:17.000 --> 00:34:21.000
Yeah, I guess that's the most important thing to know about it.


00:34:21.000 --> 00:34:31.000
Yeah. So a lot of these will make the virtual environment for you. And then you just instead of pip install you their name install, right?


00:34:31.000 --> 00:34:36.000
Like poetry install or sometimes they have add, right? Something along those lines.


00:34:36.000 --> 00:34:41.000
But then they'll figure out where their virtual environment is and install the thing the way you've asked.


00:34:41.000 --> 00:34:53.000
Yes. And also, if you use one of the packaging tools, it will do the dependency resolutions for you, which sometimes works, sometimes not so well.


00:34:53.000 --> 00:35:00.000
But I guess this is something that pip is not doing. I think it just tells you about conflict.


00:35:00.000 --> 00:35:18.000
Yeah. Yeah. Another important thing that it helps you, many of these tools help you with that pip will not help you with is dependency recording or accounting, I guess, is the right way to maybe think about that, as well as restricting it to a particular version.


00:35:18.000 --> 00:35:27.000
So if you add one of these things, it might put the dependency into the pyproject.toml and then also create a lock file, right?


00:35:27.000 --> 00:35:33.000
Exactly. Yeah. Yeah. Should we shortly say what lock files are about?


00:35:33.000 --> 00:35:35.000
Yeah. Yeah. Tell people about it.


00:35:35.000 --> 00:35:44.000
Yeah. Okay. So this is the second recap I had in the talk or which is also in the blog post. First one was pyproject.toml and the second one is a lock file.


00:35:44.000 --> 00:36:05.000
So in the pyproject.toml file, you would usually have your dependencies, but in an abstract fashion. So you would not pin them to exact versions. So you would not say, I need pandas 2.0.3, but you would set a range or not give a restriction at all.


00:36:05.000 --> 00:36:13.000
And then you have the lock file, which really records the exact versions of all the dependencies that you have installed for a project.


00:36:13.000 --> 00:36:25.000
And if you commit or have that lock file within your repository, it allows to really reproduce the exactly same setup that you have on your machine.


00:36:25.000 --> 00:36:35.000
So you can reproduce it on multiple platforms. And I also linked one, I think the one from Poetry. So if you look at a lock file, it can become huge.


00:36:35.000 --> 00:36:41.000
So it really has the exact versions of all dependencies and sub dependencies and so on recorded.


00:36:41.000 --> 00:36:54.000
Yeah, here we go. This one from Poetry. Yeah, that is, let's see, that's a thousand six hundred and eighty five lines. That is a big lock file.


00:36:54.000 --> 00:36:55.000
Yes, it is.


00:36:55.000 --> 00:37:08.000
It also, though, it does follow some of the best practices. Right. So it says the package mypy in the version of it rather than just mypy equal equal one five one.


00:37:08.000 --> 00:37:15.000
It'll have things like, and here's the hash of that, which is a recommendation to store that.


00:37:15.000 --> 00:37:25.000
But in addition to just saying, here's the hash for my particular install, it has it here it is for macOS. Here it is for Southern version. Here it is for Linux.


00:37:25.000 --> 00:37:31.000
Here it is for the ARM version of Windows or the AMD version of Windows. Right. And on and on.


00:37:31.000 --> 00:37:46.000
So it does record a lot of information there. But the main goal of just saying in a year, if I go pip install or poetry update or what, I don't remember the poetry command.


00:37:46.000 --> 00:37:52.000
There's so many. I've read all of the different CLIs for all of them. So equivalent of pip install.


00:37:52.000 --> 00:38:02.000
It'll look at that and go exactly the same thing because I see one of the guys in the audience here. I was just speaking with him.


00:38:02.000 --> 00:38:11.000
One of my courses, I didn't pin the dependencies and it uses SQLAlchemy and SQLAlchemy 2 is now out, which is awesome.


00:38:11.000 --> 00:38:16.000
But SQLAlchemy 2 has a breaking change from SQLAlchemy 1. So some code sample wouldn't run.


00:38:16.000 --> 00:38:22.000
It's like, oh, what's going on? Like, oh, no, just for now, pin the dependency yourself and I'll fix it later today.


00:38:22.000 --> 00:38:32.000
But it's it's not a theoretical problem. I literally ran into it yesterday, today through by way of one of the students.


00:38:32.000 --> 00:38:45.000
Yeah, I agree. It can be very useful. Also, if you work on a project with several people, then having the same setup everywhere can keep you from having a headache.


00:38:45.000 --> 00:38:55.000
Yeah. How much isolation do you do personally for your work? Do you do like Docker containers or is it enough to just have a lock file and agreed upon version of Python?


00:38:55.000 --> 00:39:06.000
And we often use Docker containers since I work a lot with production environments. But for personal projects, I usually only use the lock file.


00:39:06.000 --> 00:39:13.000
Yeah. Same here. I don't really use Docker all that much. I find that it's enough with just a lock file.


00:39:13.000 --> 00:39:28.000
All right. Lock file is super important. Maybe, you know, instead of going through all of these, maybe just give your thoughts on some of the with regard to package management, just some of the things in here.


00:39:28.000 --> 00:39:49.000
Yeah, I think for me, especially one important point was there is Conda also, which you can use for lots of things. But the post and also the talk does not go into detail on Conda since it's this huge, like, huge own environment or universe with Conda.


00:39:49.000 --> 00:40:05.000
Also, packaging works a little differently. And the resulting packages will be on the not on PyPI, but they have their own index. So, yeah, there's not a lot of detail there. And there's also pipenv. I've never used to them myself, actually.


00:40:05.000 --> 00:40:34.000
I never really had the use case for it, but it has been around for a long time. And what I found interesting is that pipenv uses also the lock file functionality and also introduces a toml file, but it's pipfile.toml, which I found interesting since it shows that also some tools before the standard was introduced used something similar,


00:40:34.000 --> 00:40:48.000
which I found interesting. But for me now, I'm not using pipenv since I like having only the pyproject.toml file. Having this additional pip file just confuses me.


00:40:48.000 --> 00:40:55.000
Yeah, because a lot of the packaging and stuff you can already do through pyproject.toml. So why have more files?


00:40:55.000 --> 00:41:21.000
Yeah. And I often also have to do package building. So to get a real file or just be able to install the packages on different environments. And then it's nice to use one of the other tools since pipenv can do package management and environment management, but not the packaging itself, like building a real file or publishing the package.


00:41:21.000 --> 00:41:30.000
Skipping ahead a little bit. What one are you using these days for building packages or publishing them?


00:41:30.000 --> 00:41:50.000
I'm currently using Hatch. I like it a lot since it allows you to declare your environments within the pyproject.toml file and I like to have everything organized. So having a single place where you can also say, okay, this is my environment for creating the documentation.


00:41:50.000 --> 00:42:18.000
And I only need material like mkdocs material for this or having one environment for all the style issues like running black and eyesore and the type checkers. I like that a lot. But a lot of people from my company are now using Rai. So I have to check that out, I guess, very soon for some proper project.


00:42:18.000 --> 00:42:31.000
I want to save Rai until the end because it's a very different philosophy. Not putting a judgment on it, but it really lives in a different style and philosophy than many of these other tools.


00:42:31.000 --> 00:42:32.000
Absolutely.


00:42:32.000 --> 00:42:45.000
You hinted towards this with the packaging panel discussion I had with some folks there and I think we're going to see stuff going that way. Maybe not exactly with Rai, but in that general vibe.


00:42:45.000 --> 00:43:06.000
Yeah. You know, this idea of having multiple environments for certain different parts of your program or of your project is really interesting because for small projects it doesn't matter. But as they get bigger and bigger, I was just talking to Brian Aukin yesterday on Python Bytes about this and he brought this up.


00:43:06.000 --> 00:43:26.000
On Talk Python Training I have maybe, where the courses are, I have maybe 48 dependencies that I list in the main top level. These are the things I'm using. But there's 250 different packages if you pip install -r, you know, like build out that whole thing, right, the transitive dependencies.


00:43:26.000 --> 00:43:50.000
Most of the time it will not install everything, right? I can get the stuff to run the site all the time, but also the data science analysis stuff and the notebook tools and other things like this mkdocs stuff, one of those has a restriction that is something less than x and another part has something greater than x and they just can't go together.


00:43:50.000 --> 00:44:06.000
And they don't necessarily need to live together, but in order, just without having a separation of where the dev tools go and where the accounting tools go and where the runtime tools go, they get too mixed together, you know?


00:44:06.000 --> 00:44:24.000
Yeah, absolutely. And I'm also actually not sure if any of the other tools do the same already since it all changes so quickly. I haven't checked the other tools in the past four weeks. So I just got started with Hatch and that's also what I mentioned in the beginning.


00:44:24.000 --> 00:44:43.000
Sometimes when you got used to using a tool and it works well for you, you do not get weird errors when you install it or do things and you find when you have a problem, you find the error messages useful and how it works. And I also liked the podcast episode you had with the author.


00:44:43.000 --> 00:45:00.000
Yes, exactly. Yeah, I really liked listening to it and that he's working on it and I find it really impressive what he's doing with just, he's not even able to type, right?


00:45:00.000 --> 00:45:12.000
I believe he has some limitation, I believe he can, I think it's just limited. So yeah, it's really impressive what he's doing. I think it's great. I think Hatch is cool.


00:45:12.000 --> 00:45:22.000
Yeah, I agree. But I have to say I also used Poetry in the past, which also worked well for me. I have nothing against Poetry.


00:45:22.000 --> 00:45:39.000
Just your teammate does. Awesome. Okay, let's see. We talked about Conda. Let's, I don't want to just make it go into all the list. So let me come down here and find some more.


00:45:39.000 --> 00:45:47.000
Maybe, I think PDM is maybe interesting. It's one of the newer ones. So people might know less about it. Do you want to talk, tell people about PDM?


00:45:47.000 --> 00:45:55.000
Yes. Yeah, it's also, I sometimes forget about it since I've never used it, but I know several people which like it a lot.


00:45:55.000 --> 00:46:16.000
So PDM for me was quite new since most of the tools are based on using virtual environments. And PDM is one of the only tools I think that implements a PEP, which is PEP 582 on local packages, which is an alternative way of implementing environment management.


00:46:16.000 --> 00:46:32.000
And the PEP was recently rejected. So yeah, beforehand, it was open of whether that might be the new way to do environment management, but I think it's still an interesting approach.


00:46:32.000 --> 00:46:49.000
And yeah, PDM is also, I guess, used by many people. It can do everything except for managing Python versions. But it allows you to choose your build backend freely. So you have quite a lot of flexibility.


00:46:49.000 --> 00:47:02.000
And it's also developed very quickly. So like new features added and it's a very active project.


00:47:02.000 --> 00:47:17.000
Earlier, Mike Fiedler said, "Pour one out for easy install." Indeed, I would say, I would add to that, that pour one out for PEP 582, because I really like that idea.


00:47:17.000 --> 00:47:32.000
It was a little bit like the way that Node modules and the project.json stuff works for Node, where it's just like, if you try to do something, it's just going to go up in the directories until it finds the directory that contains the thing.


00:47:32.000 --> 00:47:44.000
Like find where the virtual environment is at the top and just use that without you having to activate it and do all sorts of stuff. And I thought that was a cool idea. But it's not a thing, unfortunately.


00:47:44.000 --> 00:47:47.000
I guess it's still a thing for PDM, right?


00:47:47.000 --> 00:48:04.000
Yes, it is. And I also, I didn't read about the rejection. So I have no idea why it was rejected. But I know that they always put a lot of thought on or into the rejection. So why they do that. I have to check that out.


00:48:04.000 --> 00:48:30.000
You know, you look at other ecosystems, other programming languages, they've got like five ways to do one thing. And they're just, it seems like it's just constantly being changed to just chase trends. And over the years, that becomes a real messy language and way to do things. So I really appreciate that Python says no often, but I will miss this feature.


00:48:30.000 --> 00:48:48.000
I think it's also impressive how much work is put into these peps. And how much work they do on like formulating their ideas and discussing it very thoroughly to get to a good result. And I'm very happy that they do that for Python.


00:48:48.000 --> 00:49:13.000
Me too. And I think another really interesting aspect is just so many people use it, right? There's so many edge cases or scenarios that don't necessarily, maybe this breaks that I don't know about. Let me pose a question from the audience here from demystifying dev says, newbie question, if pip freeze outputs a perfectly usable requirements.txt file, if you want, can't that be used? What's lacking? Why these other tools?


00:49:13.000 --> 00:49:24.000
I think honestly, the reason I bring this up is this kind of like, is it almost like why do all these tools exist, right? It really is at the heart of your whole article or talk.


00:49:24.000 --> 00:49:43.000
Yeah, I think especially now this is just one of the use cases, right? Many of the tools do lots of other things as well. I think that's why a lot of them exist, especially on packaging such that you do not have to use one tool or several tools for all the different steps.


00:49:43.000 --> 00:50:03.000
In this, sorry, I cannot see the questions anymore. So I guess I still know people which use requirements.txt files. So I do think it can be useful, especially if you do not work with packaging.


00:50:03.000 --> 00:50:21.000
So if you don't want to create a package and pyproject.toml puts or adds another level of complexity, which you don't use, then I don't think you have to use it. I guess that's really specific for your use case.


00:50:21.000 --> 00:50:37.000
But if you have a package, and you have all this other information that you need to publish with it, then it's nice to have this one single file with everything, also with the dependencies and not have many different files for different things.


00:50:37.000 --> 00:50:57.000
Yeah, I agree. I think another aspect of this is this totally works well, but a lot of it's manual, right? So I could pip install a thing and it works, but then if I forget to go and put it into the requirements.txt, well, that was a manual step that I needed to remember.


00:50:57.000 --> 00:51:17.000
Or I put it in there, but I forgot to pin it. You run into the problem that I ran into earlier with SQLAlchemy changing. And with the other tools, that's their flow. You say poetry, add, whatever. It puts it into the requirements file. It puts it into the lock file.


00:51:17.000 --> 00:51:33.000
It installs it. All of those things are kind of taken care of for you. So I think part of it is that the tools kind of do the recommended workflow for you, rather than you having to remember to do it.


00:51:33.000 --> 00:51:40.000
Yeah, that's a very good point. And it also allows you to make less mistakes with your project.


00:51:40.000 --> 00:51:56.000
Yeah, you don't even have to really be aware of that. As a newbie, you just say, "Well, I know I say hatch, add, a thing, and then it works." I don't have to know, "Well, here's why you use the hash, and here's why you pin the dependency." It just does.


00:51:56.000 --> 00:52:13.000
You do give a mention to pip tools here at the end, somewhere there. And I think if you go the requirements.txt file way, which actually, honestly, the thing I'm using these days is pip tools.


00:52:13.000 --> 00:52:26.000
It lets you create a file, and then it creates this requirement, kind of like pip freeze. It creates this requirements.txt, but it also lets you evolve that over time. You can say, "I want to upgrade my thing."


00:52:26.000 --> 00:52:42.000
If I'm using FastAPI, and I say, "Pip install --upgrade FastAPI," it'll upgrade FastAPI, but not the things like Starlette that FastAPI uses. That's another reason to not do that more manual process that we were just talking about.


00:52:42.000 --> 00:52:58.000
How do you make sure you update all of the things in a coherent way? That's very, very tricky. You can still do it, but even if you do that, I think you've got to use something like pip tools or some other higher order thing there.


00:52:58.000 --> 00:53:10.000
Yeah. I can also understand that it can be frustrating in the beginning if you have to look into another tool to do what you want to do, if there's the simple hacky way to do it.


00:53:10.000 --> 00:53:29.000
But if you think in the long run, and also if you work on bigger projects, it's always a good idea to get used to these tools in the beginning, since they save you a lot of work and also save you from doing mistakes that you then have to debug, which is annoying.


00:53:29.000 --> 00:53:43.000
Also, when you're working by yourself, YOLO, you get to do whatever you want. But you working in a team, using something like Hatch means everybody does the same thing, and that's actually really important, too.


00:53:43.000 --> 00:53:48.000
Yeah. Actually, I think Rai uses pip tools as well.


00:53:48.000 --> 00:54:01.000
Oh, interesting. Okay, let's close out our conversation here with Rai, because it's different in the way that its philosophy on how it works for package management, right?


00:54:01.000 --> 00:54:20.000
Yes. So I think if you want to understand Rai, you have to know about Rust, which is a very popular programming language at the moment. And Rust has a very nice setup of how packaging works, since you have two tools, namely Rustup and Cargo, which do everything.


00:54:20.000 --> 00:54:35.000
You do not have these different tools for different steps, and everyone can contribute their own tool and it gets really messy and hard to understand, as it is for Python. But it is very simple and easy to use.


00:54:35.000 --> 00:54:54.000
And the author of Rai wrote Rai completely in Rust and was inspired by Rustup and Cargo. And Rai is also a tool that can do everything. It also is doing Python version management for you, which I guess is easier since it is not written in Python.


00:54:54.000 --> 00:55:11.000
And yeah, it's a tool that can do it all. It was started as a personal project, but there are new versions released, I guess, weekly. And when I last checked it, it was moving really, really fast.


00:55:11.000 --> 00:55:29.000
And the author is also the creator of Flask. So he's, I guess, very well known. That's also why people are adopting Rai very quickly. So I think it's a very nice or interesting addition to the whole mix.


00:55:29.000 --> 00:55:48.000
Yeah, I think it is as well. The most unusual thing, the reason I said it's unlike all of the others, the way that I use pipx is I somehow say Python, or I say somehow pip install pipx and then I can use pipx.


00:55:48.000 --> 00:56:03.000
Or I somehow Python -m pip install hatch and then I can use hatch for more Python stuff. But all of those things start with Python, some version of Python, and then I can do more Python things with them.


00:56:03.000 --> 00:56:18.000
Whereas Rust up in that world and Rai in the Python world, it says you have nothing. You don't even have Python. You ask for a version of Python and then you ask for environments, then you ask for dependencies.


00:56:18.000 --> 00:56:29.000
And so it has all the flexibility it wants to do whatever it needs because it doesn't actually depend on you even having Python, much less the right version of Python. Yeah?


00:56:29.000 --> 00:56:31.000
Exactly.


00:56:31.000 --> 00:56:35.000
You think that's going to be a trend? You think we're headed that way?


00:56:35.000 --> 00:56:50.000
Wow, that's hard to answer. I'm actually not sure. I think it would be nice. I would really like having a tool that can do everything and get rid of this clutter.


00:56:50.000 --> 00:57:01.000
Also, since I like everything to be organized, and it can be really confusing. And I know that most people are just complaining about packaging in Python.


00:57:01.000 --> 00:57:13.000
So yeah, but I know that also, it's just difficult to get to the state where you have this one tool. I remember that discussion from your podcast with the packaging panel.


00:57:13.000 --> 00:57:21.000
It's not that people do not want to have this tool. There are reasons that it's so hard to do it.


00:57:21.000 --> 00:57:33.000
Yeah, it's hard to get everybody to agree, switch over to this thing. Whereas I think Rust was more built from scratch or designed from scratch to have it.


00:57:33.000 --> 00:57:44.000
And that's an advantage Rust has existing, getting created when it did more recently. Python came out when we had Usenet maybe, right?


00:57:44.000 --> 00:57:56.000
Certainly, the ubiquity of the internet wasn't there. And we just didn't, downloading stuff off the internet everywhere, just on your command prompt or whatever it was at the time. It's just not a thing.


00:57:56.000 --> 00:58:05.000
Yeah, and it's good that newer languages learn from the mistakes of previous ones. So it's good that they added it.


00:58:05.000 --> 00:58:13.000
We probably will end up with something like Rai, but maybe people got to agree on it. That's tough.


00:58:13.000 --> 00:58:22.000
I guess one really quick thing to close out this whole section, main topic is, Tony out in the audience asks, I'm working on a large Python mono repo.


00:58:22.000 --> 00:58:36.000
So we have all kinds of dependency conflicts and resolutions we have to deal with. Maybe just worth pointing out that the multiple environments that Hatch has might address that. What do you think?


00:58:36.000 --> 00:58:49.000
Yeah, I'm also in my project right now, we have a huge mono repo, but the different folders also correspond often to different packages. So they have their own pyproject.toml file.


00:58:49.000 --> 00:59:09.000
So you can keep the dependencies organized. But if you have lots of dependencies that are for specific things, and they are not necessarily related to what you're doing in a different step, then that can be very useful.


00:59:09.000 --> 00:59:23.000
The Hatch functionality where you can define virtual environments with only the dependencies that you need for the specific task, like creating the documentation or checking style things.


00:59:23.000 --> 00:59:38.000
Excellent. You can see there are many more tabs on my web browser of things I would like to bring up and chat with you about on this topic. But at the same time, we are out of time and it's getting late over there in Germany.


00:59:38.000 --> 00:59:51.000
So maybe we'll call it a wrap here. But before we get out of here, how about a recommendation for a Python package or project that you think is cool?


00:59:51.000 --> 01:00:07.000
Yes. So I thought about this, since there are lots of people who always suggest so many nice packages. But what I'm really using a lot is mkdocs material for building documentation without a lot of work.


01:00:07.000 --> 01:00:28.000
I've just did that today. Especially if you work on a project which is difficult to explain to other people and you want to have one place and not use Confluence or other tools for documentation, this is a very nice tool to use.


01:00:28.000 --> 01:00:36.000
Excellent. Yeah, it looks great. And more than a static site, it says, it sets up search and all kinds of cool things for it.


01:00:36.000 --> 01:00:48.000
And it's very easy to use. I think even for beginners, that is a very easy way to set up a nice documentation for your package, which you can build now with one of the tools we discussed.


01:00:48.000 --> 01:00:59.000
Yeah, absolutely. It is. Okay. Excellent presentation. I really like the way you put this all together. It's going to be super helpful for folks.


01:00:59.000 --> 01:01:12.000
Yeah, I feel like it.


01:01:12.000 --> 01:01:30.000
Yeah, I think actually that's the best way to go. The other projects that we discussed on previous podcasts are also on my blog. And definitely check out my GitHub profile, I think. I have, for example, a repository on machine learning with machine learning tutorials, which is really popular.


01:01:30.000 --> 01:01:36.000
So if you like machine learning, that might be useful as well. We can link the GitHub repo, I guess.


01:01:36.000 --> 01:01:42.000
Yeah, absolutely. I'll put it in the show notes. Anna Lena, thank you for being here. It's always nice to have you on the show.


01:01:42.000 --> 01:01:45.000
Thank you. Have a good day.


01:01:45.000 --> 01:01:47.000
Bye.

