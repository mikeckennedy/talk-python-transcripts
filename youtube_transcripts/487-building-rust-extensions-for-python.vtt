WEBVTT

00:00:00.001 --> 00:00:05.000
David, Samuel, welcome to Talk By Than Me.

00:00:05.000 --> 00:00:07.000
Thank you very much for having me.

00:00:07.000 --> 00:00:09.000
Thank you for having me.

00:00:09.000 --> 00:00:11.000
Yeah, good to have you, David.

00:00:11.000 --> 00:00:14.000
And Samuel, it's always good to have you back on the show.

00:00:14.000 --> 00:00:17.000
So we're going to talk about Rust,

00:00:17.000 --> 00:00:21.000
some really cool experiences that David had

00:00:21.000 --> 00:00:25.000
building a linter that works on a ridiculous number

00:00:25.000 --> 00:00:28.000
of different projects and packages.

00:00:28.000 --> 00:00:32.000
And Samuel, Rust is obviously core to Pydantic.

00:00:32.000 --> 00:00:34.000
And I want to talk a bit about Pydantic

00:00:34.000 --> 00:00:36.000
and how you guys have used Rust as well.

00:00:36.000 --> 00:00:38.000
It should be a good time.

00:00:38.000 --> 00:00:41.000
Yeah, looking forward to it.

00:00:41.000 --> 00:00:42.000
Yeah, thanks for having me on.

00:00:42.000 --> 00:00:44.000
I've been listening to this podcast for years.

00:00:44.000 --> 00:00:46.000
Oh, wonderful.

00:00:46.000 --> 00:00:49.000
It's a little like open source.

00:00:49.000 --> 00:00:51.000
You get to help create it, you know?

00:00:51.000 --> 00:00:53.000
Exactly.

00:00:53.000 --> 00:00:55.000
All right, let's do quick introductions.

00:00:55.000 --> 00:00:59.000
I know, Samuel, you almost don't need introductions.

00:00:59.000 --> 00:01:00.000
Pydantic is so popular.

00:01:00.000 --> 00:01:03.000
However, I'm sure there's a couple people out there.

00:01:03.000 --> 00:01:10.000
You know, you have, before I let you introduce yourself and stuff just a tiny, just quickly.

00:01:10.000 --> 00:01:20.000
You have the honor, distinguished or maybe otherwise, of actually participating in the loudest Talk Python episode ever.

00:01:20.000 --> 00:01:24.000
Do you remember that forklift that was driving around behind us?

00:01:24.000 --> 00:01:26.000
It was dystopian, wasn't it?

00:01:26.000 --> 00:01:29.000
It was the end of PyCon two years ago.

00:01:29.000 --> 00:01:30.000
And we started doing the podcast.

00:01:30.000 --> 00:01:33.000
And then they started taking down the PyCon around us.

00:01:33.000 --> 00:01:34.000
And there's this forklift.

00:01:34.000 --> 00:01:39.000
It was, it felt like slight jeopardy, but it was, it was good.

00:01:39.000 --> 00:01:46.000
It certainly was a concentration test to have the forklift driving right behind us, beeping as loud as I could.

00:01:46.000 --> 00:01:47.000
That was amazing.

00:01:47.000 --> 00:01:48.000
All right.

00:01:48.000 --> 00:01:50.000
Tell people about yourself and Pydantic and stuff.

00:01:50.000 --> 00:01:51.000
Yeah.

00:01:51.000 --> 00:01:55.000
So, so I started Pydantic back in 2017 as a side project.

00:01:55.000 --> 00:02:03.000
It like toodled along and then 2021, it somehow something happened and the rate of downloads just started to increase a lot.

00:02:04.000 --> 00:02:14.000
And started working on it full time in 2022, decided to do this rebuild of the core in Rust because while I was really proud of how much people were using Pydantic, I wasn't particularly proud of its internals.

00:02:14.000 --> 00:02:25.000
I had done a bit of Rust, a bit of a couple of other projects that wrap Rust to produce Python packages, but nothing on the scale of Pydantic.

00:02:25.000 --> 00:02:32.000
And then eight months into this three month project, I was halfway through and Sequoia very kindly got in touch and offered to invest.

00:02:32.000 --> 00:02:34.000
And so I started a company around Pydantic.

00:02:34.000 --> 00:02:39.000
And so, yeah, we released Pydantic V2, the rewrite, middle of middle of last year.

00:02:39.000 --> 00:02:45.000
And yeah, adoption of Pydantic, as I'm pleased to say, continued to continue to grow.

00:02:45.000 --> 00:02:49.000
We had, I think, 307 million downloads in October.

00:02:50.000 --> 00:02:56.000
And now we're obviously building commercial stuff, Logfire in particular, but we also do a bit more Rust in Python.

00:02:56.000 --> 00:03:05.000
So we have Jitter, which is our very fast Rust based JSON parser, which is available both, is used in Pydantic and as a separate package.

00:03:05.000 --> 00:03:12.000
So yeah, that's a kind of summary of my interaction with Rust and Python over the last kind of five, six years.

00:03:12.000 --> 00:03:13.000
Amazing.

00:03:13.000 --> 00:03:14.000
Yeah.

00:03:14.000 --> 00:03:23.000
And it was that move, that pending move or partial move to Rust that actually was the basis of that forklift episode.

00:03:23.000 --> 00:03:26.000
David, hello.

00:03:26.000 --> 00:03:28.000
Hi.

00:03:28.000 --> 00:03:29.000
Yeah.

00:03:29.000 --> 00:03:31.000
So I am based in London, like Samuel.

00:03:32.000 --> 00:03:33.000
I'm working on a product called Kraken.

00:03:33.000 --> 00:03:38.000
That is not anything to do with cryptocurrency or gin.

00:03:38.000 --> 00:03:43.000
I think there's a gin or get clients.

00:03:43.000 --> 00:03:47.000
It's actually, it came out of a company called Octopus Energy.

00:03:48.000 --> 00:04:01.000
Octopus Energy is a renewable energy company and Kraken is basically a big Django monolith that we used at Octopus Energy.

00:04:01.000 --> 00:04:03.000
And it worked really well.

00:04:03.000 --> 00:04:09.000
And Octopus Energy over the, about the last eight years has grown to be the second biggest energy company in the UK.

00:04:10.000 --> 00:04:21.000
And so what we've been doing is using Kraken throughout the world on lots of different, in lots of different countries and lots of different energy companies.

00:04:21.000 --> 00:04:24.000
I think the interesting thing about it is it's absolutely massive.

00:04:24.000 --> 00:04:31.000
It's, I just counted it today, eight and a half million lines of code for one Django packet.

00:04:31.000 --> 00:04:33.000
That is nuts.

00:04:33.000 --> 00:04:37.000
I was going to have you elaborate because you said I work on a large Django monolith.

00:04:37.000 --> 00:04:38.000
Yeah.

00:04:38.000 --> 00:04:39.000
Like it's really large.

00:04:39.000 --> 00:04:40.000
That's, that's amazing.

00:04:40.000 --> 00:04:42.000
How's there ever been a bigger one?

00:04:42.000 --> 00:04:44.000
I don't know.

00:04:44.000 --> 00:04:46.000
I should probably ask on Hacker News or something.

00:04:46.000 --> 00:04:48.000
Yeah.

00:04:48.000 --> 00:04:49.000
Only GitHub knows.

00:04:49.000 --> 00:04:54.000
It's, it's big and it's also, there's quite a lot of people working on it at once.

00:04:54.000 --> 00:04:57.000
There's like, I just looked at last, last week.

00:04:57.000 --> 00:05:05.000
There were over 400 authors at the pull request in one week, all merging stuff together onto the same Python package.

00:05:06.000 --> 00:05:08.000
And you'd think it wouldn't work.

00:05:08.000 --> 00:05:15.000
I would have said it wouldn't work, but it turns out actually you can run an energy company on that basis.

00:05:15.000 --> 00:05:17.000
You know, you're a huge energy company.

00:05:17.000 --> 00:05:18.000
You must have a ton of repositories.

00:05:18.000 --> 00:05:19.000
Yeah, we got one.

00:05:19.000 --> 00:05:24.000
There are some others to be honest, but yeah, mostly, mostly it's one.

00:05:24.000 --> 00:05:31.000
Can I ask a question that's, is that continuously deployed or how is that managed in terms of deploys?

00:05:31.000 --> 00:05:40.000
So actually each energy company, there are nearly 30 energy companies, each energy company gets their own separate installation.

00:05:40.000 --> 00:05:49.000
And every time anyone merges, pretty much, we push it out to all of the energy companies.

00:05:50.000 --> 00:05:56.000
You know, it's on the basis that really, if we break something, then we can fix it quickly as well.

00:05:56.000 --> 00:06:04.000
And also in the domain of energy, how often do you actually log in to your energy account?

00:06:04.000 --> 00:06:08.000
You know, are you going to be on the phone saying, where's my bill?

00:06:09.000 --> 00:06:10.000
You know what I mean?

00:06:10.000 --> 00:06:18.000
So, you know, we can get away with that kind of thing, which maybe we couldn't do that if it was, I don't know, payments gateway or something like that.

00:06:18.000 --> 00:06:25.000
Or if you built a package that shipped over PyPI to hundreds of millions of people.

00:06:25.000 --> 00:06:27.000
Yeah.

00:06:27.000 --> 00:06:33.000
Well, we released Pydantic 2.10 yesterday and we've definitely got quite a few issues back.

00:06:34.000 --> 00:06:36.000
So we definitely break stuff too.

00:06:36.000 --> 00:06:38.000
Don't, for a second thing, we don't break anything.

00:06:38.000 --> 00:06:42.000
We don't mind the things that are unintentionally broken because we can go and fix them.

00:06:42.000 --> 00:06:43.000
It's when we change an API.

00:06:43.000 --> 00:06:52.000
That's the painful thing for us rather than actually, weirdly bugs are in some sense, like less severe than like getting the wrong API.

00:06:53.000 --> 00:07:00.000
Yeah, that's got to be really tricky to say, you know, we need to add, we need to add a parameter to this function.

00:07:00.000 --> 00:07:06.000
Or the whole two, one to two switch, you deprecated quite a few methods and stuff as well.

00:07:06.000 --> 00:07:08.000
Right.

00:07:08.000 --> 00:07:14.000
And in some sense, deprecated methods added parameters are relatively easy because someone's, you know, is relatively clear to see what's happened.

00:07:14.000 --> 00:07:25.000
It's when it's like subtle changes in behavior, like, do you apply an, like, integer constraint before or after a function that wraps the integer validation?

00:07:25.000 --> 00:07:30.000
Like things like that, if you decide to change it because you're like, well, this is marginally more correct.

00:07:30.000 --> 00:07:35.000
Is it worth making marginally more correct for a lot of people spending a lot of time very, very confused?

00:07:36.000 --> 00:07:42.000
Yeah, that can definitely generate some open issues on the issue tracker.

00:07:42.000 --> 00:07:45.000
Also, the parsing.

00:07:45.000 --> 00:07:48.000
I think you all changed the rules about the parsing, right?

00:07:48.000 --> 00:07:57.000
One of the pieces of magic of Pydantic is if you had a list and you said it was a list of integers, but it happened to be strings that could be converted to integers that would just become a list of integers.

00:07:57.000 --> 00:08:03.000
But I feel like you, you change the strictness or looseness of that behavior at one point, right?

00:08:04.000 --> 00:08:06.000
Yeah, we made it a little bit more strict in places.

00:08:06.000 --> 00:08:18.000
We said things like, you can't coerce an integer to a string because basically, like the original semantics of Pydantic was like, we'll just call integer on the thing and see if it's an int.

00:08:18.000 --> 00:08:20.000
And that mostly worked.

00:08:20.000 --> 00:08:22.000
We'll call list on something and see if it's a list.

00:08:22.000 --> 00:08:28.000
Problem is with string, you can call string on everything and then you'll get back a string, right?

00:08:28.000 --> 00:08:31.000
So it's no longer a valid test of is it a string to call string on it.

00:08:32.000 --> 00:08:33.000
Right.

00:08:33.000 --> 00:08:34.000
What time did this happen?

00:08:34.000 --> 00:08:37.000
It happened at angle bracket class date time dot date time dot.

00:08:37.000 --> 00:08:38.000
Yeah, right.

00:08:38.000 --> 00:08:39.000
Exactly.

00:08:39.000 --> 00:08:45.000
So yeah, we, and that's another thing because no one writes their unit tests for the weird edge cases of what's valid.

00:08:45.000 --> 00:08:52.000
But then if you're a bank and one bank is sending you strings for a number or numbers for a string and you change it, like we change how it works.

00:08:52.000 --> 00:08:53.000
That is that's problematic.

00:08:53.000 --> 00:08:56.000
But luckily the banks don't pay us anything in sponsorship.

00:08:56.000 --> 00:08:59.000
So I don't mind breaking it for banks as a rule.

00:08:59.000 --> 00:09:06.000
Well, you see these, these are the bootstrapped struggling small businesses.

00:09:06.000 --> 00:09:07.000
They're not ready.

00:09:07.000 --> 00:09:10.000
These banks to have enough money to, you know, support open source.

00:09:11.000 --> 00:09:13.000
We're just trying to persuade them to use log fire right now.

00:09:13.000 --> 00:09:14.000
So I'll stop being rude about banks.

00:09:14.000 --> 00:09:16.000
Yes, no, of course.

00:09:16.000 --> 00:09:20.000
It's a, well, it's a really tricky balance, right?

00:09:20.000 --> 00:09:25.000
To can, to can get those folks to open their checkbooks and pay for it.

00:09:25.000 --> 00:09:26.000
Right.

00:09:26.000 --> 00:09:33.000
They, they don't have charity usually in their bylines, bylines, whatever, or they're supposed to be doing, right?

00:09:33.000 --> 00:09:39.000
Like they, but with something like log fire, they can say, well, here's a service that we can use.

00:09:39.000 --> 00:09:45.000
And by using that, we might be able to support Pydantic and the other things that are important to us.

00:09:45.000 --> 00:09:47.000
So I think that's, that's great.

00:09:47.000 --> 00:09:50.000
You know, tell people just real quickly about log fire out there.

00:09:50.000 --> 00:09:51.000
Yeah, absolutely.

00:09:51.000 --> 00:09:57.000
So log fire is an observability platform built obviously by the team behind Pydantic.

00:09:57.000 --> 00:10:06.000
If you go to log fire along the, along the top, the, the, I suppose the two things that make it different from some of the stuff that's come before is log files built on open telemetry.

00:10:06.000 --> 00:10:14.000
So on open standards that mean that, yeah, the rails of that, where the data is being transferred are on an open standard.

00:10:14.000 --> 00:10:21.000
And if, if you decide you didn't want to use the log file platform anymore, you can send that data to anything else that supports open telemetry.

00:10:21.000 --> 00:10:31.000
But unlike lots of other companies in our space, instead of using open telemetry as an excuse to abandon the SDK space and just say, use the horrible local telemetry SDK directly.

00:10:31.000 --> 00:10:35.000
We have the log file package, which tries to make that super nice and easy to use.

00:10:35.000 --> 00:10:47.000
And then the other big change we have, I don't, I think there'll be an example, maybe further on down the page, but like we, maybe, maybe there isn't one right there, but like we allow you to write SQL directly against your data.

00:10:47.000 --> 00:10:48.000
So.

00:10:48.000 --> 00:10:49.000
Oh, interesting.

00:10:49.000 --> 00:10:50.000
Okay.

00:10:50.000 --> 00:10:52.000
Use kind of click ops to go around and do survey.

00:10:52.000 --> 00:10:56.000
So if you look here, right, you're, you can go and like write SQL to query your data.

00:10:56.000 --> 00:11:07.000
And so there are, although we're still early, there are things you can do in log file that you can't, you cannot, and then they've been able to do in like one of the big incumbents like data doc, because it's just SQL.

00:11:07.000 --> 00:11:11.000
And it's obviously much easier to learn for you, much easier for LLMs to write.

00:11:11.000 --> 00:11:18.000
So we have the like plausible chance in the future that you could basically chat with log fire and say, what's wrong with my app?

00:11:18.000 --> 00:11:26.000
And the agent can go off and run SQL to investigate things in a way that is much harder if you have your own dialect, but yeah, right.

00:11:26.000 --> 00:11:31.000
SQL against data of the scale is a monumentally difficult challenge.

00:11:31.000 --> 00:11:37.000
And one of the things we struggle with a lot, but we think it's useful enough for developers that we like put the time in.

00:11:37.000 --> 00:11:42.000
So you can write any SQL you want, except for please only do the ones that have indexes.

00:11:42.000 --> 00:11:46.000
So it's so our new databases time is data fusion.

00:11:46.000 --> 00:11:52.000
So there were no indexes, but yeah, if you do, there are queries you can do now that just like eat memory.

00:11:52.000 --> 00:11:55.000
And we, we have to find ways around them.

00:11:55.000 --> 00:12:05.000
And that's actually the hardest bit is like, whether intentionally or not, there are people, you know, there are SQL you can write, which is enormously like heavy to go and compute.

00:12:05.000 --> 00:12:11.000
And so we have to be able to find ways to like process that without taking down other customers.

00:12:11.000 --> 00:12:12.000
I suppose is the point.

00:12:12.000 --> 00:12:14.000
You don't want to do a denial of service on yourself.

00:12:14.000 --> 00:12:15.000
Right.

00:12:15.000 --> 00:12:22.000
I mean, the definition of DOS is that like the effort required to DOS is exponentially lower than the effort required to process it.

00:12:22.000 --> 00:12:23.000
Right.

00:12:23.000 --> 00:12:25.000
And writing SQL is the ultimate example of that.

00:12:25.000 --> 00:12:27.000
Yeah, it absolutely is.

00:12:27.000 --> 00:12:28.000
Okay.

00:12:28.000 --> 00:12:39.000
Well, that's a really interesting idea to have SQL there rather than like, let's just kick click around our UI until we get an answer and those sorts of things.

00:12:39.000 --> 00:12:40.000
Yeah.

00:12:40.000 --> 00:12:49.000
So I think one of the things that we've got some dashboards on that page, but the idea is like, sure, we'll go and give you a nice dashboard for HTTP traffic and like response codes.

00:12:49.000 --> 00:12:57.000
So, I think it's the next one down, but if you want to go and edit that, like the point is that you can basically, next one after that.

00:12:57.000 --> 00:13:03.000
It's the point is you can go and customize that however you like by just editing the SQL if you so wish.

00:13:03.000 --> 00:13:05.000
So it's like, it's trying to save with alerts.

00:13:05.000 --> 00:13:11.000
So we have, I guess you would say century style alerting, but again, that's all configurable because in the end, it's just SQL that you can go and edit.

00:13:11.000 --> 00:13:12.000
Yeah.

00:13:12.000 --> 00:13:13.000
Awesome.

00:13:13.000 --> 00:13:14.000
Well, congratulations.

00:13:14.000 --> 00:13:24.000
I, I know many people were curious about when they heard that, Hey, Pydantic starting a company, they have funding.

00:13:24.000 --> 00:13:27.000
It's like, what are they going to exactly going to do with that?

00:13:27.000 --> 00:13:33.000
And, you know, maybe a lot of people were worried just like, Hey, it now costs money to just use the library.

00:13:33.000 --> 00:13:34.000
Right.

00:13:35.000 --> 00:13:49.000
And, and I don't think anyone ever thought it would have been a good idea to literally have like Pydantic pro where you have to like have some API key to install Pydantic, but it could definitely have been what most open source, open source companies do is they have like open source project as a service.

00:13:49.000 --> 00:13:54.000
And then they start, if not taking out features, then adding new features to the paid version.

00:13:54.000 --> 00:13:55.000
Right.

00:13:55.000 --> 00:13:59.000
And I was super keen that Pydantic continued to be successful as an open source project.

00:13:59.000 --> 00:14:07.000
And so we did the slightly weird thing about building something which is in a different space from, from what we're known for.

00:14:07.000 --> 00:14:11.000
And that definitely has its challenges, but I think it's overall, I think it's the right decision.

00:14:11.000 --> 00:14:12.000
Yeah.

00:14:12.000 --> 00:14:13.000
Awesome.

00:14:13.000 --> 00:14:14.000
Well, congratulations.

00:14:14.000 --> 00:14:17.000
Beautiful looking project, service here and so on.

00:14:17.000 --> 00:14:23.000
And I think maybe one of the big pieces of news here, and that's not the one, although that is awesome.

00:14:23.000 --> 00:14:24.000
Is that's where we're going?

00:14:24.000 --> 00:14:26.000
is this, this jitter?

00:14:26.000 --> 00:14:27.000
What is this jitter?

00:14:27.000 --> 00:14:30.000
David, are you familiar with this jitter?

00:14:30.000 --> 00:14:32.000
I have, I've heard of it.

00:14:32.000 --> 00:14:33.000
Okay.

00:14:33.000 --> 00:14:34.000
Yeah.

00:14:34.000 --> 00:14:36.000
So parsing JSON is super important.

00:14:36.000 --> 00:14:37.000
Yeah.

00:14:37.000 --> 00:14:38.000
Tell us about this.

00:14:38.000 --> 00:14:39.000
JSON is, is a, is a big thing.

00:14:39.000 --> 00:14:46.000
And when we, when I first got Pydantic version two with, with the rust core, we were using

00:14:46.000 --> 00:14:49.000
Surdy, which is the kind of default, parsing library in rust.

00:14:49.000 --> 00:14:57.000
The problem is that Surdy wants to parse, the entire JSON object before it returns you

00:14:57.000 --> 00:14:59.000
some representation of that.

00:14:59.000 --> 00:15:05.000
And jitter came out of this idea that we could do, parsing as we do validation.

00:15:05.000 --> 00:15:09.000
So if you have it, imagine you have a list of integers, you, instead of what you would

00:15:09.000 --> 00:15:13.000
traditionally do is you would parse the JSON, you would allocate some vector of all of the

00:15:13.000 --> 00:15:14.000
values in that list.

00:15:14.000 --> 00:15:17.000
Each of which would have to be itself a like, you know, I'm up here are the different types

00:15:17.000 --> 00:15:18.000
you might get in JSON.

00:15:18.000 --> 00:15:20.000
Cause you don't know what it's going to be upfront.

00:15:20.000 --> 00:15:24.000
And then once you finished doing that, you can then go and do validation on that.

00:15:24.000 --> 00:15:28.000
and jitter, the idea is it's an iterative JSON parser that hence the name.

00:15:28.000 --> 00:15:32.000
So you could, you can effectively get, if you think of it in Python parlance as like,

00:15:32.000 --> 00:15:41.000
it's a rule that gives you back each individual element of the, of the JSON as you go along.

00:15:41.000 --> 00:15:47.000
at the truth is right now inside Pydantic core, we're still using the, this JSON value,

00:15:47.000 --> 00:15:50.000
which is Jitter's variant of doing the whole parsing first.

00:15:50.000 --> 00:15:53.000
There are a few optimizations that we get to get away with.

00:15:53.000 --> 00:15:56.000
So there are some really neat things in JSON.

00:15:56.000 --> 00:16:03.000
Like if your strings, for example, John Doe, you're showing on the screen there is, does not include any escape sequences

00:16:03.000 --> 00:16:12.000
like backslash, N or unicode sequences, then you can pass, pass a pointer to that, range of the underlying

00:16:12.000 --> 00:16:15.000
JSON object as a string, instead of having to allocate that string.

00:16:15.000 --> 00:16:18.000
So we do some like clever optimizations like that.

00:16:18.000 --> 00:16:27.000
I see the plan in a future version of Pydantic either as a like opt-in feature in V2 or as V3 is to be able to do the iterative parsing.

00:16:27.000 --> 00:16:36.000
What's crazy about Jitter is, well, one, once we started work on this, we've actually got to the point where Jitter is full on faster than Serti in any use case,

00:16:36.000 --> 00:16:47.000
even if you're not doing the iterative thing, but also this iterative JSON parsing thing is exactly what you want when you want to allow people to query JSON in, in a way like, JSONB in Postgres.

00:16:47.000 --> 00:16:56.000
And so we went and use Jitter to implement, JSON querying inside data fusion when we moved our database to data fusion.

00:16:56.000 --> 00:16:57.000
And it was just like very luckily.

00:16:57.000 --> 00:17:08.000
yeah, it happens to be exactly the right concept you need for like, for querying JSON where you want to iterate over looking for the like string foo and then stop as soon as you find it.

00:17:08.000 --> 00:17:09.000
Awesome.

00:17:09.000 --> 00:17:15.000
So the code samples you got on the repo here, got a lot of semicolons in them.

00:17:15.000 --> 00:17:20.000
Is there a, is it, is it interoperable with Python as well?

00:17:20.000 --> 00:17:21.000
Or is it just a rust?

00:17:21.000 --> 00:17:22.000
Yes.

00:17:22.000 --> 00:17:25.000
So if you, if you go up actually, it's a, it's a, this is a monorepo.

00:17:25.000 --> 00:17:39.000
So if you go up into source into crates, which is, so this is, you have a bunch of different crates in here, but if you look at Jitter Python, this is the, and I think if you go down, you'll see an example of calling Jitter directly from Python.

00:17:39.000 --> 00:17:54.000
So the reason we released this as a Python package was a large AI company who I don't know if they wanted me to name them, basically were using Pydantic V1 so heavily, but they needed some of the functionality of Jitter.

00:17:54.000 --> 00:18:03.000
and so they basically begged us to release this as a separate package so that they could, they could use Jitter themselves before they upgraded to Pydantic V2.

00:18:03.000 --> 00:18:06.000
In fact, the open AI SDK uses Jitter.

00:18:06.000 --> 00:18:08.000
So I think that is public information who it might have been.

00:18:08.000 --> 00:18:14.000
but yeah, the other interesting thing that came out, which again, I'm ashamed to say I had no idea would be useful.

00:18:14.000 --> 00:18:29.000
This idea of iteratively, iteratively passing JSON until you stop effectively turns out to be incredibly helpful in LLMs where, as you see on, on screen here, you can basically pass an incomplete JSON string.

00:18:29.000 --> 00:18:39.000
And obviously because, LLMs stream you the response, you can use this to effectively do validation as you receive structured responses.

00:18:39.000 --> 00:18:40.000
Right.

00:18:40.000 --> 00:18:44.000
Work on a JSON stream instead of a JSON response.

00:18:44.000 --> 00:18:45.000
Yeah.

00:18:46.000 --> 00:18:51.000
So, I've been surprised by how like the legs that this has had, which I wasn't expecting when we, when we first started it.

00:18:51.000 --> 00:19:04.000
But yeah, the nice bit is it's all the input, the actual JSON parsing is rust, but then we, we have the logic to, yeah, basically access that from Python, both in this package and in Pydantic core.

00:19:04.000 --> 00:19:05.000
Awesome.

00:19:05.000 --> 00:19:11.000
Well, you sent me over to this cargo section or the crate section rather.

00:19:11.000 --> 00:19:18.000
And looking here, I see the cargo dot Toml, PI project dot Toml, some source.

00:19:18.000 --> 00:19:21.000
I think this might be in the source.

00:19:21.000 --> 00:19:22.000
We've got some rust.

00:19:22.000 --> 00:19:35.000
I think that this might be David, a good, good way to start leading into working with Russ and, you know, this is kind of the destination of your whole presentation.

00:19:35.000 --> 00:19:36.000
You gave it pike on Italy, right?

00:19:36.000 --> 00:19:37.000
Absolutely.

00:19:37.000 --> 00:19:38.000
Yeah.

00:19:38.000 --> 00:19:52.000
So, well, we thought it's alluded to it already, but yeah, Python and rust can interoperate, which is an amazing fact.

00:19:52.000 --> 00:20:01.000
I think it's so easy to think, oh, well, within a particular application, you know, you're stuck with the programming language that you've picked.

00:20:01.000 --> 00:20:08.000
but actually Python was really designed originally from what I understand to be a kind of glue language.

00:20:08.000 --> 00:20:13.000
So, you know, you're not going to use the same thing as a kind of glue language.

00:20:13.000 --> 00:20:16.000
So, you know, you're not going to use the same thing as a kind of glue language.

00:20:16.000 --> 00:20:18.000
So, you know, you're not going to use the same thing as a kind of glue language.

00:20:18.000 --> 00:20:20.000
You're not going to use the same thing as a kind of glue language.

00:20:20.000 --> 00:20:22.000
So, you're not going to use the same thing as a kind of glue language.

00:20:30.000 --> 00:20:39.000
Or even maybe less obvious ones like SQLAlchemy and other places, there's optional speedups, speedup C extension type things, right?

00:20:39.000 --> 00:20:40.000
Yeah, absolutely.

00:20:40.000 --> 00:20:42.000
And in the standard library, of course.

00:20:42.000 --> 00:20:48.000
but you're not writing C or you're not writing, I think NumPy might even have Fortran.

00:20:48.000 --> 00:20:52.000
you're, you're writing Rust.

00:20:52.000 --> 00:21:01.000
but you're, you're, you're ending up with something that's, that's the same as you might have done with a different lower level language.

00:21:01.000 --> 00:21:15.000
and that allows you to use Python for all of the nice stuff like domain modeling and, and, you know, just that thing that we're all familiar with.

00:21:15.000 --> 00:21:24.000
And the reason we like Python is we can be very productive with it, but just occasionally you, you hit something with Python, whereas it's basically slow.

00:21:24.000 --> 00:21:30.000
it's, it's, there's a high level language there and those abstractions are coming at a cost.

00:21:30.000 --> 00:21:32.000
You know, we talk about the GIL as well.

00:21:32.000 --> 00:21:40.000
You know, the GIL gets in the way of using all of the CPUs on our machine, but that's not the case for extension modules.

00:21:40.000 --> 00:21:43.000
They can leave the GIL behind if you want.

00:21:43.000 --> 00:21:52.000
So you can actually, by writing these extension modules, get more out of Python than you might have thought.

00:21:52.000 --> 00:22:01.000
and Rust is a pretty new language that's learned a lot of lessons from older languages.

00:22:01.000 --> 00:22:07.000
And, it's, I mean, I think it's really lovely.

00:22:07.000 --> 00:22:11.000
it, it, you feel like you're in the presence of greatness.

00:22:11.000 --> 00:22:13.000
Almost.

00:22:13.000 --> 00:22:22.000
Well, I wanted to ask you, I wanted to ask both of you this question before we get too far down this path is Python often is referred to as CPython.

00:22:22.000 --> 00:22:27.000
Cause the runtime, the core is all built in C not Python.

00:22:27.000 --> 00:22:28.000
Right.

00:22:29.000 --> 00:22:35.000
And the original interop story is around C extensions and CFFI and those kinds of things.

00:22:35.000 --> 00:22:47.000
And so why not just, why not just pick C for Pydantic or for your linter, David, you know, it's everyone else is doing it.

00:22:47.000 --> 00:22:48.000
It had been doing it.

00:22:48.000 --> 00:22:49.000
Good question.

00:22:49.000 --> 00:22:57.000
I mean, maybe sometimes it would be the right answer, but rough is, rust is offering something very different.

00:22:57.000 --> 00:23:02.000
It's offering like a really nice, developer ecosystem.

00:23:02.000 --> 00:23:05.000
all the tooling is brilliant.

00:23:05.000 --> 00:23:11.000
and also I think security is a big, a big thing.

00:23:11.000 --> 00:23:16.000
so many security problems come from like mismanagement of pointers.

00:23:16.000 --> 00:23:26.000
rust is designed so that the compiler won't let you make a certain kind of mistake that happens all the time.

00:23:26.000 --> 00:23:30.000
It happens all over the place in, the NCS.

00:23:30.000 --> 00:23:31.000
Yeah.

00:23:32.000 --> 00:23:33.000
I put it more simply than that.

00:23:33.000 --> 00:23:35.000
I'm not clever enough to write C safely.

00:23:35.000 --> 00:23:39.000
and so I get that pointer pointer.

00:23:39.000 --> 00:23:40.000
What are we doing here?

00:23:40.000 --> 00:23:51.000
So I mean, like the good one way of good way of looking at it is that you, you can have the unsafe, mode in rust where you effectively lose those constraints.

00:23:51.000 --> 00:23:54.000
And sometimes there are the occasional place where you need to use it.

00:23:54.000 --> 00:24:09.000
And then when we do that inside Pydantic core, myself or David Hewitt, who's a much better rust developer than I am, we agonize for genuinely minutes at a time over how exact, whether or not it is really safe to write that one line of code is unsafe.

00:24:09.000 --> 00:24:13.000
And whether there was any possible case in which it could lead to problems.

00:24:13.000 --> 00:24:17.000
If you write an app in C, every single line is unsafe.

00:24:17.000 --> 00:24:24.000
And if you write a, if you're agonizing even over just a string, like a S print F equivalent.

00:24:24.000 --> 00:24:25.000
Yeah.

00:24:25.000 --> 00:24:25.000
Yeah.

00:24:25.000 --> 00:24:26.000
You don't.

00:24:26.000 --> 00:24:32.000
And it doesn't have to be eight and a half million lines of code for it to be incredibly hard to go through every single line of that.

00:24:32.000 --> 00:24:35.000
So I forget there's like 40,000 lines of code in Pydantic core.

00:24:35.000 --> 00:24:45.000
It is inconceivable that we could have written that in C and have anywhere near the confidence we have with it written in rust that it was memory safe.

00:24:45.000 --> 00:24:49.000
We have had one memory safety issue reported in Pydantic core.

00:24:49.000 --> 00:25:04.000
And it is, it was a side effect of something deep in Pyo three, which in turn was the, was, was a result of like, greenlit doing something crazy that technically the guild didn't think you could do.

00:25:04.000 --> 00:25:07.000
I mean, that was the, that's the level of complexity we have.

00:25:07.000 --> 00:25:12.000
Another example is so Jitter, which I showed you, we, we released Jitter a year ago.

00:25:12.000 --> 00:25:17.000
Now it is the most downloaded JSON parser in Python other than the one in the standard library.

00:25:17.000 --> 00:25:24.000
No one has ever reported a bug in it in terms of it parsing stuff incorrectly, except for impartial mode.

00:25:24.000 --> 00:25:30.000
I think, now I said that someone will probably go and find one, but like it has been, that just wouldn't happen in Python.

00:25:30.000 --> 00:25:32.000
You could not write that reliable.

00:25:32.000 --> 00:25:35.000
yeah.

00:25:35.000 --> 00:25:41.000
So that's one of the ways it, one of the ways it achieves this is by like really stopping you doing all the stuff that you would have.

00:25:41.000 --> 00:25:43.000
expect to be able to do.

00:25:43.000 --> 00:25:58.000
I always, whenever I sort of tell someone about rust, I say, you know, if you have a string in rust and you assign it to a variable, say X, and then like, and then you like store that X in Y.

00:25:58.000 --> 00:26:00.000
So you do Y equals X.

00:26:00.000 --> 00:26:02.000
Then you can't use X anymore.

00:26:02.000 --> 00:26:04.000
Because it's gone.

00:26:04.000 --> 00:26:09.000
and I mean, that's, that seems very strange.

00:26:09.000 --> 00:26:17.000
you know, and it seems strange maybe as Python developers, because we don't actually hardly ever, maybe never need to think about memory safety.

00:26:17.000 --> 00:26:25.000
you know, we've got that luxury, but once you go down lower level, you are starting to, and, and what's going on there with the kind of.

00:26:25.000 --> 00:26:28.000
You can't have X and Y both pointing to that string.

00:26:28.000 --> 00:26:44.000
I mean, you can, if you copy that memory so that there's then separate bits of memory in X and Y, but it's kind of making you think in detail about where is the memory for this program?

00:26:44.000 --> 00:26:48.000
Whereas Python just ownership, right?

00:26:48.000 --> 00:26:50.000
The ownership of who owns this.

00:26:50.000 --> 00:26:53.000
I can give you another good practical example.

00:26:53.000 --> 00:27:12.000
So I was saying earlier in the, in the jitter case, we have this point where some strings, you can, many strings, you can, instead of having to copy the whole of the string out of the chunk of, data within the original input of Jason, you can literally refer to that slice of data as a, with, as a pointer.

00:27:12.000 --> 00:27:15.000
Literally say, this is, this is the string itself.

00:27:15.000 --> 00:27:16.000
And you'd have to copy.

00:27:16.000 --> 00:27:24.000
But that means the type you get back for when you parse a string in jitter is what is called a cow in, in, in rust.

00:27:24.000 --> 00:27:30.000
And it is either an owned string, e.g. when you've copied it, or it's a reference to the underlying chunk of the array.

00:27:30.000 --> 00:27:42.000
And so that gets quite difficult when you're actually writing code with that because you can't go and access that string after you validated after you've passed the next token, because in theory that could have now changed.

00:27:42.000 --> 00:27:49.000
If you were writing that and see, you'd have to basically manually keep track of, am I accessing that cow in the right place?

00:27:49.000 --> 00:27:54.000
Whereas in rust, where you wouldn't have a cow in, in C, but you could presumably have some similar construct.

00:27:54.000 --> 00:27:56.000
Rust basically takes care of that.

00:27:56.000 --> 00:28:08.000
As soon as you go and do another piece of validation, it immediately says, no, no, you can't even access that previous cow because the lifetime of it has now been used when you've called, into the parser to get the next token.

00:28:08.000 --> 00:28:13.000
And so it, it's a very neat, it basically stops you from having to think about that.

00:28:13.000 --> 00:28:23.000
And that means you can actually do, not more unsafe, but more complex things knowing that the time, the, the borrower checker is gonna save you in the end.

00:28:23.000 --> 00:28:24.000
You can try and do something.

00:28:24.000 --> 00:28:26.000
And if it doesn't work, the borrower checker will say it's not possible.

00:28:26.000 --> 00:28:33.000
And if the borrower checker says it is possible, you're safe to access that reference to a string that you passed like 50 lines of code higher up.

00:28:33.000 --> 00:28:34.000
Yeah.

00:28:35.000 --> 00:28:38.000
That sounds, it sounds like a paradigm shift, but also super valuable.

00:28:38.000 --> 00:28:43.000
So I know primarily Python people are listening.

00:28:43.000 --> 00:28:49.000
So this word might not make any sense, but is this a compile time check or is this a runtime check?

00:28:49.000 --> 00:28:52.000
We don't really think about compiling much in Python, but.

00:28:52.000 --> 00:28:53.000
Right.

00:28:53.000 --> 00:29:01.000
We don't think about it, but you can, you sort of, we have, you can think of import time when you do different stuff or you think about static typing when you go and run pyright over your code.

00:29:01.000 --> 00:29:02.000
Yeah.

00:29:02.000 --> 00:29:05.000
And that is like very similar in, in some ways to compile time.

00:29:05.000 --> 00:29:07.000
it's also one of the big disadvantages of rust.

00:29:07.000 --> 00:29:09.000
I mean, people think rust is faster than Python.

00:29:09.000 --> 00:29:20.000
In many cases, if you write your script, it's a lot faster to run it in Python than it is in rust because it'll take two seconds to run in rust or in Python or a few hundred milliseconds to run in Python and 10 seconds to compile in rust.

00:29:20.000 --> 00:29:28.000
So yeah, it is not universally the case that getting the late, like yeah, the development cycle is faster than rust.

00:29:28.000 --> 00:29:30.000
It depends how many times you run the code, right?

00:29:30.000 --> 00:29:32.000
If you're going to run it once or twice.

00:29:32.000 --> 00:29:33.000
Yeah.

00:29:33.000 --> 00:29:34.000
And you've got to create it to run it.

00:29:34.000 --> 00:29:37.000
Well, you know, it maybe it took you 10 minutes versus 20 minutes.

00:29:37.000 --> 00:29:54.000
And it's another of the great powers of, of the Python ecosystem and of pipe AI that we, the maintainers of, of, Python packages built in rust can take care of compiling that rust once distribute all of the binaries.

00:29:54.000 --> 00:29:57.000
And then when people go and install it, we don't have to compile it.

00:29:57.000 --> 00:30:01.000
If you were using most other, if you were using cargo, you would have to take care.

00:30:01.000 --> 00:30:11.000
I mean, putting the controversy over 30 to one side for a minute, you would have to take care of compiling that code yourself every time you wanted to go and go and use it.

00:30:11.000 --> 00:30:20.000
Whereas actually pipe AI does an amazing job of distributing compiled rust for virtually every ecosystem, every architecture, and it just working when you install it.

00:30:20.000 --> 00:30:21.000
Yeah, absolutely.

00:30:21.000 --> 00:30:25.000
Something I just wanted to say about the memory management.

00:30:25.000 --> 00:30:33.000
Like it is a compile time, but actually it also, you can also use reference counting and things like that.

00:30:33.000 --> 00:30:35.000
it's just opt in.

00:30:35.000 --> 00:30:44.000
So there are lots of interesting tools, for allowing you to do, runtime checking of things.

00:30:44.000 --> 00:30:45.000
And sometimes that's what you have to do.

00:30:45.000 --> 00:30:50.000
You're like, Oh, I can't really do this just using stuff that's working on your own.

00:30:50.000 --> 00:30:52.000
stuff that's worked out before the program even runs.

00:30:52.000 --> 00:30:54.000
I do need to do it at runtime, but it's fine.

00:30:54.000 --> 00:30:57.000
I can do that for this particular data type.

00:30:57.000 --> 00:31:01.000
And, and there's an API to do it and it will come with other trade-offs.

00:31:01.000 --> 00:31:11.000
but you know, it's, it's giving you that control, but it's giving you control over things, which if you've only ever programmed in Python, which to be honest, pretty much.

00:31:11.000 --> 00:31:18.000
I mean, I used to do PHP a bit, but you know, I'm, my mind is soaked up in Python and coming to rust.

00:31:18.000 --> 00:31:23.000
It's like, Oh, this is, this is a completely different way of thinking.

00:31:23.000 --> 00:31:25.000
It's like the red pill and the matrix.

00:31:25.000 --> 00:31:26.000
You're like, what is this?

00:31:26.000 --> 00:31:27.000
Yeah.

00:31:27.000 --> 00:31:28.000
It's nice though.

00:31:28.000 --> 00:31:29.000
It's hard though.

00:31:29.000 --> 00:31:30.000
I'm not going to lie.

00:31:30.000 --> 00:31:31.000
Like I feel very confused a lot of the time.

00:31:31.000 --> 00:31:35.000
I suppose this is the time for the obligatory.

00:31:35.000 --> 00:31:46.000
The white house recommends the future software should be written in memory stuff languages such as rust and Python.

00:31:46.000 --> 00:31:47.000
So, right.

00:31:47.000 --> 00:31:57.000
That's always nice to have around to think about whether or not that's an argument in favor of rust or not, depending on your take on a particular white house is another question altogether, but it's definitely a thing.

00:31:57.000 --> 00:31:58.000
Well, you know what?

00:31:58.000 --> 00:32:01.000
I, I will draw your attention to the date of this.

00:32:01.000 --> 00:32:02.000
It's gotten more.

00:32:02.000 --> 00:32:07.000
New leadership recommends.

00:32:07.000 --> 00:32:08.000
Yeah.

00:32:08.000 --> 00:32:09.000
Next year.

00:32:09.000 --> 00:32:13.000
We'll see if they're like, assembly all the way.

00:32:13.000 --> 00:32:14.000
We've decided.

00:32:14.000 --> 00:32:15.000
No.

00:32:15.000 --> 00:32:16.000
Okay.

00:32:16.000 --> 00:32:17.000
All right.

00:32:17.000 --> 00:32:20.000
Let's, let's carry on with your, your story, David.

00:32:20.000 --> 00:32:28.000
So you, you wrote this thing called an import linter, which is kind of a unique, there's lots of linters in Python, right?

00:32:28.000 --> 00:32:35.000
There's, PyFlake, there's rough, another rust, success story, I suppose.

00:32:35.000 --> 00:32:39.000
But this one checks more architecturally, right?

00:32:39.000 --> 00:32:43.000
And you want to use this on your, your small little repo that you all are running over there.

00:32:43.000 --> 00:32:45.000
Tell us about that story.

00:32:45.000 --> 00:32:46.000
Yeah.

00:32:46.000 --> 00:32:59.000
I mean, I wrote it, I wrote it for Kraken, but actually I had the idea for it in a previous, company on, you know, it was still a complex monolith, but nowhere near as big.

00:32:59.000 --> 00:33:12.000
And to be honest, I find even in quotes, quite small projects with just a handful of files, it's still useful, to think about the architecture of those files.

00:33:12.000 --> 00:33:37.000
And I think for me, architecture is ultimately about dependencies and, something that Python lets you do, which I don't think is very good is that you can end up with lots of, cross dependencies between different modules and packages within a particular Python project.

00:33:37.000 --> 00:33:45.000
so for example, you know, I mean, we know that sometimes you get a circular import errors, but this is something a bit wider than that.

00:33:45.000 --> 00:33:57.000
Like possibly if you've got two sibling sub packages, you might have one module, which imports from something in one, in the other sibling package.

00:33:57.000 --> 00:34:01.000
And then there'd be like another modules that import the other way.

00:34:01.000 --> 00:34:10.000
the other way and it, it won't stop Python from loading up, but there's a, there's a sort of, there's a circular dependency conceptually between those two packages.

00:34:10.000 --> 00:34:11.000
They're tightly coupled.

00:34:11.000 --> 00:34:12.000
Yeah.

00:34:12.000 --> 00:34:27.000
And, and yeah, this is just one example of the kind of architectural rule you might want to impose on a project to say, well, actually I want there to be a dependency only one way.

00:34:27.000 --> 00:34:32.000
I want one of those packages to be kind of lower level and one of them to be higher level.

00:34:32.000 --> 00:34:47.000
or maybe you'd have like five packages that are all siblings and, you know, I call this layer really, but where you maybe, you know, say, yeah, this can import all the ones below it, but nothing can import the ones above it.

00:34:47.000 --> 00:34:51.000
And you sort of think of them in a sort of stack of.

00:34:51.000 --> 00:34:52.000
Yeah.

00:34:52.000 --> 00:34:56.000
and so here's the details, here's the public interface and then things use the public interface.

00:34:56.000 --> 00:34:59.000
They shouldn't reach down below and, and vice versa.

00:34:59.000 --> 00:35:00.000
Yeah.

00:35:00.000 --> 00:35:03.000
That's certainly one thing that you can do with it.

00:35:03.000 --> 00:35:12.000
but it's, it's mostly focused on controlling dependencies between packages as a whole.

00:35:12.000 --> 00:35:23.000
you can also do it for individual modules, but, like, so what it does is it uses imports at the proxy for a dependency.

00:35:23.000 --> 00:35:29.000
so it will statically analyze all of the imports in your module.

00:35:29.000 --> 00:35:33.000
and then it will build a directed graph.

00:35:33.000 --> 00:35:45.000
so you can then think of your module, think of your package as like every module is a node and a graph with, arrows pointing between all of them.

00:35:45.000 --> 00:35:46.000
And the arrows are the imports.

00:35:46.000 --> 00:35:50.000
sometimes you call them edges or whatever.

00:35:50.000 --> 00:36:02.000
and, and then what important inter allows you to do is to write contracts that are just in YAML or Tomo, which just say, all right, these, these are the rules.

00:36:02.000 --> 00:36:04.000
I want you to check.

00:36:04.000 --> 00:36:12.000
when you run the linter and it will then, you know, you can put it in CI or fail.

00:36:12.000 --> 00:36:15.000
If someone adds an import the wrong way.

00:36:15.000 --> 00:36:25.000
And I found it's, it's fascinating to see, like, if you have an idea for an architecture and then you put an import linter contract on and then discover all the places where you're breaking it.

00:36:25.000 --> 00:36:29.000
They're almost always quite interesting, interesting things.

00:36:29.000 --> 00:36:32.000
And you're like, yeah, actually this is a bit of a problem.

00:36:32.000 --> 00:36:35.000
Like it needs to be able to kind of untangle it.

00:36:35.000 --> 00:36:39.000
It is genuinely, you know, some conceptual tangling.

00:36:39.000 --> 00:36:41.000
It would simplify things if we didn't do it.

00:36:41.000 --> 00:36:42.000
Yeah.

00:36:42.000 --> 00:36:45.000
It's kind of a higher order code smell.

00:36:45.000 --> 00:36:48.000
People are familiar with this idea from refactoring a code smell.

00:36:48.000 --> 00:36:54.000
Like there's, it's not wrong in that it won't run, but you kind of turn your nose up at you.

00:36:54.000 --> 00:36:55.000
Like, oh, oh, right.

00:36:55.000 --> 00:37:02.000
And this is that, but not at a, oh, it takes too many parameters, but like, why is it all tied together like this?

00:37:02.000 --> 00:37:03.000
Can we think about it better?

00:37:03.000 --> 00:37:04.000
Right.

00:37:04.000 --> 00:37:08.000
You know, and you can do things like say all of these modules are independent.

00:37:08.000 --> 00:37:11.000
So, so they don't import anything from each other.

00:37:11.000 --> 00:37:18.000
I mean, this is like just my whole mentality for, for architecting Python packages.

00:37:18.000 --> 00:37:20.000
And I find it, it works really well.

00:37:20.000 --> 00:37:23.000
and I think the fact that we've got these rules in the world, right?

00:37:23.000 --> 00:37:29.000
and the fact that we've got these rules in place is probably a big reason why we're still able to have a thousand PRs a week.

00:37:29.000 --> 00:37:33.000
All happening in different time zones without that many faults.

00:37:33.000 --> 00:37:35.000
Cause we've got, we've, we've architected it.

00:37:35.000 --> 00:37:37.000
So say we know that there aren't any.

00:37:37.000 --> 00:37:42.000
Imports between say two energy companies or between two territories.

00:37:42.000 --> 00:37:48.000
You've got to install your competitors version as well to use yours.

00:37:48.000 --> 00:37:49.000
Yeah, exactly.

00:37:49.000 --> 00:37:52.000
So, so it's, you know, it's giving us.

00:37:52.000 --> 00:37:58.000
It's giving us, it's allowing us to think about things as being more independent.

00:37:58.000 --> 00:38:04.000
And so like someone can make a change in say Spain, and it's not going to break something in Australia.

00:38:04.000 --> 00:38:09.000
because you're pretty confident because they aren't importing anything from there.

00:38:09.000 --> 00:38:23.000
Does that mean in theory, if you've got this, that you could use this within, for example, CI to only run unit tests on systems that have changed or direct descendant, dependence of that package?

00:38:23.000 --> 00:38:24.000
Yeah.

00:38:24.000 --> 00:38:24.000
Yeah.

00:38:24.000 --> 00:38:25.000
So we do do that.

00:38:25.000 --> 00:38:26.000
Perfect.

00:38:26.000 --> 00:38:27.000
Yeah.

00:38:27.000 --> 00:38:28.000
Cause we've got a lot of money on CI.

00:38:28.000 --> 00:38:33.000
and so we've had to invest a lot of money to like figure out how do we narrow down the tests?

00:38:33.000 --> 00:38:34.000
so yeah.

00:38:34.000 --> 00:38:35.000
Yeah.

00:38:35.000 --> 00:38:36.000
That's awesome.

00:38:36.000 --> 00:38:37.000
That's a great observation.

00:38:37.000 --> 00:38:38.000
Yeah.

00:38:38.000 --> 00:38:46.000
And, and actually, yeah, this, this is all based on a, an underlying library called Grimp, which is, I kind of broke the libraries up.

00:38:46.000 --> 00:38:51.000
It's a little bit like what, what you did Samuel with Pydantic, Pydantic core.

00:38:51.000 --> 00:38:53.000
So import linter is pure Python.

00:38:53.000 --> 00:39:00.000
but it has a dependency, which is a grit, which is Grimp, which is, I mean, it's got Python and Rust in at the moment.

00:39:00.000 --> 00:39:12.000
but that is just a Python API for building a graph and then you can explore the graph and you can do things like it's really quite a useful tool.

00:39:12.000 --> 00:39:20.000
If you're just interested to know something about code base, you know, you can, just type in build, build me a graph of this.

00:39:20.000 --> 00:39:35.000
This package say, and then you could say, tell me all of the downstream modules of this module, and then we'll explore the whole graph and like give you a set of modules or tell me all the upstream modules of this.

00:39:35.000 --> 00:39:43.000
So you can tell what dependencies are, or you can like do, you know, what's the shortest path between this module and this module.

00:39:43.000 --> 00:39:45.000
so it makes sense.

00:39:45.000 --> 00:39:46.000
Yep.

00:39:46.000 --> 00:39:47.000
Yeah.

00:39:47.000 --> 00:39:51.000
Can you get it to do dependencies?

00:39:51.000 --> 00:39:53.000
Think the things you pip install.

00:39:53.000 --> 00:39:54.000
Oh, I see what you mean.

00:39:54.000 --> 00:40:00.000
Well, you can build the graph with multiple packages.

00:40:00.000 --> 00:40:07.000
but like, I don't even know if that's really, is that possible?

00:40:07.000 --> 00:40:11.000
Can you have two installable PI PI packages that depend on?

00:40:11.000 --> 00:40:16.000
No, I'm more, I'm more wondering if I can use this to visualize, well, what parts of my app.

00:40:16.000 --> 00:40:24.000
So I, I know that I have this dependency and I have to have it to run, but what parts of my app are using that library?

00:40:24.000 --> 00:40:27.000
So if I wanted to change it or whatever, you know what I mean?

00:40:27.000 --> 00:40:36.000
Like, cause you can, you can build a tree from there's a pit package for it, or uv will give you a tree of dependencies, but that is based on what packages require what other packages to be installed.

00:40:36.000 --> 00:40:39.000
It doesn't actually say what's being imported from where.

00:40:39.000 --> 00:40:49.000
So if you have an issue with URL in three, what is the actual like graph of where URL in three is being imported rather than what packages depend on it?

00:40:49.000 --> 00:40:56.000
there's a, there's a flag when you build the graph, which is, include external packages.

00:40:56.000 --> 00:40:57.000
Yeah.

00:40:57.000 --> 00:41:00.000
And if you pass it, then it will include them, but it doesn't include them.

00:41:00.000 --> 00:41:03.000
It just like includes the root name.

00:41:03.000 --> 00:41:08.000
if you wanted the whole thing, then you'd say, build me the graph of, I mean, that would work as well, but you could say,

00:41:08.000 --> 00:41:13.000
build me the graph of Django and cracking whatever.

00:41:13.000 --> 00:41:19.000
or you can say, build me the graph of cracking with external packages.

00:41:19.000 --> 00:41:24.000
And then, then you just see like Django would just be a node in the graph, but it would just be one node.

00:41:24.000 --> 00:41:25.000
Yeah.

00:41:25.000 --> 00:41:26.000
That'd be great.

00:41:26.000 --> 00:41:27.000
Does that make sense?

00:41:27.000 --> 00:41:28.000
Yeah.

00:41:28.000 --> 00:41:29.000
Hmm.

00:41:29.000 --> 00:41:35.000
So the story is this was working, but slow.

00:41:35.000 --> 00:41:36.000
Yes.

00:41:36.000 --> 00:41:42.000
yeah, like just as an example, one of our contracts and we had lots of contracts.

00:41:42.000 --> 00:41:45.000
One contract was taking six minutes to check.

00:41:45.000 --> 00:42:00.000
the reason for this is because actually it is quite, algorithmically expensive to check whether or not certain rules are being followed because, it does.

00:42:00.000 --> 00:42:01.000
It does.

00:42:01.000 --> 00:42:04.000
It's not like just doing a kind of search.

00:42:04.000 --> 00:42:07.000
it's actually looking for indirect imports.

00:42:07.000 --> 00:42:17.000
it's like, it's like a path finding algorithm to sort of see, well, do you end up here via this other thing that you didn't ask about?

00:42:17.000 --> 00:42:20.000
and yeah.

00:42:20.000 --> 00:42:30.000
and yeah, so certain things were taking a really long time and that was costing us money because we run this, you know, hundreds, if not thousands of times a day.

00:42:30.000 --> 00:42:32.000
and it all adds up.

00:42:32.000 --> 00:42:36.000
and it also just slows down, you know, your pull request.

00:42:36.000 --> 00:42:37.000
You want to get the green quicker.

00:42:37.000 --> 00:42:43.000
so I had heard that rust was interoperable with Python.

00:42:43.000 --> 00:42:45.000
I didn't really know anything about it.

00:42:45.000 --> 00:43:01.000
and I found this library called PI03, which is a rust library and it makes it, I'm not going to say easy, but it makes it easier.

00:43:01.000 --> 00:43:10.000
Yeah, it makes it surprisingly easy to, to write rust extension modules and gives you some of all the tooling in place.

00:43:10.000 --> 00:43:27.000
And I would say, you know, you're writing a lot less code than you would be if you're writing a C extension module, because it's sort of a nice, it's a really nice API for, creating these interoperable, compiled modules.

00:43:27.000 --> 00:43:37.000
So like I'd started by just finding, finding the function that was taking all the time and have millions and millions and millions of calls.

00:43:37.000 --> 00:43:41.000
I was like, why don't I just write that as in rust?

00:43:41.000 --> 00:43:51.000
And I kind of just sort of almost copied and pasted it over and like cobbled together some pretty rubbish rust that did basically exactly the same.

00:43:51.000 --> 00:43:56.000
and, it was a thousand times slower.

00:43:56.000 --> 00:43:58.000
well done.

00:43:58.000 --> 00:43:59.000
Well done.

00:44:00.000 --> 00:44:05.000
But, but there's a good reason for that, which is I just zoomed in too close.

00:44:05.000 --> 00:44:13.000
So because that, because that function was called a lot of times, there is actually a cost in, in crossing the boundary.

00:44:13.000 --> 00:44:20.000
So I just had to step one level up and like wrap all of those calls for that function in rust instead.

00:44:20.000 --> 00:44:22.000
So there's only one call from piping to rust.

00:44:22.000 --> 00:44:23.000
And then suddenly.

00:44:23.000 --> 00:44:24.000
Right.

00:44:24.000 --> 00:44:25.000
Majorly quicker.

00:44:25.000 --> 00:44:33.000
I mean, I think that that particular problematic contract went from about six minutes to one minute.

00:44:33.000 --> 00:44:36.000
Now that is to be honest.

00:44:36.000 --> 00:44:42.000
And that was brilliant, but that is not, that's just scratching the surface of how much quicker it could get.

00:44:42.000 --> 00:44:53.000
but still a six times speed up for relatively little work and basically just writing the same algorithm, but with some curly brackets, and a bit of head scratching.

00:44:53.000 --> 00:44:54.000
Yeah.

00:44:54.000 --> 00:45:03.000
I was able to deliver something without having ever done anything in rust and it was, and it really made a difference, you know, and saved us lots of money.

00:45:03.000 --> 00:45:04.000
yeah.

00:45:04.000 --> 00:45:05.000
Yeah.

00:45:05.000 --> 00:45:09.000
So that was, that was, and now you're a rust developer as well.

00:45:09.000 --> 00:45:14.000
Now I'm a rust developer and I read, and I'm, you know, I want to move more, more of Grimp into rust.

00:45:14.000 --> 00:45:21.000
another example, even less work was, we had a problem with, translations.

00:45:21.000 --> 00:45:30.000
So, there's a kind of standard for doing translations called fluent and some of the listeners may come across it.

00:45:30.000 --> 00:45:35.000
and there are libraries for it in all sorts of different languages, including Python and rust.

00:45:35.000 --> 00:45:49.000
And we realized that it was responsible for almost all of the bootstrap time of our application in production, was loading and scanning these translation files.

00:45:49.000 --> 00:45:53.000
you know, it was pretty problematic.

00:45:53.000 --> 00:45:55.000
It was, it was like really spiky as well.

00:45:55.000 --> 00:45:59.000
And you can see sometimes it would spike to like nine minutes.

00:45:59.000 --> 00:46:00.000
Yeah.

00:46:00.000 --> 00:46:04.000
and we knew it was all in this translations thing.

00:46:04.000 --> 00:46:08.000
And someone pointed out, look, there's a rust library for this.

00:46:08.000 --> 00:46:11.000
So all we need to do is just link them up.

00:46:11.000 --> 00:46:18.000
And so they, it wasn't, it wasn't actually me, but, they just wrote this pie three crate that was a lot of different.

00:46:18.000 --> 00:46:21.000
a crate that, a crate is like a rust library.

00:46:21.000 --> 00:46:22.000
Yeah.

00:46:22.000 --> 00:46:28.000
you know, probably only about 10, 15 lines of code just glued the two things together.

00:46:28.000 --> 00:46:34.000
and it was, it was really like not very much work.

00:46:34.000 --> 00:46:38.000
and compile that.

00:46:38.000 --> 00:46:41.000
And it just completely sorted the problem out.

00:46:41.000 --> 00:46:44.000
We, we went from eight minutes to 30 seconds.

00:46:44.000 --> 00:46:50.000
and you know, of that, like the, the, you know, that 30 seconds is other stuff.

00:46:50.000 --> 00:46:56.000
You know, I think, I think it's, it's from being something that took several minutes to being virtually instant.

00:46:56.000 --> 00:47:00.000
crazy, but really hardly any work.

00:47:00.000 --> 00:47:05.000
And I think that that's a really good example of where as Python developers, we should be aware.

00:47:05.000 --> 00:47:06.000
This is an option.

00:47:06.000 --> 00:47:12.000
If something says something slow, you might just, I mean, rust has so many good libraries.

00:47:12.000 --> 00:47:16.000
You might just be able to like to glue it up and job done.

00:47:16.000 --> 00:47:17.000
Yeah.

00:47:19.000 --> 00:47:25.000
one thing I would add the overhead of calling into pilot three has, has dropped

00:47:25.000 --> 00:47:26.000
a lot.

00:47:26.000 --> 00:47:31.000
I don't know how long ago that was you, you were trying, but I think it's, yeah, reduced

00:47:31.000 --> 00:47:32.000
significantly.

00:47:32.000 --> 00:47:37.000
So, I mean, I did this quite a lot of the same work in pirantic core to avoid the overhead

00:47:37.000 --> 00:47:38.000
of calling into and out of it lots of times.

00:47:38.000 --> 00:47:41.000
And I think that's less of a thing now than it used to be.

00:47:41.000 --> 00:47:42.000
That's good to hear.

00:47:42.000 --> 00:47:43.000
Yeah.

00:47:43.000 --> 00:47:44.000
Cool.

00:47:44.000 --> 00:47:49.000
one point I want to make is I think that's really interesting David to say that,

00:47:49.000 --> 00:47:51.000
Hey, there's this whole equivalent of pipe.

00:47:51.000 --> 00:47:52.000
Yeah.

00:47:52.000 --> 00:47:57.000
I called cargo, or you can get these libraries just like, I mean, create, sorry that you get

00:47:57.000 --> 00:48:03.000
installed with cargo that you can get all of these prebuilt, pre-tested libraries and maybe

00:48:03.000 --> 00:48:07.000
just put a wrapper on them and do some amazing stuff.

00:48:07.000 --> 00:48:13.000
I just started using this web server at the Python layer for called granion.

00:48:13.000 --> 00:48:17.000
And you're like, well, how many people are working on it?

00:48:17.000 --> 00:48:19.000
It's got up to 3000 stars now.

00:48:19.000 --> 00:48:20.000
Is that enough to trust?

00:48:20.000 --> 00:48:26.000
But if you really look at it, it's really using just hyper, right?

00:48:26.000 --> 00:48:38.000
And hyper, hyper is a library that, excuse me, that is got like 14,000 GitHub stars, 400 contributors.

00:48:38.000 --> 00:48:45.000
And like, oh, you know, it's kind of this cool application is something of a wrapper around

00:48:45.000 --> 00:48:47.000
this really popular and well-known thing, right?

00:48:47.000 --> 00:48:49.000
I think we'll see more of this kind of stuff.

00:48:49.000 --> 00:48:50.000
Absolutely.

00:48:50.000 --> 00:48:56.000
And Giovanni, who's who works on this is also working on, it's our loop, basically an alternative

00:48:56.000 --> 00:48:57.000
to uv loop.

00:48:57.000 --> 00:49:03.000
I don't know if that's in here as well.

00:49:03.000 --> 00:49:11.000
I maintain, watch files, which is the like file watching library used by UVicorn

00:49:11.000 --> 00:49:12.000
and some other things.

00:49:12.000 --> 00:49:19.000
And that is again, wrapping wrapping a rust library for getting fast system notifications.

00:49:19.000 --> 00:49:24.000
And also our Toml, which is the fastest Toml parser in Python, which is again, just wrapping

00:49:24.000 --> 00:49:25.000
the wrapping the rust library.

00:49:25.000 --> 00:49:30.000
So there are a number of places where you can get enormous performance improvements and,

00:49:30.000 --> 00:49:36.000
and indeed, like a fundamentally more reliable libraries because you're building in rust when

00:49:36.000 --> 00:49:42.000
you're doing complex, particularly multi-threaded things by, by like relying on rust.

00:49:42.000 --> 00:49:43.000
Yeah.

00:49:43.000 --> 00:49:46.000
These libraries seem to be very good quality and well thought through.

00:49:46.000 --> 00:49:51.000
That's my, been my experience somehow attracts people that are very thorough because you can't

00:49:51.000 --> 00:49:55.000
really program in rust unless you're thorough because you can't get it to compile.

00:49:55.000 --> 00:49:58.000
I think it's hard to say rust does have a bit of a problem with abandoned libraries.

00:49:58.000 --> 00:50:03.000
I think that is, I think if we didn't put, put, call it out, I know David, you and I were

00:50:03.000 --> 00:50:06.000
speaking at a, an event where there was one particular chap who had a bee in his bonnet about

00:50:06.000 --> 00:50:07.000
that exact issue.

00:50:07.000 --> 00:50:11.000
I think he was slightly overblown on it, but there is definitely an issue with some abandoned,

00:50:11.000 --> 00:50:18.000
some abandoned libraries in, in rust, but like, I mean, same as true in Python in its own place,

00:50:18.000 --> 00:50:20.000
but, but you're right.

00:50:20.000 --> 00:50:24.000
There are also libraries that are abandoned and remaining incredibly good quality.

00:50:24.000 --> 00:50:27.000
So Jitter uses a library for parsing floats.

00:50:27.000 --> 00:50:33.000
I didn't know this, but the complexity of parsing floats from strings is a entire subject of academic interest.

00:50:33.000 --> 00:50:37.000
There are eight different algorithms for doing it with different performance, depending on whether or not it is

00:50:37.000 --> 00:50:40.000
the, the structure of the float.

00:50:40.000 --> 00:50:42.000
And there was a library that does this very well.

00:50:42.000 --> 00:50:45.000
And the library was abandoned, but it worked perfectly.

00:50:45.000 --> 00:50:47.000
And eventually the guy replied to my email and went and fixed it.

00:50:47.000 --> 00:50:53.000
So, I mean, the quality, the quality is very high in my experience.

00:50:53.000 --> 00:50:54.000
Yeah.

00:50:54.000 --> 00:50:56.000
I just make the point.

00:50:56.000 --> 00:51:00.000
I think, you know, there's over half a million packages and PI PI as well.

00:51:00.000 --> 00:51:05.000
And I'm sure that there's a non-trivial amount of them that people are no longer maintaining as well.

00:51:05.000 --> 00:51:11.000
Sometimes things are done and sometimes they're abandoned and it's hard to tell the difference, you know, like, no, I haven't updated it in two years.

00:51:11.000 --> 00:51:15.000
Cause it's done, but also, also, okay.

00:51:15.000 --> 00:51:22.000
It's hard to tell the difference until you're three weeks in and you don't want to back out of using that library and you realize that actually it's, it's actually not done.

00:51:22.000 --> 00:51:24.000
It's not done.

00:51:24.000 --> 00:51:25.000
But nobody wants to write.

00:51:25.000 --> 00:51:36.000
All right, David, before we wrap this up, I would really like to have you talk us through sort of the tool chain workflow of, I've got this idea.

00:51:36.000 --> 00:51:40.000
I want to maybe, you know, rewrite it and rust.

00:51:40.000 --> 00:51:43.000
If you've spoken about it, what are the building blocks or the moving pieces?

00:51:43.000 --> 00:51:45.000
What do people need to know?

00:51:45.000 --> 00:51:46.000
Absolutely.

00:51:46.000 --> 00:51:47.000
Okay.

00:51:47.000 --> 00:51:59.000
So, the things you need to know is first of all, the thing you're going to create is an extension module, which is like a built, a built compiled thing.

00:51:59.000 --> 00:52:04.000
and that is going to end up being a Python wheel.

00:52:04.000 --> 00:52:14.000
and what you want to do is you, when you release something on pipe AI, you want to have wheels for all the different versions of Python and chip architectures and things.

00:52:14.000 --> 00:52:18.000
So that's kind of like some of the complexity.

00:52:18.000 --> 00:52:19.000
So that's kind of the end goal.

00:52:19.000 --> 00:52:22.000
We want to end up with these built versions of Python.

00:52:22.000 --> 00:52:36.000
And then we want to end up with these versions of Python that are going to contain some Python code, but also some compiled things for, you know, macOS under Python 312 or whatever like that.

00:52:36.000 --> 00:52:38.000
So that's kind of the end goal.

00:52:38.000 --> 00:52:39.000
So that's kind of the end goal.

00:52:49.000 --> 00:52:58.000
Rustup is kind of like one level up and it's maybe a bit like PyPI if people have used that, but it sort of does a bit more than that.

00:52:58.000 --> 00:53:09.000
Maybe also a bit like uv these days where you can uv install Python based on what you asked for or just create a virtual environment and it'll just grab the tools you need to make that happen.

00:53:09.000 --> 00:53:14.000
I'd say that cargo is closer to uv probably, which is the next thing I'll talk about.

00:53:14.000 --> 00:53:27.000
But Rustup is like one step up and it's like it's for managing the versions of Rust that are on your computer and the versions of cargo that are on your computer, which are cargo is the package manager for Rust.

00:53:27.000 --> 00:53:28.000
Yeah.

00:53:28.000 --> 00:53:34.000
So what you'll do, your first step is to go to the Rust website and install Rustup.

00:53:34.000 --> 00:53:40.000
And then hopefully at the command line, you'll be able to type Rust C and then you can compile a Rust file if you want to.

00:53:40.000 --> 00:53:44.000
But you don't actually need to do that because that's what you use cargo for.

00:53:44.000 --> 00:53:51.000
So your main kind of thing that you're typing all the time when you're using Rust is cargo and then some kind of command.

00:53:51.000 --> 00:53:55.000
And so you've installed Rustup and you've got cargo.

00:53:55.000 --> 00:53:58.000
Then what you'd want to do is create a project.

00:53:59.000 --> 00:54:03.000
And you can create a project using cargo.

00:54:03.000 --> 00:54:10.000
You could do cargo new and then I'll give you a whole file system structure and you'll be able to run it and run tests and all that.

00:54:10.000 --> 00:54:11.000
Very nice.

00:54:11.000 --> 00:54:17.000
And that is how you would install the latest version of PI03.

00:54:17.000 --> 00:54:32.000
So you would, I probably would just go over onto crates.io, which is the PI PI equivalent and look at what the version is of PI PI and then write it in a file.

00:54:32.000 --> 00:54:35.000
I think there is a cargo command probably for adding it.

00:54:35.000 --> 00:54:36.000
It's cargo add.

00:54:36.000 --> 00:54:40.000
But it's also worth saying that matcher in is a big part of the ecosystem.

00:54:40.000 --> 00:54:44.000
Do you want to introduce matcher in because I think that's about where that comes in.

00:54:44.000 --> 00:54:57.000
So, so cargo is the cargo is the thing that Rust, Rust people will be using to compile these things, but you can't just use that on your own because you need the whole pip installing kind of side of things.

00:54:57.000 --> 00:55:04.000
So you can use cargo and just create an extension module, but then you need to like give it the right name and copy it into the right place.

00:55:05.000 --> 00:55:08.000
So there's a bit of kind of gluing that needs to happen.

00:55:08.000 --> 00:55:10.000
And that is what matcher in is for.

00:55:10.000 --> 00:55:12.000
Why do we need two tools?

00:55:12.000 --> 00:55:20.000
Well, cargo is the rust side of things, but matcher in is actually just a pip installable Python package.

00:55:20.000 --> 00:55:34.000
So what you'll do is in your, in the Python project that you want to rustify, you will do go into your activate your virtual environment or whatever, and then do pip install matcher in.

00:55:34.000 --> 00:55:39.000
And then you've got this tool for matcher in and you could even do matcher in a new project or something like that.

00:55:39.000 --> 00:55:40.000
I can't remember what the command is.

00:55:40.000 --> 00:55:49.000
What, what I had to do was I had a preexisting project, so I couldn't just do it like that.

00:55:49.000 --> 00:55:56.000
But it might be quite a nice way to learn is to, to follow the matcher in docs to do a new project.

00:55:56.000 --> 00:56:03.000
And what matcher in allows you to do is I think you, you might edit your rust code.

00:56:03.000 --> 00:56:07.000
And then you would type matcher in develop.

00:56:07.000 --> 00:56:15.000
And then it would compile your rust code, but it would, it would kind of install it locally so that you can work with it.

00:56:15.000 --> 00:56:21.000
And then the final piece of this picture is how that gets onto PI PI.

00:56:21.000 --> 00:56:23.000
Matcher in also gives you some tools for that.

00:56:23.000 --> 00:56:29.000
There's a, there's a command called generate CI, I think, which gives you.

00:56:29.000 --> 00:56:34.000
It just spits out YAML for the, for whatever CI provider you want.

00:56:34.000 --> 00:56:35.000
Yeah.

00:56:35.000 --> 00:56:36.000
And that's really helpful as well.

00:56:36.000 --> 00:56:37.000
Yeah.

00:56:37.000 --> 00:56:41.000
Because I, I, I've given a.

00:56:41.000 --> 00:56:42.000
Yeah.

00:56:42.000 --> 00:56:56.000
Well, I think one of the things you both have to deal with here is releasing a package, a wheel for this is not just, well, let's zip up the Python files and put them up there.

00:56:56.000 --> 00:56:57.000
Right.

00:56:57.000 --> 00:57:00.000
You're compiling native code and that means you need variations.

00:57:00.000 --> 00:57:01.000
Right.

00:57:01.000 --> 00:57:02.000
Yeah.

00:57:02.000 --> 00:57:10.000
I think we, I think Pydantic core releases 60 something different wheels to cover all different possible combinations of Python version and architecture.

00:57:10.000 --> 00:57:13.000
But I mean, I think I would basically second what David was saying.

00:57:13.000 --> 00:57:20.000
Matcher in in particular, it does an amazing job of smoothing out the kind of rough edges between Rust and Python.

00:57:20.000 --> 00:57:25.000
Rust has had a good, relatively good story on package management for some time.

00:57:25.000 --> 00:57:32.000
Python is just coming, but often when you're trying to do these things, it's the, like trying to get one to speak to the other and working out what the hell is going wrong.

00:57:32.000 --> 00:57:34.000
And what does that file need to be all that?

00:57:34.000 --> 00:57:38.000
Like sim link between some DLL and some other place.

00:57:38.000 --> 00:57:42.000
Matcher in effectively gets rid of that whole challenge for you and just works.

00:57:42.000 --> 00:57:43.000
Right.

00:57:43.000 --> 00:57:46.000
And lets you, lets you work on it.

00:57:46.000 --> 00:57:51.000
Like you're, it's as easy as writing Python or, or Rust interacting with the two.

00:57:51.000 --> 00:57:52.000
Yeah.

00:57:52.000 --> 00:58:03.000
Cause cargo and Rust C will output Rust conventions, but Python wants C extension conventions naming like .so versus Dynlib and things like that.

00:58:03.000 --> 00:58:04.000
Right.

00:58:04.000 --> 00:58:05.000
And getting the inputs right.

00:58:05.000 --> 00:58:06.000
And yeah.

00:58:06.000 --> 00:58:20.000
So what your work, once you've sort of set it all up, what your workflow looks like is, if, if you're, if you haven't changed any of the Rust, then, you know, maybe like you run tests, you just run py test whatever.

00:58:20.000 --> 00:58:25.000
And that, that will run tests against the compiled.

00:58:25.000 --> 00:58:27.000
Assuming you're writing Python tests against that.

00:58:27.000 --> 00:58:33.000
but if you make a change to the Rust, then you do have to have an extra step of building it.

00:58:33.000 --> 00:58:36.000
So you type matcher in develop and then it would build it.

00:58:36.000 --> 00:58:43.000
And then you could run py test or you, you might, and I recommend you do actually, if you're working with Rust and you're not very experienced.

00:58:43.000 --> 00:58:52.000
I tend to have a test suite for Python, but also some tests in Rust because you get a much quicker feedback loop.

00:58:52.000 --> 00:58:58.000
Cause you can type cargo test and that will compile it and run the test really quite quickly.

00:58:58.000 --> 00:59:08.000
one other thing I think it's worth having is that obviously if you have this binary that contains your Rust code, which is, you know, in the end, it becomes a module that you can import in Python.

00:59:08.000 --> 00:59:11.000
But by default, that is obviously opaque to type checkers.

00:59:11.000 --> 00:59:16.000
So things like IDs and static type checking can't look inside there and see what your functions are.

00:59:16.000 --> 00:59:25.000
So you, you want to write a, a PYI file, which contains your definitions in like stub Python code effectively.

00:59:25.000 --> 00:59:31.000
The problem you then have is you end up with two separate, definitions of what your functions have in them.

00:59:31.000 --> 00:59:37.000
And so there's a really neat tool, which I didn't know about until quite recently, but I, we use it in Pydantic core where, which my partner,

00:59:37.000 --> 00:59:45.000
where, which my pie can basically type check that the P P Y I file stubs match the definitions inside the DLL.

00:59:45.000 --> 00:59:52.000
And so you can have like guarantees that when you've written in a P P Y I file, my function through bar takes a, isn't it?

00:59:52.000 --> 00:59:55.000
B is a string and C is a list of bytes.

00:59:55.000 --> 00:59:57.000
That's wild.

00:59:57.000 --> 00:59:59.000
I didn't know about that.

00:59:59.000 --> 01:00:00.000
Yeah, that's awesome.

01:00:00.000 --> 01:00:02.000
It fixes altogether.

01:00:02.000 --> 01:00:03.000
Is that my plugin?

01:00:04.000 --> 01:00:09.000
if you have a look at Pydantic core, we run it in CI or in maybe even pre commit.

01:00:09.000 --> 01:00:10.000
So you can find it there.

01:00:10.000 --> 01:00:11.000
I couldn't remember.

01:00:11.000 --> 01:00:18.000
I discovered it because it, I, I, so like, like so often with so many of us, I discovered it because it had a bug.

01:00:18.000 --> 01:00:22.000
And so it suddenly didn't do quite the right thing for me, but I mean, in general, it's been perfect until now.

01:00:22.000 --> 01:00:25.000
Yeah.

01:00:25.000 --> 01:00:26.000
It's plumbing until it doesn't work.

01:00:26.000 --> 01:00:27.000
And then it's a flood.

01:00:27.000 --> 01:00:28.000
Bug based discovery.

01:00:28.000 --> 01:00:30.000
Definitely a thing we've all, we've all practiced.

01:00:31.000 --> 01:00:32.000
Bug driven development.

01:00:32.000 --> 01:00:32.000
Yeah.

01:00:32.000 --> 01:00:33.000
Okay.

01:00:33.000 --> 01:00:34.000
Yeah.

01:00:34.000 --> 01:00:50.000
And if people want to check out these P Y I files, there's a project called type shed on GitHub that whose job is to basically become these, these so-called stub files for a ridiculous number of projects that, you know, we're talking about things that are not going to get upgraded.

01:00:50.000 --> 01:00:56.000
Maybe they're never going to get type type you put on them, but you can go and pour one of these or whatever and get.

01:00:56.000 --> 01:01:06.000
But also lots of packages now have their own, either they have types in them or they have a P Y I file that defines the types either in the Python code or in P Y I.

01:01:06.000 --> 01:01:07.000
So yeah.

01:01:07.000 --> 01:01:08.000
Yeah.

01:01:08.000 --> 01:01:09.000
Awesome.

01:01:09.000 --> 01:01:10.000
That's really cool.

01:01:10.000 --> 01:01:15.000
I didn't realize about the tool there though, that does the integration.

01:01:15.000 --> 01:01:16.000
That's awesome.

01:01:16.000 --> 01:01:19.000
I think presumably you can use it to generate your first P Y I file.

01:01:19.000 --> 01:01:23.000
Then you go in and put your doc strings in tweak things a bit and then you run it in test mode.

01:01:23.000 --> 01:01:24.000
Oh, nice.

01:01:24.000 --> 01:01:25.000
Yeah.

01:01:25.000 --> 01:01:32.000
Cause that way use the true version, the rust version and to say, generate what I need to make this work.

01:01:32.000 --> 01:01:33.000
That makes a lot of sense.

01:01:33.000 --> 01:01:34.000
Yeah.

01:01:34.000 --> 01:01:36.000
Awesome.

01:01:36.000 --> 01:01:38.000
All right.

01:01:38.000 --> 01:01:40.000
Well gentlemen, we're just pretty much out of time.

01:01:40.000 --> 01:01:46.000
I guess let me, let me ask you one more, one more thing here.

01:01:46.000 --> 01:01:47.000
And I don't think I pulled it up.

01:01:47.000 --> 01:01:49.000
So I think it's, hold on.

01:01:49.000 --> 01:02:00.000
Let me check my notes quickly checks notes for where this was one sec.

01:02:00.000 --> 01:02:02.000
There's a new PEP called external wheel hosting.

01:02:02.000 --> 01:02:03.000
Have you all heard of this?

01:02:03.000 --> 01:02:05.000
I have not seen that particular.

01:02:05.000 --> 01:02:06.000
Is that for, for wasm?

01:02:06.000 --> 01:02:14.000
I know that I've been talking to a hood a fair bit about the challenges of uploading wasm wheels.

01:02:14.000 --> 01:02:18.000
I know it has to do with more than it is five.

01:02:18.000 --> 01:02:19.000
Here we go.

01:02:19.000 --> 01:02:20.000
Copy link.

01:02:20.000 --> 01:02:23.000
It is five, seven, five, nine.

01:02:23.000 --> 01:02:28.000
And the idea that if you could, the nomenclature here is ridiculous.

01:02:28.000 --> 01:02:31.000
It is in clever.

01:02:31.000 --> 01:02:41.000
So the idea is that, you know, each build of Pydantic put 60 binary artifacts onto, onto PI PI.

01:02:41.000 --> 01:02:49.000
And there's limitations on how large your projects can be and how large individual releases can be.

01:02:49.000 --> 01:02:53.000
This is especially problematic for machine learning stuff.

01:02:53.000 --> 01:02:54.000
Right?

01:02:54.000 --> 01:03:01.000
And so the idea is could we create a wheel stub and what is a wheel sub calls with it's like the wheel without the content.

01:03:01.000 --> 01:03:13.000
It's called a rim because wheels go on right now and all, there's all sorts of stuff like that in here, but it contains a hash and then a location where the thing actually lives.

01:03:13.000 --> 01:03:14.000
Right?

01:03:14.000 --> 01:03:18.000
So you mentioned open AI, for example, maybe they have some huge thing.

01:03:18.000 --> 01:03:20.000
They want you to download eventually.

01:03:20.000 --> 01:03:25.000
They could host it and you just publish the rim, not the wheel.

01:03:25.000 --> 01:03:28.000
Do you know the story of why they're called wheels?

01:03:28.000 --> 01:03:29.000
This, this entertains me a lot.

01:03:29.000 --> 01:03:30.000
No, tell me.

01:03:30.000 --> 01:03:33.000
So they're called wheels because you have wheels of cheese.

01:03:33.000 --> 01:03:48.000
They're called wheels of cheese because the original PI PI was called the cheese shop, which in turn was called the cheese shop because there is a Monty Python sketch called the cheese shop where he goes in to buy cheese and then none of the cheeses he asked for available.

01:03:48.000 --> 01:03:54.000
And it was called that as a way of taking the piss out of, I forget which other language.

01:03:54.000 --> 01:04:01.000
It might've been Ruby or PHP, how their original package registry has no packages in it.

01:04:01.000 --> 01:04:03.000
Like the cheese shops get in Monty Python.

01:04:03.000 --> 01:04:04.000
And that has.

01:04:04.000 --> 01:04:05.000
Oh my gosh.

01:04:05.000 --> 01:04:08.000
Assisted to rims in 2024.

01:04:08.000 --> 01:04:09.000
That's incredible.

01:04:09.000 --> 01:04:10.000
Yeah.

01:04:10.000 --> 01:04:18.000
I did know the cheese shop equivalent there that that was part of it, but I didn't realize that it was the wheels of cheese.

01:04:18.000 --> 01:04:19.000
Okay.

01:04:19.000 --> 01:04:20.000
Incredible.

01:04:20.000 --> 01:04:22.000
There's a lot of, a lot of Monty Python.

01:04:22.000 --> 01:04:24.000
You know, people that you look around everywhere.

01:04:24.000 --> 01:04:26.000
The logo is the snake, right?

01:04:26.000 --> 01:04:29.000
But the logo, the name is not Python, the snake.

01:04:29.000 --> 01:04:31.000
It's Monty Python.

01:04:31.000 --> 01:04:38.000
And I know, I mean, I always think if I wrote a book about Python, I'd want to have the night to say me in the front.

01:04:38.000 --> 01:04:39.000
Yes.

01:04:39.000 --> 01:04:44.000
I want the bunny, the killer bunny.

01:04:44.000 --> 01:04:46.000
It's definitely a certain era of humor.

01:04:46.000 --> 01:04:47.000
I don't know.

01:04:47.000 --> 01:04:51.000
You know, it definitely dates Python in its way and us, perhaps, I fear.

01:04:51.000 --> 01:04:53.000
Yeah, perhaps.

01:04:53.000 --> 01:04:54.000
Perhaps.

01:04:54.000 --> 01:04:58.000
I don't know what this gray hair is about, but we're going to go.

01:04:58.000 --> 01:05:00.000
All right, guys.

01:05:00.000 --> 01:05:02.000
Let's, let's close this out.

01:05:02.000 --> 01:05:08.000
I'll give each of you a chance to just give us sort of a parting thought on integrating Rust and maybe thoughts and just

01:05:08.000 --> 01:05:11.000
Rust and Python together.

01:05:11.000 --> 01:05:13.000
I'll go, David.

01:05:13.000 --> 01:05:18.000
Only really to say I am a better programmer for having learned to write Rust as well as Python.

01:05:18.000 --> 01:05:24.000
And I failed to see the value in C anymore for new projects.

01:05:24.000 --> 01:05:26.000
I get why it exists for lots of existing ones.

01:05:26.000 --> 01:05:29.000
I'm not going to get into the issue of whether stuff should be rewritten in Rust.

01:05:29.000 --> 01:05:33.000
But I think if you're starting from scratch, you're trying to write something high performance.

01:05:33.000 --> 01:05:42.000
The experience of doing it in Rust is completely different from trying to do it in C or C++ or C# or any of the other, or Fortran or Julia or any of those other languages.

01:05:42.000 --> 01:05:43.000
Rust is awesome.

01:05:43.000 --> 01:05:46.000
So I'd really encourage people to, to give it a go.

01:05:46.000 --> 01:05:50.000
And when you're giving it a go, you might also have a, give Logfire a quick go.

01:05:50.000 --> 01:05:52.000
We're releasing our Rust SDK fairly soon.

01:05:52.000 --> 01:05:53.000
We have Python already.

01:05:53.000 --> 01:05:59.000
So we're matching the like Python Rust TypeScript ecosystem, which I think is the, like the stack to build with today.

01:05:59.000 --> 01:06:00.000
Awesome.

01:06:00.000 --> 01:06:12.000
I think my, my parting thought would be like, if you give it a go, don't be surprised if you feel quite inadequate.

01:06:12.000 --> 01:06:18.000
It's really quite hard to sort of get your head around what's going on.

01:06:18.000 --> 01:06:34.000
And I feel very much still at the beginning of my journey, but I, but nevertheless, I have actually managed to like deliver some stuff, which is valuable, even though, to be honest, I'm not like particularly proud of the code I'm writing.

01:06:34.000 --> 01:06:37.000
It's like, you know, I'm a beginner again.

01:06:37.000 --> 01:06:40.000
and I just want to say like, don't let that put you off.

01:06:40.000 --> 01:06:49.000
and if you're confused, you know, just keep on, keep on going and trying to get your head around it.

01:06:49.000 --> 01:06:51.000
It will make you a better programmer.

01:06:51.000 --> 01:07:00.000
The book that I've found the best for learning Rust is the Rust programming language, which is a free book on the Rust website.

01:07:00.000 --> 01:07:03.000
Right. Just click the learn button in the top, right?

01:07:03.000 --> 01:07:04.000
Yeah.

01:07:04.000 --> 01:07:21.000
Yeah. Awesome. Yeah. I'll also just add one quick thought as well to just follow up to what you said, David is whenever you're switching programming languages and you've been programming for a while, you just, you feel inadequate and you feel like I was so good.

01:07:21.000 --> 01:07:30.000
I had it figured out. I could just sit down and do stuff. And now even how do I just read a file or just run a program? I'm lost all over again.

01:07:30.000 --> 01:07:36.000
But every time you do that, your prior experience still carries over way more than it initially feels like it does.

01:07:36.000 --> 01:07:37.000
Cool.

01:07:37.000 --> 01:07:43.000
And you're not throwing everything away and starting over. You're, you're learning a neutral chain and then on you go.

01:07:43.000 --> 01:07:52.000
Absolutely. And particularly when it's so easy to call Python from Rust and vice versa. And so you can build applications that are like hybrid of the two.

01:07:52.000 --> 01:08:01.000
Absolutely. Yeah. Absolutely. Yeah. Well, congratulations both on some awesome projects and yeah. Thanks. Thanks for being here as well. Bye y'all.

01:08:01.000 --> 01:08:02.000
Thank you so much.

01:08:02.000 --> 01:08:03.000
Yeah. Bye.

01:08:03.000 --> 01:08:04.000
Bye.

