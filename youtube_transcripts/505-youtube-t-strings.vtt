WEBVTT

00:00:01.220 --> 00:00:05.980
Dave, Jim, and Paul, welcome to all three of you to talk Python to me.

00:00:06.390 --> 00:00:07.200
Paul, welcome back.

00:00:07.570 --> 00:00:09.380
Dave and Jim, welcome for the first time.

00:00:09.450 --> 00:00:10.060
Awesome to have you here.

00:00:11.020 --> 00:00:11.500
Thanks.

00:00:11.960 --> 00:00:12.400
Thanks.

00:00:14.460 --> 00:00:14.780
Indeed.

00:00:15.420 --> 00:00:21.620
We are going to carry on an amazing tradition of Python string formatting.

00:00:22.600 --> 00:00:25.140
We've had the percent.

00:00:26.020 --> 00:00:26.780
We've had the plus.

00:00:27.680 --> 00:00:29.100
We've had the dot format.

00:00:29.720 --> 00:00:30.880
We've had the dot join.

00:00:32.640 --> 00:00:36.240
Everyone was very excited about f-strings back at 3.6 when they came out.

00:00:36.420 --> 00:00:46.400
And now, after quite a bit of work from the three of you and others, we're going to be talking about PEP 750 T strings.

00:00:49.400 --> 00:00:49.660
Amazing.

00:00:49.890 --> 00:00:51.900
So congratulations on all of that.

00:00:52.320 --> 00:00:53.520
I think it's going to be a lot of fun.

00:00:54.320 --> 00:01:01.180
People may be surprised to think that, oh, there's an entire episode with three whole people on string formatting?

00:01:01.760 --> 00:01:02.700
Yes. Yes, that's right.

00:01:02.740 --> 00:01:03.760
There's actually a lot to it.

00:01:04.280 --> 00:01:07.460
This is a pretty rich API and a pretty big advancement.

00:01:08.220 --> 00:01:10.300
So we're going to dive into that.

00:01:10.440 --> 00:01:12.740
But before we do, how about a round of introductions?

00:01:13.520 --> 00:01:13.700
Dave?

00:01:15.180 --> 00:01:15.360
Hey,

00:01:15.560 --> 00:01:16.400
I'm Dave Peck.

00:01:16.680 --> 00:01:21.040
I'm a freelance software developer based in sunny Seattle, Washington.

00:01:22.260 --> 00:01:32.400
A freelance software developer is a polite way of saying I'm a computer weirdo, And I get to get into hopefully all kinds of good computer mischief, like working with Jim and Paul on new peps for Python.

00:01:34.700 --> 00:01:35.140
Awesome.

00:01:35.730 --> 00:01:36.380
Great to have you here.

00:01:36.560 --> 00:01:40.260
And always good to have another person from the Pacific Northwest.

00:01:41.179 --> 00:01:42.060
Jim, welcome.

00:01:43.220 --> 00:01:43.360
Hi.

00:01:44.120 --> 00:01:46.620
So, yeah, I'm a longtime Python user.

00:01:47.700 --> 00:01:58.260
I used to be very actively involved in the Jython project, which let me really learn the internals of both Jython and CPython, since we had to maintain a compatible implementation.

00:02:00.220 --> 00:02:04.880
So, you know, got deep into things like compilers and the standard library.

00:02:05.819 --> 00:02:12.260
And, yeah, it's great to talk about template strings or T-strings with you today.

00:02:14.980 --> 00:02:16.320
Paul, welcome back.

00:02:16.570 --> 00:02:18.140
How many episodes have you been on? Many.

00:02:18.320 --> 00:02:19.900
I don't know. Not enough.

00:02:20.320 --> 00:02:21.560
because Brett's ahead of me.

00:02:23.080 --> 00:02:23.580
Brett Cannon,

00:02:23.660 --> 00:02:27.900
you're not allowed to be on Talk Python for five years until I catch up, and then you can come back.

00:02:29.740 --> 00:02:35.660
Well, you should also send your message to Anthony Shaw, who I think is currently on the leaderboard, number one.

00:02:35.760 --> 00:02:36.840
Yeah, and then you're talking with

00:02:36.840 --> 00:02:42.020
Chris McDonough, who was like episode three or something like that way back in the day.

00:02:42.170 --> 00:02:42.320
Exactly.

00:02:43.460 --> 00:02:44.440
Briefly, I'm Paul.

00:02:44.590 --> 00:02:45.160
Hi, I'm Paul.

00:02:46.340 --> 00:02:49.980
I am now head of developer advocacy at JetBrains, the PyCharm people.

00:02:50.180 --> 00:02:53.400
I make coffee for Jim and Dave on this project.

00:02:55.600 --> 00:03:05.400
I let Jim do all the big thinking, and I let Dave go out and explain to complainers that we heard the same complaints for F-strings back in the day.

00:03:06.780 --> 00:03:09.600
So this has been a super fun project to be on.

00:03:10.180 --> 00:03:12.620
Yeah, it's very exciting.

00:03:12.860 --> 00:03:15.640
I'm super interested to dive into it.

00:03:16.180 --> 00:03:17.920
Something I didn't really know a lot about.

00:03:18.390 --> 00:03:19.920
So, yeah, it'll be neat.

00:03:21.020 --> 00:03:28.860
hey Jim before we carry on just a logistical thing real quick could you do me a favor just turn down the volume a little bit I think there's a bit of an echo back on your side

00:03:28.860 --> 00:03:29.240
okay

00:03:31.319 --> 00:03:52.720
not so much you can't hear us but a little bit less hopefully that's good now yeah I'm sure it is well I'll let you know for some reason it's not okay well let's let's dive into it right what is what are T-strings and why do they exist?

00:03:56.000 --> 00:03:56.480
Weren't

00:03:56.480 --> 00:03:57.320
F-strings good enough?

00:03:57.620 --> 00:03:59.800
I mean, they look kind of like F-strings when we use them.

00:04:00.680 --> 00:04:01.840
Yeah, that's a great part

00:04:01.840 --> 00:04:02.520
about them, right?

00:04:02.520 --> 00:04:03.680
They look like F-strings.

00:04:04.160 --> 00:04:12.340
They behave a lot like F-strings in terms of technical issues like the scoping of the interpolation expressions.

00:04:13.540 --> 00:04:15.580
But they're not F-strings.

00:04:16.280 --> 00:04:17.280
in a very profound way.

00:04:18.660 --> 00:04:35.060
One of the things that we wanted to prevent was stuff like the classic XKCD comic about the Bobby Tables sequel injection, where it becomes a drop tables inadvertently.

00:04:35.700 --> 00:04:36.800
And we can get, yeah, exactly.

00:04:37.480 --> 00:04:39.380
- The traditional exploits of a mom.

00:04:39.960 --> 00:04:42.000
This is your mom, this is your son's skull calling.

00:04:42.280 --> 00:04:43.740
Did he break something well in a way?

00:04:44.640 --> 00:04:53.040
Yeah, and so this is, you know, the original language of the PEP actually referenced directly Bobby Tables in this comic.

00:04:54.320 --> 00:05:00.360
For whatever reason, we removed that, but we don't have to do that today in this conversation.

00:05:00.710 --> 00:05:02.620
It was a big driver for this work.

00:05:03.070 --> 00:05:06.460
And the reason is that S-strings are great.

00:05:07.100 --> 00:05:13.960
They're great for formatting, but they're also sort of a trap, I think, for people to use.

00:05:14.140 --> 00:05:29.980
because it's you're formatting things, everything is working, and, oh, by the way, you just introduced the HTML injection or SQL injection, or you just happen to have something that doesn't format properly because you didn't consider a particular corner case.

00:05:30.660 --> 00:05:48.440
What we really wanted to do was move a lot of that out of, like, the usual user experience and into a library that could go, you know, some library, something for HTML, something for SQL, something for some other domain-specific language that would allow it to go and handle that appropriately.

00:05:49.280 --> 00:05:53.400
We'll get into more about what that means, I guess, throughout this conversation.

00:05:53.660 --> 00:05:55.220
But that's really where we started.

00:05:55.240 --> 00:06:00.040
We wanted the simplicity of using F-strings.

00:06:00.760 --> 00:06:04.760
We can get into more about what that means, but without some of the hazards.

00:06:07.340 --> 00:06:08.960
Excellent, excellent introduction.

00:06:09.840 --> 00:06:12.060
And it's important that this is part of the language.

00:06:12.620 --> 00:06:20.600
it's officially accepted in Python 3.14 oh will the jokes overflow about Py this version of Python

00:06:21.620 --> 00:06:23.020
it's a special commemorative

00:06:23.020 --> 00:06:24.080
edition of Python

00:06:24.540 --> 00:06:24.720
we're

00:06:24.720 --> 00:06:52.120
so glad to get into it that's right, it's super cool so it's going to be part of the language and the reason I bring this up is it seems like it needs to be part of the language not just an external library to really take advantage of it and not be just some API you construct strings in some weird string builder way, but through literally just, quote, start typing stuff, that has to be part of the language, right?

00:06:53.199 --> 00:06:54.580
Yeah, that's exactly right.

00:06:54.800 --> 00:06:57.540
I mean, as Jim mentioned, F-strings are wonderful.

00:06:57.800 --> 00:06:59.280
The syntax is powerful. It's robust.

00:06:59.920 --> 00:07:02.280
It became very popular because of that.

00:07:03.200 --> 00:07:10.260
But, of course, there are these foot guns of using them for, you know, SQL and HTML where you might run into some injection problems.

00:07:11.460 --> 00:07:22.620
With T-strings, the key difference is that while F-strings evaluate to the standard string type, T-strings evaluate to a new type that should be in Python 3.14 later this year called template.

00:07:23.440 --> 00:07:31.400
And so while they look like the literal form looks like any other string, they're quite different in that respect.

00:07:31.660 --> 00:07:43.320
And the key thing about the template type is it lets you, as a programmer, decide what parts of the string were statically authored and what parts of the string were dynamically substituted or interpolated.

00:07:43.840 --> 00:07:47.520
And so just being able to do that as a language feature is a really big deal.

00:07:47.680 --> 00:07:49.780
It's not something you can do with f-strings directly.

00:07:50.900 --> 00:07:55.300
And once you know those things, you can start to say, okay, this is a SQL statement.

00:07:55.500 --> 00:08:02.360
maybe I need to do something with the interpolation like escape its value before I construct the final string that I'm going to send over to my database.

00:08:05.140 --> 00:08:11.060
Yeah, if somebody were to work with an fstring, it does the cool interpolation at runtime.

00:08:13.880 --> 00:08:22.180
However, the thing that your API or any sort of code gets access to is just the resulting string that comes out.

00:08:22.240 --> 00:08:27.900
And I think this is probably the biggest piece of understanding that people need to wrap their heads around.

00:08:28.840 --> 00:08:32.039
We'll dive into some of the things people do need to wrap their heads around and how it's different.

00:08:33.059 --> 00:08:39.440
But instead of getting just here's the string result, which who knows why it says --drop table there.

00:08:39.959 --> 00:08:41.200
Maybe that's what they want.

00:08:41.840 --> 00:08:42.340
You don't know.

00:08:43.020 --> 00:08:43.120
Right?

00:08:43.260 --> 00:08:45.440
But here you would have here's part of the string.

00:08:45.980 --> 00:08:48.900
And then here's a place where a value goes with a name.

00:08:49.000 --> 00:08:54.380
And that thing, if you look it up by name, its value is --drop tables.

00:08:54.660 --> 00:08:57.100
Well, maybe we'll escape that or whatever.

00:08:57.250 --> 00:08:57.820
You know what I mean?

00:09:00.280 --> 00:09:00.440
Right.

00:09:00.580 --> 00:09:04.820
You and Brian covered it twice in Python bytes.

00:09:05.060 --> 00:09:13.460
And the first time, I'm going to exaggerate a little bit, but Brian was like, what is this for?

00:09:13.750 --> 00:09:13.860
I

00:09:13.860 --> 00:09:14.420
don't get it.

00:09:14.520 --> 00:09:15.040
Why do we need it?

00:09:15.560 --> 00:09:16.160
We have enough, right?

00:09:16.210 --> 00:09:16.480
The second

00:09:16.480 --> 00:09:18.580
time, Brian was like, oh, I get it now.

00:09:19.619 --> 00:09:20.019
and

00:09:20.019 --> 00:09:22.240
there's going to be a lot of that Paul we certainly have some explaining

00:09:22.240 --> 00:09:23.180
to do but

00:09:23.180 --> 00:09:29.240
yeah there's going to be a lot of this like why are we doing this what's that sorry sorry there's going to be a lot of that there's going to be a

00:09:29.240 --> 00:09:29.780
lot of like we

00:09:29.780 --> 00:09:31.960
already have f strings what is this yep

00:09:31.960 --> 00:10:02.160
sure an f string gives you a string a template string gives you a template and then later you will get a string later means going through a function they can go and do cool things for you like escape values or if you're doing an html templating system pass it a dictionary and it will generate a style attribute with some policies along the way or pass it a false or a boolean and it will elide the entire thing

00:10:02.160 --> 00:10:02.460
or

00:10:02.460 --> 00:10:14.980
do all kinds of other things having the template structure that dave described gives business value dsls a chance to step in and operate on structure rather than strings.

00:10:17.380 --> 00:10:24.000
So when I write this code, I say value equals T, some interpolated string sort of thing.

00:10:25.120 --> 00:10:32.600
Is it interoperable with a string in the sense that if I have a function that expects a string, could I pass it?

00:10:33.100 --> 00:10:38.040
Much like path from pathlib kind of goes where string file names go,

00:10:38.440 --> 00:10:39.180
or does

00:10:39.180 --> 00:10:41.340
the thing working with it need to know

00:10:42.620 --> 00:10:43.120
it needs

00:10:43.120 --> 00:10:50.820
to be transformed like you say process this to a SQL statement or process this to an HTML fragment and then you get a string.

00:10:52.220 --> 00:11:08.520
Yeah, and for templates the answer is very intentionally they are not the same as strings and so library authors are going to have to update their SQL libraries and their HTML libraries to expect this new template type and that's very intentional.

00:11:09.040 --> 00:11:12.520
The other thing I would say is that templates don't have a direct route to string.

00:11:12.670 --> 00:11:18.740
So if you call str of template, you just get the default repper back, right?

00:11:18.920 --> 00:11:23.760
Which is probably not something you want to be showing your users or it's not HTML that you're trying to render.

00:11:24.790 --> 00:11:24.940
And

00:11:24.940 --> 00:11:27.480
that's, again, very intentional.

00:11:27.540 --> 00:11:30.940
It's also unlikely to cause injection attacks and whatnot as well

00:11:30.940 --> 00:11:32.020
when you're getting that repper.

00:11:32.620 --> 00:11:38.240
So much, all those parentheses and braces and whatnot, not likely to happen.

00:11:39.440 --> 00:11:40.320
Yeah, absolutely.

00:11:40.820 --> 00:11:46.380
And so library authors will have to update their libraries to add new methods that expect this template type.

00:11:46.620 --> 00:11:49.560
And presumably those methods won't also take a string.

00:11:50.160 --> 00:12:01.340
You know, if you're concerned about injection vulnerabilities, presumably you want to take this new dynamic template type that tracks what parts of the string are interpolated and what parts came from the developer themselves.

00:12:03.200 --> 00:12:04.100
Right. And treat them differently.

00:12:05.340 --> 00:12:05.540
Yeah.

00:12:06.420 --> 00:12:07.180
Yeah. Very interesting.

00:12:08.380 --> 00:12:10.580
So let's just talk about that a little bit.

00:12:10.580 --> 00:12:17.820
I see some use cases in the chat, but maybe we could list out some more.

00:12:18.640 --> 00:12:25.640
So for example, Nym4 says structured logging, preventing cross-site scripting, SQL injection.

00:12:26.340 --> 00:12:28.320
What are some of the motivations here?

00:12:31.600 --> 00:12:33.440
Yeah, those are all great use cases.

00:12:34.300 --> 00:12:35.840
Any type of injection vulnerability.

00:12:36.160 --> 00:12:38.880
So SQL and HTML were obviously at the top of our minds.

00:12:38.980 --> 00:12:50.000
But another one that, in fact, there's potentially a new PEP coming around for that's being discussed right now on the Python discussion boards has to do with command injection.

00:12:50.180 --> 00:12:55.740
So when you shell out, you're worried about the user-provided values there as well.

00:12:57.720 --> 00:12:58.140
Give me a sec.

00:12:58.140 --> 00:12:59.560
I'll try and remember what the actual

00:12:59.560 --> 00:13:00.160
PEP is.

00:13:00.480 --> 00:13:01.680
There's os.system.

00:13:02.360 --> 00:13:02.780
And then you

00:13:02.780 --> 00:13:05.640
can give it a command like echo some string from the user.

00:13:06.080 --> 00:13:12.220
But it could, of course, be some string, quote, ampersand, ampersand, rm

00:13:12.220 --> 00:13:14.100
-rf, or something

00:13:14.100 --> 00:13:14.760
like that, right?

00:13:16.520 --> 00:13:34.260
And, of course, as Paul mentioned, once you have the tools to help you prevent injection vulnerabilities in sort of a more general way in this general purpose fashion, you also have the ability to do all kinds of other fun and powerful things like what Paul mentioned with HTML, which is, hey, I don't just want to write a single attribute.

00:13:34.500 --> 00:13:39.240
I want to give you a dictionary, and you write 20 attributes based on the contents of my Python dictionary.

00:13:40.600 --> 00:13:42.980
And there's no reason you can't do that now, which is exciting.

00:13:44.900 --> 00:13:45.120
Yeah, I

00:13:45.120 --> 00:13:45.580
would add to

00:13:45.580 --> 00:14:05.660
that if you wanted to, for example, do some interesting complex analytical SQL, where you're using common table expressions, or even you just want to go and have your analytical SQL, I want to be able to do it on this column name versus some other column name.

00:14:06.340 --> 00:14:09.280
We want to make it possible to do that in a safe fashion.

00:14:10.540 --> 00:14:25.480
These are things that are difficult to express with some of the typical wrappers that we might use with SQL, like SQLAlchemy, maybe like, I don't think you can really do like CTEs and Django query sets and whatnot.

00:14:25.550 --> 00:14:45.800
But what I'm trying to say is that both of those tools do allow you to access raw SQL, But now you need to be able to compose that raw SQL in a way that's safe and uses the information about where this interpolation is happening in order to properly put it in place.

00:14:46.040 --> 00:14:59.720
So if you are in a situation where maybe that CTE is something you can access, you can go and say, okay, I can insert it into the SQL or maybe a little more common usage here for a lot of people.

00:14:59.880 --> 00:15:01.780
I don't know how many people use common table expressions.

00:15:02.290 --> 00:15:02.600
I do.

00:15:03.820 --> 00:15:11.620
Is to go and, you know, I just want to, again, select from this particular table name or this particular column name in a safe fashion.

00:15:11.820 --> 00:15:17.080
Or I want to go and use values that can't be properly expressed with placeholders.

00:15:17.780 --> 00:15:23.440
But maybe if I use, like, a, you know, a temporary table to insert it in.

00:15:24.040 --> 00:15:27.180
These are all techniques that we use when we do this sort of work.

00:15:27.620 --> 00:15:37.720
But now we have this opportunity to bring it into directly in the library and then make it possible for users to use it without really having to think, where did this come from?

00:15:37.820 --> 00:15:45.020
How do I go and make this such that it can be used in a where in clause, for example, that sort of thing?

00:15:47.899 --> 00:15:48.620
If I may,

00:15:48.740 --> 00:15:53.080
real quick, I got to give Jim a lot of credit on this as we've gone through the years on this.

00:15:53.400 --> 00:15:58.380
And Jim taught programming languages at University of Colorado Boulder.

00:15:58.420 --> 00:16:06.160
And so he knows all these patterns and all these languages and the implementations from his Jython years and stuff.

00:16:07.040 --> 00:16:17.620
And even now, he's still talking in chat about, hey, you know, last year he was talking about how domain-specific languages could apply to pandas and other data science stuff.

00:16:17.740 --> 00:16:26.020
And now he's talking about LLM interactions and chat and stuff like that, where you've got a little language, but it's got a little bit of structure.

00:16:26.680 --> 00:16:36.340
And what if you could, and then 500, you know, discourse, discord messages later, Jim has invented something new and interesting.

00:16:37.920 --> 00:16:38.240
Incredible.

00:16:40.920 --> 00:16:55.500
So it seems to me like there's also some interesting possibilities for like lazy evaluation, for also some possibilities for like query optimization.

00:16:55.740 --> 00:17:06.560
You know, Jim was talking about databases, but there's a lot of different things, both from a performance perspective, but also potentially just from a tightly versus loosely coupled systems.

00:17:07.480 --> 00:17:14.319
Like maybe you could say something to the effect of like, and the username goes here, but that part of the system logging doesn't know what the username is.

00:17:14.839 --> 00:17:23.300
But somehow as the template gets rendered, the additional pieces could get filled in with real details like the IP and the username is actually this.

00:17:23.430 --> 00:17:29.740
Because over here we know, but when the logging happened, we got a template that just said, well, whatever you figure out, it goes here.

00:17:31.000 --> 00:17:32.400
How much of those things are possible now?

00:17:32.500 --> 00:17:37.980
Could you look at the structured bit of SQL and say, well, if we reorder this or if we put

00:17:37.980 --> 00:17:39.740
something

00:17:39.740 --> 00:17:47.920
about, you know, some kind of SQL hint or something about indexes or other things in there, could you maybe get more from it?

00:17:53.360 --> 00:17:57.500
I was thinking someone might else answer this, but I will go for this.

00:17:57.720 --> 00:17:59.180
I mean, I think that's possible to do.

00:18:01.220 --> 00:18:13.060
In terms, you know, often we, you know, again, if we're thinking about SQL, we would, you know, dispatch this to, you know, some sort of, you know, the internal optimizer and, you know, whatever database you're working with.

00:18:13.580 --> 00:18:39.820
But, you know, again, using the SQL example, there are multiple ways that you could potentially interface some more interesting, complicated ways of interacting with SQL that are kind of hard to, you know, either you can't express easily with placeholders, you know, the standard name placeholders or positional placeholders in SQL.

00:18:40.800 --> 00:18:48.620
Or just, you know, basically you find people going and composing SQL and, you know, doing it in a bad way.

00:18:49.250 --> 00:19:03.120
But if you were to go and, you know, there's like a popular tool called SQL Glot, for example, that allows you to take SQL, re-express it as an abstract syntax tree, and then what can you do with that?

00:19:03.700 --> 00:19:10.540
Well, you know, the interesting thing about, you know, what we do with T-strings is it can be a front end.

00:19:10.960 --> 00:19:11.680
to such tools.

00:19:12.900 --> 00:19:29.220
So T-strings themselves are, you know, intentionally designed to have just this very limited, but at the same time, you know, let's say, you know, very powerful, you know, integration with Python, right?

00:19:29.470 --> 00:19:36.180
You have, you know, effectively an F-string specification of, you know, what's going to describe that template.

00:19:36.800 --> 00:19:38.260
You describe the interpolations.

00:19:38.890 --> 00:19:40.340
They can be nested and everything.

00:19:40.440 --> 00:20:07.260
but fundamentally at the end of the day you get this template object out of it which could be tested and whatnot but it's still this simple straightforward thing and then you pass it to a function that can do interesting things with that from a performance perspective that's also something that we intentionally put together I don't know Dave if you want to talk about that what we did specifically for that because I think that might be something you want to speak to

00:20:07.660 --> 00:20:14.960
yeah absolutely Well, if you take a look at what's inside the template type, there are basically two tuples that sit there.

00:20:15.320 --> 00:20:19.540
There's a tuple called strings and a tuple called values or interpolations.

00:20:19.740 --> 00:20:20.720
You can kind of work both ways.

00:20:22.260 --> 00:20:27.300
And so as you might expect, the strings are the static parts that are part of the literal string that you specify.

00:20:28.140 --> 00:20:31.460
And the values or interpolations are the dynamic parts.

00:20:32.540 --> 00:20:43.220
And we kind of made it so that no matter how you write your literal, it's always the case that there is at least one string in that strings tuple, even if it's the empty string.

00:20:43.680 --> 00:20:52.460
So T quote, quote, gives you a template with no interpolations, with an empty tuple for interpolations, and with just a single quote for strings.

00:20:54.100 --> 00:20:58.740
And we ensure that there's always one more string than there are values or interpolations.

00:20:59.340 --> 00:21:07.700
And the reason we do that is that allows you to, basically, the strings tuple becomes a useful cache key in many cases for memorizing.

00:21:08.280 --> 00:21:18.560
So if you process a template once with your HTML function, you might sit back and say, okay, I've seen this structure of HTML before, and the next time I do it, all I need to do is fill in the gaps.

00:21:19.840 --> 00:21:26.260
And so that we think is just like a really basic optimization that you can use, and we're seeing that use.

00:21:26.360 --> 00:21:33.660
Paul, you might want to mention the TDOM library that I know you and others have been working on in the last little while.

00:21:34.200 --> 00:21:37.280
But it's just a basic optimization that we can offer.

00:21:38.920 --> 00:21:49.940
I think it is worth calling out, though, that, and I know we mentioned this earlier, but probably worth calling out once more just to make it explicit, that T strings like f-strings are eagerly evaluated, right?

00:21:50.160 --> 00:21:52.660
So if you have hello,

00:21:53.120 --> 00:21:54.120
curly

00:21:54.120 --> 00:21:59.200
braces name, and name isn't in scope, you will get a name error, just like with an F string.

00:22:00.560 --> 00:22:05.400
And so you might say, well, that feels a little weird to me because don't I want to reuse these things multiple times?

00:22:05.940 --> 00:22:11.860
And this is one of those cases where the word template is just an overloaded term in the computing world.

00:22:12.780 --> 00:22:21.260
And so if you're coming from the Jinja world or the Django templates world, you're probably used to the idea that I have this structure and I'm going to keep substituting values into it.

00:22:22.320 --> 00:22:28.200
And that's a little bit different than the other use of the word template, which comes from, say, the JavaScript side of the world.

00:22:28.360 --> 00:22:30.660
So JavaScript has tag template literals.

00:22:30.880 --> 00:22:34.200
If you've written any JavaScript code, you've probably run across them before.

00:22:35.240 --> 00:22:38.480
And there, like with T-strings, they're eagerly evaluated.

00:22:39.140 --> 00:22:42.360
So, you know, of course, you have the full generality of Python available to you.

00:22:42.820 --> 00:22:52.560
So you can just write a function that takes the parameters that you want to substitute and returns a T-string, call it multiple times with different values, and you'll get different template instances out the other side.

00:22:52.840 --> 00:22:59.180
Probably just worth calling that out so that it's clear to listeners that there is this kind of funny overloading of the word template.

00:22:59.880 --> 00:23:01.860
But yeah, back to the point about optimization.

00:23:02.460 --> 00:23:17.500
We're pretty excited about just the basic opportunities for building optimized template processing code, like an HTML function or a SQL function that works on top of this basic structure that we provide in PEP 750.

00:23:19.520 --> 00:23:28.160
Yeah, and I think one thing you can think about is that, again, we may be getting a little too into the weeds here, but let's get into the weeds.

00:23:29.520 --> 00:23:36.520
You can think about, you know, the template as basically providing, you know, this interesting way of describing your arguments.

00:23:37.360 --> 00:23:37.660
All right.

00:23:38.260 --> 00:23:43.160
And then you pass it to some sort of function, HTML, SQL, you name it.

00:23:43.620 --> 00:23:43.740
Right.

00:23:44.220 --> 00:23:48.240
And basically it's going to, you know, evaluate with respect to those arguments.

00:23:48.960 --> 00:23:49.060
Right.

00:23:49.640 --> 00:24:04.020
But, you know, if you, so we basically, you know, if I have an HTML function, I'm going to want to look it up with that dot strings, template dot strings.

00:24:05.020 --> 00:24:09.000
Say I parsed this, and I know how to go and work with this fragment.

00:24:09.140 --> 00:24:19.000
I already know where all the pieces need to go, the holes that need to be filled in by these interpolations, and it could be done very quickly.

00:24:20.160 --> 00:24:25.480
And so we've put a lot of effort in terms of thinking about what is that optimization path?

00:24:26.000 --> 00:24:27.440
and there's also related aspects.

00:24:27.880 --> 00:24:35.460
Why is this another reason this is built into the language is because you can get lexical scope as opposed to dynamic scope.

00:24:36.040 --> 00:24:44.400
You think that lexical, you know, you might think that dynamic scope is always the thing that's going to work for you, but no, this is the thing that, you know, brought Paul and I together on this project.

00:24:45.080 --> 00:24:50.680
It's exactly, you know, you can't use dynamic scope when you would expect it.

00:24:51.220 --> 00:24:56.480
So yeah, if we want to go to that scope issue when calling components, from list comprehension.

00:24:57.420 --> 00:25:03.000
So, Paul, if you want to speak to this a little bit in terms of the problems you experienced.

00:25:04.720 --> 00:25:21.780
Sure, and this is, oh my gosh, Jim in the first round of this and Dave in the second round of this and the PEP and the comments, this damn thing had more comments on it than every other PEP in the history of civilization.

00:25:22.480 --> 00:25:23.480
Almost, it felt that way.

00:25:23.920 --> 00:25:30.420
Major changes between the first draft and the second draft from lazy evaluation, from tag, template functions, all those things.

00:25:32.180 --> 00:25:38.180
But one that comes up pretty frequently is, I could just do this with this skip frame.

00:25:40.000 --> 00:25:43.440
And you can, but you can't, and you shouldn't either way.

00:25:44.520 --> 00:25:53.520
But there is a nuance about scoping that bit me right here on the screen in this ticket that was the origin story of Jim and I talking to each other.

00:25:53.880 --> 00:26:07.000
2020, a predecessor that mimicked T-strings in sysget frame from the people behind the JavaScript package called HTM.

00:26:07.860 --> 00:26:19.800
They did a port to Python called HTMPy for doing powerful template languages kind of closer to the language, something that in the JavaScript world, this is a replacement for JSX.

00:26:19.800 --> 00:26:20.820
It doesn't need tooling.

00:26:21.160 --> 00:26:25.460
So they wanted to bring that kind of experience, language-centric templating.

00:26:25.980 --> 00:26:30.400
They wanted to bring it to Python, but hit this issue about scope.

00:26:33.020 --> 00:26:33.100
Yeah.

00:26:33.540 --> 00:26:38.060
Yeah, and it seems like it's just this obscure thing, but it isn't.

00:26:38.230 --> 00:26:40.300
You know, you use a nested function, it pops up.

00:26:40.380 --> 00:26:43.060
Use a generator expression, it pops up.

00:26:43.900 --> 00:26:45.780
Use a list comprehension, it pops up.

00:26:46.110 --> 00:26:50.440
So things that you might commonly want to use, now you need to know you shouldn't do that.

00:26:50.760 --> 00:26:55.260
So that's one thing. The second thing is it's slow. And it basically also breaks

00:26:55.260 --> 00:26:56.380
a lot of optimizations

00:26:56.380 --> 00:27:01.100
that have been introduced into Python in recent years. So you don't want to do that either.

00:27:02.840 --> 00:27:05.500
And the creator of this hack, Barry said, don't use this hack.

00:27:06.580 --> 00:27:07.580
Well, I mean,

00:27:07.740 --> 00:27:12.960
there are good reasons to go and use sysgit frame, and especially there are historical good reasons.

00:27:13.620 --> 00:27:25.720
But I think we have, you know, again, so it's something that comes up because, you know, if you have dug into the internals of Python, you've looked at the inspect, you know you can do certain things.

00:27:27.140 --> 00:27:27.280
Great.

00:27:27.660 --> 00:27:31.900
And I think that's a fantastic way to explore new capabilities.

00:27:33.860 --> 00:27:36.940
But it is not necessarily what you want to go rely on because,

00:27:37.420 --> 00:27:38.200
you know, again,

00:27:38.380 --> 00:27:43.980
the theme I would have taught in the class, what is the difference between dynamic and lexical scope?

00:27:44.520 --> 00:27:46.180
Well, here's where it really bites you.

00:27:49.700 --> 00:27:49.880
Yeah.

00:27:50.160 --> 00:27:53.620
Well, let's talk about HTML templates.

00:27:53.740 --> 00:27:56.320
Because I know, Paul, that was a lot of your interest in this, right?

00:27:56.980 --> 00:27:57.160
Yeah.

00:27:58.880 --> 00:27:59.080
Indeed.

00:27:59.840 --> 00:28:02.900
Michael, you and I are like web originalists, right?

00:28:03.380 --> 00:28:03.780
That's right.

00:28:04.500 --> 00:28:05.960
you're a big fan of Chameleon.

00:28:06.380 --> 00:28:11.740
Whenever you encounter a new web framework, the first thing you do is make a package for that that gives it Chameleon

00:28:11.740 --> 00:28:12.260
support.

00:28:13.140 --> 00:28:13.580
That's right.

00:28:13.620 --> 00:28:19.200
You want FastAPI, just put the FastAPI Chameleon decorator on there and you're back to a proper language.

00:28:19.860 --> 00:28:20.040
Yeah.

00:28:22.620 --> 00:28:31.420
But my feeling has been that Python web development, particularly templating, is stuck in the early 2000s.

00:28:32.680 --> 00:28:34.060
I went and looked up recently.

00:28:34.780 --> 00:28:37.760
I think Jinja was first released in 2008.

00:28:38.700 --> 00:28:46.620
And there was a feeling back then that HTML and web design was something different than software.

00:28:48.820 --> 00:28:52.080
Separation of concerns, but more importantly, separation of people.

00:28:52.680 --> 00:28:55.780
You wanted to keep the templating people away from the software people.

00:28:55.960 --> 00:28:58.700
You've got your designers and you've got your developers.

00:28:58.950 --> 00:29:00.780
And they exchange through CSS.

00:29:00.960 --> 00:29:01.420
They give you this

00:29:01.420 --> 00:29:03.580
sandbox where you can't break things.

00:29:03.670 --> 00:29:06.740
And it's going to be like Python, but not really Python.

00:29:07.540 --> 00:29:07.740
Yeah.

00:29:08.380 --> 00:29:11.000
And the world doesn't work that way anymore.

00:29:11.260 --> 00:29:13.860
Front-end development is software.

00:29:14.920 --> 00:29:16.980
In the JavaScript world, it's software.

00:29:17.220 --> 00:29:17.880
It's components.

00:29:18.820 --> 00:29:19.440
It's tooling.

00:29:20.940 --> 00:29:22.140
It's testing.

00:29:22.780 --> 00:29:27.900
It's all of these things where people expect powerful tooling as part of software.

00:29:28.960 --> 00:29:29.740
We haven't.

00:29:30.600 --> 00:29:37.940
And there have been some things starting to get into this area, but this was what I was originally interested in, what Jim and I had talked about quite a bit.

00:29:38.060 --> 00:29:39.760
Dave comes from a similar background.

00:29:40.760 --> 00:29:48.360
And we want, in a general sense, we want DSLs, domain-specific languages, that are closer to Python.

00:29:49.720 --> 00:29:52.760
So when you say, here's a symbol, it's a symbol.

00:29:53.580 --> 00:29:55.900
And you know the scoping rules because it's just Python.

00:29:56.080 --> 00:29:58.580
It isn't some invented scoping rule.

00:29:59.680 --> 00:30:05.740
And you can use your formatter on it, and you can use mypy on it, and you can use all blah, blah, blah.

00:30:05.840 --> 00:30:11.480
You can get IDE assistance on it because it's just Python.

00:30:12.580 --> 00:30:27.380
And so that, from an HTML perspective and a web perspective, we're trying to move from PSP, JSP, PHP-style templating as a separate non-Python concern over into this new world.

00:30:28.280 --> 00:30:29.480
Dave, how did I do on that?

00:30:29.620 --> 00:30:30.680
Do you buy what I just sold?

00:30:30.960 --> 00:30:32.420
I absolutely buy it.

00:30:32.460 --> 00:30:51.580
And like Paul mentioned, that's sort of how I came into this crazy rollercoaster ride too, which is I had been working with a number of nonprofits over the last couple of years, building Python backends, doing a lot of front-end development with Python code, and feeling like, and in particular, one of the projects I worked on a couple of years ago used HTMX.

00:30:51.660 --> 00:30:54.020
I think it was one of my first experiences with HTMX.

00:30:55.180 --> 00:31:01.860
And for those who haven't used it, you often write big templates, And then occasionally you need to send lots of little blobs of HTML back.

00:31:02.200 --> 00:31:12.660
And it really starts to get difficult to use a tool like Jinja or a tool like Django templates to produce lots of little blobs of HTML while still keeping everything cleanly organized.

00:31:13.240 --> 00:31:17.020
You end up with lots of sort of include statements or Jinja macros.

00:31:17.540 --> 00:31:25.860
And those are great, powerful features, but they aren't quite as powerful as what Paul was saying, which is the full generality of the Python programming language to begin with.

00:31:26.420 --> 00:31:34.740
And so, you know, we started resorting to using HTML builders like HTTPY in my case, but there are a few others, Dominic and others.

00:31:36.000 --> 00:31:44.820
And those felt great, but they also felt to me like what building web stuff felt like in the JavaScript ecosystem circa 2010, right?

00:31:45.320 --> 00:31:50.920
Before tag template strings came along and ultimately in the JavaScript world before JSX came along as well.

00:31:52.320 --> 00:31:55.700
And so it did feel like there was really an opportunity to revisit that question.

00:31:55.980 --> 00:32:03.420
And that's sort of how I found Jim and Paul who were thinking about this stuff and had been thinking about this stuff for far longer than I in the Python ecosystem.

00:32:05.120 --> 00:32:05.540
Yeah, very neat.

00:32:05.540 --> 00:32:07.540
I pulled up an example from Vue.js.

00:32:09.540 --> 00:32:11.778
And Dave, you mentioned HTMX.

00:32:12.760 --> 00:32:13.520
And one of the

00:32:13.520 --> 00:32:14.840
big

00:32:14.840 --> 00:32:20.080
ideas that Carson Gross from HTMX promotes is a locality of behavior.

00:32:20.420 --> 00:32:25.300
Like I should be able to look kind of here on my editor and see all the stuff's going on.

00:32:25.480 --> 00:32:30.360
There shouldn't be four different places and then a convention that pulls in a fifth place that then makes a thing happen.

00:32:31.760 --> 00:32:37.020
And there's a lot of that in the JavaScript world of like, well, here's your behavior.

00:32:37.180 --> 00:32:44.580
And literally here's the fragment of HTML that we're going to work on with capturing values and different substitutions and stuff.

00:32:45.220 --> 00:32:48.000
And it feels like new templating.

00:32:49.720 --> 00:32:51.460
You're the one who said this is overloaded, right?

00:32:52.000 --> 00:32:52.140
Yeah.

00:32:52.440 --> 00:33:04.520
New templating options like Chameleon 2 or Jinja 3 or whatever could come along and build on the ideas using some of the things here.

00:33:07.320 --> 00:33:07.940
Yeah, absolutely.

00:33:08.140 --> 00:33:14.140
And I'm really hoping we see an explosion of that as after Python 3.14 ships out the door.

00:33:15.960 --> 00:33:27.280
So a lot of this work that the three of you plus others, I want to be super clear that there are other folks at the top of this PEP here about this who have also put a lot of work into it.

00:33:29.340 --> 00:33:29.780
Yeah,

00:33:29.840 --> 00:33:30.420
not just at

00:33:30.420 --> 00:33:43.980
the top of the PEP, but also, of course, the broader Python community in the discussions without which, and Paul mentioned the discussions are longer than for any PEP, but without that community feedback, I don't think we'd have landed where we are now.

00:33:47.340 --> 00:33:49.960
So if I print this, how long would this be?

00:33:51.280 --> 00:33:52.040
How many pages?

00:33:53.580 --> 00:33:58.020
206 pages to print the discussion of the

00:33:58.020 --> 00:33:58.480
tag streams.

00:33:58.480 --> 00:33:59.180
And that was the first.

00:33:59.190 --> 00:34:00.040
There were two discussions.

00:34:01.000 --> 00:34:01.160
Yeah.

00:34:02.020 --> 00:34:03.360
Even better than the novella.

00:34:06.280 --> 00:34:07.040
Yeah, that's incredible.

00:34:09.020 --> 00:34:10.159
Also great feedback

00:34:10.159 --> 00:34:14.820
in other locations as well that we were also really trying to respond to.

00:34:15.340 --> 00:34:17.720
You know, they were talking about Reddit or Hacker News.

00:34:19.880 --> 00:34:22.500
And a lot of credit to Jim on this.

00:34:22.580 --> 00:34:28.220
In the first round, Jim was really about lazy evaluation.

00:34:30.060 --> 00:34:41.200
And it was part of bigger ideas about inside out or outside in rendering and streaming and generators and a lot of things connected in his brain about it.

00:34:41.879 --> 00:34:49.280
And there was a lot of practical pushback, including Astral, about, hey, we're going to struggle to statically analyze that for Ruff.

00:34:50.320 --> 00:34:55.820
And Jim thought about it pretty hard and talked with Dave a lot and talked with others about it and

00:34:55.820 --> 00:34:57.000
rolled that back.

00:34:57.880 --> 00:34:58.420
Wow.

00:34:59.660 --> 00:35:10.780
So there's a difference between, there's a difference here between lazy, which is they're evaluated eagerly, these T-strings, but could maybe.

00:35:12.520 --> 00:35:15.020
and async, right?

00:35:16.460 --> 00:35:19.120
So can we do async stuff on our strings?

00:35:19.340 --> 00:35:23.340
Like you have to call a function, given a template to render text.

00:35:23.530 --> 00:35:25.280
That seems like you could just write that, yeah?

00:35:32.100 --> 00:35:33.000
Jim, you take this one.

00:35:35.940 --> 00:35:36.660
Let me unmute myself.

00:35:37.080 --> 00:35:43.180
So yeah, I mean, the basic thing here is that these are expressions that can be evaluated, right?

00:35:43.520 --> 00:35:53.200
And so just because you have a, you know, I'll go for something that's even, you know, broader than this.

00:35:53.320 --> 00:35:58.540
You look at something like, you know, common pattern like Django's query set, right?

00:35:59.980 --> 00:36:05.400
So it's lazily evaluated until you actually go and actually look at its contents.

00:36:06.500 --> 00:36:08.480
A query doesn't even happen, right?

00:36:09.040 --> 00:36:12.400
in terms of against the underlying SQL engine that you're using.

00:36:15.000 --> 00:36:22.160
And the point is that we can have laziness where we Lambda Wrap it.

00:36:22.280 --> 00:36:26.200
That was the original idea, and there's a lot of potential value in that.

00:36:27.260 --> 00:36:35.280
But there's also this aspect that, in general, the Python community has come up with a number of ways to incorporate laziness.

00:36:37.600 --> 00:36:47.400
And specifically through, maybe it's an iterable, maybe it's a query set that is also an iterable, maybe it's through the use of async expressions.

00:36:47.660 --> 00:36:56.780
These are all expressions that can be passed around and then used by something that is evaluating with respect to that.

00:36:58.800 --> 00:37:01.260
So T-strings don't change any of that, right?

00:37:02.200 --> 00:37:16.560
Because if you have that expression and it's been evaluated, but it's been lazily so, it can still be used for however you're going to work with that template in the function that operates on it.

00:37:19.320 --> 00:37:42.300
And I think this is just going to get at most of the things that I was thinking about when we were originally looking at this from this more lazily done way without the typing issues that ultimately we decided would make it too difficult to work with.

00:37:43.220 --> 00:37:48.780
So I think this is just something where we looked at what is the Python ecosystem?

00:37:49.400 --> 00:37:50.680
How will we help solve these problems?

00:37:52.880 --> 00:38:09.960
And even though I really wanted to go and have something that basically would allow for maybe some greater functionality along doing like a deferred or lazy type capability implicitly, that can be something else.

00:38:10.400 --> 00:38:14.300
We can bring – there are discussions around bringing in macros.

00:38:15.080 --> 00:38:24.100
You could implement that using coding on your file.

00:38:25.040 --> 00:38:26.220
I don't know where that goes.

00:38:27.060 --> 00:38:29.740
It might even interface with what we've done with T-strings.

00:38:30.160 --> 00:38:38.300
But the important thing is that you don't have to bring all that in in order to go and benefit from what we're doing with this.

00:38:39.040 --> 00:38:45.300
And by simplifying what we've done, I think we've come up with something that works a lot better.

00:38:45.840 --> 00:38:49.960
And I really value the great feedback we had from the community as far as that is concerned.

00:38:51.840 --> 00:38:52.180
Yeah, thanks.

00:38:52.740 --> 00:38:58.820
One of the things I hear a lot mentioned throughout the conversations and the PEP and stuff is DSLs.

00:38:59.800 --> 00:39:00.280
So

00:39:00.280 --> 00:39:01.560
a domain-specific language.

00:39:03.880 --> 00:39:10.940
And SQL is kind of a domain-specific language, but I think a lot of times people are thinking, something I make that is really simple, right?

00:39:11.120 --> 00:39:11.360
Maybe I

00:39:11.360 --> 00:39:11.780
want to make a

00:39:11.780 --> 00:39:15.380
language to talk to simple robots, right?

00:39:16.020 --> 00:39:27.700
And I want to use this to construct maybe a way to talk to it that's way simpler but easier to parse because you can say, well, here's where the where piece went or whatever, right?

00:39:27.900 --> 00:39:30.380
You can pull them out of the interpolations and the values and stuff.

00:39:31.720 --> 00:39:35.600
Can you guys talk to maybe some examples of what you had in mind or what might be possible there?

00:39:38.820 --> 00:39:39.560
This is good to me.

00:39:40.440 --> 00:39:47.860
So the Python has been a very popular tool for constructing two types of DSLs.

00:39:48.480 --> 00:40:00.340
One would be like the internal DSL that you see in Pydantic or SymPy, that sort of thing where it's basically taking advantage of operator overloading.

00:40:00.740 --> 00:40:01.740
So let's put that aside.

00:40:02.240 --> 00:40:12.720
We'll look at the other version, which is this external DSL, where we think about, again, canonically, HTML, SQL being pretty large targets.

00:40:13.380 --> 00:40:19.660
But if you look at the PyParsing project, you'll see, I don't know how many dozens of languages it supports.

00:40:20.240 --> 00:40:31.200
Not to mention the fact that it's straightforward to write your own grammar in it and parse it into an abstract syntax tree.

00:40:33.300 --> 00:40:45.680
Yeah, I mean, it's just like, as it says here, the use of parsing expression grammars really makes it very straightforward to write a cursor.

00:40:47.340 --> 00:40:56.120
So I highly recommend anyone who's interested in writing their own toy language or maybe have greater ambitions, look into tools like this.

00:40:56.140 --> 00:41:03.860
Because I think this is one of the fantastic advantages we have in the Python community is we have really great libraries like this that are widely used.

00:41:05.800 --> 00:41:12.900
And so for your example of writing something that would interface with a robot, absolutely.

00:41:13.560 --> 00:41:27.020
Absolutely. That's something that you could express and you think about like, would that potentially be even something where it could be useful for education, for example.

00:41:27.980 --> 00:41:30.160
And how would it work with, again, T-strings?

00:41:30.290 --> 00:41:35.180
Well, again, you would basically say there's this domain of things that we know from the Python space.

00:41:37.160 --> 00:41:42.400
We're computing maybe some velocity that we want the robot to move at.

00:41:43.140 --> 00:41:51.100
We're computing which color of brick that we want to pick up or whatever it happens to be.

00:41:52.140 --> 00:41:58.840
And we can basically say that that's something that's happening in our Python code directly.

00:41:59.240 --> 00:42:02.580
And then there's this language that we're using to talk to the robot.

00:42:04.720 --> 00:42:23.320
And what it looks like in terms of the T-strings is you basically are saying, Okay, I'm going to go and parse this language fragment with some parser that can be made to use placeholders that will work with interpolations.

00:42:25.519 --> 00:42:27.540
And I'm going to parse it.

00:42:27.910 --> 00:42:30.020
I'm going to get an abstract syntax tree out of that.

00:42:30.080 --> 00:42:41.860
I'm going to use that to then evaluate how I'm going to go and say, you know, send in a number or color or other information to that toy language or more ambitious language.

00:42:43.180 --> 00:42:52.820
And then send out, you know, whatever is necessary in order to, you know, complete that communication with, you know, the system that's implementing that.

00:42:53.820 --> 00:42:59.080
So it's going to be great for people who, you know, really love languages and, you know, want to play with them.

00:42:59.200 --> 00:43:05.020
And again, I would start with something like PyParsing as a great example of the type of tool you could use here.

00:43:06.140 --> 00:43:09.360
Excellent. Yeah, I'll put that link in the show notes so people can check it out.

00:43:12.360 --> 00:43:21.820
Yeah, maybe bringing it all back home for a second, or maybe just because I've got my head wrapped in building a slide deck for a lightning talk introduction to T-strings.

00:43:22.500 --> 00:43:34.260
But, you know, a common use case here when you're writing code that takes a template is not returning a string, but as Jim is kind of deeply hinting at here, parsing and returning some kind of abstract syntax tree.

00:43:34.310 --> 00:43:44.060
So in the HTML case, and you can actually find examples of this, for example, in the PEP 750 examples repository, there's an HTML function there, and it has a bunch of nice features.

00:43:44.620 --> 00:43:49.940
But you're returning an HTML element back from the code that processes the T string.

00:43:50.300 --> 00:43:55.380
You don't, in fact, have to grab a string out of a T-string right away or ever if you don't want to.

00:43:55.840 --> 00:44:00.960
So there's an immense amount of flexibility here that we're excited to see people use.

00:44:03.320 --> 00:44:05.600
Yeah, Dave, under your account on GitHub,

00:44:06.300 --> 00:44:06.660
Dave Peck.

00:44:07.040 --> 00:44:07.680
It needs to move.

00:44:08.360 --> 00:44:09.920
You know what? It's fine.

00:44:10.660 --> 00:44:11.760
It's just as good as anywhere.

00:44:12.480 --> 00:44:15.540
You have a bunch of examples of things you might do

00:44:15.540 --> 00:44:17.340
with

00:44:17.340 --> 00:44:17.700
these.

00:44:18.280 --> 00:44:19.460
And one of them is HTML.

00:44:20.480 --> 00:44:23.660
People can see how that might work and so on.

00:44:23.760 --> 00:44:25.840
And what are some of the other notable ones in here?

00:44:25.840 --> 00:44:26.920
I know I was looking through this earlier.

00:44:27.779 --> 00:44:33.180
Well, we wanted to show some basic examples like, hey, T-strings have a syntax that looks a lot like F-strings.

00:44:33.440 --> 00:44:35.360
How could you build F-strings on top of T-strings?

00:44:35.560 --> 00:44:46.180
So there is an F paren-paren method that's implemented here that just kind of helps you understand, OK, I'm writing dynamic code to do the thing that F-strings would have done at compile time anyway.

00:44:48.280 --> 00:44:51.000
We also have a structured logging example.

00:44:51.260 --> 00:45:00.560
And I'm excited about this, you know, structured logging that Python has shipped a logging cookbook for a long time since the Python 2.something era.

00:45:01.280 --> 00:45:10.420
And one of the examples in that logging cookbook is structured logging, by which we mean like, hey, I want to write out a sentence or two that people can understand, that humans can read.

00:45:10.800 --> 00:45:13.720
But I also have some values that I'm substituting in that sentence.

00:45:13.840 --> 00:45:17.140
And I'd really like that to be written out in some schema compliant way.

00:45:18.080 --> 00:45:41.420
And with T-strings, you can kind of do that in a really elegant way, which is to say you write the T-string once, you send it to some kind of method that expects T-strings on logging, and it emits basically the equivalent of an F-string, so that's the human readable bit, and then maybe it uses JSON or something to emit a structured output to a different log stream entirely.

00:45:41.960 --> 00:45:52.480
So one of the examples in the PEP and also in this PEP 750 repo is we send the human readable stuff to standard out and we send the machine readable stuff to standard error.

00:45:53.140 --> 00:45:56.300
And you can imagine your login system is going to redirect those somewhere else

00:45:56.300 --> 00:45:57.820
over there.

00:45:58.130 --> 00:46:10.140
Yeah, I mean, the example here, you got standard error, but you could easily do a document database with JSON as well and then put an index on action and say, show me all the actions taken that have this commonality in it, right?

00:46:10.140 --> 00:46:17.340
And do a query and go, bam, rather than really error-prone, like substring matching of text or whatever, right?

00:46:17.600 --> 00:46:19.320
Yeah, and I'm really excited about it.

00:46:19.320 --> 00:46:27.940
You write the T string once and you get the benefit of both the human readable and the structured schema-compliant output, and that's really exciting to me.

00:46:29.320 --> 00:46:29.500
Yeah.

00:46:30.160 --> 00:46:33.540
Yeah, and I guess if you use Postgres, you could just put it in a JSON field as well, something like that.

00:46:33.580 --> 00:46:33.900
Oh, yeah.

00:46:35.400 --> 00:46:37.180
We call that mullet

00:46:37.180 --> 00:46:38.020
schema, right?

00:46:38.460 --> 00:46:42.180
It's a business up front and partying back where the last column on every table is a

00:46:42.180 --> 00:46:42.840
JSON field.

00:46:43.220 --> 00:46:43.960
I've never heard that.

00:46:44.120 --> 00:46:44.640
That's incredible.

00:46:45.080 --> 00:46:45.720
It's like, yeah,

00:46:45.780 --> 00:46:46.860
we look real formal, but

00:46:46.860 --> 00:46:48.560
don't look back there.

00:46:50.720 --> 00:46:51.740
Got it in the ponytail today.

00:46:52.760 --> 00:46:52.920
Amazing.

00:46:55.580 --> 00:46:55.880
Okay.

00:46:56.400 --> 00:47:02.520
One thing I wanted to cover, there's a really interesting thing from somewhere in here.

00:47:02.620 --> 00:47:03.660
I had pulled this up, I believe.

00:47:04.560 --> 00:47:05.360
I'll just go to the PEP.

00:47:05.740 --> 00:47:10.740
In the PEP, there's a section that talks about how to teach this.

00:47:12.820 --> 00:47:22.360
And I think that that's – there's just a couple of ideas here that I think would make it really interesting for helping people understand better, right?

00:47:22.580 --> 00:47:29.180
Speaking to developers or maybe people who build libraries like web frameworks or logging libraries or something.

00:47:29.970 --> 00:47:37.340
Who wants to kind of give us a few of the ideas here that just maybe like – I know we touched on some of them a little bit.

00:47:38.200 --> 00:47:46.780
Yeah, I mean I'm happy to kind of step through the basics here, which is, you know, we touched on the fact that the syntax of T strings and f-strings is essentially identical.

00:47:47.500 --> 00:48:21.720
Anytime you have an F, you can substitute with a T, but the result, the evaluated result is entirely different. You get a string or a template, and we've kind of talked about all the reasons why you might want to do that. I guess the key thing for developers to understand, and I'm kind of going to divide developers into two groups here, those who use T strings and pull in like an HTML or a SQL library, for example, and don't really think much about what's going on under the hood, for them, all they need to know is, hey, you write T of something and you send it to your SQL library and it's safe.

00:48:22.720 --> 00:48:25.300
And you don't really need to think much more about it than that.

00:48:25.520 --> 00:48:30.640
And then, of course, we had, sorry, but we had things like literal strings and other stuff in the

00:48:30.640 --> 00:48:30.960
type

00:48:30.960 --> 00:48:35.300
system that kind of tried to make type checkers check and catch

00:48:35.500 --> 00:48:36.040
when that would happen,

00:48:36.600 --> 00:48:36.700
right?

00:48:36.840 --> 00:48:45.100
But this is more runtime catching because of the way it operates rather than, hey, it's a bad idea to do that.

00:48:45.300 --> 00:48:46.800
But, you know, Python typing can be ignored.

00:48:47.860 --> 00:48:48.300
Yeah.

00:48:48.940 --> 00:48:50.760
It's probably worth mentioning the limits of that.

00:48:51.050 --> 00:48:58.000
I mean, template and interpolation, which are new types that ship with Python 3.14, are ones that you can concept at runtime directly.

00:48:58.500 --> 00:49:00.060
You don't need to start with a literal.

00:49:00.700 --> 00:49:07.400
And so you can, of course, as a developer, do all kinds of goofy stuff and comes up all sorts of malicious templates if you want to.

00:49:07.800 --> 00:49:20.240
But generally speaking, if you're working from literals, which we sort of expect is the very common case, and you're using libraries that know about this new feature when Python 3.14 ships, generally speaking, you're staying on the safe side.

00:49:20.400 --> 00:49:22.160
You're staying in the bright, well-lit path.

00:49:22.580 --> 00:49:22.660
Yeah.

00:49:23.040 --> 00:49:33.980
One of the ideas I like to think about in APIs and design of software is, like, falling into the pit of success or falling into the pit of despair.

00:49:34.240 --> 00:49:39.860
And like you want to make it so the natural action is to fall into the pit of success and you've got to work your way out of there. You know what I mean?

00:49:40.060 --> 00:49:41.220
Yeah. You have to work hard to get there.

00:49:41.380 --> 00:49:41.420
Yeah.

00:49:41.660 --> 00:49:42.220
Hopefully we've

00:49:42.220 --> 00:49:43.460
found a nice balance there.

00:49:44.540 --> 00:49:45.940
Yeah. It seems like it has.

00:49:46.940 --> 00:49:47.260
Yeah. I mean, I

00:49:47.260 --> 00:50:01.200
think from a teaching it perspective, you know, the pit of despair is so easy to fall into with f-strings, right? You know, so your structure logging, you know, I'm sorry, you're using fstrings in your logging, it's like, oh, I inadvertently logged some passwords.

00:50:02.040 --> 00:50:02.620
That's unfortunate.

00:50:04.460 --> 00:50:07.600
Or I'm using fstrings with a SQL statement.

00:50:07.740 --> 00:50:10.000
It's like, oh, that really worked until it didn't.

00:50:10.760 --> 00:50:24.920
And so it's very easy to go down into that pit of despair as you're describing, whereas we're hopefully making it something where you have to work a little bit, know what you're doing, in fact, in order to go and actually do something that's bad.

00:50:26.660 --> 00:50:37.520
So, you know, I'm sure that, you know, someone can show me, you know, a couple steps that, you know, make it straightforward to get into that pit of despair.

00:50:38.300 --> 00:50:41.460
But I don't think it would be still the most obvious thing to do.

00:50:42.079 --> 00:50:42.440
So

00:50:42.440 --> 00:50:47.140
from a teaching perspective, we want to ensure that the most obvious thing to do is the right thing to do.

00:50:47.940 --> 00:50:58.500
And, you know, people can build libraries, you know, an HTML function or whatever in order to ensure that is, you know, going to work with that right path.

00:51:00.940 --> 00:51:12.740
But there's more, I think, Paul, you, you know, if you wanted to go and just how to teach this, I think part of this is just like, again, things like IDE integration and things like, you know, working with lenders and whatnot.

00:51:13.460 --> 00:51:15.520
That's also very exciting in terms of what can be done.

00:51:18.880 --> 00:52:10.340
and for me that's kind of the exciting part there's there's a side about really lowering the bar for writing these functions that handle a template you know you're not going to do anything with a template yourself you're going to hand it to a function that's going to do something and it's going to return a stringable not a string something that can be made later into a string. But it's the people on the other side that are going to be creating the values and the content and all that kind of stuff. And we have a real chance here to help them. We're not going to talk about double curly braces or single curly braces for the rest of time. It's single curly, just that alone. And what goes in there isn't going to be some invented language with a pipe that you send to safe or whatever, and you've got to go memorize all these rules about how do I call a macro.

00:52:10.860 --> 00:52:19.640
It's just Python, which then means IDEs and tools and linters and formatters and type checkers all get to play a game.

00:52:19.880 --> 00:52:25.020
Go to mypy and file a ticket asking for type checking on Jinja.

00:52:26.760 --> 00:52:28.860
There is a ticket already, and you can see their comments.

00:52:29.400 --> 00:52:30.600
They're not that interested.

00:52:31.460 --> 00:52:33.320
Same thing for a lot of other tools.

00:52:34.080 --> 00:52:41.060
But if they support 3.14, they support template strings, and they support f-strings, and they support this kind of everything.

00:52:41.940 --> 00:52:44.520
Because everything is just where it's supposed to be.

00:52:45.560 --> 00:52:50.980
And if I can go a little bit, Dave, is it okay if I go a little bit further on this riff about tooling?

00:52:52.020 --> 00:52:53.640
Let's see, you've got some points to make.

00:52:53.900 --> 00:52:54.620
Sorry, I'm on a roll.

00:52:55.620 --> 00:52:57.060
I'll try to wrap it up, I promise.

00:52:58.540 --> 00:53:09.460
This idea of a big ecosystem of tooling and all of that will give us a developer experience that's competitive again.

00:53:10.920 --> 00:53:13.640
All of these tools can start pitching in.

00:53:14.580 --> 00:53:15.760
I'm with the PyCharm team.

00:53:16.000 --> 00:53:21.180
Because this is f-strings with a T, they did it just like that.

00:53:21.920 --> 00:53:31.860
Dave did a fork of black where he got T-string support basically just like that because it was a T instead of an F.

00:53:33.080 --> 00:53:37.820
Then we can get into some more interesting things like an HTML templating library.

00:53:37.930 --> 00:53:44.360
We are very fortunate in the world of Python to have Andrea over from JavaScript on the PyScript team.

00:53:44.920 --> 00:53:51.860
He has written 400,000 variations of JavaScript templating engines, including tag template literals.

00:53:51.860 --> 00:53:52.760
He knows everything.

00:53:53.210 --> 00:53:56.420
He contributed a lot to this pep, such as that alternating thing.

00:53:56.960 --> 00:54:02.560
He's creating an HTML templating language that is browser first.

00:54:04.460 --> 00:54:09.380
Michael, you had a Vue.js up earlier that had like at click.

00:54:11.360 --> 00:54:21.460
There's going to be a lightning talk at PyCon about showing this in PyScript where something can run on the server and in the client and it's nuts.

00:54:21.630 --> 00:54:21.780
The

00:54:21.780 --> 00:54:22.560
whole thing is just

00:54:22.560 --> 00:54:23.020
insane.

00:54:23.380 --> 00:54:27.280
Server rendered templates but also client-side stuff.

00:54:28.140 --> 00:54:28.260
Yeah.

00:54:29.320 --> 00:54:32.780
So there is a chance for us in the world of Python.

00:54:33.620 --> 00:54:39.220
It doesn't have to be our spelling, but if we can agree to structure and intermediate representations.

00:54:39.780 --> 00:54:42.760
Dave has ideas about how HTTPY could play ball.

00:54:43.300 --> 00:54:45.500
They can make components that we can consume.

00:54:45.590 --> 00:54:47.360
We can make components that they can consume.

00:54:48.060 --> 00:54:59.520
I'm really bullish on how we can change the developer experience in web development and more to be modern Python with tooling.

00:55:01.780 --> 00:55:02.060
Dave.

00:55:02.800 --> 00:55:03.160
I'm here

00:55:03.160 --> 00:55:03.460
for it.

00:55:03.700 --> 00:55:04.260
I'm here for it, Paul.

00:55:04.940 --> 00:55:06.840
Yeah, I'm just going to give you a what-what here.

00:55:10.500 --> 00:55:24.020
yeah I think if if we really can unlock a language that works well on the front end I know PyScript's come a long way but I feel like we need a view like thing

00:55:24.580 --> 00:55:25.060
right

00:55:25.060 --> 00:55:27.500
and it sounds like work is being done

00:55:28.700 --> 00:55:29.860
yeah I mean if that

00:55:29.860 --> 00:55:35.320
comes along there's going to be a lot of people go wait we don't have to do JavaScript are you

00:55:35.320 --> 00:55:36.139
serious here

00:55:36.160 --> 00:55:37.380
That would be pretty amazing.

00:55:38.230 --> 00:55:41.920
Just throw in your 100K MicroPython implementation of

00:55:41.920 --> 00:55:42.260
PyScript

00:55:42.470 --> 00:55:43.620
and you're off to the races.

00:55:44.380 --> 00:55:44.700
Go ahead, Jim.

00:55:45.460 --> 00:55:59.900
Yeah, I was just going to say, and one other nice thing about T-strings and the fact that they look a lot like F-strings is that it's going to be a straightforward thing for us to, or I shouldn't say for us, but I think the community.

00:56:01.720 --> 00:56:05.640
I think there will be plenty of people who can work on this, fortunately.

00:56:05.680 --> 00:56:10.440
to incorporate T-strings into MicroPython.

00:56:11.320 --> 00:56:24.040
And now you, instead of having something that requires a somewhat heavier download in terms of CPython on the client side with PyScript, you can use MicroPython for that.

00:56:24.880 --> 00:56:25.360
I

00:56:25.360 --> 00:56:26.020
looked into it.

00:56:26.260 --> 00:56:26.900
It looks straightforward.

00:56:27.540 --> 00:56:31.740
I hope that we will see that development happen sooner than later.

00:56:32.540 --> 00:56:44.240
So a lot of opportunities to go and mix together client side and server side in some really interesting and very cool ways going forward with this work.

00:56:45.100 --> 00:56:45.260
Yeah.

00:56:45.800 --> 00:56:50.640
What an interesting angle to say we'll add T-strings to MicroPython

00:56:51.839 --> 00:56:52.640
so that

00:56:52.640 --> 00:56:55.680
it round trips to the front end of the browser in an efficient way.

00:56:56.640 --> 00:56:56.840
Yeah.

00:56:57.839 --> 00:57:02.760
We've got a bunch of script sprint days coming up with PyCon so you never know.

00:57:03.680 --> 00:57:04.040
Okay.

00:57:05.120 --> 00:57:14.740
Michael, when you mentioned that MicroPython is about 100K, which to my ears as an old school web person sounds huge, but also really tiny these days.

00:57:15.240 --> 00:57:16.660
When you

00:57:16.660 --> 00:57:30.280
do the default Next.js app install, which literally does nothing but ship a static looking page to you, although, of course, static includes a whole bundle of React and other stuff with Next.js these days, that's about 130K.

00:57:30.660 --> 00:57:33.100
And that doesn't include an implementation of Python.

00:57:33.880 --> 00:57:34.840
So it's

00:57:34.840 --> 00:57:35.480
kind of amazing.

00:57:37.580 --> 00:57:40.800
Yeah, and I think it's pretty comparable to other things.

00:57:41.180 --> 00:57:45.140
I'm trying to poke around and find some examples.

00:57:45.500 --> 00:57:52.900
But, yeah, I think 100K is certainly doable on a CDN and so on.

00:57:53.360 --> 00:57:54.020
It's a sweet spot.

00:57:55.080 --> 00:57:55.380
Hey, Michael,

00:57:55.440 --> 00:57:56.000
I got one

00:57:56.000 --> 00:57:56.340
for you.

00:57:57.900 --> 00:58:01.880
And this is one that Jim and I started talking about and others piped in.

00:58:01.960 --> 00:58:06.200
Kudai, who's also working on this project, is doing stuff in this field.

00:58:07.340 --> 00:58:15.460
LLMs and code that needs to generate good LLM-generated results.

00:58:17.160 --> 00:58:31.420
If you had a template language that was closer to the language of Python and could be analyzed as such, and all the LLM and RAG tricks that people are applying to not just get code, but to get good quality code.

00:58:32.280 --> 00:58:41.300
Is this a moment where we could invent a web development story for Python that wasn't just cool because it was browser first?

00:58:42.200 --> 00:58:48.060
It was cool because it anticipates AI and LLN generated code.

00:58:49.840 --> 00:58:50.020
Okay.

00:58:52.780 --> 00:59:00.400
You know, if you can infer types and things like that because you can look into the structure of the template and

00:59:00.400 --> 00:59:01.000
know things.

00:59:01.260 --> 00:59:08.560
and they are Python rules inside the curly braces instead of invented stuff, you might have a better shot at machinery.

00:59:08.780 --> 00:59:09.960
Jim, what do you think?

00:59:09.960 --> 00:59:11.140
You had a lot to say on this.

00:59:12.520 --> 00:59:21.700
Yeah, I mean, I think a lot of people are looking at stuff around, like in-context learning with how they work with prompts and everything.

00:59:23.100 --> 00:59:40.460
I do think that if I'm going to send a bunch of examples to some sort of mini shot, but I guess a few number of shots learning, it would be really nice to do it in a very structured way and really have good support for that.

00:59:40.760 --> 00:59:46.560
And so if you look at how people typically do this, well, they emit f-strings.

00:59:47.500 --> 00:59:48.740
And I'm sure it works most of the time.

00:59:49.660 --> 00:59:50.980
I just want it to work all the time.

00:59:53.340 --> 01:00:05.440
And so I think having something that can you know, TANA structure, maybe even do some interesting, you know, like there's some stuff around like DISP or DSPY or whatever.

01:00:05.440 --> 01:00:17.300
I'm not certain actually how it's pronounced, but it basically does, you know, additional rounds of optimizing your in-context learning, prompting in general.

01:00:18.940 --> 01:00:22.040
You know, having access to that structure might be very helpful for it.

01:00:22.390 --> 01:00:22.860
Who knows?

01:00:23.260 --> 01:00:23.960
I think that

01:00:23.960 --> 01:00:24.620
there's a lot

01:00:24.620 --> 01:00:38.420
of interesting opportunities in this space where we maintain this structure, we're able to reflect on it, and then use that for whatever sort of interaction we have with other systems.

01:00:39.430 --> 01:00:48.980
And fundamentally, that's what this supports, because you have access to those Python structures, you can figure out what that's supposed to be before you go and send it off to somewhere else.

01:00:50.720 --> 01:00:53.240
So what does that mean in terms of capabilities?

01:00:54.460 --> 01:00:55.120
That's very interesting.

01:00:56.040 --> 01:01:21.520
Paul, when you were talking about typing earlier and then talking about mypy, it just made me realize or think, I guess I thought about it before, but reemphasized that for me, the typing is a communication tool to me, mostly through things like PyCharm, but not 100%, but mostly through the editor saying, here's what it's supposed to be here.

01:01:21.680 --> 01:01:22.800
Here's what this is supposed to do.

01:01:22.900 --> 01:01:25.440
So I don't have to go to definition and try to decipher it.

01:01:26.960 --> 01:01:34.120
And I almost never use mypy or one of these PyRite or Pyre or you name it because that's not my goal.

01:01:34.260 --> 01:01:39.160
My goal is to add typing so that I can stay out of the docs except for I really must.

01:01:39.780 --> 01:01:45.200
And the same applies to what you share with chat and agenda code generators.

01:01:45.800 --> 01:01:53.680
They can look at those types and they can see much more information and it can make them way more accurate and productive, right?

01:01:54.419 --> 01:02:04.500
And I feel like this could communicate more information to them, like you were saying, so they have more structure to work with rather than just, here's a string, I don't know what it is.

01:02:11.380 --> 01:02:12.420
Can I riff on that for a second?

01:02:13.040 --> 01:02:13.440
Yes, riff.

01:02:14.980 --> 01:02:23.260
This is all not news to Dave, who he and I are writing our lightning talks and FlaskCon talk together.

01:02:24.100 --> 01:02:27.540
If you're around on Friday afternoon, come see Dave, come see me.

01:02:27.700 --> 01:02:30.100
It's going to be mind-blowing.

01:02:30.960 --> 01:02:31.540
Lightning talks

01:02:31.540 --> 01:02:32.720
are going to be mind-blowing, too.

01:02:32.960 --> 01:02:33.240
Awesome.

01:02:33.640 --> 01:02:35.980
Don't they normally publish those videos from FlaskCon as well?

01:02:37.660 --> 01:02:38.040
Yeah.

01:02:38.760 --> 01:02:39.260
He needs help.

01:02:40.260 --> 01:02:40.400
Okay.

01:02:40.800 --> 01:02:42.380
David is doing 500

01:02:42.380 --> 01:02:45.140
jobs at once and everyone support David Lord.

01:02:46.380 --> 01:03:05.400
I'm going to be giving a demo in PyCharm at least of T-string support with interpolation autocomplete and navigation and all the PyCharm tricks, but also a experimental plugin that does component support with TDOM.

01:03:05.680 --> 01:03:25.300
So it looks just like JSX, where you pass props to something, and it obeys the, again, do not just autocomplete of the props, but if you're missing a required prop, it will know that because it looks at the function signature of the component, and it will match the types of the prop.

01:03:25.400 --> 01:03:28.140
If you pass a string for an int, it will squiggle you.

01:03:29.200 --> 01:03:40.220
In the future, we can go further like a lot of IDs can do and extract components to be standalone, to get big components into small components, all kinds of things.

01:03:40.520 --> 01:03:48.260
Once you get into the world of tooling, you've got typing, you've got signatures, you've got all of these great things.

01:03:49.860 --> 01:03:53.260
Mouse over for doc strings and doc hints and help.

01:03:53.900 --> 01:03:54.460
Lots of help.

01:03:55.260 --> 01:03:55.740
That's awesome.

01:03:57.580 --> 01:03:58.800
Well, I'm looking forward to it.

01:04:01.980 --> 01:04:03.300
Guys, we're about out of time.

01:04:03.530 --> 01:04:06.680
I want to wrap this up with one final thought here.

01:04:06.880 --> 01:04:14.620
So speaking to several audiences, let's say two audiences at the moment, give us some advice for potential adopters.

01:04:15.060 --> 01:04:27.240
So if I'm Sebastian from FastAPI or David from FlaskCourt or I'm some other library adopter, micro-seql alchemy, right?

01:04:28.140 --> 01:04:29.640
Or that's audience one.

01:04:29.960 --> 01:04:40.640
audience too would just be people who thought f-strings were awesome and this is even more awesome. They want to try it in their code. What are some pitfalls and best practices for these folks? And like, what are the opportunities there?

01:04:49.760 --> 01:05:07.900
Well, I mean, I think, you know, in general, the fact that T strings exist doesn't mean that f-strings need to tomorrow. So I guess that'd be the first thought I'd have for the community that isn't actively building libraries that might benefit from T-string functionality, which is that the

01:05:08.280 --> 01:05:10.000
tool is still useful. And in fact,

01:05:10.010 --> 01:05:13.940
there are many cases where probably what you really want is an F-string rather than a T-string.

01:05:14.320 --> 01:05:14.720
It's

01:05:14.720 --> 01:05:30.980
exactly these cases where you want the interpolations to do something special, whether that's prevent injunction vulnerabilities or transliterate a single dictionary into a bunch of attributes in HTML where you might want to start playing with T-strings.

01:05:31.560 --> 01:05:37.980
And there, you know, I think if you're a library developer and you happen to be at PyCon, come say hello.

01:05:38.540 --> 01:05:42.160
We'd love to talk to you and kind of figure out how you're thinking about adopting these.

01:05:42.520 --> 01:05:48.880
I think the biggest one that came up in discussion amongst library developers that I saw was just, wait, how do I type my function?

01:05:49.040 --> 01:06:00.560
So if I'm writing a SQL layer and I've got an execute method, right now that takes a string or maybe it takes, you know, Michael, you mentioned literal string, to take some variety of some special type that my library supports.

01:06:01.100 --> 01:06:02.720
Should I also take a template there?

01:06:02.790 --> 01:06:04.280
Should I allow a union of both?

01:06:05.000 --> 01:06:05.880
Probably that's a foot gun.

01:06:06.030 --> 01:06:08.760
You probably really want to think about separating these things out.

01:06:09.640 --> 01:06:13.060
And so I think we'll see best practices like that kind of emerge over time.

01:06:15.160 --> 01:06:17.060
Yeah, I would add a couple things.

01:06:17.360 --> 01:06:20.880
One, we actually love f-strings.

01:06:22.140 --> 01:06:22.880
You know, when you look at

01:06:22.880 --> 01:06:32.100
the actual code that implements the T-string functionality in terms of like a library, you know, like an HTML function or whatever, what do we, what do you find in there?

01:06:32.370 --> 01:06:38.760
Lots of uses of F-strings to actually go and, you know, pump out the actual string that you need, right?

01:06:39.360 --> 01:06:51.300
It's just done in this, you know, disciplined fashion that we can do because we have carefully separated out when the interpolations are being actually evaluated in that context, right?

01:06:52.880 --> 01:07:24.300
second thing to think about is in terms of like a good best practice would be you know if you have a t-string you know and you say html I don't think html should just like do something there or sql or whatever it should go and allow it to prepare you know a document object model or you know prepare a sql query or whatever and then you execute it or render it or whatever.

01:07:24.940 --> 01:07:34.820
So I would differentiate this sort of setup versus, you know, some final rendering would be a typical best practice that certainly I would recommend.

01:07:38.400 --> 01:07:47.980
And there are obviously more, you know, another best practice definitely is at some point you probably want to think about the optimization of these things, right?

01:07:47.980 --> 01:07:56.580
And as we really put in some thought into how the template strings can be used as a memorization key efficiently.

01:07:58.800 --> 01:08:01.540
So you can look it up in terms of an LRU cache.

01:08:02.440 --> 01:08:09.400
This is no different than if you looked at the internals of, say, the RE module, you know, sports regular expressions.

01:08:11.420 --> 01:08:19.460
You know, there is this, at one point, you actually had to go into RE compile, and it's not a bad practice to do it.

01:08:19.540 --> 01:08:24.060
But if you look internally at it, it actually does the RE compile for you.

01:08:24.089 --> 01:08:30.940
So you don't pay the overhead of running through this Python parse every single time.

01:08:31.440 --> 01:08:32.480
Interesting. I didn't know that.

01:08:33.520 --> 01:08:33.620
Yeah.

01:08:34.799 --> 01:08:49.420
But the actual implementation of that in terms of running the regular expression is done through this little bytecode virtual machine that's specific to regular expression.

01:08:50.020 --> 01:08:50.900
and can be very efficient.

01:08:51.569 --> 01:09:06.060
So again, we'll see some of these sorts of separations where we'll think about, you know, what it means to go and have a, you know, a fast path where you actually are, you know, evaluating, you know, this HTML fragment or whatever, or, you know, working with SQL.

01:09:06.569 --> 01:09:10.880
And then there is some sort of, you know, well, you have to pay the parse penalty at some point.

01:09:11.560 --> 01:09:17.120
But part of paying that parsing penalty is ensuring that things are done in a safe fashion.

01:09:18.460 --> 01:09:20.160
being written out in a structured way.

01:09:20.950 --> 01:09:35.640
So that's more than makes up for it compared to, again, just using F-strings and hoping that your SQL statement didn't include in that interpolation the Bobby Tables evil injection.

01:09:38.020 --> 01:09:38.540
Yeah,

01:09:38.540 --> 01:09:39.060
excellent.

01:09:39.060 --> 01:09:39.420
For me,

01:09:39.560 --> 01:09:49.560
I'd say first a shout-out to our PEP sponsor and the hero for the second half of all this, Lissandros has been marvelous.

01:09:51.160 --> 01:09:56.020
Getting the implementation and shaping in our interface to the rest of the core team and all that kind of stuff.

01:09:56.820 --> 01:09:57.800
Really fast turnaround.

01:09:58.220 --> 01:09:59.780
Really joy to work with.

01:10:00.240 --> 01:10:04.000
Dave and Lissandros spent a lot of time ironing out all the little things.

01:10:04.640 --> 01:10:11.080
I think about this whole path since Guido and Jim sat down at a PyCon like three years ago on the implementation.

01:10:11.350 --> 01:10:15.780
I think it's been, this will be like the fourth PyCon since this whole thing first started.

01:10:16.860 --> 01:10:24.980
And Jim and Guido kind of laid the groundwork for where we are right now, which is T-strings is just the start.

01:10:25.580 --> 01:10:27.840
T-strings by itself ain't that much.

01:10:28.100 --> 01:10:35.360
And I think, Jim, you made some decisions to intentionally defer to future PEPs some of the things.

01:10:36.940 --> 01:10:42.360
Jim just said about these functions that don't immediately render.

01:10:42.440 --> 01:10:46.120
They prepare an intermediate representation that might later render.

01:10:46.720 --> 01:10:49.080
For me, that's my interest in this PyCon.

01:10:50.340 --> 01:10:51.380
Let's build a community.

01:10:52.540 --> 01:11:03.780
Let's build a community around interoperability so HTPy doesn't have to spell things our way, but we can talk to each other because we agree on a node interface or something like that for a DOM representation.

01:11:05.140 --> 01:11:08.720
The front-end world has gotten great value out of pluggability.

01:11:09.340 --> 01:11:16.220
The Vite system, for example, is a processing chain with a documented intermediate representation.

01:11:16.400 --> 01:11:20.100
It's easy to write a plug-in to go grab that and hack on it.

01:11:20.100 --> 01:11:22.140
You want to turn everything into a relative URL?

01:11:22.760 --> 01:11:28.000
Write a little plug-in, put it in the chain, and you'll be handed something that lets you operate on things.

01:11:28.720 --> 01:11:31.200
We can do something great together.

01:11:31.520 --> 01:11:37.700
We don't all have to do the XKCD to invent a new standard to replace all the other standards.

01:11:38.680 --> 01:11:40.380
We can still work with Jinja.

01:11:40.560 --> 01:11:46.660
We could still work with HTPy and some of these other things, and hopefully we'll see some of that at PyCon.

01:11:48.880 --> 01:11:49.880
Awesome. Thank you, guys.

01:11:50.300 --> 01:11:54.560
And we're specifically recording this on a time frame that

01:11:54.560 --> 01:11:55.120
hopefully...

01:11:55.120 --> 01:11:56.100
Thank you so much, Michael.

01:11:56.740 --> 01:11:57.080
You're welcome.

01:11:57.270 --> 01:12:04.320
If people are dutiful and on top of their listening, we'll listen to this right before they go to PyCon.

01:12:04.540 --> 01:12:12.660
So I would like to encourage them to reach out to all of you and maybe go to some of the lightning talks and if they have ideas to participate because now is the time.

01:12:14.500 --> 01:12:14.780
Indeed.

01:12:17.160 --> 01:12:17.300
Thanks

01:12:17.300 --> 01:12:17.540
for hosting.

01:12:17.540 --> 01:12:18.200
Dave, you got something to say?

01:12:19.120 --> 01:12:19.840
No, thanks,

01:12:20.000 --> 01:12:21.460
Michael, for doing this.

01:12:21.460 --> 01:12:23.920
And we're excited to meet everybody at PyCon who's heading out that way.

01:12:24.580 --> 01:12:25.420
Yeah, Paul, you're welcome.

01:12:25.600 --> 01:12:26.520
And you too, Dave.

01:12:27.780 --> 01:12:30.120
Jim, Dave, and Paul, thank you all for being here.

01:12:30.370 --> 01:12:30.740
See you later.

01:12:31.520 --> 01:12:31.820
Thanks, everyone.

01:12:32.340 --> 01:12:32.620
Bye.

01:12:33.420 --> 01:12:33.780
Thank you.

01:12:34.090 --> 01:12:34.340
Bye-bye.

