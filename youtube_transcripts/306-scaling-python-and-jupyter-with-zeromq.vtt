WEBVTT

00:00:00.000 --> 00:00:02.580
(upbeat music)


00:00:02.860 --> 00:00:04.660
- Hello everyone out there in the live stream.


00:00:04.660 --> 00:00:06.140
Thanks for watching live.


00:00:06.140 --> 00:00:08.180
Hopefully you can participate


00:00:08.180 --> 00:00:10.900
and give us some questions and feedback and whatnot.


00:00:10.900 --> 00:00:13.060
And yeah, we're ready to get started.


00:00:13.060 --> 00:00:14.020
Min, you ready?


00:00:14.020 --> 00:00:14.860
- Yep.


00:00:14.860 --> 00:00:15.740
- All right.


00:00:15.740 --> 00:00:17.860
Min, welcome to Talk Python To Me.


00:00:17.860 --> 00:00:18.820
- Thanks.


00:00:18.820 --> 00:00:21.660
- Yeah, it's really good to have you here.


00:00:21.660 --> 00:00:26.660
I'm excited to talk about building applications with zeroMQ.


00:00:26.660 --> 00:00:29.460
It's definitely one of those topics


00:00:29.460 --> 00:00:34.460
that I think lives in this realm of asynchronous programming


00:00:34.460 --> 00:00:36.100
in ways that I think a lot of people


00:00:36.100 --> 00:00:37.740
don't initially think of.


00:00:37.740 --> 00:00:39.100
Like you think of async programming,


00:00:39.100 --> 00:00:40.380
like, okay, well, I'm gonna do threads


00:00:40.380 --> 00:00:42.380
and if threads don't work, maybe I'll do multiprocessing


00:00:42.380 --> 00:00:44.100
and then those are my options, right?


00:00:44.100 --> 00:00:47.940
But queues and other types of intermediaries


00:00:47.940 --> 00:00:52.500
are really interesting for creating powerful design patterns


00:00:52.500 --> 00:00:53.820
that let you scale your apps


00:00:53.820 --> 00:00:55.900
and do all sorts of interesting things, right?


00:00:55.900 --> 00:00:58.100
- Yeah, yeah, zeroMQ has definitely given me


00:00:58.140 --> 00:01:02.300
a new way of thinking about how different components


00:01:02.300 --> 00:01:05.220
of a distributed application can talk to each other.


00:01:05.220 --> 00:01:07.980
- Yeah, absolutely.


00:01:07.980 --> 00:01:09.820
So we're gonna dive all into that,


00:01:09.820 --> 00:01:11.180
which is gonna be super fun.


00:01:11.180 --> 00:01:14.820
But before we do, maybe just tell us a bit about yourself.


00:01:14.820 --> 00:01:17.860
How did you get started in programming in Python?


00:01:17.860 --> 00:01:20.580
- Yeah, so I got started mostly during college


00:01:20.580 --> 00:01:22.460
where I was studying physics


00:01:22.460 --> 00:01:25.140
and what essentially amounted


00:01:25.140 --> 00:01:27.100
to a computational physics degree.


00:01:28.100 --> 00:01:31.660
And that's where I met, I had a professor, Brian Granger,


00:01:31.660 --> 00:01:36.660
who's one of the heads of the Now Jupyter Project.


00:01:36.660 --> 00:01:40.380
I started working with him as an undergrad back in 2006,


00:01:40.380 --> 00:01:42.780
working on what would ultimately become


00:01:42.780 --> 00:01:45.700
the first IPython parallel,


00:01:45.700 --> 00:01:49.420
so interactive parallel computing toolkit in IPython


00:01:49.420 --> 00:01:50.380
that would eventually-- - Oh, that's really cool.


00:01:50.380 --> 00:01:51.740
What university was that at?


00:01:51.740 --> 00:01:53.500
- That was at Santa Clara University.


00:01:53.500 --> 00:01:55.700
- Uh-huh, okay, nice.


00:01:55.700 --> 00:01:56.540
Yeah, it's really cool.


00:01:56.540 --> 00:01:57.460
So you were working on physics,


00:01:57.460 --> 00:02:00.660
but you were also at the heart of Jupyter,


00:02:00.660 --> 00:02:02.460
and I guess IPython at the time, right?


00:02:02.460 --> 00:02:05.060
IPython Notebooks is what they were called, yeah?


00:02:05.060 --> 00:02:06.660
- Yeah, coming up on 15 years


00:02:06.660 --> 00:02:11.460
that I've been working on IPython and Jupyter.


00:02:11.460 --> 00:02:13.140
- Yeah, nice.


00:02:13.140 --> 00:02:15.580
And so you basically, did you do programming


00:02:15.580 --> 00:02:17.140
before you got into your physics,


00:02:17.140 --> 00:02:19.980
or did you just learn that to get going with your degree?


00:02:19.980 --> 00:02:25.620
- Just for, so I did it for fun in college,


00:02:25.620 --> 00:02:27.540
but I played around with calculators and stuff


00:02:27.540 --> 00:02:29.940
in high school, but nothing-- - Right, right, right, right.


00:02:29.940 --> 00:02:30.780
- Nothing more complicated


00:02:30.780 --> 00:02:33.420
than printing out a Fibonacci sequence.


00:02:33.420 --> 00:02:36.100
- Nice, so were you a TI person?


00:02:36.100 --> 00:02:37.540
Were you an HP person?


00:02:37.540 --> 00:02:39.700
What kind of world were you--


00:02:39.700 --> 00:02:41.140
- Yeah, TI, TI all the way.


00:02:41.140 --> 00:02:43.180
- Yeah, me too, obviously.


00:02:43.180 --> 00:02:45.900
That reverse Polish notation, that was just wrong.


00:02:45.900 --> 00:02:47.460
- Yeah, although I did, in college,


00:02:47.460 --> 00:02:49.300
we did implement reverse Polish calculators


00:02:49.300 --> 00:02:50.500
'cause it's easier.


00:02:50.500 --> 00:02:51.340
- Yeah, yeah, cool.


00:02:51.340 --> 00:02:53.100
- It's easier to write a parser for that.


00:02:53.100 --> 00:02:55.460
- Yeah, it's easier on the creator


00:02:55.460 --> 00:02:57.140
and not on the user, which-- - Yeah, exactly.


00:02:57.140 --> 00:02:59.380
- I feel like computers used to be way more that way, right?


00:02:59.380 --> 00:03:00.940
Like, oh, it's easier for us to make it,


00:03:00.940 --> 00:03:02.100
well, if you put a little more work,


00:03:02.100 --> 00:03:04.700
it'd be easier for the millions of people that use it.


00:03:04.700 --> 00:03:06.660
Well, maybe not millions in the early, early days,


00:03:06.660 --> 00:03:08.920
but yeah, very interesting.


00:03:08.920 --> 00:03:11.260
So what kind of stuff were you doing


00:03:11.260 --> 00:03:13.900
with IPython in the early days?


00:03:13.900 --> 00:03:16.700
What kind of stuff were you studying with your physics?


00:03:16.700 --> 00:03:18.860
- So in grad school, I was studying


00:03:18.860 --> 00:03:20.600
computational plasma physics simulation,


00:03:20.600 --> 00:03:23.840
so it was particle simulations of plasmas,


00:03:23.840 --> 00:03:25.780
which are what's going on in stars.


00:03:25.780 --> 00:03:29.480
I wasn't studying stars, but that's one of the main plasmas


00:03:29.480 --> 00:03:30.640
that people know about.


00:03:30.640 --> 00:03:33.300
And so I was doing particle simulations


00:03:33.300 --> 00:03:36.020
of just studying a system, seeing what happens.


00:03:36.020 --> 00:03:39.740
And we were working on an interactive scale simulation code


00:03:39.740 --> 00:03:41.060
that was written in C++.


00:03:41.060 --> 00:03:43.420
It was a fairly nice and welcoming


00:03:43.420 --> 00:03:47.820
C++ physics simulation as far as


00:03:47.820 --> 00:03:51.180
academic C++ physics simulations go.


00:03:52.620 --> 00:03:54.760
But essentially, my first year of grad school,


00:03:54.760 --> 00:03:56.940
I wrote a paper where I had to do


00:03:56.940 --> 00:03:59.920
a simulation run for five days,


00:03:59.920 --> 00:04:03.800
look at the results, and then change some input parameters


00:04:03.800 --> 00:04:05.360
and run it again for five days,


00:04:05.360 --> 00:04:07.160
and do that for a few dozen iterations,


00:04:07.160 --> 00:04:09.080
and then wrote a paper about that.


00:04:09.080 --> 00:04:11.040
And then ultimately, my PhD thesis


00:04:11.040 --> 00:04:13.920
was about wrapping the same code in Python


00:04:13.920 --> 00:04:17.120
so that I could have programmatic self-steering,


00:04:17.120 --> 00:04:19.320
actually by this time, driven in a notebook,


00:04:20.740 --> 00:04:24.300
doing what had been manual, like change it, run it again,


00:04:24.300 --> 00:04:25.800
doing that automatically,


00:04:25.800 --> 00:04:31.340
just by wrapping the C++ code in a Python API,


00:04:31.340 --> 00:04:33.820
I could do it much more efficiently


00:04:33.820 --> 00:04:35.420
and actually take something that took


00:04:35.420 --> 00:04:37.440
multiple iterations of five days,


00:04:37.440 --> 00:04:39.820
I could actually get the same result


00:04:39.820 --> 00:04:42.220
in a little over half a day, I think.


00:04:42.220 --> 00:04:43.460
- Wow, that's really cool.


00:04:43.460 --> 00:04:46.500
So you would run basically a little small simulation


00:04:46.500 --> 00:04:49.740
with C, and then you would get the inputs in Python


00:04:49.740 --> 00:04:51.340
and go, okay, well, now how do we adjust it?


00:04:51.340 --> 00:04:53.100
How do we change that?


00:04:53.100 --> 00:04:56.820
- Yeah, it was actually the same simulation,


00:04:56.820 --> 00:05:00.380
but I had to tune the inputs a little bit differently


00:05:00.380 --> 00:05:03.040
in order to, there were some details of the physics


00:05:03.040 --> 00:05:05.640
that basically I had to turn some knobs way up


00:05:05.640 --> 00:05:07.680
because I wasn't constantly watching it.


00:05:07.680 --> 00:05:11.060
And I would say, oh, that number was too big.


00:05:11.060 --> 00:05:12.780
Turn it down, do it again,


00:05:12.780 --> 00:05:15.060
and then look and see if it was too big again.


00:05:15.060 --> 00:05:19.300
Whereas once I had a knob that could be turned


00:05:19.300 --> 00:05:21.060
while the simulation was running,


00:05:21.060 --> 00:05:22.700
which is the feature that was missing,


00:05:22.700 --> 00:05:27.460
I could say ramp up the current in this case.


00:05:27.460 --> 00:05:31.980
So I was studying the limit of current


00:05:31.980 --> 00:05:33.700
that you can get through a diode.


00:05:33.700 --> 00:05:34.700
- Right.


00:05:34.700 --> 00:05:36.900
- And so ramp up the current,


00:05:36.900 --> 00:05:39.620
and then once I see evidence that it's too high,


00:05:39.620 --> 00:05:42.520
ramp it back down, and then I could change,


00:05:42.520 --> 00:05:46.660
lower the slope so that I would slowly approach


00:05:48.900 --> 00:05:51.340
an equilibrium and find the limit.


00:05:51.340 --> 00:05:55.100
Whereas when I had to do it with this long,


00:05:55.100 --> 00:05:56.380
I had to basically wait until it's done


00:05:56.380 --> 00:05:57.220
to change the input.


00:05:57.220 --> 00:05:59.900
I had to dramatically over-inject the current,


00:05:59.900 --> 00:06:01.380
which made the simulations extra slow


00:06:01.380 --> 00:06:03.140
because there were way too many particles.


00:06:03.140 --> 00:06:04.540
- Yeah, yeah.


00:06:04.540 --> 00:06:07.700
- And the spatial resolution had to be really fine


00:06:07.700 --> 00:06:10.460
in order to resolve something called a virtual cathode.


00:06:10.460 --> 00:06:13.080
And I didn't have to do nearly as much.


00:06:13.080 --> 00:06:16.860
Basically, because I could do this live feedback,


00:06:16.860 --> 00:06:19.380
the simulations themselves could be quicker


00:06:19.380 --> 00:06:24.100
because I didn't have to provide enough information


00:06:24.100 --> 00:06:26.940
that I could get the right answer out a long time later.


00:06:26.940 --> 00:06:27.940
- Oh, that's super cool,


00:06:27.940 --> 00:06:30.520
and obviously it makes a huge difference.


00:06:30.520 --> 00:06:32.220
I feel like we have a similar background


00:06:32.220 --> 00:06:33.780
in how we got into programming.


00:06:33.780 --> 00:06:36.100
I was doing a math degree,


00:06:36.100 --> 00:06:39.220
and my math research led me into doing C++


00:06:39.220 --> 00:06:41.540
on Silicon Graphics mainframe computers


00:06:41.540 --> 00:06:42.940
and stuff like that.


00:06:42.940 --> 00:06:45.780
And you talk about letting these things run overnight.


00:06:45.780 --> 00:06:47.980
Everyone would just kick off these things,


00:06:47.980 --> 00:06:49.620
and then they would come back in the morning


00:06:49.620 --> 00:06:51.140
to see what happened.


00:06:51.140 --> 00:06:55.060
And interesting sort of random sidebars.


00:06:55.060 --> 00:06:57.740
We came in one morning,


00:06:57.740 --> 00:07:01.180
and we all tried to log into our little workstations


00:07:01.180 --> 00:07:04.100
or whatever, and the system just wouldn't respond.


00:07:04.100 --> 00:07:05.300
There was just something wrong with it.


00:07:05.300 --> 00:07:07.500
And we were like, "Well, what the heck is going on?


00:07:07.500 --> 00:07:09.140
"This is a quarter million dollar computer.


00:07:09.140 --> 00:07:10.300
"It should let us log in.


00:07:10.300 --> 00:07:11.580
"What is wrong with it?"


00:07:11.580 --> 00:07:13.940
And it was in there running really loud.


00:07:13.940 --> 00:07:16.020
It was like this huge, loud machine.


00:07:16.020 --> 00:07:19.980
And it turned out that one of the grad students, not me,


00:07:19.980 --> 00:07:22.820
had started a job that was,


00:07:22.820 --> 00:07:24.280
they were trying to figure out what was going on,


00:07:24.280 --> 00:07:26.580
and they were logging a lot


00:07:26.580 --> 00:07:28.620
'cause they were having problems with their code.


00:07:28.620 --> 00:07:31.020
And it was in this tight loop that ran all night.


00:07:31.020 --> 00:07:34.800
And because it was like a somewhat small group,


00:07:34.800 --> 00:07:38.340
they had no disk limits or permission restrictions


00:07:38.340 --> 00:07:39.400
for the large part.


00:07:39.400 --> 00:07:42.280
So it literally used up every byte on the server,


00:07:42.280 --> 00:07:45.060
and then it just wouldn't do anything at all.


00:07:45.060 --> 00:07:45.900
(laughs)


00:07:45.900 --> 00:07:47.860
And I mean, the reason I bring this up


00:07:47.860 --> 00:07:49.460
is that's the challenge of these things


00:07:49.460 --> 00:07:51.780
where you start it and let it run for days,


00:07:51.780 --> 00:07:52.840
and then figure out what's happening.


00:07:52.840 --> 00:07:54.620
You're like, "Oh, it just used up the entire hard drive


00:07:54.620 --> 00:07:55.720
"of this giant machine.


00:07:55.720 --> 00:07:58.500
"Whoops, it broke it for everyone."


00:07:58.500 --> 00:08:02.700
And so this live aspect or more self-guided


00:08:02.700 --> 00:08:04.620
is a really great idea.


00:08:04.620 --> 00:08:06.460
It's really, it's a big step ahead.


00:08:06.460 --> 00:08:09.580
Maybe more so than people initially hear it as.


00:08:09.580 --> 00:08:11.140
It's a big deal.


00:08:11.140 --> 00:08:12.540
- Yeah, and I think it was,


00:08:12.540 --> 00:08:14.180
that's part of what got me really excited


00:08:14.180 --> 00:08:18.540
about the programmatic,


00:08:18.540 --> 00:08:21.060
giving, when you have access to something in Python,


00:08:21.060 --> 00:08:23.100
and you have an environment like IPython or Jupyter


00:08:23.100 --> 00:08:27.440
or whatever, being able to interact with something,


00:08:27.440 --> 00:08:29.380
what is usually, what you might think of


00:08:29.380 --> 00:08:31.660
as an offline physics simulation


00:08:31.660 --> 00:08:33.940
that runs for hours or days.


00:08:33.940 --> 00:08:35.880
If you have a Python API to it,


00:08:37.440 --> 00:08:41.800
you can steer it while it's going.


00:08:41.800 --> 00:08:45.000
You can turn the knobs on your experiment


00:08:45.000 --> 00:08:46.480
while it's running.


00:08:46.480 --> 00:08:48.160
Sometimes there are reasons why


00:08:48.160 --> 00:08:49.400
that's not actually a good idea,


00:08:49.400 --> 00:08:52.320
but it's really powerful to not,


00:08:52.320 --> 00:08:56.160
one of the costs that I had in my experiment


00:08:56.160 --> 00:08:57.640
was that in order to change the inputs,


00:08:57.640 --> 00:08:58.640
I had to start over.


00:08:58.640 --> 00:09:01.080
Physically, I didn't have to.


00:09:01.080 --> 00:09:02.440
If it were a physical machine


00:09:02.440 --> 00:09:04.120
where I were measuring inputs and outputs,


00:09:04.120 --> 00:09:06.680
I could just turn the curve down


00:09:06.680 --> 00:09:07.520
and see the results,


00:09:07.520 --> 00:09:10.600
but the code didn't support that.


00:09:10.600 --> 00:09:11.880
Whereas with this,


00:09:11.880 --> 00:09:15.360
and the frustrating thing about it


00:09:15.360 --> 00:09:18.200
was the way the physics was written did support that.


00:09:18.200 --> 00:09:20.760
The C++ code did support that.


00:09:20.760 --> 00:09:22.680
We just hadn't written an interface


00:09:22.680 --> 00:09:24.520
that allowed me as the user to do it.


00:09:24.520 --> 00:09:28.960
And so the Python wrapping work was surprisingly little.


00:09:28.960 --> 00:09:32.400
It was expose Python APIs to,


00:09:32.400 --> 00:09:35.280
or C++ APIs to Python with Cython.


00:09:35.280 --> 00:09:36.100
- Yeah, yeah.


00:09:36.100 --> 00:09:37.040
- I could turn all the knobs


00:09:37.040 --> 00:09:38.960
that were already there in the code.


00:09:38.960 --> 00:09:41.700
I just was now allowed to turn them.


00:09:41.700 --> 00:09:45.920
- It sounds to me, thinking back on the timeline there,


00:09:45.920 --> 00:09:47.560
that must have been pretty early days


00:09:47.560 --> 00:09:51.720
in the data science, computational science


00:09:51.720 --> 00:09:52.800
world of Python, right?


00:09:52.800 --> 00:09:56.480
Like NumPy was probably just about out around then?


00:09:56.480 --> 00:09:57.320
Or what was that?


00:09:57.320 --> 00:09:59.760
- Well, by the time I was doing that work,


00:09:59.760 --> 00:10:01.320
that would have been around 2012.


00:10:01.320 --> 00:10:02.600
- Oh, okay, so yeah,


00:10:02.600 --> 00:10:03.800
it was more established at that point.


00:10:03.800 --> 00:10:05.880
I was thinking back to early,


00:10:05.880 --> 00:10:07.140
like 2005 or something.


00:10:07.140 --> 00:10:09.460
Yeah, not quite, right?


00:10:09.460 --> 00:10:10.300
- Yeah, not quite.


00:10:10.300 --> 00:10:13.060
That was when I was still, as a little undergrad,


00:10:13.060 --> 00:10:17.440
was still able to help make building NumPy.


00:10:17.440 --> 00:10:18.440
I was able to submit patches


00:10:18.440 --> 00:10:20.820
to make building NumPy on Mac a little easier.


00:10:20.820 --> 00:10:21.660
- That's cool.


00:10:21.660 --> 00:10:23.980
Before it became completely polished


00:10:23.980 --> 00:10:25.780
and so widely used.


00:10:25.780 --> 00:10:27.300
I suspect it's really nerve-wracking


00:10:27.300 --> 00:10:29.460
to contribute to those kinds of things now.


00:10:29.460 --> 00:10:32.280
- Yeah, it was pretty exciting.


00:10:32.280 --> 00:10:35.300
But it was a nice community


00:10:35.300 --> 00:10:38.140
and it was exciting to be able to say,


00:10:38.140 --> 00:10:39.020
I have a problem.


00:10:39.020 --> 00:10:42.260
There's probably other people who have a similar problem.


00:10:42.260 --> 00:10:44.540
Let me see if I can fix it and then submit a patch.


00:10:44.540 --> 00:10:45.780
- Yeah, that's fantastic.


00:10:45.780 --> 00:10:49.480
Cool, so you're carrying on


00:10:49.480 --> 00:10:52.800
with your scientific computation work these days, right?


00:10:52.800 --> 00:10:54.640
What do you do now?


00:10:54.640 --> 00:10:57.300
- Well, so now my job is actually working on Jupyter


00:10:57.300 --> 00:11:00.660
and my Python-related stuff.


00:11:00.660 --> 00:11:02.500
So I am a senior research engineer


00:11:02.500 --> 00:11:04.900
at Simula Research Lab in Oslo, Norway.


00:11:05.660 --> 00:11:07.460
Where I've been since 2015.


00:11:07.460 --> 00:11:08.820
And I'm the head of the department


00:11:08.820 --> 00:11:11.900
of scientific computing and numerical analysis.


00:11:11.900 --> 00:11:13.220
So I'm in a department


00:11:13.220 --> 00:11:16.620
where people are doing physical simulations of the brain


00:11:16.620 --> 00:11:20.440
and studying PEs and things like that.


00:11:20.440 --> 00:11:23.780
But what I do is I work on JupyterHub.


00:11:23.780 --> 00:11:24.620
- Yeah, cool.


00:11:24.620 --> 00:11:29.620
- So we made JupyterHub as a tool for deploying


00:11:29.620 --> 00:11:32.020
while I was still at Berkeley.


00:11:32.020 --> 00:11:34.380
We made it as a tool for deploying


00:11:34.380 --> 00:11:37.100
for people who want to deploy Jupyter notebooks.


00:11:37.100 --> 00:11:40.620
We say it's for if you're a person who has computers


00:11:40.620 --> 00:11:42.580
and you have some humans and you wanna help those humans


00:11:42.580 --> 00:11:44.700
use those computers with Jupyter.


00:11:44.700 --> 00:11:46.200
That's what JupyterHub is for.


00:11:46.200 --> 00:11:51.380
And so that initially was scoped


00:11:51.380 --> 00:11:53.300
to be an extremely small project


00:11:53.300 --> 00:11:57.060
because we didn't have any maintenance burden to spare.


00:11:57.060 --> 00:12:01.940
The target of that was research groups like mine


00:12:01.940 --> 00:12:05.540
in grad school of a few people, maybe small classes


00:12:05.540 --> 00:12:07.540
who have one server in their office


00:12:07.540 --> 00:12:09.900
and they just wanna make it easier for people to log in


00:12:09.900 --> 00:12:11.660
and use Jupyter on there.


00:12:11.660 --> 00:12:13.220
This is when people-- - Right, right.


00:12:13.220 --> 00:12:15.420
- People had all their SSH tunnel,


00:12:15.420 --> 00:12:18.700
reverse SSH to my server with the open or reverse tunnel


00:12:18.700 --> 00:12:21.400
so I can point localhost and it's actually over there.


00:12:21.400 --> 00:12:25.820
So we were trying to make life easier for those folks.


00:12:25.820 --> 00:12:26.820
But then-- - Yeah, 'cause they were


00:12:26.820 --> 00:12:29.260
running the servers locally and they're like,


00:12:29.260 --> 00:12:32.500
how do I get access to my computation over there


00:12:32.500 --> 00:12:34.580
but on my machine, that kind of stuff, right?


00:12:34.580 --> 00:12:35.800
- Yeah, it's like if I'm a person


00:12:35.800 --> 00:12:38.060
who's already comfortable with Jupyter


00:12:38.060 --> 00:12:40.560
but now I have access to a computer that's over there,


00:12:40.560 --> 00:12:43.220
how do I run my notebook stuff over there?


00:12:43.220 --> 00:12:45.620
And there were a few solutions to that


00:12:45.620 --> 00:12:47.260
with involving SSH tunnels or whatever.


00:12:47.260 --> 00:12:49.820
And JupyterHub was aimed at those folks.


00:12:49.820 --> 00:12:54.360
But it turned out that's not the user community


00:12:54.360 --> 00:12:57.620
that's really been the most excited about it


00:12:58.620 --> 00:13:00.860
with things like Sierra to JupyterHub,


00:13:00.860 --> 00:13:04.860
the JupyterHub on Kubernetes started by EeveePanda


00:13:04.860 --> 00:13:07.900
and now led by a whole bunch of wonderful folks.


00:13:07.900 --> 00:13:10.660
We're shifted into a larger scale


00:13:10.660 --> 00:13:12.620
than initially designed for.


00:13:12.620 --> 00:13:17.620
- Yeah, it definitely seems like JupyterLab


00:13:17.620 --> 00:13:21.300
and the predecessors to it have really probably exploded


00:13:21.300 --> 00:13:24.340
beyond the scale that people initially expected.


00:13:24.340 --> 00:13:27.860
I mean, it's just the de facto way of doing things


00:13:27.860 --> 00:13:30.500
if you're doing computation these days, it seems.


00:13:30.500 --> 00:13:34.100
- I for certain, certain folks definitely seem to like it.


00:13:34.100 --> 00:13:38.580
We try to respond to feedback


00:13:38.580 --> 00:13:41.500
and just build things that people are gonna use.


00:13:41.500 --> 00:13:44.540
- Nice, so if you're running JupyterLab


00:13:44.540 --> 00:13:46.260
for such a big group, I mean,


00:13:46.260 --> 00:13:48.760
there's gotta be crazy amounts of computation


00:13:48.760 --> 00:13:51.940
and computer type stuff there.


00:13:51.940 --> 00:13:54.180
What does your whole setup look like there?


00:13:54.180 --> 00:13:56.820
Like what are you running for your folks


00:13:56.820 --> 00:13:57.820
at the research lab?


00:13:57.820 --> 00:14:03.140
- So I run JupyterHub instances for like a summer school


00:14:03.140 --> 00:14:06.020
and they'll run a workshop and I'll spin up a cluster


00:14:06.020 --> 00:14:10.540
for running JupyterHub for doing some physics simulations.


00:14:10.540 --> 00:14:12.220
Usually it's for teaching.


00:14:12.220 --> 00:14:14.900
So I don't operate hubs for research usually,


00:14:14.900 --> 00:14:16.340
I usually operate them for teaching


00:14:16.340 --> 00:14:17.500
and then the computation--


00:14:17.500 --> 00:14:18.820
- Yeah, so maybe the computation there,


00:14:18.820 --> 00:14:20.580
it's like, yeah, not nearly as high


00:14:20.580 --> 00:14:24.020
as we're trying to model the universe and--


00:14:24.020 --> 00:14:24.860
- Yeah, that's right.


00:14:24.860 --> 00:14:27.020
Usually, yeah, often those folks,


00:14:27.020 --> 00:14:31.260
the computation are handed off somewhere.


00:14:31.260 --> 00:14:35.580
But yeah, like the folks at NERSC in Berkeley


00:14:35.580 --> 00:14:38.000
are doing some really exciting stuff


00:14:38.000 --> 00:14:40.980
with running JupyterHub on a supercomputer.


00:14:40.980 --> 00:14:41.860
- Yeah, cool.


00:14:41.860 --> 00:14:44.420
Are you doing like Kubernetes or Docker


00:14:44.420 --> 00:14:46.380
or are you just setting up VMs


00:14:46.380 --> 00:14:47.620
or how do you handle that side?


00:14:47.620 --> 00:14:50.780
- So currently, thanks to the work of the,


00:14:50.780 --> 00:14:54.780
all the folks contributing to Zero to JupyterHub,


00:14:54.780 --> 00:14:56.060
deploying JupyterHub with Kubernetes,


00:14:56.060 --> 00:14:59.060
I think is the easiest to deploy and maintain


00:14:59.060 --> 00:15:01.700
as long as you have access to a managed Kubernetes.


00:15:01.700 --> 00:15:02.900
I still wouldn't recommend


00:15:02.900 --> 00:15:05.260
deploying Kubernetes itself to anybody.


00:15:05.260 --> 00:15:07.780
- It seems fairly complicated to run and maintain


00:15:07.780 --> 00:15:09.220
that side of things, yeah.


00:15:09.220 --> 00:15:11.660
- But if you have a turnkey solution,


00:15:11.660 --> 00:15:15.100
the one I use the most is GKE,


00:15:15.100 --> 00:15:17.380
the Google managed Kubernetes.


00:15:17.380 --> 00:15:20.700
And Zero to JupyterHub, let you just step through


00:15:20.700 --> 00:15:24.380
and say, give me a cluster and run JupyterHub on it


00:15:24.380 --> 00:15:26.060
and then all I really need to do is,


00:15:26.060 --> 00:15:28.940
for the workshop is build the user images.


00:15:28.940 --> 00:15:30.820
- Nice, very cool.


00:15:30.820 --> 00:15:33.180
You also do some stuff with Binder, is that right?


00:15:33.180 --> 00:15:35.420
- Yeah, so I help operate Binder.


00:15:35.420 --> 00:15:39.620
So mybinder.org is a service built on top of JupyterHub


00:15:39.620 --> 00:15:42.020
that takes JupyterHub as a service


00:15:42.020 --> 00:15:44.880
for running notebooks on Kubernetes,


00:15:44.880 --> 00:15:48.580
in Binder's case, it's running on Kubernetes.


00:15:48.580 --> 00:15:51.580
And Binder ties in another Jupyter project


00:15:51.580 --> 00:15:53.500
called Repo2Docker that says,


00:15:53.500 --> 00:15:55.280
look at a repo, build a Docker image


00:15:55.280 --> 00:15:56.660
with the contents of that,


00:15:56.660 --> 00:15:58.620
hopefully that can run everything.


00:15:58.620 --> 00:15:59.460
So like if it finds--


00:15:59.460 --> 00:16:01.060
- Preferably it's got a requirement, yeah, exactly.


00:16:01.060 --> 00:16:03.060
It's got something that specifies its dependencies


00:16:03.060 --> 00:16:03.900
or something like that.


00:16:03.900 --> 00:16:05.700
- Yeah, and there's a bunch of things that we support


00:16:05.700 --> 00:16:08.700
and the idea is to automate existing best practices, right?


00:16:08.700 --> 00:16:11.600
So find anything that people are already using


00:16:11.600 --> 00:16:14.140
to specify environments and then install those


00:16:14.140 --> 00:16:15.180
and then build an image.


00:16:15.180 --> 00:16:17.580
And then what Binder does is, so I've built an image,


00:16:17.580 --> 00:16:19.980
then send that over to JupyterHub to say,


00:16:19.980 --> 00:16:22.020
launch a notebook server with that image.


00:16:22.020 --> 00:16:23.860
- Right, yeah, you can see like right here


00:16:23.860 --> 00:16:26.340
just on the main site, just put it in a GitHub repo


00:16:26.340 --> 00:16:29.640
and maybe a branch or a tag or something


00:16:29.640 --> 00:16:33.140
and then click go and then it spins up literally


00:16:33.140 --> 00:16:37.380
a Jupyter notebook that you can play with.


00:16:37.380 --> 00:16:38.340
When people go to GitHub,


00:16:38.340 --> 00:16:40.940
they can oftentimes see the Jupyter notebook.


00:16:40.940 --> 00:16:42.700
And always, when I first saw them,


00:16:42.700 --> 00:16:45.780
like how in the world is GitHub


00:16:45.780 --> 00:16:48.020
computing this stuff for me to see, right?


00:16:48.020 --> 00:16:49.300
Like I see, I'm like that,


00:16:49.300 --> 00:16:51.860
maybe that is like super computationally expensive


00:16:51.860 --> 00:16:53.660
and here's the answer and like how do they know


00:16:53.660 --> 00:16:55.140
the data and the dependencies?


00:16:55.140 --> 00:16:57.620
And the reality is they've just taken


00:16:57.620 --> 00:17:01.060
what's stored in the notebook, right?


00:17:01.060 --> 00:17:04.580
That is the last run and it's there.


00:17:04.580 --> 00:17:06.380
But if you wanna play with it, you can't do that on GitHub,


00:17:06.380 --> 00:17:08.620
but you can on mybinder.org, right?


00:17:08.620 --> 00:17:10.740
That creates the, it like turns that


00:17:10.740 --> 00:17:12.140
into an interactive notebook.


00:17:12.140 --> 00:17:15.200
- Yeah, it adds interactivity to the sharing


00:17:15.200 --> 00:17:18.020
that you already have with NVV or GitHub.


00:17:18.020 --> 00:17:19.660
- Yeah, nice, yeah, very cool project.


00:17:19.660 --> 00:17:20.660
I didn't know that much about it,


00:17:20.660 --> 00:17:25.140
but I had Tim Head on the show a while ago


00:17:25.140 --> 00:17:27.580
on episode 256 to talk about that


00:17:27.580 --> 00:17:30.420
and I learned a lot, so yeah, quite neat.


00:17:30.420 --> 00:17:33.980
Now let's jump into ZeroMQ.


00:17:33.980 --> 00:17:38.980
So, you know, ZeroMQ is not a Python thing,


00:17:38.980 --> 00:17:41.740
but it is very good for Python people, right?


00:17:41.740 --> 00:17:45.380
It has support for many different languages


00:17:45.380 --> 00:17:48.420
and your work primarily has been to work


00:17:48.420 --> 00:17:51.500
on making this nice and easy from Python, right?


00:17:51.500 --> 00:17:56.340
- Yeah, so ZeroMQ is a C++, a library written in C++


00:17:56.340 --> 00:17:59.220
with a C API, which makes using it a little easier.


00:17:59.220 --> 00:18:03.500
And it's a very small API, which is part of why


00:18:03.500 --> 00:18:05.300
it's usable from so many languages,


00:18:05.300 --> 00:18:08.660
that writing bindings for it is relatively easy.


00:18:08.660 --> 00:18:13.100
And the idea of ZeroMQ is it's a,


00:18:15.220 --> 00:18:19.260
name is a little funny, 'cause it's a,


00:18:19.260 --> 00:18:21.980
it comes from the world of, the people who create it


00:18:21.980 --> 00:18:25.940
come from the world of message brokers and message queues


00:18:25.940 --> 00:18:28.340
and ZeroMQ is a tongue in cheek


00:18:28.340 --> 00:18:30.900
and it's not actually a message queue at all.


00:18:30.900 --> 00:18:35.900
It's a messaging library where it's just adding


00:18:35.900 --> 00:18:39.420
a little bit of a layer of abstraction on the network


00:18:39.420 --> 00:18:42.020
in terms of you have some distributed application


00:18:42.020 --> 00:18:43.620
where things need to talk to each other


00:18:43.620 --> 00:18:46.020
and ZeroMQ is a tool for building that.


00:18:46.020 --> 00:18:50.460
And it's this library and then you can write the bindings


00:18:50.460 --> 00:18:51.660
for that library so that you can use it


00:18:51.660 --> 00:18:54.140
from any of a variety of languages.


00:18:54.140 --> 00:18:59.020
And so Brian Granger and I worked on the Python bindings


00:18:59.020 --> 00:19:04.020
to use ZeroMQ from Python, which is called PyZMQ.


00:19:04.020 --> 00:19:05.220
- Yeah, when I first thought of it,


00:19:05.220 --> 00:19:08.780
I imagined it as like a server,


00:19:08.780 --> 00:19:12.220
and something like Redis or Celery or something like that


00:19:12.220 --> 00:19:15.860
that you start up and then you create queues


00:19:15.860 --> 00:19:17.700
or something on it and then like different things


00:19:17.700 --> 00:19:19.140
can talk to it.


00:19:19.140 --> 00:19:21.740
But I think maybe a better conceptualization of it


00:19:21.740 --> 00:19:24.260
might be like Flask, right?


00:19:24.260 --> 00:19:27.820
Flask is not a server, but a Flask is a framework


00:19:27.820 --> 00:19:31.460
that you can put into your Python app and then run it


00:19:31.460 --> 00:19:34.000
and it is the server itself, right?


00:19:34.000 --> 00:19:37.220
- Yeah, and so I'd say that ZeroMQ,


00:19:37.220 --> 00:19:41.580
the best way to describe it is it's a fancy socket library.


00:19:41.580 --> 00:19:42.420
- Yeah.


00:19:42.420 --> 00:19:44.940
- So you create sockets and you send messages.


00:19:44.940 --> 00:19:46.640
And the sockets talk to other sockets,


00:19:46.640 --> 00:19:48.520
you send messages, you receive messages.


00:19:48.520 --> 00:19:52.900
And ZeroMQ is all about what abstractions and guarantees


00:19:52.900 --> 00:19:57.100
and things it gives around those sockets and messages.


00:19:57.100 --> 00:19:57.940
- Yeah.


00:19:57.940 --> 00:20:03.500
There seems to be a lot of culture and zen about ZeroMQ.


00:20:03.500 --> 00:20:05.740
Like there's a lot of interesting like nomenclature


00:20:05.740 --> 00:20:08.700
in the way that they talk about stuff over there.


00:20:08.700 --> 00:20:11.900
So they talk about the zero in ZeroMQ


00:20:11.900 --> 00:20:13.820
and the philosophy starts with zero.


00:20:13.820 --> 00:20:17.300
Zero is for the zero broker, it's brokerless.


00:20:17.300 --> 00:20:20.700
Zero latency, zero cost, it's free, zero admin.


00:20:20.700 --> 00:20:22.820
You don't have like a server type of thing.


00:20:22.820 --> 00:20:26.180
But also to a culture of minimalism


00:20:26.180 --> 00:20:28.940
that permeates the project, adding power


00:20:28.940 --> 00:20:31.100
by removing complexity rather than exposing


00:20:31.100 --> 00:20:32.520
new functionality.


00:20:32.520 --> 00:20:33.820
You wanna speak to that just a little bit,


00:20:33.820 --> 00:20:35.920
like your experience with that?


00:20:35.920 --> 00:20:38.260
- Well, so I can speak to that as someone


00:20:38.260 --> 00:20:41.740
who doesn't work on LibZMQ that much,


00:20:41.740 --> 00:20:44.380
more somebody who writes bindings for it.


00:20:44.380 --> 00:20:47.380
I can speak to that as it's nice that LibZMQ


00:20:47.380 --> 00:20:49.260
doesn't change that much.


00:20:49.260 --> 00:20:51.500
And that part of the point of,


00:20:51.500 --> 00:20:53.800
so ZeroMQ has all these features.


00:20:53.800 --> 00:20:57.140
They have, we'll talk a little bit about it in a second.


00:20:57.140 --> 00:21:01.460
But so it's structured so there are sockets


00:21:01.460 --> 00:21:02.740
and there are different kinds of sockets


00:21:02.740 --> 00:21:04.540
that have different behaviors for building


00:21:04.540 --> 00:21:06.940
these different kinds of distributed applications.


00:21:06.940 --> 00:21:09.020
But in terms of the API, there's just one.


00:21:09.020 --> 00:21:11.240
Like a socket has an API.


00:21:11.240 --> 00:21:13.540
All sockets have the same API.


00:21:13.540 --> 00:21:17.340
So from the standpoint of writing bindings to a library,


00:21:17.340 --> 00:21:22.340
I just need to say, I know how to wrap the socket APIs.


00:21:22.340 --> 00:21:25.500
And then as they add new types,


00:21:25.500 --> 00:21:28.100
those are just constants that I need to handle.


00:21:28.100 --> 00:21:30.420
So I don't need to, oh, there's a new kind of socket.


00:21:30.420 --> 00:21:32.140
I need to implement a new Python class


00:21:32.140 --> 00:21:33.540
for that new kind of socket.


00:21:35.260 --> 00:21:37.060
I just need to wrap socket.


00:21:37.060 --> 00:21:40.160
So that's really, that's from my perspective


00:21:40.160 --> 00:21:42.300
in terms of as new features are developed


00:21:42.300 --> 00:21:44.780
and things in LibZMQ.


00:21:44.780 --> 00:21:48.900
From my perspective as a binding developer,


00:21:48.900 --> 00:21:51.500
binding maintainer, that's really nice.


00:21:51.500 --> 00:21:54.540
But it also, that also extends to the application layer


00:21:54.540 --> 00:21:58.280
that once you have a socket and you understand sockets,


00:21:58.280 --> 00:22:01.320
changing the type of socket changes your message pattern.


00:22:01.320 --> 00:22:03.540
It doesn't change anything about the APIs you need


00:22:03.540 --> 00:22:04.940
to use and things like that.


00:22:05.540 --> 00:22:07.660
- Yeah, so maybe we could talk a little bit


00:22:07.660 --> 00:22:11.900
about what the application model,


00:22:11.900 --> 00:22:13.380
I don't necessarily get into programming yet,


00:22:13.380 --> 00:22:14.660
but like the application model, right?


00:22:14.660 --> 00:22:17.660
So we've got contexts, we've got sockets


00:22:17.660 --> 00:22:18.660
and we've got messages.


00:22:18.660 --> 00:22:20.320
And those are the basic building blocks


00:22:20.320 --> 00:22:22.460
of what working with this is like.


00:22:22.460 --> 00:22:24.420
So if I wanted to create something that could,


00:22:24.420 --> 00:22:27.400
maybe other applications could talk to it


00:22:27.400 --> 00:22:29.940
and exchange data, one of my options might be


00:22:29.940 --> 00:22:34.220
to create a RESTful API that exchanges JSON, right?


00:22:34.220 --> 00:22:35.060
- Yeah, sure.


00:22:35.060 --> 00:22:36.860
- There's a lot of challenges with that.


00:22:36.860 --> 00:22:40.540
One, it's sort of send request only, right?


00:22:40.540 --> 00:22:44.460
I send over my JSON and then it gives me a response,


00:22:44.460 --> 00:22:47.700
but I can't subscribe to future changes, right?


00:22:47.700 --> 00:22:50.180
I gotta do something like web sockets in that world


00:22:50.180 --> 00:22:51.300
if I want something like that,


00:22:51.300 --> 00:22:53.740
which I guess might be closer to this.


00:22:53.740 --> 00:22:56.660
And then also it's doing the text conversion.


00:22:56.660 --> 00:22:59.300
It's probably a little bit slower.


00:22:59.300 --> 00:23:01.160
You gotta do maybe extra work for async, right?


00:23:01.160 --> 00:23:05.120
So there's a lot of things that are maybe similar,


00:23:05.120 --> 00:23:07.020
but extra patterns, right?


00:23:07.020 --> 00:23:08.660
So instead of just request response,


00:23:08.660 --> 00:23:13.660
you might have pub sub, you might have like multicast,


00:23:13.660 --> 00:23:17.160
like something comes in and everyone gets notified about it.


00:23:17.160 --> 00:23:19.280
Can you talk about some of those differences,


00:23:19.280 --> 00:23:22.240
like maybe compare it to what other more common APIs


00:23:22.240 --> 00:23:23.840
people might know about?


00:23:23.840 --> 00:23:26.320
- Yeah, so the main thing that distinguishes ZRMQ


00:23:26.320 --> 00:23:29.240
is that you have, so a context is kind of


00:23:29.240 --> 00:23:31.240
an implementation detail that you shouldn't


00:23:31.240 --> 00:23:34.320
need to care about, but you still need to create.


00:23:34.320 --> 00:23:38.320
Sockets are the main thing that you deal with


00:23:38.320 --> 00:23:42.560
and you create a socket and every socket has a type.


00:23:42.560 --> 00:23:45.900
And that type determines the messaging pattern.


00:23:45.900 --> 00:23:49.040
So that means that's where we're getting at


00:23:49.040 --> 00:23:52.020
these kind of protocols and messaging patterns.


00:23:52.020 --> 00:23:55.100
So with a web server, that's usually


00:23:55.100 --> 00:23:56.500
a request reply pattern.


00:23:56.500 --> 00:23:59.240
So you have clients connect, send a request,


00:23:59.240 --> 00:24:00.540
and then they get a reply.


00:24:00.540 --> 00:24:04.620
A pub sub system might be some totally different thing,


00:24:04.620 --> 00:24:08.820
maybe in web server land, maybe it's a server side events,


00:24:08.820 --> 00:24:12.640
you know, an event stream connection.


00:24:12.640 --> 00:24:15.600
And with ZRMQ, the difference between those


00:24:15.600 --> 00:24:16.720
is the socket type.


00:24:16.720 --> 00:24:20.100
So if you're creating a publish subscribe relationship,


00:24:20.100 --> 00:24:22.400
you create a publish socket on one side


00:24:22.400 --> 00:24:24.720
and you create a subscribe socket on the other side.


00:24:24.720 --> 00:24:27.200
If you're doing a request reply,


00:24:27.200 --> 00:24:30.160
you use a socket called a dealer and a router.


00:24:30.160 --> 00:24:32.400
There's a request and a reply socket in ZRMQ,


00:24:32.400 --> 00:24:34.100
but nobody should ever use them.


00:24:34.100 --> 00:24:38.320
They're just a special case of router dealer.


00:24:38.320 --> 00:24:40.320
And then there's another one called a,


00:24:40.320 --> 00:24:42.240
pattern called like a ventilator and sink.


00:24:42.240 --> 00:24:45.240
So that's like what you'd use in a work queue,


00:24:45.240 --> 00:24:48.640
for instance, where you've got a source of work


00:24:48.640 --> 00:24:53.040
and then it sends a message to one destination,


00:24:54.100 --> 00:24:56.020
but you don't necessarily care which one.


00:24:56.020 --> 00:25:00.200
- I see, so maybe you're trying to do scaled out computing.


00:25:00.200 --> 00:25:01.040
- Yeah, exactly.


00:25:01.040 --> 00:25:04.360
- You've got 10 machines that could all do the work


00:25:04.360 --> 00:25:07.480
and you want to somehow evenly distribute that work, right?


00:25:07.480 --> 00:25:08.560
So you're like, all right, well,


00:25:08.560 --> 00:25:11.020
we're just going to throw it at ZRMQ.


00:25:11.020 --> 00:25:14.080
All the things that are available to do work can subscribe.


00:25:14.080 --> 00:25:16.440
If they need to, they could even like drop out


00:25:16.440 --> 00:25:17.800
after doing some work,


00:25:17.800 --> 00:25:20.400
but then not receive any more potentially.


00:25:20.400 --> 00:25:21.680
- Yeah, exactly.


00:25:21.680 --> 00:25:23.000
So that's what ZRMQ,


00:25:23.000 --> 00:25:25.000
one of the main things that ZRMQ does is it,


00:25:25.000 --> 00:25:29.800
it takes control over those things like multiple peers


00:25:29.800 --> 00:25:32.560
and connection events and stuff like that.


00:25:32.560 --> 00:25:37.320
Because take the, for example, the publish subscribe,


00:25:37.320 --> 00:25:38.640
there's two key,


00:25:38.640 --> 00:25:42.280
the things to think about with ZRMQ are,


00:25:42.280 --> 00:25:47.120
what happens when you've got more than one peer connected?


00:25:47.120 --> 00:25:48.040
- Right.


00:25:48.040 --> 00:25:52.440
- And, or what happens when you've got nobody sent to?


00:25:52.440 --> 00:25:54.720
So in the publish subscribe model,


00:25:54.720 --> 00:25:58.040
what it does is when you send a message on a socket,


00:25:58.040 --> 00:25:59.920
it will send, it will immediately send that message


00:25:59.920 --> 00:26:02.840
to everybody who's connected and ready.


00:26:02.840 --> 00:26:05.300
So if somebody is not able to keep up, right,


00:26:05.300 --> 00:26:06.680
there's like a queue that's building up


00:26:06.680 --> 00:26:09.040
and it's gotten full, it'll just drop,


00:26:09.040 --> 00:26:12.000
stop, drop messages to that peer until they catch up.


00:26:12.000 --> 00:26:14.800
If there are no peers, then it's really fast


00:26:14.800 --> 00:26:16.000
'cause it just doesn't send anything


00:26:16.000 --> 00:26:17.040
and just delete them.


00:26:19.760 --> 00:26:24.560
So when you're thinking of ZRMQ from Python,


00:26:24.560 --> 00:26:28.840
sending messages is really,


00:26:28.840 --> 00:26:32.160
the other thing about it is that it's asynchronous,


00:26:32.160 --> 00:26:35.080
that send is not actually,


00:26:35.080 --> 00:26:37.920
send doesn't return when the message is on the TCP buffer


00:26:37.920 --> 00:26:42.420
or whatever, send returns when you have handed control


00:26:42.420 --> 00:26:46.560
of the message to the ZRMQ IO thread.


00:26:46.560 --> 00:26:50.120
And this is why ZRMQ has this concept of context.


00:26:50.120 --> 00:26:51.720
Contexts are what own the IO threads


00:26:51.720 --> 00:26:53.880
that actually do all the real work


00:26:53.880 --> 00:26:55.920
of talking to over the network.


00:26:55.920 --> 00:26:58.160
So when you're sending in PyZMQ,


00:26:58.160 --> 00:27:02.120
you're really just passing ownership of the memory to ZRMQ


00:27:02.120 --> 00:27:03.480
and it returns immediately.


00:27:03.480 --> 00:27:05.400
And so you don't actually know


00:27:05.400 --> 00:27:07.600
when that message is finally sent.


00:27:07.600 --> 00:27:10.120
And you shouldn't care.


00:27:10.120 --> 00:27:13.280
Sometimes you do care and it can get complicated.


00:27:13.280 --> 00:27:15.560
But ZRMQ tries to make you not care.


00:27:16.560 --> 00:27:17.400
- Interesting.


00:27:17.400 --> 00:27:21.320
So basically you set up the relationships


00:27:21.320 --> 00:27:23.800
between the clients and the server


00:27:23.800 --> 00:27:26.440
through these different models.


00:27:26.440 --> 00:27:29.240
And then you drop off the messages to ZRMQ


00:27:29.240 --> 00:27:31.680
and it deals from there, right?


00:27:31.680 --> 00:27:34.160
It figures out who gets what and when.


00:27:34.160 --> 00:27:36.120
And so your application,


00:27:36.120 --> 00:27:38.360
as soon as it gets the message passed off


00:27:38.360 --> 00:27:42.680
to the ZRMQ layer, it can go about doing other stuff, right?


00:27:42.680 --> 00:27:43.520
- Right, exactly.


00:27:43.520 --> 00:27:46.960
So ZRMQ, because it's a C++ library,


00:27:46.960 --> 00:27:48.480
it's not gonna grab the GIL or anything.


00:27:48.480 --> 00:27:50.760
So it's a true, even if you're using Python,


00:27:50.760 --> 00:27:52.720
it's a true multi-threaded application,


00:27:52.720 --> 00:27:55.520
even if you're only using one Python thread.


00:27:55.520 --> 00:27:57.520
- Yeah. - Because you hand


00:27:57.520 --> 00:28:00.040
that memory off to C++, which is running in the background.


00:28:00.040 --> 00:28:02.800
You can do some GIT holding intense operation


00:28:02.800 --> 00:28:07.080
and ZRMQ will be happily dealing with all the network stuff.


00:28:07.080 --> 00:28:07.920
- Right, right.


00:28:07.920 --> 00:28:09.440
It's got its own C++ thread,


00:28:09.440 --> 00:28:10.720
which has nothing to do with the GIL


00:28:10.720 --> 00:28:12.560
and they go do its own thing, right?


00:28:12.560 --> 00:28:14.680
- Right. - Nice.


00:28:14.680 --> 00:28:17.600
- It can, there is something that comes up in PyZMQ


00:28:17.600 --> 00:28:19.400
where it can come back and try to grab the GIL


00:28:19.400 --> 00:28:22.880
from the IO thread, or it used to, it doesn't anymore,


00:28:22.880 --> 00:28:26.040
because Python does actually need to know


00:28:26.040 --> 00:28:27.600
when it let go of that memory


00:28:27.600 --> 00:28:30.160
in order to avoid false.


00:28:30.160 --> 00:28:34.240
But that's an implementation to do.


00:28:34.240 --> 00:28:36.040
- Right, right, okay, cool.


00:28:36.040 --> 00:28:41.040
So is there anything about reliable messaging here


00:28:41.600 --> 00:28:45.040
where you could say, I wanna make sure


00:28:45.040 --> 00:28:48.760
that this message gets delivered to every client?


00:28:48.760 --> 00:28:51.040
Like if you said, for example, in this Pub/Sub,


00:28:51.040 --> 00:28:52.960
if someone fall behind, it can just drop the messages.


00:28:52.960 --> 00:28:56.000
Is there a way to say, pile that up


00:28:56.000 --> 00:28:59.900
and then send it along when it catches up or whatever?


00:28:59.900 --> 00:29:02.840
- Yeah, so the ZRMQ perspective


00:29:02.840 --> 00:29:04.640
is that that's an application level problem.


00:29:04.640 --> 00:29:08.480
So ZRMQ helps you build the messaging there


00:29:08.480 --> 00:29:12.440
to not, so that it doesn't crash.


00:29:12.440 --> 00:29:16.020
And then, and that's part of why it drops messages.


00:29:16.020 --> 00:29:19.400
And then it basically, it's up to you to say,


00:29:19.400 --> 00:29:20.560
you know, if you're sending messages


00:29:20.560 --> 00:29:23.000
and there's a generation counter, for instance,


00:29:23.000 --> 00:29:25.160
and you notice, I got message five


00:29:25.160 --> 00:29:26.760
and then I got message eight,


00:29:26.760 --> 00:29:28.720
it's up to your application to say,


00:29:28.720 --> 00:29:33.200
okay, keep a recent history buffer


00:29:33.200 --> 00:29:35.840
so that folks can come back with a different pattern,


00:29:35.840 --> 00:29:37.880
a request reply pattern to say,


00:29:37.880 --> 00:29:40.720
give me a batch of recent messages that I missed


00:29:40.720 --> 00:29:42.760
so that I can resume.


00:29:42.760 --> 00:29:45.240
But ZRMQ doesn't help you with that.


00:29:45.240 --> 00:29:48.040
- Yeah, okay.


00:29:48.040 --> 00:29:50.080
But it handles all the networking stuff,


00:29:50.080 --> 00:29:52.040
so you don't have to worry about that.


00:29:52.040 --> 00:29:53.120
You just have to worry about like,


00:29:53.120 --> 00:29:55.840
how do we set up a way to ask again


00:29:55.840 --> 00:29:58.160
or have the application ask it once more?


00:29:58.160 --> 00:29:59.900
Yeah, nice.


00:29:59.900 --> 00:30:03.960
David out there on the live stream asks,


00:30:03.960 --> 00:30:06.360
what alternatives to ZRMQ could have been used


00:30:06.360 --> 00:30:07.800
to build the Jupyter protocol?


00:30:07.800 --> 00:30:10.440
So maybe before we, thanks for the question.


00:30:10.440 --> 00:30:12.320
Before we get to that though,


00:30:12.320 --> 00:30:14.280
maybe let's just talk about like,


00:30:14.280 --> 00:30:17.960
oh wait, ZRMQ is used to build the Jupyter protocol?


00:30:17.960 --> 00:30:18.800
- Yeah, yeah.


00:30:18.800 --> 00:30:20.560
So the Jupyter protocol,


00:30:20.560 --> 00:30:23.640
which essentially started out in IPython parallel.


00:30:23.640 --> 00:30:27.160
So we had this interactive parallel computing


00:30:27.160 --> 00:30:31.280
networking framework that eventually evolved into,


00:30:31.280 --> 00:30:32.880
wait, we've got this network protocol


00:30:32.880 --> 00:30:34.720
for remote computation.


00:30:34.720 --> 00:30:38.360
We can build basically a REPL protocol,


00:30:38.360 --> 00:30:40.640
an interactive shell protocol.


00:30:40.640 --> 00:30:45.640
And that ultimately became the Jupyter protocol,


00:30:45.640 --> 00:30:51.720
which was built with this kind of ZRMQ mindset of,


00:30:51.720 --> 00:30:55.440
I wanna be able to have multiple front ends


00:30:55.440 --> 00:30:57.180
at the same time.


00:30:57.180 --> 00:31:01.360
So let's say, and we had in 2010, I think,


00:31:01.360 --> 00:31:03.400
Fernando and Brian had a working prototype


00:31:03.400 --> 00:31:06.560
of real-time collaboration on a terminal.


00:31:06.560 --> 00:31:09.240
So you've got, using this protocol,


00:31:09.240 --> 00:31:10.520
so you've got two people at the terminal,


00:31:10.520 --> 00:31:12.400
you're typing, you can run code


00:31:12.400 --> 00:31:14.880
and you can see each other's output.


00:31:14.880 --> 00:31:16.940
So we built the Jupyter protocol


00:31:16.940 --> 00:31:20.200
with multiple connections in mind.


00:31:20.200 --> 00:31:23.160
So that means there's this request reply socket.


00:31:23.160 --> 00:31:26.520
So the front end sends a request to please run this code


00:31:26.520 --> 00:31:30.360
and the backend sends a reply saying, I ran that,


00:31:30.360 --> 00:31:32.080
here's the result.


00:31:32.080 --> 00:31:34.400
And there's another channel called IOPub


00:31:34.400 --> 00:31:35.760
where we publish output.


00:31:35.760 --> 00:31:38.440
So when you do a print statement


00:31:38.440 --> 00:31:41.960
or you display a Matplotlib figure,


00:31:41.960 --> 00:31:45.200
that's a message that goes on a Pub/Sub channel,


00:31:45.200 --> 00:31:48.320
which means that every connected front end,


00:31:48.320 --> 00:31:51.040
so you could have multiple JupyterLab instances,


00:31:51.040 --> 00:31:54.020
they'll all receive the same message.


00:31:54.020 --> 00:31:57.600
- Right, I mean, that sounds like the perfect example


00:31:57.600 --> 00:31:58.680
of Pub/Sub.


00:31:58.680 --> 00:32:00.080
Somebody's making a change,


00:32:01.080 --> 00:32:03.280
somebody has triggered the server to make a change,


00:32:03.280 --> 00:32:06.000
but it doesn't matter who started that change,


00:32:06.000 --> 00:32:07.920
everybody looking at it wants to see the output, right?


00:32:07.920 --> 00:32:09.200
- Right.


00:32:09.200 --> 00:32:12.280
And so to answer the question of,


00:32:12.280 --> 00:32:14.360
and this becomes particularly important


00:32:14.360 --> 00:32:17.760
in the design of IPython parallel,


00:32:17.760 --> 00:32:19.280
but getting to the question of what alternatives


00:32:19.280 --> 00:32:22.120
to ZRMQ could have been used for the Jupyter protocol.


00:32:22.120 --> 00:32:23.640
So when we were designing it,


00:32:23.640 --> 00:32:25.800
we thought this protocol of talking directly to kernels


00:32:25.800 --> 00:32:27.200
was gonna be the main thing.


00:32:28.600 --> 00:32:33.280
It turns out that the main way in 2020 or 2021,


00:32:33.280 --> 00:32:34.560
I guess we're in now,


00:32:34.560 --> 00:32:41.720
most kernels talk one-to-one with a notebook web server,


00:32:41.720 --> 00:32:43.320
and it's the web server that's the one


00:32:43.320 --> 00:32:46.140
that's actually spanning out to multiple clients.


00:32:46.140 --> 00:32:50.480
With that being the case,


00:32:50.480 --> 00:32:53.480
if we had required the notebook server


00:32:53.480 --> 00:32:57.520
to be the place where we do all the multiplexing


00:32:57.520 --> 00:33:01.200
and everything, we could have actually built


00:33:01.200 --> 00:33:03.160
the lower level Jupyter protocol on something much simpler,


00:33:03.160 --> 00:33:06.720
just an HTTP rest and event stream


00:33:06.720 --> 00:33:08.040
probably could have worked just fine.


00:33:08.040 --> 00:33:09.640
- Right, maybe just use web sockets


00:33:09.640 --> 00:33:12.160
or something on the web server side.


00:33:12.160 --> 00:33:14.480
- Yeah, if web sockets had existed at the time.


00:33:14.480 --> 00:33:16.080
- Yeah, yeah, yeah, sure.


00:33:16.080 --> 00:33:17.680
Yeah, I mean, that's just a year's easy.


00:33:17.680 --> 00:33:19.680
Yeah, so much of that stuff's easier now,


00:33:19.680 --> 00:33:21.360
and the browser support it and so on.


00:33:21.360 --> 00:33:23.320
So yeah, super interesting.


00:33:23.320 --> 00:33:26.760
Now, one thing that that makes me think of is,


00:33:26.760 --> 00:33:31.760
how much, how close are we to some sort of


00:33:31.760 --> 00:33:38.240
Google Docs JupyterLab type of thing?


00:33:38.240 --> 00:33:39.360
I mean, we're not there, right?


00:33:39.360 --> 00:33:43.240
I know there's SageMath and there's Google Colab.


00:33:43.240 --> 00:33:46.480
There's other systems where this does exist,


00:33:46.480 --> 00:33:49.080
where there's sort of, we can all type on the notebook,


00:33:49.080 --> 00:33:50.920
same cell, same time type of thing.


00:33:50.920 --> 00:33:52.280
Is there anything like that, JupyterLab,


00:33:52.280 --> 00:33:55.020
that I just didn't miss, or I missed?


00:33:55.020 --> 00:33:59.300
- So there've been, I think, three prototypes at this point


00:33:59.300 --> 00:34:01.880
that have been developed and are,


00:34:01.880 --> 00:34:05.680
and ultimately not finished for various reasons.


00:34:05.680 --> 00:34:08.160
There's another one that's picking up again


00:34:08.160 --> 00:34:09.700
and going strong using Yjs,


00:34:09.700 --> 00:34:14.920
working with QuantStack, I believe.


00:34:14.920 --> 00:34:17.380
- Okay. - So, hopefully soon.


00:34:17.380 --> 00:34:19.680
That's not an area of the project


00:34:19.680 --> 00:34:21.160
where I've done a lot of work.


00:34:21.160 --> 00:34:23.160
I helped a little bit with the last one.


00:34:23.160 --> 00:34:25.180
- Well, I mean, to me it sounds like


00:34:25.180 --> 00:34:28.180
that's just all JavaScript front-end craziness,


00:34:28.180 --> 00:34:30.700
and not a whole lot of other stuff, right?


00:34:30.700 --> 00:34:32.780
- Yeah, the state probably lives on the server,


00:34:32.780 --> 00:34:34.200
so you need to have a server,


00:34:34.200 --> 00:34:36.680
whether it's running CRDT or whatever,


00:34:36.680 --> 00:34:37.940
to synchronize the state.


00:34:37.940 --> 00:34:41.220
- And the Pub/Sub, yeah, as well, for the changes, yeah.


00:34:41.220 --> 00:34:44.580
Going down the rabbit hole for a minute,


00:34:44.580 --> 00:34:49.580
I'll also, Noah asked an interesting question about 0MQ.


00:34:50.180 --> 00:34:53.720
What's the story with 0MQ and microservices, right?


00:34:53.720 --> 00:34:56.980
Like, when I think microservices,


00:34:56.980 --> 00:34:59.520
people often set up a whole bunch of little small flask


00:34:59.520 --> 00:35:04.280
or FastAPI things that talk JSON exchange request response,


00:35:04.280 --> 00:35:09.280
but man, like the performance and the multiplexing,


00:35:09.280 --> 00:35:10.680
all those types of things,


00:35:10.680 --> 00:35:13.160
sound like it actually could be a really awesome


00:35:13.160 --> 00:35:16.000
non-HTTP-based microservice.


00:35:16.000 --> 00:35:19.360
- Yeah, I think 0MQ is a really good fit


00:35:19.360 --> 00:35:23.040
for microservice-based distributed applications,


00:35:23.040 --> 00:35:24.800
because one of the things you do


00:35:24.800 --> 00:35:26.640
when you're designing with microservices


00:35:26.640 --> 00:35:28.840
is you're defining the communication relationship


00:35:28.840 --> 00:35:31.400
and your scaling axes,


00:35:31.400 --> 00:35:36.400
and a nice thing to do with 0MQ is to say,


00:35:36.400 --> 00:35:39.720
that your application doesn't change


00:35:39.720 --> 00:35:41.560
when you've got a bunch of peers.


00:35:41.560 --> 00:35:43.060
Your application doesn't even need to know


00:35:43.060 --> 00:35:46.080
when a new peer comes and goes, 'cause 0MQ handles that.


00:35:46.080 --> 00:35:48.240
So one of the things that's nifty about,


00:35:48.240 --> 00:35:50.560
that's weird and magical, but also really useful


00:35:50.560 --> 00:35:53.960
about 0MQ is it abstracts binding


00:35:53.960 --> 00:35:56.360
and connecting and transports.


00:35:56.360 --> 00:35:58.560
So you can have the same application


00:35:58.560 --> 00:35:59.800
with the same connection pattern,


00:35:59.800 --> 00:36:01.640
and maybe this one binds,


00:36:01.640 --> 00:36:05.360
and maybe one side binds and one side connects.


00:36:05.360 --> 00:36:07.240
So pub binds and sub connects,


00:36:07.240 --> 00:36:09.800
but you can also have sub bind and pub connect.


00:36:09.800 --> 00:36:12.280
You can also have pub, your pub bind once


00:36:12.280 --> 00:36:13.480
and connect three times,


00:36:13.480 --> 00:36:16.440
and none of that changes how your application behaves.


00:36:16.440 --> 00:36:19.040
It just changes where the connections go.


00:36:19.040 --> 00:36:19.880
- Right.


00:36:19.880 --> 00:36:23.200
So with microservices, when you're doing HTTP requests,


00:36:23.200 --> 00:36:24.040
you always gotta figure out,


00:36:24.040 --> 00:36:26.000
"Okay, well, what's the URL I'm going to?"


00:36:26.000 --> 00:36:27.760
And sometimes that even gets real tricky


00:36:27.760 --> 00:36:31.160
with what is even the URL of the identity server?


00:36:31.160 --> 00:36:34.560
What is the URL of the thing that manages the catalog


00:36:34.560 --> 00:36:35.720
before I even request it?


00:36:35.720 --> 00:36:37.640
And then usually that's a single endpoint


00:36:37.640 --> 00:36:39.560
HTTP request type of thing,


00:36:39.560 --> 00:36:41.260
if it's like an update notification.


00:36:41.260 --> 00:36:43.120
So yeah, I can imagine that there's some real


00:36:43.120 --> 00:36:44.500
interesting things here.


00:36:45.340 --> 00:36:46.780
The other thing is-- - Yes, we might--


00:36:46.780 --> 00:36:47.620
- Sorry, go ahead.


00:36:47.620 --> 00:36:48.900
No, go ahead.


00:36:48.900 --> 00:36:53.080
- Yeah, so you can have, in a distributed work


00:36:53.080 --> 00:36:58.080
kind of situation, you can have one or a few sources of work


00:36:58.080 --> 00:37:01.260
and then you have an elastic number of workers


00:37:01.260 --> 00:37:04.660
that just connect and start receiving messages.


00:37:04.660 --> 00:37:07.860
And the way this is in kind of the push-pull pattern.


00:37:07.860 --> 00:37:10.900
So pub-sub is always send them,


00:37:10.900 --> 00:37:13.460
every message you send, send it to everybody connected


00:37:13.460 --> 00:37:15.180
who can receive a message.


00:37:15.180 --> 00:37:17.540
Whereas push-pull is whenever you send a message,


00:37:17.540 --> 00:37:20.780
send it to exactly one peer, and I don't care which one.


00:37:20.780 --> 00:37:22.660
And so if more peers are connected,


00:37:22.660 --> 00:37:24.900
it will load balance across all those peers.


00:37:24.900 --> 00:37:25.980
But if only one's connected,


00:37:25.980 --> 00:37:27.860
it will just keep sending to that one.


00:37:27.860 --> 00:37:32.420
And at no point in the sender,


00:37:32.420 --> 00:37:35.240
do you ever need to know how many,


00:37:35.240 --> 00:37:37.580
you never get notified that peers are connecting.


00:37:37.580 --> 00:37:40.040
You never need to know that there are any peers,


00:37:40.040 --> 00:37:42.300
that there's one peer, that there's a thousand peers.


00:37:42.300 --> 00:37:43.460
It doesn't matter.


00:37:43.460 --> 00:37:46.060
So then it's in your distributed application to say,


00:37:46.060 --> 00:37:50.740
this one's sending with this push-pull pattern,


00:37:50.740 --> 00:37:51.860
ventilator sync pattern,


00:37:51.860 --> 00:37:56.300
and then I just elastically grow my number of workers


00:37:56.300 --> 00:37:58.980
and shut them down and they just connect and close,


00:37:58.980 --> 00:38:01.060
disconnect and everything, and it just works.


00:38:01.060 --> 00:38:01.940
- Interesting.


00:38:01.940 --> 00:38:04.460
Okay, so follow up question from Nawa,


00:38:04.460 --> 00:38:05.660
that makes me think.


00:38:05.660 --> 00:38:07.600
So he asked, he, she, sorry,


00:38:07.600 --> 00:38:10.820
asked whether it is a good idea


00:38:10.820 --> 00:38:14.020
to replace REST communication with CRMQ.


00:38:14.020 --> 00:38:17.380
And so that leads me to wonder,


00:38:17.380 --> 00:38:19.020
you talked about, you send the message


00:38:19.020 --> 00:38:20.980
and it's sort of fire and forget style,


00:38:20.980 --> 00:38:23.100
like message sent, success.


00:38:23.100 --> 00:38:25.280
But so often what I wanna do is,


00:38:25.280 --> 00:38:29.620
I need to know what products are offered on sale right now


00:38:29.620 --> 00:38:32.820
from the sale microservice or whatever.


00:38:32.820 --> 00:38:34.380
I need to get the answer back,


00:38:34.380 --> 00:38:36.340
these three products, thank you.


00:38:36.340 --> 00:38:37.180
You know what I mean?


00:38:37.180 --> 00:38:40.120
How do I, how would I implement something like that


00:38:40.120 --> 00:38:42.700
where I send a message but I want the answer?


00:38:42.700 --> 00:38:46.140
- Yeah, so that's the request reply pattern.


00:38:46.140 --> 00:38:50.940
So you would use either the request reply sockets


00:38:50.940 --> 00:38:55.940
or the router dealer sockets for that kind of pattern.


00:38:55.940 --> 00:38:58.180
And that's, you send a message.


00:38:58.180 --> 00:39:03.180
So in that case, this does have multi-peer semantics,


00:39:03.180 --> 00:39:06.580
but usually the requester is connected to one endpoint.


00:39:06.580 --> 00:39:08.860
It can be connected to several,


00:39:08.860 --> 00:39:11.200
in which case it'll load balance its requests.


00:39:11.200 --> 00:39:17.280
And the router, so the receiver side, handles requests


00:39:17.280 --> 00:39:21.160
and each request comes in with a message prefix


00:39:21.160 --> 00:39:25.440
that identifies who that message came from.


00:39:25.440 --> 00:39:29.920
And then it can send replies using that identity prefix


00:39:29.920 --> 00:39:32.640
and it will go to whoever sent that request.


00:39:32.640 --> 00:39:35.680
And that's how most of the Jupyter protocol


00:39:35.680 --> 00:39:37.720
is a request reply pattern.


00:39:37.720 --> 00:39:39.380
- Yeah, sure, yeah, I guess that makes sense


00:39:39.380 --> 00:39:42.160
'cause you want the answer from the computation or whatever.


00:39:42.160 --> 00:39:44.960
You want to know that it's done and so on.


00:39:44.960 --> 00:39:48.320
Interesting, okay, yeah, well, that's pretty neat.


00:39:48.320 --> 00:39:50.540
The other thing that comes to mind around this


00:39:50.540 --> 00:39:51.840
is serialization.


00:39:51.840 --> 00:39:55.720
So when I'm doing microservices, I make JSON documents.


00:39:55.720 --> 00:39:57.780
I know what things go in JSON, right?


00:39:57.780 --> 00:40:01.680
Like fundamental type, strings, integers, and so on.


00:40:01.680 --> 00:40:05.680
Surprisingly, dates and times can't go into JSON.


00:40:05.680 --> 00:40:08.000
That blow, I still, like, this is 2021.


00:40:08.000 --> 00:40:10.320
We can't come up with a text representation


00:40:10.320 --> 00:40:11.200
of what time it is.


00:40:11.200 --> 00:40:14.760
Anyway, so that's a bit of a pain.


00:40:14.760 --> 00:40:16.760
It seems to me like you might be able to exchange


00:40:16.760 --> 00:40:20.680
more data more efficiently using a binary.


00:40:20.680 --> 00:40:23.560
And it's not even going over the HTTP layer, right?


00:40:23.560 --> 00:40:27.680
It's going literally over a TCP socket.


00:40:27.680 --> 00:40:31.920
- Yeah, or IPC with BST sockets or UDP.


00:40:31.920 --> 00:40:33.240
- Even lower level than that, yeah.


00:40:33.240 --> 00:40:35.600
Not even touching the network stack, right?


00:40:35.600 --> 00:40:40.240
So, yeah, this gets us to the last piece of XeromQ


00:40:40.240 --> 00:40:41.360
that we haven't talked about yet,


00:40:41.360 --> 00:40:43.240
and that's what is a message?


00:40:43.240 --> 00:40:45.120
So one of the other nice things,


00:40:45.120 --> 00:40:48.600
if you've worked with a lower level socket library,


00:40:48.600 --> 00:40:50.480
just talking TCP sockets,


00:40:50.480 --> 00:40:52.480
you know you have to deal with chunks


00:40:52.480 --> 00:40:54.020
and then figure out when you're done


00:40:54.020 --> 00:40:55.480
with your message protocol.


00:40:55.480 --> 00:40:57.160
Like if you've ever written an HTTP server,


00:40:57.160 --> 00:40:59.520
you know you need to find those double blank lines


00:40:59.520 --> 00:41:03.880
and all that stuff before you know that you have a request


00:41:03.880 --> 00:41:06.320
that you can hand off to your request handler.


00:41:06.320 --> 00:41:08.400
- Right, right, you're doing a whole lot of funky,


00:41:08.400 --> 00:41:10.120
like parsing the header, okay?


00:41:10.120 --> 00:41:12.440
The header it says it's the next 100 bytes


00:41:12.440 --> 00:41:13.800
of the thing that I'm getting,


00:41:13.800 --> 00:41:15.400
and this one is an int, so I'm gonna parse,


00:41:15.400 --> 00:41:17.400
like it's gnarly stuff.


00:41:17.400 --> 00:41:19.080
I've worked on projects where we did that,


00:41:19.080 --> 00:41:22.800
and it's super fast, but boy, it's low level business.


00:41:22.800 --> 00:41:24.440
- Yeah, and that's what, so that's what something


00:41:24.440 --> 00:41:26.840
like Flask does for you, right?


00:41:26.840 --> 00:41:29.360
It implements the HTTP protocol and then says,


00:41:29.360 --> 00:41:32.480
okay, here's a request, please send a reply.


00:41:32.480 --> 00:41:35.340
And it helps you construct that reply message.


00:41:35.340 --> 00:41:39.760
So ZMQ or PyZMQ live at that level of Flask


00:41:39.760 --> 00:41:44.760
where a message is a, not one binary blob,


00:41:44.760 --> 00:41:48.360
but a collection of binary blobs.


00:41:48.360 --> 00:41:53.200
And ZMQ always delivers whole messages,


00:41:53.200 --> 00:41:56.080
so it's atomic and it's asynchronous in its messaging,


00:41:56.080 --> 00:41:58.880
which means you will never get part of a message.


00:41:58.880 --> 00:42:01.220
There's no like, okay, I got the first third


00:42:01.220 --> 00:42:04.040
of this message, keep it in my own buffer


00:42:04.040 --> 00:42:06.280
until I get to the end.


00:42:06.280 --> 00:42:09.960
A ZMQ socket does not become readable


00:42:09.960 --> 00:42:13.480
until an entire message is ready to be read.


00:42:13.480 --> 00:42:14.880
- Right, and there may be buffering down


00:42:14.880 --> 00:42:17.120
the C++ layer, but it's not gonna tell you


00:42:17.120 --> 00:42:19.880
I've received a thing until it's fully baked.


00:42:19.880 --> 00:42:21.840
- Right, yeah, all that stuff still happens.


00:42:21.840 --> 00:42:24.080
It's just ZMQ takes care of that,


00:42:24.080 --> 00:42:28.600
and then when at the PyZMQ level,


00:42:28.600 --> 00:42:33.600
or at the ZMQ API level, when you receive with a socket,


00:42:33.600 --> 00:42:36.320
or in PyZMQ you say receive multi-part,


00:42:36.320 --> 00:42:41.140
you get a list of blobs of memory.


00:42:41.140 --> 00:42:44.180
And so if you're talking about serialization with JSON,


00:42:44.180 --> 00:42:47.780
so PyZMQ has a helper function called sendJSON,


00:42:47.780 --> 00:42:51.420
and it's literally just JSON.dumps thing,


00:42:51.420 --> 00:42:52.260
and then send it.


00:42:52.260 --> 00:42:57.340
With a little, ensuring UTF-8 bytes, I think.


00:42:57.340 --> 00:42:58.580
- Yeah, yeah, nice.


00:42:58.580 --> 00:43:02.340
- So PyZMQ, and this is really,


00:43:02.340 --> 00:43:04.620
turned out to be really important for,


00:43:04.620 --> 00:43:08.380
more important for IPython parallel


00:43:08.380 --> 00:43:11.700
than it turned out to be for the Jupyter protocol.


00:43:11.700 --> 00:43:14.660
- I'm not familiar with IPython parallel.


00:43:14.660 --> 00:43:15.500
Tell me about this.


00:43:15.500 --> 00:43:17.160
- So IPython parallel is,


00:43:17.160 --> 00:43:20.060
so if you're aware of the Jupyter protocol,


00:43:20.060 --> 00:43:21.580
it's a network protocol for,


00:43:21.580 --> 00:43:23.780
I've got somewhere over the network


00:43:23.780 --> 00:43:25.500
where I wanna run code,


00:43:25.500 --> 00:43:27.820
and I have this protocol for sending messages,


00:43:27.820 --> 00:43:30.380
please run this code, give me a return output,


00:43:30.380 --> 00:43:31.860
show me display stuff.


00:43:31.860 --> 00:43:33.660
IPython parallel is a kind of weird


00:43:33.660 --> 00:43:36.660
parallel computing library based on the fact that,


00:43:36.660 --> 00:43:38.860
so I've got a network protocol to talk to,


00:43:38.860 --> 00:43:41.780
to run code remotely.


00:43:41.780 --> 00:43:44.280
Why don't I just wrap that in a little bit


00:43:44.280 --> 00:43:48.580
to talk to N remote places?


00:43:48.580 --> 00:43:50.380
- Maybe partition up the work across them


00:43:50.380 --> 00:43:51.220
or something like that.


00:43:51.220 --> 00:43:52.300
- Yeah, exactly.


00:43:52.300 --> 00:43:56.300
And the fun thing about ZMQ is that


00:43:56.300 --> 00:43:59.460
in a Jupyter notebook, the kernel is the server.


00:43:59.460 --> 00:44:02.460
The kernel listens for connections on its various sockets.


00:44:02.460 --> 00:44:04.620
And then the notebook server, the web server,


00:44:04.620 --> 00:44:08.640
or the QT console or the terminal is a client,


00:44:08.640 --> 00:44:10.300
and it connects to those sockets.


00:44:10.300 --> 00:44:14.660
IPython parallel, because of this fun stuff about ZMQ


00:44:14.660 --> 00:44:17.820
not caring about connection direction or count,


00:44:17.820 --> 00:44:21.200
adds a scheduler layer,


00:44:21.200 --> 00:44:24.100
and it modifies the kernel,


00:44:24.100 --> 00:44:26.900
the IPython kernel that you'd use in a Jupyter notebook,


00:44:26.900 --> 00:44:28.460
and the only change it makes is


00:44:28.460 --> 00:44:30.620
instead of binding on those sockets,


00:44:30.620 --> 00:44:33.940
it connects to a central scheduler.


00:44:33.940 --> 00:44:35.640
And the kernel's otherwise identical,


00:44:35.640 --> 00:44:37.340
the message protocol's otherwise identical,


00:44:37.340 --> 00:44:39.020
but the connection direction is different


00:44:39.020 --> 00:44:41.660
because the many to one relationship is different.


00:44:41.660 --> 00:44:44.020
There's one controller and many engines


00:44:44.020 --> 00:44:47.020
instead of many clients connecting to one kernel.


00:44:48.140 --> 00:44:53.140
And then, again, using some of the magic


00:44:53.140 --> 00:44:57.320
of the ZMQ routing identities,


00:44:57.320 --> 00:45:02.320
there's a multiplexer in PyZMQ


00:45:02.320 --> 00:45:04.840
called a monitored queue,


00:45:04.840 --> 00:45:08.320
where if you have router sockets,


00:45:08.320 --> 00:45:10.520
so a router socket is one where the first,


00:45:10.520 --> 00:45:12.360
so we talked about a ZMQ message


00:45:12.360 --> 00:45:14.820
is a sequence of blobs of memory.


00:45:16.800 --> 00:45:18.300
So it can just be one.


00:45:18.300 --> 00:45:20.660
With a router socket, it's always at least two,


00:45:20.660 --> 00:45:25.180
because the first part is the routing identity


00:45:25.180 --> 00:45:28.380
to tell the underlying ZMQ which peer


00:45:28.380 --> 00:45:30.260
should it actually send to.


00:45:30.260 --> 00:45:31.100
- Sure, okay.


00:45:31.100 --> 00:45:33.340
That's cool, and we don't have to worry about that,


00:45:33.340 --> 00:45:35.260
'cause that's down at the low level, right?


00:45:35.260 --> 00:45:36.700
But that's what happens.


00:45:36.700 --> 00:45:40.260
- Well, you need to know about it in that you need to,


00:45:40.260 --> 00:45:41.520
when you get a request,


00:45:41.520 --> 00:45:43.020
you need to remember that first part,


00:45:43.020 --> 00:45:44.060
so when you send a reply,


00:45:44.060 --> 00:45:46.420
the first part of the reply is the ID


00:45:46.420 --> 00:45:47.400
that came with the request.


00:45:47.400 --> 00:45:49.480
- Got it, got it, so it goes back to the right place.


00:45:49.480 --> 00:45:51.000
- Yeah, but you can also use that,


00:45:51.000 --> 00:45:52.400
if you know the IDs,


00:45:52.400 --> 00:45:55.640
you can send messages to a destination


00:45:55.640 --> 00:45:58.700
without being in response to a request, right?


00:45:58.700 --> 00:45:59.840
What a router really is,


00:45:59.840 --> 00:46:01.880
is a socket that can route messages


00:46:01.880 --> 00:46:04.280
based on this identity prefix.


00:46:04.280 --> 00:46:06.720
So if you have a bundle of identity prefixes,


00:46:06.720 --> 00:46:10.060
then you can send messages to anyone at any time.


00:46:10.060 --> 00:46:14.360
And that allows us to build a multiplexing scheduler


00:46:14.360 --> 00:46:16.900
that from one client connected to one scheduler,


00:46:16.900 --> 00:46:18.460
just send messages,


00:46:18.460 --> 00:46:21.860
regular, plain old, XeromQ protocol messages,


00:46:21.860 --> 00:46:25.180
but with an identity prefix from the client,


00:46:25.180 --> 00:46:27.180
and those will end up at the right kernel


00:46:27.180 --> 00:46:31.820
just by the magic of XeromQ routing identity.


00:46:31.820 --> 00:46:32.660
- Yeah, yeah, yeah.


00:46:32.660 --> 00:46:37.040
- And so this is a substantially different messaging pattern,


00:46:37.040 --> 00:46:40.860
so the request reply patterns are all the same,


00:46:40.860 --> 00:46:43.300
but the connection patterns are totally different.


00:46:44.280 --> 00:46:48.720
And the client and the endpoint


00:46:48.720 --> 00:46:49.880
don't need to know about it at all,


00:46:49.880 --> 00:46:52.360
we just have this adapter in the middle.


00:46:52.360 --> 00:46:54.280
- I feel like to really get the zen of this


00:46:54.280 --> 00:46:55.200
and take full advantage,


00:46:55.200 --> 00:46:57.120
you've gotta really think about


00:46:57.120 --> 00:47:00.280
these messaging patterns and styles a little bit,


00:47:00.280 --> 00:47:01.880
'cause they're fairly different than,


00:47:01.880 --> 00:47:03.800
this is what I know from web servers.


00:47:03.800 --> 00:47:06.980
- Yeah, so the big thing to do with,


00:47:06.980 --> 00:47:08.800
if you're getting into XeromQ is to read,


00:47:08.800 --> 00:47:10.160
there's something called the guide,


00:47:10.160 --> 00:47:13.440
so there'll be a link in the notes,


00:47:13.440 --> 00:47:16.920
and if you go to xeromq.org, it'll be prominently linked.


00:47:16.920 --> 00:47:19.560
This goes through the different patterns


00:47:19.560 --> 00:47:22.640
that XeromQ thinks about, the abstractions in XeromQ,


00:47:22.640 --> 00:47:27.120
and the different socket types and what they're for,


00:47:27.120 --> 00:47:29.400
and the guide will help you,


00:47:29.400 --> 00:47:32.740
and there are examples in many languages, including Python.


00:47:32.740 --> 00:47:35.840
- Yeah, this is great, yeah.


00:47:35.840 --> 00:47:39.480
- Build little boy example patterns


00:47:39.480 --> 00:47:42.720
of here's a publish/subscribe application,


00:47:42.720 --> 00:47:45.840
here's a ventilator sync application,


00:47:45.840 --> 00:47:47.680
and then it also does things--


00:47:47.680 --> 00:47:48.840
- With pictures.


00:47:48.840 --> 00:47:52.560
- Yes, yeah, yeah, so that's a really,


00:47:52.560 --> 00:47:55.560
that's I think the way to internalize


00:47:55.560 --> 00:47:58.280
what are the XeromQ concepts and how do I deal with this.


00:47:58.280 --> 00:47:59.880
So when it comes to serialization,


00:47:59.880 --> 00:48:02.600
this is really important for IPython Parallel,


00:48:02.600 --> 00:48:04.560
and it also comes up if you're in Jupyter


00:48:04.560 --> 00:48:05.760
and use the interactive widgets,


00:48:05.760 --> 00:48:07.720
if you use the really intense ones


00:48:07.720 --> 00:48:10.120
that do like 3D visualization,


00:48:10.120 --> 00:48:11.720
interactive 3D visualization in the browser


00:48:11.720 --> 00:48:14.780
that sometimes are streaming a lot of data from the kernel.


00:48:14.780 --> 00:48:19.080
Because a XeromQ, this combines two things,


00:48:19.080 --> 00:48:22.520
one from PyXmq and one from XeromQ itself,


00:48:22.520 --> 00:48:24.680
so the XeromQ concept that a message


00:48:24.680 --> 00:48:26.940
is actually a collection of frames.


00:48:26.940 --> 00:48:32.360
This lets you, and another,


00:48:32.360 --> 00:48:34.720
that XeromQ can be zero copy,


00:48:34.720 --> 00:48:36.560
and PyXmq supports zero copy,


00:48:36.560 --> 00:48:39.200
so anything that supports the Python buffer interface


00:48:39.200 --> 00:48:43.080
can be sent without copying,


00:48:43.080 --> 00:48:44.920
meaning it's still copied over the network,


00:48:44.920 --> 00:48:47.880
but at no point are there any copies in memory.


00:48:47.880 --> 00:48:52.160
So you can send 100 megabyte NumPy array


00:48:52.160 --> 00:48:56.300
with XeromQ without copying it,


00:48:56.300 --> 00:48:57.960
but then you've got to think about,


00:48:57.960 --> 00:49:00.520
oh wait, if I send a NumPy array


00:49:00.520 --> 00:49:01.840
using the Python buffer interface,


00:49:01.840 --> 00:49:03.080
all I got were the bytes.


00:49:04.120 --> 00:49:07.840
Where's the D type information?


00:49:07.840 --> 00:49:10.260
How do I know this is a 2D array of integers?


00:49:10.260 --> 00:49:17.360
Because a message is, in Python language,


00:49:17.360 --> 00:49:22.320
is a list of chunk of blobs instead of a single blob,


00:49:22.320 --> 00:49:25.640
you can serialize that metadata as a header


00:49:25.640 --> 00:49:29.940
and the blob you don't want to copy, the big one, separately.


00:49:29.940 --> 00:49:34.940
So you can say, Jason dumps some message metadata


00:49:34.940 --> 00:49:38.500
that tells you how to interpret the binary blob,


00:49:38.500 --> 00:49:41.440
and then just the binary blob, and you don't copy it.


00:49:41.440 --> 00:49:44.380
So then you can send, as one message,


00:49:44.380 --> 00:49:46.960
we're not breaking the single message delivery,


00:49:46.960 --> 00:49:51.300
you have your metadata that's serialized with message pack.


00:49:51.300 --> 00:49:53.980
- It comes as a frame or something like that in the message?


00:49:53.980 --> 00:49:55.300
Yeah. - Yeah.


00:49:55.300 --> 00:49:58.320
So one frame is your header,


00:49:58.320 --> 00:50:00.380
one frame is the data itself.


00:50:00.380 --> 00:50:02.060
And we do this in the Jupyter protocol,


00:50:02.060 --> 00:50:04.220
that the Jupyter protocol has an arbitrary number


00:50:04.220 --> 00:50:06.220
of buffers on the end.


00:50:06.220 --> 00:50:07.980
But then there are three frames


00:50:07.980 --> 00:50:11.020
that are actually Jason serialized dictionaries.


00:50:11.020 --> 00:50:13.340
- Nice, very cool, very cool.


00:50:13.340 --> 00:50:14.940
Yeah, looking at the guide here,


00:50:14.940 --> 00:50:20.940
it says there's 60 diagrams and 750 examples


00:50:20.940 --> 00:50:22.160
in 28 languages.


00:50:22.160 --> 00:50:25.780
That's a big cross-product matrix of options in here,


00:50:25.780 --> 00:50:28.640
you can also download it as a PDF to take with you,


00:50:28.640 --> 00:50:30.560
which, yeah, this looks like a really great place


00:50:30.560 --> 00:50:31.400
to get started.


00:50:31.400 --> 00:50:33.800
Speaking of getting started,


00:50:33.800 --> 00:50:38.800
let's talk about programming with the Python aspect here.


00:50:38.800 --> 00:50:43.320
All right, so here we'll use PyZMQ,


00:50:43.320 --> 00:50:46.720
and this is a library that you work on as well, yeah?


00:50:46.720 --> 00:50:48.840
- Yeah, I maintain PyZMQ.


00:50:48.840 --> 00:50:49.800
- Yeah, awesome.


00:50:49.800 --> 00:50:53.320
So maybe, it's hard to talk about code,


00:50:53.320 --> 00:50:55.140
but just give us a sense of what it's like


00:50:55.140 --> 00:50:56.120
to create a server.


00:50:56.120 --> 00:50:59.760
Like in Flask, you know, I say app equals Flask,


00:50:59.760 --> 00:51:03.640
and then I decorate app.route on a function.


00:51:03.640 --> 00:51:08.280
Like, what's the zero MQ Python equivalent of that?


00:51:08.280 --> 00:51:11.800
- Yeah, so first you always have to create a context,


00:51:11.800 --> 00:51:15.080
and then use that context as a socket method


00:51:15.080 --> 00:51:16.360
that creates sockets.


00:51:16.360 --> 00:51:21.900
And then you either bind or connect those sockets,


00:51:21.900 --> 00:51:23.880
and then you start sending and receiving messages.


00:51:23.880 --> 00:51:25.780
So if you're writing a server,


00:51:25.780 --> 00:51:29.700
which usually means this is the one that binds.


00:51:29.700 --> 00:51:33.700
So you'd create a socket, you'd call socket.bind,


00:51:33.700 --> 00:51:35.880
and give it a URL, maybe a TCP URL,


00:51:35.880 --> 00:51:39.460
or an IPC URL with a local path.


00:51:39.460 --> 00:51:44.780
And then you'd go into a loop saying, you know,


00:51:44.780 --> 00:51:47.700
receive a message, handle that message, send a reply.


00:51:47.700 --> 00:51:49.540
Or if it's a publisher--


00:51:49.540 --> 00:51:52.420
- Yeah, sorry, they often have a while true loop


00:51:52.420 --> 00:51:53.380
sort of thing, right?


00:51:53.380 --> 00:51:56.020
Just while true, wait for somebody to talk to me.


00:51:56.020 --> 00:51:57.260
Or while-- - Yeah, that's a simple version.


00:51:57.260 --> 00:52:01.620
Or you could be integrated into asyncio,


00:52:01.620 --> 00:52:05.260
or tornado, or gevent, or whatever.


00:52:05.260 --> 00:52:06.500
- Yeah.


00:52:06.500 --> 00:52:10.060
Yeah, one of the fundamental principles of zero MQ


00:52:10.060 --> 00:52:11.700
is that it's async all over the place.


00:52:11.700 --> 00:52:15.740
What's the async and await story with pyzmq?


00:52:15.740 --> 00:52:17.320
Is there any integration there?


00:52:17.320 --> 00:52:20.060
- Yeah, so if you do import zmq.asyncio,


00:52:20.060 --> 00:52:23.360
instead of, if you do import zmq.asyncio


00:52:23.360 --> 00:52:26.580
as zmq, you will have the same thing,


00:52:26.580 --> 00:52:29.420
but send and receive are awaitable instead.


00:52:29.420 --> 00:52:30.700
- Oh, that's glorious.


00:52:30.700 --> 00:52:33.940
Yeah, that's really, really fantastic.


00:52:33.940 --> 00:52:35.300
So you should be able to scale that


00:52:35.300 --> 00:52:39.920
to handling lots of concurrent exchanges.


00:52:39.920 --> 00:52:41.460
Pretty straightforward, right?


00:52:41.460 --> 00:52:44.380
- Yeah, and that's how, so taking Jupyter as an example,


00:52:44.380 --> 00:52:48.780
again, so the Jupyter notebook uses the tornado framework,


00:52:48.780 --> 00:52:50.540
which if you're getting into asyncio,


00:52:50.540 --> 00:52:53.480
tornado is basically asyncio before asyncio.


00:52:53.480 --> 00:52:57.060
- Right, yeah, it's early days, early take asyncio, yeah.


00:52:57.060 --> 00:53:01.680
- Yeah, so, and there we use something called a zmq stream,


00:53:01.680 --> 00:53:05.840
which is something inspired by tornado's IO stream,


00:53:05.840 --> 00:53:09.800
which is their wrapper around a regular socket.


00:53:09.800 --> 00:53:11.340
It's like bytes are coming in,


00:53:11.340 --> 00:53:14.960
call events when bytes have arrived.


00:53:14.960 --> 00:53:19.000
Zmq stream is a tornado thing that says


00:53:19.000 --> 00:53:21.920
when you have an on receive method


00:53:21.920 --> 00:53:25.320
that passes a callback, it says whenever there's a message,


00:53:25.320 --> 00:53:29.120
call this callback with the message after receiving it.


00:53:29.120 --> 00:53:31.520
And so that's actually how the IPython kernel


00:53:31.520 --> 00:53:35.460
and Jupyter notebook work on the zmq side,


00:53:35.460 --> 00:53:37.800
is with these zmq stream objects.


00:53:37.800 --> 00:53:38.680
- Yeah, cool.


00:53:38.680 --> 00:53:41.840
So the example you talked about is how to create a server,


00:53:41.840 --> 00:53:45.680
but the web version would be use request


00:53:45.680 --> 00:53:48.360
to do a request.get against the server


00:53:48.360 --> 00:53:50.280
to be the client that talks to it.


00:53:50.280 --> 00:53:54.080
What's that version in PyZmQ?


00:53:54.080 --> 00:53:57.220
- In PyZmQ, a client looks very much like a server,


00:53:57.220 --> 00:54:00.460
except instead of bind, you'd call connect.


00:54:00.460 --> 00:54:02.680
And you generally--


00:54:02.680 --> 00:54:04.780
- And instead of receive, you'd do a send, yeah?


00:54:04.780 --> 00:54:07.800
- Yeah, and so in a request reply pattern,


00:54:07.800 --> 00:54:10.560
yeah, so wherever you have a receive on the server side,


00:54:10.560 --> 00:54:12.940
you have a send on the client side and vice versa.


00:54:12.940 --> 00:54:14.700
So in a request reply pattern,


00:54:14.700 --> 00:54:18.320
the client is doing send a request


00:54:18.320 --> 00:54:20.680
and then receive to get the reply.


00:54:20.680 --> 00:54:23.560
In a server, you're doing receive a request


00:54:23.560 --> 00:54:24.600
and send the reply.


00:54:24.600 --> 00:54:27.340
In Pub/Sub, you're only sending.


00:54:27.340 --> 00:54:30.000
On the publisher side and on the sub-subscriber side,


00:54:30.000 --> 00:54:31.100
you're only receiving.


00:54:31.100 --> 00:54:34.120
- Nice, and the way you set this,


00:54:34.120 --> 00:54:35.560
you basically choose these things,


00:54:35.560 --> 00:54:37.760
is when you go to the context and you create the socket,


00:54:37.760 --> 00:54:39.760
you tell it what kind of pattern you're looking for?


00:54:39.760 --> 00:54:41.160
Is that where you specify that?


00:54:41.160 --> 00:54:43.320
- Yeah, so zmq has a bunch of constants


00:54:43.320 --> 00:54:45.840
that identify socket types.


00:54:45.840 --> 00:54:47.920
So you'd use, when you create a socket,


00:54:47.920 --> 00:54:50.280
you always have to give it a single argument


00:54:50.280 --> 00:54:51.320
that is the socket type.


00:54:51.320 --> 00:54:54.280
So it'd be like zmq.pub for a publisher socket,


00:54:54.280 --> 00:54:56.320
zmq.sub for a subscriber socket,


00:54:56.320 --> 00:54:59.600
router, dealer, push, pull.


00:54:59.600 --> 00:55:02.920
That defines the messaging pattern


00:55:02.920 --> 00:55:05.480
of the underlying sockets.


00:55:05.480 --> 00:55:07.400
- Nice, and yeah, sorry, you also have


00:55:07.400 --> 00:55:10.880
some JupyterLab examples,


00:55:10.880 --> 00:55:12.840
which I guess we can link to as well,


00:55:12.840 --> 00:55:15.080
like some diagrams for that, right?


00:55:15.080 --> 00:55:19.720
- Yeah, so the Jupyter protocol has a diagram of,


00:55:19.720 --> 00:55:22.320
a diagram that we maybe should redesign.


00:55:22.320 --> 00:55:26.240
- Okay, maybe not that far, oh, there we go.


00:55:26.240 --> 00:55:28.200
- That shows you basically what happens


00:55:28.200 --> 00:55:31.600
when you have one kernel and multiple front ends


00:55:31.600 --> 00:55:33.980
connected to it with the different socket types


00:55:33.980 --> 00:55:35.560
that we have in the Jupyter protocol.


00:55:35.560 --> 00:55:39.200
So the Jupyter kernel has two router sockets


00:55:40.340 --> 00:55:44.740
and a pub socket, and a fully featured front end


00:55:44.740 --> 00:55:49.380
would have two dealer sockets or request sockets


00:55:49.380 --> 00:55:51.900
and a sub socket.


00:55:51.900 --> 00:55:53.500
- Wow, how neat.


00:55:53.500 --> 00:55:55.940
It's just so much is happening below the scenes.


00:55:55.940 --> 00:55:58.180
I think getting your mind around these is really neat,


00:55:58.180 --> 00:56:00.860
but basically, zeroMQ is handling so much of this


00:56:00.860 --> 00:56:02.000
for everyone, right?


00:56:02.000 --> 00:56:04.620
- Yeah, it's handling all the,


00:56:04.620 --> 00:56:07.860
so we never care about there's multiple peers connected.


00:56:09.460 --> 00:56:10.620
We don't need to deal with that.


00:56:10.620 --> 00:56:12.260
We have no connection events.


00:56:12.260 --> 00:56:17.220
Some folks working on different issues


00:56:17.220 --> 00:56:18.960
that causes headaches for them,


00:56:18.960 --> 00:56:22.580
because, so there's some aspects of zeroMQ,


00:56:22.580 --> 00:56:25.500
like the not guaranteed pub/sub delivery


00:56:25.500 --> 00:56:28.060
is actually kind of a pain,


00:56:28.060 --> 00:56:30.860
because in,


00:56:30.860 --> 00:56:35.140
because we actually want all of this.


00:56:35.140 --> 00:56:36.140
- Yeah, yeah, of course.


00:56:36.140 --> 00:56:39.660
Is there any, around a lot of libraries,


00:56:39.660 --> 00:56:41.940
there's stuff that adds layers that does stuff,


00:56:41.940 --> 00:56:44.660
so like Flask extensions and stuff like that.


00:56:44.660 --> 00:56:47.580
Is there an extension that will let you do


00:56:47.580 --> 00:56:50.620
reliable messaging that you can plug in on top of this?


00:56:50.620 --> 00:56:54.860
- So there are, yeah, so if you look at the zeroMQ guide,


00:56:54.860 --> 00:56:57.300
there are different patterns,


00:56:57.300 --> 00:56:59.500
some of which are basic uses of sockets,


00:56:59.500 --> 00:57:03.980
so there's no reason to build another layer of software


00:57:03.980 --> 00:57:07.340
on, in order to implement that,


00:57:07.340 --> 00:57:09.320
like a simple ventilator pattern,


00:57:09.320 --> 00:57:13.220
but if you're talking about things like reliable messaging,


00:57:13.220 --> 00:57:16.300
there are some patterns in the guide,


00:57:16.300 --> 00:57:17.580
and they have names,


00:57:17.580 --> 00:57:21.420
and so some people have written those protocols


00:57:21.420 --> 00:57:23.580
as standalone Python packages that say, like,


00:57:23.580 --> 00:57:27.300
implement this scheme on top of zmq


00:57:27.300 --> 00:57:31.100
that might have things like message replay,


00:57:32.500 --> 00:57:36.660
or election stuff, like if you do Kubernetes things,


00:57:36.660 --> 00:57:38.060
they're often leader elections


00:57:38.060 --> 00:57:40.900
to allow you to scale and migrate things,


00:57:40.900 --> 00:57:43.620
so you can do that with zeroMQ applications, too.


00:57:43.620 --> 00:57:45.580
- Yeah, and some of those reliable messaging things


00:57:45.580 --> 00:57:47.500
sound amazing, and you go, yeah, that's gonna be great,


00:57:47.500 --> 00:57:49.740
but there's other drawbacks to those as well,


00:57:49.740 --> 00:57:52.180
like poison messages, like,


00:57:52.180 --> 00:57:53.640
I gotta make sure I send this,


00:57:53.640 --> 00:57:55.700
but the server, the client can't receive it,


00:57:55.700 --> 00:57:57.500
so they crash, so then I try to send it again,


00:57:57.500 --> 00:57:59.100
and you're just in these weird loops,


00:57:59.100 --> 00:58:01.740
and there's a lot of, they all have their challenges.


00:58:01.740 --> 00:58:02.580
- Yeah.


00:58:02.580 --> 00:58:06.580
- So another thing that I think would be interesting


00:58:06.580 --> 00:58:09.540
to touch on for our conversation,


00:58:09.540 --> 00:58:11.060
which we've spent so much time talking


00:58:11.060 --> 00:58:12.900
about all the programming patterns and stuff


00:58:12.900 --> 00:58:14.340
that I don't know we have as much time,


00:58:14.340 --> 00:58:15.980
maybe, as we imagined, but--


00:58:15.980 --> 00:58:16.980
- Yeah, that's fine.


00:58:16.980 --> 00:58:22.540
- Building PyZMQ for,


00:58:22.540 --> 00:58:24.900
basically to wrap this C library, right,


00:58:24.900 --> 00:58:27.100
this is, some challenges you've had,


00:58:27.100 --> 00:58:30.620
it supports both CPython and PyPI, sorry, PyPy,


00:58:31.020 --> 00:58:34.420
yeah, and whatnot, so maybe talk about


00:58:34.420 --> 00:58:35.420
some of the ways you did that,


00:58:35.420 --> 00:58:38.020
you had to do this in the early days


00:58:38.020 --> 00:58:40.180
when there was Python 2 and 3,


00:58:40.180 --> 00:58:41.080
there's a lot of stuff going on,


00:58:41.080 --> 00:58:43.380
maybe pre-wheels, right?


00:58:43.380 --> 00:58:45.420
- Yeah, so a few years pre-wheels,


00:58:45.420 --> 00:58:47.060
so with IPython and Jupyter,


00:58:47.060 --> 00:58:49.140
our target audience is pretty wide, right,


00:58:49.140 --> 00:58:51.340
we have a lot of people in education,


00:58:51.340 --> 00:58:54.700
a lot of students, a lot of people on Windows.


00:58:54.700 --> 00:58:56.960
- A lot of those people don't even want to be programmers


00:58:56.960 --> 00:58:58.380
or care about, like, who wants,


00:58:58.380 --> 00:58:59.420
they just want this to work,


00:58:59.420 --> 00:59:00.660
why won't this thing install,


00:59:00.660 --> 00:59:03.400
I just need to do this for my class or for my project,


00:59:03.400 --> 00:59:05.340
it needs to work, right?


00:59:05.340 --> 00:59:08.960
- Yeah, and so having a compiled dependency


00:59:08.960 --> 00:59:13.960
was a big deal for a lot of people,


00:59:13.960 --> 00:59:17.340
and so making binary releases


00:59:17.340 --> 00:59:20.860
as widely installable as possible


00:59:20.860 --> 00:59:22.780
was really important to us,


00:59:22.780 --> 00:59:26.860
and supporting as many Python implementations as possible


00:59:26.860 --> 00:59:28.200
was also important to us.


00:59:29.040 --> 00:59:34.040
So, PyZenQ was originally written all in Cython,


00:59:34.040 --> 00:59:39.200
which is a wonderful library for this,


00:59:39.200 --> 00:59:41.200
when you're interfacing with a C library,


00:59:41.200 --> 00:59:43.100
especially when you want to do things


00:59:43.100 --> 00:59:45.080
with the buffer interface,


00:59:45.080 --> 00:59:48.680
so when you have a C object and a Python object


00:59:48.680 --> 00:59:50.360
that represent the same memory,


00:59:50.360 --> 00:59:52.900
Cython is the best.


00:59:52.900 --> 00:59:53.920
- Right.


00:59:53.920 --> 00:59:55.920
- And so that's a lot of what we do,


00:59:55.920 --> 01:00:00.080
we do a lot of the PyGroCop stuff in PyZenQ.


01:00:00.080 --> 01:00:03.840
So, when we were working on this,


01:00:03.840 --> 01:00:04.960
wheels didn't exist.


01:00:04.960 --> 01:00:07.920
- Wheels being the binary version


01:00:07.920 --> 01:00:10.240
that you get from PyPI now.


01:00:10.240 --> 01:00:12.820
- Yeah, so if you pip install something like PyZenQ,


01:00:12.820 --> 01:00:14.280
it doesn't compile it, right?


01:00:14.280 --> 01:00:15.960
You get a wheel, and that just unzips it,


01:00:15.960 --> 01:00:17.200
and it's really nice.


01:00:17.200 --> 01:00:19.100
But at the time, there were only eggs.


01:00:19.100 --> 01:00:22.400
And there was a period of time


01:00:22.400 --> 01:00:26.640
when pip was taking over from easy install,


01:00:26.640 --> 01:00:29.040
which was eventually wonderful,


01:00:29.040 --> 01:00:30.840
but one of the drawbacks was,


01:00:30.840 --> 01:00:32.820
during this time when pip was taking over,


01:00:32.820 --> 01:00:34.160
there was still no wheels.


01:00:34.160 --> 01:00:37.440
And so people had started shifting to pip


01:00:37.440 --> 01:00:39.080
because easy install did a lot of things


01:00:39.080 --> 01:00:40.240
that people don't like.


01:00:40.240 --> 01:00:45.000
But you had to use easy install


01:00:45.000 --> 01:00:46.480
if you wanted to get a binary,


01:00:46.480 --> 01:00:48.680
which means, effectively, if you're on Windows,


01:00:48.680 --> 01:00:50.080
you had to use easy install.


01:00:51.020 --> 01:00:52.660
And so we had a really complicated,


01:00:52.660 --> 01:00:54.940
there actually used to be a big delay,


01:00:54.940 --> 01:00:57.660
might even still be there, in PyZenQ.


01:00:57.660 --> 01:00:58.740
No, this is definitely not,


01:00:58.740 --> 01:01:00.140
so there was a big delay in PyZenQ


01:01:00.140 --> 01:01:03.180
that if you ran setup.py, it would sleep for 10 seconds


01:01:03.180 --> 01:01:04.580
and show you a big message that says,


01:01:04.580 --> 01:01:06.100
you might want to easy install.


01:01:06.100 --> 01:01:12.380
But now we're in a very different world, right?


01:01:12.380 --> 01:01:14.580
So even after wheels, it was a couple years


01:01:14.580 --> 01:01:18.840
before we had many Linux wheels, right?


01:01:18.840 --> 01:01:20.860
There was a while before you were even allowed


01:01:20.860 --> 01:01:22.140
to make wheels for Linux.


01:01:22.140 --> 01:01:29.060
And now we're at a place where we've got wheels


01:01:29.060 --> 01:01:32.560
for ARM Max and ARM Linux


01:01:32.560 --> 01:01:36.220
and a bunch of different Linux versions


01:01:36.220 --> 01:01:39.780
and Windows and everything.


01:01:39.780 --> 01:01:44.020
And it's a really different world


01:01:44.020 --> 01:01:45.060
and a lot of things would be different


01:01:45.060 --> 01:01:46.020
if we were starting this project now.


01:01:46.020 --> 01:01:46.900
- Right, it would be easier


01:01:46.900 --> 01:01:48.620
if you started now, probably, right?


01:01:48.620 --> 01:01:49.940
- Yeah, it would be a lot easier.


01:01:49.940 --> 01:01:52.460
We were getting in on some early stuff.


01:01:52.460 --> 01:01:54.140
But one of the wonderful things about Cython


01:01:54.140 --> 01:01:55.340
is that if you're writing Cython,


01:01:55.340 --> 01:01:57.160
you're really writing C, right?


01:01:57.160 --> 01:01:58.740
If you're writing Cython code,


01:01:58.740 --> 01:02:03.740
it's generating a C program


01:02:03.740 --> 01:02:05.980
that calls the Python C API.


01:02:05.980 --> 01:02:09.660
- Right, you write Python with a little typing stuff.


01:02:09.660 --> 01:02:12.140
It turns that into C and then compiles that


01:02:12.140 --> 01:02:13.300
to machine instructions, right?


01:02:13.300 --> 01:02:17.340
Like you're basically projecting C somehow, yeah.


01:02:17.340 --> 01:02:21.420
- Yeah, and you're basically writing C


01:02:21.420 --> 01:02:22.580
that looks like Python.


01:02:22.580 --> 01:02:28.940
But the nice thing about C is that with directives


01:02:28.940 --> 01:02:31.520
and things, you can have one file


01:02:31.520 --> 01:02:34.100
that actually contains 10 different files


01:02:34.100 --> 01:02:39.340
because you can just turn off lines when it's compiling.


01:02:39.340 --> 01:02:41.420
And that means that it's much easier


01:02:41.420 --> 01:02:44.420
to write Cython code that supported Python.


01:02:44.420 --> 01:02:47.420
At the time, we were supporting Python 2.5 through 3.1.


01:02:47.420 --> 01:02:52.360
And with a single code base, we had no two to three,


01:02:52.360 --> 01:02:55.460
none of that, single code base in 2010


01:02:55.460 --> 01:02:57.900
supporting Python 2.5 and Python 3.1


01:02:57.900 --> 01:02:59.380
and everything in between.


01:02:59.380 --> 01:03:01.860
- Wow, that's quite the accomplishment.


01:03:01.860 --> 01:03:06.420
- And the tricks were all dealing with PyZMQ.


01:03:06.420 --> 01:03:08.500
We were early adopters of a lot of the Python concepts,


01:03:08.500 --> 01:03:11.580
Python 3 concepts of we talk bytes, we don't talk str.


01:03:13.500 --> 01:03:16.940
Disambiguate, we use bytes and Unicode everywhere.


01:03:16.940 --> 01:03:20.300
- There's not necessarily that many differences


01:03:20.300 --> 01:03:24.540
between Python 2 and 3, but you could make them different.


01:03:24.540 --> 01:03:26.700
But in a lot of the more modern Python 2,


01:03:26.700 --> 01:03:30.980
you could still be much closer to what eventually


01:03:30.980 --> 01:03:33.580
became Python 3, yeah?


01:03:33.580 --> 01:03:38.420
- Yeah, and so I would say it was either 3.3 or 3.4,


01:03:38.420 --> 01:03:43.180
it became the norm to have single code base,


01:03:43.180 --> 01:03:47.220
single syntax support 2.7, so drop support for 2.6,


01:03:47.220 --> 01:03:49.700
support 2.7 and I think 3.3 or above,


01:03:49.700 --> 01:03:52.680
or 3.4 and above, whenever they let you back in.


01:03:52.680 --> 01:03:56.500
Because then it became easier.


01:03:56.500 --> 01:03:59.020
- Yeah, what's the story with Python 2 now?


01:03:59.020 --> 01:04:00.260
Does it still support it?


01:04:00.260 --> 01:04:06.620
- Just as of December, right, so Python 2 end of life


01:04:06.620 --> 01:04:07.920
was last December.


01:04:09.540 --> 01:04:14.420
Python, so PyZMQ dropped support,


01:04:14.420 --> 01:04:16.820
the latest release requires Python 3.6 actually.


01:04:16.820 --> 01:04:22.340
- Nice, I feel like a lot of people are going to 3.6.


01:04:22.340 --> 01:04:23.900
Why did you guys choose 3.6?


01:04:23.900 --> 01:04:26.500
Is it f-strings or was it something else?


01:04:26.500 --> 01:04:27.900
- It was actually the typing.


01:04:27.900 --> 01:04:29.620
- All right.


01:04:29.620 --> 01:04:31.780
- So one of the main complaints about PyZMQ


01:04:31.780 --> 01:04:35.820
is it's so auto-generated and dynamically defined, right?


01:04:35.820 --> 01:04:38.120
'Cause we didn't just target multiple versions of Python,


01:04:38.120 --> 01:04:40.220
there's also multiple versions of LibZMQ.


01:04:40.220 --> 01:04:46.220
And that means that PyZMQ, what constants are defined


01:04:46.220 --> 01:04:48.940
is different depending on what version of LibZMQ is linked,


01:04:48.940 --> 01:04:50.740
which meant that a lot of, the way it's written,


01:04:50.740 --> 01:04:53.080
a lot of static analysis fails.


01:04:53.080 --> 01:04:56.500
So when you're auto-completing based on static analysis,


01:04:56.500 --> 01:04:59.300
you know, all the constants don't show up.


01:04:59.300 --> 01:05:01.660
And so that was an occasional, you know, folks like,


01:05:01.660 --> 01:05:03.760
my auto-complete in PyCharm's not working.


01:05:05.420 --> 01:05:08.100
That's why I added the types, was to allow static.


01:05:08.100 --> 01:05:10.600
- Oh yeah, that's fantastic.


01:05:10.600 --> 01:05:13.000
Does it do anything with like what Typeshed does,


01:05:13.000 --> 01:05:18.000
where it's like defining the structure in these stub files?


01:05:18.000 --> 01:05:21.480
- Yeah, so there's some type annotations


01:05:21.480 --> 01:05:23.240
in the pure Python code, but the most,


01:05:23.240 --> 01:05:27.120
the relevant part was the stub files for the compiled.


01:05:27.120 --> 01:05:28.880
- Right, right.


01:05:28.880 --> 01:05:30.320
Yeah, and if people haven't seen those stub files,


01:05:30.320 --> 01:05:35.320
those PYI files, it's a little like a C++ header


01:05:35.360 --> 01:05:37.740
thing where it has the definition,


01:05:37.740 --> 01:05:39.740
but then somewhere else is the implementation of it.


01:05:39.740 --> 01:05:41.380
It's a little funky, but yeah,


01:05:41.380 --> 01:05:44.180
it's also useful for adding that in, right?


01:05:44.180 --> 01:05:46.880
So you could say, here's the structure,


01:05:46.880 --> 01:05:48.540
and we'll make that at runtime dynamically,


01:05:48.540 --> 01:05:50.980
but this is what you should think of it as, right?


01:05:50.980 --> 01:05:52.660
- Yeah.


01:05:52.660 --> 01:05:54.320
- Yeah, very cool, very cool.


01:05:54.320 --> 01:05:58.300
All right, Manuel, you know, I think we just,


01:05:58.300 --> 01:05:59.740
honestly, just scratched the surface.


01:05:59.740 --> 01:06:02.900
We could go on and on and on, but at the same time,


01:06:02.900 --> 01:06:05.140
I want to be respectful of your time.


01:06:05.140 --> 01:06:08.600
So maybe we should wrap it up on the main topic there.


01:06:08.600 --> 01:06:11.880
So I'll ask you the two questions on the way out.


01:06:11.880 --> 01:06:13.040
So if you're gonna write some code,


01:06:13.040 --> 01:06:17.280
if you're gonna work on PyZMQ or something like that,


01:06:17.280 --> 01:06:19.520
what editor would you use?


01:06:19.520 --> 01:06:22.800
- So my favorite editor of all time is TextMate.


01:06:22.800 --> 01:06:24.860
- Okay.


01:06:24.860 --> 01:06:27.400
- But for various reasons, I don't use that anymore.


01:06:27.400 --> 01:06:31.400
It kind of, it hasn't kept up with activity and things,


01:06:31.400 --> 01:06:33.440
and I didn't feel sustainable anyway,


01:06:33.440 --> 01:06:35.160
so I haven't used it in a long time.


01:06:35.160 --> 01:06:37.660
I've tried pretty much everything,


01:06:37.660 --> 01:06:42.320
and I'm in constant search of the next TextMate.


01:06:42.320 --> 01:06:44.760
So right now I'm actually using Nova, the new editor.


01:06:44.760 --> 01:06:47.200
- I was gonna say, maybe Nova is your next TextMate.


01:06:47.200 --> 01:06:48.040
How about that?


01:06:48.040 --> 01:06:51.360
Like, I know if I say Visual Studio Code or PyCharm,


01:06:51.360 --> 01:06:52.200
people are like, oh yeah,


01:06:52.200 --> 01:06:53.360
I'm pretty sure I know what that means.


01:06:53.360 --> 01:06:55.120
Nova is pretty new.


01:06:55.120 --> 01:06:56.440
Tell folks about it.


01:06:56.440 --> 01:07:00.100
- So Nova is a new text editor from Panic,


01:07:01.360 --> 01:07:03.200
one of the great Mac developers.


01:07:03.200 --> 01:07:05.640
- Oh yeah, I use some of their apps,


01:07:05.640 --> 01:07:08.240
like Transmit for working with S3 files.


01:07:08.240 --> 01:07:10.080
They're really nice stuff, yeah.


01:07:10.080 --> 01:07:11.700
- Yeah, so they do a great job designing things,


01:07:11.700 --> 01:07:14.000
and thanks to the recent work


01:07:14.000 --> 01:07:16.960
of the language server protocol and stuff,


01:07:16.960 --> 01:07:20.280
new editors are able to,


01:07:20.280 --> 01:07:24.720
there's a lot more shared infrastructure in editor features,


01:07:24.720 --> 01:07:26.920
so it's starting from,


01:07:26.920 --> 01:07:30.320
further from zero than it might otherwise be,


01:07:30.320 --> 01:07:34.800
but I'm not sure I could recommend it


01:07:34.800 --> 01:07:36.080
widely to Python developers.


01:07:36.080 --> 01:07:38.640
It's a bit of an early adopter situation.


01:07:38.640 --> 01:07:40.080
- It is supposed to have Python support,


01:07:40.080 --> 01:07:43.240
but it's not specifically for Python, right?


01:07:43.240 --> 01:07:45.160
- Right, yeah, no, it's a general purpose editor,


01:07:45.160 --> 01:07:49.120
and the target community is more Mac developers,


01:07:49.120 --> 01:07:50.360
Ruby and web stuff.


01:07:50.360 --> 01:07:53.000
- Yeah, I feel like it's pretty JavaScript friendly,


01:07:53.000 --> 01:07:54.160
and maybe Mac developers as well.


01:07:54.160 --> 01:07:57.320
- Yeah, and extensions are written in JavaScript.


01:07:57.320 --> 01:07:58.720
I've written a couple extensions


01:07:58.720 --> 01:08:03.720
for to use the darker code formatter.


01:08:03.720 --> 01:08:06.400
(laughing)


01:08:06.400 --> 01:08:07.240
- Very cool.


01:08:07.240 --> 01:08:09.120
All right, well, that's quite neat,


01:08:09.120 --> 01:08:11.200
and I'm glad to hear that's working out for you.


01:08:11.200 --> 01:08:13.320
I've wanted to try it, but I just haven't.


01:08:13.320 --> 01:08:15.640
And then notable PyPI packages.


01:08:15.640 --> 01:08:19.240
I know you picked two that have some relation


01:08:19.240 --> 01:08:21.640
back to this challenge of building binary stuff


01:08:21.640 --> 01:08:22.960
and distributing it.


01:08:22.960 --> 01:08:24.720
- Yeah, so up until December,


01:08:24.720 --> 01:08:26.520
there was exactly one computer in the world


01:08:26.520 --> 01:08:29.640
that could build PyZenKey releases.


01:08:29.640 --> 01:08:30.840
It was my laptop.


01:08:30.840 --> 01:08:32.840
And I finally solved that problem


01:08:32.840 --> 01:08:34.480
thanks to two wonderful packages.


01:08:34.480 --> 01:08:37.940
One is CI Build Wheel, which is a more generally useful,


01:08:37.940 --> 01:08:42.640
if you have compiled Python packages, CI Build Wheel.


01:08:42.640 --> 01:08:44.360
It's a wonderful thing for building


01:08:44.360 --> 01:08:45.960
and distributing all your wheels


01:08:45.960 --> 01:08:49.840
on all kinds of platforms.


01:08:49.840 --> 01:08:52.640
So now PyZenKey wheels are all built on GitHub Actions,


01:08:52.640 --> 01:08:54.080
and I don't need to do anything,


01:08:54.080 --> 01:08:57.160
tag a release, and it all happens magically.


01:08:57.160 --> 01:08:58.880
The other one that I wanted to highlight


01:08:58.880 --> 01:09:00.640
that probably fewer people know about


01:09:00.640 --> 01:09:02.520
that's related to CI Build Wheel,


01:09:02.520 --> 01:09:04.460
because when you build a Python package


01:09:04.460 --> 01:09:05.920
that has an external dependency,


01:09:05.920 --> 01:09:09.440
there's an extra step to say, I built PyZenKey,


01:09:09.440 --> 01:09:12.040
I linked it against libzmq over here.


01:09:12.040 --> 01:09:16.120
But if somebody else installs that wheel as it is,


01:09:16.120 --> 01:09:17.520
it's not gonna work, because it's gonna say,


01:09:17.520 --> 01:09:18.880
I don't have libzmq.


01:09:18.880 --> 01:09:23.000
So for a long time, there have been Mac,


01:09:23.000 --> 01:09:25.280
there's a Mac thing called Delocate


01:09:25.280 --> 01:09:27.400
and a Linux one called Audit Wheel


01:09:27.400 --> 01:09:29.800
that say, look at the binaries in there


01:09:29.800 --> 01:09:31.240
and find them on your system,


01:09:31.240 --> 01:09:32.800
bring them in and update the linking


01:09:32.800 --> 01:09:33.960
to make sure they load.


01:09:33.960 --> 01:09:37.960
So the wonderful thing that I just found


01:09:37.960 --> 01:09:40.400
is someone created something called Delve Wheel,


01:09:40.400 --> 01:09:44.200
which is Audit Wheel or Delocate, but for Windows.


01:09:44.200 --> 01:09:46.800
And I don't understand anything about Windows.


01:09:46.800 --> 01:09:48.800
- You go grab the DLLs and all that kind of stuff


01:09:48.800 --> 01:09:52.900
that have to be there and put it in the right location.


01:09:52.900 --> 01:09:54.040
- Perfect.


01:09:54.040 --> 01:09:56.320
- Yeah, and so for a long, long time,


01:09:56.320 --> 01:09:59.760
for, yeah, I guess 10 years plus,


01:09:59.760 --> 01:10:03.840
PyZenKey built libzmq on Windows as an extension.


01:10:03.840 --> 01:10:06.320
So it actually took the XeromQ sources


01:10:06.320 --> 01:10:09.360
and then just said, hey, this is a Python extension.


01:10:09.360 --> 01:10:12.240
You don't need to worry about the fact


01:10:12.240 --> 01:10:14.960
that it's actually a C++ library.


01:10:14.960 --> 01:10:18.680
Just pass it to disutils and compile it as an extension.


01:10:18.680 --> 01:10:21.040
And there were a lot of issues with that.


01:10:21.040 --> 01:10:23.520
He never got good optimized results,


01:10:23.520 --> 01:10:27.900
but it worked most of the time, and that was the point.


01:10:27.900 --> 01:10:31.940
And it was a wonderful contribution from Brandon Rhodes


01:10:31.940 --> 01:10:35.900
that was a huge step in making PyZenKey installable


01:10:35.900 --> 01:10:38.100
a lot more of the time was this


01:10:38.100 --> 01:10:40.020
bundling libzmq as an extension.


01:10:40.020 --> 01:10:42.260
But finally got to the point


01:10:42.260 --> 01:10:44.860
where I almost never do that anymore.


01:10:44.860 --> 01:10:47.420
- Nice, that's beautiful. - Thanks to Delve Wheel.


01:10:47.420 --> 01:10:49.540
So Delve Wheel's my big one.


01:10:49.540 --> 01:10:51.040
- Yeah, the CI Build Wheel one.


01:10:51.040 --> 01:10:54.440
It makes me happy to see the macOS Apple Silicon


01:10:54.440 --> 01:10:56.440
got a little checkbox there.


01:10:56.440 --> 01:10:59.440
That's what I'm doing, or recording from on my machine


01:10:59.440 --> 01:11:00.580
over here, got the Mac mini one.


01:11:00.580 --> 01:11:03.040
And man, that is a sweet device,


01:11:03.040 --> 01:11:04.600
but you're a little bit back in like,


01:11:04.600 --> 01:11:06.880
oh, we don't have wheels for your system, sorry.


01:11:06.880 --> 01:11:10.120
- Yeah, yeah, I have, so I have two Mac Silicon wheels,


01:11:10.120 --> 01:11:13.360
one that I just finished last week,


01:11:13.360 --> 01:11:17.160
but with CI Build Wheel, that's a universal wheel.


01:11:17.160 --> 01:11:21.460
And then I have another Mac Arm wheel targeting


01:11:21.460 --> 01:11:25.280
macOS 11 plus basically just for Homebrew Python


01:11:25.280 --> 01:11:29.560
on Homebrew Python 3.9 on Arm Macs.


01:11:29.560 --> 01:11:31.880
- That's pretty specific, but yes,


01:11:31.880 --> 01:11:34.580
that's a thing I have actually.


01:11:34.580 --> 01:11:37.120
- Yeah, it's not an insignificant target.


01:11:37.120 --> 01:11:39.560
And that one I built on my wife's new laptop.


01:11:39.560 --> 01:11:41.280
- Nice, very cool, very cool.


01:11:41.280 --> 01:11:44.100
- So that's the only one that's not built on CI yet.


01:11:44.100 --> 01:11:45.060
- Right, awesome.


01:11:46.120 --> 01:11:49.760
Well, thank you so much for sharing all this stuff.


01:11:49.760 --> 01:11:51.600
And of course, all your work.


01:11:51.600 --> 01:11:53.480
I feel like I have a lot to go learn,


01:11:53.480 --> 01:11:55.600
but it's exciting stuff to be able to think about


01:11:55.600 --> 01:11:59.200
new networking, ways of doing stuff


01:11:59.200 --> 01:12:00.460
with networking and Python.


01:12:00.460 --> 01:12:01.640
So thanks so much for that.


01:12:01.640 --> 01:12:03.680
And final call to action,


01:12:03.680 --> 01:12:04.920
people want to get started with this stuff,


01:12:04.920 --> 01:12:06.920
what would you tell them to do?


01:12:06.920 --> 01:12:07.940
- I'd say read the guide.


01:12:07.940 --> 01:12:10.200
So if you're interested in ZRMQ,


01:12:10.200 --> 01:12:11.800
thinking about building distributed applications


01:12:11.800 --> 01:12:14.200
and things, read the ZRMQ guide, the whole thing.


01:12:15.200 --> 01:12:16.520
And I think it'll give you some new ideas.


01:12:16.520 --> 01:12:17.520
Even if you don't use ZRMQ,


01:12:17.520 --> 01:12:19.560
it'll give you some good new ideas for how--


01:12:19.560 --> 01:12:21.440
- Yeah, you'll have some ideas about,


01:12:21.440 --> 01:12:22.840
right, like these design patterns


01:12:22.840 --> 01:12:25.200
that maybe are not so common,


01:12:25.200 --> 01:12:26.840
but like Pub/Sub or whatever.


01:12:26.840 --> 01:12:29.440
Yeah, awesome.


01:12:29.440 --> 01:12:30.520
Well, thanks again for being on the show.


01:12:30.520 --> 01:12:31.600
It was great to chat with you.


01:12:31.600 --> 01:12:32.560
- Yeah, thanks so much.


01:12:32.560 --> 01:12:33.400
- You bet, bye.

