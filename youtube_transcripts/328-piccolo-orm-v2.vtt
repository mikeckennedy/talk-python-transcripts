WEBVTT

00:00:00.000 --> 00:00:05.000
- Hey, Dan, welcome to the live stream


00:00:05.000 --> 00:00:06.960
and almost to the podcast.


00:00:06.960 --> 00:00:08.600
- Hi, Michael, thanks for having me.


00:00:08.600 --> 00:00:09.760
- Yeah, it's good to have you here.


00:00:09.760 --> 00:00:12.880
Super excited to talk about ORMs and stuff.


00:00:12.880 --> 00:00:14.840
And before we get too far into it,


00:00:14.840 --> 00:00:16.080
folks out there in the live stream,


00:00:16.080 --> 00:00:18.040
please put comments in the live chat


00:00:18.040 --> 00:00:19.040
if you're watching live,


00:00:19.040 --> 00:00:21.000
and we'll try to make that part of the show.


00:00:21.000 --> 00:00:26.680
Dan, welcome to Talk Python to Me.


00:00:26.680 --> 00:00:28.640
- Yeah, thanks for having me.


00:00:28.640 --> 00:00:29.600
I'm a big fan of the show,


00:00:29.600 --> 00:00:31.960
So it's kind of like a little dream to be on the show.


00:00:31.960 --> 00:00:33.520
- Oh, how nice.


00:00:33.520 --> 00:00:34.360
That means a lot.


00:00:34.360 --> 00:00:35.480
Thank you.


00:00:35.480 --> 00:00:36.400
It's great to have you here


00:00:36.400 --> 00:00:38.840
and you've built some really neat software


00:00:38.840 --> 00:00:41.180
that I'm looking forward to diving into.


00:00:41.180 --> 00:00:44.560
It's interesting because,


00:00:44.560 --> 00:00:46.280
I mean, we're gonna talk about your ORM,


00:00:46.280 --> 00:00:48.920
but it's also, there's so many different areas


00:00:48.920 --> 00:00:51.400
at which now that we're kind of past Python 2


00:00:51.400 --> 00:00:54.560
and there's a lot of folks who are saying,


00:00:54.560 --> 00:00:56.960
you know what, we can really put Python 2 behind us


00:00:56.960 --> 00:00:59.220
and let's just build for the future.


00:00:59.220 --> 00:01:01.000
That just opens up so many doors, right?


00:01:01.000 --> 00:01:02.700
Like, oh, well, type-ins, of course, type-ins.


00:01:02.700 --> 00:01:03.540
Why not type-ins?


00:01:03.540 --> 00:01:07.300
Well, Python 2 is why not type-ins, but not anymore, right?


00:01:07.300 --> 00:01:10.100
And async and all these other things.


00:01:10.100 --> 00:01:14.760
And just, it's really great to have these frameworks


00:01:14.760 --> 00:01:16.980
like yours coming along that just go,


00:01:16.980 --> 00:01:19.620
modern Python, what can we build now?


00:01:19.620 --> 00:01:20.460
- Yeah, I totally agree.


00:01:20.460 --> 00:01:23.180
It felt like Python 3.6 kind of closed the door


00:01:23.180 --> 00:01:25.700
on the should we still be using Python 2 conversation?


00:01:25.700 --> 00:01:27.900
because by that point you had async,


00:01:27.900 --> 00:01:29.300
you had type annotations,


00:01:29.300 --> 00:01:33.460
data classes I think were Python 3.7, enums.


00:01:33.460 --> 00:01:34.620
It just goes on and on.


00:01:34.620 --> 00:01:36.980
It just felt like the Python community


00:01:36.980 --> 00:01:40.420
knocked out of the park, Python 3.6 and on.


00:01:40.420 --> 00:01:44.300
- Yeah, I have a theory that is completely unsubstantiated


00:01:44.300 --> 00:01:46.620
that actually a lot of the progress


00:01:46.620 --> 00:01:47.940
has to do with f-strings.


00:01:47.940 --> 00:01:48.760
So many people are like,


00:01:48.760 --> 00:01:50.860
"Ah, I just want to easily format this code.


00:01:50.860 --> 00:01:51.700
What do I need?


00:01:51.700 --> 00:01:52.540
I need Python 3.6."


00:01:52.540 --> 00:01:54.540
Fine, we're going-- - That's true, actually.


00:01:54.540 --> 00:01:55.380
- We're gonna switch.


00:01:55.380 --> 00:01:58.420
It's such a minor feature, still minor.


00:01:58.420 --> 00:02:01.260
- The pain of going back would be horrible.


00:02:01.260 --> 00:02:03.220
I couldn't imagine using Python 2 now, actually.


00:02:03.220 --> 00:02:04.800
- I know, yeah, same.


00:02:04.800 --> 00:02:07.340
Quick welcome to some folks on livestream.


00:02:07.340 --> 00:02:08.800
Chris May, hey, happy to see you here.


00:02:08.800 --> 00:02:10.860
Paul Everett, so glad you can stop by.


00:02:10.860 --> 00:02:12.580
And Teddy as well.


00:02:12.580 --> 00:02:15.380
We'll get some questions in from you all, I'm sure.


00:02:15.380 --> 00:02:17.580
Now, before we get into Piccolo


00:02:17.580 --> 00:02:20.700
and all the cool stuff that I was alluding to there,


00:02:20.700 --> 00:02:21.980
let's just start with your story, Dan.


00:02:21.980 --> 00:02:24.460
How'd you get into programming in Python?


00:02:24.460 --> 00:02:28.300
Yeah, so i've been programming for quite a long time now. I might look quite youthful on this camera


00:02:28.300 --> 00:02:31.340
But that's just because my webcam's got a filter on it. But um


00:02:31.340 --> 00:02:38.620
The touch up my appearance is checked. Yeah, i've actually been getting yeah program a python for about 14 years


00:02:38.620 --> 00:02:40.220
um


00:02:40.220 --> 00:02:42.220
So django was kind of one of my first


00:02:42.220 --> 00:02:45.900
Frameworks and just really fell in love with it because in university I learned c


00:02:45.900 --> 00:02:50.540
And then it's like oh this world of python exists and it's a bit more easier than c


00:02:50.540 --> 00:02:52.060
um


00:02:52.060 --> 00:02:54.460
And so i've used it extensively since then


00:02:54.460 --> 00:02:57.500
I mostly been working for startups


00:02:57.500 --> 00:03:03.820
And design agencies and then really fell down the async rabbit hole over the last few years


00:03:03.820 --> 00:03:10.220
um, so really enjoy working with web sockets and building kind of interactive front ends and


00:03:10.220 --> 00:03:15.420
Also really kind of excited the way that postgres continues to grow and have new features


00:03:15.420 --> 00:03:18.620
Um, so yeah, they're the things that really excite me in the python world


00:03:18.620 --> 00:03:20.540
Yeah


00:03:20.540 --> 00:03:24.700
Those things are super exciting and the web frameworks are coming along to embrace them


00:03:24.700 --> 00:03:28.780
The language features, you know async and await, right?


00:03:28.780 --> 00:03:30.780
We had async io in python 3.4


00:03:30.780 --> 00:03:36.380
But it didn't really gain a ton of adoption because there was it sort of had this callback


00:03:36.380 --> 00:03:40.700
Style of working which is not the same as you know, await a thing and just keep rocking


00:03:40.700 --> 00:03:47.660
Totally agree. Yeah, so I think they pretty much took what twisted had created and ported it over and like I say, it's all callbacks and


00:03:48.140 --> 00:03:51.820
Um, it was still better than it's still good to have that option in the standard library


00:03:51.820 --> 00:03:54.380
But I totally agree async await really kind of set it on fire


00:03:54.380 --> 00:03:57.900
Um because it was quite hard to approach async iot first


00:03:57.900 --> 00:04:01.180
It was you don't have to think about how you write code differently


00:04:01.180 --> 00:04:04.780
You just put the awaits in the spots and then you know, everything kind of flows


00:04:04.780 --> 00:04:10.140
It's I know it's not the same but from how you think about structuring your code is real similar


00:04:10.140 --> 00:04:14.620
yeah, and I think the maturity is there now with the libraries and the standard library and


00:04:15.020 --> 00:04:19.100
It feels like you can just dive in and it feels a bit like a no-brainer now to use async


00:04:19.100 --> 00:04:22.700
Yeah, I think it is a no-brainer for sure. So


00:04:22.700 --> 00:04:29.020
It's interesting that you got into django in the early days because django's


00:04:29.020 --> 00:04:35.900
The only the only major web framework that says here's your orm


00:04:35.900 --> 00:04:41.900
Here's how you use it as opposed to flask that says do what you want or pyramid that says do what you want


00:04:41.980 --> 00:04:48.060
You know, you could use in orm, but you don't have to but django's it's it's part of the culture and the zen of it


00:04:48.060 --> 00:04:51.180
Right. Yeah, i'm a big fan of django


00:04:51.180 --> 00:04:56.060
I think it's kind of a masterpiece because it's still to test the time so remarkably well


00:04:56.060 --> 00:05:02.860
And how you could have written a app 12 years ago and then in an afternoon you could have upgraded it to the latest version


00:05:02.860 --> 00:05:05.420
so there's lots to be said for django and


00:05:05.420 --> 00:05:11.900
I really like the tight integration. So, i'm one so people tend to prefer one or the other


00:05:11.900 --> 00:05:19.020
the kind of the flask route where you can make all of your choices, but I like really tightly integrated solutions where


00:05:19.020 --> 00:05:23.420
You come to a problem and then you pretty much know what to pick


00:05:23.420 --> 00:05:27.260
Um, yeah, so that's definitely inspired piccolo to some extent


00:05:27.260 --> 00:05:29.900
yeah, I I love the


00:05:29.900 --> 00:05:34.380
Diversity of technology and libraries and ways of doing things in the python space


00:05:34.380 --> 00:05:36.940
But when people come from other


00:05:37.800 --> 00:05:42.580
It's a challenge to go, well, here's 20 different ORMs


00:05:42.580 --> 00:05:44.460
you could use and seven different web frameworks.


00:05:44.460 --> 00:05:45.540
And they're like, I don't want seven.


00:05:45.540 --> 00:05:47.260
I want to know what I should be doing.


00:05:47.260 --> 00:05:48.100
What should I do?


00:05:48.100 --> 00:05:50.440
And so it's a mixed bag.


00:05:50.440 --> 00:05:51.280
- I really like that.


00:05:51.280 --> 00:05:53.380
But the thing is, if you come from the JavaScript world,


00:05:53.380 --> 00:05:56.180
then it's a relief because you've only got 20, not 2000.


00:05:56.180 --> 00:05:59.060
- Oh my goodness, this one's seven months old.


00:05:59.060 --> 00:06:00.100
It's like ancient.


00:06:00.100 --> 00:06:01.300
Can we still use it?


00:06:01.300 --> 00:06:02.260
- Yeah.


00:06:02.260 --> 00:06:03.340
- Yeah, no, no.


00:06:03.340 --> 00:06:05.420
That's a whole different discussion.


00:06:05.420 --> 00:06:07.620
The JavaScript churn over there.


00:06:07.620 --> 00:06:08.460
- Yeah.


00:06:08.460 --> 00:06:10.620
- But yeah, let's focus in on what you built here.


00:06:10.620 --> 00:06:12.180
So let's talk about Piccolo.


00:06:12.180 --> 00:06:17.140
You used to sell it, you describe it as a fast async ORM


00:06:17.140 --> 00:06:18.540
for Python that's easy to learn.


00:06:18.540 --> 00:06:21.460
And I think it seems like it really hits


00:06:21.460 --> 00:06:22.300
on all those points.


00:06:22.300 --> 00:06:23.140
Tell us about it.


00:06:23.140 --> 00:06:23.960
Where did it come from?


00:06:23.960 --> 00:06:25.860
- So all those terms are like fairly aspirational.


00:06:25.860 --> 00:06:29.340
So the fast is because it's built on asyncpg.


00:06:29.340 --> 00:06:31.740
So this is a really fast Postgres adapter


00:06:31.740 --> 00:06:33.580
that the Magic Stack guys built.


00:06:33.580 --> 00:06:37.220
Part of the reason it's so fast is it's written in Cypher.


00:06:37.220 --> 00:06:38.500
So it's compiled.


00:06:38.500 --> 00:06:41.540
And then there's also a few other features


00:06:41.540 --> 00:06:43.420
within Piccolo which kind of help it speed wise,


00:06:43.420 --> 00:06:46.300
like frozen queries where it doesn't have to generate


00:06:46.300 --> 00:06:48.540
the SQL each time, it kind of caches some of it.


00:06:48.540 --> 00:06:51.260
So that's kind of where the fast comes from.


00:06:51.260 --> 00:06:53.020
Async. - Oh, nice.


00:06:53.020 --> 00:06:54.620
- Async, it supports Async.io.


00:06:54.620 --> 00:06:57.460
That was really one of the core reasons for building it


00:06:57.460 --> 00:07:00.780
is because I was a Django channels power user


00:07:00.780 --> 00:07:03.700
and I had to build a lot of chat applications in my day job.


00:07:04.660 --> 00:07:07.300
So for me, async was kind of essential.


00:07:07.300 --> 00:07:09.980
And then the easy to learn is called also aspirational.


00:07:09.980 --> 00:07:12.280
I've put like as much effort as I possibly can


00:07:12.280 --> 00:07:14.060
into the documentation and stuff like that,


00:07:14.060 --> 00:07:17.300
but I'll let the readers be the judge of that.


00:07:17.300 --> 00:07:18.860
- Yeah, that's in the eye of the beholder, right?


00:07:18.860 --> 00:07:22.060
But at the same time, you have done a lot of things


00:07:22.060 --> 00:07:23.420
that I don't see others doing.


00:07:23.420 --> 00:07:25.220
Like the documentation is good.


00:07:25.220 --> 00:07:27.260
Obviously that's pretty standard


00:07:27.260 --> 00:07:28.980
on a lot of the different frameworks,


00:07:28.980 --> 00:07:31.540
although they can be super intense, right?


00:07:31.540 --> 00:07:33.660
Like I love SQLAlchemy, but when I go and read there,


00:07:33.660 --> 00:07:35.700
I'm like, okay, here's a 20 page doc.


00:07:35.700 --> 00:07:37.800
I better pay attention, turn off my music


00:07:37.800 --> 00:07:39.680
and just like not miss something.


00:07:39.680 --> 00:07:42.040
On the other hand, but what you are doing


00:07:42.040 --> 00:07:44.080
that's pretty unique is you've got like a playground.


00:07:44.080 --> 00:07:46.120
You've got a playground for the admin backend.


00:07:46.120 --> 00:07:47.840
Oh, by the way, there's an admin backend.


00:07:47.840 --> 00:07:51.360
And you've got a playground for trying out queries


00:07:51.360 --> 00:07:52.400
and stuff like that, right?


00:07:52.400 --> 00:07:54.040
That's pretty unique.


00:07:54.040 --> 00:07:56.560
- Yeah, so I was really excited by the playground concept.


00:07:56.560 --> 00:07:59.120
So it's something I borrowed from the Swift world


00:07:59.120 --> 00:08:01.800
and because Apple is trying to make Swift accessible


00:08:01.800 --> 00:08:08.840
Newcomers, they have this concept of a playground which is basically a pre-populated chunk of code and then you can just um


00:08:08.840 --> 00:08:11.000
Play around with it as kind of the name implies


00:08:11.000 --> 00:08:15.820
So I use ipython to achieve it. So a lot of people know ipython


00:08:15.820 --> 00:08:21.400
Just running it on the command line like a terminal, but you can actually embed it within your python code


00:08:21.400 --> 00:08:27.640
So the way the playgrounds work is it creates a sqlite database. It loads an example schema


00:08:28.360 --> 00:08:32.360
Populates it with data and then basically launches the up hyphen shell. Um


00:08:32.360 --> 00:08:36.280
so you basically have all of that set up because


00:08:36.280 --> 00:08:41.640
One of the problems with learning and learning an orm is the barrier is huge when you think about it for a newcomer


00:08:41.640 --> 00:08:48.440
You have to set up a database you have to understand schemas and migrations and running them and populating data


00:08:48.440 --> 00:08:51.640
So I just wanted to say look i'm going to shortcut all of that


00:08:51.640 --> 00:08:54.840
You install piccolo you do piccolo playground run


00:08:55.240 --> 00:08:58.760
and then you've got an example schema, and then you can actually follow along with the documentation.


00:08:58.760 --> 00:09:03.880
So whenever there's a example query in the piccolo docs, you can actually run it in the playground,


00:09:03.880 --> 00:09:08.280
and you should see the results. So yeah, I was quite excited about that.


00:09:08.280 --> 00:09:14.840
I like it a lot. And you're right that it is challenging. You know, as we build up experience,


00:09:14.840 --> 00:09:18.520
we get used to it. It's like, oh, yeah, you just you fire up the database server, and then you


00:09:18.520 --> 00:09:23.960
connect to it, then you do this thing. But how do you get the database server installed? What if you


00:09:23.960 --> 00:09:26.480
you have the wrong version? What if it requires authentication?


00:09:26.480 --> 00:09:29.680
What if there's a firewall? Just like there's layers and layers of places


00:09:29.680 --> 00:09:32.480
where people get sheared off. Like, "Ah, this doesn't work for me."


00:09:32.480 --> 00:09:35.200
Right? And so keeping that simple is great.


00:09:35.200 --> 00:09:37.520
And I think I just want to give a shout out to SQLite,


00:09:37.520 --> 00:09:41.920
because what you just said is such a good example of,


00:09:41.920 --> 00:09:45.120
you're probably going to run this against Postgres or something like that.


00:09:45.120 --> 00:09:46.120
Yeah.


00:09:46.120 --> 00:09:48.320
But for the little example, you don't need that.


00:09:48.320 --> 00:09:51.920
You can just use SQLite. And it's so nice that that's a serverless


00:09:51.920 --> 00:09:53.920
in the sense that it's just embedded,


00:09:53.920 --> 00:09:56.920
doesn't require a separate process to run or connect to.


00:09:56.920 --> 00:10:00.260
It already comes with Python, generally speaking.


00:10:00.260 --> 00:10:01.760
It's really nice.


00:10:01.760 --> 00:10:02.760
Yeah, I totally agree.


00:10:02.760 --> 00:10:05.260
And that's the reason for SQLite support within Piccolo,


00:10:05.260 --> 00:10:07.260
because as you said, no one's going to run it in production.


00:10:07.260 --> 00:10:10.760
But then it's just that frictionless setup,


00:10:10.760 --> 00:10:11.760
which is so great.


00:10:11.760 --> 00:10:15.260
Like, using SQLite asynchronously doesn't really make a lot of sense


00:10:15.260 --> 00:10:18.260
because you don't really have any network lag talking to the database.


00:10:18.260 --> 00:10:21.260
But it's great to have it in there for convenience.


00:10:21.260 --> 00:10:22.100
- Yeah, it is.


00:10:22.100 --> 00:10:24.200
I suspect there may be some people who run it


00:10:24.200 --> 00:10:28.060
in production in like an early, early prototype stage.


00:10:28.060 --> 00:10:29.360
They're just wanting to get something up


00:10:29.360 --> 00:10:31.280
and here let's just put it up on,


00:10:31.280 --> 00:10:32.660
you know, on some hosting place


00:10:32.660 --> 00:10:33.700
and just check it out real quick


00:10:33.700 --> 00:10:35.220
and then we'll go from there.


00:10:35.220 --> 00:10:37.520
- Yeah, one thing that's quite nice is


00:10:37.520 --> 00:10:38.900
I used to do this in the design agency.


00:10:38.900 --> 00:10:40.440
We'd use SQLite for the prototype


00:10:40.440 --> 00:10:42.780
and then you could rsync it down to your local machine.


00:10:42.780 --> 00:10:45.800
So you didn't have to do a database dump and reload it.


00:10:45.800 --> 00:10:47.880
You could literally just rsync the file.


00:10:47.880 --> 00:10:48.720
- Yeah.


00:10:48.720 --> 00:10:50.020
- So there are a bunch of conveniences


00:10:50.020 --> 00:10:51.580
of SQLite for sure.


00:10:51.580 --> 00:10:53.140
- Yeah, it's all gets to be too much data


00:10:53.140 --> 00:10:55.380
or really you want sort of too much concurrency


00:10:55.380 --> 00:10:59.340
or multi-machines scale out and all that sort of stuff.


00:10:59.340 --> 00:11:00.900
So it's not the final destination,


00:11:00.900 --> 00:11:02.660
but I do think it's a really interesting


00:11:02.660 --> 00:11:04.520
and important starting ground there.


00:11:04.520 --> 00:11:05.820
- Yeah, for sure.


00:11:05.820 --> 00:11:06.660
- Yeah.


00:11:06.660 --> 00:11:12.620
So I gave a shout out to two ORMs already,


00:11:12.620 --> 00:11:16.340
the Django one and SQLAlchemy.


00:11:16.340 --> 00:11:18.900
And I feel like those are probably the two big hitters


00:11:18.900 --> 00:11:22.340
of the Python space, although there are many, many more.


00:11:22.340 --> 00:11:25.780
So why not just use those?


00:11:25.780 --> 00:11:27.780
Like why go and create Piccolo?


00:11:27.780 --> 00:11:29.380
- Yeah, so when I started it,


00:11:29.380 --> 00:11:32.100
there was no async options for ORMs at all.


00:11:32.100 --> 00:11:33.220
It was all like very new.


00:11:33.220 --> 00:11:37.860
And my day job involved async programming all of the time


00:11:37.860 --> 00:11:41.100
because of chat apps, online games, that kind of stuff.


00:11:41.100 --> 00:11:42.500
So that was really why I was like,


00:11:42.500 --> 00:11:45.540
well, nothing really served my needs at the time.


00:11:45.540 --> 00:11:46.740
- Right, because until recently,


00:11:46.740 --> 00:11:50.780
SQLAlchemy had no async capabilities.


00:11:50.780 --> 00:11:51.620
- Yeah.


00:11:51.620 --> 00:11:53.940
- And Django or more or less still doesn't, right?


00:11:53.940 --> 00:11:56.700
That's the final part that they're trying to move to async.


00:11:56.700 --> 00:11:58.900
- Yeah, so the workaround is to run it in a thread,


00:11:58.900 --> 00:12:00.380
but it's just not as performant


00:12:00.380 --> 00:12:02.260
as running with async.io directly.


00:12:02.260 --> 00:12:07.500
So there's kind of this vacuum for a time with async ORMs,


00:12:07.500 --> 00:12:10.620
but then it was also about just starting


00:12:10.620 --> 00:12:12.120
through a blank sheet of paper and thinking,


00:12:12.120 --> 00:12:15.700
look, we've got all these great tools to work with now


00:12:15.700 --> 00:12:19.460
Python 3.6 and onwards, how can I absolutely push them to the limit?


00:12:19.460 --> 00:12:28.260
So the syntax, it uses a lot of direct references to objects rather than strings.


00:12:28.260 --> 00:12:38.820
So for example, in Django, you do my table.object and then .filter and name equals Dan.


00:12:38.820 --> 00:12:43.820
The problem with that is you can quite easily make a mistake


00:12:43.820 --> 00:12:46.940
as the code changes.


00:12:46.940 --> 00:12:51.040
So you might end up having a column which no longer exists.


00:12:51.040 --> 00:12:53.620
So strings can be a little bit fragile.


00:12:53.620 --> 00:12:56.340
So with Piccolo, it's just object references everywhere.


00:12:56.340 --> 00:13:00.060
So rather than name, in this example here,


00:13:00.060 --> 00:13:03.500
it's band.name where band is the name of the table.


00:13:03.500 --> 00:13:05.500
- Right, so like many of the ORMs,


00:13:05.500 --> 00:13:08.180
it's sort of class OOP based, right?


00:13:08.180 --> 00:13:12.980
to create a class that maps to a table and database, right?


00:13:12.980 --> 00:13:14.900
- Yeah, so there's one distinction


00:13:14.900 --> 00:13:15.820
I'd like to make quickly as well.


00:13:15.820 --> 00:13:17.860
So there's ORMs and then there's query builders.


00:13:17.860 --> 00:13:20.900
And in Python, there's not really too much of a distinction,


00:13:20.900 --> 00:13:23.380
but in other languages like JavaScript,


00:13:23.380 --> 00:13:25.060
query builders are really popular


00:13:25.060 --> 00:13:27.900
as like a separate idea to ORMs.


00:13:27.900 --> 00:13:29.900
And query builders, they kind of,


00:13:29.900 --> 00:13:33.900
you create a SQL query, you execute it on the database,


00:13:33.900 --> 00:13:36.140
and then you tend to work more with dictionaries and lists


00:13:36.140 --> 00:13:37.300
rather than objects.


00:13:37.300 --> 00:13:41.540
So I'd say that 90% of piccolo is a query builder.


00:13:41.540 --> 00:13:45.660
But people are used to ORMs and Python.


00:13:45.660 --> 00:13:49.500
And it can actually lead you to some quite poor patterns


00:13:49.500 --> 00:13:53.180
ORMs because what the first thing people learn with Django


00:13:53.180 --> 00:13:56.500
is they'll go my table.objects.get.


00:13:56.500 --> 00:13:58.820
So it returns an object and then they'll change


00:13:58.820 --> 00:14:01.600
the attributes of the object and then they'll call save.


00:14:01.600 --> 00:14:03.720
But then that's actually two database queries


00:14:03.720 --> 00:14:06.180
'cause you have to get it and then you have to update it.


00:14:06.180 --> 00:14:07.980
- And it's not just two database queries.


00:14:07.980 --> 00:14:10.380
It can be a lot of serialization.


00:14:10.380 --> 00:14:14.580
Like the slowest part of all of my data stack


00:14:14.580 --> 00:14:19.420
is if I were to try to pull back 10,000 records at a time,


00:14:19.420 --> 00:14:21.940
it's the deserialization of those 10,000 things


00:14:21.940 --> 00:14:25.140
that is actually the slowest part of the entire process.


00:14:25.140 --> 00:14:27.940
And here, if what you're talking about,


00:14:27.940 --> 00:14:29.060
like you're talking about the band,


00:14:29.060 --> 00:14:31.420
if the band has tons of information


00:14:31.420 --> 00:14:33.740
and you just want to change the name, right?


00:14:33.740 --> 00:14:35.380
You're pulling all that data back,


00:14:35.380 --> 00:14:37.580
converting it or whatever, then changing the thing


00:14:37.580 --> 00:14:39.060
and then pushing it back down.


00:14:39.060 --> 00:14:39.900
Yeah, it's a lot of work.


00:14:39.900 --> 00:14:41.500
- Yeah, and a lot of the time what'll happen


00:14:41.500 --> 00:14:43.300
is you'll serialize it into an object


00:14:43.300 --> 00:14:45.900
and then you'll deserialize it out into JSON anyway


00:14:45.900 --> 00:14:48.220
and you kind of, it's kind of pointless


00:14:48.220 --> 00:14:49.540
when you think about it.


00:14:49.540 --> 00:14:52.420
And there's also the problem with objects getting stale.


00:14:52.420 --> 00:14:54.820
So you might pull an object into memory,


00:14:54.820 --> 00:14:57.380
but then some other user might manipulate all those objects.


00:14:57.380 --> 00:14:59.300
But then when you save it, are you gonna overwrite


00:14:59.300 --> 00:15:01.820
those fields that have been updated in the database?


00:15:01.820 --> 00:15:03.540
So it's problematic in a way.


00:15:03.540 --> 00:15:07.260
So it is an ORM, but then I'd really encourage people


00:15:07.260 --> 00:15:08.660
to look at it as a query builder too,


00:15:08.660 --> 00:15:13.340
because in my own apps, I use the select method a lot.


00:15:13.340 --> 00:15:15.140
So rather than returning the objects,


00:15:15.140 --> 00:15:16.940
it returns dictionaries,


00:15:16.940 --> 00:15:19.500
and then it has this option, an output method.


00:15:19.500 --> 00:15:21.900
So you can just literally deserialize it


00:15:21.900 --> 00:15:23.480
straight into JSON.


00:15:23.480 --> 00:15:25.820
So this is what makes it fast


00:15:25.820 --> 00:15:28.220
because the query is going through async-pg,


00:15:28.220 --> 00:15:29.220
which is super fast,


00:15:29.220 --> 00:15:31.380
and then it's coming back as a dictionary


00:15:31.380 --> 00:15:33.460
straight from async-pg,


00:15:33.460 --> 00:15:36.220
and then it's using all JSON to stick it


00:15:36.220 --> 00:15:37.180
straight into a string.


00:15:37.180 --> 00:15:38.560
So you're kind of missing,


00:15:38.560 --> 00:15:41.500
you're skipping all this deserialization nonsense.


00:15:41.500 --> 00:15:42.900
- Yeah, yeah, yeah.


00:15:42.900 --> 00:15:43.900
This is super interesting.


00:15:43.900 --> 00:15:45.780
Now that you pointed out,


00:15:45.780 --> 00:15:50.780
I'm not used to seeing projections in ORMs.


00:15:50.780 --> 00:15:52.500
What I'm used to seeing is,


00:15:52.500 --> 00:15:56.060
give me back the classes that in this case, a band, right?


00:15:56.060 --> 00:15:58.280
Do a query like where the popular is greater than 100


00:15:58.280 --> 00:16:00.740
or whatever, and give me a whole bunch of bands,


00:16:00.740 --> 00:16:02.540
and then I'm gonna work with them.


00:16:02.540 --> 00:16:06.540
But sometimes, like the one I work with most commonly


00:16:06.540 --> 00:16:09.780
is Mongo engine, which I know is not an ORM, it's an ODM,


00:16:09.780 --> 00:16:12.300
but close enough, does the serialization bit.


00:16:12.300 --> 00:16:14.500
And you can say, I don't really want the other parts,


00:16:14.500 --> 00:16:19.500
just give me the name and like the website or something.


00:16:19.500 --> 00:16:22.100
And it won't ship or deserialize those things,


00:16:22.100 --> 00:16:23.820
but you just end up with the same objects


00:16:23.820 --> 00:16:26.700
that just have none everywhere else, right?


00:16:26.700 --> 00:16:29.860
Where in your ORM, you can actually say,


00:16:29.860 --> 00:16:33.700
you can actually say band.select, band.name,


00:16:33.700 --> 00:16:35.860
band.url or something like that.


00:16:35.860 --> 00:16:37.180
And that would return the dictionary


00:16:37.180 --> 00:16:38.320
with those two things, right?


00:16:38.320 --> 00:16:40.820
A list of dictionaries, probably?


00:16:40.820 --> 00:16:41.940
- A list of dictionaries, yeah.


00:16:41.940 --> 00:16:43.340
And then it also has a feature,


00:16:43.340 --> 00:16:46.240
like Django has this feature which is invaluable.


00:16:46.240 --> 00:16:47.820
It's called values list.


00:16:47.820 --> 00:16:49.540
And so if you just want one value back,


00:16:49.540 --> 00:16:52.980
it'll then condense it down to just a list of values.


00:16:52.980 --> 00:16:55.780
- I want all the IDs of the bands


00:16:55.780 --> 00:16:58.180
that play pop music or something.


00:16:58.180 --> 00:17:01.180
- Yeah, and it's so much more efficient than doing like


00:17:01.180 --> 00:17:04.100
in Django, you know, found the objects,


00:17:04.100 --> 00:17:07.060
the all and then looping through to get the IDs.


00:17:07.060 --> 00:17:08.500
It's just these little tricks you learn.


00:17:08.500 --> 00:17:10.620
Like if you're Django for ages,


00:17:10.620 --> 00:17:12.380
you just learn these little tricks.


00:17:12.380 --> 00:17:15.540
- Right, another one that stood out to me


00:17:15.540 --> 00:17:18.700
is the ability to do set-based operations.


00:17:18.700 --> 00:17:21.700
'Cause when I think of ORMs, I, just for everyone listening,


00:17:21.700 --> 00:17:22.700
I adore ORMs.


00:17:22.700 --> 00:17:25.040
I think they're really empowering for people.


00:17:25.040 --> 00:17:27.660
I think they take a lot of the modern tooling


00:17:27.660 --> 00:17:31.940
that we love, like refactoring and allow you to apply that


00:17:31.940 --> 00:17:35.260
like over to your query, because if you wanted to like


00:17:35.260 --> 00:17:37.660
change the casing of band.name, you could refactor,


00:17:37.660 --> 00:17:39.500
rename that and it would affect your queries


00:17:39.500 --> 00:17:41.940
'cause that's still Python code, right?


00:17:41.940 --> 00:17:45.080
That said, there are places where people either abuse it


00:17:45.080 --> 00:17:46.420
or it's just inappropriate.


00:17:46.420 --> 00:17:48.380
So the places where it gets abused a lot


00:17:48.380 --> 00:17:51.940
would be the N plus one problem, right?


00:17:51.940 --> 00:17:54.940
Where you've got a lazy reference to something else


00:17:54.940 --> 00:17:58.340
And you don't know that that's gonna be a separate query


00:17:58.340 --> 00:17:59.980
for every time you touch one of those.


00:17:59.980 --> 00:18:02.460
And you get a list of objects back and you loop over them


00:18:02.460 --> 00:18:03.940
and you access like in your example,


00:18:03.940 --> 00:18:07.860
you got band.manager for being band, band.manager, right?


00:18:07.860 --> 00:18:09.540
That could be 101 queries


00:18:09.540 --> 00:18:12.260
for what should have been one, right?


00:18:12.260 --> 00:18:13.380
- Yeah, that's a really good point.


00:18:13.380 --> 00:18:16.220
And even experienced developers get this wrong


00:18:16.220 --> 00:18:17.620
because they might use serializers,


00:18:17.620 --> 00:18:20.900
which are calling properties under the hood on the table,


00:18:20.900 --> 00:18:22.260
which are triggering SQL queries.


00:18:22.260 --> 00:18:25.420
So this is another design intent behind Piccolo


00:18:25.420 --> 00:18:28.660
is whenever a query is run, it's very explicit.


00:18:28.660 --> 00:18:30.620
You're literally calling dot run,


00:18:30.620 --> 00:18:32.660
- Right. - Or dot run sync.


00:18:32.660 --> 00:18:34.300
So there's none of this magic.


00:18:34.300 --> 00:18:37.540
You can't accidentally create an N plus one query.


00:18:37.540 --> 00:18:38.420
- You might accidentally end up


00:18:38.420 --> 00:18:40.340
with a co-routine or something.


00:18:40.340 --> 00:18:41.180
- Yeah.


00:18:41.180 --> 00:18:43.620
So yeah, it's a really good point


00:18:43.620 --> 00:18:45.780
'cause I think N plus one is kind of like the scourge


00:18:45.780 --> 00:18:47.100
of developers with performance.


00:18:47.100 --> 00:18:50.020
And also coming back to your point about ORMs,


00:18:50.020 --> 00:18:51.740
as a backend developer,


00:18:51.740 --> 00:18:53.780
you can spend hours a day using ORMs.


00:18:53.780 --> 00:18:56.060
It's kind of like one of the main tools in our tool belt.


00:18:56.060 --> 00:18:58.980
So it's kind of quite nice to start from a blank sheet


00:18:58.980 --> 00:19:01.260
of paper and think, how can I make that experience


00:19:01.260 --> 00:19:03.580
maybe like slightly better if I can.


00:19:03.580 --> 00:19:04.620
- Yeah, absolutely.


00:19:04.620 --> 00:19:07.540
So the N plus one problem, I believe is a,


00:19:07.540 --> 00:19:10.500
either there's some tool doing something


00:19:10.500 --> 00:19:11.500
behind the scenes you don't know,


00:19:11.500 --> 00:19:13.820
but often it's just a lack of understanding.


00:19:13.820 --> 00:19:17.420
Oh, that actually is a lazily loaded property,


00:19:17.420 --> 00:19:18.800
which is gonna trip your query.


00:19:18.800 --> 00:19:20.220
So I should have put a join


00:19:20.220 --> 00:19:21.820
and then I'd be in a better place.


00:19:21.820 --> 00:19:24.900
Right, like that's a programmer thing


00:19:24.900 --> 00:19:27.520
that you should pay attention to and work with.


00:19:27.520 --> 00:19:29.700
The one where I don't know how to fix it


00:19:29.700 --> 00:19:31.400
is more like the serialization thing.


00:19:31.400 --> 00:19:34.540
Like what if I want to go through my database


00:19:34.540 --> 00:19:39.220
and go to 10,000 records and make some changes to them?


00:19:39.220 --> 00:19:43.260
So often it's do the query, loop over the 10,000 things


00:19:43.260 --> 00:19:45.860
and make a change, call save.


00:19:45.860 --> 00:19:47.820
Maybe it's in one giant transaction


00:19:47.820 --> 00:19:49.500
that you finally push the changes back.


00:19:49.500 --> 00:19:52.100
but you're pulling all the data back.


00:19:52.100 --> 00:19:55.500
And one of the things I really like about your,


00:19:55.500 --> 00:19:58.720
or I'm here is like this update section here


00:19:58.720 --> 00:20:00.720
where you can do set based operations


00:20:00.720 --> 00:20:03.740
without pulling the records back.


00:20:03.740 --> 00:20:05.440
- Yeah, so you can do stuff like,


00:20:05.440 --> 00:20:07.300
so this example here,


00:20:07.300 --> 00:20:10.340
weight band.update, band.popularity 10,000,


00:20:10.340 --> 00:20:13.380
but then you can also do band.popularity


00:20:13.380 --> 00:20:15.680
is band.popularity plus 10.


00:20:15.680 --> 00:20:16.900
And then in the database,


00:20:16.900 --> 00:20:19.300
it will then just add 10 to all of the numbers.


00:20:19.300 --> 00:20:21.020
- Oh really?


00:20:21.020 --> 00:20:22.460
That's awesome. - Yeah.


00:20:22.460 --> 00:20:24.900
And then it's all just magic around,


00:20:24.900 --> 00:20:27.580
you know, Python magic methods.


00:20:27.580 --> 00:20:30.940
It's just, as a library offer, it gives you so much power.


00:20:30.940 --> 00:20:33.500
It's one of the things I love about Python.


00:20:33.500 --> 00:20:35.620
'Cause when you're building like query languages,


00:20:35.620 --> 00:20:38.820
like ORMs, I think very few languages


00:20:38.820 --> 00:20:41.940
can really rival Python with its flexibility.


00:20:41.940 --> 00:20:44.660
- Yeah.


00:20:44.660 --> 00:20:46.660
That's really why a lot of this stuff's possible.


00:20:46.660 --> 00:20:50.460
It's really neat. And I think


00:20:50.460 --> 00:20:54.700
the ability to push these changes without actually...


00:20:54.700 --> 00:20:58.260
You're still programming in the ORM classes in the model,


00:20:58.260 --> 00:21:01.260
but you're not actually pushing a whole bunch of them back and forth


00:21:01.260 --> 00:21:04.180
to make the changes, but to do these set-based operations,


00:21:04.180 --> 00:21:06.940
like delete them where, or make this update


00:21:06.940 --> 00:21:10.980
to this value where this is true, and then just push that,


00:21:10.980 --> 00:21:13.780
make that happen in the best way you can with SQL, right?


00:21:14.460 --> 00:21:19.260
Yeah, exactly. I think going back to your point around the n plus one, I think


00:21:19.260 --> 00:21:23.660
properties are something that can be a little bit evil and


00:21:23.660 --> 00:21:25.500
i've really


00:21:25.500 --> 00:21:27.500
shy away from them in the piccolo code because


00:21:27.500 --> 00:21:32.780
It can you call the property and you think you're getting a value back, but it could be doing any kind of magic


00:21:32.780 --> 00:21:34.700
and then


00:21:34.700 --> 00:21:40.220
Once you've defined something as a property, you then can't add arguments to it without breaking your api


00:21:40.220 --> 00:21:42.460
um


00:21:42.460 --> 00:21:47.500
So yeah, I think that's something i've tried to steer away from in general with piccolo like properties. Yeah


00:21:47.500 --> 00:21:53.980
It's a lot of a lot of hidden stuff happening there, right? Yeah. Yeah, it's not entirely clear. I think they're super useful but


00:21:53.980 --> 00:21:56.540
certainly in something where


00:21:56.540 --> 00:21:59.100
I thought I was accessing a field of the class


00:21:59.100 --> 00:22:01.580
But what I actually did is make a network call like that


00:22:01.580 --> 00:22:06.300
Distinction is possibly too big of a bridge to just make that automatic a lot of the times


00:22:06.300 --> 00:22:11.900
Yeah, there's no async properties in python as well. So that's kind of one of the reasons why


00:22:11.900 --> 00:22:14.900
It doesn't use any async properties.


00:22:14.900 --> 00:22:18.900
Maybe if they add it, maybe I'll put a comment on the PEP saying, "Don't do it."


00:22:18.900 --> 00:22:20.900
Yeah, exactly.


00:22:20.900 --> 00:22:24.900
Another thing that's interesting here is an alt code,


00:22:24.900 --> 00:22:31.900
every code you've written is await band.select or await band.delete and so on or update.


00:22:31.900 --> 00:22:33.900
And then at the end you say run.


00:22:33.900 --> 00:22:36.900
This is the explicit part that you were talking about in your API.


00:22:36.900 --> 00:22:38.900
Like I know here's where it's happening.


00:22:38.900 --> 00:22:42.060
And it probably makes a lot of sense to do that as well


00:22:42.060 --> 00:22:44.060
because on the flip side of it,


00:22:44.060 --> 00:22:47.060
that's where you have to await it anyway, right?


00:22:47.060 --> 00:22:50.060
Yeah, so what happens is you build up this query,


00:22:50.060 --> 00:22:52.060
you just chain methods to it,


00:22:52.060 --> 00:22:54.560
and then at any point you can print out that object,


00:22:54.560 --> 00:22:56.560
and I'll give you the SQL.


00:22:56.560 --> 00:22:58.560
- Oh, nice. - Yeah.


00:22:58.560 --> 00:23:00.560
And then until you actually await it...


00:23:00.560 --> 00:23:03.060
So there's something under the hood that I don't really publicize.


00:23:03.060 --> 00:23:05.060
You don't need the .run.


00:23:05.060 --> 00:23:08.060
If you await it, it will run as a convenience because people forget.


00:23:08.060 --> 00:23:14.860
But then it just makes it easier from a documentation perspective to say when it's async use run and when it's synchronous use run sync


00:23:14.860 --> 00:23:16.620
um


00:23:16.620 --> 00:23:17.740
right


00:23:17.740 --> 00:23:20.380
but and if you do run sync then um


00:23:20.380 --> 00:23:23.020
i've got like a bit of magic in there where


00:23:23.020 --> 00:23:25.580
it tries to


00:23:25.580 --> 00:23:30.220
Create an event loop to run it or it tries to figure out if there's already an event loop if there is run it in there


00:23:30.220 --> 00:23:34.540
Um, so you you can use piccolo in an old school


00:23:35.660 --> 00:23:39.420
WSGI app if you wanted to just synchronously.


00:23:39.420 --> 00:23:40.740
- Yeah, well, let's dive into that


00:23:40.740 --> 00:23:43.820
because that's one of the things that really stood out to me.


00:23:43.820 --> 00:23:48.140
Many frameworks or APIs packages tell you


00:23:48.140 --> 00:23:49.820
you're gonna either have to go,


00:23:49.820 --> 00:23:51.580
you're gonna take a fork in the road,


00:23:51.580 --> 00:23:52.860
you're gonna go down the async fork


00:23:52.860 --> 00:23:55.620
and you're gonna use the async library like HTTPX


00:23:55.620 --> 00:23:56.940
or you're gonna go on another fork


00:23:56.940 --> 00:24:00.340
and you're gonna use the request library that has no async


00:24:00.340 --> 00:24:02.140
and you're gonna go down that path


00:24:02.140 --> 00:24:05.140
and you choose and you just go.


00:24:05.140 --> 00:24:08.340
And with Piccolo, you can actually run,


00:24:08.340 --> 00:24:13.340
I guess the default behavior would be to be async and await,


00:24:13.340 --> 00:24:15.380
but it has this .run async,


00:24:15.380 --> 00:24:18.860
which will kind of cap where the asynchronous behaves


00:24:18.860 --> 00:24:20.940
and goes, and it'll just,


00:24:20.940 --> 00:24:23.220
you could run it in a regular Flask app


00:24:23.220 --> 00:24:24.860
or Django app or whatever,


00:24:24.860 --> 00:24:27.780
and not worry about it being async at all, right?


00:24:27.780 --> 00:24:28.620
- Yeah, that's right.


00:24:28.620 --> 00:24:30.380
And it's actually one of the design challenges


00:24:30.380 --> 00:24:32.060
with Piccolo is how do you create an API


00:24:32.060 --> 00:24:34.780
which is synchronous and asynchronous?


00:24:34.780 --> 00:24:36.820
And there's only really two ways of achieving it.


00:24:36.820 --> 00:24:39.840
It's with a method like run or run sync


00:24:39.840 --> 00:24:41.060
or with context managers.


00:24:41.060 --> 00:24:43.780
So some of them you'll create


00:24:43.780 --> 00:24:46.940
either an async context manager or synchronous.


00:24:46.940 --> 00:24:48.620
And then that'll then impact


00:24:48.620 --> 00:24:51.240
whether the underlying query is synchronous or not.


00:24:51.240 --> 00:24:53.460
But then it adds a little bit more boilerplate


00:24:53.460 --> 00:24:55.420
if every time you run a query,


00:24:55.420 --> 00:24:58.300
you need a context manager to tell it to be async.


00:24:58.300 --> 00:25:02.420
So this was kind of the best outcome I could think of


00:25:02.420 --> 00:25:04.980
which just have .run or .runsync.


00:25:04.980 --> 00:25:07.260
- I think this is great, especially since even


00:25:07.260 --> 00:25:09.340
if you forget the run, it'll still run async,


00:25:09.340 --> 00:25:11.140
but there's a way to kind of cap it.


00:25:11.140 --> 00:25:13.900
So something I wanted to talk about,


00:25:13.900 --> 00:25:16.420
it's driven me crazy ever since async and await


00:25:16.420 --> 00:25:18.760
were introduced because I don't find it to be true,


00:25:18.760 --> 00:25:21.740
but I hear it all the time spoken about in the community


00:25:21.740 --> 00:25:25.400
is async and await, they're super neat,


00:25:25.400 --> 00:25:27.100
but they're like viruses.


00:25:27.100 --> 00:25:30.100
And in the sense that soon as like one of your functions


00:25:30.100 --> 00:25:32.780
way, way at the bottom has to do something async.


00:25:32.780 --> 00:25:34.900
Well, then the thing that calls it has to be async


00:25:34.900 --> 00:25:35.740
and await it.


00:25:35.740 --> 00:25:37.180
And the things that call that function now


00:25:37.180 --> 00:25:38.420
all have to await it.


00:25:38.420 --> 00:25:40.540
And that percolates all the way at the top of your app.


00:25:40.540 --> 00:25:43.180
And so now you've, by using any async library,


00:25:43.180 --> 00:25:44.900
you've turned your entire thing into this like


00:25:44.900 --> 00:25:48.420
async vertical call stack, right?


00:25:48.420 --> 00:25:52.940
And, and what your example here shows that that's not,


00:25:52.940 --> 00:25:54.580
it doesn't have to be that way, right?


00:25:54.580 --> 00:25:55.460
That's sort of the naive,


00:25:55.460 --> 00:25:57.740
I'm just gonna like write the code without thinking about it.


00:25:57.740 --> 00:26:01.500
But if you want to say, have your data access layer


00:26:01.500 --> 00:26:03.280
do three things,


00:26:03.280 --> 00:26:05.420
'cause it's got to pull up some stuff from different places,


00:26:05.420 --> 00:26:06.380
you want that to be async,


00:26:06.380 --> 00:26:08.340
it doesn't mean that function has to be async.


00:26:08.340 --> 00:26:10.380
It could just start its own event loop,


00:26:10.380 --> 00:26:13.240
do the three things faster than without it,


00:26:13.240 --> 00:26:14.700
and then return the answers, right?


00:26:14.700 --> 00:26:16.860
You can kind of cap it at any level that you want.


00:26:16.860 --> 00:26:20.100
And your run sync is kind of an example of that.


00:26:20.100 --> 00:26:21.980
Like you can choose to not have it


00:26:21.980 --> 00:26:24.340
just turn your entire app async.


00:26:24.340 --> 00:26:26.960
- Yeah, you can jump between them.


00:26:26.960 --> 00:26:30.140
So typically if people use an async,


00:26:30.140 --> 00:26:32.140
then it's like, the argument is,


00:26:32.140 --> 00:26:35.220
if you need async, your whole app probably should be async


00:26:35.220 --> 00:26:37.620
because otherwise why use an async?


00:26:37.620 --> 00:26:39.380
But then you can flip between them quite easily.


00:26:39.380 --> 00:26:41.140
So if you've got a synchronous app


00:26:41.140 --> 00:26:42.420
and you wanna call some async code,


00:26:42.420 --> 00:26:44.500
there's asyncio.run.


00:26:44.500 --> 00:26:47.460
And you can also do stuff like spin up an event loop


00:26:47.460 --> 00:26:50.700
in a different thread and then send work to that.


00:26:50.700 --> 00:26:51.540
- Yeah, absolutely.


00:26:51.540 --> 00:26:53.060
- So it is quite fluid.


00:26:53.060 --> 00:26:55.460
You can flip between them quite easily.


00:26:55.460 --> 00:26:57.220
- Yeah, I mean, just one example that comes to mind


00:26:57.220 --> 00:27:01.780
is what if I wanted to go web scrape every page


00:27:01.780 --> 00:27:03.140
at a certain domain?


00:27:03.140 --> 00:27:06.140
So I've got a function that gives me a domain,


00:27:06.140 --> 00:27:09.660
I give it a domain, and then I want it to return


00:27:09.660 --> 00:27:12.660
or store into the database all the pages.


00:27:12.660 --> 00:27:16.180
That would be perfectly reasonable to have that thing go,


00:27:16.180 --> 00:27:17.940
okay, well, let's do a request,


00:27:17.940 --> 00:27:19.020
figure out what all the pages are,


00:27:19.020 --> 00:27:21.260
and then just recursively sort of grab them


00:27:21.260 --> 00:27:23.100
all asynchronously.


00:27:23.100 --> 00:27:24.300
You would get a huge boost


00:27:24.300 --> 00:27:26.520
on getting every page off a site,


00:27:26.520 --> 00:27:29.040
even if that function blocked, you know what I mean?


00:27:29.040 --> 00:27:32.000
'Cause it itself could just go crazy against the server.


00:27:32.000 --> 00:27:33.960
Maybe it shouldn't, but it could.


00:27:33.960 --> 00:27:37.000
- Yeah, I'm a huge fan of asyncio.gather as well.


00:27:37.000 --> 00:27:40.480
So that's a really like beautiful API just for saying,


00:27:40.480 --> 00:27:42.280
do these 50 things now, please.


00:27:42.280 --> 00:27:44.000
And let me know when you're done.


00:27:44.000 --> 00:27:45.600
- Yeah, and block, right?


00:27:45.600 --> 00:27:49.040
When you're done, give me a list of answers or errors.


00:27:49.040 --> 00:27:49.880
- Yeah.


00:27:49.880 --> 00:27:53.560
- Also on the live stream, Chris May, hey Chris,


00:27:53.560 --> 00:27:56.840
says, "I'm so excited to use Piccolo with Unsync.


00:27:56.840 --> 00:27:59.100
"I have a workflow that'd be nice to parallelize."


00:27:59.100 --> 00:28:01.680
And yeah, so I think Unsync is another


00:28:01.680 --> 00:28:06.200
really interesting library that wraps up async.io


00:28:06.200 --> 00:28:09.360
plus threading plus multi-processing,


00:28:09.360 --> 00:28:11.520
but then gives you a nice way to cap it as well


00:28:11.520 --> 00:28:13.980
'cause you can go, like, be given a task


00:28:13.980 --> 00:28:14.880
that comes back from there.


00:28:14.880 --> 00:28:17.220
If you just ask for the result and it's not done,


00:28:17.220 --> 00:28:20.520
it'll just block like a regular thing.


00:28:20.520 --> 00:28:22.080
And it does kind of what you're talking about.


00:28:22.080 --> 00:28:25.140
it has a background thread with its own event loop


00:28:25.140 --> 00:28:27.900
and it just pushes all the work over to there.


00:28:27.900 --> 00:28:29.740
Yeah, so, yeah, pretty neat.


00:28:29.740 --> 00:28:31.420
- That's a cool library.


00:28:31.420 --> 00:28:34.260
- Yeah, it is, at least for the size, right?


00:28:34.260 --> 00:28:38.100
Like 126 lines and it unifies those three APIs


00:28:38.100 --> 00:28:39.040
and adds some more stuff.


00:28:39.040 --> 00:28:43.140
That's pretty big bang for the Python byte there.


00:28:43.140 --> 00:28:43.980
- Yeah, that's impressive.


00:28:43.980 --> 00:28:45.540
I wish Piccolo was not to us.


00:28:45.540 --> 00:28:49.420
I think it's thousands, tens of thousands of lines by now.


00:28:49.420 --> 00:28:50.700
- Yeah, yeah.


00:28:50.700 --> 00:28:55.140
- So another one of the new Python 3.6 onward type of things


00:28:55.140 --> 00:28:57.780
that's really cool is the type annotations.


00:28:57.780 --> 00:28:59.740
- Yeah, I love type annotations.


00:28:59.740 --> 00:29:05.280
So part of my job in the past was using Swift


00:29:05.280 --> 00:29:09.480
and Swift is almost like Python's brother or sister.


00:29:09.480 --> 00:29:11.740
It was very heavily inspired by Python.


00:29:11.740 --> 00:29:13.660
- Right, it's like if Python all of a sudden decided


00:29:13.660 --> 00:29:18.420
it was incredibly strict about typing and type definitions.


00:29:18.420 --> 00:29:19.260
- Yeah.


00:29:19.260 --> 00:29:20.080
- That would be a lot like Swift, right?


00:29:20.080 --> 00:29:25.600
compiled. Yeah, but it's a combination of type annotations and the tooling to support it


00:29:25.600 --> 00:29:28.240
So in python's case, it's vs code and in swift's case


00:29:28.240 --> 00:29:34.240
It's xcode and it just means that when you're refactoring it just makes it so much more confident about what's going on


00:29:34.240 --> 00:29:37.040
um, it provides documentation because


00:29:37.040 --> 00:29:43.040
Previously people were putting in a doc string anyway, so why not put it in your function definition and then you can introspect it


00:29:43.040 --> 00:29:50.020
Um, and my pi is incredibly powerful. I I honestly don't think I could have built piccola without type annotations


00:29:50.020 --> 00:29:54.020
Because it makes your code so much more maintainable


00:29:54.020 --> 00:30:00.020
The click to go to VS Code as well is just a beautiful usability improvement


00:30:00.020 --> 00:30:04.020
And then, kind of one of the hidden benefits is it makes tab completion so good


00:30:04.020 --> 00:30:11.020
So a lot of Python auto completions, they use a library called Jedi under the hood


00:30:11.020 --> 00:30:16.020
So when I was building Piccolo, I had to look at the source code to try and figure out how it does its magic


00:30:16.020 --> 00:30:19.360
And if you give a type annotation to something like,


00:30:19.360 --> 00:30:20.620
this is what this function returns,


00:30:20.620 --> 00:30:24.700
it's a really strong indicator to Jedi that,


00:30:24.700 --> 00:30:26.060
you know, this is what's gonna get returned.


00:30:26.060 --> 00:30:28.120
I don't need to do any magic anymore.


00:30:28.120 --> 00:30:30.640
And so-- - I would say that half the time,


00:30:30.640 --> 00:30:32.740
that's why I do it is to make the editor better.


00:30:32.740 --> 00:30:34.440
So both VS Code and PyCharm,


00:30:34.440 --> 00:30:38.540
like take a good look at what the type annotations are.


00:30:38.540 --> 00:30:39.380
- Yeah. - Right?


00:30:39.380 --> 00:30:41.020
You can just say, oh, you're trying to pass a string


00:30:41.020 --> 00:30:42.660
and that's really supposed to be an integer.


00:30:42.660 --> 00:30:44.820
But then also like you say, tab completion


00:30:44.820 --> 00:30:47.960
or autocomplete all over the place is fantastic.


00:30:47.960 --> 00:30:49.420
- Yeah, I think that's a distinction as well


00:30:49.420 --> 00:30:51.180
where I think if you're building an application,


00:30:51.180 --> 00:30:53.220
let's say you're building a Django app or a Flask app,


00:30:53.220 --> 00:30:54.660
you don't need to care quite as much.


00:30:54.660 --> 00:30:57.860
Like I personally would still have type annotations,


00:30:57.860 --> 00:31:00.540
but for libraries, I think it's just absolutely essential.


00:31:00.540 --> 00:31:02.820
Like I don't think any new Python library


00:31:02.820 --> 00:31:03.820
should be written without it


00:31:03.820 --> 00:31:08.600
because you're kind of shortchanging your users in a way


00:31:08.600 --> 00:31:10.980
'cause their editor experience is so much worse.


00:31:10.980 --> 00:31:14.060
- Yeah, in the Flask app, for example, that you've mentioned,


00:31:14.060 --> 00:31:15.860
I would say on the boundaries, right?


00:31:15.860 --> 00:31:16.980
Like here's a data access layer,


00:31:16.980 --> 00:31:19.780
like put type annotations on those little bits there.


00:31:19.780 --> 00:31:21.380
And then the rest of the app,


00:31:21.380 --> 00:31:23.660
usually the editors and the tools will just pick it up


00:31:23.660 --> 00:31:26.420
and continue to tell you what you're working with.


00:31:26.420 --> 00:31:27.260
- Yeah.


00:31:27.260 --> 00:31:28.200
- But if you're doing a library, right,


00:31:28.200 --> 00:31:30.120
you want every function or every class


00:31:30.120 --> 00:31:33.840
to be kind of standalone and know everything it can.


00:31:33.840 --> 00:31:34.680
- Yeah, definitely.


00:31:34.680 --> 00:31:36.460
And one more thing about type annotations


00:31:36.460 --> 00:31:38.220
is it's probably the greatest source


00:31:38.220 --> 00:31:39.740
of interview questions ever made


00:31:39.740 --> 00:31:42.700
because you can ask people in an interview,


00:31:42.700 --> 00:31:44.420
What's the difference between like a sequence


00:31:44.420 --> 00:31:45.260
and an iterable?


00:31:45.260 --> 00:31:47.180
And like when you use type annotations,


00:31:47.180 --> 00:31:49.820
you really start to think about what's going on.


00:31:49.820 --> 00:31:52.140
And it's a great learning experience too.


00:31:52.140 --> 00:31:54.460
- I wanna pass a generator here,


00:31:54.460 --> 00:31:57.700
but it takes a list of things and it says that won't work.


00:31:57.700 --> 00:31:59.980
Maybe you just need to relax your type annotations


00:31:59.980 --> 00:32:00.820
to an iterator.


00:32:00.820 --> 00:32:01.660
- Yeah.


00:32:01.660 --> 00:32:03.260
- Yeah, that kind of thing.


00:32:03.260 --> 00:32:05.540
Quick question from Roller out there on livestream.


00:32:05.540 --> 00:32:08.420
Hey Roller, can I just pick a level and place a Mongo engine


00:32:08.420 --> 00:32:11.620
or is it just for a relational stuff?


00:32:11.620 --> 00:32:14.780
- Yeah, it's just relational and it's,


00:32:14.780 --> 00:32:17.380
you can use SQLite locally, but it's mostly Postgres.


00:32:17.380 --> 00:32:21.020
It was really built to take advantage of Postgres


00:32:21.020 --> 00:32:23.100
because Postgres is,


00:32:23.100 --> 00:32:26.660
it's like the fastest growing SQL database in the world,


00:32:26.660 --> 00:32:29.180
which is remarkable to think it's how old it is.


00:32:29.180 --> 00:32:31.700
And I think I'll, you know,


00:32:31.700 --> 00:32:33.940
I think adding other SQL databases would be quite easy,


00:32:33.940 --> 00:32:38.540
but adding something like Mongo would be a bit trickier.


00:32:38.540 --> 00:32:41.240
I wouldn't say it was impossible, but a bit more work.


00:32:41.240 --> 00:32:47.680
Yeah, I would think so. Yeah, it's not certainly not impossible, but like joined and stuff would get tricky. What about


00:32:47.680 --> 00:32:53.900
SQL injection, I mean many of us have heard about the little Bobby tables XKCD, which is


00:32:53.900 --> 00:32:56.760
delightful, you know, yeah, you know sort of


00:32:56.760 --> 00:33:00.120
Schadenfreude a sort of way


00:33:00.120 --> 00:33:05.440
we all kind of sort of relish in somebody else suffering this but I


00:33:05.760 --> 00:33:11.680
I find that this is actually one of the really nice things about orms most of the time is that they scrape off


00:33:11.680 --> 00:33:17.120
The ability to do sql injection because you're not building the sql


00:33:17.120 --> 00:33:19.920
Yeah, definitely. So, um


00:33:19.920 --> 00:33:25.200
Your database adapter so something like async pg or psycho pg in the synchronous world


00:33:25.200 --> 00:33:30.720
What you want to do is you want to pass it the query string with placeholders for any user


00:33:31.360 --> 00:33:36.000
Submitted values and then you submit the values that separately like in a list


00:33:36.000 --> 00:33:37.520
um


00:33:37.520 --> 00:33:44.080
And it sounds like a parameterized query basically. Yeah. Yeah, and as long as you do that you're safe. but then


00:33:44.080 --> 00:33:46.800
for a library


00:33:46.800 --> 00:33:50.960
When people are programmatically creating very complex equal queries


00:33:50.960 --> 00:33:52.720
and then


00:33:52.720 --> 00:33:58.320
You need to try and make sure that you've got the right values that match the right placeholders to pass to the adapter


00:33:58.960 --> 00:34:05.600
It is quite challenging. There's some like recursive code where it has to so we use some called query strings internally within piccolo


00:34:05.600 --> 00:34:08.880
So it never concatenates strings for sql statements


00:34:08.880 --> 00:34:14.400
It just it uses query strings and then it compiles them before sending it to the database adapter


00:34:14.400 --> 00:34:17.520
And it basically looks through all of the sub query strings


00:34:17.520 --> 00:34:22.480
It might have if it's a really complex query and then it kind of passes it to the adapter


00:34:22.480 --> 00:34:24.000
um, but yeah


00:34:24.000 --> 00:34:26.040
- Yeah, it's just one of the complex things


00:34:26.040 --> 00:34:27.760
about building ORMs for sure.


00:34:27.760 --> 00:34:30.520
And also one of the most dangerous to get wrong.


00:34:30.520 --> 00:34:32.180
- Yeah, yeah, it absolutely is.


00:34:32.180 --> 00:34:34.960
There's untold number of bad things


00:34:34.960 --> 00:34:37.080
that can happen with SQL injection.


00:34:37.080 --> 00:34:38.080
And it's so easy.


00:34:38.080 --> 00:34:40.880
All you have to do is put a single little tick


00:34:40.880 --> 00:34:42.720
to comment out stuff,


00:34:42.720 --> 00:34:45.780
semi-colon to finish the statement,


00:34:45.780 --> 00:34:47.640
and then you can run arbitrary code.


00:34:47.640 --> 00:34:49.200
And a lot of times you can even,


00:34:49.200 --> 00:34:51.200
some database engines will let you run


00:34:52.360 --> 00:34:57.360
sub-process type things, which is even worse, but yeah.


00:34:57.360 --> 00:35:00.040
It's not good, so you definitely wanna avoid it.


00:35:00.040 --> 00:35:01.640
- Yeah, it's a good argument for using ORMs


00:35:01.640 --> 00:35:05.040
and query builders because it'll make it less likely.


00:35:05.040 --> 00:35:08.200
- Yeah, I think for sure.


00:35:08.200 --> 00:35:09.960
You know, another thing that I wanted to touch on


00:35:09.960 --> 00:35:14.760
a little bit here is the actual filtering


00:35:14.760 --> 00:35:17.320
or projection statement type bits.


00:35:17.320 --> 00:35:21.160
So I mentioned using Mongo engine before,


00:35:21.160 --> 00:35:26.640
which I'm a big fan of, and it's basically a Mongo equivalent of that Django ORM.


00:35:26.640 --> 00:35:28.640
So in that regard, they're real similar.


00:35:28.640 --> 00:35:31.960
And you do things like if I wanted to say where the band popularity,


00:35:31.960 --> 00:35:37.000
or let's say the band name is Pythonistas, right?


00:35:37.000 --> 00:35:41.880
You would just say name equals Pythonistas as part of the filter.


00:35:41.880 --> 00:35:44.120
And there's two things that are crummy about that.


00:35:44.120 --> 00:35:47.880
One is you get no autocomplete that there's a column called name


00:35:47.880 --> 00:35:52.880
because it's not, it doesn't really know what class,


00:35:52.880 --> 00:35:56.040
even though you started out, like band.objects,


00:35:56.040 --> 00:35:57.460
it doesn't, in the filter part,


00:35:57.460 --> 00:36:00.200
it no longer knows that the name came from the band, right?


00:36:00.200 --> 00:36:02.360
That's not part of the language.


00:36:02.360 --> 00:36:04.760
And then the other one is you're doing an equals,


00:36:04.760 --> 00:36:07.480
or you've got like weird operators,


00:36:07.480 --> 00:36:12.480
like in the name, like name__gt for greater than


00:36:12.480 --> 00:36:14.040
and stuff like that.


00:36:14.040 --> 00:36:16.400
Whereas yours, you just write what you would put


00:36:16.400 --> 00:36:19.000
into an if statement or a loop or something like that.


00:36:19.000 --> 00:36:22.240
So you would say like band out popularity less than 1000.


00:36:22.240 --> 00:36:25.160
That's the thing you send in there.


00:36:25.160 --> 00:36:26.000
- Yeah, that's right.


00:36:26.000 --> 00:36:28.800
So I've been caught up,


00:36:28.800 --> 00:36:30.400
tripped up so many times in the past with Django


00:36:30.400 --> 00:36:33.680
where I've had something like name double underscore


00:36:33.680 --> 00:36:34.800
something else.


00:36:34.800 --> 00:36:38.360
And then it can't really understand that's wrong


00:36:38.360 --> 00:36:41.320
like a linter or while you're coding


00:36:41.320 --> 00:36:42.400
it only really knows that a runtime


00:36:42.400 --> 00:36:43.480
and then you've got a 500 error.


00:36:43.480 --> 00:36:46.520
So the idea here is a linter would be able


00:36:46.520 --> 00:36:49.200
to pick up these problems.


00:36:49.200 --> 00:36:52.920
- Exactly, because so much of the pieces are,


00:36:52.920 --> 00:36:54.880
they're just using star star KW args,


00:36:54.880 --> 00:36:57.000
and then they figure out how to generate a query


00:36:57.000 --> 00:37:00.680
out of like looking for special keywords in the key names


00:37:00.680 --> 00:37:03.360
and then turning those to columns.


00:37:03.360 --> 00:37:05.000
Also the refactoring thing, right?


00:37:05.000 --> 00:37:07.320
The linters and if I wanna do a refactoring


00:37:07.320 --> 00:37:08.880
to rename popularity,


00:37:08.880 --> 00:37:13.360
it's not gonna check popularity_gt as a keyword argument.


00:37:13.360 --> 00:37:15.360
It has no idea those are related


00:37:15.360 --> 00:37:17.360
Yeah, yeah, definitely


00:37:17.360 --> 00:37:21.280
um, so the way it's implemented this the double equals and


00:37:21.280 --> 00:37:26.980
All these operators is this is one of the amazing things about python is how you can just overload


00:37:26.980 --> 00:37:31.840
Like fundamental things about the language so you can overload what?


00:37:31.840 --> 00:37:34.400
addition means


00:37:34.400 --> 00:37:38.480
And when someone first tells you that it sounds like the most mental thing in the world because why would you want one plus one?


00:37:38.480 --> 00:37:43.120
To equal five for then it turns out when you're building an orm. It's it's golden


00:37:43.120 --> 00:37:46.380
And this is one reason why I find Python


00:37:46.380 --> 00:37:48.700
just so compelling over and over again,


00:37:48.700 --> 00:37:52.100
is because as a library author, you can do this stuff


00:37:52.100 --> 00:37:55.860
that you can get closer to more of like a DSL


00:37:55.860 --> 00:37:56.700
than like a--


00:37:56.700 --> 00:38:00.140
- Like domain specific language, yeah, absolutely.


00:38:00.140 --> 00:38:00.980
- Yeah.


00:38:00.980 --> 00:38:05.340
- So is this be done with descriptors or what's the magic?


00:38:05.340 --> 00:38:10.340
- So for the less than, there's like double underscore LT


00:38:12.540 --> 00:38:13.600
and you can override that.


00:38:13.600 --> 00:38:15.340
And then what happens is when you call that method,


00:38:15.340 --> 00:38:17.380
it returns a where object.


00:38:17.380 --> 00:38:21.700
And then you can also do in brackets,


00:38:21.700 --> 00:38:24.100
band.popularity less than 1000,


00:38:24.100 --> 00:38:26.180
and then double and sign as well,


00:38:26.180 --> 00:38:28.980
band.popularity greater than 500.


00:38:28.980 --> 00:38:31.140
So you can combine them with and and or statements.


00:38:31.140 --> 00:38:35.380
So the where statements in Piccolo can get really powerful.


00:38:35.380 --> 00:38:38.860
But yeah, it's just--


00:38:38.860 --> 00:38:41.820
- You just have to teach the where clauses how to and,


00:38:41.820 --> 00:38:43.500
and then structure it in a way that Python


00:38:43.500 --> 00:38:45.860
will let it kind of go through, right?


00:38:45.860 --> 00:38:48.260
- Yeah, or you can do .where, put some stuff in,


00:38:48.260 --> 00:38:49.540
and then another .where statement.


00:38:49.540 --> 00:38:50.860
If you've got multiple where statements,


00:38:50.860 --> 00:38:52.740
it becomes like it's an and.


00:38:52.740 --> 00:38:54.220
- Yeah, yeah.


00:38:54.220 --> 00:38:56.420
- But yeah, it's just all Python magic,


00:38:56.420 --> 00:38:59.980
which is one of the reasons I love Python.


00:38:59.980 --> 00:39:02.780
- Yeah, speaking of overridden things,


00:39:02.780 --> 00:39:04.860
the thing that I think is the most insane,


00:39:04.860 --> 00:39:08.100
that I'm starting to love, but took a while to get used to,


00:39:08.100 --> 00:39:12.180
is the way the path object works for defining paths.


00:39:12.180 --> 00:39:18.940
The forward slash often means like drive separation


00:39:18.940 --> 00:39:21.580
on the POSIX systems and it's close enough.


00:39:21.580 --> 00:39:23.380
You could actually put forward slash in your strings


00:39:23.380 --> 00:39:25.300
in Python on Windows and it'll still like,


00:39:25.300 --> 00:39:27.300
okay, fine, backslash is what you meant.


00:39:27.300 --> 00:39:32.540
So they overrode the divide operator in code


00:39:32.540 --> 00:39:36.280
to allow you to concatenate strings and paths together.


00:39:36.280 --> 00:39:37.740
And that's just crazy.


00:39:37.740 --> 00:39:39.680
- Yeah, the first time I saw it, I was very confused,


00:39:39.680 --> 00:39:43.020
but when you understand it, it's okay, but yeah, totally.


00:39:43.020 --> 00:39:45.940
- Yeah, I've gotten okay with it as well,


00:39:45.940 --> 00:39:47.620
and I start to use it, and I really like it now,


00:39:47.620 --> 00:39:49.180
but I was like, I don't know if I can get behind.


00:39:49.180 --> 00:39:50.740
This is a bridge too far.


00:39:50.740 --> 00:39:52.020
This is, that's division.


00:39:52.020 --> 00:39:53.300
What are we doing here?


00:39:53.300 --> 00:39:54.820
No, it's cool, it's cool.


00:39:54.820 --> 00:39:56.660
- Talking of magic, to Piccolo,


00:39:56.660 --> 00:39:58.860
like all ORMs, it uses metaclasses a lot,


00:39:58.860 --> 00:40:01.620
and there's something that got added in,


00:40:01.620 --> 00:40:03.940
I don't know if it's Python 3.7 or 3.6,


00:40:03.940 --> 00:40:06.500
but they actually changed metaclasses slightly,


00:40:06.500 --> 00:40:09.160
So there's now like a thunder magic method called in its subclass


00:40:09.160 --> 00:40:14.440
and piccolo uses this a lot and it's it's actually an amazing hidden feature of


00:40:14.440 --> 00:40:18.520
Python where you can now add keyword arguments to a class definition


00:40:18.520 --> 00:40:22.280
So if you had class foo open brackets inherits from bar


00:40:22.280 --> 00:40:27.320
Comma and then you can start adding keyword arguments to the class to customize its creation


00:40:27.320 --> 00:40:30.040
And that that's kind of like a new


00:40:30.040 --> 00:40:32.280
layer of magic that's been added


00:40:32.280 --> 00:40:34.600
to python recently and


00:40:34.600 --> 00:40:39.800
Piccolo uses it extensively, but I don't see many other libraries using it yet because it's probably not so well known


00:40:39.800 --> 00:40:45.640
But yeah, just kind of spread that bit of magic. So hopefully people can use it too. Nice. Yeah, that sounds awesome


00:40:45.640 --> 00:40:48.440
I can certainly see how and like trying to create


00:40:48.440 --> 00:40:52.040
The classes like the band class or whatever you say that it's going to be


00:40:52.040 --> 00:40:58.780
Would definitely use that so one of the things that you say is awesome about piccolo is the batteries included


00:40:58.780 --> 00:41:02.760
Yeah, so let's talk about some of the batteries. So


00:41:03.800 --> 00:41:09.560
yeah, so the main battery by far is the admin because when I started it I was working for a design agency and


00:41:09.560 --> 00:41:14.680
Admins are incredibly important for design agencies because you want to put something in front of a customer


00:41:14.680 --> 00:41:17.160
That they like the look of and they're comfortable using


00:41:17.160 --> 00:41:21.640
um, so this is a huge part of the effort that's gone into piccolo and


00:41:21.640 --> 00:41:23.640
um


00:41:23.640 --> 00:41:26.040
So this is a it's just a project called piccolo admin


00:41:26.040 --> 00:41:31.640
And what happens is it's it's an ascii app so I can maybe go into more detail about ascii later on but


00:41:32.360 --> 00:41:36.440
All you do is you give it a list of piccolo tables and then it uses


00:41:36.440 --> 00:41:40.040
Pydantic so pydantic is a serialization library and


00:41:40.040 --> 00:41:48.040
It basically creates a pydantic model from the piccolo table and then pydantic models have this really useful method


00:41:48.040 --> 00:41:54.280
Where it's json schema and it creates a json schema for the pydantic model


00:41:54.280 --> 00:42:01.480
So right because the buy tender classes know this field is an end. This one is an optional date time and so on


00:42:01.960 --> 00:42:07.160
Yeah, so picola has really good pedantic support, but it's in a sister repo called piccolo api


00:42:07.160 --> 00:42:13.880
and then that so that creates the Pydantic model and it also has something called piccolo crud, so you give it a


00:42:13.880 --> 00:42:16.760
piccolo table and it creates


00:42:16.760 --> 00:42:21.000
Another ascii app which has got all of the crud operations for your database. So


00:42:21.000 --> 00:42:25.240
You can programmatically create this huge api just by giving it a few tables


00:42:25.240 --> 00:42:30.920
And then the front end is written in vue js and it's completely decoupled from the back end. It's just all by api


00:42:31.800 --> 00:42:33.160
um


00:42:33.160 --> 00:42:38.120
so yeah, i'm a huge fan of ujs because it's it's very natural for python developers who used to


00:42:38.120 --> 00:42:44.380
Template syntax in django and flask if you looked at the view templates you'd be like this looks very familiar


00:42:44.380 --> 00:42:46.840
So yeah, i'm a big fan of that. Nice


00:42:46.840 --> 00:42:50.040
Yeah, I think it's super close to chameleon because the attribute driven


00:42:50.040 --> 00:42:52.680
Behavior as well. Yeah


00:42:52.680 --> 00:42:53.560
Yeah


00:42:53.560 --> 00:42:57.880
But then like to make a working admin requires so much work because you've also got the security side


00:42:57.960 --> 00:43:03.880
So piccolo API has a bunch of really useful asking middleware and it has like session authentication


00:43:03.880 --> 00:43:08.920
Csrf protection and rate limiting as well because you don't want people to spam the login


00:43:08.920 --> 00:43:13.960
um, so like just to get a fairly simple admin is


00:43:13.960 --> 00:43:16.760
In it's like a iceberg


00:43:16.760 --> 00:43:18.760
Um to do it properly


00:43:18.760 --> 00:43:23.000
So yeah, a lot of effort's gone into the admin. but i'm really proud of it and


00:43:24.120 --> 00:43:31.080
Like this is really what excites me more than anything about the future because as we add support for post GIS and stuff like that


00:43:31.080 --> 00:43:36.520
Being able to create really interesting widgets around data. So, you know, how could I design?


00:43:36.520 --> 00:43:39.880
a rectangle field for post gis or


00:43:39.880 --> 00:43:44.600
I could see some really cool stuff that


00:43:44.600 --> 00:43:49.640
Are sort of template extensions, you know, like let's just pick Jinja for example


00:43:49.800 --> 00:43:53.800
Like if you had one of these objects you could pass it over and it knew


00:43:53.800 --> 00:43:58.040
For example, here's a daytime. You could just say make a calendar picker


00:43:58.040 --> 00:44:01.880
Here and it just you know, as long as you have the javascript included


00:44:01.880 --> 00:44:07.080
Instead of just putting the text it gives you like a nice little ajax widget


00:44:07.080 --> 00:44:09.080
or


00:44:09.080 --> 00:44:13.160
These this list goes on a map drop in the map widget and off it goes


00:44:13.160 --> 00:44:14.760
Yeah


00:44:14.760 --> 00:44:19.320
Um, so basically pickler admin. It's just it's just turns pydantic models into ui


00:44:19.320 --> 00:44:23.600
And it's actually quite interesting.


00:44:23.600 --> 00:44:26.080
And I'd love to get it to the point where


00:44:26.080 --> 00:44:27.980
for a business app, you just use Piccolo Admin.


00:44:27.980 --> 00:44:29.160
You don't even have to build UI.


00:44:29.160 --> 00:44:31.040
You just say, here are my tables.


00:44:31.040 --> 00:44:31.880
- Yeah.


00:44:31.880 --> 00:44:32.700
- And then, yeah.


00:44:32.700 --> 00:44:33.840
- Well, the truth is so often,


00:44:33.840 --> 00:44:35.880
like there's a lot of these little internal apps


00:44:35.880 --> 00:44:38.720
that people build that are just like forms over data.


00:44:38.720 --> 00:44:41.080
I just need to see the details, click on one,


00:44:41.080 --> 00:44:43.280
edit it, create a new one and delete one.


00:44:43.280 --> 00:44:45.480
And like, that's the app I need for this table.


00:44:45.480 --> 00:44:47.080
Could you build that, right?


00:44:47.080 --> 00:44:48.680
- Yeah, for sure.


00:44:48.680 --> 00:44:49.780
- It is a lot of it.


00:44:49.780 --> 00:44:53.640
'Cause I think with the approach I took to Piccolo


00:44:53.640 --> 00:44:55.120
is you have a lot of Python libraries


00:44:55.120 --> 00:44:57.160
and they kind of start from the outside in.


00:44:57.160 --> 00:44:59.480
So they start from the URL layer


00:44:59.480 --> 00:45:01.840
and then the views and like middleware.


00:45:01.840 --> 00:45:03.880
And then over time they then add the data layer


00:45:03.880 --> 00:45:05.000
and the security.


00:45:05.000 --> 00:45:08.360
But then with Piccolo it's kind of from the inside out,


00:45:08.360 --> 00:45:09.920
like I started from the data layer


00:45:09.920 --> 00:45:11.720
and then have the admin and some middleware.


00:45:11.720 --> 00:45:14.200
So it's quite a nice companion to a Veraski app.


00:45:14.200 --> 00:45:16.280
So just kind of pick the framework you like


00:45:16.280 --> 00:45:18.440
and then Piccolo kind of gives you the data layer


00:45:18.440 --> 00:45:19.920
in the admin, that's kind of.


00:45:19.920 --> 00:45:20.960
- Yeah, yeah, yeah.


00:45:20.960 --> 00:45:22.680
Well, let's talk about the ASCII stuff a little bit


00:45:22.680 --> 00:45:26.120
'cause you did mention that there's some interesting support


00:45:26.120 --> 00:45:31.120
for those things and it's got like to some degree,


00:45:31.120 --> 00:45:36.480
native FastAPI, Flask and even Black Sheep,


00:45:36.480 --> 00:45:38.200
which is an interesting one,


00:45:38.200 --> 00:45:40.440
support for those frameworks, right?


00:45:40.440 --> 00:45:41.880
- Yeah, so I'm a huge fan of ASCII


00:45:41.880 --> 00:45:44.320
'cause I was a Django channels power user


00:45:44.320 --> 00:45:49.320
and Andrew Godwin created ASCII out of Django channels.


00:45:49.320 --> 00:45:53.920
And it's really like a beautiful thing.


00:45:53.920 --> 00:45:57.680
So Starlette was the one that really built the foundation.


00:45:57.680 --> 00:46:02.240
So this is an async library,


00:46:02.240 --> 00:46:03.560
but also kind of like a framework.


00:46:03.560 --> 00:46:04.880
Like you can build an app with Starlet


00:46:04.880 --> 00:46:07.160
or you can use it to build up frameworks.


00:46:07.160 --> 00:46:11.000
But what's amazing about ASCII is like every component


00:46:11.000 --> 00:46:13.520
in an ASCII framework is ASCII.


00:46:13.520 --> 00:46:16.720
So ASCII is basically the spec where it's a function


00:46:16.720 --> 00:46:20.180
that accepts a scope, a send and a receive.


00:46:20.180 --> 00:46:23.080
And then if you look at the internals of Starlet,


00:46:23.080 --> 00:46:25.280
everything's ASCII, like the middleware's ASCII,


00:46:25.280 --> 00:46:27.240
the endpoints are ASCII, like the whole thing.


00:46:27.240 --> 00:46:29.140
And it's like super composable.


00:46:29.140 --> 00:46:32.320
So you can say, I've got an ASCII app


00:46:32.320 --> 00:46:35.280
and you can mount other ASCII apps within it.


00:46:35.280 --> 00:46:39.960
So this is what I love about ASCII as a spec.


00:46:39.960 --> 00:46:42.720
So you can say, take a FastAPI app or a Starlette app


00:46:42.720 --> 00:46:45.860
and include Piccolo admin, same with black sheep.


00:46:45.860 --> 00:46:52.160
- You could say slash catalog is actually handled


00:46:52.160 --> 00:46:54.200
by this other app written in FastAPI


00:46:54.200 --> 00:46:55.880
where the main thing is written in flask


00:46:55.880 --> 00:46:56.720
or something like that.


00:46:56.720 --> 00:46:58.880
And you just kind of click them together in that cool way.


00:46:58.880 --> 00:47:01.160
Maybe core, it would have to be the one, but still.


00:47:01.160 --> 00:47:03.720
- Yeah, and I really loved that as it's quite exciting


00:47:03.720 --> 00:47:05.000
that you could kind of build an app


00:47:05.000 --> 00:47:06.920
with multiple frameworks and be like, well,


00:47:06.920 --> 00:47:09.240
this part of the app will be better served by FastAPI,


00:47:09.240 --> 00:47:10.600
but this bit, I just need style,


00:47:10.600 --> 00:47:14.440
to I want black sheep or whichever ASCII framework


00:47:14.440 --> 00:47:16.400
people can dream up.


00:47:16.400 --> 00:47:19.480
So I think it's really exciting for the Python community,


00:47:19.480 --> 00:47:20.760
the ASCII spec.


00:47:20.760 --> 00:47:23.520
- Yeah, and we did talk a little bit about the challenges


00:47:23.520 --> 00:47:27.120
and the cascading effect of async and await.


00:47:27.120 --> 00:47:29.440
But if you're already running a framework


00:47:29.440 --> 00:47:31.560
that has async view methods,


00:47:31.560 --> 00:47:32.780
there's just nothing to it, right?


00:47:32.780 --> 00:47:34.620
You just write your code and you just await the bits


00:47:34.620 --> 00:47:36.960
you gotta await in the view method


00:47:36.960 --> 00:47:39.600
and it just, the server and the framework


00:47:39.600 --> 00:47:42.340
handle the vent loops and all that business.


00:47:42.340 --> 00:47:45.900
- Yeah, I think as well, what kind of happened


00:47:45.900 --> 00:47:49.460
is asyncIO came out and it doesn't directly affect speed.


00:47:49.460 --> 00:47:50.740
It's more about throughput,


00:47:50.740 --> 00:47:53.180
but it's like the Python community took it as a challenge


00:47:53.180 --> 00:47:55.180
to build faster frameworks.


00:47:55.180 --> 00:47:59.980
And so there's a lot of them have really quite fast


00:47:59.980 --> 00:48:04.860
internals and they do feel quite cutting edge.


00:48:04.860 --> 00:48:06.780
- Yeah, like UV loop and stuff like that.


00:48:06.780 --> 00:48:07.780
They're like, how can we do this,


00:48:07.780 --> 00:48:11.060
but have the minimal overhead of adding this.


00:48:11.060 --> 00:48:12.340
I mean, people do talk about,


00:48:12.340 --> 00:48:14.500
okay, async and await won't make your code go faster.


00:48:14.500 --> 00:48:16.340
Well, it won't make CPU code go faster,


00:48:16.340 --> 00:48:17.660
but so often what we're doing,


00:48:17.660 --> 00:48:19.860
especially in web apps is waiting.


00:48:19.860 --> 00:48:22.140
I wanna wait on a database and then wait on the network,


00:48:22.140 --> 00:48:23.660
and then I wanna wait on the database again,


00:48:23.660 --> 00:48:25.340
and then I'm gonna wait on an API,


00:48:25.340 --> 00:48:27.980
and then I'm gonna send back three lines of JSON, right?


00:48:27.980 --> 00:48:32.020
Like 99.9% of that is just waiting on something else.


00:48:32.020 --> 00:48:33.380
And when you're using async and await,


00:48:33.380 --> 00:48:35.460
like you can just do other things


00:48:35.460 --> 00:48:37.580
while you're doing that 99% of waiting.


00:48:37.580 --> 00:48:40.200
- Yeah, so usually if you do a database query,


00:48:40.200 --> 00:48:41.980
it takes a few milliseconds.


00:48:41.980 --> 00:48:44.220
But then if you use the time it module in Python


00:48:44.220 --> 00:48:46.220
and you see how long basic operations take,


00:48:46.220 --> 00:48:48.180
they're more like microseconds.


00:48:48.180 --> 00:48:50.180
So there's like orders of magnitude difference


00:48:50.180 --> 00:48:52.820
in how long a database query takes to basic Python stuff.


00:48:52.820 --> 00:48:55.180
But this is why having stuff like UV loops


00:48:55.180 --> 00:48:57.260
are really important because if you had a really slow


00:48:57.260 --> 00:49:00.140
event loop, it kind of wouldn't make much difference


00:49:00.140 --> 00:49:01.600
because the event loops fast as well.


00:49:01.600 --> 00:49:06.600
And like a lot of the projects I did in the past,


00:49:06.860 --> 00:49:09.400
So Fruitport's really important because some apps,


00:49:09.400 --> 00:49:10.480
you won't have a lot of traffic


00:49:10.480 --> 00:49:13.520
and then all of a sudden you'll get a thousand users.


00:49:13.520 --> 00:49:15.700
So I was doing like live events


00:49:15.700 --> 00:49:17.600
and you'd get a thousand people at once.


00:49:17.600 --> 00:49:18.480
And in that situation,


00:49:18.480 --> 00:49:20.720
Fruitport is incredibly important.


00:49:20.720 --> 00:49:22.300
- Right.


00:49:22.300 --> 00:49:25.620
I mean, look at how the whole healthcare rollout


00:49:25.620 --> 00:49:27.840
in 2008 went, right?


00:49:27.840 --> 00:49:28.760
I just can't help but think


00:49:28.760 --> 00:49:31.220
there must've been more awaits available


00:49:31.220 --> 00:49:34.240
to those frameworks and those web apps


00:49:34.240 --> 00:49:36.360
'cause they just kept crashing and stuff was timing out


00:49:36.360 --> 00:49:38.480
And I'm sure it's just like, well,


00:49:38.480 --> 00:49:42.000
we're just gonna wait on this other slow government API


00:49:42.000 --> 00:49:43.200
and we're gonna do that for a lot of people


00:49:43.200 --> 00:49:44.680
and it's just gonna overwhelm it, right?


00:49:44.680 --> 00:49:46.800
It's just, it's crazy.


00:49:46.800 --> 00:49:48.920
- It just feels natural because like in the web server world


00:49:48.920 --> 00:49:51.480
you have Apache and a lot of people move to Nginx


00:49:51.480 --> 00:49:52.640
'cause that's very similar.


00:49:52.640 --> 00:49:53.760
It's like event loop driven


00:49:53.760 --> 00:49:57.360
and we've kind of seen how beneficial Nginx was.


00:49:57.360 --> 00:50:00.360
So it just makes perfect sense to build your backend


00:50:00.360 --> 00:50:01.680
in the same way.


00:50:01.680 --> 00:50:03.800
- Yeah, absolutely, absolutely.


00:50:03.800 --> 00:50:04.820
All right, a couple more things.


00:50:04.820 --> 00:50:07.600
we got some time to talk about over here,


00:50:07.600 --> 00:50:10.680
you've got a Django comparison page,


00:50:10.680 --> 00:50:12.760
which I guess also could be slightly


00:50:12.760 --> 00:50:14.080
a Mongo engine comparison page,


00:50:14.080 --> 00:50:16.120
'cause like I said, they're basically the same thing


00:50:16.120 --> 00:50:17.120
without the nesting.


00:50:17.120 --> 00:50:22.040
So if somebody's familiar with Django


00:50:22.040 --> 00:50:24.140
and they're like, I would like to consider using this


00:50:24.140 --> 00:50:26.880
for my framework or for part of my code or whatever,


00:50:26.880 --> 00:50:28.840
just like wanna use it,


00:50:28.840 --> 00:50:30.800
but they already know how to do stuff in Django,


00:50:30.800 --> 00:50:33.080
you have like, well, here's how you would create an object


00:50:33.080 --> 00:50:35.020
And save it in the different frameworks.


00:50:35.020 --> 00:50:37.140
Here's how you would update an object


00:50:37.140 --> 00:50:39.840
and make changes and so on.


00:50:39.840 --> 00:50:41.920
And you can just go through one at a time


00:50:41.920 --> 00:50:44.660
and just sort of compare the different pieces, right?


00:50:44.660 --> 00:50:47.060
- Yeah, so it's quite heavily inspired by Django,


00:50:47.060 --> 00:50:51.540
but then I think Django and its ORM, it's more Pythonic.


00:50:51.540 --> 00:50:54.960
So rather than using where, it uses filter.


00:50:54.960 --> 00:50:55.860
But then with Piccolo,


00:50:55.860 --> 00:50:58.460
it's meant to be very, very close to SQL.


00:50:58.460 --> 00:51:00.580
'Cause the theory is, if you know SQL,


00:51:00.580 --> 00:51:02.060
it'll be super easy to learn.


00:51:02.060 --> 00:51:04.240
And when you do need to drop down to a SQL query,


00:51:04.240 --> 00:51:06.180
there's no like mismatch.


00:51:06.180 --> 00:51:08.960
You just like, well, I'm always sort of working


00:51:08.960 --> 00:51:10.200
in a SQL mindset.


00:51:10.200 --> 00:51:13.560
But there are a lot of similarities with Django still.


00:51:13.560 --> 00:51:17.960
Like I think people could pick it up quite quickly.


00:51:17.960 --> 00:51:19.080
- Yeah, I agree.


00:51:19.080 --> 00:51:21.000
Like instead of object that values list,


00:51:21.000 --> 00:51:23.080
you have a select projection


00:51:23.080 --> 00:51:25.240
or instead of filter you have a where,


00:51:25.240 --> 00:51:28.960
but it's honestly not a huge mental jump to make.


00:51:28.960 --> 00:51:32.640
- Yeah, and Piccolo also takes like huge inspiration


00:51:32.640 --> 00:51:35.640
from Django migrations, which I think is kind of like


00:51:35.640 --> 00:51:39.040
the gold standard of migrations in any language.


00:51:39.040 --> 00:51:39.880
So a lot of that's going into that.


00:51:39.880 --> 00:51:41.000
- Yeah, and one of the batteries


00:51:41.000 --> 00:51:42.680
that you were kind of touching on, right,


00:51:42.680 --> 00:51:44.940
is the migrations bit.


00:51:44.940 --> 00:51:47.920
- Yeah, well, it's, migrations are incredibly hard


00:51:47.920 --> 00:51:49.340
to do right.


00:51:49.340 --> 00:51:50.560
I think the Django way is--


00:51:50.560 --> 00:51:51.680
- I can only imagine.


00:51:51.680 --> 00:51:53.960
I don't even wanna try to imagine writing that


00:51:53.960 --> 00:51:55.920
'cause it seems really hard.


00:51:55.920 --> 00:51:58.440
- Yeah, so the way Django does it


00:51:58.440 --> 00:52:00.600
is it looks at your tables


00:52:00.600 --> 00:52:02.680
and then it creates a migration file.


00:52:02.680 --> 00:52:06.160
And then it then adds up the migration files


00:52:06.160 --> 00:52:09.120
to build a picture of what the schema looks like.


00:52:09.120 --> 00:52:12.080
And then that's how it then creates subsequent migrations


00:52:12.080 --> 00:52:12.920
by doing a diff.


00:52:12.920 --> 00:52:13.740
And that's what--


00:52:13.740 --> 00:52:15.320
- I've gotta go from this level to that level.


00:52:15.320 --> 00:52:18.720
So here's the five migrations to basically use in order.


00:52:18.720 --> 00:52:19.560
- Yeah.


00:52:19.560 --> 00:52:22.920
And then you've gotta do code generation as well.


00:52:22.920 --> 00:52:23.760
So like with Piccolo,


00:52:23.760 --> 00:52:25.720
it has to actually create a Python file.


00:52:25.720 --> 00:52:27.040
And that's harder than what it seems,


00:52:27.040 --> 00:52:28.960
I'm actually writing a Python file,


00:52:28.960 --> 00:52:31.800
but if you look at the Piccolo migrations,


00:52:31.800 --> 00:52:32.640
they're actually really,


00:52:32.640 --> 00:52:34.240
they look like quite beautiful Python code.


00:52:34.240 --> 00:52:36.000
And there's a little trick I use internally.


00:52:36.000 --> 00:52:37.440
I use like the black formatter on it


00:52:37.440 --> 00:52:40.920
before I write out the auto-generated code.


00:52:40.920 --> 00:52:41.760
- Oh, that's cool.


00:52:41.760 --> 00:52:45.600
So your generated code is pep8 and all the goodness.


00:52:45.600 --> 00:52:48.120
- Yeah, so if you look at it--


00:52:48.120 --> 00:52:49.920
- That's clever, actually.


00:52:49.920 --> 00:52:51.420
Yeah, that's really clever.


00:52:51.420 --> 00:52:53.520
- Yeah, it's called black.


00:52:53.520 --> 00:52:54.880
- Yeah, I feel like other frameworks,


00:52:54.880 --> 00:52:59.020
like for example, the cookie cutter stuff,


00:52:59.020 --> 00:53:01.620
you know, you're just generating code files like crazy.


00:53:01.620 --> 00:53:03.660
I feel like you could apply that same technique


00:53:03.660 --> 00:53:07.020
is after we inject all the user entered values,


00:53:07.020 --> 00:53:09.620
let's just do a quick format on them and then drop them.


00:53:09.620 --> 00:53:11.380
- Yeah, it makes sense 'cause otherwise


00:53:11.380 --> 00:53:14.140
you'll run your linters on your project


00:53:14.140 --> 00:53:15.620
and they'll fail 'cause your migrations


00:53:15.620 --> 00:53:17.060
aren't correctly formatted.


00:53:17.060 --> 00:53:19.460
- Yeah, yeah, yeah, no, that's cool.


00:53:19.460 --> 00:53:22.060
A quick question from Teddy out in the live stream says,


00:53:22.060 --> 00:53:24.080
I don't use ORMs much in my day to day.


00:53:24.080 --> 00:53:26.960
What are good use cases besides web apps for them


00:53:26.960 --> 00:53:29.160
and where does Piccolo perform better?


00:53:29.160 --> 00:53:30.300
So two questions.


00:53:30.300 --> 00:53:35.480
- So I think that data science is obviously a big bit.


00:53:35.480 --> 00:53:39.560
So another reason for building Piccolo is data science


00:53:39.560 --> 00:53:42.000
is so much on the ascendancy in the Python world.


00:53:42.000 --> 00:53:46.000
And people are just still dealing with databases


00:53:46.000 --> 00:53:46.880
on a day-to-day basis.


00:53:46.880 --> 00:53:49.220
So you can use it in a script if you like.


00:53:49.220 --> 00:53:52.040
Then there's maybe a couple of examples in the docs


00:53:52.040 --> 00:53:57.040
where you might be scraping some data from a website


00:53:57.040 --> 00:53:59.380
and then you just need to stick it into Postgres.


00:53:59.380 --> 00:54:02.340
So that would be another good example for using Piccolo.


00:54:02.340 --> 00:54:04.040
- Yeah, that is a good example.


00:54:04.040 --> 00:54:05.480
- And then where it performs better,


00:54:05.480 --> 00:54:08.300
it's really where you need the async


00:54:08.300 --> 00:54:12.480
or you might still want a web app component,


00:54:12.480 --> 00:54:14.020
even if it's just like a data science script,


00:54:14.020 --> 00:54:17.400
you still might want an admin screen to view that data.


00:54:17.400 --> 00:54:20.260
- Yeah, I think that performs better.


00:54:20.260 --> 00:54:22.460
you could maybe break it into two pieces.


00:54:22.460 --> 00:54:24.180
Where does Piccolo perform better?


00:54:24.180 --> 00:54:26.500
And I think the async stuff is really important there,


00:54:26.500 --> 00:54:27.860
like you say.


00:54:27.860 --> 00:54:30.060
And then where does an ORM perform better?


00:54:30.060 --> 00:54:31.780
You know, when you talk about performance


00:54:31.780 --> 00:54:33.460
and getting stuff done,


00:54:33.460 --> 00:54:35.840
like sometimes it's how fast does the code run,


00:54:35.840 --> 00:54:39.420
but sometimes it's how fast do I get the final thing built?


00:54:39.420 --> 00:54:40.260
Right?


00:54:40.260 --> 00:54:42.180
And I think ORMs,


00:54:42.180 --> 00:54:44.220
even if they're not always the most efficient way,


00:54:44.220 --> 00:54:45.980
sometimes they're really efficient, but not always.


00:54:45.980 --> 00:54:47.860
But, you know, they could help you


00:54:48.740 --> 00:54:52.180
Safely get to the other side, especially if you don't know sql super well


00:54:52.180 --> 00:54:55.460
Yeah, they hold your hand a little bit


00:54:55.460 --> 00:55:00.500
Yeah, I created this while working at a design agency and speed's really important design agency


00:55:00.500 --> 00:55:04.980
not really execution speed in terms of sql queries, but in terms of scaffolding an app and


00:55:04.980 --> 00:55:07.460
being productive


00:55:07.460 --> 00:55:14.180
um, so there's so piccolo has something called piccolo asking you and then if you use that command it'll basically scaffold your web app, so


00:55:14.180 --> 00:55:17.540
It supports fast api starlet and black sheep


00:55:17.540 --> 00:55:24.540
Yeah, that's really cool. So yeah, it's, you just kind of create your starter code and your starter structure from that, right?


00:55:24.540 --> 00:55:44.540
Yeah, so a bit like with Django, where you, you know, you create a project on the command line, but with Piccolo, you get an option of different ASCII frameworks. And over time, I'd like to add, you know, way more because there's this, there's many more exciting ASCII frameworks like Quartz, Sanic, Django itself is actually an ASCII app, so it could support Django.


00:55:44.540 --> 00:55:46.620
- Yeah, Django's coming along there.


00:55:46.620 --> 00:55:48.740
So if people were out there listening


00:55:48.740 --> 00:55:51.500
and their favorite framework wasn't listed


00:55:51.500 --> 00:55:54.220
in one of those three, or wasn't one of those three,


00:55:54.220 --> 00:55:58.340
PRs are accepted, I guess, and they could integrate


00:55:58.340 --> 00:56:02.480
their favorite Sanic or whatever they're after.


00:56:02.480 --> 00:56:03.580
- Yeah, definitely.


00:56:03.580 --> 00:56:05.140
Any feedback's really appreciated.


00:56:05.140 --> 00:56:07.380
So the community's definitely helped me a lot with Piccolo,


00:56:07.380 --> 00:56:10.280
just as much as trying it and giving feedback,


00:56:10.280 --> 00:56:14.200
or obviously pull requests are also really valued.


00:56:14.200 --> 00:56:17.640
Even if you just wanna raise an issue to say,


00:56:17.640 --> 00:56:18.760
"Why the hell did you do this?"


00:56:18.760 --> 00:56:20.000
Like that, you know?


00:56:20.000 --> 00:56:21.760
That's still welcome.


00:56:21.760 --> 00:56:23.600
- Yeah, awesome.


00:56:23.600 --> 00:56:25.720
Cool, well, maybe that's a good place to talk about


00:56:25.720 --> 00:56:27.200
where things are going in the future


00:56:27.200 --> 00:56:29.840
and kind of wrap up our conversation a bit.


00:56:29.840 --> 00:56:32.960
- Yeah, so I feel like I'll never be bored with Piccolo


00:56:32.960 --> 00:56:35.880
because Postgres is continuously developing


00:56:35.880 --> 00:56:36.960
and adding new features.


00:56:36.960 --> 00:56:39.120
And I almost feel like Postgres


00:56:39.120 --> 00:56:40.840
There's almost like an operating system in a way,


00:56:40.840 --> 00:56:43.200
like the amount it does is kind of insane.


00:56:43.200 --> 00:56:47.460
So it even has like a pub sub built in.


00:56:47.460 --> 00:56:48.760
You can do that listen, notify.


00:56:48.760 --> 00:56:49.600
- Oh, wow.


00:56:49.600 --> 00:56:55.300
- But I'd like to do post GIS support.


00:56:55.300 --> 00:56:58.720
Timescale DBs are really up and coming extension as well


00:56:58.720 --> 00:57:00.680
for Postgres, for time series data.


00:57:00.680 --> 00:57:04.000
But then a lot of the stuff I'm excited about


00:57:04.000 --> 00:57:05.480
is like on the admin side.


00:57:05.480 --> 00:57:10.480
So as I mentioned before, Piccolo Admin effectively


00:57:10.480 --> 00:57:13.960
turns Pydantic models into UI.


00:57:13.960 --> 00:57:17.160
So the next thing I want to add is you can basically


00:57:17.160 --> 00:57:19.640
give it arbitrary Pydantic models


00:57:19.640 --> 00:57:22.200
and it will render them as forms in the admin.


00:57:22.200 --> 00:57:25.740
So if you have, for example, you want to send an email,


00:57:25.740 --> 00:57:29.200
you'll just create send email model,


00:57:29.200 --> 00:57:31.700
give it to Piccolo Admin and it'll generate a form.


00:57:31.700 --> 00:57:33.680
So that's stuff I'm really excited about as well,


00:57:33.680 --> 00:57:36.140
just to increase the utility of Piccolo Admin.


00:57:36.140 --> 00:57:39.440
So a backend developer could build a functional app


00:57:39.440 --> 00:57:42.020
for a business without actually writing any code.


00:57:42.020 --> 00:57:43.160
That's kind of the dream,


00:57:43.160 --> 00:57:45.120
is to build a really, really great admin.


00:57:45.120 --> 00:57:47.720
- Yeah, yeah, these self-serve.


00:57:47.720 --> 00:57:50.000
Like once you create the app and hand it off,


00:57:50.000 --> 00:57:54.760
how far can people go before they have to hire


00:57:54.760 --> 00:57:56.960
your design agency again or something like that?


00:57:56.960 --> 00:57:58.440
The more that they can just run with it,


00:57:58.440 --> 00:58:00.000
the better, I suspect.


00:58:00.000 --> 00:58:03.120
- Yeah, it's such a huge benefit from Django,


00:58:03.120 --> 00:58:04.320
like having that admin.


00:58:04.320 --> 00:58:07.640
So I just wanna kind of see what I can do


00:58:07.640 --> 00:58:09.600
with the latest technologies.


00:58:09.600 --> 00:58:13.560
- Yeah, what's the story with Django and Piccolo?


00:58:13.560 --> 00:58:16.400
Is there a reasonable way to click them together?


00:58:16.400 --> 00:58:18.920
Or is it really not so much so far?


00:58:18.920 --> 00:58:19.760
- I think you can.


00:58:19.760 --> 00:58:21.100
I haven't really tried it much,


00:58:21.100 --> 00:58:23.920
but it's very configurable Piccolo.


00:58:23.920 --> 00:58:25.840
So, you know, and none of the names,


00:58:25.840 --> 00:58:27.760
they deliberately don't clash with Django.


00:58:27.760 --> 00:58:30.240
So Django has a settings.py,


00:58:30.240 --> 00:58:33.080
Piccolo has a piccolo_conf.py.


00:58:33.080 --> 00:58:35.660
And then Django has a migrations folder,


00:58:35.660 --> 00:58:38.180
but Piccolo has piccolo_migrations.


00:58:38.180 --> 00:58:39.360
So there's no clash there.


00:58:39.360 --> 00:58:41.380
So in theory, they would work together,


00:58:41.380 --> 00:58:45.380
but there's no like compatibility layer between the admins.


00:58:45.380 --> 00:58:47.480
So you'd have like two separate admins or,


00:58:47.480 --> 00:58:50.860
but I'd like to add support for Django


00:58:50.860 --> 00:58:51.820
as it is an ASCII app,


00:58:51.820 --> 00:58:54.020
and it's the originator of the ASCII standard.


00:58:54.020 --> 00:58:57.340
And I still think Django is one of the great


00:58:57.340 --> 00:58:59.300
kind of masterpieces in the framework world


00:58:59.300 --> 00:59:01.380
that it's lasted so long


00:59:01.380 --> 00:59:04.300
and it's still such a rock solid choice.


00:59:04.300 --> 00:59:07.180
I would like to see what I can do there.


00:59:07.180 --> 00:59:11.180
- Yeah, the closer those could be, I think, right?


00:59:11.180 --> 00:59:12.940
Like this having the Genesis


00:59:12.940 --> 00:59:14.700
and so many similar ideas to Django,


00:59:14.700 --> 00:59:17.060
it seems like they should be somehow working together,


00:59:17.060 --> 00:59:17.880
which is great.


00:59:17.880 --> 00:59:18.820
- Yeah, it'd be cool.


00:59:18.820 --> 00:59:22.060
- All right, well, Dan,


00:59:22.060 --> 00:59:25.060
I think that might be about it for time that we got.


00:59:25.060 --> 00:59:27.740
Let me ask you the final two questions that I always ask.


00:59:27.740 --> 00:59:28.860
If you're gonna write some code,


00:59:28.860 --> 00:59:30.120
you're gonna work on Piccolo,


00:59:30.120 --> 00:59:31.300
what editor to use?


00:59:31.300 --> 00:59:33.960
I think I caught a hint of it earlier, but go ahead.


00:59:33.960 --> 00:59:36.100
- Yeah, VS Code all the way.


00:59:36.100 --> 00:59:38.620
I was a huge Sublime Text and TextMate user,


00:59:38.620 --> 00:59:40.660
and I was like, "I'll try out this VS Code,


00:59:40.660 --> 00:59:41.700
"see what all the hype's about."


00:59:41.700 --> 00:59:44.140
And after five minutes, I was never going back.


00:59:44.140 --> 00:59:46.180
I just think it's such a great gift


00:59:46.180 --> 00:59:48.100
to the world from Microsoft.


00:59:48.100 --> 00:59:48.940
- Yeah. - It just gets better


00:59:48.940 --> 00:59:49.980
and better as well.


00:59:49.980 --> 00:59:53.220
- Yeah. - So yeah, love VS Code.


00:59:53.220 --> 00:59:55.860
- Right on, and then notable PyPI package


00:59:55.860 --> 00:59:57.860
you wanna give a shout out to?


00:59:57.860 --> 00:59:59.100
- So I'm gonna cheat and pick two.


00:59:59.100 --> 01:00:02.140
So Pydantic because I think it's such a nice


01:00:02.140 --> 01:00:04.380
serialization library and I think it could almost


01:00:04.380 --> 01:00:05.780
be in the standard library.


01:00:05.780 --> 01:00:08.300
It feels so Pythonic and natural.


01:00:08.300 --> 01:00:11.780
And then Starlette 'cause I think it's just a beautiful


01:00:11.780 --> 01:00:13.660
like foundation for the ASCII world.


01:00:13.660 --> 01:00:16.340
And I'd really encourage people to look at the code


01:00:16.340 --> 01:00:21.180
to see the power of ASCII, how it is this like


01:00:21.180 --> 01:00:23.780
turtles all the way down, everything's ASCII,


01:00:23.780 --> 01:00:25.220
it is quite interesting.


01:00:25.220 --> 01:00:27.340
So those would be my two shout outs.


01:00:27.340 --> 01:00:28.180
- Yeah, very cool.


01:00:28.180 --> 01:00:29.660
FastAPI is so popular now,


01:00:29.660 --> 01:00:32.500
but FastAPI is kind of like an opinionated view


01:00:32.500 --> 01:00:34.980
on top of Starlette to a large degree.


01:00:34.980 --> 01:00:36.940
- Yeah, FastAPI is great as well.


01:00:36.940 --> 01:00:39.100
- Yeah, well, I mean, it takes the two things you said,


01:00:39.100 --> 01:00:40.940
PyDandec and Starlet, and puts them together


01:00:40.940 --> 01:00:43.420
in like a nice way, which I think is pretty neat.


01:00:43.420 --> 01:00:44.820
- Yeah, it's got great taste.


01:00:44.820 --> 01:00:46.580
- Yeah, for sure.


01:00:46.580 --> 01:00:48.780
- I'd just like to say one thing really quick,


01:00:48.780 --> 01:00:51.260
and just thanks to everyone who's contributed to Piccolo,


01:00:51.260 --> 01:00:52.980
'cause there's been people who've been contributing


01:00:52.980 --> 01:00:54.500
for several years by this point,


01:00:54.500 --> 01:00:56.300
and have put a lot of work in.


01:00:56.300 --> 01:01:00.100
So yeah, just a shout out to anyone in the Piccolo community.


01:01:00.100 --> 01:01:02.340
- Yeah, and final call, actually,


01:01:02.340 --> 01:01:03.680
people are interested in using this.


01:01:03.680 --> 01:01:04.980
It's good to go.


01:01:04.980 --> 01:01:06.700
It's ready for production, web apps,


01:01:06.700 --> 01:01:07.940
and all that good stuff.


01:01:07.940 --> 01:01:09.420
- So I didn't really want to promote it


01:01:09.420 --> 01:01:10.340
before it was ready.


01:01:10.340 --> 01:01:12.260
And I use it in production, I have done for years,


01:01:12.260 --> 01:01:15.380
and I am quite conservative about pushing stuff out there


01:01:15.380 --> 01:01:17.220
unless I think it's solid.


01:01:17.220 --> 01:01:18.980
And it's got hundreds unit tests.


01:01:18.980 --> 01:01:22.180
It's solid.


01:01:22.180 --> 01:01:23.860
I'm not saying there's not some edge case


01:01:23.860 --> 01:01:26.700
I haven't discovered yet in some version of,


01:01:26.700 --> 01:01:27.980
you know, Postgres or something,


01:01:27.980 --> 01:01:31.680
but I use it in production every single day.


01:01:31.680 --> 01:01:33.700
- Yeah.


01:01:33.700 --> 01:01:37.780
Well, congrats on building a really cool Pythonic ORM.


01:01:37.780 --> 01:01:40.340
I really like the way that you put things together


01:01:40.340 --> 01:01:42.260
and yeah, it looks great.


01:01:42.260 --> 01:01:44.900
It's got a lot of nice modern Python features


01:01:44.900 --> 01:01:46.980
and people should definitely check it out.


01:01:46.980 --> 01:01:48.740
- Cool, yeah, thanks a lot, Michael.


01:01:48.740 --> 01:01:50.180
- You bet, see you later.


01:01:50.180 --> 01:01:51.740
- Cheers, bye.


01:01:51.740 --> 01:01:53.500
- Thanks everyone for being on the live stream as well.


01:01:53.500 --> 01:01:57.900
see y'all.

