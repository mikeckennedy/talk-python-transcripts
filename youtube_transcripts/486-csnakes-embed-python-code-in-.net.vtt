WEBVTT

00:00:00.001 --> 00:00:04.160
Hello, Anthony. Hello, Aaron. Welcome to Talk Bythonomy.

00:00:04.160 --> 00:00:05.760
Hi, Michael.

00:00:05.760 --> 00:00:07.440
Hi, thanks for having us.

00:00:07.440 --> 00:00:13.040
It's great to have you here. Anthony, always, always good to have you back on the show.

00:00:13.040 --> 00:00:19.840
You're one of the most popular guests and we'll see where it lands, where this puts you in the

00:00:19.840 --> 00:00:25.040
list, but you're right near the top of the guest page out of all of them. I love having you on the

00:00:25.040 --> 00:00:32.480
show. Thank you. And Aaron, welcome. It's great to have you here. So even though you've been on a

00:00:32.480 --> 00:00:37.200
bunch of times, Anthony, maybe a real quick introduction, just who you are for those who

00:00:37.200 --> 00:00:43.360
have not met you yet. Yeah, I'm Anthony Shaw. I work at Microsoft. I'm the lead Python advocate,

00:00:43.360 --> 00:00:50.160
and I do a whole bunch of open source projects. And I wrote a book called CPython Internals,

00:00:50.160 --> 00:00:55.280
which is how most people know me these days. And yeah, that's me.

00:00:55.280 --> 00:01:02.640
Awesome. Yeah. So we're going to talk about more CPython Internals, or maybe putting Python

00:01:02.640 --> 00:01:07.360
inside of .NET. I don't know. Something's going into the internals of the something else. We'll

00:01:07.360 --> 00:01:13.760
figure out which way that goes. It's a very cool project. Hello, Aaron. Tell people a bit about

00:01:13.760 --> 00:01:20.720
yourself. Sure. Well, I'm definitely the odd one out here. I am someone who has pretty much never

00:01:20.720 --> 00:01:25.920
written Python in my life. I really I now know a bit more about it. Having worked on this project

00:01:25.920 --> 00:01:34.640
with Anthony, but I'm a .NET developer by trade. Been doing that for longer than I'll admit on a recorded

00:01:34.640 --> 00:01:44.080
audio. At least 10 years. Okay. Got it. Yeah. Yes, we'll go with at least 10 years. Yeah, I'm setting

00:01:44.080 --> 00:01:49.600
a good bound, a lower bound for us. That's a good one. Yeah. But I also work at Microsoft. I mean,

00:01:49.600 --> 00:01:59.280
a team adjacent to Anthony's doing advocacy around .NET. And yeah, but otherwise, I also write JavaScript. So

00:02:00.080 --> 00:02:06.400
do everything I can to avoid having to get into the Python space now in my time. And yet here you are.

00:02:06.400 --> 00:02:15.360
And here I am. Yes. Amazing. Yeah. So it's a different world, right? Coming from .NET, that's

00:02:15.360 --> 00:02:22.800
guaranteed static typing, a lot of semicolons, a lot of ceremony around the types. And then Python kind of

00:02:22.800 --> 00:02:29.600
says, hold on now. And whitespace. Python loves its whitespace. But then again,

00:02:29.600 --> 00:02:35.280
like, I have a very soft spot for F#. So I'm not like, I kind of get the white space significance

00:02:35.280 --> 00:02:40.800
aspect of a Python language. But at the same time, I do miss McCurley brackets.

00:02:40.800 --> 00:02:47.200
Yeah. The trick is if you use a good editor, you don't really notice it. If you don't,

00:02:47.200 --> 00:02:54.720
it's pretty bad. Yeah. So use a good editor. I mean, that's all there is to it. Anthony,

00:02:54.720 --> 00:03:04.400
what have you been up to? What's new in your world? I've been up to this project for a few months now.

00:03:04.400 --> 00:03:10.480
Is this primarily what you're focused on? It was for a few months, yeah. I'm trying to get ready for,

00:03:10.480 --> 00:03:14.880
we've got a massive conference, one of our two big conferences of the year coming up in a couple of

00:03:14.880 --> 00:03:20.960
weeks. I'm working hard on demos to try and get ready for that. But... Is that .NET Conf? What is that?

00:03:20.960 --> 00:03:26.960
No, this is for Ignite. It's the partner conference. Oh yeah. Yeah. Ignite is so big.

00:03:26.960 --> 00:03:33.920
I... 15,000 people or something. Yes, exactly. I went to a pre-pandemic and I think it was 30,000 people.

00:03:33.920 --> 00:03:40.400
Oh wow. Yeah. It was in Florida and there was a whole podcast row. So Microsoft had me out as

00:03:40.400 --> 00:03:45.040
one of like 10 podcasts or something. I thought, oh, what is this? I've hardly ever heard of this. I've

00:03:45.040 --> 00:03:50.480
heard of Build and some others and I show up like, this is something else. Where'd all these people

00:03:50.480 --> 00:03:55.120
come from? It's a big conference. It's crazy. So yeah, I'm getting ready for that at the moment. But yeah,

00:03:55.120 --> 00:04:02.400
I've been working on this project for a few months. We kind of kicked it off in May. The idea kind of

00:04:02.400 --> 00:04:09.280
floated around in May at the Build conference, which is Microsoft's developer conference. After talking to

00:04:09.280 --> 00:04:13.920
a lot of different developers and people in Microsoft, we were kind of kicking around the idea of

00:04:14.560 --> 00:04:22.080
if we looked at this again. So like running Python code from .NET, like how would you approach it?

00:04:22.080 --> 00:04:27.760
I kind of had some ideas, put some ideas together and then started working with Aaron

00:04:27.760 --> 00:04:34.640
on a really early prototype just to see like if it was even possible. And then we kind of

00:04:34.640 --> 00:04:42.960
got something working, chucked it in the bin, pretty much started again and then redesigned it. And then

00:04:43.760 --> 00:04:46.400
yeah, we've been sort of fiddling with it ever since.

00:04:46.400 --> 00:04:50.160
Yeah. So go ahead, Aaron.

00:04:50.160 --> 00:04:56.720
I was going to say that from my perspective, I said before, I'm not a Python person, but as someone

00:04:56.720 --> 00:05:05.760
in the .NET ecosystem, looking at the breadth of libraries that exist for Python, like there's a lot

00:05:05.760 --> 00:05:11.680
of things that I would have loved to have used, particularly doing some of the AI stuff that we've been doing

00:05:12.320 --> 00:05:17.840
in projects recently, there's just not as many packages or options in the .NET space. So it's

00:05:17.840 --> 00:05:24.080
it's always been that like, ah, okay, well, if I want to learn this, the tutorial is in Python or

00:05:24.080 --> 00:05:30.880
the package it recommends using is in Python. So it was always kind of like, how do we bridge that gap?

00:05:30.880 --> 00:05:39.440
And that was kind of one of the early thinkings of just, you know, that's a clear problem space, right?

00:05:39.440 --> 00:05:44.240
Like a lot of people are learning that, but then going into industry and maybe Python isn't the language

00:05:44.240 --> 00:05:49.200
that the organization they're working with is using. So how do we still have that

00:05:51.680 --> 00:05:55.680
a fundamental knowledge that they've gained or the like the tooling they want to use available to us?

00:05:55.680 --> 00:06:03.440
Well, just think about me. I'm sure you have thought about how much of an explosion and possibility it

00:06:03.440 --> 00:06:12.080
is. If you can say, and by the way, there's almost 600,000 other libraries, including the biggest community

00:06:12.080 --> 00:06:20.880
of AI based resources that are now, as far as you're concerned, native to .NET, right?

00:06:20.880 --> 00:06:22.640
Yeah. Yeah.

00:06:22.640 --> 00:06:24.960
But from the way you consume it, not the way it runs is what I mean.

00:06:24.960 --> 00:06:32.560
Exactly. Yeah. Like you mentioned there, there's nearly 600,000 Python packages. And you add that to

00:06:32.560 --> 00:06:40.000
there's like 400,000 packages on NuGet for .NET. Like you got quite literally a million possibilities.

00:06:40.800 --> 00:06:46.160
Yeah. Yeah. It's amazing. And just for people listening, primarily Python audience,

00:06:46.160 --> 00:06:49.440
NuGet is .NET's equivalent of our PyPI.

00:06:49.440 --> 00:06:50.560
Yep.

00:06:50.560 --> 00:06:52.960
Yep. Yep.

00:06:52.960 --> 00:06:58.880
Okay. So Anthony, you had this idea. Somebody said, "Hey, how would you go about doing this?"

00:06:58.880 --> 00:07:01.600
And then you were sucked in?

00:07:01.600 --> 00:07:10.480
Yeah. It was actually one of the sort of lead designers on .NET. Asked me at Build. They said,

00:07:10.480 --> 00:07:17.120
"Oh, we've been looking at how you might integrate Python into .NET for a while. Like,

00:07:17.120 --> 00:07:22.800
if you were to approach it, how would you do it?" And I kind of went through all the projects that have

00:07:22.800 --> 00:07:27.520
tried this in the past, or there are different ways of doing it and pros and cons of each.

00:07:28.080 --> 00:07:33.440
And kind of the pros and cons of a really low level integration on a high level one.

00:07:33.440 --> 00:07:40.240
So like a high level one would be stick a FastAPI on top of your Python app and just call it via

00:07:40.240 --> 00:07:40.800
HTTP rest.

00:07:40.800 --> 00:07:46.080
Right. Somehow auto-generate some rest endpoints and then make those.

00:07:46.080 --> 00:07:52.160
Yeah. And you could use it like an open API spec on top of it and auto-generate a client and stuff

00:07:52.160 --> 00:07:58.400
like that. That's like the high level option. And then like the lowest level option is like,

00:07:58.400 --> 00:08:04.320
you know, you could get into the bytecode level, which I've explored years ago with Pigeon.

00:08:04.720 --> 00:08:09.120
And yeah, that's a very deep, dark tunnel.

00:08:09.120 --> 00:08:11.920
Yeah, but...

00:08:11.920 --> 00:08:15.280
It's full of terrible edge cases and corners and sharp edges.

00:08:15.280 --> 00:08:23.040
Yeah. And one of the challenges there is that the, like, Python's implementation is changing so

00:08:23.040 --> 00:08:31.280
rapidly right now. Like, but just in Python 3.13 and looking at 3.14 now and like all the changes

00:08:31.280 --> 00:08:36.960
and stuff in there, like it's just continuously changing. So it needs to be a happy medium and

00:08:36.960 --> 00:08:40.080
in terms of how we blend the two together.

00:08:40.080 --> 00:08:47.280
So there has to be some level of disconnectedness a little bit, right? So that Python can do its,

00:08:47.280 --> 00:08:50.320
have its changes without you constantly chasing it, right?

00:08:50.320 --> 00:08:57.680
Yeah, exactly. So yeah, kind of what we kind of came up with was we would do the integration at

00:08:57.680 --> 00:09:05.520
the C level using Python C API. There's a way of consuming Python through sort of like an embedded

00:09:05.520 --> 00:09:12.320
mode. Not many projects do this, but it is definitely possible. So you can spin up a Python interpreter

00:09:12.320 --> 00:09:16.320
inside another process, which in our case is the internet process.

00:09:16.320 --> 00:09:23.360
Yeah. And I think Blender does that. I'm pretty sure that there's a bunch in the film and movie

00:09:23.360 --> 00:09:28.720
industry that do that for their automation pipelines. I don't think it's that great.

00:09:28.720 --> 00:09:37.920
You know, I talked to some of the people from the movie and video space and they,

00:09:37.920 --> 00:09:42.960
most of them are still running on Python too, because when they wrote the implementation to

00:09:42.960 --> 00:09:48.960
integrate the thing, integrate CPython, they're like, well, it's done. And like you kind of said,

00:09:48.960 --> 00:09:52.240
Python moved on and they're like, well, that's a lot of work. And then we got to,

00:09:52.240 --> 00:09:54.720
we'll just leave it on Python too. And that's not, that's not great.

00:09:54.720 --> 00:10:00.480
Yeah, exactly. So we looked at this and said, we want to be, we want to support the newest version

00:10:00.480 --> 00:10:08.400
of Python. We want to support the sort of practically old version, which I think you settled around 3.8

00:10:08.400 --> 00:10:14.640
was like as old as I was willing to go. And I think we maybe push that forward to 3.9 because

00:10:14.640 --> 00:10:22.640
there were some specific features we need. And on the .net side, again, there's a lot of changes

00:10:22.640 --> 00:10:28.640
happening in .net. Sharon, maybe you can share a bit more, but like, you know, there's going through

00:10:28.640 --> 00:10:34.960
just as many changes. So we've got like two moving, constantly moving platforms and we want to make

00:10:34.960 --> 00:10:39.600
an integration between the two of them. So let's think about like, how can we do this in a way which

00:10:39.600 --> 00:10:45.520
is actually maintainable? And we can make it, you know, we can test it and we can make it stable as well.

00:10:45.520 --> 00:10:53.520
Yeah. One thing maybe you could speak to as part of this, people might know .net as this Windows

00:10:53.520 --> 00:11:01.120
programming library that you use Visual Studio with, right? But it's, it's changed a lot since then.

00:11:01.120 --> 00:11:05.920
There's, there's .net core, there's open source, it runs on Linux. There's, there's a lot of different

00:11:05.920 --> 00:11:07.520
things that have been changed about it, right?

00:11:07.520 --> 00:11:13.360
Yeah. And it's a fairly common misconception that we've got is that, that people equate .net with

00:11:13.360 --> 00:11:17.520
Windows. And like, historically, that's, that's true. Like that's, that's where I got started is

00:11:17.520 --> 00:11:23.760
developing on Windows. And I, I'll be honest, I'm still a Windows developer. It's what, what my

00:11:23.760 --> 00:11:30.400
primary OS has been. I've, I've flirted with macOS and Linux over the years, but Windows is just where

00:11:30.400 --> 00:11:38.080
I'm more comfortable with. But I think it's a, I think it's been a bit over a decade now, since the,

00:11:38.080 --> 00:11:44.880
they essentially relaunched .net. It was originally called .net core. So, so now we kind of have these

00:11:44.880 --> 00:11:51.280
two streams concurrently, you've got .net framework, which is the one that is what we traditionally thought

00:11:51.280 --> 00:11:57.840
of as .net. It ships kind of like with Windows and stuff like that. So it's, it's very much designed

00:11:57.840 --> 00:12:05.280
around that longer tail support life cycle and, and, and whatnot. It is fairly stable, but also

00:12:05.280 --> 00:12:12.480
getting minimalistic investment just because it has that kind of need to be stable and consistent

00:12:12.480 --> 00:12:23.840
year in, year out. So then we have .net core or now, now we just kind of refer to it as .net. Just

00:12:23.840 --> 00:12:30.320
naming things as hard. Let's, let's be honest. But so we, we have .net and every year a new release

00:12:30.320 --> 00:12:38.160
comes out and this is like a, like a major framework, like a major revision to the runtime. So .net 9 is

00:12:38.160 --> 00:12:44.320
actually coming out next week, at least at the time of recording, it's next week. And this is considered

00:12:44.320 --> 00:12:50.400
a, like a short-term support life cycle. So if you're familiar with support life cycles of, a lot of run

00:12:50.400 --> 00:12:55.840
run times out there now, so like node popularized this quite a lot now. Python is starting to adopt a

00:12:55.840 --> 00:13:01.520
bit more that kind of, you had this yearly rolling life cycle and, and you'll have long-term supports and

00:13:01.520 --> 00:13:07.760
short-term support. So the long-term is every even number. So .net 8 being the most recent long-term

00:13:07.760 --> 00:13:14.400
support. .net 6 was the previous one, which is actually going out of support next week, and the time of

00:13:14.400 --> 00:13:20.000
recording, and then we'll, so we'll have .net 8 and .net 9 and to Anthony's point, then you've got

00:13:20.000 --> 00:13:27.120
two versions of .net that we're trying to target, to bring to the future. So we originally,

00:13:27.120 --> 00:13:34.480
a very early on, .net support because it was just going to result in too many variants in terms of,

00:13:34.960 --> 00:13:47.680
the future. So we're going to start looking at other things. So .net 9, we've got to make

00:13:47.680 --> 00:13:54.880
available. And yeah, so hopefully, those of you listening can understand something like

00:13:54.880 --> 00:14:03.200
digitalization in what was, where we land from versioning standpoints. but also, you know,

00:14:03.200 --> 00:14:07.680
being realistic of where people are and developing their applications. We couldn't just target

00:14:07.680 --> 00:14:14.160
Python 3.13 and .net 9 as the only support of versions because to be honest, that's not where

00:14:14.160 --> 00:14:19.520
most packages are. That's not where most projects are going to be. So we have to make, you know, some,

00:14:19.520 --> 00:14:24.560
some calls there. Yeah. You do have to have a little bit of, a little bit of slack in there.

00:14:25.120 --> 00:14:30.240
Even for me and some of my web apps and stuff, I had to wait a few weeks to upgrade to 3.13 because

00:14:30.240 --> 00:14:37.920
some dependency of a dependency had something that had been removed, you know, been deprecated for a

00:14:37.920 --> 00:14:41.680
while and was removed and it didn't work. Well, try that again in a few weeks and see how it works.

00:14:41.680 --> 00:14:49.120
And eventually they, they caught up, but yeah, it's definitely a challenge. All right. Anthony,

00:14:49.120 --> 00:14:55.520
when we opened this, you mentioned there had been other attempts, other ways. The one that comes to

00:14:55.520 --> 00:15:04.480
mind for me is Iron Python, right? There's Iron Python is a, a CLR implementation of Python. And that's

00:15:04.480 --> 00:15:11.040
a pretty big difference right there than what you're trying to. So maybe contrast it with some of the

00:15:11.040 --> 00:15:17.120
things that people have done previously. Yeah. So probably three projects, I think,

00:15:17.120 --> 00:15:23.920
that have been done previously that kind of sit in the same space, but they have different goals.

00:15:24.560 --> 00:15:34.240
So I mean, the main goal for our project is that there are loads of .NET developers that have existing applications.

00:15:34.240 --> 00:15:40.640
they are typically quite, like sits in the enterprise space, a lot of it. So they're like

00:15:40.640 --> 00:15:46.480
quite big, big applications. They've got teams working on them and there's a technology in Python

00:15:46.480 --> 00:15:52.960
they want to use. And that technology is often a package or a library or an example, especially in

00:15:52.960 --> 00:15:59.040
like data science now. And a lot of the ML and AI libraries that are floating around. So a lot of the

00:15:59.840 --> 00:16:05.360
idea for this and the demand from developers was from, you know, are we, we want to use these

00:16:05.360 --> 00:16:13.600
libraries or we want to use this particular package in Python. And like, how do we import that into our

00:16:13.600 --> 00:16:17.760
.NET application? So like, that's kind of the angle that we've come at this from, which is like,

00:16:17.760 --> 00:16:25.200
how can we make the best of both worlds? And like, you've got a bit, you're like a fast, mature

00:16:25.200 --> 00:16:29.680
enterprise application in .NET. And then it's like a piece of technology that's in Python that you want to

00:16:29.680 --> 00:16:38.000
use. Iron Python is an implementation of Python written in .NET that was done quite a while ago,

00:16:38.000 --> 00:16:47.680
I think. And yeah, like older versions of .NET, older versions of Python. And it's kind of similar to

00:16:47.680 --> 00:16:51.680
Jython as well. Like I think, I think put it in the same bucket as Jython, which is,

00:16:51.680 --> 00:16:59.120
which like, and at that time, a lot of people were making different implementations of Python, the

00:16:59.120 --> 00:17:06.000
language in other frameworks. And so yes, you can write Python syntax and run it in the CLR,

00:17:06.000 --> 00:17:10.320
but you couldn't do something like import NumPy. And that's the difference is that

00:17:10.320 --> 00:17:18.160
most packages in the ecosystem these days are designed and tested for CPython. And this is,

00:17:19.440 --> 00:17:26.400
that at least they're tested for PyPy. But all the other implementations are pretty much a no. Like,

00:17:26.400 --> 00:17:32.320
like Pandas, NumPy, scikit-learn, like all the data science ML tools.

00:17:32.320 --> 00:17:35.360
Especially the C interop type of stuff.

00:17:35.360 --> 00:17:41.360
Yeah. And I've sort of written about this in the past, how, you know, Python's,

00:17:41.360 --> 00:17:46.080
one of the solutions to Python's performance problem is that you implement extension modules in C,

00:17:46.080 --> 00:17:53.200
which is a great solution. Or you use Siphon, which is the same kind of thing, which is a great

00:17:53.200 --> 00:17:58.640
solution. But it just means that the ecosystem is more and more tied to CPython as the interpreter of

00:17:58.640 --> 00:18:06.560
choice. So what I didn't want to do is write a whole new interpreter. Like that goes back to the

00:18:06.560 --> 00:18:12.240
compatibility problem and the maintainability issue. Like by the time we published it, it would be out

00:18:12.240 --> 00:18:16.240
of date. And we'd just be opening up for a whole lot of work.

00:18:16.240 --> 00:18:22.400
Well, it's not even about, it's not even a matter of whether you can do it and you can keep up with

00:18:22.400 --> 00:18:29.440
the language. As we talked about, you know, as Aaron mentioned, right? There's a million libraries

00:18:29.440 --> 00:18:32.960
you can use. But if you did this, you wouldn't be able to.

00:18:32.960 --> 00:18:42.000
Yeah, exactly. So that's, yeah, iron python is one. Pigeon, we've covered in a past episode.

00:18:42.000 --> 00:18:48.880
Pigeon is a P-Y-G.

00:18:48.880 --> 00:18:49.600
There we go.

00:18:50.880 --> 00:18:55.360
Not that one. It's a weird spelling. P-Y-G-I-O-N.

00:18:55.360 --> 00:18:58.640
No, that's right. I remember now. P-Y-G-I-O-N.

00:18:58.640 --> 00:19:09.040
Yeah. This is a JIT for CPython that happens to use the .NET Core JIT engine

00:19:09.040 --> 00:19:18.000
because that was one of the most pluggable JITs at the time. There are other JITs available. It could

00:19:18.000 --> 00:19:24.560
have been written in ASM JIT. It could have been written in LLVM JIT. But Dino, Dino who actually

00:19:24.560 --> 00:19:29.520
worked on Iron Python, so like he knows this space really well. And Brett Cannon worked on Pigeon

00:19:29.520 --> 00:19:37.760
originally. And then I rewrote it like a few years later. That's a different problem. That doesn't help you

00:19:37.760 --> 00:19:44.320
integrate .NET and Python together. It just happens to use components from .NET to implement a JIT.

00:19:44.320 --> 00:19:47.200
And that project is effectively dead.

00:19:49.440 --> 00:19:55.760
So, some of the benefits of it have been rolled into CPython in versions 3.10 and 3.11.

00:19:55.760 --> 00:20:01.280
Like the things that made it faster. Most of those were sort of picked up anyway.

00:20:01.280 --> 00:20:08.640
And then the third one is Python.NET, which is probably the closest to the project that we've started.

00:20:10.000 --> 00:20:18.880
This one has been around for a while. It's a similar thing, but they mostly focused on the

00:20:18.880 --> 00:20:25.920
integration and the other way around. So, like how you call .NET libraries and things from Python.

00:20:25.920 --> 00:20:30.960
You can call Python from .NET. So, we bring a lot of...

00:20:30.960 --> 00:20:32.800
Yeah, a lot of the focus is actually the other way around.

00:20:32.800 --> 00:20:37.840
Got it. So, if there was a popular .NET library that you wanted to use in your Python app,

00:20:37.840 --> 00:20:40.880
you might Python.NET your way to that.

00:20:40.880 --> 00:20:49.440
Yeah. And this project has been around for a while. And so, the API is pretty stable.

00:20:49.440 --> 00:20:54.960
We originally looked at this one actually as a potential solution, but found a number of things that

00:20:54.960 --> 00:21:00.000
they'd kind of tied themselves to in the design, which are going to go away in .NET 9.

00:21:00.000 --> 00:21:08.720
So, it wasn't really an option for us. And also, like a lot of the way the C API was used was

00:21:08.720 --> 00:21:13.040
different to how we wanted to do it. So, yeah, that's kind of the alternatives.

00:21:13.040 --> 00:21:20.880
Yeah. And so, you ended up writing your own because just none of these really matched, right? The

00:21:21.440 --> 00:21:27.680
Iron Python was just never going to keep up. And it didn't have this package support

00:21:27.680 --> 00:21:33.200
for data science mostly. And then the other one was the other way around. And yeah. So,

00:21:33.200 --> 00:21:41.120
well, I guess a good thing to think about is, well, why did you think you could do that? Like a lot of

00:21:41.120 --> 00:21:46.560
people, a lot of smart people put a lot of time into this. Why did you think, "Oh, this is going to be,

00:21:46.560 --> 00:21:50.720
this is going to work well." Do you have a fresh take on it or what were you thinking?

00:21:52.800 --> 00:21:59.040
I really wanted to use some of the modern benefits of both Python and .NET to do this,

00:21:59.040 --> 00:22:05.440
to design it. And one of the biggest changes in, actually, as we've been implementing this,

00:22:05.440 --> 00:22:14.640
we're learning 80% of the challenges are related to typing. And Aaron's smiling because he's agreeing with

00:22:14.640 --> 00:22:22.880
me. Like, integrating two different ecosystems together, like this, is about calling functions,

00:22:22.880 --> 00:22:28.160
methods, whatever. But calling things is about calling them with arguments, really. And it's

00:22:28.160 --> 00:22:32.560
passing data backwards and forwards, marshalling information, and getting things backwards and forwards

00:22:32.560 --> 00:22:39.600
between different types. Like that's, if you integrated, I don't know, some function that you wrote in

00:22:39.600 --> 00:22:44.080
Python into .NET, you're going to be calling it with something. Like you're going to be sending

00:22:44.080 --> 00:22:51.280
it some data and expecting some data back. Now in Python, there are types, you know, that it is

00:22:51.280 --> 00:22:57.840
dynamically typed, but the types do exist. Right. Even if you don't put it in your function signature,

00:22:57.840 --> 00:23:02.000
there's still instant strings and stuff being sent all over the place behind the scenes. Yeah.

00:23:02.000 --> 00:23:08.960
Yeah, exactly. And when we looked at Python.NET, like, you know, you could call a function in from .NET

00:23:08.960 --> 00:23:13.440
in Python, but you'd have to write a load of code that said like, oh, I think this parameter is

00:23:13.440 --> 00:23:17.680
probably this type. So convert that to this. And then when it comes back, then it's probably this

00:23:17.680 --> 00:23:25.520
one to try that one first. And so we sort of said like, now typing type annotations are more popular

00:23:25.520 --> 00:23:34.720
than Python. And what we wanted to do was basically you give it some Python code and you write like a

00:23:34.720 --> 00:23:40.640
function, which is the one that you want to call and you annotate the function. So you say it takes,

00:23:40.640 --> 00:23:46.400
you know, has these arguments and they are these types and it returns back this type. And then what

00:23:46.400 --> 00:23:53.920
we did is wrote a code generator called a source generator for .NET that would in your project,

00:23:53.920 --> 00:23:58.640
it would look at the Python file that you wanted to embed. It would see what functions are defined,

00:23:58.640 --> 00:24:04.560
what their signatures are and what types they take. And then it would generate a function that can call

00:24:04.560 --> 00:24:13.040
that for you with .NET equivalents. And then it handles the marshaling, like the transfer of the

00:24:13.040 --> 00:24:19.200
types backwards and forwards between .NET and Python. And like that's most of the project is really about

00:24:19.200 --> 00:24:27.360
that particular problem. Right. Okay. So it's leveraging the C API of Python to kind of talk directly to the

00:24:27.360 --> 00:24:37.920
runtime? Yep. Yep. So you can write a function in Python, you know, that takes a string, a list and a tuple

00:24:37.920 --> 00:24:45.520
and returns back a dictionary. Like it's a fairly common thing to do. And you would give it type annotations

00:24:45.520 --> 00:24:53.600
in Python and you drop that Python file into your .NET project. And, you know, you run build again and you

00:24:53.600 --> 00:25:00.000
would see a type in .NET with the same name, with a function that is the one you just defined and with

00:25:00.000 --> 00:25:05.040
arguments which are .NET equivalents to that. And you just call the function and it just runs in Python.

00:25:05.040 --> 00:25:10.880
How complicated can this data exchange be? Like, can I come up for my own types and exchange them? Or do

00:25:10.880 --> 00:25:16.640
they have to be six or seven core types? I think the data exchange is actually one of the really

00:25:16.640 --> 00:25:24.080
tricky bits, right? Here's a, here's a list of a million items. Why don't you copy them all over to

00:25:24.080 --> 00:25:30.960
a .NET type, run it, or revert, copy it over to a Python list, run the thing, and then copy the back to

00:25:30.960 --> 00:25:34.480
a .NET list with one more item in it or something crazy like that, right?

00:25:34.480 --> 00:25:39.600
Yeah. If you jump to the documentation and then in the reference page, there is,

00:25:39.600 --> 00:25:44.560
there's a list of the ones that we support at the moment.

00:25:44.560 --> 00:25:49.680
So if you go on reference, on the docs,

00:25:49.680 --> 00:25:59.120
the code is a list of the core ones that we support. And then anything beyond that. So we do generics,

00:25:59.120 --> 00:26:05.840
for example. So if you say it's a list of strings, we will give you back a read-only list of string in .NET.

00:26:05.840 --> 00:26:12.640
If it's a dictionary and you type the key and the value, we will give you back a .NET key and value. Now,

00:26:13.200 --> 00:26:19.200
in Python, often it could be an any or it could be a union or it could be something complicated.

00:26:19.200 --> 00:26:26.400
So you've got the option to say it could be a dynamically defined type. You know, that's still

00:26:26.400 --> 00:26:31.920
supported. And then at runtime, you can look at the type to see what it is and then convert it into something that you need.

00:26:33.920 --> 00:26:39.520
I see a lot of read-only on the .NET side. And this is the thing receiving the data from Python.

00:26:39.520 --> 00:26:47.280
I'm glad that you picked up on that because that was something that I made a decision when we're doing

00:26:47.280 --> 00:26:56.000
the .NET surface area for this, that anytime we're receiving data back or when we're sending data to,

00:26:56.000 --> 00:27:02.640
is it should be represented as read-only just to indicate that if you're calling a function that's

00:27:02.640 --> 00:27:08.960
been exposed from Python from .NET and it's returning a collection like a dictionary or a list or

00:27:08.960 --> 00:27:15.280
anything like that, it should be returned as read-only just to make it very clear to you as the consumer

00:27:15.280 --> 00:27:19.840
that you don't own this data. Like you weren't the one that created it. There's nothing inside of

00:27:19.840 --> 00:27:26.960
your application technically that created that data that you've then got responsibility for.

00:27:26.960 --> 00:27:31.840
You can then transfer that into some kind of immutable data structure if you do need to mutate it,

00:27:31.840 --> 00:27:39.920
but then you're making a clear code choice to transform that from the original source of the

00:27:39.920 --> 00:27:45.040
data into something that is then immutable with inside of your new runtime space.

00:27:45.040 --> 00:27:51.360
Okay. So if you had an I read-only list of int, you could create a list of int and then you'd have

00:27:51.360 --> 00:27:56.880
to pass that to the constructor or something and it would do a copy sort of thing?

00:27:56.880 --> 00:28:07.200
Yeah. There's some syntax that would be very familiar for .NET developers for creating an array from an

00:28:07.200 --> 00:28:12.800
existing collection of data and then that becomes obviously a more mutable data structure or

00:28:14.080 --> 00:28:20.800
like a list like the read-only list for example that then plugs straight into links so that you can do

00:28:20.800 --> 00:28:29.120
the the query syntax or the expression method syntax to perform operations on those collections of data

00:28:29.120 --> 00:28:34.080
inside of .NET space and kind of once it's being hydrated back out of out of python.

00:28:34.080 --> 00:28:42.240
So I guess you get a lot of these read-only innumerable type of things you could do link on them, L I N Q.

00:28:42.240 --> 00:28:43.200
Yeah.

00:28:43.200 --> 00:28:44.880
Which is that's pretty glorious.

00:28:44.880 --> 00:28:46.000
Yeah. Yeah.

00:28:46.000 --> 00:28:46.480
Yeah.

00:28:46.480 --> 00:28:51.360
I wish we had this in Python. I know we have something kind of like it with list compreemptions, but it's not the same.

00:28:51.360 --> 00:28:58.000
Yeah. One thing that I really wanted to make sure that we were tackling with this and to Anthony's point before of the

00:28:58.000 --> 00:29:07.280
that you've got two very different types of systems that you're working with and structurally the way that you write code in Python is going to look different to the way that you write in .NET.

00:29:07.280 --> 00:29:18.960
So we didn't want to feel like the code gen that we do for you is that we've just made this it's just .NET casing of Python code.

00:29:18.960 --> 00:29:24.000
We wanted to feel like as a .NET developer, I'm working against a .NET interface.

00:29:24.000 --> 00:29:34.400
So when you work with the types and the modules that you expose out to .NET and we do code gen against,

00:29:34.400 --> 00:29:39.680
we then generate you a class behind the scenes that is then we then generate an interface for you.

00:29:39.680 --> 00:29:44.400
And then that's registered into the dependency injection container.

00:29:44.400 --> 00:29:48.240
So you then can just resolve that elsewhere with inside of your application.

00:29:48.240 --> 00:29:58.640
So now as a .NET developer, I am just I'm important I'm getting an interface injected into a class that I'm using elsewhere with inside of my code base.

00:29:58.640 --> 00:30:10.080
So I haven't had to go okay, well, no, I'm calling some kind of like an import or I'm doing some kind of resolve or something that might be unfamiliar to me as a .NET developer.

00:30:10.080 --> 00:30:13.680
This is what I'm doing is just it just feels like I'm writing.

00:30:13.680 --> 00:30:16.000
I shouldn't say necessarily .NET developer.

00:30:16.000 --> 00:30:19.440
I'm running C# and we've optimized this to C#.

00:30:20.400 --> 00:30:25.760
I said earlier on I have soft swap for F# and it kind of works in F#.

00:30:25.760 --> 00:30:34.480
And similarly, if you're a .NET developer, but yeah, we optimize this to the kind of development experience you would expect when you're writing C# code.

00:30:34.480 --> 00:30:39.440
We just so happen to have you, you haven't written this, some of this C# code.

00:30:39.440 --> 00:30:44.720
We've just automatically generated it for you and injected it into a dependency injection container.

00:30:44.720 --> 00:30:45.920
Yeah.

00:30:45.920 --> 00:30:46.400
Amazing.

00:30:46.400 --> 00:30:55.120
So when you when we're talking about exchanging this data, this is CPython in the same process.

00:30:55.120 --> 00:30:55.920
Is that right, Anthony?

00:30:55.920 --> 00:30:56.720
Mm-hmm.

00:30:56.720 --> 00:30:56.960
Yeah.

00:30:56.960 --> 00:30:58.640
How's that work?

00:30:58.640 --> 00:31:00.160
I'm not invited.

00:31:00.160 --> 00:31:00.240
I have.

00:31:00.240 --> 00:31:04.240
Um, so Python's C API.

00:31:04.240 --> 00:31:10.640
Normally, if you call, so CPython is the interpreter that you would use to run your Python code.

00:31:10.640 --> 00:31:14.160
Um, it is implemented in C mostly.

00:31:14.160 --> 00:31:18.640
Um, the standard library modules are written, some of them are in Python, some of them are in C.

00:31:18.640 --> 00:31:21.920
You can write modules for Python in C.

00:31:23.120 --> 00:31:29.280
And the way that you would do things like create numbers and dictionaries and lists is use this API.

00:31:29.280 --> 00:31:30.400
It's a C API.

00:31:30.400 --> 00:31:39.280
And, part of that C API is the ability to spin up a Python interpreter inside another process.

00:31:39.280 --> 00:31:42.960
Um, and that's embedded, embedded Python.

00:31:42.960 --> 00:31:43.360
Okay.

00:31:43.360 --> 00:31:45.840
There's, there's, there's different APIs for doing it.

00:31:45.840 --> 00:31:47.760
There's a lot of different ways of approaching it.

00:31:47.760 --> 00:31:53.040
Um, but really what we do is that when you spin up, .NET and you use,

00:31:53.040 --> 00:31:58.960
you use C snakes, you inject a Python interpreter into the environment.

00:31:58.960 --> 00:32:02.560
Um, it's not like a separate process.

00:32:02.560 --> 00:32:06.800
Like it's not, it hasn't got like a, command line windows running in the background.

00:32:06.800 --> 00:32:09.840
Um, it's, it's embedded into the process.

00:32:09.840 --> 00:32:11.040
It's like loading the library.

00:32:11.040 --> 00:32:13.360
Um, it's running inside the process.

00:32:13.360 --> 00:32:16.720
And then we have full control over everything in CPython.

00:32:16.720 --> 00:32:20.080
So we can, then import modules.

00:32:20.080 --> 00:32:24.640
We can, convert things, types backwards and forwards.

00:32:24.640 --> 00:32:30.160
So we're kind of doing a lot of the work that often gets done either in the C extension module or inside the interpreter.

00:32:30.640 --> 00:32:36.320
So if we want to create a Python number, for example, like an integer from a .NET integer,

00:32:37.280 --> 00:32:38.320
we do that at the C level.

00:32:38.320 --> 00:32:41.120
So we can do that at like a really high performance API.

00:32:41.120 --> 00:32:46.240
Um, if we want to look at the size of dictionaries or the types and stuff like that,

00:32:46.240 --> 00:32:47.280
we do that at the C level.

00:32:47.280 --> 00:32:49.440
So again, it's, it's super high performance.

00:32:49.440 --> 00:32:55.120
Um, and then really importantly, well, the typing stuff is really important.

00:32:55.120 --> 00:33:01.280
I don't know the other major challenge with this is, you know, .NET freely uses threading,

00:33:01.280 --> 00:33:05.360
and thread pools and, and coroutines and stuff like that.

00:33:05.360 --> 00:33:09.200
Python can use threading, but there is a lock.

00:33:09.200 --> 00:33:12.560
So you have to be really, really careful.

00:33:12.560 --> 00:33:17.440
And this is something I don't, didn't see like a novel solution from the other projects that are

00:33:17.440 --> 00:33:20.640
looking at this kind of space, but how they would tackle it.

00:33:21.200 --> 00:33:26.720
Um, or it was kind of based around like older styles of Python and things have changed so much

00:33:26.720 --> 00:33:27.360
recently.

00:33:27.360 --> 00:33:31.600
So we kind of wanted to make sure that you could run this in a multi-threaded environment,

00:33:31.600 --> 00:33:36.240
whether that's like a UI, for example, like a desktop interface or it's a web app.

00:33:36.240 --> 00:33:44.560
So like one of our demos is like, is a .NET web app, like API, that each request can

00:33:44.560 --> 00:33:46.240
run a Python function if it wants to.

00:33:46.240 --> 00:33:49.040
And they're all running in separate threads in a thread pool in .NET.

00:33:49.520 --> 00:33:51.680
And you shouldn't have to worry about the gill.

00:33:51.680 --> 00:33:56.640
Um, like you didn't have to know too much in terms of what it is and how it works.

00:33:56.640 --> 00:34:00.080
So we've done quite a lot of work to make sure that that, that can happen.

00:34:00.080 --> 00:34:01.360
Yeah, that's amazing.

00:34:01.360 --> 00:34:04.240
Python has async and await.

00:34:04.240 --> 00:34:06.160
C# has async and await.

00:34:06.160 --> 00:34:07.520
They're similar, but not the same.

00:34:07.520 --> 00:34:09.440
Yeah.

00:34:09.440 --> 00:34:16.320
So can, can I have an async function in Python that is called by C#?

00:34:17.280 --> 00:34:18.240
No, not yet.

00:34:18.240 --> 00:34:21.120
Um, there is a pet.

00:34:21.120 --> 00:34:22.240
Just a, there has been a pet.

00:34:22.240 --> 00:34:23.280
You know, task.run.

00:34:23.280 --> 00:34:28.080
Async.io.run to completion sort of thing and then keep going for now.

00:34:28.080 --> 00:34:28.320
Yeah.

00:34:28.320 --> 00:34:32.480
I would love to do this, but there isn't, there is no API for it on the Python side.

00:34:32.480 --> 00:34:43.280
Um, to like manage event loops and embed an event loop into another process or to write a custom event loop.

00:34:43.280 --> 00:34:49.840
It's all kind of built into the standard library or is built into another module.

00:34:49.840 --> 00:34:54.320
Um, there's been a couple of proposals in draft peps, but none of them have been accepted.

00:34:54.320 --> 00:35:00.000
And if they were, then it might be in 3.14 anyway, which we can't backward compatible support.

00:35:00.000 --> 00:35:00.320
Yeah.

00:35:00.320 --> 00:35:00.560
Yeah.

00:35:00.560 --> 00:35:02.400
You're not quite there time wise yet.

00:35:02.400 --> 00:35:06.480
Do you find that the async.io event loops in Python are hard to juggle?

00:35:06.480 --> 00:35:07.520
Right?

00:35:07.520 --> 00:35:16.000
Like you have to create one if it doesn't exist, but if it does exist and it doesn't want you to create a new one, but there's not a great way to see if it exists.

00:35:16.000 --> 00:35:25.040
And if you don't have direct access to it, how do you get like, it's just, it always feels to me a little bit out of touch to fully take control over that and work with it.

00:35:25.040 --> 00:35:28.000
And it changes between Python versions.

00:35:28.000 --> 00:35:29.000
Yeah.

00:35:29.000 --> 00:35:30.760
Like it gets, it's gotten easier recently.

00:35:30.760 --> 00:35:34.720
Um, like there's a, there's like a dot run function now.

00:35:34.720 --> 00:35:40.720
And, whereas previously you have to like get the event loop and create one and stuff like that.

00:35:40.720 --> 00:35:42.720
But now you can just kind of run the coroutine.

00:35:42.720 --> 00:35:46.080
Um, but yeah, there's still, it's still tricky.

00:35:46.080 --> 00:35:57.760
And, the idea of basically writing a custom event loop and then giving it coroutine objects and like polling them and looping them from another runtime.

00:35:57.760 --> 00:36:00.400
Um, I just couldn't figure out the API.

00:36:00.400 --> 00:36:01.120
I'd love to do it.

00:36:01.120 --> 00:36:02.960
If anyone knows, then please ping me.

00:36:02.960 --> 00:36:06.080
Well, UV loop does it.

00:36:06.080 --> 00:36:08.000
Right?

00:36:08.000 --> 00:36:08.400
Yeah.

00:36:08.400 --> 00:36:09.200
Somehow.

00:36:09.200 --> 00:36:12.960
But maybe they just swap out some pieces of it, not all of it.

00:36:12.960 --> 00:36:14.560
Yeah, I'm not sure how.

00:36:14.560 --> 00:36:16.960
But you can set the event loop from UV loop.

00:36:16.960 --> 00:36:19.920
So maybe, I don't know, maybe there's a breadcrumb there to chase.

00:36:19.920 --> 00:36:22.800
All right.

00:36:22.800 --> 00:36:26.000
So I see in the steps, install Python.

00:36:26.720 --> 00:36:28.400
Put your projects in a C# file.

00:36:28.400 --> 00:36:33.600
Use annotations on your Python functions.

00:36:33.600 --> 00:36:33.840
Right?

00:36:33.840 --> 00:36:35.760
That's a really important step that you talked about.

00:36:35.760 --> 00:36:39.920
Install the CSnakes runtime package.

00:36:39.920 --> 00:36:43.760
So maybe from this point on, let's talk a little bit about some of the steps.

00:36:43.760 --> 00:36:48.800
So this CSnakes runtime, this is a NuGet package that you put into your .NET project.

00:36:48.800 --> 00:36:50.320
Is that what I'm reading here?

00:36:51.280 --> 00:36:51.680
Yeah.

00:36:51.680 --> 00:36:55.600
So we essentially have two binaries that we ship.

00:36:55.600 --> 00:36:58.560
One, which is going to do all the code generation for you.

00:36:58.560 --> 00:37:04.400
So from a .NET perspective, it wouldn't be uncommon to have multiple different projects

00:37:04.400 --> 00:37:06.800
with inside of your solution, which is then,

00:37:07.840 --> 00:37:13.920
like one might just be a bunch of services, which are then going to then talk to a database or

00:37:13.920 --> 00:37:16.160
whatever the case may be.

00:37:16.160 --> 00:37:22.480
So you might have that as just a, like, that would be where you would have the code gen that you want

00:37:22.480 --> 00:37:28.160
to do so where the Python files are actually getting their C# interop generated for you.

00:37:28.160 --> 00:37:29.520
So you have one project with that.

00:37:29.520 --> 00:37:36.000
And then we have a second binary, which is then the runtime to actually, like, make that work when

00:37:36.000 --> 00:37:37.040
your application is running.

00:37:37.040 --> 00:37:41.040
Now we do ship this as a single consolidated package just for ease of use.

00:37:41.040 --> 00:37:48.240
But that's kind of why we differentiate some of it in terms of like code gen versus runtime,

00:37:48.240 --> 00:37:50.080
because they're different concepts.

00:37:50.080 --> 00:37:53.680
And one is a compilation step versus obviously a runtime step.

00:37:53.680 --> 00:37:55.760
So, yeah.

00:37:55.760 --> 00:37:56.320
Okay.

00:37:56.320 --> 00:37:57.760
Yeah.

00:37:57.760 --> 00:38:04.480
So with our runtime package and the documentation talks a little bit more about this,

00:38:04.480 --> 00:38:09.280
there's just a few steps you've got to do to make sure that the C# compiler is capable of

00:38:09.280 --> 00:38:10.560
finding the Python files.

00:38:10.560 --> 00:38:18.160
We actually do stuff with inside of the C# compiler pipeline to generate code that is then

00:38:18.160 --> 00:38:18.720
added to it.

00:38:18.720 --> 00:38:25.520
So this also means that we can very early on find out if you're going to have compatibility issues.

00:38:25.520 --> 00:38:33.760
So if something is type of the type that we don't understand or the Python code is syntactically

00:38:33.760 --> 00:38:39.520
obscure, because what I've learned is that there are ways that you can write valid Python code that is

00:38:39.520 --> 00:38:42.080
very obscure.

00:38:42.080 --> 00:38:47.440
And then you showed me some things that you can do, but please don't do it.

00:38:48.080 --> 00:38:48.640
Yeah.

00:38:48.640 --> 00:38:49.040
And yeah.

00:38:49.040 --> 00:38:53.360
So you'll actually fail a compilation step rather than fail a runtime process.

00:38:53.360 --> 00:38:58.880
And I think, again, from a .NET developer's perspective, we're used to that static typing,

00:38:58.880 --> 00:39:04.800
that compilation step, that belief that the compiler has done a whole bunch of checks for us to give

00:39:04.800 --> 00:39:12.640
us code that should just work, rather than just that more dynamic typing system that you get out of Python,

00:39:12.640 --> 00:39:15.200
like in my experience, like the JavaScript side of things.

00:39:15.200 --> 00:39:15.920
Yeah.

00:39:15.920 --> 00:39:16.480
Yeah.

00:39:17.040 --> 00:39:18.000
That's definitely the expectation.

00:39:18.000 --> 00:39:26.000
If you're doing C#, C++, if it compiles, at least it's clicked together in a coherent way.

00:39:26.000 --> 00:39:26.400
Yeah.

00:39:26.400 --> 00:39:26.480
Right?

00:39:26.480 --> 00:39:29.120
Whereas Python, we're pretty sure.

00:39:29.120 --> 00:39:30.880
We don't know for sure, but we're pretty sure.

00:39:30.880 --> 00:39:35.120
So in Python typing, you can lie, right?

00:39:35.120 --> 00:39:39.840
I could say it takes a list of integers and really what it took was strings, which had numbers as

00:39:39.840 --> 00:39:40.240
character.

00:39:40.240 --> 00:39:40.720
Who knows?

00:39:40.720 --> 00:39:40.960
Right?

00:39:40.960 --> 00:39:45.520
What happens if I lie to the C# code gen thing?

00:39:45.520 --> 00:39:48.800
I mean, it's going to just take care of it.

00:39:48.800 --> 00:39:50.080
That's what I was thinking, Tor.

00:39:50.080 --> 00:39:51.040
I'm talking to you.

00:39:51.040 --> 00:39:52.160
That's what I was thinking of me.

00:39:53.440 --> 00:39:54.160
Oh my gosh.

00:39:54.160 --> 00:39:57.280
So it just crashes?

00:39:57.280 --> 00:39:57.760
Don't do it.

00:39:57.760 --> 00:40:00.080
Yeah.

00:40:00.080 --> 00:40:00.960
Yeah.

00:40:00.960 --> 00:40:07.920
That's actually just crash when it calls because it has to make the assumption that

00:40:07.920 --> 00:40:09.840
what you've told it is correct.

00:40:09.840 --> 00:40:16.960
In .NET, if I've got a tuple of ints and I give it across and it's like, "Ha ha, I actually

00:40:16.960 --> 00:40:17.600
wanted strings."

00:40:18.880 --> 00:40:20.000
No, it's not going to happen.

00:40:20.000 --> 00:40:20.960
It will raise a...

00:40:20.960 --> 00:40:26.080
Yeah, because to get, for example, if it returns a list of strings, but you actually return a list

00:40:26.080 --> 00:40:33.200
of integers, in order to give you back a list of strings in C#, we first check that it's a list.

00:40:33.200 --> 00:40:38.720
If it isn't, or if it's not a sequence type, like it could be a...

00:40:38.720 --> 00:40:42.000
I don't know if you could have inherited from list and made your own custom list,

00:40:42.000 --> 00:40:43.600
or you could make something which is a sequence.

00:40:43.600 --> 00:40:47.520
Like if it's not that, then we will raise an exception.

00:40:48.240 --> 00:40:49.600
It doesn't just crash, I was joking.

00:40:49.600 --> 00:40:50.400
Oh, that's good.

00:40:50.400 --> 00:40:52.480
And we've got a lot of testing to make sure.

00:40:52.480 --> 00:41:00.640
There's a whole like a test environment that's around like lying code and type hints and stuff

00:41:00.640 --> 00:41:01.840
which are completely invalid.

00:41:01.840 --> 00:41:06.400
And then for the strings, you know, we need to look at the Python string and then

00:41:06.400 --> 00:41:13.200
Python mostly uses UTF-8 and .NET mostly uses UTF-16.

00:41:13.200 --> 00:41:16.320
You know, we need to convert from one to the other.

00:41:16.320 --> 00:41:19.920
And if it's an integer, not a string in the first place, then that's never going to work.

00:41:19.920 --> 00:41:23.840
So we would raise an exception there and say, you told us it was a string and you lied.

00:41:23.840 --> 00:41:26.000
Um, yeah.

00:41:26.000 --> 00:41:30.320
So you lied exception is thrown.

00:41:30.320 --> 00:41:31.600
Yeah.

00:41:31.600 --> 00:41:32.320
Yeah.

00:41:32.320 --> 00:41:35.600
I think it's like a cast, invalid cast exception or something like that.

00:41:35.600 --> 00:41:35.760
Yeah.

00:41:35.760 --> 00:41:35.920
Of course.

00:41:35.920 --> 00:41:37.520
With the description.

00:41:37.520 --> 00:41:44.480
We've tried to raise like the exceptions we raise are .NET exceptions, which are relevant to the

00:41:44.480 --> 00:41:48.240
concept of the problem that we've covered.

00:41:48.240 --> 00:41:54.640
But at the same time, it actually will give you, imagine if something failed in the Python code as

00:41:54.640 --> 00:42:01.120
well, like, you know, you type annotated that it was like a bunch of strings and we, and,

00:42:01.120 --> 00:42:04.240
uh, no, a bunch of ints and we, we gave you a bunch of strings.

00:42:04.240 --> 00:42:06.320
Well, okay.

00:42:06.320 --> 00:42:09.360
Um, and the, the Python code is going to fail there.

00:42:09.360 --> 00:42:15.200
So, where we then surface out the Python exceptions as well as like embedded with inside

00:42:15.200 --> 00:42:16.560
of the .NET exception.

00:42:16.560 --> 00:42:22.000
So you can, you can actually get down to like the, the lines of code with inside of Python that

00:42:22.000 --> 00:42:30.400
failed, which the stack trace actually includes C#, C#, C#, Python, Python, Python,

00:42:30.400 --> 00:42:30.960
potentially.

00:42:30.960 --> 00:42:31.200
Yeah.

00:42:31.200 --> 00:42:32.320
Yeah.

00:42:32.320 --> 00:42:38.800
And if you did in Python, if you didn't it, raise from, it, that will

00:42:38.800 --> 00:42:41.040
show up as an inner exception in .NET as well.

00:42:41.040 --> 00:42:45.280
Um, so we did a lot of work on exceptions mostly because we had to like debug this stuff

00:42:45.280 --> 00:42:46.080
when we're developing it.

00:42:46.080 --> 00:42:48.240
And that's really helpful.

00:42:48.240 --> 00:42:48.640
Yeah.

00:42:48.640 --> 00:42:50.800
We felt the pain that someone else was going to build.

00:42:50.800 --> 00:42:56.400
Um, so yeah, you see the, you can see the stack trace, you get like all the frame

00:42:56.400 --> 00:42:57.440
variables and stuff like that.

00:42:57.440 --> 00:43:02.240
So things that you would probably want from like a PDB, you can see on the .NET side.

00:43:02.240 --> 00:43:08.240
So if you're running the debugger in .NET, and it crashes in Python, like it or raises

00:43:08.240 --> 00:43:11.600
an exception or something, you see the Python exception with all the details.

00:43:11.600 --> 00:43:17.040
Um, and then you see like inner exceptions and stuff like that as well, as well as the

00:43:17.040 --> 00:43:20.640
locals and the globals and any other frame information.

00:43:20.640 --> 00:43:21.600
Yeah.

00:43:21.600 --> 00:43:27.600
I was pretty impressed when I saw that, that how integrated, how much I felt from both directions,

00:43:27.600 --> 00:43:30.640
kind of natural and not just bolted on.

00:43:30.640 --> 00:43:32.240
Yeah.

00:43:32.240 --> 00:43:33.360
Yeah.

00:43:33.360 --> 00:43:38.480
So another step is mark these for code for source generation.

00:43:38.480 --> 00:43:45.760
This feels like a visual studio 20, whatever year, the last release of visual studio was.

00:43:45.760 --> 00:43:46.800
Yeah.

00:43:46.800 --> 00:43:48.400
Aaron, where, what's the number?

00:43:48.400 --> 00:43:50.720
Uh, 20, 22.

00:43:50.720 --> 00:43:51.600
Okay.

00:43:51.600 --> 00:43:56.400
So the, the reason I bring this up is a lot of people hear visual studio, especially

00:43:56.400 --> 00:43:58.720
in the Python space and think Visual Studio Code.

00:43:58.720 --> 00:44:00.560
Does this work in Visual Studio Code?

00:44:00.560 --> 00:44:01.600
Or is it just a.

00:44:01.600 --> 00:44:06.960
No, it definitely works in, in VS Code.

00:44:06.960 --> 00:44:10.640
Um, I, I, I, I sometimes open it in VS Code.

00:44:10.640 --> 00:44:16.640
Obviously you're likely to install the C# extension to get a, a better developer experience

00:44:16.640 --> 00:44:22.960
on that, but, so what, what we have to do is cause, cause the, the source generator

00:44:22.960 --> 00:44:26.160
is actually running as they step with inside of the C# compiler pipeline.

00:44:26.160 --> 00:44:28.960
We need it to know how to find these files.

00:44:28.960 --> 00:44:33.440
Um, and we, we, we kind of toyed with the idea of just to like, you know, just do a directory scan,

00:44:33.440 --> 00:44:36.800
but everything that ends in dot P Y we're, we're going after.

00:44:36.800 --> 00:44:37.280
Yeah.

00:44:37.280 --> 00:44:39.440
That that's, that's not particularly efficient.

00:44:39.440 --> 00:44:43.600
And also like, if you've just got like modules that are using other modules, things like you,

00:44:43.600 --> 00:44:46.480
you, you, you want to what was, how do you craft a surface error?

00:44:46.480 --> 00:44:50.400
And Python that you actually want to expose rather than just, you know, expose everything.

00:44:50.400 --> 00:44:56.000
Um, so we, inside of the CS project file.

00:44:56.000 --> 00:45:03.600
So this is the, the, the file that is the instructions on how to compile a more complex.net application.

00:45:03.600 --> 00:45:11.520
Um, we can then add, add nodes to that XML structure to say, like, here's a Python file.

00:45:12.400 --> 00:45:16.320
Um, it's an, annotate that for the C# compiler to pick up.

00:45:16.320 --> 00:45:25.840
So that when the source generator hits it, it hits our, our steps, it goes, okay, I'm going to find all of these, additional files that you've said I need to be aware of.

00:45:25.840 --> 00:45:27.840
And then I can read them in.

00:45:27.840 --> 00:45:35.840
And it's actually got some optimizations for how like internally it will read that file in rather than us then having to do file IO or anything like that.

00:45:35.840 --> 00:45:49.840
So it, it just, it's more intrinsically aware of them and that it will make those available so that it can then generate out the code rather than, rather than, like I said, us having to try and guess what Python files you want available.

00:45:49.840 --> 00:45:55.840
Like, you know, they have to be in a special folder or they had to be named a certain way, or we just, you know, directory scanned everything.

00:45:55.840 --> 00:46:07.840
And we don't pay why you want to be really careful about which ones you're trying to do this to because they require type annotation and you don't want to just expose all the guts of some.

00:46:07.840 --> 00:46:08.840
Bit of code.

00:46:08.840 --> 00:46:10.840
You want to maybe talk about the surface area, right?

00:46:10.840 --> 00:46:11.840
Yeah.

00:46:12.840 --> 00:46:18.840
As.net people, you have these protected private internal protected internal, et cetera, things.

00:46:18.840 --> 00:46:20.840
We don't talk about them in Python.

00:46:20.840 --> 00:46:23.840
You want to be consistent with that, right?

00:46:23.840 --> 00:46:24.840
Yeah.

00:46:24.840 --> 00:46:32.840
So Anthony, it says last step to instantiate the Python environment.

00:46:32.840 --> 00:46:36.840
This is, feels almost like a, an import statement.

00:46:36.840 --> 00:46:39.840
Then you use it namespace style later.

00:46:39.840 --> 00:46:41.840
Do you want to talk about that real quick?

00:46:41.840 --> 00:46:42.840
Yeah.

00:46:42.840 --> 00:46:44.840
So, Python.

00:46:44.840 --> 00:46:51.840
So in order to start like into embed Python into the.net process, you need to create Python environment.

00:46:51.840 --> 00:46:56.840
Uh, and there's a few things we have to know, like where is Python installed?

00:46:56.840 --> 00:46:58.840
Um, what version is it?

00:46:58.840 --> 00:47:00.840
Um, do you have a virtual environment?

00:47:00.840 --> 00:47:02.840
Is it just like the global environment?

00:47:02.840 --> 00:47:04.840
Do you have like packages?

00:47:04.840 --> 00:47:09.840
There's like additional things that we need to know that you would have in Python, you would have kind of.

00:47:09.840 --> 00:47:10.840
set those elsewhere.

00:47:10.840 --> 00:47:13.840
Like if there was a virtual environment, you would have activated it.

00:47:13.840 --> 00:47:18.840
Um, you know, if you were running Python, then you would have set which version it was and where it's installed.

00:47:18.840 --> 00:47:23.840
Um, so you've in.net, you haven't done those steps.

00:47:23.840 --> 00:47:30.840
Um, so we need you to tell us like which version of Python do you want to, do you want to create?

00:47:30.840 --> 00:47:31.840
Uh, and where is it?

00:47:31.840 --> 00:47:35.840
Um, and we've created a whole bunch of code to help you find it.

00:47:35.840 --> 00:47:43.840
And the UV team actually have been solving a similar, problem with like spitting up Python and running Python.

00:47:43.840 --> 00:47:46.840
Um, so I'm kind of curious to see like how they've tackled it.

00:47:46.840 --> 00:47:52.840
And we might even try and look at bringing UV in as one of the mechanisms for finding Python for you.

00:47:52.840 --> 00:47:53.840
Um, cause it's.

00:47:53.840 --> 00:47:54.840
This was something.

00:47:54.840 --> 00:47:54.840
Yeah.

00:47:54.840 --> 00:47:57.840
It's something I wanted to talk to you about is.

00:47:57.840 --> 00:48:01.840
You've got to have Python installed and you've got to get the dependencies and.

00:48:01.840 --> 00:48:04.840
Yeah, we're not going to use them for you.

00:48:04.840 --> 00:48:05.840
Um.

00:48:05.840 --> 00:48:07.840
Yeah, but with UV.

00:48:07.840 --> 00:48:11.840
V and V give it a Python version.

00:48:11.840 --> 00:48:12.840
It'll just.

00:48:12.840 --> 00:48:13.840
It can download.

00:48:13.840 --> 00:48:19.840
It can fetch it and just run it and it's cached and maybe you could embed that as a resource at compile time.

00:48:19.840 --> 00:48:22.840
There's interesting possibilities there.

00:48:22.840 --> 00:48:23.840
Yeah.

00:48:23.840 --> 00:48:30.840
So our virtual environment support, uses either condor or pip as the package manager, depending on what you want.

00:48:30.840 --> 00:48:36.840
Um, and you can say, here's my requirements file and it will go in and pip install them as well.

00:48:36.840 --> 00:48:39.840
Like it can do all of those things for you because we're kind of assuming that.

00:48:39.840 --> 00:48:40.840
Yeah.

00:48:40.840 --> 00:48:44.840
You've developing this locally and you're running it locally, but it's going to be deployed somewhere else.

00:48:44.840 --> 00:48:46.840
So you don't, you don't want to have to like.

00:48:46.840 --> 00:48:52.840
Log into the production servers and like create virtual environments and the command line and stuff like that.

00:48:52.840 --> 00:48:56.840
We've with hopefully 15, 20 years past people doing that.

00:48:56.840 --> 00:49:06.840
Um, like, so you should be able to programmatically say this project needs a virtual environment and it needs these packages installed and needs this version of Python.

00:49:06.840 --> 00:49:14.840
And then you can either use the version of Python that comes with your Linux container, for example, or you can.

00:49:14.840 --> 00:49:17.840
Pull in one from somewhere else.

00:49:17.840 --> 00:49:20.840
Um, for windows, you can actually download it from new get.

00:49:20.840 --> 00:49:23.840
It's like a, you can actually add it as a dependency in.net.

00:49:23.840 --> 00:49:27.840
Um, and that's a really simple solution for windows development for macOS.

00:49:27.840 --> 00:49:37.840
If you've installed it from Python to org, like using the official installer, you just, you just tell it that you just say, use like the macOS Python and give it the version number.

00:49:37.840 --> 00:49:40.840
And then for Linux, it's a lot more complicated.

00:49:40.840 --> 00:49:42.840
Um, cause there's no standards.

00:49:42.840 --> 00:49:49.840
Um, so yeah, we've kind of support every which way of, finding it on, on Linux.

00:49:49.840 --> 00:49:54.840
And then once you've kind of put the Python environment into the process, there should only be one of them.

00:49:54.840 --> 00:50:01.840
Um, Python itself does not want you to ever spin up more than one Python environment in the same, like operating process.

00:50:01.840 --> 00:50:05.840
Um, it will have all sorts of problems if you, if you do that.

00:50:05.840 --> 00:50:13.840
So it's, it's basically put in as a singleton and then you import a module, by creating an instance of it.

00:50:13.840 --> 00:50:18.840
And then on that module, you can then call methods, which are the functions in the module.

00:50:18.840 --> 00:50:29.840
So like if you had a module called demo.py, then in your environment, you'd see like a factory for like effectively like import demo and giving back an instance of it.

00:50:29.840 --> 00:50:33.840
And then on that instance, you'd have methods, which are the functions.

00:50:33.840 --> 00:50:38.840
Um, and the example you've got on your screen, you know, there's a function called hello world.

00:50:38.840 --> 00:50:41.840
It takes some arguments in a, in a file called demo.py.

00:50:41.840 --> 00:50:44.840
So you just say environment.demo, like make a demo instance.

00:50:44.840 --> 00:50:50.840
And then on that instance, you can call .hello world with the arguments and it gives you back the results.

00:50:50.840 --> 00:50:58.840
So there's no really like in a few lines of code, like four or five, you can spin up a Python environment, import a module, minor function.

00:50:58.840 --> 00:51:01.840
Um, so we'd really try to minimize the boilerplate code.

00:51:01.840 --> 00:51:06.840
Um, by, and then following the patterns that are best for both platforms.

00:51:06.840 --> 00:51:10.840
There's a lot of places you could go with this.

00:51:10.840 --> 00:51:11.840
This is really cool.

00:51:11.840 --> 00:51:22.840
Uh, for example, if you, if you've got a singleton, which is great, I mean, that's kind of how Python typically is one environment, but with the sub interpreters, you could theoretically create these in parallel.

00:51:22.840 --> 00:51:31.840
One thing that stands out as maybe a little non-expected in this is like, you have var module equals env a demo, right?

00:51:31.840 --> 00:51:35.840
Where you're creating this, but in Python, the, this thing is called demo.

00:51:35.840 --> 00:51:43.840
Like, would it be a, would it be a pattern to maybe name the variable to same as the module name?

00:51:43.840 --> 00:51:44.840
Maybe.

00:51:44.840 --> 00:51:45.840
Yeah.

00:51:47.840 --> 00:51:52.840
I think the, that's probably just more from laziness in the way we've written our docs, but yeah.

00:51:52.840 --> 00:51:53.840
Yeah.

00:51:53.840 --> 00:51:54.840
Oh yeah.

00:51:54.840 --> 00:51:55.840
No worries.

00:51:55.840 --> 00:52:09.840
Um, what we're probably lacking, from, cause this is obviously, docs and just markdown code is that so that, when you, so we would get back our IPython environment from our dependency injection container.

00:52:09.840 --> 00:52:26.840
And then, things like the, the demo methods exposed there would then return an, I, I demo, I think it is, or, and that is then the representation of the, that demo.py file that you've imported.

00:52:26.840 --> 00:52:27.840
So yeah.

00:52:27.840 --> 00:52:28.840
Um, I, I, yeah, yeah.

00:52:28.840 --> 00:52:29.840
Probably.

00:52:29.840 --> 00:52:29.840
Yeah.

00:52:29.840 --> 00:52:31.840
So then, then all those methods are then exposed on that.

00:52:31.840 --> 00:52:32.840
So yeah.

00:52:32.840 --> 00:52:40.840
I module from it, like conceptually, if I'm, if I'm thinking about this as a .NET developer, looking at it from Python, I'm like, okay, the, the module is that Python file.

00:52:40.840 --> 00:52:48.840
Um, and that's what I get back when I say, like, I, I want an instance of the interface into that file.

00:52:48.840 --> 00:52:49.840
And that's what I'm trying to do.

00:52:49.840 --> 00:52:50.840
Yeah.

00:52:50.840 --> 00:52:53.840
And it does, honestly, it doesn't matter how I feel about this as a Python person.

00:52:53.840 --> 00:52:58.840
It feels about, it matters how .NET people feel about this when they look, cause that's, this is C# code.

00:52:58.840 --> 00:52:59.840
That's their code.

00:52:59.840 --> 00:53:01.840
That's their world.

00:53:01.840 --> 00:53:07.840
It, it just so happens that C snake make it, makes it really nice and possible to talk to the Python world.

00:53:07.840 --> 00:53:09.840
Yeah.

00:53:11.840 --> 00:53:22.840
So one thing I wanted, maybe you could spend a couple minutes talking about this, Anthony is I saw an example where you, you showed integrated.

00:53:22.840 --> 00:53:37.840
OpenTelemetry and ASP.NET and Postgres and all sorts of stuff together, not just a, you know, hello world sort of example, which shows some really cool stuff, but maybe doesn't convince people that they could do cool stuff with it.

00:53:37.840 --> 00:53:44.840
You want to just maybe talk us through some of the moving parts of that to give people a sense of a more realistic example?

00:53:45.840 --> 00:53:46.840
Yeah.

00:53:47.840 --> 00:53:49.840
So we have a, another demo, which is a web app.

00:53:49.840 --> 00:53:51.840
It's in, in the project.

00:53:51.840 --> 00:53:58.840
It's, it's, this is kind of what we thought was the more realistic integration example.

00:53:58.840 --> 00:54:04.840
So you've got a, a web app written in, well, the front end written in HTML and JavaScript.

00:54:04.840 --> 00:54:06.840
The, the API is written in .NET.

00:54:06.840 --> 00:54:10.840
Um, you're using Postgres as the database.

00:54:10.840 --> 00:54:20.840
Um, and, you've got like a feature that you want to add to your app where you want to use some Python libraries and some Python code.

00:54:20.840 --> 00:54:24.840
Um, and we were looking at, whether everyone loves the weather demo.

00:54:24.840 --> 00:54:27.840
Um, so it's just real enough.

00:54:27.840 --> 00:54:28.840
Come on.

00:54:28.840 --> 00:54:29.840
It's just real enough.

00:54:29.840 --> 00:54:36.840
The weather demo is like the canonical .NET demo of like, when you do file new API projects, like here is a weather app.

00:54:36.840 --> 00:54:39.840
So I, from a .NET developer, I feel very much at home.

00:54:39.840 --> 00:54:41.840
Yeah.

00:54:41.840 --> 00:54:42.840
You're already on board.

00:54:42.840 --> 00:54:42.840
Okay.

00:54:42.840 --> 00:54:43.840
Got it.

00:54:43.840 --> 00:54:43.840
Yeah.

00:54:43.840 --> 00:54:45.840
We're creating the one that people would expect.

00:54:45.840 --> 00:54:48.840
Um, now on the .NET side, we also said, right.

00:54:48.840 --> 00:55:03.840
Like, yeah, let's be realistic about what people would want to do because, like modern applications, you would write the API in, ASP.NET and you would, you know, have API endpoints that you would, and, and routes and configure those.

00:55:03.840 --> 00:55:11.840
Um, and you would have a, probably a relational database like Postgres or SQL server or something, as the, the storage environment.

00:55:11.840 --> 00:55:21.840
Um, and then now we support open telemetry, in a platform called Aspire, which Aaron can probably explain in a, in a second.

00:55:21.840 --> 00:55:32.840
Um, so open telemetry is a, is a new standard for, like tracing and instrumentation and observability generally of, of, of applications written in any language.

00:55:32.840 --> 00:55:48.840
Uh, and in .NET you can have, so for this app, for example, like, you know, somebody makes a request to the web app and you see the request come in and all the timing and it doesn't need log records in .NET or if anything crashes or like it's all associated with the same request.

00:55:48.840 --> 00:56:00.840
Um, now if we're going to spin up and run a Python function and in Python, you do import logging, you know, logger, logging.info or logging.error, like where does that go?

00:56:00.840 --> 00:56:04.840
Um, because you've just logged something in Python.

00:56:04.840 --> 00:56:06.840
Does it just disappear into the ether?

00:56:06.840 --> 00:56:12.840
Is it like, it goes into the, the terminal output of the container it runs in, who knows, right?

00:56:12.840 --> 00:56:12.840
Yeah, exactly.

00:56:12.840 --> 00:56:17.840
Like it would be kind of useless and, and not easy to manage.

00:56:17.840 --> 00:56:21.840
And we're coming at this at the angle, like people write big enterprise apps in .NET.

00:56:21.840 --> 00:56:25.840
So like they would expect that they do logging and it's all in the same system.

00:56:25.840 --> 00:56:37.840
So this demo basically says, okay, one of the API endpoints in on .NET, it runs a punk function in Python, which, you know, spins up.

00:56:37.840 --> 00:56:48.840
It uses pandas and as a data frame to look at the weather or in it like calculates some averages and shifting means and stuff like that to give you back like a prediction for what the weather is going to be like this week.

00:56:48.840 --> 00:56:53.840
Um, and we just use Seattle was the data set because it's easy because it's always going to rain.

00:56:53.840 --> 00:56:57.840
But, and then it's not actually most of the time it doesn't.

00:56:57.840 --> 00:56:58.840
It's not fair.

00:56:58.840 --> 00:57:07.840
Um, so it runs that in Python and in the Python code, we use open telemetry to show the trace of it talking to the database.

00:57:07.840 --> 00:57:15.840
And we, we make, we use Python logging, and that log information on the trace information all gets put into the same trace.

00:57:15.840 --> 00:57:20.840
So from .NET from start to finish, you see the request come in on the front end.

00:57:20.840 --> 00:57:23.840
You see that code executing, you see the Python code.

00:57:23.840 --> 00:57:29.840
And then if Python crashes or if the log entries go in, they're all in the same environment.

00:57:29.840 --> 00:57:39.840
So in like an open telemetry dashboard, you see the whole trace across both .NET and Python all in the same environment.

00:57:39.840 --> 00:57:41.840
And you can just use logging as you would normally.

00:57:41.840 --> 00:57:43.840
Um, yeah.

00:57:43.840 --> 00:57:50.840
And .NET aspire comes with a, like a free open telemetry dashboard that you can run locally.

00:57:50.840 --> 00:57:51.840
It's like a Docker container.

00:57:51.840 --> 00:57:52.840
This is really nice.

00:57:52.840 --> 00:57:56.840
Um, to save you kind of spinning up, Jaeger or something.

00:57:56.840 --> 00:57:58.840
Yeah, this is really cool.

00:57:58.840 --> 00:58:03.840
Yeah, this is really cool because you've got an ASP.NET API.

00:58:03.840 --> 00:58:23.840
But then when it's called, it uses one of these code gen CSnakes, Python integrations, but a lot of stuff just flows through like the Postgres connection string flows through the open telemetry context flows through the logging kind of goes tangentially off.

00:58:23.840 --> 00:58:27.840
Then it talks to the database in Python, and then it returns back.

00:58:27.840 --> 00:58:39.840
So for example, it's just pure, SQL connections and stuff, but you know, psycopg too, but you could use pretty much any ORM or anything, right?

00:58:39.840 --> 00:58:41.840
There's no real constraint there.

00:58:41.840 --> 00:58:42.840
Yeah.

00:58:42.840 --> 00:58:42.840
Yeah.

00:58:42.840 --> 00:58:59.840
And it uses a few modules which are tricky, like pandas and psycopg is a, is a, anyone who's deployed that to production in containers or in different environments knows it's, it's hard because like, it's like, which binary do you use?

00:58:59.840 --> 00:59:05.840
And like importing it is hard and you know, you need lib PQ and like, it's a bit of a nightmare.

00:59:05.840 --> 00:59:10.840
Um, so it's just demonstrate that they're like, this is, this is a real thing you can do.

00:59:10.840 --> 00:59:21.840
And it shows something which is practical in Python and something which is practical in.net, which is like a proper app with tracing and logging and all the, you know, all those kinds of features.

00:59:21.840 --> 00:59:28.840
And on the Python side, we're using pandas, which, you know, and we're using numpy, which is the C extension.

00:59:28.840 --> 00:59:35.840
Um, we're using psycopg, which is like, depends on a whole bunch of like third party libraries as well.

00:59:35.840 --> 00:59:40.840
Um, and stringing it all together and it just looks and feels seamless.

00:59:40.840 --> 00:59:49.840
Like you see the demo working and you would never know that the, the weather prediction comes from Python or even that it's running in this way.

00:59:49.840 --> 00:59:53.840
Like it just looks like, and it's implemented, like it's part of the same API.

00:59:53.840 --> 00:59:57.840
Just call a function and one of the libraries and off it goes.

00:59:57.840 --> 00:59:59.840
But yeah, it's all connected together like this.

00:59:59.840 --> 01:00:00.840
All right.

01:00:00.840 --> 01:00:04.840
I'll let you know we're about out of time, but I'll let either of you take this.

01:00:04.840 --> 01:00:08.840
That was a web example.

01:00:08.840 --> 01:00:19.840
What about something like WPF or Maui or any other desktop app possible?

01:00:19.840 --> 01:00:20.840
Yeah.

01:00:20.840 --> 01:00:27.840
Um, so because, I'll, I'll talk about Maui cause obviously that's the, the more modern, UI framework.

01:00:27.840 --> 01:00:33.840
Give a really, really quick definition to listeners who probably have think of that as part of Hawaii.

01:00:33.840 --> 01:00:43.840
Um, it's kind of the, the, the next evolution of, of Xamarin, which people may be familiar with the way that you do cross platform, UIs.

01:00:43.840 --> 01:00:44.840
Yeah.

01:00:44.840 --> 01:00:53.840
Uh, I'm, I'm definitely not the, the expert on Maui, but the idea is that, you know, you can have something that is a bit more portable from, a, a application experience.

01:00:53.840 --> 01:01:01.840
Whether you want to, target like a mobile application, like an Android or an iOS or, run as a, as a desktop application on windows or something like that.

01:01:01.840 --> 01:01:06.840
So just a, like a level of portability and some abstraction between UI concepts.

01:01:06.840 --> 01:01:11.840
Um, but fundamentally that's just running.net behind the scenes.

01:01:11.840 --> 01:01:19.840
Um, so there's no reason why we couldn't also, drop in a, any, a bit of, sea snakes in there and have that, yeah.

01:01:19.840 --> 01:01:22.840
Work with some kind of, backend service.

01:01:22.840 --> 01:01:32.840
So you could use this and this is something that Anthony and I have talked about, trying to, trying to get a demo of doing like a local model running with, like, so you, you pull a model off of hugging face or something like that.

01:01:32.840 --> 01:01:40.840
It just runs it locally to do some kind of AI inference or whatever the case may be for the scenario you want to tackle.

01:01:40.840 --> 01:01:44.840
But that way you don't have to be, you know, calling out to an external service.

01:01:44.840 --> 01:01:48.840
Now, while sure running like a local model, it's doable with.net.

01:01:48.840 --> 01:01:52.840
It is just way easier to do that with Python.

01:01:52.840 --> 01:01:57.840
Um, and all the examples you would find are going to be written in Python first and foremost.

01:01:57.840 --> 01:02:01.840
So trying to then go, okay, well, so this is doable in Python.

01:02:01.840 --> 01:02:02.840
So what's the C# equivalent?

01:02:02.840 --> 01:02:08.840
How do I find the equivalent.net, libraries on new yet and so on and so forth?

01:02:08.840 --> 01:02:16.840
Well, you know, like with, with sea snakes, you could expose that model, create some surface areas, in just Python APIs.

01:02:16.840 --> 01:02:21.840
That is then going to be contundable by a.net application.

01:02:21.840 --> 01:02:25.840
Um, so yeah, it's, it's something you can definitely do.

01:02:25.840 --> 01:02:28.840
Um, not a hundred percent sure whether you could do it on mobile.

01:02:28.840 --> 01:02:36.840
Um, I don't, I think that's probably stretching it a bit far just because of the way that we have to bootstrap Python with inside of it.

01:02:36.840 --> 01:02:49.840
I, and you'd probably be limited from a mobile OS runtime to be able to do that kind of bootstrapping, but at the very least like a desktop application, or if you wanted to tackle with like a cross platform UI framework, like Avalonia.

01:02:49.840 --> 01:02:54.840
So Avalonia is a cross platform.net UI framework.

01:02:54.840 --> 01:02:59.840
Um, that means that you could build for Linux and windows and, macOS at the same time.

01:02:59.840 --> 01:03:10.840
You could then run sea snakes under the hood of that to then have that desktop experience that is leveraging Python for where Python is going to be better suited to tackle a problem.

01:03:10.840 --> 01:03:20.840
.net for a different style, a set of problems that's better suited for that just inside this application where you would have no idea as the end user that you're like, that that's what's actually happening.

01:03:20.840 --> 01:03:23.840
Very compelling.

01:03:23.840 --> 01:03:24.840
Very compelling.

01:03:24.840 --> 01:03:28.840
All right, Anthony, let's close this out with one final thing.

01:03:28.840 --> 01:03:30.840
I think this is important and we haven't really touched on it yet.

01:03:30.840 --> 01:03:36.840
You guys started the conversation by saying this is really important for data science, right?

01:03:36.840 --> 01:03:37.840
Data science use cases.

01:03:38.840 --> 01:03:41.840
And I made the joke about copying a million items to add one to the list.

01:03:41.840 --> 01:03:52.840
But what about sharing data like NumPy across different in, you know, the .NET side and the Python side and so on?

01:03:52.840 --> 01:03:57.840
Um, yeah, so we've, we have tackled that specifically.

01:03:57.840 --> 01:04:03.840
So, there's something called the buffer protocol is, it's a PEP from a few years ago.

01:04:03.840 --> 01:04:14.840
It's a kind of an API, for the internals of something like an ND array in NumPy, in NumPy.

01:04:14.840 --> 01:04:18.840
Um, and the buffer protocol, where is it?

01:04:18.840 --> 01:04:19.840
We, we support that.

01:04:19.840 --> 01:04:30.840
So if your function returns a buffer, which is a type, then we can access the internals of that buffer, directly without having to convert the data.

01:04:30.840 --> 01:04:45.840
What this means in reality is that if your function returns a, like a NumPy array, like an ND array and the internal, values in the ND array are a specific type, like a 32 bit integer.

01:04:45.840 --> 01:04:54.840
Um, you can access them as 32 bit integers in .NET without having to marshal copy data.

01:04:54.840 --> 01:04:55.840
So that's awesome.

01:04:55.840 --> 01:05:02.840
You might reach inside of the, the ND array, just grab its actual memory and just say, got it.

01:05:02.840 --> 01:05:03.840
Let's go.

01:05:03.840 --> 01:05:04.840
Yeah, that's exactly what we do.

01:05:04.840 --> 01:05:07.840
And so that's a, it's in .NET.

01:05:07.840 --> 01:05:09.840
It's called a read only span.

01:05:09.840 --> 01:05:13.840
Um, which is the, you can write to the data as well.

01:05:13.840 --> 01:05:21.840
So you can do a span and you can actually just modify the values inside the NumPy array directly from .NET without having to copy backwards and forwards.

01:05:21.840 --> 01:05:27.840
And we support pretty much every like low level types that NumPy supports.

01:05:27.840 --> 01:05:30.840
And that means you don't have to do a .2 list on the NumPy array.

01:05:30.840 --> 01:05:33.840
Um, because like that is really expensive.

01:05:33.840 --> 01:05:40.840
And also .NET works in a similar, you know, low level numeric types that NumPy does.

01:05:40.840 --> 01:05:46.840
Um, you know, it will work with 32 bit ints and, and 32 or 64 bit floats, for example.

01:05:46.840 --> 01:06:02.840
So like if you're storing a 2d matrices in 32 bit floats in NumPy, and then you want to send that to, to .NET to, I don't know, like pick out some specific values or like do some calculations in, in .NET.

01:06:02.840 --> 01:06:07.840
Um, and there's information in the docs about how to do this.

01:06:07.840 --> 01:06:10.840
And then you can just access the values directly out of memory.

01:06:10.840 --> 01:06:13.840
So it's super fast.

01:06:13.840 --> 01:06:21.840
Um, and if you even want to like fill a buffer with values from .NET, then you can do that using the writable span.

01:06:21.840 --> 01:06:25.840
That's pretty awesome.

01:06:25.840 --> 01:06:29.840
So yeah, that really is leaning into the data science benefits here as well, isn't it?

01:06:30.840 --> 01:06:31.840
Yeah.

01:06:31.840 --> 01:06:32.840
And nothing ever goes wrong.

01:06:32.840 --> 01:06:35.840
If you're sharing memory across runtimes for different programming languages.

01:06:35.840 --> 01:06:37.840
It's no, I don't see how this could go wrong.

01:06:37.840 --> 01:06:38.840
Yeah.

01:06:39.840 --> 01:06:39.840
Perfect.

01:06:39.840 --> 01:06:40.840
Perfectly fine.

01:06:40.840 --> 01:06:43.840
And that's why I pushed to make sure we supported read only span.

01:06:43.840 --> 01:06:46.840
Yeah.

01:06:46.840 --> 01:06:47.840
Right.

01:06:47.840 --> 01:06:48.840
Okay.

01:06:48.840 --> 01:06:49.840
No, I think it's great.

01:06:49.840 --> 01:06:53.840
The UI stuff with Avalonia is something I'm going to look at.

01:06:53.840 --> 01:06:54.840
That sounds really cool to play with.

01:06:54.840 --> 01:06:55.840
So, all right.

01:06:55.840 --> 01:07:06.840
Final thoughts, you guys, people out there going, oh my gosh, I cannot believe we can finally do this with our .NET app and plug in some of the other things we're already doing in Python.

01:07:06.840 --> 01:07:07.840
Should they?

01:07:08.840 --> 01:07:09.840
Is it ready?

01:07:09.840 --> 01:07:11.840
Is somebody were to take this and build a thing?

01:07:11.840 --> 01:07:12.840
Is that a good idea or should they wait?

01:07:12.840 --> 01:07:15.840
Yep.

01:07:15.840 --> 01:07:17.840
They should download it, give it a go.

01:07:18.840 --> 01:07:23.840
The only thing we're possibly changing at the moment is the API based on feedback.

01:07:23.840 --> 01:07:25.840
We're trying to keep that as stable as possible right now.

01:07:25.840 --> 01:07:28.840
So, we're only making changes that are backward compatible.

01:07:28.840 --> 01:07:34.840
And yeah, we just want to see more use cases and people can get more feedback.

01:07:34.840 --> 01:07:42.840
So, yeah, please pull it, grab the samples, spin them up, build something, tell us what you made and give us any feedback.

01:07:42.840 --> 01:07:43.840
Yeah.

01:07:43.840 --> 01:07:44.840
Well, congrats.

01:07:44.840 --> 01:07:45.840
It looks really, really nice.

01:07:45.840 --> 01:07:52.840
Definitely, definitely looks promising and I think it's, it solves a lot of the problems that the other attempts had.

01:07:52.840 --> 01:07:53.840
So, nice work.

01:07:53.840 --> 01:07:55.840
Thanks, Mike.

01:07:55.840 --> 01:07:56.840
Thanks.

01:07:56.840 --> 01:07:57.840
Yep.

01:07:57.840 --> 01:07:58.840
Bye guys.

01:07:58.840 --> 01:08:00.520
Thank you.

