WEBVTT

00:00:00.000 --> 00:00:02.760
>> Hey, YouTube. Hey, Benji.


00:00:02.760 --> 00:00:03.840
>> Hey.


00:00:03.840 --> 00:00:07.400
>> Hey, great to have you here on the live stream.


00:00:07.400 --> 00:00:09.200
Just a moment on the podcast.


00:00:09.200 --> 00:00:10.340
Everyone out there listening,


00:00:10.340 --> 00:00:11.560
thank you for being here.


00:00:11.560 --> 00:00:13.920
Put your ideas into the live chat


00:00:13.920 --> 00:00:16.080
and we'll see if they can be part of the show.


00:00:16.080 --> 00:00:19.440
With that, Benji, welcome to Talk Python to Me.


00:00:19.440 --> 00:00:21.240
>> Thank you. It's great to be here.


00:00:21.240 --> 00:00:23.120
>> It's great to have you here.


00:00:23.120 --> 00:00:26.400
I'm quite excited to talk about Pants and Build


00:00:26.400 --> 00:00:31.360
and bringing a little bit more structure and automation


00:00:31.360 --> 00:00:35.960
to the developer workflow using this tool that you all built.


00:00:35.960 --> 00:00:38.240
Very happy to talk about that, something


00:00:38.240 --> 00:00:40.600
I've been very passionate about for a long time.


00:00:40.600 --> 00:00:42.760
Yeah, you've been working on this quite a long time,


00:00:42.760 --> 00:00:44.000
as we will see.


00:00:44.000 --> 00:00:46.100
But before we get into all the details there,


00:00:46.100 --> 00:00:47.300
let's start with your story.


00:00:47.300 --> 00:00:50.240
How'd you get into programming and Python?


00:00:50.240 --> 00:00:54.320
I love this question because I've


00:00:54.320 --> 00:00:57.960
been a software developer for 25 years or so.


00:00:57.960 --> 00:01:00.440
So I've been around for a while.


00:01:00.440 --> 00:01:01.280
But I first got--


00:01:01.280 --> 00:01:04.560
You and me both almost the same duration there.


00:01:04.560 --> 00:01:06.160
So we've seen some stuff.


00:01:06.160 --> 00:01:08.760
But I first got into computers when I was about 10 years old.


00:01:08.760 --> 00:01:13.240
And my uncle, who is a big gadget nut,


00:01:13.240 --> 00:01:15.640
bought a very, very early home computer.


00:01:15.640 --> 00:01:16.640
This was in the UK.


00:01:16.640 --> 00:01:20.160
So it was the Sinclair ZX80, if anyone's familiar with that.


00:01:20.160 --> 00:01:23.000
1K of RAM.


00:01:23.000 --> 00:01:25.360
you know, 16, you know, 8-bit machine.


00:01:25.360 --> 00:01:28.400
It was, I had just never seen anything like it,


00:01:28.400 --> 00:01:30.280
and I was instantly smitten by it


00:01:30.280 --> 00:01:32.360
and got really into it then.


00:01:32.360 --> 00:01:35.280
And at some point, got my own home computer,


00:01:35.280 --> 00:01:37.600
and at some point realized, oh, this is sort of a thing


00:01:37.600 --> 00:01:39.960
I want to do for the rest of my life.


00:01:39.960 --> 00:01:41.760
Now, granted, at that time, I also thought


00:01:41.760 --> 00:01:43.280
I would play with Legos for the rest of my life,


00:01:43.280 --> 00:01:45.360
so it's not like I'm always right about that,


00:01:45.360 --> 00:01:47.120
but in this case, I absolutely was.


00:01:47.120 --> 00:01:50.600
- It's pretty awesome that we get to do that, right?


00:01:50.600 --> 00:01:51.440
- Yeah. - You know, it's like,


00:01:51.440 --> 00:01:56.320
this is such a neat little project and I would just do this for fun but if people pay me I get


00:01:56.320 --> 00:02:02.400
to build even more ambitious things and a lot of times those are just the thoughts and dreams of


00:02:02.400 --> 00:02:07.360
kids who don't know better right just wait till you get get in the real world but as programmers


00:02:07.360 --> 00:02:11.520
that's not true like we get to do it all the time. It's absolutely unbelievable that your


00:02:11.520 --> 00:02:15.600
childhood hobby can become your grown-up profession if you have the right hobby.


00:02:15.600 --> 00:02:20.400
Yeah exactly it's important to pick good hobbies kids if you're out there listening and you haven't


00:02:20.400 --> 00:02:22.080
haven't picked a hobby yet and you're not there.


00:02:22.080 --> 00:02:23.280
Yeah, pick a good hobby.


00:02:23.280 --> 00:02:28.800
Just, you talked about the 1K of RAM and the retro thing.


00:02:28.800 --> 00:02:33.040
I just, I started working on this project last night.


00:02:33.040 --> 00:02:36.760
No, two days ago using CircuitPython.


00:02:36.760 --> 00:02:38.360
And for, what was that thing?


00:02:38.360 --> 00:02:42.280
$17, I got an ESP32 Feather,


00:02:42.280 --> 00:02:47.320
little microchip, has a wifi built in.


00:02:47.320 --> 00:02:49.760
It's got like a temperature sensor and all these things.


00:02:49.760 --> 00:02:53.200
and all you need to make it go is just plug in a USB-C.


00:02:53.200 --> 00:02:56.080
That thing is like a 240 megahertz,


00:02:56.080 --> 00:03:02.280
two megs of RAM, four megs of storage,


00:03:02.280 --> 00:03:05.480
which is not much at all, but like it fits,


00:03:05.480 --> 00:03:09.000
like it has two thirds of your hand.


00:03:09.000 --> 00:03:12.400
And it's unimaginably powerful compared to what


00:03:12.400 --> 00:03:14.900
the types of computers you were talking about, right?


00:03:14.900 --> 00:03:17.580
- Oh, that, as I said, 1K of RAM,


00:03:19.160 --> 00:03:23.400
It had the Zilog Z80 was the processor,


00:03:23.400 --> 00:03:27.160
which I believe was clocked at about four megahertz


00:03:27.160 --> 00:03:28.000
or something.


00:03:28.000 --> 00:03:30.240
It was, yeah.


00:03:30.240 --> 00:03:32.520
I mean, and at the time, you know, when you're a child,


00:03:32.520 --> 00:03:33.760
a million sounds like a lot.


00:03:33.760 --> 00:03:35.160
So I'm sort of, what do you mean megahertz?


00:03:35.160 --> 00:03:37.000
Like I can't count to a million.


00:03:37.000 --> 00:03:38.120
- Yeah, that's unbelievable.


00:03:38.120 --> 00:03:39.200
That's right.


00:03:39.200 --> 00:03:42.800
Yeah, and here we are well, well past the early Pentiums


00:03:42.800 --> 00:03:44.600
for $14, $17.


00:03:44.600 --> 00:03:47.520
Anyway, it's just, it's really interesting to think


00:03:47.520 --> 00:03:49.280
about the different types of computers


00:03:49.280 --> 00:03:50.580
that we have to work with.


00:03:50.580 --> 00:03:53.220
- Yeah. - And where we all start.


00:03:53.220 --> 00:03:55.160
The other thing I always find interesting


00:03:55.160 --> 00:03:59.240
is thinking back to early '90s, late '80s,


00:03:59.240 --> 00:04:01.720
those computers and their interfaces were so basic


00:04:01.720 --> 00:04:05.620
and yet the possibility that at least I experienced


00:04:05.620 --> 00:04:09.280
when I worked with them, it seemed so great and so amazing


00:04:09.280 --> 00:04:11.440
that even stuff today doesn't come close to where you're like


00:04:11.440 --> 00:04:14.460
I see where this is going, it's gonna be incredible.


00:04:14.460 --> 00:04:15.720
- There's definitely a joy.


00:04:15.720 --> 00:04:17.240
I mean, when you use the word basic,


00:04:17.240 --> 00:04:21.400
assuming in lowercase, but the interface to many of them was literally the language basic


00:04:21.400 --> 00:04:27.960
all uppercase. Or you could just write machine code directly. And those were your only two


00:04:27.960 --> 00:04:34.440
options, essentially. And so you were either, you know, 10 print your name, 20 go to 10, or


00:04:34.440 --> 00:04:42.840
you were messing around with registers. And once you learned how to do that, it was such a joy


00:04:42.840 --> 00:04:46.000
because you're essentially, you're


00:04:46.000 --> 00:04:47.960
melding with the hardware in some way.


00:04:47.960 --> 00:04:52.840
And it's, yeah, today, obviously, mostly for good,


00:04:52.840 --> 00:04:56.200
we are 19 layers removed from the hardware.


00:04:56.200 --> 00:04:58.360
And if you're going to be removed from the hardware,


00:04:58.360 --> 00:04:59.600
Python's a good way to do it.


00:04:59.600 --> 00:05:06.040
But yeah, definitely some joy has been lost.


00:05:06.040 --> 00:05:07.600
And replaced with other joys.


00:05:07.600 --> 00:05:09.480
Yeah, it's a new kind of joy.


00:05:09.480 --> 00:05:12.080
Now I pip install something in three lines.


00:05:12.080 --> 00:05:14.240
I have a cluster of servers at my command.


00:05:14.240 --> 00:05:16.740
It's a different kind of joy than working with registers.


00:05:16.740 --> 00:05:23.880
Indeed. All right, well, let's get into the main topic.


00:05:23.880 --> 00:05:27.560
Let's talk about Pants, this project that you all have created.


00:05:27.560 --> 00:05:34.520
Its role, as we stated briefly at the beginning,


00:05:34.520 --> 00:05:38.920
is really about helping orchestrate common tasks


00:05:38.920 --> 00:05:43.080
that we have to do to build and run and prepare software.


00:05:43.080 --> 00:05:46.120
And it's only getting more and more complex


00:05:46.120 --> 00:05:49.480
as I guess Python grows up, as you sort of put it,


00:05:49.480 --> 00:05:51.920
as we were chatting before I hit record.


00:05:51.920 --> 00:05:55.240
As Python grows up, as it's being used on larger projects,


00:05:55.240 --> 00:05:57.440
as it's being used across larger teams,


00:05:57.440 --> 00:06:02.440
the expectations of what it means to have a piece of software


00:06:02.440 --> 00:06:05.400
and run it is changing and evolving, right?


00:06:05.400 --> 00:06:08.360
So maybe we could just start by talking about


00:06:08.360 --> 00:06:13.240
some of the pain points of large software, scaling software, Python in particular?


00:06:13.240 --> 00:06:23.000
Sure. So an important piece of background here that I'm sure all the listeners will be familiar


00:06:23.000 --> 00:06:28.760
with is what has happened to Python in the last 10 to 15 years. I mean, I started programming in


00:06:28.760 --> 00:06:37.160
Python about 20 years ago on Python 2.2, and it was very much a sort of fancy bash at that point.


00:06:37.160 --> 00:06:41.800
It was just the language, the little bit of glue you used around the edges of your real code,


00:06:41.800 --> 00:06:48.440
which was written in C or whatever. And fast forward to today, and if you look at the process


00:06:48.440 --> 00:06:55.080
of particularly over the last 10 years, Python is this absolutely critical language that has


00:06:55.080 --> 00:07:02.600
grown up incredibly and is now being used to build large systems. It's being used as the


00:07:02.600 --> 00:07:07.000
language of choice for data science. It's being used as the language of choice for DevOps. It is


00:07:07.000 --> 00:07:14.520
an absolutely crucial language that large, growing, scalable code bases are increasingly


00:07:14.520 --> 00:07:16.120
being built out of.


00:07:16.120 --> 00:07:20.760
And that's, you know, presumably everyone listening is a fan of Python as I am, and


00:07:20.760 --> 00:07:24.000
so there are good reasons why this is the case.


00:07:24.000 --> 00:07:32.600
But we're still a little behind the curve on the tooling that you need to grow a Python


00:07:32.600 --> 00:07:33.800
code base.


00:07:33.800 --> 00:07:39.780
The standalone Python tooling, and there are so many great tools in that toolkit, they're


00:07:39.780 --> 00:07:48.920
pretty single use, and they tend to be designed to assume that you have a small, single use,


00:07:48.920 --> 00:07:53.560
standalone binary that's the only thing that your code base contains.


00:07:53.560 --> 00:07:58.520
But now increasingly, you have these large, growing code bases, sometimes referred to


00:07:58.520 --> 00:08:02.760
to as monorepos, where you have a lot of Python code,


00:08:02.760 --> 00:08:05.200
possibly code in other languages as well.


00:08:05.200 --> 00:08:07.660
You are trying to share code


00:08:07.660 --> 00:08:08.960
across a bunch of different projects


00:08:08.960 --> 00:08:10.200
and a bunch of different binaries.


00:08:10.200 --> 00:08:12.420
You have a lot of, you may be deploying


00:08:12.420 --> 00:08:13.400
out of a single code base.


00:08:13.400 --> 00:08:15.360
You want to deploy many microservices.


00:08:15.360 --> 00:08:18.200
You want to deploy AWS Lambdas.


00:08:18.200 --> 00:08:23.200
You want to deploy many different Docker images.


00:08:23.200 --> 00:08:27.960
You have this complexity that you need to manage.


00:08:27.960 --> 00:08:32.120
And so with other languages, there


00:08:32.120 --> 00:08:35.040
have been tools around to help you deal with this problem.


00:08:35.040 --> 00:08:38.800
Python, and for more contemporary languages,


00:08:38.800 --> 00:08:42.960
many of the solutions tend to come standard


00:08:42.960 --> 00:08:47.680
with that language's tool chain, such as Go just


00:08:47.680 --> 00:08:50.520
comes with a Swiss army knife, and Rust


00:08:50.520 --> 00:08:52.160
comes with a Swiss army knife.


00:08:52.160 --> 00:08:53.760
Python does not, for better or worse,


00:08:53.760 --> 00:08:54.960
come with a Swiss army knife.


00:08:54.960 --> 00:08:58.840
It comes with, you know, there are many, many blades out there.


00:08:58.840 --> 00:09:06.280
And Pants, particularly in its focus on Python, is designed to help you grow and scale that


00:09:06.280 --> 00:09:13.320
Python code base so that all of the steps you need to take to go from authoring some


00:09:13.320 --> 00:09:21.600
code to having it be validated, tested, checked, you know, have passed all its quality control


00:09:21.600 --> 00:09:29.880
checks and be ready to be deployed or used in production, rather than you manually having


00:09:29.880 --> 00:09:34.060
to figure out, well, which tools do I need to invoke in which order?


00:09:34.060 --> 00:09:36.600
How do I ensure that they are consistent?


00:09:36.600 --> 00:09:43.220
How do I do the least amount of work in the least amount of time that is necessary to


00:09:43.220 --> 00:09:45.260
assure those quality checks?


00:09:45.260 --> 00:09:49.440
That is all a very automatable problem, and that's essentially what Pants is.


00:09:49.440 --> 00:09:50.560
it can look at your code base,


00:09:50.560 --> 00:09:53.200
it can look at changes to your code base and say,


00:09:53.200 --> 00:09:54.680
oh, you want to run tests?


00:09:54.680 --> 00:09:56.520
Here's the actual work that needs to happen


00:09:56.520 --> 00:09:59.380
and here are the tools that need to be invoked.


00:09:59.380 --> 00:10:03.280
- Sure, so maybe you wanna run pytest, right?


00:10:03.280 --> 00:10:04.800
And as we'll learn,


00:10:04.800 --> 00:10:07.980
Pants has some great ways to speed up things


00:10:07.980 --> 00:10:09.720
like executing tests.


00:10:09.720 --> 00:10:12.160
Some of that's parallelism, some of that's going,


00:10:12.160 --> 00:10:13.240
you know what, we already did that work,


00:10:13.240 --> 00:10:15.440
nothing's changed, carry on.


00:10:15.440 --> 00:10:17.640
- Exactly.


00:10:18.600 --> 00:10:26.320
So Pants is essentially the layer between either you


00:10:26.320 --> 00:10:31.920
as a developer working on your laptop or your CI environment


00:10:31.920 --> 00:10:36.320
and the underlying tools of which there are so many.


00:10:36.320 --> 00:10:39.440
And Pants, I think, supports well over 20 Python tools,


00:10:39.440 --> 00:10:42.280
and it's fairly easy to add more.


00:10:42.280 --> 00:10:45.640
So for example, test being a very important example,


00:10:45.640 --> 00:10:49.200
you can say, hey, Pants, run all the tests on everything


00:10:49.200 --> 00:10:53.160
that is affected by my current set of changes.


00:10:53.160 --> 00:10:54.880
The system can look at your code,


00:10:54.880 --> 00:10:57.340
look at the dependencies, perform all this analysis,


00:10:57.340 --> 00:10:58.840
and say, well, that means I actually


00:10:58.840 --> 00:11:04.400
need to invoke pytest on these underlying tests.


00:11:04.400 --> 00:11:06.840
And if that means I need to first install


00:11:06.840 --> 00:11:10.200
pytest in a hermetic environment, I will do that.


00:11:10.200 --> 00:11:13.760
Pants also runs everything in these hermetic sandboxes,


00:11:13.760 --> 00:11:19.360
which means they neither consume nor create side effects,


00:11:19.360 --> 00:11:22.520
which means all of this work can be cached


00:11:22.520 --> 00:11:23.740
at a very fine-grained level.


00:11:23.740 --> 00:11:25.960
You can cache the result of an individual test.


00:11:25.960 --> 00:11:31.300
And you can apply concurrency at the level


00:11:31.300 --> 00:11:32.440
of an individual test.


00:11:32.440 --> 00:11:34.560
And so if you have eight cores on your machine,


00:11:34.560 --> 00:11:38.000
you can run eight tests at the same time.


00:11:38.000 --> 00:11:41.540
And you only need to run the ones whose inputs have changed,


00:11:41.540 --> 00:11:46.280
because everything else is cached, potentially.


00:11:46.280 --> 00:11:48.580
So that's the test example.


00:11:48.580 --> 00:11:50.580
Then you could look at another really important


00:11:50.580 --> 00:11:53.740
quality control check is linting and formatting.


00:11:53.740 --> 00:11:56.640
There are, I don't know, eight or 10 different linters


00:11:56.640 --> 00:11:58.060
and formatters for Python,


00:11:58.060 --> 00:12:01.580
and Pants can orchestrate them all in the right order.


00:12:01.580 --> 00:12:04.020
It understands the distinction between linters,


00:12:04.020 --> 00:12:05.780
which don't modify your source code


00:12:05.780 --> 00:12:07.800
so they can all run concurrently,


00:12:07.800 --> 00:12:10.820
and formatters, which do modify your code


00:12:10.820 --> 00:12:12.900
so they have to run sequentially.


00:12:12.900 --> 00:12:14.900
So it's a lot of, it's this layer between you


00:12:14.900 --> 00:12:17.340
that allows you to not worry about which tools do I need?


00:12:17.340 --> 00:12:18.700
How do I install them?


00:12:18.700 --> 00:12:19.980
How do I isolate them?


00:12:19.980 --> 00:12:21.340
How do I cache their results?


00:12:21.340 --> 00:12:23.860
How do I reason about concurrency


00:12:23.860 --> 00:12:25.180
and what can and can't be run together?


00:12:25.180 --> 00:12:26.820
It just takes that away from you.


00:12:26.820 --> 00:12:32.140
- One of the most powerful things for me personally,


00:12:32.140 --> 00:12:34.540
when I see all of this,


00:12:34.540 --> 00:12:37.020
how it brings all of these things together,


00:12:37.020 --> 00:12:39.300
is a lot of times, you're like,


00:12:39.300 --> 00:12:41.800
well, yeah, I should probably run the linter on that,


00:12:41.800 --> 00:12:43.940
but it's fine.


00:12:43.940 --> 00:12:49.360
Maybe I should run the tests, but I didn't change that much.


00:12:49.360 --> 00:12:51.020
I mean, it was only a couple of lines of code.


00:12:51.020 --> 00:12:54.180
I don't really, you know, like there's these different steps


00:12:54.180 --> 00:12:56.540
you gotta keep in mind and at each level,


00:12:56.540 --> 00:12:59.620
do I need to do this or do I need to remember to do it?


00:12:59.620 --> 00:13:03.860
Or is it justified to disrupt what I'm thinking about?


00:13:03.860 --> 00:13:08.260
And if it's just, you know, pants build or pants tests,


00:13:08.260 --> 00:13:12.740
and you don't have to worry about it and the system just does it all for you.


00:13:12.740 --> 00:13:20.900
At least personally, I am more willing to adopt more software engineering practices and guards


00:13:20.900 --> 00:13:25.460
on my code if it doesn't feel like I have to do them.


00:13:25.460 --> 00:13:28.420
You know what I mean? If I don't actually have to remember like,


00:13:28.420 --> 00:13:32.340
well, I was doing five steps and that was a lot, now I'm doing six and I'm really sick of these steps now.


00:13:32.340 --> 00:13:37.380
If it's the same number of steps and it's fast enough because of the caching and parallelism,


00:13:37.380 --> 00:13:43.780
then why not adopt it?


00:13:43.780 --> 00:13:45.380
Exactly, and I think an underappreciated


00:13:45.380 --> 00:13:47.380
complication is when it's not an


00:13:47.380 --> 00:13:49.060
individual adopting it but a team.


00:13:49.060 --> 00:13:50.820
So a team wants to assume some best


00:13:50.820 --> 00:13:52.420
practices but now


00:13:52.420 --> 00:13:54.580
everyone on your you want to adopt a new


00:13:54.580 --> 00:13:56.500
linter or a new


00:13:56.500 --> 00:13:58.900
quality control check of any kind,


00:13:58.900 --> 00:14:00.900
that's more cognitive


00:14:00.900 --> 00:14:02.420
load on behalf of, you know, now what you


00:14:02.420 --> 00:14:03.860
do, do you send an email to everyone on


00:14:03.860 --> 00:14:05.860
the team saying, well now you have to


00:14:03.860 --> 00:14:09.780
to run this as well, you can set up your existing build layer,


00:14:09.780 --> 00:14:13.100
Pants in this case, to apply that new linter,


00:14:13.100 --> 00:14:14.340
and it just happens.


00:14:14.340 --> 00:14:16.900
Nobody has to change their workflow.


00:14:16.900 --> 00:14:19.700
Where we want to get to is essentially--


00:14:19.700 --> 00:14:21.980
and we're, in many cases, very close to this--


00:14:21.980 --> 00:14:27.620
is you run a single command.


00:14:27.620 --> 00:14:32.340
As a developer, you run that same single command in CI,


00:14:32.340 --> 00:14:35.140
And the right thing just magically happens.


00:14:35.140 --> 00:14:37.380
And the ability to do the right thing magically


00:14:37.380 --> 00:14:40.820
depends on the ability to do dependency analysis,


00:14:40.820 --> 00:14:42.460
to build a fine-grained workflow,


00:14:42.460 --> 00:14:45.220
to apply concurrency and caching to it.


00:14:45.220 --> 00:14:48.180
And as I think we'll get to maybe later,


00:14:48.180 --> 00:14:53.300
even not just concurrency and caching on your machine,


00:14:53.300 --> 00:14:56.580
but remote execution in a cluster


00:14:56.580 --> 00:15:01.900
and shared remote caching so that work is being shared.


00:15:01.900 --> 00:15:03.660
It's not just past work that you have done,


00:15:03.660 --> 00:15:07.820
but past work that anyone individually or in CI has done.


00:15:07.820 --> 00:15:09.620
- Yeah, that's fantastic.


00:15:09.620 --> 00:15:11.420
And if you've got a large code base,


00:15:11.420 --> 00:15:14.340
that starts to pay off, yeah.


00:15:14.340 --> 00:15:15.180
- Yeah.


00:15:15.180 --> 00:15:19.180
- I wanna talk to you about monorepos,


00:15:19.180 --> 00:15:20.860
but before we get to there,


00:15:20.860 --> 00:15:22.740
maybe you could just give a quick shout out


00:15:22.740 --> 00:15:24.940
about some of the language support.


00:15:24.940 --> 00:15:28.180
I mean, obviously we're talking about Python tools


00:15:28.180 --> 00:15:29.460
for Python code bases


00:15:29.460 --> 00:15:31.740
for Python developers and data scientists,


00:15:31.740 --> 00:15:37.020
But we might also live in multilingual heterogeneous


00:15:37.020 --> 00:15:39.500
environments at work and on our projects.


00:15:39.500 --> 00:15:43.460
And we might have some Kotlin for our mobile app


00:15:43.460 --> 00:15:48.380
and our Python for our APIs or something like that.


00:15:48.380 --> 00:15:52.640
So yes, Pants is not a Python-only tool,


00:15:52.640 --> 00:15:56.300
but it is a Python-first or Python-centric tool


00:15:56.300 --> 00:16:00.060
in that there is a long history to the project.


00:16:00.060 --> 00:16:01.860
but the current iteration of Pants,


00:16:01.860 --> 00:16:05.060
which we very unimaginatively called Pants v2,


00:16:05.060 --> 00:16:07.020
'cause we're not great at naming,


00:16:07.020 --> 00:16:09.780
it launched almost exactly two years ago,


00:16:09.780 --> 00:16:10.980
two years ago at the end of the month,


00:16:10.980 --> 00:16:14.500
and with just support for just Python.


00:16:14.500 --> 00:16:16.820
And since then, we've added support for Go,


00:16:16.820 --> 00:16:21.180
for Java, for Scala, for Kotlin, for Shell.


00:16:21.180 --> 00:16:23.540
The next thing we're looking at very closely,


00:16:23.540 --> 00:16:25.580
obviously, is JavaScript and TypeScript.


00:16:25.580 --> 00:16:26.820
Can't ignore those.


00:16:29.620 --> 00:16:34.460
But one of the things that makes Pants stand out--


00:16:34.460 --> 00:16:36.940
and the P in the name is no accident--


00:16:36.940 --> 00:16:42.500
is the recognition that Python is no longer this third cousin


00:16:42.500 --> 00:16:45.540
that you put at the end of the list of languages to deal with.


00:16:45.540 --> 00:16:46.920
And it's sort of an afterthought,


00:16:46.920 --> 00:16:49.260
but really this thing is designed for Java.


00:16:49.260 --> 00:16:52.220
It was really part of the big driving use cases.


00:16:52.220 --> 00:16:54.940
But if you have many languages in your repo,


00:16:54.940 --> 00:16:57.300
or if you have no Python at all in your repo,


00:16:57.300 --> 00:16:59.740
Pants is still a useful tool for you


00:16:59.740 --> 00:17:02.660
because you still get the benefit of all the analysis


00:17:02.660 --> 00:17:04.260
that it does on your behalf.


00:17:04.260 --> 00:17:10.020
- Indeed, and people will see that pants is written


00:17:10.020 --> 00:17:13.060
sort of top layer in Python and lower layer in Rust


00:17:13.060 --> 00:17:15.620
and the extensibility layers in Python.


00:17:15.620 --> 00:17:18.740
So there's a lot of Python first, as you say there.


00:17:18.740 --> 00:17:20.540
But I did wanna call out,


00:17:20.540 --> 00:17:23.260
it does work on these other languages.


00:17:23.260 --> 00:17:26.620
So if you're trying to adopt some kind of automation


00:17:26.620 --> 00:17:28.120
that involves multiple languages,


00:17:28.120 --> 00:17:30.200
this might work for you.


00:17:30.200 --> 00:17:35.100
>> Yep, and we are always interested in people


00:17:35.100 --> 00:17:38.700
who have opinions about what the next languages we should support


00:17:38.700 --> 00:17:39.200
should be.


00:17:39.200 --> 00:17:40.720
Obviously, as I said, JavaScript, TypeScript,


00:17:40.720 --> 00:17:41.820
very high on the list.


00:17:41.820 --> 00:17:43.400
I suspect Rust is very high on the list,


00:17:43.400 --> 00:17:47.720
partly because we use it and partly because it is very up


00:17:47.720 --> 00:17:50.040
and coming and for very good reasons.


00:17:50.040 --> 00:17:51.380
>> Yeah.


00:17:51.380 --> 00:17:55.340
I mean, all developer tools kind of come of age


00:17:55.340 --> 00:17:58.180
when they can make themselves.


00:17:58.180 --> 00:17:59.020
(laughs)


00:17:59.020 --> 00:18:01.300
You know, like they're now fully independent


00:18:01.300 --> 00:18:04.980
where a language or a tool builds its own self


00:18:04.980 --> 00:18:06.500
with its own features.


00:18:06.500 --> 00:18:09.140
So yeah, if you could do that for Rust,


00:18:09.140 --> 00:18:12.140
then it can kind of be a part of that group.


00:18:12.140 --> 00:18:14.220
- Yep.


00:18:14.220 --> 00:18:16.820
Self-hosting is a major milestone


00:18:16.820 --> 00:18:19.740
in any sort of build type project.


00:18:19.740 --> 00:18:20.580
- Indeed.


00:18:20.580 --> 00:18:21.900
All right, quick question from the audience.


00:18:21.900 --> 00:18:23.180
Mustafa out there says,


00:18:23.180 --> 00:18:25.780
How does Pants handle bulk publishing of packages,


00:18:25.780 --> 00:18:27.580
where I might have a set of preconditions


00:18:27.580 --> 00:18:29.980
to auto-publish it, intervals of all package


00:18:29.980 --> 00:18:34.820
that meet those conditions, or something along those lines?


00:18:34.820 --> 00:18:36.100
So great question.


00:18:36.100 --> 00:18:38.020
So Pants has, I should mention, there


00:18:38.020 --> 00:18:40.780
are many different types of deployable that it can build.


00:18:40.780 --> 00:18:46.700
I mentioned AWS Lambda or Google Cloud Functions.


00:18:46.700 --> 00:18:50.020
Or we have a format that's specifically


00:18:50.020 --> 00:18:51.340
of interest to Python users called


00:18:51.340 --> 00:18:56.540
PEX, which stands for Python Executable, and it's basically a single file that contains


00:18:56.540 --> 00:19:02.220
your Python code and all of its transitive dependencies. So it is ready to run as long


00:19:02.220 --> 00:19:06.540
as there's a Python interpreter on the system you run it on, and it even knows how to find


00:19:06.540 --> 00:19:09.580
that interpreter. But I think what the question was about...


00:19:09.580 --> 00:19:10.860
PEX came from you guys.


00:19:10.860 --> 00:19:11.820
Yes.


00:19:11.820 --> 00:19:16.940
I had no idea. I mean, I've heard of PEX, but I didn't associate it with PANs. That's cool.


00:19:16.940 --> 00:19:22.060
Yeah, I mean, other systems can also build PECs, and PECs has a standalone command line tool that


00:19:22.060 --> 00:19:31.260
you can use to build PECs, but PANCE is the sort of home base of PECs. But I think the question


00:19:31.260 --> 00:19:39.980
was about building and publishing Python distributions, for example, to PyPI, which


00:19:39.980 --> 00:19:46.780
PANCE can obviously do. And I'm not 100% sure I'm answering the question appropriately, but I


00:19:46.780 --> 00:19:50.140
I think one of the ways that Pants can help you here


00:19:50.140 --> 00:19:55.820
is it knows when code has changed.


00:19:55.820 --> 00:19:58.400
So if you're publishing a large number of packages


00:19:58.400 --> 00:20:06.300
from your repo, it can do the math of--


00:20:06.300 --> 00:20:09.340
here are the-- by tracking dependencies,


00:20:09.340 --> 00:20:12.900
it can do the math to say, based on the changes


00:20:12.900 --> 00:20:14.780
since the last time this thing was published,


00:20:14.780 --> 00:20:18.500
now has changed and needs to be republished.


00:20:18.500 --> 00:20:21.340
So it can give you a lot of that logic.


00:20:21.340 --> 00:20:24.980
When it comes to auto-publishing at intervals,


00:20:24.980 --> 00:20:27.060
I guess I would say Pants can tell you


00:20:27.060 --> 00:20:30.660
whether it meets the conditions based on dependency analysis,


00:20:30.660 --> 00:20:32.500
et cetera.


00:20:32.500 --> 00:20:36.700
There is no auto-publishing, per se.


00:20:36.700 --> 00:20:38.900
Pants is a tool you have to invoke.


00:20:38.900 --> 00:20:43.140
So you could cron around it or something like that.


00:20:43.140 --> 00:20:43.980
- Yeah, cool.


00:20:43.980 --> 00:20:48.220
You mentioned monorepos.


00:20:48.220 --> 00:20:50.800
Now, you also mentioned sharing code.


00:20:50.800 --> 00:20:56.620
If I've got, say, some SQL model definitions


00:20:56.620 --> 00:20:59.500
that point at what my database looks like,


00:20:59.500 --> 00:21:03.300
well, my API code probably needs access


00:21:03.300 --> 00:21:04.780
to the right version of those,


00:21:04.780 --> 00:21:07.800
but so do my data scientists for their library


00:21:07.800 --> 00:21:09.980
that talks using SQL model


00:21:09.980 --> 00:21:12.180
to get the data into their notebooks.


00:21:12.180 --> 00:21:15.620
And if those things get out of sync, as we know,


00:21:15.620 --> 00:21:18.620
SQLAlchemy will go bonkers and say,


00:21:18.620 --> 00:21:21.900
you're missing a column here, done, crash, right?


00:21:21.900 --> 00:21:23.980
And so keeping that stuff in sync


00:21:23.980 --> 00:21:27.500
across these different projects can be challenging.


00:21:27.500 --> 00:21:30.620
Is that the idea behind these monorepos?


00:21:30.620 --> 00:21:33.660
- Yes, that's one of the reasons


00:21:33.660 --> 00:21:36.340
why they are increasing in popularity.


00:21:36.340 --> 00:21:41.300
So the problem is, as your codebase grows,


00:21:41.300 --> 00:21:43.060
When your code base is small, there are no problems.


00:21:43.060 --> 00:21:47.620
And as your code base grows, you're faced with kind of two,


00:21:47.620 --> 00:21:49.460
you're faced with a decision on how to manage that.


00:21:49.460 --> 00:21:50.940
One is to keep breaking it up


00:21:50.940 --> 00:21:55.140
into multiple smaller repos, essentially.


00:21:55.140 --> 00:21:57.780
Each one with their own build and their own practices.


00:21:57.780 --> 00:21:59.860
And the way you consume code across them


00:21:59.860 --> 00:22:02.900
is through publishing, through version publishing.


00:22:02.900 --> 00:22:04.260
And we can--


00:22:04.260 --> 00:22:07.260
- Maybe you make your SQL models a data package


00:22:07.260 --> 00:22:09.340
and you publish it to an internal pipe BI


00:22:09.340 --> 00:22:11.740
and everyone consumes it, and they pin their versions


00:22:11.740 --> 00:22:12.860
just like--


00:22:12.860 --> 00:22:13.460
>>Exactly.


00:22:13.460 --> 00:22:15.980
So the problem with that is that there


00:22:15.980 --> 00:22:18.340
are several problems with it, but a big one is that you're


00:22:18.340 --> 00:22:21.020
inviting the famous dependency hell problem, which


00:22:21.020 --> 00:22:24.220
is already bad enough with third party requirements,


00:22:24.220 --> 00:22:26.620
into your first party code.


00:22:26.620 --> 00:22:32.300
So the problem is when you make changes to a library,


00:22:32.300 --> 00:22:35.100
you have no way of knowing who is consuming you upstream


00:22:35.100 --> 00:22:39.220
from you, and therefore what changes they might need.


00:22:39.220 --> 00:22:41.080
Now, you might say, well, not my problem


00:22:41.080 --> 00:22:43.160
because everything is supposed to be versioned.


00:22:43.160 --> 00:22:45.000
But that breaks as soon as anyone


00:22:45.000 --> 00:22:46.800
needs to upgrade anything, because now they


00:22:46.800 --> 00:22:50.240
have this horrific upgrade problem that


00:22:50.240 --> 00:22:52.300
is happening potentially weeks or months


00:22:52.300 --> 00:22:55.840
after the changes that are breaking them have happened.


00:22:55.840 --> 00:22:59.800
So you're kind of pushing the problem off.


00:22:59.800 --> 00:23:03.520
Where a monorepo is helpful is that you


00:23:03.520 --> 00:23:08.420
get this visibility into all of the upstream dependencies.


00:23:08.420 --> 00:23:12.980
Essentially, if all the tests in the monorepo pass,


00:23:12.980 --> 00:23:16.620
you know that your changes have not broken your coworkers.


00:23:16.620 --> 00:23:22.460
You know that you can use in-repo tools like git grep


00:23:22.460 --> 00:23:27.420
to find or any kind of discovery tools and dependency analysis


00:23:27.420 --> 00:23:30.020
that tools like Pats offer within the repo


00:23:30.020 --> 00:23:32.260
to find out the impact of your changes.


00:23:32.260 --> 00:23:36.340
And this is why monorepos are increasingly popular


00:23:36.340 --> 00:23:40.740
And it's not to say that because a bunch of other companies


00:23:40.740 --> 00:23:41.900
are doing it, you should be doing it.


00:23:41.900 --> 00:23:46.380
But it is instructive to note that Google and Facebook


00:23:46.380 --> 00:23:50.260
and Twitter and a lot of successful companies


00:23:50.260 --> 00:23:52.980
have gone in that direction, or in Google's case,


00:23:52.980 --> 00:23:55.380
started out in that direction.


00:23:55.380 --> 00:23:57.900
And it has to be said that with monorepos or without,


00:23:57.900 --> 00:24:00.660
you need appropriate tooling.


00:24:00.660 --> 00:24:03.460
So at some point, you have to pick your poison.


00:24:03.460 --> 00:24:06.820
But the reason I am biased towards monorepos,


00:24:06.820 --> 00:24:10.180
having worked at companies that have had one unified codebase


00:24:10.180 --> 00:24:13.100
and companies that have had a very fragmented codebase,


00:24:13.100 --> 00:24:15.540
is that the structure of your codebase


00:24:15.540 --> 00:24:18.820
tends to recapitulate the cohesion and structure


00:24:18.820 --> 00:24:20.580
of your organization itself.


00:24:20.580 --> 00:24:21.940
And if everybody is collaborating


00:24:21.940 --> 00:24:25.460
on a single large repo, within reason,


00:24:25.460 --> 00:24:29.260
you don't necessarily need to have literally one


00:24:29.260 --> 00:24:30.580
repo for the entire company.


00:24:30.580 --> 00:24:33.480
but a small number of large repos with boundaries


00:24:33.480 --> 00:24:34.720
between them that makes sense


00:24:34.720 --> 00:24:38.160
because they don't mutually depend on each other, let's say,


00:24:38.160 --> 00:24:42.880
then that mutuality and that sharing of code


00:24:42.880 --> 00:24:45.280
creates more cohesion at the organizational level.


00:24:45.280 --> 00:24:47.320
And when you have a very fragmented code base,


00:24:47.320 --> 00:24:49.400
you tend to have a fragmented organization.


00:24:49.400 --> 00:24:54.080
Now your organization resembles a loose collection


00:24:54.080 --> 00:24:57.880
of warring tribes more than a single unified organization.


00:24:57.880 --> 00:25:01.400
So I am biased towards monorepos.


00:25:01.400 --> 00:25:05.280
And while you can use PANs very effectively in even


00:25:05.280 --> 00:25:07.480
multiple smaller repos, I do think


00:25:07.480 --> 00:25:12.480
it supports the monorepo architecture really well.


00:25:12.480 --> 00:25:14.140
And the last thing I would say about this


00:25:14.140 --> 00:25:16.600
is just to really clarify, because we get a lot of questions


00:25:16.600 --> 00:25:17.760
about this.


00:25:17.760 --> 00:25:20.000
Monorepo is about your repo architecture,


00:25:20.000 --> 00:25:22.360
nothing to do with your deployment architecture.


00:25:22.360 --> 00:25:26.880
So it is not the opposite of microservices.


00:25:26.880 --> 00:25:29.740
For example, if you have many microservices,


00:25:29.740 --> 00:25:31.640
you probably want them to be in a single repo


00:25:31.640 --> 00:25:35.120
because they share, as you said, data models, they share code,


00:25:35.120 --> 00:25:38.920
and it is actually easier to deploy many microservices out


00:25:38.920 --> 00:25:42.640
of a single repo than constantly creating new teeny repos


00:25:42.640 --> 00:25:45.480
and having to go through the whole publish and consume


00:25:45.480 --> 00:25:50.600
dance every time you want to publish a microservice.


00:25:50.600 --> 00:25:53.000
And so publishing many microservices


00:25:53.000 --> 00:25:55.260
out of a single monolithic repo is actually


00:25:55.260 --> 00:26:01.740
a common pattern and a very effective one, in my opinion.


00:26:01.740 --> 00:26:05.180
>> Yeah, I guess if you have a monolith where the code is


00:26:05.180 --> 00:26:08.700
architectured into one giant thing,


00:26:08.700 --> 00:26:10.660
it necessarily means that you're probably just


00:26:10.660 --> 00:26:11.820
going to have it in one repo.


00:26:11.820 --> 00:26:14.500
But if it's microservices, there may be this temptation


00:26:14.500 --> 00:26:17.420
to have, well, we've got 10 microservices,


00:26:17.420 --> 00:26:19.060
so we've got 20 repos because here's


00:26:19.060 --> 00:26:21.300
each one for the service, and then the shared bits got


00:26:21.300 --> 00:26:23.660
to be broken out into their own so they can be reused.


00:26:23.660 --> 00:26:25.260
and--


00:26:25.260 --> 00:26:27.260
>> Yes.


00:26:27.260 --> 00:26:30.380
Just essentially, in a monorepo, you


00:26:30.380 --> 00:26:33.980
get a much tighter development loop


00:26:33.980 --> 00:26:36.540
because you are cutting out all of the publishing.


00:26:36.540 --> 00:26:38.180
Everything is consuming.


00:26:38.180 --> 00:26:40.500
All the inner code-based consumption


00:26:40.500 --> 00:26:42.700
is happening at head.


00:26:42.700 --> 00:26:44.540
So you don't have this constant publishing.


00:26:44.540 --> 00:26:46.060
>> Yeah, it's super interesting.


00:26:46.060 --> 00:26:47.820
I hadn't really thought about it that way.


00:26:47.820 --> 00:26:51.780
But a lot of the tools, the really good tools that we have,


00:26:51.780 --> 00:26:53.260
things like PyCharm and stuff, we


00:26:53.260 --> 00:26:57.580
we can open them up and go to a function or a variable or a class and right click and say,


00:26:57.580 --> 00:26:59.580
"Show me all the uses of this."


00:26:59.580 --> 00:27:04.140
But if there's a bunch of different consumers of your library, well, you don't really know


00:27:04.140 --> 00:27:07.820
because anybody could be grabbing something and using it.


00:27:07.820 --> 00:27:11.820
But if you go to a repo and it says, "No usage is found," well, that means more.


00:27:11.820 --> 00:27:18.220
Exactly. The consumption metadata on published artifacts goes the wrong way.


00:27:18.220 --> 00:27:23.220
It says that the metadata that gets published with the wheel


00:27:23.220 --> 00:27:25.220
says here is what this wheel consumes,


00:27:25.220 --> 00:27:27.220
but it has no idea who consumes it.


00:27:27.220 --> 00:27:30.220
And so if you want to figure that out,


00:27:30.220 --> 00:27:32.220
now you need a whole bunch of tooling.


00:27:32.220 --> 00:27:36.220
So why not just cut that out entirely?


00:27:36.220 --> 00:27:38.220
Yeah, and you get things like refactor, rename,


00:27:38.220 --> 00:27:43.220
or to cross the whole company sort of in interesting ways as well.


00:27:43.220 --> 00:27:45.220
Okay, cool.


00:27:45.220 --> 00:27:52.220
Maybe we should touch a little bit on the history of Pants.


00:27:52.220 --> 00:27:57.220
I know Pants 1.0 has been around for a long time,


00:27:57.220 --> 00:27:59.220
and then there's this 2.0 version.


00:27:59.220 --> 00:28:03.220
Do you want to tell people a bit about the changes there?


00:28:03.220 --> 00:28:05.220
They maybe have experienced it a while ago.


00:28:05.220 --> 00:28:06.220
Sure thing.


00:28:06.220 --> 00:28:09.220
So Pants, what we now refer to as Pants V1,


00:28:09.220 --> 00:28:13.220
was a project that started as an internal project at Twitter,


00:28:13.220 --> 00:28:16.060
and it was focused primarily on Scala


00:28:16.060 --> 00:28:19.220
and how can we speed up Scala builds


00:28:19.220 --> 00:28:22.460
and make them more organized and more tractable.


00:28:22.460 --> 00:28:25.720
It then got open sourced out of Twitter


00:28:25.720 --> 00:28:29.180
and was used at a handful of other Scala using companies,


00:28:29.180 --> 00:28:30.720
notably Foursquare.


00:28:30.720 --> 00:28:34.180
Square used it as well.


00:28:34.180 --> 00:28:36.460
There were a few companies of that vintage


00:28:36.460 --> 00:28:38.960
of early 2010s Silicon Valley startups


00:28:38.960 --> 00:28:40.720
that were using Scala in a big way.


00:28:42.300 --> 00:28:46.180
That, V1 is basically gone at this point.


00:28:46.180 --> 00:28:48.840
I think there's a handful of organizations still maybe using it.


00:28:48.840 --> 00:28:50.940
We're desperately trying to get them onto V2.


00:28:50.940 --> 00:28:55.120
The Pants V2 is a thing that we launched two years ago.


00:28:55.120 --> 00:28:59.420
There's a complete ground up re-implementation.


00:28:59.420 --> 00:29:03.460
It really only shares a name with the old,


00:29:03.460 --> 00:29:08.700
and a sort of project home with the old one.


00:29:08.700 --> 00:29:10.060
The code is entirely new.


00:29:10.060 --> 00:29:14.060
as you alluded to earlier, one of the big differences in the implementation


00:29:14.060 --> 00:29:19.340
is that the execution engine in v2 is written in Rust,


00:29:19.340 --> 00:29:25.420
and the APIs are async Python 3. But that is an important difference, but


00:29:25.420 --> 00:29:28.860
the bigger difference is the design itself is a very


00:29:28.860 --> 00:29:34.940
different in the v2 system. Learned a lot from our experience with


00:29:34.940 --> 00:29:39.420
v1, both in terms of the implementation and


00:29:39.420 --> 00:29:45.340
how to make important features like caching and concurrency


00:29:45.340 --> 00:29:47.340
just fall out of the design rather than be


00:29:47.340 --> 00:29:52.660
this laborious thing you have to add at every corner.


00:29:52.660 --> 00:29:55.480
And also, an equally important lesson


00:29:55.480 --> 00:29:59.580
was, unlike many other systems, including PANSv1, which


00:29:59.580 --> 00:30:01.980
came out of a single company and were really tailored


00:30:01.980 --> 00:30:05.000
for that company's use cases, with v2,


00:30:05.000 --> 00:30:07.080
we wanted to build something that was for everyone,


00:30:07.080 --> 00:30:10.680
like any organization, large or small, could use and get.


00:30:10.680 --> 00:30:13.760
You shouldn't have to work at Microsoft or Google or Twitter


00:30:13.760 --> 00:30:17.160
to get this quality of build experience.


00:30:17.160 --> 00:30:18.600
Anyone should be able to.


00:30:18.600 --> 00:30:20.440
And that required looking at the use cases


00:30:20.440 --> 00:30:23.440
of a lot of organizations of different languages


00:30:23.440 --> 00:30:25.040
and different sizes.


00:30:25.040 --> 00:30:27.700
And one thing we learned was nobody wants to write


00:30:27.700 --> 00:30:28.980
a ton of build metadata.


00:30:28.980 --> 00:30:32.680
If anyone's used a system like Pants v1 or Bazel or Buck


00:30:32.680 --> 00:30:36.400
or something similar, you start by


00:30:36.400 --> 00:30:38.100
potentially refactoring your code base


00:30:38.100 --> 00:30:40.100
to be what the system expects.


00:30:40.100 --> 00:30:41.980
And then you write thousands and thousands


00:30:41.980 --> 00:30:44.980
of lines of what's so-called build files.


00:30:44.980 --> 00:30:46.780
We wanted to eliminate all of that.


00:30:46.780 --> 00:30:50.620
And so the system is designed to accept your code base as it is.


00:30:50.620 --> 00:30:53.780
And it doesn't require huge amounts of build metadata.


00:30:53.780 --> 00:30:56.620
It requires small amounts that it can mostly generate.


00:30:56.620 --> 00:30:59.660
But the important information, which is the dependencies,


00:30:59.660 --> 00:31:02.180
it actually infers at runtime by looking


00:31:02.180 --> 00:31:08.020
import statements and various other tricks and heuristics for figuring out what your code's


00:31:08.020 --> 00:31:12.340
actual dependencies are. So that saves a huge amount of time and makes it a lot easier to use


00:31:12.340 --> 00:31:18.100
and a lot easier to adopt. So that's kind of why v2 came about. We wanted to build something that


00:31:18.100 --> 00:31:22.340
wasn't like, "Here's something we built for Twitter, throw it over the wall and you can use it if you


00:31:22.340 --> 00:31:26.900
want to, but here's a thing that was designed for you, designed for Python, designed to be easy to


00:31:26.900 --> 00:31:28.740
to adopt, designed to be easy to use,


00:31:28.740 --> 00:31:35.340
designed to be easy to extend, has a robust API that


00:31:35.340 --> 00:31:37.740
is async Python 3, essentially.


00:31:37.740 --> 00:31:41.260
And that's where that project came from.


00:31:41.260 --> 00:31:46.540
Yeah, it's really interesting how


00:31:46.540 --> 00:31:48.940
it came from this big tech side of things.


00:31:48.940 --> 00:31:51.860
But second take, it's like, well,


00:31:51.860 --> 00:31:55.700
how do we just make this for all the projects, not just


00:31:55.700 --> 00:31:57.140
of the large ones.


00:31:57.140 --> 00:32:00.320
You know, there's that interesting article


00:32:00.320 --> 00:32:02.840
and it's quoted in various forms a lot.


00:32:02.840 --> 00:32:04.960
Like, you're not Facebook, you're not Google,


00:32:04.960 --> 00:32:06.040
you're not LinkedIn.


00:32:06.040 --> 00:32:08.680
Speaking to most people, right?


00:32:08.680 --> 00:32:11.080
I mean, there are people who actually are there,


00:32:11.080 --> 00:32:13.380
but like for most people who look at these architectures


00:32:13.380 --> 00:32:14.960
and what's happening, they may,


00:32:14.960 --> 00:32:16.600
oh, look how they're scaling this.


00:32:16.600 --> 00:32:18.740
And like, yeah, but you just have a hundred users.


00:32:18.740 --> 00:32:21.380
You don't need to like go to that much architecture


00:32:21.380 --> 00:32:24.540
and crazy designs for what you're doing.


00:32:24.540 --> 00:32:33.380
And so I can see how it would be a temptation to have an overly complicated system that


00:32:33.380 --> 00:32:34.380
comes along.


00:32:34.380 --> 00:32:37.300
But it looks to me like this is really easy to adopt.


00:32:37.300 --> 00:32:40.780
It is significantly easier.


00:32:40.780 --> 00:32:43.940
And we are constantly working on automating the adoption.


00:32:43.940 --> 00:32:49.620
There is a one of the commands in Pants, this is the only Pants-related pun we've allowed


00:32:49.620 --> 00:32:56.100
ourselves in the system is called "tailor" because it "tailors" your metadata. It essentially generates,


00:32:56.100 --> 00:33:01.860
it does inspection of your code and generates a bunch of metadata, not including dependencies.


00:33:01.860 --> 00:33:07.220
Those, as I mentioned, are inferred at runtime, but this is kind of a thing you run periodically


00:33:07.220 --> 00:33:13.140
because this is metadata that you may want to manually tweak. And so we're constantly working


00:33:13.140 --> 00:33:18.580
on making that easier and easier to adopt for real-world cases. So just one obvious example is


00:33:18.580 --> 00:33:21.580
Many repos have dependency tangles


00:33:21.580 --> 00:33:23.460
and circular dependencies.


00:33:23.460 --> 00:33:25.860
And Pants v2 can handle that.


00:33:25.860 --> 00:33:29.620
Those other systems cannot, including Pants v1.


00:33:29.620 --> 00:33:31.340
And those other systems were not really


00:33:31.340 --> 00:33:32.980
designed for easy adoption because they


00:33:32.980 --> 00:33:34.780
didn't need to be, because they were only


00:33:34.780 --> 00:33:37.820
designed to be adopted once by a captive audience of all


00:33:37.820 --> 00:33:41.060
the developers at that company.


00:33:41.060 --> 00:33:43.620
We want this to be adopted thousands of times


00:33:43.620 --> 00:33:45.060
by thousands of organizations.


00:33:45.060 --> 00:33:47.820
So we want it to be much, much easier.


00:33:47.820 --> 00:33:49.860
- Yeah, fantastic.


00:33:49.860 --> 00:33:52.620
You talked about some of the tools that you could use.


00:33:52.620 --> 00:33:54.180
Maybe we could go through that list


00:33:54.180 --> 00:33:56.060
of common tools real quickly


00:33:56.060 --> 00:33:58.300
and you could just give us your thoughts


00:33:58.300 --> 00:33:59.220
on why you think it's great


00:33:59.220 --> 00:34:00.880
and why you might want to adopt it,


00:34:00.880 --> 00:34:02.580
make it part of your flow,


00:34:02.580 --> 00:34:06.320
because with Pants, you don't have to add more steps,


00:34:06.320 --> 00:34:07.220
as we said.


00:34:07.220 --> 00:34:10.820
So some of the tools you've called out are mypy.


00:34:10.820 --> 00:34:14.460
I know you're a fan of Python 3 and Pype annotations.


00:34:14.460 --> 00:34:15.540
- Oh yeah.


00:34:15.540 --> 00:34:17.200
- Tell people quick about mypy.


00:34:17.200 --> 00:34:18.320
So for those who aren't familiar,


00:34:18.320 --> 00:34:23.320
mypy brings a level of rigor to your Python quality control


00:34:23.320 --> 00:34:26.080
that is fantastic.


00:34:26.080 --> 00:34:28.960
Essentially, you add type annotations


00:34:28.960 --> 00:34:30.640
to your Python 3 code,


00:34:30.640 --> 00:34:34.040
and mypy performs static type checking,


00:34:34.040 --> 00:34:37.080
and is absolutely tremendous.


00:34:37.080 --> 00:34:41.160
It is essentially a sort of compilation step for Python.


00:34:41.160 --> 00:34:43.760
It's not actually generating code,


00:34:43.760 --> 00:34:46.120
but it is performing type checks


00:34:46.120 --> 00:34:49.120
that finds a wide variety of bugs and issues.


00:34:49.120 --> 00:34:52.260
And I would never go back to non-type checked Python.


00:34:52.260 --> 00:34:55.600
- Interesting, yeah, so it's like,


00:34:55.600 --> 00:34:58.720
if I were to compile it, what would happen?


00:34:58.720 --> 00:34:59.680
We're not actually going to,


00:34:59.680 --> 00:35:02.160
but let's go through that and give you a report,


00:35:02.160 --> 00:35:03.840
like sort of print out the warnings and errors


00:35:03.840 --> 00:35:06.360
that you would have seen in a compiled language,


00:35:06.360 --> 00:35:08.400
and then we'll carry on.


00:35:08.400 --> 00:35:11.840
You know, a common way these things are referred to


00:35:11.840 --> 00:35:13.240
in Python is type hints,


00:35:13.240 --> 00:35:15.920
which kind of implies they have no effect.


00:35:15.920 --> 00:35:18.540
But with mypy, it's a little bit closer, right?


00:35:18.540 --> 00:35:20.820
>>Right. So they have no runtime effect, which is true,


00:35:20.820 --> 00:35:24.080
but they have the type annotations.


00:35:24.080 --> 00:35:27.840
Well, they can if you, in certain circumstances,


00:35:27.840 --> 00:35:31.120
Pants itself uses its own code's type annotations


00:35:31.120 --> 00:35:34.640
at runtime in an interesting way.


00:35:34.640 --> 00:35:40.680
But generally, running mypy just is an extremely effective


00:35:40.680 --> 00:35:43.160
quality control check in your code.


00:35:43.160 --> 00:35:46.240
But getting set up with mypy can be complicated.


00:35:46.240 --> 00:35:50.520
And with Pants, you just Pants check all my code,


00:35:50.520 --> 00:35:55.720
or Pants check all my code that has changed since my last--


00:35:55.720 --> 00:35:57.240
since my last edits.


00:35:57.240 --> 00:36:02.720
And it will install mypy, and it will set it up,


00:36:02.720 --> 00:36:04.440
and it will run it.


00:36:04.440 --> 00:36:07.400
And the first time you do that, you'll get many, many errors,


00:36:07.400 --> 00:36:07.960
I'm sure.


00:36:07.960 --> 00:36:08.560
But--


00:36:08.560 --> 00:36:10.000
>>Luis: I'm sure.


00:36:10.000 --> 00:36:11.600
I'm sure you will.


00:36:11.600 --> 00:36:13.360
Another one you've given a shout out to


00:36:13.360 --> 00:36:16.280
is Protobuf for protocol buffers.


00:36:16.280 --> 00:36:18.360
I don't know that I've spoken very much about those at all


00:36:18.360 --> 00:36:19.080
on the show.


00:36:19.080 --> 00:36:22.520
I mean, people know REST and JSON.


00:36:22.520 --> 00:36:26.240
They may have scars from soap and XML.


00:36:26.240 --> 00:36:29.040
I'm not sure how many people are doing--


00:36:29.040 --> 00:36:31.440
depending how long they've been doing this kind of stuff.


00:36:31.440 --> 00:36:33.560
But what's Protobuf?


00:36:33.560 --> 00:36:36.080
I just had XML PTSD for a second there.


00:36:36.080 --> 00:36:36.960
Yeah, I'm sorry.


00:36:36.960 --> 00:36:40.800
We'll send a therapist your way after the show.


00:36:40.800 --> 00:36:46.400
So Protobuf is a really fabulous tool out of Google


00:36:46.400 --> 00:36:56.520
that generates code in many languages from a .proto file,


00:36:56.520 --> 00:37:00.600
which is a language-neutral interface definition language.


00:37:00.600 --> 00:37:04.280
And that works well with gRPC, which


00:37:04.280 --> 00:37:06.480
is the Google RPC language, where it actually


00:37:06.480 --> 00:37:15.120
generates RPC code and stubs so that you can use protocol


00:37:15.120 --> 00:37:19.880
buffers over the wire.


00:37:19.880 --> 00:37:22.520
Protocol is referred to as protocol buffers.


00:37:22.520 --> 00:37:25.480
And you can just use them as this binary interchange format


00:37:25.480 --> 00:37:29.080
that is very efficient over the wire.


00:37:29.080 --> 00:37:32.240
So code generation--


00:37:32.240 --> 00:37:36.080
>>Exchanging binary data, if you say, here's four bytes,


00:37:36.080 --> 00:37:39.440
that's the count, and then here's, you know,


00:37:39.440 --> 00:37:41.320
the length of the string is the next four bytes.


00:37:41.320 --> 00:37:42.480
And then there's the, like,


00:37:42.480 --> 00:37:44.960
doing that manually is super tricky.


00:37:44.960 --> 00:37:48.040
And so protocol buffers is a formalization of that.


00:37:48.040 --> 00:37:50.920
And then this tool would maybe write the Python code


00:37:50.920 --> 00:37:53.300
that understands a particular exchange.


00:37:53.300 --> 00:37:54.140
Okay.


00:37:54.140 --> 00:37:56.280
- So PaaS knows how to do code generation in general.


00:37:56.280 --> 00:37:58.640
It supports many code generators, including Thrift,


00:37:58.640 --> 00:38:03.640
which is a sort of similar in spirit to Protobuf.


00:38:03.960 --> 00:38:09.480
But Protobuf is a very prominent one, and the idea is that it will generate this Python code


00:38:09.480 --> 00:38:14.760
out of, you have this very succinct interface definition, and it generates fairly elaborate


00:38:14.760 --> 00:38:22.840
Python code that can serialize and deserialize these messages and send them via RPC interfaces,


00:38:22.840 --> 00:38:26.440
and send and receive them via RPC interfaces over the wire, where the thing on the other side of


00:38:26.440 --> 00:38:32.920
that RPC interface might not be Python at all, but they're all talking the same IDL. And yeah,


00:38:32.920 --> 00:38:35.400
Yeah, protos are very efficient binary formats


00:38:35.400 --> 00:38:36.440
so that they use things like


00:38:36.440 --> 00:38:38.160
variable length integer encoding.


00:38:38.160 --> 00:38:42.580
So the same message will be significantly more compact


00:38:42.580 --> 00:38:45.440
in protobuf as it will be in JSON.


00:38:45.440 --> 00:38:47.640
That said, in probably many, many cases,


00:38:47.640 --> 00:38:49.480
JSON is absolutely fine, right?


00:38:49.480 --> 00:38:51.320
And you should use protobuf.


00:38:51.320 --> 00:38:52.960
- A lot of value.


00:38:52.960 --> 00:38:55.480
Exactly, there's a ton of value to be like,


00:38:55.480 --> 00:38:59.480
I can put my web browser or postman or something at that


00:38:59.480 --> 00:39:02.120
and see the answer.


00:39:02.120 --> 00:39:02.960
- Yes. - Right?


00:39:02.960 --> 00:39:04.120
Like that goes a long ways,


00:39:04.120 --> 00:39:08.000
but if you're exchanging really low latency,


00:39:08.000 --> 00:39:09.480
lots of data as fast as you can,


00:39:09.480 --> 00:39:12.040
then JSON is probably not it.


00:39:12.040 --> 00:39:15.000
Certainly XML with namespaces and XSLT


00:39:15.000 --> 00:39:17.120
is definitely not the right thing.


00:39:17.120 --> 00:39:21.240
So this sounds like a cool, more modern way to do it.


00:39:21.240 --> 00:39:24.400
Some other tools, we've already talked about pytest.


00:39:24.400 --> 00:39:25.960
People know what pytest is.


00:39:25.960 --> 00:39:28.520
Black formatting, right?


00:39:28.520 --> 00:39:29.760
Auto formatting your code.


00:39:29.760 --> 00:39:32.600
Stop the indentation argument.


00:39:32.600 --> 00:39:33.480
Yes.


00:39:33.480 --> 00:39:33.960
Oh my god.


00:39:33.960 --> 00:39:37.360
When we adopted black in the pants repo,


00:39:37.360 --> 00:39:40.240
everybody, myself included, got upset for about 10 minutes


00:39:40.240 --> 00:39:43.560
and then realized that far more important than which format


00:39:43.560 --> 00:39:48.280
is that there is a format that is enforced automatically.


00:39:48.280 --> 00:39:51.880
I personally used to at least prefer two space


00:39:51.880 --> 00:39:55.240
indents to four space indents.


00:39:55.240 --> 00:39:57.540
The reason it's called black, for those who don't know,


00:39:57.540 --> 00:39:59.040
is that famous you can have any color you want


00:39:59.040 --> 00:40:00.240
as long as it's black.


00:40:00.240 --> 00:40:02.080
I think that was Henry Ford.


00:40:02.080 --> 00:40:03.440
- It's low, Model T.


00:40:03.440 --> 00:40:06.920
- So basically it's a very opinionated formatter


00:40:06.920 --> 00:40:09.120
that just says this is what Python code should look like.


00:40:09.120 --> 00:40:10.080
And you know what?


00:40:10.080 --> 00:40:13.680
I embrace robot overlords in this case.


00:40:13.680 --> 00:40:16.120
It's absolutely wonderful.


00:40:16.120 --> 00:40:20.280
I can just do pants format and it just formats all the code.


00:40:20.280 --> 00:40:21.100
And that's it.


00:40:21.100 --> 00:40:24.400
That is the, there are no more arguments.


00:40:24.400 --> 00:40:27.520
Like the true formatting is whatever black outputs.


00:40:27.520 --> 00:40:29.800
And Pants, again, makes it very easy to adopt Black.


00:40:29.800 --> 00:40:31.880
It also makes it easy, as you mentioned,


00:40:31.880 --> 00:40:34.360
for linters, for formatters, even for mypy,


00:40:34.360 --> 00:40:35.720
Pants has affordances in it


00:40:35.720 --> 00:40:37.420
to help you adopt them incrementally,


00:40:37.420 --> 00:40:38.440
which you kind of have to do.


00:40:38.440 --> 00:40:40.140
If you have an existing code base,


00:40:40.140 --> 00:40:45.320
you may want to adopt, you know, it takes time to,


00:40:45.320 --> 00:40:46.760
so Black is very aggressive,


00:40:46.760 --> 00:40:51.360
but there are many other linters that Pants can run,


00:40:51.360 --> 00:40:55.440
DocFormatter and Flake8 and PyLint and Bandit and so on,


00:40:55.440 --> 00:40:59.840
and I sort and you may want to adopt them incrementally


00:40:59.840 --> 00:41:02.600
and Pants has ways to help you do that.


00:41:02.600 --> 00:41:07.160
And certainly with mypy because it relies on upstream,


00:41:07.160 --> 00:41:09.280
mypy you kind of have to adopt independency order


00:41:09.280 --> 00:41:13.080
because it relies on upstream type annotations


00:41:13.080 --> 00:41:15.160
and so there are ways to do that.


00:41:15.160 --> 00:41:17.080
- Right, to get the most out of it,


00:41:17.080 --> 00:41:20.980
you've got to have the, we call these three functions,


00:41:20.980 --> 00:41:23.380
well those three functions have to have type information


00:41:23.380 --> 00:41:29.460
be valid and I got started the foundation with those. Bandit's interesting. I don't know how


00:41:29.460 --> 00:41:36.100
many people run Bandit. Probably people who accept user input probably should or input from the


00:41:36.100 --> 00:41:42.900
internet. Tell people about Bandit. I'm not super familiar. I'm no expert on Bandit but it does


00:41:42.900 --> 00:41:52.260
security checks. So it will automatically find common security issues in your code and again


00:41:52.260 --> 00:41:55.140
And then, Pants makes it very easy to adopt it.


00:41:55.140 --> 00:41:59.340
You essentially just enable the Bandit plugin.


00:41:59.340 --> 00:42:01.580
Pants, I should mention, has this plugin architecture


00:42:01.580 --> 00:42:05.620
where you can opt in to whichever bits of functionality


00:42:05.620 --> 00:42:06.100
you want.


00:42:06.100 --> 00:42:08.860
So you enable the Bandit plugin, and that's kind of it.


00:42:08.860 --> 00:42:12.180
And the next time you run lint, it will run the Bandit checks,


00:42:12.180 --> 00:42:14.380
and it will yell at you about all the security issues


00:42:14.380 --> 00:42:15.460
it's found in your code.


00:42:15.460 --> 00:42:16.140
>>That's cool.


00:42:16.140 --> 00:42:17.760
So you have these different categories.


00:42:17.760 --> 00:42:20.740
Like you have a test category, a lint category, and so on.


00:42:20.740 --> 00:42:24.460
And then in your configuration, you can say, when I say lint,


00:42:24.460 --> 00:42:26.420
I mean these three things.


00:42:26.420 --> 00:42:27.180
>> Correct.


00:42:27.180 --> 00:42:30.980
So what you refer to as a category in the sort of pants


00:42:30.980 --> 00:42:33.020
jargon is referred to as a goal.


00:42:33.020 --> 00:42:35.220
So it's basically what you type on the command line.


00:42:35.220 --> 00:42:38.140
Pants test means run test.


00:42:38.140 --> 00:42:39.980
Pants lint means run all the linters.


00:42:39.980 --> 00:42:44.340
But what all the linters means depends on your configuration.


00:42:44.340 --> 00:42:45.100
>> Sure.


00:42:45.100 --> 00:42:46.780
That makes a lot of sense.


00:42:46.780 --> 00:42:48.540
Maybe one more.


00:42:48.540 --> 00:42:57.540
I know the list is kind of unbounded in a sense, but AWS Lambda, or sort of functions,


00:42:57.540 --> 00:43:00.300
serverless functions in general, there's probably other ones.


00:43:00.300 --> 00:43:03.780
You could probably do Azure functions and other things as well.


00:43:03.780 --> 00:43:07.540
The two we support at the moment are Google Cloud Functions and AWS Lambdas.


00:43:07.540 --> 00:43:13.960
Yes, so Chance knows how to take your Python code and package it into a Lambda function


00:43:13.960 --> 00:43:18.920
that you can deploy to AWS or a cloud function you can deploy to GCP.


00:43:18.920 --> 00:43:23.000
So the management of that kind of stuff is super,


00:43:23.000 --> 00:43:27.840
super picky because you might have 20 functions coming out of all these


00:43:27.840 --> 00:43:28.840
different pieces of code.


00:43:28.840 --> 00:43:32.260
And did you forget to push that to that particular function and point?


00:43:32.260 --> 00:43:33.220
That's really hard to do.


00:43:33.220 --> 00:43:36.880
Exactly. If you're using serverless, if you're using cloud functions,


00:43:36.880 --> 00:43:41.220
you probably have many of them and a tool that can tell you


00:43:41.520 --> 00:43:44.980
which ones need to be redeployed based on changes.


00:43:44.980 --> 00:43:48.460
Because it's very simple with PaaS to say


00:43:48.460 --> 00:43:51.000
which cloud functions have been affected


00:43:51.000 --> 00:43:54.900
by any transitive change since this tag,


00:43:54.900 --> 00:43:56.580
since this deployment tag.


00:43:56.580 --> 00:43:58.580
And it will tell you, it'll just give you a list,


00:43:58.580 --> 00:44:00.820
and you can just repackage them and redeploy them


00:44:00.820 --> 00:44:03.460
without having to repackage and redeploy everything


00:44:03.460 --> 00:44:05.460
every single time.


00:44:05.460 --> 00:44:07.460
Awesome. Yeah, that sounds incredibly helpful


00:44:07.460 --> 00:44:08.780
if you're using them.


00:44:08.780 --> 00:44:11.260
So the reason I wanted to go through that list here


00:44:11.260 --> 00:44:16.260
is like if those adopting those tools and those features


00:44:16.260 --> 00:44:19.780
sounds interesting, the more you adopt,


00:44:19.780 --> 00:44:24.380
the more the tools like Pants can help lower the burden


00:44:24.380 --> 00:44:26.460
and just make that automatic, right?


00:44:26.460 --> 00:44:27.660
- Exactly.


00:44:27.660 --> 00:44:29.820
It generally just takes away the pain of


00:44:29.820 --> 00:44:30.900
how do I adopt this tool?


00:44:30.900 --> 00:44:32.100
How do I run it?


00:44:32.100 --> 00:44:33.260
How do I configure it?


00:44:33.260 --> 00:44:34.940
How do I make sure that everyone in my team


00:44:34.940 --> 00:44:37.620
is on the same page about how to use these things?


00:44:37.620 --> 00:44:40.420
It just automates away all of that.


00:44:40.420 --> 00:44:44.860
It also supports things like you can run a Python REPL


00:44:44.860 --> 00:44:50.020
that contains all the dependencies of the bit of code


00:44:50.020 --> 00:44:52.340
you're interested in.


00:44:52.340 --> 00:44:55.260
Because it has this fine-grained dependency analysis,


00:44:55.260 --> 00:45:00.060
it can know that even if you have a big requirements.txt


00:45:00.060 --> 00:45:03.940
file, it knows which subparts of that requirements.txt


00:45:03.940 --> 00:45:05.460
and their transitive dependencies


00:45:05.460 --> 00:45:07.340
are relevant to every given binary.


00:45:07.340 --> 00:45:10.400
So now you're not managing many different sets


00:45:10.400 --> 00:45:13.160
of requirements for each of your, let's say,


00:45:13.160 --> 00:45:15.080
Cloud Functions or each of your Docker images,


00:45:15.080 --> 00:45:17.240
that's all happening automatically for you.


00:45:17.240 --> 00:45:19.040
- Nice.


00:45:19.040 --> 00:45:24.720
Let's talk about running these tasks


00:45:24.720 --> 00:45:29.720
and sort of caching, performance, parallelization, and so on.


00:45:29.720 --> 00:45:35.440
So one thing it has here right on the pantsbuild.org page,


00:45:35.440 --> 00:45:37.920
and you've hinted at this a few times,


00:45:37.920 --> 00:45:39.840
is that it speaks Git.


00:45:39.840 --> 00:45:43.320
And so it has this way of understanding changes.


00:45:43.320 --> 00:45:48.960
- Yes, so built into it is the ability to say,


00:45:48.960 --> 00:45:54.640
things like, when you wanna run tests,


00:45:54.640 --> 00:45:56.000
you can say run all the tests,


00:45:56.000 --> 00:45:57.960
you can say run all the tests in this directory,


00:45:57.960 --> 00:46:00.880
you can say run all the tests, run this specific test,


00:46:00.880 --> 00:46:03.680
you can say run all the tests that have this tag,


00:46:03.680 --> 00:46:05.360
there's like a tagging mechanism,


00:46:05.360 --> 00:46:07.120
sort of where you can label things,


00:46:07.120 --> 00:46:09.680
Or you can say, run all the tests


00:46:09.680 --> 00:46:16.120
that are affected by changes since this other git state.


00:46:16.120 --> 00:46:19.200
So you can say, as you're working on your laptop,


00:46:19.200 --> 00:46:21.640
you can say, all right, run the tests that could possibly


00:46:21.640 --> 00:46:28.240
be affected based on my changes since the main branch.


00:46:28.240 --> 00:46:32.680
And it will internally use git tooling


00:46:32.680 --> 00:46:34.000
to figure out what that means.


00:46:34.000 --> 00:46:36.760
So it'll say, OK, which files have you changed,


00:46:36.760 --> 00:46:39.420
and which things are downstream from those changes.


00:46:39.420 --> 00:46:44.680
- When you say affected by, how is that determined?


00:46:44.680 --> 00:46:47.420
Does that mean like I saw there's some Python code


00:46:47.420 --> 00:46:50.200
that my, here's my test and my test is importing this


00:46:50.200 --> 00:46:55.200
and these import those, or does it do like code coverage?


00:46:55.200 --> 00:46:59.300
What does it base its opinion on of what's changed?


00:46:59.300 --> 00:47:01.860
- It base its opinions on its view


00:47:01.860 --> 00:47:04.480
of your code's dependencies.


00:47:04.480 --> 00:47:07.320
Now, almost all of that view comes from analysis


00:47:07.320 --> 00:47:08.600
of import statements.


00:47:08.600 --> 00:47:10.840
Occasionally, you may have to override those.


00:47:10.840 --> 00:47:12.820
So for example, if you're using Django,


00:47:12.820 --> 00:47:14.080
we have good support for Django,


00:47:14.080 --> 00:47:17.320
but Django notoriously does a huge amount of dynamic loading


00:47:17.320 --> 00:47:19.680
based on strings in settings.py.


00:47:19.680 --> 00:47:20.520
- Right, right, right.


00:47:20.520 --> 00:47:22.340
- And occasionally, sometimes Pants can actually look


00:47:22.340 --> 00:47:23.520
at those strings and figure it out.


00:47:23.520 --> 00:47:24.720
It has a mode where you can tell it


00:47:24.720 --> 00:47:26.160
that if it sees strings in a file


00:47:26.160 --> 00:47:28.000
that look like module names,


00:47:28.000 --> 00:47:30.440
to assume that those are like imports,


00:47:30.440 --> 00:47:32.040
but sometimes that doesn't work.


00:47:32.960 --> 00:47:36.800
And so you can manually override the dependency inference


00:47:36.800 --> 00:47:40.360
and you can say, actually, here's a dependency


00:47:40.360 --> 00:47:42.440
that's important and you failed to infer it


00:47:42.440 --> 00:47:44.960
or the opposite, you can exclude a dependency


00:47:44.960 --> 00:47:48.840
that pants mistakenly inferred, but that's extremely rare.


00:47:48.840 --> 00:47:53.840
So it bases that on its automatic static analysis


00:47:53.840 --> 00:47:54.980
of your dependencies.


00:47:54.980 --> 00:47:57.440
- Cool.


00:47:57.440 --> 00:47:59.800
So one of the things that might be important


00:47:59.800 --> 00:48:03.940
when you're running these steps is,


00:48:03.940 --> 00:48:06.960
for example, the protobuf thing, right?


00:48:06.960 --> 00:48:08.680
It's step has an output,


00:48:08.680 --> 00:48:11.580
and maybe that output is consumed by some other,


00:48:11.580 --> 00:48:12.940
maybe by the tests, or I don't know,


00:48:12.940 --> 00:48:14.460
maybe the tests load up the Python file


00:48:14.460 --> 00:48:17.540
that was generated by that to go talk to some binary blob


00:48:17.540 --> 00:48:19.580
and see if it understands it.


00:48:19.580 --> 00:48:22.140
It's really important those run in order, right?


00:48:22.140 --> 00:48:23.140
- Yes.


00:48:23.140 --> 00:48:25.220
So from your dependencies,


00:48:25.220 --> 00:48:29.660
plus its understanding of which jobs need


00:48:29.660 --> 00:48:32.260
which inputs needs to consume which inputs


00:48:32.260 --> 00:48:34.900
and which jobs produce those inputs as their outputs,


00:48:34.900 --> 00:48:38.140
it constructs this very fine-grained workflow graph.


00:48:38.140 --> 00:48:39.660
And that is exactly where the caching


00:48:39.660 --> 00:48:40.940
and the concurrency comes from.


00:48:40.940 --> 00:48:43.540
So every node in this graph-- and there could be thousands


00:48:43.540 --> 00:48:48.820
even-- every very fine-grained node in this workflow graph


00:48:48.820 --> 00:48:52.220
knows exactly which inputs it needs.


00:48:52.220 --> 00:48:55.860
And the work is done in the right sequence.


00:48:55.860 --> 00:48:58.240
So if you have two pieces of work that neither of which


00:48:58.240 --> 00:49:00.160
depend on each other, right?


00:49:00.160 --> 00:49:02.840
In the DAG sense, they are independent.


00:49:02.840 --> 00:49:04.720
They can run concurrently, and they will.


00:49:04.720 --> 00:49:07.280
So presumably, if you have multiple cores on your machine,


00:49:07.280 --> 00:49:08.720
they literally will run--


00:49:08.720 --> 00:49:11.720
they could run in parallel at the same time.


00:49:11.720 --> 00:49:15.320
But obviously, if a little work unit


00:49:15.320 --> 00:49:18.400
needs the output of some other work unit to be its input,


00:49:18.400 --> 00:49:19.960
then it will wait for those.


00:49:19.960 --> 00:49:21.760
And how all that is strung together


00:49:21.760 --> 00:49:26.200
is using all of the work is described, as I mentioned.


00:49:26.200 --> 00:49:29.840
The API for this is Python 3, is async Python 3.


00:49:29.840 --> 00:49:32.880
And so you have these things called rules,


00:49:32.880 --> 00:49:36.080
which are these async coroutines.


00:49:36.080 --> 00:49:41.680
And the Rust engine strings together executions


00:49:41.680 --> 00:49:44.560
of these rules based on data dependencies.


00:49:44.560 --> 00:49:47.680
And the data dependencies use type annotations,


00:49:47.680 --> 00:49:50.960
use just regular Python 3 type annotations


00:49:50.960 --> 00:49:54.200
to describe the types of the inputs and outputs.


00:49:54.200 --> 00:49:56.680
And so the engine can say, ah, you,


00:49:56.680 --> 00:49:59.720
this rule needs to consume an output of this type.


00:49:59.720 --> 00:50:03.320
I have found a rule that produces an output of that type


00:50:03.320 --> 00:50:06.760
based on some other input that I already have.


00:50:06.760 --> 00:50:07.920
So I will string them together


00:50:07.920 --> 00:50:10.920
and it will do that recursively until it ends up


00:50:10.920 --> 00:50:15.080
at sort of the initial data, which obviously it has.


00:50:15.080 --> 00:50:17.640
- Right, we'll start here,


00:50:17.640 --> 00:50:19.400
go down this path in that order.


00:50:19.400 --> 00:50:21.960
Some of them though can be parallel, right?


00:50:21.960 --> 00:50:26.080
like bandit and pyflake, those just, mypy,


00:50:26.080 --> 00:50:28.260
all those just look at the code and say,


00:50:28.260 --> 00:50:29.620
looks good or doesn't look good,


00:50:29.620 --> 00:50:31.540
and here's your warning message, right?


00:50:31.540 --> 00:50:34.800
And so you can, does it by default


00:50:34.800 --> 00:50:37.600
or just optionally parallelize that?


00:50:37.600 --> 00:50:39.460
- It will happen by default.


00:50:39.460 --> 00:50:42.060
It will always, I mean, you can control


00:50:42.060 --> 00:50:43.780
the amount of concurrency.


00:50:43.780 --> 00:50:45.460
Let's say you're running multiple things on the machine


00:50:45.460 --> 00:50:47.640
and you don't want it to consume all your cores,


00:50:47.640 --> 00:50:50.480
you can tune that down, but just normally by default,


00:50:50.480 --> 00:50:55.600
it will use as much concurrency as the graph allows.


00:50:55.600 --> 00:50:58.400
So every one of those small work units


00:50:58.400 --> 00:51:01.520
is a candidate for being executed concurrently


00:51:01.520 --> 00:51:02.400
with other ones.


00:51:02.400 --> 00:51:04.400
But it is also-- and this is really important--


00:51:04.400 --> 00:51:06.520
a candidate for being cached.


00:51:06.520 --> 00:51:09.760
So many, many intermediate steps can be cached.


00:51:09.760 --> 00:51:14.560
And in a typical iterative run, when


00:51:14.560 --> 00:51:16.760
you're iterating on your laptop and you're developing,


00:51:16.760 --> 00:51:18.200
you make some changes and you run some tests


00:51:18.200 --> 00:51:20.460
and you make some changes and you run the tests again.


00:51:20.460 --> 00:51:22.460
So much work that normally would be repeated


00:51:22.460 --> 00:51:26.060
will not be repeated by Pants because the outputs


00:51:26.060 --> 00:51:28.060
will be pulled from cache.


00:51:28.060 --> 00:51:30.380
Because every one of those nodes has its--


00:51:30.380 --> 00:51:32.540
it runs, as I said, with no side effects.


00:51:32.540 --> 00:51:34.780
It runs in a sandbox with no side effects,


00:51:34.780 --> 00:51:39.420
and its inputs and outputs are statically defined.


00:51:39.420 --> 00:51:45.180
So it can be correctly cached every time.


00:51:45.180 --> 00:51:48.340
So you as an author of a plugin, for example,


00:51:48.340 --> 00:51:50.540
don't have to think about caching or concurrency,


00:51:50.540 --> 00:51:52.540
you just write to the API,


00:51:52.540 --> 00:51:54.840
and caching and concurrency fall out of the design.


00:51:54.840 --> 00:51:59.740
That's really neat. And I can imagine on large code bases,


00:51:59.740 --> 00:52:02.340
things like Bandit and mypy,


00:52:02.340 --> 00:52:05.440
all those analysis tools, they can take a while.


00:52:05.440 --> 00:52:07.640
And if you just change one file,


00:52:07.640 --> 00:52:10.440
and especially if you're in the mono-repo business,


00:52:10.440 --> 00:52:13.740
where it's not just for your website, but there's a ton of stuff,


00:52:13.740 --> 00:52:16.040
you don't want to rerun all those things.


00:52:16.040 --> 00:52:17.540
So it could really get a lot faster.


00:52:17.540 --> 00:52:22.540
you can get a lot of speed increases that way, yes.


00:52:22.540 --> 00:52:26.380
- Yeah, one of the hesitations to adopt tools like this


00:52:26.380 --> 00:52:29.100
is that it keeps rerunning from scratch over and over,


00:52:29.100 --> 00:52:30.700
and that makes it slow.


00:52:30.700 --> 00:52:35.700
The other one is, while you may run it,


00:52:35.700 --> 00:52:40.860
your teammates may have less buy-in


00:52:40.860 --> 00:52:44.980
on some of these linting, formatting, testing ideas.


00:52:44.980 --> 00:52:46.800
And if you just do that in CI,


00:52:46.800 --> 00:52:50.620
well. When you check it in, it works. Someone else gets their code, you merge theirs, you


00:52:50.620 --> 00:52:54.560
check it in again, and it breaks the build. And it can be super frustrating. Is there


00:52:54.560 --> 00:53:02.880
a way, like a pre-commit hook or some other mechanism to encourage these to be run by


00:53:02.880 --> 00:53:04.280
everyone?


00:53:04.280 --> 00:53:05.720
You certainly can have a personal...


00:53:05.720 --> 00:53:08.840
Or is that a personnel problem?


00:53:08.840 --> 00:53:13.680
That really depends on the organization. We tend to see adoption of Pants at the team


00:53:13.680 --> 00:53:15.240
level.


00:53:15.240 --> 00:53:18.360
Usually what happens is someone at the team who


00:53:18.360 --> 00:53:22.480
is just fed up with a not great status quo


00:53:22.480 --> 00:53:26.840
drives adoption of it, and other team members see--


00:53:26.840 --> 00:53:29.100
there's obviously initial skepticism,


00:53:29.100 --> 00:53:32.120
because there always is whenever you try to introduce new tooling.


00:53:32.120 --> 00:53:34.600
I'm as guilty of this as anyone.


00:53:34.600 --> 00:53:37.000
But then there's that aha moment of, oh, things


00:53:37.000 --> 00:53:39.280
got more rigorous and faster.


00:53:39.280 --> 00:53:42.680
That is a trade-off I will gladly take.


00:53:42.680 --> 00:53:50.120
So very often, if CI runs pants, and that is, therefore,


00:53:50.120 --> 00:53:53.480
in some sense, the definition of correct quality control


00:53:53.480 --> 00:53:57.480
checks, because whether it's testing, linting, packaging,


00:53:57.480 --> 00:54:01.720
et cetera, because you can't merge until you pass CI,


00:54:01.720 --> 00:54:03.300
there's strong incentive there for you


00:54:03.300 --> 00:54:08.520
to use the same thing that CI is doing on your laptop.


00:54:08.520 --> 00:54:11.480
Because if you get that to pass on your laptop,


00:54:11.480 --> 00:54:14.080
is overwhelmingly more likely to pass in CI,


00:54:14.080 --> 00:54:16.680
which just gets you to merge faster.


00:54:16.680 --> 00:54:19.860
- Yeah, I guess it depends a little bit


00:54:19.860 --> 00:54:22.420
on how you work as a team in source control.


00:54:22.420 --> 00:54:26.080
If everyone can just commit to main,


00:54:26.080 --> 00:54:28.640
it's much harder to have that.


00:54:28.640 --> 00:54:30.680
But if you've got to go through a get flow,


00:54:30.680 --> 00:54:32.360
like you work on your branch and then you merge it


00:54:32.360 --> 00:54:35.160
in the main when it's approved and CI passes,


00:54:35.160 --> 00:54:38.080
well, then all of a sudden, if CI is not passing,


00:54:38.080 --> 00:54:40.920
you're not merging and then it trickles back


00:54:40.920 --> 00:54:42.360
until it gets fixed.


00:54:42.360 --> 00:54:45.040
- I think this is a big part of Python quote unquote


00:54:45.040 --> 00:54:46.360
growing up as a language.


00:54:46.360 --> 00:54:50.440
Like now, again, it's not fancy shell scripts.


00:54:50.440 --> 00:54:53.040
It is a workhorse language that people are building


00:54:53.040 --> 00:54:55.680
massive businesses and systems


00:54:55.680 --> 00:54:59.980
and data science capabilities out of.


00:54:59.980 --> 00:55:04.980
And you need to, that comes with responsibility


00:55:04.980 --> 00:55:07.820
to be rigorous about quality control.


00:55:07.820 --> 00:55:10.980
And essentially, having really good CI,


00:55:10.980 --> 00:55:14.460
having really good iterative development practices


00:55:14.460 --> 00:55:16.260
is something that is really important


00:55:16.260 --> 00:55:19.220
for these growing repos, and it's why Pants exists.


00:55:19.220 --> 00:55:21.900
It is to make that much, much easier


00:55:21.900 --> 00:55:24.620
and much, much faster than it would otherwise be.


00:55:24.620 --> 00:55:26.140
If you are sort of not running tests,


00:55:26.140 --> 00:55:28.940
not really running any checks, pushing directly to main,


00:55:28.940 --> 00:55:33.980
because historically, Python repos


00:55:33.980 --> 00:55:37.380
were these tiny toy things that you could do that in.


00:55:37.380 --> 00:55:41.380
you know, you're asking for trouble.


00:55:41.380 --> 00:55:45.380
So I'm asking you how do I get this tool that


00:55:45.380 --> 00:55:49.380
automates all of these engineering best practices


00:55:49.380 --> 00:55:53.380
and you're suggesting that maybe you start by


00:55:53.380 --> 00:55:57.380
start at the core and work your way out, right? Like just the


00:55:57.380 --> 00:56:01.380
way that you work together as a team through source control, like you formalize that a little bit


00:56:01.380 --> 00:56:03.380
then everything else becomes easy.


00:56:03.380 --> 00:56:06.300
I think so. I mean, having CI, that is the--


00:56:06.300 --> 00:56:09.980
you need some way of saying what is correct.


00:56:09.980 --> 00:56:12.620
You need some way of saying,


00:56:12.620 --> 00:56:15.420
"If this CI is green, that means you can merge this change.


00:56:15.420 --> 00:56:18.780
If this CI is green, it means that you can deploy to production."


00:56:18.780 --> 00:56:22.780
You need some way, automated way, of saying, "This code is good."


00:56:22.780 --> 00:56:28.340
Pants makes it very easy to build that ability.


00:56:28.340 --> 00:56:32.820
And once you have that, you never want to go back.


00:56:32.820 --> 00:56:39.140
there is a hurdle you have to, you know, it's less convenient than not doing any quality control, but you sort of have to


00:56:39.140 --> 00:56:45.700
So well, it's less convenient up front. It's less convenient up front. It was right, right? I mean not worry about it


00:56:45.700 --> 00:56:49.460
But you it is but as soon as you spend the whole weekend


00:56:49.460 --> 00:56:54.340
Trying to figure out why the thing doesn't work and you're supposed to release it and it turns out it was somebody else's problem


00:56:54.340 --> 00:56:56.420
and they didn't test and then like


00:56:56.420 --> 00:56:58.980
Then all of a sudden that that little bit of work up front


00:56:59.540 --> 00:57:04.540
didn't seem so big.


00:57:04.540 --> 00:57:05.820
- Nobody goes backwards, right?


00:57:05.820 --> 00:57:07.060
Nobody goes in the direction of fewer quality control checks.


00:57:07.060 --> 00:57:11.260
There is a point in the evolution of your repo


00:57:11.260 --> 00:57:13.540
where you start adopting them and you just adopt


00:57:13.540 --> 00:57:15.460
more and more of them and it's a one-way ratchet,


00:57:15.460 --> 00:57:19.460
basically, and with good reason.


00:57:19.460 --> 00:57:22.100
- In my mind, all these conversations I've been having,


00:57:22.100 --> 00:57:24.500
I've been around teams, I guess, maybe,


00:57:24.500 --> 00:57:26.860
seeded by the idea of you talking about it


00:57:26.860 --> 00:57:28.700
coming from places like Twitter and so on.


00:57:28.060 --> 00:57:32.300
What is the Pants story for open source repos?


00:57:32.300 --> 00:57:35.560
Like if I was in charge of HTTPX, I'm not,


00:57:35.560 --> 00:57:37.900
but if I were, what does Pants offer me?


00:57:37.900 --> 00:57:44.020
- So we're starting to see open source repos adopt Pants now.


00:57:44.020 --> 00:57:47.020
Tends to be the larger ones where things like,


00:57:47.020 --> 00:57:52.020
how can I speed up tests become a question


00:57:52.020 --> 00:57:53.400
even in that repo.


00:57:53.400 --> 00:57:56.500
One thing that we haven't talked about really


00:57:56.500 --> 00:58:04.220
is security and sort of protecting your own software supply chain, especially if you're


00:58:04.220 --> 00:58:08.260
an open source project where you are typically part of other people's software supply chain.


00:58:08.260 --> 00:58:15.380
So one of the features of PANCE is it has very strong support for lock files, and universal


00:58:15.380 --> 00:58:23.860
lock files that are valid across platforms, that lock down, essentially you generate a


00:58:23.860 --> 00:58:27.620
a lock file that contains, pins every single transitive


00:58:27.620 --> 00:58:32.500
dependency, including these SHA-256s of all of the wheel


00:58:32.500 --> 00:58:34.100
files.


00:58:34.100 --> 00:58:38.500
And PANS then knows how to very efficiently build


00:58:38.500 --> 00:58:40.800
virtual environments out of the subset of those


00:58:40.800 --> 00:58:44.260
that is actually necessary in any given situation.


00:58:44.260 --> 00:58:46.020
So if a test only needs some small subset,


00:58:46.020 --> 00:58:48.700
it will only use those, the advantage


00:58:48.700 --> 00:58:52.740
being that that test gets invalidated a lot less when--


00:58:52.740 --> 00:58:55.700
because the results don't get invalidated


00:58:55.700 --> 00:59:00.020
if an unrelated upstream requirement changes.


00:59:00.020 --> 00:59:09.180
So even for smaller repos or for open source repos,


00:59:09.180 --> 00:59:11.780
apart from all the other benefits,


00:59:11.780 --> 00:59:13.820
one benefit that I think is worth looking at


00:59:13.820 --> 00:59:17.060
is lock files and just locking down your supply chain.


00:59:17.060 --> 00:59:21.500
It means you don't have the left pad issue, things like that.


00:59:21.500 --> 00:59:26.100
much more robust to your build is much less impacted


00:59:26.100 --> 00:59:29.620
by changes on PyPI, by changes in the world at large.


00:59:29.620 --> 00:59:35.780
- Yeah, in the homepage it says it has out of the box support


00:59:35.780 --> 00:59:38.820
for multiple dependency resolvers


00:59:38.820 --> 00:59:40.860
in addition to these lock files, right?


00:59:40.860 --> 00:59:45.860
So is this like your own private PyPI server


00:59:45.860 --> 00:59:48.540
that you can limit what goes in there?


00:59:48.540 --> 00:59:49.540
What does that mean?


00:59:49.540 --> 00:59:51.660
Well, you can-- I think what that was referring to


00:59:51.660 --> 00:59:54.540
was that you can have multiple of these lock files.


00:59:54.540 --> 00:59:57.300
So when you have a large code base,


00:59:57.300 --> 00:59:58.760
you might have different parts of it


00:59:58.760 --> 01:00:01.420
that genuinely need conflicting dependencies.


01:00:01.420 --> 01:00:06.440
But you can say, OK, here are two or three lock files


01:00:06.440 --> 01:00:08.100
that you are allowed to--


01:00:08.100 --> 01:00:09.940
you have to pick one for a piece of code.


01:00:09.940 --> 01:00:12.020
Or a piece of code can be compatible with multiple,


01:00:12.020 --> 01:00:14.400
but you have to pick one when you come to build a binary


01:00:14.400 --> 01:00:15.900
or something like that.


01:00:15.900 --> 01:00:18.100
So for example, it's pretty common to have,


01:00:18.100 --> 01:00:21.740
here is the lock file that is for my web application code


01:00:21.740 --> 01:00:26.060
and here's a different lock file for my data science code


01:00:26.060 --> 01:00:28.060
because there are just conflicts between them


01:00:28.060 --> 01:00:29.420
that can't be resolved.


01:00:29.420 --> 01:00:32.820
- So there may be no reason to install a JupyterLab


01:00:32.820 --> 01:00:35.260
on your FastAPI server, right?


01:00:35.260 --> 01:00:37.380
- Well, that wouldn't happen anyway


01:00:37.380 --> 01:00:38.340
because Pants would know,


01:00:38.340 --> 01:00:40.660
even if you had a single lock file that included,


01:00:40.660 --> 01:00:45.660
say, NumPy, Pants would know that nothing in your web app


01:00:45.660 --> 01:00:49.100
nothing in your web app imports NumPy,


01:00:49.100 --> 01:00:50.260
so it wouldn't bring it in.


01:00:50.260 --> 01:00:53.300
This is more when you actually have multiple lock files.


01:00:53.300 --> 01:00:55.900
Yeah, so Pants is very good about shaving down


01:00:55.900 --> 01:00:58.980
the dependencies, both the internal and the external ones,


01:00:58.980 --> 01:01:01.340
to just what you actually need.


01:01:01.340 --> 01:01:03.500
But where multiple lock files comes in


01:01:03.500 --> 01:01:06.540
is when you have conflicts, when your code base is large enough


01:01:06.540 --> 01:01:09.140
that you genuinely cannot have the entire code base


01:01:09.140 --> 01:01:12.180
be in lockstep on a single set of dependencies.


01:01:12.180 --> 01:01:15.700
We don't encourage that, but it's not a great way to be.


01:01:15.700 --> 01:01:19.260
It's better if you can have a single consistent resolve


01:01:19.260 --> 01:01:21.980
across your entire code base, but it's not always possible.


01:01:21.980 --> 01:01:24.140
And this is an example of where we designed


01:01:24.140 --> 01:01:27.460
for the world as it is and not the world


01:01:27.460 --> 01:01:29.260
as we would like it to be.


01:01:29.260 --> 01:01:30.500
- Yeah, that makes a lot of sense.


01:01:30.500 --> 01:01:35.500
I mean, if one of the APIs is written in Django one


01:01:35.500 --> 01:01:37.460
and the person who built it left


01:01:37.460 --> 01:01:39.080
and there's no reason for it to change,


01:01:39.080 --> 01:01:41.620
like just don't touch it, just leave that alone over there.


01:01:41.620 --> 01:01:46.000
but the other part needs to use newer libraries and sure.


01:01:46.000 --> 01:01:47.600
- Yeah, that's a great example.


01:01:47.600 --> 01:01:49.640
- Yeah, cool.


01:01:49.640 --> 01:01:53.600
All right, Benji, I think we might be getting short


01:01:53.600 --> 01:01:56.840
on time here, but let me close this out


01:01:56.840 --> 01:01:58.580
with one final question.


01:01:58.580 --> 01:02:01.520
So you talked a lot about the caching


01:02:01.520 --> 01:02:04.140
and the parallelization and how like


01:02:04.140 --> 01:02:07.200
the dependency understanding.


01:02:07.200 --> 01:02:09.920
So if I wanna run these tests, I can just say,


01:02:09.920 --> 01:02:14.400
run since this last get a tag or whatever,


01:02:14.400 --> 01:02:17.120
Shah, or whatever it is you're going back to.


01:02:17.120 --> 01:02:20.600
What is your personal workflow or common workflows


01:02:20.600 --> 01:02:22.720
you see for managing that?


01:02:22.720 --> 01:02:28.160
Because at some point, I'm like, OK, the stuff up to here


01:02:28.160 --> 01:02:29.200
is good.


01:02:29.200 --> 01:02:30.160
It's been a few days.


01:02:30.160 --> 01:02:32.000
I want to move forward.


01:02:32.000 --> 01:02:34.880
I know the older stuff is good, and we're not changing it.


01:02:34.880 --> 01:02:39.840
How do you evolve this developer workflow


01:02:39.840 --> 01:02:44.280
history, what's your workflow there?


01:02:44.280 --> 01:02:51.960
I rely very heavily on the Git comparison logic.


01:02:51.960 --> 01:02:55.840
So I should mention, I do not code very much anymore.


01:02:55.840 --> 01:02:58.680
Because I'm now-- I am the co-founder of Toolchain, which


01:02:58.680 --> 01:03:00.920
is a company that actually provides


01:03:00.920 --> 01:03:06.640
SaaS and support and services around builds, Python


01:03:06.640 --> 01:03:07.760
and otherwise.


01:03:07.760 --> 01:03:10.800
And obviously, that's where a lot of the Pants expertise


01:03:10.800 --> 01:03:12.440
comes from.


01:03:12.440 --> 01:03:14.840
And so we provide things like remote caching,


01:03:14.840 --> 01:03:17.960
remote execution as a service.


01:03:17.960 --> 01:03:21.240
So I don't code that much anymore.


01:03:21.240 --> 01:03:24.320
But occasionally when I do, I rely very heavily


01:03:24.320 --> 01:03:30.880
on the Git diff functionality.


01:03:30.880 --> 01:03:33.840
So my command lines are just basically--


01:03:33.840 --> 01:03:36.000
and one thing Pants has is macros,


01:03:36.000 --> 01:03:40.440
where you can create these--


01:03:40.440 --> 01:03:41.760
sorry, macros is something else.


01:03:41.760 --> 01:03:43.940
What I was actually referring to was you can create


01:03:43.940 --> 01:03:45.680
these command line aliases.


01:03:45.680 --> 01:03:50.600
So I can run like pants green, literally just those words.


01:03:50.600 --> 01:03:53.080
And that will expand to a slightly longer command line


01:03:53.080 --> 01:03:57.400
that just says run tests, linters, formatters,


01:03:57.400 --> 01:04:01.400
and type checking on mypy, essentially,


01:04:01.400 --> 01:04:04.760
on all the files that are affected by my changes compared


01:04:04.760 --> 01:04:06.920
to main compared to the main branch.


01:04:06.920 --> 01:04:08.560
- Oh yeah, yeah, okay, that's a cool,


01:04:08.560 --> 01:04:11.560
because the stuff in main should have been verified by CI


01:04:11.560 --> 01:04:12.400
and should be all good.


01:04:12.400 --> 01:04:13.880
- Right, if it's in main, it's good.


01:04:13.880 --> 01:04:16.200
I want to see how have I broken main.


01:04:16.200 --> 01:04:19.040
And what you can actually do is run this in a loop.


01:04:19.040 --> 01:04:23.000
So you can have Pants just sort of watch for file system,


01:04:23.000 --> 01:04:24.560
it watches your file system for changes


01:04:24.560 --> 01:04:28.600
and automatically rerun that logic every time you save.


01:04:28.600 --> 01:04:33.060
So often by the time I tab into my terminal,


01:04:33.060 --> 01:04:36.180
those checks have already run, or are at least running.


01:04:36.180 --> 01:04:37.820
- Yeah, okay.


01:04:37.820 --> 01:04:39.860
- Yeah, that's my workflow.


01:04:39.860 --> 01:04:43.500
- This command alias is a cool idea as well.


01:04:43.500 --> 01:04:45.000
I'm sure people will dig that.


01:04:45.000 --> 01:04:48.100
All right, well, congratulations on toolchain.


01:04:48.100 --> 01:04:50.620
That seems like a cool thing to be working on


01:04:50.620 --> 01:04:54.540
and clearly builds on a ton of work you all have been doing.


01:04:54.540 --> 01:04:55.740
- Thank you, yeah.


01:04:55.740 --> 01:04:59.980
We basically feel both on the open source side


01:04:59.980 --> 01:05:02.700
and on the company side that you should not have to work


01:05:02.700 --> 01:05:04.460
at Google or Microsoft or Facebook


01:05:04.460 --> 01:05:08.900
to have a really fast, stable, powerful build experience,


01:05:08.900 --> 01:05:11.020
you should have that when you're a 20-person company


01:05:11.020 --> 01:05:12.260
and when you're a 200-person company


01:05:12.260 --> 01:05:14.020
and when you're a 2,000-person company.


01:05:14.020 --> 01:05:14.860
You should not have to wait


01:05:14.860 --> 01:05:17.040
to be a 100,000-person company to get that.


01:05:17.040 --> 01:05:19.740
- Yeah, there shouldn't be somebody


01:05:19.740 --> 01:05:21.460
whose job it is to set up CI.


01:05:21.460 --> 01:05:22.380
I mean, their whole job,


01:05:22.380 --> 01:05:24.780
not just something they do as part of their job.


01:05:24.780 --> 01:05:29.060
Yeah, I guess that's the other side of things.


01:05:29.060 --> 01:05:30.620
I asked you about the developer workflow.


01:05:30.620 --> 01:05:32.060
What does it look like?


01:05:32.060 --> 01:05:36.380
Let's suppose I have GitHub and I'm using GitHub Actions


01:05:36.380 --> 01:05:38.100
as my CI.


01:05:38.100 --> 01:05:40.220
How do I get Pants to work over there?


01:05:40.220 --> 01:05:43.980
- So that's an interesting area that we are looking at


01:05:43.980 --> 01:05:45.540
more and more closely.


01:05:45.540 --> 01:05:50.120
And we will have some interesting announcements about that


01:05:50.120 --> 01:05:51.820
over the next few weeks.


01:05:51.820 --> 01:05:55.260
But right now it is pretty easy to-


01:05:55.260 --> 01:05:57.300
- Just a heads up, this episode will probably,


01:05:57.300 --> 01:05:59.460
for people not watching the live stream,


01:05:59.460 --> 01:06:01.620
will be out probably in three or four weeks.


01:06:01.620 --> 01:06:05.460
So it might actually be real as they hear these words.


01:06:05.460 --> 01:06:05.980
We'll see.


01:06:05.980 --> 01:06:07.020
>> Maybe.


01:06:07.020 --> 01:06:08.380
Fingers crossed.


01:06:08.380 --> 01:06:14.620
But it is very easy to set up GitHub Actions or CircleCI


01:06:14.620 --> 01:06:18.820
or Buildkite or whatever you're using to run PANCE commands.


01:06:18.820 --> 01:06:21.580
And those PANCE commands, in turn,


01:06:21.580 --> 01:06:23.020
take away a lot of the-- or handle


01:06:23.020 --> 01:06:26.060
a lot of the concurrency and caching concerns


01:06:26.060 --> 01:06:29.140
that normally you would have to really mess with.


01:06:29.140 --> 01:06:33.420
you'd have to really drill into your CI config in order to get.


01:06:33.420 --> 01:06:37.060
So it essentially makes it much, much, much easier


01:06:37.060 --> 01:06:41.140
to configure CI because the complexity of, well,


01:06:41.140 --> 01:06:42.140
how do I get caching?


01:06:42.140 --> 01:06:45.420
How do I get concurrency?


01:06:45.420 --> 01:06:48.660
How do I speed things up is handled automatically


01:06:48.660 --> 01:06:50.340
by parents instead of you manually


01:06:50.340 --> 01:06:56.940
having to write tons of YAML or whatever your CI provider's


01:06:56.940 --> 01:07:00.460
config is in order to get that concurrency.


01:07:00.460 --> 01:07:03.160
Here, there's a lot of heavy lifting going on


01:07:03.160 --> 01:07:05.500
where the system itself is analyzing your code


01:07:05.500 --> 01:07:08.440
and saying, oh, here are opportunities for concurrency,


01:07:08.440 --> 01:07:10.340
here are opportunities for caching.


01:07:10.340 --> 01:07:14.580
Whereas today with CI of all kinds,


01:07:14.580 --> 01:07:17.580
CI workflows of all kinds,


01:07:17.580 --> 01:07:20.900
either you do that yourself or you vary manually


01:07:20.900 --> 01:07:21.900
or you don't get it.


01:07:21.900 --> 01:07:24.820
- Interesting, and maybe as part of the caching,


01:07:24.820 --> 01:07:26.140
you just say, like you described


01:07:26.140 --> 01:07:28.140
for the developer workflow, right?


01:07:28.140 --> 01:07:29.580
Everything other than, you know,


01:07:29.580 --> 01:07:33.620
compare that against main and now run it on that diff.


01:07:33.620 --> 01:07:34.740
- Exactly.


01:07:34.740 --> 01:07:39.300
- And CI is basically, you set up CI to call pants,


01:07:39.300 --> 01:07:42.180
pants does its magic, pants just come out.


01:07:42.180 --> 01:07:46.100
- So you don't have to write tons of CI config


01:07:46.100 --> 01:07:49.800
because a lot of, so much of the reason


01:07:49.800 --> 01:07:53.120
you would have to do that is now handled by pants itself.


01:07:53.120 --> 01:07:54.700
- Yeah, awesome.


01:07:54.700 --> 01:07:57.380
All right, well, very cool project


01:07:57.380 --> 01:08:01.100
and definitely something to be checking out.


01:08:01.100 --> 01:08:02.140
Now, before you get out of there,


01:08:02.140 --> 01:08:03.940
out of here, but final two questions.


01:08:03.940 --> 01:08:05.300
If you're gonna write some code,


01:08:05.300 --> 01:08:06.940
even if you do a little bit less these days,


01:08:06.940 --> 01:08:08.700
what editor are you using?


01:08:08.700 --> 01:08:09.660
- I use PyCharm.


01:08:09.660 --> 01:08:11.700
- Yeah. - Right on.


01:08:11.700 --> 01:08:13.140
- Actually, technically I use IntelliJ


01:08:13.140 --> 01:08:16.620
with the PyCharm plugin because of just a habit


01:08:16.620 --> 01:08:20.220
of I used to write JVM code and I never lost the habit,


01:08:20.220 --> 01:08:22.060
but effectively PyCharm.


01:08:22.060 --> 01:08:23.820
- Yeah, right on, cool.


01:08:23.820 --> 01:08:26.820
- And then notable PyPI package?


01:08:26.820 --> 01:08:27.940
- I really like Click.


01:08:27.940 --> 01:08:30.740
We don't use it for various reasons.


01:08:30.740 --> 01:08:33.020
We need a lot of control over the CLI,


01:08:33.020 --> 01:08:35.860
but I really like Click for just cobbling together


01:08:35.860 --> 01:08:41.480
cool tools that have really good CLI interfaces.


01:08:41.480 --> 01:08:44.460
- Excellent, and let me hijack the end here


01:08:44.460 --> 01:08:48.060
just for a moment, maybe I should have asked you before.


01:08:48.060 --> 01:08:51.060
To install pants, it's not pip install pants, is it?


01:08:51.060 --> 01:08:51.900
- Nope.


01:08:53.540 --> 01:08:55.420
So if you go to our website, pantsbuild.org,


01:08:55.420 --> 01:08:58.420
there's very simple steps for walking through it.


01:08:58.420 --> 01:09:00.300
But essentially, there's a wrapper script


01:09:00.300 --> 01:09:04.860
that does things like install Pants for you in a virtual env


01:09:04.860 --> 01:09:07.220
and keep it up to date.


01:09:07.220 --> 01:09:12.780
So you don't have to worry about where is this virtual env,


01:09:12.780 --> 01:09:14.580
which version of Pants is in it.


01:09:14.580 --> 01:09:16.860
It will look at the version that's in your Pants config


01:09:16.860 --> 01:09:17.100
file.


01:09:17.100 --> 01:09:19.460
There's a pants.toml file that contains a bunch of Pants


01:09:19.460 --> 01:09:20.060
config.


01:09:20.060 --> 01:09:21.860
One of them is, which version of Pants


01:09:21.860 --> 01:09:23.680
is this repo supposed to be using?


01:09:23.680 --> 01:09:26.740
And the script will make sure that is the version being used.


01:09:26.740 --> 01:09:28.180
So you don't pip install it.


01:09:28.180 --> 01:09:31.380
You run this script, and it does a bunch of magic


01:09:31.380 --> 01:09:35.840
on top of the vanilla virtual env experience.


01:09:35.840 --> 01:09:36.580
Fantastic.


01:09:36.580 --> 01:09:37.380
OK.


01:09:37.380 --> 01:09:41.940
Yeah, just pantsbuild.org/docs/installation,


01:09:41.940 --> 01:09:42.900
and off you go.


01:09:42.900 --> 01:09:44.820
All right, thank you so much for being here.


01:09:44.820 --> 01:09:45.700
Final call to action.


01:09:45.700 --> 01:09:47.240
People want to get started with Pants.


01:09:47.240 --> 01:09:48.140
What do they do?


01:09:48.140 --> 01:09:53.740
So, pantsville.org, and probably one of the best resources is our Slack channel.


01:09:53.740 --> 01:09:59.420
So, if you go to pantsville.org and click on that community link at the top, it'll take you straight


01:09:59.420 --> 01:10:05.260
into how to come chat with us on Slack. So, obviously, you're welcome to try and get started


01:10:05.260 --> 01:10:14.300
without that, but we have a very friendly, helpful community that firmly believes that


01:10:14.300 --> 01:10:17.100
that there are no bad questions, only bad documentation.


01:10:17.100 --> 01:10:21.700
And so Slack is a great place to kind of sample the community,


01:10:21.700 --> 01:10:23.540
come chat with us, tell us about your needs,


01:10:23.540 --> 01:10:25.040
tell us about how Pants can meet them


01:10:25.040 --> 01:10:27.820
or how it can't meet them.


01:10:27.820 --> 01:10:31.220
It's open source, and we have a lot of contributors


01:10:31.220 --> 01:10:33.780
from all sorts of companies and all sorts of organizations


01:10:33.780 --> 01:10:36.380
and all sorts of teams who started that way


01:10:36.380 --> 01:10:41.820
and got really enamored with what Pants can do


01:10:41.820 --> 01:10:45.320
and got really involved both in improving the developer


01:10:45.320 --> 01:10:47.200
experience at their organizations


01:10:47.200 --> 01:10:49.600
and also in improving Pants itself.


01:10:49.600 --> 01:10:54.320
So we really-- the best call to action is come say hi.


01:10:54.320 --> 01:10:54.920
Fantastic.


01:10:54.920 --> 01:10:55.560
All right.


01:10:55.560 --> 01:10:58.200
Well, congrats on a cool project,


01:10:58.200 --> 01:11:00.000
and thanks for coming and sharing with us.


01:11:00.000 --> 01:11:01.360
It was my pleasure.


01:11:01.360 --> 01:11:01.860
You bet.


01:11:01.860 --> 01:11:03.400
Bye.


01:11:03.400 --> 01:11:13.400
[BLANK_AUDIO]

