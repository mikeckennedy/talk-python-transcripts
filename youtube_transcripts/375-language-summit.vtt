WEBVTT

00:00:00.000 --> 00:00:03.360
>> Hey, Alex. Hey, YouTube.


00:00:03.360 --> 00:00:04.640
>> Hey.


00:00:04.640 --> 00:00:08.440
>> Hey. So great to have you here on the channel for a moment,


00:00:08.440 --> 00:00:10.040
and in just a minute on Talk By Lawn.


00:00:10.040 --> 00:00:12.320
So it's going to be a lot of fun.


00:00:12.320 --> 00:00:14.960
We're going to get this look you had inside


00:00:14.960 --> 00:00:17.680
the language summit this year,


00:00:17.680 --> 00:00:20.080
which is very exciting.


00:00:20.080 --> 00:00:23.920
There's a, I think maybe more than normal,


00:00:23.920 --> 00:00:25.160
a pretty exciting things going on.


00:00:25.160 --> 00:00:27.200
So anyway, let's get into it.


00:00:27.200 --> 00:00:28.520
Those of you out in the audience,


00:00:28.520 --> 00:00:33.120
Thank you for being here. If you've got thoughts, ideas, questions, comments, put them in the


00:00:33.120 --> 00:00:39.360
live chat. If you're here live, if not, thanks for watching the replay. Alex, welcome to


00:00:39.360 --> 00:00:42.360
Talk Python To Me. >> Thank you. It's great to be on the show.


00:00:42.360 --> 00:00:46.880
Big fan of the pod. >> Thank you. It's fantastic to have you


00:00:46.880 --> 00:00:53.600
here. There's so much going on with the Python Language Summit, especially this year. I think


00:00:53.600 --> 00:01:00.960
there's quite a renaissance of new ideas to sort of look at the foundations and the fundamentals


00:01:00.960 --> 00:01:06.320
of Python. And a lot of it has to do with speed in different aspects. Maybe that's through threading,


00:01:06.320 --> 00:01:11.520
or through raw performance, or through reference cutting garbage collection. And so we're going to


00:01:11.520 --> 00:01:18.080
dive into all those ideas and more by just talking about your coverage of the Python Language Summit


00:01:18.080 --> 00:01:22.800
2022. It's going to be super fun. But before we get to that, let's get to your story. How did you


00:01:22.800 --> 00:01:25.840
get into programming in Python and how did you get inside the language summit anyway?


00:01:25.840 --> 00:01:33.360
Oh yeah, sure. So I started programming actually only around two years ago.


00:01:33.360 --> 00:01:41.520
But my first line of code during the pandemic started off as a hobby. Still actually is a hobby.


00:01:41.520 --> 00:01:49.360
Yeah, had to have something to do while staying indoors.


00:01:50.320 --> 00:01:51.600
- Exactly, yeah.


00:01:51.600 --> 00:01:56.200
- So yeah, so Python is my first language


00:01:56.200 --> 00:02:00.640
and I'm entirely self-taught and yeah,


00:02:00.640 --> 00:02:02.760
once I started, couldn't stop.


00:02:02.760 --> 00:02:04.080
- That's cool.


00:02:04.080 --> 00:02:05.800
What kind of things were you looking to build?


00:02:05.800 --> 00:02:07.120
Were you just looking to learn a language


00:02:07.120 --> 00:02:10.280
or did you have some idea of something you wanted to create?


00:02:10.280 --> 00:02:13.640
- So I started, so I was doing a journalism masters


00:02:13.640 --> 00:02:18.640
at the time and there's a sub-community


00:02:19.520 --> 00:02:24.120
of journal coders, so people who use programming languages


00:02:24.120 --> 00:02:31.680
to gather data, scrape the web to find stories, essentially.


00:02:31.680 --> 00:02:33.680
So I thought that sounded pretty cool.


00:02:33.680 --> 00:02:35.280
Yeah, that sounds very cool.


00:02:35.280 --> 00:02:40.960
Yeah, so I started learning Python to help with that.


00:02:40.960 --> 00:02:44.320
And then sort of started to realize I actually


00:02:44.320 --> 00:02:48.640
enjoyed Python quite a lot, just for its own sake.


00:02:48.640 --> 00:02:53.640
So I started building, built a card game using Pygame.


00:02:53.640 --> 00:02:56.000
It was one of my first projects,


00:02:56.000 --> 00:02:58.420
which was a lot harder than I anticipated.


00:02:58.420 --> 00:03:02.120
- All the first projects are.


00:03:02.120 --> 00:03:03.680
- Oh yeah, yeah, definitely.


00:03:03.680 --> 00:03:08.640
And then built a bad website using Flask.


00:03:08.640 --> 00:03:13.560
And then eventually started contributing to open source.


00:03:13.560 --> 00:03:15.540
And that's about where I am now.


00:03:15.540 --> 00:03:17.400
- Fantastic.


00:03:17.400 --> 00:03:19.620
>> Yeah, yeah, that's really cool.


00:03:19.620 --> 00:03:21.180
It's interesting that you bring up journalism.


00:03:21.180 --> 00:03:25.740
I had Carolyn Stransky on a little while ago,


00:03:25.740 --> 00:03:27.740
predated the pandemic.


00:03:27.740 --> 00:03:29.500
>> Mm.


00:03:29.500 --> 00:03:31.580
>> Is it, did it? Yeah. Maybe not.


00:03:31.580 --> 00:03:33.100
I don't even know when the pandemic was.


00:03:33.100 --> 00:03:34.420
A couple years ago.


00:03:34.420 --> 00:03:35.820
Anyway, we talked about Python.


00:03:35.820 --> 00:03:37.820
>> Looks like you just hit before the, before the start.


00:03:37.820 --> 00:03:40.340
>> Just before it really, really kicked in.


00:03:40.340 --> 00:03:41.700
Exactly.


00:03:41.700 --> 00:03:43.820
>> Yeah.


00:03:43.820 --> 00:03:47.100
>> We talked about Python and AI and journalism,


00:03:47.100 --> 00:03:50.340
And there's a ton of neat things that people are doing


00:03:50.340 --> 00:03:55.340
in sort of automate the act of gathering data


00:03:55.340 --> 00:03:57.500
and reporting on it, right?


00:03:57.500 --> 00:04:00.100
- Yeah, no, it's a really cool space.


00:04:00.100 --> 00:04:03.620
I'm not directly employed in journalism


00:04:03.620 --> 00:04:05.740
as my full-time job at the moment,


00:04:05.740 --> 00:04:10.100
but it's something I'd love to go to dip into again


00:04:10.100 --> 00:04:11.420
at some point, definitely.


00:04:11.420 --> 00:04:12.260
- For sure.


00:04:12.260 --> 00:04:15.540
Yeah, Carolyn was talking about things like


00:04:15.540 --> 00:04:20.540
monitoring certain websites like the National Geography,


00:04:20.540 --> 00:04:24.040
whatever the foundation there is there


00:04:24.040 --> 00:04:26.060
that alerts people about earthquakes.


00:04:26.060 --> 00:04:29.700
And I would bring up details and sort of pre-fill


00:04:29.700 --> 00:04:32.440
so like some folks in LA, like on the LA Times


00:04:32.440 --> 00:04:34.660
or something would get an alert, there's an earthquake.


00:04:34.660 --> 00:04:35.660
Here's most of the details.


00:04:35.660 --> 00:04:37.900
Just put the details around it and hit publish


00:04:37.900 --> 00:04:40.100
within 10 minutes or whatever.


00:04:40.100 --> 00:04:41.460
That was, that's pretty cool.


00:04:41.460 --> 00:04:44.220
Little beep and they're like, go write your article now.


00:04:44.220 --> 00:04:47.820
One of my first projects I tried to do, again,


00:04:47.820 --> 00:04:49.520
biting off much more than I could chew,


00:04:49.520 --> 00:04:54.180
was there's a, in the UK we have this body


00:04:54.180 --> 00:04:57.860
called Historic England, which catalogs


00:04:57.860 --> 00:05:03.340
England's old buildings and heritage assets.


00:05:03.340 --> 00:05:05.900
And I have this all online,


00:05:05.900 --> 00:05:08.460
but it's not like in an easily downloadable form.


00:05:08.460 --> 00:05:10.340
You know, you can't just like download the CSV


00:05:10.340 --> 00:05:13.620
of the National Heritage List.


00:05:13.620 --> 00:05:16.380
So I decided I was going to try and scrape this


00:05:16.380 --> 00:05:17.220
from the website.


00:05:17.220 --> 00:05:18.700
And of course, the scraping is easy,


00:05:18.700 --> 00:05:22.580
but then the data cleaning is a nightmare.


00:05:22.580 --> 00:05:24.180
Because there's no consistent format,


00:05:24.180 --> 00:05:25.740
and some of it's from the 1950s.


00:05:25.740 --> 00:05:28.420
And yeah, it's horrible.


00:05:28.420 --> 00:05:31.020
Well, it would have been cool if you could have gotten it right


00:05:31.020 --> 00:05:32.420
and shared it with everyone.


00:05:32.420 --> 00:05:34.220
I got some way there.


00:05:34.220 --> 00:05:39.700
But yeah, it's just way too difficult for one man who's


00:05:39.700 --> 00:05:42.220
just started learning a few months ago.


00:05:42.220 --> 00:05:44.140
Yeah, yeah, of course.


00:05:44.140 --> 00:05:46.740
Well, it's those kinds of projects


00:05:46.740 --> 00:05:49.060
that are really good for learning programming.


00:05:49.060 --> 00:05:49.900
You know, they're--


00:05:49.900 --> 00:05:51.100
- Oh yeah, I learned a ton.


00:05:51.100 --> 00:05:51.940
I don't regret it at all.


00:05:51.940 --> 00:05:54.900
- Yeah, you're like, here's my goal,


00:05:54.900 --> 00:05:56.660
and then you just start frantically searching


00:05:56.660 --> 00:05:58.420
for like, well, what are the steps I need?


00:05:58.420 --> 00:06:00.020
And then how do I make those steps happen


00:06:00.020 --> 00:06:02.380
in my programming language, Python in this case?


00:06:02.380 --> 00:06:05.140
And like, you might not normally care


00:06:05.140 --> 00:06:07.780
to figure out how do you parse a CSV file out of disk,


00:06:07.780 --> 00:06:08.900
but you're gonna have to do it now


00:06:08.900 --> 00:06:11.140
because you're trying to, you know, aggregate on,


00:06:11.140 --> 00:06:13.220
you know, add onto it, append onto it and so on.


00:06:13.220 --> 00:06:17.020
So yeah, those kinds of things are great, great projects.


00:06:17.020 --> 00:06:18.260
- Yeah.


00:06:18.260 --> 00:06:19.100
- Cool.


00:06:19.100 --> 00:06:20.620
All right, well, how'd you get


00:06:20.620 --> 00:06:22.220
into the Python Language Summit?


00:06:22.220 --> 00:06:26.140
From a journalism anger, from the open source angle,


00:06:26.140 --> 00:06:27.640
what was the story here?


00:06:27.640 --> 00:06:32.820
- So I was invited in the autumn, I think,


00:06:32.820 --> 00:06:35.960
to become a triage with CPython.


00:06:37.460 --> 00:06:41.180
So at that point I'd contributed a lot of docs,


00:06:41.180 --> 00:06:42.500
documentation fixes,


00:06:42.500 --> 00:06:45.360
just something I was pretty good at


00:06:45.360 --> 00:06:48.420
because of the journals and masters and yeah.


00:06:48.420 --> 00:06:50.220
- You absolutely had a right, so.


00:06:50.220 --> 00:06:51.060
- Yeah, you know.


00:06:51.060 --> 00:06:56.380
I'd also contributed code to a few modules at that point.


00:06:56.380 --> 00:06:59.600
Few small fixes to,


00:06:59.600 --> 00:07:03.460
I think, funk tools,


00:07:03.460 --> 00:07:06.340
yeah, a few standard lib modules.


00:07:06.340 --> 00:07:11.340
So I'd been invited by Ken Jin,


00:07:11.340 --> 00:07:15.780
who's one of the typing module maintainers


00:07:15.780 --> 00:07:17.620
to become a triage during the autumn.


00:07:17.620 --> 00:07:23.160
So that got me onto the CPython developers discord channel.


00:07:23.160 --> 00:07:29.220
And then I think it was February or March,


00:07:29.220 --> 00:07:33.580
there was a discussion there where a few core devs


00:07:33.580 --> 00:07:35.620
were asking who they were gonna invite


00:07:35.620 --> 00:07:37.380
to become the blogger this year.


00:07:37.380 --> 00:07:41.860
I sort of said--


00:07:41.860 --> 00:07:43.580
- You know, Alex does journalism.


00:07:43.580 --> 00:07:47.140
- Yeah, like, you know, I've got this master's,


00:07:47.140 --> 00:07:49.540
I mean, could maybe I do it?


00:07:49.540 --> 00:07:55.020
And they said yes, which is very flattering.


00:07:55.020 --> 00:07:57.340
- Yeah, fantastic.


00:07:57.340 --> 00:08:00.140
- Great of them, and I really, really appreciate it.


00:08:00.140 --> 00:08:04.740
So it's Ukas, Mariata, and Sentil,


00:08:04.740 --> 00:08:06.300
this year who organized the Language Summit,


00:08:06.300 --> 00:08:09.200
so massive thanks to them for inviting me


00:08:09.200 --> 00:08:10.420
to be the blogger this year.


00:08:10.420 --> 00:08:11.940
Hugely appreciate it.


00:08:11.940 --> 00:08:12.980
- Yeah, that's great.


00:08:12.980 --> 00:08:16.300
You must have been also at PyCon then, I'm guessing,


00:08:16.300 --> 00:08:18.620
'cause you're at the Language Summit, you're at PyCon.


00:08:18.620 --> 00:08:19.460
Yeah, what was your experience there?


00:08:19.460 --> 00:08:21.060
Was it a good time?


00:08:21.060 --> 00:08:22.180
- Yeah, I had a blast.


00:08:22.180 --> 00:08:23.120
It was great.


00:08:23.120 --> 00:08:27.980
Yeah, just awesome to meet all these people


00:08:27.980 --> 00:08:31.040
I've been doing open source stuff with


00:08:31.040 --> 00:08:32.760
online for several months.


00:08:32.760 --> 00:08:37.760
Yeah, it was really cool.


00:08:37.760 --> 00:08:55.760
Well, I really appreciate these conferences because there's people I work with or talk to in different ways through GitHub, through Twitter, through the podcast, but you don't really get to see them in person because they're not around the world until you show up and have a beer together or hang out together.


00:08:55.760 --> 00:08:57.760
Yeah.


00:08:57.760 --> 00:09:01.460
- Yeah, I think that was, I mean, the talks were fantastic.


00:09:01.460 --> 00:09:04.420
But yeah, that was definitely the best bit for me,


00:09:04.420 --> 00:09:05.940
was actually-- - Yeah, that's the same,


00:09:05.940 --> 00:09:06.780
same for me, actually.


00:09:06.780 --> 00:09:09.220
That's the thing that I dig the most.


00:09:09.220 --> 00:09:11.700
All right, let's talk about the Language Summit.


00:09:11.700 --> 00:09:12.660
- Sure.


00:09:12.660 --> 00:09:14.460
- So maybe tell people really quickly,


00:09:14.460 --> 00:09:15.860
what is the Language Summit?


00:09:15.860 --> 00:09:21.780
- Sure, so the Language Summit is an event every year


00:09:21.780 --> 00:09:25.100
that happens just like the day or two days


00:09:25.100 --> 00:09:27.060
before PyCon itself stops.


00:09:27.060 --> 00:09:35.700
So most of PyCon is available to just like anybody who's interested in Python,


00:09:35.700 --> 00:09:42.100
but the language summit is generally only available to like core developers and special guests.


00:09:42.100 --> 00:09:50.340
So it's a bit exclusive. That's not because they want to be like secretive about what's


00:09:50.340 --> 00:09:51.180
what's happening in there.


00:09:51.180 --> 00:09:54.520
It's more so that it can just be a


00:09:54.520 --> 00:10:02.280
sort of frank conversation between friends, I think,


00:10:02.280 --> 00:10:03.640
sort of, if that makes sense.


00:10:03.640 --> 00:10:05.280
- Yeah, that's where the business


00:10:05.280 --> 00:10:09.600
of planning out Python gets done, right?


00:10:09.600 --> 00:10:11.320
- Yeah, exactly, yeah.


00:10:11.320 --> 00:10:12.360
- It's not the only place.


00:10:12.360 --> 00:10:16.000
We have our peps and we have other places


00:10:16.000 --> 00:10:18.420
where conversation happens, but it's,


00:10:18.420 --> 00:10:21.100
It seems like one of the places where some of the ideas


00:10:21.100 --> 00:10:24.820
of the peps are discussed and there's a quick feedback loop


00:10:24.820 --> 00:10:27.180
amongst a lot of the core developers.


00:10:27.180 --> 00:10:28.300
- Yeah, exactly.


00:10:28.300 --> 00:10:30.820
I think it's just get everybody together,


00:10:30.820 --> 00:10:33.860
all in one small room, talk Python for a whole day


00:10:33.860 --> 00:10:36.540
and then see what comes out of it.


00:10:36.540 --> 00:10:37.900
- Awesome, how many people show up there?


00:10:37.900 --> 00:10:41.100
How many core developers and other folks?


00:10:41.100 --> 00:10:44.060
- Around 30 this year, I think.


00:10:44.060 --> 00:10:47.460
So mostly core developers, a few triages,


00:10:47.460 --> 00:10:50.040
and a few special guests.


00:10:50.040 --> 00:10:55.040
So Zach Hatfield-Dobbs, I think, from Hypothesis was there.


00:10:55.040 --> 00:10:58.280
Sam Colvin from Pydantic.


00:10:58.280 --> 00:11:02.140
So yeah, a few open source maintainers


00:11:02.140 --> 00:11:03.540
outside of the Core Dev team as well.


00:11:03.540 --> 00:11:04.380
- Right, right.


00:11:04.380 --> 00:11:06.220
- Yeah.


00:11:06.220 --> 00:11:08.600
- Yeah, Pydantic's interesting.


00:11:08.600 --> 00:11:10.300
Obviously a great library.


00:11:10.300 --> 00:11:13.520
It's interesting to me because it kind of,


00:11:13.520 --> 00:11:15.620
a lot of its meaningful functionality


00:11:15.620 --> 00:11:19.860
is in the way that it breaks with the tradition of Python.


00:11:19.860 --> 00:11:20.700
- Yeah, yeah, yeah.


00:11:20.700 --> 00:11:21.740
- Like, yeah, yeah.


00:11:21.740 --> 00:11:23.580
Now all of a sudden don't just mean something,


00:11:23.580 --> 00:11:26.420
but like they are the core way in which that library works.


00:11:26.420 --> 00:11:27.380
Whereas like most of the time,


00:11:27.380 --> 00:11:31.260
it's a suggestion or a hint as the name would suggest.


00:11:31.260 --> 00:11:32.700
- Sure, yeah, yeah, yeah.


00:11:32.700 --> 00:11:35.260
And then the way it's quite coercive as well.


00:11:35.260 --> 00:11:37.800
So you don't have to like, yeah.


00:11:37.800 --> 00:11:39.900
- Yeah, for sure.


00:11:39.900 --> 00:11:41.340
It's, so he's a good guest to have


00:11:41.340 --> 00:11:43.540
because he's both got a popular project


00:11:43.540 --> 00:11:45.340
and one that's kind of an outlier


00:11:45.340 --> 00:11:46.780
to some degree. - It's huge popular,


00:11:46.780 --> 00:11:47.900
isn't it?


00:11:47.900 --> 00:11:48.900
- Yeah, it sure is.


00:11:48.900 --> 00:11:53.620
We've got a SQL model by Sebastian Ramirez,


00:11:53.620 --> 00:11:56.680
which is basically take Pydantic models


00:11:56.680 --> 00:12:00.900
on top of SQLAlchemy, and you've got Beanie from Roman Wright


00:12:00.900 --> 00:12:03.060
and there's some other ones that are just like


00:12:03.060 --> 00:12:07.080
sort of using Pydantic as their layer, which is really cool.


00:12:07.080 --> 00:12:09.900
So obviously the reason we're chatting today


00:12:09.900 --> 00:12:12.500
is this year's summit was covered by Alex Waygood.


00:12:12.500 --> 00:12:13.860
That's awesome. - That's me.


00:12:13.860 --> 00:12:15.700
- Yeah. - Yay, nicely done.


00:12:15.700 --> 00:12:19.100
And so when I saw this article or series of articles,


00:12:19.100 --> 00:12:21.300
I guess you might say, come out,


00:12:21.300 --> 00:12:25.220
I thought it was really fantastic because like I said,


00:12:25.220 --> 00:12:28.940
I think there's just so much that's exciting going on here.


00:12:28.940 --> 00:12:31.100
No, it's not, well, we're gonna change the language


00:12:31.100 --> 00:12:32.020
a little bit here or there,


00:12:32.020 --> 00:12:34.620
but there's stuff that everyone's gonna get.


00:12:34.620 --> 00:12:36.340
- There's some really huge stuff in there.


00:12:36.340 --> 00:12:40.220
Yeah, thank you. - Yeah, yeah, absolutely.


00:12:40.220 --> 00:12:42.220
So I thought what we could do for our conversation


00:12:42.220 --> 00:12:46.060
is just go in order and just sort of chat through them.


00:12:46.060 --> 00:12:49.420
You can give me a sense of what it was like


00:12:49.420 --> 00:12:50.260
to be in the room,


00:12:50.260 --> 00:12:52.680
what are some of the main ideas of each of these,


00:12:52.680 --> 00:12:53.900
and we'll just chat about them.


00:12:53.900 --> 00:12:58.840
So the first one was a very exciting project by Sam Gross.


00:12:58.840 --> 00:12:59.900
- Yes.


00:12:59.900 --> 00:13:01.840
- Who I think works for Meta.


00:13:01.840 --> 00:13:04.380
Yeah, I think he's part of the Cinder stuff, yeah.


00:13:04.380 --> 00:13:09.740
And this is Python without the GIL or no GIL.


00:13:09.740 --> 00:13:10.780
Yeah, go ahead.


00:13:10.780 --> 00:13:13.220
- So I don't think he's on the Cinder team,


00:13:13.220 --> 00:13:15.580
but yeah, he is working at Meta.


00:13:15.580 --> 00:13:17.540
- Right, okay, cool.


00:13:17.540 --> 00:13:20.260
Yeah, there's other stuff from Cinder we'll get to later.


00:13:20.260 --> 00:13:25.260
But yeah, Python without the GIL or his no-GIL story,


00:13:25.260 --> 00:13:28.860
there's been, from a historical perspective,


00:13:28.860 --> 00:13:32.540
we've had attempts to remove the GIL


00:13:32.540 --> 00:13:35.580
or change the performance characteristics of the GIL


00:13:35.580 --> 00:13:36.420
and so on.


00:13:36.420 --> 00:13:38.380
And maybe let me just set the stage a little bit


00:13:38.380 --> 00:13:41.120
with this GIL or global interpreter lock


00:13:41.120 --> 00:13:42.440
for people listening.


00:13:42.440 --> 00:13:45.060
When I heard this, the global interpreter lock


00:13:45.060 --> 00:13:49.480
means you can only run one statement of Python at a time,


00:13:49.480 --> 00:13:51.360
even if it's happening in multiple threads,


00:13:51.360 --> 00:13:55.080
I thought, okay, well, this must be some odd constraint


00:13:55.080 --> 00:13:58.240
put on the language so that things like threading


00:13:58.240 --> 00:14:00.200
are easier for people.


00:14:00.200 --> 00:14:01.800
But as I learned more about it,


00:14:01.800 --> 00:14:04.120
the real purpose of the GIL has nothing to do


00:14:04.120 --> 00:14:08.240
with threading per se, it has to do with memory management.


00:14:08.240 --> 00:14:09.720
- Yep. - Right, yeah.


00:14:09.720 --> 00:14:13.600
So the way memory management happens in Python,


00:14:13.600 --> 00:14:15.900
at least in the primary first pass sense,


00:14:15.900 --> 00:14:16.900
is it's reference counted.


00:14:16.900 --> 00:14:20.680
So everything, numbers, strings, classes, dictionaries,


00:14:20.680 --> 00:14:21.840
they all have a ref count.


00:14:21.840 --> 00:14:23.400
And if that ref count ever reaches zero,


00:14:23.400 --> 00:14:26.960
it gets deleted as long as there's no cycles.


00:14:26.960 --> 00:14:28.320
And the problem is,


00:14:28.320 --> 00:14:32.720
if you're gonna change that number on the object,


00:14:32.720 --> 00:14:34.720
normally you would have to do that in a thread safe way.


00:14:34.720 --> 00:14:36.300
You would lock it.


00:14:36.300 --> 00:14:39.380
but that turns out to slow single-threaded Python down


00:14:39.380 --> 00:14:40.760
a lot when it's unneeded.


00:14:40.760 --> 00:14:44.100
And so the global interpreter lock is there


00:14:44.100 --> 00:14:46.580
meant to basically allow for that reference counting


00:14:46.580 --> 00:14:49.620
to happen quickly in the single-threaded case.


00:14:49.620 --> 00:14:52.580
And that made fantastic sense 30 years ago.


00:14:52.580 --> 00:14:56.660
Now that we're sitting here with our 16 and 32 core CPUs,


00:14:56.660 --> 00:14:59.620
all of a sudden we might wanna run more than one thread


00:14:59.620 --> 00:15:01.660
and get stuff done, you know what I mean?


00:15:01.660 --> 00:15:03.020
- Yeah, yeah.


00:15:03.020 --> 00:15:05.920
- Yeah, so that's the history of the GIL.


00:15:05.920 --> 00:15:12.240
And so there were other things, like Larry Hastings.


00:15:12.240 --> 00:15:13.880
He was there, right?


00:15:13.880 --> 00:15:15.000
>>Joseph: Yeah, yeah.


00:15:15.000 --> 00:15:16.500
Just to interject for a second, it's


00:15:16.500 --> 00:15:19.600
really fun to see how long a project it has


00:15:19.600 --> 00:15:21.240
been to try to remove the GIL.


00:15:21.240 --> 00:15:24.120
You can go back 10 years ago, and there's


00:15:24.120 --> 00:15:28.000
a talk by David Beasley on weird things going on


00:15:28.000 --> 00:15:30.720
with the GIL in 2010.


00:15:30.720 --> 00:15:32.720
And then I was--


00:15:32.720 --> 00:15:35.520
while I was writing this, after the summit,


00:15:35.520 --> 00:15:38.120
looking through the archives of past language summit bloggers.


00:15:38.120 --> 00:15:43.180
And I think there's three successive years running


00:15:43.180 --> 00:15:45.520
where there's presentations about the latest project


00:15:45.520 --> 00:15:46.360
to remove the GIL.


00:15:46.360 --> 00:15:48.840
But this time, it actually seems like it could happen.


00:15:48.840 --> 00:15:50.160
So it's really cool.


00:15:50.160 --> 00:15:51.000
It could happen.


00:15:51.000 --> 00:15:53.000
Yeah, it certainly could.


00:15:53.000 --> 00:15:56.560
Sam Gross's work seems to be the most likely candidate.


00:15:56.560 --> 00:16:01.000
In all the other attempts, their challenges have been,


00:16:01.000 --> 00:16:02.760
yes, you might remove the GIL, and you


00:16:02.760 --> 00:16:05.760
might make the parallel computing faster,


00:16:05.760 --> 00:16:08.160
but you're gonna make single-threaded Python


00:16:08.160 --> 00:16:11.580
so much slower that we don't want to accept it, right?


00:16:11.580 --> 00:16:14.040
If you could say, well, you can use all the cores


00:16:14.040 --> 00:16:16.660
in your machine, but now everything runs half as fast,


00:16:16.660 --> 00:16:20.400
that's not a huge benefit to a lot of people.


00:16:20.400 --> 00:16:24.400
- Yeah, and especially because of the fact


00:16:24.400 --> 00:16:26.520
that the Guild's been there for so long,


00:16:26.520 --> 00:16:27.880
the vast majority of Python code


00:16:27.880 --> 00:16:30.520
is written with only one thread, right?


00:16:30.520 --> 00:16:34.080
So it's like, well, it could make Python code faster,


00:16:34.080 --> 00:16:37.040
but only if you rewrote all of your code,


00:16:37.040 --> 00:16:38.740
which not many people want to do.


00:16:38.740 --> 00:16:44.960
- True, the other major problem or challenge that is there


00:16:44.960 --> 00:16:48.040
is how does it work with the C extensions


00:16:48.040 --> 00:16:52.720
that are so important to making Python work well, right?


00:16:52.720 --> 00:16:56.480
NumPy and all those types of things, right?


00:16:56.480 --> 00:16:57.900
- Yeah. - Yeah.


00:16:57.900 --> 00:17:01.960
So Larry Hastings was there and he worked on the Gilectomy,


00:17:01.960 --> 00:17:04.760
which I think is still the best name of all these projects.


00:17:04.760 --> 00:17:06.960
The Gilectomy, the removal of the GIL.


00:17:06.960 --> 00:17:12.200
Yeah, but it sounds like he thinks that Sam's project


00:17:12.200 --> 00:17:15.620
is already farther than his, so that's great.


00:17:15.620 --> 00:17:18.940
So maybe tell us a bit about what Sam was proposing there.


00:17:18.940 --> 00:17:25.520
- So yeah, so Sam has got this fork of CPython


00:17:26.820 --> 00:17:29.860
where he has removed the GIL and it all works.


00:17:29.860 --> 00:17:33.520
I think, you know, there's still a few rough edges,


00:17:33.520 --> 00:17:35.480
but it all basically works essentially.


00:17:35.480 --> 00:17:39.880
So now he is looking to, so if you want to,


00:17:39.880 --> 00:17:40.960
you can try that right now.


00:17:40.960 --> 00:17:43.540
You can go and download Sam's fork in the gill


00:17:43.540 --> 00:17:46.300
and most Python programs will run fine on it.


00:17:46.300 --> 00:17:50.000
That's it right there, yeah.


00:17:50.000 --> 00:17:50.840
For those watching on YouTube.


00:17:50.840 --> 00:17:52.880
- Yeah, I'll put a link in the show notes.


00:17:52.880 --> 00:17:54.440
People can check out the GitHub repo


00:17:54.440 --> 00:17:59.000
And it's just a fork of CPython and then goes from there, right?


00:17:59.000 --> 00:18:00.000
>> Yeah.


00:18:00.000 --> 00:18:01.000
Yeah.


00:18:01.000 --> 00:18:10.440
And now, Simon is hoping to essentially create a separate mode of CPython that you can enable


00:18:10.440 --> 00:18:16.000
with a compiler flag, which would enable Nogail.


00:18:16.000 --> 00:18:22.200
So to get exchanges merged into the CPython main branch, essentially.


00:18:22.200 --> 00:18:29.040
So that would mean you would have to build CPython separately in order to get a version


00:18:29.040 --> 00:18:31.600
of CPython where no-guild would work.


00:18:31.600 --> 00:18:36.400
So it wouldn't be like you'd be able to just open up the repl and go import no-guild.


00:18:36.400 --> 00:18:40.680
It wouldn't be quite that easy.


00:18:40.680 --> 00:18:49.560
But it is a bit of a hassle that it's literally a separate compilation step, a separate binary


00:18:49.560 --> 00:18:50.560
and so on.


00:18:50.560 --> 00:18:51.560
Yes.


00:18:51.560 --> 00:18:55.260
could ship, maybe the CPython distribution,


00:18:55.260 --> 00:18:59.720
if this really works out well, could be shipped with that.


00:18:59.720 --> 00:19:03.440
Like it could be a set of Python or Python 3


00:19:03.440 --> 00:19:04.280
or whatever you type.


00:19:04.280 --> 00:19:07.560
It could be Python NG or something like that.


00:19:07.560 --> 00:19:09.560
You know, like some extra command you can run,


00:19:09.560 --> 00:19:10.920
but at least it would be nice,


00:19:10.920 --> 00:19:13.360
at least if you didn't have to literally go find


00:19:13.360 --> 00:19:16.200
a different installer and try to avoid the name clashes


00:19:16.200 --> 00:19:18.500
of what Python means, you know?


00:19:18.500 --> 00:19:19.700
- Yeah, yeah, for sure.


00:19:20.680 --> 00:19:22.940
And this is a change from his original proposal.


00:19:22.940 --> 00:19:26.000
So his original proposal was for a runtime flag.


00:19:26.000 --> 00:19:28.140
So that would mean that you would be able to,


00:19:28.140 --> 00:19:30.320
I don't know, I don't know how exactly it would work,


00:19:30.320 --> 00:19:33.840
but do something like import Nogail and then.


00:19:33.840 --> 00:19:35.400
- Yeah, and reading your write up here,


00:19:35.400 --> 00:19:39.280
it sounded like Sam has come to the conclusion


00:19:39.280 --> 00:19:41.060
that there's too many differences


00:19:41.060 --> 00:19:43.400
for a runtime flag to make sense.


00:19:43.400 --> 00:19:46.480
And it's gotta be a compiled type of thing.


00:19:46.480 --> 00:19:47.580
- Yeah, exactly.


00:19:49.880 --> 00:19:52.300
So yeah, so that was his proposal.


00:19:52.300 --> 00:19:55.880
- How was the reception?


00:19:55.880 --> 00:19:58.280
- So there was,


00:19:58.280 --> 00:20:03.300
there were a lot of questions for Sam.


00:20:03.300 --> 00:20:05.540
(laughing)


00:20:05.540 --> 00:20:09.600
I think there were,


00:20:09.600 --> 00:20:13.760
I think like a few of the other proposal presentations


00:20:13.760 --> 00:20:16.880
finished under time later on in the summit.


00:20:16.880 --> 00:20:19.960
And then we went back and asked some more questions to Sam


00:20:19.960 --> 00:20:21.920
because people still have questions.


00:20:21.920 --> 00:20:28.760
So I think everybody in the room definitely knew.


00:20:28.760 --> 00:20:29.840
So like, it's crazy.


00:20:29.840 --> 00:20:33.780
If you look at the viewing figures for these blogs,


00:20:33.780 --> 00:20:37.760
like the blog on NoGil is off the charts


00:20:37.760 --> 00:20:41.760
in terms of how many people have clicked on it and read it.


00:20:41.760 --> 00:20:43.000
- Interesting, okay.


00:20:43.000 --> 00:20:46.480
- So it's like, the last time I checked,


00:20:46.480 --> 00:20:49.220
it was like 40,000 people had read the No Girl article


00:20:49.220 --> 00:20:51.880
and the next highest was 5,000 people.


00:20:51.880 --> 00:20:57.640
So there was a huge amount of interest in this feature


00:20:57.640 --> 00:20:59.400
and the people in the room knew


00:20:59.400 --> 00:21:01.280
that there was a huge amount of interest in this feature.


00:21:01.280 --> 00:21:03.960
So I think there's a lot of interest in making this work


00:21:03.960 --> 00:21:05.600
if it can be made to work.


00:21:05.600 --> 00:21:10.760
But there's just a lot of complications


00:21:10.760 --> 00:21:11.920
about how to get there.


00:21:11.920 --> 00:21:16.920
So there were a lot of people asking


00:21:16.920 --> 00:21:20.920
what exactly the plan is here,


00:21:20.920 --> 00:21:23.760
because it's this huge project


00:21:23.760 --> 00:21:25.720
that Sam's been working on for months and months.


00:21:25.720 --> 00:21:29.180
And how do you merge that into CPython?


00:21:29.180 --> 00:21:31.840
You obviously can't have one PR


00:21:31.840 --> 00:21:34.520
where you have tens of thousands of lines of code


00:21:34.520 --> 00:21:36.080
changed all at once.


00:21:36.080 --> 00:21:37.760
So how do you split that up?


00:21:39.180 --> 00:21:44.180
How do you, yeah, so I think Sam was looking


00:21:44.180 --> 00:21:50.840
for a kind of pre-approval before submitting a PEP.


00:21:50.840 --> 00:21:53.500
I think some people were reluctant.


00:21:53.500 --> 00:21:55.980
- Taking the temperature of the room to see if it was--


00:21:55.980 --> 00:21:56.820
- Yeah.


00:21:56.820 --> 00:21:58.860
- If it was welcome or unwelcome, right?


00:21:58.860 --> 00:22:02.260
- I think the general mood was sort of cautious,


00:22:02.260 --> 00:22:03.100
if that makes sense.


00:22:03.100 --> 00:22:03.940
- Yeah.


00:22:03.940 --> 00:22:07.260
- It's like, yes, but we'd need to set the plan


00:22:07.260 --> 00:22:10.220
before we give our stamp of approval.


00:22:10.220 --> 00:22:13.340
That was the kind of vibe I got.


00:22:13.340 --> 00:22:15.100
- Okay.


00:22:15.100 --> 00:22:19.620
Yeah, there was some feedback from Barry Warsaw


00:22:19.620 --> 00:22:24.180
and Itamar Osteriker about the impact it might have


00:22:24.180 --> 00:22:25.420
on third-party libraries.


00:22:25.420 --> 00:22:28.500
I think Carol Willing also talked about that


00:22:28.500 --> 00:22:30.700
'cause especially these C layers


00:22:30.700 --> 00:22:34.500
or these native code layers are super common


00:22:34.500 --> 00:22:37.460
in the data science space, especially.


00:22:37.460 --> 00:22:41.100
So yeah, some conversation about that, right?


00:22:41.100 --> 00:22:42.860
- Yes.


00:22:42.860 --> 00:22:47.860
Yeah, I think there's a lot of concern about,


00:22:47.860 --> 00:22:53.700
you know, with some features new to the language,


00:22:53.700 --> 00:22:56.140
for example, with typing,


00:22:56.140 --> 00:22:58.660
was added a few releases back,


00:22:58.660 --> 00:23:01.620
and I'm very involved with the typing community.


00:23:01.620 --> 00:23:03.900
I'm a massive fan of typing.


00:23:03.900 --> 00:23:05.940
- I am too.


00:23:05.940 --> 00:23:07.860
- Yeah. - Staying not involved.


00:23:07.860 --> 00:23:08.700
- Sure.


00:23:08.700 --> 00:23:15.980
But you know, it's kind of got a little bit


00:23:15.980 --> 00:23:17.860
of a bad name for itself in some ways


00:23:17.860 --> 00:23:21.380
because there's some people who go to maintainers


00:23:21.380 --> 00:23:25.700
and sort of demand that type hints be added or whatever.


00:23:25.700 --> 00:23:26.540
- Right.


00:23:26.540 --> 00:23:28.980
- And that's not really fair on the maintainers


00:23:28.980 --> 00:23:32.580
because everybody's volunteer doing it for free.


00:23:32.580 --> 00:23:35.220
- It is getting easier because one of the complaint,


00:23:35.220 --> 00:23:37.660
not complaints, one of the holdups used to be,


00:23:37.660 --> 00:23:40.860
well, my library is for Python two and three


00:23:40.860 --> 00:23:42.700
and I'm not gonna maintain two versions


00:23:42.700 --> 00:23:44.060
and so on and so on, right?


00:23:44.060 --> 00:23:47.180
So with the typing, wouldn't work in Python two.


00:23:47.180 --> 00:23:50.620
At least now we're generally past that holdup,


00:23:50.620 --> 00:23:51.460
but it's still, yeah,


00:23:51.460 --> 00:23:54.660
it's an effort that the person might not wanna put out there.


00:23:54.660 --> 00:23:59.660
- And again, I'm a TypeShed maintainer.


00:24:00.180 --> 00:24:01.840
Yeah, I'm very good at typing.


00:24:01.840 --> 00:24:04.020
So yeah.


00:24:04.020 --> 00:24:04.860
- Tell people about TypeShed.


00:24:04.860 --> 00:24:06.100
TypeShed's pretty cool.


00:24:06.100 --> 00:24:08.780
- Oh, sure.


00:24:08.780 --> 00:24:12.980
So TypeShed is the repository of stubs


00:24:12.980 --> 00:24:14.140
for the standard library


00:24:14.140 --> 00:24:18.620
and also a bunch of third-party stubs.


00:24:18.620 --> 00:24:21.980
So if you...


00:24:21.980 --> 00:24:26.940
TypeShed is like the only version of the standard library


00:24:26.940 --> 00:24:32.460
that mypy knows or pyright or pytype or any other type checker.


00:24:32.460 --> 00:24:41.340
So they don't actually know what's going on in the real standard library at all.


00:24:41.340 --> 00:24:41.820
>> Right.


00:24:41.820 --> 00:24:46.340
>> They only know this bundle of stubs in TypeShed.


00:24:46.340 --> 00:24:48.380
They don't feel like I'm explaining it very well.


00:24:48.380 --> 00:24:49.980
>> Yeah, so I'll put one for app-jers.


00:24:49.980 --> 00:24:52.100
These are not py files,


00:24:52.100 --> 00:24:54.100
these are pyi files.


00:24:54.100 --> 00:24:54.780
>> Yes.


00:24:54.780 --> 00:24:55.580
>> If you look at them.


00:24:55.580 --> 00:25:00.220
- The implementation is super straight. (laughs)


00:25:00.220 --> 00:25:01.860
Information, I don't know.


00:25:01.860 --> 00:25:06.260
The implementation of all these is super interesting


00:25:06.260 --> 00:25:08.300
because all the functions are dot dot dot


00:25:08.300 --> 00:25:10.900
and the default values are dot dot dot.


00:25:10.900 --> 00:25:13.720
But what you have is you have function name,


00:25:13.720 --> 00:25:18.400
variable name, type, return value, type, or class,


00:25:18.400 --> 00:25:23.240
field type, field type, field type, right?


00:25:23.240 --> 00:25:25.640
Yeah, so it's like a Python file.


00:25:25.640 --> 00:25:27.880
- I suspect some people don't even know.


00:25:27.880 --> 00:25:29.360
Yeah, I suspect some people don't even know


00:25:29.360 --> 00:25:31.780
that this is a thing you can do


00:25:31.780 --> 00:25:35.160
to improve the understanding of editors and stuff, right?


00:25:35.160 --> 00:25:36.500
In mypy.


00:25:36.500 --> 00:25:37.820
- Yeah, yeah.


00:25:37.820 --> 00:25:43.800
So yeah, so a static type checker will use this information


00:25:43.800 --> 00:25:47.720
to inform the errors that's flagging on your file


00:25:47.720 --> 00:25:49.480
if you use it to check a file.


00:25:51.020 --> 00:25:56.700
So if you import appders in your Python project,


00:25:56.700 --> 00:26:01.700
and you install types appders, then


00:26:01.700 --> 00:26:04.740
mypy will use the type hints from TypeShed to understand,


00:26:04.740 --> 00:26:09.620
oh, OK, this appders instance has an app name.


00:26:09.620 --> 00:26:11.460
[INTERPOSING VOICES]


00:26:11.460 --> 00:26:13.660
--of type str.


00:26:13.660 --> 00:26:15.940
Do you know what the editors do?


00:26:15.940 --> 00:26:19.380
Does PyCharm already have this information?


00:26:19.380 --> 00:26:22.020
Does VS Code already have this information?


00:26:22.020 --> 00:26:24.900
From other sources or behind the scenes?


00:26:24.900 --> 00:26:29.900
- VS Code does use TypeShed completely.


00:26:29.900 --> 00:26:36.260
PyCharm, I think mostly uses TypeShed now.


00:26:36.260 --> 00:26:38.260
It was kind of--


00:26:38.260 --> 00:26:39.860
- They used to have their own way.


00:26:39.860 --> 00:26:42.200
- Yeah, I think it was a bit of a journey


00:26:42.200 --> 00:26:44.300
for them to move to TypeShed.


00:26:44.300 --> 00:26:48.060
I'm not sure if they 100% do yet, but yeah.


00:26:48.060 --> 00:26:50.220
- Okay, yeah, very interesting.


00:26:50.220 --> 00:26:55.020
Let's see, we were talking about the CPython stuff


00:26:55.020 --> 00:26:56.860
and Mr. Hypermagnetic asked,


00:26:56.860 --> 00:27:00.140
will CPython ever become RustPython?


00:27:00.140 --> 00:27:03.380
They also pointed out that type 10 saves lives.


00:27:03.380 --> 00:27:04.740
Saves lives, that's great.


00:27:04.740 --> 00:27:07.140
But back to the first question, did that come up?


00:27:07.140 --> 00:27:09.180
Did Rust ever come up?


00:27:09.180 --> 00:27:12.820
My first thought is that's a pretty far bridge,


00:27:12.820 --> 00:27:14.220
but did it come up? - Yeah.


00:27:15.380 --> 00:27:19.580
So there is already Rust Python, I think.


00:27:19.580 --> 00:27:22.860
You can go and use that if you want to.


00:27:22.860 --> 00:27:25.540
Sure.


00:27:25.540 --> 00:27:29.620
I think it's quite a long way from becoming the default--


00:27:29.620 --> 00:27:31.780
like, default-- from becoming the leading


00:27:31.780 --> 00:27:34.380
version of the reference implementation of Python.


00:27:34.380 --> 00:27:35.460
Right, right, right.


00:27:35.460 --> 00:27:35.960
Interesting.


00:27:35.960 --> 00:27:36.460
Yeah, OK.


00:27:36.460 --> 00:27:38.200
We can come back to that in a little bit,


00:27:38.200 --> 00:27:40.660
because it'll circle its way back a little bit.


00:27:40.660 --> 00:27:41.500
Yeah, yeah.


00:27:41.500 --> 00:27:42.500
All right.


00:27:42.500 --> 00:27:47.140
Let's-- so we're halfway through the show,


00:27:47.140 --> 00:27:48.260
and we've got one of our items done.


00:27:48.260 --> 00:27:48.740
Fantastic.


00:27:48.740 --> 00:27:49.140
>> Yes.


00:27:49.140 --> 00:27:49.860
>> Let's go to the next one.


00:27:49.860 --> 00:27:51.540
No, we'll pick up speed as we go.


00:27:51.540 --> 00:27:52.740
>> Yeah.


00:27:52.740 --> 00:27:58.580
>> This other one, this next one is a Per Interpreter GIL,


00:27:58.580 --> 00:28:03.860
which actually has been a little bit around from PEP 684,


00:28:03.860 --> 00:28:07.540
and it's still in draft mode from Eric Snow.


00:28:07.540 --> 00:28:10.980
This also goes back to dealing with the GIL,


00:28:10.980 --> 00:28:13.480
And it tries to, instead of remove it, say,


00:28:13.480 --> 00:28:14.780
"Well, you know what the GIL does?


00:28:14.780 --> 00:28:17.320
Is it makes you have single threaded code."


00:28:17.320 --> 00:28:21.120
So what we're gonna do is, if you wanna run a thread,


00:28:21.120 --> 00:28:24.400
you just start a new sub-interpreter in the same process.


00:28:24.400 --> 00:28:26.360
And sure, it has a gill, but it's meaningless


00:28:26.360 --> 00:28:31.020
because there's only one thread per interpreter.


00:28:31.020 --> 00:28:35.040
And so it's a way to kind of sidestep that problem, right?


00:28:35.040 --> 00:28:35.960
- Yeah, it's kind of funny.


00:28:35.960 --> 00:28:38.480
So the first talk is like, "Yeah, let's get rid of the GIL."


00:28:38.480 --> 00:28:40.480
And then Eric comes along and says,


00:28:40.480 --> 00:28:44.520
But what if we had lots of gills?


00:28:44.520 --> 00:28:46.560
The problem is the gills shared.


00:28:46.560 --> 00:28:47.060
Yeah.


00:28:47.060 --> 00:28:51.480
Although, we got to rename it if there's a per interpreter GIL.


00:28:51.480 --> 00:28:53.320
Yeah, it's not global anymore, right?


00:28:53.320 --> 00:28:55.680
It should just be a per interpreter ill.


00:28:55.680 --> 00:28:58.000
The gill, the G part, the global,


00:28:58.000 --> 00:29:00.080
doesn't make sense anymore.


00:29:00.080 --> 00:29:01.280
A pill?


00:29:01.280 --> 00:29:01.840
I don't know.


00:29:01.840 --> 00:29:02.400
Yeah.


00:29:02.400 --> 00:29:02.900
A pill?


00:29:02.900 --> 00:29:04.240
Yeah, that sounds a little bad.


00:29:04.240 --> 00:29:06.520
But it's interesting to point out,


00:29:06.520 --> 00:29:08.320
like you pointed out in your article here,


00:29:08.320 --> 00:29:14.120
that back in 1997, Guido posted something saying,


00:29:14.120 --> 00:29:17.040
"A massive changes for separate thread state management.


00:29:17.040 --> 00:29:19.680
All per-thread globals are moved to a struct, which


00:29:19.680 --> 00:29:21.600
is manipulated separately."


00:29:21.600 --> 00:29:24.480
Basically trying to do the same thing.


00:29:24.480 --> 00:29:30.320
And it turns out, though, that through another picture


00:29:30.320 --> 00:29:32.120
that you've got laid out here, there's


00:29:32.120 --> 00:29:34.160
actually a lot of global state shared


00:29:34.160 --> 00:29:36.520
across threads and different things.


00:29:36.520 --> 00:29:37.360
That's the problem.


00:29:37.360 --> 00:29:39.320
- Yeah.


00:29:39.320 --> 00:29:43.240
So I think if I understand it correctly,


00:29:43.240 --> 00:29:48.240
and Eric, send me an angry email if I'm doing this wrong.


00:29:48.240 --> 00:29:50.280
- I have had him on the show before,


00:29:50.280 --> 00:29:52.360
so I'll link to that episode as well.


00:29:52.360 --> 00:29:53.200
- Okay, cool.


00:29:53.200 --> 00:29:58.040
I think it is impossible, sorry,


00:29:58.040 --> 00:30:02.960
possible now to run multiple interpreters


00:30:02.960 --> 00:30:04.560
within the same process,


00:30:04.560 --> 00:30:06.280
but it just doesn't work very well.


00:30:06.280 --> 00:30:08.600
If I understand correctly.


00:30:08.600 --> 00:30:13.080
So it's like, right into all sorts of problems,


00:30:13.080 --> 00:30:18.960
which is like safety and yeah, race conditions.


00:30:18.960 --> 00:30:20.240
>> Okay.


00:30:20.240 --> 00:30:20.920
>> There we go.


00:30:20.920 --> 00:30:22.320
>> Yeah.


00:30:22.320 --> 00:30:28.760
>> Yeah. So it sounds like he's been working on this for a long time.


00:30:28.760 --> 00:30:32.320
I think you opened with a funny quote.


00:30:32.320 --> 00:30:34.280
Hopefully, the speaker began.


00:30:34.280 --> 00:30:37.000
This is the last time I give a talk on this subject.


00:30:37.000 --> 00:30:40.280
He's been working on it since 2014.


00:30:40.280 --> 00:30:42.080
- Yeah, yeah.


00:30:42.080 --> 00:30:44.000
I think at the time he gave the talk,


00:30:44.000 --> 00:30:46.680
he was hoping to get it in for 3.11,


00:30:46.680 --> 00:30:48.200
but didn't quite make it.


00:30:48.200 --> 00:30:50.100
- Yeah, yeah, exactly.


00:30:50.100 --> 00:30:52.400
So maybe it'll be 3.12.


00:30:52.400 --> 00:30:54.720
Yeah, 'cause 3.11 is already frozen.


00:30:54.720 --> 00:30:56.440
Yeah, and it's still in draft mode.


00:30:56.440 --> 00:30:58.000
Okay, so that's a good one.


00:30:58.000 --> 00:30:59.960
People can check that out.


00:30:59.960 --> 00:31:02.640
There's a tension between many of these projects


00:31:02.640 --> 00:31:05.680
in that the optimizations one are making


00:31:05.680 --> 00:31:09.440
might be complicating the work the others are doing.


00:31:09.440 --> 00:31:10.280
- Yeah.


00:31:10.280 --> 00:31:11.840
- And that's also true for the next one here,


00:31:11.840 --> 00:31:15.500
which actually I think is the biggest news of Python 3.11.


00:31:15.500 --> 00:31:16.340
- I completely agree.


00:31:16.340 --> 00:31:17.960
- Performance improvements, yeah.


00:31:17.960 --> 00:31:20.480
Performance improvements for 3.11.


00:31:20.480 --> 00:31:22.760
- Yeah, and I felt like it's a shame


00:31:22.760 --> 00:31:25.340
that so many more people read the Nogill one


00:31:25.340 --> 00:31:26.920
than this one actually, in a way.


00:31:26.920 --> 00:31:27.920
- Yeah.


00:31:27.920 --> 00:31:30.760
- Because I've been watching the CPython repo,


00:31:30.760 --> 00:31:32.860
I know how much work has been going into this.


00:31:32.860 --> 00:31:35.660
And I think it's really impressive.


00:31:35.660 --> 00:31:37.480
- Yeah.


00:31:37.480 --> 00:31:41.320
- Yeah, so essentially the top line news from this


00:31:41.320 --> 00:31:45.080
is Python 3.11 is gonna be about 25% faster


00:31:45.080 --> 00:31:46.520
than Python 3.10.


00:31:46.520 --> 00:31:49.320
And this is,


00:31:49.320 --> 00:31:56.240
so this is mainly a result of implementing a pep


00:31:56.240 --> 00:31:57.480
by Mark Shannon.


00:31:59.200 --> 00:32:01.240
I'm not sure I can remember the number.


00:32:01.240 --> 00:32:04.120
- It's known as the Shannon plan.


00:32:04.120 --> 00:32:06.840
I'm making Python five times faster over five years


00:32:06.840 --> 00:32:10.540
or something like that by doing like this 1.25X per year,


00:32:10.540 --> 00:32:12.300
which they did it this year.


00:32:12.300 --> 00:32:13.600
That's incredible.


00:32:13.600 --> 00:32:14.680
- Yes, yeah.


00:32:14.680 --> 00:32:20.640
So yeah, so the main chunk of this is


00:32:20.640 --> 00:32:23.560
that there are loads of like small optimizations


00:32:23.560 --> 00:32:24.400
that have gone into this,


00:32:24.400 --> 00:32:26.720
but a lot of them have to do with


00:32:26.720 --> 00:32:27.560
implementing what's called


00:32:27.560 --> 00:32:29.700
a specializing adaptive interpreter.


00:32:29.700 --> 00:32:34.360
So, this is-- - Okay, what is that?


00:32:34.360 --> 00:32:39.200
- Well, so this is essentially an interpreter


00:32:39.200 --> 00:32:43.440
that monitors your program as it's running


00:32:43.440 --> 00:32:50.240
and spots if you've got like an inefficient byte code


00:32:50.240 --> 00:32:54.280
that can do lots of different things.


00:32:54.280 --> 00:33:03.320
So like maybe it's an add bytecode that could plausibly--


00:33:03.320 --> 00:33:06.080
I'm almost settling in and get some details wrong here.


00:33:06.080 --> 00:33:10.240
But maybe it could add two lists together or add two ints


00:33:10.240 --> 00:33:12.520
together.


00:33:12.520 --> 00:33:14.360
It's just like a generic add bytecode.


00:33:14.360 --> 00:33:19.520
And then the specializing adaptive interpreter


00:33:19.520 --> 00:33:21.760
will spot, oh, hang on.


00:33:21.760 --> 00:33:24.400
OK, we're in a tight loop here.


00:33:24.400 --> 00:33:27.600
Only numbers are being-- only ints are being added here.


00:33:27.600 --> 00:33:31.160
We can replace this bytecode with a more specialized one,


00:33:31.160 --> 00:33:33.680
which will do the same thing faster.


00:33:33.680 --> 00:33:35.220
>>Yeah, because there's probably a lot


00:33:35.220 --> 00:33:38.440
of checks and different types of bits of indirection


00:33:38.440 --> 00:33:41.040
to let it add strings and lists and so on.


00:33:41.040 --> 00:33:43.540
But if you know its numbers, it can just be the number thing


00:33:43.540 --> 00:33:44.640
without the checks.


00:33:44.640 --> 00:33:46.160
>>Yeah, exactly.


00:33:46.160 --> 00:33:47.800
So that's known as quickening.


00:33:47.800 --> 00:33:50.560
So like as the program is running,


00:33:50.560 --> 00:33:54.800
the specializing adaptive interpreter quickens your code


00:33:54.800 --> 00:33:58.420
and replaces the bytecode with a more specialized one.


00:33:58.420 --> 00:34:00.260
And then, yeah.


00:34:00.260 --> 00:34:01.400
And there's actually,


00:34:01.400 --> 00:34:06.400
have you heard of Brent Booker's specialist project?


00:34:06.400 --> 00:34:08.320
- No.


00:34:08.320 --> 00:34:10.080
- So if you look that up on GitHub,


00:34:10.080 --> 00:34:16.120
it's a project that he published a few weeks ago, I think.


00:34:17.200 --> 00:34:18.800
And it's really cool.


00:34:18.800 --> 00:34:23.800
You can see it's like visualizes the way Python 3.11


00:34:23.800 --> 00:34:29.120
will quicken your code as it's running.


00:34:29.120 --> 00:34:32.360
So I'll send you a, can I send a link?


00:34:32.360 --> 00:34:33.360
- Yeah, yeah, send a link.


00:34:33.360 --> 00:34:34.200
- Yeah. - Yeah.


00:34:34.200 --> 00:34:37.520
- Give me one second.


00:34:47.080 --> 00:34:49.980
So you're pulling that up out in the audience.


00:34:49.980 --> 00:34:53.080
Over here,


00:34:53.080 --> 00:34:57.040
Tomer points out that they've been following


00:34:57.040 --> 00:34:59.780
the faster CPython repository.


00:34:59.780 --> 00:35:03.240
And yeah, I'll link to that as well,


00:35:03.240 --> 00:35:04.320
Mark Shannon and other stuff,


00:35:04.320 --> 00:35:09.080
the ideas for making CPython faster over time


00:35:09.080 --> 00:35:10.160
and different things.


00:35:10.160 --> 00:35:11.880
Yeah, so very cool.


00:35:11.880 --> 00:35:15.400
- Yeah, so that's like that idea is helpful.


00:35:15.400 --> 00:35:16.760
Yeah.


00:35:16.760 --> 00:35:17.600
- Yeah.


00:35:17.600 --> 00:35:19.680
- Okay, Matt, how to do it.


00:35:19.680 --> 00:35:21.440
- All right, let's see, I got you.


00:35:21.440 --> 00:35:22.280
Thank you.


00:35:22.280 --> 00:35:29.360
Visualizing, it's specializing adaptive interpreter.


00:35:29.360 --> 00:35:30.200
Okay.


00:35:30.200 --> 00:35:31.040
- Yeah.


00:35:31.040 --> 00:35:33.560
- All right, very interesting.


00:35:33.560 --> 00:35:34.920
So this is the thing,


00:35:34.920 --> 00:35:36.960
PivotSolve specialist is a thing you can do,


00:35:36.960 --> 00:35:38.280
and then it'll what?


00:35:38.280 --> 00:35:40.640
It'll show you like a printout of the code


00:35:40.640 --> 00:35:43.140
where it's actually found improvements?


00:35:43.140 --> 00:35:44.480
- Yeah, exactly.


00:35:44.480 --> 00:35:47.260
So it will show you where it's quickened your code


00:35:47.260 --> 00:35:50.060
and where it's been unable to quicken your code.


00:35:50.060 --> 00:35:53.300
So you can see with the, I think the green bits here,


00:35:53.300 --> 00:35:57.540
specialist has, yeah, quickened those bits of code,


00:35:57.540 --> 00:35:58.540
but the other bits it's been like,


00:35:58.540 --> 00:36:00.160
yeah, don't know what to do here.


00:36:00.160 --> 00:36:01.740
Gotta leave it as it is.


00:36:01.740 --> 00:36:02.580
Yeah.


00:36:02.580 --> 00:36:03.400
- Yeah, so for people listening,


00:36:03.400 --> 00:36:06.300
if you just pull up the specialist GitHub repository,


00:36:06.300 --> 00:36:08.380
which I will put in the show notes,


00:36:08.380 --> 00:36:10.540
there's a bunch of pictures and colorized code


00:36:10.540 --> 00:36:14.300
showing you where Python 3.11 was able to make it faster


00:36:14.300 --> 00:36:17.100
where it wasn't. This is super cool. I had never heard of this.


00:36:17.100 --> 00:36:24.700
So yeah, and this is a project by Brant Booker, who's been one of the major


00:36:24.700 --> 00:36:26.860
collaborators on the Faster CPython project.


00:36:26.860 --> 00:36:28.780
Right. Yeah. OK.


00:36:28.780 --> 00:36:30.860
It's coming from the top.


00:36:30.860 --> 00:36:34.860
Coming. Yeah. What also is neat is this is not just for 3.11.


00:36:34.860 --> 00:36:36.780
3.11 is just that.


00:36:36.780 --> 00:36:38.820
They're like only halfway through.


00:36:38.820 --> 00:36:42.180
Yeah. So yeah.


00:36:42.180 --> 00:36:44.260
- It's pretty well funded too, right?


00:36:44.260 --> 00:36:47.820
Like Microsoft has, I think a team of six people


00:36:47.820 --> 00:36:50.220
possibly working with Guido and Mark.


00:36:50.220 --> 00:36:51.620
- That sounds about right.


00:36:51.620 --> 00:36:56.620
- And then also Bloomberg has contributed some resources


00:36:56.620 --> 00:36:58.660
or some help.


00:36:58.660 --> 00:36:59.500
- Yeah.


00:36:59.500 --> 00:37:00.580
- Yeah, it's really got a lot of speed here,


00:37:00.580 --> 00:37:03.300
a lot of inertia behind it, I guess I should say.


00:37:03.300 --> 00:37:05.120
- And speed, yeah.


00:37:05.120 --> 00:37:08.020
- Yeah, absolutely.


00:37:08.020 --> 00:37:10.740
All right, this one, actually, I think this is the big news.


00:37:10.740 --> 00:37:13.660
I know that it probably didn't make the biggest splash


00:37:13.660 --> 00:37:15.020
of the headlines, but--


00:37:15.020 --> 00:37:17.980
- Yeah, and I think it's getting,


00:37:17.980 --> 00:37:20.540
because this is gonna make everybody's code faster.


00:37:20.540 --> 00:37:23.780
It's not like one small micro-optimization.


00:37:23.780 --> 00:37:27.540
It's across the board, so yeah.


00:37:27.540 --> 00:37:30.300
- The threading stuff is very exciting and interesting,


00:37:30.300 --> 00:37:32.260
but I'm gonna go out on a limb and say,


00:37:32.260 --> 00:37:34.460
I think a lot of people think they need it


00:37:34.460 --> 00:37:37.940
or they think they want it more than they actually need it.


00:37:37.940 --> 00:37:40.500
So for example, if you're running a web site


00:37:40.500 --> 00:37:45.500
with APIs and stuff, G-Unicorn or MicroWiz Geat or whatever,


00:37:45.500 --> 00:37:49.020
they all spin out a bunch of worker processes


00:37:49.020 --> 00:37:52.340
and you can have several worker processes per core,


00:37:52.340 --> 00:37:56.240
meaning you're already like saturating every core of the CPU.


00:37:56.240 --> 00:37:59.860
So in those scenarios, it's nice,


00:37:59.860 --> 00:38:04.420
but it doesn't help that much in terms of a lot of stuff


00:38:04.420 --> 00:38:07.060
that you don't really need the threading.


00:38:07.060 --> 00:38:08.540
On the data science side, you might,


00:38:08.540 --> 00:38:10.620
but at the same time you often,


00:38:10.620 --> 00:38:12.380
you're doing the computation in C


00:38:12.380 --> 00:38:14.580
or you can use async and await if it's IO bound.


00:38:14.580 --> 00:38:15.900
There's a lot of ways where this problem


00:38:15.900 --> 00:38:17.140
is actually already solved.


00:38:17.140 --> 00:38:18.980
It just doesn't feel like it's solved.


00:38:18.980 --> 00:38:23.020
And so this one though, this makes multi-threaded code


00:38:23.020 --> 00:38:24.780
faster, single-threaded code faster.


00:38:24.780 --> 00:38:28.220
It just makes all the code faster, which is great.


00:38:28.220 --> 00:38:32.180
- Yeah, yeah, 100% great.


00:38:32.180 --> 00:38:34.540
- Yep, all right, let's see.


00:38:37.940 --> 00:38:39.500
What is the next one we want here?


00:38:39.500 --> 00:38:40.460
Not this one.


00:38:40.460 --> 00:38:45.980
Yeah, so the next one we want to talk about is--


00:38:45.980 --> 00:38:53.140
this could be a given it a run for the money.


00:38:53.140 --> 00:38:57.700
When the listener asked earlier about Rust


00:38:57.700 --> 00:39:00.180
being the reference implementation for CPython,


00:39:00.180 --> 00:39:02.300
well, what is it then, RPython?


00:39:02.300 --> 00:39:02.940
I don't know.


00:39:02.940 --> 00:39:04.860
Maybe CPython isn't the name for it anymore.


00:39:04.860 --> 00:39:06.900
the reference implementation for Python.


00:39:06.900 --> 00:39:11.260
This one here, Python in the browser,


00:39:11.260 --> 00:39:13.960
could put some pressure to move in that direction, right?


00:39:13.960 --> 00:39:15.620
So this one has to do with WebAssembly.


00:39:15.620 --> 00:39:16.580
Tell us about this.


00:39:16.580 --> 00:39:22.860
- Yes, so this is, so for a while now,


00:39:22.860 --> 00:39:25.940
there's been a project called Pyodite,


00:39:25.940 --> 00:39:28.460
which has been like a third party project,


00:39:28.460 --> 00:39:32.140
which has been monkey patching essentially CPython


00:39:33.060 --> 00:39:35.660
to get a version of CPython running in the browser.


00:39:35.660 --> 00:39:43.220
And PyDite has been the basis for several cool projects,


00:39:43.220 --> 00:39:49.700
which are all sort of just starting to take off now.


00:39:49.700 --> 00:39:53.520
I feel like we've sort of reached this like critical point


00:39:53.520 --> 00:39:55.940
where it's all finally sort of starting to fit together


00:39:55.940 --> 00:39:57.220
and make sense.


00:39:57.220 --> 00:40:02.980
And over the last two years, Christian Himes,


00:40:02.980 --> 00:40:06.680
core developer and contributor Ethan Smith


00:40:06.680 --> 00:40:11.680
have been working to upstream loads of these changes


00:40:11.680 --> 00:40:16.740
that Pyodide has been making to CPython itself,


00:40:16.740 --> 00:40:19.800
which would mean that Pyodide doesn't need to


00:40:19.800 --> 00:40:23.080
monkey-pax CPython nearly so much anymore.


00:40:23.080 --> 00:40:27.360
And CPython essentially will just work in the browser,


00:40:27.360 --> 00:40:28.960
which would be huge. - Yeah, there was a bunch


00:40:28.960 --> 00:40:30.840
of changes, yeah, that's fantastic.


00:40:30.840 --> 00:40:33.120
There were a bunch of changes made to make this possible.


00:40:33.120 --> 00:40:36.160
And I can't remember where in the article you said, but.


00:40:36.160 --> 00:40:38.100
- There's a specific.


00:40:38.100 --> 00:40:39.520
- Over 60 PRs.


00:40:39.520 --> 00:40:40.820
- Yeah.


00:40:40.820 --> 00:40:42.860
- Yeah, and a GitHub issue, right?


00:40:42.860 --> 00:40:44.260
- Yeah, that's the one.


00:40:44.260 --> 00:40:46.540
You can just like see.


00:40:46.540 --> 00:40:49.340
- Consider supporting mscripten/webassembly


00:40:49.340 --> 00:40:50.180
as a build target.


00:40:50.180 --> 00:40:51.620
And guess what?


00:40:51.620 --> 00:40:52.480
That's now a thing.


00:40:52.480 --> 00:40:54.760
Now you can actually go in and say,


00:40:54.760 --> 00:41:00.180
--with mscripten target equals browser


00:41:00.180 --> 00:41:02.020
as to compile CPython.


00:41:02.020 --> 00:41:05.020
And that's a big deal, I think.


00:41:05.020 --> 00:41:10.020
It's gonna make it possible to use Python


00:41:10.020 --> 00:41:13.700
where you would have otherwise used JavaScript.


00:41:13.700 --> 00:41:14.940
- Yeah, for sure.


00:41:14.940 --> 00:41:18.140
So I think this is possibly one of the biggest gripes


00:41:18.140 --> 00:41:21.540
that anybody using Python for web development has,


00:41:21.540 --> 00:41:24.480
that they have to use JavaScript.


00:41:24.480 --> 00:41:27.580
- Yeah, people will say sometimes to me


00:41:27.580 --> 00:41:31.360
that I'm being mean or inconsiderate or something


00:41:31.360 --> 00:41:33.940
when I say that we might not want to write in JavaScript.


00:41:33.940 --> 00:41:37.000
You're like, why are you hating on JavaScript?


00:41:37.000 --> 00:41:39.420
I think the frustration that a lot of people


00:41:39.420 --> 00:41:43.500
feel in the software industry is not that they necessarily


00:41:43.500 --> 00:41:46.700
hate JavaScript, that JavaScript is the only option.


00:41:46.700 --> 00:41:49.580
There's almost nowhere else in programming where we go,


00:41:49.580 --> 00:41:52.100
there's one language and one runtime, and that's it.


00:41:52.100 --> 00:41:55.180
That's all you get to use, period.


00:41:55.180 --> 00:41:58.180
on the desktop, on embedded, on the web,


00:41:58.180 --> 00:42:00.420
like on server-side web,


00:42:00.420 --> 00:42:04.120
you can pick tens of languages at least, right?


00:42:04.120 --> 00:42:05.740
And you pick the one that works well for you


00:42:05.740 --> 00:42:08.980
and the one you like, except for in the browser.


00:42:08.980 --> 00:42:11.580
Everyone is forced to do this one language,


00:42:11.580 --> 00:42:12.580
which is frustrating.


00:42:12.580 --> 00:42:16.380
And so as Python developers, where we like Python,


00:42:16.380 --> 00:42:19.060
it would be great if we could continue to use a language


00:42:19.060 --> 00:42:23.140
that we prefer for things like this, right?


00:42:23.140 --> 00:42:27.060
- And now you can.


00:42:27.060 --> 00:42:27.900
- And now you can.


00:42:27.900 --> 00:42:33.340
There's a few challenges with this.


00:42:33.340 --> 00:42:36.500
One is that the WebAssembly binaries are a bit large.


00:42:36.500 --> 00:42:38.820
Not huge, they're not huge,


00:42:38.820 --> 00:42:42.780
but they're like five or 10 megs instead of 50k.


00:42:42.780 --> 00:42:45.460
So that's a bit of a challenge.


00:42:45.460 --> 00:42:48.520
But there's places where this is already highly valuable.


00:42:48.520 --> 00:42:52.260
So for example, if you're doing like an Electron.js app,


00:42:52.260 --> 00:42:54.940
you could write that largely in Python


00:42:54.940 --> 00:42:58.900
using this stuff already.


00:42:58.900 --> 00:42:59.740
- Yep.


00:42:59.740 --> 00:43:00.560
- And it doesn't matter


00:43:00.560 --> 00:43:03.100
'cause you already downloaded an entire copy of Chrome.


00:43:03.100 --> 00:43:04.380
What's another 10 megs?


00:43:04.380 --> 00:43:06.620
You know, is it 200 or 205?


00:43:06.620 --> 00:43:08.780
Like I don't care, it's the same, you know?


00:43:08.780 --> 00:43:10.860
- Yeah, yeah.


00:43:10.860 --> 00:43:13.140
I think, yeah.


00:43:13.140 --> 00:43:17.880
I think Simon Willison might've done that a few weeks ago.


00:43:17.880 --> 00:43:19.420
Just, yeah.


00:43:19.420 --> 00:43:20.260
- Okay.


00:43:20.260 --> 00:43:23.780
- Creating an Electron.js app with PyScript?


00:43:23.780 --> 00:43:24.780
- Yeah, I think so.


00:43:24.780 --> 00:43:26.580
- Okay.


00:43:26.580 --> 00:43:27.420
- I could, yeah.


00:43:27.420 --> 00:43:28.240
- I'll have to look into that.


00:43:28.240 --> 00:43:30.020
That sounds really fantastic.


00:43:30.020 --> 00:43:34.560
Let's see, so this is cool because PyIodized is great,


00:43:34.560 --> 00:43:37.760
but it's like this sort of project maintained


00:43:37.760 --> 00:43:39.140
alongside CPython.


00:43:39.140 --> 00:43:42.060
And this is saying the core developers


00:43:42.060 --> 00:43:44.900
and the team behind Python are allowing you


00:43:44.900 --> 00:43:49.660
to just compile a limited version directly, right?


00:43:49.660 --> 00:43:52.340
- So I could say build on top of this one


00:43:52.340 --> 00:43:54.620
and not have to maintain their own copy.


00:43:54.620 --> 00:43:56.020
- Exactly, yeah.


00:43:56.020 --> 00:43:57.300
So we do need to be careful here.


00:43:57.300 --> 00:43:58.220
Like it's,


00:43:58.220 --> 00:44:02.100
M scripts in the WebAssembly are not fully supported


00:44:02.100 --> 00:44:03.020
by CPython yet.


00:44:03.020 --> 00:44:05.020
- Yeah.


00:44:05.020 --> 00:44:07.620
- So there was a lot of concern about that at the summit.


00:44:07.620 --> 00:44:10.580
Like if we say it's supported now,


00:44:10.580 --> 00:44:13.580
then it's a big statement to put out there.


00:44:13.580 --> 00:44:17.220
So definitely not fully supported yet.


00:44:17.220 --> 00:44:18.060
- Yeah, okay.


00:44:18.060 --> 00:44:18.880
Good to point that out.


00:44:18.880 --> 00:44:23.080
- And there's plenty of things that are not supported


00:44:23.080 --> 00:44:26.200
because they're probably not just haven't,


00:44:26.200 --> 00:44:27.320
they're not ready.


00:44:27.320 --> 00:44:30.000
And there are some things that will never ever be supported.


00:44:30.000 --> 00:44:32.400
Like TK inter support is probably never coming


00:44:32.400 --> 00:44:33.240
to the browser.


00:44:33.240 --> 00:44:35.240
You know what I mean?


00:44:35.240 --> 00:44:38.860
Or other things that are not permitted by the browsers,


00:44:38.860 --> 00:44:42.160
sandboxing rules and so on.


00:44:42.160 --> 00:44:44.960
- Yeah, so obviously if you,


00:44:44.960 --> 00:44:46.840
anything that can be run in the browser


00:44:46.840 --> 00:44:51.840
needs to be extremely security conscious


00:44:51.840 --> 00:44:55.160
because nobody expects to have arbitrary code


00:44:55.160 --> 00:44:56.480
executed on their browser.


00:44:56.480 --> 00:44:59.120
- Yeah, and it sounds very, very suspicious.


00:44:59.120 --> 00:45:02.120
Like, you're gonna let me run binary code in the browser,


00:45:02.120 --> 00:45:05.120
but it's subjected to exactly the same rules as JavaScript,


00:45:05.120 --> 00:45:07.320
and JavaScript gets jit compiled to binary code


00:45:07.320 --> 00:45:08.160
and then run anyway.


00:45:08.160 --> 00:45:10.240
It just feels better that it's like, oh, here's a script.


00:45:10.240 --> 00:45:12.240
It's like, no, it's the same thing.


00:45:12.240 --> 00:45:13.600
So very cool.


00:45:13.600 --> 00:45:15.120
I do wanna just point out,


00:45:15.120 --> 00:45:18.320
give a quick shout out to PyScript, which you also did in your article.


00:45:18.320 --> 00:45:20.640
This is super exciting.


00:45:20.640 --> 00:45:22.680
This takes it and makes it way, way more real.


00:45:22.680 --> 00:45:25.960
This is where you really do put Python in the browser.


00:45:25.960 --> 00:45:27.940
Yeah.


00:45:27.940 --> 00:45:30.440
So this is built on top of Pyrodive, I think.


00:45:30.440 --> 00:45:39.440
and yeah, just enables you to embed Python inside an HTML file.


00:45:39.440 --> 00:45:42.480
and it just works.


00:45:42.480 --> 00:45:43.380
Um,


00:45:43.380 --> 00:45:46.140
- Yeah, it looks pretty good.


00:45:46.140 --> 00:45:51.140
- Opening tag, pi-script inside an HTML file.


00:45:51.140 --> 00:45:54.900
Don't need to download anything.


00:45:54.900 --> 00:45:58.540
It's pretty incredible.


00:45:58.540 --> 00:46:04.500
- You can also say source equals app.pi in your browser.


00:46:04.500 --> 00:46:07.900
As long as that can be delivered as a static file,


00:46:07.900 --> 00:46:08.780
it'll pull that up and run.


00:46:08.780 --> 00:46:11.340
I just, quick follow up on this.


00:46:11.340 --> 00:46:14.020
One-- oh, this is a different one.


00:46:14.020 --> 00:46:15.140
I'll roll it.


00:46:15.140 --> 00:46:18.560
But I do want to point out that I actually--


00:46:18.560 --> 00:46:19.980
I don't know if people know this.


00:46:19.980 --> 00:46:22.500
I did a video called Python PyScript WebAssembly,


00:46:22.500 --> 00:46:26.780
and then I actually created an offline progressive web


00:46:26.780 --> 00:46:27.780
app with it.


00:46:27.780 --> 00:46:31.460
So once you've installed this app,


00:46:31.460 --> 00:46:35.700
it no longer has to download that larger binary.


00:46:35.700 --> 00:46:40.260
So if you look at the code, it's like super, super simple.


00:46:40.260 --> 00:46:42.020
you can get this cool little offline app.


00:46:42.020 --> 00:46:49.380
And it is like launch time down to one second, maybe,


00:46:49.380 --> 00:46:50.940
1 and 1/2 seconds.


00:46:50.940 --> 00:46:54.180
And it's just so bizarre to write Python


00:46:54.180 --> 00:46:55.860
for JavaScript events.


00:46:55.860 --> 00:46:58.420
You can say, on click equals, here's


00:46:58.420 --> 00:47:00.420
the Python function, and all sorts of stuff.


00:47:00.420 --> 00:47:01.860
So people go and check that out.


00:47:01.860 --> 00:47:03.940
I'll leave that in the show notes.


00:47:03.940 --> 00:47:05.700
But yeah, this is a really big deal,


00:47:05.700 --> 00:47:07.560
this WebAssembly stuff that's coming in.


00:47:07.560 --> 00:47:09.220
It's coming from these different angles.


00:47:09.220 --> 00:47:10.900
coming from Pyodide, from PyScript,


00:47:10.900 --> 00:47:14.300
from the core developers compiling to WebAssembly.


00:47:14.300 --> 00:47:17.340
All of those things are pretty fantastic.


00:47:17.340 --> 00:47:19.700
- Yeah, and it's really cool to see so many people


00:47:19.700 --> 00:47:22.260
collaborate on the same thing at once


00:47:22.260 --> 00:47:24.820
from so many different parts of the community.


00:47:24.820 --> 00:47:25.820
- Yeah, it's true.


00:47:25.820 --> 00:47:27.780
It's happening, there's two parts where that's happening,


00:47:27.780 --> 00:47:29.420
right, in this GIL thing


00:47:29.420 --> 00:47:31.940
and in the WebAssembly side of things, right?


00:47:31.940 --> 00:47:34.100
They're not necessarily coordinating,


00:47:34.100 --> 00:47:35.860
but they're all working on the same problem


00:47:35.860 --> 00:47:38.820
and surely we'll get some good outcomes from that.


00:47:38.820 --> 00:47:45.580
All right, let's talk about the Cinder one next.


00:47:45.580 --> 00:47:48.780
So this one does come also from Meta, more Instagram,


00:47:48.780 --> 00:47:50.940
I suppose, directly.


00:47:50.940 --> 00:47:53.220
But this comes from the Cinder project,


00:47:53.220 --> 00:47:56.380
and this has to do with some of the optimizations.


00:47:56.380 --> 00:47:58.580
You want to tell us about this one?


00:47:58.580 --> 00:48:04.900
>>Yeah, so these are essentially async-specific optimizations.


00:48:04.900 --> 00:48:06.620
So Cinder, for those who don't know,


00:48:06.620 --> 00:48:10.400
is a performance-oriented fork of CPython.


00:48:10.400 --> 00:48:16.260
So the Instagram team essentially were like,


00:48:16.260 --> 00:48:18.180
we really love Python, but it's a bit too slow


00:48:18.180 --> 00:48:20.300
for our web servers if we're gonna have


00:48:20.300 --> 00:48:22.340
the whole thing written in Python.


00:48:22.340 --> 00:48:25.620
So they forked it and implemented,


00:48:25.620 --> 00:48:28.900
there's a ton of different optimizations


00:48:28.900 --> 00:48:29.740
implemented in Cinder.


00:48:29.740 --> 00:48:31.100
- Many changes, yeah.


00:48:31.100 --> 00:48:32.140
There's a ton.


00:48:32.140 --> 00:48:33.420
If you check out the Cinder project,


00:48:33.420 --> 00:48:37.460
there's just a whole list of all these different things.


00:48:37.460 --> 00:48:38.860
Some of them have to do with JIT,


00:48:38.860 --> 00:48:43.180
some of them have to do with immortal objects,


00:48:43.180 --> 00:48:47.060
and some have to do with other things as well, yeah.


00:48:47.060 --> 00:48:48.860
- Yeah. - Async.io.


00:48:48.860 --> 00:48:52.200
- Lazy import, so yeah, loads of stuff going on.


00:48:52.200 --> 00:48:58.420
Yeah, so with all the attention recently


00:48:58.420 --> 00:48:59.920
on making Python faster,


00:49:00.840 --> 00:49:06.520
the sender team is hopeful that they will be able to get some of their optimizations


00:49:06.520 --> 00:49:13.100
merged into the main branch of CPython. So, this presentation was specifically about some


00:49:13.100 --> 00:49:23.200
of the async-specific optimizations that they have been implementing in their fork. So,


00:49:23.200 --> 00:49:28.020
Essentially, the issue is to do with


00:49:28.020 --> 00:49:29.860
eagerly awaited coroutines.


00:49:29.860 --> 00:49:33.680
So if you have a coroutine,


00:49:33.680 --> 00:49:39.440
then, you know, generally,


00:49:39.440 --> 00:49:40.840
if you have a coroutine function,


00:49:40.840 --> 00:49:41.880
you'll call that function,


00:49:41.880 --> 00:49:43.640
it will create this coroutine object,


00:49:43.640 --> 00:49:46.320
and that coroutine object doesn't do much


00:49:46.320 --> 00:49:47.560
until you await it,


00:49:47.560 --> 00:49:50.360
and then eventually you get a result back.


00:49:52.560 --> 00:49:59.760
But that can be inefficient in some situations.


00:49:59.760 --> 00:50:06.440
Because if the task being done in the coroutine


00:50:06.440 --> 00:50:10.000
can just finish immediately, then there's


00:50:10.000 --> 00:50:13.280
no reason to create that coroutine object.


00:50:13.280 --> 00:50:16.400
Right, and to schedule it and to do all the stuff on the loop


00:50:16.400 --> 00:50:20.480
and then wait for it, all of that is just overhead, right?


00:50:20.480 --> 00:50:21.200
Yeah.


00:50:21.200 --> 00:50:30.960
So what's done in the sender fork is they detect when a task


00:50:30.960 --> 00:50:33.840
can be immediately finished and don't


00:50:33.840 --> 00:50:36.840
bother creating the coroutine object in that case.


00:50:36.840 --> 00:50:37.400
>> Right.


00:50:37.400 --> 00:50:39.920
So let me see if I can come up with an example for people


00:50:39.920 --> 00:50:40.440
that might--


00:50:40.440 --> 00:50:43.920
>> Yeah, it's kind of complicated.


00:50:43.920 --> 00:50:44.880
>> Yeah, no, it is.


00:50:44.880 --> 00:50:48.160
But I think once you get the feel for it, it's no problem.


00:50:48.160 --> 00:50:49.400
It's not that bad.


00:50:49.400 --> 00:50:53.080
Probably bad to implement, but not bad to understand.


00:50:53.080 --> 00:50:55.600
So imagine you have an async function that's


00:50:55.600 --> 00:50:58.920
going to call an API, but you might have an in-memory cache


00:50:58.920 --> 00:51:01.680
that says, have I already looked this up


00:51:01.680 --> 00:51:03.840
for this particular argument?


00:51:03.840 --> 00:51:07.720
So your code could say, if this value is in the cache,


00:51:07.720 --> 00:51:08.840
just return that value.


00:51:08.840 --> 00:51:13.160
Otherwise, await httpx get da da da da da.


00:51:13.160 --> 00:51:16.200
So that first case where you call something


00:51:16.200 --> 00:51:18.520
that's in the cache, by default in Python


00:51:18.520 --> 00:51:22.280
now it's going to still schedule that on the loop and it's going to make it run


00:51:22.280 --> 00:51:25.400
on the loop and wait for all that to happen in this inefficient way.


00:51:25.400 --> 00:51:31.140
So the optimization is like run it as a regular function until you hit it in a


00:51:31.140 --> 00:51:33.300
wait and then go through that process.


00:51:33.300 --> 00:51:33.900
Something like that.


00:51:33.900 --> 00:51:34.400
Right.


00:51:34.400 --> 00:51:36.300
I think so.


00:51:36.300 --> 00:51:36.980
Yeah.


00:51:36.980 --> 00:51:40.040
That's my understanding of people are going to send me messages and let


00:51:40.040 --> 00:51:40.740
me know I got it wrong.


00:51:40.740 --> 00:51:44.240
That's the basic idea is there's, there's scenarios where.


00:51:44.240 --> 00:51:47.960
In my case, if it's in the cache, it doesn't ever really need to be


00:51:47.960 --> 00:51:51.560
traded as a async coroutine ever,


00:51:51.560 --> 00:51:53.800
you just get the value back like a regular function.


00:51:53.800 --> 00:51:55.840
But if it goes past that, then it does need to be one.


00:51:55.840 --> 00:51:58.240
And that's the distinction, I think.


00:51:58.240 --> 00:51:59.720
- Yeah.


00:51:59.720 --> 00:52:00.560
- Okay, cool.


00:52:00.560 --> 00:52:02.360
So there's actually a lot of improvements


00:52:02.360 --> 00:52:05.240
and performance things coming from the Cinder project.


00:52:05.240 --> 00:52:08.680
There's this one, but there was also the lazy imports,


00:52:08.680 --> 00:52:12.160
right, pep690, and that one, and so on.


00:52:12.160 --> 00:52:17.400
- Yeah, so yeah, on discuss.python.org,


00:52:17.400 --> 00:52:20.120
There's been a, I think the discussion has reached


00:52:20.120 --> 00:52:23.280
over a hundred comments now on lazy imports.


00:52:23.280 --> 00:52:28.280
So if you have views, that is where to send them.


00:52:28.280 --> 00:52:30.280
- Yeah.


00:52:30.280 --> 00:52:37.360
- So yeah, so that's a whole different proposal


00:52:37.360 --> 00:52:41.960
where you could, which would introduce an API


00:52:41.960 --> 00:52:45.880
to enable or disable lazy imports.


00:52:46.960 --> 00:52:48.960
So with lazy imports enabled,


00:52:48.960 --> 00:52:53.200
so at the moment, all imports in Python are eager.


00:52:53.200 --> 00:52:57.800
So if you type in import func tools at the top of a file,


00:52:57.800 --> 00:53:01.260
it will execute the entire func tools module


00:53:01.260 --> 00:53:04.840
and then put a reference to that module


00:53:04.840 --> 00:53:05.940
in your file for you.


00:53:05.940 --> 00:53:10.860
Whereas with lazy imports enabled,


00:53:10.860 --> 00:53:13.040
it would see the import func tool statement,


00:53:13.040 --> 00:53:14.320
and it'd be like, "Meh,


00:53:14.320 --> 00:53:16.240
don't gonna do anything with that."


00:53:16.240 --> 00:53:18.340
and then wouldn't actually import the module


00:53:18.340 --> 00:53:20.920
until the first time FuncTools was referenced


00:53:20.920 --> 00:53:22.080
later on down the file.


00:53:22.080 --> 00:53:24.020
And then it would actually-- - Right,


00:53:24.020 --> 00:53:27.040
because the problem is there's a cost for doing an import.


00:53:27.040 --> 00:53:29.400
It's not like a hashing fee,


00:53:29.400 --> 00:53:30.760
which might be a compile time thing.


00:53:30.760 --> 00:53:33.980
There's an actual runtime cost for every import.


00:53:33.980 --> 00:53:37.040
The PEP-8 says all the imports go at the top


00:53:37.040 --> 00:53:39.080
to keep them orderly. - Yeah.


00:53:39.080 --> 00:53:42.640
- But if there's many apps that might or might not


00:53:42.640 --> 00:53:46.880
use some import depending on what part of it runs, right?


00:53:46.880 --> 00:53:47.720
- Yeah.


00:53:47.720 --> 00:53:51.580
- And so if you could delay that expense


00:53:51.580 --> 00:53:54.040
only if you use it, that would be great.


00:53:54.040 --> 00:53:56.620
- And this can have a major impact on startup time


00:53:56.620 --> 00:53:58.240
for Python CLI apps.


00:53:58.240 --> 00:54:00.400
- Yeah, especially.


00:54:00.400 --> 00:54:01.880
- Yeah, yeah.


00:54:01.880 --> 00:54:04.320
- Nice, okay.


00:54:04.320 --> 00:54:07.000
This one.


00:54:07.000 --> 00:54:08.840
But the one that we were talking about


00:54:08.840 --> 00:54:10.640
is this ASIC optimization.


00:54:10.640 --> 00:54:12.640
So that's the one that was actually covered,


00:54:12.640 --> 00:54:15.840
but it's just one of the things coming out of Cinder,


00:54:15.840 --> 00:54:16.680
which is cool.


00:54:16.680 --> 00:54:17.660
- Yes.


00:54:17.660 --> 00:54:20.780
- And then I think maybe this path forward


00:54:20.780 --> 00:54:23.720
for immortal objects, is that also coming out of Cinder?


00:54:23.720 --> 00:54:26.540
- No, that's another one.


00:54:26.540 --> 00:54:29.920
- Similar but not the same.


00:54:29.920 --> 00:54:32.140
- Yeah, sure.


00:54:36.100 --> 00:54:40.820
- Yes, so this is linked to the


00:54:40.820 --> 00:54:47.040
Per Interpreter GIL talk, essentially.


00:54:47.040 --> 00:54:52.040
So this is one of those proposals


00:54:52.040 --> 00:54:54.980
that's kind of very much in the weeds


00:54:54.980 --> 00:54:57.500
of how CPython is implemented.


00:54:57.500 --> 00:55:01.800
So it's a proposal to introduce


00:55:01.800 --> 00:55:03.900
what's known as immortal objects.


00:55:03.900 --> 00:55:08.900
So an immortal object is, well, an object that never dies.


00:55:08.900 --> 00:55:16.420
So generally in Python, as we were talking about earlier,


00:55:16.420 --> 00:55:19.920
objects have reference count,


00:55:19.920 --> 00:55:22.100
and if that reference count reaches zero,


00:55:22.100 --> 00:55:24.900
then the garbage collector comes along eventually,


00:55:24.900 --> 00:55:27.100
and the rest is freeing up memory


00:55:27.100 --> 00:55:29.280
that was holding that object.


00:55:31.420 --> 00:55:35.500
So this PEP proposes introducing a class of objects


00:55:35.500 --> 00:55:37.900
where the reference count would never reach zero,


00:55:37.900 --> 00:55:41.500
meaning that the object would never be cleaned up


00:55:41.500 --> 00:55:44.020
by the garbage collector and would never die.


00:55:44.020 --> 00:55:48.220
So this would have the advantage.


00:55:48.220 --> 00:55:50.420
- Why are you bothering to like check and check


00:55:50.420 --> 00:55:52.020
on these objects that you know


00:55:52.020 --> 00:55:57.020
will never ever have any sort of reasonable way, right?


00:55:57.020 --> 00:56:00.500
- So like there's the num singleton, for example,


00:56:00.500 --> 00:56:03.540
like it would be quite rare to have a program


00:56:03.540 --> 00:56:06.080
that doesn't use none at least once.


00:56:06.080 --> 00:56:13.500
- Or the number five, which is pre-allocated, right?


00:56:13.500 --> 00:56:14.340
- Yeah.


00:56:14.340 --> 00:56:18.580
- As well as the number 200, like the first negative five


00:56:18.580 --> 00:56:22.180
in the top 255 or something like that, yeah.


00:56:22.180 --> 00:56:23.020
- Yeah.


00:56:23.020 --> 00:56:27.940
But nonetheless, Python will like doggedly


00:56:27.940 --> 00:56:30.300
keep a reference count for these objects


00:56:30.300 --> 00:56:33.380
and track where they are.


00:56:33.380 --> 00:56:39.660
Yeah, so for a lot of these, yeah,


00:56:39.660 --> 00:56:44.320
pre-allocated object numbers, in-term strings,


00:56:44.320 --> 00:56:49.740
the empty tuple, I think, is also a singleton.


00:56:49.740 --> 00:56:55.820
The non-singleton, these would all become immortal objects


00:56:55.820 --> 00:56:57.100
if this pet was accepted.


00:56:57.100 --> 00:57:10.820
And that would have, that would, I think, in the short term, make Python a little bit slower, probably.


00:57:10.820 --> 00:57:23.420
So I think a naive implementation makes it slower by around 6%, but with mitigations, you can make it so that the performance impact is marginal.


00:57:23.420 --> 00:57:27.580
But then if you do implement immortal objects,


00:57:27.580 --> 00:57:31.740
it makes things like a parent up to Gil easier.


00:57:31.740 --> 00:57:33.980
It might also simplify no Gil, I think.


00:57:33.980 --> 00:57:35.900
>> Yeah, probably.


00:57:35.900 --> 00:57:37.740
Because once you know something's immortal,


00:57:37.740 --> 00:57:43.660
and probably also immutable, then you can share it all you want.


00:57:43.660 --> 00:57:43.900
Yeah.


00:57:43.900 --> 00:57:44.940
>> Exactly.


00:57:44.940 --> 00:57:45.180
Yeah.


00:57:45.180 --> 00:57:46.460
So you don't have to worry about--


00:57:46.460 --> 00:57:48.620
yeah, exactly.


00:57:48.620 --> 00:57:48.940
Yeah.


00:57:48.940 --> 00:57:49.980
>> Yeah, yeah.


00:57:49.980 --> 00:57:51.740
So some of that state that's really hard


00:57:51.740 --> 00:57:53.860
to create one per interpreter, you're just like,


00:57:53.860 --> 00:57:54.860
well, it doesn't change.


00:57:54.860 --> 00:57:56.180
So here it is.


00:57:56.180 --> 00:57:56.680
>>Yeah.


00:57:56.680 --> 00:57:57.340
>>You don't have to check it.


00:57:57.340 --> 00:58:00.100
>>It just kind of makes sense when you think about it,


00:58:00.100 --> 00:58:01.580
in a way, I think.


00:58:01.580 --> 00:58:04.660
Why would you track the reference count for these objects?


00:58:04.660 --> 00:58:09.540
>>Exactly.


00:58:09.540 --> 00:58:12.540
True and false are never going to be gone, so just forget it.


00:58:12.540 --> 00:58:15.100
Just tweak that memory or whatever, right?


00:58:15.100 --> 00:58:15.620
Yeah.


00:58:15.620 --> 00:58:16.260
>>Yeah.


00:58:16.260 --> 00:58:17.220
>>All right, let's see.


00:58:17.220 --> 00:58:18.740
What else have we got to cover here?


00:58:18.740 --> 00:58:23.740
Maybe the issues in PR backlog?


00:58:23.740 --> 00:58:24.740
Sure.


00:58:24.740 --> 00:58:27.740
That's one of the, I think that's the longest one.


00:58:27.740 --> 00:58:33.740
Okay, yeah, this is a pretty interesting aspect because it has to do with the developer in


00:58:33.740 --> 00:58:37.740
Residence, and Lukasch Lange, and all the improvements that having somebody dedicated


00:58:37.740 --> 00:58:40.740
to that role has brought, right?


00:58:40.740 --> 00:58:45.740
- Yeah, so there are a lot of open issues


00:58:45.740 --> 00:58:48.080
and open PRs on CPython Reaper.


00:58:48.080 --> 00:58:54.700
So this talk was essentially kind of taking a step back


00:58:54.700 --> 00:58:58.740
and looking philosophically about it


00:58:58.740 --> 00:59:03.100
and sort of saying, well, what is an issue for?


00:59:03.100 --> 00:59:05.500
You know, why there's all these issues.


00:59:05.500 --> 00:59:07.700
Some of them haven't had activity on them


00:59:07.700 --> 00:59:10.120
for five years or whatever.


00:59:10.120 --> 00:59:13.940
like, why is that issue still open?


00:59:13.940 --> 00:59:16.100
Like, what is that doing for us really?


00:59:16.100 --> 00:59:16.940
- Yeah, yeah.


00:59:16.940 --> 00:59:18.060
And also, I guess really quick shout out,


00:59:18.060 --> 00:59:20.700
this is from a Reet Kattrail.


00:59:20.700 --> 00:59:21.520
- Yes.


00:59:21.520 --> 00:59:23.380
- This talk.


00:59:23.380 --> 00:59:25.800
So I think that's, it's like two perspectives, right?


00:59:25.800 --> 00:59:29.140
You see the person who, when they open their phone


00:59:29.140 --> 00:59:32.920
at the bottom, it has 26,214 unread messages,


00:59:32.920 --> 00:59:34.500
the first is inbox zero.


00:59:34.500 --> 00:59:37.460
Like, you know, it's like, well,


00:59:37.460 --> 00:59:39.060
if we can't close this issue


00:59:39.060 --> 00:59:42.260
and we can't deal with it within five years,


00:59:42.260 --> 00:59:43.540
it's just friction.


00:59:43.540 --> 00:59:46.700
That's one side of the argument, I suspect,


00:59:46.700 --> 00:59:47.540
is it's friction.


00:59:47.540 --> 00:59:49.500
The other people are like, "Well, this is history."


00:59:49.500 --> 00:59:52.020
- Yeah. - Historical friction.


00:59:52.020 --> 00:59:52.860
What do we do about it?


00:59:52.860 --> 00:59:54.200
- Yeah, I know.


00:59:54.200 --> 00:59:57.740
So, Sahi Spachaka,


00:59:57.740 --> 01:00:03.420
one of the most prolific CPython core developers


01:00:03.420 --> 01:00:06.660
who's contributed more to CPython, like I say.


01:00:08.860 --> 01:00:13.060
You're saying, well, you know, sometimes I do come back to issues after five years.


01:00:13.060 --> 01:00:19.380
And I do, I am planning on working on it, but I'm working on a lot of things and have


01:00:19.380 --> 01:00:22.780
hundreds of local branches and I'm working on loads of things at once.


01:00:22.780 --> 01:00:27.300
And sometimes I forget about something for five years and then come back to it, which is


01:00:27.300 --> 01:00:28.220
which is totally fair.


01:00:28.220 --> 01:00:30.340
It is fair.


01:00:30.340 --> 01:00:32.100
But I don't think.


01:00:32.100 --> 01:00:38.060
Like one person isn't going to fix all of those issues, you know, when you've got.


01:00:38.060 --> 01:00:41.140
How many is it now?


01:00:41.140 --> 01:00:48.140
Let's see, over 6,500 open issues on the CPython repo.


01:00:48.140 --> 01:00:49.620
>> Yeah.


01:00:49.620 --> 01:00:50.500
>> Yeah.


01:00:50.500 --> 01:00:52.740
>> I don't know how I would actually fall on this.


01:00:52.740 --> 01:00:54.900
I mean, on one hand,


01:00:54.900 --> 01:00:58.300
I totally get that you want to keep it around.


01:00:58.300 --> 01:01:00.660
On the other, if it was something really important,


01:01:00.660 --> 01:01:04.620
it would probably resurface again anyway.


01:01:04.620 --> 01:01:05.620
You know what I mean?


01:01:05.620 --> 01:01:09.120
- Yeah, yeah, no, I completely get that.


01:01:09.120 --> 01:01:14.660
I think at the moment, my personal opinion is


01:01:14.660 --> 01:01:17.620
we do have too many open issues at the moment,


01:01:17.620 --> 01:01:20.780
and a lot of them just aren't ever gonna have,


01:01:20.780 --> 01:01:22.020
either aren't gonna get fixed,


01:01:22.020 --> 01:01:23.580
or if they are gonna get fixed,


01:01:23.580 --> 01:01:25.740
it's not because of the issue being open.


01:01:25.740 --> 01:01:28.880
Like somebody else will just come along and be like,


01:01:28.880 --> 01:01:30.020
I'm gonna fix this now.


01:01:30.020 --> 01:01:32.860
- Yeah, I mean, I feel like you could,


01:01:32.860 --> 01:01:35.340
it's on GitHub now, you could apply a tag to it


01:01:35.340 --> 01:01:38.840
like closed due to old age or something.


01:01:38.840 --> 01:01:41.020
- Yeah. - And just close them.


01:01:41.020 --> 01:01:41.980
They can be reopened.


01:01:41.980 --> 01:01:43.700
People could go, well, I really wanna see all the ones


01:01:43.700 --> 01:01:45.100
that were closed due to old age,


01:01:45.100 --> 01:01:46.540
plus the ones that are open.


01:01:46.540 --> 01:01:50.100
You know, just create a search that shows that view.


01:01:50.100 --> 01:01:50.940
Yeah.


01:01:50.940 --> 01:01:53.380
- Somebody's really bored and it's like,


01:01:53.380 --> 01:01:57.020
I really wanna fix some Tkinter feature requests


01:01:57.020 --> 01:01:57.980
from 20 years ago.


01:01:57.980 --> 01:02:02.340
- Can scroll through that, isn't it?


01:02:02.340 --> 01:02:04.540
Yeah.


01:02:04.540 --> 01:02:06.060
- All right, let's, yeah, for sure.


01:02:06.060 --> 01:02:06.900
Okay.


01:02:06.900 --> 01:02:10.940
It's an interesting conversation and discussion


01:02:10.940 --> 01:02:12.060
and what to think about,


01:02:12.060 --> 01:02:14.940
but it's not something that directly affects people.


01:02:14.940 --> 01:02:16.420
Like that's the perfect kind of thing


01:02:16.420 --> 01:02:18.540
that's like handled at this meeting, right?


01:02:18.540 --> 01:02:19.380
'Cause it's really about that.


01:02:19.380 --> 01:02:21.180
- Exactly, yeah.


01:02:21.180 --> 01:02:24.040
- All right, the final one, the fstring grammar.


01:02:24.040 --> 01:02:25.740
We've got fstrings in Python 3.6


01:02:25.740 --> 01:02:29.340
and it's one of the most popular languages added recently,


01:02:29.340 --> 01:02:30.220
language features.


01:02:30.220 --> 01:02:31.980
Everyone loves it.


01:02:31.980 --> 01:02:34.660
I've heard people upgrading to 3.6 and beyond,


01:02:34.660 --> 01:02:35.960
or throwing away old versions


01:02:35.960 --> 01:02:38.580
just so they can write f-strings, which is great.


01:02:38.580 --> 01:02:43.140
But it turns out that the actual parser for f-strings


01:02:43.140 --> 01:02:45.260
is kind of insane, I had no idea.


01:02:45.260 --> 01:02:46.080
Tell us about that.


01:02:46.080 --> 01:02:49.300
- Yeah, so it's, I think it's,


01:02:49.300 --> 01:02:50.460
how many lines of code is it?


01:02:50.460 --> 01:02:52.380
I think I wrote it in the article.


01:02:52.380 --> 01:02:57.380
- 1,400 lines of custom C parser code


01:02:57.380 --> 01:02:59.020
just for f-strings. - Thank you.


01:02:59.020 --> 01:03:01.920
- That's separate from the regular parser.


01:03:01.920 --> 01:03:06.920
Yeah, so this whole file is just manually handwritten C code


01:03:06.920 --> 01:03:08.700
to parse f-strings.


01:03:08.700 --> 01:03:12.880
And Pablo brought up this crazy slide on that.


01:03:12.880 --> 01:03:16.280
So this talk was by Pablo Goendo Salgado.


01:03:16.280 --> 01:03:21.320
He is a core developer, steering council member,


01:03:21.320 --> 01:03:25.200
and release manager for Python 3.10 and 3.11.


01:03:28.560 --> 01:03:31.920
Yeah, so this is his big project.


01:03:31.920 --> 01:03:41.440
So yeah, Pablo put up this crazy slide


01:03:41.440 --> 01:03:45.800
showing the dance that the interpreter has to go through


01:03:45.800 --> 01:03:47.600
whenever it encounters an F string.


01:03:47.600 --> 01:03:53.880
Just like past--


01:03:53.880 --> 01:03:55.880
- It sounds really tricky to figure out


01:03:55.880 --> 01:03:58.240
'cause you've got all the captured variables.


01:03:58.240 --> 01:03:59.880
you gotta figure out how to pass those over.


01:03:59.880 --> 01:04:02.200
Then it goes to the parser and it's like, oh, geez.


01:04:02.200 --> 01:04:03.040
Okay.


01:04:03.040 --> 01:04:03.860
- Yeah.


01:04:03.860 --> 01:04:04.700
- So what is the idea?


01:04:04.700 --> 01:04:06.160
The idea is to make this part of the regular parser,


01:04:06.160 --> 01:04:08.400
just move this over to like the main,


01:04:08.400 --> 01:04:10.000
to bring it into the head parser


01:04:10.000 --> 01:04:11.160
and all those kinds of things?


01:04:11.160 --> 01:04:11.980
Okay.


01:04:11.980 --> 01:04:12.820
- Yeah.


01:04:12.820 --> 01:04:16.920
So since Python 3.9, Python has had a generated parser.


01:04:16.920 --> 01:04:21.480
So like you just write all the grammar rules


01:04:21.480 --> 01:04:23.560
down in this file,


01:04:23.560 --> 01:04:28.560
according to a mini language for the grammar.


01:04:28.560 --> 01:04:33.660
And then a program will generate a very large C file


01:04:33.660 --> 01:04:38.200
to passing Python according to those rules.


01:04:38.200 --> 01:04:42.400
So it's a much nicer way of doing things.


01:04:42.400 --> 01:04:44.080
It's much less error prone


01:04:44.080 --> 01:04:46.600
because you can just generate all the C code


01:04:46.600 --> 01:04:48.580
instead of writing it all out.


01:04:48.580 --> 01:04:52.240
And so Pablo's big idea is,


01:04:52.240 --> 01:04:55.240
Yeah, let's just move all this FString passing


01:04:55.240 --> 01:04:58.240
into the grammar, do it all at the same time as that.


01:04:58.240 --> 01:05:04.720
It'll be much, much cleaner, much nicer to maintain.


01:05:04.720 --> 01:05:10.360
And it also has some exciting things for users.


01:05:10.360 --> 01:05:15.360
So it will mean that the Core Dev team


01:05:15.360 --> 01:05:20.200
will be able to do some big work on improving error messages,


01:05:20.200 --> 01:05:22.720
for example, for f-strings, it's currently quite hard to do


01:05:22.720 --> 01:05:27.640
because like, if you touch one corner of this C file,


01:05:27.640 --> 01:05:29.440
could have a chain reaction through the rest of it


01:05:29.440 --> 01:05:32.620
and cause 10 bugs and nobody wants that, so.


01:05:32.620 --> 01:05:35.120
- Yeah, that's good.


01:05:35.120 --> 01:05:37.440
That's good that the other areas of focus there


01:05:37.440 --> 01:05:39.600
has been lately on improving error messages.


01:05:39.600 --> 01:05:40.800
That's good. - Yeah.


01:05:40.800 --> 01:05:44.720
- 3.10 had improvements just in general for error messages.


01:05:44.720 --> 01:05:45.560
- Yeah, and there's been another--


01:05:45.560 --> 01:05:47.360
- Maybe it's also from the PEG parser, right?


01:05:47.360 --> 01:05:48.200
Like maybe that's related.


01:05:48.200 --> 01:05:50.460
if the peg parser already has better error messages


01:05:50.460 --> 01:05:51.940
and you can get this into the peg parser,


01:05:51.940 --> 01:05:54.800
it'll just bring along better error messages more easily.


01:05:54.800 --> 01:05:58.640
- So, like the peg, so yeah,


01:05:58.640 --> 01:06:01.140
so the peg parser is smarter than the old parser.


01:06:01.140 --> 01:06:08.300
So like the old parser couldn't like look back


01:06:08.300 --> 01:06:10.760
when it encountered the syntax error, essentially.


01:06:10.760 --> 01:06:13.760
So like if it encountered the syntax error,


01:06:13.760 --> 01:06:16.980
it would just kind of throw up its hands and die on you.


01:06:16.980 --> 01:06:21.980
Whereas the new parser is able to catch the syntax error


01:06:21.980 --> 01:06:25.400
and then kind of look around at context


01:06:25.400 --> 01:06:27.400
and then give you a better message


01:06:27.400 --> 01:06:29.000
using that context, essentially.


01:06:29.000 --> 01:06:31.860
- That's great.


01:06:31.860 --> 01:06:32.700
- Yeah.


01:06:32.700 --> 01:06:36.260
- All right, well, I think that pretty much,


01:06:36.260 --> 01:06:38.200
yeah, yeah, sure, I think that pretty much covers it.


01:06:38.200 --> 01:06:41.560
Anything else you wanna mention to people


01:06:41.560 --> 01:06:43.060
about the Language Summit?


01:06:43.060 --> 01:06:45.300
- Anything else?


01:06:45.300 --> 01:06:50.300
>> You wrote it up pretty well, I think.


01:06:50.300 --> 01:06:52.300
>> Yeah.


01:06:52.300 --> 01:06:58.300
Pyfound.blogspot.com is the address if you want to read that.


01:06:58.300 --> 01:07:02.300
>> Yeah, for sure.


01:07:02.300 --> 01:07:06.300
>> I think we pretty much covered everything.


01:07:06.300 --> 01:07:08.300
We've covered a lot, anyway.


01:07:08.300 --> 01:07:11.300
>> Yeah, we have covered a lot, Alex. That's great.


01:07:11.300 --> 01:07:12.960
All right, well, thanks for all of this


01:07:12.960 --> 01:07:15.320
and all your work on the other things as well.


01:07:15.320 --> 01:07:16.160
Before we get out of here,


01:07:16.160 --> 01:07:18.000
let me ask you the final two questions.


01:07:18.000 --> 01:07:20.600
If you're gonna write some Python code,


01:07:20.600 --> 01:07:24.340
be it 3.12 or something older, what editor are you using?


01:07:24.340 --> 01:07:28.520
- Good question.


01:07:28.520 --> 01:07:32.440
I'm actually using Idle quite a lot these days.


01:07:32.440 --> 01:07:35.760
- Okay, right on.


01:07:35.760 --> 01:07:39.380
- Yeah, I used Python for a while.


01:07:41.080 --> 01:07:43.920
I've tried out VS Code several times.


01:07:43.920 --> 01:07:45.520
I've never really got on with it.


01:07:45.520 --> 01:07:46.620
I'm not quite sure why.


01:07:46.620 --> 01:07:51.800
I loved all the features PyCharm had,


01:07:51.800 --> 01:07:56.320
but nowadays I'm just enjoying something


01:07:56.320 --> 01:07:57.880
that just starts up really quickly.


01:07:57.880 --> 01:07:58.840
And it's just really simple.


01:07:58.840 --> 01:08:00.180
- Simple and simple.


01:08:00.180 --> 01:08:01.660
All right, cool.


01:08:01.660 --> 01:08:05.080
And then notable PyPI package or library,


01:08:05.080 --> 01:08:06.400
something I wanna give a shout out to.


01:08:06.400 --> 01:08:09.040
I mean, we kind of sort of did that in a meta sense


01:08:09.040 --> 01:08:11.220
with TypeScript, or TypeShed rather.


01:08:11.220 --> 01:08:16.280
- Yeah, am I allowed to shout out my own packages?


01:08:16.280 --> 01:08:19.480
- You can shout out whatever you want, absolutely.


01:08:19.480 --> 01:08:25.800
- I'll just give another shout out to Specialist, I think.


01:08:25.800 --> 01:08:27.840
I think that's really cool.


01:08:27.840 --> 01:08:30.040
- Okay, yeah, Specialist is neat.


01:08:30.040 --> 01:08:32.200
I'm glad I learned about that today, that's cool.


01:08:32.200 --> 01:08:34.440
All right, well.


01:08:34.440 --> 01:08:36.040
- Then I can seem magnanimous


01:08:36.040 --> 01:08:38.040
by shouting out somebody else's project.


01:08:38.040 --> 01:08:40.000
[LAUGHS]


01:08:40.000 --> 01:08:40.960
There you go.


01:08:40.960 --> 01:08:42.960
All right, well, thanks for doing the write-up.


01:08:42.960 --> 01:08:45.380
Thanks for taking good notes and sharing it with everyone.


01:08:45.380 --> 01:08:48.340
Because while it makes total sense


01:08:48.340 --> 01:08:52.360
that the Language Summit is this closed-door story where


01:08:52.360 --> 01:08:54.100
people can have open conversations


01:08:54.100 --> 01:08:57.020
and just keep it amongst the core developers,


01:08:57.020 --> 01:08:59.560
I know everyone in the community really appreciates


01:08:59.560 --> 01:09:02.220
having a sense of what's coming, where the focus is,


01:09:02.220 --> 01:09:04.260
what people are worried about, and so on.


01:09:04.260 --> 01:09:06.960
So thanks for getting that out in the light for us.


01:09:06.960 --> 01:09:10.240
- Yeah, no worries, it was fun to do.


01:09:10.240 --> 01:09:12.480
Really fun to have this conversation.


01:09:12.480 --> 01:09:14.740
- Yeah, you bet.


01:09:14.740 --> 01:09:16.100
Thanks.


01:09:16.100 --> 01:09:17.460
- Awesome, thanks, Michael.

