WEBVTT

00:00:00.000 --> 00:00:02.280
- Hello everyone out there watching the live stream


00:00:02.280 --> 00:00:03.120
or watching the replay.


00:00:03.120 --> 00:00:04.280
Thank you for being here.


00:00:04.280 --> 00:00:05.800
Rod, great to see you.


00:00:05.800 --> 00:00:06.800
- Thanks for having me.


00:00:06.800 --> 00:00:08.960
- Yeah, it's fantastic to have you here.


00:00:08.960 --> 00:00:10.840
We're gonna talk about some cool stuff on this podcast.


00:00:10.840 --> 00:00:14.680
So let's go ahead and just kick it off officially.


00:00:14.680 --> 00:00:16.000
- Sure.


00:00:16.000 --> 00:00:18.240
- Rod, welcome to Talk By The Enemy.


00:00:18.240 --> 00:00:19.080
- Thank you.


00:00:19.080 --> 00:00:21.160
- Yeah, it's super to have you here.


00:00:21.160 --> 00:00:23.480
There's a lot of things you've been building


00:00:23.480 --> 00:00:24.800
and you've been working on.


00:00:24.800 --> 00:00:25.960
So let's get started.


00:00:25.960 --> 00:00:26.800
- Yeah, let's get started.


00:00:26.800 --> 00:00:27.640
- So let's get started.


00:00:27.640 --> 00:00:33.480
There's a lot of things you've been building for different companies through your work.


00:00:33.480 --> 00:00:37.640
That's going to be really fun to explore. I think one of the really neat things here is


00:00:37.640 --> 00:00:44.040
you're not just working for one company, working on one team the way it works, but you're kind of


00:00:44.040 --> 00:00:48.360
interacting with a bunch of different projects and types of technologies. So you'll have a


00:00:48.360 --> 00:00:52.600
good broad perspective on what went well, what didn't, what you would change and so on.


00:00:53.240 --> 00:00:54.240
- That's true.


00:00:54.240 --> 00:00:57.800
Python is the one thing that stuck with me since 1997


00:00:57.800 --> 00:00:59.360
across different companies,


00:00:59.360 --> 00:01:01.560
let's say like five different companies,


00:01:01.560 --> 00:01:04.400
two different continents,


00:01:04.400 --> 00:01:07.680
but Python was the one thing that remained the same.


00:01:07.680 --> 00:01:08.520
- That's fantastic.


00:01:08.520 --> 00:01:10.720
A good choice indeed.


00:01:10.720 --> 00:01:13.320
Well, let's start this conversation


00:01:13.320 --> 00:01:15.720
by talking about your story


00:01:15.720 --> 00:01:17.760
and how you got into programming in Python.


00:01:17.760 --> 00:01:20.480
It sounds like you were one of the early adopters.


00:01:20.480 --> 00:01:21.640
What version of Python?


00:01:21.640 --> 00:01:23.560
That was probably a version one type of thing.


00:01:23.560 --> 00:01:24.400
- It was 1.5.2.


00:01:24.400 --> 00:01:25.240
- Okay.


00:01:25.240 --> 00:01:27.120
- It was in 1997.


00:01:27.120 --> 00:01:33.240
At that time, I was almost finishing my undergraduate course


00:01:33.240 --> 00:01:35.800
in computer engineering.


00:01:35.800 --> 00:01:40.800
And I already engaged in my master's post-graduation course.


00:01:40.800 --> 00:01:42.760
And one of the--


00:01:42.760 --> 00:01:43.600
- What were you studying?


00:01:43.600 --> 00:01:44.600
What was your degree?


00:01:44.600 --> 00:01:49.240
- Well, my undergraduate degree was computer engineering.


00:01:49.240 --> 00:01:53.160
But for the master thesis, I was studying computational reflection.


00:01:53.160 --> 00:01:59.040
In the end, it's the line of research that led to AspectJ and other things.


00:01:59.040 --> 00:02:03.680
But it was all about object-oriented protocols.


00:02:03.680 --> 00:02:08.280
So how you organize object orientation in programming languages, those kind of things.


00:02:08.280 --> 00:02:09.320
- Okay, cool.


00:02:09.320 --> 00:02:13.280
And AspectJ, that's like aspect-oriented programming?


00:02:13.280 --> 00:02:14.160
- Exactly.


00:02:14.280 --> 00:02:20.160
Aspect-oriented programming was like a byproduct of the research in computational reflection.


00:02:20.160 --> 00:02:28.600
At the time, we were, academically speaking, we were trying to figure out what can you do with reflection.


00:02:28.600 --> 00:02:35.920
I think Java was one of the languages that made it popular to do introspection and reflection in programming languages.


00:02:35.920 --> 00:02:39.880
Of course, we had that in Lisp, like, since back to the 70s.


00:02:40.240 --> 00:02:45.120
But Java made it like known to the wide world.


00:02:45.120 --> 00:02:48.560
So then we became like researching more formally.


00:02:48.560 --> 00:02:52.080
And I started probing supports


00:02:52.080 --> 00:02:55.400
for reflective programming in programming languages.


00:02:55.400 --> 00:02:57.000
And that meant not only Java,


00:02:57.000 --> 00:03:00.360
but at the time, Perl, Python, Tcl.


00:03:00.360 --> 00:03:02.760
And once I saw Python,


00:03:02.760 --> 00:03:05.360
it felt like a glove to my hands.


00:03:05.360 --> 00:03:07.560
And then I stuck with it.


00:03:07.560 --> 00:03:09.920
>> Yeah. That's really neat.


00:03:09.920 --> 00:03:12.040
Maybe you could just talk a little tiny bit


00:03:12.040 --> 00:03:14.480
about what reflection is for people listening here,


00:03:14.480 --> 00:03:18.660
maybe who haven't done a lot of Java or .NET,


00:03:18.660 --> 00:03:19.920
they have it as well.


00:03:19.920 --> 00:03:22.040
And in Python, we have it in the sense


00:03:22.040 --> 00:03:25.360
that you can go in and explore the types


00:03:25.360 --> 00:03:28.880
and so give it an object, what if it's class,


00:03:28.880 --> 00:03:30.040
and what if it's meta class,


00:03:30.040 --> 00:03:32.000
and you can dig into it and even change it.


00:03:32.000 --> 00:03:36.640
But I don't typically hear it referred to as reflection


00:03:36.640 --> 00:03:38.440
in the Python ecosystem.


00:03:38.440 --> 00:03:40.000
- Right, yeah.


00:03:40.000 --> 00:03:45.000
Introspection became a more common term used,


00:03:45.000 --> 00:03:49.840
but at the time, reflection was about creating programs


00:03:49.840 --> 00:03:51.760
that reason about programs.


00:03:51.760 --> 00:03:55.440
So it was about this meta-level reasoning.


00:03:55.440 --> 00:03:58.920
And it was very popular to do non-functional aspects.


00:03:58.920 --> 00:04:01.080
So you once write your codes,


00:04:01.080 --> 00:04:03.800
and the code has the functional aspects,


00:04:03.800 --> 00:04:06.940
what it do, how it like transform things.


00:04:06.940 --> 00:04:10.500
And then the non-functional aspects like logging,


00:04:10.500 --> 00:04:14.740
persistency, monitoring, those kinds of things,


00:04:14.740 --> 00:04:18.200
people were exploring how to detach, decouple those things


00:04:18.200 --> 00:04:22.000
from your actual program and do that on a separate layer.


00:04:22.000 --> 00:04:25.420
And that was what Reflection was all about.


00:04:25.420 --> 00:04:30.100
It was about having as inputs, your own code


00:04:30.100 --> 00:04:34.180
and as output changing the behavior of your program.


00:04:34.180 --> 00:04:36.880
And the way we attacked that at the time


00:04:36.880 --> 00:04:39.580
was by an interception mechanism.


00:04:39.580 --> 00:04:42.100
So Python always had that,


00:04:42.100 --> 00:04:45.360
I think they called the DOM buildery hook


00:04:45.360 --> 00:04:46.580
or something like that,


00:04:46.580 --> 00:04:48.980
where you could like intercept like anything


00:04:48.980 --> 00:04:50.260
that was happening there.


00:04:50.260 --> 00:04:54.420
We do have the debugging hook in the sys module


00:04:54.420 --> 00:04:59.420
that allow us to like pause your computation


00:04:59.420 --> 00:05:01.180
and see what's happening.


00:05:01.180 --> 00:05:02.800
But other programming languages,


00:05:02.800 --> 00:05:06.140
and at the time we're talking about the 90s,


00:05:06.140 --> 00:05:10.460
the popular ones were statically compiled programming languages.


00:05:10.460 --> 00:05:13.980
- Right, C, C++, they generally don't have this behavior, yeah?


00:05:13.980 --> 00:05:18.220
- Exactly. Sometimes they had runtime type information


00:05:18.220 --> 00:05:22.620
when you compiled your source code enabling that.


00:05:22.620 --> 00:05:26.940
- That's right, I remember there was an RTTI option in C++,


00:05:26.940 --> 00:05:28.300
but it was off by default.


00:05:28.300 --> 00:05:33.820
- Exactly. But in the interpreted world, you had everything, right?


00:05:33.820 --> 00:05:36.480
You have the interpreter during runtime.


00:05:36.480 --> 00:05:39.500
Sometimes you had the compiler as well,


00:05:39.500 --> 00:05:42.380
which was true for Java, which was true for Python,


00:05:42.380 --> 00:05:47.220
Perl, all the interpreted dynamically languages.


00:05:47.220 --> 00:05:49.060
And then that became more of a thing.


00:05:49.060 --> 00:05:54.420
Of course, in time, people realized there were other ways


00:05:54.420 --> 00:05:59.420
to achieve the same goals, which were more effective,


00:05:59.420 --> 00:06:03.660
because one of the main things with introspection


00:06:03.660 --> 00:06:09.020
and interception is that everything that is happening in your program,


00:06:09.020 --> 00:06:13.500
it's kind of being reified, delivered to this meta level,


00:06:13.500 --> 00:06:22.540
and then handled as data. So that is like a major break in speed, right?


00:06:22.540 --> 00:06:26.940
So it was not the answer for everything, especially when you wanted


00:06:26.940 --> 00:06:30.460
to have like runtime performance. But for


00:06:30.460 --> 00:06:33.020
things that were offline batch or analysis,


00:06:33.020 --> 00:06:34.740
it was not a problem.


00:06:34.740 --> 00:06:38.140
One thing, an exercise that I've done at the time,


00:06:38.140 --> 00:06:44.340
which is interesting, was to introduce a debugger during runtime.


00:06:44.340 --> 00:06:48.500
Because we had this reflection mechanism that works just like this,


00:06:48.500 --> 00:06:52.200
you could take possession of an object,


00:06:52.200 --> 00:06:54.620
and then any direction with these objects,


00:06:54.620 --> 00:06:57.040
which go to its guardian angel,


00:06:57.040 --> 00:07:00.100
which I call the meta object of this object.


00:07:00.100 --> 00:07:02.740
Then the meta object decided what to do,


00:07:02.740 --> 00:07:04.980
to lie about what has happened,


00:07:04.980 --> 00:07:09.300
to just delegate back to that object down there,


00:07:09.300 --> 00:07:13.340
do something else, become a proxy, solve the computation.


00:07:13.340 --> 00:07:14.820
You could do anything.


00:07:14.820 --> 00:07:18.520
In that case, we could install a debugger just for


00:07:18.520 --> 00:07:22.220
a given class or a given instance of your program,


00:07:22.220 --> 00:07:26.020
and then propagate like a virus for anything,


00:07:26.020 --> 00:07:28.700
either that class or instance touched.


00:07:28.700 --> 00:07:32.060
So that was kind of interesting, a new dimension of programming,


00:07:32.060 --> 00:07:35.260
but became more as an academical exercise.


00:07:35.260 --> 00:07:42.060
And the only thing that I remember that kind of succeeded into the industry


00:07:42.060 --> 00:07:44.940
was aspect-oriented programming of sorts.


00:07:44.940 --> 00:07:47.260
Right. Yeah. Well, that's very interesting.


00:07:47.260 --> 00:07:51.900
It seems to me a little bit like decorators.


00:07:51.900 --> 00:07:55.420
Yes, decorators are rappers.


00:07:56.780 --> 00:07:59.900
But the thing is, they are not transparent.


00:07:59.900 --> 00:08:04.300
So whenever you create a decorator or a proxy,


00:08:04.300 --> 00:08:06.700
what's happening is that the references you had


00:08:06.700 --> 00:08:10.500
to the original objects now need to point to the wrapper,


00:08:10.500 --> 00:08:12.220
to the decorator, right?


00:08:12.220 --> 00:08:17.220
So the key insights for a reflectional computation


00:08:17.220 --> 00:08:19.660
that we were exploring at the time


00:08:19.660 --> 00:08:23.260
was how do we make this proxy totally transparent?


00:08:23.260 --> 00:08:27.700
So if you have a pointer or a reference to an object,


00:08:27.700 --> 00:08:32.700
before it became reflective, it would still be valid.


00:08:32.700 --> 00:08:36.740
So you can turn on and off those introspection mechanisms


00:08:36.740 --> 00:08:40.300
and interception mechanism, and it's totally transparent.


00:08:40.300 --> 00:08:44.800
So to achieve that, we had to change the interpreter.


00:08:44.800 --> 00:08:46.940
So that's how we've done it for Java,


00:08:46.940 --> 00:08:49.180
and that's how I was exploring at the time


00:08:49.180 --> 00:08:51.100
for Python itself and Perl,


00:08:51.100 --> 00:08:56.940
to change the interpreter to add the hook in there and do transparent wrapping.


00:08:56.940 --> 00:09:02.980
>> Yeah. It seems like some of the new peps might make it possible to plug in now,


00:09:02.980 --> 00:09:04.580
rather than actually change it.


00:09:04.580 --> 00:09:07.980
I know there's that JIT plug-in that they're working in,


00:09:07.980 --> 00:09:12.860
that where you can intercept the method parsing compilation bits and stuff.


00:09:12.860 --> 00:09:13.980
I don't remember the number.


00:09:13.980 --> 00:09:18.900
>> Yeah. I haven't explored doing it to modern Python.


00:09:18.900 --> 00:09:24.620
At the time, I did some exercises using the debug hook.


00:09:24.620 --> 00:09:26.220
>> Yeah.


00:09:26.220 --> 00:09:30.380
>> It works, but it was messy and super slow.


00:09:30.380 --> 00:09:34.860
I stopped, but it will be interesting to revisit that again.


00:09:34.860 --> 00:09:37.820
>> Yeah, I'm sure. I do remember


00:09:37.820 --> 00:09:41.180
how interesting all the research was around that time.


00:09:41.180 --> 00:09:44.100
I feel like a lot of what's happening now,


00:09:44.100 --> 00:09:45.980
it's getting a little more structured,


00:09:45.980 --> 00:09:48.740
a little less dynamic with things like decorators.


00:09:48.740 --> 00:09:51.700
other types of wrappers and inner functions and stuff.


00:09:51.700 --> 00:09:54.420
But yeah, quite an interesting time.


00:09:54.420 --> 00:09:55.780
So how about now?


00:09:55.780 --> 00:09:58.780
Maybe we can talk about what you're doing these days.


00:09:58.780 --> 00:09:59.620
- Oh yeah.


00:09:59.620 --> 00:10:03.420
So nowadays I'm a technology director at Working Coal.


00:10:03.420 --> 00:10:06.180
Working Coal is a digital products company


00:10:06.180 --> 00:10:10.900
where we not only do designs and strategy,


00:10:10.900 --> 00:10:14.940
but we also do implementation and quality assurance


00:10:14.940 --> 00:10:17.300
for the projects that we take on.


00:10:17.300 --> 00:10:20.460
So that's what makes us different from just an agency,


00:10:20.460 --> 00:10:24.140
a design agency, because the founders of Working Coal


00:10:24.140 --> 00:10:27.500
realize that it's much better for the clients


00:10:27.500 --> 00:10:29.980
to hire a single entity


00:10:29.980 --> 00:10:33.020
to do the full digital products turnkey.


00:10:33.020 --> 00:10:36.540
And then we can make sure that whatever we design,


00:10:36.540 --> 00:10:38.260
it's possible to build.


00:10:38.260 --> 00:10:40.220
So that is the vision for Working Coal.


00:10:40.220 --> 00:10:45.060
We are very successful, I must say.


00:10:45.060 --> 00:10:48.500
In a few years, Working Code won many prizes.


00:10:48.500 --> 00:10:52.260
It became famous for the Virgin America app


00:10:52.260 --> 00:10:55.540
for booking passages with Virgin America,


00:10:55.540 --> 00:10:58.740
which was, I guess, five or six years ago.


00:10:58.740 --> 00:11:01.660
But we're doing things for like Apple, Google,


00:11:01.660 --> 00:11:03.200
Chase, you name it.


00:11:03.200 --> 00:11:06.740
- Yeah, and I know that involves a lot of Python.


00:11:06.740 --> 00:11:08.780
Does it involve other technology?


00:11:08.780 --> 00:11:10.900
Yeah, probably other technologies as well, right?


00:11:10.900 --> 00:11:11.740
Somebody comes and says,


00:11:11.740 --> 00:11:13.040
"Well, we want this thing designed


00:11:13.040 --> 00:11:15.680
and where our Java shops don't make it for Java.


00:11:15.680 --> 00:11:19.040
- Yeah, whatever happens is usually,


00:11:19.040 --> 00:11:21.320
there are projects that are just design,


00:11:21.320 --> 00:11:24.080
projects that are design plus front-end work,


00:11:24.080 --> 00:11:26.560
projects that go all the way through to back-end.


00:11:26.560 --> 00:11:29.440
Sometimes back-end is just like a mediator


00:11:29.440 --> 00:11:32.400
for some infrastructure that the client already have,


00:11:32.400 --> 00:11:35.680
but there are other times where we have to do everything,


00:11:35.680 --> 00:11:39.680
like the full digital platform for the client.


00:11:39.680 --> 00:11:44.680
And in those cases, Python becomes a key technology for us


00:11:44.680 --> 00:11:48.360
because what Python gives you most in my experience


00:11:48.360 --> 00:11:51.840
is optimizing for development time, right?


00:11:51.840 --> 00:11:54.280
It's people are very much concerned


00:11:54.280 --> 00:11:57.040
about Python runtime efficiency,


00:11:57.040 --> 00:12:01.600
but the key problem is development efficiency, right?


00:12:01.600 --> 00:12:05.320
Most of the time, if it's a little bit slower,


00:12:05.320 --> 00:12:09.200
like in comparison, a Formula One car


00:12:09.200 --> 00:12:12.880
in a regular vehicle, one is much faster than the other,


00:12:12.880 --> 00:12:16.800
we don't need Formula One cars most of the time, right?


00:12:16.800 --> 00:12:17.640
- That's right.


00:12:17.640 --> 00:12:19.280
- So it's like fast enough.


00:12:19.280 --> 00:12:20.520
And that is the point.


00:12:20.520 --> 00:12:24.120
So for many things, Python is fast enough.


00:12:24.120 --> 00:12:26.600
But in terms of development time,


00:12:26.600 --> 00:12:28.560
Python is the Formula One vehicle.


00:12:28.560 --> 00:12:29.840
It's like super fast.


00:12:29.840 --> 00:12:31.600
It's super easy to throw things away.


00:12:31.600 --> 00:12:33.200
It's super easy to explore.


00:12:33.200 --> 00:12:36.640
It can touch every niche in computer science.


00:12:36.640 --> 00:12:37.480
And I--


00:12:37.480 --> 00:12:38.560
- It has high PI.


00:12:38.560 --> 00:12:41.140
- Yeah, it has, exactly, it has PyPI, right?


00:12:41.140 --> 00:12:42.600
For example, you can-- - Exactly, exactly.


00:12:42.600 --> 00:12:44.160
- pip install this and go, yeah.


00:12:44.160 --> 00:12:47.940
- Exactly, so it was a key technology for us


00:12:47.940 --> 00:12:49.640
in those cases that we have


00:12:49.640 --> 00:12:52.320
an extremely agile cycle of development,


00:12:52.320 --> 00:12:54.560
lots of changes because design was sometimes


00:12:54.560 --> 00:12:57.160
moving along the way, and we need to rebuild


00:12:57.160 --> 00:12:59.520
the backend infrastructure overnight.


00:12:59.520 --> 00:13:03.100
So because for those scenarios, it was key.


00:13:03.100 --> 00:13:06.460
- Yeah, okay, well, I think the conversation


00:13:06.460 --> 00:13:09.860
around performance in Python is super interesting


00:13:09.860 --> 00:13:14.020
because there's just so many layers and variations.


00:13:14.020 --> 00:13:16.460
And what are you trying to do?


00:13:16.460 --> 00:13:19.340
Well, if you're trying to do a tight loop that does math,


00:13:19.340 --> 00:13:20.160
guess what?


00:13:20.160 --> 00:13:21.420
Python's bad at that.


00:13:21.420 --> 00:13:22.500
But maybe you shouldn't be doing that.


00:13:22.500 --> 00:13:26.140
Maybe you should be using NumPy and the SciPy stuff.


00:13:26.140 --> 00:13:28.300
And then all of a sudden it's C speed again.


00:13:28.300 --> 00:13:34.220
Maybe you're doing some data driven web API


00:13:34.220 --> 00:13:36.140
and you're like, well, it might be slow.


00:13:36.140 --> 00:13:43.240
well, actually what you're doing is you're orchestrating exchange of JSON and talking to a database server or cluster.


00:13:43.240 --> 00:13:47.040
And it's almost exactly the same speed as if it were written in C,


00:13:47.040 --> 00:13:49.440
because you're mostly waiting on the database and waiting on the network.


00:13:49.440 --> 00:13:52.040
And, right, there's all of those things.


00:13:52.040 --> 00:13:56.140
And then on top of it is this thing that you talk about that often gets ignored.


00:13:56.140 --> 00:13:59.640
There's a really interesting story in,


00:14:00.240 --> 00:14:03.920
It was recounted in Mike Driscoll's Python Interviews book


00:14:03.920 --> 00:14:09.480
about the competition between Google Video and YouTube


00:14:09.480 --> 00:14:12.680
and how Google Video had like 100 C++ engineers


00:14:12.680 --> 00:14:17.120
and YouTube, this little startup, had 20 Python developers.


00:14:17.120 --> 00:14:20.360
And YouTube was just blowing away all the Google engineers


00:14:20.360 --> 00:14:22.480
because they could add features faster


00:14:22.480 --> 00:14:24.280
and if Google would do something, they could copy it,


00:14:24.280 --> 00:14:26.280
re-implement it really quickly.


00:14:26.280 --> 00:14:29.840
And so Google fixed the problem by buying YouTube.


00:14:29.840 --> 00:14:33.360
It's still Python to some degree there.


00:14:33.360 --> 00:14:36.640
So I think that's a really good point.


00:14:36.640 --> 00:14:40.480
Yeah, my experience, there are two like factors.


00:14:40.480 --> 00:14:45.440
One factor that you just mentioned is having it under control when it grows.


00:14:45.440 --> 00:14:48.240
So software is like a living thing.


00:14:48.240 --> 00:14:52.560
You start a project, it gets, it's born, it starts to grow.


00:14:52.560 --> 00:14:56.000
Does it become a sequoia or does it become blackberry bushes?


00:14:56.000 --> 00:15:06.800
Exactly. But it has this life cycle, right? At some point, depending on its history, it gets out of control.


00:15:06.800 --> 00:15:13.600
So if you didn't have the proper team, the proper guidance, it can become the problem.


00:15:13.600 --> 00:15:18.600
Not the problem it was supposed to solve, but the software itself becomes a problem.


00:15:18.600 --> 00:15:24.900
And then people tend to, "Oh, let's throw this away and get something else because this is unmanageable."


00:15:24.900 --> 00:15:30.740
And I don't think it's an intrinsic problem on any programming language or infrastructure.


00:15:30.740 --> 00:15:40.180
It's more between the matching of did the team that was doing this really master the technology at the time.


00:15:40.180 --> 00:15:45.140
If they do, it could be Fortran, COBOL, C++ or Python.


00:15:45.140 --> 00:15:46.380
You have good results.


00:15:46.380 --> 00:15:54.420
If they didn't, they might get into this one-way road in the opposite direction.


00:15:54.420 --> 00:15:54.920
>> Yeah.


00:15:54.920 --> 00:15:56.960
>> Then they're screwed.


00:15:56.960 --> 00:15:58.500
This is one thing.


00:15:58.500 --> 00:16:01.060
The other thing, it's all about


00:16:01.060 --> 00:16:04.940
flexibility and the performance that you mentioned.


00:16:04.940 --> 00:16:07.940
For example, in this latest project that we are tackling,


00:16:07.940 --> 00:16:10.140
the GX project, we have it all.


00:16:10.140 --> 00:16:13.380
We had CPU bound problems that we're tackling,


00:16:13.380 --> 00:16:16.340
I/O bound problems, and in both cases,


00:16:16.340 --> 00:16:18.340
Python was behaving just fine.


00:16:18.340 --> 00:16:22.220
We have 16,000 users right now.


00:16:22.220 --> 00:16:24.360
We have three API instances.


00:16:24.360 --> 00:16:28.060
And when it's a performance problem, we change the algorithm,


00:16:28.060 --> 00:16:32.460
we introduce caching, we're using MongoDB for scalability,


00:16:32.460 --> 00:16:36.660
and we have zero performance issues so far.


00:16:36.660 --> 00:16:40.820
But because we have the software under control,


00:16:40.820 --> 00:16:42.820
we know what's happening in there.


00:16:42.820 --> 00:16:45.320
The technology is not a mystery.


00:16:45.320 --> 00:16:48.460
Then it's easy to pinpoint what's wrong


00:16:48.460 --> 00:16:51.960
and then replace it for a new version fast.


00:16:51.960 --> 00:16:56.280
and that's it. It's bringing results.


00:16:56.280 --> 00:16:58.240
>> That's a fantastic point.


00:16:58.240 --> 00:17:00.640
You've got the architectural considerations


00:17:00.640 --> 00:17:02.760
as well as just the raw technology, right?


00:17:02.760 --> 00:17:04.680
>> Oh, yeah. For sure.


00:17:04.680 --> 00:17:06.660
It's a single thing.


00:17:06.660 --> 00:17:10.720
That's why I use the metaphor of a living organism,


00:17:10.720 --> 00:17:13.040
because it's on an ecosystem.


00:17:13.040 --> 00:17:15.560
Your software is not an island anymore.


00:17:15.560 --> 00:17:20.720
In the past, we had this release to the desktop install,


00:17:20.720 --> 00:17:22.980
and it's all on your machine.


00:17:22.980 --> 00:17:26.760
But today it's interacting with the operating system,


00:17:26.760 --> 00:17:29.240
with the cloud, with the user.


00:17:29.240 --> 00:17:30.580
So it's alive, right?


00:17:30.580 --> 00:17:32.080
It's a dynamic ecosystem.


00:17:32.080 --> 00:17:34.360
So it's all about those interactions


00:17:34.360 --> 00:17:38.840
and understanding the dynamics on each of these interfaces


00:17:38.840 --> 00:17:42.980
and then optimizing for the Feng Shui, for the flow.


00:17:42.980 --> 00:17:44.680
- Yeah, very cool.


00:17:44.680 --> 00:17:48.720
And I want to dive into this first API


00:17:48.720 --> 00:17:50.320
because I think it's super interesting


00:17:50.320 --> 00:17:53.360
and people are gonna be really surprised by it, I'm sure.


00:17:53.360 --> 00:17:54.200
- Well, let's go.


00:17:54.200 --> 00:17:55.040
- Yeah, it'll be fun.


00:17:55.040 --> 00:17:56.900
But before I do, I do wanna ask you one more


00:17:56.900 --> 00:17:59.840
sort of big picture question.


00:17:59.840 --> 00:18:02.520
So you're working with Work & Co,


00:18:02.520 --> 00:18:03.800
you're working with all these clients


00:18:03.800 --> 00:18:07.660
as this digital agency doing this end-to-end work,


00:18:07.660 --> 00:18:09.840
which I think makes a lot of sense.


00:18:09.840 --> 00:18:14.600
What is the trends for Python that you've seen


00:18:14.600 --> 00:18:17.720
across the last five years or so?


00:18:17.720 --> 00:18:20.120
What has stood out to you from these conversations?


00:18:20.120 --> 00:18:22.040
maybe you had five, 10 years ago, you're having now,


00:18:22.040 --> 00:18:24.480
you're thinking about the future.


00:18:24.480 --> 00:18:29.240
- Yeah, the two things that are my reality, at least,


00:18:29.240 --> 00:18:31.560
and that doesn't mean like,


00:18:31.560 --> 00:18:33.320
it's a broad world that we have out there.


00:18:33.320 --> 00:18:34.560
So there's any case, right?


00:18:34.560 --> 00:18:37.240
So I'll speak just from my experience


00:18:37.240 --> 00:18:38.640
in the last three years.


00:18:38.640 --> 00:18:41.800
So there are two things that's come to mind.


00:18:41.800 --> 00:18:46.800
One of them is this like mediator thing.


00:18:46.800 --> 00:18:49.480
So because everything is in the cloud,


00:18:49.480 --> 00:18:54.220
because you're not writing any more software from scratch,


00:18:54.220 --> 00:18:57.540
you have to do integration, like gluing.


00:18:57.540 --> 00:19:00.600
Python, back in the early days,


00:19:00.600 --> 00:19:03.000
became famous as a glue language,


00:19:03.000 --> 00:19:05.420
and it was kind of gluing things in the desktop.


00:19:05.420 --> 00:19:08.720
Now Python is gluing things in the cloud.


00:19:08.720 --> 00:19:12.720
And because Python is such a versatile language


00:19:12.720 --> 00:19:15.880
in terms of a huge ecosystem of libraries,


00:19:15.880 --> 00:19:18.280
because the language itself allows you


00:19:18.280 --> 00:19:19.920
to compute like anything.


00:19:19.920 --> 00:19:23.280
It became an excellence technology for a group language.


00:19:23.280 --> 00:19:27.920
And for us, it's critical because any project


00:19:27.920 --> 00:19:31.640
we're dealing with, okay, we have to talk to a database


00:19:31.640 --> 00:19:34.040
for sure, but we also have to talk


00:19:34.040 --> 00:19:36.500
to a forecasting weather service.


00:19:36.500 --> 00:19:39.720
We have to talk to a push notification service.


00:19:39.720 --> 00:19:44.720
We have to talk to analytics system platform.


00:19:44.720 --> 00:19:47.080
So you need to send signals there.


00:19:47.080 --> 00:19:50.980
So it's this ecosystem thing, Python is great for that


00:19:50.980 --> 00:19:54.800
because you find the connectors, you find the drivers,


00:19:54.800 --> 00:19:56.720
you find examples.


00:19:56.720 --> 00:19:59.760
So all of that speeds up the cycle of development


00:19:59.760 --> 00:20:02.400
and gives you confidence that you achieve


00:20:02.400 --> 00:20:04.280
whatever you need in success, right?


00:20:04.280 --> 00:20:08.660
And in terms of ecosystems still,


00:20:08.660 --> 00:20:11.280
we're not talking about just the computer right now.


00:20:11.280 --> 00:20:14.840
So we did a project for Google, the new store in Google.


00:20:14.840 --> 00:20:16.900
there are some embedded devices there.


00:20:16.900 --> 00:20:22.120
So that's another niche, embedded systems,


00:20:22.120 --> 00:20:24.480
IoT, things for the television,


00:20:24.480 --> 00:20:26.000
we did things for Marriott,


00:20:26.000 --> 00:20:29.040
where it was like embedded on a set-top box.


00:20:29.040 --> 00:20:31.040
So this is one thing that I think we're going to see


00:20:31.040 --> 00:20:32.280
more and more often,


00:20:32.280 --> 00:20:35.160
now that we see like CPUs in your lamps,


00:20:35.160 --> 00:20:37.280
and people playing pool in their lamps.


00:20:37.280 --> 00:20:42.680
The other thing, it's the data-driven aspect.


00:20:42.680 --> 00:20:45.920
So one of the flags that I carry at Working Co.


00:20:45.920 --> 00:20:48.080
is the data-driven design.


00:20:48.080 --> 00:20:50.840
So data-driven design is like, okay,


00:20:50.840 --> 00:20:54.480
we are not doing design just based on the inspirational


00:20:54.480 --> 00:20:57.080
thing from designers and their creativity


00:20:57.080 --> 00:21:00.120
and their capacity for innovation,


00:21:00.120 --> 00:21:03.640
but anchor in data from the real world.


00:21:03.640 --> 00:21:08.640
And sometimes that approach goes all the way through


00:21:09.360 --> 00:21:12.840
conceptual design into the end product,


00:21:12.840 --> 00:21:16.200
which we are seeing with these machine learn,


00:21:16.200 --> 00:21:19.000
deep learning based products.


00:21:19.000 --> 00:21:21.200
- Email model in production behind flash.


00:21:21.200 --> 00:21:22.440
- Exactly, exactly.


00:21:22.440 --> 00:21:27.440
So that's another trend that Python is great, right?


00:21:27.440 --> 00:21:32.840
Not only for the business analytical aspects,


00:21:32.840 --> 00:21:37.840
but also for the pipelines to build models in production.


00:21:38.000 --> 00:21:39.160
- Yeah, very neat.


00:21:39.160 --> 00:21:44.040
The way you described Python as a glue language


00:21:44.040 --> 00:21:46.760
is super interesting compared to the way


00:21:46.760 --> 00:21:48.720
it's traditionally been described.


00:21:48.720 --> 00:21:51.800
Traditionally glue language meant something like,


00:21:51.800 --> 00:21:56.440
well, I've got a C library and I'm talking to Linux.


00:21:56.440 --> 00:21:58.680
And so I could write this stuff in Python


00:21:58.680 --> 00:22:02.120
that'll do some shell stuff with Linux


00:22:02.120 --> 00:22:04.800
and that it'll also like pull in the C API


00:22:04.800 --> 00:22:07.200
and just move that data from here to there and go.


00:22:07.200 --> 00:22:12.200
And it's come across a little bit as a second class thing.


00:22:12.200 --> 00:22:15.320
It's like the very best scripting language you can imagine.


00:22:15.320 --> 00:22:19.120
And it's kind of not perfect for apps, but well, we'll do this.


00:22:19.120 --> 00:22:23.360
But what you described was, we're going to take the database, we're going to take these


00:22:23.360 --> 00:22:27.480
APIs, we're going to take the web requests, we're going to glue that together.


00:22:27.480 --> 00:22:29.720
I mean, that is the application.


00:22:29.720 --> 00:22:36.240
It's like, it's thinking, yeah, it's thinking of, well, really, what is a modern API app


00:22:36.240 --> 00:22:38.520
other than a thing that takes a little data


00:22:38.520 --> 00:22:40.280
from an inbound request,


00:22:40.280 --> 00:22:42.720
maybe pushes something over to Celery,


00:22:42.720 --> 00:22:44.280
grabs something out of the database,


00:22:44.280 --> 00:22:47.560
calls these APIs and bundles it back up as a response


00:22:47.560 --> 00:22:50.120
and sends it back with a status code.


00:22:50.120 --> 00:22:51.560
That's the entire application.


00:22:51.560 --> 00:22:54.200
And yet this idea of gluing these pieces together


00:22:54.200 --> 00:22:56.240
is a really interesting way to think of it.


00:22:56.240 --> 00:22:58.320
- Yeah, yeah, that's what I learned.


00:22:58.320 --> 00:23:03.320
And it's about like gluing systems and gluing data.


00:23:03.320 --> 00:23:06.120
And of course these things are connected,


00:23:06.120 --> 00:23:11.120
but sometimes you can have gluing data in a asynchronous way,


00:23:11.120 --> 00:23:16.620
right, in batch processing or local processing


00:23:16.620 --> 00:23:19.680
or for analysis or human interaction,


00:23:19.680 --> 00:23:22.480
but it's still like gluing data from several sources.


00:23:22.480 --> 00:23:24.040
And there's this other approach,


00:23:24.040 --> 00:23:26.700
which is like gluing live systems.


00:23:26.700 --> 00:23:28.840
And of course, data is flowing across them,


00:23:28.840 --> 00:23:32.760
but also the connectivity aspect is key, right?


00:23:32.760 --> 00:23:36.600
can I authenticate and talk to all of these systems


00:23:36.600 --> 00:23:39.480
in the way they expect to interchange information.


00:23:39.480 --> 00:23:41.160
- Yeah, and the real power is


00:23:41.160 --> 00:23:44.400
how well does it perform that combination,


00:23:44.400 --> 00:23:46.800
not how well does that one millisecond


00:23:46.800 --> 00:23:49.760
versus two milliseconds in the actual web view method


00:23:49.760 --> 00:23:51.400
runtime behave, right?


00:23:51.400 --> 00:23:54.440
It's super interesting to see it that way.


00:23:54.440 --> 00:23:57.440
All right, well, let's jump into the first API


00:23:57.440 --> 00:23:58.840
that we're gonna talk about.


00:23:58.840 --> 00:24:02.480
This is the-- - Rekt.


00:24:02.480 --> 00:24:05.400
- Yeah, so this has to do with Gatorade,


00:24:05.400 --> 00:24:08.080
which is the sports drink company.


00:24:08.080 --> 00:24:11.640
And they have created this really interesting idea


00:24:11.640 --> 00:24:16.640
of the quantified self for fitness here


00:24:16.640 --> 00:24:19.820
with this thing called the GX sweat patch.


00:24:19.820 --> 00:24:22.040
- Exactly.


00:24:22.040 --> 00:24:22.880
- To help you go with this.


00:24:22.880 --> 00:24:26.120
This is something that blew my mind when I saw it first.


00:24:26.120 --> 00:24:27.600
- Yes, this is something that is like


00:24:27.600 --> 00:24:28.600
really in the beginning.


00:24:28.600 --> 00:24:32.200
We launched this in production in March 1st,


00:24:32.200 --> 00:24:33.280
this year.


00:24:33.280 --> 00:24:36.320
It has been in development since 2019


00:24:36.320 --> 00:24:40.840
and the research inside Gatorade goes even far back.


00:24:40.840 --> 00:24:43.040
So what they are trying to do,


00:24:43.040 --> 00:24:46.280
Gatorade has this subunit called GSSI,


00:24:46.280 --> 00:24:49.360
the Gatorade Sports Science Institute.


00:24:49.360 --> 00:24:53.160
I had the opportunity to visit one of their physical


00:24:53.160 --> 00:24:57.800
instances in Sarasota, Florida in 2020.


00:24:57.800 --> 00:25:00.480
And they do like amazing work there,


00:25:00.480 --> 00:25:04.080
like bridging sports science, like students,


00:25:04.080 --> 00:25:06.400
actual experiments, and they are helping


00:25:06.400 --> 00:25:10.120
to develop this concept of how do you bring


00:25:10.120 --> 00:25:15.120
some of the metrics used by high-performance athletes


00:25:15.120 --> 00:25:18.040
to a more general broad audience?


00:25:18.040 --> 00:25:20.920
- Right, we've probably all seen pictures


00:25:20.920 --> 00:25:23.960
of Olympic athletes or, you know,


00:25:23.960 --> 00:25:26.200
pick your favorite sport athletes


00:25:26.200 --> 00:25:29.040
with a couple of doctors or researchers


00:25:29.040 --> 00:25:32.320
around with a clipboard and like a big breathing thing


00:25:32.320 --> 00:25:34.800
and they're on like a workout bike or they're doing


00:25:34.800 --> 00:25:37.920
and they're like studying all these different things.


00:25:37.920 --> 00:25:41.440
Right, and they get really interesting feedback on,


00:25:41.440 --> 00:25:44.040
well, under this situation,


00:25:44.040 --> 00:25:47.160
this is where you're hitting your limits in cardio


00:25:47.160 --> 00:25:51.640
or in like the breathing at altitude or something.


00:25:51.640 --> 00:25:56.240
And for the rest of us, we just put on shoes and run


00:25:56.240 --> 00:25:58.760
or get on a bike or whatever it is.


00:25:58.760 --> 00:26:00.320
and now we just have no idea.


00:26:00.320 --> 00:26:01.560
- Exactly.


00:26:01.560 --> 00:26:04.120
In specific case of the,


00:26:04.120 --> 00:26:06.680
what you're showing now on the screen, the sweat patch,


00:26:06.680 --> 00:26:09.640
this thing that you can put in your forearm


00:26:09.640 --> 00:26:11.860
and it's going to capture your sweat


00:26:11.860 --> 00:26:14.280
in your micropores in your skin.


00:26:14.280 --> 00:26:17.560
And then you lead that sweat into two channels.


00:26:17.560 --> 00:26:20.020
One channel, which is the orange channel


00:26:20.020 --> 00:26:22.500
that fills up in a zigzag form,


00:26:22.500 --> 00:26:25.100
it's the volume of sweat you're producing.


00:26:25.100 --> 00:26:30.100
The other channel is a slightly bar on the lower side


00:26:30.100 --> 00:26:35.340
that will react in colors to reflect the amount of sodium


00:26:35.340 --> 00:26:39.140
that is in your sweat.


00:26:39.140 --> 00:26:42.540
And those two things, they will be super critical


00:26:42.540 --> 00:26:47.540
to understand how much fluid you're losing from your body,


00:26:47.540 --> 00:26:50.940
why you're performing some sports activity,


00:26:50.940 --> 00:26:54.460
and the concentration of sodium you're losing as well,


00:26:54.460 --> 00:26:56.220
because sodium, as everybody knows,


00:26:56.220 --> 00:26:59.220
it's critical for the performance of muscles,


00:26:59.220 --> 00:27:02.740
the potassium, sodium pump that exists


00:27:02.740 --> 00:27:04.260
and control all muscles.


00:27:04.260 --> 00:27:06.600
So learning about those things


00:27:06.600 --> 00:27:09.560
can help you improve your performance.


00:27:09.560 --> 00:27:12.500
And of course, this is more impactful


00:27:12.500 --> 00:27:14.300
if you are a professional athlete,


00:27:14.300 --> 00:27:16.340
but I think everybody can benefit from it.


00:27:16.340 --> 00:27:20.540
And the biggest challenge was to take that out of the lab,


00:27:20.540 --> 00:27:22.220
where you mentioned, Michael,


00:27:22.220 --> 00:27:25.420
where you have an apparatus that is easier


00:27:25.420 --> 00:27:29.660
to capture all the signals and bring that out in the field


00:27:29.660 --> 00:27:33.140
where anybody can use under any conditions.


00:27:33.140 --> 00:27:35.560
And that was the challenge that we took up


00:27:35.560 --> 00:27:38.180
to help Gatorade to achieve that.


00:27:38.180 --> 00:27:42.900
And it's had a lot of obstacles for us to overcome.


00:27:42.900 --> 00:27:45.260
And Python was like super helpful


00:27:45.260 --> 00:27:48.840
because not only it had the tools for us to like build APIs,


00:27:48.840 --> 00:27:52.080
but also there's a ton of formulas


00:27:52.080 --> 00:27:55.040
that we need to compute to achieve that.


00:27:55.040 --> 00:27:59.520
And Python had NumPy, pandas, and stats,


00:27:59.520 --> 00:28:03.940
and all the tooling that we needed to make it happen.


00:28:03.940 --> 00:28:06.640
- So let me just describe this really quickly


00:28:06.640 --> 00:28:09.000
for people who are watching.


00:28:09.000 --> 00:28:14.000
It's like a bandaid, maybe two and a half inches square.


00:28:14.000 --> 00:28:18.560
Yeah, three or four fingers, something like that.


00:28:18.560 --> 00:28:21.200
Maybe about the size of the palm of most people's hands.


00:28:21.200 --> 00:28:26.200
You stick it on to your arm and it changes these colors


00:28:26.200 --> 00:28:29.400
and reads out and then you scan it with this iOS app


00:28:29.400 --> 00:28:31.180
and it gives you an analysis


00:28:31.180 --> 00:28:32.300
that you're talking about here.


00:28:32.300 --> 00:28:34.380
- Exactly, exactly.


00:28:34.380 --> 00:28:38.180
The app of course serves for other purposes as well.


00:28:38.180 --> 00:28:40.180
So you can like track your workouts.


00:28:40.180 --> 00:28:43.020
It does integrate multiple sources of information,


00:28:43.020 --> 00:28:44.980
Garmin, Strava, HealthKit.


00:28:44.980 --> 00:28:48.620
And then it creates this timeline of events in your day


00:28:48.620 --> 00:28:53.620
that understands if you're like doing multiple workouts a day,


00:28:53.620 --> 00:28:57.680
very early in the morning, very late on the evening,


00:28:57.680 --> 00:29:00.620
and how they interfere in each other.


00:29:00.620 --> 00:29:02.520
Because if they are too close apart,


00:29:02.520 --> 00:29:05.120
maybe you shouldn't drink anything between the two of them.


00:29:05.120 --> 00:29:06.620
If they are too far apart,


00:29:06.620 --> 00:29:08.720
maybe you need supplemental hydration.


00:29:08.720 --> 00:29:10.240
So all of those effects,


00:29:10.240 --> 00:29:13.360
we perform that analysis in Python at the backend.


00:29:13.360 --> 00:29:16.720
And the app becomes like the avatar


00:29:16.720 --> 00:29:20.640
that conveys that information to the athletes in real time.


00:29:20.640 --> 00:29:22.080
- Yeah, when I first heard about this,


00:29:22.080 --> 00:29:24.120
I thought it specifically would just be like,


00:29:24.120 --> 00:29:25.520
well, Gatorade recommends this,


00:29:25.520 --> 00:29:27.120
so here's how much Gatorade you should buy.


00:29:27.120 --> 00:29:31.040
You should get the lime flavor, not the cool, or whatever.


00:29:31.040 --> 00:29:33.060
But it takes in data from, like you said,


00:29:33.060 --> 00:29:35.280
like Apple HealthKit and Garmin


00:29:35.280 --> 00:29:37.280
and these other things as well.


00:29:37.280 --> 00:29:39.040
How do you get that data out of it?


00:29:39.040 --> 00:29:40.440
- That's a great question.


00:29:40.440 --> 00:29:44.060
So the plan was to go as broad as possible.


00:29:44.060 --> 00:29:47.020
We even investigated Fitbit and other providers.


00:29:47.020 --> 00:29:51.780
But for the MVP, we went for three sources.


00:29:51.780 --> 00:29:56.380
Two external sources, Strava API and Garmin API.


00:29:56.380 --> 00:29:58.980
So if you're a Strava user or a Garmin user,


00:29:58.980 --> 00:30:03.900
you can, in a web view, connect to Garmin and Strava


00:30:03.900 --> 00:30:05.540
through our app.


00:30:05.540 --> 00:30:09.500
And then we created this data feed


00:30:09.500 --> 00:30:11.980
from Garmin and Strava into our system.


00:30:11.980 --> 00:30:15.100
- So it's like some OAuth backend sort of API type of thing?


00:30:15.100 --> 00:30:16.340
- Yes, exactly.


00:30:16.340 --> 00:30:18.420
- Okay. - API to API.


00:30:18.420 --> 00:30:20.180
And then it starts popping up in the app.


00:30:20.180 --> 00:30:22.860
You don't need, the app becomes a read-only thing.


00:30:22.860 --> 00:30:25.660
You just look into it and you perform your exercise,


00:30:25.660 --> 00:30:30.060
but the information comes through the backend.


00:30:30.060 --> 00:30:31.640
So these are the main channels,


00:30:31.640 --> 00:30:34.980
but we also talk to Apple HealthKits,


00:30:34.980 --> 00:30:39.580
the platform in the iOS that consolidates


00:30:41.300 --> 00:30:45.620
information from multiple apps, health related, of course.


00:30:45.620 --> 00:30:48.500
And then in that case, if you have like a sleep tracker


00:30:48.500 --> 00:30:51.900
or other sports tracker, for example, I use RunKeeper.


00:30:51.900 --> 00:30:54.340
So I go to that application,


00:30:54.340 --> 00:30:57.320
I allow that application to export information


00:30:57.320 --> 00:31:00.740
to HealthKit, and then of course, Apple Health,


00:31:00.740 --> 00:31:04.940
the app will see it, but also any other app registered


00:31:04.940 --> 00:31:07.940
as a reader for the HealthKit platform.


00:31:07.940 --> 00:31:12.860
And that's how we grab and consolidate all your activity,


00:31:12.860 --> 00:31:16.980
sleeping and workouts, into this single timeline.


00:31:16.980 --> 00:31:19.740
And then we provide recommendations on top of that.


00:31:19.740 --> 00:31:21.260
- Right, so you might be able to correlate


00:31:21.260 --> 00:31:25.060
workout with sleep, how well you sleep in


00:31:25.060 --> 00:31:25.940
or something like that.


00:31:25.940 --> 00:31:26.780
- Yes, yes.


00:31:26.780 --> 00:31:28.220
That's one of the things we do.


00:31:28.220 --> 00:31:29.900
That was one of the challenges.


00:31:29.900 --> 00:31:34.220
Dealing with this events timeline became this,


00:31:34.220 --> 00:31:36.060
we needed a time series database


00:31:36.060 --> 00:31:39.660
to do time series analysis, because time is super relevant.


00:31:39.660 --> 00:31:41.340
We have to handle conflicts,


00:31:41.340 --> 00:31:44.740
because you may have like many trackers


00:31:44.740 --> 00:31:46.900
reporting the same thing.


00:31:46.900 --> 00:31:48.960
So the same physical events comes


00:31:48.960 --> 00:31:51.020
as multiple digital events.


00:31:51.020 --> 00:31:54.460
Sometimes there are applications that break up


00:31:54.460 --> 00:31:56.540
a single event into multiple events.


00:31:56.540 --> 00:31:59.060
Sleep trackers typically do that.


00:31:59.060 --> 00:32:01.940
So for us, you have a single night of sleep.


00:32:01.940 --> 00:32:04.640
You go to bed and you wake up, right?


00:32:04.640 --> 00:32:08.760
But actually what happens is multiple cycles of sleep,


00:32:08.760 --> 00:32:10.800
then you wake up in the middle of night,


00:32:10.800 --> 00:32:13.360
but we don't handle them logically


00:32:13.360 --> 00:32:15.720
as multiple sleeping periods.


00:32:15.720 --> 00:32:18.060
For us, logically, it's a single sleeping period.


00:32:18.060 --> 00:32:21.520
So this is another thing we have to handle in the system.


00:32:21.520 --> 00:32:22.520
- Nice.


00:32:22.520 --> 00:32:24.020
Yeah, it seems really useful, actually,


00:32:24.020 --> 00:32:25.640
the more I hear about it.


00:32:25.640 --> 00:32:28.640
So let's talk about some of the tech behind the scenes


00:32:28.640 --> 00:32:29.880
for this one.


00:32:29.880 --> 00:32:30.720
- Cool.


00:32:30.720 --> 00:32:32.860
- There's probably some data science side.


00:32:32.860 --> 00:32:35.420
there's obviously the API and database side.


00:32:35.420 --> 00:32:36.660
What do you got going on here?


00:32:36.660 --> 00:32:38.060
- Okay, so in the beginning,


00:32:38.060 --> 00:32:41.100
we went down to GSSI,


00:32:41.100 --> 00:32:42.620
the Gateway Sports Science Institute,


00:32:42.620 --> 00:32:45.100
and together with their scientists,


00:32:45.100 --> 00:32:46.900
we start to create a model,


00:32:46.900 --> 00:32:50.020
not only for the way the sweats patch works,


00:32:50.020 --> 00:32:52.980
the sweats patch was developed by a Boston company


00:32:52.980 --> 00:32:56.060
named Epicor, the physical patch,


00:32:56.060 --> 00:32:59.820
and also the driver that kind of captures


00:32:59.820 --> 00:33:01.940
the basic information from the patch.


00:33:01.940 --> 00:33:04.300
that is embedded on the mobile app.


00:33:04.300 --> 00:33:06.900
And then when you take a picture of the patch,


00:33:06.900 --> 00:33:09.340
we do some image processing and we extract


00:33:09.340 --> 00:33:12.140
the two bits of information that we want.


00:33:12.140 --> 00:33:12.980
The volume channel--


00:33:12.980 --> 00:33:14.100
- That's probably something like Swift


00:33:14.100 --> 00:33:15.380
or something on the app, right?


00:33:15.380 --> 00:33:18.860
- It's, today it's in C# Xamarin.


00:33:18.860 --> 00:33:19.700
- Okay, yeah.


00:33:19.700 --> 00:33:22.060
- But it was a more restriction from PepsiCo.


00:33:22.060 --> 00:33:25.280
They were already using that technology


00:33:25.280 --> 00:33:29.960
and it was supposed to be a framework cross platform.


00:33:29.960 --> 00:33:32.940
So later when we decided to go to Android,


00:33:32.940 --> 00:33:35.720
it would be a possibility to like reuse that framework.


00:33:35.720 --> 00:33:40.100
So there was a constraint that we had to accommodate for,


00:33:40.100 --> 00:33:44.220
but those modules are Objective-C and Swift for sure.


00:33:44.220 --> 00:33:46.320
They are native.


00:33:46.320 --> 00:33:47.360
- Yeah. - Yeah.


00:33:47.360 --> 00:33:50.120
And so what we do after we have that,


00:33:50.120 --> 00:33:53.080
we have to translate whatever you read,


00:33:53.080 --> 00:33:55.460
which is your local sweat rate,


00:33:55.460 --> 00:33:57.720
how much your forearm is sweating,


00:33:57.720 --> 00:34:00.280
a single micropore in your forearm.


00:34:00.280 --> 00:34:04.120
And we have a statistical model developed by GSI


00:34:04.120 --> 00:34:07.680
to translate that into a whole body sweat rate.


00:34:07.680 --> 00:34:10.440
So that is the first like machine learning,


00:34:10.440 --> 00:34:15.440
statistical learning bit that is embedded on the system.


00:34:15.440 --> 00:34:18.760
And we need to take into consideration


00:34:18.760 --> 00:34:22.540
what's the weather like, what's your weight,


00:34:22.540 --> 00:34:24.800
what type of sports you were doing.


00:34:24.800 --> 00:34:25.640
All those--


00:34:25.640 --> 00:34:27.000
- What's the humidity, yeah.


00:34:27.000 --> 00:34:30.440
Humidity we're we're not using right now because it's hard to capture


00:34:30.440 --> 00:34:36.120
So we had to create a less accurate model, but for sure humidity is critical


00:34:36.120 --> 00:34:39.740
But it was the product decision to leave that one out


00:34:39.740 --> 00:34:44.180
Because of the facility to grab the information to capture that right, right


00:34:44.180 --> 00:34:51.320
And once we we have your whole body sweat rate that acts as a crystal ball


00:34:51.840 --> 00:34:57.780
For future workouts. So when you're performing a new workout, you don't need to use the sweat patch again


00:34:57.780 --> 00:35:02.320
You can use the stretch profile the crystal ball to predict


00:35:02.320 --> 00:35:05.160
Given the conditions of this new workout


00:35:05.160 --> 00:35:10.200
How much you're going to sweat and then base recommendations on that?


00:35:10.200 --> 00:35:14.660
So, of course if the there is there are some


00:35:15.180 --> 00:35:17.660
constraints that if they do not match,


00:35:17.660 --> 00:35:19.700
you have to do a new sweat test,


00:35:19.700 --> 00:35:22.540
create a new profile for those new conditions.


00:35:22.540 --> 00:35:25.020
For example, I create a patch for running


00:35:25.020 --> 00:35:26.580
and now I'm doing bike.


00:35:26.580 --> 00:35:28.220
So it's a different activity.


00:35:28.220 --> 00:35:30.420
It should be best if I create a new profile.


00:35:30.420 --> 00:35:32.140
- Yeah, nice.


00:35:32.140 --> 00:35:33.500
How does the app know what you're doing?


00:35:33.500 --> 00:35:35.540
Do you tell it just right now I'm doing this,


00:35:35.540 --> 00:35:37.460
so take a scan?


00:35:37.460 --> 00:35:39.900
- Yes, you have two options.


00:35:39.900 --> 00:35:42.700
One of them, the app asks the user,


00:35:42.700 --> 00:35:45.140
when you're scheduling manually a workout,


00:35:45.140 --> 00:35:47.460
You can say, I'm planning to use a sweat patch


00:35:47.460 --> 00:35:49.780
on this particular workout, so be prepared.


00:35:49.780 --> 00:35:50.940
That's one option.


00:35:50.940 --> 00:35:53.820
The other option is, after you finish a workout,


00:35:53.820 --> 00:35:57.300
the app asks you, did you use a sweat patch?


00:35:57.300 --> 00:36:00.420
So if you did, let's go with the flow of scanning.


00:36:00.420 --> 00:36:03.340
If you're not, there is a fallback mechanism


00:36:03.340 --> 00:36:05.180
called weigh in, weigh out,


00:36:05.180 --> 00:36:09.340
where we can compare your rates and subtract them


00:36:09.340 --> 00:36:11.920
and see how much fluid you lost.


00:36:13.100 --> 00:36:17.300
The downside of this is that we do not capture sodium loss.


00:36:17.300 --> 00:36:19.300
So you cannot take sodium consideration.


00:36:19.300 --> 00:36:23.180
- So when it gets to the server side,


00:36:23.180 --> 00:36:25.740
what's the API framework?


00:36:25.740 --> 00:36:29.900
- Right, so the app is talking to the backend all the time.


00:36:29.900 --> 00:36:33.820
So we kind of use the backend for frontend metaphor


00:36:33.820 --> 00:36:34.860
of sorts.


00:36:34.860 --> 00:36:39.860
So the API not only does the reasoning for the whole system,


00:36:40.100 --> 00:36:43.700
But sometimes it even helps the app a little bit with layout.


00:36:43.700 --> 00:36:47.020
So the app talks to the back end to get user profile,


00:36:47.020 --> 00:36:49.940
to get the timeline of events, and then it


00:36:49.940 --> 00:36:52.340
renders those timeline of events,


00:36:52.340 --> 00:36:54.620
captures additional information-- for example,


00:36:54.620 --> 00:36:56.980
your motivation and your fatigue--


00:36:56.980 --> 00:37:00.060
and reports that information to the back end.


00:37:00.060 --> 00:37:04.480
The sweat scans and manually scheduled workouts.


00:37:04.480 --> 00:37:07.020
Everything else happens at the back end.


00:37:07.020 --> 00:37:09.260
By everything else, what do we mean?


00:37:09.260 --> 00:37:10.900
Grabbing weather information.


00:37:10.900 --> 00:37:13.860
So translating your latitudes and longitudes


00:37:13.860 --> 00:37:17.440
into a temperature if your workout was outdoor.


00:37:17.440 --> 00:37:18.280
One thing.


00:37:18.280 --> 00:37:22.660
Sending push, scheduling push notifications


00:37:22.660 --> 00:37:25.760
to remind you that you have this recommendation


00:37:25.760 --> 00:37:28.740
or there's an upcoming workout, things like that.


00:37:28.740 --> 00:37:33.460
It also computes the local to whole body transformation.


00:37:33.460 --> 00:37:36.080
It manages your sweat profiles


00:37:36.080 --> 00:37:40.240
and it triggers some product recommendation engines


00:37:40.240 --> 00:37:43.280
that will tell you not only Gatorade products,


00:37:43.280 --> 00:37:47.380
but also general foods that could be suitable


00:37:47.380 --> 00:37:49.140
for your nutritional needs.


00:37:49.140 --> 00:37:51.300
So we can say, for example,


00:37:51.300 --> 00:37:55.480
if you need this amount of carbs, this amount of protein,


00:37:55.480 --> 00:37:59.720
maybe you should take a little bit of caffeine or casein.


00:37:59.720 --> 00:38:02.940
And then we give it a list of generic food,


00:38:02.940 --> 00:38:07.940
like rice, coffee, and then you can plan accordingly


00:38:07.940 --> 00:38:11.860
to fulfill those recommendations.


00:38:11.860 --> 00:38:13.820
All of that comes from the backend.


00:38:13.820 --> 00:38:16.740
- And the backend is Flask?


00:38:16.740 --> 00:38:17.580
Is that what it is?


00:38:17.580 --> 00:38:19.140
- The backend is Flask.


00:38:19.140 --> 00:38:21.020
We were in doubt in the beginning


00:38:21.020 --> 00:38:24.860
being between FastAPI and Flask.


00:38:24.860 --> 00:38:30.780
I wanted to fight the problem domain, not the technology.


00:38:32.140 --> 00:38:34.300
So I decided to go fully synchronous


00:38:34.300 --> 00:38:38.340
because in that case, it's super easy to debug.


00:38:38.340 --> 00:38:41.060
It's much less prone to problems.


00:38:41.060 --> 00:38:43.600
I was not concerned with performance in the beginning.


00:38:43.600 --> 00:38:47.620
What we learned was that Flask was performant enough


00:38:47.620 --> 00:38:49.300
for all our needs.


00:38:49.300 --> 00:38:51.740
So that went well.


00:38:51.740 --> 00:38:53.900
We had a separate API


00:38:53.900 --> 00:38:56.460
just for integrations with Garmin and Strava.


00:38:56.460 --> 00:38:59.260
After we entered to production in March,


00:38:59.260 --> 00:39:03.780
we realized that the team was too small to maintain it


00:39:03.780 --> 00:39:05.180
and we really didn't need.


00:39:05.180 --> 00:39:08.900
So we merged the two APIs into a single monolith.


00:39:08.900 --> 00:39:11.740
But those two APIs, one of them was asynchronous.


00:39:11.740 --> 00:39:15.140
So we did that asynchronous API with Quartz


00:39:15.140 --> 00:39:18.020
and that was the one talking to Garmin and Strava


00:39:18.020 --> 00:39:22.340
because that one was purely IO bound, not CPU bound.


00:39:22.340 --> 00:39:27.340
- But you're entirely waiting on Strava and Garmin


00:39:27.340 --> 00:39:28.740
and the internet.


00:39:28.740 --> 00:39:31.020
>> You should be able to scale that many,


00:39:31.020 --> 00:39:33.840
many times out because all you're doing is waiting on their APIs,


00:39:33.840 --> 00:39:37.560
and you're completely at the mercy of their performance.


00:39:37.560 --> 00:39:38.080
>> That's true.


00:39:38.080 --> 00:39:40.720
>> Picture as well. Async makes a lot of sense,


00:39:40.720 --> 00:39:42.360
but it turns out it wasn't needed.


00:39:42.360 --> 00:39:45.460
>> Yeah. The thing that we realized was that,


00:39:45.460 --> 00:39:47.600
of course, there are trade-offs.


00:39:47.600 --> 00:39:53.760
If you go for a job interview and you present that as a conceptual problem,


00:39:53.760 --> 00:39:56.160
I think the answer is no, do it asynchronously.


00:39:56.160 --> 00:39:57.860
Do it as a separate API,


00:39:57.860 --> 00:40:00.260
because then you can scale independently.


00:40:00.260 --> 00:40:02.120
You have better IO throughput,


00:40:02.120 --> 00:40:03.740
lower latency, etc.


00:40:03.740 --> 00:40:05.480
But in the real world,


00:40:05.480 --> 00:40:09.380
you have to balance all those things with the size of your team,


00:40:09.380 --> 00:40:11.260
the resources that you have,


00:40:11.260 --> 00:40:13.060
other external conditions.


00:40:13.060 --> 00:40:15.780
In the end, we decided to consolidate


00:40:15.780 --> 00:40:19.460
everything into a single technology in a single stack,


00:40:19.460 --> 00:40:23.400
because it was simpler if we need to onboard new people train,


00:40:23.400 --> 00:40:26.260
instead of knowing flask and cart,


00:40:26.260 --> 00:40:28.620
Now they only need to know a single framework.


00:40:28.620 --> 00:40:32.340
And because scalability was not a problem,


00:40:32.340 --> 00:40:34.860
we were using like Kubernetes in production


00:40:34.860 --> 00:40:37.220
and it's like horizontally scalable.


00:40:37.220 --> 00:40:39.620
We decided to reverse that


00:40:39.620 --> 00:40:42.700
and build a monolith, single stack,


00:40:42.700 --> 00:40:45.540
flask all the way, and that's what we have today.


00:40:45.540 --> 00:40:48.660
How interesting. So you decided you can just solve it by


00:40:48.660 --> 00:40:51.180
running more worker processes


00:40:51.180 --> 00:40:54.860
per container and then just running more containers if you need to.


00:40:54.860 --> 00:40:59.260
Yeah, exactly. That was a better solve for the conditions we had in the project.


00:40:59.260 --> 00:41:05.660
Yeah, I think that makes a lot of sense. You know, there's so often these recommendations of using,


00:41:05.660 --> 00:41:11.740
you know, microservices, breaking stuff into a bunch of pieces, having, you know, just the


00:41:11.740 --> 00:41:19.180
right technology for just this slice of what you're doing. And then you've got your app,


00:41:19.180 --> 00:41:24.700
your app is talking to the different services. Now you're trying to coordinate. It just gives


00:41:24.700 --> 00:41:28.860
me chills to even think about it. Releasing this through the Apple app approved process


00:41:28.860 --> 00:41:34.860
and coordinating that with the versions of multiple APIs. That sounds so bad.


00:41:34.860 --> 00:41:41.740
It becomes a nightmare really fast. And in my mind, my experience is that microservices is an


00:41:41.740 --> 00:41:47.980
answer for a given team size. So if you have like 100 developers, like I don't know, or 1000


00:41:47.980 --> 00:41:54.300
developers like Netflix or Shopify, then it makes every sense in the world to break it up


00:41:54.300 --> 00:41:57.740
and individual components because you have individual teams,


00:41:57.740 --> 00:42:02.940
common is law, right? The software you build reflects the


00:42:02.940 --> 00:42:06.700
architecture of the people in the company and how they build the software.


00:42:06.700 --> 00:42:11.500
But when you have a very tiny little team, the monolith is great. It simplifies


00:42:11.500 --> 00:42:17.500
everything. So that's like a lesson we learned


00:42:17.500 --> 00:42:20.780
that we kind of over-engineered in the beginning,


00:42:20.780 --> 00:42:22.780
trying to go with two APIs,


00:42:22.780 --> 00:42:26.380
and we took the route of bringing a monolith.


00:42:26.380 --> 00:42:31.080
I think that makes a lot of sense for small teams.


00:42:31.080 --> 00:42:33.580
And here's the thing, if you run into performance problems


00:42:33.580 --> 00:42:35.580
that really need async stuff,


00:42:35.580 --> 00:42:39.580
you know, when you considered to use Flask and not FastAPI,


00:42:39.580 --> 00:42:44.080
FastAPI was brand new, and who knows if it would survive another six months,


00:42:44.080 --> 00:42:46.080
or if it would go the way of


00:42:46.080 --> 00:42:49.380
other really promising projects like


00:42:49.380 --> 00:42:52.220
which as far as I could be wrong, but as far as I know,


00:42:52.220 --> 00:42:54.580
it hasn't gotten a ton of attraction.


00:42:54.580 --> 00:42:55.940
It was really exciting for a while


00:42:55.940 --> 00:42:59.580
and it just kind of fizzled out, right?


00:42:59.580 --> 00:43:00.420
- Yes, yes.


00:43:00.420 --> 00:43:01.660
- You don't want to, you want to build on that.


00:43:01.660 --> 00:43:03.620
So I think Flask is a totally reasonable choice,


00:43:03.620 --> 00:43:05.500
but I guess what I was going to say is,


00:43:05.500 --> 00:43:06.740
you know, it's not that different.


00:43:06.740 --> 00:43:08.820
If you need to re translate that,


00:43:08.820 --> 00:43:10.740
if you're going to convert that to FastAPI,


00:43:10.740 --> 00:43:13.500
like that's a thing you as a team of a couple of people


00:43:13.500 --> 00:43:15.740
could do in a few days.


00:43:15.740 --> 00:43:16.580
- Yes, exactly.


00:43:16.580 --> 00:43:18.020
- And it would be fine.


00:43:18.020 --> 00:43:18.860
- Exactly.


00:43:18.860 --> 00:43:23.480
>> Exactly. There were other circumstances.


00:43:23.480 --> 00:43:26.540
For example, as a big fan of Talk Python to me,


00:43:26.540 --> 00:43:28.880
I watched the episode on FastAPI.


00:43:28.880 --> 00:43:31.000
I watched the episode on Pydantic,


00:43:31.000 --> 00:43:34.320
and I knew of the symbiosis between the two of them.


00:43:34.320 --> 00:43:41.280
But for us, we started with Kerberos as a schema validation technology.


00:43:41.280 --> 00:43:43.960
>> Which comes out of the Eve project from my friend,


00:43:43.960 --> 00:43:44.640
Niccolo, by the way.


00:43:44.640 --> 00:43:46.840
>> Yeah. We evolved into using


00:43:46.840 --> 00:43:49.560
in Marshmallow replacing Kerberos.


00:43:49.560 --> 00:43:53.360
And we compare with PyDanic,


00:43:53.360 --> 00:43:56.640
and at the time we didn't want to like extract PyDanic


00:43:56.640 --> 00:44:00.060
from FastAPI and use FastAPI with Marshmallow.


00:44:00.060 --> 00:44:03.600
So we went with Flask that was like not opinionated


00:44:03.600 --> 00:44:06.080
about what the schema should look like,


00:44:06.080 --> 00:44:08.880
and we went with Flask and Marshmallow.


00:44:08.880 --> 00:44:10.160
- Yeah, nice.


00:44:10.160 --> 00:44:11.960
Some other interesting building blocks


00:44:11.960 --> 00:44:16.960
that you highlighted is PINT, P-I-N-T for units.


00:44:16.960 --> 00:44:19.960
PINT is super cool, tell people a bit about PINT.


00:44:19.960 --> 00:44:23.000
- Exactly, so one of the things that we're doing


00:44:23.000 --> 00:44:25.680
on this particular project was,


00:44:25.680 --> 00:44:28.080
it's supposed to be international


00:44:28.080 --> 00:44:30.920
and it's like heavy on the physics.


00:44:30.920 --> 00:44:35.060
So we're dealing with rates and concentrations,


00:44:35.060 --> 00:44:37.300
there's a lot of chemistry going on.


00:44:37.300 --> 00:44:40.080
We're talking about the metric system,


00:44:40.080 --> 00:44:42.780
US customary imperial systems.


00:44:42.780 --> 00:44:45.420
So converting between units


00:44:45.420 --> 00:44:49.400
was going to be a big part of the system.


00:44:49.400 --> 00:44:51.520
And then we find out about Pint.


00:44:51.520 --> 00:44:55.120
I was like in the Pint community for over 20 years.


00:44:55.120 --> 00:44:58.960
I shook hands with Guido Von Rossel in 2005


00:44:58.960 --> 00:45:02.440
when I translated his tutorial to Portuguese.


00:45:02.440 --> 00:45:05.360
But I never heard of Pint in those 20 years.


00:45:05.360 --> 00:45:09.040
But when I had the need, I did a quick research


00:45:09.040 --> 00:45:11.940
and I found exactly the solution that we wanted.


00:45:11.940 --> 00:45:16.420
So, Pint uses the excellent object orientation


00:45:16.420 --> 00:45:19.980
that we have in Python to transparently create


00:45:19.980 --> 00:45:22.760
this like new integers and floats


00:45:22.760 --> 00:45:24.720
that are just not numbers,


00:45:24.720 --> 00:45:28.220
but they also have a unit together with them.


00:45:28.220 --> 00:45:29.460
- It's so fantastic.


00:45:29.460 --> 00:45:31.180
Let me maybe describe this little example


00:45:31.180 --> 00:45:32.580
on the Pint homepage.


00:45:32.580 --> 00:45:37.460
So if I wanted to have three meters plus four centimeters,


00:45:37.460 --> 00:45:40.420
instead of saying three times 100 plus four,


00:45:40.420 --> 00:45:42.840
or vice versa, you know, divide by 100,


00:45:42.840 --> 00:45:47.260
you have three times meter plus four times cm,


00:45:47.260 --> 00:45:48.940
and then what you get back is a quantity,


00:45:48.940 --> 00:45:50.620
which is 3.04 meters.


00:45:50.620 --> 00:45:51.700
It's fantastic.


00:45:51.700 --> 00:45:52.520
- Exactly.


00:45:52.520 --> 00:45:54.060
- And you could mix, you could even do something horrible


00:45:54.060 --> 00:45:57.620
like three meters plus seven inches, if you had to.


00:45:57.620 --> 00:46:00.300
- Exactly, and it becomes even more powerful


00:46:00.300 --> 00:46:04.300
when you're talking about different kind of dimensions.


00:46:04.300 --> 00:46:06.940
For example, if I want a concentration,


00:46:06.940 --> 00:46:10.680
and I'm going to like to divide mass per volume.


00:46:10.680 --> 00:46:12.520
And then I need to make sure


00:46:12.520 --> 00:46:15.040
that my calculation makes sense.


00:46:15.040 --> 00:46:17.560
So PyEnt allows you to do that.


00:46:17.560 --> 00:46:22.280
So you do those conversions and the units are preserved.


00:46:22.280 --> 00:46:23.920
And because the units are preserved,


00:46:23.920 --> 00:46:27.040
it's easier to test, it's easier to compute.


00:46:27.040 --> 00:46:32.040
So it's really a lifesaver that saved us a lot of time


00:46:32.040 --> 00:46:36.280
while coding this API.


00:46:36.280 --> 00:46:38.280
- Yeah, this is not something that in my world


00:46:38.280 --> 00:46:40.900
I do anything with these days really,


00:46:40.900 --> 00:46:42.960
but if I did, boy, I'd be all over Pint.


00:46:42.960 --> 00:46:44.120
That thing's cool.


00:46:44.120 --> 00:46:46.200
Also there was UNIT.


00:46:46.200 --> 00:46:48.880
- Yes.


00:46:48.880 --> 00:46:50.920
- I've also just recently heard about,


00:46:50.920 --> 00:46:53.680
and I don't know really how they can,


00:46:53.680 --> 00:46:57.320
U-N-Y-T, but this is also something similar


00:46:57.320 --> 00:46:59.040
in that regard as well.


00:46:59.040 --> 00:47:01.920
- Yeah, we, at the time, and I'm talking about


00:47:03.400 --> 00:47:07.240
early 2020, we evaluated a couple.


00:47:07.240 --> 00:47:09.600
I don't remember if Unity we checked,


00:47:09.600 --> 00:47:13.600
but there were three others besides Pint,


00:47:13.600 --> 00:47:16.800
but in the end, Pint sound the most robust one,


00:47:16.800 --> 00:47:18.400
but I'll check Unity again.


00:47:18.400 --> 00:47:21.320
- Yeah, well, I guess what's your assessment


00:47:21.320 --> 00:47:23.320
now that you've been actually using Pint, it's good?


00:47:23.320 --> 00:47:24.560
- We're super happy.


00:47:24.560 --> 00:47:25.400
- Nice.


00:47:25.400 --> 00:47:26.680
- We have like zero issues with Pint


00:47:26.680 --> 00:47:29.840
and it saved our lives time and again.


00:47:29.840 --> 00:47:32.440
- Yeah, another one that you'll run into is time.


00:47:32.440 --> 00:47:34.620
So you used Pendulum for that?


00:47:34.620 --> 00:47:38.640
>> Yes. I was even a little bit resistant in


00:47:38.640 --> 00:47:42.560
the beginning because I was using dates time forever.


00:47:42.560 --> 00:47:45.420
Of course, members of my team were suggesting,


00:47:45.420 --> 00:47:46.860
"Hey, why don't we use Pendulum?


00:47:46.860 --> 00:47:48.920
It has a really nice interface."


00:47:48.920 --> 00:47:54.120
The deal breaker for me was that the Pendulum object,


00:47:54.120 --> 00:47:59.280
it inherits from the regular date-time objects.


00:47:59.280 --> 00:48:01.500
So they are completely interchangeable.


00:48:01.500 --> 00:48:08.460
The one thing I didn't want to happen was to have these two libraries dealing with time,


00:48:08.460 --> 00:48:13.100
and in that case, daytime is standard in the standard Pylon library.


00:48:13.100 --> 00:48:19.100
Something else external would be a cause of concern for me in my experience,


00:48:19.100 --> 00:48:21.260
but in that case, it was seamless.


00:48:21.260 --> 00:48:28.220
So I can use either Pendulum or Daytime, it doesn't matter because they all inherit from the same root.


00:48:28.780 --> 00:48:30.540
So that was key.


00:48:30.540 --> 00:48:33.300
And to be honest, it was convenient,


00:48:33.300 --> 00:48:36.380
especially for time zones.


00:48:36.380 --> 00:48:39.420
But remember that that was before,


00:48:39.420 --> 00:48:41.900
I think it was on Python 3.9,


00:48:41.900 --> 00:48:46.120
that we had better support for time zones.


00:48:46.120 --> 00:48:50.740
And at least in the standard Python.


00:48:50.740 --> 00:48:54.460
And at that time, I think Pendulum was having a better way


00:48:54.460 --> 00:48:56.860
to handle with time zone conversion.


00:48:56.860 --> 00:48:59.940
that was key for us in terms of the solution.


00:48:59.940 --> 00:49:01.740
We never know where our athletes are going to be


00:49:01.740 --> 00:49:02.740
in the world.


00:49:02.740 --> 00:49:04.820
So that was the key reason.


00:49:04.820 --> 00:49:07.700
And we're happy with Paddle.


00:49:07.700 --> 00:49:09.340
- Yeah, this is super neat.


00:49:09.340 --> 00:49:11.420
You know, I didn't really put it together


00:49:11.420 --> 00:49:12.440
when I was looking at this before,


00:49:12.440 --> 00:49:14.660
but the time zone stuff is quite interesting.


00:49:14.660 --> 00:49:17.780
Like something that's always a challenge


00:49:17.780 --> 00:49:21.940
that I deal with is when I'm working


00:49:21.940 --> 00:49:25.100
with some of the web apps that I have,


00:49:25.100 --> 00:49:28.940
or other things, just where is the server


00:49:28.940 --> 00:49:33.380
versus where is the person accessing the server?


00:49:33.380 --> 00:49:36.480
And it turns out to be way more annoying than you think.


00:49:36.480 --> 00:49:38.100
Right? - It is.


00:49:38.100 --> 00:49:39.380
- Another thing we're gonna talk about


00:49:39.380 --> 00:49:41.420
is using MongoDB for the backend on this.


00:49:41.420 --> 00:49:44.500
And so am I, and I'm just a super fan of MongoDB.


00:49:44.500 --> 00:49:48.260
It's been such a nice way to make fast,


00:49:48.260 --> 00:49:50.460
easy to maintain apps.


00:49:50.460 --> 00:49:52.980
But it stores stuff at like UTC,


00:49:52.980 --> 00:49:55.620
whereas the server I think is in Eastern time zone,


00:49:55.620 --> 00:49:57.460
and I'm in the Pacific time zone.


00:49:57.460 --> 00:49:58.780
And so if I want to pull some of them,


00:49:58.780 --> 00:50:00.220
so this event is going to happen then,


00:50:00.220 --> 00:50:02.380
or it happened at what time,


00:50:02.380 --> 00:50:06.020
it's not easy to say, well, that was an hour ago.


00:50:06.020 --> 00:50:08.740
Like something so simple as here's a list of activities,


00:50:08.740 --> 00:50:10.980
and this one was an hour ago.


00:50:10.980 --> 00:50:12.540
It's challenging, and this is really cool.


00:50:12.540 --> 00:50:13.920
So you can say, instead of daytime now,


00:50:13.920 --> 00:50:18.060
I can say pendulum.now, and then pass in the base time zone.


00:50:18.060 --> 00:50:20.860
I say, well, what is now in, you know,


00:50:20.860 --> 00:50:23.300
the inbound time zone or something like that,


00:50:23.300 --> 00:50:25.020
would be really, really nice.


00:50:25.020 --> 00:50:27.540
>> Right. The strategy we took,


00:50:27.540 --> 00:50:28.980
which is a traditional strategy,


00:50:28.980 --> 00:50:32.100
is that at all the edges of the system,


00:50:32.100 --> 00:50:36.060
we convert to UTC and inside,


00:50:36.060 --> 00:50:38.500
we're just reasoning on UTC.


00:50:38.500 --> 00:50:41.780
Only when we're exporting information through


00:50:41.780 --> 00:50:46.180
this membrane of the system back to close to the user,


00:50:46.180 --> 00:50:48.380
then we translate back to their time zone.


00:50:48.380 --> 00:50:55.380
However, it gets tricky when we're talking about not real time, but nominal time.


00:50:55.380 --> 00:50:56.380
What is nominal time?


00:50:56.380 --> 00:51:00.380
For example, I wake up at 7 a.m.


00:51:00.380 --> 00:51:04.380
So, 7 a.m. for me, it's a nominal time.


00:51:04.380 --> 00:51:07.380
It's not anchored on any place on Earth.


00:51:07.380 --> 00:51:11.380
It's like the time that I'm supposed to wake up.


00:51:11.380 --> 00:51:17.380
The nominal time becomes trickier because it's not anchored on a particular place.


00:51:17.380 --> 00:51:21.380
So you have to deal those kind of things a little bit differently.


00:51:21.380 --> 00:51:28.380
But other than that, Pendler was very ergonomic in terms of their API,


00:51:28.380 --> 00:51:31.380
which is super easy. You can keep it on your mind.


00:51:31.380 --> 00:51:34.380
And it's compatible with the time, so it was a plus.


00:51:34.380 --> 00:51:40.380
Yeah, I think that's a really neat point because if you've got some other API


00:51:40.380 --> 00:51:44.380
that takes a date time, you can just pass in the pendulum time


00:51:44.380 --> 00:51:46.880
and it just, it is a daytime.


00:51:46.880 --> 00:51:47.720
- Yeah.


00:51:47.720 --> 00:51:48.740
- Right, so you don't have to make,


00:51:48.740 --> 00:51:51.320
oh, I forgot to convert here, so it's broken.


00:51:51.320 --> 00:51:53.040
So the lander crashed into the ground,


00:51:53.040 --> 00:51:54.300
'cause you know, whatever.


00:51:54.300 --> 00:51:55.140
- Exactly.


00:51:55.140 --> 00:51:56.480
- All those units and conversion sites.


00:51:56.480 --> 00:51:58.240
- Yeah, and the arithmetic, right?


00:51:58.240 --> 00:52:00.160
So I think that is the other aspect


00:52:00.160 --> 00:52:02.240
that Pendulum makes a little bit easier,


00:52:02.240 --> 00:52:04.040
the arithmetic, what it's like,


00:52:04.040 --> 00:52:06.520
as a day, subtract minutes.


00:52:06.520 --> 00:52:11.520
This duality between a point in time and a delta


00:52:12.040 --> 00:52:14.840
that we do have on like the time and time delta


00:52:14.840 --> 00:52:16.480
and all the Python API.


00:52:16.480 --> 00:52:20.640
But Pendulum also helps you in that sense


00:52:20.640 --> 00:52:23.800
to do those conversions in terms of like scale


00:52:23.800 --> 00:52:25.200
and arithmetic.


00:52:25.200 --> 00:52:27.080
So it was really interesting.


00:52:27.080 --> 00:52:27.920
- Yeah.


00:52:27.920 --> 00:52:29.640
One quick thought I'll throw out there


00:52:29.640 --> 00:52:31.240
'cause this was such a surprise to me.


00:52:31.240 --> 00:52:32.080
I just had,


00:52:32.080 --> 00:52:35.960
it's so undiscoverable,


00:52:35.960 --> 00:52:38.800
but it's good once you know it.


00:52:38.800 --> 00:52:41.320
It's good to know it, let's put it that way at least,


00:52:41.320 --> 00:52:43.800
that when you're doing, forget pendulum for a minute,


00:52:43.800 --> 00:52:47.040
if you're just doing raw date times and time deltas,


00:52:47.040 --> 00:52:49.960
so time deltas always have a seconds, right?


00:52:49.960 --> 00:52:52.840
So I create a time, a difference between two times,


00:52:52.840 --> 00:52:54.280
or I take a time and add a time delta,


00:52:54.280 --> 00:52:57.280
I get a new time delta, or you get new time.


00:52:57.280 --> 00:52:59.520
But if you have a time delta and it's in seconds,


00:52:59.520 --> 00:53:02.520
which is basically the only option you get,


00:53:02.520 --> 00:53:04.440
and you wanna know, well, I need this in hours,


00:53:04.440 --> 00:53:07.520
I would always just go two total seconds divided by 60,


00:53:07.520 --> 00:53:10.240
you know, divided by 60 again.


00:53:10.240 --> 00:53:14.740
what you can do is create another time delta and say time delta hours equals one


00:53:14.740 --> 00:53:18.940
and then divide one by the other and then you get a number of hours.


00:53:18.940 --> 00:53:24.700
Or if you want like weeks, you know, time delta seven days and you divide your time delta by that


00:53:24.700 --> 00:53:27.260
and it'll give you the days and that's really handy.


00:53:27.260 --> 00:53:30.180
But boy, is it hard to discover to know that that's possible.


00:53:30.180 --> 00:53:31.140
Exactly.


00:53:31.140 --> 00:53:36.340
And that's where I think Python shines as well, because since the beginning,


00:53:36.740 --> 00:53:39.300
one of the arguments in favor of Python.


00:53:39.300 --> 00:53:43.700
It was when people said Python is pseudocode that runs,


00:53:43.700 --> 00:53:49.180
they were telling you Python brings you closer to the domain of the problem.


00:53:49.180 --> 00:53:56.940
Syntax sugar matters because the way you express software,


00:53:56.940 --> 00:54:00.780
it means you'll make less mistakes.


00:54:00.780 --> 00:54:03.620
When you read it, you fully understand it.


00:54:03.620 --> 00:54:06.500
It's easy to do a review.


00:54:06.500 --> 00:54:08.620
It's easy to do maintenance.


00:54:08.620 --> 00:54:11.160
It's easy to throw away and write it again.


00:54:11.160 --> 00:54:16.060
That matters. It's not just about if you know the logic,


00:54:16.060 --> 00:54:19.340
if you know the theory,


00:54:19.340 --> 00:54:23.700
but in the way you express the logic and the theory matters a lot.


00:54:23.700 --> 00:54:26.380
>> Yeah, absolutely. Totally agree.


00:54:26.380 --> 00:54:32.540
Let's talk one more element here on this one.


00:54:32.540 --> 00:54:35.900
That's the database side of things.


00:54:35.900 --> 00:54:38.700
Why did you choose MongoDB?


00:54:38.700 --> 00:54:40.240
What's your experience working with it?


00:54:40.240 --> 00:54:41.080
- That's a good question.


00:54:41.080 --> 00:54:41.900
- In this example.


00:54:41.900 --> 00:54:42.740
- That's a good question.


00:54:42.740 --> 00:54:46.760
So I came, while I was at the university,


00:54:46.760 --> 00:54:48.940
I was working with the database group.


00:54:48.940 --> 00:54:52.580
And I had a lot of experience with like database.


00:54:52.580 --> 00:54:56.460
I played with object-oriented database in 1993.


00:54:56.460 --> 00:54:59.300
There are French object database called O2.


00:54:59.300 --> 00:55:04.340
As time went by, we had Zoop and Zodb.


00:55:04.340 --> 00:55:05.900
I played a lot with GLDB,


00:55:05.900 --> 00:55:08.460
I even made a tiny little contribution to Zoho.


00:55:08.460 --> 00:55:10.460
So I've been exposed to NoSQL


00:55:10.460 --> 00:55:12.920
before NoSQL became a thing.


00:55:12.920 --> 00:55:16.320
But of course, SQL was still there.


00:55:16.320 --> 00:55:21.940
But what we wanted was, again, development time.


00:55:21.940 --> 00:55:24.240
So as a director at Working Cool,


00:55:24.240 --> 00:55:26.260
my main consideration is,


00:55:26.260 --> 00:55:30.300
can I make this project fit the budget and the schedule


00:55:30.300 --> 00:55:33.540
before I exactly know what we have to do?


00:55:33.540 --> 00:55:36.980
because the details will only be captured


00:55:36.980 --> 00:55:39.620
at the end of the conceptual design phase.


00:55:39.620 --> 00:55:42.940
But at that point in time, the money is defined,


00:55:42.940 --> 00:55:45.540
the schedule is set, so it's like,


00:55:45.540 --> 00:55:47.160
okay, I'll build the pyramids,


00:55:47.160 --> 00:55:48.580
but I didn't know it's going to be like


00:55:48.580 --> 00:55:52.040
bring those blocks of rock across the Nile.


00:55:52.040 --> 00:55:56.720
So because of that, I wanted to go for flexibility first.


00:55:56.720 --> 00:55:59.460
And going for a NoSQL database,


00:55:59.460 --> 00:56:03.800
it gives you speed in terms of development time, right?


00:56:03.800 --> 00:56:06.460
So you can put anything in there.


00:56:06.460 --> 00:56:10.100
Mongo is storing information in the same format


00:56:10.100 --> 00:56:12.820
as the applications are consuming them,


00:56:12.820 --> 00:56:13.660
which today--


00:56:13.660 --> 00:56:14.700
- Right, you don't have that object


00:56:14.700 --> 00:56:16.540
relational impedance mismatch.


00:56:16.540 --> 00:56:19.740
You just have, it's in Python, now it's in Mongo,


00:56:19.740 --> 00:56:20.900
now it's back in Python.


00:56:20.900 --> 00:56:24.260
- Exactly, it's the ORMs of the world.


00:56:24.260 --> 00:56:28.020
I always was let down by ORMs,


00:56:28.020 --> 00:56:30.620
because in the beginning when you know nothing,


00:56:30.620 --> 00:56:33.700
they are great because you don't need to learn


00:56:33.700 --> 00:56:36.200
the actual language of the database.


00:56:36.200 --> 00:56:39.480
After you evolve, they become a barrier


00:56:39.480 --> 00:56:42.280
because they are never as sophisticated


00:56:42.280 --> 00:56:47.280
as the data manipulation language of the database, right?


00:56:47.280 --> 00:56:50.540
And then it's like, why they don't support this and that.


00:56:50.540 --> 00:56:54.420
- My challenge has been more operational with ORMs


00:56:54.420 --> 00:56:56.860
is I think they're pretty good.


00:56:56.860 --> 00:56:58.780
A lot of times if you have the right indexes,


00:56:58.780 --> 00:56:59.860
the speed can be okay.


00:56:59.860 --> 00:57:02.380
If you make sure you do the joins


00:57:02.380 --> 00:57:06.500
instead of the lazy N plus one type of queries,


00:57:06.500 --> 00:57:09.340
you'll be okay, but you build up your classes


00:57:09.340 --> 00:57:10.220
and everything's easy.


00:57:10.220 --> 00:57:14.340
And then you wanna add a field to a class.


00:57:14.340 --> 00:57:15.980
You wanna create a relationship.


00:57:15.980 --> 00:57:17.300
Well, now you try to run your app.


00:57:17.300 --> 00:57:18.540
It doesn't just not work well.


00:57:18.540 --> 00:57:21.740
It fully crashes until you do a database migration.


00:57:21.740 --> 00:57:24.580
And are you doing that migration in production


00:57:24.580 --> 00:57:28.060
and then staging and dev, and then what's the downtime story


00:57:28.060 --> 00:57:30.860
as you roll out the changes to your multiple servers


00:57:30.860 --> 00:57:34.020
that all got to talk to that database, just like, ah.


00:57:34.020 --> 00:57:35.700
And for me, something like Mongo


00:57:35.700 --> 00:57:37.980
that is just so much more likely to adapt,


00:57:37.980 --> 00:57:40.700
like I haven't run a database migration


00:57:40.700 --> 00:57:43.820
or anything like that for years.


00:57:43.820 --> 00:57:47.060
And people talk about Mongo for like, it's web scale,


00:57:47.060 --> 00:57:48.620
and it's all this data and that's great.


00:57:48.620 --> 00:57:51.540
I mean, like my database probably has seven gigs of data


00:57:51.540 --> 00:57:54.580
for like TalkByDon training and the podcast.


00:57:54.580 --> 00:57:58.540
And that's a non-trivial amount of data,


00:57:58.540 --> 00:58:00.140
but it's not so much about the data,


00:58:00.140 --> 00:58:01.460
it's about the flexibility.


00:58:01.460 --> 00:58:03.460
Like it's easy to make it fast


00:58:03.460 --> 00:58:07.700
and it doesn't require DevOps at the extreme


00:58:07.700 --> 00:58:09.140
to do it well, you know?


00:58:09.140 --> 00:58:12.500
- That is a great point because managing the database,


00:58:12.500 --> 00:58:13.900
I will mention DevOps.


00:58:13.900 --> 00:58:17.980
So because Mongo, they also provide the Atlas service


00:58:17.980 --> 00:58:20.260
where you have like database as a service,


00:58:20.260 --> 00:58:23.680
That was key for us because then we can like forget


00:58:23.680 --> 00:58:25.920
about this, we simply connect to Atlas,


00:58:25.920 --> 00:58:28.620
they manage our cluster, they have the dashboards,


00:58:28.620 --> 00:58:30.400
everything in place.


00:58:30.400 --> 00:58:33.600
It was one click of a button to migrate


00:58:33.600 --> 00:58:36.700
from one version of Mongo to another version of Mongo.


00:58:36.700 --> 00:58:39.840
So those things are priceless when you're doing


00:58:39.840 --> 00:58:41.600
like quick pace development.


00:58:41.600 --> 00:58:43.060
There was another reason though.


00:58:43.060 --> 00:58:44.400
In the beginning of this project,


00:58:44.400 --> 00:58:47.640
PepsiCo asked us to use Azure.


00:58:47.640 --> 00:58:51.960
So that meant we were doing our Python services within Azure


00:58:51.960 --> 00:58:54.880
and we had to do a database within Azure.


00:58:54.880 --> 00:58:57.120
And we went for CosmoDB


00:58:57.120 --> 00:59:00.200
because CosmoDB was compatible with Mongo.


00:59:00.200 --> 00:59:04.280
If at any point in time we needed to move out of CosmoDB,


00:59:04.280 --> 00:59:05.920
we would have Mongo as a fallback.


00:59:05.920 --> 00:59:07.680
And that's exactly what happened.


00:59:07.680 --> 00:59:09.720
So a couple of months,


00:59:09.720 --> 00:59:12.360
there were some political changes within PepsiCo.


00:59:12.360 --> 00:59:15.680
They decided to go like AWS out of Azure,


00:59:15.680 --> 00:59:16.920
and then boom,


00:59:16.920 --> 00:59:19.720
We had MongoDB in Atlas,


00:59:19.720 --> 00:59:24.300
and we had like the same cluster in AWS for Python.


00:59:24.300 --> 00:59:25.140
We were happy.


00:59:25.140 --> 00:59:28.320
- Yeah, totally agree.


00:59:28.320 --> 00:59:29.160
Fantastic.


00:59:29.160 --> 00:59:30.140
So really neat.


00:59:30.140 --> 00:59:34.760
Now, I know we're gonna talk about a bunch of APIs,


00:59:34.760 --> 00:59:37.240
but we spent all our time talking about this one.


00:59:37.240 --> 00:59:41.120
But I think this is really a super interesting thing


00:59:41.120 --> 00:59:43.800
to dive into.


00:59:43.800 --> 00:59:46.480
We can touch on some of the other ones maybe a little bit,


00:59:46.480 --> 00:59:48.620
But I guess before we move off of this,


00:59:48.620 --> 00:59:50.660
like what's one of the big takeaways


00:59:50.660 --> 00:59:52.320
you took from this project here?


00:59:52.320 --> 00:59:55.200
- Oh, that's such a big question.


00:59:55.200 --> 00:59:57.980
There are like many things.


00:59:57.980 --> 01:00:02.980
I think the biggest perhaps is at the core


01:00:02.980 --> 01:00:06.760
of the agile mindset.


01:00:06.760 --> 01:00:08.860
After you implement stuff,


01:00:08.860 --> 01:00:12.060
it's really when you start to understand the problem.


01:00:12.060 --> 01:00:17.060
It's really, really hard to kind of design on paper


01:00:17.060 --> 01:00:19.700
and then it just works.


01:00:19.700 --> 01:00:23.660
So what we did for this project was many, many cycles


01:00:23.660 --> 01:00:25.460
of software rewrite.


01:00:25.460 --> 01:00:29.460
So when the project started back in 2019,


01:00:29.460 --> 01:00:33.420
like over the weekend,


01:00:33.420 --> 01:00:36.020
when they presented me the problem over the weekend,


01:00:36.020 --> 01:00:40.980
I was able to in a Friday afternoon, Saturday and Sunday


01:00:40.980 --> 01:00:43.940
to work on a tiny little full-blown solution.


01:00:43.940 --> 01:00:47.060
I had a timeline, I had a recommendation system,


01:00:47.060 --> 01:00:49.040
I had recommendations.


01:00:49.040 --> 01:00:52.860
It was kind of mockery a little bit,


01:00:52.860 --> 01:00:57.000
but I was able to cook that up in three days,


01:00:57.000 --> 01:00:58.700
show that to the clients and say,


01:00:58.700 --> 01:01:00.300
this is more or less what you're gonna do.


01:01:00.300 --> 01:01:02.500
And they really understood what was in there.


01:01:02.500 --> 01:01:04.180
And then we threw all of that away


01:01:04.180 --> 01:01:06.580
and built like the new version, like on Troy,


01:01:06.580 --> 01:01:09.700
many cities built one on top of the other.


01:01:09.700 --> 01:01:11.960
So that's what happened on this API.


01:01:11.960 --> 01:01:15.780
Like we're doing microservices like let's do Monolith.


01:01:15.780 --> 01:01:17.940
We're doing Cosmo, let's do Mongo.


01:01:17.940 --> 01:01:21.880
We're doing Quartz, let's just do Flask.


01:01:21.880 --> 01:01:24.440
We're doing Kerberos, let's do Marshmallow.


01:01:24.440 --> 01:01:27.880
Being able to throw things away


01:01:27.880 --> 01:01:32.000
and kind of rebuild, refactor, the power of refactoring


01:01:32.000 --> 01:01:35.600
made us to have a system that's always performing,


01:01:35.600 --> 01:01:39.600
that's manageable, that's minimal technical debt,


01:01:39.600 --> 01:01:42.920
And I think that was the key learning


01:01:42.920 --> 01:01:45.080
that I was able to fully apply


01:01:45.080 --> 01:01:47.280
in this long-term projects, like two years.


01:01:47.280 --> 01:01:49.160
That is not common for a working coach


01:01:49.160 --> 01:01:52.000
to have this two long projects.


01:01:52.000 --> 01:01:54.800
Usually our projects are like three months, six months,


01:01:54.800 --> 01:01:57.920
maybe a year, but in the case of Gatorade,


01:01:57.920 --> 01:01:59.300
it's a retainer project,


01:01:59.300 --> 01:02:01.720
we're for the long run with them.


01:02:01.720 --> 01:02:06.140
And in this case, you really need to evolve the platform.


01:02:06.140 --> 01:02:09.360
It's like maintenance-driven development.


01:02:09.360 --> 01:02:13.080
Yeah. Does that actually give you a different mindset when you're creating it?


01:02:13.080 --> 01:02:15.680
Like, I'm going to have to live with this.


01:02:15.680 --> 01:02:17.520
Not they. We're going to have to live with it.


01:02:17.520 --> 01:02:27.560
That is, I think that is the most difference between what I consider seasoned developers and new developers.


01:02:27.560 --> 01:02:32.440
We have like junior developers that they are very competent.


01:02:32.440 --> 01:02:34.520
They are very capable.


01:02:34.520 --> 01:02:37.320
They master really quickly new technologies.


01:02:37.760 --> 01:02:40.080
But the difference is to fully understand


01:02:40.080 --> 01:02:43.560
the impacts of decisions, not just based on theory,


01:02:43.560 --> 01:02:48.560
but based on social events that may or may not happen,


01:02:48.560 --> 01:02:51.280
based on what the future may bring.


01:02:51.280 --> 01:02:54.280
And experience counts a lot in that sense.


01:02:54.280 --> 01:02:59.120
And the maintenance-driven development mindset,


01:02:59.120 --> 01:03:00.400
when you know you're the one


01:03:00.400 --> 01:03:02.400
that you're going to do the maintenance,


01:03:02.400 --> 01:03:04.520
change things a lot.


01:03:04.520 --> 01:03:08.520
You think about stability, robustness, task coverage


01:03:08.520 --> 01:03:10.840
in a completely different way.


01:03:10.840 --> 01:03:11.680
- Yeah.


01:03:11.680 --> 01:03:14.880
I totally, it seems like it would.


01:03:14.880 --> 01:03:16.240
It seems like it absolutely would


01:03:16.240 --> 01:03:18.200
if you're the one who's got to live with it.


01:03:18.200 --> 01:03:20.320
Because you go to some of these consulting projects


01:03:20.320 --> 01:03:22.360
and they're like, oh, we really wanna use


01:03:22.360 --> 01:03:25.880
this specific database.


01:03:25.880 --> 01:03:28.080
We wanna use this framework, but in this odd way.


01:03:28.080 --> 01:03:30.080
And you're like, well, they're the customer.


01:03:30.080 --> 01:03:30.920
They're always right.


01:03:30.920 --> 01:03:32.880
But if it's gonna be you, you're like,


01:03:32.880 --> 01:03:36.200
yeah, we better build this the way that we're gonna be happy in a year.


01:03:36.200 --> 01:03:44.880
No, there's that, it reminds me of that funny quote, like always code as if a person who ends up maintaining your code will be a violent psychopath.


01:03:44.880 --> 01:03:45.960
You know, that's where you live, right?


01:03:45.960 --> 01:03:46.400
Very good.


01:03:46.400 --> 01:03:47.400
That's good advice.


01:03:47.400 --> 01:03:52.760
Yeah, a little, a little bit morbid, but, but do think about that.


01:03:52.760 --> 01:03:54.480
You'll have to live with it, I guess.


01:03:54.480 --> 01:03:55.760
Um,


01:03:55.760 --> 01:04:01.160
I think that that talks to the trend they call boring codes, right?


01:04:01.320 --> 01:04:04.160
There's a bunch of like speeches and talks in the internet.


01:04:04.160 --> 01:04:06.480
People talking about, "Oh, write boring code.


01:04:06.480 --> 01:04:09.000
Code that is easy to understand, easy to do maintenance."


01:04:09.000 --> 01:04:13.320
It has this mindset that when you're learning things


01:04:13.320 --> 01:04:15.680
and you're not concerned about production stuff,


01:04:15.680 --> 01:04:21.040
you are much more bold to try new things, right?


01:04:21.040 --> 01:04:24.440
Because then the project is done, you move away.


01:04:24.440 --> 01:04:27.120
So there's no cost, there's no risk,


01:04:27.120 --> 01:04:30.040
there's no penalty for trying new stuff


01:04:30.040 --> 01:04:32.040
that may prove inadequate.


01:04:32.040 --> 01:04:34.840
But when your success measurement is


01:04:34.840 --> 01:04:37.160
considering the maintenance phase,


01:04:37.160 --> 01:04:39.440
the long-term success of the project,


01:04:39.440 --> 01:04:41.200
the mindset is a different one.


01:04:41.200 --> 01:04:43.880
It's what is stable, what's guaranteed.


01:04:43.880 --> 01:04:45.680
>> Because if you're chasing the shiny new thing,


01:04:45.680 --> 01:04:47.000
you could end up saying, "Well, I'm going to build


01:04:47.000 --> 01:04:49.120
this six-month project, I'll do that in React.


01:04:49.120 --> 01:04:50.360
This one is going to be in view,


01:04:50.360 --> 01:04:51.720
and this one will be in Angular.


01:04:51.720 --> 01:04:54.040
This is going to have this back-end and that back-end."


01:04:54.040 --> 01:04:56.160
Then all of a sudden, you end up maintaining


01:04:56.160 --> 01:04:58.320
every JavaScript front-end framework in the world,


01:04:58.320 --> 01:05:00.520
- Exactly. - A small back ends and,


01:05:00.520 --> 01:05:02.360
yeah, you don't want to be like that.


01:05:02.360 --> 01:05:04.120
I think the other thing you touched on


01:05:04.120 --> 01:05:05.340
is really interesting.


01:05:05.340 --> 01:05:09.160
One of the things that I try to preach a lot is,


01:05:09.160 --> 01:05:13.760
it often doesn't matter too much how you get started


01:05:13.760 --> 01:05:15.840
so much as you get started on a project.


01:05:15.840 --> 01:05:17.560
I see a lot of people saying,


01:05:17.560 --> 01:05:18.700
you know, they'll get frozen,


01:05:18.700 --> 01:05:21.760
they're like, "I just can't decide between Django and Flask


01:05:21.760 --> 01:05:26.020
"or FastAPI or this or Postgres or Mongo."


01:05:26.020 --> 01:05:29.100
and they just, they think and they think and they think


01:05:29.100 --> 01:05:30.300
and they don't get anywhere.


01:05:30.300 --> 01:05:31.700
Like you highlighted with your,


01:05:31.700 --> 01:05:34.020
I did it over the weekend prototype.


01:05:34.020 --> 01:05:35.740
A lot of times those people who are stuck,


01:05:35.740 --> 01:05:38.500
if they just fully internalize,


01:05:38.500 --> 01:05:40.300
like you can just go on a path


01:05:40.300 --> 01:05:43.100
and then evolve it with refactoring and change it


01:05:43.100 --> 01:05:46.140
and throw it away and rewrite it with more knowledge.


01:05:46.140 --> 01:05:48.540
The time you spent worrying about what to do,


01:05:48.540 --> 01:05:51.860
you would already have a working example, probably.


01:05:51.860 --> 01:05:53.660
And then you have so much more information


01:05:53.660 --> 01:05:55.220
to build from and decide from.


01:05:55.220 --> 01:05:57.620
I think that's a really important takeaway.


01:05:57.620 --> 01:05:58.780
- Exactly.


01:05:58.780 --> 01:06:00.220
God is in the details.


01:06:00.220 --> 01:06:01.900
Nobody stumbles in mountains.


01:06:01.900 --> 01:06:05.380
It's the little things that make you fall.


01:06:05.380 --> 01:06:07.020
- That's a good quote, I like it.


01:06:07.020 --> 01:06:11.420
Nice, all right, well, I think rather than diving


01:06:11.420 --> 01:06:13.180
into the other APIs that we're gonna cover,


01:06:13.180 --> 01:06:17.500
I think maybe just this deep one into the GX sweat patches


01:06:17.500 --> 01:06:20.900
is probably a little bit more constructive and useful.


01:06:20.900 --> 01:06:23.220
So maybe we'll leave it here for the APIs.


01:06:23.220 --> 01:06:24.060
- Cool.


01:06:24.060 --> 01:06:26.660
>> Yeah. But really, really neat work.


01:06:26.660 --> 01:06:28.420
A lot of moving parts.


01:06:28.420 --> 01:06:29.580
You've got your mobile apps,


01:06:29.580 --> 01:06:31.520
you've got your mobile apps in Xamarin,


01:06:31.520 --> 01:06:33.820
you've got your ML models,


01:06:33.820 --> 01:06:36.660
you've got the APIs,


01:06:36.660 --> 01:06:38.940
the other external API integration,


01:06:38.940 --> 01:06:41.100
the other app integration, a lot of stuff going on here.


01:06:41.100 --> 01:06:42.820
I think it's a pretty good case study.


01:06:42.820 --> 01:06:45.780
>> It is. One bits that we didn't mention,


01:06:45.780 --> 01:06:48.320
I'd like to really quickly mention,


01:06:48.320 --> 01:06:53.820
is that we have another engine for product recommendations.


01:06:53.820 --> 01:06:56.980
that use constrain problem solving.


01:06:56.980 --> 01:07:00.220
This was, we're reusing a module,


01:07:00.220 --> 01:07:03.020
a colleague of mine called Gustavo Niemeyer.


01:07:03.020 --> 01:07:07.660
He's a core developer for Python now working for Canonical.


01:07:07.660 --> 01:07:11.700
He was with me in EuroPython 2005.


01:07:11.700 --> 01:07:16.180
On EuroPython 2005, he presented a Python module that now we're


01:07:16.180 --> 01:07:21.460
using to solve those constraint-based problem of [inaudible]


01:07:21.460 --> 01:07:24.360
And that is really cool because it's a really powerful


01:07:24.360 --> 01:07:28.580
mechanism and the problem we were solving was that


01:07:28.580 --> 01:07:32.220
you have all of these needs, right?


01:07:32.220 --> 01:07:35.500
Needs for carbs, needs for protein, needs for hydration,


01:07:35.500 --> 01:07:37.100
needs for electrolytes.


01:07:37.100 --> 01:07:39.340
And then you have all of these products that have


01:07:39.340 --> 01:07:42.060
different combinations of those elements.


01:07:42.060 --> 01:07:46.020
So what is the optimal amount of products and types


01:07:46.020 --> 01:07:50.060
of products and what is the minimum amount that you need


01:07:50.060 --> 01:07:53.740
to kind of fulfill all your nutritional


01:07:53.740 --> 01:07:55.180
and hydrational needs.


01:07:55.180 --> 01:07:58.660
And for that, we use Python Constraint.


01:07:58.660 --> 01:08:00.300
There are other engines there,


01:08:00.300 --> 01:08:05.100
but we want it to be like fully Python solution.


01:08:05.100 --> 01:08:08.860
And that is another hint that I wanna share with people.


01:08:08.860 --> 01:08:10.980
That is, it solves like a big problem


01:08:10.980 --> 01:08:13.740
and it's really easy to use.


01:08:13.740 --> 01:08:16.860
- And this is Python-Constraint on PyPI?


01:08:16.860 --> 01:08:19.140
- Yes, exactly this one you have on screen.


01:08:19.140 --> 01:08:21.280
by the dash constraint.


01:08:21.280 --> 01:08:22.720
- Okay, looks really cool.


01:08:22.720 --> 01:08:24.800
It reminds me a little bit of linear programming.


01:08:24.800 --> 01:08:26.480
- It is, it is.


01:08:26.480 --> 01:08:29.040
The difference is, well, actually,


01:08:29.040 --> 01:08:31.280
you have linear programming like Simplex,


01:08:31.280 --> 01:08:34.460
where you're kind of going into the plane


01:08:34.460 --> 01:08:36.320
and trying to optimize numerically.


01:08:36.320 --> 01:08:38.040
This is one kind of thing.


01:08:38.040 --> 01:08:40.920
This other one is more on exploring


01:08:40.920 --> 01:08:44.260
a discrete space of solutions.


01:08:44.260 --> 01:08:45.960
So you define your variables,


01:08:45.960 --> 01:08:49.120
the domain of values for each of these variables


01:08:49.120 --> 01:08:51.600
and the constraints that validate,


01:08:51.600 --> 01:08:54.880
is this combination of values a solution to the problem


01:08:54.880 --> 01:08:55.720
or not?


01:08:55.720 --> 01:08:57.120
If not, it's refused.


01:08:57.120 --> 01:08:57.960
- Got it.


01:08:57.960 --> 01:08:59.280
- So then it's a search space.


01:08:59.280 --> 01:09:03.520
- Yeah, so there's like a chess problem, the rook.


01:09:03.520 --> 01:09:04.360
- Exactly.


01:09:04.360 --> 01:09:08.160
- Which clearly is not a continuous problem.


01:09:08.160 --> 01:09:09.220
It's a very discreet.


01:09:09.220 --> 01:09:11.120
The rook can be in one of, you know,


01:09:11.120 --> 01:09:13.800
a hundred places or whatever on a chess board and that's it.


01:09:13.800 --> 01:09:14.760
- Exactly.


01:09:14.760 --> 01:09:15.600
- Got it.


01:09:15.600 --> 01:09:17.580
- Very cool.


01:09:17.580 --> 01:09:22.640
One final thing on this project here,


01:09:22.640 --> 01:09:23.840
now that you've created it,


01:09:23.840 --> 01:09:27.000
how many people are keeping it going and working on it?


01:09:27.000 --> 01:09:28.960
What's the team size at the beginning and the end?


01:09:28.960 --> 01:09:31.720
And we talked about the monolith versus microservices,


01:09:31.720 --> 01:09:33.280
but not really the details there


01:09:33.280 --> 01:09:35.280
that made you decide the monolith side.


01:09:35.280 --> 01:09:36.420
- That's a great question.


01:09:36.420 --> 01:09:38.360
So first of all,


01:09:38.360 --> 01:09:43.960
all the time we're talking about the GX consumer.


01:09:43.960 --> 01:09:45.280
So for like you and me,


01:09:45.280 --> 01:09:48.460
We also have another app that talks to the same API


01:09:48.460 --> 01:09:50.340
called GX Teams.


01:09:50.340 --> 01:09:54.180
And the GX Teams is for practitioners, coach,


01:09:54.180 --> 01:09:58.220
personals that they are managing a group of athletes.


01:09:58.220 --> 01:10:00.540
So this is another thing that Gatorade launched


01:10:00.540 --> 01:10:02.220
I guess this month.


01:10:02.220 --> 01:10:07.040
Both apps talk to the same API that we call GX Rack Engine.


01:10:07.040 --> 01:10:10.460
So just for GX Rack Engine,


01:10:10.460 --> 01:10:14.700
our development team is today four people.


01:10:14.700 --> 01:10:18.620
It's me, John Gomez, Nicholas Moya,


01:10:18.620 --> 01:10:21.340
Rodrigo Merlo and Sashari Moreno.


01:10:21.340 --> 01:10:22.900
So it's me plus four.


01:10:22.900 --> 01:10:26.300
So that is the whole backend team.


01:10:26.300 --> 01:10:31.300
For frontend, for PM, strategy, business, product,


01:10:31.300 --> 01:10:35.420
then it's kind of gross, right?


01:10:35.420 --> 01:10:38.980
But the things that we talk about in the Python world,


01:10:38.980 --> 01:10:40.580
we're talking about five people.


01:10:40.580 --> 01:10:44.540
- Yeah, you know, that's super common.


01:10:44.540 --> 01:10:48.260
if we look at the Python developer survey from the PSF,


01:10:48.260 --> 01:10:50.900
and we go down and look at the team size,


01:10:50.900 --> 01:10:54.660
the average team size, 75% of the time,


01:10:54.660 --> 01:10:55.820
was two to seven people.


01:10:55.820 --> 01:10:58.620
- Yeah, it's the bits rule, right?


01:10:58.620 --> 01:11:00.900
- Yeah, if you get out to what I would call


01:11:00.900 --> 01:11:05.900
the microservice side, that's maybe 20 people or so.


01:11:05.900 --> 01:11:09.260
And 20 people or more on the team size


01:11:09.260 --> 01:11:12.660
is only 4% of all software developers doing Python.


01:11:12.660 --> 01:11:16.900
So keep that in balance when you hear about like,


01:11:16.900 --> 01:11:19.980
you know, how Netflix or Google or Instagram


01:11:19.980 --> 01:11:21.340
is doing some amazing thing, right?


01:11:21.340 --> 01:11:24.340
That context doesn't necessarily apply to like your context.


01:11:24.340 --> 01:11:25.420
- Exactly, exactly.


01:11:25.420 --> 01:11:26.580
And they break down, right?


01:11:26.580 --> 01:11:28.700
I worked for global.com,


01:11:28.700 --> 01:11:32.220
which is the biggest news company in Brazil.


01:11:32.220 --> 01:11:36.300
We had a audience of 4 million people,


01:11:36.300 --> 01:11:39.300
like daily going through like our websites, et cetera.


01:11:39.300 --> 01:11:41.460
And the teams internally,


01:11:41.460 --> 01:11:46.360
They were like four or five people, none above seven,


01:11:46.360 --> 01:11:48.760
because it becomes unmanageable.


01:11:48.760 --> 01:11:51.560
The communication overhead becomes so high


01:11:51.560 --> 01:11:53.640
that it's not worth it.


01:11:53.640 --> 01:11:55.840
- Yeah, super interesting.


01:11:55.840 --> 01:11:57.840
I think we're gonna leave it there,


01:11:57.840 --> 01:11:59.660
but I'm gonna ask you the two final questions.


01:11:59.660 --> 01:12:02.120
Before I do that, let me just call out a couple comments


01:12:02.120 --> 01:12:04.120
from the live stream.


01:12:04.120 --> 01:12:06.000
Black and White said, "This video is so great, to be frank.


01:12:06.000 --> 01:12:06.840
"Thank you."


01:12:06.840 --> 01:12:08.320
And Vincent, hello, hello.


01:12:08.320 --> 01:12:10.320
Love your show, keep up the work, please.


01:12:10.320 --> 01:12:12.120
all your guests are on point, very interesting.


01:12:12.120 --> 01:12:14.720
Yeah, thank you all for being here.


01:12:14.720 --> 01:12:16.000
That's great.


01:12:16.000 --> 01:12:18.960
All right, Rod, working on these projects and others,


01:12:18.960 --> 01:12:20.180
if you're gonna write some Python code,


01:12:20.180 --> 01:12:22.280
what editor would you fire up?


01:12:22.280 --> 01:12:23.560
- Well, that's a great question.


01:12:23.560 --> 01:12:26.000
So I'm a big fan of PyCharm.


01:12:26.000 --> 01:12:28.880
So I've been using like PyCharm forever.


01:12:28.880 --> 01:12:32.060
It has some features that I kind of love,


01:12:32.060 --> 01:12:36.000
like class hierarchy, like usages of functions,


01:12:36.000 --> 01:12:41.000
the debugging, it's super well polished.


01:12:41.000 --> 01:12:43.800
So I use PyCharm for professional work,


01:12:43.800 --> 01:12:46.760
but having said that, I use everything else.


01:12:46.760 --> 01:12:51.120
So I dabble with like Visual Studio Code, great tool.


01:12:51.120 --> 01:12:55.440
I use Vim a lot when I'm on the shell or doing stuff.


01:12:55.440 --> 01:12:58.200
And of course I use Jupyter Notebooks as well.


01:12:58.200 --> 01:13:01.360
And sometimes I code stuff in Jupyter Notebooks,


01:13:01.360 --> 01:13:02.960
straight on Jupyter Notebooks.


01:13:02.960 --> 01:13:05.080
And it's like lots of code.


01:13:05.080 --> 01:13:05.920
- Of course.


01:13:05.920 --> 01:13:07.120
All of those.


01:13:07.120 --> 01:13:08.400
- Fantastic.


01:13:08.400 --> 01:13:13.400
I agree with all that and notable PyPI package.


01:13:13.400 --> 01:13:15.880
- Well, we mentioned like a couple there, right?


01:13:15.880 --> 01:13:21.340
Like Pint and Pendulum and Python Constraint.


01:13:21.340 --> 01:13:24.280
One that I heard in your show


01:13:24.280 --> 01:13:27.480
and I explore a little bit is called Rich.


01:13:27.480 --> 01:13:30.640
So I think it was Brad Cannon that mentioned Rich,


01:13:30.640 --> 01:13:32.000
but I'm not sure right now.


01:13:32.000 --> 01:13:34.680
But that was really awesome as well.


01:13:34.680 --> 01:13:36.160
really interesting.


01:13:36.160 --> 01:13:38.720
So these are like my picks.


01:13:38.720 --> 01:13:42.480
- Yeah, Rich is coming along as quite an interesting project.


01:13:42.480 --> 01:13:43.840
It's going, you know,


01:13:43.840 --> 01:13:46.160
Will there is doing such interesting work


01:13:46.160 --> 01:13:49.360
and it just has super opened up what you can do


01:13:49.360 --> 01:13:52.840
in the terminal, I think in a much more approachable way.


01:13:52.840 --> 01:13:54.720
Have you seen Textual?


01:13:54.720 --> 01:13:57.040
- Go ahead.


01:13:57.040 --> 01:14:01.140
- A Textual is like a layout engine for Rich


01:14:01.140 --> 01:14:02.800
that is coming on here.


01:14:02.800 --> 01:14:06.640
So what you can do is you can break up your terminal


01:14:06.640 --> 01:14:10.280
and to have like a toolbar, like a left docking thing,


01:14:10.280 --> 01:14:12.280
a footer, and then a main area.


01:14:12.280 --> 01:14:15.200
And then you render into each of those with Rich.


01:14:15.200 --> 01:14:16.040
- Fancy.


01:14:16.040 --> 01:14:18.160
- And you can do like even arrow keys


01:14:18.160 --> 01:14:20.920
and only like move the main window section.


01:14:20.920 --> 01:14:23.400
Oh, it's, yeah, there's a lot of cool stuff going there.


01:14:23.400 --> 01:14:24.440
So.


01:14:24.440 --> 01:14:25.720
- Super cool.


01:14:25.720 --> 01:14:26.560
- Yeah.


01:14:26.560 --> 01:14:27.400
Awesome, awesome.


01:14:27.400 --> 01:14:31.720
All right, well, final call to action.


01:14:31.720 --> 01:14:34.900
What's your final advice for people building these APIs,


01:14:34.900 --> 01:14:38.500
thinking about these decisions for their own projects?


01:14:38.500 --> 01:14:42.060
- Well, one I already have given, it's like be hands-on.


01:14:42.060 --> 01:14:46.700
Like try it out, see how it feels, get your hands dirty.


01:14:46.700 --> 01:14:48.900
This is crucial in my mind.


01:14:48.900 --> 01:14:50.420
The other one is start thinking


01:14:50.420 --> 01:14:52.420
about maintenance-driven development.


01:14:52.420 --> 01:14:55.900
So when you start, because even if it's not you,


01:14:55.900 --> 01:14:59.600
somebody will have to like give maintenance.


01:14:59.600 --> 01:15:04.600
So at least balance the costs and benefits of exploration


01:15:04.600 --> 01:15:07.320
and the advantages and downsides


01:15:07.320 --> 01:15:09.600
of reusing well-established technology.


01:15:09.600 --> 01:15:12.520
Always look for the zen, the yin yang,


01:15:12.520 --> 01:15:15.240
the balance on these forces.


01:15:15.240 --> 01:15:18.240
- Good advice, definitely secondhand.


01:15:18.240 --> 01:15:19.760
Rod, thanks for being on the show.


01:15:19.760 --> 01:15:21.240
- Thank you so much, Michael.


01:15:21.240 --> 01:15:22.080
- Yeah, you bet.


01:15:22.080 --> 01:15:26.200
And Penfield, glad you enjoyed the show.


01:15:26.200 --> 01:15:27.160
Thanks for being here.


01:15:27.160 --> 01:15:31.360
and yeah, catch y'all later.

