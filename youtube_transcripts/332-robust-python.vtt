WEBVTT

00:00:00.000 --> 00:00:01.000
Hey, Pat.


00:00:01.000 --> 00:00:02.000
>> Hey, Michael.


00:00:02.000 --> 00:00:03.000
How are you doing?


00:00:03.000 --> 00:00:04.000
>> Doing well.


00:00:04.000 --> 00:00:05.000
Hello, everyone out in the live stream.


00:00:05.000 --> 00:00:08.000
If you're here live, super happy to have you here.


00:00:08.000 --> 00:00:13.000
Put some comments into the live chat, and we'll try to make it a part of your show.


00:00:13.000 --> 00:00:18.000
If you're listening later, thanks for watching and being here on YouTube.


00:00:18.000 --> 00:00:23.000
And with that said, I think it's time for us to kick it off.


00:00:23.000 --> 00:00:25.000
Pat, welcome to Talk Python To Me.


00:00:25.000 --> 00:00:26.000
>> Thank you.


00:00:26.000 --> 00:00:27.000
I'm so honored to be here.


00:00:27.000 --> 00:00:28.000
Longtime listener.


00:00:28.000 --> 00:00:32.000
to be here. Long time listener.


00:00:32.000 --> 00:00:33.360
Oh, that's fantastic. I really, really


00:00:33.360 --> 00:00:36.000
appreciate that. It's


00:00:36.000 --> 00:00:37.280
an honor to have you here. We're talking


00:00:37.280 --> 00:00:40.080
about one of these subjects


00:00:40.080 --> 00:00:41.200
that I really enjoy. I feel like it's one


00:00:41.200 --> 00:00:43.440
of these


00:00:43.440 --> 00:00:45.600
more evergreen type of topics. You know,


00:00:45.600 --> 00:00:48.080
it's super fun to talk about


00:00:48.080 --> 00:00:49.920
the new features in Flask 2.0,


00:00:49.920 --> 00:00:51.600
but that's only relevant for so long


00:00:51.600 --> 00:00:53.440
and for so many people. But


00:00:53.440 --> 00:00:55.760
writing software that's reliable, that can


00:00:53.440 --> 00:00:57.600
can be changed over time, doing so in a Pythonic way,


00:00:57.600 --> 00:01:00.840
that's good stuff to learn no matter


00:01:00.840 --> 00:01:02.560
where you are in your career.


00:01:02.560 --> 00:01:03.800
- Oh, I absolutely agree.


00:01:03.800 --> 00:01:09.280
- Yeah, so you've written a book called "Robust Python"


00:01:09.280 --> 00:01:11.920
which caught my interest.


00:01:11.920 --> 00:01:14.840
I, as you can imagine, get a couple of books


00:01:14.840 --> 00:01:18.440
and ideas sent to me periodically per day.


00:01:18.440 --> 00:01:21.600
And so they don't usually appeal to me,


00:01:21.600 --> 00:01:26.800
But this one really does for the reasons that I exactly stated in the opening and we're just going to sort of riff on


00:01:26.800 --> 00:01:28.800
this more broad idea of


00:01:28.800 --> 00:01:32.000
What is robust python? What is clean code?


00:01:32.000 --> 00:01:37.760
Like how do you do this in python and make it maintainable for both you in the future and other people and so on


00:01:37.760 --> 00:01:42.800
Yeah, sounds good. Yeah before we get to that though. Let's start with you. What's your story?


00:01:42.800 --> 00:01:45.200
How do you get into programming in python?


00:01:45.200 --> 00:01:50.800
So I got into programming like many males my age. I loved video games as a kid


00:01:51.440 --> 00:01:55.840
And I was 12 or 13, and some ad in one of my video game


00:01:55.840 --> 00:01:59.400
magazines caught my eye for a video game creator studio.


00:01:59.400 --> 00:02:05.280
And it was this C++ engine, but it


00:02:05.280 --> 00:02:08.560
provided easy ways to do sprites and animations and particle


00:02:08.560 --> 00:02:09.720
effects.


00:02:09.720 --> 00:02:12.160
And they gave you step-by-step instructions.


00:02:12.160 --> 00:02:13.600
Here's how you build Pong.


00:02:13.600 --> 00:02:14.760
Here's how you build Frogger.


00:02:14.760 --> 00:02:16.160
And here are the assets.


00:02:16.160 --> 00:02:17.200
I started riffing on it.


00:02:17.200 --> 00:02:19.240
I really came to love it.


00:02:19.240 --> 00:02:22.720
I then took a programming class in high school,


00:02:22.720 --> 00:02:25.060
true basic, which I don't remember much of


00:02:25.060 --> 00:02:28.320
other than I don't think I'd ever go back to it now.


00:02:28.320 --> 00:02:30.240
But it interested me enough


00:02:30.240 --> 00:02:33.480
that I decided to go into computer science, college.


00:02:33.480 --> 00:02:35.440
I learned more about the video game industry,


00:02:35.440 --> 00:02:37.120
especially some of the hours they work and said,


00:02:37.120 --> 00:02:40.400
you know what, maybe the video game industry is not for me,


00:02:40.400 --> 00:02:42.420
but I still loved programming at its heart.


00:02:42.420 --> 00:02:46.280
So I continued on and just found a few jobs after college


00:02:46.280 --> 00:02:48.000
and just went from there.


00:02:48.000 --> 00:02:51.320
As far as Python went, so I worked in telecom for a little bit.


00:02:51.320 --> 00:02:52.320
Okay.


00:02:52.320 --> 00:02:54.800
And early 2010s, we had some test software.


00:02:54.800 --> 00:02:58.320
It was all written in the TCL programming language.


00:02:58.320 --> 00:03:01.960
And that is an interesting programming language.


00:03:01.960 --> 00:03:05.140
As far as types go, everything's treated as a string.


00:03:05.140 --> 00:03:07.640
And it led to some very unmaintainable code.


00:03:07.640 --> 00:03:11.480
So a few sharp engineers and myself, we decided, you know, what would it look like if we wrote


00:03:11.480 --> 00:03:13.120
this in Python?


00:03:13.120 --> 00:03:15.640
And a whole test automation was born from there.


00:03:15.640 --> 00:03:18.920
And we just went, wow, Python makes everything nicer.


00:03:18.920 --> 00:03:21.360
Like this is so much pleasurable to work with.


00:03:21.360 --> 00:03:24.500
And I've done like C++ and Java before then.


00:03:24.500 --> 00:03:26.480
So Python was a breath of fresh air


00:03:26.480 --> 00:03:28.400
and I just fell in love with the language.


00:03:28.400 --> 00:03:31.980
- Yeah, those are both very syntax symbol heavy languages.


00:03:31.980 --> 00:03:33.960
I've done a ton of C++.


00:03:33.960 --> 00:03:36.800
I did professional C++ development for a while.


00:03:36.800 --> 00:03:40.240
I have never done much Java, but yeah,


00:03:40.240 --> 00:03:41.800
they're really interesting.


00:03:41.800 --> 00:03:45.720
I remember when I came to Python, I came from C#,


00:03:45.720 --> 00:03:47.040
but also from C++.


00:03:47.040 --> 00:03:50.880
And just in my mind, those symbols,


00:03:50.880 --> 00:03:52.860
all the parentheses on the if statements


00:03:52.860 --> 00:03:54.580
and the semicolons at the end of the line


00:03:54.580 --> 00:03:57.140
and all that business, it was just required.


00:03:57.140 --> 00:03:59.440
That's just what languages needed to be.


00:03:59.440 --> 00:04:00.520
And then they weren't there.


00:04:00.520 --> 00:04:01.880
And I'm like, I just,


00:04:01.880 --> 00:04:03.520
this I'm having a hard time with this, right?


00:04:03.520 --> 00:04:05.480
And I thought it was weird,


00:04:05.480 --> 00:04:08.720
but then when I went back just to work on like a project


00:04:08.720 --> 00:04:11.560
that was still ongoing, it seemed more weird.


00:04:11.560 --> 00:04:13.640
I'm like, wait a minute, my eye, you know,


00:04:13.640 --> 00:04:15.640
like the wool's been taken off my eyes.


00:04:15.640 --> 00:04:18.100
Like I know now these are not required


00:04:18.100 --> 00:04:20.320
and still here I am continuing to write them.


00:04:20.320 --> 00:04:23.120
And it just drove me crazy once I realized


00:04:23.120 --> 00:04:24.640
I don't have to put these things here.


00:04:24.640 --> 00:04:26.080
It's just this language that makes me.


00:04:26.080 --> 00:04:28.200
And so, yeah, it was really nice.


00:04:28.200 --> 00:04:29.020
- Yeah, yeah.


00:04:29.020 --> 00:04:31.400
Python kind of captured that magic for me.


00:04:31.400 --> 00:04:34.120
And it's funny 'cause going back to C++


00:04:34.120 --> 00:04:35.040
every once in a while,


00:04:35.040 --> 00:04:38.240
my C++ got a lot better because of Python.


00:04:38.240 --> 00:04:40.160
You start focusing on the simple, that's nice.


00:04:40.160 --> 00:04:41.800
- Yeah, yeah, exactly.


00:04:41.800 --> 00:04:44.480
You're not trying to flex with your double pointers


00:04:44.480 --> 00:04:46.280
and all that kind of stuff.


00:04:46.280 --> 00:04:47.120
It's like, we don't need this.


00:04:47.120 --> 00:04:49.200
Let's not do this, come on.


00:04:49.200 --> 00:04:50.040
Very cool.


00:04:50.040 --> 00:04:50.860
So how about now?


00:04:50.860 --> 00:04:51.700
What are you doing?


00:04:51.700 --> 00:04:54.000
- So right now I am a software engineer at Canonical.


00:04:54.000 --> 00:04:56.160
I'm on their public cloud team.


00:04:56.160 --> 00:04:57.800
So we're building the Ubuntu operating system


00:04:57.800 --> 00:05:02.600
for public clouds, AWS, Azure, GCE, a couple others.


00:05:02.600 --> 00:05:05.960
And so we customize the images for clouds,


00:05:05.960 --> 00:05:08.240
work with a lot of other Canonical teams


00:05:08.240 --> 00:05:11.680
to make sure that their changes are reflected in our software.


00:05:11.680 --> 00:05:13.680
And we maintain the CI/CD pipelines


00:05:13.680 --> 00:05:16.600
to deliver those as often as we can.


00:05:16.600 --> 00:05:19.240
Most of the tooling is written in Python,


00:05:19.240 --> 00:05:21.640
so I get to use Python day to day, which makes me happy.


00:05:21.640 --> 00:05:23.520
That's really cool.


00:05:23.520 --> 00:05:26.120
What kind of features are we talking about here?


00:05:26.120 --> 00:05:29.800
General hardware enablement.


00:05:29.800 --> 00:05:33.720
So clouds may have new instances, new processor types,


00:05:33.720 --> 00:05:36.640
working to make sure that that's enabled,


00:05:36.640 --> 00:05:39.680
do a lot of close work with our kernel team.


00:05:39.680 --> 00:05:44.040
Features that the cloud themselves might request, maybe--


00:05:44.040 --> 00:05:46.280
- Like something the cloud needs to set up


00:05:46.280 --> 00:05:48.240
and maintain the VM aspect?


00:05:48.240 --> 00:05:51.400
- Yes, more on the infrastructure side,


00:05:51.400 --> 00:05:54.440
maybe how do they hibernate their VMs?


00:05:54.440 --> 00:05:55.800
How do they improve boot speed?


00:05:55.800 --> 00:05:56.960
Those sort of changes.


00:05:56.960 --> 00:06:00.320
Or how do they improve the security profile?


00:06:00.320 --> 00:06:01.400
That's something I'm working on right now


00:06:01.400 --> 00:06:03.120
with some of our clouds.


00:06:03.120 --> 00:06:04.920
- Yeah, super, super important.


00:06:05.920 --> 00:06:14.080
that's part of the promise to go into the cloud is often there's better security and better durability. But if it fails, it fails for


00:06:14.080 --> 00:06:19.840
potentially all of some big chunk of it, right? Like that's the consequence of failure is also higher. So


00:06:19.840 --> 00:06:25.240
yeah, yeah, the you have to be very aware of how many people are using your software when you deploy to the cloud.


00:06:25.240 --> 00:06:27.200
Does it make you nervous to work on that kind of stuff?


00:06:27.200 --> 00:06:34.720
Oh, absolutely. Yeah, yeah. I wouldn't I'd be lying if I said it didn't. But you, you learn to be careful, you learn to really


00:06:34.720 --> 00:06:40.320
focus on making everyone, you know, having good communication between your teams, making


00:06:40.320 --> 00:06:44.480
sure there's no surprises for anyone, that sort of thing.


00:06:44.480 --> 00:06:48.600
Yeah, I remember that as well, just working on certain things like the first e-commerce


00:06:48.600 --> 00:06:52.960
system I wrote, like this thing's going to be charging thousands of dollars per transaction


00:06:52.960 --> 00:06:57.960
and I might screw this up and I'm really worried, deploying it for the whole company.


00:06:57.960 --> 00:07:01.140
It was like big purchases people were doing.


00:07:01.140 --> 00:07:03.940
It made me really nervous, but at the same time,


00:07:03.940 --> 00:07:05.480
one of the things I've come to learn


00:07:05.480 --> 00:07:09.840
over my career of programming is it's one of the things


00:07:09.840 --> 00:07:12.500
that will really put a sad look on your face


00:07:12.500 --> 00:07:14.740
is if you spend a lot of time and create beautiful software


00:07:14.740 --> 00:07:16.020
and no one uses it.


00:07:16.020 --> 00:07:17.140
- That's true.


00:07:17.140 --> 00:07:19.100
- Yeah, so even though it may be stressful


00:07:19.100 --> 00:07:20.820
that it's getting used a lot, it's really central.


00:07:20.820 --> 00:07:22.980
That's also amazing, right?


00:07:22.980 --> 00:07:25.140
- Yeah, but it's also made me a better programmer


00:07:25.140 --> 00:07:26.440
'cause you just start thinking


00:07:26.440 --> 00:07:28.740
about explicit error cases more.


00:07:28.740 --> 00:07:30.580
At my last job, I mentioned I did telecom


00:07:30.580 --> 00:07:33.700
and so 911 calls get routed through your equipment.


00:07:33.700 --> 00:07:34.820
You don't wanna fail that.


00:07:34.820 --> 00:07:38.780
And it is scary at first,


00:07:38.780 --> 00:07:41.220
but you learn to develop disciplines over time of,


00:07:41.220 --> 00:07:42.540
okay, how do we make sure


00:07:42.540 --> 00:07:44.620
we're not making mistakes along the way?


00:07:44.620 --> 00:07:46.100
- Yeah, absolutely.


00:07:46.100 --> 00:07:47.340
And speaking of that,


00:07:47.340 --> 00:07:49.420
I think that's maybe a good segue


00:07:49.420 --> 00:07:53.300
into talk about this idea of robust Python.


00:07:53.300 --> 00:07:54.140
- Yeah.


00:07:54.140 --> 00:07:55.860
- First of all, let's just talk about your book


00:07:55.860 --> 00:07:56.700
for just a minute,


00:07:56.700 --> 00:07:58.020
and then we'll just get into the general idea of it.


00:07:58.020 --> 00:08:00.460
What motivated you to write this book?


00:08:00.460 --> 00:08:03.940
So I mentioned I've done C++ development in the past.


00:08:03.940 --> 00:08:08.300
I started diving heavy into modern C++


00:08:08.300 --> 00:08:11.580
and how it uses a lot more type safety features


00:08:11.580 --> 00:08:13.700
than some earlier versions of C++.


00:08:13.700 --> 00:08:15.500
Did a quick dabble into Haskell


00:08:15.500 --> 00:08:16.820
just from a learning perspective


00:08:16.820 --> 00:08:20.380
and really started to love static type systems.


00:08:20.380 --> 00:08:22.860
But my day-to-day language was Python.


00:08:22.860 --> 00:08:24.620
So I really, really dove deep on,


00:08:24.620 --> 00:08:26.940
how do I make my Python safer moving forward?


00:08:26.940 --> 00:08:28.900
So I pitched to a few publishers,


00:08:28.900 --> 00:08:32.660
I want to write a book about type system best practices


00:08:32.660 --> 00:08:33.500
in Python.


00:08:33.500 --> 00:08:34.860
Let's talk type checkers,


00:08:34.860 --> 00:08:38.220
let's talk about design types and so on and so forth.


00:08:38.220 --> 00:08:39.920
O'Reilly, who published my book,


00:08:39.920 --> 00:08:42.780
they bit and they said, "Oh, that sounds interesting.


00:08:42.780 --> 00:08:44.580
"Can we expand the scope a little bit more?"


00:08:44.580 --> 00:08:48.260
And I thought, okay, well, why do I write types in Python?


00:08:48.260 --> 00:08:50.740
Why do I advocate type systems?


00:08:50.740 --> 00:08:52.740
It's to make things more maintainable,


00:08:52.740 --> 00:08:55.900
to make things live longer, to make things clearer.


00:08:55.900 --> 00:08:58.260
And the idea of robust Python came out of that.


00:08:58.260 --> 00:09:03.260
I think it's really a pretty interesting idea.


00:09:03.260 --> 00:09:08.940
I do think when you come from these languages like C++ or Java or something,


00:09:08.940 --> 00:09:15.820
there is something to be said for it literally is verified to be clicked together,


00:09:15.820 --> 00:09:17.980
just like a perfect jigsaw puzzle.


00:09:17.980 --> 00:09:21.980
Yeah, it won't catch every error, but it can catch more errors.


00:09:21.980 --> 00:09:23.180
And that's a good thing.


00:09:23.180 --> 00:09:27.900
Yeah, I remember how excited I was when I got my first non-trivial C++ thing


00:09:27.900 --> 00:09:29.900
to compile and I'm like, yes, I've done it.


00:09:29.900 --> 00:09:32.340
Little did I know, like I was in for it.


00:09:32.340 --> 00:09:34.500
I mean, it was out of compiler errors


00:09:34.500 --> 00:09:37.980
and into like real errors at that point, right?


00:09:37.980 --> 00:09:39.980
- Yeah, the fun errors, right?


00:09:39.980 --> 00:09:41.460
- Yeah, exactly.


00:09:41.460 --> 00:09:42.860
The why, what is it?


00:09:42.860 --> 00:09:43.700
What is it?


00:09:43.700 --> 00:09:45.580
Segfault, whatever.


00:09:45.580 --> 00:09:46.420
I don't know.


00:09:46.420 --> 00:09:47.240
We're gonna work on that.


00:09:47.240 --> 00:09:50.900
So anyway, that was really interesting.


00:09:50.900 --> 00:09:55.260
I do think that it's not required, right?


00:09:55.260 --> 00:09:58.940
I do think that there's really interesting code being written in Python.


00:09:58.940 --> 00:10:02.340
And you can see that how it's being adopted in all these ways.


00:10:02.340 --> 00:10:07.980
The biggest maybe example I have in mind of these two things side by side is,


00:10:07.980 --> 00:10:12.580
you know, YouTube versus Google Video and how Google Video was in Python


00:10:12.580 --> 00:10:17.180
with 20 engineers, Google Video was 100 C++ engineers, and eventually Google


00:10:17.180 --> 00:10:20.660
just said, "All right, we're going to put that project aside and buy YouTube


00:10:20.660 --> 00:10:23.340
because they just keep outrunning us in features with Python."


00:10:23.340 --> 00:10:25.400
- Yeah, I think that's the beauty of Python


00:10:25.400 --> 00:10:27.800
is that you can build things fast,


00:10:27.800 --> 00:10:29.480
you can see them working faster,


00:10:29.480 --> 00:10:32.000
and you don't have to fight the compiler


00:10:32.000 --> 00:10:32.840
as much of the way.


00:10:32.840 --> 00:10:34.600
So it's almost like these two things are at odds


00:10:34.600 --> 00:10:37.640
and I think the answer is just Python's gradual typing.


00:10:37.640 --> 00:10:39.560
You just type as you need to.


00:10:39.560 --> 00:10:42.120
You add typing where it makes sense.


00:10:42.120 --> 00:10:43.760
And I won't be prescriptive and say


00:10:43.760 --> 00:10:45.360
you need types everywhere,


00:10:45.360 --> 00:10:47.440
but there's certain places where it makes a lot of sense


00:10:47.440 --> 00:10:49.760
and can save you money and time.


00:10:49.760 --> 00:10:52.260
- Yeah, I do find it pretty interesting


00:10:52.260 --> 00:10:54.420
how they've implemented types in Python.


00:10:54.420 --> 00:10:56.480
And to be clear, this idea of robust Python


00:10:56.480 --> 00:10:59.260
that you're focused on, types is just one part of it,


00:10:59.260 --> 00:11:01.860
but it sounds like it was the genesis of it.


00:11:01.860 --> 00:11:02.980
- It was absolutely the genesis.


00:11:02.980 --> 00:11:04.100
- Yeah, yeah.


00:11:04.100 --> 00:11:09.100
So we have sort of two other realities


00:11:09.100 --> 00:11:10.480
that we might look at.


00:11:10.480 --> 00:11:12.700
We could look at C++ or C# or Java,


00:11:12.700 --> 00:11:14.380
like they're all the same in that regard.


00:11:14.380 --> 00:11:17.600
They're like static compiled languages.


00:11:17.600 --> 00:11:20.100
And then we've got something that's much closer to Python


00:11:20.100 --> 00:11:22.320
with TypeScript, where they said,


00:11:22.320 --> 00:11:24.920
we have the same problem, we have JavaScript,


00:11:24.920 --> 00:11:27.760
which is even less typed, 'cause the runtime types


00:11:27.760 --> 00:11:32.280
are all just weird dictionary prototype things anyway.


00:11:32.280 --> 00:11:36.120
And we wanna make that reliable for larger scale software


00:11:36.120 --> 00:11:37.600
and integrations and stuff.


00:11:37.600 --> 00:11:41.040
So we create TypeScript, but the real fork in the road,


00:11:41.040 --> 00:11:43.680
I think, that was interesting is the TypeScript people said,


00:11:43.680 --> 00:11:47.280
we're gonna apply the ideas of absolute strict typing.


00:11:47.280 --> 00:11:50.580
Once you start down that path, it's all down that path.


00:11:50.580 --> 00:11:51.960
And they have to match up.


00:11:51.960 --> 00:11:53.700
Whereas in Python, it's like,


00:11:53.700 --> 00:11:57.400
let's help you down this path,


00:11:57.400 --> 00:12:01.160
but not give up the Zen of Python


00:12:01.160 --> 00:12:03.560
where you can easily put things together


00:12:03.560 --> 00:12:06.240
and you're not restricted by this type system.


00:12:06.240 --> 00:12:08.200
But if you run the right tools,


00:12:08.200 --> 00:12:12.100
be that PyCharm, VS Code, or mypy or something like that,


00:12:12.100 --> 00:12:15.720
it'll be there to help you make it better in lots of ways.


00:12:15.720 --> 00:12:19.960
I think that's a really creative and interesting aspect of it.


00:12:19.960 --> 00:12:22.160
- Yeah, yeah, I absolutely agree with that.


00:12:22.160 --> 00:12:26.720
A lot of things that I discussed throughout the book


00:12:26.720 --> 00:12:31.720
is the idea that these are tools in your toolbox.


00:12:31.720 --> 00:12:35.060
And so I talk about tests, I talk about API design,


00:12:35.060 --> 00:12:37.400
I talk about extensibility, they're all tools


00:12:37.400 --> 00:12:40.480
and they shouldn't be applied everywhere.


00:12:40.480 --> 00:12:43.160
I really wanna start focusing on first principles.


00:12:43.160 --> 00:12:45.780
why do we do the things we do in software engineering


00:12:45.780 --> 00:12:48.800
and what are the most appropriate places for them?


00:12:48.800 --> 00:12:49.640
- Yeah.


00:12:49.640 --> 00:12:52.740
You had a really interesting quote in your book


00:12:52.740 --> 00:12:54.800
about software engineering.


00:12:54.800 --> 00:12:56.780
And I've always sort of struggled


00:12:56.780 --> 00:12:59.340
to have this conversation with people like,


00:12:59.340 --> 00:13:00.640
oh, are you a programmer?


00:13:00.640 --> 00:13:01.620
Are you a coder?


00:13:01.620 --> 00:13:03.140
Are you an engineer?


00:13:03.140 --> 00:13:04.620
Like, where are you on that?


00:13:04.620 --> 00:13:06.960
Like, is that even a meaningful distinction?


00:13:06.960 --> 00:13:07.900
And to a large degree,


00:13:07.900 --> 00:13:10.300
I've always felt like it was just sort of,


00:13:10.300 --> 00:13:12.160
you know, whatever sort of culture you're in,


00:13:12.160 --> 00:13:14.360
You know, if you're in a startup, it's one thing.


00:13:14.360 --> 00:13:15.900
If you're in like a giant enterprise,


00:13:15.900 --> 00:13:18.120
they may value a different title in a different way.


00:13:18.120 --> 00:13:19.460
It's all kind of the same.


00:13:19.460 --> 00:13:21.400
But you had this cool quote that said something like,


00:13:21.400 --> 00:13:24.840
"Software engineering is programming integrated over time."


00:13:24.840 --> 00:13:26.680
- Yes, and I wish I could claim credit for that,


00:13:26.680 --> 00:13:29.600
but that actually came from Titus Winters of Google


00:13:29.600 --> 00:13:33.320
in a C++ con or CPP con talk.


00:13:33.320 --> 00:13:35.720
And it's just really resonated with me.


00:13:35.720 --> 00:13:39.840
We program, but software engineering is the efforts


00:13:39.840 --> 00:13:44.240
that programming over years or decades, your code will live


00:13:44.240 --> 00:13:47.560
decades. The more valuable it is, the longer live it probably


00:13:47.560 --> 00:13:51.400
will be. I've worked on code that's been 15 years old when I


00:13:51.400 --> 00:13:55.040
started on it. And there's code that I wrote 12 years ago that's


00:13:55.040 --> 00:13:58.120
still running operationally. And that that's scares me to some


00:13:58.120 --> 00:14:02.000
degree. Because like, Oh, did I know what I was doing back then?


00:14:02.000 --> 00:14:05.880
But it just reemphasize like why it's so important to think


00:14:06.640 --> 00:14:10.280
towards the future of what your audience,


00:14:10.280 --> 00:14:12.560
you're gonna have maintainers that come after you.


00:14:12.560 --> 00:14:14.560
And do you want them to curse your name


00:14:14.560 --> 00:14:15.520
or do you want them to be like,


00:14:15.520 --> 00:14:17.200
oh, thank goodness, this person wrote something


00:14:17.200 --> 00:14:19.280
that I can use, it's really easy.


00:14:19.280 --> 00:14:21.880
And I always prefer the latter on that.


00:14:21.880 --> 00:14:22.720
I also like to say--


00:14:22.720 --> 00:14:25.400
- Yeah, and the nicer code that you write


00:14:25.400 --> 00:14:28.640
and the more durable and long live code that you write,


00:14:28.640 --> 00:14:32.440
the more it can continue to have a life


00:14:32.440 --> 00:14:34.720
even after you've stepped away from the project, right?


00:14:34.720 --> 00:14:37.120
It's like, this is thing is still working well.


00:14:37.120 --> 00:14:40.840
We can keep growing it rather than it's turned into a complete pile of junk that


00:14:40.840 --> 00:14:42.680
we've got to throw away and start over.


00:14:42.680 --> 00:14:42.920
Right.


00:14:42.920 --> 00:14:45.260
So that's, that's a goal that you might want.


00:14:45.260 --> 00:14:47.480
And then also that long-term maintainer might be you.


00:14:47.480 --> 00:14:48.520
Yep.


00:14:48.520 --> 00:14:49.200
Yep.


00:14:49.200 --> 00:14:52.600
You might be working out five years from now and go, why did I


00:14:52.600 --> 00:14:53.720
make the decisions that I did?


00:14:53.720 --> 00:14:54.520
I don't remember this.


00:14:54.520 --> 00:14:56.960
Maybe you've jumped to a different project and came back.


00:14:56.960 --> 00:14:58.680
It absolutely can be you.


00:14:58.680 --> 00:15:00.800
Yeah, it absolutely can.


00:15:02.160 --> 00:15:07.240
So maybe let's talk about some of the core ideas


00:15:07.240 --> 00:15:10.560
that you have about making software


00:15:10.560 --> 00:15:13.440
maintainable, reliable.


00:15:13.440 --> 00:15:16.800
One of the things you talk about is the separation of time


00:15:16.800 --> 00:15:20.280
and how code has to communicate, or the artifacts


00:15:20.280 --> 00:15:22.320
that we all produce around code has


00:15:22.320 --> 00:15:27.960
to communicate with people, both maybe almost immediately.


00:15:27.960 --> 00:15:29.600
Like I am working on this project


00:15:29.600 --> 00:15:31.600
with a couple of other developers,


00:15:31.600 --> 00:15:33.840
and we need to keep it going forward.


00:15:33.840 --> 00:15:35.760
The other one is way down in the future,


00:15:35.760 --> 00:15:36.880
someone comes back and they're like,


00:15:36.880 --> 00:15:40.640
"Oh, I'm new here, the person who created it left."


00:15:40.640 --> 00:15:43.320
Maybe talk about some of those ideas that you've covered.


00:15:43.320 --> 00:15:45.920
- Yeah, and so it feels a little weird


00:15:45.920 --> 00:15:46.760
'cause what we're talking about


00:15:46.760 --> 00:15:48.160
is asynchronous communication.


00:15:48.160 --> 00:15:50.720
And it's weird to talk about that on a Python podcast


00:15:50.720 --> 00:15:52.560
and not talk about Async/Await.


00:15:52.560 --> 00:15:53.400
- Yeah, exactly.


00:15:53.400 --> 00:15:55.400
- But it's asynchronous communication in real life,


00:15:55.400 --> 00:15:57.280
which I actually think is much harder.


00:15:57.280 --> 00:15:58.680
You have to think about,


00:15:58.680 --> 00:16:00.280
you're time traveling to some degree.


00:16:00.280 --> 00:16:02.080
you have to think about the future


00:16:02.080 --> 00:16:03.520
and you have to communicate to them.


00:16:03.520 --> 00:16:05.380
You probably will never meet them.


00:16:05.380 --> 00:16:06.720
You'll never talk to them.


00:16:06.720 --> 00:16:09.560
The only thing that lives on are the artifacts you create.


00:16:09.560 --> 00:16:13.320
So your code, your documentation, your commit messages,


00:16:13.320 --> 00:16:15.960
that's what people in the future are gonna construct


00:16:15.960 --> 00:16:17.480
this mental model of your work from.


00:16:17.480 --> 00:16:20.000
They're gonna be doing archeology when things go wrong.


00:16:20.000 --> 00:16:21.720
Why is this code the way it is?


00:16:21.720 --> 00:16:23.480
Is it safe to change?


00:16:23.480 --> 00:16:25.400
What were the original intentions?


00:16:25.400 --> 00:16:28.200
And so the more you can embed that in the code you write


00:16:28.200 --> 00:16:31.320
and the surrounding commit messages, documentation,


00:16:31.320 --> 00:16:33.600
the more robust your code base is going to be,


00:16:33.600 --> 00:16:37.720
the more you're communicating intent to the future.


00:16:37.720 --> 00:16:38.760
- Yeah.


00:16:38.760 --> 00:16:43.080
Well, I do believe that that's one of the things


00:16:43.080 --> 00:16:46.960
that was so important for 2020, 2021, for all of us, right?


00:16:46.960 --> 00:16:49.480
Like we didn't know how much we were gonna need it


00:16:49.480 --> 00:16:51.760
because there's always been this kind of tension.


00:16:51.760 --> 00:16:54.680
Well, there's the open source world


00:16:54.680 --> 00:16:55.800
and these other projects,


00:16:55.800 --> 00:16:57.780
and there's those weird remote teams,


00:16:57.780 --> 00:17:00.260
But we come to our cubicles and we all sit down


00:17:00.260 --> 00:17:01.740
and we have our stand up in the morning


00:17:01.740 --> 00:17:03.900
and we write our software together.


00:17:03.900 --> 00:17:07.060
And like that's, and we use, you know,


00:17:07.060 --> 00:17:08.780
Perforce or something,


00:17:08.780 --> 00:17:10.220
internal where we lock the file.


00:17:10.220 --> 00:17:12.780
No one else can edit the file till I unlock the file, right?


00:17:12.780 --> 00:17:14.540
Like there's these, these different ways.


00:17:14.540 --> 00:17:17.780
And we've been moving more and more towards this sort of


00:17:17.780 --> 00:17:20.220
everything, even if the person is right next to you,


00:17:20.220 --> 00:17:23.420
the way we work is as if they were across the world.


00:17:23.420 --> 00:17:24.260
- Yeah.


00:17:24.260 --> 00:17:25.980
- And you know, it's been really, I guess,


00:17:25.980 --> 00:17:30.980
lucky for us as an industry that that was mostly in place.


00:17:30.980 --> 00:17:33.200
- Yes, absolutely. - And that actually became true.


00:17:33.200 --> 00:17:36.160
- Yeah, and so I think you touched on an interesting point


00:17:36.160 --> 00:17:38.760
of a lot of developers think,


00:17:38.760 --> 00:17:41.900
oh, if we're close in space, we can collaborate.


00:17:41.900 --> 00:17:43.520
You know, I don't have to worry about my remote teams


00:17:43.520 --> 00:17:47.280
and I don't have to worry about, you know, someone global.


00:17:47.280 --> 00:17:50.520
But by thinking of that, of your collaborators


00:17:50.520 --> 00:17:51.880
in that terms, it sets you up to think


00:17:51.880 --> 00:17:53.120
about the future as well.


00:17:53.120 --> 00:17:55.480
'Cause you can be asynchronous in space


00:17:55.480 --> 00:17:57.400
or asynchronous time.


00:17:57.400 --> 00:17:58.480
- Right, right.


00:17:58.480 --> 00:18:02.400
And basically the same tools are there to address it.


00:18:02.400 --> 00:18:04.400
- The same strategies help with both.


00:18:04.400 --> 00:18:06.000
- Yeah.


00:18:06.000 --> 00:18:08.880
So one of the things that you talked about


00:18:08.880 --> 00:18:13.280
was this principle of least surprise.


00:18:13.280 --> 00:18:14.120
- Yeah.


00:18:14.120 --> 00:18:15.400
- Tell us about that principle.


00:18:15.400 --> 00:18:16.640
- Yeah, the principle of least surprise,


00:18:16.640 --> 00:18:19.520
also known as the principle of least astonishment.


00:18:19.520 --> 00:18:21.780
I feel like it's safe to say most developers


00:18:21.780 --> 00:18:23.760
have gone through a code base


00:18:23.760 --> 00:18:25.600
and been legitimately surprised.


00:18:25.600 --> 00:18:28.040
And I went, that function does that?


00:18:28.040 --> 00:18:30.360
Oh my goodness, I would never have thought that.


00:18:30.360 --> 00:18:32.700
Once worked on a nasty bug


00:18:32.700 --> 00:18:36.240
where the get event function was setting an event.


00:18:36.240 --> 00:18:37.880
And I kept overlooking it because I'm like,


00:18:37.880 --> 00:18:38.720
what's a get event?


00:18:38.720 --> 00:18:40.880
It's just a getter, I can ignore this.


00:18:40.880 --> 00:18:41.720
And like two days later-- - This will have


00:18:41.720 --> 00:18:43.680
no side effect, this will be fine.


00:18:43.680 --> 00:18:46.080
- Two days later, I'm like, let me go step through this.


00:18:46.080 --> 00:18:47.720
And I was floored, I'm like,


00:18:47.720 --> 00:18:49.480
of course this explains my bug.


00:18:49.480 --> 00:18:51.880
So your goal when developing software


00:18:51.880 --> 00:18:54.420
is you don't want to surprise your future readers.


00:18:54.420 --> 00:18:58.220
And I think this is why people say avoid clever code,


00:18:58.220 --> 00:19:00.380
favor clear code over clever code.


00:19:00.380 --> 00:19:02.940
You don't want to surprise readers.


00:19:02.940 --> 00:19:05.900
Many, many people may not be as well versed


00:19:05.900 --> 00:19:06.740
in the language as you.


00:19:06.740 --> 00:19:08.320
Maybe they're coming from a different language,


00:19:08.320 --> 00:19:10.280
maybe from TypeScript to Python.


00:19:10.280 --> 00:19:13.860
The more you rely on clever tricks or poor naming


00:19:13.860 --> 00:19:16.180
or just the wrong patterns,


00:19:16.180 --> 00:19:17.500
you're throwing people off their feet


00:19:17.500 --> 00:19:20.140
and they need, there's an added cognitive burden


00:19:20.140 --> 00:19:23.940
that they must then carry to understand what you've written.


00:19:23.940 --> 00:19:25.440
- Right, one of the beautiful things


00:19:25.440 --> 00:19:28.140
about different abstractions are, here's a function.


00:19:28.140 --> 00:19:31.300
I read the function name, that's all I need to know.


00:19:31.300 --> 00:19:34.140
Here's a class, I understand what the class does.


00:19:34.140 --> 00:19:37.260
I don't need to go and look into the details.


00:19:37.260 --> 00:19:40.860
And it lets you build these more larger building blocks


00:19:40.860 --> 00:19:42.560
of conceptual models.


00:19:42.560 --> 00:19:43.980
But if that's not true, right?


00:19:43.980 --> 00:19:45.660
Like if a getter is a setter,


00:19:45.660 --> 00:19:47.120
well then all of a sudden those things


00:19:47.120 --> 00:19:49.900
are all out the window and that's bad.


00:19:49.900 --> 00:19:54.540
Yeah, I mean, we work by building mental models, and you need trust to build those mental models.


00:19:54.540 --> 00:20:00.620
And as soon as that trust is violated, you it just starts taking time to do everyday tasks.


00:20:00.620 --> 00:20:05.900
You say I want to implement a single API endpoint. Well, if I have to go dig through 10 different


00:20:05.900 --> 00:20:11.180
files, just to make sure I'm doing everything right, that's going to slow me down. And if I


00:20:11.180 --> 00:20:15.340
can trust that my mental model is correct, and it's been shown to be correct time and time again,


00:20:15.980 --> 00:20:20.300
I can put more faith in that code and I can feel safer to start changing that code.


00:20:20.300 --> 00:20:22.300
Yeah, for sure.


00:20:22.300 --> 00:20:32.140
Another thing that I really liked about some of your ideas was that you talked about people having good intentions,


00:20:32.140 --> 00:20:37.740
even if they write bad code, like they're trying their best and they're, for the most part, I mean, there might be people who are just


00:20:37.740 --> 00:20:43.820
lazy or whatever, but for the most part, like they tried to write this well, even if it came out bad, they probably tried to write it well.


00:20:43.820 --> 00:20:45.820
And it just didn't turn out.


00:20:45.820 --> 00:20:47.820
as good as they hoped.


00:20:47.820 --> 00:20:49.820
Or even they wrote it well


00:20:49.820 --> 00:20:51.820
and it's just changed over time and those


00:20:51.820 --> 00:20:53.820
original assumptions got lost.


00:20:53.820 --> 00:20:55.820
It made sense in the early days


00:20:55.820 --> 00:20:57.820
and the assumptions or the context changed


00:20:57.820 --> 00:20:59.820
and now it's no longer accurate.


00:20:59.820 --> 00:21:01.820
Or it's inflexible


00:21:01.820 --> 00:21:03.820
and it's really hard to use to extend to your current


00:21:03.820 --> 00:21:05.820
use case. I see that all the time.


00:21:05.820 --> 00:21:07.820
Yeah.


00:21:07.820 --> 00:21:11.820
One of the ideas that I thought was


00:21:11.820 --> 00:21:13.820
interesting is this idea of legacy


00:21:13.820 --> 00:21:15.860
And I've always been kind of fascinated with


00:21:15.860 --> 00:21:17.660
what does legacy code mean?


00:21:17.660 --> 00:21:18.500
- Yeah.


00:21:18.500 --> 00:21:21.380
- Because legacy code for one person could be COBOL.


00:21:21.380 --> 00:21:27.480
Legacy code for another person could be Python 2.6.


00:21:27.480 --> 00:21:28.700
That's pretty old.


00:21:28.700 --> 00:21:31.420
It could even just be Python 3.6


00:21:31.420 --> 00:21:34.080
that's been around for a while, right?


00:21:34.080 --> 00:21:36.220
And there's different people who have different definitions.


00:21:36.220 --> 00:21:37.900
Michael Feathers has a cool book called


00:21:37.900 --> 00:21:38.940
"Working Effectively"


00:21:38.940 --> 00:21:40.580
or "Effectively Working With Legacy Code,"


00:21:40.580 --> 00:21:41.420
something like that.


00:21:41.420 --> 00:21:42.860
That's an interesting book.


00:21:42.860 --> 00:21:45.560
I believe it comes from maybe a slightly different time,


00:21:45.560 --> 00:21:47.620
but still some of the ideas will make you think.


00:21:47.620 --> 00:21:49.060
- And I was gonna quote that book actually,


00:21:49.060 --> 00:21:51.140
'cause his is a legacy code base


00:21:51.140 --> 00:21:53.860
is a code base that doesn't have tests.


00:21:53.860 --> 00:21:56.460
And I used to think that for a long time.


00:21:56.460 --> 00:21:58.620
And I love tests,


00:21:58.620 --> 00:22:01.800
but I've come to evolve my understanding of legacy code.


00:22:01.800 --> 00:22:04.540
And here's where the definition I've settled on.


00:22:04.540 --> 00:22:07.420
Legacy code, a legacy code base is a code base


00:22:07.420 --> 00:22:08.900
in which you can no longer communicate


00:22:08.900 --> 00:22:11.380
to the original authors or maintainers.


00:22:11.380 --> 00:22:14.180
So the length of time doesn't matter as much.


00:22:14.180 --> 00:22:17.500
If you've lost contact from the original authors,


00:22:17.500 --> 00:22:19.060
all you have is the code base


00:22:19.060 --> 00:22:20.560
and the surrounding documentation


00:22:20.560 --> 00:22:22.900
to understand why it's doing it as it does.


00:22:22.900 --> 00:22:26.940
So that's become my favorite definition for legacy code.


00:22:26.940 --> 00:22:27.940
- Yeah, I like that one too.


00:22:27.940 --> 00:22:29.820
I don't really like the test one.


00:22:29.820 --> 00:22:32.280
I see where it comes from,


00:22:32.280 --> 00:22:37.280
but I feel like it's judging a world


00:22:37.280 --> 00:22:40.900
from like too strict of a place, right?


00:22:40.900 --> 00:22:44.620
because not every piece of code is written


00:22:44.620 --> 00:22:48.340
in a way that it has to be absolutely correct.


00:22:48.340 --> 00:22:49.180
- Yeah.


00:22:49.180 --> 00:22:51.340
- Right, so I think this is also a good way


00:22:51.340 --> 00:22:54.120
to sort of scope this conversation


00:22:54.120 --> 00:22:55.660
because a lot of times people hear,


00:22:55.660 --> 00:22:59.700
oh, I have to use protocols and I have to use mypy


00:22:59.700 --> 00:23:01.460
and I have to use x, y, and z


00:23:01.460 --> 00:23:03.500
and I have to do all these fancy things


00:23:03.500 --> 00:23:07.140
'cause Pat and Michael said so 'cause they were awesome.


00:23:07.140 --> 00:23:08.540
And it's a big hassle.


00:23:08.540 --> 00:23:09.520
I don't think I need it,


00:23:09.520 --> 00:23:12.560
but here I'm trying to be a good software developer, right?


00:23:12.560 --> 00:23:14.460
So I'll give you an example.


00:23:14.460 --> 00:23:16.680
Years ago, I switched all the talk Python stuff,


00:23:16.680 --> 00:23:18.880
especially the Talk Python Training stuff


00:23:18.880 --> 00:23:21.800
from relational databases and SQLAlchemy


00:23:21.800 --> 00:23:24.640
over to MongoDB and Mongo engine.


00:23:24.640 --> 00:23:27.220
And so I had to write a whole ton of code


00:23:27.220 --> 00:23:29.320
that would take a couple of tables


00:23:29.320 --> 00:23:30.880
and then put them into a structure


00:23:30.880 --> 00:23:32.020
and then put them in Mongo.


00:23:32.020 --> 00:23:34.400
And that was all fine and good.


00:23:34.400 --> 00:23:37.680
But here's the thing, the moment that code ran successfully,


00:23:37.680 --> 00:23:40.160
I never wanted to run it again.


00:23:40.160 --> 00:23:41.160
It only had to run once.


00:23:41.160 --> 00:23:42.640
It had to move the data one time.


00:23:42.640 --> 00:23:44.240
When it was done, it was,


00:23:44.240 --> 00:23:47.480
there was no scenario where I cared about its typing


00:23:47.480 --> 00:23:48.960
or I cared about its continuous integrate.


00:23:48.960 --> 00:23:50.440
It was, I could have deleted it.


00:23:50.440 --> 00:23:52.320
I just kept it because, hey, source control.


00:23:52.320 --> 00:23:55.320
But, you know, like there's these scenarios, right?


00:23:55.320 --> 00:23:57.740
On the other hand, you talk about like,


00:23:57.740 --> 00:24:03.280
if you're an online, you know, reservation system,


00:24:03.280 --> 00:24:05.160
like the reservation booking engine,


00:24:05.160 --> 00:24:08.080
that part needs an entirely different bit of attention


00:24:08.080 --> 00:24:10.720
and mindset than my little migration script, right?


00:24:10.720 --> 00:24:13.360
- Yeah, and what I see is


00:24:13.360 --> 00:24:14.960
what value are the things delivering?


00:24:14.960 --> 00:24:17.860
Some things have one-off value and that's perfectly okay.


00:24:17.860 --> 00:24:20.880
You know, your migration script, it's served its value,


00:24:20.880 --> 00:24:24.680
but there won't be much value derived from it in the future.


00:24:24.680 --> 00:24:26.640
Maybe from an archeology standpoint,


00:24:26.640 --> 00:24:28.120
how did I go do this?


00:24:28.120 --> 00:24:28.960
- Yes, exactly, maybe.


00:24:28.960 --> 00:24:31.360
- But it's served its purpose.


00:24:31.360 --> 00:24:33.480
With something that's core to a business,


00:24:33.480 --> 00:24:38.280
a reservation booking engine, it delivers value when you've built it, but you want it


00:24:38.280 --> 00:24:41.760
to keep delivering value throughout its lifetime.


00:24:41.760 --> 00:24:45.560
And furthermore, the people who are working on it want to deliver value just as fast as


00:24:45.560 --> 00:24:46.560
you did in the beginning.


00:24:46.560 --> 00:24:50.200
So you don't want to slow down the future.


00:24:50.200 --> 00:24:54.080
You start getting into where you get product managers saying, "Why is this taking so long?


00:24:54.080 --> 00:24:56.400
This is super easy.


00:24:56.400 --> 00:24:59.240
Why do you have to spend three weeks just adding this one little field?"


00:24:59.240 --> 00:25:05.160
And the answer is often, "Oh, you know, we didn't think about how to enable value faster


00:25:05.160 --> 00:25:06.720
when we built it."


00:25:06.720 --> 00:25:10.120
And there's a tricky line there because you can't just gold plate everything and say,


00:25:10.120 --> 00:25:12.560
"I'm going to make everything super flexible."


00:25:12.560 --> 00:25:13.920
That often has the reverse effect.


00:25:13.920 --> 00:25:17.800
It makes things too flexible and that becomes unmaintainable.


00:25:17.800 --> 00:25:21.480
But there's a fine line between saying, "Okay, I'm going to think for the future and deliver


00:25:21.480 --> 00:25:22.480
value now."


00:25:22.480 --> 00:25:28.560
- Yeah, if every dependency can be replaced and everything can be configured from a file,


00:25:28.560 --> 00:25:32.480
settings file and like you never, you know, eventually that becomes a nightmare.


00:25:32.480 --> 00:25:33.320
It sounds cool.


00:25:33.320 --> 00:25:34.040
It's not cool.


00:25:34.040 --> 00:25:35.360
I've watched on some of those.


00:25:35.360 --> 00:25:35.680
Yeah.


00:25:35.680 --> 00:25:36.880
It's just painful.


00:25:36.880 --> 00:25:40.520
And so here's the advice I give to people who want to think about how to make


00:25:40.520 --> 00:25:41.880
their code base more maintainable.


00:25:41.880 --> 00:25:45.240
Target your moneymakers, the things that produce value, because those are the


00:25:45.240 --> 00:25:50.000
things you want to protect and whatever value means to you target things with


00:25:50.000 --> 00:25:50.680
high churn.


00:25:50.680 --> 00:25:52.800
So you can look in your get history.


00:25:52.800 --> 00:25:56.200
You can see what files change the most chances are those are the files that are


00:25:56.200 --> 00:25:57.160
being read the most.


00:25:57.200 --> 00:25:59.740
They're the files that people are working in the most.


00:25:59.740 --> 00:26:02.940
Putting more safeguards in those files,


00:26:02.940 --> 00:26:04.400
making them more extensible,


00:26:04.400 --> 00:26:07.760
will pay off just because more people are using them.


00:26:07.760 --> 00:26:11.160
Look for areas where you do large swaths of changes.


00:26:11.160 --> 00:26:12.980
It's called shotgun surgery,


00:26:12.980 --> 00:26:14.560
where if you want to add a single thing,


00:26:14.560 --> 00:26:16.280
you have to touch 20 files.


00:26:16.280 --> 00:26:18.580
The same 20 files keep getting changed


00:26:18.580 --> 00:26:20.400
again and again in a grouping.


00:26:20.400 --> 00:26:21.720
That tells you that, you know,


00:26:21.720 --> 00:26:23.360
if I were someone coming in new to the project,


00:26:23.360 --> 00:26:26.920
how do I know it's 20 and not 19 or 21?


00:26:26.920 --> 00:26:29.620
- Yeah, those are the things that are super easy


00:26:29.620 --> 00:26:31.240
to forget a case.


00:26:31.240 --> 00:26:32.080
- Oh yeah.


00:26:32.080 --> 00:26:33.340
- Like, oh, we added this feature


00:26:33.340 --> 00:26:35.780
and every if statement had an else if


00:26:35.780 --> 00:26:37.700
that covered the new thing,


00:26:37.700 --> 00:26:40.300
except for that one where we did the auditing


00:26:40.300 --> 00:26:41.780
or except for that one where we checked


00:26:41.780 --> 00:26:43.220
if they were an admin.


00:26:43.220 --> 00:26:44.380
Oh, that one.


00:26:44.380 --> 00:26:46.060
Now everyone's an admin, whoops.


00:26:46.060 --> 00:26:47.700
- Yep, and so that's the sort of places


00:26:47.700 --> 00:26:48.980
where I think type hinting is


00:26:48.980 --> 00:26:51.940
and other strategies are just super useful


00:26:51.940 --> 00:26:53.660
because you can start encoding that,


00:26:53.660 --> 00:26:56.500
those ideas of, I want to catch this


00:26:56.500 --> 00:26:59.800
when I miss a case, you can start encoding that


00:26:59.800 --> 00:27:03.460
into your checks, into linters, into type checkers,


00:27:03.460 --> 00:27:05.260
static analysis, and so on and so forth,


00:27:05.260 --> 00:27:06.540
which I think is important.


00:27:06.540 --> 00:27:08.060
- Yeah, absolutely.


00:27:08.060 --> 00:27:12.300
So I think people are pretty familiar


00:27:12.300 --> 00:27:15.140
with the typing system these days.


00:27:15.140 --> 00:27:16.220
I think it's really cool.


00:27:16.220 --> 00:27:19.820
The new type system is coming along with more things


00:27:19.820 --> 00:27:24.820
like 3.9 now lets you write lowercase set bracket integers


00:27:25.180 --> 00:27:28.540
or whatever, rather than from typing import capital set,


00:27:28.540 --> 00:27:30.740
and then you can say it in parallel, right?


00:27:30.740 --> 00:27:31.580
That's really nice.


00:27:31.580 --> 00:27:34.540
With the pipe union definition,


00:27:34.540 --> 00:27:38.880
you can do like none pipe a thing instead of optional.


00:27:38.880 --> 00:27:39.860
- Yeah.


00:27:39.860 --> 00:27:42.420
- All of those are really nice and so on.


00:27:42.420 --> 00:27:45.220
I suspect that a lot of people are using types


00:27:45.220 --> 00:27:49.320
for their editor, but are not going any further than that


00:27:49.320 --> 00:27:52.580
with anything like mypy or continuous integration


00:27:52.580 --> 00:27:53.420
or any of those.


00:27:53.420 --> 00:27:56.540
Do you want to maybe speak to like the use case of both of those?


00:27:56.540 --> 00:28:00.620
Yeah, so the use of editors alone is valuable.


00:28:00.620 --> 00:28:02.020
You get autocomplete.


00:28:02.020 --> 00:28:04.740
I mean, it gets squiggly if you do it wrong.


00:28:04.740 --> 00:28:06.340
Yeah, I mean, that's right.


00:28:06.340 --> 00:28:08.340
Autocomplete alone is so good.


00:28:08.340 --> 00:28:12.460
And I was just thinking when you were talking about that getter that was actually a setter,


00:28:12.460 --> 00:28:17.340
there's a really good chance that whoever wrote that code knew that was bad.


00:28:18.260 --> 00:28:24.680
And yet their tooling was such that it was so error prone for them to change the name


00:28:24.680 --> 00:28:28.920
that they were willing to live with a getter that changed values.


00:28:28.920 --> 00:28:34.520
Because they're like, I could break so much stuff in ways I don't understand


00:28:34.520 --> 00:28:39.080
if I don't have a proper set of tools, like a proper editor that'll do


00:28:39.080 --> 00:28:43.480
multi-file refactoring and continuous integration and all of those things, right?


00:28:43.480 --> 00:28:48.360
And so this is sort of like in that vein of your tools now do more for you.


00:28:48.360 --> 00:28:52.360
Yeah, and so if you take a look at how costly errors are,


00:28:52.360 --> 00:28:58.800
an error at the customer is incredibly costly when you factor in support and testing and


00:28:58.800 --> 00:29:02.280
field engineering, whatever you need to resolve that customer context,


00:29:02.280 --> 00:29:04.280
not to mention loss of customer faith.


00:29:04.280 --> 00:29:09.400
But it's expensive for tests in the later stages of QA


00:29:09.400 --> 00:29:14.300
to catch an error too, because now our development hasn't been planning to go fix this test


00:29:14.300 --> 00:29:20.140
or this code, we have to stop what we're doing and go back and fix this test that maybe worked on three weeks ago.


00:29:20.140 --> 00:29:23.080
The best time to catch an error is immediately after you write it.


00:29:23.080 --> 00:29:25.760
And that's where that tooling comes in with your editors.


00:29:25.760 --> 00:29:28.920
As you're typing, if you can find an error, great.


00:29:28.920 --> 00:29:31.720
You is the least amount of cost you could have spent.


00:29:31.720 --> 00:29:38.600
And then the second least amount, in my opinion, is letting some sort of stack analysis tool catch it, something like mypy.


00:29:38.600 --> 00:29:40.920
So using types, you can say,


00:29:40.920 --> 00:29:44.640
"I want to encode some assumptions into my code base.


00:29:44.640 --> 00:29:46.640
This value will never be none.


00:29:46.640 --> 00:29:48.320
This value may be none.


00:29:48.320 --> 00:29:51.880
This value will be an enter string or this string."


00:29:51.880 --> 00:29:53.440
- If you're right that it's never none,


00:29:53.440 --> 00:29:55.440
you never have to check it for none.


00:29:55.440 --> 00:29:56.760
- Right. - But if you're wrong,


00:29:56.760 --> 00:29:58.640
you always have to check it for none, right?


00:29:58.640 --> 00:29:59.720
Which is it?


00:29:59.720 --> 00:30:01.880
- Yeah, we don't want to do defensive programming


00:30:01.880 --> 00:30:05.080
of checking is none on every single variable we create


00:30:05.080 --> 00:30:06.320
in every function and location.


00:30:06.320 --> 00:30:09.760
application, that would just, it wouldn't be fun.


00:30:09.760 --> 00:30:12.720
But your alternative, if you don't have that tooling is,


00:30:12.720 --> 00:30:14.520
"All right, does this function return none?


00:30:14.520 --> 00:30:16.360
Let me go look at its source code.


00:30:16.360 --> 00:30:17.920
Oh, it calls five other functions.


00:30:17.920 --> 00:30:19.480
Let me go look at their source code.


00:30:19.480 --> 00:30:21.360
Oh, this calls something to the database.


00:30:21.360 --> 00:30:22.920
Is that a nullable field?"


00:30:22.920 --> 00:30:27.800
Anytime you're making someone trawl through your code base to try to answer


00:30:27.800 --> 00:30:30.400
a question of, "Can this value be none?"


00:30:30.400 --> 00:30:33.880
You're wasting their time, and they're either going to delay


00:30:35.040 --> 00:30:39.440
features that just adds up over time, or they're going to make some incorrect assumptions,


00:30:39.440 --> 00:30:42.560
and that's going to cause mistakes, which will lead to time and waste of money.


00:30:42.560 --> 00:30:49.040
Yeah. You've already talked about focusing your attention to put things like type annotations


00:30:49.040 --> 00:30:52.400
on the parts that matter and not necessarily stress about the parts that don't, especially


00:30:52.400 --> 00:30:58.000
for code that's being retrofitted. But even code, I think that's not right. Like the thing that logs,


00:30:58.000 --> 00:31:01.440
you know, it's going to turn whatever to a string, and if it comes out as like,


00:31:01.440 --> 00:31:07.040
you know, some object at some address, like we'll catch it later and figure it out. But it's the core thing that you want


00:31:07.040 --> 00:31:12.320
that stuff to be right. But one of the things that can be challenging is


00:31:12.320 --> 00:31:14.800
the


00:31:14.800 --> 00:31:17.680
interest and the buy-in and the love for this idea


00:31:17.680 --> 00:31:20.320
might not be uniform across your team.


00:31:20.320 --> 00:31:26.560
No, no, you know, and I've seen the same thing for testing and I've seen the same thing for continuous integration.


00:31:26.560 --> 00:31:30.720
Not necessarily the same person in the same thing, but you know, it's like


00:31:30.720 --> 00:31:33.920
if there's a person on your team that just doesn't care


00:31:33.920 --> 00:31:35.320
about the continuous integration


00:31:35.320 --> 00:31:37.320
and turns off all the notifications


00:31:37.320 --> 00:31:39.520
that the continuous integration fails,


00:31:39.520 --> 00:31:42.800
and then they keep checking in stuff and failing the build,


00:31:42.800 --> 00:31:45.480
you're like, not again, I gotta go fix this


00:31:45.480 --> 00:31:48.080
'cause this person doesn't bother to check their thing.


00:31:48.080 --> 00:31:49.560
It just gets super frustrated.


00:31:49.560 --> 00:31:51.080
And I feel like probably typing


00:31:51.080 --> 00:31:53.000
has a similar analogy to that.


00:31:53.000 --> 00:31:53.840
- It does.


00:31:53.840 --> 00:31:56.200
And that's why if you're in a legacy code base


00:31:56.200 --> 00:31:59.160
or even a maintained code base


00:31:59.160 --> 00:32:01.880
that doesn't have a whole lot of typing in it.


00:32:01.880 --> 00:32:03.000
There's some alternatives you can have


00:32:03.000 --> 00:32:05.520
just beyond being strategic where you pick.


00:32:05.520 --> 00:32:08.200
There's some fantastic tooling like monkey type,


00:32:08.200 --> 00:32:11.400
which can annotate your code base for you.


00:32:11.400 --> 00:32:13.800
There's Google's type checker, PyType.


00:32:13.800 --> 00:32:16.120
It can do type checking without type annotations.


00:32:16.120 --> 00:32:18.460
And it does it with a little bit different philosophy


00:32:18.460 --> 00:32:20.640
than mypy, which I think is kind of cool.


00:32:20.640 --> 00:32:23.920
It tries to infer based on just the values


00:32:23.920 --> 00:32:25.160
throughout your function bodies,


00:32:25.160 --> 00:32:28.480
what the types should be without type annotations.


00:32:28.480 --> 00:32:31.520
So there might be ways to get the benefits


00:32:31.520 --> 00:32:34.800
without actually making the full commitment


00:32:34.800 --> 00:32:38.680
to those type checkers for just type annotations in general.


00:32:38.680 --> 00:32:42.560
There's also, I mean, tie real world value to it.


00:32:42.560 --> 00:32:43.840
Look through your bug reports.


00:32:43.840 --> 00:32:46.100
If you find out that, hey, you know,


00:32:46.100 --> 00:32:51.100
we've had 12 dereferences of none in the past month.


00:32:51.100 --> 00:32:57.680
- And it's cost us X amount of dollars


00:32:57.680 --> 00:33:03.400
dollars, I can now go to someone and say, look, this is costing us real money and our


00:33:03.400 --> 00:33:10.000
time. Sometimes data speaks volumes. If you're having a tough time convincing people, I often


00:33:10.000 --> 00:33:13.880
say, find the data to back it up. Look through your bug reports and find out what would we


00:33:13.880 --> 00:33:21.200
have caught? How much faster could we go? Do an informal survey around your developer


00:33:21.200 --> 00:33:27.120
base. How much more confident do you feel working in your code? And use that data to


00:33:27.120 --> 00:33:29.680
to decide yes, this is working or no,


00:33:29.680 --> 00:33:31.960
we need to look at alternative strategies.


00:33:31.960 --> 00:33:34.120
- How much autocomplete do you get?


00:33:34.120 --> 00:33:34.960
- Yeah.


00:33:34.960 --> 00:33:36.160
- I mean, that might be a winner, right?


00:33:36.160 --> 00:33:37.640
I would for me actually.


00:33:37.640 --> 00:33:38.560
- Yeah.


00:33:38.560 --> 00:33:39.560
- Yeah, absolutely.


00:33:39.560 --> 00:33:42.100
So I do wanna move on to some other ideas


00:33:42.100 --> 00:33:43.480
because it's not all about typing,


00:33:43.480 --> 00:33:47.920
but I think typing unlocks a lot of these


00:33:47.920 --> 00:33:52.640
sort of durability ideas that you're covering there.


00:33:52.640 --> 00:33:55.800
So another one that you talked a lot about,


00:33:55.800 --> 00:33:57.940
I think is really interesting in this context


00:33:57.940 --> 00:34:02.940
has to do with collection types


00:34:02.940 --> 00:34:04.940
and knowing the right data type.


00:34:04.940 --> 00:34:05.780
- Yes.


00:34:05.780 --> 00:34:08.420
- And that matters so much, right?


00:34:08.420 --> 00:34:10.420
Like somebody might use a dictionary


00:34:10.420 --> 00:34:13.180
where they should have used a set or something.


00:34:13.180 --> 00:34:14.860
And you're like, well, you used a dictionary.


00:34:14.860 --> 00:34:16.300
So you mean me to look this up by value?


00:34:16.300 --> 00:34:19.020
Like, no, no, I just want to have one of everything.


00:34:19.020 --> 00:34:21.700
Okay, but why did we use the dictionary?


00:34:21.700 --> 00:34:22.980
But people, when they're new,


00:34:22.980 --> 00:34:23.940
they don't necessarily know that.


00:34:23.940 --> 00:34:25.580
They find the first thing that works.


00:34:25.580 --> 00:34:26.820
like, oh, a dictionary worked for this.


00:34:26.820 --> 00:34:27.660
We're using dictionaries.


00:34:27.660 --> 00:34:30.280
But beyond that, it means something


00:34:30.280 --> 00:34:33.160
for certain container types and other things, right?


00:34:33.160 --> 00:34:35.440
- And I think if you look at the Zen of Python,


00:34:35.440 --> 00:34:37.020
there should only be one way to do it.


00:34:37.020 --> 00:34:39.340
Most people say, but there's multiple ways to do that.


00:34:39.340 --> 00:34:41.620
Like I can use a dictionary, I can use a set,


00:34:41.620 --> 00:34:45.180
I can use a list and just search for unique values.


00:34:45.180 --> 00:34:47.460
- Encode it in a string and you can parse it every time.


00:34:47.460 --> 00:34:48.820
- Yeah.


00:34:48.820 --> 00:34:51.580
The choices you make, the abstractions you choose,


00:34:51.580 --> 00:34:53.820
communicate a certain intent.


00:34:53.820 --> 00:34:57.360
When you choose to use a set, that tells me I can iterate over it.


00:34:57.360 --> 00:34:59.360
There won't be any duplicates.


00:34:59.360 --> 00:35:05.160
And I won't be looking things up by key.


00:35:05.160 --> 00:35:08.240
When I think of a dictionary, I think of a mapping from key to value.


00:35:08.240 --> 00:35:09.960
The keys must be unique.


00:35:09.960 --> 00:35:12.620
But if all I care about is the keys and no values,


00:35:12.620 --> 00:35:15.740
like there's added cognitive dissonance of,


00:35:15.740 --> 00:35:17.620
"Why do I have values for this dictionary?"


00:35:17.620 --> 00:35:19.280
They're all secrets. It doesn't make sense.


00:35:19.280 --> 00:35:22.660
Yeah, it goes back to the principle of Lisa Stachman.


00:35:22.660 --> 00:35:26.820
You get surprised like, oh, this dictionary is being used as a set.


00:35:26.820 --> 00:35:28.820
I get it now.


00:35:28.820 --> 00:35:32.620
And if you're not addressing that as you find it, you're just kicking the can onto a future


00:35:32.620 --> 00:35:36.580
maintainer who then has to add that to the 20 other things he's trying to keep track


00:35:36.580 --> 00:35:45.900
of throughout their maintenance of the program.


00:35:45.900 --> 00:35:49.940
You mentioned that one of my big pet peeves is -- so a dictionary, I say, is a mapping


00:35:49.940 --> 00:35:50.940
from key to value.


00:35:50.940 --> 00:35:53.220
That's typically a homogenous mapping.


00:35:53.220 --> 00:35:55.940
Every key is the same type and every value is the same type.


00:35:55.940 --> 00:36:00.860
But we really, really, really love dictionaries for things like JSON responses


00:36:00.860 --> 00:36:03.180
or relationships of data.


00:36:03.180 --> 00:36:07.100
And that can be so detrimental to maintainability of codebases


00:36:07.100 --> 00:36:08.460
if you're not careful.


00:36:08.460 --> 00:36:12.740
So the problem is, a type checker isn't the greatest at saying,


00:36:12.740 --> 00:36:14.660
"Oh, this is a dict.


00:36:14.660 --> 00:36:19.340
Some of the keys are strings, others are ints, others are decimals,


00:36:19.340 --> 00:36:21.740
and the values are all over the type.


00:36:21.740 --> 00:36:24.700
You can use a type stick to try to get around that.


00:36:24.700 --> 00:36:27.260
But really what you're talking about is a relationship of data.


00:36:27.260 --> 00:36:30.940
When you talk about dictionaries, you're getting into the,


00:36:30.940 --> 00:36:33.900
well, if I see, let's say I'm code reviewing,


00:36:33.900 --> 00:36:36.380
let me put this in concrete terms.


00:36:36.380 --> 00:36:37.820
I'm code reviewing some code,


00:36:37.820 --> 00:36:42.540
and I see someone accessing dictionary and the key is foo.


00:36:42.540 --> 00:36:47.500
I have to go look at all of where that dictionary was created and modified


00:36:47.500 --> 00:36:51.500
to make sure that foo is actually a valid field in that dictionary.


00:36:51.500 --> 00:36:55.500
I have no guarantees just if I see dict in a type checker,


00:36:55.500 --> 00:36:57.500
I'm sorry, a type annotation.


00:36:57.500 --> 00:36:59.500
So again, it's that trawling through the code base,


00:36:59.500 --> 00:37:01.500
and oh, this is actually coming from an API,


00:37:01.500 --> 00:37:03.500
and now I have to go read the API,


00:37:03.500 --> 00:37:06.500
and I can't effectively code review code


00:37:06.500 --> 00:37:09.500
or maintain code if I'm just reading that through


00:37:09.500 --> 00:37:13.500
without doing that every time to make sure something hasn't changed.


00:37:13.500 --> 00:37:16.500
So in this case, I say use a data class.


00:37:16.500 --> 00:37:21.020
you have explicit fields, you can lean on your tooling.


00:37:21.020 --> 00:37:23.020
If you mess up the field,


00:37:23.020 --> 00:37:26.220
you aren't expecting to see new fields get created


00:37:26.220 --> 00:37:29.740
in probably 95, 99% of the time.


00:37:29.740 --> 00:37:32.980
Or, and I'm like, I will prefer a data class to a dictionary


00:37:32.980 --> 00:37:36.380
if I have heterogeneous data almost all the time.


00:37:36.380 --> 00:37:40.540
- Yeah, and maybe get it back like a Flask API call,


00:37:40.540 --> 00:37:43.420
just call JSON and then just jam that star star


00:37:43.420 --> 00:37:45.740
of that thing into the data class, something like that.


00:37:45.740 --> 00:37:48.000
- Yep, yep, and I know you've talked about


00:37:48.000 --> 00:37:49.980
Pydantic on the show a lot.


00:37:49.980 --> 00:37:53.400
I love Pydantic, just define a model,


00:37:53.400 --> 00:37:55.400
let it parse that JSON response


00:37:55.400 --> 00:37:57.780
and just build that data class for me.


00:37:57.780 --> 00:37:59.000
Throw an error if it's invalid.


00:37:59.000 --> 00:38:01.140
And I really like that model


00:38:01.140 --> 00:38:03.100
of attacking programs like that.


00:38:03.100 --> 00:38:06.500
- I love Pydantic.


00:38:06.500 --> 00:38:10.300
I love how it tries to sort of be flexible.


00:38:10.300 --> 00:38:12.580
It's like, if I think we can fix this,


00:38:12.580 --> 00:38:15.000
if you had a thing that is a string,


00:38:15.000 --> 00:38:17.760
but in the string, it really is parsable to a number.


00:38:17.760 --> 00:38:18.800
And it's supposed to be a number.


00:38:18.800 --> 00:38:22.160
I'll just go ahead and do that type conversion for you.


00:38:22.160 --> 00:38:23.960
If not, I'll give you a decent error message.


00:38:23.960 --> 00:38:26.000
It's really, really lovely.


00:38:26.000 --> 00:38:27.440
- Yeah, so if I'm working with APIs,


00:38:27.440 --> 00:38:29.880
I love Pydantic for that reason that you just outlined,


00:38:29.880 --> 00:38:32.320
but I'll often convert it to a data class


00:38:32.320 --> 00:38:35.200
or a Pydantic data class so that I can say,


00:38:35.200 --> 00:38:36.480
this is a relationship of data,


00:38:36.480 --> 00:38:38.800
and I can kind of shape how a user uses


00:38:38.800 --> 00:38:40.200
that relationship of data


00:38:40.200 --> 00:38:42.120
throughout the lifetime of the code.


00:38:42.120 --> 00:38:42.960
- Right.


00:38:44.120 --> 00:38:46.060
- Yeah, it's an interesting tension


00:38:46.060 --> 00:38:48.920
on how much those models get used


00:38:48.920 --> 00:38:50.600
throughout all the tiers of your app


00:38:50.600 --> 00:38:52.480
and how much you wanna keep them separate.


00:38:52.480 --> 00:38:55.760
Have you seen SQL model, I believe it's called?


00:38:55.760 --> 00:38:57.280
I just came out. - Oh, I have not.


00:38:57.280 --> 00:38:59.920
I have not. - Okay, here we go.


00:38:59.920 --> 00:39:01.720
You probably heard of FastAPI, right?


00:39:01.720 --> 00:39:02.560
- Yeah, of course. - Obviously,


00:39:02.560 --> 00:39:05.960
that's where Pydantic got, I think it's a big boost.


00:39:05.960 --> 00:39:09.300
So Sebastian Ramirez came out a few days ago


00:39:09.300 --> 00:39:12.080
with this thing called SQL model.


00:39:13.240 --> 00:39:15.160
And already, I think it's less than a week old,


00:39:15.160 --> 00:39:17.600
it has 4,000 GitHub stars, which is amazing.


00:39:17.600 --> 00:39:21.200
But basically it's a merging of Pydantic and SQLAlchemy.


00:39:21.200 --> 00:39:22.280
- Oh, fantastic.


00:39:22.280 --> 00:39:26.160
- It has the SQLAlchemy unit of work model


00:39:26.160 --> 00:39:28.400
and it underline has all the SQLAlchemy stuff,


00:39:28.400 --> 00:39:31.680
but its models are actually Pydantic models.


00:39:31.680 --> 00:39:33.920
- Yeah, and I think this is just another illustration


00:39:33.920 --> 00:39:36.640
of why thinking about what types things are,


00:39:36.640 --> 00:39:38.360
even if you're not doing type annotations,


00:39:38.360 --> 00:39:39.600
why that's so important.


00:39:39.600 --> 00:39:42.360
It goes back to how do we build mental models?


00:39:42.360 --> 00:39:46.200
how do we build these abstractions in our brain


00:39:46.200 --> 00:39:49.000
that we can rely upon as we work through our code base?


00:39:49.000 --> 00:39:52.220
Yeah.


00:39:52.220 --> 00:39:55.780
I do think this is interesting in that you could use the same model


00:39:55.780 --> 00:39:57.920
at the data level, internal to your app,


00:39:57.920 --> 00:39:59.920
and then you could even use it at API level.


00:39:59.920 --> 00:40:03.840
But there's also people are saying, "But maybe that's not a good idea.


00:40:03.840 --> 00:40:07.320
Maybe you want to separate those in interesting ways


00:40:07.320 --> 00:40:10.440
for one can change and the other doesn't have to change."


00:40:11.000 --> 00:40:13.000
But yeah, I see a lot of value to this thing.


00:40:13.000 --> 00:40:15.000
It looks exciting.


00:40:15.000 --> 00:40:17.500
And the answer to that is going to probably be it depends.


00:40:17.500 --> 00:40:20.460
If your application needs them to be the same,


00:40:20.460 --> 00:40:22.460
law of least surprise, make them the same.


00:40:22.460 --> 00:40:24.460
If they have different reasons to change,


00:40:24.460 --> 00:40:26.460
this is something I see a lot too.


00:40:26.460 --> 00:40:28.460
We all get the dry principle,


00:40:28.460 --> 00:40:29.960
don't repeat yourself,


00:40:29.960 --> 00:40:31.960
ingrained in our head, and we think,


00:40:31.960 --> 00:40:34.960
"Oh, if source code looks the same, we must deduplicate it."


00:40:34.960 --> 00:40:37.960
But if that source code can change for different reasons,


00:40:37.960 --> 00:40:40.960
you're going to add more headaches by deduplicating it.


00:40:40.960 --> 00:40:42.560
because you're going to start adding special cases.


00:40:42.560 --> 00:40:44.300
Well, this thing needs to change,


00:40:44.300 --> 00:40:46.320
but the other thing doesn't.


00:40:46.320 --> 00:40:49.060
How do I reconcile that? Special cases.


00:40:49.060 --> 00:40:52.700
Soon you've become the very thing you've formed to destroy.


00:40:52.700 --> 00:40:55.760
As you build that out, it's just littered with


00:40:55.760 --> 00:40:57.960
special cases as you're trying to tie


00:40:57.960 --> 00:41:02.040
together two things that have two separate contexts.


00:41:02.040 --> 00:41:04.840
If you want to use something like SQL model for


00:41:04.840 --> 00:41:08.320
a API level and your internal data model,


00:41:08.320 --> 00:41:11.420
ask yourself, do these have different reasons for changing?


00:41:11.420 --> 00:41:17.000
Maybe in the future, and like, a lot of this is just empathy for the future.


00:41:17.000 --> 00:41:20.200
When I talk about maintainable code, robust code,


00:41:20.200 --> 00:41:23.800
you have to have empathy for those future maintainers, put yourself in their shoes.


00:41:23.800 --> 00:41:26.140
Are they going to want to migrate at some time?


00:41:26.140 --> 00:41:31.980
And maybe change the API that they present to customers or users or other developers.


00:41:31.980 --> 00:41:34.480
Do you want to change your database at the same time?


00:41:34.480 --> 00:41:37.280
If so, keep them together.


00:41:37.280 --> 00:41:40.580
if you want to keep that separate so that you have certain migration paths,


00:41:40.580 --> 00:41:44.080
maybe you keep them separate. And so it's going to depend case by case.


00:41:44.080 --> 00:41:47.840
But again, everything comes down to that those first principles of


00:41:47.840 --> 00:41:51.560
what are you communicating with your intent when you make that decision in your code?


00:41:51.560 --> 00:41:57.000
Yeah, well, and you're also like we've touched on, you're building different things at different times


00:41:57.000 --> 00:42:00.920
under different constraints. Are you building Instagram's API,


00:42:00.920 --> 00:42:03.560
which millions of people and apps are using?


00:42:03.560 --> 00:42:09.980
Or are you building something really quick so you can get that app to work for marketing for the next thing for the week?


00:42:09.980 --> 00:42:10.980
Right?


00:42:10.980 --> 00:42:11.480
Yeah.


00:42:11.480 --> 00:42:16.280
If it's that the second one, then you don't want to worry about too much abstraction.


00:42:16.280 --> 00:42:18.120
And you just want to go like, I just need these to be in sync.


00:42:18.120 --> 00:42:20.680
The data goes here, we're going to send over the API, we're going to be good, right?


00:42:20.680 --> 00:42:21.680
This is going to fly.


00:42:21.680 --> 00:42:26.760
On the other hand, if you're building something incredibly consumed and long lived,


00:42:26.760 --> 00:42:29.880
then maybe you have different design patterns and care about it.


00:42:29.880 --> 00:42:32.960
And I think it's important to think about organizational boundaries.


00:42:32.960 --> 00:42:37.960
is the users, the consumers, the actors in your use cases,


00:42:37.960 --> 00:42:41.480
is there an organizational boundary separating them?


00:42:41.480 --> 00:42:43.600
In the Instagram case,


00:42:43.600 --> 00:42:46.080
the people who are gonna be using my API,


00:42:46.080 --> 00:42:48.160
I have no control over in my organization,


00:42:48.160 --> 00:42:50.860
it's general public as far as I'm concerned.


00:42:50.860 --> 00:42:52.940
If it's just someone on my team using it,


00:42:52.940 --> 00:42:56.840
we can work through, okay, I'm changing this API,


00:42:56.840 --> 00:42:58.300
let me help you through that.


00:42:58.300 --> 00:42:59.800
But if it's someone outside your team


00:42:59.800 --> 00:43:01.680
or outside your organization,


00:43:01.680 --> 00:43:05.120
you're going to have a backwards compatibility to think about,


00:43:05.120 --> 00:43:09.440
you're going to have all these vast amount of things that people are going to complain about.


00:43:09.440 --> 00:43:12.920
And you need to think about that and say, okay, can I make these changes?


00:43:12.920 --> 00:43:14.920
And is it good for my user base?


00:43:14.920 --> 00:43:18.080
Even though I can't control them, the best I can do is entice them.


00:43:18.080 --> 00:43:21.440
But you'll never be able to force someone to use something they don't want to


00:43:21.440 --> 00:43:23.080
if you don't have that control over them.


00:43:23.080 --> 00:43:25.080
That's why we have open source forks.


00:43:25.080 --> 00:43:27.080
Yeah, absolutely.


00:43:28.480 --> 00:43:32.640
So one of the ideas that I think comes up in this whole story,


00:43:32.640 --> 00:43:35.600
and you talk a lot about like inheritance,


00:43:35.600 --> 00:43:38.720
both inheritance in terms of class hierarchies


00:43:38.720 --> 00:43:41.520
and even multiple inheritance, but also maybe


00:43:41.520 --> 00:43:45.280
the more traditional interface style with protocols,


00:43:45.280 --> 00:43:49.680
just so that you can express type stuff separately, right,


00:43:49.680 --> 00:43:54.120
in interesting ways without coming up with inheritance


00:43:54.120 --> 00:43:56.400
beasts and whatnot.


00:43:56.400 --> 00:44:00.320
So one thing I did want to give people a quick shout out.


00:44:00.320 --> 00:44:02.920
So we've all heard of solid principles, right?


00:44:02.920 --> 00:44:05.560
And I've, I really enjoyed the solid principles


00:44:05.560 --> 00:44:07.160
and I thought they were super interesting.


00:44:07.160 --> 00:44:08.540
I still do.


00:44:08.540 --> 00:44:10.560
I think they're pretty great.


00:44:10.560 --> 00:44:13.240
I recently came across a presentation


00:44:13.240 --> 00:44:17.920
and it was, I encountered over on Richard Campbell's show,


00:44:17.920 --> 00:44:20.860
.NET Rocks, which I know people probably don't care


00:44:20.860 --> 00:44:22.240
about .NET, but they actually talked


00:44:22.240 --> 00:44:23.520
about this thing called Cupid,


00:44:23.520 --> 00:44:26.200
which is an alternative to solid.


00:44:26.200 --> 00:44:27.400
I might have to go check that out.


00:44:27.400 --> 00:44:29.600
- And it was super, it has nothing to do with .NET.


00:44:29.600 --> 00:44:31.640
It's just like software in general, patterns.


00:44:31.640 --> 00:44:35.160
Like what do we know now, 20 years later,


00:44:35.160 --> 00:44:38.120
that doesn't necessarily make so much sense for Solid.


00:44:38.120 --> 00:44:39.600
And what is the alternative?


00:44:39.600 --> 00:44:40.700
And he has this really cute name.


00:44:40.700 --> 00:44:44.480
So as people are thinking about maybe those kind of levels,


00:44:44.480 --> 00:44:46.760
like that's a pretty interesting thing to check out.


00:44:46.760 --> 00:44:48.960
- Yeah, I like thinking of Solid,


00:44:48.960 --> 00:44:50.400
again, going back to first principles,


00:44:50.400 --> 00:44:53.560
there are things that I like about Solid.


00:44:53.560 --> 00:45:00.360
There are things I also think get a bad rep because they're associated with heavy, heavy


00:45:00.360 --> 00:45:05.760
OO code bases that have class hierarchies that are just unmanageable.


00:45:05.760 --> 00:45:08.520
Probably multiple templates in there somehow as well.


00:45:08.520 --> 00:45:09.520
Yeah.


00:45:09.520 --> 00:45:12.220
And we've kind of grouped these things together.


00:45:12.220 --> 00:45:16.420
So an example, like one of the most misunderstood ones in my opinion is the Lispkov substitution


00:45:16.420 --> 00:45:19.060
principle of the solid principles.


00:45:19.060 --> 00:45:23.220
And it applies when you're doing duck typing in Python, which has nothing to do with class


00:45:23.220 --> 00:45:27.220
hierarchies, it doesn't have anything to do with, you know, interfaces or things


00:45:27.220 --> 00:45:30.820
like that. It's a term about substitutability. And so when we talk


00:45:30.820 --> 00:45:35.220
about duck typing in Python, it's, well, multiple types can represent some


00:45:35.220 --> 00:45:40.300
behavior. Maybe they support an addition method and a subtraction method. Can they


00:45:40.300 --> 00:45:43.900
be substituted into this function that's expecting addition and subtraction?


00:45:43.900 --> 00:45:48.860
Right. When I do addition and subtraction on dates and times, another might do it


00:45:48.860 --> 00:45:52.460
on, like, imaginary numbers. But the concept of adding and subtracting things,


00:45:52.460 --> 00:45:54.260
- Yeah. - You can read that, right?


00:45:54.260 --> 00:45:55.100
Something like that.


00:45:55.100 --> 00:45:57.860
- Yeah, and so things like Liskov's Substitutability,


00:45:57.860 --> 00:46:00.820
excuse me, Liskov's Substitutability Principle


00:46:00.820 --> 00:46:03.420
starts with how do you think about substitutability


00:46:03.420 --> 00:46:06.020
from your requirements and from your behaviors?


00:46:06.020 --> 00:46:08.220
And you can get value from that


00:46:08.220 --> 00:46:09.660
without ever touching a class.


00:46:09.660 --> 00:46:12.940
So I think all too often we lump those solid principles


00:46:12.940 --> 00:46:16.860
to a strict OO of the 90s or the noughts


00:46:16.860 --> 00:46:19.660
and think that they aren't as useful.


00:46:19.660 --> 00:46:20.740
I'm gonna have to check out Cupid


00:46:20.740 --> 00:46:22.500
and see how that's changed as well.


00:46:22.500 --> 00:46:25.900
I would expect that a lot of the same first principles are true,


00:46:25.900 --> 00:46:30.140
but they've kind of reframed it in a way that is more applicable


00:46:30.140 --> 00:46:32.140
to how we program today.


00:46:32.140 --> 00:46:35.740
Yeah. I don't remember all the details exactly.


00:46:35.740 --> 00:46:39.220
So, but yeah, something roughly along those lines.


00:46:39.220 --> 00:46:40.860
I think that makes sense.


00:46:40.860 --> 00:46:43.780
So, one thing I do also want to just sort of get your thoughts on


00:46:43.780 --> 00:46:45.780
before we leave it completely in the dust.


00:46:45.780 --> 00:46:48.540
You talked about a lot of times you've got a dictionary


00:46:48.540 --> 00:46:50.540
and it's supposed to represent...


00:46:50.540 --> 00:46:55.180
some stuff, maybe it's a response from an API where it says,


00:46:55.180 --> 00:46:57.860
here was what you requested, here was the status code,


00:46:57.860 --> 00:47:00.980
here's what the cloud cost of that is, and here's like the...


00:47:00.980 --> 00:47:02.980
Something that looks like that,


00:47:02.980 --> 00:47:08.300
maybe doesn't make sense as a dictionary, maybe gets moved into like a Pydantic model


00:47:08.300 --> 00:47:09.660
or something like that.


00:47:09.660 --> 00:47:13.060
But the other one is, I have 10,000 users,


00:47:13.060 --> 00:47:15.300
and I want to put their email address as the key


00:47:15.300 --> 00:47:17.580
and their user object as the value.


00:47:17.580 --> 00:47:20.140
And given an email address, I want to know super fast


00:47:20.140 --> 00:47:22.640
which user is that or do I have that user at all?


00:47:22.640 --> 00:47:24.640
In that case, the dictionary makes a lot of sense.


00:47:24.640 --> 00:47:25.300
Absolutely.


00:47:25.300 --> 00:47:28.340
There's a super big difference to say the keys represent


00:47:28.340 --> 00:47:32.340
like the same thing across different results,


00:47:32.340 --> 00:47:35.560
whereas the same data structure,


00:47:35.560 --> 00:47:37.940
a dictionary represents this heterogeneous,


00:47:37.940 --> 00:47:41.260
like not really a class, but a class.


00:47:41.260 --> 00:47:45.420
How do you position those so that beginners understand that


00:47:45.420 --> 00:47:48.220
those are completely unrelated things


00:47:48.220 --> 00:47:49.580
that need to be thought about separately,


00:47:49.580 --> 00:47:51.580
but they kind of appear the same in code.


00:47:51.580 --> 00:47:53.580
Because when I'm talking to people about dictionaries


00:47:53.580 --> 00:47:54.860
and I'm teaching, they're like,


00:47:54.860 --> 00:47:56.860
"Oh, well, why would you use a dictionary here?


00:47:56.860 --> 00:47:58.860
Because over here you were doing it this other way,


00:47:58.860 --> 00:48:00.860
but now it's like a database. Like, what are you doing with it?


00:48:00.860 --> 00:48:03.420
This is weird. Why are these not... Why are they the same but different?"


00:48:03.420 --> 00:48:05.420
So here's how I explain it.


00:48:05.420 --> 00:48:07.900
So for the key mapping value,


00:48:07.900 --> 00:48:11.260
I would say there's a few use cases you're going to have.


00:48:11.260 --> 00:48:13.740
You're going to either be iterating over the dictionary


00:48:13.740 --> 00:48:15.740
to do something on every element,


00:48:15.740 --> 00:48:18.620
or you're going to be looking up a specific element


00:48:18.620 --> 00:48:23.260
And that element that lookup is dynamic, you're typically passing in some value.


00:48:23.260 --> 00:48:27.660
Maybe it's a variable that contains the email address in your example.


00:48:27.660 --> 00:48:31.460
For something like an API response, something that might be more heterogeneous,


00:48:31.460 --> 00:48:35.420
something that should be a data class or Pydantic model, what have you,


00:48:35.420 --> 00:48:38.420
you typically aren't iterating over every key.


00:48:38.420 --> 00:48:41.100
You're looking up specific keys,


00:48:41.100 --> 00:48:46.660
but you're statically indexed, meaning you're passing in string literals between the square brackets.


00:48:46.660 --> 00:48:49.140
This is the key I want in this circumstance,


00:48:49.140 --> 00:48:53.380
the name, the age, the date of birth.


00:48:53.380 --> 00:48:56.780
So you're looking at specific fields and you're building


00:48:56.780 --> 00:49:00.080
a relationship between different key-value pairs.


00:49:00.080 --> 00:49:03.580
A name, age, and date of birth is a relationship called person.


00:49:03.580 --> 00:49:05.460
With your dictionary,


00:49:05.460 --> 00:49:07.340
you're doing or with your mapping,


00:49:07.340 --> 00:49:08.540
your key-value mapping,


00:49:08.540 --> 00:49:10.440
there's no relationship between


00:49:10.440 --> 00:49:13.700
email one to user object one and email two to user object two.


00:49:13.700 --> 00:49:15.900
The relationship is just from key to value.


00:49:15.900 --> 00:49:19.220
And that's typically what I explain to people trying to discern the difference.


00:49:19.220 --> 00:49:21.180
That's a really interesting way to think about it.


00:49:21.180 --> 00:49:25.980
Cause yeah, you will almost always use static literal strings when it's the


00:49:25.980 --> 00:49:27.940
heterogeneous API response style.


00:49:27.940 --> 00:49:30.220
And you will almost never do that.


00:49:30.220 --> 00:49:33.700
Like, why would you say quote, type in the email address?


00:49:33.700 --> 00:49:35.820
You would just have that object.


00:49:35.820 --> 00:49:39.460
You wouldn't need to type in, like you would just never create that structure in


00:49:39.460 --> 00:49:41.980
the first place, which I think is a really interesting.


00:49:41.980 --> 00:49:45.340
So yeah, if you're dynamically passing in the keys,


00:49:45.340 --> 00:49:48.020
it's probably all the same object,


00:49:48.020 --> 00:49:50.820
but different ones of them as opposed to an API response.


00:49:50.820 --> 00:49:53.340
- And I think that's the heart of why I really wanted


00:49:53.340 --> 00:49:54.940
to write about robust Python.


00:49:54.940 --> 00:49:57.620
So I've been programming for a while now,


00:49:57.620 --> 00:50:00.220
and I make a lot of decisions as a senior engineer.


00:50:00.220 --> 00:50:02.060
I really started to step back and ask myself,


00:50:02.060 --> 00:50:03.980
why do I make these decisions?


00:50:03.980 --> 00:50:06.220
Why do I choose a dictionary over a data class?


00:50:06.220 --> 00:50:08.700
Why do I choose a class over a data class?


00:50:08.700 --> 00:50:12.040
Why do I choose an acceptance test over a unit test?


00:50:12.040 --> 00:50:14.340
Why do I choose to do a plug-in here,


00:50:14.340 --> 00:50:17.640
but a dependency injection somewhere else?


00:50:17.640 --> 00:50:19.240
And I just wanted to start documenting,


00:50:19.240 --> 00:50:22.280
here's why I make the decisions I do.


00:50:22.280 --> 00:50:26.040
Here's what intent I'm trying to communicate through


00:50:26.040 --> 00:50:28.520
in the hopes that we start normalizing that conversation


00:50:28.520 --> 00:50:29.680
more in our field.


00:50:29.680 --> 00:50:31.880
Why are we doing the things we do?


00:50:31.880 --> 00:50:33.720
Because as a beginner, it's frustrating.


00:50:33.720 --> 00:50:35.960
Oh, you use a dictionary here, why?


00:50:35.960 --> 00:50:36.800
You use a set here, why?


00:50:36.800 --> 00:50:38.460
- How do you learn how to do that?


00:50:38.460 --> 00:50:41.660
- Yeah, and so I wanted to really capture,


00:50:41.660 --> 00:50:43.820
again, I've said it a lot, the first principle is,


00:50:43.820 --> 00:50:45.740
why am I doing the things I'm doing?


00:50:45.740 --> 00:50:47.580
What are the things I often give as advice


00:50:47.580 --> 00:50:51.620
to junior programmers, intermediate programmers too,


00:50:51.620 --> 00:50:53.500
and senior programmers?


00:50:53.500 --> 00:50:56.820
It's just, it's, it's really,


00:50:56.820 --> 00:50:59.960
it was really enlightening for me to really step back


00:50:59.960 --> 00:51:03.100
and try to dissect why I do the things I do in Python


00:51:03.100 --> 00:51:03.920
and come up with,


00:51:03.920 --> 00:51:06.020
here are the valid engineering reasons behind it


00:51:06.020 --> 00:51:08.020
and try to frame that in terms of maintainability.


00:51:08.020 --> 00:51:11.760
Yeah, I think that's very valuable. I think it'll help people


00:51:11.760 --> 00:51:14.420
learn because it's not enough to see it by example.


00:51:14.420 --> 00:51:17.420
You're like, "Well, these both kind of work." It's like, yeah, but they mean


00:51:17.420 --> 00:51:19.420
something different. They totally


00:51:19.420 --> 00:51:21.420
communicate something different.


00:51:21.420 --> 00:51:23.720
A couple of thoughts from the live stream I want to share.


00:51:23.720 --> 00:51:25.720
Kim Van Wick out there says


00:51:25.720 --> 00:51:27.720
fantastic advice


00:51:27.720 --> 00:51:30.720
about having too much configurability.


00:51:30.720 --> 00:51:33.420
Far too often I prematurely


00:51:33.420 --> 00:51:35.420
dedupe two similar blocks of code


00:51:35.420 --> 00:51:37.820
and then find myself adding special cases I wouldn't need.


00:51:37.820 --> 00:51:40.340
Yeah, that sounds like what you're saying as well.


00:51:40.340 --> 00:51:42.380
- Yeah, and so what I would say is that


00:51:42.380 --> 00:51:45.500
there's a difference between policies and mechanisms.


00:51:45.500 --> 00:51:46.980
The policies are your business logic


00:51:46.980 --> 00:51:49.180
and the mechanisms are how you go do something.


00:51:49.180 --> 00:51:51.620
Logging module in Python is fantastic for this.


00:51:51.620 --> 00:51:54.680
You're logging, the logger module doesn't care


00:51:54.680 --> 00:51:56.540
what you're logging, how you're logging it,


00:51:56.540 --> 00:51:57.620
when you're logging it.


00:51:57.620 --> 00:51:59.460
It's just the mechanism. - Database,


00:51:59.460 --> 00:52:01.060
DevNull, who cares?


00:52:01.060 --> 00:52:02.420
It's all the same.


00:52:02.420 --> 00:52:04.540
- But the what you're logging is your policies.


00:52:04.540 --> 00:52:06.900
And so very often I try to find a way to say,


00:52:06.900 --> 00:52:10.700
okay, how do I make my mechanisms deduplicated?


00:52:10.700 --> 00:52:12.480
'Cause those are what have reuse.


00:52:12.480 --> 00:52:14.220
My business rules are gonna change,


00:52:14.220 --> 00:52:16.060
they're gonna change for different reasons.


00:52:16.060 --> 00:52:18.780
I wanna make that simple to define business rules,


00:52:18.780 --> 00:52:20.180
but keep the mechanisms reusable.


00:52:20.180 --> 00:52:23.580
You wanna be able to compose those mechanisms together.


00:52:23.580 --> 00:52:26.460
- Yeah, that's a very interesting point.


00:52:26.460 --> 00:52:30.020
Also on the live stream, Mr. Hypermagnetic says,


00:52:30.020 --> 00:52:32.940
is it faster to look up a user or whatever


00:52:32.940 --> 00:52:36.380
from a dictionary rather than iterate over a list.


00:52:36.380 --> 00:52:40.220
And I think, boy, oh boy, if you've been down that path,


00:52:40.220 --> 00:52:41.700
you know there's a difference.


00:52:41.700 --> 00:52:43.980
- This is coming from an advice from a C++ programmer


00:52:43.980 --> 00:52:46.980
who really cared about performance, measure it.


00:52:46.980 --> 00:52:49.140
Use cases can be surprising.


00:52:49.140 --> 00:52:53.720
If there are times where a contiguous block of memory


00:52:53.720 --> 00:52:57.500
with a binary search is faster than a dictionary lookup,


00:52:57.500 --> 00:52:59.660
but you will not know until you measure it.


00:53:00.740 --> 00:53:03.460
There are also things that need to be fast in your program,


00:53:03.460 --> 00:53:06.700
and there are many things that don't need to be fast in your program.


00:53:06.700 --> 00:53:10.700
I think it's important being aware of which one those are.


00:53:10.700 --> 00:53:13.060
You don't want to, not to sound clich,


00:53:13.060 --> 00:53:17.020
the whole premature optimization is the root of all evil.


00:53:17.020 --> 00:53:20.660
Breaking that down a bit, it's you don't want to just optimize everything


00:53:20.660 --> 00:53:23.060
because it takes time to optimize things,


00:53:23.060 --> 00:53:25.540
and it can obfuscate your code to optimize.


00:53:25.540 --> 00:53:30.100
Why am I iterating over a list when a dictionary lookup can be just as useful?


00:53:30.100 --> 00:53:35.700
If you measure the parts that need to be fast, and you say, "This is slow, and this way is faster,"


00:53:35.700 --> 00:53:39.960
as long as you have a comment and a good commit message


00:53:39.960 --> 00:53:45.840
that says why you're doing the slightly obfuscated way or breaking that law of least surprise,


00:53:45.840 --> 00:53:50.340
as long as you have those breadcrumbs for someone to follow and go, "Oh, it's for speed.


00:53:50.340 --> 00:53:52.840
This is the critical performance loop of my application.


00:53:52.840 --> 00:53:57.440
Maybe it's the web request handler or something in a database engine."


00:53:57.440 --> 00:54:01.000
You want to give those breadcrumbs so people can learn why you made the choices you did.


00:54:01.000 --> 00:54:03.760
The last thing you want is someone in five years to say,


00:54:03.760 --> 00:54:07.760
"Oh, they were iterating over lists because they don't know that a dictionary exists.


00:54:07.760 --> 00:54:10.040
Let me go change that and slow down your app."


00:54:10.040 --> 00:54:14.040
But without that measurement, without that data, it's a fruitless endeavor, in my opinion.


00:54:14.040 --> 00:54:18.440
Yeah. I mean, for a lot of data in general, a dictionary lookup would be a lot faster.


00:54:18.440 --> 00:54:22.800
But if what you have to do is every time create the dictionary,


00:54:22.800 --> 00:54:24.800
and then do the lookup,


00:54:25.320 --> 00:54:30.320
probably that act of creating the dictionary erases the speed up


00:54:30.320 --> 00:54:33.320
because you would have just, you're kind of looping over anyway, right?


00:54:33.320 --> 00:54:36.320
So it certainly depends, but yeah.


00:54:36.320 --> 00:54:39.320
Yeah, don't take a website as prescriptive.


00:54:39.320 --> 00:54:42.320
Measure, measure, measure, measure.


00:54:42.320 --> 00:54:44.320
Yeah, absolutely.


00:54:44.320 --> 00:54:49.320
And invoking just your command line application


00:54:49.320 --> 00:54:52.320
with -mcprofile is super illuminating.


00:54:52.320 --> 00:54:54.320
How long have I spent in a function?


00:54:54.320 --> 00:54:56.740
How many times did I call this function?


00:54:56.740 --> 00:55:00.360
Where's most of my execution time spending?


00:55:00.360 --> 00:55:02.700
And it might be that the bottleneck you think you have


00:55:02.700 --> 00:55:04.700
is somewhere else completely.


00:55:04.700 --> 00:55:08.200
Well, yeah, that's actually a really important point as well.


00:55:08.200 --> 00:55:10.200
If you do that C profile


00:55:10.200 --> 00:55:12.540
and you find you're spending 5% of your time


00:55:12.540 --> 00:55:14.540
in that part you're trying to optimize,


00:55:14.540 --> 00:55:16.540
if you could make it go to zero,


00:55:16.540 --> 00:55:18.540
it's still going to be 95% as fast.


00:55:18.540 --> 00:55:20.540
Right?


00:55:20.540 --> 00:55:23.260
So it might be able to be sped up significantly,


00:55:23.260 --> 00:55:28.260
but it might not actually be germane to making your program feel any faster


00:55:28.260 --> 00:55:31.360
because it's like optimizing nothing, basically.


00:55:31.360 --> 00:55:33.060
And I don't want to misrepresent.


00:55:33.060 --> 00:55:34.820
To go back to the question on the live stream,


00:55:34.820 --> 00:55:38.460
typically a dictionary lookup will be faster than entering over a list.


00:55:38.460 --> 00:55:40.700
I expect that most of the time.


00:55:40.700 --> 00:55:44.760
I would not rely on that all of the time, which is why I advocate measuring.


00:55:44.760 --> 00:55:47.620
Yeah, measuring, measuring, measuring.


00:55:47.620 --> 00:55:49.420
I've definitely been in a place where I'm like,


00:55:49.420 --> 00:55:52.220
"Oh, this 6,000 line super complicated thing


00:55:52.220 --> 00:55:54.060
that is hard to understand and work on,


00:55:54.060 --> 00:55:56.660
this is where it's slow."


00:55:56.660 --> 00:55:59.180
And no, it was just some other like wrong data structure


00:55:59.180 --> 00:56:00.940
and some other very simple part.


00:56:00.940 --> 00:56:02.580
But if I didn't measure,


00:56:02.580 --> 00:56:04.300
I would have gone and tried to rewrite the part


00:56:04.300 --> 00:56:06.780
I was like barely understanding


00:56:06.780 --> 00:56:07.860
and would have probably broken it


00:56:07.860 --> 00:56:09.100
and still would have been slow.


00:56:09.100 --> 00:56:11.900
- Yeah, I forget who mentioned it,


00:56:11.900 --> 00:56:14.900
the order of writing things is you make it correct,


00:56:14.900 --> 00:56:16.700
so that, and you have tests around it,


00:56:16.700 --> 00:56:18.660
so that you know that it stays correct.


00:56:18.660 --> 00:56:21.200
You then work on making it clear,


00:56:21.200 --> 00:56:23.600
and then you make it fast if it needs to be.


00:56:23.600 --> 00:56:25.380
And that last part is optional based on,


00:56:25.380 --> 00:56:27.220
is this slowing, actually slowing me down?


00:56:27.220 --> 00:56:30.020
Is there business value I'm losing because this is slow?


00:56:30.020 --> 00:56:32.560
There's certain things I work with.


00:56:32.560 --> 00:56:35.660
We're publishing something once a day.


00:56:35.660 --> 00:56:37.780
If something takes another five minutes,


00:56:37.780 --> 00:56:39.260
I don't really care.


00:56:39.260 --> 00:56:43.180
Like my time is spent better on focusing on parallelization


00:56:43.180 --> 00:56:44.820
or things of that nature.


00:56:44.820 --> 00:56:46.900
And so it's just really understanding


00:56:46.900 --> 00:56:49.460
why things are slowing down and where.


00:56:49.460 --> 00:56:51.340
So there's a little bit of a tangent of robust Python,


00:56:51.340 --> 00:56:53.660
but it's an interesting question to bring up nonetheless.


00:56:53.660 --> 00:56:55.100
- You know, is that five minutes?


00:56:55.100 --> 00:56:56.660
Are you waiting on that five minutes?


00:56:56.660 --> 00:56:59.540
Or is that, you kick it off and you go, yeah, exactly.


00:56:59.540 --> 00:57:02.080
Then you probably don't care at all.


00:57:02.080 --> 00:57:05.100
But speaking of time,


00:57:05.100 --> 00:57:06.780
I'm sure there are a ton of people listening


00:57:06.780 --> 00:57:10.300
that are like, I would love to take some of these ideas,


00:57:10.300 --> 00:57:13.980
maybe using mypy or putting more types


00:57:13.980 --> 00:57:16.620
or looking at stuff like Pydantic


00:57:16.620 --> 00:57:18.340
and so on.


00:57:18.340 --> 00:57:19.800
But at the same time,


00:57:19.800 --> 00:57:24.180
there's a lot of pressure on me to just,


00:57:24.180 --> 00:57:27.580
from the time I receive the request to get some feature done


00:57:27.580 --> 00:57:29.020
till the feature is done,


00:57:29.020 --> 00:57:33.380
and the people making that request,


00:57:33.380 --> 00:57:37.340
managers, business owners, clients, whatever,


00:57:37.340 --> 00:57:41.300
they don't care that much about robust Python.


00:57:41.300 --> 00:57:44.940
They want minimum input of money and time


00:57:44.940 --> 00:57:46.540
for output of features.


00:57:46.540 --> 00:57:50.260
But anyone who has done that for any extended period of time


00:57:50.260 --> 00:57:52.980
knows that that is a net negative.


00:57:52.980 --> 00:57:54.740
- Yes. - How do you address that?


00:57:54.740 --> 00:57:56.700
I'll give you some thoughts of what I've done,


00:57:56.700 --> 00:57:59.440
but how do you address that for people who...


00:57:59.440 --> 00:58:01.440
- The way I... - Or is even that.


00:58:01.440 --> 00:58:03.260
- I wanna frame the conversation for ourself.


00:58:03.260 --> 00:58:07.940
It is your duty to deliver value as quickly as you can.


00:58:07.940 --> 00:58:11.160
It is also your duty to make it so that your maintainers


00:58:11.160 --> 00:58:14.420
can deliver value at the same speed.


00:58:14.420 --> 00:58:17.080
So if you're delivering value today,


00:58:17.080 --> 00:58:19.920
but hindering your ability to deliver a month,


00:58:19.920 --> 00:58:22.520
three months from now, that's a problem.


00:58:22.520 --> 00:58:26.320
Now I'm not saying jeopardize your MVP or go-to market,


00:58:26.320 --> 00:58:28.800
but making sure that the business people understand,


00:58:28.800 --> 00:58:32.460
I can do this, I'm not gonna be able to do this again.


00:58:32.460 --> 00:58:35.180
The other part that I say that is just practice.


00:58:35.180 --> 00:58:37.360
Practice with these sort of concepts


00:58:37.360 --> 00:58:38.960
and apply them in small places.


00:58:38.960 --> 00:58:40.880
You can do things incrementally.


00:58:40.880 --> 00:58:44.560
Maybe there's a couple hundred lines of a library you have.


00:58:44.560 --> 00:58:46.280
Just write type annotations for that


00:58:46.280 --> 00:58:48.120
or make it more extensible.


00:58:48.120 --> 00:58:51.000
Find small little wins here and there.


00:58:51.000 --> 00:58:53.980
And as you keep working at it, just as Boy Scout rule,


00:58:53.980 --> 00:58:56.280
leave the code base cleaner than you found it.


00:58:56.280 --> 00:58:58.320
So if I'm going into something and say,


00:58:58.320 --> 00:59:00.480
you know what, these assumptions don't hold up anymore.


00:59:00.480 --> 00:59:02.500
I can't fix it all right now,


00:59:02.500 --> 00:59:04.600
but I can do one incremental step


00:59:04.600 --> 00:59:06.920
that makes it easier the next time I'm in here.


00:59:06.920 --> 00:59:08.720
I take those little bites over time


00:59:08.720 --> 00:59:11.400
and slowly morph into something that's like, okay,


00:59:11.400 --> 00:59:13.480
as we start slowing down delivery,


00:59:13.480 --> 00:59:14.800
I'm starting to make those improvements


00:59:14.800 --> 00:59:17.760
and then we start speeding up back again.


00:59:17.760 --> 00:59:21.240
Because there is a real tension between deliver it now


00:59:21.240 --> 00:59:26.240
and making sure that you are going to be able to deliver


00:59:26.240 --> 00:59:27.700
hastily in the future.


00:59:27.700 --> 00:59:31.440
And by no means am I advocating gold plating where,


00:59:31.440 --> 00:59:34.000
oh, make everything maintainable now.


00:59:34.000 --> 00:59:36.440
'Cause there's typically a business behind this


00:59:36.440 --> 00:59:38.280
and you don't want the business to fail.


00:59:38.280 --> 00:59:41.840
you need to be able to be able to ship early and often.


00:59:41.840 --> 00:59:45.160
And it's that often part that is often the tricky part.


00:59:45.160 --> 00:59:47.840
Practice, practice, practice


00:59:47.840 --> 00:59:50.640
and target where you're applying these ideas.


00:59:50.640 --> 00:59:52.280
- You have tools to make it,


00:59:52.280 --> 00:59:56.080
you don't have to put all that flexibility in there first.


00:59:56.080 --> 00:59:57.400
You write it one way, you get it out,


00:59:57.400 --> 00:59:59.240
but then you have refactoring tools,


00:59:59.240 --> 01:00:00.320
you have continuous integration,


01:00:00.320 --> 01:00:03.280
you have things that allow you to make those changes


01:00:03.280 --> 01:00:05.480
long as you keep using them


01:00:05.480 --> 01:00:07.880
and as long as the code doesn't get too bad.


01:00:07.880 --> 01:00:12.200
And here's one of the things I've always liked seeing.


01:00:12.200 --> 01:00:13.320
I forget who said this.


01:00:13.320 --> 01:00:14.160
There's a great quote.


01:00:14.160 --> 01:00:16.320
It's like, "To make a hard change,


01:00:16.320 --> 01:00:18.600
first make the hard change easy."


01:00:18.600 --> 01:00:19.720
That's the hard part.


01:00:19.720 --> 01:00:21.520
And then go make the easy change.


01:00:21.520 --> 01:00:22.420
- Yeah.


01:00:22.420 --> 01:00:25.360
- When you see, like a lot of teams do some sort of


01:00:25.360 --> 01:00:28.360
estimation of their stories, how big will this effort take?


01:00:28.360 --> 01:00:31.560
If you see consistently high estimates,


01:00:31.560 --> 01:00:32.960
and this is always a large,


01:00:32.960 --> 01:00:35.240
we're always doing larges and extra larges.


01:00:35.240 --> 01:00:40.120
Ask yourself, what would it take to make this a small?


01:00:40.120 --> 01:00:42.080
Sometimes you use Fibonacci numbers,


01:00:42.080 --> 01:00:43.520
like if this is an eight,


01:00:43.520 --> 01:00:45.920
what would it take for me to make this a three?


01:00:45.920 --> 01:00:47.740
And some of your listeners may be like,


01:00:47.740 --> 01:00:48.720
what are you talking about?


01:00:48.720 --> 01:00:51.520
But estimation, we're estimating effort.


01:00:51.520 --> 01:00:53.480
- Yeah, traditionally way, way back in the day,


01:00:53.480 --> 01:00:55.200
people used to estimate in hours.


01:00:55.200 --> 01:00:56.560
How many hours is this gonna take you?


01:00:56.560 --> 01:01:00.760
And it's like, that is a granularity that we don't have.


01:01:00.760 --> 01:01:03.600
Like, I can't tell you, is it 17 or 18 hours?


01:01:03.600 --> 01:01:08.400
I can tell you that two hours or two days, but I can't tell you 17 hours.


01:01:08.400 --> 01:01:13.060
And so when you get large estimates again and again, ask yourself, are these estimates


01:01:13.060 --> 01:01:18.320
because of necessary complexity, complexity that's inherent to my domain, or is it accidental


01:01:18.320 --> 01:01:20.360
complexity that's built up over time?


01:01:20.360 --> 01:01:25.960
I have to talk so necessary complexity is, you know, the deep workings of a neural net


01:01:25.960 --> 01:01:30.320
or flight controller software, like these are inherently hard problems.


01:01:30.320 --> 01:01:36.320
I can't make that simpler, not without making a whole lot of money revamping an industry.


01:01:36.320 --> 01:01:39.200
But things like tax preparation, right?


01:01:39.200 --> 01:01:44.280
Like there's a minimum set of complexity to just figure out what that answer is, because


01:01:44.280 --> 01:01:46.160
the rules are complex.


01:01:46.160 --> 01:01:52.040
But if let's take that tax, if I have to, you know, maybe add a new rule, and it's just


01:01:52.040 --> 01:01:59.280
a simple multiplication somewhere, I shouldn't have to add 20 to 30 files of changes just


01:01:59.280 --> 01:02:03.600
implement that one thing because it's going to happen again and again and again.


01:02:03.600 --> 01:02:07.120
And so you look for these common cases, say, you know, we keep saying this is a


01:02:07.120 --> 01:02:09.240
large effort, how do I make that smaller?


01:02:09.240 --> 01:02:13.880
And then you say, Oh, you know, if we just restructured things here, you often find


01:02:13.880 --> 01:02:19.160
that the same amount of effort to go make that heart change easy will pay off in one


01:02:19.160 --> 01:02:22.360
to two cycles of like, okay, now that we're doing this again and again and again,


01:02:22.360 --> 01:02:26.600
like, yes, I took an extra day longer or week longer.


01:02:26.600 --> 01:02:28.720
And again, be mindful of your schedules.


01:02:28.720 --> 01:02:30.720
I'm not saying split schedules intentionally,


01:02:30.720 --> 01:02:34.720
but find that wiggle room where you can band together with your team


01:02:34.720 --> 01:02:38.720
and find those areas, "Oh, this is a place that we can get some gains back."


01:02:38.720 --> 01:02:42.320
I often like to set junior engineers on the team


01:02:42.320 --> 01:02:43.920
at these sort of tasks.


01:02:43.920 --> 01:02:45.560
They get more familiar with the code.


01:02:45.560 --> 01:02:48.560
They often don't have as many responsibilities as a senior engineer.


01:02:48.560 --> 01:02:51.840
And they just get that understanding.


01:02:51.840 --> 01:02:55.360
And they feel like, "Oh, I've done something that really, really matters."


01:02:55.360 --> 01:02:57.840
- I really need to make a change. - Right, so they're not on a cleanup job.


01:02:57.840 --> 01:03:01.040
Yeah, and that has worked wonders for me as well.


01:03:01.040 --> 01:03:03.040
Like it's just a win-win.


01:03:03.040 --> 01:03:05.240
And then you're delivering those features,


01:03:05.240 --> 01:03:07.240
those same things you're doing again and again


01:03:07.240 --> 01:03:08.940
at a much greater speed.


01:03:08.940 --> 01:03:12.240
And that saves you time to go do the next thing that you have to do.


01:03:12.240 --> 01:03:14.240
Yeah.


01:03:14.240 --> 01:03:17.940
My approach to this,


01:03:17.940 --> 01:03:21.440
I mean, it only works with certain groups of stakeholders,


01:03:21.440 --> 01:03:23.440
I suppose.


01:03:23.440 --> 01:03:25.940
But when somebody would ask me, "How long does this feature take?"


01:03:25.940 --> 01:03:29.140
It wasn't like, well, here's the essence of the feature.


01:03:29.140 --> 01:03:31.480
Like it will work and you can click the button.


01:03:31.480 --> 01:03:33.860
Here's how much it'll take to add error handling.


01:03:33.860 --> 01:03:35.860
Here's how much it'll take to add logging.


01:03:35.860 --> 01:03:37.860
Here's how much it'll add to make that work


01:03:37.860 --> 01:03:40.320
in continuous integration and have tests.


01:03:40.320 --> 01:03:41.900
And here's how much we got to do to like


01:03:41.900 --> 01:03:45.240
not add technical debt while adding this feature, right?


01:03:45.240 --> 01:03:48.620
Instead of presenting like, well, here's your menu.


01:03:48.620 --> 01:03:49.960
Well, all I want is the feature.


01:03:49.960 --> 01:03:51.760
Just give me the feature, right?


01:03:51.760 --> 01:03:54.420
I just say, okay, well, if the feature is three hours,


01:03:54.420 --> 01:03:59.380
the other two hours, like five hours, it's gonna take me five hours or whatever, like metric used


01:03:59.380 --> 01:04:05.700
that that is what delivering it means in a professional setting is that it is done,


01:04:05.700 --> 01:04:11.940
not that it's minimum path, zero errors and zero bad data will execute, right? They're not the same.


01:04:11.940 --> 01:04:17.860
It's not to get sucked into the minimum. How quick can I do this? I bet I can do it an hour if I


01:04:17.860 --> 01:04:19.620
I really fly, right?


01:04:19.620 --> 01:04:22.180
- Yeah, and I think that's a trap we often fall into.


01:04:22.180 --> 01:04:26.600
Like we're, as engineers, it's our responsibility


01:04:26.600 --> 01:04:28.480
to provide accurate estimates


01:04:28.480 --> 01:04:30.560
for what's best for the business.


01:04:30.560 --> 01:04:32.980
And like, if you say, "Oh, I can do this without tests."


01:04:32.980 --> 01:04:34.740
What you're really telling people are,


01:04:34.740 --> 01:04:37.440
"I can do it, but I can't guarantee it will keep working


01:04:37.440 --> 01:04:39.720
"after I deploy it, 'cause I will have no way of knowing."


01:04:39.720 --> 01:04:43.100
I've removed that visibility of tests to tell me,


01:04:43.100 --> 01:04:45.680
"Oh, this important thing that you really wanted now,


01:04:45.680 --> 01:04:51.360
no idea if it's working now, sorry. And once you start framing it like that, people go,


01:04:51.360 --> 01:04:55.840
"Okay, yeah, yeah, okay, let's see what we can do." And you might need to have some hard


01:04:55.840 --> 01:05:00.880
conversations with the people who manage this. It might be, "We need more headcount. We don't need


01:05:00.880 --> 01:05:08.960
as... We can't take as many projects. We can't take this much complexity. Maybe a worldwide


01:05:08.960 --> 01:05:14.880
pandemic is happening and are, you know, we've been severely impacted. And I mean, you can't,


01:05:14.880 --> 01:05:20.720
to some degree, you can't fix poor management of something, but you can coach your way up to


01:05:20.720 --> 01:05:25.680
try to get out of that. Some people are very receptive to that. Some people are not. And in


01:05:25.680 --> 01:05:29.920
the places that aren't, I mean, you have to ask yourself, is this something that I'm going to


01:05:29.920 --> 01:05:34.000
live with? Or is this something that bothers me and I need to think about other things?


01:05:34.000 --> 01:05:37.000
- Yeah, well, I think you're probably in a pretty good space


01:05:37.000 --> 01:05:40.000
if you're making that clear to people.


01:05:40.000 --> 01:05:43.000
So I think if you're proposing a feature


01:05:43.000 --> 01:05:45.000
or how long will it take to do this feature,


01:05:45.000 --> 01:05:48.000
then you just include what that means for a feature to be done.


01:05:48.000 --> 01:05:52.000
It's not like zero bad data and it works sometimes.


01:05:52.000 --> 01:05:55.000
It works for real.


01:05:55.000 --> 01:05:59.000
The harder story is we've gotten into a bad place.


01:05:59.000 --> 01:06:03.000
We need to not add features and just refactor improvement.


01:06:03.000 --> 01:06:11.000
And that's a really tough one, because if I'm a business person, I'm never going to say yes, please stop feature delivery and making money for us


01:06:11.000 --> 01:06:14.000
to go build the same thing we already have.


01:06:14.000 --> 01:06:16.000
Like that's a tough sell to a business.


01:06:16.000 --> 01:06:19.000
And I really think just an incremental approach.


01:06:19.000 --> 01:06:22.000
And again, I mentioned earlier, targeting strategically.


01:06:22.000 --> 01:06:25.000
What are your most used libraries or parts of code?


01:06:25.000 --> 01:06:27.000
What are the areas with the highest bug count?


01:06:27.000 --> 01:06:28.000
Put data to that.


01:06:28.000 --> 01:06:30.000
Hey, what's the biggest bug?


01:06:30.000 --> 01:06:32.640
the highest bug count, put data to that.


01:06:32.640 --> 01:06:35.180
Hey, we've had five customer complaints


01:06:35.180 --> 01:06:36.660
about a crash in their system.


01:06:36.660 --> 01:06:38.560
They're linked to this one piece.


01:06:38.560 --> 01:06:41.120
If we start doing this, we save X amount of money


01:06:41.120 --> 01:06:43.220
and we would have kept that one customer.


01:06:43.220 --> 01:06:44.620
That's the sort of thing that speaks


01:06:44.620 --> 01:06:46.300
when you're getting against those


01:06:46.300 --> 01:06:49.680
somewhat unrealistic business pressures.


01:06:49.680 --> 01:06:52.200
You have to speak on their level.


01:06:52.200 --> 01:06:54.360
And what I'm saying is a little wrong


01:06:54.360 --> 01:06:56.840
'cause it's not an us versus them type mentality.


01:06:56.840 --> 01:06:58.320
You're in this together.


01:06:58.320 --> 01:07:00.560
They feel lost versus them at some times,


01:07:00.560 --> 01:07:02.260
but you need to work together, make them understand


01:07:02.260 --> 01:07:04.120
here are the business implications


01:07:04.120 --> 01:07:05.880
of the choices we're making.


01:07:05.880 --> 01:07:06.720
- Yeah, exactly.


01:07:06.720 --> 01:07:09.000
I mean, you're the engineer and they're the business people,


01:07:09.000 --> 01:07:11.740
but you've got to just put the situation


01:07:11.740 --> 01:07:13.480
in terms that they appreciate


01:07:13.480 --> 01:07:16.560
and they can decide if it makes sense for them.


01:07:16.560 --> 01:07:17.880
- Yep.


01:07:17.880 --> 01:07:20.360
- I would also add, people out there listening,


01:07:20.360 --> 01:07:23.760
that if the answer is almost never,


01:07:23.760 --> 01:07:26.520
can we clean up technical debt and make this better?


01:07:26.520 --> 01:07:29.320
you probably will end up with a team over time


01:07:29.320 --> 01:07:31.320
who is full of people who don't care about


01:07:31.320 --> 01:07:33.320
raising technical debt and making it better.


01:07:33.320 --> 01:07:35.640
And it's only just going to get worse and worse


01:07:35.640 --> 01:07:37.640
in combinatorial ways.


01:07:37.640 --> 01:07:41.200
It's not where the top engineers want to be.


01:07:41.200 --> 01:07:43.080
And they don't get excited about coming to work


01:07:43.080 --> 01:07:46.880
where they have to sneak in something that's unreliable


01:07:46.880 --> 01:07:50.520
and cram new features in the broken, ugly code.


01:07:50.520 --> 01:07:53.000
And something I've learned over a long time programming


01:07:53.000 --> 01:07:55.640
is almost every technical solution,


01:07:55.640 --> 01:07:58.840
there's a people or process problem at the root of it.


01:07:58.840 --> 01:08:01.140
There's a lot of things that we think,


01:08:01.140 --> 01:08:02.320
oh, code can solve this.


01:08:02.320 --> 01:08:05.120
If I just refactor this, everything will be great.


01:08:05.120 --> 01:08:06.520
But there's a people aspect of this.


01:08:06.520 --> 01:08:08.880
And I'm not putting down those people.


01:08:08.880 --> 01:08:11.320
Everyone around you is just a living, breathing human being.


01:08:11.320 --> 01:08:13.400
They all have their own hopes, their own dreams,


01:08:13.400 --> 01:08:16.280
their own obstacles, their own places in life.


01:08:16.280 --> 01:08:19.200
And we have to recognize that sometimes.


01:08:19.200 --> 01:08:20.860
Sometimes you have to work with the people


01:08:20.860 --> 01:08:23.320
in order to solve that technical problem.


01:08:23.320 --> 01:08:24.900
- Yeah, yeah, absolutely.


01:08:24.900 --> 01:08:29.900
- So much for the mythos of the software engineer


01:08:29.900 --> 01:08:31.600
in the basement by themself, huh?


01:08:31.600 --> 01:08:35.920
- I think that stereotype is long dead for the most part.


01:08:35.920 --> 01:08:37.520
- I agree, I agree.


01:08:37.520 --> 01:08:40.280
All right, well, we go on and on,


01:08:40.280 --> 01:08:41.640
but I think we're out of time.


01:08:41.640 --> 01:08:44.080
So thanks for all your thoughts on this


01:08:44.080 --> 01:08:46.600
and the book's interesting.


01:08:46.600 --> 01:08:47.520
We'll talk more about it in a second,


01:08:47.520 --> 01:08:50.720
but before we do, if you're gonna write some of this code,


01:08:50.720 --> 01:08:52.040
work on some of these ideas,


01:08:52.040 --> 01:08:54.040
what editor are you up to?


01:08:54.040 --> 01:08:56.360
- Yeah, I use VS Code,


01:08:56.360 --> 01:08:58.000
'cause I still jump between languages quite a bit,


01:08:58.000 --> 01:08:59.780
and I like the flexibility of that.


01:08:59.780 --> 01:09:01.720
For 1Z/2Z, I'll use Vim.


01:09:01.720 --> 01:09:05.960
- Cool, then notable PyPI package?


01:09:05.960 --> 01:09:07.640
- I'm gonna call it stevedore,


01:09:07.640 --> 01:09:11.280
'cause it's a package used for plugins,


01:09:11.280 --> 01:09:12.400
doing plugin development.


01:09:12.400 --> 01:09:14.200
I think it's really neat how it uses


01:09:14.200 --> 01:09:17.120
the package's entry points,


01:09:17.120 --> 01:09:19.080
so that you can deploy plugins


01:09:19.080 --> 01:09:21.360
as separate pip installable packages.


01:09:21.360 --> 01:09:23.040
Just something I wish more people knew about.


01:09:23.040 --> 01:09:23.880
- That's awesome.


01:09:23.880 --> 01:09:25.440
One of the things we didn't cover,


01:09:25.440 --> 01:09:29.280
but is also part of this robust story that you tell


01:09:29.280 --> 01:09:31.620
is about extensibility, about plugins,


01:09:31.620 --> 01:09:33.520
about all those kinds of things, right?


01:09:33.520 --> 01:09:34.600
- Yeah, and that just goes back


01:09:34.600 --> 01:09:36.760
to making the common cases simple.


01:09:36.760 --> 01:09:39.560
If you're doing something again and again and again,


01:09:39.560 --> 01:09:41.320
make it easy for people to do that.


01:09:41.320 --> 01:09:44.040
And extensible code is a way to do that.


01:09:44.040 --> 01:09:45.560
- Yeah, like that tax example, right?


01:09:45.560 --> 01:09:47.520
If you could plug in the formulas


01:09:47.520 --> 01:09:48.480
that are applied in this place,


01:09:48.480 --> 01:09:49.880
and then you just add it in,


01:09:49.880 --> 01:09:51.880
and maybe it just picks it up and goes,


01:09:51.880 --> 01:09:53.280
- That would be ideal, yeah.


01:09:53.280 --> 01:09:55.960
All right, awesome.


01:09:55.960 --> 01:09:58.800
Good recommendation, one that I had not heard of.


01:09:58.800 --> 01:10:00.440
All right, so people are interested in this idea.


01:10:00.440 --> 01:10:02.800
I assume that they can check out your book,


01:10:02.800 --> 01:10:04.520
maybe tell people about that real quick,


01:10:04.520 --> 01:10:07.920
and then what else would you provide as resources


01:10:07.920 --> 01:10:09.580
or places to get started?


01:10:09.580 --> 01:10:15.400
- Yeah, I think just talking to senior members on your team,


01:10:15.400 --> 01:10:17.480
talking to junior members on your team,


01:10:17.480 --> 01:10:20.480
learning how people use the code around you,


01:10:20.480 --> 01:10:25.480
keeping an ear for your stakeholders, your co-developers,


01:10:25.480 --> 01:10:27.040
think about the code you write,


01:10:27.040 --> 01:10:29.320
think about the implications it has,


01:10:29.320 --> 01:10:32.120
I mean, just listen, most of this is empathy.


01:10:32.120 --> 01:10:33.880
I thought I was writing a technical book,


01:10:33.880 --> 01:10:35.560
I wrote a book about empathy instead,


01:10:35.560 --> 01:10:37.280
and just didn't know it.


01:10:37.280 --> 01:10:38.720
Put yourself in other people's shoes


01:10:38.720 --> 01:10:40.800
and think about how they're gonna perceive your code


01:10:40.800 --> 01:10:44.400
a month from now, a year from now, five years from now.


01:10:44.400 --> 01:10:49.400
And again, just, I mean, a lot of talks that you'll see


01:10:49.480 --> 01:10:52.320
at PyCon or the other Python conferences,


01:10:52.320 --> 01:10:55.280
you'll see these nuggets of truth throughout them.


01:10:55.280 --> 01:10:58.220
Ask yourself, why are they making the decisions they do?


01:10:58.220 --> 01:11:00.160
And see if you can really understand


01:11:00.160 --> 01:11:05.080
the kind of the root cause of why they're using this feature


01:11:05.080 --> 01:11:07.440
especially as new features come out with Python.


01:11:07.440 --> 01:11:09.040
- Yeah.


01:11:09.040 --> 01:11:10.640
Well, a lot of great ideas in here


01:11:10.640 --> 01:11:12.400
and I had a fun time talking about them.


01:11:12.400 --> 01:11:13.320
- Oh, me too.


01:11:13.320 --> 01:11:14.840
- Yeah, thanks for being here.


01:11:14.840 --> 01:11:16.280
- Thank you so much.


01:11:16.280 --> 01:11:17.840
- You're welcome, bye.


01:11:17.840 --> 01:11:19.360
- Bye.


01:11:19.360 --> 01:11:20.260
Bye everyone in the live stream.


01:11:20.260 --> 01:11:22.520
Thanks for being here or thanks for watching.


01:11:22.520 --> 01:11:32.520
[BLANK_AUDIO]

