WEBVTT

00:00:00.920 --> 00:00:04.260
Hey, Charlie. Hey, Carl. Welcome to StockPython to Me. Awesome to have you here.

00:00:05.340 --> 00:00:08.020
Thank you so much for, I guess, having me back on

00:00:08.020 --> 00:00:08.980
and

00:00:08.980 --> 00:00:12.140
having Carl here, too. We're really excited to be here.

00:00:12.460 --> 00:00:14.840
Yes, I've had you both on before, but never together,

00:00:15.400 --> 00:00:16.980
side by side on the screen.

00:00:19.100 --> 00:00:19.300
Yes.

00:00:20.500 --> 00:00:29.980
Amazing. You know, you folks over at Astral, you're doing things in the Python space. You're

00:00:32.119 --> 00:00:34.520
Yeah, that's kind of our, you know, that's our goal.

00:00:35.500 --> 00:00:37.620
We want to get people to talk about Python.

00:00:38.100 --> 00:00:39.780
And so it's a good mix for what we're doing on the podcast.

00:00:41.400 --> 00:00:53.100
Yeah, but our, yeah, I mean, a big part of what we've been doing is just trying to like inject as much energy as we can into the Python ecosystem and like see what comes of it.

00:00:53.540 --> 00:00:58.860
So yeah, this new project that we're working on, I think hopefully we'll shake things up a little bit more too.

00:00:59.700 --> 00:01:15.260
absolutely going to. I was just thinking this morning, as I was realizing we were going to be talking today and not some other day, that I was using both RUF and UV on a project, multiple projects already this morning, and I smile every time I do. They're both great projects.

00:01:16.140 --> 00:01:17.200
Thank you. I appreciate that.

00:01:19.780 --> 00:01:38.900
I do want to talk about UV for just a moment before we kind of go down the other side of the branch there. But before we do either of those, it's been a while, Carl, since you've been on, and Charlie, not everyone listens to every episode, so maybe I'll sit on it. Just maybe a quick round of introductions from you guys. Charlie, you want to go first?

00:01:39.740 --> 00:02:00.740
Yeah, sure. Hey, I'm Charlie. I am the founder of a company called Astral. We build developer tools for the Python ecosystem. So we're best known for two tools, the first of which is called Ruff. It's a Python static analysis tool, So it kind of looks at your code, tries to identify problems, and then in a lot of cases, fix them.

00:02:00.880 --> 00:02:02.280
It can also reformat your code.

00:02:02.580 --> 00:02:07.680
So if you've used tools like FlakeGate or Black before, Ruff is an alternative to those kinds of tools.

00:02:08.800 --> 00:02:11.800
And then UV, which is a Python package manager.

00:02:12.840 --> 00:02:16.580
So if you've used tools like PIP or Poetry in the past, UV would be an alternative to those tools.

00:02:17.420 --> 00:02:20.140
Helps you manage all your dependencies, manage your Python installation itself.

00:02:21.300 --> 00:02:25.840
So yeah, I've been working on Python tooling full-time for about two and a half years.

00:02:28.500 --> 00:02:36.060
And Astral as a company, we're now 14, 15 people working on this stuff full-time.

00:02:36.320 --> 00:02:45.580
So yeah, I spent all my time either thinking about Python or writing code to try to make Python better or talking to people about Python.

00:02:49.320 --> 00:02:49.580
That's

00:02:49.580 --> 00:02:49.700
awesome.

00:02:51.240 --> 00:02:51.700
I'm

00:02:51.700 --> 00:02:51.960
Carl.

00:02:52.500 --> 00:03:05.420
I've been hanging around the Python community for a long time now. Way back in the day, I used to maintain PIP and VirtualEnv, along with Giannis Liddell and Brian Rosner back in the day.

00:03:06.220 --> 00:03:20.860
And for a while, I was on the Django core team, spent some time at Instagram, worked on the Cinder JIT compiler there. And then a little more than a year ago, Charlie came along and said, hey, would you like to come to Astral and build a Python type checker in Rust?

00:03:21.640 --> 00:03:22.840
and that sounds like a lot of fun.

00:03:23.040 --> 00:03:23.120
So

00:03:23.120 --> 00:03:23.980
here I am.

00:03:23.990 --> 00:03:25.000
Yes, that was the pitch.

00:03:25.440 --> 00:03:25.520
Yeah.

00:03:26.880 --> 00:03:28.720
I guess that's our segue into the next topic then.

00:03:29.560 --> 00:03:30.060
Yeah, it is.

00:03:30.280 --> 00:03:32.400
And what a storied history you got there.

00:03:32.520 --> 00:03:32.800
That's awesome.

00:03:35.620 --> 00:03:36.140
It is.

00:03:36.440 --> 00:03:43.980
Now, I want to take the second half of your sentence there, Carl, and focus on that just for a second, just the rust side and just the tooling side.

00:03:45.940 --> 00:03:54.000
I want to talk a little bit about UV because I feel like you should shine a bit of a light on it while you two are here, even though it's not the main topic.

00:03:54.090 --> 00:04:01.880
So before we dive down the rabbit hole of the new project, let's talk just a little bit of UV, maybe give us a bit of an update.

00:04:02.260 --> 00:04:10.640
And also, I want to point out that when I said the opening statement, I think you're making people talk about Python things.

00:04:12.720 --> 00:04:16.500
Pip proper got quite a big update recently.

00:04:16.880 --> 00:04:23.680
And I think a lot of the energy that's being put into other tooling is like, whoa, if we're going to keep doing this, we better keep up.

00:04:25.150 --> 00:04:25.260
Right?

00:04:26.100 --> 00:04:28.100
I think you're making a lot of interesting changes.

00:04:28.380 --> 00:04:29.680
There's the new lock file.

00:04:31.100 --> 00:04:33.220
Is it pylock.toml it's called, I think?

00:04:33.220 --> 00:04:33.840
Yep, that's right.

00:04:33.840 --> 00:04:34.640
And Brett Cannon and

00:04:34.640 --> 00:04:36.660
crew were advocating for.

00:04:37.060 --> 00:04:39.420
So, yeah, maybe give us a quick update on these things.

00:04:40.080 --> 00:04:40.700
Yeah, yeah, totally.

00:04:40.920 --> 00:05:01.720
So, yeah, we're still very focused on UV and UV continues to grow just in terms of the number of users that we have, the amount of companies that are using it, the amount of individuals that are using it.

00:05:01.760 --> 00:05:04.720
I think I ran the numbers the other week.

00:05:05.360 --> 00:05:18.740
And over the previous seven-day period, it was over 20% of PyPI traffic came from people using UV, which is just sort of like an unfathomably large number because PyPI is over 2 billion requests a day.

00:05:19.000 --> 00:05:23.040
So that's like hundreds and hundreds of millions of requests a day from people using UV.

00:05:24.980 --> 00:05:27.000
So a lot of things have been happening.

00:05:27.280 --> 00:05:30.360
We've been participating in some of the newer PEPs.

00:05:30.520 --> 00:05:39.320
So yeah, there was a lockfile pep that was accepted that Brett heroically spent a lot of time getting approved.

00:05:39.450 --> 00:05:46.380
And I'm just laughing because I also felt like I spent a lot of time, but then I just think about how much time he spent, which is so much more.

00:05:46.900 --> 00:05:50.660
And just realize how it's just a lot of work to build consensus.

00:05:51.060 --> 00:05:53.640
So that proposal now exists.

00:05:53.780 --> 00:06:01.220
It's kind of like an upgraded requirements TXT format, a tool agnostic way to record the exact dependencies and files that you want to install.

00:06:02.220 --> 00:06:03.300
And we ship support for that.

00:06:05.680 --> 00:06:07.120
What's the status on that?

00:06:07.300 --> 00:06:09.580
Are you 100% that's ready to go?

00:06:09.800 --> 00:06:13.220
Or is there any sort of caveats like it's tentative, it's new?

00:06:15.080 --> 00:06:16.900
Parts of it are technically behind

00:06:16.900 --> 00:06:21.500
the preview flag, but that just means that you'll get warned if you don't pass the preview flag.

00:06:21.820 --> 00:06:23.620
So it exists.

00:06:24.300 --> 00:06:43.840
I think the thing that's maybe a little tricky to convey is we still use our own uv.lock format, and we view the pylock.tommel as sort of like an export format or an interoperability format because it doesn't quite support everything that we need in our format.

00:06:44.860 --> 00:06:50.000
So if you just use UV to resolve and install and manage your dependencies, you'll still use a UV.lock.

00:06:50.680 --> 00:06:54.920
But you can export out to pylock.tomil, and then you could use that with other tools.

00:06:55.680 --> 00:07:02.020
You could also generate a pylock.tomil with pip, for example, and then install from that in UV.

00:07:02.540 --> 00:07:03.420
So it's really meant

00:07:03.420 --> 00:07:10.680
as an interoperability format with other tools, but it's supported throughout the UV API.

00:07:11.700 --> 00:07:14.920
And we'll try and just make that support better and better over time.

00:07:15.070 --> 00:07:23.120
And also, hopefully, if we can find time, do a few more iterations on the spec to try and expand the scope of what that format can do, too.

00:07:23.740 --> 00:07:26.840
But it's a big upgrade over requirements.txt.

00:07:26.980 --> 00:07:31.140
A lot of people historically used requirements.txt as a quote-unquote lock file.

00:07:31.760 --> 00:07:32.920
Like, you'd write out, yeah,

00:07:33.120 --> 00:07:33.360
and

00:07:33.360 --> 00:07:40.500
it was kind of the best thing that we had for a while, where it's just the package equals equals the version and then maybe the hashes.

00:07:41.440 --> 00:07:45.540
And that's just not, it's not a great interoperable format.

00:07:46.320 --> 00:07:49.040
For one thing, it's not standardized.

00:07:49.620 --> 00:07:51.320
There's not really a specification around it.

00:07:52.140 --> 00:07:54.540
It's basically defined by what pip does.

00:07:54.930 --> 00:08:03.660
So when we have wanted support for it, we just constantly had to ask, well, how does pip handle this syntax or this grammar or this case and do that?

00:08:04.010 --> 00:08:06.240
Or make maybe small improvements to it if we thought we could.

00:08:07.820 --> 00:08:10.820
The other is that it's not super secure.

00:08:11.860 --> 00:08:25.080
the ability to put hashes in it helped a lot but with pylock.toml for example it'll list the exact URLs that you should use and you can say that this package needs to come from this index and all that kind of stuff so

00:08:25.080 --> 00:08:26.800
it's a really nice improvement over

00:08:26.800 --> 00:08:31.660
those and yeah I'm glad that we tried to ship support for it pretty quickly so

00:08:31.660 --> 00:08:33.140
I'm

00:08:33.140 --> 00:08:40.900
sure there's a lot of sort of like a long tail of things we could do to make it a little bit better but I'm pretty happy with the state of that so far

00:08:41.620 --> 00:08:47.580
yeah fantastic Carl anything you want to add I know you're not quite working on UV most of the time probably

00:08:48.500 --> 00:08:53.620
I don't think I have anything to add on UV I enjoy using it but there's no

00:08:53.620 --> 00:08:56.460
UV dash dash check types or nothing

00:08:56.460 --> 00:08:56.680
like

00:08:56.680 --> 00:08:56.940
that

00:08:57.200 --> 00:08:58.060
no flags in there

00:08:58.520 --> 00:08:58.580
it's

00:08:58.580 --> 00:09:00.640
on

00:09:00.640 --> 00:09:01.160
the road map

00:09:02.620 --> 00:09:10.460
nice I will not install a package that lies about it's types this is how it's going to be it's the new version Yeah, you laugh,

00:09:10.740 --> 00:09:16.180
but I think that being able to integrate these tools together is actually something that we're very interested in.

00:09:16.720 --> 00:09:17.340
Interesting. Okay.

00:09:18.120 --> 00:09:20.480
We'll sort of get into it, but we're building a type checker.

00:09:21.300 --> 00:09:26.900
And there's a lot of powerful things we could do in terms of making the type checking just work.

00:09:27.180 --> 00:09:34.320
If you're in a UV structured project that UV understands and UV can manage the dependencies, there's a lot of interesting interop that we could do between the tools.

00:09:34.460 --> 00:09:34.780
I mean, we

00:09:34.780 --> 00:09:34.940
want

00:09:34.940 --> 00:09:38.900
them to all work great standalone if you're just using it in however way you want.

00:09:39.060 --> 00:09:44.260
But when you bring those things together, I think there are some cool opportunities to make the experience a lot more powerful and seamless.

00:09:45.440 --> 00:09:46.020
Yeah, that's cool.

00:09:47.180 --> 00:09:48.280
There's definitely room to grow.

00:09:48.400 --> 00:09:52.320
It's super popular, over 50,000 GitHub stars, which is incredible.

00:09:53.160 --> 00:09:55.660
That's almost as many as Flask or Django has.

00:09:57.139 --> 00:10:01.280
But Armin Roeneker did a Twitter thread that said, if you're not using UV, tell me why.

00:10:02.060 --> 00:10:04.320
and there was a bunch of misconceptions and other things.

00:10:04.410 --> 00:10:06.340
So there's still room for you guys to grow, right?

00:10:06.860 --> 00:10:08.120
Yeah, definitely. 100%.

00:10:08.620 --> 00:10:09.120
Where's that

00:10:09.120 --> 00:10:11.860
80% of PyPI traffic, right?

00:10:14.900 --> 00:10:24.339
But let's talk about your new project, which I guess doesn't really show up here, but I'm going to sort of maybe...

00:10:25.380 --> 00:10:26.360
No, it doesn't show up here.

00:10:26.940 --> 00:10:27.040
It's

00:10:27.040 --> 00:10:27.300
secret.

00:10:27.380 --> 00:10:28.680
Possibly group...

00:10:28.680 --> 00:10:29.740
So I think let's

00:10:29.740 --> 00:10:30.500
start with an announcement.

00:10:31.060 --> 00:10:31.840
Let's start with an announcement.

00:10:32.060 --> 00:10:43.660
The title of the show, the working title, the working title that I put here for, because at the time that was its name, for the live stream at least, is Red Knot, Ruff's New Type Checker.

00:10:45.620 --> 00:10:45.760
Yes.

00:10:45.760 --> 00:10:46.520
It still lasts a week.

00:10:46.640 --> 00:10:47.180
What's going on here?

00:10:47.230 --> 00:10:47.760
Tell me about it.

00:10:47.880 --> 00:10:48.340
Yeah, yeah.

00:10:48.660 --> 00:10:56.460
So when we start a new project, we always develop it under a code name because we don't want to spend a bunch of time trying to figure out the right name up front.

00:10:57.040 --> 00:10:58.820
It takes a lot of time to pick a name.

00:10:59.700 --> 00:11:06.620
And so I shouldn't even say this part on the air, but like UV for a long time, for all of its development, it was called Puffin.

00:11:07.460 --> 00:11:08.880
Puffin, P-U-F-F-I-N.

00:11:09.420 --> 00:11:10.020
Yeah, yeah.

00:11:10.680 --> 00:11:12.920
And the names are always birds.

00:11:13.820 --> 00:11:14.060
And

00:11:14.060 --> 00:11:23.060
it's a little bit of an inside joke, but like I didn't know that when I chose the name Ruff for Ruff, that a Ruff is actually a kind of bird.

00:11:23.820 --> 00:11:29.520
And Mika on our team kept making bird jokes that I didn't understand.

00:11:29.580 --> 00:11:31.360
and I thought it was just being like silly.

00:11:32.230 --> 00:11:32.900
And then eventually

00:11:32.900 --> 00:11:37.260
we had a conversation where he brought up to me that it's a bird and then it finally made sense because I had no idea.

00:11:37.790 --> 00:11:39.580
So now we always use birds for the codename.

00:11:39.780 --> 00:11:41.000
So when

00:11:41.000 --> 00:11:41.340
we started

00:11:41.340 --> 00:11:47.080
the type checker, we used the codename Red Knot and that's really meant to be a codename.

00:11:48.020 --> 00:11:49.540
Although it sort of takes on a life of its own.

00:11:50.140 --> 00:11:54.720
But we're going to release the type checker under a different name, which is TY, just the letters TY.

00:11:56.200 --> 00:11:59.220
So that's what we'll be publishing it on PyPI and everywhere else.

00:11:59.780 --> 00:12:02.660
and that will be, anyway, so we'll have to change the name of the show.

00:12:03.500 --> 00:12:05.160
Yeah, we'll update it. We'll update it.

00:12:07.540 --> 00:12:09.480
Red Knot is now TY is going to have a new title.

00:12:09.650 --> 00:12:10.220
Well, now we'll see.

00:12:10.290 --> 00:12:13.100
Correct. Yes. Yeah, you heard it here first on Talk By Time.

00:12:13.100 --> 00:12:14.040
That's right. That's awesome.

00:12:15.040 --> 00:12:17.320
It keeps with the nice concise names that you got.

00:12:17.840 --> 00:12:19.400
Does TY have anything to do with birds?

00:12:21.120 --> 00:12:21.480
No,

00:12:21.480 --> 00:12:22.320
not to my knowledge.

00:12:23.280 --> 00:12:24.740
Maybe someone will tell us it does. I don't know.

00:12:25.180 --> 00:12:25.380
Yeah,

00:12:25.800 --> 00:12:25.920
exactly,

00:12:26.140 --> 00:12:26.320
Carl.

00:12:26.570 --> 00:12:27.280
In some language,

00:12:27.520 --> 00:12:29.160
it's like a parrot or something. I don't know.

00:12:30.000 --> 00:12:31.220
Yeah, we like names.

00:12:31.540 --> 00:12:39.780
When we go through this exercise of trying to pick a name, I mean, it's super hard and actually probably my least favorite part of the job, which is maybe saying something.

00:12:39.900 --> 00:12:41.680
I mean, it's good that that's my least favorite part of the job.

00:12:42.160 --> 00:12:45.240
But when we try to pick a name, we're looking for a few things.

00:12:45.440 --> 00:12:49.260
We want something that's short and ideally very easy to type.

00:12:50.100 --> 00:12:52.360
That's one of the things that we actually think about a lot.

00:12:54.739 --> 00:12:58.960
And we want something that's kind of distinctive and in some way thematic.

00:12:59.380 --> 00:13:03.040
So we liked TY because we could get it.

00:13:03.420 --> 00:13:04.480
It's very short.

00:13:05.480 --> 00:13:06.180
It's pretty distinctive.

00:13:06.900 --> 00:13:12.760
And it ambiguously ties into lots of different things, like type checking, but it's also an acronym for thank you.

00:13:13.380 --> 00:13:18.140
And so it actually shouldn't really be clear why it's called that, ideally.

00:13:19.340 --> 00:13:20.100
But it has

00:13:20.100 --> 00:13:22.300
a bunch of ambiguous reasons why it could be called that.

00:13:22.570 --> 00:13:23.800
And it's incredibly easy to type.

00:13:24.280 --> 00:13:28.000
And you get to write TY space check to take your types, which is somewhat invaluable.

00:13:29.440 --> 00:13:34.780
Well, I do think that having a short CLI command is an ergonomics thing, right?

00:13:35.110 --> 00:13:35.780
It is useful.

00:13:35.830 --> 00:13:35.940
Yes.

00:13:36.940 --> 00:13:37.100
Yes.

00:13:37.560 --> 00:13:52.100
I did find out this morning from David on our team, who's in Germany, that he was confused why we kept saying TY was easy to type because apparently on a German keyboard, the Y and the Z are swapped, and so the Y is kind of like way off to the

00:13:52.100 --> 00:13:52.360
side.

00:13:52.630 --> 00:13:53.160
For real?

00:13:53.940 --> 00:13:54.100
Wow.

00:13:54.240 --> 00:13:54.960
I have to apologize

00:13:54.960 --> 00:13:59.140
in advance to all of our German keyboard users that it won't be quite as easy to type for you.

00:13:59.380 --> 00:14:00.080
That's interesting,

00:14:00.270 --> 00:14:00.380
yeah.

00:14:00.550 --> 00:14:02.760
So what are you guys going to do if they download it like a thousand times?

00:14:02.860 --> 00:14:04.640
You'll send them like an alternate keyboard or something?

00:14:05.380 --> 00:14:06.420
Yeah, yeah.

00:14:06.630 --> 00:14:08.180
We have multiple people on the team in Germany.

00:14:10.020 --> 00:14:10.740
We'll publish

00:14:10.740 --> 00:14:10.940
a short term.

00:14:10.940 --> 00:14:12.000
I'm glad we figured that out first.

00:14:12.000 --> 00:14:12.660
Swapster ZNY.

00:14:13.820 --> 00:14:14.000
Yeah.

00:14:15.260 --> 00:14:20.500
Yeah, when I lived in Germany, one of my concerns was I was changing jobs and stuff.

00:14:20.500 --> 00:14:23.300
I'm like, oh, please don't make me buy a MacBook here.

00:14:23.980 --> 00:14:24.300
Please.

00:14:24.880 --> 00:14:25.720
I can't handle the keyboard.

00:14:26.440 --> 00:14:27.040
I got to get one

00:14:27.040 --> 00:14:27.720
with the

00:14:27.720 --> 00:14:34.580
layout that I'm used to, which I guess wherever you are, that probably that goes for saying, but luckily I got to keep my US layout.

00:14:36.710 --> 00:14:38.560
I mean, we should all be using Dvorak anyway.

00:14:38.700 --> 00:14:40.560
We're all doing it wrong in just slightly different ways.

00:14:41.400 --> 00:14:41.760
Right.

00:14:42.280 --> 00:14:42.640
Yeah.

00:14:42.880 --> 00:14:43.240
So

00:14:43.240 --> 00:14:53.800
Rednaught is now TY, and that has been a major focus for, not the name, but the project itself, has been a major focus for our team for the past, wow, a while.

00:14:54.480 --> 00:14:56.780
Almost a year, maybe a little bit less.

00:14:57.480 --> 00:14:59.580
But we've been working on this for a long time.

00:15:00.120 --> 00:15:02.720
So I'm excited that we're in a position where we can finally start talking about it.

00:15:03.520 --> 00:15:03.840
Yeah.

00:15:04.920 --> 00:15:05.300
I'm excited.

00:15:05.600 --> 00:15:07.760
When I saw it, I'm like, oh, I have to have you guys on the show.

00:15:08.000 --> 00:15:09.720
We got to talk about this because this is a big deal.

00:15:10.300 --> 00:15:14.560
So let's just start by talking about why a type checker at all.

00:15:14.660 --> 00:15:16.020
We've had a couple of type checkers.

00:15:16.460 --> 00:15:21.220
There's a few benefits you can get from them, but I'll let you all riff on that a bit.

00:15:21.640 --> 00:15:22.320
Like, why do we care?

00:15:22.720 --> 00:15:24.380
Python itself is a dynamic language.

00:15:25.000 --> 00:15:26.000
Let the ducks be ducks.

00:15:26.200 --> 00:15:26.900
What are we doing here?

00:15:27.680 --> 00:15:27.860
Yeah.

00:15:28.540 --> 00:15:29.240
Carl, would you like to

00:15:29.240 --> 00:15:29.560
take

00:15:29.560 --> 00:15:30.420
a stab at that?

00:15:32.500 --> 00:15:32.700
Sure.

00:15:32.960 --> 00:15:35.400
I mean, I think Python gets used in a lot of different ways.

00:15:36.400 --> 00:15:47.640
And I think compared to the initial vision for Python back in 1990 or whenever Guido released the first version, it's used for a lot bigger projects and more

00:15:47.640 --> 00:15:48.280
sort

00:15:48.280 --> 00:15:52.320
of serious software engineering than it was maybe initially envisioned to be for.

00:15:53.060 --> 00:16:13.140
and I think when you get larger projects, larger amounts of code, larger numbers of people working on the projects, there can be a lot of value in having some machine enforceable documentation about your intention when you wrote this function. What were you envisioning that it should operate on? What were you envisioning that it should return?

00:16:13.740 --> 00:16:14.400
I know

00:16:14.400 --> 00:16:33.080
certainly when I was at Instagram and working on the very large Python code base there and thousands of developers with a lot of turnover coming in and out of that project, you can waste a lot of time digging kind of through layers and layers of code, just trying to understand even what is this variable?

00:16:33.300 --> 00:16:34.020
Where could it come from?

00:16:34.260 --> 00:16:35.000
What could it look like?

00:16:35.740 --> 00:16:39.760
And a type annotation can give you that information kind of just right up front immediately.

00:16:40.300 --> 00:16:42.860
So there can be a lot of value in that.

00:16:43.020 --> 00:16:51.260
And certainly I don't think anyone, or at least we are not aiming to change Python into a fully statically typed language.

00:16:51.500 --> 00:16:54.060
I don't think that would be possible or desirable.

00:16:54.360 --> 00:16:57.880
It's great to have that flexibility for a continuum of use cases.

00:16:59.400 --> 00:17:09.560
But for those who want to have types available and type enforcement, we can make that available in an opt-in kind of gradual way.

00:17:10.520 --> 00:17:10.959
Yeah.

00:17:12.209 --> 00:17:18.520
Yeah, I think, and there's a couple of different elements to it, all of which Carl touched on in some way.

00:17:18.680 --> 00:17:24.600
but one helps prevent you from shipping bugs, helps you write correct code.

00:17:25.650 --> 00:17:38.900
But the other piece is, I think the types and the typing have actually played more and more of a role over time because what you end up getting is the way that the types feed into the editor experience.

00:17:39.480 --> 00:17:54.920
So it's not just about running a type checker to check that your code is correct, but I actually talked to teams that don't even run a type checker, but they still add type annotations to their code because when they add type annotations to the code, the editor is more useful to them.

00:17:55.090 --> 00:17:58.720
Like the auto-completion is better and they get real-time diagnostics.

00:17:58.980 --> 00:18:09.980
So even if you're not actually running a type checker on your code for whatever reason, like adding types to your code can actually make you more productive by integrating with the language server and the editor.

00:18:10.600 --> 00:18:13.820
So I don't know, for me, it's actually a really big part of how I write Python.

00:18:14.880 --> 00:18:21.120
I try to write pretty stupid Python and do that with a fair number of types.

00:18:21.900 --> 00:18:23.680
And I find that that's what helps me scale.

00:18:24.960 --> 00:18:25.920
So I don't know.

00:18:26.020 --> 00:18:40.660
I think the typing, it's useful both in the context of I want to run this in CI and make sure that I'm not shipping code that has obvious problems and in the context of how do I make myself just more productive when I'm sitting in my editor writing code trying to figure out how to implement a given function.

00:18:41.840 --> 00:18:45.720
I was going to jump in and say that, but you articulated it very well.

00:18:45.830 --> 00:18:46.200
For me,

00:18:46.250 --> 00:18:48.300
I don't run

00:18:48.300 --> 00:18:51.660
a type checker, but I want my editor.

00:18:53.080 --> 00:18:59.820
If I am going to the documentation for stuff that I kind of understand how it works, I'm probably doing it wrong in my mind.

00:19:01.100 --> 00:19:05.620
If I see star args, star, star, kwrgs, and I'm just like, what am I going to do?

00:19:05.740 --> 00:19:10.980
But most of the time you can just hit dot or parenthesis, and then there's all the information.

00:19:11.560 --> 00:19:17.480
provided either the editor can detect the type somehow through some chain or you just type them there.

00:19:17.860 --> 00:19:18.060
And then

00:19:18.060 --> 00:19:18.740
it's just bam, bam,

00:19:18.900 --> 00:19:19.020
bam.

00:19:20.260 --> 00:19:24.400
And until you kind of don't understand stuff or it's really new, then you maybe go to the docs.

00:19:24.620 --> 00:19:26.460
But like you're saying, you can just fly.

00:19:26.470 --> 00:19:30.780
And I will throw out a new one that is now relevant in the last couple years.

00:19:31.960 --> 00:19:36.820
If I am going to take some Python code and share it with an AI of some

00:19:36.820 --> 00:19:37.120
variation,

00:19:38.040 --> 00:19:48.220
some agent code generator or chat or whatever, If that code has types in it, it's way better because it probably doesn't have the possibility of getting the right context otherwise.

00:19:49.080 --> 00:19:49.180
Right.

00:19:49.870 --> 00:19:50.740
Yeah, that's a big part.

00:19:50.820 --> 00:20:06.400
And it also creates a feedback loop for if you are running like an agent or if you're using like cursor or cloud code or one of those systems, you actually create a feedback loop whereby they can iterate on the code without executing it, right?

00:20:06.540 --> 00:20:12.160
Because they can run your code, run it through a type checker, look at the diagnostics, and then modify it in turn.

00:20:12.420 --> 00:20:25.760
So it's like, I sort of think some of this stuff will potentially become like even more important, like the static, providing good static analysis because it's your opportunity as a human to like hit the computer in a given way and inject

00:20:25.760 --> 00:20:26.020
some

00:20:26.020 --> 00:20:26.420
context.

00:20:26.910 --> 00:20:27.620
So I mean, we'll see.

00:20:27.650 --> 00:20:29.280
I could be completely wrong about that.

00:20:29.680 --> 00:20:33.880
But I at least find it to be really helpful in those contexts too.

00:20:36.400 --> 00:20:40.520
Yeah, I see some comments out there in the chat that I like. Yeah, same thing.

00:20:43.740 --> 00:21:10.200
I also, you know, I liked Carl's comments that sort of for large real projects, you know, you can opt into this. And I like, one of the powers of Python, I think, I guess, to put it this way, is I feel like you can be incredibly productive and you can get a lot done with Python with a very partial understanding of what it is, like incredibly partial, right?

00:21:10.400 --> 00:21:22.380
You don't have to know what a class is, maybe not even a function, but if you can string together 10 lines of interacting with some library, you might have accomplished something that would make you, wow, I'm not a programmer, but look what it did.

00:21:24.139 --> 00:21:42.620
And that's great that it has that level, but as it grows bigger and more serious, I've heard the comment from somebody on some podcast somewhere, like they were lamenting the fact that there's so much Python in data science, machine learning.

00:21:42.820 --> 00:21:45.120
They're like, oh, this is a language for unserious people.

00:21:46.140 --> 00:21:53.340
Well, it can be used in an unserious way, but things like this are part of like, I choose to use it in a serious way, right?

00:21:53.820 --> 00:21:54.040
It's

00:21:54.040 --> 00:21:55.660
not a flaw of

00:21:55.660 --> 00:21:55.740
it.

00:21:55.860 --> 00:22:02.860
It's actually a power of it that when you don't need a systems-level language, you don't have to write systems-level code.

00:22:03.100 --> 00:22:09.020
But when you're ready to, you can sort of progressively add on these layers and run things like Ty to check it.

00:22:09.570 --> 00:22:09.680
Wait,

00:22:09.690 --> 00:22:10.380
is that, do

00:22:10.380 --> 00:22:11.200
we TY or TY?

00:22:11.490 --> 00:22:12.560
Yeah, TY, TY,

00:22:12.810 --> 00:22:13.220
Michael, come on.

00:22:13.410 --> 00:22:27.540
No, that, you know, it's funny that you say that because like that's off, that is sometimes how I think about actually like what we're trying to do here, like with this company and this, this like set of projects in the first place, which is Python is this like enormous programming ecosystem.

00:22:28.060 --> 00:22:32.280
Like, like the largest or the second largest programming ecosystem on earth.

00:22:32.760 --> 00:22:39.400
And like, and yet like there's a lot of people who just don't take it very seriously or like are constantly predicting its demise.

00:22:39.720 --> 00:22:40.720
And yet it just like keeps growing.

00:22:41.580 --> 00:22:45.460
And so like our, my approach has generally been, well, what if we just like take it really seriously?

00:22:46.800 --> 00:22:46.880
Like

00:22:46.880 --> 00:22:47.380
we'll just bring

00:22:47.380 --> 00:22:48.799
in the smartest people.

00:22:49.500 --> 00:22:55.460
Hopefully I'll try to recruit the smartest people I can come in and build like really serious software.

00:22:56.160 --> 00:23:03.180
And the net effect is like you can have an enormous impact because we build, like I was talking about UV, right?

00:23:03.280 --> 00:23:09.280
Like we build UV and suddenly we have like hundreds of millions of requests running through that project a day.

00:23:09.400 --> 00:23:18.560
And so you just think about the scope of impact because Python may not be a perfect language, but a lot of programming and technology is about path dependence, right?

00:23:18.900 --> 00:23:18.980
Like

00:23:18.980 --> 00:23:19.500
people,

00:23:20.140 --> 00:23:20.940
it's very hard.

00:23:21.070 --> 00:23:26.200
Like Python is going to continue to be used in tons of places, even if, you know, despite its problems.

00:23:26.690 --> 00:23:33.480
And so my perspective has always been, well, how can we like meet that world where it is and like try to build really great tooling?

00:23:33.770 --> 00:23:36.660
Because the amount of impact, it's like a huge lever.

00:23:38.140 --> 00:23:38.980
So yes, I feel

00:23:38.980 --> 00:23:42.760
that way about like kind of everything we build, but it was funny to hear you say it.

00:23:42.770 --> 00:23:52.200
And we, you know, we spend a lot of time now with companies that are like have hundreds and hundreds of engineers, like Python programmers working on a single code base.

00:23:53.000 --> 00:23:57.180
And yeah, for them also, the performance is a big piece of it.

00:23:57.360 --> 00:24:02.740
So how do they get these tools to scale to very large projects?

00:24:03.160 --> 00:24:15.820
And our goal is to basically build tooling that can scale to very large projects, but is also useful and helpful for people like beginners and people working on very small projects.

00:24:16.120 --> 00:24:21.760
We want to have something in the tool that's useful and valuable to both of those demographics, which are very different.

00:24:21.920 --> 00:24:27.280
So we often think about building for scale, but designing for everyone.

00:24:27.640 --> 00:24:29.300
We want to build a tool that can

00:24:29.300 --> 00:24:29.640
scale

00:24:29.640 --> 00:24:41.800
to tens of millions plus lines of code, but it's also meets a beginner where they are and helps them get started and get productive with Python.

00:24:42.620 --> 00:24:43.300
Yeah, that's awesome.

00:24:44.420 --> 00:24:45.920
So either one of you want to take this one.

00:24:47.850 --> 00:24:49.380
So we understand why types are important,

00:24:49.910 --> 00:24:50.000
but

00:24:50.000 --> 00:24:50.480
why

00:24:50.480 --> 00:24:52.760
are you all building a type checker, right?

00:24:52.880 --> 00:24:55.900
We have MyPy, MyPyRite, right?

00:24:58.160 --> 00:24:58.520
Yes.

00:25:00.580 --> 00:25:01.160
Carl, do you want

00:25:01.160 --> 00:25:01.620
me to go?

00:25:03.760 --> 00:25:05.060
Either way, I can take that one.

00:25:05.680 --> 00:25:06.340
I mean, you know

00:25:06.340 --> 00:25:06.940
why you decided

00:25:06.940 --> 00:25:07.720
to build a type checker.

00:25:08.300 --> 00:25:10.100
Why don't I say why I decided that we should build

00:25:10.100 --> 00:25:10.400
a type

00:25:10.400 --> 00:25:12.680
checker, and then we'll see what Carl says.

00:25:13.600 --> 00:25:18.940
So I think for me, like when I, there's a couple of pieces to it.

00:25:19.020 --> 00:25:28.620
One is like when I started working on Ruff and then I started the company, there was always a vision in my mind of this like unified set of tools that we wanted to build and put together.

00:25:29.460 --> 00:25:43.340
And we did the linter and then we did the formatter and the type checker was kind of like always the missing piece there of, well, if I had like a suite of static analysis tools that handled everything for my project, I would want like a linter, a formatter and a type

00:25:44.200 --> 00:25:44.680
and

00:25:44.680 --> 00:26:44.780
we didn't have that and I was like I think that would really help complete the story for what we're trying to provide to people so one piece was this is the experience we want of like you can use astral's tools it like gives you everything you need really to be productive with python but the other piece is this has been the thing that people have asked me for probably more than anything else ever since we released rough so um uh I think it's natural that people would ask for it because this is like sort of in a similar space of things that you do like but everyone's saying hey i'm having problems with my type checker i'm having problems with my type checker when i switch to rough i experienced this great this change and how i work can you bring that same experience to to type checking and um you know i think for me the answer was like yeah we absolutely can i don't see any reason why we can't provide the same like level of quality of life improvement for people um so you know part of it was i saw a big opportunity And within that opportunity, I think there were like two things that really stuck out to me.

00:26:45.320 --> 00:26:47.060
One was performance.

00:26:48.740 --> 00:26:52.940
And this is more about people working, you know, companies that we talk to where they're working on really large projects.

00:26:53.780 --> 00:26:56.020
Your little demo app probably is going to be fine either way.

00:26:56.320 --> 00:26:57.000
Yeah, that was fine.

00:26:57.240 --> 00:26:57.340
Yeah.

00:26:57.500 --> 00:27:04.380
But like the, you know, if you have a really, if you have a big company with a lot of people working on a Python project, this comes into play in a couple of different ways.

00:27:04.640 --> 00:27:10.640
One is like some companies can't even really run the type checker locally anymore, or they're spending a lot of money running it on huge machines.

00:27:11.600 --> 00:27:12.420
That's a real thing that happens.

00:27:14.300 --> 00:27:18.940
Other times it's the language server, the thing that lives in your editor that gets slowed down.

00:27:19.050 --> 00:27:24.020
So we'll talk to companies where like, they're like the language server can't index our project anymore.

00:27:24.210 --> 00:27:26.220
So go to definition doesn't work.

00:27:27.260 --> 00:27:27.480
Or

00:27:27.480 --> 00:27:29.200
every time I change branches.

00:27:29.680 --> 00:27:29.960
Yeah.

00:27:30.180 --> 00:27:32.140
Let me throw a little background information on there.

00:27:32.660 --> 00:27:48.040
For people who don't know, the way your editor autocompletes, goes to definition, and all that kind of stuff is there's this language server that parses and understands the code almost like an abstract syntax tree, and it needs to read all of the code and

00:27:48.040 --> 00:27:48.800
allow you to

00:27:48.800 --> 00:27:53.160
basically use that live information as you interact with it.

00:27:53.800 --> 00:28:01.140
What you're saying, Charlie, is if it's too big, then basically it's always behind or just can't quite handle it.

00:28:01.640 --> 00:28:02.320
It's always behind or

00:28:02.320 --> 00:28:04.420
it can't fit all the context into the system

00:28:04.420 --> 00:28:05.620
or something like that.

00:28:05.890 --> 00:28:07.580
And what you're hinting at is you might fix this.

00:28:08.440 --> 00:28:09.360
Yeah, we want to fix that.

00:28:09.430 --> 00:28:10.880
So it's not just about building a type checker.

00:28:10.890 --> 00:28:12.220
We also want to build a language server.

00:28:12.310 --> 00:28:18.180
And these two things are like intimately related, like PyLance, which is a very popular language server.

00:28:18.450 --> 00:28:24.700
You might not even know you're using it, but it's like the primary language server in VS Code is powered by PyRite, which is another type checker.

00:28:24.830 --> 00:28:26.780
And those tools are very interconnected.

00:28:26.940 --> 00:28:36.280
It's like when you try to auto-complete something in your editor, the editor needs to go through a process of understanding, well, what are the valid options that could fit here?

00:28:36.700 --> 00:28:39.620
And that is similar in shape to a type-checking problem.

00:28:40.420 --> 00:28:49.180
So part of it was performance of seeing these huge projects and all these companies that were coming to us saying we're having all these problems with the scaling of the tooling to our projects.

00:28:49.940 --> 00:28:55.000
And the other was the ability to build, I think, a really different experience by integrating more of our tooling.

00:28:55.400 --> 00:29:42.660
like we've thought about this with rough which is a linter and then rough you know we have like rules that for example should only run on dictionaries and so we might need to understand like could this object be a dictionary in order to know whether we should flag a certain rule and right now we do basically like bad unreliable things to understand like is this variable could it be a dictionary and if you kind of take that to an extreme you could imagine we could build a much better linter if we actually had access to type information. If we knew what all the variables were in the program and what types they could take on, we could give people much better information about the problems that they have. So part of it was performance. Part of it was this opportunity to build something that I thought was really different. Carl, I want to hear from you, though.

00:29:44.280 --> 00:29:54.660
Yeah, no, I think those are the primary motivations. Performance, for sure. I think we're already seeing that we can be quite a lot faster than the existing type checkers.

00:29:55.260 --> 00:30:05.520
I think another thing that's become clear as we've worked on TY is that there are areas where we do want to provide a little different experience than some of the existing type checkers.

00:30:05.880 --> 00:30:22.960
And I think this connects to what we were talking about before about the way Python scales with you as a project grows and the way you can kind of start out with something quick and simple and realize it's successful and grow to make it bigger and kind of gradually opt in to stricter typing.

00:30:24.240 --> 00:30:45.000
One thing that has been part of the experience in Python typing up until now is that even though it's supposed to be something that you can gradually adopt, the reality has been that if you have a code base that's working but isn't really typed and you start to run a type checker on it, you'll probably get a pretty long list of type errors the first time that you run it.

00:30:45.440 --> 00:30:55.420
And you really have to spend a lot of time adding type annotations and even reworking the way some of your code works in order to make the type checker even happy with your code.

00:30:55.840 --> 00:31:11.980
Because the type checkers, for various reasons, they're sort of opinionated often and making kind of assumptions about, well, if you assigned an integer to this variable here, then clearly you never meant to ever assign anything else to that same variable later in the function or whatever.

00:31:12.200 --> 00:31:16.140
And so you sort of have to adjust your code to work around the assumptions the type checker is making.

00:31:17.200 --> 00:31:32.340
And one thing that we're aiming to do with TY is to try to smooth that curve a little bit in the sense that we try not to make assumptions about what you meant and rely on what you've explicitly told us about your types.

00:31:32.580 --> 00:31:47.660
so that if you run it on a code base that isn't typed, but that is working correctly, we'd like to not issue a bunch of false positive errors right off the bat and just start to issue errors gradually as you start to gradually add type annotations.

00:31:49.120 --> 00:31:50.720
Yeah, I think it makes a lot of sense.

00:31:50.840 --> 00:31:54.780
We talked about the different motivations and reasons that people might use types.

00:31:56.020 --> 00:32:02.260
And so I can certainly see why that would lead to different expectations or rules or whatever from your tools.

00:32:02.400 --> 00:32:32.020
right? If you're adding types so that your editor is better or so you can talk to AI better, you might not want it to be just super complaining at you that every little thing is wrong. I know on some of the projects that I run, I did some decorator and the decorator was just, it was super complicated because it can do both sync and async functions. And it just somehow I got the type, it's just a little bit wrong, but I didn't ever notice it. You don't ever call the view functions.

00:32:32.680 --> 00:32:34.480
directly in your code because

00:32:34.480 --> 00:32:36.100
that's

00:32:36.100 --> 00:32:37.120
what the frameworks call, right?

00:32:37.680 --> 00:32:40.200
When you put the, you know, at get on it or whatever.

00:32:40.960 --> 00:32:50.040
However, some people running that through the type checker are sending me these things, say, well, look, you're getting this warning for using this decorator here.

00:32:50.160 --> 00:32:53.660
I'm just like, okay, I'm going to fix this fine and understand that.

00:32:53.820 --> 00:32:53.880
But,

00:32:54.420 --> 00:32:54.980
you know, is the

00:32:54.980 --> 00:33:02.120
type checker actually helping you to say, we expected the thing that you never called to look like this, but it looks slightly different.

00:33:02.380 --> 00:33:05.920
Like, well, you know, tree falls and forest, no one's there kind of thing, right?

00:33:09.860 --> 00:33:18.560
Yeah, so I guess I pulled up this GitHub issue here on Ruff, and this points to two questions I want to get to.

00:33:19.900 --> 00:33:21.480
The one on the screen is not the first one.

00:33:21.620 --> 00:33:22.180
That's the second one.

00:33:22.580 --> 00:33:22.900
The first

00:33:22.900 --> 00:33:24.040
one is, will

00:33:24.040 --> 00:33:30.660
this be part of Ruff, or is TY its own separate, you know, UV tool install type thing?

00:33:30.860 --> 00:33:32.360
How will I manage it, right?

00:33:33.380 --> 00:33:33.780
We're

00:33:33.780 --> 00:33:34.180
initially

00:33:34.180 --> 00:33:34.780
planning to...

00:33:34.880 --> 00:33:35.400
Oh, go ahead, Charlie.

00:33:36.120 --> 00:33:36.400
No, you

00:33:36.400 --> 00:33:36.600
got it.

00:33:37.540 --> 00:33:37.840
Yeah, yeah.

00:33:37.860 --> 00:33:40.440
We're planning to release it as a separate tool.

00:33:40.640 --> 00:33:47.940
So you'd install it separately, and UV tool install TY or UV install TY, and then run it as TY.

00:33:50.020 --> 00:33:50.120
Yeah.

00:33:50.580 --> 00:33:50.680
Okay.

00:33:51.180 --> 00:33:52.500
Because it came out...

00:33:52.500 --> 00:33:56.600
I feel like its motivation, as you are saying as well, came out of Ruff, right?

00:33:56.860 --> 00:33:58.100
The linter and formatter.

00:33:58.760 --> 00:34:05.220
But as you thought about it, I guess, this is actually its own thing now, right?

00:34:05.260 --> 00:34:08.840
But if you look at all the GitHub issues, a lot of them are on RUF, actually.

00:34:09.560 --> 00:34:17.899
Yeah, it's currently built in the RUF code base, so they share a code base, and that's mostly just for convenience because we share a lot of common infrastructure with RUF.

00:34:17.960 --> 00:34:23.520
So the parser and the abstract syntax tree and all of that are shared between RUF and TY.

00:34:26.260 --> 00:34:45.879
But yeah, and we initially did consider the possibility that we would develop the type checker kind of more under the covers in rough and sort of gradually start to power more and more rough lint rules with type information without really shipping a type checker per se.

00:34:46.760 --> 00:34:57.680
But we kind of debated those two options and decided that it just really seemed like there was a high demand for a type checker, a full type checker like MyPy or PyRite.

00:34:58.230 --> 00:35:06.380
And we thought we could reach that goal more efficiently and quickly if we did it a little more separately from rough at the product level.

00:35:08.880 --> 00:35:09.560
Makes sense to me.

00:35:10.880 --> 00:35:11.100
All right.

00:35:11.290 --> 00:35:12.720
Now the real question I actually have on the screen.

00:35:13.540 --> 00:35:18.080
Will Redknot, aka TY, because that was the codename, right?

00:35:18.900 --> 00:35:19.340
Will

00:35:19.340 --> 00:35:23.440
TY be a drop-in replacement for MyPy or PyRite?

00:35:25.180 --> 00:35:27.940
Pretty sure Carl has a very good answer in this thread.

00:35:28.090 --> 00:35:30.440
Carl, do you want to answer the question?

00:35:30.440 --> 00:35:30.680
I mean, I

00:35:30.680 --> 00:35:32.220
think you can talk or you can just scroll down.

00:35:35.640 --> 00:35:36.100
Oh, wow.

00:35:36.960 --> 00:35:37.400
That's

00:35:37.400 --> 00:35:37.800
the answer.

00:35:38.150 --> 00:35:38.280
Okay.

00:35:39.700 --> 00:35:40.520
The answer is no.

00:35:41.980 --> 00:35:42.700
Spoiler alert.

00:35:42.820 --> 00:35:45.100
The answer is no, it will not be a drop-in.

00:35:45.580 --> 00:35:51.720
I don't think we will brand it as a drop-in replacement because I don't think we will feel that it will be a drop-in replacement.

00:35:54.600 --> 00:35:55.980
Yeah, we're making different design choices.

00:35:56.840 --> 00:35:57.160
Yeah.

00:35:58.380 --> 00:35:59.000
Yeah, but I

00:35:59.000 --> 00:36:02.080
feel, I guess my feeling, I mean, there will definitely be differences.

00:36:05.020 --> 00:36:13.000
I think my, the thing I'm slightly buoyed by, and Carl is in a much better position to comment on whether this is actually true.

00:36:14.320 --> 00:36:24.740
But from my perspective, at least, a focus area for typing in Python broadly as an ecosystem has been increased conformance.

00:36:24.990 --> 00:36:42.860
So trying to create rigorous specifications around how some of the typing features that are a little underspecified should work, and then ensuring that the type checkers can implement common behaviors on not all dimensions, but on some of those dimensions.

00:36:43.150 --> 00:36:57.100
I think there's still, my feeling is the intent is still that there's actually room for some subjectivity in how type checkers work, but that in a lot of areas, they actually want to standardize how things are supposed to work so that there can be less deviation.

00:36:58.380 --> 00:36:58.700
Yeah, particularly

00:36:58.700 --> 00:37:00.800
when

00:37:00.800 --> 00:37:04.480
it comes to typing a public API for like a library

00:37:04.480 --> 00:37:04.900
author.

00:37:05.660 --> 00:37:10.740
I mean, if you just have your own project that you're running your type checker on, you're probably going to pick one type checker and run it.

00:37:10.820 --> 00:37:13.260
And so it's okay if it behaves differently from some other ones.

00:37:13.690 --> 00:37:23.480
But if you have a popular library and you want to provide types for your library, you may have some users of your library using MyPy and some using PyRite and some are going to use TY.

00:37:24.140 --> 00:37:33.360
And so we need to, in particular, have some standardization in the type system that allows a library author to provide types for their library that will actually work for all their users.

00:37:34.460 --> 00:37:48.100
And so in TY, we do aim to pass, we don't yet, we're not at that stage yet, but we do aim to pass the conformance suite for the Python typing specification and be a standards conformant type checker.

00:37:48.520 --> 00:38:03.660
There may be some points of tension where we have a different opinion about how some things should be done, and we'll probably have some discussions there about changing or suggesting some possible changes to the spec in some areas, but we will aim to be conformant.

00:38:05.760 --> 00:38:16.440
yeah that's excellent I was just messing with my rough.toml for one of my projects are you going to have a tie.toml or something like that that we can tweak the rules

00:38:17.220 --> 00:38:17.560
oh

00:38:17.560 --> 00:38:17.800
yeah

00:38:20.220 --> 00:38:20.960
currently we already

00:38:20.960 --> 00:38:21.260
have a

00:38:21.260 --> 00:38:21.840
not

00:38:21.840 --> 00:38:25.100
.json which I think probably needs to become tie.json

00:38:26.060 --> 00:38:27.240
or I guess it's tie.not

00:38:27.240 --> 00:38:30.520
.toml so it'll be tie.toml yeah I think it's json

00:38:30.520 --> 00:38:31.500
in the web

00:38:31.500 --> 00:38:34.080
playground because we

00:38:34.080 --> 00:38:35.580
have a web playground for this stuff.

00:38:36.000 --> 00:38:36.260
And

00:38:36.260 --> 00:38:37.040
in those

00:38:37.040 --> 00:38:39.140
contexts, it's much easier to...

00:38:40.420 --> 00:38:45.180
I think you can have a JSON schema, so it's much easier to use JSON also because it's all natively built.

00:38:45.460 --> 00:38:47.500
JavaScript just supports JSON natively and everything.

00:38:48.960 --> 00:38:50.380
Yeah, yeah. Excellent.

00:38:50.880 --> 00:38:53.340
A couple of thoughts here from the audience.

00:38:53.620 --> 00:38:54.300
Let's jump over there.

00:38:54.330 --> 00:38:56.180
Richard Ellison asks, this sounds awesome.

00:38:56.520 --> 00:38:58.320
What will the client setup look like?

00:38:58.980 --> 00:39:00.220
Will it all be server-side?

00:39:00.520 --> 00:39:01.780
Please don't put magic into the client.

00:39:01.860 --> 00:39:06.180
like PyLance does with PyRite NeoVim user here, by the way.

00:39:09.320 --> 00:39:30.860
I wish some of our other developers here who work on the LSP stuff more were here to answer this one, but I think we're aiming to just follow the LSP standard and not put magic into the extension for, say, VS code that wouldn't be something you could replicate on NeoVim or any other editor that

00:39:30.860 --> 00:39:31.560
uses LSP.

00:39:32.080 --> 00:39:43.380
Yeah, I mean, a core goal for us here is like, I mean, this will, of course, be open source and permissively licensed just like our other tools.

00:39:45.620 --> 00:39:48.960
I guess it's probably MIT right now, just by way of being in RUV.

00:39:49.080 --> 00:39:52.140
UV is dual MIT in Apache, but RUV is MIT.

00:39:52.330 --> 00:39:55.000
So I think that implicitly this is all MIT.

00:40:00.220 --> 00:40:09.260
An explicit goal here is by building an open source language server, it should be possible to use it in any editor that supports language server protocol equally well.

00:40:09.840 --> 00:40:23.440
So if you have people on your team using NeoVim, VS Code, whatever, Zed, any of these editors, you should be able to plug in our LSP and get an equally good experience in all of them.

00:40:25.220 --> 00:40:39.320
So I actually view that as a big advantage and reason to do this, which is that I think we can build a language server that you can use in any editor and have the same experience across your team and on the command line.

00:40:39.920 --> 00:40:47.220
So yes, we want it to be like, it's very intentional that we don't want there to be any magic in the server or whatnot.

00:40:47.460 --> 00:40:53.380
We want this to just be a thing that implements language server protocol that you can use from any editor that supports it.

00:40:54.460 --> 00:40:55.300
I guess

00:40:55.300 --> 00:41:03.100
the analogy would be like Rust Analyzer, which maybe isn't actually a great analogy for this audience because it entirely depends on whether you've written Rust before.

00:41:04.040 --> 00:41:08.120
But Rust Analyzer is the Rust language server, and you can use

00:41:08.120 --> 00:41:09.120
that in

00:41:09.120 --> 00:41:11.220
any editor, and it works great.

00:41:12.080 --> 00:41:12.720
Nice. All right.

00:41:13.060 --> 00:41:15.240
Other question I thought was good is Andrew out there.

00:41:15.340 --> 00:41:16.240
I just started listening.

00:41:17.340 --> 00:41:21.600
Will this be accessible as a library from the Python side?

00:41:21.980 --> 00:41:24.280
It could be interesting to be able to write scripts against types.

00:41:25.780 --> 00:41:28.520
yeah we're just like laughing you go Carl

00:41:30.060 --> 00:42:01.680
I mean my answer to this one would be that I don't see any strong technical barriers to this we already sort of have an internal API where you can just say given an expression in the AST what is its type and so exposing that to Python should be technically not too difficult I think the challenges here are just prioritization of that versus other things and wanting to be a little careful about what we lock ourselves into API-wise.

00:42:03.300 --> 00:42:03.640
So I

00:42:03.640 --> 00:42:04.260
would say it

00:42:04.260 --> 00:42:06.100
should be possible, but not an immediate priority.

00:42:06.760 --> 00:42:07.020
Sure.

00:42:07.440 --> 00:42:11.880
What about plugins or extensions or extensibility, something like that?

00:42:12.840 --> 00:42:13.920
I'm going to let Charlie take that one.

00:42:14.820 --> 00:42:15.780
No, probably not.

00:42:15.960 --> 00:42:16.700
No, unlikely.

00:42:17.800 --> 00:42:20.640
I think plugins and extensions are somewhat unlikely.

00:42:24.960 --> 00:42:37.980
I mean maybe like I think I think we would prioritize like plugins and extensions for like lint rules over like type inference which is sort of a fuzzy line to draw but

00:42:37.980 --> 00:42:38.660
like a lot of people

00:42:38.660 --> 00:42:45.500
want plugins and extensions in rough often to do things that are they want to identify certain patterns or whatnot and like I think we

00:42:45.500 --> 00:42:46.080
would support that

00:42:46.320 --> 00:42:48.480
before we supported extensions in the type checker

00:42:50.140 --> 00:42:56.720
sure like we want to detect this general usage pattern that is yeah or like this library like

00:42:56.720 --> 00:43:00.800
should never be imported in this part of the code base or like this

00:43:00.800 --> 00:43:01.880
function should

00:43:01.880 --> 00:43:19.160
never be called without like first calling this function or something like that like sort of what i think of as like proprietary rules basically like things that are very specific to your project um but carl what's the thing that David implemented, the Python typing, the import? Oh, so

00:43:19.160 --> 00:43:21.480
we have a module.

00:43:22.280 --> 00:43:32.960
It's kind of a fake module because it doesn't exist in Python. It just exists in the mind of TY. It's currently called not extensions. I suppose we'll probably rename it to TY extensions.

00:43:33.740 --> 00:43:49.360
But it has a bunch of interesting tools in it that you can kind of import and use to to sort of ask the type system what it thinks of a type of a certain value is, or make some assertions that this type is a subtype of this other type.

00:43:49.920 --> 00:44:01.500
So if you're kind of interested in getting into the nitty gritty of what's happening under the hood with the type system, we do expose some, something you can import and use in your code to do

00:44:01.500 --> 00:44:02.060
some of those things.

00:44:02.160 --> 00:44:08.300
Yeah, it's a little different, but it's, yeah, but it's sort of vaguely at the intersection of importing.

00:44:09.200 --> 00:45:17.840
something. In terms of plugins, I think, at least on the type checker side, there's sort of both philosophical and technical reasons to be pretty cautious. Like philosophically on the type system side, I think we believe that there is value in having a specified and standardized type system that's the same for everybody. And so that you can have a project that's using one type checker and decide to switch to another one. And we don't really want to have, so plugins are kind of antithetical to that in the sense that if you have a plugin, it's clearly specific to one type checker. And then if you're relying on that plugin, well, then that's kind of a barrier to be able to switch to a different type checker. And so I think we have a preference for having, if there's patterns that people need, we should find a way to include those in the typing specification so that all type checkers implement them rather than having them in a plugin. And on the technical level, it's, difficult for us just because what language do people write their plugins in if it's i mean is it like a shared library if it's written in python or lure or something then potentially we lose a lot of the speed so i think there's a few different reasons that we are hesitant to do that

00:45:20.560 --> 00:45:20.640
yeah

00:45:20.640 --> 00:45:26.040
is that accurate charlie yeah yeah yeah all

00:45:26.040 --> 00:45:39.540
right oh let's play around a little bit here So over at types.rought.rs, you actually have a type checker in your browser, I guess, that you can play with.

00:45:40.200 --> 00:45:40.980
First of all, how does this run?

00:45:41.080 --> 00:45:41.820
Is this WebAssembly?

00:45:42.280 --> 00:45:43.360
Is this the server-side thing?

00:45:43.460 --> 00:45:43.600
What's

00:45:43.600 --> 00:45:43.780
happening?

00:45:44.200 --> 00:45:46.940
This is TY's Rust code compiled to WASM.

00:45:47.680 --> 00:45:48.560
So it's

00:45:48.560 --> 00:45:50.100
literally TY running in your browser.

00:45:51.540 --> 00:45:52.060
It also makes

00:45:52.060 --> 00:45:53.620
it very fast in your browser, which is nice.

00:45:54.800 --> 00:45:55.660
It sure does.

00:45:56.600 --> 00:45:56.860
All right.

00:45:56.900 --> 00:46:02.980
What if I go over here and I put like a seven or something?

00:46:03.440 --> 00:46:03.700
I don't

00:46:03.700 --> 00:46:04.420
know what's going to happen.

00:46:04.420 --> 00:46:04.600
Moment of truth here.

00:46:05.820 --> 00:46:06.860
That's probably nine.

00:46:06.860 --> 00:46:08.620
That's testing against seven, but

00:46:08.620 --> 00:46:09.560
I'm going to make it.

00:46:13.100 --> 00:46:13.440
Hold on.

00:46:18.280 --> 00:46:18.900
Oh, my gosh.

00:46:19.100 --> 00:46:19.860
Moment of truth here.

00:46:21.720 --> 00:46:24.900
Oh, it came up as a literal of seven, which I don't want.

00:46:25.180 --> 00:46:27.100
I saw somebody

00:46:27.100 --> 00:46:29.640
in the chat was asking about inlay type-ins.

00:46:29.900 --> 00:46:30.680
Yeah, yeah, let's talk about it.

00:46:31.620 --> 00:46:32.440
They exist right here.

00:46:33.260 --> 00:46:36.360
As soon as you type that, it gave you a little inlay showing the type.

00:46:37.800 --> 00:46:39.280
Okay, so define what that is.

00:46:39.400 --> 00:46:40.760
So if I type like style.

00:46:41.020 --> 00:46:42.780
So like if you type style equals 7 there.

00:46:45.820 --> 00:46:48.700
So you didn't type colon literal 7.

00:46:48.740 --> 00:46:50.380
You didn't put any type annotation there.

00:46:50.760 --> 00:46:51.100
We're just

00:46:51.100 --> 00:46:51.780
putting an inlay

00:46:51.780 --> 00:46:54.500
right into your code to show you that that's what we understand the type to be.

00:46:55.160 --> 00:47:00.960
I see and so this is not actually in the code but the editor sort of deal yeah it's

00:47:00.960 --> 00:47:03.300
showing you the type that the type checker inferred

00:47:04.340 --> 00:47:04.740
despite

00:47:04.740 --> 00:47:10.140
the lack of annotations and you could put like style colon int for example yeah if I put up here

00:47:11.200 --> 00:47:16.860
like you have a style I'll do it like that there we go now I'm getting my warning there we

00:47:16.860 --> 00:47:17.080
go

00:47:18.180 --> 00:47:24.520
that's what I was expecting so I can just play around here yeah and then you also have an error

00:47:24.540 --> 00:47:25.440
on the bottom, right?

00:47:26.610 --> 00:47:29.380
Because online 24, because you're passing the string in.

00:47:30.700 --> 00:47:30.880
Yeah.

00:47:31.440 --> 00:47:31.880
Yeah,

00:47:31.980 --> 00:47:32.460
you pass

00:47:32.460 --> 00:47:35.040
in underlined, but the real value is underlined.

00:47:36.220 --> 00:47:40.400
Yeah, so I'll be sure to put this in the show notes and people can go to the playground and play around.

00:47:41.540 --> 00:47:44.620
So you also got your not.json.

00:47:44.630 --> 00:47:46.100
You can specify your Python version.

00:47:47.860 --> 00:47:47.960
Yeah,

00:47:48.150 --> 00:47:49.340
and like Charlie said, that's actually

00:47:49.340 --> 00:47:50.660
specific to the web playground

00:47:51.480 --> 00:47:51.920
in

00:47:51.920 --> 00:47:53.400
the terminal.

00:47:53.760 --> 00:47:56.760
I mean, outside of the playground context, that would be a Toml file.

00:47:57.280 --> 00:47:57.960
Yeah, this would be Toml.

00:47:58.460 --> 00:47:58.560
Yeah.

00:47:58.920 --> 00:47:59.020
Yeah.

00:47:59.740 --> 00:47:59.800
Yeah.

00:48:00.260 --> 00:48:00.420
Yeah.

00:48:00.700 --> 00:48:00.880
Cool.

00:48:00.940 --> 00:48:01.840
Let me see if I can see it.

00:48:01.930 --> 00:48:02.200
Hold on.

00:48:03.520 --> 00:48:06.180
We spent a lot of time up front.

00:48:06.839 --> 00:48:07.440
Thank you.

00:48:07.560 --> 00:48:07.840
There we go.

00:48:07.990 --> 00:48:08.800
Perfect for this screenshot.

00:48:09.280 --> 00:48:09.400
Perfect.

00:48:10.000 --> 00:48:11.400
We spent a lot of time up

00:48:11.400 --> 00:48:21.200
front, which makes sense, but really on the architecture and the core design of how should this all work.

00:48:21.940 --> 00:48:27.300
And we wanted to build, we had some fairly specific design goals.

00:48:27.660 --> 00:48:33.120
We wanted to build a type checker that could power a language server.

00:48:33.400 --> 00:48:36.460
I would say that was the first thing that we were trying to do.

00:48:37.020 --> 00:48:44.220
And that imposes some pretty specific, I don't know about constraints, but it really informs how you build it.

00:48:44.520 --> 00:49:34.140
Because if you think about a language server, what happens is you open up your editor, and you open up a file. To understand what's happening in that file, you don't necessarily have to look at everything in the editor, every other file in the project. You should be able to quickly give people some analysis and some information just based on looking at the current scope and then the things it imports and figuring out what do I need to look at in order to answer these questions. And the thing that you also want is that if the user edits that file, you don't want to have to reanalyze the whole world. You want to reanalyze basically as little as possible. Maybe that file and anything that's affected by it, et cetera, et cetera.

00:49:36.400 --> 00:49:53.140
To just sit in a terminal and check the types of a program is one problem. But building a language server is pretty different because what's happening is things are changing in real time and you want to be able to do like the minimal amount of analysis at all times to like get people the answers to the questions that they're implicitly asking

00:49:53.140 --> 00:49:57.200
right that's a per keystroke thing rather than i ran a right yeah right

00:49:57.200 --> 00:50:16.760
so from that perspective we needed to think the whole thing to be like highly i mean the word we would use is like incremental so like we're incrementally like pulling in more context or if the user makes an edit to a file we're like incrementing just incrementally the things that might have changed and to update our view of the world.

00:50:17.480 --> 00:50:19.340
So that informed a lot of the design.

00:50:19.450 --> 00:50:31.520
The fact that we wanted this not only to work as a standalone tool that you run on the command line in CI, but also could power this language server experience, that ended up informing a lot of how we approached the design.

00:50:32.660 --> 00:50:36.400
And we spent a lot of time trying to get that right and give us a good foundation for building that.

00:50:37.160 --> 00:50:40.880
So does it do progressive stuff if there's some huge code base?

00:50:41.280 --> 00:50:42.820
So it makes some changes.

00:50:43.080 --> 00:50:47.560
Will it try to give you answers sooner than it reanalyzed everything?

00:50:48.500 --> 00:50:58.840
Yeah, so if you're checking a very big code base or a code base that, say, has a lot of big third-party dependencies, whichever files you actually ask us to check, we'll check that whole file.

00:50:59.400 --> 00:51:19.660
And then each individual thing that it imports, like say you import one little constant that's just like a string or something from a massive third-party file that has a whole bunch of stuff in it, we will literally ignore all of that file and just go straight to the one constant, the definition of that one constant that you actually

00:51:19.660 --> 00:51:20.060
imported.

00:51:20.280 --> 00:51:20.800
And we'll

00:51:20.800 --> 00:51:21.540
just look at that.

00:51:21.890 --> 00:51:26.420
And so we've seen that that makes, I mean, it's good, obviously, for being incremental when you make changes.

00:51:26.950 --> 00:51:37.440
But that also just gives a big speed up for just the initial cold check of a project because we're able to just ignore all the things that you aren't using that might be sitting there in your dependencies.

00:51:39.039 --> 00:51:43.820
Yeah, a little like, yeah, shaking CSS or whatever. Like, I know it's there, but these things don't matter. We're just gonna write.

00:51:44.670 --> 00:51:45.700
Yeah, similar. It's like,

00:51:45.820 --> 00:51:49.080
it's like, let's figure out exactly what we need to look at and then like go just do that work.

00:51:49.480 --> 00:51:51.140
And a

00:51:51.140 --> 00:52:08.360
lot of how we power that is through a library called salsa, which this is getting a little bit into the weeds of rust. But it's, it also it's, it's also powers the rust analyzer, the rust language server that I mentioned.

00:52:08.440 --> 00:52:34.380
before is also powered by salsa um so we've been collaborating like with the salsa team basically since the start of this project saying like hey like we really want to use this and like here are things that we really would need and like blah blah and we've actually spent i mean i shouldn't speak for the team because i've done basically zero work here but like we've been contributing back to salsa and like investing a lot in making salsa better so and also

00:52:34.380 --> 00:52:35.020
learning from

00:52:35.020 --> 00:53:03.960
salsa and learning from like Miko Matsakis and like the people who work on REST Analyzer and everyone else. So it's been cool to kind of like have this community of people who cared about building language servers or other things that rely on highly incremental computation. And that's been a big part of actually like the design and building of the type checker has been the choice to use Salsa and then our investments like back in it to try and improve it in different ways that are important to us. But Carl can speak that much better than I can, that process at least.

00:53:05.560 --> 00:53:07.100
Yeah, I don't know if I have a lot to add to that.

00:53:07.220 --> 00:54:12.760
I mean, I think the cool thing about Salsa and about building on top of Salsa is that it provides a very kind of abstracted general framework for incremental computation is what it's called. So like you basically define your program or your type checker in our case as a bunch of queries and every query should have an output based on only on its input. So it should be deterministic, right? So like a query could be something like, given the input is this assignment statement, the output is what is the type that was assigned to the variable in that statement. And so we kind of build up the entire program in terms of those queries. And we can kind of build it ignoring the whole incrementality problem, like the idea that one thing might change and we don't want to analyze a bunch of stuff unnecessarily. And Salsa just handles that for us automatically. So if we build in terms of all of these queries, Salsa will automatically track when we're doing our initial type check of everything, which queries depended on which other queries and ultimately depended on like which file contents.

00:54:13.460 --> 00:54:26.780
And so then if you just change one part of one file, Salsa can just flow that change through the graph of queries and figure out exactly which queries may have been affected and need to re-execute and all the others can just be left alone.

00:54:27.540 --> 00:54:36.080
So it allows us to kind of have that level of very fine-grained incrementality without really having to think a lot about it as we're building the type checker.

00:54:37.040 --> 00:54:37.320
Yep.

00:54:38.220 --> 00:54:38.300
Yeah.

00:54:38.580 --> 00:54:38.760
It's

00:54:38.760 --> 00:54:39.820
honestly like super cool.

00:54:41.220 --> 00:54:41.300
Yeah.

00:54:41.320 --> 00:54:44.100
It sounds like a reactive sort of data structure.

00:54:45.020 --> 00:54:45.960
You know, it just

00:54:45.960 --> 00:54:46.920
keeps itself in sync.

00:54:47.100 --> 00:54:47.340
That's cool.

00:54:48.540 --> 00:54:48.660
All right.

00:54:48.700 --> 00:54:51.840
I do want to talk about the roadmap a little bit here.

00:54:51.940 --> 00:54:56.360
And by way of introduction there, I'll ask a question from Islam here.

00:54:56.600 --> 00:54:58.760
is there a date for the release of this?

00:55:00.200 --> 00:55:01.440
Wow, that's, you know what, Carl?

00:55:01.620 --> 00:55:04.600
I give you, that one is in your hands.

00:55:06.420 --> 00:55:06.880
Well, thank you.

00:55:08.160 --> 00:55:10.060
It depends what you mean by the release.

00:55:10.960 --> 00:55:24.800
I think we are targeting a sort of general availability release where we really feel like this is ready to be used in production and could be, you know, you can swap out MyPyrePyrite for it.

00:55:26.880 --> 00:55:30.040
and we're targeting that for sometime later this year, probably in the fall sometime.

00:55:30.840 --> 00:55:32.840
We don't have a solid date on that yet.

00:55:33.660 --> 00:55:41.320
We are aiming for an initial, what we would call maybe an early experimental preview alpha release.

00:55:42.980 --> 00:55:45.140
There's a lot of good qualifiers there, you should be safe.

00:55:46.100 --> 00:55:52.440
I mean, there's definitely things that will be missing, like type system features that we won't have yet, and there will be bugs, et cetera.

00:55:52.680 --> 00:55:53.800
You should expect all of that.

00:55:54.440 --> 00:55:58.900
But it's just something to sort of play with and kind of get a little flavor of what we're trying to do.

00:55:59.370 --> 00:56:06.120
And we're aiming to have that available so that you can install it by PyCon, which is coming up, I guess, May 16.

00:56:06.680 --> 00:56:07.140
So by that

00:56:07.140 --> 00:56:07.900
week, we're going to have

00:56:07.900 --> 00:56:08.060
something.

00:56:08.150 --> 00:56:08.440
Yeah, a couple weeks from right now.

00:56:09.039 --> 00:56:11.260
Yeah, that'll be a very early release.

00:56:13.180 --> 00:56:18.020
I was laughing and I made Carl answer the question because I wanted to see how exactly he would describe it.

00:56:18.100 --> 00:56:25.620
But that release, you know, our goal there is not necessarily for people to like take it and migrate over to the tool.

00:56:25.860 --> 00:56:37.500
It's more like to kind of, it's just kind of a milestone for we have a thing now that we can put out there and people can play around with and see like where it's strong and where it needs work.

00:56:37.630 --> 00:56:45.920
And we'll know there'll be a long list of features that like aren't yet implemented, but it will be able to, you know, check some of your types and understand your code.

00:56:45.940 --> 00:56:49.820
and it will be highly incremental and it will be very fast and et cetera, et cetera.

00:56:50.000 --> 00:56:50.080
So

00:56:50.080 --> 00:56:51.080
that'll be like a very

00:56:51.080 --> 00:56:54.560
early release, but we wanted to get something out there for people to kind of play around with.

00:56:54.750 --> 00:57:01.520
And then, yeah, from there, we'll look to do a beta a little later in the year and

00:57:01.520 --> 00:57:02.460
the

00:57:02.460 --> 00:57:08.920
framing there will probably be something like motivated users should be able to migrate over.

00:57:10.080 --> 00:57:10.740
And then we'll do,

00:57:10.890 --> 00:57:10.980
again, we'll do a general.

00:57:11.000 --> 00:57:13.300
If you don't mind the rough edges, yeah, you can do it.

00:57:13.410 --> 00:57:13.560
Yeah, yeah.

00:57:13.920 --> 00:57:16.100
Motivated users is a phrase I like to use.

00:57:17.540 --> 00:57:28.280
And then, yeah, but we want to do, yeah, I mean, hopefully we get this sort of like general available full public release, you know, a little later this year.

00:57:28.830 --> 00:57:30.500
So that's the goal that we're working towards.

00:57:30.610 --> 00:57:33.540
I know it's a vague timeline, but that's the goal that we're working

00:57:33.540 --> 00:57:33.740
towards.

00:57:33.760 --> 00:57:34.320
That's how software goes.

00:57:34.960 --> 00:57:39.380
So when you say all this stuff about timelines and things that people can try and so on, are you talking language server?

00:57:39.600 --> 00:57:40.900
Are you talking type checker?

00:57:41.390 --> 00:57:41.520
Both?

00:57:43.760 --> 00:57:44.700
We're talking both.

00:57:45.400 --> 00:57:45.980
We're talking both.

00:57:46.890 --> 00:57:47.000
Yeah.

00:57:47.850 --> 00:57:48.520
No sleep for Carl.

00:57:48.570 --> 00:57:48.800
Come on.

00:57:49.880 --> 00:57:50.760
Yeah, sorry, Carl.

00:57:51.540 --> 00:57:52.360
Carl, are we talking both

00:57:52.360 --> 00:57:52.560
now?

00:57:53.000 --> 00:57:54.980
Yeah, we're talking both.

00:57:56.240 --> 00:58:08.100
Yeah, but for the language server in particular, there's kind of a long tail of features that we want to support in the language server, just like lots of things that a great complete language server can do.

00:58:10.660 --> 00:58:22.280
we, to start, we're very focused on code navigation, like a smaller number of things, like being able to go to definition, being able to do auto-completion, auto-import, all that kind of stuff.

00:58:22.690 --> 00:58:32.200
So the first versions of the language driver will be very focused on a smaller number of features like code navigation and the things that you need in addition to the kind of diagnostics that you see on the screen.

00:58:32.550 --> 00:58:35.200
So type errors and things that are undefined.

00:58:35.380 --> 00:58:40.800
But beyond that, the focus will be code navigation and auto-completion, auto-import, those kinds of things.

00:58:41.720 --> 00:58:51.900
And I should say that for this initial preview alpha for PyCon, the focus is really on the online playground and running it on the command line on your code.

00:58:53.120 --> 00:59:01.960
The LSP support is there, and it will be possible for you to try it out, but we're not going to really push that at this point because it's very early stages.

00:59:02.260 --> 00:59:07.440
So we're not going to be releasing a VS Code extension or any other editor extensions or anything at this point yet.

00:59:08.820 --> 00:59:09.480
That'll come later.

00:59:09.980 --> 00:59:11.100
Yeah, of course.

00:59:11.820 --> 00:59:13.100
Got to build the foundation first.

00:59:13.540 --> 00:59:13.600
Yep.

00:59:14.580 --> 00:59:15.700
Before we put windows on it.

00:59:17.920 --> 00:59:22.040
One of the things I was thinking about when you two were talking about, well, why does it need to be fast?

00:59:22.320 --> 00:59:24.340
Well, there's large code bases and there's the editors.

00:59:25.360 --> 00:59:34.220
Another thing that came to mind, for me at least, was thinking about continuous integration and large teams and large code bases.

00:59:35.140 --> 00:59:35.340
And

00:59:35.340 --> 00:59:47.800
as soon as the time your CI takes to run outruns the gaps between check-ins, you're getting into a bad place where they fall further and further behind, right?

00:59:48.660 --> 00:59:53.460
And so certainly having a good CI story seems important.

00:59:53.820 --> 01:00:01.900
I'm guessing you guys might have thoughts about, I don't know, pre-commit hooks, CI, GitHub integration, stuff like that.

01:00:03.080 --> 01:00:04.320
I know you have that for UV, Charlie.

01:00:05.720 --> 01:00:34.980
yeah I mean I think we want to have a good experience there we want to have a lot of the similar niceties that we have for Ruff it will like take maybe a little bit of time to get to all of them but Ruff obviously has like a pre-commit integration it also has a GitHub Action and I think we'll probably provide basically all those things for TY as well or at least that would be my expectation we haven't built them yet but the good news is we have a lot of infrastructure that we can leverage from Ruff for everything really like also even like releases and like the release pipeline.

01:00:35.210 --> 01:00:42.260
Like thankfully we've done all this now once, arguably twice because we've done UV too.

01:00:42.470 --> 01:00:47.120
Although like UV doesn't have quite as many of those things because they just don't make as much sense.

01:00:47.340 --> 01:00:54.240
But the good news is like we've built a lot of that infrastructure already and we've been able to leverage it for this project.

01:00:54.450 --> 01:01:01.480
I think similarly like fuzzing, like we can probably leverage a lot of the fuzzing infrastructure that we have for RUF for this program too.

01:01:01.780 --> 01:01:01.780
So

01:01:01.780 --> 01:01:02.720
the good news

01:01:02.720 --> 01:01:07.940
is we built the static analysis tool before, and so we have things we can leverage to make that happen.

01:01:08.620 --> 01:01:09.200
Yeah, that's cool.

01:01:09.420 --> 01:01:12.680
And shout out to the UV caching GitHub Action thing.

01:01:12.840 --> 01:01:13.340
That's pretty excellent.

01:01:14.500 --> 01:01:15.140
Yes, Setup UV?

01:01:15.900 --> 01:01:16.380
Yes, exactly.

01:01:17.180 --> 01:01:17.240
Nice.

01:01:17.390 --> 01:01:17.500
And

01:01:17.500 --> 01:01:20.900
honestly, the biggest CI feature in my mind is performance, right?

01:01:21.080 --> 01:01:32.800
So we're talking to people who are today waiting 25 or 30 minutes for feedback in CI from the type checker, we want that to be 10 to 15 seconds instead of minutes.

01:01:34.000 --> 01:01:36.020
Yeah, that is really the goal.

01:01:37.140 --> 01:01:37.320
Yeah.

01:01:37.960 --> 01:01:41.160
And I think it's hard for people to actually...

01:01:42.400 --> 01:01:50.340
I think people don't actually realize that, but there are Python projects out there that are taking dozens of minutes

01:01:50.340 --> 01:01:51.460
to type

01:01:51.460 --> 01:01:51.780
check.

01:01:52.520 --> 01:01:55.520
And we want to get that down to, yeah, two seconds.

01:01:56.380 --> 01:01:58.540
And so that's what we're aiming to do.

01:01:59.799 --> 01:02:05.680
And I think there will be a lot of other benefits to the type checker and the language server, even for smaller projects.

01:02:05.900 --> 01:02:07.120
That's something that we think about a lot.

01:02:07.370 --> 01:02:12.800
Again, how can we build things that are useful and interesting and powerful for projects of all shapes and sizes?

01:02:13.160 --> 01:02:21.180
And I think having the language server that works in all these different editors and it's tightly integrated with the type checker that you run, I think that will be really helpful for people.

01:02:21.330 --> 01:02:23.160
I think the type inference will be really powerful.

01:02:23.360 --> 01:02:28.380
There's all these things we want to do, But the performance is a little bit of a North Star.

01:02:28.660 --> 01:02:34.280
It's like we should be building things that are orders of magnitude faster than what else is out

01:02:34.280 --> 01:02:34.520
there.

01:02:36.160 --> 01:02:37.700
That would be on brand.

01:02:38.820 --> 01:02:45.660
So I'm sitting here looking at this playground, and I have Python code in the browser, and you're telling me WebAssembly is checking it.

01:02:45.910 --> 01:02:52.580
So is there a way I could actually use this if I'm doing Pyodide or PyScript type of things?

01:02:53.140 --> 01:02:58.520
Do you have any expectations to worry about that, or is it just more CPython-like?

01:03:00.620 --> 01:03:06.920
I mean, the TY just operates on source code, so if it's Python source, we should be able to check it.

01:03:07.160 --> 01:03:14.760
Speaking of Pyodide, though, one cool little feature of the Playground here is there should be, see that little run arrow over on the right-hand side?

01:03:15.500 --> 01:03:16.060
That will actually,

01:03:16.460 --> 01:03:18.960
whatever code you have in the Playground that you're type-checking, that

01:03:18.960 --> 01:03:20.640
will run it using

01:03:20.640 --> 01:03:21.220
Pyodide.

01:03:22.320 --> 01:03:23.940
Yeah, you have to click the run button there.

01:03:24.160 --> 01:03:24.880
Run and then run.

01:03:24.960 --> 01:03:26.260
You've got to click the run button twice.

01:03:26.680 --> 01:03:27.400
But I...

01:03:28.900 --> 01:03:29.620
We could work on that.

01:03:30.540 --> 01:03:30.700
Yeah.

01:03:33.280 --> 01:03:33.820
Yeah, beautiful.

01:03:34.840 --> 01:03:38.340
So that just gives you an easy way to quickly check, you know, what's the actual runtime behavior?

01:03:38.580 --> 01:03:39.520
What's the type checker saying?

01:03:39.780 --> 01:03:40.680
Do they match up, et cetera?

01:03:42.020 --> 01:03:42.400
Yeah, nice.

01:03:42.580 --> 01:03:44.400
Yeah, your function is returning none.

01:03:44.720 --> 01:03:46.680
You've got to annotate it as returning string.

01:03:47.620 --> 01:03:47.860
I do.

01:03:48.060 --> 01:03:48.140
And

01:03:48.140 --> 01:03:49.360
then we will catch that bug.

01:03:51.660 --> 01:03:52.160
Oh, yeah.

01:03:52.350 --> 01:03:54.560
I do got an annotator returning string, right?

01:03:54.800 --> 01:03:55.560
Oh, but it hates it.

01:03:55.720 --> 01:03:57.980
So let's return the string there, right?

01:03:57.990 --> 01:03:59.100
I mean, we're programming a browser.

01:04:01.340 --> 01:04:01.840
There we go.

01:04:02.700 --> 01:04:03.260
Yeah, let's go.

01:04:03.680 --> 01:04:04.280
Let's go.

01:04:04.500 --> 01:04:05.060
There it is.

01:04:06.080 --> 01:04:06.360
Perfect.

01:04:07.000 --> 01:04:07.280
All right.

01:04:07.420 --> 01:04:07.760
Very nice

01:04:07.760 --> 01:04:07.960
to you guys.

01:04:07.960 --> 01:04:09.060
That's a nifty little program, huh?

01:04:09.700 --> 01:04:09.960
Yeah.

01:04:10.339 --> 01:04:10.700
Yeah.

01:04:13.019 --> 01:04:13.380
Yeah.

01:04:13.530 --> 01:04:16.460
So that's our goal is like we want to...

01:04:16.460 --> 01:04:17.080
Today we have Raph.

01:04:17.410 --> 01:04:17.980
We have the linter.

01:04:18.090 --> 01:04:18.820
We have the formatter.

01:04:20.660 --> 01:04:25.140
And we want to build a similar experience for type checking and for the editor.

01:04:26.019 --> 01:04:27.920
And there'll be a lot of tie-ins with Ruff.

01:04:29.559 --> 01:04:40.940
You hinted at this, but if you go to the Ruff issue tracker, there's a lot of issues that have been raised in Ruff over the years that we've now basically assigned as being part of the scope of Red Knot.

01:04:41.480 --> 01:04:41.840
Right.

01:04:42.040 --> 01:04:43.560
Because there are all these...

01:04:43.620 --> 01:04:46.200
I mean, what other color could you pick for the label, right?

01:04:46.860 --> 01:04:47.120
Yeah.

01:04:47.160 --> 01:04:48.260
There's a get it where you can

01:04:48.260 --> 01:04:49.160
go and pull them off, yeah.

01:04:49.940 --> 01:04:53.100
Yeah, sorry, part of TY, but the GitHub label is Red Knot.

01:04:54.600 --> 01:04:55.760
Only the people

01:04:55.760 --> 01:05:01.020
who were really early believers will know why the colors red are involved with TY.

01:05:01.880 --> 01:05:02.500
You know, I

01:05:02.500 --> 01:05:03.700
had a

01:05:03.700 --> 01:05:05.040
very incredible experience.

01:05:05.270 --> 01:05:10.960
I went to Eurorust maybe in November of last year.

01:05:12.959 --> 01:05:15.680
And when I was there, I gave a talk about UV.

01:05:15.960 --> 01:05:23.800
And after the talk, a bunch of people came up to me and were like, it was a Rust conference, but a bunch of people were like, hey, like, we really like your like Python tools, like blah, blah, blah.

01:05:24.660 --> 01:05:29.200
And then I, like a bunch of them just brought up and started talking to me about Redknot.

01:05:29.920 --> 01:05:31.120
And I was like, what's going on here?

01:05:31.200 --> 01:05:33.200
Because we didn't, we had not talked to anyone about that project.

01:05:33.460 --> 01:05:34.120
It's never been hidden.

01:05:34.620 --> 01:05:38.640
It's been developed in the rough repo from the start, but we didn't advertise it at all.

01:05:39.100 --> 01:05:45.560
And so it was like only like really, you know, deep rough heads knew that this was even happening.

01:05:46.180 --> 01:05:46.720
and I was like

01:05:46.720 --> 01:05:47.460
okay this is the

01:05:47.460 --> 01:05:56.440
degree we must be doing something right because these people just came up to me and started talking to me about a top secret public project that we haven't advertised

01:05:57.000 --> 01:06:01.040
hidden in plain sight that's awesome we

01:06:01.040 --> 01:06:16.740
did UV in a little bit of a similar way actually where like we had kind of two major releases like we did like the initial launch which was all the UV pip stuff and then we did a bigger launch later with like lock files and all this other stuff. And

01:06:16.740 --> 01:06:17.000
all that

01:06:17.000 --> 01:06:30.880
stuff was developed just like in the repo, but we didn't talk about it at all until it was like publicly launched. And yet we had this like steady stream of people, you know, avid users who are like testing it and giving us lots of feedback over time. So that's

01:06:30.880 --> 01:06:31.400
kind of the attitude

01:06:31.400 --> 01:06:42.220
that we've taken, I think here too, is like, we just build it in public and some people choose to get involved and choose to use it and choose to give us feedback, but we don't really advertise it until we're kind of ready to unleash it to the world.

01:06:42.320 --> 01:06:52.400
I guess this is a little bit of an exception, but we'll have our really experimental alpha preview release in a couple of weeks, and then it will be released to the world.

01:06:53.360 --> 01:06:53.520
Awesome.

01:06:54.150 --> 01:06:59.320
Yeah, well, thanks for coming here and talking about it and telling everyone about it, both of you guys.

01:07:00.060 --> 01:07:01.300
Oh, yeah, thanks for having us.

01:07:01.760 --> 01:07:03.380
Let's do a final call to action.

01:07:03.900 --> 01:07:07.840
People who maybe didn't know about it before, but now they do, pretty excited.

01:07:08.040 --> 01:07:10.680
They might want to give you feedback or try it out or whatever.

01:07:10.820 --> 01:07:11.380
What are you telling them?

01:07:12.620 --> 01:07:14.580
For the type checker?

01:07:15.160 --> 01:07:16.040
Yeah, for

01:07:16.040 --> 01:07:17.540
TY.

01:07:18.980 --> 01:07:41.440
I think if you're highly motivated, you could go clone the rough repo and build the experimental RedKnot codename binary and run that on your project and see what works.

01:07:42.060 --> 01:07:53.260
But if you're not incredibly motivated, then you should wait several weeks and we will have something for you that I think will be a lot more useful.

01:07:54.220 --> 01:07:55.260
All right, let me just throw you one.

01:07:55.900 --> 01:08:00.340
You can go to types.rough.rs and play around with it in your web browser.

01:08:00.960 --> 01:08:02.680
That's the least motivated thing you could probably do.

01:08:04.820 --> 01:08:05.200
Sorry, go ahead.

01:08:05.260 --> 01:08:05.360
Yeah,

01:08:05.360 --> 01:08:05.620
that's awesome.

01:08:06.040 --> 01:08:21.140
Yeah, all I was going to say is this episode is probably one to two weeks out from now so it's going to be even closer to release when people hear it on the podcast channel so yeah time is pretty good they won't have to wait too long do you guys have a blog?

01:08:21.839 --> 01:08:22.720
can they RSS you?

01:08:24.000 --> 01:08:25.859
yes yeah so

01:08:27.780 --> 01:08:28.580
slash blog

01:08:36.920 --> 01:08:38.120
beautiful SS.xml.

01:08:39.359 --> 01:08:41.060
I bet it's in here as an alternate.

01:08:41.640 --> 01:08:42.339
Alternate, yeah.

01:08:42.740 --> 01:08:43.060
There you go.

01:08:44.200 --> 01:08:44.799
People should find it.

01:08:45.339 --> 01:08:45.980
They should find it.

01:08:47.160 --> 01:08:47.220
Cool.

01:08:47.660 --> 01:08:50.400
So, yeah.

01:08:51.120 --> 01:08:52.140
Thank you both for being here.

01:08:53.020 --> 01:08:57.460
And congratulations on all the projects you've been cranking out and the continued work.

01:08:57.460 --> 01:09:02.640
And we didn't even get to talk about an update with Python Build Standalone.

01:09:03.060 --> 01:09:04.240
But, you know, thanks for that as well.

01:09:05.299 --> 01:09:05.740
Yeah, of course.

01:09:06.180 --> 01:09:06.680
Yeah, yeah, yeah.

01:09:06.940 --> 01:09:07.259
No, no,

01:09:07.480 --> 01:09:09.819
we're like, this is what we love to do.

01:09:09.960 --> 01:09:12.759
We love to build stuff that hopefully people like to use.

01:09:13.080 --> 01:09:17.859
That is the ambitious slogan for our approach to tooling.

01:09:18.460 --> 01:09:23.580
So much that they'll say, yeah, they'll say thank you every time they run it, every time they check the code, right?

01:09:24.940 --> 01:09:25.319
Yeah, TY.

01:09:26.900 --> 01:09:27.100
Cool.

01:09:27.240 --> 01:09:28.500
Yeah, well, thanks so much for having us on.

01:09:28.640 --> 01:09:29.460
It's always a pleasure.

01:09:31.000 --> 01:09:37.400
And yeah, well, I think this stuff's going to be launching in the next few weeks and months.

01:09:37.830 --> 01:09:38.680
And so stay tuned.

01:09:39.420 --> 01:09:40.180
Yeah, awesome.

01:09:41.180 --> 01:09:41.540
Thanks, guys.

01:09:42.029 --> 01:09:42.319
See you later.

01:09:42.779 --> 01:09:43.040
Thank you.

01:09:43.580 --> 01:09:43.640
Thanks.

01:09:44.420 --> 01:09:44.580
All right.

