WEBVTT

00:00:00.001 --> 00:00:04.320
>> Hey, Seth. Welcome back to Talk Python To Me.

00:00:04.320 --> 00:00:06.640
>> Hey, Michael.

00:00:06.640 --> 00:00:13.120
>> Awesome to have you here. I'm really excited to get a look into the zeitgeist of the core

00:00:13.120 --> 00:00:19.680
devs and the people building Python for us through the Python Language Summit.

00:00:19.680 --> 00:00:22.520
>> Yeah. Let's do it.

00:00:22.520 --> 00:00:30.040
>> Let's do it. So we're going to talk about the 2024 Language Summit that happened in

00:00:30.040 --> 00:00:36.600
Pittsburgh. It's like an embedded mini conference inside of PyCon, which is smart rather than

00:00:36.600 --> 00:00:41.680
trying to travel all over. But before we get into that and all those things, I know you've

00:00:41.680 --> 00:00:45.600
been on the show not too long ago, but for those who may have missed your introductions,

00:00:45.600 --> 00:00:48.840
you know, who are you? What do you do for Python these days?

00:00:48.840 --> 00:00:55.760
>> Yeah, I'm Seth Larson, and I've been working at the Python Software Foundation for a little

00:00:55.760 --> 00:01:01.880
over a year now as the security developer in residence. And so that means that I do

00:01:01.880 --> 00:01:07.000
a lot of stuff related to security just for the entire Python ecosystem. That's CPython,

00:01:07.000 --> 00:01:14.400
pip, the packaging ecosystem, like outwardly facing things for PyPI, maybe not as much

00:01:14.400 --> 00:01:19.200
the internals. I leave that for Mike Fiedler, the PyPI safety and security engineer. And

00:01:19.200 --> 00:01:25.520
I maintain a lot of open source projects specifically in like the HTTP and internet space. So like

00:01:25.520 --> 00:01:29.240
requests, Urlib3, TrustStore, things like that.

00:01:29.240 --> 00:01:35.400
>> Oh, awesome. Yeah, thanks for everything you're doing there. And how's the role working

00:01:35.400 --> 00:01:39.240
out? I know this is one of... You were the first person in this role, like officially,

00:01:39.240 --> 00:01:40.800
right? Is that true?

00:01:40.800 --> 00:01:47.560
>> It is true. Yeah, I was the first security oriented hire at the PSF. It's been going

00:01:47.560 --> 00:01:52.840
really great. I mean, I feel like we've made a lot of improvements. And there's a lot of

00:01:52.840 --> 00:01:57.800
exciting stuff that I'm working on today. And I don't know, I think one of the things

00:01:57.800 --> 00:02:04.600
that also got highlighted, because this role exists, it just means that more people at

00:02:04.600 --> 00:02:09.520
the PSF and in CPython core team and just in the Python ecosystem in general are talking

00:02:09.520 --> 00:02:13.820
more about security. And like, that's just as important as the stuff that I'm doing day

00:02:13.820 --> 00:02:20.080
to day is that it's just, there's just more awareness of what's happening in security.

00:02:20.080 --> 00:02:30.160
>> So I have two polar opposite thoughts here. One is, I'm really surprised how few significant

00:02:30.160 --> 00:02:43.260
issues there are in Python, CPython. The interpreter, the runtime, the standard library, all that.

00:02:43.260 --> 00:02:50.600
It's really rare that you get a red light flashing, oh my gosh, go patch your systems

00:02:50.600 --> 00:02:58.880
now. There's sometimes really minor things like this audit trail is not completely followed

00:02:58.880 --> 00:03:04.400
under this condition, but that's not a, the pager goes off and you know, cause you got,

00:03:04.400 --> 00:03:15.000
it's now a race. That's one thing. So that's awesome, right? That the other is PyPI, typo

00:03:15.000 --> 00:03:22.320
squatting, all the stuff that makes Python extra good, the half million packages and

00:03:22.320 --> 00:03:26.320
other shady things people do. And we're going to talk about this in the broader sense, not

00:03:26.320 --> 00:03:31.640
PyPI, but you know, in the open source space of like, well, what if, what if somebody took

00:03:31.640 --> 00:03:38.840
over a GitHub account for a little while or, or something? Yeah. So in that, that's not

00:03:38.840 --> 00:03:45.360
on fire, but that's, there are battles being waged actively there, I would say. Right.

00:03:45.360 --> 00:03:47.400
It's a contrast, right?

00:03:47.400 --> 00:03:52.120
>> I can speak with confidence that there is malware on PyPI right now as we speak, but

00:03:52.120 --> 00:03:58.400
like, yeah, so that's, that's the case. Right. I think it really has to do with CPython is

00:03:58.400 --> 00:04:05.120
an incredibly mature project in like every sense of the word, like governance, security,

00:04:05.120 --> 00:04:10.080
design, all of these things. Right. And like, there's just a huge amount of people and resources

00:04:10.080 --> 00:04:16.440
being, being work, like working on CPython at any one moment and like contrast that to

00:04:16.440 --> 00:04:24.280
the, you said half a million, you know, I tend to focus on the like 95% of downloads

00:04:24.280 --> 00:04:28.760
by totality. Right. Because there's a lot of projects on PyPI that maybe don't have

00:04:28.760 --> 00:04:34.640
the supply chain criticality of others. Right. But yeah, absolutely. A hundred percent. And

00:04:34.640 --> 00:04:40.760
when you, I think when you hone in on that smaller window of projects it ends up being

00:04:40.760 --> 00:04:42.280
a much better picture than

00:04:42.280 --> 00:04:48.400
>> I think it's a hundred percent good picture. Honestly, there are legitimate bugs that people

00:04:48.400 --> 00:04:53.440
have to deal with. Like, you know, maybe there's a Django release that says we didn't validate

00:04:53.440 --> 00:05:00.160
the CRF token in, in this particular form. So you should update your Django. Right. And

00:05:00.160 --> 00:05:05.240
that's, that's just a legit bug. That's not people attempting to do bad things.

00:05:05.240 --> 00:05:10.440
>> And I mean, I can't even take really any credit for how secure and mature CPython is.

00:05:10.440 --> 00:05:18.600
I'm such a late addition in the life of CPython and like PyPI projects. So it really is the

00:05:18.600 --> 00:05:22.760
community. I think it is just, there's so much investment and so much love and care

00:05:22.760 --> 00:05:27.280
happening in all these projects that it does speak volumes. But that, I mean, that doesn't

00:05:27.280 --> 00:05:32.200
mean that we need to think that things need to be perfect or that it's necessarily a bad

00:05:32.200 --> 00:05:37.760
thing to have a vulnerability in a, in a project because there's projects that are even more

00:05:37.760 --> 00:05:42.640
mature than CPython that have vulnerabilities all the time. It's totally normal. I think

00:05:42.640 --> 00:05:46.320
the important thing is just like knowing what to do when that happens. And that's where

00:05:46.320 --> 00:05:49.840
I come in. >> Yeah. I don't want to belabor this because

00:05:49.840 --> 00:05:54.520
that, you know, the security angle, while interesting to me and central to what you're

00:05:54.520 --> 00:06:00.320
up to is not the topic. But I do think it's interesting that the White House recently

00:06:00.320 --> 00:06:04.800
came out. I think it was the White House that said, we recommend Python and a couple other

00:06:04.800 --> 00:06:09.960
languages. We basically, we, we recommend memory safe languages, which did you see that

00:06:09.960 --> 00:06:14.200
post you must have, right? >> I certainly did. And I actually had a,

00:06:14.200 --> 00:06:18.680
a big part of recommending that to the White House. So when the...

00:06:18.680 --> 00:06:22.960
>> No kidding. I had no idea. >> Yeah. Yeah. So the PSF, we responded

00:06:22.960 --> 00:06:28.120
to the request for information that CISA put out or the office of the cyber director put

00:06:28.120 --> 00:06:34.680
out, I think a year and change ago. And in that post, we recommended CPython and Python

00:06:34.680 --> 00:06:40.240
in general as a memory safe language and went into all the details about like, yes, it's

00:06:40.240 --> 00:06:45.440
written in C, but like the language itself, what people will actually be programming in

00:06:45.440 --> 00:06:52.720
is Python. And we also emphasized how Python is a bridge into memory unsafe languages.

00:06:52.720 --> 00:06:57.320
And because of all the focus on performance lately, it's actually like sometimes in some

00:06:57.320 --> 00:07:02.920
cases more performant to keep the code written in Python as opposed to writing it in C. And

00:07:02.920 --> 00:07:08.040
so we emphasize a whole bunch of stuff. And so I think that that had a small percentage

00:07:08.040 --> 00:07:13.400
of the, of the reason why that was recommended. >> Put it on the radar and positioned it correctly

00:07:13.400 --> 00:07:18.480
maybe. >> Exactly. >> Awesome. Well, congratulations. I was just going to say that's kind of interesting,

00:07:18.480 --> 00:07:22.680
but there's way more to it than that. >> There's a lot happening behind the scenes.

00:07:22.680 --> 00:07:27.000
Yeah. Yeah. Yeah. >> Yeah, there is. All right. Shall we talk

00:07:27.000 --> 00:07:34.960
about this language summit thing? >> Let's do it. >> Let's do it. So let's just,

00:07:34.960 --> 00:07:41.520
I mean, I gave it sort of a vague intro. You wrote a nice blog post about it here on the

00:07:41.520 --> 00:07:47.400
Python blog. But just give us a sense of what the language summit, what is it for? Is this

00:07:47.400 --> 00:07:53.400
something, is it like an open space I can go to or not? >> No. So the, so it is, it

00:07:53.400 --> 00:08:01.640
is a specific space for Python core developers to use. And so I think the whole goal

00:08:01.640 --> 00:08:07.920
of this is to get a bunch of core developers in a room together to discuss things and to

00:08:07.920 --> 00:08:16.400
kind of get some recommendations, some ideas flowing maybe without necessarily like having

00:08:16.400 --> 00:08:20.640
the full formed thought, right? Because like putting something out there, like completely

00:08:20.640 --> 00:08:26.560
radically changing the direction of Python, that's a lot to put that out just publicly

00:08:26.560 --> 00:08:31.320
or whatever. And so this is like a place to collaborate for core developers and some special

00:08:31.320 --> 00:08:35.760
guests because not everyone that's there is a core developer, but it is invite. So you

00:08:35.760 --> 00:08:40.320
have to like apply to go and say why you want to go. And then, yeah. So it's not just-

00:08:40.320 --> 00:08:46.000
>> Yeah. I think some folks who were, I can't remember if it was Sebastian Ramirez or Samuel

00:08:46.000 --> 00:08:50.120
Collin or something around the typing thing. I remember some of those folks might've been

00:08:50.120 --> 00:08:54.440
at one of them because they're like, wait, we can't change typing to be more performant,

00:08:54.440 --> 00:08:58.080
but where it completely ignores the runtime stuff because we have all these frameworks.

00:08:58.080 --> 00:09:00.880
>> Right, right, right. >> Yeah.

00:09:00.880 --> 00:09:06.440
>> Yeah. But the language summit, it's a whole bunch of different like submitted topics. People

00:09:06.440 --> 00:09:12.280
will talk and then there's discussion and some outcome. Maybe there's no outcome. Maybe

00:09:12.280 --> 00:09:17.880
there's like next steps. Maybe we solve some problems within the time of the meeting. And

00:09:17.880 --> 00:09:23.800
yeah, my job there was to actually like take down all the notes and write about it and

00:09:23.800 --> 00:09:28.560
like publish these blog posts. Because one of the reasons why this is allowed to be like

00:09:28.560 --> 00:09:34.600
an invite only meeting is that there is someone who is basically taking notes and blogging

00:09:34.600 --> 00:09:39.280
about everything that gets discussed and like what happened during the discussion so that

00:09:39.280 --> 00:09:46.680
then the community can learn about what actually happened without necessarily getting the rawness

00:09:46.680 --> 00:09:52.120
of it, I guess. >> Yeah, there's a real careful balance you

00:09:52.120 --> 00:10:00.720
got to strike between allowing the freedom to say whatever without public scrutiny, but

00:10:00.720 --> 00:10:04.320
at the same time, you don't want it to be like, well, the Python cabal met. They've

00:10:04.320 --> 00:10:05.320
decided. >> Exactly.

00:10:05.320 --> 00:10:09.320
>> They don't like your idea or whatever. >> Exactly.

00:10:09.320 --> 00:10:15.240
>> Yeah, it's cool. So I'll point people, obviously it's going to be in the show notes,

00:10:15.240 --> 00:10:20.800
but I'll point people at your write-up. It's like a meta post, I guess, would you say that?

00:10:20.800 --> 00:10:23.320
It talks about sort of -- >> Landing page.

00:10:23.320 --> 00:10:29.600
>> Landing page, exactly. Four, one, two, three, four, five, six, seven, eight, nine.

00:10:29.600 --> 00:10:35.440
And then nine topics and presentations that were covered. And then the lightning talks,

00:10:35.440 --> 00:10:40.320
which is also almost like another submeta section. So there's a lot to explore here.

00:10:40.320 --> 00:10:47.040
And there's nice write-ups on each of these. So where should we start? Do we want to kind

00:10:47.040 --> 00:10:51.720
of wrap up the conversation we were just having? Because that was actually a little bit of

00:10:51.720 --> 00:10:57.320
a topic at the Language Summit, right? >> Yeah, security was definitely a topic at

00:10:57.320 --> 00:11:05.120
the Language Summit. This was somewhat in the recent light, like the light of XZ, when

00:11:05.120 --> 00:11:12.640
XZ had happened, Pablo, one of the release managers for CPython 3.10 and 3.11, I believe,

00:11:12.640 --> 00:11:20.360
brought this topic. And it was basically discussing Python's contribution and release and all

00:11:20.360 --> 00:11:26.200
of that model in the light of XZ. So like XZ, I'll just go over really quickly.

00:11:26.200 --> 00:11:30.120
>> Yeah, yeah. Tell people about XZ. >> Yeah, I'm sure a lot of people have heard

00:11:30.120 --> 00:11:36.640
of it at this point, but... >> It was such a long game deal. It was crazy.

00:11:36.640 --> 00:11:38.720
So yeah, what is... >> That's the scary part.

00:11:38.720 --> 00:11:42.880
>> What is XZUtils and then what is the XZUtils security issue?

00:11:42.880 --> 00:11:50.560
>> Yeah, so XZUtils is a library written in C for basically processing archives of the

00:11:50.560 --> 00:12:00.000
XZ format, which is just a compression format, like GZIP, like any other compression format,

00:12:00.000 --> 00:12:07.560
but flea, broadly, all of those. And so this library was maintained by a single person,

00:12:07.560 --> 00:12:15.600
big surprise. And what is relatively little known, right, before all of this happened,

00:12:15.600 --> 00:12:21.040
I would say, was probably just adding features, fixing bugs, every once in a while make a

00:12:21.040 --> 00:12:29.920
release and all of that. And what ended up happening is this project was identified as

00:12:29.920 --> 00:12:37.880
a project that had very few maintainers and also, through a series of reasons, had a linkage

00:12:37.880 --> 00:12:42.560
to SSH. And so what ended up happening... >> Oh.

00:12:42.560 --> 00:12:48.360
>> Yep. And so SSH was... >> If you can get into SSH and SSHD, then

00:12:48.360 --> 00:12:52.600
bad things are going to happen. >> Yeah. So the whole end goal of this entire

00:12:52.600 --> 00:13:02.320
operation was to get access to OpenSSH through linking, basically. And so what ended up happening

00:13:02.320 --> 00:13:10.080
is a bunch of fake sock puppet accounts showed up after this loan maintainer indicated that

00:13:10.080 --> 00:13:15.480
they were having a little bit of trouble maintaining the project and meeting user demands. These

00:13:15.480 --> 00:13:22.320
sock puppet accounts show up like days before they were actually used and all kind of in

00:13:22.320 --> 00:13:29.640
similar fashion, right? And basically are pressuring this maintainer to either make

00:13:29.640 --> 00:13:35.000
them feel like they're not doing a good job or to try to add a new maintainer. In this

00:13:35.000 --> 00:13:43.880
case, geotan is the pseudonym that this account used. And what ended up happening is over

00:13:43.880 --> 00:13:52.280
a year of legitimate positive contribution from this account, this account was added

00:13:52.280 --> 00:13:58.760
as equivalent to a release manager, right? Like someone who is approving PRs and merging

00:13:58.760 --> 00:14:06.480
things and is capable of accessing the actual archives when releases happen. And then a

00:14:06.480 --> 00:14:13.760
good chunk of time passes after that, and there's a couple of little changes added that

00:14:13.760 --> 00:14:20.780
on their own are not an attack, but it was preparing for an attack where essentially

00:14:20.780 --> 00:14:26.500
a small change was added into the release archives that was not a part of the source

00:14:26.500 --> 00:14:35.040
tree that activated the entire attack chain. And then when this started to be pulled in

00:14:35.040 --> 00:14:41.000
downstream into things like Fedora, early versions of Red Hat, this never went into

00:14:41.000 --> 00:14:47.040
any stable builds, but it was all the pre-releases. This ended up getting onto people's machines

00:14:47.040 --> 00:14:52.680
and then was eventually discovered because of a very small performance difference when

00:14:52.680 --> 00:14:54.000
logging into SSH.

00:14:54.000 --> 00:14:59.600
Yeah, and that was somebody who wasn't even looking. I forgot the person's name, but they

00:14:59.600 --> 00:15:04.720
worked at Microsoft and they were just on the Azure team or something. And they just

00:15:04.720 --> 00:15:09.040
were like, why did this slow down a little bit? That's weird. And they're like, wait

00:15:09.040 --> 00:15:15.800
a minute, what is this doing in here? Yeah, it was on the verge. And what a long game.

00:15:15.800 --> 00:15:22.280
One person, one account came along and was just, I'm going to hear to help you. I'm going

00:15:22.280 --> 00:15:29.920
to try to just become your best friend contributor. And then another one is just mentally abusing

00:15:29.920 --> 00:15:33.840
the people. Why don't you just quit? Why don't you get some more support? And then like,

00:15:33.840 --> 00:15:37.920
well, let me reach out to some people who are helping me out recently. And it turns

00:15:37.920 --> 00:15:41.360
out these are like two sides of the same coin.

00:15:41.360 --> 00:15:42.360
Yep, exactly.

00:15:42.360 --> 00:15:49.640
Yeah, shady. Okay. Luckily that got caught because there's a lot of servers in the world

00:15:49.640 --> 00:15:55.640
that can be SSHed into and like, well, we got public private key encryption. You can't

00:15:55.640 --> 00:16:00.520
break through that stuff as long as you don't use passwords, you're going to be fine. Unless

00:16:00.520 --> 00:16:02.560
you're not.

00:16:02.560 --> 00:16:08.680
I received a lovely email on the day that this happened. Report to the security response

00:16:08.680 --> 00:16:14.920
team for Python because we of course use the XZUtils libraries because Python supports

00:16:14.920 --> 00:16:21.040
XZ format as well. And there was a lovely few seconds where I'm like, oh, this is either

00:16:21.040 --> 00:16:26.200
going to be a fine day for me or a really bad day. And it ended up being a fine day.

00:16:26.200 --> 00:16:27.200
So

00:16:27.200 --> 00:16:31.800
That's good. It's like, are we going to be canceling all our plans for next few weeks?

00:16:31.800 --> 00:16:38.120
Yep. I'm not going to have lots of questions to answer from concerned customers, users,

00:16:38.120 --> 00:16:40.560
but it was fine.

00:16:40.560 --> 00:16:47.320
I find this kind of stuff is a lot like, everything's fine. You relax. Just work's going good. Life's

00:16:47.320 --> 00:16:52.200
going good. And then something's on fire just out of the blue and you have this, you know,

00:16:52.200 --> 00:17:00.080
it takes your breath away moment. Like, does that apply to us as well? Because if it does,

00:17:00.080 --> 00:17:01.080
everything just changed.

00:17:01.080 --> 00:17:02.080
Yeah. Fun times.

00:17:02.080 --> 00:17:07.800
Yeah. I'm really glad it did. So one of the talks was Python security model after this

00:17:07.800 --> 00:17:11.520
issue, the XZUtils backdoor. Tell us about that.

00:17:11.520 --> 00:17:18.040
Yeah. So this entire talk was essentially just overviewing like, hey, is this possible?

00:17:18.040 --> 00:17:23.440
Is this possible for CPython to be impacted by such an attack? And I mean, the answer

00:17:23.440 --> 00:17:30.320
is yes, it really is. Because if you have accounts that are willing to put years of

00:17:30.320 --> 00:17:37.920
effort into contributing good code to CPython, right? Like that, that is enough to become

00:17:37.920 --> 00:17:43.640
a core developer likely. And if you're a core developer, it means you can merge PRs. It

00:17:43.640 --> 00:17:48.600
means if you, I mean, if you get two core developer accounts promoted to this level

00:17:48.600 --> 00:17:55.480
of authorization, you can merge your own PRs with review, right? Like, we're the big focus

00:17:55.480 --> 00:18:01.520
on this talk was like, okay, how can we prevent this? And if we in the ways that we can't

00:18:01.520 --> 00:18:07.020
prevent it, how can we be ready? And kind of like a discussing whether or not we're

00:18:07.020 --> 00:18:12.360
ready at this point. And I think the big consensus was that if we were to discover something

00:18:12.360 --> 00:18:18.360
like this, it had already been merged into Python or had been released in Python, that

00:18:18.360 --> 00:18:25.040
we would be okay to be able to get it to like, get the word out. Like that sort of infrastructure

00:18:25.040 --> 00:18:29.120
already exists. And we're not too worried about that. Like we're CNA, we can create

00:18:29.120 --> 00:18:34.120
a CV really quickly. We can get like the announcements out really quickly. We can get releases out

00:18:34.120 --> 00:18:40.560
really quickly. So like, in that way, the reactive sense, we're okay. In the proactive

00:18:40.560 --> 00:18:48.040
sense, there, which is the more important one, but it's also the harder one.

00:18:48.040 --> 00:18:54.400
We yeah, because when nation states hire people to say the next three years of your job, yeah,

00:18:54.400 --> 00:19:00.280
it's, it's almost like, it's like a team, like a spot. Yeah. For, for multiple years,

00:19:00.280 --> 00:19:06.400
it's like the CIA or MI six or something, you know, it can on the code side, you know,

00:19:06.400 --> 00:19:10.440
to be honest with you, it doesn't even need to necessarily be like nation state level

00:19:10.440 --> 00:19:18.720
stuff for this to happen because vulnerabilities in popular pieces of software are very, very

00:19:18.720 --> 00:19:24.400
lucrative. You can sell them and people make a lot of money on selling vulnerabilities

00:19:24.400 --> 00:19:33.600
to projects, but so why not grow your own, right? Yeah. Go ahead.

00:19:33.600 --> 00:19:39.480
One of the things I think is great is there's a really long release cycle, right? And like

00:19:39.480 --> 00:19:46.960
a stage rollout. So I don't know how many people jump in and install alpha one of some

00:19:46.960 --> 00:19:51.600
Python, but it's, it's pretty limited and it's not going to make it. No, no, of course.

00:19:51.600 --> 00:20:00.120
I know I see you raising your hand. However, I don't see that shipping on, you know, Ubuntu's

00:20:00.120 --> 00:20:06.040
update channel or, or doc, Docker's a whole different deal. Like let's not even go there,

00:20:06.040 --> 00:20:12.640
but on the main Docker images, you know? Yeah. Yeah. I mean, this, the slow rollout is, is

00:20:12.640 --> 00:20:17.360
definitely a big part of it, right? Like a lot of people get their Python, not direct

00:20:17.360 --> 00:20:23.760
from the source. They get it from a, like a distribution or they get it from, you know,

00:20:23.760 --> 00:20:28.760
if they, you know, like Amazon Linux with Python or whatever, right? Like it's a distribution

00:20:28.760 --> 00:20:35.400
of Python brew install or brew install Python. Yeah. So a lot of people are not living on

00:20:35.400 --> 00:20:42.560
the edge. And I think that that helps in a way. Obviously people that are living on the

00:20:42.560 --> 00:20:47.400
edge, maybe they're the more valuable targets, but I mean, I'm not going to be the one to,

00:20:47.400 --> 00:20:56.200
to encourage that. Yeah. I don't think that, I think the biggest defenses against

00:20:56.200 --> 00:21:01.960
this, and this was what was discussed there was trying to push things to be in the open

00:21:01.960 --> 00:21:08.640
and actually in a way open source is uniquely able to respond. Right, right, right, right.

00:21:08.640 --> 00:21:12.960
And so I think that's something that we're really excited against for these sorts of

00:21:12.960 --> 00:21:19.040
attacks, because if this were to happen in windows, for example, like would we have had

00:21:19.040 --> 00:21:26.240
the almost immediate, like being able to debug what the actual attack was, how long this

00:21:26.240 --> 00:21:31.360
had been going on, what patches were bad, right? Like that, that sort of visibility

00:21:31.360 --> 00:21:35.440
into the source code is something that was really important in being able to actually

00:21:35.440 --> 00:21:41.480
respond. And so like having test files and binary files, not checked into source code

00:21:41.480 --> 00:21:46.320
and instead generated. So one of the parts of this attack that allowed it to go hidden

00:21:46.320 --> 00:21:51.000
for so long and be checked into source code was that all, almost all of the attack code

00:21:51.000 --> 00:21:57.680
was hidden extremely well in a binary file, which made it so that code reviewers...

00:21:57.680 --> 00:22:03.840
Some of the test binary elements, cause if you've got a compression file utility, you

00:22:03.840 --> 00:22:07.240
got to have compressed files for your unit test, right?

00:22:07.240 --> 00:22:12.840
Exactly. So it was basically these files were checked in and there's just huge binary blobs

00:22:12.840 --> 00:22:18.640
that you can't actually get your eyeballs on to review. We talk about like lots of eyeballs

00:22:18.640 --> 00:22:23.360
make for shallow bugs. Well, if the eyeballs can't see the bugs, then you're not going

00:22:23.360 --> 00:22:29.000
to find them. And so we talked about like removing binary files from the source code

00:22:29.000 --> 00:22:33.000
or making sure that all the binary files that are generated have like a script that allows

00:22:33.000 --> 00:22:36.840
them to be generated at any time and things like that.

00:22:36.840 --> 00:22:41.600
Is it one of the changes recently, I can't remember if this was on PyPI or if this is

00:22:41.600 --> 00:22:49.800
a GitHub thing, but allowing GitHub to be the thing that publishes directly, builds

00:22:49.800 --> 00:22:55.040
the wheels and uploads them to PyPI rather than somebody downloading the code, building

00:22:55.040 --> 00:22:59.640
them and uploading it, which obviously that's a opaque step there.

00:22:59.640 --> 00:23:06.520
Yeah. So other like other things that tie more strongly, these, whatever release artifacts

00:23:06.520 --> 00:23:11.080
are actually ending up on people's machines to the source code. So that's, I mean, I would

00:23:11.080 --> 00:23:16.480
call that build provenance. There's a whole bunch of different frameworks that that works

00:23:16.480 --> 00:23:20.520
under, but yeah, build provenance, being able to tie in an artifact that's installed in

00:23:20.520 --> 00:23:27.200
your system back to the actual source code so that when you are evaluating that, that

00:23:27.200 --> 00:23:31.640
artifact on whether you want to install that on your system or deciding whether to upgrade

00:23:31.640 --> 00:23:37.760
or whatever, you can look at the source code instead of writing up this like compiled binary.

00:23:37.760 --> 00:23:41.360
That's something that I really want to focus on for like PyPI in the future, but yeah,

00:23:41.360 --> 00:23:42.360
we're not there yet.

00:23:42.360 --> 00:23:46.200
Awesome. Yeah. When you, cause when you look at a project, you say, well, let me, let's

00:23:46.200 --> 00:23:51.120
see what the release is on GitHub. If you know that literally that was the thing that

00:23:51.120 --> 00:23:59.440
compiled or got built and then that's what's on PyPI, that's a different forensic analysis

00:23:59.440 --> 00:24:07.000
than exactly. Well, somebody's machine, what it ends up nice, like being nice is that it,

00:24:07.000 --> 00:24:11.360
and this is the tough part is that I feel like a lot of people's behavior, which is

00:24:11.360 --> 00:24:16.840
to go on GitHub and look at the diff between like tags. That's what a lot of people do,

00:24:16.840 --> 00:24:20.600
but that's not actually what you should do. You should be looking at the diff between

00:24:20.600 --> 00:24:23.720
the artifacts. That's the thing that's actually installed in your machine, but that's way

00:24:23.720 --> 00:24:27.400
harder to do than looking at the diff tags. So adding build.

00:24:27.400 --> 00:24:31.320
We just crowdsource it. We're all crowdsourcing it. Like wait for somebody to scream.

00:24:31.320 --> 00:24:33.440
I know we are.

00:24:33.440 --> 00:24:38.840
All right. Just related to this while we're still on this topic, you know you talked about

00:24:38.840 --> 00:24:48.880
the somewhere, there we go. There's also big news around CVEs, which are official vulnerability

00:24:48.880 --> 00:25:00.280
numbering. So they're referenced through all those cybersecurity talk and stuff. You can

00:25:00.280 --> 00:25:06.720
describe it better. But so big news is that the PSF now, and you alluded to this, is now

00:25:06.720 --> 00:25:11.960
an official numbering authority. So rather than saying there's a problem with Python,

00:25:11.960 --> 00:25:17.240
who is going to sort of officially call this out and write it up and so on, like you guys

00:25:17.240 --> 00:25:19.480
can do that directly now, right?

00:25:19.480 --> 00:25:26.920
Yeah. So like CVEs are basically, it's a set of identifiers and records that show, it's

00:25:26.920 --> 00:25:32.440
like a bunch of metadata about vulnerabilities in software is what it is. And it's only one

00:25:32.440 --> 00:25:36.800
system. There are a bunch of other like vulnerability databases, but CVE seems to be the one that

00:25:36.800 --> 00:25:45.100
everyone uses or references. And so what being a CVE numbering authority gives us is it makes

00:25:45.100 --> 00:25:53.800
it so that someone at the PSF can like operate the CVE UI and workflow and all of that to

00:25:53.800 --> 00:25:59.240
say like, oh, we want to create a new CVE ID on behalf of the Python team or on behalf

00:25:59.240 --> 00:26:05.840
of the pip team. And what that ends up meaning is that because we are part of the process,

00:26:05.840 --> 00:26:12.080
instead of having to go to some other entity, so like Mitre or Red Hat or, you know, Microsoft,

00:26:12.080 --> 00:26:16.860
there's a whole bunch of CNAs. There's a bunch, there's over a hundred now, I think. Instead

00:26:16.860 --> 00:26:23.060
of going to someone else that, you know, isn't as well versed in Python or, you know, our

00:26:23.060 --> 00:26:29.700
release schedule or any of those things, right? We get to inject the knowledge that we have

00:26:29.700 --> 00:26:35.300
about Python into all of these records, into all these advisories. And it makes it so that

00:26:35.300 --> 00:26:38.980
we don't actually have to talk to someone else to be able to handle a vulnerability

00:26:38.980 --> 00:26:44.540
end to end, right? So like before you would potentially have a reporter going to talk

00:26:44.540 --> 00:26:49.220
to someone else and getting a CVE ID, and then they would come talk to us. And by that

00:26:49.220 --> 00:26:53.380
point, like it was, it's hard to like make a determination and there's a whole bunch

00:26:53.380 --> 00:26:56.260
of things have already happened. And maybe there's messes that need to get cleaned up

00:26:56.260 --> 00:27:01.820
to make sure that it's not confusing. So by owning the entire process, we're able to make

00:27:01.820 --> 00:27:06.760
sure that things are as little confusing as possible, like what actually needs to be done

00:27:06.760 --> 00:27:09.580
for users when we publish these things.

00:27:09.580 --> 00:27:17.140
Yeah, that's, that's great. I want to move off the security angle here, because I know

00:27:17.140 --> 00:27:21.700
there's so much more to talk about. However, I can't help it. Do you guys do any, have

00:27:21.700 --> 00:27:26.620
you considered or ever run any sort of bug bounty program?

00:27:26.620 --> 00:27:30.940
We don't have a bug bounty program right now. I mean, the hard part with a bug bounty program

00:27:30.940 --> 00:27:36.440
is it takes money. So if you would like to see a bug bounty program happening at the

00:27:36.440 --> 00:27:40.920
PSF, get in touch with the PSF. Send the email.

00:27:40.920 --> 00:27:46.680
Yeah, I think incentives are really aligned there. There's a lot of companies that have

00:27:46.680 --> 00:27:54.600
this tooling at the center of their data center. So maybe, maybe, maybe, maybe we can make

00:27:54.600 --> 00:27:56.160
it happen.

00:27:56.160 --> 00:28:04.700
All right. Next up, the REPL, or the PyREPL for the Python PyREPL. What's the deal with

00:28:04.700 --> 00:28:05.700
this?

00:28:05.700 --> 00:28:11.260
Yeah, so this was a, a talk that was given by a couple of different core devs. I think

00:28:11.260 --> 00:28:16.940
this included a bunch of people, Pablo, Lukasz, and Lissandros all gave this talk. And it

00:28:16.940 --> 00:28:24.180
was about, hey, this new REPL that's coming in Python 3.13. Here's all the cool stuff

00:28:24.180 --> 00:28:30.540
that it can do and how it makes the usability so much better for people. And they demoed

00:28:30.540 --> 00:28:35.140
a whole bunch of the new features, which was really exciting. There was lots of applause

00:28:35.140 --> 00:28:40.460
showing off a few of these like little, little features. And I think that the other

00:28:40.460 --> 00:28:48.020
side of it is like, because this new REPL is written in Python and not written in C,

00:28:48.020 --> 00:28:54.100
it lowers the barrier for contributions and maintenance drastically. Before the REPL was

00:28:54.100 --> 00:29:00.740
like super entwined with like the parser and all of these other really low level details

00:29:00.740 --> 00:29:04.940
of Python that a lot of people probably didn't want to get involved with if they didn't have

00:29:04.940 --> 00:29:11.820
to versus this where it's this completely separate and much more easy to contribute

00:29:11.820 --> 00:29:13.380
to piece of software.

00:29:13.380 --> 00:29:17.380
Yeah. And did this come from the PyPy, P-Y-P-Y project?

00:29:17.380 --> 00:29:23.140
Yes, this was P-Y-P-Y. And I think that there's been some, some back and forth contributing

00:29:23.140 --> 00:29:26.500
back, contributing forward, all of that, which is also really great, right? Having

00:29:26.500 --> 00:29:29.300
one REPL shared between two different implementations.

00:29:29.300 --> 00:29:35.140
Yeah, that's great. Just working, working better together, more people working on it.

00:29:35.140 --> 00:29:41.860
I always call it P-Y-P-Y because some people call Python packaging injects, PyPy, but that's

00:29:41.860 --> 00:29:44.260
also this other thing. So anyway.

00:29:44.260 --> 00:29:47.060
It's a non-zero part of every one of my days, right?

00:29:47.060 --> 00:29:48.640
I'm sure that is.

00:29:48.640 --> 00:29:52.900
Because a lot of the times, you know, a significant percentage of my work as a security person

00:29:52.900 --> 00:29:58.300
is being in working groups that are not Python related at all. And yeah, there's a lot of

00:29:58.300 --> 00:29:59.300
PyPy flying around.

00:29:59.300 --> 00:30:05.060
Yeah. You talk about NumPy being on PyPy and you're like, okay, hold on.

00:30:05.060 --> 00:30:07.460
Hold on. Could be two different things.

00:30:07.460 --> 00:30:10.020
There's a lot going on here.

00:30:10.020 --> 00:30:11.020
Yeah.

00:30:11.020 --> 00:30:16.340
So this is really interesting. I haven't really played with it much. I honestly don't spend

00:30:16.340 --> 00:30:22.180
a ton of time in the bare Python REPL. Like if I'm, I'm REPLing, a lot of times I'm in

00:30:22.180 --> 00:30:30.380
the JetBrains sort of enhanced REPL that's inside PyCharm, something like that.

00:30:30.380 --> 00:30:35.900
But and I think partly because there was a lot of challenges with the bare Python REPL,

00:30:35.900 --> 00:30:36.900
right?

00:30:36.900 --> 00:30:42.260
There's no autocomplete, but worse than that was if you've got a five line function and

00:30:42.260 --> 00:30:46.220
you want to edit it, you've kind of got to go to the top part hitter.

00:30:46.220 --> 00:30:52.940
It really was hard to work with blocks of code. There's no color, things like that.

00:30:52.940 --> 00:30:57.300
Yeah. Color's the standard for, if you don't have color in your terminal at this point,

00:30:57.300 --> 00:31:02.820
like even 20, basically you've given up at that point. If you don't have an emoji and

00:31:02.820 --> 00:31:04.380
you don't have color, I mean,

00:31:04.380 --> 00:31:09.420
Emoji's color, gotta have like the rainbow prompts and maybe like the ASCII logo of the

00:31:09.420 --> 00:31:10.420
thing when it starts up.

00:31:10.420 --> 00:31:15.140
A starship. Oh yeah. I didn't even consider the ASCII art and possibly the ASCII art in

00:31:15.140 --> 00:31:16.140
color.

00:31:16.140 --> 00:31:23.460
So I do think it sounds like a minor deal, but just the readability of having highlighting

00:31:23.460 --> 00:31:25.260
and stuff is really nice.

00:31:25.260 --> 00:31:28.060
Yeah. Syntax highlighting is huge. Syntax highlighting is like really huge. That's not

00:31:28.060 --> 00:31:33.740
a part of the current REPL, I don't think, but like it becomes much more possible because

00:31:33.740 --> 00:31:35.140
this PyREPL exists.

00:31:35.140 --> 00:31:37.820
Yeah, exactly. Very cool.

00:31:37.820 --> 00:31:42.220
I think that like the biggest thing, yeah, like the whole blocks of code, I just remember

00:31:42.220 --> 00:31:46.380
the demo of them showing like, oh, you have like five lines you have to hit up, up, up

00:31:46.380 --> 00:31:47.380
like four times.

00:31:47.380 --> 00:31:52.300
Oh, and if you mess it up, you got to start over. You get it out of order.

00:31:52.300 --> 00:31:55.740
You're just sad. You just contemplate putting it in a file instead of doing this in the

00:31:55.740 --> 00:31:56.740
REPL.

00:31:56.740 --> 00:31:59.820
Exactly. That's why I'm not in there. I avoid being in there because it's hard.

00:31:59.820 --> 00:32:04.100
This will be really, really great for people that are just starting Python Journey, because

00:32:04.100 --> 00:32:09.860
I think that a lot of people learning and starting off will use the REPL straight up

00:32:09.860 --> 00:32:14.740
instead of an IDE. And so like having this, there was a big focus on like teachability

00:32:14.740 --> 00:32:20.140
and documenting it and making it work the same. Like if you actually like read the post,

00:32:20.140 --> 00:32:23.860
like what the discussions were about for like everyone is basically totally in favor. They

00:32:23.860 --> 00:32:28.860
loved it, but they wanted to make sure that this was going to be like a consistent experience,

00:32:28.860 --> 00:32:33.700
specifically like Carol Willing had this big point about like having a consistent experience

00:32:33.700 --> 00:32:38.180
being really important for teaching Python across different operating systems.

00:32:38.180 --> 00:32:44.860
Yeah. And something a little bit, a little bit better than up, up, up five times and

00:32:44.860 --> 00:32:46.340
don't get it out of order.

00:32:46.340 --> 00:32:47.340
Exactly.

00:32:47.340 --> 00:32:53.340
Yeah. That's cool. Though, I guess one of the, I don't know if this was discussed, but

00:32:53.340 --> 00:32:57.980
one of the challenges of this, I think is it requires, and this is not necessarily bad,

00:32:57.980 --> 00:33:03.860
but just a challenge is I think it requires the new Windows terminal rather than say cmd.exe,

00:33:03.860 --> 00:33:10.980
the older style. So it just works out of the box on macOS and on Linux, but on windows,

00:33:10.980 --> 00:33:13.740
you got to be a little careful about how you run it. Is that right?

00:33:13.740 --> 00:33:17.840
So I actually don't know what the current status of all of this is because time has

00:33:17.840 --> 00:33:23.300
marched on since these blog posts have happened. And there has been a lot of work done on the

00:33:23.300 --> 00:33:28.140
windows side, the current team, like the team that presented this didn't have any windows

00:33:28.140 --> 00:33:33.540
experience. And so they didn't know really how hard it was going to be. I think that

00:33:33.540 --> 00:33:38.060
there's been a lot of strides in the windows side of things. So I think the situation is

00:33:38.060 --> 00:33:43.260
better. I don't know offhand if cmd.exe is supported or if it's just the new windows

00:33:43.260 --> 00:33:45.580
terminal, but I, yeah.

00:33:45.580 --> 00:33:49.300
I think it's fine if it's a new Windows terminal, like people need to be using that thing anyway.

00:33:49.300 --> 00:33:50.300
It's true.

00:33:50.300 --> 00:33:55.460
It's like opening up on your Mac and just having like the bare white bash. I guess it's

00:33:55.460 --> 00:34:01.660
Z shell these days, but just the completely, you know, non-fixed font. Like what is this

00:34:01.660 --> 00:34:06.100
thing that you are running? I feel like the terminal is horrible. Well, that thing is,

00:34:06.100 --> 00:34:13.540
but you could make it a lot nicer by the way. And it's similar trade off there in the

00:34:13.540 --> 00:34:18.100
Windows world. So, okay. Interesting.

00:34:18.100 --> 00:34:27.340
Next one is, should we adopt calendar versioning? We're beyond zero-verse, so that's really

00:34:27.340 --> 00:34:38.580
good, but there's been a reluctance to have Python 4, but we've got 3, 12, 313. Are we

00:34:38.580 --> 00:34:45.180
just going to have 3.128 or should we come up with something else? Right? What is calendar

00:34:45.180 --> 00:34:49.100
versioning and should we adopt it and how many digits should it have?

00:34:49.100 --> 00:34:56.940
Yeah. So this was presented on by Hugo, who is the new release manager for Python 3, 14

00:34:56.940 --> 00:35:01.900
and 15, which maybe that's a little presumptive saying those numbers. Cause if this goes through,

00:35:01.900 --> 00:35:04.540
that will not be the case anymore.

00:35:04.540 --> 00:35:08.500
He's going to work himself straight out of a job here. What's going on?

00:35:08.500 --> 00:35:13.220
This was, there were definitely jokes about like, this is just your attempt to get out

00:35:13.220 --> 00:35:20.980
of being the release manager for these releases. But yeah, so Hugo proposed this, this is kind

00:35:20.980 --> 00:35:27.260
of like a pre- PEP feeling out of how this situation should be and trying to pare down

00:35:27.260 --> 00:35:33.180
the options I think was Hugo's biggest question. What should we do it and should we pare down

00:35:33.180 --> 00:35:38.100
the options? Cause there's a million different ways we can do calendar versioning. And yeah,

00:35:38.100 --> 00:35:43.180
I think if you scroll down, there was a slide that had just every single possible calendar

00:35:43.180 --> 00:35:49.580
versioning possibility for Python and all the different languages. But yeah, calendar

00:35:49.580 --> 00:35:54.580
versioning is like really common for programming languages and other things that are similar

00:35:54.580 --> 00:36:02.100
to Python. And so this was basically like, Hey, we have this yearly release cycle that

00:36:02.100 --> 00:36:05.420
is been working for a while and we're probably going to keep doing it.

00:36:05.420 --> 00:36:09.900
It's worth pointing out for people who don't know that it used to be 18 months. And so

00:36:09.900 --> 00:36:15.340
the calendar versioning would get a little out of phase or something there. But now,

00:36:15.340 --> 00:36:19.620
that it's yearly in the fall, it really lines up perfectly.

00:36:19.620 --> 00:36:24.380
Yeah. And so this kind of assumes that we're going to keep doing the yearly thing, which

00:36:24.380 --> 00:36:29.100
I'm fine with the yearly thing, but yeah, as long as we kept the yearly schedule, it

00:36:29.100 --> 00:36:33.860
would line, like the release year would line up with whatever the, so it would be like

00:36:33.860 --> 00:36:40.380
the ended, the one that was like most agreed upon was like three dot and then a two digit

00:36:40.380 --> 00:36:45.220
year or what would end up becoming a three digit year when we roll over to a hundred,

00:36:45.220 --> 00:36:50.540
assuming that Python is still used in a hundred years. But yeah, so like that was kind of

00:36:50.540 --> 00:36:55.300
like the one that was most palatable to core devs or people were most excited about.

00:36:55.300 --> 00:37:01.460
And I think the big reason why switching to like a Calver year was interesting is that

00:37:01.460 --> 00:37:07.100
we have this thing called like support lifetime. So like how long is CPython supported? How

00:37:07.100 --> 00:37:11.180
long do you get security fixes? How long do you get bug fixes?

00:37:11.180 --> 00:37:18.460
Right. Like let me, yeah, exactly. Like, let me put this out to the audience. Is Python

00:37:18.460 --> 00:37:25.580
3.8 supported or is it not supported? I don't know. You got to do, you got to do math. You

00:37:25.580 --> 00:37:31.020
got to think about it. Yeah. So 3.7 just recently dropped support, right? Which is crazy. Cause

00:37:31.020 --> 00:37:36.460
that seems like a pretty new version of my mind, but it totally makes sense. But if you

00:37:36.460 --> 00:37:41.220
just knew it's supported for how many years, six years, five years, it's five years for

00:37:41.220 --> 00:37:47.500
security releases, I believe. Yeah. So then you're like, it's 2025. So, you know, 2020

00:37:47.500 --> 00:37:55.340
out the math becomes a lot easier. And then you also say like, do I have the current one,

00:37:55.340 --> 00:37:58.940
right? If you're not tracking it super carefully, like 3.11, is that the latest? Like, I don't

00:37:58.940 --> 00:38:04.220
know. I don't, I only use Python every like once a month, but was it 2023? Oh, I see.

00:38:04.220 --> 00:38:09.300
Well, maybe that's not the latest one. Okay. Yeah. Yeah. So it was just an interesting

00:38:09.300 --> 00:38:13.700
conversation about figuring out what the best potential option was. And then Hugo ended

00:38:13.700 --> 00:38:21.020
up creating a PEP and I think that's being discussed right now. So. Cool. Why not 2024?

00:38:21.020 --> 00:38:28.180
Why 24? Because that feels, I don't know, it just feels like you've just point shifted

00:38:28.180 --> 00:38:34.180
what you're doing now rather than, than really clear. Cause you know, as a new person coming

00:38:34.180 --> 00:38:38.300
in, you don't see that and go, it's 24. So it must be 2024. And unless you really like

00:38:38.300 --> 00:38:43.420
put together the calendar, but if it's a dot 2024, you're like, I bet that's the year,

00:38:43.420 --> 00:38:47.660
you know? Right. Yeah. I mean, cause eventually the, in the not too distant future, there

00:38:47.660 --> 00:38:56.340
will be a Python 3.24. Exactly. Yeah. We'll see. So there's going to be a pepper on this.

00:38:56.340 --> 00:39:02.700
You say, in fact, it says right here, PEP 604, right? I think it's PEP. What is it like?

00:39:02.700 --> 00:39:06.540
Well, you know, that's the, just the yearly announcement. You scroll down all the way

00:39:06.540 --> 00:39:11.660
to the bottom. It'll find some peps. Yeah. There's a lot of drafting. It just says drafting

00:39:11.660 --> 00:39:17.100
a PEP. Give that a click. I'm pretty sure there's a number 2026. There we go. Okay.

00:39:17.100 --> 00:39:22.740
Yeah. Oh, so that's going to be a while till they release this PEP. Well, so I'm just kidding.

00:39:22.740 --> 00:39:28.820
The most, the most important part of this discussion was that the Python version

00:39:28.820 --> 00:39:39.260
3.14 be, be preserved Python. So yeah, cool. It wasn't allowed for three, 3.14 to change

00:39:39.260 --> 00:39:45.820
it. Yeah. The only thing that I can think of that you would have the two digits is that

00:39:45.820 --> 00:39:52.020
there's a lot of code and regular expressions and junk out there that checks for that. But

00:39:52.020 --> 00:39:56.420
you know, if we talk about some of the other stuff out there, like that's a pretty minor

00:39:56.420 --> 00:40:06.780
change. Like for example, free-threaded Python. Yes. Rethreaded Python. It's here. It is here.

00:40:06.780 --> 00:40:12.140
Sort of. You know what actually really surprised me is when I saw this PEP come through, is

00:40:12.140 --> 00:40:20.140
it 702 or something like that? It said, we're going to allow free threaded Python, which

00:40:20.140 --> 00:40:25.220
I'm going to have you explain for folks in a moment, but you're going to have to have

00:40:25.220 --> 00:40:28.380
a special build of it. And I thought, oh, well that means if you want to play with it,

00:40:28.380 --> 00:40:31.940
you're going to have to build your own. But I noticed that the installers now give you

00:40:31.940 --> 00:40:37.500
an option for it. Yeah, they do. Yeah. The installers pair side-by-side install. Right.

00:40:37.500 --> 00:40:44.220
Yeah. The, what is it? I think there's like a T that gets put onto your actual like. Yes.

00:40:44.220 --> 00:40:49.660
Python T is what you type instead of Python. Yeah. If you want the free threaded one. Yeah.

00:40:49.660 --> 00:40:54.540
I mean, free threading is here. I mean, there's options if you're compiling it yourself, you

00:40:54.540 --> 00:40:59.580
just enable some options. And I think I go over that in the actual blog post to the options

00:40:59.580 --> 00:41:05.460
that you actually use to try it out. And yeah, it free threading essentially is, it's a way

00:41:05.460 --> 00:41:12.340
to remove the GIL and move to a different like reference counting model, object counting

00:41:12.340 --> 00:41:18.340
model. And which is quite exciting for a lot of people, but it will, what it will end up

00:41:18.340 --> 00:41:25.540
meaning is that a lot of the packages that are written in C or that are relying on C

00:41:25.540 --> 00:41:31.460
Python APIs will have to get either, you know, tweaked a little bit to like use these slightly

00:41:31.460 --> 00:41:36.620
different C APIs to make it so that they play nicely with having no GIL enabled and with

00:41:36.620 --> 00:41:44.660
the new memory management. Yeah. It's super exciting. Changes from the ecosystem basically.

00:41:44.660 --> 00:41:49.940
Yeah. Just because you have threads doesn't mean you get perfect scalability across the

00:41:49.940 --> 00:41:58.860
cores. I can't remember who wrote this article. I said, Simon Willison, maybe who did some,

00:41:58.860 --> 00:42:01.700
yeah, I'm pretty sure it was Simon Willison who wrote one that said, look, we're going

00:42:01.700 --> 00:42:07.900
to take an algorithm that can, is kind of embarrassingly parallel and parallelize it.

00:42:07.900 --> 00:42:15.420
And it turned out to be something like 50% gain per core. So it was like he had eight

00:42:15.420 --> 00:42:21.420
cores and it was four times faster with free threaded Python than without, which is still

00:42:21.420 --> 00:42:28.540
if you can get your code to run four times faster, that's still really good. Right? Yeah.

00:42:28.540 --> 00:42:35.420
But it's, it's going to have, like you said, I think it's going to have an interesting

00:42:35.420 --> 00:42:43.260
requirement put on all the people building packages. Right. And I know when I hear people

00:42:43.260 --> 00:42:47.980
say, I think maybe you just said like, Oh, it's going to be the C extension packages

00:42:47.980 --> 00:42:51.980
that are really going to have to deal with it. Cause they, they all have to do locks

00:42:51.980 --> 00:42:58.100
in their thing. I think even in the Python code, there's certainly algorithms that have

00:42:58.100 --> 00:43:03.940
multiple steps that they'll get some data here. They'll work with the data. They'll

00:43:03.940 --> 00:43:09.300
make some changes, then they'll put the data back in the same place. And even that

00:43:09.300 --> 00:43:16.260
would be subject to a race condition. Right. And I think we're, you know, I've in long

00:43:16.260 --> 00:43:20.940
in the past did a lot of C++ I did a lot of C# and in communities like that,

00:43:20.940 --> 00:43:25.940
people are like always focused. They're like, always kind of crazy about two things, memory

00:43:25.940 --> 00:43:33.920
and threading. And we just don't do that in Python. We just, I think we have just levered

00:43:33.920 --> 00:43:39.260
the fact that the GIL gives us kind of enough coarse grain granularity, the execution of

00:43:39.260 --> 00:43:44.100
our code that it's just not something we hit a lot. And we don't try to do a ton of threading

00:43:44.100 --> 00:43:50.220
because it doesn't work all that well. However, this, this could expose lots of stuff. This

00:43:50.220 --> 00:43:58.140
could put a new focus on that. Yeah, definitely. Yeah. Just having more people using threading

00:43:58.140 --> 00:44:05.940
with Python, that that's going to be huge for finding thread safety issues. Yeah, it's,

00:44:05.940 --> 00:44:10.940
it's just really exciting. I think that and there's another blog post, a completely separate

00:44:10.940 --> 00:44:14.980
one that talks about like the C API. And there was some mention about like free threading

00:44:14.980 --> 00:44:20.420
and evolving the API so that it's a lot easier to use from a three, a free threading perspective.

00:44:20.420 --> 00:44:28.780
So like, there's a ton of work happening in here to make this as easy, hopefully brief

00:44:28.780 --> 00:44:33.820
kind of split in the ecosystem and then have it converge together. I think that's like

00:44:33.820 --> 00:44:38.620
the overall plan is like, okay, we gotta, we gotta have a way that if this is really

00:44:38.620 --> 00:44:43.060
not working out, we can go back. But if it is working, we need a way that we can actually

00:44:43.060 --> 00:44:44.660
land this thing as the default.

00:44:44.660 --> 00:44:50.180
Right, right, right. And the PEP discusses this is like, we're gonna, we're gonna see

00:44:50.180 --> 00:44:58.140
how it goes, which is really interesting. But I think it's not breaking in the sense

00:44:58.140 --> 00:45:03.620
that you can't still run Python three with the thing that you've got, you just might

00:45:03.620 --> 00:45:09.480
not be able to enable this free threading aspect of it for some time. Whereas from two

00:45:09.480 --> 00:45:17.220
to three, it's like you cannot run this library on three, period. There's no scenario which

00:45:17.220 --> 00:45:21.260
this is going to work because it needs to take into account this and it doesn't and

00:45:21.260 --> 00:45:28.820
so it's out. So I feel like there's more time and space to evolve it. And you could say,

00:45:28.820 --> 00:45:36.100
well, in this space, you know, this data science section of the world, we use these seven libraries

00:45:36.100 --> 00:45:39.740
and we're going to work and make them compatible so that we can get way better performance

00:45:39.740 --> 00:45:44.400
or you know, we're going to work to make sure that FastAPI and Pydantic support it really

00:45:44.400 --> 00:45:48.060
well so that we can scale our web servers better. Whatever.

00:45:48.060 --> 00:45:53.940
Yeah, no, this will be huge for for like web and, and data. I think that a lot of people

00:45:53.940 --> 00:45:59.860
are excited for this for a really good. Yeah, I totally agree. I totally agree. Okay, so

00:45:59.860 --> 00:46:06.580
this is a big deal. It's coming in 3.13. But you've got to run Python T for now. Yeah,

00:46:06.580 --> 00:46:11.020
it's 3.13. But it's also available in the pre releases. The first release candidate

00:46:11.020 --> 00:46:18.460
for 3.13 is out. So give it a test. If you haven't given it a test, give it a test. Yeah,

00:46:18.460 --> 00:46:25.660
very cool. All right, what's what one do we want to talk about next? We got just a couple

00:46:25.660 --> 00:46:33.500
more minutes to cover. We've got what about Python and mobile? I think that one's I know

00:46:33.500 --> 00:46:42.300
there's the black swan talk that Keith Russell McGee gave. And Carol willing also

00:46:42.300 --> 00:46:47.980
sort of shouted out like, there's a couple of places that are really, really important

00:46:47.980 --> 00:46:55.180
computationally in the world that Python kind of isn't. We should have it there. And number

00:46:55.180 --> 00:46:59.180
one has got to be mobile. Yeah, mobile and front end for me mobile and front end are

00:46:59.180 --> 00:47:05.420
the two. And like a far distant behind that is like, could I get a single binary out of

00:47:05.420 --> 00:47:09.980
my app that I can give to someone that's a different that also is in there, but it's

00:47:09.980 --> 00:47:15.020
it's like, not as important as, hey, I want to I want to build some mobile apps. Can I

00:47:15.020 --> 00:47:21.580
use Python? You know, I want to learn that with an easy language. I use Python. And ask

00:47:21.580 --> 00:47:28.380
me something else. Yeah, yeah, right. Like next question. Yeah, so this was, this was

00:47:28.380 --> 00:47:34.780
a, it's almost almost like a big status update on where Python is in the mobile space, which

00:47:34.780 --> 00:47:41.580
is really exciting, because they've made a ton of progress on getting like actual tiering

00:47:41.580 --> 00:47:47.660
of support for these platforms. So if you don't know, Python has a like platform support

00:47:47.660 --> 00:47:53.740
tiers where it's like tier one is like x86 Linux, right? Like, that's a, you know, 90%

00:47:53.740 --> 00:47:59.180
of PyPI downloads are that like, yeah, well, we want to support that one. And then as things

00:47:59.180 --> 00:48:05.740
like macOS, you know, x86 and arm and all of that, right. And then lower down, there's

00:48:05.740 --> 00:48:09.900
tier two, which is, you know, the platforms that they have people that are interested

00:48:09.900 --> 00:48:14.460
in them. But if those people were to go away, then we wouldn't actually have a way to support

00:48:14.460 --> 00:48:20.540
them. And tier three is like even more so, right. So having tier three support for Python

00:48:20.540 --> 00:48:25.500
for both Android and iOS for 313. Like, that's super exciting. It means that these things

00:48:25.500 --> 00:48:31.420
are getting actively tested. There's like integration testing on real platforms, and

00:48:31.420 --> 00:48:35.500
that there's people that care about it that are fixing bugs. And this is exactly what

00:48:35.500 --> 00:48:41.900
you need to get your platform supported. And so this is all being provided by Anaconda

00:48:41.900 --> 00:48:47.500
funding this project and beware. Okay. Yeah, that's right. They are, you know, beware.

00:48:47.500 --> 00:48:52.140
And Keith has been on this for a long time, but Anaconda have come along and put more

00:48:52.140 --> 00:48:57.980
time and energy behind it, in terms of funding. And I think people as well, I'm not sure,

00:48:57.980 --> 00:49:00.460
but certainly in funding, that's awesome.

00:49:00.460 --> 00:49:06.460
Yeah, so I think this was, it was both a status report and also kind of trying to figure out

00:49:06.460 --> 00:49:14.140
how these sorts of platforms can get tested more easily and like actually not having constant

00:49:14.140 --> 00:49:19.420
breaking because these platforms are so different from, you know, what almost every other core

00:49:19.420 --> 00:49:24.380
developer is using to develop Python or a lot more limited in terms of capabilities,

00:49:24.380 --> 00:49:27.340
and like lockdown in a security perspective too.

00:49:27.340 --> 00:49:33.660
And they have no regard for backwards compatibility. It's so frustrating. I got, I, you know,

00:49:33.660 --> 00:49:39.980
I have mobile apps for the talk Python courses that are in both iOS and Android app stores.

00:49:39.980 --> 00:49:47.580
And I'll get messages like, Hey, dear developer, if we see that you're built against three-year-old

00:49:47.580 --> 00:49:53.740
APIs, if you don't rebuild and republish your app in the next six months, we're taking it out.

00:49:53.740 --> 00:50:00.300
The last one I did this for was Google. I'm like three, three years. Okay. Can we,

00:50:01.180 --> 00:50:04.940
no, we can't get any better compatibility than that. Like, I just got to keep re-uploading the

00:50:04.940 --> 00:50:09.660
same thing, even if there's no changes. Like, so, you know, that's just a different mentality of

00:50:09.660 --> 00:50:11.740
like, ah, we changed all that. We don't like that anymore.

00:50:11.740 --> 00:50:17.820
Yeah. Luckily I'm, I'm actually not sure how affected Python in particular is by things like

00:50:17.820 --> 00:50:24.940
that. Cause that's like utilizing APIs, like mobile SDK APIs versus like the operating system

00:50:24.940 --> 00:50:26.540
of the phone, which.

00:50:26.540 --> 00:50:31.020
Yeah. Right. Like people would build apps with Python and then they would be subjected to these

00:50:31.020 --> 00:50:35.100
emails. And it's not even that I was necessarily using any of those APIs. It's just like, we see

00:50:35.100 --> 00:50:38.460
you're compiled against the wrong version. So try again, you know?

00:50:38.460 --> 00:50:44.780
Yeah, no, the, yeah, the difficulties that I've, at least from, from this talk have figured

00:50:44.780 --> 00:50:49.900
out is that like these platforms are just a lot more locked down. So like a lot of system calls

00:50:49.900 --> 00:50:54.620
won't be available that the test suite like assumes are available always.

00:50:54.620 --> 00:50:59.180
Sure. It's almost like a circuit Python sort of deal, but not that extreme.

00:50:59.820 --> 00:51:05.020
Yeah. It's like somewhere in the middle and figuring out how to all work together happily

00:51:05.020 --> 00:51:09.660
and develop on this similar code base that has all these different target platforms.

00:51:09.660 --> 00:51:15.740
Yeah, absolutely. Absolutely. Awesome. Well, I am, I'm really excited. I'm all here for it. If

00:51:15.740 --> 00:51:23.020
three years ago, I think it was when we started working on those mobile apps, if I could have

00:51:23.020 --> 00:51:28.300
used Python in a really solid way, a hundred percent, those apps to be built in Python, but

00:51:28.300 --> 00:51:34.460
just, there's so many, so much tooling and stuff around. Now you got to create a signed APK before

00:51:34.460 --> 00:51:38.940
you upload. There's a lot of stuff going on there. And so hopefully they, they get that. That would

00:51:38.940 --> 00:51:44.940
be, would be a game changer and just, you know, it's not on, it wasn't here. Almost surprised me

00:51:44.940 --> 00:51:52.780
that it wasn't here, but front end stuff, WebAssembly, PyScripts, Pyodide, all those

00:51:52.780 --> 00:51:57.900
things I think are in that same realm. Although they can just kind of ship stuff to the web

00:51:57.900 --> 00:52:06.620
because there's no gatekeepers, but still. Yeah. Was that mentioned anywhere during the

00:52:06.620 --> 00:52:14.060
summit that just didn't make a post? No, Wasm was not, there was no topic about Wasm specifically

00:52:14.060 --> 00:52:19.660
at this language summit at least. Yeah, sure. I think there was the previous year.

00:52:19.660 --> 00:52:27.100
Previous year there was. Yeah. Should we make PDB better? Does it matter?

00:52:27.100 --> 00:52:34.140
Are people using PDB? What do you think? Yeah. So this, this was all about, PDB is Python's

00:52:34.140 --> 00:52:39.740
debugger for people that don't know. If you've never used it, it lets you kind of like drop into,

00:52:39.740 --> 00:52:45.260
set a break point in Python and then drop into that exact spot with all the context and everything,

00:52:45.260 --> 00:52:50.060
which is really- At a lower level. Yeah. At a lower level than VS Code or PyCharm.

00:52:50.060 --> 00:52:55.980
Right. Exactly. Yeah. Like seeing all these like super internals of Python, if that's something

00:52:55.980 --> 00:53:06.060
that you really need. Right. And so this was a talk that was mostly about, okay, we have PDB,

00:53:06.060 --> 00:53:11.900
but now we have all of these new models like free threading and all of that. And also we're being

00:53:12.860 --> 00:53:19.180
a little bit held back by backwards compatibility. There's like a specific, really specific point

00:53:19.180 --> 00:53:26.380
where because of backwards compatibility reasons and PDB is a part of the Python standard library,

00:53:26.380 --> 00:53:31.740
it becomes difficult to break backwards compatibility, even if it would mean you get a

00:53:31.740 --> 00:53:37.100
bunch of really good stuff out of it. You can't always do that because people are depending on it.

00:53:37.100 --> 00:53:43.900
And I think that the, yeah, the recommendation was maybe we should develop this outside of the

00:53:43.900 --> 00:53:51.020
standard library so we can break backwards compatibility if it's not necessary and make

00:53:51.020 --> 00:53:55.420
it so that we can support multiple versions instead of just having it be per version. And

00:53:55.420 --> 00:54:00.780
yeah. Yeah. That's a good idea. That's exactly what I was thinking. Cause there's the whole

00:54:00.780 --> 00:54:06.300
dead batteries talk. Like, does this still belong here? I'm not necessarily thinking this should not

00:54:06.300 --> 00:54:15.180
be in Python, but yeah. Something broken out maybe, but take that exact code, break it out,

00:54:15.180 --> 00:54:22.620
but enhance it kind of independently. Yeah. I think the concern from some people in the room

00:54:22.620 --> 00:54:27.580
was that, oh, if we break this out onto PyPI, then it would potentially mean that it would not get

00:54:27.580 --> 00:54:33.580
the same level of contribution that PDB sees because it's part of Python. Right. Sure. And

00:54:33.580 --> 00:54:37.900
I mean, totally valid in my opinion too. Like being a part of Python is a huge,

00:54:37.900 --> 00:54:44.860
like blessing of like, yeah, this is something important. Right. But I think that there's,

00:54:44.860 --> 00:54:48.700
there's other ways to signal that that's something important. Like if you look at like my pie,

00:54:48.700 --> 00:54:54.460
my pie is underneath the Python GitHub organization. And so maybe something like that,

00:54:54.460 --> 00:54:59.820
right. Where it's this tool that is very actively used by core developers for development.

00:55:00.460 --> 00:55:05.180
And it is a little bit more official than, you know, just some random person putting something

00:55:05.180 --> 00:55:10.460
up on PyPI. This is core developers supporting this. And black is that way too, I believe, right?

00:55:10.460 --> 00:55:17.820
It is. So maybe something to signal just a little bit more of an official, this is a core developer

00:55:17.820 --> 00:55:22.060
tool. Here's why you should contribute to it instead of just, you know, a random project

00:55:22.060 --> 00:55:26.940
on PyPI, which definitely wouldn't be in that case. It would not, it would definitely not.

00:55:28.540 --> 00:55:34.540
All right. How about, how about a quick review of maybe some, some of the lightning talks?

00:55:34.540 --> 00:55:43.100
Any of these stand out? You know, Rust and Python is seriously one.

00:55:43.100 --> 00:55:47.660
Yeah. Emily's talk was, yeah, I was gonna say Emily's got a good one.

00:55:47.660 --> 00:55:53.020
Emily has a really good one because, and this is like, it's, it's almost meta, right? Because

00:55:53.020 --> 00:55:59.500
lightning talks are not submitted ahead of time. You actually have to submit them during other

00:55:59.500 --> 00:56:04.460
people's talks, like to the list that you want to talk about this and then put together some

00:56:04.460 --> 00:56:10.780
slides really quickly. So yeah, these talks are pretty impressive in that way, having mere minutes.

00:56:10.780 --> 00:56:18.540
But the Emily's talk was about, it was kind of like wrapping up a theme that was being heard

00:56:18.540 --> 00:56:22.140
multiple times over the course of the language summit. But obviously this is a problem outside

00:56:22.140 --> 00:56:28.460
of the language summit too, which is that when someone goes to make a prototype for a PEP,

00:56:28.460 --> 00:56:35.980
they are given, at least today, not a whole lot of support for doing that prototype because

00:56:35.980 --> 00:56:39.900
it's basically like, oh, we think that this should be developed outside of the standard library

00:56:39.900 --> 00:56:47.340
initially. Right. Like that's a really common determination that the steering council comes to.

00:56:48.380 --> 00:56:56.460
And so being able to have kind of like a, a standardized way that people do a PEP prototype

00:56:56.460 --> 00:57:01.500
outside of the standard library. So things like creating a repo and like having all of this

00:57:01.500 --> 00:57:07.820
existing infrastructure set up and maybe even hosting it under the Python GitHub organization

00:57:07.820 --> 00:57:12.940
to give it some like air of officiality of like, yeah, this is something like really big is

00:57:12.940 --> 00:57:18.620
happening here. It's not just like someone in a corner writing something, right. Like giving some

00:57:18.620 --> 00:57:24.060
more grandiosity to, to the work that's being done and not just kind of saying, oh, go away.

00:57:24.060 --> 00:57:27.980
Like that is the intention, right. But that's kind of how it can land sometimes.

00:57:27.980 --> 00:57:33.340
Right. And maybe setting up people for success, at least this is what we're going to expect from

00:57:33.340 --> 00:57:37.260
you. If you go through this process, then you've got, you're further down the pipeline of

00:57:37.260 --> 00:57:40.620
having that conversation for a PEP.

00:57:40.620 --> 00:57:47.180
Yeah, definitely. And like, if you're wanting to write something that is for Python, you know,

00:57:47.180 --> 00:57:53.020
you probably don't necessarily care about like setting up these exact workflows for publishing

00:57:53.020 --> 00:57:57.820
to PyPI. Like that's just a whole bunch of things that are in your way to actually being successful.

00:57:57.820 --> 00:58:02.460
So having that all be figured out already ahead of time for you

00:58:02.460 --> 00:58:04.380
makes things a lot easier for you. So,

00:58:04.780 --> 00:58:07.660
yeah. Yep. Yep.

00:58:07.660 --> 00:58:15.260
Let's, let's finish out with Yuri Silvanov's presentation,

00:58:15.260 --> 00:58:18.460
efficient data sharing between sub-interpreters. And it's interesting because

00:58:18.460 --> 00:58:24.540
we talked about free threaded Python, but the year before the big news

00:58:24.540 --> 00:58:33.340
was sub-interpreters and Eric Snow's work. And those are not directly competing type of things,

00:58:33.340 --> 00:58:35.020
but in a sense they're kind of competing.

00:58:35.020 --> 00:58:43.260
Yeah, they're definitely competing for being like the model of how to do efficient,

00:58:43.260 --> 00:58:45.660
you know, parallelism in Python.

00:58:45.660 --> 00:58:49.740
Yeah. How do we isolate this stuff so that we can avoid the guilt? We take it out and add

00:58:49.740 --> 00:58:55.020
different algorithms or do we just make copies of the interpreter and run them in isolation,

00:58:55.020 --> 00:59:01.100
but then you have this data sharing issue. I can't just share a pointer easily. Right. So

00:59:01.100 --> 00:59:01.900
what's this about?

00:59:02.620 --> 00:59:09.420
Yeah. So Yuri basically came with, and this was also, if you want the extended version,

00:59:09.420 --> 00:59:15.100
Yuri also gave like an actual PyCon talk about this library that he's developed called Memhive.

00:59:15.100 --> 00:59:16.940
And what's it called?

00:59:16.940 --> 00:59:20.460
Memhive. Like M-E-M-H-I-V-E.

00:59:20.460 --> 00:59:25.900
Yeah. All right. Awesome. And just for everyone listening just this week, last week, recently,

00:59:25.900 --> 00:59:30.700
all the videos of all the talks are now available on YouTube. So it's been a while coming, but you

00:59:30.700 --> 00:59:31.500
can go watch it now.

00:59:32.060 --> 00:59:37.020
Exactly. So go watch them all. If you missed out on a talk, go watch them. But yeah, this,

00:59:37.020 --> 00:59:45.420
so this library in particular is, it's basically a way using immutable data structures. There's this

00:59:45.420 --> 00:59:49.740
immutable data structure called an H-A-M-T. I actually don't know what it's short for, but

00:59:49.740 --> 00:59:54.940
it's a hash array map tree. There we go. It was in the, I wrote it down.

00:59:57.500 --> 01:00:05.740
And it's essentially like a way to have this tree that can be passed around and shared without

01:00:05.740 --> 01:00:11.980
worrying what the other processes, sub-interpreters are. They're not processes.

01:00:11.980 --> 01:00:17.660
The other sub-interpreters are doing to this data structure. So it enables a more efficient and safe

01:00:17.660 --> 01:00:22.700
way of sharing data. That's kind of like in a tree structure. And I think one, the demo that

01:00:22.700 --> 01:00:28.620
he ended up giving was about a dictionary-like data structure where, you know, you have a million

01:00:28.620 --> 01:00:33.260
keys and a bunch of sub-interpreter workers working on that data. And they're able to,

01:00:33.260 --> 01:00:38.940
because it is using this immutable data structure, the modifications and changes are all safe,

01:00:38.940 --> 01:00:41.740
but it's also like super scalable and performant.

01:00:41.740 --> 01:00:48.780
Yeah. Yeah. Yeah. The thing about parallelism and multi-threading is if it's immutable,

01:00:48.780 --> 01:00:51.660
you can have many things that you want reading from the same memory. It's only when they start

01:00:51.660 --> 01:00:52.780
writing does it matter. So.

01:00:52.780 --> 01:00:59.900
Exactly. Yeah. This has a way, a mechanism to capture the writes in a way that is safe. So that

01:00:59.900 --> 01:01:05.820
like the current one can see what has been written and then the other ones aren't affected because

01:01:05.820 --> 01:01:07.660
their copy is not changed.

01:01:07.660 --> 01:01:15.500
Okay. That sounds very interesting. We talked about the coming compatibility matrix of free

01:01:15.500 --> 01:01:21.340
threaded Python. This won't have that issue, right? This operates in the every version of Python.

01:01:21.740 --> 01:01:27.180
Yeah. So this, I would assume that this sort of module would be able to say like,

01:01:27.180 --> 01:01:34.940
I am ready for a GIL free world. So that's like the mechanism that I believe CPython has adopted

01:01:34.940 --> 01:01:41.180
for saying that your C module is ready for not having a GIL. You actually have to opt into it.

01:01:41.180 --> 01:01:45.820
And then that module will be allowed to run in a free threaded Python.

01:01:45.820 --> 01:01:50.460
Yeah. It's something I recently learned is there's separate wheeled builds for free

01:01:50.460 --> 01:01:54.380
threaded Python as well. So that's interesting.

01:01:54.380 --> 01:01:59.100
Yeah. It's its own, I don't know exactly the phrase for it, but yeah, its own wheel tag.

01:01:59.100 --> 01:02:00.940
Platform target or whatever.

01:02:00.940 --> 01:02:01.900
Platform. Yeah.

01:02:01.900 --> 01:02:06.780
Yeah. Yeah. Like free threaded gets appended to, you know, macOS arm 64 or whatever.

01:02:06.780 --> 01:02:07.920
Exactly.

01:02:07.920 --> 01:02:15.420
Yeah. Awesome. All right. Seth, this has been great. How about some parting thoughts? Let's

01:02:15.420 --> 01:02:20.140
close this out with just takeaways from the whole experience.

01:02:20.140 --> 01:02:26.140
Yeah. I mean, the language summit is lovely. One of the things that's like most important to me is

01:02:26.140 --> 01:02:31.180
like this whole aspect of storytelling. And so that's why I felt really, really happy that I

01:02:31.180 --> 01:02:36.220
was invited along to be able to tell these stories to all of you. And I think that having all of

01:02:36.220 --> 01:02:41.980
these different narratives all in one place of all of these huge themes about what Python is

01:02:41.980 --> 01:02:48.780
going through all at once. Right. Like it's really incredible how many different things are

01:02:48.780 --> 01:02:53.580
happening in Python all at once. And like sometimes when you're focusing on just one or just two,

01:02:53.580 --> 01:02:58.380
you can, you know, you don't have this huge context of, wow, Python is changing in like

01:02:58.380 --> 01:03:03.020
at least 20 different ways all at once. And we're somehow doing really, really well, I would say.

01:03:03.020 --> 01:03:09.420
Like, yeah, I have no doubt about any of, any of these huge changes that Python is going through,

01:03:09.420 --> 01:03:14.620
like to, to take it in the wrong direction. Like I'm feeling hopeful and excited about all of them.

01:03:14.620 --> 01:03:20.460
So it's an exciting time. Yeah, I am as well. And it is really tricky to get a picture,

01:03:20.460 --> 01:03:26.380
a holistic picture of the progress because there's a lot of different groups doing

01:03:26.380 --> 01:03:33.260
different things and there's no one person's or one company's job to get somebody to come and tell

01:03:33.260 --> 01:03:38.860
that story. So, yeah, thanks for giving us the insight here. It's been awesome. Yeah. Thanks

01:03:38.860 --> 01:03:43.900
for being on the show and I'm sure we'll have you back soon. Yeah. Sounds good. Thanks for having me.

01:03:43.900 --> 01:03:46.940
See ya. Bye.

