WEBVTT

00:00:00.000 --> 00:00:04.960
- Hey everyone out there in the live stream.


00:00:04.960 --> 00:00:06.080
Thanks so much for being here.


00:00:06.080 --> 00:00:07.560
It's great to see you all.


00:00:07.560 --> 00:00:09.640
So many exciting comments here.


00:00:09.640 --> 00:00:13.640
Unexpected maker, glad you were able to make it.


00:00:13.640 --> 00:00:15.960
Hello, Matt, Mike, Corey,


00:00:15.960 --> 00:00:17.400
thanks for the heads up on the talk.


00:00:17.400 --> 00:00:18.780
Hello, Johnny, Jim.


00:00:18.780 --> 00:00:21.720
Please keep the comments coming during the show.


00:00:21.720 --> 00:00:24.420
I'll try to send them along to Scott and Damien.


00:00:24.420 --> 00:00:27.200
And yeah, we'll go ahead and get started.


00:00:27.200 --> 00:00:28.160
You two are ready?


00:00:29.440 --> 00:00:30.280
- Yep.


00:00:30.280 --> 00:00:34.360
- Scott, Damien, welcome to Talk Python to Me.


00:00:34.360 --> 00:00:35.320
Damien, welcome back.


00:00:35.320 --> 00:00:37.360
Scott, great to have you here.


00:00:37.360 --> 00:00:38.200
- Thanks for having me.


00:00:38.200 --> 00:00:40.680
- Hi, yeah, thanks for having me as well.


00:00:40.680 --> 00:00:43.840
- Yeah, it's really good to have you both here.


00:00:43.840 --> 00:00:46.360
And normally I ask people how they got into programming.


00:00:46.360 --> 00:00:47.840
Damien, you've already told your story


00:00:47.840 --> 00:00:50.960
and maybe I think we'll mix it up just a little bit.


00:00:50.960 --> 00:00:53.960
Let's maybe just have you both do a quick introduction


00:00:53.960 --> 00:00:56.920
about how you fit into the Python world


00:00:56.920 --> 00:00:58.560
and what you're up to these days.


00:00:58.560 --> 00:01:01.280
Damian, you want to go first?


00:01:01.280 --> 00:01:02.280
Sure.


00:01:02.280 --> 00:01:08.760
Yeah, so I'm the creator of MicroPython.


00:01:08.760 --> 00:01:15.120
It's been a long journey in the past nine years or so.


00:01:15.120 --> 00:01:23.960
Before that, I was a theoretical physicist and I studied at Melbourne University in Australia


00:01:23.960 --> 00:01:27.560
and did a PhD in theoretical physics.


00:01:27.560 --> 00:01:29.780
my PhD was in extra dimensions


00:01:29.780 --> 00:01:32.560
and kind of string theory related stuff.


00:01:32.560 --> 00:01:33.600
- That's super cool.


00:01:33.600 --> 00:01:35.400
- Yeah, it was it's-


00:01:35.400 --> 00:01:38.800
- It's gonna be like, you know, astrophysics type thing.


00:01:38.800 --> 00:01:40.080
It's gotta be something small


00:01:40.080 --> 00:01:41.440
if you're working on MicroPython, right?


00:01:41.440 --> 00:01:42.960
Like if that's your-


00:01:42.960 --> 00:01:45.040
- Well, the thing with the particle physics


00:01:45.040 --> 00:01:47.000
is all about the tiny, tiny things.


00:01:47.000 --> 00:01:50.720
The box is sort of as small as we know,


00:01:50.720 --> 00:01:53.820
but also linking to cosmology,


00:01:53.820 --> 00:01:56.400
which is the really, really huge things.


00:01:56.400 --> 00:02:02.720
and the idea of cosmology is to link the tiny with the large.


00:02:02.720 --> 00:02:05.960
But yeah, that's all, I guess, very different


00:02:05.960 --> 00:02:08.840
from microcontrollers and programming and software


00:02:08.840 --> 00:02:10.560
and hardware and real tangible things.


00:02:10.560 --> 00:02:15.520
How do you get from physics to programming side of things?


00:02:15.520 --> 00:02:19.400
I always liked computers and programming.


00:02:19.400 --> 00:02:23.160
And I always had that as a side hobby.


00:02:23.160 --> 00:02:25.560
and I actually also studied computer engineering


00:02:25.560 --> 00:02:31.040
and mathematics, but physics was the thing I kept,


00:02:31.040 --> 00:02:33.940
I did sort of professionally, if you could say that,


00:02:33.940 --> 00:02:39.760
and always had on the side, microcontrollers and my desk


00:02:39.760 --> 00:02:44.080
and CNC machines and sort of half built robots.


00:02:44.080 --> 00:02:45.960
- Fantastic.


00:02:45.960 --> 00:02:51.320
- Yeah, so turned that eventually into MicroPython


00:02:51.320 --> 00:02:55.400
when I was doing a postdoc in Cambridge.


00:02:55.400 --> 00:02:59.400
And yeah, I did a Kickstarter with MicroPython,


00:02:59.400 --> 00:03:01.880
and then that all sort of continued on


00:03:01.880 --> 00:03:03.200
and continued and grew and grew.


00:03:03.200 --> 00:03:06.540
And that's how I sort of end up where I am now.


00:03:06.540 --> 00:03:07.380
- Cool.


00:03:07.380 --> 00:03:11.440
Kickstarter was so neat when it came out in 2015, 2014,


00:03:11.440 --> 00:03:13.360
whatever time that was.


00:03:13.360 --> 00:03:14.880
It seemed like it had such possibility.


00:03:14.880 --> 00:03:16.720
Now I don't hear about it as much anymore.


00:03:16.720 --> 00:03:18.560
I know it's still out there, but.


00:03:18.560 --> 00:03:19.840
- Yeah, I think it was a bit earlier than that,


00:03:19.840 --> 00:03:22.160
'cause we did it at the end of 2013


00:03:22.160 --> 00:03:24.360
and it had already been around a few years.


00:03:24.360 --> 00:03:29.440
Yeah, but it was such a huge thing back then.


00:03:29.440 --> 00:03:32.160
- Yeah, super cool that you'll answer on that.


00:03:32.160 --> 00:03:33.200
Scott, how about you?


00:03:33.200 --> 00:03:37.240
- So I got into programming with PHP was my first language.


00:03:37.240 --> 00:03:40.000
So I came kind of like from the website of things.


00:03:40.000 --> 00:03:44.560
And then when I wanted to do desktop apps, I found Python


00:03:44.560 --> 00:03:47.280
and you can still find a source for page,


00:03:47.280 --> 00:03:50.680
source Forge page for a program called Denu,


00:03:50.680 --> 00:03:52.500
which is like dynamic menu stuff


00:03:52.500 --> 00:03:55.440
for like managing your menus in Linux.


00:03:55.440 --> 00:03:59.560
That was my first Python program, that was 2004.


00:03:59.560 --> 00:04:01.240
So that's before I went to university


00:04:01.240 --> 00:04:03.740
and then I got a computer engineering degree


00:04:03.740 --> 00:04:07.840
and I taught some of the intro TA classes there


00:04:07.840 --> 00:04:09.680
and did like a Python version of it there.


00:04:09.680 --> 00:04:12.200
So like Python's kind of always followed me


00:04:12.200 --> 00:04:13.160
throughout my career.


00:04:13.160 --> 00:04:16.440
After university, I did six years in industry


00:04:16.440 --> 00:04:20.180
and then took a year off and did drone flight controller hardware stuff.


00:04:20.180 --> 00:04:23.140
And then when that was coming to an end,


00:04:23.140 --> 00:04:25.080
when I was going to have to find a new job,


00:04:25.080 --> 00:04:29.380
I went to Adafruit and said, "Hey, I need a job."


00:04:29.380 --> 00:04:32.540
And they were like, "Hey, we have this project in MyNarUK


00:04:32.540 --> 00:04:33.680
doing a project that we want."


00:04:33.680 --> 00:04:39.080
And it was to bring MicroPython to their boards


00:04:39.080 --> 00:04:43.280
that had a different microcontroller than what MicroPython supported originally.


00:04:44.180 --> 00:04:50.980
So that was in August of 2016 that I started working on the Adafruit version of MicroPython,


00:04:50.980 --> 00:04:52.820
which then became CircuitPython.


00:04:52.820 --> 00:05:00.380
So CircuitPython is a fork of MicroPython that originally was for Adafruit's microcontrollers,


00:05:00.380 --> 00:05:06.380
and we've really pushed it to be really uniform and a good beginner experience.


00:05:06.380 --> 00:05:09.380
So that's kind of how we fit in.


00:05:09.380 --> 00:05:10.380
Yeah, super interesting.


00:05:10.380 --> 00:05:11.380
In brief.


00:05:11.380 --> 00:05:14.740
Well, it sounds to me like with your drone experience


00:05:14.740 --> 00:05:18.100
and all the small servos and electronics


00:05:18.100 --> 00:05:19.660
and then this programming background,


00:05:19.660 --> 00:05:23.440
it's kind of a nice thing to bring together as well, right?


00:05:23.440 --> 00:05:27.580
- Yeah, I mean, like I had done Python for a long, long time


00:05:27.580 --> 00:05:29.460
and I had just gotten into embedded


00:05:29.460 --> 00:05:33.400
and I really liked that the software depth, so to speak,


00:05:33.400 --> 00:05:34.660
is like much thinner, right?


00:05:34.660 --> 00:05:36.060
Like there's a lot less software


00:05:36.060 --> 00:05:38.140
between the hardware and your code.


00:05:38.140 --> 00:05:39.500
And I thought that was really cool


00:05:39.500 --> 00:05:43.620
MicroPython was amazing how well it brings Python


00:05:43.620 --> 00:05:46.780
to those inexpensive devices.


00:05:46.780 --> 00:05:50.620
- Yeah, so MicroPython was first, Damian,


00:05:50.620 --> 00:05:54.980
and then CircuitPython was forked from it to,


00:05:54.980 --> 00:05:57.100
like Scott said, to make it work a little bit closer


00:05:57.100 --> 00:05:58.300
with the Adafruit stuff.


00:05:58.300 --> 00:06:01.100
Is that sort of the history of it there?


00:06:01.100 --> 00:06:01.940
- Yeah.


00:06:01.940 --> 00:06:05.420
I think there's a, well,


00:06:05.420 --> 00:06:08.420
there's sort of a different focus on the use,


00:06:08.420 --> 00:06:14.660
they're sort of the end user and what level of experience you have and


00:06:14.660 --> 00:06:18.020
kind of what you intend to do with the device.


00:06:18.020 --> 00:06:23.380
So I see it as MicroPython being used in industry and professionally


00:06:23.380 --> 00:06:30.820
to build products and CircuitPython is to support, well initially to


00:06:30.820 --> 00:06:33.860
support Ada for its hardware but also more for


00:06:33.860 --> 00:06:37.780
for kind of beginners and people who are getting into hardware and want to


00:06:37.780 --> 00:06:43.780
have a sort of much easier on-boarding with libraries and things that are


00:06:43.780 --> 00:06:46.820
working with the hardware that Adapter Fruit


00:06:46.820 --> 00:06:51.540
provides. So there's a real distinction there


00:06:51.540 --> 00:06:55.300
with the audience and therefore the kind of features and


00:06:55.300 --> 00:06:58.900
things that we focus on. So there's a lot of focus in


00:06:58.900 --> 00:07:04.020
MicroPython on code coverage and making sure


00:07:04.020 --> 00:07:08.500
things are really stable, we're as stable as we can make them across releases so that


00:07:08.500 --> 00:07:15.300
people who are working with MicroPython in a product can continue to work and


00:07:15.300 --> 00:07:21.860
be confident that updating will fix bugs and not change other things too drastically.


00:07:21.860 --> 00:07:29.060
We get a lot of sort of requests for features and bug fixes and


00:07:29.060 --> 00:07:35.140
things from people using it professionally. And so I have to keep an eye on a lot of


00:07:35.140 --> 00:07:41.140
all these things so that when they come together, all the people I know who are using MicroPython


00:07:41.140 --> 00:07:47.780
are not going to suddenly have the rug pulled out from under them when they switch


00:07:47.780 --> 00:07:52.580
to the next version because something else has changed. >> All right, that's an interesting


00:07:52.580 --> 00:07:57.580
the sort of pro production side versus Adafruit


00:07:57.580 --> 00:08:02.580
is so very welcoming towards, this is your first project,


00:08:02.580 --> 00:08:04.580
your first IoT thing.


00:08:04.580 --> 00:08:07.580
I like to build something for like a science project.


00:08:07.580 --> 00:08:09.580
I mean, Scott, maybe you could classify it better.


00:08:09.580 --> 00:08:13.580
You know, certainly better than I do what the specific focus is.


00:08:13.580 --> 00:08:15.580
But when I go to Adafruit and I look around,


00:08:15.580 --> 00:08:18.580
I get this feel that it's very much like these kits


00:08:18.580 --> 00:08:20.580
and very supportive of like getting started


00:08:20.580 --> 00:08:23.020
And not like, hey, how's your robot doing?


00:08:23.020 --> 00:08:24.180
Here's where you plug in the thing


00:08:24.180 --> 00:08:26.620
for your industrial car making robot.


00:08:26.620 --> 00:08:31.020
- Yeah, I mean, I think you're both right on it.


00:08:31.020 --> 00:08:34.300
I think there's a bit, two aspects to it.


00:08:34.300 --> 00:08:36.520
One is like the focus that I brought to the project.


00:08:36.520 --> 00:08:40.900
And I mentioned the TAing, the intro course in university,


00:08:40.900 --> 00:08:42.820
'cause I think that does have a lot of influence


00:08:42.820 --> 00:08:45.620
over how I drive our focus for CircuitPython


00:08:45.620 --> 00:08:48.320
is like, we're very focused on what that experience


00:08:48.320 --> 00:08:51.000
in the first five minutes that you've ever programmed,


00:08:51.000 --> 00:08:53.240
not just hardware, but programming in general,


00:08:53.240 --> 00:08:55.200
what that first five minute experience is.


00:08:55.200 --> 00:08:58.400
So we've done things like all of those CircuitPython boards


00:08:58.400 --> 00:09:01.960
that we now support are all show up as a USB drive


00:09:01.960 --> 00:09:04.680
once you've put CircuitPython on it.


00:09:04.680 --> 00:09:07.720
And so all of the tutorials and things that we've written


00:09:07.720 --> 00:09:09.900
on top of that is uniform across that.


00:09:09.900 --> 00:09:13.360
And then that dovetails nicely


00:09:13.360 --> 00:09:15.560
into Adafruit's business model,


00:09:15.560 --> 00:09:17.440
where they really do focus on beginners


00:09:17.440 --> 00:09:21.120
because the reality is there's far more beginners


00:09:21.120 --> 00:09:25.320
than there are intermediate and advanced electronics folks.


00:09:25.320 --> 00:09:27.480
So from a business perspective,


00:09:27.480 --> 00:09:30.520
Adafruit's interested in the beginner side


00:09:30.520 --> 00:09:34.360
just because that's where the vast majority of people are.


00:09:34.360 --> 00:09:38.640
- Yeah, I also feel like the zen or the ethos


00:09:38.640 --> 00:09:41.900
of Adafruit at the beginning was to inspire people


00:09:41.900 --> 00:09:44.360
getting into programming and getting into hardware


00:09:44.360 --> 00:09:45.600
like from the beginning, right?


00:09:45.600 --> 00:09:48.160
that was sort of almost why it was founded.


00:09:48.160 --> 00:09:50.920
- Yeah, I mean, like Adafruit started around,


00:09:50.920 --> 00:09:53.840
like it's always been a matter of open source software,


00:09:53.840 --> 00:09:56.800
open source hardware and open source tutorials, right?


00:09:56.800 --> 00:10:00.800
Like Lomor, the founder of Adafruit, who goes by Ladyada,


00:10:00.800 --> 00:10:04.560
like she started even before Adafruit was a company,


00:10:04.560 --> 00:10:07.000
writing tutorials about how people could go


00:10:07.000 --> 00:10:08.800
get all the parts to build this one thing.


00:10:08.800 --> 00:10:11.040
So that's very, you know,


00:10:11.040 --> 00:10:12.680
a lot of what we think about with CircuitPython


00:10:12.680 --> 00:10:15.320
is not necessarily teaching you to code from if statements


00:10:15.320 --> 00:10:18.800
but actually just getting you all the code to do a project.


00:10:18.800 --> 00:10:22.280
And then from there, now it's modifying that project


00:10:22.280 --> 00:10:23.200
in the way that you want,


00:10:23.200 --> 00:10:25.800
rather than starting from a blank screen.


00:10:25.800 --> 00:10:27.960
- Yeah, yeah, very cool.


00:10:27.960 --> 00:10:29.080
Coming out in the live stream,


00:10:29.080 --> 00:10:31.800
Sean Tibor from Teaching Python Podcast.


00:10:31.800 --> 00:10:33.040
Hey, Sean.


00:10:33.040 --> 00:10:35.160
He's a teacher who teaches programming.


00:10:35.160 --> 00:10:37.480
Also I know uses some of the Adafruit stuff


00:10:37.480 --> 00:10:38.320
and Circa Python.


00:10:38.320 --> 00:10:40.160
It says the speed from zero to blinky lights


00:10:40.160 --> 00:10:42.080
is really important for learning.


00:10:42.080 --> 00:10:47.080
We've got that study from the BBC micro bit


00:10:47.080 --> 00:10:49.960
where they gave that to, I guess,


00:10:49.960 --> 00:10:52.200
all seventh graders or something in the UK.


00:10:52.200 --> 00:10:53.820
I think that's roughly right anyway.


00:10:53.820 --> 00:10:57.160
And it really changed how many people saw themselves


00:10:57.160 --> 00:10:59.000
as interested in programming,


00:10:59.000 --> 00:11:01.760
especially young girls said,


00:11:01.760 --> 00:11:04.020
well, they're way more likely to take a programming course


00:11:04.020 --> 00:11:07.480
after having something physical and neat


00:11:07.480 --> 00:11:08.320
that you can play with


00:11:08.320 --> 00:11:10.620
rather than just a terminal with a print statement.


00:11:10.620 --> 00:11:14.220
So yeah, I think that I agree with that as well.


00:11:14.220 --> 00:11:16.340
What do you all think?


00:11:16.340 --> 00:11:21.340
- Yeah, I agree getting a blinking light is,


00:11:21.340 --> 00:11:24.620
it's the hell of a world of microcontrollers,


00:11:24.620 --> 00:11:27.860
but it's actually really quite hard,


00:11:27.860 --> 00:11:31.660
you know, whatever your piece of hardware is.


00:11:31.660 --> 00:11:34.500
So often when I'm making MicroPython work


00:11:34.500 --> 00:11:36.620
on a new piece of hardware,


00:11:36.620 --> 00:11:39.940
the thing you can get to is once you can get a blinking LED,


00:11:39.940 --> 00:11:41.880
then you're sort of set.


00:11:41.880 --> 00:11:43.120
But getting there is really hard.


00:11:43.120 --> 00:11:46.200
And I'm not talking actually about blinking an LED in Python.


00:11:46.200 --> 00:11:48.740
I'm just blinking an LED however you can


00:11:48.740 --> 00:11:51.320
in assembly or C or whatever.


00:11:51.320 --> 00:11:53.920
Because getting a tool chain working,


00:11:53.920 --> 00:11:56.200
making the plugging in the board, powering it up,


00:11:56.200 --> 00:11:57.520
knowing how to power it up,


00:11:57.520 --> 00:11:59.200
knowing how to get it into a mode


00:11:59.200 --> 00:12:01.180
where you can change the firmware on it.


00:12:01.180 --> 00:12:03.480
These things take, it can take days.


00:12:03.480 --> 00:12:04.960
I mean, or longer.


00:12:04.960 --> 00:12:08.040
- And why is my serial port working right


00:12:08.040 --> 00:12:10.680
and all sorts of stuff.


00:12:10.680 --> 00:12:14.280
- So to port MicroPython to a new microcontroller,


00:12:14.280 --> 00:12:17.200
once you've got a tool chain, a way to flash the device


00:12:17.200 --> 00:12:20.380
and you can blink an LED or write characters to a UART,


00:12:20.380 --> 00:12:22.720
then getting MicroPython working


00:12:22.720 --> 00:12:24.720
is probably another hour's worth of work.


00:12:24.720 --> 00:12:30.620
And then you've got the whole of MicroPython ecosystem


00:12:30.620 --> 00:12:31.460
that you can play with.


00:12:31.460 --> 00:12:34.600
But from a beginner's point of view,


00:12:34.600 --> 00:12:35.620
it's a similar sort of story.


00:12:35.620 --> 00:12:39.780
they want to they get something they've never done it before, they've got a piece of hardware and


00:12:39.780 --> 00:12:44.340
you know what's going on. So blinking an LED to get to that stage there's a lot of


00:12:44.340 --> 00:12:50.100
kind of conceptual hurdles and also you know maybe installing things on your computer hurdles as well


00:12:50.100 --> 00:12:57.140
but to get to a blinking LED is really the beginning and then from there you can be a


00:12:57.140 --> 00:13:02.980
whole sort of world of possibility opens up because you can see then how you can turn that into a real


00:13:02.980 --> 00:13:06.980
project. Yeah, start to work with the other sensors.


00:13:06.980 --> 00:13:10.980
Things like the accelerometers


00:13:10.980 --> 00:13:14.980
or motion or microphone


00:13:14.980 --> 00:13:18.980
or anything, right? Exactly, yep.


00:13:18.980 --> 00:13:22.980
Yeah, I think maybe it makes sense to pause for just a moment


00:13:22.980 --> 00:13:26.980
and define microcontroller for people. So I have a


00:13:26.980 --> 00:13:30.980
Mac mini here. It's small, right? That's not a microcontroller. I could


00:13:30.980 --> 00:13:36.420
get a Raspberry Pi which is even smaller, still not a microcontroller. Like give us a sense for


00:13:36.420 --> 00:13:45.380
the size of these boards and like what does the hardware look like? I mean it's not really


00:13:45.380 --> 00:13:54.340
physical size. A microcontroller itself is actually more complicated than a PC in some sense. But


00:13:54.980 --> 00:14:02.500
a PC like a Mac mini or a laptop or Raspberry Pi, that has a CPU in it


00:14:02.500 --> 00:14:06.900
and it's connected usually to a keyboard and a screen and maybe some audio


00:14:06.900 --> 00:14:10.100
and Wi-Fi or some kind of internet.


00:14:10.100 --> 00:14:15.540
And it's relatively straightforward, it's a CPU that is fast and does a


00:14:15.540 --> 00:14:19.460
lot of processing and can output to a screen at a high


00:14:19.460 --> 00:14:21.780
refresh rate and you can interact with it.


00:14:21.780 --> 00:14:28.420
But a microcontroller is a CPU plus a lot of other peripherals around it,


00:14:28.420 --> 00:14:38.260
like UART and SPI and I2C and I2S and Ethernet and Wi-Fi and then really low-level stuff like DMA


00:14:38.260 --> 00:14:44.980
and things that make the microcontroller work in a microcontrollery way, timers that interrupt it


00:14:44.980 --> 00:14:49.460
very precisely. So a microcontroller is what they say


00:14:49.460 --> 00:14:55.860
sometimes a system on a chip, SoC. It's a real tightly


00:14:55.860 --> 00:15:01.140
interconnected piece of silicon which has a CPU at the center which controls


00:15:01.140 --> 00:15:03.700
things, but what's more important is the things it's


00:15:03.700 --> 00:15:07.060
controlling. And it's got to do that in a really


00:15:07.060 --> 00:15:12.820
precise and real-time way so that what it's controlling,


00:15:12.820 --> 00:15:20.020
say a coffee machine or an airplane is guaranteed to work every time the same way and run for years


00:15:20.020 --> 00:15:25.060
without having any problems. But if you have a laptop and you know that's probably


00:15:25.060 --> 00:15:30.500
not going to run for years without needing to be upgraded or crashing for some reason.


00:15:30.500 --> 00:15:38.500
So yeah there is this kind of distinction there, it's a bit subtle but


00:15:39.220 --> 00:15:46.740
The microcontroller is a really precise machine and a really complex machine in the way it


00:15:46.740 --> 00:15:52.260
interacts. Would you say more real-time? Yes, that's one of its tasks is to be real-time.


00:15:52.260 --> 00:16:01.460
And it's not as powerful as a laptop or a PC, but it is more sort of capable.


00:16:04.020 --> 00:16:06.020
And also programming it is a lot harder.


00:16:06.020 --> 00:16:12.180
So I think it's important to say that microcontrollers are typically used


00:16:12.180 --> 00:16:16.380
to do a single task in a larger system.


00:16:16.380 --> 00:16:23.260
So think of your car and I think a Tesla has a microcontroller that manages the door handle, for example.


00:16:23.260 --> 00:16:27.180
So microcontrollers are in a lot of things.


00:16:27.180 --> 00:16:29.500
Damien said toasters is another example.


00:16:29.500 --> 00:16:32.500
So that means that they're everywhere.


00:16:32.500 --> 00:16:33.940
you just don't see them.


00:16:33.940 --> 00:16:37.140
And that has the benefit of being very low cost.


00:16:37.140 --> 00:16:40.420
So the microcontrollers, which are like the black chip


00:16:40.420 --> 00:16:42.260
on the circuit playground you see here,


00:16:42.260 --> 00:16:44.660
they're only like a couple centimeters square.


00:16:44.660 --> 00:16:46.660
You know, they'll cost under a dollar


00:16:46.660 --> 00:16:48.500
or a few dollars at most,


00:16:48.500 --> 00:16:52.180
which means that they're really inexpensive to get into.


00:16:52.180 --> 00:16:55.300
In terms of processing power,


00:16:55.300 --> 00:17:00.020
what you'll see is like if my desktop has 32 gigs of RAM,


00:17:00.020 --> 00:17:04.380
But a microcontroller will have anywhere from like eight kilobytes of RAM


00:17:04.380 --> 00:17:06.380
up to maybe a megabyte of RAM,


00:17:06.380 --> 00:17:10.020
or a few megabytes of RAM at the higher end.


00:17:10.020 --> 00:17:15.300
And the distinction between a microcontroller and a microprocessor


00:17:15.300 --> 00:17:18.300
also involves how good it is at doing multiple things.


00:17:18.300 --> 00:17:23.180
Specifically, there's memory protection stuff that will happen


00:17:23.180 --> 00:17:27.380
in your desktop CPU that a microcontroller typically cannot do.


00:17:27.380 --> 00:17:30.660
So really, it's usually just a single task thing.


00:17:30.660 --> 00:17:33.500
- So unlike macOS or Linux or whatever,


00:17:33.500 --> 00:17:38.000
you've got the OS and then it's running your processes


00:17:38.000 --> 00:17:40.400
often in user space, they have protected memory,


00:17:40.400 --> 00:17:41.320
there's a bunch of them,


00:17:41.320 --> 00:17:43.980
the OS is doing preemptive multi-threading,


00:17:43.980 --> 00:17:45.260
all those kinds of things.


00:17:45.260 --> 00:17:47.860
This, your Python program,


00:17:47.860 --> 00:17:50.320
your MicroPython or CircuitPython


00:17:50.320 --> 00:17:52.980
basically is the operating system almost, right?


00:17:52.980 --> 00:17:55.000
It's like got full control.


00:17:55.000 --> 00:17:55.840
- Right.


00:17:55.840 --> 00:17:58.300
there's a real-time operating system under the hood,


00:17:58.300 --> 00:18:01.280
but in some other cases there isn't.


00:18:01.280 --> 00:18:03.180
- Okay, interesting.


00:18:03.180 --> 00:18:08.060
So one of the things that might be fun to talk about


00:18:08.060 --> 00:18:13.060
is we've got MicroPython and we've got CircuitPython


00:18:13.060 --> 00:18:16.620
and we've also, you know, when people say Python,


00:18:16.620 --> 00:18:20.000
they often mean python.org, CPython, Python.


00:18:20.000 --> 00:18:24.900
Damian, you wanna start us off with maybe like,


00:18:24.900 --> 00:18:29.060
What's the difference between this huge,


00:18:29.060 --> 00:18:31.560
I don't know how large it is, 40, 50 megabyte thing


00:18:31.560 --> 00:18:34.640
I download from python.org


00:18:34.640 --> 00:18:37.500
and then maybe what MicroPython is.


00:18:37.500 --> 00:18:38.940
What's the same and what's different?


00:18:38.940 --> 00:18:41.220
Can I take a random Python program


00:18:41.220 --> 00:18:44.940
and run it on MicroPython and so on?


00:18:44.940 --> 00:18:47.240
- Yeah, that's a really good question.


00:18:47.240 --> 00:18:52.380
And I guess, yeah, it's sort of the biggest thing


00:18:52.380 --> 00:18:55.860
about if it's called Python, like MicroPython,


00:18:55.860 --> 00:18:58.620
shouldn't it be just the same as Python?


00:18:58.620 --> 00:19:01.500
And why can't I just use Python instead if it's the same?


00:19:01.500 --> 00:19:07.640
So to begin with, you can't run Python


00:19:07.640 --> 00:19:11.580
on a little microcontroller because Python,


00:19:11.580 --> 00:19:13.540
it uses too much memory is kind of the base,


00:19:13.540 --> 00:19:15.740
really the reason.


00:19:15.740 --> 00:19:18.300
- Just to load the runtime libraries probably exceeds


00:19:18.300 --> 00:19:20.100
the entire working memory.


00:19:22.100 --> 00:19:26.660
just to load sort of the mapping table of Unicode character names is megabytes of data,


00:19:26.660 --> 00:19:34.820
which MicroPython obviously doesn't support. But so then one of the main things when I was writing


00:19:34.820 --> 00:19:42.500
MicroPython was to make sure it didn't use memory where possible. So all of the things that could be


00:19:42.500 --> 00:19:51.780
put into read-only memory or flash or ROM were put in there. So dictionaries and modules


00:19:51.780 --> 00:19:56.100
and things that are sort of built in like a sys module,


00:19:56.100 --> 00:20:00.020
all of that is in read-only memory in MicroPython


00:20:00.020 --> 00:20:03.460
and CircuitPython, whereas in normal Python


00:20:03.460 --> 00:20:07.940
pretty much everything is put into RAM.


00:20:07.940 --> 00:20:14.580
And so when you make, yeah, when you if you try to run Python on a


00:20:14.580 --> 00:20:19.620
CPython on a microcontroller you would need megabytes of RAM.


00:20:19.620 --> 00:20:24.980
and that really is the main difference, but then there's a lot of other


00:20:24.980 --> 00:20:30.820
things on a sort of a list of things that are different to make MicroPython efficient on a


00:20:30.820 --> 00:20:39.300
microcontroller, to make it small in code size, to make it run relatively efficiently, and as part


00:20:39.300 --> 00:20:43.940
of that we had to make some sacrifices in compatibility with CPython. So there are some


00:20:43.940 --> 00:20:50.340
things that are not the same, but for the most part it, MicroPython and CirclePython really do


00:20:50.340 --> 00:20:56.980
feel like normal Python. The syntax is the same at least up to a given Python version because Python


00:20:56.980 --> 00:21:02.980
keeps adding syntax. The syntax is exactly the same and the semantics of the syntax are the same,


00:21:02.980 --> 00:21:10.500
and a lot of the built-in types are, you know, one-to-one mapping with the same semantics and


00:21:10.500 --> 00:21:17.860
the same methods. So there's a lot of things down there that are very similar because


00:21:17.860 --> 00:21:23.780
Python is such a dynamic language and such a big language that it has so many sort of


00:21:23.780 --> 00:21:29.460
little corner cases and things that behave a certain way and when you're used to


00:21:29.460 --> 00:21:33.940
Python you're used to that. - I want to change that meta class so that this other thing does this other


00:21:33.940 --> 00:21:38.500
weird thing in this way and I'm expecting to patch that when we load this module and


00:21:39.060 --> 00:21:45.380
Yeah, yeah, exactly. - Scott's shaking his head like, "Maybe not." - But even down to things like how division


00:21:45.380 --> 00:21:51.460
and modulo work with negative numbers is sort of very specific, you know, when you have a modulo b


00:21:51.460 --> 00:21:56.580
and the negative numbers then the answer is a certain way and MicroPython copies that as well.


00:21:56.580 --> 00:22:02.660
So there's a lot of subtleties there that you may not realize that over the years we've gotten,


00:22:02.660 --> 00:22:07.300
to make sure it's the right thing, CPython just because we've got a lot of tests and a lot of


00:22:07.300 --> 00:22:14.980
people giving feedback when it's not exactly as they expect. And yeah, I mean, I've definitely


00:22:14.980 --> 00:22:20.500
learned so much about CPython and, well, the Python language, because so many things I had no idea


00:22:20.500 --> 00:22:25.460
about. - You had to get the exact nuanced details of how this thing or that thing works, right?


00:22:25.460 --> 00:22:30.820
To make sure it's the same. One of the things that I think is worth keeping in mind as people think


00:22:30.820 --> 00:22:36.340
about this is when somebody says, "I love Python" or "I think Python works this way" or "Python is


00:22:36.340 --> 00:22:38.960
is this thing and it's productive or it's whatever,


00:22:38.960 --> 00:22:40.100
it's slow, it's fast.


00:22:40.100 --> 00:22:43.800
They often can be talking about many things.


00:22:43.800 --> 00:22:45.100
Somebody could say, I love Python


00:22:45.100 --> 00:22:46.700
and they mean the Python syntax.


00:22:46.700 --> 00:22:47.980
Somebody could say, I love Python


00:22:47.980 --> 00:22:49.160
that I get the standard library.


00:22:49.160 --> 00:22:51.980
So cool that it comes with all of these things


00:22:51.980 --> 00:22:52.860
in the standard library.


00:22:52.860 --> 00:22:56.300
They could mean I pip installed pandas and requests


00:22:56.300 --> 00:22:58.260
and now something cool happened.


00:22:58.260 --> 00:22:59.100
- Right.


00:22:59.100 --> 00:23:00.900
- When you say Python runs there,


00:23:00.900 --> 00:23:02.460
there's like, you kind of got to say,


00:23:02.460 --> 00:23:03.820
okay, well, what are we talking about?


00:23:03.820 --> 00:23:07.540
Are we, it's mostly the language for sure,


00:23:07.540 --> 00:23:10.580
but there's gotta be a ton of standard library things


00:23:10.580 --> 00:23:11.400
that don't make sense.


00:23:11.400 --> 00:23:14.460
Like there's this one about parsing CSS hex values,


00:23:14.460 --> 00:23:15.820
like who cares?


00:23:15.820 --> 00:23:17.640
Tkinter, don't care.


00:23:17.640 --> 00:23:19.980
- Yeah, I did.


00:23:19.980 --> 00:23:21.620
- SQLite, maybe, I don't know.


00:23:21.620 --> 00:23:22.460
- Yeah.


00:23:22.460 --> 00:23:26.360
- I was gonna say, I did actually do a like lightning talk


00:23:26.360 --> 00:23:30.060
at the last language summit, kind of on this topic.


00:23:30.060 --> 00:23:33.100
And like Damian was saying, like to his credit,


00:23:33.100 --> 00:23:36.940
MicroPython is Python in the core syntax areas


00:23:36.940 --> 00:23:38.140
and the built-in types.


00:23:38.140 --> 00:23:39.640
But as you kind of grow outwards


00:23:39.640 --> 00:23:41.360
into like the standard library,


00:23:41.360 --> 00:23:44.980
things get omitted a lot.


00:23:44.980 --> 00:23:49.140
Because frankly, the standard library in CPython is large.


00:23:49.140 --> 00:23:52.100
And so I did kind of a comparison there


00:23:52.100 --> 00:23:54.220
and I can share people with the slides,


00:23:54.220 --> 00:23:56.580
but like take all this stuff in CPython


00:23:56.580 --> 00:23:58.740
and show what's in CircuitPython.


00:23:58.740 --> 00:24:00.140
- That's cool.


00:24:00.140 --> 00:24:02.280
- I've been having like discussions off and on


00:24:02.280 --> 00:24:03.720
with Brett Cannon about this as well,


00:24:03.720 --> 00:24:05.240
'cause he's been thinking about like,


00:24:05.240 --> 00:24:07.840
how would you define like a minimum version of Python?


00:24:07.840 --> 00:24:11.440
And I think that MicroPython did such a great job of that.


00:24:11.440 --> 00:24:13.080
It feels like Python to me,


00:24:13.080 --> 00:24:15.920
I had the background in Python before,


00:24:15.920 --> 00:24:18.780
so like coming to MicroPython, it felt very natural.


00:24:18.780 --> 00:24:23.400
So I think we're a good case for that.


00:24:23.400 --> 00:24:25.560
- Yeah, I think you definitely are.


00:24:25.560 --> 00:24:26.760
You know, Brett was,


00:24:26.760 --> 00:24:29.440
I know he's been thinking a lot about WebAssembly


00:24:29.440 --> 00:24:30.680
and what would it look like


00:24:30.680 --> 00:24:32.420
if we could have Python and WebAssembly


00:24:32.420 --> 00:24:33.540
and we could have it in these other,


00:24:33.540 --> 00:24:35.660
you know, like what would a mobile Python look like


00:24:35.660 --> 00:24:37.440
and these different environments


00:24:37.440 --> 00:24:40.120
that are not just desktops plus servers


00:24:40.120 --> 00:24:45.120
and having this standard core Python subset


00:24:45.120 --> 00:24:46.860
is a pretty neat idea, yeah.


00:24:46.860 --> 00:24:49.520
A couple of things from the live stream,


00:24:49.520 --> 00:24:52.100
Sean has a warning for everyone who gets into this


00:24:52.100 --> 00:24:55.000
that these microcontrollers tend to multiply quickly.


00:24:55.000 --> 00:24:56.040
He started with just one or two


00:24:56.040 --> 00:24:57.320
and now he has a whole collection.


00:24:57.320 --> 00:25:00.400
I can't see what's in your background, Damian,


00:25:00.400 --> 00:25:02.740
but Scott, you seem to have a bunch of these things


00:25:02.740 --> 00:25:04.580
gathered around.


00:25:04.580 --> 00:25:07.620
- Oh yeah, this room is a mess right now.


00:25:07.620 --> 00:25:10.980
I probably have at least a dozen on my desk though as well.


00:25:10.980 --> 00:25:15.340
- Yeah, I just got to find new and inventive ways


00:25:15.340 --> 00:25:16.940
of actually organizing them.


00:25:16.940 --> 00:25:21.060
'Cause I mean, this thing like, you know,


00:25:21.060 --> 00:25:25.740
a box full of dev boards sort of in plastic blister packs.


00:25:25.740 --> 00:25:27.860
- Yeah, I take it back.


00:25:27.860 --> 00:25:30.940
- The blister packs are too big, I try to take those out.


00:25:30.940 --> 00:25:31.780
- Yeah.


00:25:31.780 --> 00:25:36.100
- I have bins per manufacturer, so like STM, NRF,


00:25:36.100 --> 00:25:39.140
Atmel, of all the different development boards.


00:25:39.140 --> 00:25:39.980
- Yeah.


00:25:39.980 --> 00:25:43.940
I don't know, there's just, yeah,


00:25:43.940 --> 00:25:45.940
there's a whole lot of stuff everywhere.


00:25:45.940 --> 00:25:49.420
- They're inexpensive, they're impulse buyable,


00:25:49.420 --> 00:25:50.420
which is bad.


00:25:50.420 --> 00:25:52.420
- Exactly, I'll take three of those and one of these,


00:25:52.420 --> 00:25:53.700
and yeah, amazing.


00:25:53.700 --> 00:25:56.380
But it's gotta be a collection of cool little things.


00:25:57.260 --> 00:26:00.380
Yeah, it's also important to figure out


00:26:00.380 --> 00:26:04.660
what each individual microcontroller can do uniquely.


00:26:04.660 --> 00:26:07.460
What makes something unique?


00:26:07.460 --> 00:26:09.740
It's obvious, if it's a BLE chip,


00:26:09.740 --> 00:26:11.540
then that's obviously what you wanna do.


00:26:11.540 --> 00:26:14.220
If it's Wi-Fi, that's what it can do.


00:26:14.220 --> 00:26:17.300
But the RP2040, which is the new chip from Raspberry Pi,


00:26:17.300 --> 00:26:20.500
they have this really weird, unique peripheral


00:26:20.500 --> 00:26:23.820
that allows to do really, really, really real-time stuff.


00:26:24.680 --> 00:26:27.280
because an actual CPU in a microcontroller


00:26:27.280 --> 00:26:31.080
is still not perfectly real-time.


00:26:31.080 --> 00:26:33.120
So they have this special thing that they added


00:26:33.120 --> 00:26:35.680
that can do some really impressive real-time stuff.


00:26:35.680 --> 00:26:38.080
So it's very interesting to see the stuff


00:26:38.080 --> 00:26:39.580
that's standard between all these things


00:26:39.580 --> 00:26:42.000
and then what's different.


00:26:42.000 --> 00:26:43.680
- Yeah, I can imagine.


00:26:43.680 --> 00:26:45.600
All right, well, one more interesting thing


00:26:45.600 --> 00:26:47.760
I wanna ask you about from the live stream.


00:26:47.760 --> 00:26:50.240
Tim out there asks,


00:26:50.240 --> 00:26:52.040
"What are your thoughts on CircuitPython


00:26:52.040 --> 00:26:53.800
being used in TI calculators?"


00:26:53.800 --> 00:26:58.800
So the new TI-84 comes with programming as,


00:26:58.800 --> 00:27:01.660
and you can write Python.


00:27:01.660 --> 00:27:02.860
Where's the bit in here?


00:27:02.860 --> 00:27:05.400
I don't remember what the,


00:27:05.400 --> 00:27:07.700
oh, here it is, the programming bits where you can see.


00:27:07.700 --> 00:27:11.320
But yeah, I mean, I remember programming in calculators


00:27:11.320 --> 00:27:14.240
being-


00:27:14.240 --> 00:27:15.080
- Yeah, I did that.


00:27:15.080 --> 00:27:16.140
- Really weird.


00:27:16.140 --> 00:27:18.700
Yeah, I didn't see what, I mean, a little bit funky,


00:27:18.700 --> 00:27:21.600
but, you know, having Python there is quite neat as well.


00:27:22.760 --> 00:27:24.960
- Yeah, so this is a fork of CircuitPython.


00:27:24.960 --> 00:27:26.960
- Interesting.


00:27:26.960 --> 00:27:30.360
- So it's not publicly released, which is totally okay.


00:27:30.360 --> 00:27:33.320
And they are careful not to call it CircuitPython,


00:27:33.320 --> 00:27:34.700
which is good as well.


00:27:34.700 --> 00:27:36.520
But that does mean that like,


00:27:36.520 --> 00:27:38.480
if you go to circuitpython.org/downloads,


00:27:38.480 --> 00:27:41.200
you won't find like the latest version of CircuitPython


00:27:41.200 --> 00:27:42.440
for your calculator.


00:27:42.440 --> 00:27:45.120
But generally, I think it's great.


00:27:45.120 --> 00:27:48.520
Like, I love seeing people build on CircuitPython,


00:27:48.520 --> 00:27:50.940
just like we've built on MicroPython.


00:27:50.940 --> 00:27:52.160
Like people should do that.


00:27:52.160 --> 00:27:59.040
really neat. Yeah, absolutely. And then another one out there that's neat that says, Matt says,


00:27:59.040 --> 00:28:04.080
"MicroPython and the new Lego Spike delighted the inner teenager in me."


00:28:04.080 --> 00:28:11.280
Did you catch that, Damien? You must have known about this, right? How do you take this news?


00:28:11.280 --> 00:28:18.240
Yeah, that was pretty amazing. It was a year or a couple of years ago, I think,


00:28:18.240 --> 00:28:23.120
what it may be the longer three years ago when they started, while they contacted me about it.


00:28:23.120 --> 00:28:31.600
So it's still an ongoing thing, there's a Lego education which is separate to sort of Lego


00:28:31.600 --> 00:28:38.080
retail. Lego education is for schools, I remember using that when I was in high school a long long


00:28:38.080 --> 00:28:43.760
time ago. It's obviously Lego but it's the different kit and it's different focus on what


00:28:43.760 --> 00:28:49.040
you do with it. And the Lego education these days, sort of the new version of Mindstorms is


00:28:49.040 --> 00:28:57.680
uses MicroPython in the hub, the sort of the central processing unit of the central sort of


00:28:57.680 --> 00:29:03.200
Lego control. - Do they expose that to the kids to play with or is it just like a runtime internal


00:29:03.200 --> 00:29:09.760
sort of thing? It's kind of both.


00:29:09.760 --> 00:29:16.800
The thing that you can get for Lego


00:29:16.800 --> 00:29:20.400
education is using MicroPython to implement


00:29:20.400 --> 00:29:25.200
sort of what the kids see, but I think there are plans to make


00:29:25.200 --> 00:29:27.840
it so that you can actually use MicroPython directly.


00:29:27.840 --> 00:29:29.600
That'd be really neat.


00:29:29.600 --> 00:29:30.440
- Yeah.


00:29:30.440 --> 00:29:32.920
So yeah, very cool.


00:29:32.920 --> 00:29:33.880
- Yeah, very cool.


00:29:33.880 --> 00:29:35.240
I think it's great.


00:29:35.240 --> 00:29:38.440
Scott, I asked about the comparison


00:29:38.440 --> 00:29:41.400
between MicroPython and CPython.


00:29:41.400 --> 00:29:43.400
You wanna close the circle


00:29:43.400 --> 00:29:45.520
and go from maybe the differences


00:29:45.520 --> 00:29:47.840
of MicroPython and CircuitPython.


00:29:47.840 --> 00:29:52.240
Like why are there two things here and whatnot?


00:29:52.240 --> 00:29:53.240
How people think about like,


00:29:53.240 --> 00:29:54.680
if I'm gonna work with one or the other,


00:29:54.680 --> 00:29:56.480
where would they go?


00:29:56.480 --> 00:30:00.620
Yeah, so I think the why is what Damon iterated earlier,


00:30:00.620 --> 00:30:03.580
is like our focus in CircuitPython really is beginners.


00:30:03.580 --> 00:30:10.780
And coming into Adafruit, I also knew that their model is that,


00:30:10.780 --> 00:30:12.540
like for every device that they sell,


00:30:12.540 --> 00:30:15.500
they provide example code and drivers for it.


00:30:15.500 --> 00:30:18.780
And because Adafruit was going to do this for the Python world,


00:30:18.780 --> 00:30:21.620
we had to make sure that the hardware abstraction layer,


00:30:21.620 --> 00:30:25.780
like the modules you import in Python that allow you access to the hardware,


00:30:26.020 --> 00:30:28.940
would be consistent across everything that runs CircuitPython.


00:30:28.940 --> 00:30:31.820
So you saw me get a little niggly about,


00:30:31.820 --> 00:30:34.740
it's not actually CircuitPython on the TI calculator,


00:30:34.740 --> 00:30:39.260
because I think the branding of CircuitPython is really important,


00:30:39.260 --> 00:30:42.620
because it means that you can download it from the website,


00:30:42.620 --> 00:30:46.380
you can use the APIs that we have standard as CircuitPython,


00:30:46.380 --> 00:30:49.980
and therefore all of our CircuitPython libraries work on top of that,


00:30:49.980 --> 00:30:52.820
all our guides for CircuitPython work on top of that.


00:30:54.460 --> 00:31:02.060
So that was really, you know, one of the more important things for us is having that uniform API that we can then build all of this Python software on top of.


00:31:02.060 --> 00:31:15.180
So that's, that's one of the main main differences, it should be, I should say that we do actually have this layer called Blinka now, that allows you to use micro Python under the hood, or actually see Python under the hood.


00:31:15.180 --> 00:31:19.620
But it presents that same circuit Python API for other things as well.


00:31:20.380 --> 00:31:23.100
So this line has been blurred some.


00:31:23.100 --> 00:31:29.740
But the thing that doesn't come with that is that in CircuitPython, we still do


00:31:29.740 --> 00:31:32.700
ensure that your workflow is the same as well.


00:31:32.700 --> 00:31:36.860
So all of the CircuitPython boards that you can download now, except in the future,


00:31:36.860 --> 00:31:42.620
this is going to change, show up as a CircuitPy drive, and you can edit the code.py file on it.


00:31:42.620 --> 00:31:45.100
It runs after you save it automatically.


00:31:45.100 --> 00:31:48.220
And it's really quick and easy to iterate on.


00:31:48.220 --> 00:31:50.300
So I would encourage--


00:31:50.300 --> 00:31:53.700
- There's a file watcher that looks at your source file


00:31:53.700 --> 00:31:54.980
that is the program.


00:31:54.980 --> 00:31:56.020
And if it sees a change,


00:31:56.020 --> 00:31:58.820
it kind of just reboots super quick and reruns it, right?


00:31:58.820 --> 00:31:59.900
- It's not even that smart.


00:31:59.900 --> 00:32:01.700
It's any write to the file system.


00:32:01.700 --> 00:32:04.580
It doesn't know what file you're writing to.


00:32:04.580 --> 00:32:07.500
It's just any write will trigger that.


00:32:07.500 --> 00:32:09.340
And the caveat I had is I'm working


00:32:09.340 --> 00:32:12.080
on a BLE only workflow as well.


00:32:12.080 --> 00:32:14.220
So in the future,


00:32:14.220 --> 00:32:16.380
there will be two ways of using CircuitPython.


00:32:16.380 --> 00:32:20.820
there will be a USB way and a Bluetooth low energy way.


00:32:20.820 --> 00:32:23.100
- So you don't have to actually connect physically


00:32:23.100 --> 00:32:26.120
to the thing, it could be over there and you can program it.


00:32:26.120 --> 00:32:30.880
- That ends from phones and tablets in particular.


00:32:30.880 --> 00:32:35.880
Devices that aren't really easily interoperable over USB.


00:32:35.880 --> 00:32:39.040
We wanna bring the beginner experience of programming


00:32:39.040 --> 00:32:42.260
in CircuitPython to those devices as well.


00:32:42.260 --> 00:32:43.220
So that's the caveat.


00:32:43.220 --> 00:32:44.860
Like right now everything does USB,


00:32:44.860 --> 00:32:49.740
but I'm like working on the micro bit V2 right now that will not be doing USB.


00:32:49.740 --> 00:32:52.020
It'll only be doing Bluetooth low energy.


00:32:52.020 --> 00:32:53.580
Yeah, that sounds more complicated.


00:32:53.580 --> 00:32:55.380
Yeah, it is.


00:32:55.380 --> 00:33:00.300
Very useful, but I just without a wire, you know, yeah, when my headphones like


00:33:00.300 --> 00:33:02.700
get disconnected, like, oh, interference, how frustrating.


00:33:02.700 --> 00:33:05.020
And but, you know, when that's your connection, right?


00:33:05.020 --> 00:33:06.300
Bluetooth is yeah.


00:33:06.300 --> 00:33:09.460
Bluetooth has come a long way and I have had it working a bit.


00:33:09.460 --> 00:33:13.900
a lot of the challenge with Bluetooth is there's no standard way of doing like


00:33:13.900 --> 00:33:20.460
file transfer. So we really like we're working on apps to be able to transfer files and apps


00:33:20.460 --> 00:33:25.420
that are letting you pull that will pull down all the example code and automatically load


00:33:25.420 --> 00:33:30.940
that over. And that file transfer API that we have is all public. So if folks want to


00:33:30.940 --> 00:33:35.180
a link to that, I can send them a link to that protocol. So yeah, there's a lot more


00:33:35.180 --> 00:33:39.500
work off the device to do for for this Bluetooth stuff.


00:33:39.500 --> 00:33:40.580
- That's cool.


00:33:40.580 --> 00:33:42.660
So I see on circuitpython.org,


00:33:42.660 --> 00:33:45.020
it says Blinka and CircuitPython libraries


00:33:45.020 --> 00:33:47.220
are just a pip install away.


00:33:47.220 --> 00:33:51.340
So if I'm working, but I'm on my desktop machine


00:33:51.340 --> 00:33:54.500
or server machine, can I still do like prototyping


00:33:54.500 --> 00:33:55.780
and try the libraries?


00:33:55.780 --> 00:33:57.420
What does that mean?


00:33:57.420 --> 00:34:00.620
- It's not every computer.


00:34:00.620 --> 00:34:02.300
If you're on a Raspberry Pi,


00:34:02.300 --> 00:34:04.580
it will work because that is supported.


00:34:04.580 --> 00:34:05.940
If you actually, I think if you click


00:34:05.940 --> 00:34:07.520
that single board computers link,


00:34:07.520 --> 00:34:11.000
it'll show you all the ones that we specifically support.


00:34:11.000 --> 00:34:15.040
But single board computer is like a Linux class computer


00:34:15.040 --> 00:34:20.040
that usually breaks out general purpose IO, GPIO.


00:34:20.040 --> 00:34:23.400
So that's kind of the class of Linux computers


00:34:23.400 --> 00:34:25.560
that you'll be able to use this on.


00:34:25.560 --> 00:34:26.400
- Okay.


00:34:26.400 --> 00:34:28.560
- And then we do also have a couple of cases


00:34:28.560 --> 00:34:31.200
where you could like plug something into your USB


00:34:31.200 --> 00:34:36.200
that would also like give you that GPIO on another device.


00:34:36.240 --> 00:34:39.160
- Yeah, okay, cool.


00:34:39.160 --> 00:34:41.080
Question from the live stream for Tim again,


00:34:41.080 --> 00:34:44.040
how has the workflow changed over the past?


00:34:44.040 --> 00:34:45.840
Hold on a second.


00:34:45.840 --> 00:34:49.160
There we go.


00:34:49.160 --> 00:34:52.760
Sorry, how has the workflow changed over the past few years


00:34:52.760 --> 00:34:55.320
for a CirclePython and MicroPython when deploying code?


00:34:55.320 --> 00:35:00.320
And it sounds like Matt's talking about MP remote.


00:35:00.320 --> 00:35:03.680
Damon, you wanna talk about what the deployment looks like?


00:35:05.200 --> 00:35:10.200
Yeah, there's a lot of sort of answers to that question


00:35:10.200 --> 00:35:13.040
from a MicroPython point of view.


00:35:13.040 --> 00:35:15.900
As I mentioned, if you're using MicroPython in a product,


00:35:15.900 --> 00:35:19.200
then it's a really different setup


00:35:19.200 --> 00:35:21.760
as if you're using it in a hobby


00:35:21.760 --> 00:35:23.860
trying to make your light turn on and off.


00:35:23.860 --> 00:35:27.680
So using it in a professional setting,


00:35:27.680 --> 00:35:31.360
you'll probably have a big sort of workflow or setup


00:35:31.360 --> 00:35:33.840
where you can freeze the code into MicroPython


00:35:33.840 --> 00:35:38.480
deploy it or something like this. - Yeah, in production, what do you put actually on there?


00:35:38.480 --> 00:35:43.200
Do you go and say, "Well, we're going to put a PYC file there instead of the Python


00:35:43.200 --> 00:35:50.880
file," or is there stuff like that you might do? - Yeah, we have our MPYs sort of instead of PYC.


00:35:50.880 --> 00:35:57.040
Pre-compiled code, yes. But there's sort of a further step where you can take pre-compiled code


00:35:57.040 --> 00:36:02.320
and then sort of freeze that into a C data structure, which becomes part of the firmware


00:36:02.320 --> 00:36:09.600
itself. So big projects might have hundreds of Python files which are then all pre-compiled


00:36:09.600 --> 00:36:13.440
and frozen and then built into the firmware and then deployed onto the device.


00:36:13.440 --> 00:36:18.960
Is there any room for something like Cython or Numba or some one of these C compiler type things?


00:36:18.960 --> 00:36:27.520
Yeah, Cython don't really support that but you can write C code as well if you need to, if you


00:36:27.520 --> 00:36:32.560
really need speed, you can implement a module in C and then tie that into Python quite easily.


00:36:32.560 --> 00:36:41.200
So there are lots of options in terms of making things faster or efficient or the way you do your


00:36:41.200 --> 00:36:47.520
workflow, but sort of to get back to the original question, MPRemote is a new tool that was released


00:36:47.520 --> 00:36:56.720
in the last version and it's intended to make a workflow, well give you more options, you can


00:36:56.720 --> 00:37:03.520
use it to copy files on and off, get a REPL on the board, or one of the main features is to mount,


00:37:03.520 --> 00:37:11.520
so make your PC's file system available on the device that you're running on. So


00:37:11.520 --> 00:37:21.680
you mount the, you mount your PC's file system on your Pi board or ESP32 or whatever,


00:37:21.680 --> 00:37:25.920
and then when you go onto the board and do it os.lister


00:37:25.920 --> 00:37:29.360
you actually can list the files on your pc running


00:37:29.360 --> 00:37:35.520
on the board. So this allows you to basically do all your work on the pc and


00:37:35.520 --> 00:37:38.800
then your board can import and run code from


00:37:38.800 --> 00:37:42.480
the pc, read and write files from the pc.


00:37:42.480 --> 00:37:46.000
And so the workflow is very quick and when you're sort of


00:37:46.000 --> 00:37:49.360
happy you can then pre-compile or copy files


00:37:49.360 --> 00:37:57.840
MPY files onto the board to run it disconnected from the PC. This is also good for sort of


00:37:57.840 --> 00:38:05.200
testing integration tests of devices. They can sort of interact more closely with the PC that


00:38:05.200 --> 00:38:13.200
they're testing against, and yeah, just aims to provide you with more things, tools,


00:38:13.200 --> 00:38:15.880
- Fingertips to make your workflow more productive.


00:38:15.880 --> 00:38:17.440
- Yeah, that's neat.


00:38:17.440 --> 00:38:20.440
When I wanna put something onto my server


00:38:20.440 --> 00:38:25.440
to upgrade like a course site, something like that,


00:38:25.440 --> 00:38:27.040
I'll do some work locally.


00:38:27.040 --> 00:38:30.000
I'll do a Git push, some magic will happen.


00:38:30.000 --> 00:38:32.560
GitHub will do a webhook back over to the server.


00:38:32.560 --> 00:38:34.240
The server will grab that.


00:38:34.240 --> 00:38:37.120
It'll pull it down, install the new dependencies,


00:38:37.120 --> 00:38:40.160
restart the server through like a zero downtime


00:38:40.160 --> 00:38:41.920
sort of firewall type of thing.


00:38:41.920 --> 00:38:46.880
If I have a robot in a factory, what do I do?


00:38:46.880 --> 00:38:52.680
Is there a continuous deployment equivalent for things or what's the story look like over


00:38:52.680 --> 00:38:53.680
there?


00:38:53.680 --> 00:38:54.680
Yeah, that's a good question.


00:38:54.680 --> 00:39:02.480
I think this came up the last time we had a couple chats between the folks that work


00:39:02.480 --> 00:39:04.520
on CircuitPython and the folks that work on MicroPython.


00:39:04.520 --> 00:39:08.720
I think this was kind of a topic that we all said, "Yeah, that would be really nice."


00:39:08.720 --> 00:39:13.000
I mean, we don't have a sort of recommended


00:39:13.000 --> 00:39:15.280
or official way to do all of that.


00:39:15.280 --> 00:39:17.680
But I guess what you're talking about


00:39:17.680 --> 00:39:20.400
is over the air updates maybe kind of answers the question.


00:39:20.400 --> 00:39:21.400
- Yeah, basically, yeah.


00:39:21.400 --> 00:39:24.760
Like if I had a Tesla, sometimes I wake up in the morning,


00:39:24.760 --> 00:39:26.400
maybe my Tesla does different things.


00:39:26.400 --> 00:39:29.480
It's something like that, but for micropython things.


00:39:29.480 --> 00:39:32.960
- Well, if you have a factory full of robots,


00:39:32.960 --> 00:39:35.160
you probably don't want them to automatically update


00:39:35.160 --> 00:39:37.500
'cause you need to be there when it happens


00:39:37.500 --> 00:39:41.420
need to control it and do it at the right time and so on.


00:39:41.420 --> 00:39:44.860
It really depends heavily on the project that you have,


00:39:44.860 --> 00:39:48.540
but over the outdates are sort of definitely


00:39:48.540 --> 00:39:51.740
the way to do this and they have been done and they are


00:39:51.740 --> 00:39:55.580
sort of out in the field and they're done in lots of different ways


00:39:55.580 --> 00:40:00.460
like some over bluetooth where you download the new firmware and then


00:40:00.460 --> 00:40:03.500
it's a little like what's working on now yeah.


00:40:03.500 --> 00:40:09.660
Yeah, so an automated way to install the new code and then reboot.


00:40:09.660 --> 00:40:14.300
But and then other places where it's they're connected by a USB and you can


00:40:14.300 --> 00:40:18.940
just do a normal DFU upgrade or similar or maybe over


00:40:18.940 --> 00:40:22.700
i2c they're listening in a special mode to download new code.


00:40:22.700 --> 00:40:27.340
There are lots of ways to do it and there are


00:40:27.340 --> 00:40:30.780
lots of sort of parts in MicroPython's code that


00:40:30.780 --> 00:40:35.740
allow you to do it. And it really depends on your project.


00:40:35.740 --> 00:40:38.940
I think Scott has a different answer.


00:40:38.940 --> 00:40:42.140
Well I was gonna say from the hobby side like it's never


00:40:42.140 --> 00:40:46.300
I don't we don't focus on the automated update story.


00:40:46.300 --> 00:40:50.460
But you know a lot of the folks that that use CircuitPython are coming from


00:40:50.460 --> 00:40:54.860
an Arduino world. So Arduino is a really common


00:40:54.860 --> 00:40:58.460
hobby. It's based on C but it's got some like


00:40:58.460 --> 00:41:00.220
stuff on top of the C stuff.


00:41:00.220 --> 00:41:02.620
But it means that you have to have a computer that


00:41:02.620 --> 00:41:05.940
has Arduino installed that can compile the source code.


00:41:05.940 --> 00:41:09.220
And because we focus so much on this interaction of it


00:41:09.220 --> 00:41:12.140
shows up as a USB drive, it actually


00:41:12.140 --> 00:41:15.620
means that it makes it more accessible to update.


00:41:15.620 --> 00:41:19.660
So if I'm remote and somebody wrote the software for me once,


00:41:19.660 --> 00:41:21.380
but now they want me to update it,


00:41:21.380 --> 00:41:23.340
even though I don't understand how it's doing,


00:41:23.340 --> 00:41:24.540
I can plug it in.


00:41:24.540 --> 00:41:27.620
It shows up as a drive, and I can copy files over.


00:41:27.620 --> 00:41:30.960
So it's really has been beneficial for folks that way,


00:41:30.960 --> 00:41:33.060
whether it's the Python code they're updating,


00:41:33.060 --> 00:41:36.660
or a lot of our boards also come with a bootloader,


00:41:36.660 --> 00:41:38.340
which is like the software that manages


00:41:38.340 --> 00:41:39.660
what you're installing.


00:41:39.660 --> 00:41:41.980
And a lot of our bootloaders for devices


00:41:41.980 --> 00:41:43.860
also show up as a drive as well.


00:41:43.860 --> 00:41:48.560
So it's still a manual process,


00:41:48.560 --> 00:41:51.300
but it's a manual process that's gotten better


00:41:51.300 --> 00:41:53.300
from the previous things.


00:41:53.300 --> 00:41:55.020
- Right, and from the hobby perspective,


00:41:55.020 --> 00:41:56.580
you could have a little app or something that says,


00:41:56.580 --> 00:41:58.700
Oh, I noticed we're connected to this thing


00:41:58.700 --> 00:42:00.460
and we're just gonna, it's out of date.


00:42:00.460 --> 00:42:02.260
So we're just gonna push some stuff to it.


00:42:02.260 --> 00:42:04.820
- Yeah, we actually have some community members


00:42:04.820 --> 00:42:07.900
who've really fleshed out this app called CIRCUP,


00:42:07.900 --> 00:42:12.000
C-I-R-C-U-P, which you can pip install.


00:42:12.000 --> 00:42:14.260
And that will like figure out all the libraries


00:42:14.260 --> 00:42:16.300
on your CircuitPy drive that are out of date


00:42:16.300 --> 00:42:17.920
and update them for you.


00:42:17.920 --> 00:42:20.740
Which is pretty neat.


00:42:20.740 --> 00:42:24.580
So it's kind of like the pip of CircuitPython.


00:42:24.580 --> 00:42:25.900
- Yeah. - That's cool.


00:42:25.900 --> 00:42:27.180
- Yeah, that's very neat.


00:42:27.180 --> 00:42:29.700
Yeah, I'm just sure the requirements


00:42:29.700 --> 00:42:31.340
and concerns are extremely different


00:42:31.340 --> 00:42:34.040
if you're working with a small hobby device


00:42:34.040 --> 00:42:37.260
versus something that is controlling a robot


00:42:37.260 --> 00:42:40.940
or runs a thing that shouldn't go down.


00:42:40.940 --> 00:42:42.780
So one thing I wanted to definitely focus on


00:42:42.780 --> 00:42:43.860
while we were here together,


00:42:43.860 --> 00:42:46.420
seeing I find it is somewhere.


00:42:46.420 --> 00:42:48.700
Oh, it's hiding now this.


00:42:48.700 --> 00:42:52.940
There's a lot of work that has been done.


00:42:52.940 --> 00:42:56.300
it sounds to me like on the CircuitPython side


00:42:56.300 --> 00:42:58.740
to catch up with MicroPython.


00:42:58.740 --> 00:43:00.220
Is that right?


00:43:00.220 --> 00:43:01.860
Wanna tell us about that, Scott?


00:43:01.860 --> 00:43:04.300
- Yeah, so the history of this is like,


00:43:04.300 --> 00:43:08.020
when Adafruit started paying me to work


00:43:08.020 --> 00:43:09.620
on what became CircuitPython,


00:43:09.620 --> 00:43:11.540
it was like, okay, I'm gonna write a whole lot of code,


00:43:11.540 --> 00:43:13.740
right, so that's when on GitHub I hit fork.


00:43:13.740 --> 00:43:17.660
That's when I added a new port for @mlsamd,


00:43:17.660 --> 00:43:20.720
and that's kind of when we split.


00:43:20.720 --> 00:43:25.160
And later on, we decided like, oh, you know, like, we have enough changes here


00:43:25.160 --> 00:43:30.400
that it would be a lot of work for both Damien and us to get those changes merged back together.


00:43:30.400 --> 00:43:32.680
And that's still very true.


00:43:32.680 --> 00:43:38.680
But what I said at the time was that we would kind of keep pace for every stable release that we do,


00:43:38.680 --> 00:43:41.320
we would keep pace with stable releases from MicroPython.


00:43:41.320 --> 00:43:45.640
That wasn't true for about like two or three years.


00:43:45.640 --> 00:43:47.720
We stopped updating.


00:43:47.720 --> 00:43:49.720
We do it's basically a Git merge, right?


00:43:49.720 --> 00:43:52.060
So it's a whole lot of work.


00:43:52.060 --> 00:43:57.060
And so I did, we had six versions of MicroPython emerging.


00:43:57.060 --> 00:43:58.640
So I did those.


00:43:58.640 --> 00:44:03.640
That's like 112 through 115 or 110, something like that.


00:44:03.640 --> 00:44:08.360
And then since then, we've actually updated 116 as well.


00:44:08.360 --> 00:44:11.080
So what's involved with that is like,


00:44:11.080 --> 00:44:13.280
MicroPython has both like a Pi folder,


00:44:13.280 --> 00:44:15.640
which you can think of as kind of like the VM.


00:44:15.640 --> 00:44:17.500
We think of that as kind of the core.


00:44:17.500 --> 00:44:23.040
and then there's separate ports for each main type of chip that we support.


00:44:23.040 --> 00:44:26.880
And we don't really share code with MicroPython


00:44:26.880 --> 00:44:29.880
for those different implementations for different chips,


00:44:29.880 --> 00:44:31.880
but we do share that core Python VM.


00:44:31.880 --> 00:44:34.580
So a lot of the work to merge in MicroPython


00:44:34.580 --> 00:44:37.080
is like updating all of that core stuff.


00:44:37.080 --> 00:44:40.680
And the discussions that Damian and I have had


00:44:40.680 --> 00:44:42.720
along with the other folks that work on these two projects


00:44:42.720 --> 00:44:47.200
has been like, all right, what can we do just to get back to this world


00:44:47.200 --> 00:44:49.800
where we have the same copy of that Pi folder.


00:44:49.800 --> 00:44:54.520
Because there's like a few weird things


00:44:54.520 --> 00:44:55.740
that like CircuitPython has done


00:44:55.740 --> 00:44:58.000
that haven't been merged back into MicroPython


00:44:58.000 --> 00:45:00.320
and we've had discussions about


00:45:00.320 --> 00:45:01.920
which things are those are interesting


00:45:01.920 --> 00:45:04.160
and which ones would we wanna make configurable


00:45:04.160 --> 00:45:05.560
and things like that.


00:45:05.560 --> 00:45:06.720
- Yeah, interesting.


00:45:06.720 --> 00:45:08.200
- So now that we're updated,


00:45:08.200 --> 00:45:09.240
we have this foundation


00:45:09.240 --> 00:45:10.880
where we can have this discussion again


00:45:10.880 --> 00:45:14.000
because we actually can tell like what the differences are


00:45:14.000 --> 00:45:17.080
between the two latest versions of these projects.


00:45:17.080 --> 00:45:18.440
- Yeah.


00:45:18.440 --> 00:45:19.920
- Yeah, Larry Bank out the live stream says,


00:45:19.920 --> 00:45:21.640
"My imaging codec still haven't been merged


00:45:21.640 --> 00:45:22.920
into MicroPython."


00:45:22.920 --> 00:45:26.480
- There's a lot of things that haven't been merged


00:45:26.480 --> 00:45:27.680
into MicroPython.


00:45:27.680 --> 00:45:29.680
- Yeah, Damien, I was gonna ask you,


00:45:29.680 --> 00:45:31.360
what does this mean for MicroPython?


00:45:31.360 --> 00:45:33.800
Like obviously it makes sense for CircuitPython


00:45:33.800 --> 00:45:35.400
to just not be out of date.


00:45:35.400 --> 00:45:39.600
And the farther you are away from one of these merges,


00:45:39.600 --> 00:45:41.480
it's more like credit card debt.


00:45:41.480 --> 00:45:43.400
A little bit is fine, but as it gets farther,


00:45:43.400 --> 00:45:45.360
it starts to become a problem.


00:45:45.360 --> 00:45:47.720
But in reverse, there's probably a lot of things


00:45:47.720 --> 00:45:50.560
that people who are engaged on the CircuitPython side


00:45:50.560 --> 00:45:53.560
could bring back if it was basically the same.


00:45:53.560 --> 00:46:00.600
- Yeah, I mean, there are some, yeah,


00:46:00.600 --> 00:46:03.600
there's some great things that CircuitPython Squad has done


00:46:03.600 --> 00:46:08.220
with garbage collection for one thing.


00:46:08.220 --> 00:46:13.480
And it's, yeah, it would be great to share


00:46:13.480 --> 00:46:20.360
common py folder at least, and we've had, as he said, we've had discussions about


00:46:20.360 --> 00:46:27.400
sort of how we can smooth things or make things more common and where we know we differ,


00:46:27.400 --> 00:46:36.120
you know, how we can make it easier that we differ. So yeah, there's been recently actually


00:46:36.120 --> 00:46:43.880
a really good improvement in MicroPython for tab completion, so that it didn't have to be


00:46:43.880 --> 00:46:48.440
underscore and also tab completed imports, you do imports based tab and then it lists the


00:46:48.440 --> 00:46:57.720
tab completes the things you can import, and some good improvements for sort of fuzzing and


00:46:57.720 --> 00:47:05.160
sanitization of addresses and sort of various subtle bug fixes that have come across. So


00:47:05.160 --> 00:47:12.120
So it's yeah, look it's really great to have an open source project and because other people


00:47:12.120 --> 00:47:20.520
find bugs for you and fix them. So I think the more we can be in line the better.


00:47:20.520 --> 00:47:24.280
And there are actually other, I mean there are other people using MicroPython and CircuitPython


00:47:24.280 --> 00:47:33.160
as we saw with the calculator and Lego. And I think in the early days I was happy


00:47:33.160 --> 00:47:40.200
people were using MicroPython and wasn't too concerned about sort of people forking and


00:47:40.200 --> 00:47:46.680
changing things. But these days, I've shifted more towards, well, what can MicroPython do to


00:47:46.680 --> 00:47:52.520
make it easier for other people to use it without changing it? - Right, so when they're about to


00:47:52.520 --> 00:47:56.120
think, "Maybe I need to fork this to do this," you're like, "Well, why are they about to push that button?


00:47:56.120 --> 00:48:02.040
What can we do to make it more extensible or whatever it needs to be?" - Yeah, how can we make


00:48:02.680 --> 00:48:08.920
someone else's life easier so they don't have to fork. Not that we want to accommodate everybody,


00:48:08.920 --> 00:48:14.600
we can't, but does it make sense to talk with these people and then make sure that


00:48:14.600 --> 00:48:19.640
their needs can be met in a sensible way and maybe it helps everyone else as well?


00:48:19.640 --> 00:48:27.240
So yeah, it just helps the community when you have less sort of forking and more cohesion.


00:48:29.480 --> 00:48:34.120
Yeah, it absolutely does. I mean, we've seen the Python 2, Python 3 stuff mostly get resolved


00:48:34.120 --> 00:48:39.960
by people finally moving all onto the same place where the core devs spend their time, and I think


00:48:39.960 --> 00:48:45.240
that that's only been beneficial. It seems like a lot of projects are taking some of these ideas


00:48:45.240 --> 00:48:49.640
and picking up speed, whereas there used to be a lot of hesitancy as there's too many different


00:48:49.640 --> 00:48:57.160
paths in the road. Yeah, well, I'm just glad I did Python 3 from the beginning with MicroPython.


00:48:57.160 --> 00:49:01.700
I was just playing around with this.


00:49:01.700 --> 00:49:06.720
I was able to use like a smiley face emoji as a variable name and it just worked, which


00:49:06.720 --> 00:49:09.580
kind of blew my mind.


00:49:09.580 --> 00:49:15.100
So that's super credit to Damien for making MicroPython really, really strong, really


00:49:15.100 --> 00:49:18.220
robust and really Python.


00:49:18.220 --> 00:49:22.740
I think, you know, in terms of like CircuitPython and MicroPython, another thing that I think


00:49:22.740 --> 00:49:28.260
we can really complement MicroPython with is like, we can, we're willing to be more experimental.


00:49:28.260 --> 00:49:33.940
Damien alluded to this memory allocation thing that he, I pitched to him at one point, and he


00:49:33.940 --> 00:49:38.580
was like, "Well, we'll put it in CircuitPython, we'll see how it goes, and then you can decide


00:49:38.580 --> 00:49:44.500
whether you want it or not." So I think that's a benefit that we can have in CircuitPython is that


00:49:44.500 --> 00:49:49.860
like, because Damien really wants MicroPython to be stable, we can try things out in CircuitPython,


00:49:49.860 --> 00:49:53.700
and then he can pick the things that he wants to move into MicroPython.


00:49:53.700 --> 00:49:55.700
That's a fantastic way to look at it.


00:49:55.700 --> 00:49:58.660
The fact that you've got these merge differences,


00:49:58.660 --> 00:50:03.140
these version differences down to such a small gap.


00:50:03.140 --> 00:50:05.060
It's not like, "Well, that would have worked three years ago."


00:50:05.060 --> 00:50:06.260
I'm not sure it works now.


00:50:06.260 --> 00:50:09.780
Now you're basically experimenting on what is the real thing.


00:50:09.780 --> 00:50:10.980
Right.


00:50:10.980 --> 00:50:13.940
Yeah, and that's helpful for this tab complete thing


00:50:13.940 --> 00:50:16.980
where somebody added it into CircuitPython and we merged it,


00:50:16.980 --> 00:50:19.620
but then they also made a pull request to MicroPython


00:50:19.620 --> 00:50:24.180
and making sure that they're starting from a closer baseline will help everybody as well.


00:50:24.180 --> 00:50:25.140
- Yeah. - Yeah.


00:50:25.140 --> 00:50:30.340
- Yeah, and I mean, it's really good to hear you do 1.16, and we're trying hard from


00:50:30.340 --> 00:50:37.380
MicroPython's side to release every two months or so, so that it's either for everybody to upgrade


00:50:37.380 --> 00:50:40.260
and it doesn't take so long for a new release to come out.


00:50:40.260 --> 00:50:43.940
- Yeah, and what's the schedule for CircuitPython, Scott?


00:50:43.940 --> 00:50:49.220
We don't have a set timeline.


00:50:49.220 --> 00:50:51.980
We do try to get in a rhythm of--


00:50:51.980 --> 00:50:56.300
we do both stable and prerelease releases.


00:50:56.300 --> 00:50:58.780
And we don't have a fixed schedule,


00:50:58.780 --> 00:51:04.660
but we tend to try to have pretty recent prereleases out.


00:51:04.660 --> 00:51:07.620
And then if it's been long enough


00:51:07.620 --> 00:51:09.940
that we're recommending the prerelease over the stable


00:51:09.940 --> 00:51:13.260
release, we ask ourselves, OK, why aren't we just


00:51:13.260 --> 00:51:15.260
calling this a stable release.


00:51:15.260 --> 00:51:18.100
And that gives us a forcing function


00:51:18.100 --> 00:51:21.260
to up the stable release.


00:51:21.260 --> 00:51:25.180
We are in this window between major releases.


00:51:25.180 --> 00:51:30.260
So we're currently doing 7.0 stable--


00:51:30.260 --> 00:51:31.620
or pre-releases for that.


00:51:31.620 --> 00:51:34.860
And that's a chance when we did all these merges,


00:51:34.860 --> 00:51:36.580
because we get a lot of instability.


00:51:36.580 --> 00:51:38.500
Not because the code we're merging in is bad,


00:51:38.500 --> 00:51:40.460
but the merge is really hard.


00:51:40.460 --> 00:51:41.740
It's hard to get correct.


00:51:41.740 --> 00:51:47.420
So we're kind of in this very big state of flux right now with CircuitPython,


00:51:47.420 --> 00:51:52.300
where a lot of things are changing, and we're very quickly approaching this like,


00:51:52.300 --> 00:51:54.860
"All right, we got to stop changing things so that we can stabilize,"


00:51:54.860 --> 00:51:57.260
because we're no longer recommending the stable release,


00:51:57.260 --> 00:51:58.860
we're recommending the pre-release.


00:51:58.860 --> 00:51:59.980
Yeah.


00:51:59.980 --> 00:52:03.180
Because when somebody introduces a new board,


00:52:03.180 --> 00:52:05.820
and it's like, "Oh, well, that new board is not supported in the stable release,


00:52:05.820 --> 00:52:09.740
you have to use the pre-release," that's largely a forcing function for us.


00:52:10.780 --> 00:52:13.020
Interesting that the hardware is driving the software like that.


00:52:13.020 --> 00:52:18.940
Yeah, and that's a thing from like a number of us are funded by Adafruit to work on it.


00:52:18.940 --> 00:52:23.420
So when Adafruit releases new hardware, we have to decide like how we're going to make it available.


00:52:23.420 --> 00:52:29.820
Absolutely. All right. Let me take one question from the live stream. This is from Murray. Hey, Murray.


00:52:29.820 --> 00:52:33.500
I don't actually know the details, but I'll read to you. I'm sure you all do. Here's a different question.


00:52:33.500 --> 00:52:37.980
What's the state of MicroPython-lib project as regards to the bigger MicroPython project?


00:52:39.420 --> 00:52:51.900
Yes, that's a good question. The aim is to switch to, you know, improving


00:52:51.900 --> 00:52:59.020
MicroPython lib. It languished a bit because, well, there was just a lot of stuff to do in the


00:52:59.020 --> 00:53:07.660
main repository, but now that a lot of the code in the main repository has sort of stabilized and


00:53:08.620 --> 00:53:15.340
settle down and mature, there's more scope now to go and write everything, well write all the


00:53:15.340 --> 00:53:21.980
extra bits in Python and put them in MicroPython lib. So we have recently reorganized that


00:53:21.980 --> 00:53:32.620
repository to be a bit clearer as to what's in there, and the aim is to maintain it


00:53:32.620 --> 00:53:39.660
and keep it running and put lots of libraries in there, improve the


00:53:39.660 --> 00:53:44.940
CPython standard library support and other things. There you might have


00:53:44.940 --> 00:53:51.660
noticed there was AIOBLE which is a asynchronous Bluetooth library


00:53:51.660 --> 00:53:58.300
which is in MicroPython lib and is being used in production. It's pretty


00:53:58.300 --> 00:54:04.540
good in terms of stability, it's very good in terms of features and what it can do, it's really


00:54:04.540 --> 00:54:12.780
quite amazing how it makes Bluetooth simple. Bluetooth is a very asynchronous thing and a very


00:54:12.780 --> 00:54:20.460
high latency thing, so having an asynchronous API is really beneficial. So that's just one example


00:54:20.460 --> 00:54:30.060
of a library that is written in Python, pure Python, and is in MicroPython lib. And we aim to


00:54:30.060 --> 00:54:39.340
continue that trend. I know that it's a little bit stale, some code in there, but we will fix


00:54:39.340 --> 00:54:47.020
things in the very near future. Yeah, very neat.


00:54:47.020 --> 00:54:51.020
Speaking of asynchronous, what are some of the


00:54:51.020 --> 00:54:55.100
this question both of you, what are some of the shiny language features that are


00:54:55.100 --> 00:54:58.300
new and neat in there like asynchrono-wait, can I do that with the


00:54:58.300 --> 00:55:03.180
Bluetooth library? Or walrus, can I do a walrus operator?


00:55:03.180 --> 00:55:07.340
What's going on? Like what can I do? Well we have


00:55:07.340 --> 00:55:16.220
we have a micro async io, uasync io, which is in its third sort of iteration, third version,


00:55:16.220 --> 00:55:24.540
and that's been I think about a year old now, that version, and that also has been used in


00:55:24.540 --> 00:55:35.500
quite a few production systems. That's also quite stable, and I think is a really good showcase of


00:55:35.500 --> 00:55:43.100
using Python on microcontrollers because things on microcontrollers, well some things take time


00:55:43.100 --> 00:55:48.380
like reading a sensor and waiting for a Bluetooth packet to arrive and you've got to do lots of


00:55:48.380 --> 00:55:54.700
things at once like blink a light to indicate progress. It'd be great to have those events


00:55:54.700 --> 00:56:02.060
come in right? Yeah so event-based but also easy to sort of use because I mean multi-threading


00:56:02.060 --> 00:56:05.740
using, you know, threading in Python you can do, you can do that on some


00:56:05.740 --> 00:56:10.140
MicroPython ports, but it's heavy weight in the sense that


00:56:10.140 --> 00:56:14.860
it uses a lot of memory for each stack, a stack of each thread,


00:56:14.860 --> 00:56:19.900
and it's slow to switch and respond, so it's not a great


00:56:19.900 --> 00:56:23.020
solution. So cooperative multitasking, which is


00:56:23.020 --> 00:56:26.860
what asyncio is, is I think a better solution than


00:56:26.860 --> 00:56:30.940
threading on a microcontroller and even on a desktop.


00:56:30.940 --> 00:56:34.240
And it works really well.


00:56:34.240 --> 00:56:37.540
When you have something that's well suited to asyncio,


00:56:37.540 --> 00:56:40.920
it's a really fun experience to program.


00:56:40.920 --> 00:56:43.960
- And it's aptly named because what it's really well suited


00:56:43.960 --> 00:56:47.760
to is waiting on things like IO, right?


00:56:47.760 --> 00:56:50.400
Waiting on these devices, on these various sensors


00:56:50.400 --> 00:56:51.800
and stuff to come back and just say,


00:56:51.800 --> 00:56:54.920
hey, I've got an input, I've got a call back or whatever.


00:56:54.920 --> 00:56:57.640
Like that's, it seems like the perfect case.


00:56:57.640 --> 00:56:58.840
It's not like, well, we're trying to do all


00:56:58.840 --> 00:57:03.480
those computational stuff, asynchronous, like, well, that work is quite well that way.


00:57:03.480 --> 00:57:08.280
- Yeah, like, you know, you may just want to wait for a pin to change from high to low.


00:57:08.280 --> 00:57:15.320
So you spawn a task and you, you know, await on the pin and then when that statement continues,


00:57:15.320 --> 00:57:21.560
it means the pin has changed. That's hard to do in a sort of callback-based system.


00:57:21.560 --> 00:57:27.800
Well, it's not, I mean, it's just different conceptually and maybe it's harder to reason


00:57:27.800 --> 00:57:35.240
about things. So there are, yeah we have support for these fancy features asyncio and the walrus


00:57:35.240 --> 00:57:40.520
operator we had in f strings are not yet in, I think circuit python has f string.


00:57:40.520 --> 00:57:47.640
Oh you guys already have the f strings. Yeah we, Damian has a higher bar for merging than we do.


00:57:47.640 --> 00:57:54.760
Interesting. Yeah so in circuit python side we have f strings merged in but we haven't done this


00:57:54.760 --> 00:57:58.280
work on the async stuff that Damien's really done.


00:57:58.280 --> 00:58:02.200
Because our audience is beginners, I really pushed us not to do async stuff.


00:58:02.200 --> 00:58:05.640
Because I think something that beginners don't necessarily understand is like the


00:58:05.640 --> 00:58:10.520
computer literally does things in order that you want it to do. And so a lot of


00:58:10.520 --> 00:58:13.800
the examples that I that would that we use and that we get


00:58:13.800 --> 00:58:17.400
to people to doing is just doesn't use async. So it's not


00:58:17.400 --> 00:58:20.440
been a focus of ours. One of the reasons to merge was to get


00:58:20.440 --> 00:58:24.040
the newer async stuff in and kind of hope that somebody would come


00:58:24.040 --> 00:58:27.040
along and turn it on and make sure it's all working.


00:58:27.040 --> 00:58:31.720
But we've had the opposite approach.


00:58:31.720 --> 00:58:37.120
And I think talking about async, one of the things that we've been thinking about is async


00:58:37.120 --> 00:58:41.020
is very networking oriented in terms of Python.


00:58:41.020 --> 00:58:47.180
And it's not necessarily clear how that impacts hardware APIs and waiting for pins and things.


00:58:47.180 --> 00:58:52.680
So I think it's really interesting to think about how async applies to things like spy


00:58:52.680 --> 00:58:57.960
transactions and I squared C transactions and what exactly like we talked about how


00:58:57.960 --> 00:59:03.720
CircuitPython has a different hardware layer than MicroPython does and like I don't think either of


00:59:03.720 --> 00:59:07.800
us have really come up with a like what does that look like when you have async await support.


00:59:07.800 --> 00:59:15.720
So I'm curious to see what Damian comes up with. Yeah I mean we do, we have recently


00:59:15.720 --> 00:59:22.360
merged I2S support which has a preliminary async I/O support in it as well so you can


00:59:22.360 --> 00:59:32.840
yeah asynchronously send and receive audio buffers. We also have async support for pins using


00:59:32.840 --> 00:59:39.000
well a small sort of piece of wrapper code. A thread safe flag is our main sort of


00:59:39.000 --> 00:59:44.920
interaction between interrupts and async I/O so you create a thread safe flag object


00:59:44.920 --> 01:00:00.920
On the asyncio side you wait on the flag and on the IRQ side, so some event happens like a spy transaction completes and you get an IRQ and then you can set the thread safe flag and then that will mean that the task waiting on that can continue.


01:00:00.920 --> 01:00:11.920
So yeah, but I agree, Scott, that it's still early days with API for connecting I2C and things like that into the async world.


01:00:11.920 --> 01:00:23.200
I know one project I'm sort of working on uses asyncIO and Bluetooth and threadsafe flag with pins,


01:00:23.200 --> 01:00:31.360
but yeah nothing else is async. But the things that are async are very important to be async.


01:00:31.360 --> 01:00:37.680
And a lot of the time just asyncio.sleep is the thing you want, and yeah just wait for a bit of time.


01:00:39.280 --> 01:00:42.160
So you're waiting on a PNN sleeping is actually gets you a long way.


01:00:42.160 --> 01:00:50.080
So but I think it's still early days and even asyncIO in CPython is sort of still early days


01:00:50.080 --> 01:00:56.800
in the sense that they're still trying to work through what API is good for streams and there's


01:00:56.800 --> 01:01:05.280
Trio as well which is providing good feedback to CPython on asyncIO. So it's still early days in


01:01:05.280 --> 01:01:07.240
in the whole Python space.


01:01:07.240 --> 01:01:10.480
- Yeah, there's my favorite unsync,


01:01:10.480 --> 01:01:15.000
which is a unification layer on tops of threads,


01:01:15.000 --> 01:01:17.320
multi-processing and asyncio.


01:01:17.320 --> 01:01:18.960
And it's like, I think the whole implementation


01:01:18.960 --> 01:01:23.200
is 126 lines of Python in one file, but it's glorious.


01:01:23.200 --> 01:01:28.640
All right, one final topic I wanna touch on here.


01:01:28.640 --> 01:01:32.520
There's been a lot of interesting work


01:01:32.520 --> 01:01:36.180
about making Python regular old server side,


01:01:36.180 --> 01:01:38.520
desktop side, CPython faster.


01:01:38.520 --> 01:01:41.360
There's been a bunch of interesting things coming on.


01:01:41.360 --> 01:01:44.280
Pigeon from Microsoft is kind of making a comeback.


01:01:44.280 --> 01:01:46.560
I think Anthony Shah is doing some work on that.


01:01:46.560 --> 01:01:48.920
Maybe Brett Cannon as well.


01:01:48.920 --> 01:01:52.160
There's Cinder, the Instagram crew has released


01:01:52.160 --> 01:01:54.480
with really interesting stuff going on


01:01:54.480 --> 01:01:59.480
about making a lot of interesting changes in the runtime


01:01:59.560 --> 01:02:04.560
about making it faster, stuff about like immortal instances


01:02:04.560 --> 01:02:07.720
that are sort of not subject to GC


01:02:07.720 --> 01:02:09.680
and reference counting and whatnot.


01:02:09.680 --> 01:02:14.300
We've got the latest language summit.


01:02:14.300 --> 01:02:16.960
Guido was talking about interesting things he's doing


01:02:16.960 --> 01:02:21.960
and focusing on to try to sort of accomplish the same goal.


01:02:21.960 --> 01:02:23.600
Is any of this stuff influencing


01:02:23.600 --> 01:02:24.520
what you all are thinking about


01:02:24.520 --> 01:02:26.440
or is it just not really applicable?


01:02:26.440 --> 01:02:37.320
I think, yeah, this is a really big topic because Python has a long history


01:02:37.320 --> 01:02:45.240
and it's used in a lot of places for a lot of different things and it's built by a community


01:02:45.240 --> 01:02:52.520
unlike other languages. I mean, yeah, lots of languages built by communities but Python in


01:02:52.520 --> 01:02:56.200
particular is one of the, you know, so the more popular languages that is really just community run


01:02:56.200 --> 01:02:58.960
- You might say it as something like,


01:02:58.960 --> 01:03:01.280
it's built by a very diverse community,


01:03:01.280 --> 01:03:04.320
technically speaking, as opposed to say JavaScript,


01:03:04.320 --> 01:03:06.040
which is almost always web.


01:03:06.040 --> 01:03:07.560
And then kind of recently it's been a little node,


01:03:07.560 --> 01:03:10.760
but like it's astrophysicists, it's embedded,


01:03:10.760 --> 01:03:12.400
it's data science, it's web.


01:03:12.400 --> 01:03:14.080
Like there's a lot of different pressures


01:03:14.080 --> 01:03:16.880
and areas that Python gets put into.


01:03:16.880 --> 01:03:20.520
- Yeah, and the focus has not been on performance.


01:03:20.520 --> 01:03:23.800
It's been on usability and features


01:03:23.800 --> 01:03:25.840
and keeping up with that. - Backwards compatibility.


01:03:25.840 --> 01:03:31.680
Yeah, I mean it's been, it's such a, it is an old language that has evolved a long way,


01:03:31.680 --> 01:03:38.560
like C is an old language but C hasn't changed that much. C++ is an old thing, well C++ has


01:03:38.560 --> 01:03:45.360
changed a lot but it's got a very big community around it and lots of production. But Python is


01:03:45.360 --> 01:03:51.440
sort of, yeah, it's got such an amazing and passionate community who do all this stuff for


01:03:51.440 --> 01:03:57.440
free. And performance is something that's sort of always been in the back of people's minds, but


01:03:57.440 --> 01:04:03.040
it needs a lot of work and it kind of needs a stable Python language before you can consider


01:04:03.040 --> 01:04:07.600
performance. You know, you can't optimize along the way of adding features, it's really hard.


01:04:07.600 --> 01:04:15.840
Anyway, this is sort of just to say that it's a big topic and lots of people have tried to make


01:04:15.840 --> 01:04:22.480
Python faster and PyPy is an amazing piece of software that makes Python faster. One of my


01:04:22.480 --> 01:04:28.800
first big Python projects we used PyPy because it was really, really good and made things a lot


01:04:28.800 --> 01:04:34.880
faster, like 10 times faster, and we didn't have any sort of extension modules that didn't work


01:04:34.880 --> 01:04:40.400
with PyPy, they all did work with PyPy and it was really, really good. So use that if it


01:04:40.400 --> 01:04:47.360
works for you. Although it's a bit big though, but what it does is does really well.


01:04:47.360 --> 01:04:52.720
On the other hand, making CPython faster, just the core CPython, I think is a fantastic goal.


01:04:52.720 --> 01:05:01.920
And I think probably the thing I would say is that any interest in Python is good for


01:05:01.920 --> 01:05:08.880
CircuitPython and MicroPython and the general Python ecosystem, just because it's people


01:05:08.880 --> 01:05:14.960
working on Python and trying to make it better. Whether or not, you know, there's something that


01:05:14.960 --> 01:05:23.280
comes out at the end is kind of secondary. It's that people are interested and hacking on things


01:05:23.280 --> 01:05:28.720
and having fun and things will come out of it. Maybe it's not going to be a very fast, a super


01:05:28.720 --> 01:05:32.560
fast CPython at the end, although that would be really great and that's what people are really,


01:05:32.560 --> 01:05:39.600
really working towards now. But I just think the general interest in Python is the biggest thing


01:05:39.600 --> 01:05:44.720
that will come to us is that Python will be in the headlines more and people will be


01:05:44.720 --> 01:05:49.280
talking about how it's faster now and it's interesting and it will change people's perceptions


01:05:49.280 --> 01:05:52.800
and then people will learn more about MicroPython and through Python.


01:05:52.800 --> 01:05:58.320
We'll start having to deal with all these articles of people are leaving C and Go because it's so slow now and


01:05:58.960 --> 01:06:03.960
- Well, yeah, Python is such an ergonomic language.


01:06:03.960 --> 01:06:06.200
It's so great.


01:06:06.200 --> 01:06:07.020
- Yeah, it's so lovely.


01:06:07.020 --> 01:06:11.400
I think actually the performance side is just so,


01:06:11.400 --> 01:06:12.480
so many layers, right?


01:06:12.480 --> 01:06:16.040
Like it's slow, except for if you use the SciPy libraries,


01:06:16.040 --> 01:06:17.200
all of a sudden it's really fast.


01:06:17.200 --> 01:06:19.480
And then like, it's just, it's super interesting.


01:06:19.480 --> 01:06:21.600
Scott, you're good, David.


01:06:21.600 --> 01:06:24.180
- No, I mean, it really depends what you're using it for.


01:06:24.180 --> 01:06:27.280
And I don't think you should,


01:06:27.280 --> 01:06:30.440
slow Python shouldn't be, it should be banished


01:06:30.440 --> 01:06:31.520
sort of that concept.


01:06:31.520 --> 01:06:34.600
It should be like, use Python and see if it works for you.


01:06:34.600 --> 01:06:35.880
'Cause, and if it doesn't, you know,


01:06:35.880 --> 01:06:36.760
then use a different language.


01:06:36.760 --> 01:06:38.720
But that's the same you say with any language.


01:06:38.720 --> 01:06:40.680
It's like use the language if it's gonna work for you.


01:06:40.680 --> 01:06:42.240
- And oftentimes it's just, well,


01:06:42.240 --> 01:06:44.720
you're not using the right part of the Python ecosystem


01:06:44.720 --> 01:06:46.140
to address that problem.


01:06:46.140 --> 01:06:48.160
- Yeah.


01:06:48.160 --> 01:06:51.640
- Yeah, Scott, do you wanna maybe weigh in on that real quick


01:06:51.640 --> 01:06:52.600
before we wrap it up?


01:06:52.600 --> 01:06:53.440
Since we're about out of time.


01:06:53.440 --> 01:06:56.040
- Yeah, generally I delegate to Damian.


01:06:56.040 --> 01:06:58.960
Damien does a lot of work on this core and makes it really fast.


01:06:58.960 --> 01:07:02.340
I try not to get sucked into the performance stuff


01:07:02.340 --> 01:07:04.840
because I'm trying to do the workflow side of things.


01:07:04.840 --> 01:07:08.880
But I did want to point out for those folks that are coming from CPython


01:07:08.880 --> 01:07:10.880
and may not have done embedded Python,


01:07:10.880 --> 01:07:14.840
is that the boards that we run on, both MicroPython and CircuitPython,


01:07:14.840 --> 01:07:17.840
we're very much in Moore's Law territory still.


01:07:17.840 --> 01:07:21.220
The first board that I supported is 48 megahertz,


01:07:21.220 --> 01:07:24.900
but the TNT4 runs at 600 megahertz.


01:07:24.900 --> 01:07:28.300
So we can get a lot of speed within this domain


01:07:28.300 --> 01:07:29.940
by paying a few dollars more.


01:07:29.940 --> 01:07:33.620
And that's important to realize,


01:07:33.620 --> 01:07:35.260
is that like the things that we do for speed


01:07:35.260 --> 01:07:38.420
may not be the things that you would do in CPython.


01:07:38.420 --> 01:07:39.300
- Interesting, yeah.


01:07:39.300 --> 01:07:43.020
There's hardly a make the computer faster answer.


01:07:43.020 --> 01:07:44.420
- Yeah, but we do have a turbo.


01:07:44.420 --> 01:07:46.780
We do kind of have a turbo button


01:07:46.780 --> 01:07:49.920
if we can just clock the CPU faster.


01:07:49.920 --> 01:07:50.980
- Yeah, awesome.


01:07:50.980 --> 01:07:53.860
My Pentium 90 had a turbo button, I loved it.


01:07:53.860 --> 01:07:56.520
And it was probably just as fast as what we're running


01:07:56.520 --> 01:07:58.500
MicroPython and CircuitPython on now.


01:07:58.500 --> 01:07:59.340
- Oh, interesting.


01:07:59.340 --> 01:08:01.140
Yeah, for sure.


01:08:01.140 --> 01:08:01.980
All right, you guys.


01:08:01.980 --> 01:08:04.340
Well, we could go on and on and on about this.


01:08:04.340 --> 01:08:05.500
Maybe we'll have to do another episode,


01:08:05.500 --> 01:08:07.420
but I think we're probably out of time.


01:08:07.420 --> 01:08:10.220
So I'm gonna ask you a couple of wrap-up questions.


01:08:10.220 --> 01:08:15.000
I normally ask the editor and PyPI library.


01:08:15.000 --> 01:08:16.060
Maybe we'll go ahead and do that,


01:08:16.060 --> 01:08:19.780
but I wanna throw in maybe one more thing as well.


01:08:19.780 --> 01:08:21.620
So let's do editor first.


01:08:21.620 --> 01:08:24.100
If you're gonna write some code that runs on


01:08:24.100 --> 01:08:26.860
either Circuit or MicroPython devices,


01:08:26.860 --> 01:08:28.020
what editor do you use?


01:08:28.020 --> 01:08:32.380
- Vim, I use Vim since day one, I think.


01:08:32.380 --> 01:08:33.780
- Right on, Scott?


01:08:33.780 --> 01:08:36.140
- I use Sublime Text.


01:08:36.140 --> 01:08:37.940
- Cool, very good, very good.


01:08:37.940 --> 01:08:39.940
Notable PyPI package, something out there


01:08:39.940 --> 01:08:41.220
that's pretty cool.


01:08:41.220 --> 01:08:44.180
I've seen a bunch of things going by in the live chat


01:08:44.180 --> 01:08:46.220
as we're talking, it's very active today.


01:08:47.740 --> 01:08:55.660
I think HTTPIE is really quite a cool tool for like instead of Wget.


01:08:55.660 --> 01:09:02.540
- I've 100% moved to HTTPI. HTTPI, I guess is how you yeah it's


01:09:02.540 --> 01:09:06.380
it's like curl or Wget but you get like syntax highlighting


01:09:06.380 --> 01:09:10.060
for your response. It's beautiful. - And it's actually a good


01:09:10.060 --> 01:09:13.900
tool for when you're like working with MicroPython if MicroPython


01:09:13.900 --> 01:09:20.940
actually accepts HTTP, it's not just for pretty printing. It's good for actual workflow as well.


01:09:20.940 --> 01:09:24.060
Yeah, cool. Scott, you got one to recommend?


01:09:24.060 --> 01:09:29.900
For the folks in CPython who are getting into hardware, if you have a Raspberry Pi, Blinka is


01:09:29.900 --> 01:09:36.380
great as the foundation. You'll want to find a device that you're interested in using, and then


01:09:36.380 --> 01:09:37.580
then you can use Blinka.


01:09:37.580 --> 01:09:40.280
Yeah, I don't know.


01:09:40.280 --> 01:09:42.540
That's a really good one.


01:09:42.540 --> 01:09:43.940
The HTTPi is a good one.


01:09:43.940 --> 01:09:45.080
I'll have to take a look at that.


01:09:45.080 --> 01:09:47.660
- Yeah, I've completely switched on all my servers


01:09:47.660 --> 01:09:50.300
and even on my desktop to just have that for testing thing.


01:09:50.300 --> 01:09:52.020
It's really, really good.


01:09:52.020 --> 01:09:54.420
Okay, here's the extra third question


01:09:54.420 --> 01:09:55.660
that normally we don't get.


01:09:55.660 --> 01:09:57.500
So if you're gonna work on a project,


01:09:57.500 --> 01:10:00.280
I have all these ideas of things


01:10:00.280 --> 01:10:02.260
that I would love to create and stuff,


01:10:02.260 --> 01:10:04.980
but I don't ever know really what the right


01:10:04.980 --> 01:10:06.020
hardware for it is.


01:10:06.020 --> 01:10:07.720
So I guess, Damon, you first,


01:10:07.720 --> 01:10:09.000
if you're gonna work on something,


01:10:09.000 --> 01:10:10.500
you've got some idea,


01:10:10.500 --> 01:10:12.440
you know, what kind of board would you get?


01:10:12.440 --> 01:10:13.760
Maybe you have to give us a little background


01:10:13.760 --> 01:10:16.200
on like the scope of the idea or the context,


01:10:16.200 --> 01:10:17.800
but what board would you play with


01:10:17.800 --> 01:10:19.560
that people are thinking of getting into stuff


01:10:19.560 --> 01:10:21.040
and playing with it and so on?


01:10:21.040 --> 01:10:23.820
- Yeah, that's a good question.


01:10:23.820 --> 01:10:25.820
It really depends on the project.


01:10:25.820 --> 01:10:30.800
If you want something like the pie board,


01:10:30.800 --> 01:10:34.900
we started making and selling that like eight years ago.


01:10:34.900 --> 01:10:39.060
was with the first kickstarter and we still sell a lot of these. The original pi board


01:10:39.060 --> 01:10:46.900
down a little bit on that page, yeah that one, and that's just a really good general purpose


01:10:46.900 --> 01:10:55.700
workhorse with good I/O support and I use it still today to do things and that's really cool.


01:10:55.700 --> 01:10:59.780
If you want high performance wi-fi bluetooth, if you just scroll back up a bit then the new


01:10:59.780 --> 01:11:09.700
pi board d is what you need. That has really fast wi-fi and really good bluetooth support.


01:11:09.700 --> 01:11:14.820
The Raspberry pypyco I think is a really another really good option if you want something that


01:11:14.820 --> 01:11:22.340
is relatively cheap and has good functionality and this new PIO, programmable IO stuff that


01:11:22.340 --> 01:11:27.140
Scott was talking about. That's also a really cool option. There's a whole lot of stuff out there.


01:11:28.020 --> 01:11:32.020
there's a lot of choice and it's all really good choice.


01:11:32.020 --> 01:11:35.780
Exciting, yeah very exciting and not super expensive as you all are saying


01:11:35.780 --> 01:11:39.540
like you can get them and try them it's not a huge investment. Scott what's


01:11:39.540 --> 01:11:42.660
your your dream board that you would a


01:11:42.660 --> 01:11:47.860
recommended board you would start with? I don't think there's any one board.


01:11:47.860 --> 01:11:52.980
I see some people trying to make this a particular board they have do something


01:11:52.980 --> 01:11:57.700
that it doesn't necessarily do very well. So what I recommend people is actually


01:11:57.700 --> 01:12:00.340
go to learn.adafruit.com,


01:12:00.340 --> 01:12:03.780
which is where Adafruit has all of our tutorials.


01:12:03.780 --> 01:12:07.280
And look there, find a project that is close


01:12:07.280 --> 01:12:09.480
or exactly what you want to do,


01:12:09.480 --> 01:12:14.240
and then you'll see all of the stuff that you need to do that.


01:12:14.240 --> 01:12:17.440
That's where I would start, because not only are you picking the hardware


01:12:17.440 --> 01:12:20.240
that you could use to do what you want,


01:12:20.240 --> 01:12:23.100
but you're also getting all the software to do it as well.


01:12:23.100 --> 01:12:26.200
So you're definitely getting a head start


01:12:26.200 --> 01:12:28.200
by starting from an existing project.


01:12:28.200 --> 01:12:30.200
Yeah, that's an interesting perspective.


01:12:30.200 --> 01:12:32.200
Instead of what board do I want?


01:12:32.200 --> 01:12:34.200
What project, what thing do I want to create and solve?


01:12:34.200 --> 01:12:37.200
Now what hardware do I need to facilitate that?


01:12:37.200 --> 01:12:39.200
Yeah, and then the other thing you can do is


01:12:39.200 --> 01:12:41.200
if you go to circuitpython.org/downloads,


01:12:41.200 --> 01:12:45.200
you actually can type different features.


01:12:45.200 --> 01:12:48.200
You want to see all the BLE boards or the Wi-Fi boards?


01:12:48.200 --> 01:12:51.200
It will filter out the boards there for you.


01:12:51.200 --> 01:12:54.200
And those are all the boards that CircuitPython runs on.


01:12:54.200 --> 01:12:57.040
- Very neat, very neat.


01:12:57.040 --> 01:13:00.220
All right, you guys, well,


01:13:00.220 --> 01:13:02.200
thank you for being here and sharing this.


01:13:02.200 --> 01:13:03.840
It's really cool to see the two projects


01:13:03.840 --> 01:13:06.040
working more closely together,


01:13:06.040 --> 01:13:08.420
and I hope they both keep going strong.


01:13:08.420 --> 01:13:11.240
- Thank you, thanks for having me.


01:13:11.240 --> 01:13:13.200
- Yeah, absolutely. - Yeah, thanks for having us.


01:13:13.200 --> 01:13:14.680
- But, so final call to action,


01:13:14.680 --> 01:13:17.320
people wanna get started, one from each of you, I guess.


01:13:17.320 --> 01:13:19.020
Like, what would you tell people?


01:13:21.040 --> 01:13:22.540
- Well, go to micropython.org,


01:13:22.540 --> 01:13:25.120
go to forum.micropython.org,


01:13:25.120 --> 01:13:25.960
where our forum is,


01:13:25.960 --> 01:13:28.440
that's sort of the most active place for discussion.


01:13:28.440 --> 01:13:31.760
And then github/micropython/micropython


01:13:31.760 --> 01:13:34.960
is also where all of the development action is.


01:13:34.960 --> 01:13:37.080
- Scott?


01:13:37.080 --> 01:13:39.960
- For CircuitPython, you can go to circuitpython.org


01:13:39.960 --> 01:13:42.760
and the slash downloads is particularly useful


01:13:42.760 --> 01:13:45.640
if you happen to have a device already in hand,


01:13:45.640 --> 01:13:49.920
that will get you the file for that particular device.


01:13:49.920 --> 01:13:52.520
If you want to hang out with us that are working on CircuitPython,


01:13:52.520 --> 01:13:56.720
we do have an Adafruit Discord server that everybody is welcome to join.


01:13:56.720 --> 01:14:01.420
You can go to the URL adafru.it/discord.


01:14:01.420 --> 01:14:03.420
That's the short link for it.


01:14:03.420 --> 01:14:04.420
And that will get you in there.


01:14:04.420 --> 01:14:06.420
You'll see there's a CircuitPython dev channel.


01:14:06.420 --> 01:14:09.120
That's where we coordinate all the development.


01:14:09.120 --> 01:14:13.720
And on GitHub, we're github.com/adafruit/circuitpython.


01:14:13.720 --> 01:14:15.820
Although we are...


01:14:15.820 --> 01:14:17.020
- Sorry, go ahead.


01:14:17.020 --> 01:14:18.820
- I was going to say, we're moving more and more to...


01:14:18.820 --> 01:14:21.020
we have a CircuitPython organization as well.


01:14:21.020 --> 01:14:23.140
So maybe at some point we'll do,


01:14:23.140 --> 01:14:26.980
we'll be github.com/circuitpython/circuitpython.


01:14:26.980 --> 01:14:28.320
- Right on, I was also just gonna throw out


01:14:28.320 --> 01:14:31.460
that you do a fair number of live stream,


01:14:31.460 --> 01:14:32.660
Twitch-like things. - I do.


01:14:32.660 --> 01:14:34.020
- Maybe just tell people about that as well,


01:14:34.020 --> 01:14:35.300
if they wanna catch you there.


01:14:35.300 --> 01:14:37.380
- Yeah, so I started live streaming


01:14:37.380 --> 01:14:39.380
kind of like as the pandemic ramped up,


01:14:39.380 --> 01:14:41.640
as just like something I've wanted to do.


01:14:41.640 --> 01:14:42.980
So I started doing it regularly.


01:14:42.980 --> 01:14:46.460
I do it at 2 p.m. Pacific on the Adafruit channels.


01:14:46.460 --> 01:14:49.340
So you can go to youtube.com/adafruit.


01:14:49.340 --> 01:14:50.900
It's called Deep Dive with Scott.


01:14:50.900 --> 01:14:52.540
There's a playlist there.


01:14:52.540 --> 01:14:56.820
They tend to be about two hours or more and very casual,


01:14:56.820 --> 01:14:59.140
no editing, but I answer questions


01:14:59.140 --> 01:15:03.140
and show off into the weeds of CircuitPython stuff.


01:15:03.140 --> 01:15:05.100
And we've gotten a lot of contributors out of that,


01:15:05.100 --> 01:15:06.100
which has been great.


01:15:06.100 --> 01:15:09.900
So if you wanna hang out on a Friday afternoon,


01:15:09.900 --> 01:15:11.180
everybody's welcome to do that.


01:15:11.180 --> 01:15:13.380
And we've talked to Damian about joining that


01:15:13.380 --> 01:15:14.480
at some point as well.


01:15:15.700 --> 01:15:17.300
- Cool, well, I look forward to seeing you both


01:15:17.300 --> 01:15:18.140
over there as well.


01:15:18.140 --> 01:15:19.700
So thanks for being on the show.


01:15:19.700 --> 01:15:21.060
- Thanks Michael. - Thank you.


01:15:21.060 --> 01:15:22.340
- Yeah, you bet.


01:15:22.340 --> 01:15:24.260
Thanks everyone for all the comments and live stream.


01:15:24.260 --> 01:15:25.100
See you later.


01:15:25.100 --> 01:15:28.100
(audience laughing)

