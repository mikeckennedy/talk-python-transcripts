WEBVTT

00:00:00.000 --> 00:00:05.000
- Mike, welcome back to Talk Python To Me.


00:00:05.000 --> 00:00:05.840
- Hi, how are you doing?


00:00:05.840 --> 00:00:06.660
- It's been a while.


00:00:06.660 --> 00:00:07.500
Hey, I'm doing really well.


00:00:07.500 --> 00:00:08.340
How about you?


00:00:08.340 --> 00:00:11.980
- I have a cold, but hanging in there.


00:00:11.980 --> 00:00:14.620
- Yeah, thanks for toughing out and being here with us.


00:00:14.620 --> 00:00:15.460
- Yeah.


00:00:15.460 --> 00:00:16.860
- Yeah.


00:00:16.860 --> 00:00:20.460
When we last spoke, we did speak about SQLAlchemy,


00:00:20.460 --> 00:00:25.020
of course, but it was in April of 2015.


00:00:25.020 --> 00:00:26.460
That's been a while.


00:00:26.460 --> 00:00:30.260
- Yeah, so was that live version 1.1?


00:00:30.260 --> 00:00:32.180
- Something like that, yeah, yeah, yeah.


00:00:32.180 --> 00:00:34.260
And that was episode five of the podcast


00:00:34.260 --> 00:00:35.100
that's been going on for years.


00:00:35.100 --> 00:00:35.940
- Oh, right.


00:00:35.940 --> 00:00:37.600
- So really early days.


00:00:37.600 --> 00:00:39.580
I appreciate you helping me kick off the show


00:00:39.580 --> 00:00:41.140
and can you believe it's still going?


00:00:41.140 --> 00:00:42.100
That's crazy, huh?


00:00:42.100 --> 00:00:43.700
- Yeah, doing great.


00:00:43.700 --> 00:00:44.540
- Yeah, thanks a lot.


00:00:44.540 --> 00:00:46.820
- I'm glad Python's popular enough


00:00:46.820 --> 00:00:48.680
that it can have its own podcast.


00:00:48.680 --> 00:00:51.300
I'm pretty psyched about that.


00:00:51.300 --> 00:00:53.020
- I'm super psyched about that as well.


00:00:53.020 --> 00:00:57.460
Maybe, let's sort of start with that actually.


00:00:57.460 --> 00:01:01.260
Back then Python was already popular, right?


00:01:01.260 --> 00:01:04.340
2015, we'd already sort of hit that hockey stick


00:01:04.340 --> 00:01:07.020
growth curve that started around 2012.


00:01:07.020 --> 00:01:10.580
But even so, does Python's popularity and growth


00:01:10.580 --> 00:01:13.720
and appeal surprise you these days?


00:01:13.720 --> 00:01:15.980
- No, it doesn't surprise me.


00:01:15.980 --> 00:01:19.220
I'm pleased that it's growing in popularity.


00:01:19.220 --> 00:01:21.260
I think the first thing that I saw about Python


00:01:21.260 --> 00:01:25.060
when I first got into it in the early 2000s was,


00:01:25.060 --> 00:01:28.540
it's really clear, it's really unambiguous


00:01:28.540 --> 00:01:31.540
compared to everything else that I've used.


00:01:31.540 --> 00:01:33.940
And I always wanted to be involved in the language


00:01:33.940 --> 00:01:37.180
that quote unquote regular people can get involved with


00:01:37.180 --> 00:01:40.060
and people at a low level, high level


00:01:40.060 --> 00:01:41.360
can do things with it.


00:01:41.360 --> 00:01:45.340
You know, I didn't wanna be focusing on a computer language


00:01:45.340 --> 00:01:48.620
that would only be very high level math whizzes


00:01:48.620 --> 00:01:51.860
'cause I'm not a math person at all.


00:01:51.860 --> 00:01:54.260
That's why I don't really do Haskell.


00:01:54.260 --> 00:01:55.580
You know, I wanted to, there to be,


00:01:55.580 --> 00:01:57.340
'cause I, you know, worked in different jobs


00:01:57.340 --> 00:01:58.980
and I always would be, not always,


00:01:58.980 --> 00:02:01.180
but often someone that was writing all the frameworks


00:02:01.180 --> 00:02:02.300
and the architectures,


00:02:02.300 --> 00:02:05.260
and then all the other people were using my frameworks,


00:02:05.260 --> 00:02:06.900
but I, you know, a lot of those people


00:02:06.900 --> 00:02:09.340
were not at the level that I was,


00:02:09.340 --> 00:02:11.660
and I wanted to make sure that the stuff that I did


00:02:11.660 --> 00:02:12.900
was approachable.


00:02:12.900 --> 00:02:15.780
So Python's very approachable.


00:02:15.780 --> 00:02:19.380
And the fact that now that the academic world


00:02:19.380 --> 00:02:23.620
and the media news world is getting very data oriented,


00:02:23.620 --> 00:02:25.460
surprise, they're all using Python,


00:02:25.460 --> 00:02:27.260
which was like-- - Yeah, surprise, surprise.


00:02:27.260 --> 00:02:29.740
- Yeah, I missed exactly what I would have expected.


00:02:29.740 --> 00:02:31.060
And it might not have gone that way,


00:02:31.060 --> 00:02:32.740
but it was a pretty good bet.


00:02:32.740 --> 00:02:37.740
So it's cool that there's a data science profession now


00:02:37.740 --> 00:02:41.660
and Python is at the center of it.


00:02:41.660 --> 00:02:43.300
So I think that's really great.


00:02:43.300 --> 00:02:45.340
- Yeah, it makes a lot of sense


00:02:45.340 --> 00:02:46.380
that it's at the center of it.


00:02:46.380 --> 00:02:50.220
I do think it has this special appeal to people.


00:02:50.220 --> 00:02:51.860
And I think it's made up of a couple of parts.


00:02:51.860 --> 00:02:54.140
One is it's, you can be very effective


00:02:54.140 --> 00:02:56.180
with a partial understanding of Python.


00:02:56.180 --> 00:02:58.100
Like you could not even understand what a class is


00:02:58.100 --> 00:02:59.760
and you could totally meaningful stuff, right?


00:02:59.760 --> 00:03:01.780
Which a lot of languages don't have that feature.


00:03:01.780 --> 00:03:02.620
- Right.


00:03:02.620 --> 00:03:03.960
- It has the packages, right?


00:03:03.960 --> 00:03:06.540
All the, I haven't even checked.


00:03:06.540 --> 00:03:07.380
Let me check it out.


00:03:07.380 --> 00:03:10.720
How many packages are on PyPI these days?


00:03:10.720 --> 00:03:12.300
338,000.


00:03:12.300 --> 00:03:15.140
That's a few things to just grab and, you know,


00:03:15.140 --> 00:03:17.420
- Sure. - With like Lego block style,


00:03:17.420 --> 00:03:19.220
some of which you've contributed to up there.


00:03:19.220 --> 00:03:20.260
So that's pretty awesome.


00:03:20.260 --> 00:03:22.180
Some of the popular ones.


00:03:22.180 --> 00:03:24.060
Yeah, I think it's fantastic.


00:03:24.060 --> 00:03:28.740
So good to see people continuing to embrace it.


00:03:28.740 --> 00:03:32.140
And you mentioned making it more accessible, right?


00:03:32.140 --> 00:03:34.500
Like there's different things of accessibility.


00:03:34.500 --> 00:03:36.780
There's, well, I can write for loops


00:03:36.780 --> 00:03:38.380
and do a list comprehension


00:03:38.380 --> 00:03:39.760
and that's pretty easy to understand.


00:03:39.760 --> 00:03:44.140
There's another, like I need to talk to a Postgres cluster


00:03:44.140 --> 00:03:45.380
and make it do things, right?


00:03:45.380 --> 00:03:47.540
It doesn't matter how simple Python is.


00:03:47.540 --> 00:03:49.900
When you talk to external systems,


00:03:49.900 --> 00:03:52.680
you to some degree take on the complexity


00:03:52.680 --> 00:03:54.140
of that external system, right?


00:03:54.140 --> 00:03:58.940
And I do think ORMs and in the NoSQL world, ODMs,


00:03:58.940 --> 00:04:03.740
if you will, really democratize that as well.


00:04:03.740 --> 00:04:06.780
You can write the code in the language you already know,


00:04:06.780 --> 00:04:08.700
and it does the database stuff,


00:04:08.700 --> 00:04:13.580
including the slight mismatch of language features


00:04:13.580 --> 00:04:17.420
in SQL like @parameter name versus question mark


00:04:17.420 --> 00:04:19.740
type of variations, right?


00:04:19.740 --> 00:04:20.580
- Yeah.


00:04:20.580 --> 00:04:23.220
What's interesting, that particular variation


00:04:23.220 --> 00:04:26.100
is not even necessary.


00:04:26.100 --> 00:04:27.860
That's a quirk of the Python DB API


00:04:27.860 --> 00:04:30.580
that they decided to have different parameter styles.


00:04:30.580 --> 00:04:33.420
So yeah, we wanted to make it so you wouldn't have


00:04:33.420 --> 00:04:34.260
to worry about that.


00:04:34.260 --> 00:04:35.660
So yes, as far as democratizing,


00:04:35.660 --> 00:04:40.100
SQLAlchemy was always aiming to democratize


00:04:40.100 --> 00:04:43.460
as much as it could to make things


00:04:43.460 --> 00:04:45.380
that are trivial and you shouldn't have to worry about


00:04:45.380 --> 00:04:47.460
like question marks versus colon name.


00:04:47.460 --> 00:04:50.060
You don't have to worry about that stuff.


00:04:50.060 --> 00:04:52.740
But at the same time, I always came from


00:04:52.740 --> 00:04:54.200
all these different database shops


00:04:54.200 --> 00:04:56.900
where we had to use every feature possible.


00:04:56.900 --> 00:05:01.220
And it's always about exposing the database,


00:05:01.220 --> 00:05:05.140
the SQL, SQLAlchemy remains pretty different


00:05:05.140 --> 00:05:09.580
than most tools, any tool I've seen in Python, more or less.


00:05:09.580 --> 00:05:12.040
Probably tools in other languages that is not trying


00:05:12.040 --> 00:05:18.200
to create this abstracted way, you can't really know that there's some vaguely relational


00:05:18.200 --> 00:05:19.900
object store thing.


00:05:19.900 --> 00:05:24.440
It's like we really want you to be into SQL and you just happen to be able to write it


00:05:24.440 --> 00:05:29.120
in terms of Python constructs, but you can also write SQL strings.


00:05:29.120 --> 00:05:35.080
We're going to try to get that to have as much flexibility as possible.


00:05:35.080 --> 00:05:36.080
And yeah.


00:05:36.080 --> 00:05:37.860
Yeah, that's one of the...


00:05:37.860 --> 00:05:39.860
There's a couple of interesting philosophies


00:05:39.860 --> 00:05:43.860
around SQLAlchemy or philosophies of SQLAlchemy


00:05:43.860 --> 00:05:45.460
that you've imbued upon it.


00:05:45.460 --> 00:05:48.060
And one of them is not to hide the database, right?


00:05:48.060 --> 00:05:50.460
Because you often end up in this leaky abstraction


00:05:50.460 --> 00:05:52.960
where it's like, "Oh, you can just forget there's no database.


00:05:52.960 --> 00:05:54.460
Oh, wait, is it too slow?


00:05:54.460 --> 00:05:57.960
Well, now you're into some weird world where it's not a great fit, right?"


00:05:57.960 --> 00:06:00.960
So maybe we could talk a bit about the philosophies


00:06:00.960 --> 00:06:04.960
a bit before we get into what's new and where things are going.


00:06:04.960 --> 00:06:09.600
Yeah, well, the basic philosophy has always been, and I think some years into it, I read


00:06:09.600 --> 00:06:13.040
some articles that gave me some better terminology.


00:06:13.040 --> 00:06:16.640
One of automation, of working with a SQL database.


00:06:16.640 --> 00:06:19.360
Like if you're going to write an application that talks to a database and you're going


00:06:19.360 --> 00:06:25.160
to have 20 tables, and say you're not using any ORM, you're just going to write, write


00:06:25.160 --> 00:06:29.600
the raw SQL, you're going to find yourself writing the same insert statement, typing


00:06:29.600 --> 00:06:31.760
it out over and over again.


00:06:31.760 --> 00:06:34.280
I know that my table has these 10 columns.


00:06:34.280 --> 00:06:35.520
I'm going to type this insert statement.


00:06:35.520 --> 00:06:38.320
That's what we call boilerplate, right?


00:06:38.320 --> 00:06:40.800
Any program that anyone writes using nothing at all,


00:06:40.800 --> 00:06:42.520
they're going to write some function


00:06:42.520 --> 00:06:45.040
to generate that insert statement, right?


00:06:45.040 --> 00:06:46.880
People usually talk about select statements


00:06:46.880 --> 00:06:48.560
as the ones they want to have more control over.


00:06:48.560 --> 00:06:49.920
But there's just the boring ones.


00:06:49.920 --> 00:06:51.320
There's updates, inserts, and deletes,


00:06:51.320 --> 00:06:52.680
which are really boring.


00:06:52.680 --> 00:06:55.360
There's all the DDL for creating tables and stuff


00:06:55.360 --> 00:06:57.760
that's very redundant.


00:06:57.760 --> 00:06:59.880
Like, nobody needs to--


00:06:59.880 --> 00:07:02.520
Like if you want to learn how to do that stuff, you should learn how to do this stuff.


00:07:02.520 --> 00:07:06.880
But if you have 100 classes, you don't want to type in 100 create table statements.


00:07:06.880 --> 00:07:08.800
You don't want to have to do that. It should be automated.


00:07:08.800 --> 00:07:29.840
So the idea is that when you're working in this automated environment, you still know everything that's, you know, what a create table statement is, you know what an insert is, you know what CRUD somewhat is, you know, you know, SQL, you know, you would know it, ideally, not necessarily, but ideally, you would know how to write this whole program without using anything like you would know how to use raw SQL.


00:07:29.840 --> 00:07:35.640
Right. I would say probably a good rule of thumb for I've studied enough SQL


00:07:35.640 --> 00:07:41.640
to feel like I'm not hiding too much from myself by using an ORM


00:07:41.640 --> 00:07:46.040
would be if you could get the ORM to print out its statement.


00:07:46.040 --> 00:07:49.840
So in SQL, I can be on the engine if you set echo equals true, for example.


00:07:49.840 --> 00:07:53.640
And you know what it does when you read the statements.


00:07:53.640 --> 00:07:58.040
You're like, okay, I'm not sure I would have exactly seemed to write the join that way,


00:07:58.040 --> 00:07:59.240
but okay, that makes sense.


00:07:59.240 --> 00:08:01.680
I see why it's been, I see what this update statement,


00:08:01.680 --> 00:08:02.520
these parameters mean.


00:08:02.520 --> 00:08:05.960
Okay, like now let's just, let's be productive, right?


00:08:05.960 --> 00:08:07.640
What do you think about that as a rule?


00:08:07.640 --> 00:08:09.240
- Echo equals true, right?


00:08:09.240 --> 00:08:10.960
Was when I first wrote SQL,


00:08:10.960 --> 00:08:13.600
whatever I did for the first two weeks,


00:08:13.600 --> 00:08:15.240
echo equals true was right there.


00:08:15.240 --> 00:08:16.800
That was like the very first thing,


00:08:16.800 --> 00:08:18.960
like you will see the SQL.


00:08:18.960 --> 00:08:20.360
'Cause I had come from using,


00:08:20.360 --> 00:08:24.000
I think I'd probably use Hibernate for a while for Java.


00:08:24.000 --> 00:08:26.080
Now it's 20 years later or 25,


00:08:26.080 --> 00:08:29.560
what, you know, hibernate, I'm sure it's very different, but at that time,


00:08:29.560 --> 00:08:33.160
I don't know how to see what the heck it was sending to the database.


00:08:33.160 --> 00:08:34.360
I had no idea.


00:08:34.360 --> 00:08:37.040
I mean, I'm sure there was a way to do it, but it wasn't like obvious.


00:08:37.040 --> 00:08:40.120
It was like, you have to set up lockers and this and that and job at this and job


00:08:40.120 --> 00:08:40.520
at that.


00:08:40.520 --> 00:08:45.160
And the idea with hibernate and other, it was like, well, you shouldn't have to


00:08:45.160 --> 00:08:46.440
know that we do the SQL for you.


00:08:46.440 --> 00:08:47.720
Why should you know that?


00:08:47.720 --> 00:08:51.040
Like, and like, no, use this correctly.


00:08:51.040 --> 00:08:52.240
And we'll solve the problem.


00:08:52.240 --> 00:08:52.520
Right.


00:08:52.560 --> 00:08:57.440
I want a really one-to-one thing where you're writing this Python select dot where dot whatever


00:08:57.440 --> 00:08:59.240
and it's like what you can one-to-one.


00:08:59.240 --> 00:09:04.560
I mean if I had more videography skills and also a lot of time, I'd make some kind of


00:09:04.560 --> 00:09:11.680
cartoon that shows boom boom how it lines up at the statement.


00:09:11.680 --> 00:09:13.640
It's not meant to hide anything.


00:09:13.640 --> 00:09:14.640
It's meant to automate.


00:09:14.640 --> 00:09:18.920
So like if you had, I always use this term, the idea of a soda bottle company, like a


00:09:18.920 --> 00:09:20.760
soda company, like you're selling soda.


00:09:20.760 --> 00:09:21.760
Soda's not good for you.


00:09:21.760 --> 00:09:24.900
But if you had to bottle 4,000 bottles of soda,


00:09:24.900 --> 00:09:26.620
you would use a machine to do it.


00:09:26.620 --> 00:09:28.640
It's not to say that you don't know how to pour soda


00:09:28.640 --> 00:09:32.220
into a bottle yourself, but you need to scale it up.


00:09:32.220 --> 00:09:36.180
It's about scaling up something that is very repetitive


00:09:36.180 --> 00:09:37.600
to be typing by hand.


00:09:37.600 --> 00:09:40.640
- And be consistent and repetitive and whatnot.


00:09:40.640 --> 00:09:43.000
- Yep. - Absolutely, absolutely.


00:09:43.000 --> 00:09:44.720
A couple comments from the audience real quick,


00:09:44.720 --> 00:09:46.040
I just wanna throw out there.


00:09:46.040 --> 00:09:48.480
D Varazzo says, "Hello from--"


00:09:48.480 --> 00:09:49.920
- Daniel, yeah.


00:09:49.920 --> 00:09:52.860
- Yeah, from PsychoPG, thank you for your kind wrapping


00:09:52.860 --> 00:09:56.020
and Jay Lee is just cheerleading for Python.


00:09:56.020 --> 00:09:56.860
It's awesome.


00:09:56.860 --> 00:09:59.660
Awesome, hello everyone out there.


00:09:59.660 --> 00:10:03.140
So yeah, I think this is really a powerful thing


00:10:03.140 --> 00:10:05.260
to think about, just the reproducibility


00:10:05.260 --> 00:10:09.260
and also in terms of linking into the tooling.


00:10:09.260 --> 00:10:14.260
I think one thing people often miss about the advantages


00:10:14.260 --> 00:10:16.780
because sometimes you'll hear people say,


00:10:16.780 --> 00:10:18.220
you should never use an ORM,


00:10:18.220 --> 00:10:19.780
It's hiding too much from you.


00:10:19.780 --> 00:10:21.480
- Yeah, sure.


00:10:21.480 --> 00:10:22.760
- Yeah, sure, go.


00:10:22.760 --> 00:10:23.640
I'm gonna go do something.


00:10:23.640 --> 00:10:25.960
You keep working on your strings.


00:10:25.960 --> 00:10:29.020
So one of the things I can see


00:10:29.020 --> 00:10:31.060
that sometimes can easily get missed


00:10:31.060 --> 00:10:34.680
is refactoring tools, error checking.


00:10:34.680 --> 00:10:37.820
If you write some kind of select statement on a class


00:10:37.820 --> 00:10:41.540
and you wanna change that field or that column,


00:10:41.540 --> 00:10:42.480
you change the field,


00:10:42.480 --> 00:10:44.040
which obviously maps over to the column,


00:10:44.040 --> 00:10:45.900
but that also changes your entire code


00:10:45.900 --> 00:10:49.160
if you're using a proper editor that understands refactoring,


00:10:49.160 --> 00:10:52.260
like VS Code or PyCharm or something like that, right?


00:10:52.260 --> 00:10:53.100
- Yep.


00:10:53.100 --> 00:10:57.140
Yeah, so a big thing with refactoring,


00:10:57.140 --> 00:11:00.260
and one of the things that we had to adapt to as it came


00:11:00.260 --> 00:11:05.260
was PEP 44, which is, I call it mypy, but it's not mypy.


00:11:05.260 --> 00:11:08.620
mypy is a tool that checks Python annotations,


00:11:08.620 --> 00:11:11.860
and we call it the mypy thing, but it's really PEP 44,


00:11:11.860 --> 00:11:15.500
which is that new thing where they're trying to have


00:11:15.500 --> 00:11:20.500
kind of a layer of typing, like a strongly typed,


00:11:20.500 --> 00:11:24.900
static typed, sorry, statically typed layer


00:11:24.900 --> 00:11:26.820
on top of your Python script.


00:11:26.820 --> 00:11:28.940
So if you're a library in Python,


00:11:28.940 --> 00:11:30.540
you have to work with the system now


00:11:30.540 --> 00:11:31.420
'cause people expect it.


00:11:31.420 --> 00:11:35.840
And the IDEs, I use VS Code now with,


00:11:35.840 --> 00:11:39.540
so I keep forgetting the name of the engine,


00:11:39.540 --> 00:11:42.340
but that's the PyFlakes, not PyFlakes.


00:11:42.340 --> 00:11:44.180
You know what it is?


00:11:44.180 --> 00:11:45.020
- Yeah. - Pylance.


00:11:45.020 --> 00:11:46.540
I can never remember that name, Pylance.


00:11:46.540 --> 00:11:48.500
Pylance, think of a lance.


00:11:48.500 --> 00:11:49.940
Pylance.


00:11:49.940 --> 00:11:51.780
Pylance uses the annotations a lot.


00:11:51.780 --> 00:11:54.740
So, and I actually am seeing where it works


00:11:54.740 --> 00:11:55.580
and where it doesn't work.


00:11:55.580 --> 00:12:00.060
And I think the refactoring tools are greatly improved


00:12:00.060 --> 00:12:01.980
by the fact that there is this concept


00:12:01.980 --> 00:12:03.820
of static type annotations.


00:12:03.820 --> 00:12:04.960
- Yeah.


00:12:04.960 --> 00:12:07.180
- I think there's a lot of shortcomings in PEP44.


00:12:07.180 --> 00:12:09.620
There's a lot of things that's like,


00:12:09.620 --> 00:12:10.900
it's not great.


00:12:10.900 --> 00:12:12.820
You know, I'm not a hundred percent optimistic on it,


00:12:12.820 --> 00:12:15.520
but I definitely it's way better than nothing.


00:12:15.520 --> 00:12:19.200
And there's some also some features that are coming


00:12:19.200 --> 00:12:22.080
that are in in peps that have not been implemented.


00:12:22.080 --> 00:12:25.200
This is thing called variadic types that would allow us


00:12:25.200 --> 00:12:27.600
to actually be able to type your results


00:12:27.600 --> 00:12:29.280
that coming back if you give it a select,


00:12:29.280 --> 00:12:31.760
we'll know the types in your result row.


00:12:31.760 --> 00:12:35.920
- I see, is that something like a generic or template type?


00:12:35.920 --> 00:12:39.560
- It's a generic that works like the tuple type


00:12:39.560 --> 00:12:41.760
'cause you might notice in PEP 44,


00:12:41.760 --> 00:12:43.520
you can't make your own tuple type.


00:12:43.520 --> 00:12:45.320
The typing that's applied to tuple is actually,


00:12:45.320 --> 00:12:47.600
if you look at the mypy source, it's hard coded.


00:12:47.600 --> 00:12:51.540
If equals tuple, then all these new special things.


00:12:51.540 --> 00:12:53.440
So things like that, they need to fix.


00:12:53.440 --> 00:12:58.560
Yeah, 'cause rows from a database are essentially tuples.


00:12:58.560 --> 00:12:59.400
- Right.


00:12:59.400 --> 00:13:00.840
- So that's how we wanna type them.


00:13:00.840 --> 00:13:03.880
- I do have a question,


00:13:03.880 --> 00:13:05.240
since we're talking about the typing.


00:13:05.240 --> 00:13:08.680
I pulled up this super simple example here


00:13:08.680 --> 00:13:11.000
off of the SQLAlchemy documentation.


00:13:11.000 --> 00:13:11.840
It doesn't really matter.


00:13:11.840 --> 00:13:14.200
It's just a class that drives from declare to base,


00:13:14.200 --> 00:13:15.820
has a table name, and then it has the stuff


00:13:15.820 --> 00:13:18.580
that people probably know from many ORMs.


00:13:18.580 --> 00:13:19.760
These descriptors, right?


00:13:19.760 --> 00:13:22.600
So id equals a column, which is of type integer,


00:13:22.600 --> 00:13:24.560
primary key equals true, name equals column,


00:13:24.560 --> 00:13:26.300
which is a string, and so on.


00:13:26.300 --> 00:13:27.640
I'm gonna tell you what I've been doing


00:13:27.640 --> 00:13:28.480
with this stuff lately,


00:13:28.480 --> 00:13:30.920
and you tell me whether this is a good idea


00:13:30.920 --> 00:13:32.760
or a bad idea or whatever.


00:13:32.760 --> 00:13:35.060
So what I've been doing is I've been writing this code


00:13:35.060 --> 00:13:36.260
as like this name one.


00:13:36.260 --> 00:13:41.100
I would say name colon string equals column string.


00:13:41.100 --> 00:13:44.100
So the Python code believes it's the type


00:13:44.100 --> 00:13:45.920
that's backed by the database, the column type.


00:13:45.920 --> 00:13:49.300
So name is a string, ID colon int,


00:13:49.300 --> 00:13:51.300
even though it's really set to a descriptor


00:13:51.300 --> 00:13:53.540
of column integer primary equals true.


00:13:53.540 --> 00:13:54.860
- Yeah.


00:13:54.860 --> 00:13:55.680
- Have you seen this?


00:13:55.680 --> 00:13:56.520
Is this a good idea?


00:13:56.520 --> 00:13:58.980
- Yes, I have done a lot of work on this concept


00:13:58.980 --> 00:14:02.100
and what you're doing is not incorrect,


00:14:02.100 --> 00:14:04.940
but there's a lot of complexities to it


00:14:06.020 --> 00:14:10.060
that require a little more going on.


00:14:10.060 --> 00:14:10.900
You mentioned--


00:14:10.900 --> 00:14:12.460
- To be clear, I'm not doing this for mypy,


00:14:12.460 --> 00:14:14.660
I'm doing this just so my editor is more--


00:14:14.660 --> 00:14:16.900
- Sure, yes, but also, yes, for the editor,


00:14:16.900 --> 00:14:18.000
I don't have the link handy,


00:14:18.000 --> 00:14:19.340
I'd have to go searching on my computer,


00:14:19.340 --> 00:14:21.140
but there's actually, so first of all,


00:14:21.140 --> 00:14:24.420
we do have a mypy plugin where you are able


00:14:24.420 --> 00:14:28.580
to use annotations like name colon string,


00:14:28.580 --> 00:14:31.060
and it will automatically kind of work them


00:14:31.060 --> 00:14:34.260
into the correct kind of thing to be recognized


00:14:34.260 --> 00:14:36.060
also at the query level.


00:14:36.060 --> 00:14:39.140
It doesn't work with PyLance.


00:14:39.140 --> 00:14:41.460
And I have a new approach that I worked out


00:14:41.460 --> 00:14:43.660
with some other people for PyLance type stuff


00:14:43.660 --> 00:14:45.420
where we won't need a plugin,


00:14:45.420 --> 00:14:48.020
where you will be able to make,


00:14:48.020 --> 00:14:49.980
we're not totally sure how we want to do it.


00:14:49.980 --> 00:14:52.180
The point is that you would say name colon,


00:14:52.180 --> 00:14:54.900
you wouldn't say str,


00:14:54.900 --> 00:14:58.260
you would use this other construct called mapping,


00:14:58.260 --> 00:14:59.580
or maps rather, and maps,


00:14:59.580 --> 00:15:01.700
and then the map type is str.


00:15:01.700 --> 00:15:03.020
The reason you do that is because


00:15:03.020 --> 00:15:08.020
If you use the user class in a query, not as an instance,


00:15:08.020 --> 00:15:11.200
it also has behaviors at the class level.


00:15:11.200 --> 00:15:14.260
- Right, like .desc for descending.


00:15:14.260 --> 00:15:16.420
- Yeah, like that kind of stuff.


00:15:16.420 --> 00:15:19.760
Right, so I'm trying to work out the best way to do this


00:15:19.760 --> 00:15:21.980
where you're not typing the same,


00:15:21.980 --> 00:15:23.060
you're not repeating yourself,


00:15:23.060 --> 00:15:26.100
'cause right now it's a little bit squirrely.


00:15:26.100 --> 00:15:29.380
The class works completely in PyLance,


00:15:29.380 --> 00:15:32.100
everything that's expected both at the class level


00:15:32.100 --> 00:15:34.100
and at the instance level will work out.


00:15:34.100 --> 00:15:38.740
It probably requires that when you do the declarative class,


00:15:38.740 --> 00:15:41.180
you would use a slightly different API.


00:15:41.180 --> 00:15:46.420
The current proposal is instead of using uppercase column,


00:15:46.420 --> 00:15:48.520
it's this new thing called m.column.


00:15:48.520 --> 00:15:51.920
We can always change the name and how it looks.


00:15:51.920 --> 00:15:54.580
One of the flaws with that declarative model


00:15:54.580 --> 00:15:56.060
you see there is that when I came up


00:15:56.060 --> 00:15:59.540
with that declarative idea many years ago,


00:15:59.540 --> 00:16:03.940
Those column objects are not Python descriptor compatible at all.


00:16:03.940 --> 00:16:06.240
They actually get replaced when you map the class.


00:16:06.240 --> 00:16:07.340
It's totally a...


00:16:07.340 --> 00:16:08.080
- Okay.


00:16:08.080 --> 00:16:08.580
- Like a seal.


00:16:08.580 --> 00:16:11.000
It's not that clean.


00:16:11.000 --> 00:16:16.740
So I have ideas to make declarative cleaner, you know, and do more of what it's


00:16:16.740 --> 00:16:19.340
supposed to do without kind of breaking the rules.


00:16:19.340 --> 00:16:22.000
That's the thing about Python is that as the years have gone by, everyone,


00:16:22.000 --> 00:16:27.580
even newcomers, we're all much more into not...into being clean about code and being


00:16:27.580 --> 00:16:30.620
more verbose and typing is more verbose


00:16:30.620 --> 00:16:31.980
and async I/O is more verbose.


00:16:31.980 --> 00:16:35.040
You know, when we were doing Python in '06, '07,


00:16:35.040 --> 00:16:38.740
everything was like, done, just magic object, boom,


00:16:38.740 --> 00:16:41.240
magic object, like nobody wanted to type anything.


00:16:41.240 --> 00:16:44.780
Now, you know, which was bad, you know,


00:16:44.780 --> 00:16:46.460
we didn't totally do it 'cause it was scripting language,


00:16:46.460 --> 00:16:48.320
but nowadays people are way more tolerant


00:16:48.320 --> 00:16:51.100
of more verbosity, more clarity.


00:16:51.100 --> 00:16:53.560
And I'm trying to keep SQLAlchemy and my MA team,


00:16:53.560 --> 00:16:54.900
we're trying to keep it going along with that.


00:16:54.900 --> 00:16:58.820
So the PEP 44 thing, 44, the async.io stuff.


00:16:58.820 --> 00:17:03.060
That's my knowledge dump for the typing thing.


00:17:03.060 --> 00:17:03.900
- No, that's fantastic.


00:17:03.900 --> 00:17:05.460
- It's a work in progress.


00:17:05.460 --> 00:17:06.300
Yeah.


00:17:06.300 --> 00:17:08.300
- Do you think that people, I have some thoughts on this,


00:17:08.300 --> 00:17:11.580
but do you think that people are more willing to accept


00:17:11.580 --> 00:17:13.340
like a little more structure in the code now


00:17:13.340 --> 00:17:17.340
because of the tooling is more there to help you write it?


00:17:17.340 --> 00:17:20.140
Like the auto, like I write my maybe C tab.


00:17:20.140 --> 00:17:22.660
I don't write column of whatever, right?


00:17:22.660 --> 00:17:23.940
- Right.


00:17:23.940 --> 00:17:28.820
Maybe it's the tooling, because nowadays people use Python data classes,


00:17:28.820 --> 00:17:31.020
and they want to use Python.


00:17:31.020 --> 00:17:33.380
We have some support for Python data classes now.


00:17:33.380 --> 00:17:39.500
And the syntaxes that they want me to implement, which we've done, are pretty


00:17:39.500 --> 00:17:43.060
verbose, because they want to have a data class where you have all your data class


00:17:43.060 --> 00:17:46.020
fields, and then within the field, they want to have the mapping information.


00:17:46.020 --> 00:17:47.500
And people are like, "This is awesome."


00:17:47.500 --> 00:17:49.780
And I'm like, "Great."


00:17:50.220 --> 00:17:53.180
'cause like it's actually more verbose than I would prefer,


00:17:53.180 --> 00:17:55.280
but like people are way more tolerant of that.


00:17:55.280 --> 00:17:57.100
So yeah, I guess their IDEs are spitting things out


00:17:57.100 --> 00:17:58.060
or just people.


00:17:58.060 --> 00:18:00.340
- Yeah.


00:18:00.340 --> 00:18:01.540
- The values are different now.


00:18:01.540 --> 00:18:02.620
- Kids these days.


00:18:02.620 --> 00:18:06.220
So is the goal with the data classes


00:18:06.220 --> 00:18:09.260
to try to have a more pure entity model


00:18:09.260 --> 00:18:11.820
that doesn't have like column information


00:18:11.820 --> 00:18:13.180
and key index information


00:18:13.180 --> 00:18:16.220
and just there's some other layer that puts those together?


00:18:16.220 --> 00:18:17.060
What's this?


00:18:17.060 --> 00:18:18.140
I haven't really played with that aspect.


00:18:18.140 --> 00:18:21.980
- Data classes, I haven't really had the Kool-Aid


00:18:21.980 --> 00:18:22.820
with the data classes yet.


00:18:22.820 --> 00:18:25.860
I think the idea is that it's this very clean


00:18:25.860 --> 00:18:30.860
data encapsulating object that has kind of prefab


00:18:30.860 --> 00:18:35.580
constructors and reaper and validation maybe.


00:18:35.580 --> 00:18:37.620
- It does have that kind of stuff, that's right, comparison.


00:18:37.620 --> 00:18:38.460
- Yeah, I might be thinking of Pydantic.


00:18:38.460 --> 00:18:40.820
I mean, Pydantic kind of takes it a little further.


00:18:40.820 --> 00:18:43.580
It's kind of some murky stuff between data classes,


00:18:43.580 --> 00:18:44.420
Pydantic and Tcl.


00:18:44.420 --> 00:18:45.240
I mean--


00:18:45.240 --> 00:18:46.580
- Yeah, they blend together in my mind a little as well.


00:18:46.580 --> 00:18:47.540
- It's all weird, yeah.


00:18:47.540 --> 00:18:49.180
And there's a new product called SQL model


00:18:49.180 --> 00:18:51.580
that seems to be pretty popular in that regard.


00:18:51.580 --> 00:18:53.820
- Yeah, built on SQLAlchemy.


00:18:53.820 --> 00:18:56.020
- Yeah, yeah, which is great.


00:18:56.020 --> 00:18:57.540
It's totally awesome.


00:18:57.540 --> 00:19:01.860
It's actually a more opinionated overlay of the ORM


00:19:01.860 --> 00:19:03.460
which is also, it's also using Python.


00:19:03.460 --> 00:19:04.860
So that's good.


00:19:04.860 --> 00:19:07.060
Yeah, the thing you've got on the screen there


00:19:07.060 --> 00:19:13.500
is another way of, yeah, that's called imperative table.


00:19:13.980 --> 00:19:17.540
but it also has the mapper registry.mapped on it,


00:19:17.540 --> 00:19:18.940
which is interesting, has some of it.


00:19:18.940 --> 00:19:21.940
It's table metadata has like not just the table name,


00:19:21.940 --> 00:19:23.900
but all the column information as well.


00:19:23.900 --> 00:19:28.300
It's interesting, it does have the same type declaration


00:19:28.300 --> 00:19:29.460
that I was trying to impose


00:19:29.460 --> 00:19:32.460
upon the traditional SQLAlchemy models.


00:19:32.460 --> 00:19:34.900
- Yeah, that's one form of the data class model.


00:19:34.900 --> 00:19:39.220
If you scroll down, the more inline embedded one is there.


00:19:39.220 --> 00:19:40.700
Let me see if that's what it is.


00:19:40.700 --> 00:19:42.100
Yeah, that's the one that's even crazier,


00:19:42.100 --> 00:19:44.420
which you have the data class fields.


00:19:44.420 --> 00:19:49.820
So you're fully data, you're fully a data class as far as what's your ID sees.


00:19:49.820 --> 00:19:53.100
But then you have the SQLAlchemy mapping stuff inside.


00:19:53.100 --> 00:19:58.140
So all of this is, you know, we'll, it'll time will tell which approach becomes.


00:19:58.140 --> 00:20:02.580
The popular one or people just use SQL model because the people that like data


00:20:02.580 --> 00:20:08.680
classes are tend to be using SQL model and pydantic anyway, and maybe they'll


00:20:08.680 --> 00:20:09.540
just, they'll be there.


00:20:09.540 --> 00:20:10.260
I don't really know.


00:20:11.380 --> 00:20:14.140
- Yeah, I'm gonna talk to Sebastian Ramirez,


00:20:14.140 --> 00:20:17.100
maybe in December or January about SQL model.


00:20:17.100 --> 00:20:17.940
- Yeah.


00:20:17.940 --> 00:20:19.140
- SQL model is interesting


00:20:19.140 --> 00:20:23.820
because it basically takes Pydantic models


00:20:23.820 --> 00:20:26.980
and SQLAlchemy and merges them together.


00:20:26.980 --> 00:20:29.860
And Sebastian has a good feel


00:20:29.860 --> 00:20:31.580
for what a nice API looks like.


00:20:31.580 --> 00:20:33.580
So I'm optimistic for this.


00:20:33.580 --> 00:20:34.660
I haven't done anything with it,


00:20:34.660 --> 00:20:37.160
but it does look pretty neat.


00:20:37.160 --> 00:20:39.060
- What he had to do was he had to modify


00:20:39.060 --> 00:20:40.700
Pydantic's base class.


00:20:40.700 --> 00:20:44.300
'Cause when I first looked, maybe like in this last past year


00:20:44.300 --> 00:20:47.420
about how Pydantic do SQLAlchemy


00:20:47.420 --> 00:20:49.480
without having two separate models,


00:20:49.480 --> 00:20:51.260
I was like, okay, this base class has got a whole thing,


00:20:51.260 --> 00:20:52.780
a lot of things going on that don't work


00:20:52.780 --> 00:20:55.460
with Python descriptors, so it'd have to change.


00:20:55.460 --> 00:20:57.860
And I think Sebastian did that, basically.


00:20:57.860 --> 00:20:59.780
He went in and changed how the init works


00:20:59.780 --> 00:21:03.500
so that it's compatible and more power to it.


00:21:03.500 --> 00:21:05.340
- Yeah, more power to it, awesome.


00:21:05.340 --> 00:21:06.340
- I have enough to work on.


00:21:06.340 --> 00:21:07.540
I can't, this is like too much for me


00:21:07.540 --> 00:21:09.620
to also work on Pydantic,


00:21:09.620 --> 00:21:10.900
So I'm glad someone else did it.


00:21:10.900 --> 00:21:13.260
- Yeah, absolutely, absolutely.


00:21:13.260 --> 00:21:16.540
One more philosophy thing, that is not it, this is the one.


00:21:16.540 --> 00:21:19.060
One more philosophy thing that I want to ask about,


00:21:19.060 --> 00:21:20.740
or let you just speak to,


00:21:20.740 --> 00:21:25.220
because this is a key element of how SQLAlchemy works.


00:21:25.220 --> 00:21:27.340
There's other ORMs that work this way.


00:21:27.340 --> 00:21:31.100
And then there's also this one, I think it's called Django.


00:21:31.100 --> 00:21:33.500
People might've used the Django ORM before.


00:21:33.500 --> 00:21:36.420
No, that one is more of a traditional


00:21:36.420 --> 00:21:37.900
Ruby on Rails Active Record,


00:21:37.900 --> 00:21:39.380
I have a thing and I call save on it.


00:21:39.380 --> 00:21:40.580
- Sure.


00:21:40.580 --> 00:21:42.580
- You went with this thing called unit of work,


00:21:42.580 --> 00:21:44.660
which is a little more transactional,


00:21:44.660 --> 00:21:46.460
like I'm gonna do a bunch of stuff and then all together.


00:21:46.460 --> 00:21:47.540
- Yeah. - It happens.


00:21:47.540 --> 00:21:49.500
Maybe just speak to that real quick before we talk about it.


00:21:49.500 --> 00:21:52.020
- Well, when I was gonna do SQLAlchemy,


00:21:52.020 --> 00:21:54.260
the main thing that I had worked on a lot at work


00:21:54.260 --> 00:21:56.940
was a lot of fancy selects.


00:21:56.940 --> 00:21:59.460
I hadn't done much work with the persistent side,


00:21:59.460 --> 00:22:02.420
but I read this book by Martin Fowler


00:22:02.420 --> 00:22:04.540
called "Patterns of Enterprise Architecture."


00:22:04.540 --> 00:22:05.460
- I read it as well.


00:22:05.460 --> 00:22:07.420
It was quite an interesting book back then, yeah.


00:22:07.420 --> 00:22:10.300
And I had actually never, even though I had used Hibernate,


00:22:10.300 --> 00:22:12.040
I had never heard of unit of work.


00:22:12.040 --> 00:22:15.580
And I was like, wow, that looks cool.


00:22:15.580 --> 00:22:17.160
I'm gonna write that.


00:22:17.160 --> 00:22:19.900
Because one of the philosophies was like,


00:22:19.900 --> 00:22:23.020
insert update deletes are really, really boring.


00:22:23.020 --> 00:22:25.660
And even saying object that's saved is really boring.


00:22:25.660 --> 00:22:28.940
I was working on a content management system


00:22:28.940 --> 00:22:30.800
for Major League Baseball.


00:22:30.800 --> 00:22:32.060
And when you work with CMSs,


00:22:32.060 --> 00:22:35.180
you have a lot of tree-based hierarchical structures


00:22:35.180 --> 00:22:37.220
with lots of self-referential stuff.


00:22:37.220 --> 00:22:41.780
when you persist self-referential structures in a database with auto-incorporated primary keys,


00:22:41.780 --> 00:22:45.220
you've got to get one row, get the primary key back, put it there,


00:22:45.220 --> 00:22:47.820
put it then everything's going to be done in a very specific order.


00:22:47.820 --> 00:22:50.820
Yeah, yeah. Like I tried to call save on this, but that didn't work


00:22:50.820 --> 00:22:54.500
because I need to call save first there and it's like, ah, this is crazy, right?


00:22:54.500 --> 00:22:57.580
Right. So it's like, why would I want to do, I shouldn't have to do that either.


00:22:57.580 --> 00:23:00.780
I should just have this thing like, here's everything in the transaction, just push it.


00:23:00.780 --> 00:23:04.500
And it, you know, took a very, very long time to get it right.


00:23:04.780 --> 00:23:07.600
It has a couple of little chinks in the armor,


00:23:07.600 --> 00:23:10.660
a couple of cases that you might have to drop it


00:23:10.660 --> 00:23:12.820
to call it flush explicitly,


00:23:12.820 --> 00:23:16.540
but we never get bugs with the unit of work stuff.


00:23:16.540 --> 00:23:18.780
I had, if you look at unit of work.py,


00:23:18.780 --> 00:23:22.200
it hasn't changed in years.


00:23:22.200 --> 00:23:23.120
- Yeah.


00:23:23.120 --> 00:23:24.980
- I mean, it took a long, long time in the beginning,


00:23:24.980 --> 00:23:26.500
and then I rewrote it a few times


00:23:26.500 --> 00:23:28.900
and we found it was really, really bad early on.


00:23:28.900 --> 00:23:31.580
It was very hard to get it right for the stuff.


00:23:31.580 --> 00:23:32.900
- Yeah, a lot of edge cases, right?


00:23:32.900 --> 00:23:34.340
I can imagine.


00:23:34.340 --> 00:23:36.380
People can do at least six months of thinking


00:23:36.380 --> 00:23:37.220
and then you have to make it right.


00:23:37.220 --> 00:23:38.060
- Mostly that we support


00:23:38.060 --> 00:23:39.880
these joint table inheritance models


00:23:39.880 --> 00:23:41.400
were very hard for me to get my head around


00:23:41.400 --> 00:23:42.240
how to persist that.


00:23:42.240 --> 00:23:44.960
And then it just took a long time


00:23:44.960 --> 00:23:46.800
'cause it kind of grew organically.


00:23:46.800 --> 00:23:48.760
You know you're coding, you know what you're doing.


00:23:48.760 --> 00:23:50.600
- Yeah, well, I'm glad you wrote that instead of me.


00:23:50.600 --> 00:23:51.440
So thank you.


00:23:51.440 --> 00:23:53.880
- Yeah, I wouldn't be able to do it today.


00:23:53.880 --> 00:23:56.960
- You gotta be deep in it, right?


00:23:56.960 --> 00:23:58.880
Comment from Brandon Brenner.


00:23:58.880 --> 00:23:59.720
Hey, Brandon.


00:23:59.720 --> 00:24:01.880
Says, "I use SQL model in a demo project


00:24:01.880 --> 00:24:03.000
"and it was so easy to use."


00:24:03.000 --> 00:24:03.840
Very nice.


00:24:03.840 --> 00:24:11.840
- All right, so I think probably the big news over here is 2.0.


00:24:11.840 --> 00:24:12.840
- Yeah.


00:24:12.840 --> 00:24:15.840
- Or as you like to put it at your recent talk, the 1.4ening.


00:24:15.840 --> 00:24:18.840
- Right, the 1.4ening.


00:24:18.840 --> 00:24:25.840
So, yeah, 2.0 has now the docs for it, which are very early stages, are on the site.


00:24:25.840 --> 00:24:30.840
In the library tab is a development thing where the development docs are.


00:24:30.840 --> 00:24:34.840
- The current release is the 1.4. - 1.4.


00:24:34.840 --> 00:24:37.840
It has a lot of these features in there already, right?


00:24:37.840 --> 00:24:44.840
Yes, all of the... just about everything in SQL 2.0 internally is available in 1.4.


00:24:44.840 --> 00:24:48.840
We did all of the internals first and added all the stuff


00:24:48.840 --> 00:24:51.840
so that 1.4 could be a transitional release


00:24:51.840 --> 00:24:56.840
so that all the behind-the-scenes would be getting tested


00:24:56.840 --> 00:24:59.840
and people could use the new APIs and transition over.


00:24:59.840 --> 00:25:03.840
Right. Is 2.0 going to drop some of the older APIs hard?


00:25:03.840 --> 00:25:05.840
Many, yeah.


00:25:05.840 --> 00:25:11.840
So people who have looked, 1.4 has this big migration thing where


00:25:11.840 --> 00:25:16.840
if you're on 1.3, which is pretty common, you can go to 1.4 pretty easily without much problems.


00:25:16.840 --> 00:25:20.840
But right, when you're on this thing, we have this whole thing


00:25:20.840 --> 00:25:25.840
that is kind of inspired by the Python 2-3 process


00:25:25.840 --> 00:25:29.720
and at the same time tries to not make some of them


00:25:29.720 --> 00:25:32.120
what I thought were mistakes of the Python 2D process.


00:25:32.120 --> 00:25:38.280
So what this is based on is that 1.4 has a environment variable


00:25:38.280 --> 00:25:40.840
you can turn on in your console or whatever


00:25:40.840 --> 00:25:43.800
called SQLAlchemyWarn2O, something like that.


00:25:43.800 --> 00:25:47.080
And when you turn that on, you're in now in warnings mode.


00:25:47.080 --> 00:25:50.480
You will get all kinds of warnings about all kinds of APIs


00:25:50.480 --> 00:25:54.200
that either have changed or are going away or use this one or that one.


00:25:54.200 --> 00:25:57.400
So a lot has happened. But at the same time,


00:25:57.400 --> 00:26:02.280
the reason that's maybe not as scary as you might think is that all the APIs that are being deprecated


00:26:02.280 --> 00:26:04.760
are APIs that I've already taken out of the docs years ago.


00:26:04.760 --> 00:26:08.360
Like, the APIs that I've been telling people for years,


00:26:08.360 --> 00:26:10.920
don't do that anymore. We don't, we're not gonna do that.


00:26:10.920 --> 00:26:12.920
So it's a lot of old stuff


00:26:12.920 --> 00:26:17.320
that is not what we feature in the docs. Like, basically, the things we're checking out too well


00:26:17.320 --> 00:26:19.320
are things that have annoyed me for years.


00:26:19.320 --> 00:26:24.040
And there's a few changes in 2.0 that are


00:26:24.040 --> 00:26:29.480
a little more like boom, like we change how the engine is auto begin instead of auto commit.


00:26:29.480 --> 00:26:39.000
But 2.0 is basically going to be, I think, better. It's in line with this whole notion of people are


00:26:39.000 --> 00:26:47.160
appreciate more explicitness when things are clear. So 2.0 is going to remove a lot of implicit stuff,


00:26:47.160 --> 00:26:52.200
a lot of five ways to do the same thing kind of patterns. It's going to narrow you down into


00:26:53.320 --> 00:26:56.320
like one or two possible patterns for things.


00:26:56.320 --> 00:26:58.120
- Yeah, that has been a thing with SQLAlchemy, right?


00:26:58.120 --> 00:27:01.000
There's a lot of ways to accomplish stuff, yeah.


00:27:01.000 --> 00:27:02.960
- Yeah, because I came from Perl, I can, I'm sorry.


00:27:02.960 --> 00:27:05.760
You know, I was doing Perl.


00:27:05.760 --> 00:27:08.240
You know, it's still the case


00:27:08.240 --> 00:27:09.760
that there's more than one way to do things.


00:27:09.760 --> 00:27:11.960
You can't really get away from that totally.


00:27:11.960 --> 00:27:15.520
- Yeah, well, there's often, there's the,


00:27:15.520 --> 00:27:17.280
I want the super simple, easy way,


00:27:17.280 --> 00:27:19.260
just call an ORM method, and then,


00:27:19.260 --> 00:27:21.400
oh, we gotta rewrite the select statement


00:27:21.400 --> 00:27:23.000
is this SOAR procedure type.


00:27:23.000 --> 00:27:25.000
There's usually a backdoor type of thing


00:27:25.000 --> 00:27:28.240
in the database world that has to happen at some point, right?


00:27:28.240 --> 00:27:32.480
Yeah, SOAR procedure is a pretty dramatic example.


00:27:32.480 --> 00:27:35.360
But yeah, these days, the way it is,


00:27:35.360 --> 00:27:36.520
is that when you write your code,


00:27:36.520 --> 00:27:40.800
it's going to be clear where the SQL is being executed,


00:27:40.800 --> 00:27:42.360
where the IO happens.


00:27:42.360 --> 00:27:45.520
I mean, in many ways, it actually was inspired by asyncIO,


00:27:45.520 --> 00:27:49.080
where I had been tweeting a lot with people into asyncIO,


00:27:49.080 --> 00:27:53.320
which I'm a little skeptical of it.


00:27:53.320 --> 00:27:58.600
At the same time, what people appreciate about it is that you're very aware of where


00:27:58.600 --> 00:28:03.240
the actual message to the database is happening.


00:28:03.240 --> 00:28:04.800
This is where the message gets sent out.


00:28:04.800 --> 00:28:05.800
Here's where it comes back.


00:28:05.800 --> 00:28:07.960
When you say, "Wait, now."


00:28:07.960 --> 00:28:08.460
Yeah.


00:28:08.460 --> 00:28:08.960
Now it's happening.


00:28:08.960 --> 00:28:13.440
Now, I think that's a little heavy handed, but at the same time, I appreciated that notion.


00:28:13.440 --> 00:28:17.240
So with 2.0, I tried to work with that idea that we want to make it very clear.


00:28:17.240 --> 00:28:21.880
Here's where you're making a SQL statement. Here's where it's executing. Here's where the results are.


00:28:21.880 --> 00:28:28.680
And then also, here's where the transaction is. And those are actually the biggest changes that


00:28:28.680 --> 00:28:33.000
you're going to know that you're in a transaction, you're going to know when your transaction ended,


00:28:33.000 --> 00:28:36.920
when you're going to know if you committed it, or if it just rolled back.


00:28:36.920 --> 00:28:37.560
Yeah.


00:28:37.560 --> 00:28:41.960
And you'll know and the code is going to be a little more verbose than SQLAlchemy and SQL.client.


00:28:41.960 --> 00:28:46.600
But people are already writing code that way. Because now that I've seen many years of people


00:28:46.600 --> 00:28:49.880
writing code, you know, what I really want to know when this


00:28:49.880 --> 00:28:53.880
happens. So yeah, people don't want, they don't want excess


00:28:53.880 --> 00:28:57.080
bells and switches that are all that that don't mean seem to


00:28:57.080 --> 00:29:01.040
have any purpose. But there if your code is clear, it being


00:29:01.040 --> 00:29:04.640
I basically mean being able to read the code, and the intent is


00:29:04.640 --> 00:29:08.320
as clear as you can get it without. Well, this just does


00:29:08.320 --> 00:29:11.440
that we just know it does that, you know, that's kind of where


00:29:11.440 --> 00:29:15.760
I'm trying to go. And I'm somewhat freed by the fact that


00:29:15.760 --> 00:29:18.920
that I know people are more tolerant of step A,


00:29:18.920 --> 00:29:20.520
step B, step C.


00:29:20.520 --> 00:29:21.360
- Sure.


00:29:21.360 --> 00:29:23.560
- Being explicit. - A little less magic, yeah.


00:29:23.560 --> 00:29:24.560
- Yeah, people are okay with that.


00:29:24.560 --> 00:29:27.520
Now, they weren't okay with that 15, 12 years ago.


00:29:27.520 --> 00:29:28.880
People are like, "That's too much typing."


00:29:28.880 --> 00:29:31.680
So it's good.


00:29:31.680 --> 00:29:33.840
- So I wanna talk about this migration thing,


00:29:33.840 --> 00:29:35.360
like what a person does to go


00:29:35.360 --> 00:29:37.360
from a 1.3 application onward.


00:29:37.360 --> 00:29:39.900
But I think that's getting a little bit ahead of ourselves.


00:29:39.900 --> 00:29:42.280
How about we talk a little bit about


00:29:42.280 --> 00:29:47.280
What are the major features coming in 2.0?


00:29:47.280 --> 00:29:49.960
- Well, first of all, obviously we're finally


00:29:49.960 --> 00:29:52.560
to Python 3 only.


00:29:52.560 --> 00:29:54.640
- Yeah, what is it, 3.6?


00:29:54.640 --> 00:29:55.480
That you're, has a minimum version?


00:29:55.480 --> 00:29:57.120
- We're gonna make it 3.7.


00:29:57.120 --> 00:29:57.960
- 3.7, okay.


00:29:57.960 --> 00:30:01.560
- 3.7, yeah, 3.6 is EOL, so in a month or two.


00:30:01.560 --> 00:30:04.200
- Yeah, yeah, no point to do that.


00:30:04.200 --> 00:30:07.120
- Yeah, just today, or I didn't merge it yet,


00:30:07.120 --> 00:30:11.440
but we're ready to merge this gigantic Garrett review


00:30:11.440 --> 00:30:15.900
that's going to take all the Unicode conversion crap out.


00:30:15.900 --> 00:30:17.680
That was all Python 2.


00:30:17.680 --> 00:30:22.920
I mean, Python 3 having native Unicode is tremendous for us


00:30:22.920 --> 00:30:25.520
because all the DB APIs do the Unicode now.


00:30:25.520 --> 00:30:34.240
The new APIs-- so yeah, we have this new SQL caching system


00:30:34.240 --> 00:30:37.440
that I've talked about a bunch in some


00:30:37.440 --> 00:30:38.720
of the talks I did recently.


00:30:38.720 --> 00:30:40.520
Yeah, tell us about that in a little bit.


00:30:40.520 --> 00:30:41.760
Yeah, that's in 1.4.


00:30:41.760 --> 00:30:44.520
Is that like compiling the SQL statements


00:30:44.520 --> 00:30:46.520
and then like caching those results?


00:30:46.520 --> 00:30:48.520
What are we talking about here?


00:30:48.520 --> 00:30:51.160
So when you run a SQLAlchemy statement,


00:30:51.160 --> 00:30:53.600
we have to take your Python code and make a string out of it,


00:30:53.600 --> 00:30:55.600
which is the string we sent to the database.


00:30:55.600 --> 00:30:57.920
We also have to look at that thing and figure out


00:30:57.920 --> 00:30:59.920
what kinds of results are we going to get back?


00:30:59.920 --> 00:31:02.920
Are we going to get strings and dates and integers and floats?


00:31:02.920 --> 00:31:05.680
And then for those strings and states and floats and whatever,


00:31:05.680 --> 00:31:07.680
do we have to do any processing on the rows?


00:31:07.680 --> 00:31:09.680
We want to have that all set up because if you get


00:31:09.680 --> 00:31:13.160
10,000 rows back, you want to make all those decisions up front.


00:31:13.160 --> 00:31:15.800
- So that we run 10,000 times. - 10,000 times.


00:31:15.800 --> 00:31:17.800
Everything is as fast as possible.


00:31:17.800 --> 00:31:19.800
Everything is already figured out.


00:31:19.800 --> 00:31:23.440
When you do the ORM, that whole process becomes way more complicated.


00:31:23.440 --> 00:31:25.440
There's way more going on. There's ego loaders,


00:31:25.440 --> 00:31:27.440
and there's more fancy kinds of types.


00:31:27.440 --> 00:31:30.680
We might be taking columns and putting them into an object.


00:31:30.680 --> 00:31:34.160
All of that stuff is time-consuming,


00:31:34.160 --> 00:31:38.640
and it all now in 1.4 lives behind what I call the cache wall,


00:31:38.640 --> 00:31:40.960
which means when the caching is working,


00:31:40.960 --> 00:31:42.940
which it seems to work,


00:31:42.940 --> 00:31:44.380
it's only gonna do that stuff once


00:31:44.380 --> 00:31:46.800
for a statement that's been cached.


00:31:46.800 --> 00:31:48.120
So when we run your statement,


00:31:48.120 --> 00:31:50.060
we're gonna do a process that's still a little pricey,


00:31:50.060 --> 00:31:53.580
which is to get a cache key from what you typed.


00:31:53.580 --> 00:31:55.540
- You gotta determine some sort of unique hash


00:31:55.540 --> 00:31:56.380
type of thing out of it.


00:31:56.380 --> 00:31:59.060
- Yeah, it's actually a gigantic tuple right now.


00:31:59.060 --> 00:32:01.020
And maybe it'll be a hash in some other release.


00:32:01.020 --> 00:32:01.980
But for now it's a giant tuple


00:32:01.980 --> 00:32:04.660
'cause Python's pretty good at that.


00:32:04.660 --> 00:32:07.380
It's cheaper than doing the whole compilation.


00:32:07.380 --> 00:32:10.540
And then we get the whole compilation from a cache,


00:32:10.540 --> 00:32:12.660
if it's there, and if it's LRU cache.


00:32:12.660 --> 00:32:14.180
So if it's not, we make it.


00:32:14.180 --> 00:32:18.100
And it allows us to put more bells and whistles


00:32:18.100 --> 00:32:19.260
into the compiler.


00:32:19.260 --> 00:32:21.820
We have this thing where it will now detect


00:32:21.820 --> 00:32:24.540
if your statement will produce a Cartesian product,


00:32:24.540 --> 00:32:26.560
meaning you have joins between tables


00:32:26.560 --> 00:32:28.100
that are not linked together.


00:32:28.100 --> 00:32:30.020
And we have all kinds of other fun things


00:32:30.020 --> 00:32:33.040
the ORM can do that take a little more time to compile,


00:32:33.040 --> 00:32:34.180
but now they're behind a cache.


00:32:34.180 --> 00:32:38.820
So the performance is not really impacted too much.


00:32:38.820 --> 00:32:41.620
And so that's exciting stuff.


00:32:41.620 --> 00:32:46.940
And we're going to be looking into 2.0 to start using Cython


00:32:46.940 --> 00:32:49.020
to speed this up even more.


00:32:49.020 --> 00:32:50.660
SQLogging for many years--


00:32:50.660 --> 00:32:53.100
yeah, SQLogging for many years has C extensions


00:32:53.100 --> 00:32:55.540
that we wrote as C code years ago.


00:32:55.540 --> 00:32:57.860
We're going to migrate those to Cython


00:32:57.860 --> 00:33:02.100
so that we can more quickly add new Cythonized code


00:33:02.100 --> 00:33:03.900
for different sections to speed up


00:33:03.900 --> 00:33:05.900
to have those cache keys get built.


00:33:05.900 --> 00:33:07.540
- Yeah, it's one thing to say we're gonna write


00:33:07.540 --> 00:33:09.660
some big chunk in C layer.


00:33:09.660 --> 00:33:11.980
It's another to say, just that loop,


00:33:11.980 --> 00:33:14.020
could that loop be C?


00:33:14.020 --> 00:33:14.860
- Yeah.


00:33:14.860 --> 00:33:17.100
- And with Cython, you can kind of just do that.


00:33:17.100 --> 00:33:17.940
- You can do that.


00:33:17.940 --> 00:33:20.660
You can do it quicker and without having to worry


00:33:20.660 --> 00:33:24.060
about all the memory reference counters.


00:33:24.060 --> 00:33:26.820
You know, C code in Python is pretty tedious.


00:33:26.820 --> 00:33:29.220
I'm not really a spectacular C programmer anyway.


00:33:29.220 --> 00:33:31.380
Yeah, so the cache--


00:33:31.380 --> 00:33:34.160
- So a lot of people who might want to come contribute


00:33:34.160 --> 00:33:35.560
are probably not C developers,


00:33:35.560 --> 00:33:37.040
they're Python developers first.


00:33:37.040 --> 00:33:40.360
- Yeah, yeah, Cython is pretty cool.


00:33:40.360 --> 00:33:41.480
So that is because you can really,


00:33:41.480 --> 00:33:42.800
if you just do Python, you can do it.


00:33:42.800 --> 00:33:44.980
It's just like a strict Python.


00:33:44.980 --> 00:33:47.240
It's pretty neat.


00:33:47.240 --> 00:33:50.400
And we found that some of the Cythonized versions


00:33:50.400 --> 00:33:53.000
of the functions are actually faster than our C code.


00:33:53.000 --> 00:33:55.000
- Really? - Strange.


00:33:55.000 --> 00:33:56.320
- That's pretty strange.


00:33:56.320 --> 00:33:58.040
- That's strange because Cython,


00:33:58.040 --> 00:34:01.880
the people that did Cython optimize the crap out of it.


00:34:01.880 --> 00:34:06.380
They know all these very esoteric Python C API things


00:34:06.380 --> 00:34:08.440
that like literally we have,


00:34:08.440 --> 00:34:09.680
our C code is not a lot of code.


00:34:09.680 --> 00:34:11.000
It's like, you know, it's like a few hundred lines.


00:34:11.000 --> 00:34:12.520
It's like, we'll call like, you know,


00:34:12.520 --> 00:34:15.320
tuple get item or whatever it's called.


00:34:15.320 --> 00:34:17.240
Cython has some, well, if we do this and that,


00:34:17.240 --> 00:34:19.500
then it's faster and it actually is.


00:34:19.500 --> 00:34:22.000
I can't give you detail on, cause I don't know,


00:34:22.000 --> 00:34:24.920
but like we did benching and Cython


00:34:24.920 --> 00:34:26.720
was actually faster than raw C code.


00:34:26.720 --> 00:34:30.440
- Yeah, I remember way back when hearing,


00:34:30.440 --> 00:34:31.440
you know, people used to say,


00:34:31.440 --> 00:34:32.680
well, if you want it to be fast,


00:34:32.680 --> 00:34:34.880
you have to write an assembler.


00:34:34.880 --> 00:34:37.760
And then you can use C if it's not gonna be that fast.


00:34:37.760 --> 00:34:38.600
- Right.


00:34:38.600 --> 00:34:39.420
- Right?


00:34:39.420 --> 00:34:41.000
- That's a different kind of fast.


00:34:41.000 --> 00:34:42.000
- Right, well, what I was--


00:34:42.000 --> 00:34:42.840
- To be clear.


00:34:42.840 --> 00:34:43.660
- Well, turn, of course,


00:34:43.660 --> 00:34:46.960
but to be, well, the interesting thing to me was


00:34:46.960 --> 00:34:50.040
there was this switch when the compilers got good enough


00:34:50.040 --> 00:34:52.880
that you probably were slower writing assembly


00:34:52.880 --> 00:34:53.720
for most people, right?


00:34:53.720 --> 00:34:54.540
- Yeah, right.


00:34:54.540 --> 00:34:55.800
- And I feel like the thing you're describing here


00:34:55.800 --> 00:35:00.320
kind of like that transformation like this, the compiler understands the whole system


00:35:00.320 --> 00:35:03.520
better than if you were to do it yourself at the same level.


00:35:03.520 --> 00:35:08.520
Yeah, they found, yeah, they've apparently, I don't know the specifics, but in some cases,


00:35:08.520 --> 00:35:11.360
they've figured out ways to make it even faster.


00:35:11.360 --> 00:35:13.160
So there's no reason to not use Cython.


00:35:13.160 --> 00:35:16.600
You think of what people are doing with Cython, right?


00:35:16.600 --> 00:35:21.120
They're running on supercomputers doing huge calculations that take so, they have a strong


00:35:21.120 --> 00:35:24.520
motivation to make it a little bit faster here and there.


00:35:24.520 --> 00:35:54.480
Yeah, I mean, right. Look, here's the thing about Python. Python is a high level scripting language. It's interpreted always. So it's already not, you know, I don't want to say that. But like, if you're really writing like, you know, high frequency trading software, you probably want to use something like Rust or something. You know, Python is not really that. It's a lot of things. But it's not like, you know, high frequency trading speed daemon type thing. It's just it's, I mean, you can't do that.


00:35:54.480 --> 00:35:55.680
You can make it do that.


00:35:55.680 --> 00:36:01.200
- Once you start wanting it to be sub millisecond,


00:36:01.200 --> 00:36:03.400
you might wanna start, but other than that,


00:36:03.400 --> 00:36:04.440
you're probably fine, yeah.


00:36:04.440 --> 00:36:07.160
- Yeah, it's not gonna, I might be wrong,


00:36:07.160 --> 00:36:10.000
it's not gonna control the rockets, you know,


00:36:10.000 --> 00:36:12.560
but I guess maybe it does, I don't know.


00:36:12.560 --> 00:36:13.400
It doesn't have to be that.


00:36:13.400 --> 00:36:15.720
It's so useful for so much stuff that--


00:36:15.720 --> 00:36:17.400
- Yeah, absolutely.


00:36:17.400 --> 00:36:18.880
Okay, so that's really cool.


00:36:18.880 --> 00:36:23.420
So you're thinking about switching some of your C code


00:36:23.420 --> 00:36:25.560
over to Cycon, which is really interesting.


00:36:25.560 --> 00:36:28.200
And I didn't see that one coming.


00:36:28.200 --> 00:36:29.040
That's awesome.


00:36:29.040 --> 00:36:30.220
The cache layer is cool.


00:36:30.220 --> 00:36:33.340
So that way, if I call a function and in that function,


00:36:33.340 --> 00:36:36.940
I do a query statement in the ORM,


00:36:36.940 --> 00:36:38.180
the first time that's expensive,


00:36:38.180 --> 00:36:41.420
the second time it's not free, but less expensive, right?


00:36:41.420 --> 00:36:42.260
Cheapish.


00:36:42.260 --> 00:36:43.580
- It's much, much less expensive.


00:36:43.580 --> 00:36:44.620
- Much less, okay.


00:36:44.620 --> 00:36:45.780
- Yeah, yeah.


00:36:45.780 --> 00:36:47.100
What we haven't sped up yet,


00:36:47.100 --> 00:36:48.780
and I mean, I've been speaking this for many years,


00:36:48.780 --> 00:36:51.700
is when you fetch rows from the ORM


00:36:51.700 --> 00:36:54.160
to create the Python objects that are your classes,


00:36:54.160 --> 00:36:57.420
that's still more expensive than we'd like it to be.


00:36:57.420 --> 00:36:58.260
So if you're fetching 1,000--


00:36:58.260 --> 00:36:59.100
- That is one of the most,


00:36:59.100 --> 00:37:01.260
yeah, that's super expensive in terms,


00:37:01.260 --> 00:37:02.820
in ORMs and ODMs. - It is.


00:37:02.820 --> 00:37:05.280
- If you select 10,000 rows out of a database,


00:37:05.280 --> 00:37:07.780
it's probably the serialization or deserialization


00:37:07.780 --> 00:37:08.940
that's the cost, right?


00:37:08.940 --> 00:37:10.980
- Completely, completely.


00:37:10.980 --> 00:37:14.820
And I've made the loading way, way,


00:37:14.820 --> 00:37:17.220
like I spent years and years making it way faster


00:37:17.220 --> 00:37:18.460
by doing that whole thing


00:37:18.460 --> 00:37:21.460
where we precalculate everything up front.


00:37:21.460 --> 00:37:23.700
Every loader, we're not gonna,


00:37:23.700 --> 00:37:25.320
like every time you get a row,


00:37:25.320 --> 00:37:26.360
it's like zip, zip, zip, zip, zip.


00:37:26.360 --> 00:37:27.580
We have this little call we'll set up.


00:37:27.580 --> 00:37:30.100
But still, just to make the object,


00:37:30.100 --> 00:37:32.540
just to make a new class in Python is expensive.


00:37:32.540 --> 00:37:33.560
It's pricey.


00:37:33.560 --> 00:37:35.880
So still a work in progress.


00:37:35.880 --> 00:37:38.140
But yeah, the caching will not speed that up.


00:37:38.140 --> 00:37:41.120
It'll speed up the overhead per query.


00:37:41.120 --> 00:37:42.260
- Sure, which is still,


00:37:42.260 --> 00:37:44.860
like every area you can speed it up is great.


00:37:44.860 --> 00:37:46.520
Danielle out there says,


00:37:46.520 --> 00:37:49.460
Cython is also a great choice to forget about ref count


00:37:49.460 --> 00:37:52.780
and PsychoPG2, it took a while to find all the--


00:37:52.780 --> 00:37:54.780
- Totally, yeah, ref counts are tough.


00:37:54.780 --> 00:37:57.180
Ref counts are tough.


00:37:57.180 --> 00:37:59.180
- Yeah.


00:37:59.180 --> 00:38:02.060
- I'm pretty proud of myself that I did figure them out


00:38:02.060 --> 00:38:03.620
to some degree.


00:38:03.620 --> 00:38:05.180
You know, they're not as hard as malloc and free,


00:38:05.180 --> 00:38:09.580
but it's kind of an esoteric set of rules to ref counts.


00:38:09.580 --> 00:38:11.460
- While we're down in the internals, let me ask you this,


00:38:11.460 --> 00:38:13.700
if you've thought about this or experimented with this,


00:38:13.700 --> 00:38:18.700
any, one thing, as I dug into Python's memory model,


00:38:19.300 --> 00:38:24.300
that I found to be really interesting is when you create,


00:38:24.300 --> 00:38:26.500
you know, you have GC, the GC module,


00:38:26.500 --> 00:38:28.940
you can say GC get thresholds or set thresholds,


00:38:28.940 --> 00:38:30.460
and the thresholds tell you


00:38:30.460 --> 00:38:32.340
what will trigger a garbage collection,


00:38:32.340 --> 00:38:33.220
not reference counting,


00:38:33.220 --> 00:38:36.220
but a cycle detection type of thing, right?


00:38:36.220 --> 00:38:37.400
- Yeah.


00:38:37.400 --> 00:38:39.620
- The defaults, at least last I looked,


00:38:39.620 --> 00:38:44.100
I haven't looked in 3.10, but in 3.9, it was 710.10,


00:38:44.100 --> 00:38:47.140
which means 700 allocations,


00:38:47.140 --> 00:38:49.260
and then for every 10 Gen0 collections,


00:38:49.260 --> 00:38:51.300
there's a Gen 1 and every 10 Gen 1,


00:38:51.300 --> 00:38:53.380
there's a Gen 2 collection.


00:38:53.380 --> 00:38:57.140
That 700 means if you allocate more,


00:38:57.140 --> 00:39:01.480
700 more classes or dictionaries or tuples or whatever,


00:39:01.480 --> 00:39:05.780
then have been freed, a GC will run.


00:39:05.780 --> 00:39:06.620
- Yeah.


00:39:06.620 --> 00:39:11.340
- So if you select 10,000 rows out of a database,


00:39:11.340 --> 00:39:12.760
how many GCs are running?


00:39:12.760 --> 00:39:15.500
I mean, that's a lot, right?


00:39:15.500 --> 00:39:16.340
That's like 14 GCs. - It depends on


00:39:16.340 --> 00:39:18.860
what you're doing, because if you're taking the 10,000 rows


00:39:18.860 --> 00:39:21.900
put them in a gigantic list, then it's not GCing much at all, because you're putting


00:39:21.900 --> 00:39:23.860
it all in a gigantic buffer.


00:39:23.860 --> 00:39:26.860
You're going to have to watch the size of your process grow.


00:39:26.860 --> 00:39:27.860
Right.


00:39:27.860 --> 00:39:32.220
I mean, you're not freeing any, and you're not ref-count freeing any either, but you're


00:39:32.220 --> 00:39:35.340
allocating 700 more.


00:39:35.340 --> 00:39:40.140
I think that might trigger 14 GCs, unless I'm understanding it wrong.


00:39:40.140 --> 00:39:41.140
You would know.


00:39:41.140 --> 00:39:42.140
I don't know anything about it.


00:39:42.140 --> 00:39:43.140
I wouldn't know.


00:39:43.140 --> 00:39:45.140
All I know about GC is that it's going to happen.


00:39:45.140 --> 00:39:46.140
Yeah.


00:39:46.140 --> 00:39:49.420
The reference counting stuff is super straightforward, but the GC side,


00:39:49.420 --> 00:39:53.180
so I've always thought about this around the database,


00:39:53.180 --> 00:39:56.740
even if you're just getting dictionaries, not ORM classes back.


00:39:56.740 --> 00:39:57.420
Yeah.


00:39:57.420 --> 00:39:59.020
If you're selecting a whole bunch of stuff,


00:39:59.020 --> 00:40:00.820
not only are you doing that serialization layer,


00:40:00.820 --> 00:40:02.540
you're also incurring a bunch of GC


00:40:02.540 --> 00:40:05.460
because it's trying to preemptively run around and look for cycles


00:40:05.460 --> 00:40:06.860
that might have been forming.


00:40:06.860 --> 00:40:10.420
Right. Well, one thing you can do is make the code


00:40:10.420 --> 00:40:11.780
so that you don't have as many cycles.


00:40:11.780 --> 00:40:13.020
And we actually do that.


00:40:13.020 --> 00:40:16.220
We've had people post issues related to this.


00:40:16.220 --> 00:40:18.060
So I said I don't know much about GC.


00:40:18.060 --> 00:40:20.540
I do know that if you can reduce reference cycles,


00:40:20.540 --> 00:40:23.500
you will have less of these asynchronous GC runs happening.


00:40:23.500 --> 00:40:28.380
So we had someone specifically came to me with a whole lot of use cases where he showed,


00:40:28.380 --> 00:40:31.500
when you run this little code, like all these GCs would happen.


00:40:31.500 --> 00:40:34.860
And we went in there and got rid of a lot of cycles.


00:40:34.860 --> 00:40:38.540
So we actually have a test suite in test/aa profiling,


00:40:38.540 --> 00:40:41.020
test man usage called cycle test, something like that.


00:40:41.020 --> 00:40:44.460
And they're all these little whiz bangs that run like,


00:40:44.460 --> 00:40:47.500
make a session and close it, do this and that, do this and that, and then it will


00:40:47.500 --> 00:40:51.500
runs it in a harness that actually counting what GC is doing.


00:40:51.500 --> 00:40:55.180
And it's asserting that there's only like five GC calls and not 20.


00:40:55.180 --> 00:40:56.780
Right, yeah, that's fantastic.


00:40:56.780 --> 00:40:58.060
We have a lot of that happening.


00:40:58.060 --> 00:41:01.340
Yeah, it's cool that you're thinking about it. I mean,


00:41:01.340 --> 00:41:04.700
on one hand, this is an external thing. So you can control your data structures,


00:41:04.700 --> 00:41:07.820
but you can't totally control what people set their GC to do. But


00:41:07.820 --> 00:41:10.060
anyway, it's just something that I always think about when


00:41:10.060 --> 00:41:12.380
when you're creating lots of these ORM things,


00:41:12.380 --> 00:41:14.460
because a lot of the signals to the GC are like,


00:41:14.460 --> 00:41:15.660
"Oh, I got to get busy."


00:41:15.660 --> 00:41:17.660
But you're not even...


00:41:17.660 --> 00:41:19.660
That's a single call to SQLAlchemy,


00:41:19.660 --> 00:41:20.660
and I'm just waiting.


00:41:20.660 --> 00:41:22.660
There's nothing else I can do to get out of the way.


00:41:22.660 --> 00:41:23.660
You know what I mean?


00:41:23.660 --> 00:41:25.660
We've just been around for so many years,


00:41:25.660 --> 00:41:26.660
and people have come to us.


00:41:26.660 --> 00:41:29.060
We have all kinds of mem usage


00:41:29.060 --> 00:41:31.460
and C-profile stuff in our test suite


00:41:31.460 --> 00:41:33.860
to make sure the call counts don't grow here,


00:41:33.860 --> 00:41:35.360
to make sure we don't do too many GCs.


00:41:35.360 --> 00:41:37.360
We try to work on that as much as we can.


00:41:37.360 --> 00:41:39.360
Yeah, cool.


00:41:39.360 --> 00:41:46.720
ongoing. So I would say one of the things that makes me more excited than most of the other stuff here is probably the


00:41:46.720 --> 00:41:55.000
async support that you have going on. That's, you want to talk a bit about, about that? Yeah. So when I was doing 2.0, I


00:41:55.000 --> 00:42:01.440
thought, I wanted to be kind of compatible with how asyncio works. And because I figured I would eventually do an


00:42:01.440 --> 00:42:03.160
an asyncio API for it.


00:42:03.160 --> 00:42:06.460
But then I suddenly had this idea.


00:42:06.460 --> 00:42:10.220
Why don't we just do the asyncio thing and we use it?


00:42:10.220 --> 00:42:11.120
We do it doing this.


00:42:11.120 --> 00:42:13.200
We use this library called Greenlit.


00:42:13.200 --> 00:42:15.160
OK, yeah.


00:42:15.160 --> 00:42:21.120
Can we can we just take a quick quick break 'cause I have I


00:42:21.120 --> 00:42:23.360
one second? Yeah, sure, no problem.


00:42:23.360 --> 00:42:25.880
I'm just talking every second be right back.


00:42:25.880 --> 00:42:40.380
Thanks everyone out there in the audience for all the good questions. I'm going to have


00:42:40.380 --> 00:42:50.320
to run some of those GC examples and count it. I ask that because over on Talk Python


00:42:50.320 --> 00:43:04.000
training here have as you imagine sitemap dot XML is all the sitemap stuff


00:43:04.000 --> 00:43:08.600
but tons and tons of stuff you see how big that scroll bar is it's massive when


00:43:08.600 --> 00:43:12.920
we were loading that page we were getting 77 garbage collection cycles


00:43:12.920 --> 00:43:18.840
yeah we had to change the GC stuff and we got it down to two and it made the


00:43:18.840 --> 00:43:22.080
the speed of the site so much better.


00:43:22.080 --> 00:43:23.200
Now we're not using SQLAlchemy,


00:43:23.200 --> 00:43:24.920
we're using MongoEngine and MongoDBs,


00:43:24.920 --> 00:43:28.640
but the principle is identical, so it's interesting.


00:43:28.640 --> 00:43:31.040
But still, I gotta check into it for SQLAlchemy.


00:43:31.040 --> 00:43:32.280
Pretty interesting stuff.


00:43:32.280 --> 00:43:36.660
Thanks, John, really glad.


00:43:36.660 --> 00:43:41.660
Yeah, Mike has some fantastic insight there, for sure.


00:43:41.660 --> 00:43:45.240
- We're back, sorry about that.


00:43:45.240 --> 00:43:46.360
- And we're back, no worries.


00:43:46.360 --> 00:43:48.960
I was just sort of riffing on some stuff,


00:43:48.960 --> 00:43:50.200
some follow up stuff there.


00:43:50.200 --> 00:43:51.360
All right, so async.


00:43:51.360 --> 00:43:54.600
Where's a good example that I could pull up on the website


00:43:54.600 --> 00:43:57.000
to show like using a query?


00:43:57.000 --> 00:43:58.560
- There should be an async I/O.


00:43:58.560 --> 00:44:01.160
Okay, in ORM examples.


00:44:01.160 --> 00:44:02.760
- Yeah, that's exactly.


00:44:02.760 --> 00:44:03.600
- Yeah.


00:44:03.600 --> 00:44:04.420
- Let's see.


00:44:04.420 --> 00:44:05.260
ORM examples, okay.


00:44:05.260 --> 00:44:06.240
- You were just there a minute ago.


00:44:06.240 --> 00:44:07.680
- Yeah, I'm there, I'm there.


00:44:07.680 --> 00:44:11.240
- Do we have async I/O?


00:44:11.240 --> 00:44:12.120
- That's what I was thinking.


00:44:12.120 --> 00:44:12.960
Let's see, Jason.


00:44:12.960 --> 00:44:14.560
Oh, here you go, async I/O integration.


00:44:14.560 --> 00:44:15.860
There we go.


00:44:15.860 --> 00:44:19.540
So the way the asyncio works is that SQLAlchemy


00:44:19.540 --> 00:44:22.500
has async blocking API.


00:44:22.500 --> 00:44:25.620
We call dbAPI execute, it blocks, it comes back.


00:44:25.620 --> 00:44:28.980
Usually the way you want to make that kind of thing work


00:44:28.980 --> 00:44:32.180
in an async non-blocking context is you have to throw


00:44:32.180 --> 00:44:33.920
all the stuff into a thread pool.


00:44:33.920 --> 00:44:36.260
You probably don't want to be in the wiki,


00:44:36.260 --> 00:44:38.620
'cause that's more old stuff.


00:44:38.620 --> 00:44:39.460
- Okay.


00:44:39.460 --> 00:44:41.580
- Yeah, like that one.


00:44:41.580 --> 00:44:43.420
Click on async ORM at the top, that one.


00:44:43.420 --> 00:44:44.260
- There we go.


00:44:44.260 --> 00:44:45.080
This is the one I was looking for.


00:44:45.080 --> 00:44:45.920
- The most basic, yeah.


00:44:45.920 --> 00:44:48.120
- This is the one I wanted to show people, yes.


00:44:48.120 --> 00:44:50.760
Not the Session one, but the ORM.


00:44:50.760 --> 00:44:51.760
- Yeah, this is ORM.


00:44:51.760 --> 00:44:55.760
So what's important here is that the notion that we,


00:44:55.760 --> 00:44:59.360
2.0 style has a thing where there's a very specific place


00:44:59.360 --> 00:45:01.220
that execute happens.


00:45:01.220 --> 00:45:03.280
Because with the query object that,


00:45:03.280 --> 00:45:06.160
like, you know, SQL query session.query,


00:45:06.160 --> 00:45:09.400
you could say query.all, query.one, query.first.


00:45:09.400 --> 00:45:11.760
I didn't want to have all this await this, await that,


00:45:11.760 --> 00:45:12.920
await everything.


00:45:12.920 --> 00:45:16.320
With the new API, it's just, which is really the old API,


00:45:16.320 --> 00:45:18.680
it's await execute.


00:45:18.680 --> 00:45:19.720
And then you get your result back


00:45:19.720 --> 00:45:21.320
and then the result is buffered.


00:45:21.320 --> 00:45:24.680
And the way this works that changed


00:45:24.680 --> 00:45:27.320
the whole asyncio equation for SQLAlchemy


00:45:27.320 --> 00:45:30.520
is that this is not a rewrite of anything.


00:45:30.520 --> 00:45:34.680
This is a layer on top of the completely blocking API stuff


00:45:34.680 --> 00:45:36.440
and it does not use threads.


00:45:36.440 --> 00:45:38.160
It uses Greenlet.


00:45:38.160 --> 00:45:40.800
When I went to look at what Greenlet actually does,


00:45:41.720 --> 00:45:44.080
A greenlet is compared to a thread,


00:45:44.080 --> 00:45:47.080
but it's kind of not like, it's like a thread,


00:45:47.080 --> 00:45:48.040
but when you see what it is,


00:45:48.040 --> 00:45:49.160
it doesn't really feel like a thread


00:45:49.160 --> 00:45:51.600
because it's like, it's a little thing with code


00:45:51.600 --> 00:45:53.720
that you can context switch somewhere else.


00:45:53.720 --> 00:45:57.080
- It's more like generators than it is like threads.


00:45:57.080 --> 00:45:59.280
Like the weirdness of generators skipping around, yeah.


00:45:59.280 --> 00:46:00.160
- Exactly.


00:46:00.160 --> 00:46:02.720
So the way Python asyncIO has that await key,


00:46:02.720 --> 00:46:06.080
where the await is your context switch in asyncIO.


00:46:06.080 --> 00:46:08.400
Now, I wanted the internals of SQLAlchemy


00:46:08.400 --> 00:46:10.440
to work in this context switching way,


00:46:10.440 --> 00:46:12.160
but to integrate with Await.


00:46:12.160 --> 00:46:15.800
So we basically made a greenlit wrapper


00:46:15.800 --> 00:46:19.480
that emulates Await without actually using Await.


00:46:19.480 --> 00:46:24.120
So you're able to take SQL means blocking internals,


00:46:24.120 --> 00:46:26.160
which ultimately go out to,


00:46:26.160 --> 00:46:28.440
when you use SQL to be async I/O,


00:46:28.440 --> 00:46:30.840
you're gonna use a DP API.


00:46:30.840 --> 00:46:33.200
Actually, it's not DP, it's a database driver


00:46:33.200 --> 00:46:34.960
that is itself also async I/O.


00:46:34.960 --> 00:46:39.020
Currently, you're gonna call asyncpg,


00:46:40.400 --> 00:46:43.000
There's an AO SQLite, there's an AsyncMy,


00:46:43.000 --> 00:46:46.040
and also there's one, oh, I can't remember the name of it.


00:46:46.040 --> 00:46:47.040
Wait, I can't remember the name.


00:46:47.040 --> 00:46:48.400
Trying to get Daniel to,


00:46:48.400 --> 00:46:51.080
PsychoPG3.


00:46:51.080 --> 00:46:54.240
I was teasing Daniel 'cause he's on there.


00:46:54.240 --> 00:46:57.520
There's gonna be a PsychoPG3 that we're also gonna support


00:46:57.520 --> 00:47:02.120
that does AsyncIO for Postgres.


00:47:02.120 --> 00:47:05.240
So you have the AsyncIO driver,


00:47:05.240 --> 00:47:07.920
SQLAlchemy then adapts the AWait calls


00:47:07.920 --> 00:47:11.360
into its synchronous thing using the green lit thing.


00:47:11.360 --> 00:47:14.360
And then on the outside, where you see on the screen there,


00:47:14.360 --> 00:47:16.960
is you have asyncio stuff.


00:47:16.960 --> 00:47:19.600
And when I actually talked to some of the people


00:47:19.600 --> 00:47:21.780
that were involved with asyncio in Python,


00:47:21.780 --> 00:47:23.380
they explained to me, you could do it the other way too.


00:47:23.380 --> 00:47:27.760
You can have a synchronous API that calls into an async


00:47:27.760 --> 00:47:29.920
middle that goes back out to async API.


00:47:29.920 --> 00:47:31.120
And that's actually kind of easier to do.


00:47:31.120 --> 00:47:32.440
But since SQLAlchemy was already written


00:47:32.440 --> 00:47:34.640
in sync blocking style, we kept it that way.


00:47:34.640 --> 00:47:37.160
- Right, it's a lot easier to wrap an async shell


00:47:37.160 --> 00:47:40.300
on something that's 15 years old and polished,


00:47:40.300 --> 00:47:41.140
all the way through, right?


00:47:41.140 --> 00:47:41.960
And then it's just like,


00:47:41.960 --> 00:47:43.840
we're gonna do the inside all over again.


00:47:43.840 --> 00:47:45.480
- Yeah, and the thing with Async is that


00:47:45.480 --> 00:47:49.240
there were some SQLAlchemy-based things on GitHub


00:47:49.240 --> 00:47:51.480
and whatever that were basically taking our engine


00:47:51.480 --> 00:47:52.640
and connection and rewriting them


00:47:52.640 --> 00:47:55.440
as totally brand new AsyncIO things.


00:47:55.440 --> 00:47:56.520
And I always thought, I'm like,


00:47:56.520 --> 00:47:58.640
that's not, you can't maintain that.


00:47:58.640 --> 00:48:00.520
It's like you're taking our code,


00:48:00.520 --> 00:48:03.340
taking about 30% of what it actually does,


00:48:03.340 --> 00:48:07.420
and putting it up and I was like, that can't work.


00:48:07.420 --> 00:48:08.660
There's gotta be a way to get green.


00:48:08.660 --> 00:48:12.420
'Cause I had used G event and eventlet a lot.


00:48:12.420 --> 00:48:14.260
And I'm like, okay, I know Python can do this.


00:48:14.260 --> 00:48:17.140
I know it can context switch without using a way.


00:48:17.140 --> 00:48:18.620
I know it can do it.


00:48:18.620 --> 00:48:20.580
I just had to go in greenlet and read the docs.


00:48:20.580 --> 00:48:21.420
And I did that.


00:48:21.420 --> 00:48:22.420
- Yeah, that's really cool.


00:48:22.420 --> 00:48:25.040
I'm super excited to see this because it opens up


00:48:25.040 --> 00:48:28.140
using SQLAlchemy with some of the other frameworks


00:48:28.140 --> 00:48:29.140
that really leverage it.


00:48:29.140 --> 00:48:30.580
For example, FastAPI,


00:48:30.580 --> 00:48:33.060
but there's plenty of others as well, right?


00:48:33.060 --> 00:48:39.780
Yeah. Another cool thing about async.io was that when I did the SQL HTML 1.4,


00:48:39.780 --> 00:48:43.400
which introduces this new query ORM interface, but keeps the old one,


00:48:43.400 --> 00:48:48.280
which is not going to go away because there's just too much code in the old query interface.


00:48:48.280 --> 00:48:50.980
But for async.io, it's totally brand new Greenfield development.


00:48:50.980 --> 00:48:53.720
So I said, with async.io, you've got to use our new API.


00:48:53.720 --> 00:48:59.600
That automatically got a lot of people to be testing the new way of working and got us to get people...


00:48:59.600 --> 00:49:02.200
Because one thing that makes libraries really good


00:49:02.200 --> 00:49:03.900
is when a lot of people use them


00:49:03.900 --> 00:49:07.200
and find problems with them and add use cases


00:49:07.200 --> 00:49:09.160
and the library becomes a chore.


00:49:09.160 --> 00:49:11.800
So the async I/O thing has been enormously helpful


00:49:11.800 --> 00:49:13.840
to bring a lot of people to SQLAlchemy


00:49:13.840 --> 00:49:15.160
who would not have been there.


00:49:15.160 --> 00:49:16.360
A lot of people who were probably


00:49:16.360 --> 00:49:17.880
gonna leave SQLAlchemy stayed.


00:49:17.880 --> 00:49:19.680
And people using the 2.0 thing--


00:49:19.680 --> 00:49:22.160
- SQL model probably wouldn't have been based on SQLAlchemy.


00:49:22.160 --> 00:49:23.000
- Not at all.


00:49:23.000 --> 00:49:25.640
Yeah, exactly.


00:49:25.640 --> 00:49:28.520
- Because obviously, Sebastian needs that


00:49:28.520 --> 00:49:31.720
to integrate with FastAPI and async is a core element there.


00:49:31.720 --> 00:49:34.600
Our audience, Daniel says,


00:49:34.600 --> 00:49:38.040
"I wonder if other drivers are moving to expose native async interfaces themselves.


00:49:38.040 --> 00:49:40.040
Time to go back to DbSig."


00:49:40.040 --> 00:49:42.280
Yeah, that's the database special interest group.


00:49:42.280 --> 00:49:44.280
Yeah.


00:49:44.280 --> 00:49:46.760
Sure, Daniel can go there.


00:49:46.760 --> 00:49:53.320
I've not had much success when I go to the SIG to suggest things.


00:49:53.320 --> 00:49:57.000
Yeah. Let me talk about this async API a little bit for folks


00:49:57.000 --> 00:50:01.240
who are probably familiar with the SQL alchemies traditional API,


00:50:01.240 --> 00:50:05.240
because there's a couple of things that stand out to me here.


00:50:05.240 --> 00:50:08.840
One is, let's start simple here.


00:50:08.840 --> 00:50:14.400
One is you have this concept of creating a select statement


00:50:14.400 --> 00:50:17.120
and then executing the statement as opposed to like,


00:50:17.120 --> 00:50:20.960
a query of a dot filter.


00:50:20.960 --> 00:50:24.680
So there's this sort of this statement model


00:50:25.240 --> 00:50:28.040
that you build up. You want to speak about that?


00:50:28.040 --> 00:50:31.160
The original, the SQLAlchemy with query


00:50:31.160 --> 00:50:34.760
really is 95% the same statement model.


00:50:34.760 --> 00:50:38.200
It's just the statement has the fetcher, the getter,


00:50:38.200 --> 00:50:40.200
the result fetching method stuck on it.


00:50:40.200 --> 00:50:42.200
Yeah.


00:50:42.200 --> 00:50:46.920
And, you know, when query came out, that was kind of a historical thing.


00:50:46.920 --> 00:50:50.680
The original idea of SQLAlchemy was that there was only going to be the select object


00:50:50.680 --> 00:50:55.080
and then you would use select object with the session to get results.


00:50:55.080 --> 00:50:58.880
And then it wasn't really done very well,


00:50:58.880 --> 00:50:59.840
and it wasn't very flexible.


00:50:59.840 --> 00:51:02.040
So people were coming to me with,


00:51:02.040 --> 00:51:04.760
well, why don't we use generative builder thing?


00:51:04.760 --> 00:51:05.960
And that's kind of what happened,


00:51:05.960 --> 00:51:06.960
'cause I wasn't really,


00:51:06.960 --> 00:51:09.560
I was a little bit rudderless in those days.


00:51:09.560 --> 00:51:12.640
So we had query, and it took me quite a long time


00:51:12.640 --> 00:51:15.280
to realize, wait a second, query is basically,


00:51:15.280 --> 00:51:16.600
once query got much more fancy,


00:51:16.600 --> 00:51:17.600
it started out as very simplistic,


00:51:17.600 --> 00:51:20.500
I only keep query for one object, and do this and that.


00:51:20.500 --> 00:51:22.720
As I had to keep adding to it,


00:51:22.720 --> 00:51:25.000
it became clear that I was rebuilding select.


00:51:25.000 --> 00:51:26.560
that they met in the middle.


00:51:26.560 --> 00:51:28.120
- Yeah, that like, I'm just rebuilding select


00:51:28.120 --> 00:51:31.480
in exactly the same, but slightly different way.


00:51:31.480 --> 00:51:33.860
And that bothered me for years.


00:51:33.860 --> 00:51:36.140
So with 2.0, I finally took that on


00:51:36.140 --> 00:51:41.020
and did a really, really long, difficult refactoring


00:51:41.020 --> 00:51:44.800
to take all of the guts of ORM query


00:51:44.800 --> 00:51:47.840
and put it into a different module called context


00:51:47.840 --> 00:51:49.160
that you don't deal with.


00:51:49.160 --> 00:51:52.980
And when you get the select object you see there,


00:51:52.980 --> 00:51:56.020
that indicates the exact same intent


00:51:56.020 --> 00:51:59.180
as query a options filter.


00:51:59.180 --> 00:52:01.260
And they both go to the same backend


00:52:01.260 --> 00:52:04.520
that does all the ORM, figure it out stuff


00:52:04.520 --> 00:52:06.120
that's a little more elaborate


00:52:06.120 --> 00:52:09.500
to come up with the SQL that will be sent to the database.


00:52:09.500 --> 00:52:10.340
- Yeah.


00:52:10.340 --> 00:52:11.820
- One of the biggest refactoring I've ever done


00:52:11.820 --> 00:52:13.260
and it was quite stressful


00:52:13.260 --> 00:52:14.680
when it seemed like I was hitting dead ends


00:52:14.680 --> 00:52:16.260
is oh, this is not gonna work.


00:52:16.260 --> 00:52:18.140
- Yeah, I can imagine.


00:52:18.140 --> 00:52:18.980
- Yeah.


00:52:18.980 --> 00:52:20.940
- This is cool.


00:52:20.940 --> 00:52:27.780
So basically the query of class dot, that style is going away, right?


00:52:27.780 --> 00:52:31.380
It's never going to go away because there's so much code in that style that it's basically


00:52:31.380 --> 00:52:34.860
not when you go to the website, it's not going to be in the tutorial, it's going to, it'll


00:52:34.860 --> 00:52:36.580
be in reference docs.


00:52:36.580 --> 00:52:37.980
So people that deal with that code can deal with it.


00:52:37.980 --> 00:52:42.260
It'd be in some sort of middle ground where it's not fully deprecated, but it's not promoted


00:52:42.260 --> 00:52:43.260
either.


00:52:43.260 --> 00:52:44.380
It's just called, it's called legacy.


00:52:44.380 --> 00:52:47.220
We've had different systems that stay in legacy for many years.


00:52:47.220 --> 00:52:48.220
Sure.


00:52:48.220 --> 00:52:49.220
Makes sense.


00:52:49.220 --> 00:52:50.220
And where are you?


00:52:50.220 --> 00:52:51.700
in that way, I totally agree.


00:52:51.700 --> 00:52:53.700
- Yeah, I probably would never take it out.


00:52:53.700 --> 00:52:55.500
But what I did do is when I do that,


00:52:55.500 --> 00:52:58.340
I try to make that code written such that


00:52:58.340 --> 00:53:00.100
it's all by itself.


00:53:00.100 --> 00:53:01.500
And it basically, what query does now


00:53:01.500 --> 00:53:03.900
is it makes that select inside.


00:53:03.900 --> 00:53:04.720
It sends it off.


00:53:04.720 --> 00:53:06.940
So it's what you call eating your own dog food.


00:53:06.940 --> 00:53:10.740
It means that the alternate API


00:53:10.740 --> 00:53:12.580
uses the real API internally,


00:53:12.580 --> 00:53:14.100
so you're testing it either way.


00:53:14.100 --> 00:53:15.640
- Right, going back to our patterns talk,


00:53:15.640 --> 00:53:19.060
it's like an adapter for the select pattern.


00:53:19.060 --> 00:53:21.700
- Yeah, okay, API. - Yeah.


00:53:21.700 --> 00:53:23.500
- Two other things that stand out here.


00:53:23.500 --> 00:53:26.540
One is you create a session maker traditionally


00:53:26.540 --> 00:53:28.780
and you create a session by calling it.


00:53:28.780 --> 00:53:31.420
Here you have an async session maker, right?


00:53:31.420 --> 00:53:32.860
To create them. - Yep.


00:53:32.860 --> 00:53:34.940
- That's one of the differences.


00:53:34.940 --> 00:53:35.860
That's not super different,


00:53:35.860 --> 00:53:37.700
but the other one that is interesting to me


00:53:37.700 --> 00:53:41.860
is now these things are context managers.


00:53:41.860 --> 00:53:42.680
- Yeah.


00:53:42.680 --> 00:53:45.020
- When I used to work with SQLAlchemy,


00:53:45.020 --> 00:53:46.220
traditional ones,


00:53:46.220 --> 00:53:49.160
I would create a class called a session context


00:53:49.160 --> 00:53:52.280
just so I could do this in a with statement.


00:53:52.280 --> 00:53:54.080
And here, obviously, it's an async with statement,


00:53:54.080 --> 00:53:56.280
but that's just the async aspect of it.


00:53:56.280 --> 00:53:57.600
- It's in the sync aspect too.


00:53:57.600 --> 00:54:00.880
I should mention that when SQLAlchemy,


00:54:00.880 --> 00:54:03.280
in 2006, we were in Python 2.3,


00:54:03.280 --> 00:54:05.360
there were not context managers.


00:54:05.360 --> 00:54:07.440
They didn't come out until Python 2.5.


00:54:07.440 --> 00:54:08.680
- Right, so you can't integrate with them


00:54:08.680 --> 00:54:09.840
if they don't exist in your API.


00:54:09.840 --> 00:54:12.360
- So I didn't, so nothing was based on that.


00:54:12.360 --> 00:54:18.220
So SQLAlchemy 1.4 and 2.0, as much as possible,


00:54:18.220 --> 00:54:21.100
completely support the Context Manager model.


00:54:21.100 --> 00:54:24.800
And the docs and the tutorials, if you look at the new 1.4 tutorial


00:54:24.800 --> 00:54:27.700
that's on the site, it's all about Context Managers,


00:54:27.700 --> 00:54:32.200
and all the try, except writing your own thing should go away.


00:54:32.200 --> 00:54:34.200
You should use Context Managers now.


00:54:34.200 --> 00:54:36.200
And what you see there with the Async pattern,


00:54:36.200 --> 00:54:39.200
I've made it so that if you're using all the new APIs,


00:54:39.200 --> 00:54:42.800
the context manager pattern with the engine and connection in core


00:54:42.800 --> 00:54:47.200
is mirrored to the context manager pattern with the session


00:54:47.200 --> 00:54:48.640
and the session maker.


00:54:48.640 --> 00:54:51.520
And then it's also mirrored in the async I/O API.


00:54:51.520 --> 00:54:52.640
So there's four different APIs.


00:54:52.640 --> 00:54:55.320
There's core and ORM, sync and async.


00:54:55.320 --> 00:54:58.080
And they all should have, as much as they can,


00:54:58.080 --> 00:55:01.840
the same-- see the hands, this means code.


00:55:01.840 --> 00:55:04.400
They have the same--


00:55:04.400 --> 00:55:08.120
as much as possible, they should have the same context manager patterns.


00:55:08.120 --> 00:55:11.380
And we want you to use context managers for everything now,


00:55:11.380 --> 00:55:13.260
for any kind of blocking of...


00:55:13.260 --> 00:55:16.300
And that's also how we can improve the transactional model


00:55:16.300 --> 00:55:19.420
so that you're really working the transaction all the time with the core


00:55:19.420 --> 00:55:22.560
because it's not a burden because you have context managers.


00:55:22.560 --> 00:55:26.720
Yeah, so one of the things I see, I want to ask you about two bits of code


00:55:26.720 --> 00:55:29.180
and then take another question from the audience.


00:55:29.180 --> 00:55:32.720
So you have a with session.begin,


00:55:32.720 --> 00:55:35.020
and you do some inserts,


00:55:35.020 --> 00:55:37.180
and then you don't say session.commit.


00:55:37.180 --> 00:55:41.260
So the way this works, I'm presuming, tell me if I'm understanding this right,


00:55:41.260 --> 00:55:44.940
if it makes it through the with block without an error, it commits.


00:55:44.940 --> 00:55:47.180
If it makes it through the with block with an exception,


00:55:47.180 --> 00:55:50.300
it just doesn't commit and effectively rolls it back.


00:55:50.300 --> 00:55:51.900
It doesn't roll back. Yeah.


00:55:51.900 --> 00:55:52.700
Beautiful.


00:55:52.700 --> 00:55:57.260
That's correct. And we've had the begin content manager for a long time.


00:55:57.260 --> 00:56:00.540
It's just it wasn't totally consistent everywhere.


00:56:00.540 --> 00:56:02.380
But we've had that for a long time.


00:56:03.260 --> 00:56:06.800
And yeah, but now I've made sure that all the opening


00:56:06.800 --> 00:56:09.900
and closing of resource and the begin commit of resource


00:56:09.900 --> 00:56:13.220
are consistent and also there's always a way


00:56:13.220 --> 00:56:16.560
that you can open the resource and begin commit


00:56:16.560 --> 00:56:18.080
in one line of code also.


00:56:18.080 --> 00:56:20.660
The session maker has a begin on it now.


00:56:20.660 --> 00:56:22.840
You can do that.


00:56:22.840 --> 00:56:23.680
Yeah.


00:56:23.680 --> 00:56:26.440
- The other thing I'm super familiar with execute.


00:56:26.440 --> 00:56:27.280
- Yep.


00:56:27.280 --> 00:56:30.200
- But then you also have stream, which looks real similar.


00:56:30.200 --> 00:56:31.600
What's the difference there?


00:56:31.600 --> 00:56:34.380
Stream is async I/O only right now.


00:56:34.380 --> 00:56:38.020
Stream is because it's important in many cases


00:56:38.020 --> 00:56:42.100
to get a result that's doing async streaming.


00:56:42.100 --> 00:56:43.780
And when you're doing async streaming with async I/O,


00:56:43.780 --> 00:56:44.980
you've got to have the await keyword.


00:56:44.980 --> 00:56:47.460
So you can see the result object returned


00:56:47.460 --> 00:56:50.340
from session.stream is called an async result.


00:56:50.340 --> 00:56:54.740
And all of the methods have the async annotation on them


00:56:54.740 --> 00:56:58.420
so that you see it's async for A in result.scalars.


00:56:58.420 --> 00:56:59.260
- Oh, I see.


00:56:59.260 --> 00:57:00.460
So the things you interact with,


00:57:00.460 --> 00:57:03.580
the subsequent functions are themselves all async as well.


00:57:03.580 --> 00:57:06.940
- Yeah, and what that will do is that will try


00:57:06.940 --> 00:57:08.780
to use a server-side cursor.


00:57:08.780 --> 00:57:10.020
- Yeah, yeah, that's what I imagined.


00:57:10.020 --> 00:57:11.140
That's cool, yeah.


00:57:11.140 --> 00:57:12.860
Instead of trying to pull it all into memory,


00:57:12.860 --> 00:57:14.700
if you got a thousand rows back,


00:57:14.700 --> 00:57:16.900
you could start pulling them more generator.


00:57:16.900 --> 00:57:18.400
- Right, when you use a server-side cursor,


00:57:18.400 --> 00:57:20.140
you actually are genuinely not pulling everything


00:57:20.140 --> 00:57:21.900
into memory first.


00:57:21.900 --> 00:57:24.360
When you use the buffered result,


00:57:24.360 --> 00:57:26.060
you're getting everything into memory at once.


00:57:26.060 --> 00:57:27.860
Which is normally okay for smaller.


00:57:27.860 --> 00:57:29.500
- Yeah, most of the time it's fine.


00:57:29.500 --> 00:57:33.460
but if you want a whole bunch or you're flowing it on word.


00:57:33.460 --> 00:57:35.940
Yeah, anyway, a lot of cool stuff there.


00:57:35.940 --> 00:57:40.820
So I think we'll get short on time.


00:57:40.820 --> 00:57:42.460
Mr. Hypermagnetic out there asked,


00:57:42.460 --> 00:57:45.060
does CWOC support paginated results?


00:57:45.060 --> 00:57:48.700
That also leads us towards a little area I wanna focus on


00:57:48.700 --> 00:57:50.140
just a couple of things as well.


00:57:50.140 --> 00:57:52.620
So yeah, maybe address that first.


00:57:52.620 --> 00:57:55.220
- Paginated results is kind of one of those things


00:57:55.220 --> 00:57:57.900
that seems simple, but it's more of a quagmire


00:57:57.900 --> 00:57:59.940
than you might expect.


00:57:59.940 --> 00:58:02.740
There's different ways to do paginated results.


00:58:02.740 --> 00:58:06.220
The way we all did it years ago was we used these functions


00:58:06.220 --> 00:58:07.780
in SQL called limit and offset,


00:58:07.780 --> 00:58:11.420
where limit will give you like 10 rows at a time


00:58:11.420 --> 00:58:14.740
and offset will start your results set in the middle.


00:58:14.740 --> 00:58:16.060
Once we work with bigger database,


00:58:16.060 --> 00:58:18.260
we all realized that offset is terrible


00:58:18.260 --> 00:58:20.900
because offset will actually get the whole results set


00:58:20.900 --> 00:58:22.620
and scroll through it.


00:58:22.620 --> 00:58:24.220
It does it on the server side, but it's still very slow.


00:58:24.220 --> 00:58:25.500
So nowadays when you do pagination,


00:58:25.500 --> 00:58:26.820
you want to have some kind of approach


00:58:26.820 --> 00:58:34.220
where the query you're doing is looking at some data in the data,


00:58:34.220 --> 00:58:37.160
some row in the data, some column in the data you're querying.


00:58:37.160 --> 00:58:39.360
So like if you're paginating by date,


00:58:39.360 --> 00:58:42.860
page 10 would be where date is greater than this date


00:58:42.860 --> 00:58:45.260
that you know from the previous page you just got.


00:58:45.260 --> 00:58:46.460
That's one way.


00:58:46.460 --> 00:58:49.420
Another way is to write SQL query that do this thing called window functions


00:58:49.420 --> 00:58:53.760
where you can kind of figure out all the date or whatever thing ahead of time.


00:58:53.760 --> 00:59:02.400
Pagination implies, of that approach, implies that you have, actually of any approach, implies that you have an order by something.


00:59:02.400 --> 00:59:08.680
So it's hard to make pagination be like this, like this result here, result.scalars to say .paginate.


00:59:08.680 --> 00:59:18.080
That's not really, I mean, you can make a very crappy version that does that, but it's not really, it wouldn't really work that way.


00:59:18.080 --> 00:59:27.600
There is, I should say, there is a method in the result called partitions that will


00:59:27.600 --> 00:59:30.080
give you chunks of a result at a time.


00:59:30.080 --> 00:59:32.640
It's not quite the same as pagination because pagination is stateless.


00:59:32.640 --> 00:59:36.680
It's usually for web applications where you're going to get a certain page of a result and


00:59:36.680 --> 00:59:39.760
then show them a web page and then your whole SQL is over.


00:59:39.760 --> 00:59:42.920
And then you're going to come back to that SQL later.


00:59:42.920 --> 00:59:47.520
So we have features built in for partitioning of a single result set so that you get chunks


00:59:47.520 --> 00:59:49.580
for that time, which is helpful.


00:59:49.580 --> 00:59:51.860
Pagination is something you need to go and look.


00:59:51.860 --> 00:59:54.320
There's some, I think maybe SQL Utils


00:59:54.320 --> 00:59:57.440
probably has some helper functions for that.


00:59:57.440 --> 00:59:59.920
We have some recipes in that wiki page


00:59:59.920 --> 01:00:00.980
that I told you to leave.


01:00:00.980 --> 01:00:03.680
There's actually some recipes for pagination there.


01:00:03.680 --> 01:00:07.100
I don't think pagination is like a turnkey.


01:00:07.100 --> 01:00:08.480
It's gotta be kind of customized


01:00:08.480 --> 01:00:11.440
and people will write pagination frameworks


01:00:11.440 --> 01:00:15.600
and they're complicated and they're hard to do.


01:00:15.600 --> 01:00:19.980
So we leave those as an exercise for the community to do.


01:00:19.980 --> 01:00:21.320
But we do have some recipes for that.


01:00:21.320 --> 01:00:22.160
Yeah.


01:00:22.160 --> 01:00:22.980
- Yeah, thanks.


01:00:22.980 --> 01:00:23.820
That's a great answer.


01:00:23.820 --> 01:00:24.920
Okay, now for the last thing,


01:00:24.920 --> 01:00:28.360
I wanted to talk really quickly about this list


01:00:28.360 --> 01:00:31.200
from Dalia called Awesome SQLAlchemy.


01:00:31.200 --> 01:00:32.140
It's one of these awesome lists


01:00:32.140 --> 01:00:34.060
that covers all these SQLAlchemy things


01:00:34.060 --> 01:00:36.440
like data structures and types.


01:00:36.440 --> 01:00:38.240
And I'm just throwing this at you


01:00:38.240 --> 01:00:40.000
and neither of us have a ton of experience


01:00:40.000 --> 01:00:41.380
with a lot of these things,


01:00:41.380 --> 01:00:43.360
but I thought it'd be fun to just kind of go through them,


01:00:43.360 --> 01:00:48.360
some of the nice or interesting things that I've read across the air.


01:00:48.360 --> 01:00:50.860
So as a way to kind of wrap this up, like some extras, all right?


01:00:50.860 --> 01:00:56.260
So one of them is SQLAlchemy Continuum,


01:00:56.260 --> 01:00:59.560
a versioning extension for SQLAlchemy.


01:00:59.560 --> 01:01:00.560
Yeah.


01:01:00.560 --> 01:01:04.760
It's probably based on one of the recipes that we have


01:01:04.760 --> 01:01:09.160
in the source distribution, probably.


01:01:09.160 --> 01:01:12.660
Versioning, yeah, it says the first line of SQLAlchemy


01:01:12.660 --> 01:01:14.660
already has a versioning extension.


01:01:14.660 --> 01:01:16.580
The extension is very limited.


01:01:16.580 --> 01:01:17.420
That's correct.


01:01:17.420 --> 01:01:18.240
Everything he wrote there,


01:01:18.240 --> 01:01:19.740
everything they wrote there is correct.


01:01:19.740 --> 01:01:23.240
I had had some jobs in the banking industry


01:01:23.240 --> 01:01:24.080
where I was doing SQLAlchemy


01:01:24.080 --> 01:01:28.540
and we had some need to version rows and data.


01:01:28.540 --> 01:01:30.980
- I need to know exactly audit this


01:01:30.980 --> 01:01:32.180
and when has it changed and how do I go back.


01:01:32.180 --> 01:01:33.020
- Yeah, they need, yeah.


01:01:33.020 --> 01:01:33.860
- All that kind of stuff, right.


01:01:33.860 --> 01:01:35.380
- Yeah, there's different models.


01:01:35.380 --> 01:01:37.180
You can either take the rows as you get them


01:01:37.180 --> 01:01:38.860
and put them in an archive table,


01:01:38.860 --> 01:01:42.220
or you can do this thing where you never update


01:01:42.220 --> 01:01:44.320
or delete a row, you just insert a new row.


01:01:44.320 --> 01:01:47.220
And you've got kind of a temporal version scheme.


01:01:47.220 --> 01:01:49.580
I have some recipes to do that in the example section


01:01:49.580 --> 01:01:50.500
'cause I did them at a job.


01:01:50.500 --> 01:01:53.380
And I believe Continuum builds upon those


01:01:53.380 --> 01:01:56.980
to make a more robust, well-supported thing.


01:01:56.980 --> 01:01:58.980
I don't know, I've heard of Liquibase.


01:01:58.980 --> 01:02:00.980
I don't know.


01:02:00.980 --> 01:02:04.940
- Yeah, this is out of my world.


01:02:04.940 --> 01:02:07.260
I'm not a Java person either, sorry, but yeah.


01:02:07.260 --> 01:02:09.860
- Maybe, it might be like that, yeah.


01:02:09.860 --> 01:02:10.740
- All right, here's another one


01:02:10.740 --> 01:02:13.060
that I ran across from that SQLAlchemy awesome list


01:02:13.060 --> 01:02:15.800
is SQLAlchemy enum 3.4,


01:02:15.800 --> 01:02:17.580
I'm guessing because it came from Python 3.4.


01:02:17.580 --> 01:02:20.780
This package provides SQLAlchemy type to store


01:02:20.780 --> 01:02:24.100
as a standard enum.enums.


01:02:24.100 --> 01:02:25.780
'Cause a lot of times what happens is those things


01:02:25.780 --> 01:02:28.740
get turned into like numbers or other weird things.


01:02:28.740 --> 01:02:31.860
And here they get a little more type information, right?


01:02:31.860 --> 01:02:33.620
- Yeah, this might be absolutely,


01:02:33.620 --> 01:02:37.940
'cause we do support regular Python enums in our enum type.


01:02:37.940 --> 01:02:39.100
We didn't at first.


01:02:39.940 --> 01:02:41.820
- Yeah, this is looking like it's,


01:02:41.820 --> 01:02:43.500
well, seven months ago.


01:02:43.500 --> 01:02:45.020
- Well, you know, if someone's using this,


01:02:45.020 --> 01:02:47.580
they could stay, 'cause there are some enum features.


01:02:47.580 --> 01:02:52.120
I've been notified that we don't do exactly the way.


01:02:52.120 --> 01:02:53.780
There's some extra features that I forgot what they were,


01:02:53.780 --> 01:02:55.260
but there are some things that enums do


01:02:55.260 --> 01:02:56.220
that we don't support.


01:02:56.220 --> 01:02:57.060
So maybe this probably--


01:02:57.060 --> 01:02:58.500
- Maybe it adds that on, yeah.


01:02:58.500 --> 01:03:00.300
- Does that better, yeah.


01:03:00.300 --> 01:03:03.140
Enums are really a pain in the butt.


01:03:03.140 --> 01:03:04.140
The data types.


01:03:04.140 --> 01:03:05.740
- I know, I know.


01:03:05.740 --> 01:03:06.580
All right.


01:03:06.580 --> 01:03:09.180
- The Python side's good, but the database side is,


01:03:09.180 --> 01:03:11.380
Yeah, it's always some sort of hack.


01:03:11.380 --> 01:03:14.340
Alembic, I mean, that's pretty well known to people,


01:03:14.340 --> 01:03:16.420
but that's obviously important


01:03:16.420 --> 01:03:19.580
because you've got to keep your database and your models


01:03:19.580 --> 01:03:22.340
pretty closely in sync, right?


01:03:22.340 --> 01:03:24.300
- Yeah, so we maintain Alembic.


01:03:24.300 --> 01:03:27.780
I wrote Alembic years ago as SQLAlchemy Migrate


01:03:27.780 --> 01:03:32.340
was kind of not really holding up to what we were doing.


01:03:32.340 --> 01:03:36.060
SQLAlchemy Migrate is part of OpenStack now,


01:03:36.060 --> 01:03:38.220
and I actually have maintained that a little bit as well,


01:03:38.220 --> 01:03:41.580
but Alembic was meant to be more of a bare bones,


01:03:41.580 --> 01:03:46.020
straightforward, not too fancy tool.


01:03:46.020 --> 01:03:47.580
It has become fancier.


01:03:47.580 --> 01:03:51.460
And people that use it and get what it's about,


01:03:51.460 --> 01:03:52.480
like it a lot.


01:03:52.480 --> 01:03:57.460
It's never gonna be as cool as South for Django.


01:03:57.460 --> 01:04:00.700
I mean, maybe in Alembic 3, you know,


01:04:00.700 --> 01:04:03.340
but I don't, that could happen.


01:04:03.340 --> 01:04:07.020
It's not as automated as everybody would like.


01:04:07.020 --> 01:04:09.380
It has a system that it will look at your models,


01:04:09.380 --> 01:04:10.420
it'll look at the database


01:04:10.420 --> 01:04:14.220
and what we call auto-generate your migrations.


01:04:14.220 --> 01:04:16.940
But we don't guarantee those migrations


01:04:16.940 --> 01:04:18.260
are completely perfect.


01:04:18.260 --> 01:04:20.660
You've got to go and look at them and fix them.


01:04:20.660 --> 01:04:23.980
Which I still think it just did 95% of the typing for you,


01:04:23.980 --> 01:04:26.140
you know, of the work for you.


01:04:26.140 --> 01:04:27.980
That's what it was meant to do.


01:04:27.980 --> 01:04:28.820
- Yeah.


01:04:28.820 --> 01:04:29.660
- So I think it's very, very solid.


01:04:29.660 --> 01:04:31.780
- I think also it's helpful because it works in that realm


01:04:31.780 --> 01:04:34.420
of that's the area of SQL.


01:04:34.420 --> 01:04:36.820
I know less well, the DDL and that drop.


01:04:36.820 --> 01:04:41.820
How do I drop a table or a column and then re-add it under a different name without losing data?


01:04:41.820 --> 01:04:43.820
All that kind of stuff can be tricky.


01:04:43.820 --> 01:04:48.820
Yeah, and DDL is where a lot of the database vendor specific stuff is exposed.


01:04:48.820 --> 01:04:54.820
Like all these crazy keywords and data types and it's less declarative and more imperative.


01:04:54.820 --> 01:04:58.820
And so for Alembic, we just provide a model to create your migrations


01:04:58.820 --> 01:05:01.820
that has been working pretty well. It's got a lot of features now.


01:05:01.820 --> 01:05:06.820
But it's again a tool where if you don't know what DDL is,


01:05:06.820 --> 01:05:10.420
you're going to have a bad time with Alembic.


01:05:10.420 --> 01:05:14.500
You should learn what database migrations look like in the alter table,


01:05:14.500 --> 01:05:17.260
alter column and kind of know what that means.


01:05:17.260 --> 01:05:19.260
And then Alembic will be pretty smooth.


01:05:19.260 --> 01:05:20.620
And there actually are extensions for this.


01:05:20.620 --> 01:05:21.820
I saw it wasn't on that list.


01:05:21.820 --> 01:05:24.060
There's an extension called Alembic Utils,


01:05:24.060 --> 01:05:26.820
which are extensions for Alembic for Postgres


01:05:26.820 --> 01:05:30.020
that also build upon some recipes that are in these docs here.


01:05:30.020 --> 01:05:32.580
and I recommend looking at that too.


01:05:32.580 --> 01:05:33.420
- Cool.


01:05:33.420 --> 01:05:35.540
All right, there's a couple we can go quick on.


01:05:35.540 --> 01:05:39.380
There's one for talking to Amazon Redshift as a provider.


01:05:39.380 --> 01:05:40.900
That's pretty cool.


01:05:40.900 --> 01:05:41.740
- Yeah.


01:05:41.740 --> 01:05:43.940
- There's FormAlchemy, which--


01:05:43.940 --> 01:05:44.860
- Is it still maintained?


01:05:44.860 --> 01:05:46.220
This is an old one.


01:05:46.220 --> 01:05:48.900
FormAlchemy is, you see, 12 years ago.


01:05:48.900 --> 01:05:49.740
- Oh yeah.


01:05:49.740 --> 01:05:50.700
- It's old.


01:05:50.700 --> 01:05:51.740
- It's old, maybe it still works,


01:05:51.740 --> 01:05:52.580
but let's leave that one alone.


01:05:52.580 --> 01:05:53.580
- It probably still works.


01:05:53.580 --> 01:05:54.420
It looks--


01:05:54.420 --> 01:05:55.260
- Yeah, probably.


01:05:55.260 --> 01:05:56.080
- Yeah.


01:05:56.080 --> 01:05:56.920
- HTML hasn't changed since then,


01:05:56.920 --> 01:05:58.500
just style some CSS on it.


01:05:58.500 --> 01:06:00.620
All right, GeoAlchemy is pretty popular


01:06:00.620 --> 01:06:03.220
for people doing geospatial work.


01:06:03.220 --> 01:06:06.740
- Yep, so there's GeoAlchemy and there's GeoAlchemy 2.


01:06:06.740 --> 01:06:08.500
I'm not sure of the relationship,


01:06:08.500 --> 01:06:10.840
which one is which, who works on which one.


01:06:10.840 --> 01:06:15.020
GeoAlchemy seems like it might have,


01:06:15.020 --> 01:06:16.700
it might not, I'm not sure how much it's maintained.


01:06:16.700 --> 01:06:17.740
I think it's maintained.


01:06:17.740 --> 01:06:20.720
I would like it to be much more well-maintained.


01:06:20.720 --> 01:06:25.140
I think it supports, it's pretty Postgres-centric,


01:06:25.140 --> 01:06:27.980
but there are Geo things for SQL Server and Oracle


01:06:27.980 --> 01:06:32.380
and my SQL, I would like to see that stuff supported as well.


01:06:32.380 --> 01:06:35.860
GUAlchemy, I don't hear much about it,


01:06:35.860 --> 01:06:39.460
but I think it's a good project.


01:06:39.460 --> 01:06:40.400
- Yeah, cool.


01:06:40.400 --> 01:06:42.500
One for some growth, perhaps.


01:06:42.500 --> 01:06:43.340
- Yeah.


01:06:43.340 --> 01:06:47.180
- SQLTAP, a SQL profiling and introspection


01:06:47.180 --> 01:06:49.220
for applications using SQLAlchemy.


01:06:49.220 --> 01:06:51.500
- Wow, cool. - Have you seen this?


01:06:51.500 --> 01:06:52.940
- Probably not.


01:06:52.940 --> 01:06:54.820
- I have not seen this either.


01:06:54.820 --> 01:06:58.300
- So when you do a request, I think what it's doing,


01:06:58.300 --> 01:07:01.020
it stores what the page did.


01:07:01.020 --> 01:07:02.860
So it says here, there's 12 queries.


01:07:02.860 --> 01:07:05.460
It would spend like 20 milliseconds.


01:07:05.460 --> 01:07:07.900
And then you click on each one and it'll show you


01:07:07.900 --> 01:07:11.140
the select statements and like the actual SQL.


01:07:11.140 --> 01:07:13.820
- So it's probably profiling from the client side.


01:07:13.820 --> 01:07:15.300
- Yeah, yeah, yeah, yeah, I think so.


01:07:15.300 --> 01:07:16.180
Yeah, I think so.


01:07:16.180 --> 01:07:17.020
- That's nice.


01:07:17.020 --> 01:07:18.300
That's yeah, 'cause you can, if you're just timing it,


01:07:18.300 --> 01:07:19.540
yeah, that's cool.


01:07:19.540 --> 01:07:22.000
I wonder if it does things like explain.


01:07:22.000 --> 01:07:24.340
- Yeah, I don't totally know,


01:07:24.340 --> 01:07:26.960
but it looks like it has a whiskey integration,


01:07:26.960 --> 01:07:27.800
which is cool.


01:07:27.800 --> 01:07:28.760
- Yep, cool.


01:07:28.760 --> 01:07:31.480
- This is another one related sort of that helps.


01:07:31.480 --> 01:07:33.440
It's called N plus one.


01:07:33.440 --> 01:07:34.440
- Oh yeah.


01:07:34.440 --> 01:07:35.600
- Your N plus one.


01:07:35.600 --> 01:07:36.500
- That's cool.


01:07:36.500 --> 01:07:39.840
- Yeah, is a problem that many ORMs run into


01:07:39.840 --> 01:07:42.280
when people don't realize they're doing lazy loading


01:07:42.280 --> 01:07:43.440
and they don't do a join.


01:07:43.440 --> 01:07:45.600
And it can be super indirect.


01:07:45.600 --> 01:07:47.680
Like here, I got a query of a list


01:07:47.680 --> 01:07:49.840
and I sent the list off to the HTML template


01:07:49.840 --> 01:07:51.560
and the HTML template did a loop


01:07:51.560 --> 01:07:53.720
and talked about some property on the thing.


01:07:53.720 --> 01:07:55.880
and then there's more, a bunch of more database queries


01:07:55.880 --> 01:07:57.760
or something crazy, right?


01:07:57.760 --> 01:07:59.960
- Yeah, interesting that it seems to work


01:07:59.960 --> 01:08:01.720
for multiple lower ends.


01:08:01.720 --> 01:08:03.800
- Yeah, SQLAlchemy, Pui, Django.


01:08:03.800 --> 01:08:07.460
- It's streaming, maybe just taps into the APIs


01:08:07.460 --> 01:08:08.640
of all those different tools.


01:08:08.640 --> 01:08:11.040
- Yeah, probably someone's added a layer for each.


01:08:11.040 --> 01:08:12.120
- Yeah, I guess you could do it


01:08:12.120 --> 01:08:15.200
in a kind of a distant way, heuristically.


01:08:15.200 --> 01:08:17.640
If you want to see the same query


01:08:17.640 --> 01:08:19.520
to the same table over and over again,


01:08:19.520 --> 01:08:21.360
maybe that's what it's looking for.


01:08:21.360 --> 01:08:22.200
- Yeah.


01:08:22.200 --> 01:08:23.020
- Where I could do that


01:08:23.020 --> 01:08:26.020
looking at SQL saying lazy logo called.


01:08:26.020 --> 01:08:27.900
If you just look at the SQL, there's probably ways to do it,


01:08:27.900 --> 01:08:31.320
but that's kind of an intricate problem.


01:08:31.320 --> 01:08:33.060
But that seems like a really useful tool if it works.


01:08:33.060 --> 01:08:34.140
- Yeah, yeah, it does.


01:08:34.140 --> 01:08:36.860
And also I saw in there, we'll just close out with this.


01:08:36.860 --> 01:08:41.300
I saw in there they mentioned the Pyramid debug toolbar,


01:08:41.300 --> 01:08:43.900
the Flask debug toolbar, and the Django debug toolbar.


01:08:43.900 --> 01:08:45.620
And I can't speak to Django.


01:08:45.620 --> 01:08:46.940
I don't think I've even run the Flask one,


01:08:46.940 --> 01:08:49.640
but the Pyramid one has a, like you can open it up


01:08:49.640 --> 01:08:52.840
and say what were the SQLAlchemy queries of this page?


01:08:52.840 --> 01:08:54.800
and actually see how many queries.


01:08:54.800 --> 01:08:56.360
If you're on a page and it says,


01:08:56.360 --> 01:08:57.900
look, there's 51 queries,


01:08:57.900 --> 01:08:58.940
you're like, I thought I did one,


01:08:58.940 --> 01:08:59.780
what just happened?


01:08:59.780 --> 01:09:00.620
How'd I get 51?


01:09:00.620 --> 01:09:02.920
I'm like, well, you got 50 elements


01:09:02.920 --> 01:09:03.760
in an in-plus line.


01:09:03.760 --> 01:09:05.600
- Yeah, the debug tool,


01:09:05.600 --> 01:09:06.440
I haven't really worked with it,


01:09:06.440 --> 01:09:08.520
but yeah, we have a lot of people


01:09:08.520 --> 01:09:11.880
dealing with it or we have to fix issues with it.


01:09:11.880 --> 01:09:14.440
I don't actually write any web applications anymore.


01:09:14.440 --> 01:09:15.280
I just do this.


01:09:15.280 --> 01:09:17.880
So I don't get to see that stuff.


01:09:17.880 --> 01:09:18.760
- Awesome.


01:09:18.760 --> 01:09:19.600
Now, really cool.


01:09:19.600 --> 01:09:21.200
I also don't use them very much anymore either.


01:09:21.200 --> 01:09:24.440
I don't need that support as much as I did in the early days,


01:09:24.440 --> 01:09:26.440
but I do remember them being quite valuable.


01:09:26.440 --> 01:09:27.280
- Yeah.


01:09:27.280 --> 01:09:28.560
- All right, Mike.


01:09:28.560 --> 01:09:30.600
Well, there's more stuff we can go into,


01:09:30.600 --> 01:09:33.480
but what a cool conversation.


01:09:33.480 --> 01:09:36.320
And thank you so much for releasing the 2.0 stuff,


01:09:36.320 --> 01:09:37.600
for adding the async support.


01:09:37.600 --> 01:09:40.180
It really opens up a lot more use cases.


01:09:40.180 --> 01:09:41.100
- Yeah.


01:09:41.100 --> 01:09:42.880
- I think that are going to be interesting for people.


01:09:42.880 --> 01:09:45.080
So, man, it's fantastic.


01:09:45.080 --> 01:09:45.920
- Yeah, my pleasure.


01:09:45.920 --> 01:09:47.360
The async worked out really well.


01:09:47.360 --> 01:09:48.280
I'm really happy about that.


01:09:48.280 --> 01:09:49.120
- Yeah, great.


01:09:49.120 --> 01:09:49.940
Now, before you get out of here,


01:09:49.940 --> 01:09:51.380
Let me ask you the final two questions.


01:09:51.380 --> 01:09:53.140
You kind of alluded to this already.


01:09:53.140 --> 01:09:54.000
If you're gonna write some code,


01:09:54.000 --> 01:09:56.580
what Python editor do you use?


01:09:56.580 --> 01:09:59.300
- I'm on VS Code right now.


01:09:59.300 --> 01:10:01.960
I was on Sublime for a long time.


01:10:01.960 --> 01:10:03.740
Years ago I used TextMate.


01:10:03.740 --> 01:10:07.380
I do use VI and Vim a lot,


01:10:07.380 --> 01:10:08.980
but if I have like lots of windows open,


01:10:08.980 --> 01:10:10.600
it's gonna, right now it's VS Code.


01:10:10.600 --> 01:10:12.100
- Yeah, fantastic.


01:10:12.100 --> 01:10:16.140
Then notable PyPI package, anything come to mind?


01:10:16.140 --> 01:10:18.140
I mean, we kind of threw out a whole bunch, probably.


01:10:18.140 --> 01:10:19.260
- Did I put anything?


01:10:19.260 --> 01:10:21.260
- No. - Click to the item pointing down.


01:10:21.260 --> 01:10:23.260
(laughing)


01:10:23.260 --> 01:10:26.060
- I'll put your favorite in the list that I threw up there for you.


01:10:26.060 --> 01:10:27.760
Tell me like, the awesome ones.


01:10:27.760 --> 01:10:29.760
Which one stood out the most to you?


01:10:29.760 --> 01:10:31.760
- Oh, that N+1 thing looks really interesting.


01:10:31.760 --> 01:10:34.560
- All right, awesome. So N+1 with the plus spelled out.


01:10:34.560 --> 01:10:36.560
And the one also spelled out. - Yeah.


01:10:36.560 --> 01:10:38.560
- Yeah, very good.


01:10:38.560 --> 01:10:40.560
All right, well, final call to action.


01:10:40.560 --> 01:10:43.060
People have a bunch of SQLAlchemy code that they've written,


01:10:43.060 --> 01:10:45.060
but it's probably for the older style.


01:10:45.060 --> 01:10:47.060
It's probably not async and so on. What do you tell them?


01:10:47.060 --> 01:10:51.660
We have a brand new tutorial on the current website.


01:10:51.660 --> 01:10:57.660
If you go to docs.sqlacademy.org, on the left side, it'll have this 1.4/2.0 tutorial


01:10:57.660 --> 01:11:04.860
that kind of represents SQLAlchemy all over again, using all the newest concepts.


01:11:04.860 --> 01:11:10.460
I would look at that and just get to know it and also point out problems.


01:11:10.460 --> 01:11:14.460
Yeah, this is a new tutorial, so this supersedes the old tutorials.


01:11:14.460 --> 01:11:17.140
and it's going to talk about Core and ORM at the same time.


01:11:17.140 --> 01:11:22.620
So this is a complete brand new rewrite from the ground up.


01:11:22.620 --> 01:11:24.540
It took many weeks to do it.


01:11:24.540 --> 01:11:26.540
And then there's also the migration guide.


01:11:26.540 --> 01:11:28.940
But if you go through this tutorial,


01:11:28.940 --> 01:11:31.180
you really see what the new way of working is supposed to look like


01:11:31.180 --> 01:11:34.580
and what the idea is, what it's supposed to be.


01:11:34.580 --> 01:11:37.260
If you look at it, if you read the tutorial


01:11:37.260 --> 01:11:38.540
and assume you don't have any SQL Academy code,


01:11:38.540 --> 01:11:40.260
assume you're just learning it from scratch,


01:11:40.260 --> 01:11:42.300
you know, see what it's like, see, wow, wow, this is different.


01:11:42.300 --> 01:11:45.040
Or you might see, "Oh, I never knew that was like that."


01:11:45.040 --> 01:11:47.540
Because it really tries to represent the library


01:11:47.540 --> 01:11:51.940
from the first principles, so to speak,


01:11:51.940 --> 01:11:54.680
up to the ORM stuff.


01:11:54.680 --> 01:11:56.680
Yeah, fantastic.


01:11:56.680 --> 01:11:59.180
All right, well, I'm excited about all these new features,


01:11:59.180 --> 01:12:02.380
even the embracing of context managers everywhere.


01:12:02.380 --> 01:12:04.380
It looks great to me.


01:12:04.380 --> 01:12:06.380
Thanks for being here and thanks for sharing this with everyone.


01:12:06.380 --> 01:12:08.380
Yeah, my pleasure.


01:12:08.380 --> 01:12:10.380
You bet. Bye.

