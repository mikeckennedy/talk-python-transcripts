WEBVTT

00:00:00.001 --> 00:00:05.500
ORMs are one of the main tools to put first-class data access in the hands of non-SQL-loving

00:00:05.500 --> 00:00:06.020
developers.

00:00:06.020 --> 00:00:10.060
And even for those who do love SQL, making them way more productive.

00:00:10.060 --> 00:00:15.900
When you hear about ORMs in Python, we often hear about either SQLAlchemy or Django ORM.

00:00:15.900 --> 00:00:17.060
And we should, they're great.

00:00:17.060 --> 00:00:20.960
But there are newer ORMs that take better advantage of modern Python.

00:00:20.960 --> 00:00:23.500
On this episode, you'll meet Daniel Townsend.

00:00:23.500 --> 00:00:25.240
He's the creator of Piccolo ORM.

00:00:25.240 --> 00:00:29.740
A great ORM that is async first, but also has a synchronous API.

00:00:30.360 --> 00:00:33.600
It has a super clean query syntax, and it's easy to learn.

00:00:33.600 --> 00:00:39.500
This is Talk Python to Me, episode 328, recorded July 22nd, 2021.

00:00:39.500 --> 00:00:57.280
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the

00:00:57.280 --> 00:00:58.700
ecosystem, and the personalities.

00:00:59.120 --> 00:01:00.480
This is your host, Michael Kennedy.

00:01:00.480 --> 00:01:02.700
Follow me on Twitter, where I'm @mkennedy.

00:01:02.700 --> 00:01:06.440
And keep up with the show and listen to past episodes at talkpython.fm.

00:01:06.440 --> 00:01:09.480
And follow the show on Twitter via at Talk Python.

00:01:09.480 --> 00:01:15.000
This episode is brought to you by Linode, us over at Talk Python Training, and the transcripts

00:01:15.000 --> 00:01:16.620
are brought to you by Assembly AI.

00:01:16.620 --> 00:01:19.240
Please check out what we're all offering during our segments.

00:01:19.240 --> 00:01:20.640
It really helps support the show.

00:01:21.460 --> 00:01:25.680
Do you want to learn Python, but you can't bear to subscribe to yet another service?

00:01:25.680 --> 00:01:28.960
At Talk Python Training, we hate subscriptions too.

00:01:28.960 --> 00:01:33.480
That's why our course bundle gives you full access to the entire library of courses for

00:01:33.480 --> 00:01:34.500
one fair price.

00:01:34.500 --> 00:01:35.620
That's right.

00:01:35.920 --> 00:01:40.240
With the course bundle, you save 70% off the full price of our courses, and you own

00:01:40.240 --> 00:01:41.560
them all forever.

00:01:41.560 --> 00:01:46.260
That includes courses published at the time of the purchase, as well as courses released

00:01:46.260 --> 00:01:47.680
within about a year of the bundle.

00:01:47.680 --> 00:01:53.160
So stop subscribing and start learning at talkpython.fm/everything.

00:01:54.040 --> 00:01:55.620
Dan, welcome to Talk Python to Me.

00:01:55.620 --> 00:01:56.520
Yeah, thanks for having me.

00:01:56.520 --> 00:01:59.600
I'm a big fan of the show, so it's kind of like a little dream to be on the show.

00:01:59.600 --> 00:02:00.440
Oh, how nice.

00:02:00.440 --> 00:02:01.100
That means a lot.

00:02:01.100 --> 00:02:01.480
Thank you.

00:02:01.480 --> 00:02:06.300
It's great to have you here, and you've built some really neat software that I'm looking forward

00:02:06.300 --> 00:02:07.040
to diving into.

00:02:07.040 --> 00:02:12.220
It's interesting because we're going to talk about your ORM, but it's also, there's so many

00:02:12.220 --> 00:02:16.440
different areas at which now they're kind of past Python 2, and there's a lot of folks

00:02:16.440 --> 00:02:20.620
who are saying, you know what, we can really put Python 2 behind us, and let's just build

00:02:20.620 --> 00:02:21.220
for the future.

00:02:21.220 --> 00:02:23.320
That just opens up so many doors, right?

00:02:23.320 --> 00:02:25.020
Like, oh, well, type-ins, of course, type-ins.

00:02:25.020 --> 00:02:25.860
Why not type-ins?

00:02:25.860 --> 00:02:29.080
Well, Python 2 is why not type-ins, but not anymore, right?

00:02:29.080 --> 00:02:35.720
And async and all these other things, and just, it's really great to have these frameworks

00:02:35.720 --> 00:02:39.680
like yours coming along that just go, modern Python, what can we build now?

00:02:39.680 --> 00:02:40.580
Yeah, I totally agree.

00:02:40.580 --> 00:02:44.900
It felt like Python 3.6 kind of closed the door on the, should we still be using Python

00:02:44.900 --> 00:02:45.720
2 conversation?

00:02:45.720 --> 00:02:50.600
Because by that point, you had async, you had type annotations, data classes, I think

00:02:50.600 --> 00:02:52.180
were Python 3.7, enums.

00:02:52.600 --> 00:02:53.600
It just goes on and on.

00:02:53.600 --> 00:02:58.900
Like, it just felt like the Python community knocked out of the park, Python 3.6 and on.

00:02:58.900 --> 00:03:05.560
Yeah, I have a theory that is completely unsubstantiated, that actually a lot of the progress has to

00:03:05.560 --> 00:03:06.320
do with f-strings.

00:03:06.320 --> 00:03:09.120
So many people are like, ah, I just want to easily format this code.

00:03:09.120 --> 00:03:10.000
What do I need?

00:03:10.000 --> 00:03:11.000
I need Python 3.6.

00:03:11.000 --> 00:03:11.420
Fine.

00:03:11.420 --> 00:03:12.520
That's true, actually.

00:03:12.520 --> 00:03:13.800
We're going to switch.

00:03:13.800 --> 00:03:15.760
And it's such a minor feature.

00:03:15.760 --> 00:03:16.560
Still minor.

00:03:16.780 --> 00:03:18.680
The pain of going back would be horrible.

00:03:18.680 --> 00:03:20.880
I couldn't imagine using Python 2 now, actually.

00:03:20.880 --> 00:03:21.420
I know.

00:03:21.420 --> 00:03:21.800
Yeah.

00:03:21.800 --> 00:03:22.260
Same.

00:03:22.260 --> 00:03:24.100
Quick welcome to some folks on Livestream.

00:03:24.100 --> 00:03:24.580
Chris May.

00:03:24.580 --> 00:03:24.860
Hey.

00:03:24.860 --> 00:03:25.640
Happy to see you here.

00:03:25.640 --> 00:03:26.140
Paul Everett.

00:03:26.140 --> 00:03:27.340
So glad you can stop by.

00:03:27.340 --> 00:03:28.580
And Teddy as well.

00:03:28.580 --> 00:03:30.500
We'll get some questions in from you all, I'm sure.

00:03:30.500 --> 00:03:36.360
Now, before we get into Piccolo and all the cool stuff that I was alluding to there, let's

00:03:36.360 --> 00:03:37.320
just start with your story, Dan.

00:03:37.320 --> 00:03:38.640
How do you get into programming in Python?

00:03:38.840 --> 00:03:40.540
Yeah, so I've been programming for quite a long time now.

00:03:40.540 --> 00:03:44.400
I might look quite youthful on this camera, but that's just because my webcam's got a filter

00:03:44.400 --> 00:03:44.720
on it.

00:03:44.720 --> 00:03:46.260
But I've actually been through.

00:03:46.260 --> 00:03:47.820
The touch up my appearance is checked.

00:03:47.820 --> 00:03:48.220
Yeah.

00:03:48.220 --> 00:03:48.980
I've actually been.

00:03:48.980 --> 00:03:49.340
I'm just kidding.

00:03:49.340 --> 00:03:49.640
Yeah.

00:03:49.640 --> 00:03:52.240
Programming with Python for about 14 years.

00:03:52.240 --> 00:03:57.000
So Django was kind of one of my first frameworks and just really fell in love with it because

00:03:57.000 --> 00:04:01.460
in university I learned C. And then it's like, oh, this world of Python exists and it's

00:04:01.460 --> 00:04:05.500
a bit more easier than C. And so I've used it extensively since then.

00:04:05.800 --> 00:04:11.980
I've mostly been working for startups and design agencies and then really fell down the

00:04:11.980 --> 00:04:14.420
async rabbit hole over the last few years.

00:04:14.420 --> 00:04:20.060
So I really enjoy working with WebSockets and building kind of interactive front ends and

00:04:20.060 --> 00:04:25.040
also really kind of excited the way that Postgres continues to grow and have new features.

00:04:25.040 --> 00:04:27.160
They're the things that really excite me in the Python world.

00:04:27.160 --> 00:04:27.520
Yeah.

00:04:27.520 --> 00:04:32.020
Those things are super exciting and the web frameworks are coming along to embrace them.

00:04:32.020 --> 00:04:34.620
The language features, you know, async and await.

00:04:35.060 --> 00:04:40.720
We had asyncio in Python 3.4, but it didn't really gain a ton of adoption because there

00:04:40.720 --> 00:04:45.460
was, it sort of had this callback style of working, which is not the same as, you know,

00:04:45.460 --> 00:04:46.960
await a thing and just keep rocking.

00:04:46.960 --> 00:04:47.480
Totally agree.

00:04:47.480 --> 00:04:47.700
Yeah.

00:04:47.700 --> 00:04:51.560
So I think they pretty much took what Twisted had created and ported it over.

00:04:51.560 --> 00:04:55.520
And like I say, it's all callbacks and it was still better than, it was still good

00:04:55.520 --> 00:04:57.000
to have that option in the standard library.

00:04:57.000 --> 00:04:57.840
But I totally agree.

00:04:57.840 --> 00:05:02.240
Async await really kind of set it on fire because it was quite hard to approach asyncio at

00:05:02.240 --> 00:05:02.580
first.

00:05:02.860 --> 00:05:05.280
It was, you don't have to think about how you write code differently.

00:05:05.280 --> 00:05:08.960
You just put the awaits in the spots and then, you know, everything kind of flows.

00:05:08.960 --> 00:05:13.900
It's, I know it's not the same, but from how you think about structuring your code is real

00:05:13.900 --> 00:05:14.220
similar.

00:05:14.220 --> 00:05:14.600
Yeah.

00:05:14.600 --> 00:05:18.560
And I think the maturity is there now with the libraries and the standard library and it

00:05:18.560 --> 00:05:22.440
feels like you can just dive in and it feels a bit like a no brainer now to use async.

00:05:22.640 --> 00:05:22.840
Yeah.

00:05:22.840 --> 00:05:24.840
I think it is a no brainer for sure.

00:05:24.840 --> 00:05:31.220
So it's interesting that you got into Django in the early days because Django is the only

00:05:31.220 --> 00:05:34.340
major web framework that says, here's your ORM.

00:05:34.340 --> 00:05:35.680
Here's how you use it.

00:05:35.680 --> 00:05:38.260
As opposed to Flask that says, do what you want.

00:05:38.260 --> 00:05:40.060
Or Pyramid that says, do what you want.

00:05:40.060 --> 00:05:42.640
You know, you could use an ORM, but you don't have to.

00:05:42.640 --> 00:05:45.740
But Django is, it's part of the culture and the zen of it.

00:05:45.740 --> 00:05:45.940
Right?

00:05:46.060 --> 00:05:47.780
Yeah, I'm a big fan of Django.

00:05:47.780 --> 00:05:52.760
I think it's kind of a masterpiece because it stood the test of time so remarkably well

00:05:52.760 --> 00:05:58.100
and how you could have written a app 12 years ago and then in an afternoon, you could have

00:05:58.100 --> 00:05:59.360
upgraded it to the latest version.

00:05:59.360 --> 00:06:03.900
So there's a lot to be said for Django and I really like the tight integration.

00:06:03.900 --> 00:06:08.880
So people tend to prefer one or the other, the kind of the Flask route where you can make

00:06:08.880 --> 00:06:09.520
all of your choices.

00:06:09.520 --> 00:06:16.480
But I like really tightly integrated solutions where you come to a problem and then you pretty

00:06:16.480 --> 00:06:17.760
much know what to pick.

00:06:17.760 --> 00:06:18.200
Yeah.

00:06:18.200 --> 00:06:20.840
So that's definitely inspired Piccolo to some extent.

00:06:20.840 --> 00:06:21.200
Yeah.

00:06:21.200 --> 00:06:26.680
I love the diversity of technology and libraries and ways of doing things in the Python space.

00:06:26.680 --> 00:06:33.280
But when people come from other technologies, it's a challenge to go, well, here's 20 different

00:06:33.280 --> 00:06:35.520
ORMs you could use and seven different web frameworks.

00:06:35.520 --> 00:06:36.620
And they're like, I don't want seven.

00:06:36.620 --> 00:06:38.180
I want to know what I should be doing.

00:06:38.180 --> 00:06:39.300
What should I do?

00:06:39.300 --> 00:06:39.640
Right.

00:06:39.640 --> 00:06:41.220
And so it's a mixed bag.

00:06:41.220 --> 00:06:42.060
I really like that.

00:06:42.060 --> 00:06:45.280
But the thing is, if you come from the JavaScript world, then it's a relief because you've only

00:06:45.280 --> 00:06:46.640
got 20, not 2000.

00:06:46.640 --> 00:06:48.620
Oh my goodness.

00:06:48.620 --> 00:06:50.020
This one's seven months old.

00:06:50.020 --> 00:06:50.900
It's like ancient.

00:06:50.900 --> 00:06:51.980
Can we still use it?

00:06:51.980 --> 00:06:52.420
Yeah.

00:06:52.420 --> 00:06:53.200
Yeah.

00:06:53.200 --> 00:06:53.560
No, no.

00:06:53.560 --> 00:06:55.560
That's a whole different discussion.

00:06:55.560 --> 00:06:57.380
The JavaScript churn over there.

00:06:57.380 --> 00:06:57.700
Yeah.

00:06:57.700 --> 00:07:00.120
But yeah, let's focus in on what you built here.

00:07:00.120 --> 00:07:01.480
So let's talk about Piccolo.

00:07:01.480 --> 00:07:02.880
You just sell it.

00:07:02.880 --> 00:07:06.320
You describe it as a fast async ORM for Python.

00:07:06.320 --> 00:07:07.220
That's easy to learn.

00:07:07.220 --> 00:07:10.160
And I think it seems like it really hits on all those points.

00:07:10.160 --> 00:07:10.840
Tell us about it.

00:07:10.840 --> 00:07:11.340
Yes.

00:07:11.340 --> 00:07:13.620
So all those terms are like fairly aspirational.

00:07:13.620 --> 00:07:16.100
So the fast is because it's built on asyncpg.

00:07:16.100 --> 00:07:20.560
So this is a really fast Postgres adapter that the Magic Stack guys built.

00:07:20.560 --> 00:07:23.560
Part of the reason it's so fast is it's written in Syphon.

00:07:23.940 --> 00:07:24.760
So it's compiled.

00:07:24.760 --> 00:07:28.740
And then there's also a few other features in Piccolo, which kind of help it speed wise, like

00:07:28.740 --> 00:07:32.280
frozen queries where it doesn't have to generate the SQL each time.

00:07:32.280 --> 00:07:33.540
It kind of caches some of it.

00:07:33.540 --> 00:07:35.780
So that's kind of where the fast comes from.

00:07:35.780 --> 00:07:36.520
Async.

00:07:36.520 --> 00:07:37.100
Oh, nice.

00:07:37.100 --> 00:07:37.460
Async.

00:07:37.560 --> 00:07:38.300
Async.

00:07:38.300 --> 00:07:38.300
Async.

00:07:38.300 --> 00:07:38.560
Async.io.

00:07:38.560 --> 00:07:43.560
That was really one of the core reasons for building it is because I was a Django channels

00:07:43.560 --> 00:07:47.560
power user and I had to build a lot of chat applications in my day job.

00:07:47.560 --> 00:07:49.600
So for me, async was kind of essential.

00:07:49.600 --> 00:07:52.500
And then the easy to learn is called also aspirational.

00:07:52.660 --> 00:07:56.620
I put like as much effort as I possibly can into the documentation and stuff like that.

00:07:56.620 --> 00:07:59.380
But I'll let the readers be the judge of that.

00:07:59.380 --> 00:07:59.580
Yeah.

00:07:59.580 --> 00:08:00.680
That's in the eye of the beholder.

00:08:00.680 --> 00:08:00.980
Right.

00:08:00.980 --> 00:08:05.300
But at the same time, you have done a lot of things that I don't see others doing.

00:08:05.300 --> 00:08:06.740
Like the documentation is good.

00:08:06.740 --> 00:08:11.340
Obviously, that's pretty standard on a lot of the different frameworks, although they can

00:08:11.340 --> 00:08:12.400
be super intense.

00:08:12.400 --> 00:08:12.920
Right.

00:08:12.920 --> 00:08:13.940
Like I love SQLAlchemy.

00:08:13.940 --> 00:08:16.660
But when I go and read there, I'm like, OK, here's a 20 page doc.

00:08:16.660 --> 00:08:21.680
I better pay attention and turn off my music and just like not miss something on the other

00:08:21.680 --> 00:08:21.840
hand.

00:08:21.840 --> 00:08:24.520
But what you are doing that's pretty unique is you've got like a playground.

00:08:24.520 --> 00:08:26.540
You've got a playground for the admin backend.

00:08:26.540 --> 00:08:27.960
Oh, by the way, there's an admin backend.

00:08:27.960 --> 00:08:32.580
And you've got a playground for trying out queries and stuff like that.

00:08:32.580 --> 00:08:32.780
Right.

00:08:32.780 --> 00:08:33.640
That's pretty unique.

00:08:33.640 --> 00:08:33.940
Yeah.

00:08:33.940 --> 00:08:36.080
So I was really excited by the playground concept.

00:08:36.080 --> 00:08:38.500
So it's something I borrowed from the Swift world.

00:08:38.500 --> 00:08:43.340
And because Apple are trying to make Swift accessible to newcomers, they have this concept

00:08:43.340 --> 00:08:47.020
of a playground, which is basically a pre-populated chunk of code.

00:08:47.020 --> 00:08:50.580
And then you can just play around with it as kind of the name implies.

00:08:51.400 --> 00:08:53.480
So I use IPython to achieve it.

00:08:53.480 --> 00:08:57.620
So a lot of people know IPython, just running it on the command line like a terminal.

00:08:57.620 --> 00:09:00.640
But you can actually embed it within your Python code.

00:09:00.640 --> 00:09:04.940
So the way the playgrounds work is it creates a SQLite database.

00:09:04.940 --> 00:09:10.060
It loads an example schema, populates it with data, and then basically launches the IPython

00:09:10.060 --> 00:09:10.440
shell.

00:09:11.000 --> 00:09:13.340
So you basically have all of that set up.

00:09:13.340 --> 00:09:17.900
Because one of the problems with learning an ORM is the barrier is huge when you think

00:09:17.900 --> 00:09:18.800
about it for a newcomer.

00:09:18.800 --> 00:09:21.020
You have to set up a database.

00:09:21.020 --> 00:09:25.360
You have to understand schemas and migrations and running them and populating data.

00:09:26.080 --> 00:09:28.660
So I just wanted to say, look, I'm going to shortcut all of that.

00:09:28.660 --> 00:09:29.740
You install Piccolo.

00:09:29.740 --> 00:09:31.600
You do Piccolo Playground Run.

00:09:31.600 --> 00:09:33.100
And then you've got an example schema.

00:09:33.100 --> 00:09:35.040
And then you can actually follow along with the documentation.

00:09:35.040 --> 00:09:40.000
So whenever there's an example query in the Piccolo docs, you can actually run it in the

00:09:40.000 --> 00:09:40.280
playground.

00:09:40.280 --> 00:09:41.820
And you should see the results.

00:09:42.260 --> 00:09:43.760
So yeah, I was quite excited about that.

00:09:43.760 --> 00:09:44.440
I like it a lot.

00:09:44.440 --> 00:09:45.920
And you're right that it is challenging.

00:09:45.920 --> 00:09:49.860
You know, as we build up experience and we get used to it, it's like, oh, yeah, you just

00:09:49.860 --> 00:09:52.600
fire up the database server and then you connect to it.

00:09:52.600 --> 00:09:53.500
Then you do this thing.

00:09:53.500 --> 00:09:56.200
But how do you get the database server installed?

00:09:56.200 --> 00:09:57.360
What if you have the wrong version?

00:09:57.360 --> 00:09:58.800
What if it requires authentication?

00:09:58.800 --> 00:10:00.220
What if there's a firewall?

00:10:00.220 --> 00:10:03.800
Just like there's layers and layers of places where people get sheared off.

00:10:03.800 --> 00:10:05.020
Like, ah, this doesn't work for me.

00:10:05.020 --> 00:10:05.540
All right.

00:10:05.540 --> 00:10:07.440
And so keeping that simple, it's great.

00:10:07.440 --> 00:10:09.720
And I think I just want to give a shout out to SQLite.

00:10:10.080 --> 00:10:14.460
Because what you just said is such a good example of you're probably going to run this

00:10:14.460 --> 00:10:16.200
against Postgres or something like that.

00:10:16.200 --> 00:10:16.520
Yeah.

00:10:16.520 --> 00:10:18.800
But for the little example, you don't need that.

00:10:18.800 --> 00:10:19.840
You can just use SQLite.

00:10:19.840 --> 00:10:24.100
And it's so nice that that's a serverless in the sense that it's just embedded.

00:10:24.100 --> 00:10:26.920
Doesn't require a separate process to run or connect to.

00:10:26.920 --> 00:10:29.740
It's already comes with Python, generally speaking.

00:10:29.740 --> 00:10:30.680
It's really nice.

00:10:30.680 --> 00:10:31.520
Yeah, I totally agree.

00:10:31.520 --> 00:10:33.960
And that's the reason for SQLite support within Piccolo.

00:10:33.960 --> 00:10:35.720
Because as you said, no one's going to run it in production.

00:10:35.720 --> 00:10:39.940
But then it's just that frictionless setup, which is so great.

00:10:39.940 --> 00:10:43.480
Like, using SQLite asynchronously doesn't really make a lot of sense.

00:10:43.480 --> 00:10:46.040
Because you don't really have any network lag talking to the database.

00:10:46.040 --> 00:10:48.520
But it's great to have it in there for convenience.

00:10:48.520 --> 00:10:49.460
Yeah, it is.

00:10:49.460 --> 00:10:53.660
You know, I suspect there may be some people who run it in production in like an early, early

00:10:53.660 --> 00:10:54.660
prototype stage.

00:10:54.660 --> 00:10:55.280
Yeah.

00:10:55.280 --> 00:10:56.360
They just want to get something up.

00:10:56.360 --> 00:11:00.040
And here, let's just put it up on, you know, on some hosting place and just check it out

00:11:00.040 --> 00:11:00.400
real quick.

00:11:00.400 --> 00:11:01.600
And then we'll go from there.

00:11:01.760 --> 00:11:01.980
Yeah.

00:11:01.980 --> 00:11:05.200
One thing that's quite nice is I used to do this in the design agency.

00:11:05.200 --> 00:11:06.580
We'd use SQLite for the prototype.

00:11:06.580 --> 00:11:09.000
And then you could R-sync it down to your local machine.

00:11:09.000 --> 00:11:12.140
So you didn't have to do a database dump and reload it.

00:11:12.140 --> 00:11:13.600
You could literally just R-sync the file.

00:11:13.600 --> 00:11:14.500
Yeah.

00:11:14.500 --> 00:11:17.260
So there are a bunch of conveniences with SQLite for sure.

00:11:17.260 --> 00:11:17.520
Yeah.

00:11:17.520 --> 00:11:18.880
So it gets to be too much data.

00:11:18.880 --> 00:11:24.060
Or really, you want sort of too much concurrency or multi-machines scale out and all that sort

00:11:24.060 --> 00:11:24.260
of stuff.

00:11:24.260 --> 00:11:25.740
So it's not the final destination.

00:11:25.880 --> 00:11:28.980
But I do think it's a really interesting and important starting ground there.

00:11:28.980 --> 00:11:29.640
Yeah, for sure.

00:11:29.640 --> 00:11:30.000
Yeah.

00:11:30.000 --> 00:11:36.780
So I gave a shout out to two ORMs already, the Django one and SQLAlchemy.

00:11:36.780 --> 00:11:41.280
And I feel like those are probably the two big hitters of the Python space, although there

00:11:41.280 --> 00:11:42.140
are many, many more.

00:11:42.140 --> 00:11:44.980
So why not just use those?

00:11:44.980 --> 00:11:46.480
Why go and create Piccolo?

00:11:46.480 --> 00:11:46.980
Yeah.

00:11:46.980 --> 00:11:50.680
So when I started it, there was no async options for ORMs at all.

00:11:50.680 --> 00:11:52.040
It was all very new.

00:11:52.040 --> 00:11:55.800
And my day job involved async programming all of the time.

00:11:56.060 --> 00:11:58.660
Because of chat apps, online games, that kind of stuff.

00:11:58.660 --> 00:12:02.480
So that was really why I was like, well, nothing really served my needs at the time.

00:12:02.480 --> 00:12:02.860
Right.

00:12:02.860 --> 00:12:07.440
Because until recently, SQLAlchemy had no async capabilities.

00:12:07.440 --> 00:12:08.060
Yeah.

00:12:08.060 --> 00:12:10.960
And Django ORM more or less still doesn't, right?

00:12:10.960 --> 00:12:13.040
That's the final part that they're trying to move to async.

00:12:13.040 --> 00:12:13.480
Yeah.

00:12:13.480 --> 00:12:17.180
So the workaround is to run it in a thread, but it's just not as performant as running

00:12:17.180 --> 00:12:18.380
with asyncio directly.

00:12:18.380 --> 00:12:21.760
So there's kind of this vacuum for a time with async ORMs.

00:12:21.920 --> 00:12:26.440
But then it was also about just starting through a blank sheet of paper and thinking, look,

00:12:26.440 --> 00:12:30.960
like we've got all these great tools to work with now in Python 3.6 and onwards.

00:12:30.960 --> 00:12:33.200
How can I absolutely push them to the limit?

00:12:33.200 --> 00:12:39.120
So the syntax, it uses a lot of direct references to objects rather than strings.

00:12:39.460 --> 00:12:46.940
So for example, in Django, you do my table to objects and then dot filter and you name equals

00:12:46.940 --> 00:12:47.260
Dan.

00:12:47.260 --> 00:12:52.680
The problem with that is you can quite easily make a mistake as the code changes.

00:12:52.680 --> 00:12:58.520
So you might end up having a column which no longer exists or so strings can be a little

00:12:58.520 --> 00:12:59.100
bit fragile.

00:12:59.100 --> 00:13:02.020
So with Piccolo, it's just object references everywhere.

00:13:02.020 --> 00:13:07.660
So rather than name, it's in this example here, it's band dot name where band is the

00:13:07.660 --> 00:13:08.320
name of the table.

00:13:08.320 --> 00:13:08.580
Right.

00:13:08.580 --> 00:13:13.100
So it's like many of the ORMs, it's sort of class OOP based, right?

00:13:13.100 --> 00:13:16.760
So you create a class that maps to a table and database, right?

00:13:16.760 --> 00:13:17.120
Yeah.

00:13:17.120 --> 00:13:19.520
So there's one distinction I'd like to make quickly as well.

00:13:19.520 --> 00:13:21.320
So there's ORMs and then there's query builders.

00:13:21.320 --> 00:13:25.560
And in Python, there's not really too much of a distinction, but in other languages like

00:13:25.560 --> 00:13:30.720
JavaScript, query builders are really popular as like a separate idea to ORMs.

00:13:30.720 --> 00:13:35.500
And query builders, they kind of, you create a SQL query, you execute it on the database,

00:13:35.500 --> 00:13:39.040
and then you tend to work more with dictionaries and lists rather than objects.

00:13:39.040 --> 00:13:46.580
So I'd say that 90% of Piccolo is a query builder, but people are used to ORMs and Python and it

00:13:46.580 --> 00:13:51.460
can actually lead you to some quite poor patterns, ORMs, because what the first thing people learn

00:13:51.460 --> 00:13:55.040
with Django is they'll go my table dot objects dot get.

00:13:55.040 --> 00:13:59.200
So it returns an object and then they'll change the attributes of the object and then they'll

00:13:59.200 --> 00:13:59.780
call save.

00:14:00.180 --> 00:14:03.500
But then that's actually two database queries because you have to get it and then you have

00:14:03.500 --> 00:14:04.140
to update it.

00:14:04.140 --> 00:14:05.920
Well, and it's not just two database queries.

00:14:05.920 --> 00:14:07.720
It can be a lot of serialization.

00:14:07.720 --> 00:14:08.340
Yeah.

00:14:08.340 --> 00:14:15.080
Like the slowest part of all of my data stack is if I were to try to pull back 10,000 records

00:14:15.080 --> 00:14:19.720
at a time, it's the deserialization of those 10,000 things that is actually the slowest part

00:14:19.720 --> 00:14:20.800
of the entire process.

00:14:21.360 --> 00:14:25.800
And here, if what you're talking about, like you're talking about the band, if the band

00:14:25.800 --> 00:14:29.120
has tons of information and you just want to change the name, right?

00:14:29.120 --> 00:14:33.020
You're pulling all that data back, converting it or whatever, then changing the thing and

00:14:33.020 --> 00:14:34.160
then pushing it back down.

00:14:34.160 --> 00:14:34.640
Yeah.

00:14:34.640 --> 00:14:35.120
It's a lot of work.

00:14:35.120 --> 00:14:38.740
And a lot of the time what will happen is you'll serialize it into an object and then

00:14:38.740 --> 00:14:41.000
you'll deserialize it out into JSON anyway.

00:14:41.000 --> 00:14:43.900
And it's kind of pointless when you think about it.

00:14:44.640 --> 00:14:46.960
And there's also the problem with objects getting stale.

00:14:46.960 --> 00:14:51.280
So you might pull an object into memory, but then some other user might manipulate all those

00:14:51.280 --> 00:14:51.700
objects.

00:14:51.700 --> 00:14:54.780
But then when you save it, are you going to overwrite those fields that have been updated

00:14:54.780 --> 00:14:55.540
in the database?

00:14:55.540 --> 00:14:57.760
So it's problematic in a way.

00:14:57.760 --> 00:15:02.460
So it is an ORM, but then I'd really encourage people to look at it as a query builder too,

00:15:02.460 --> 00:15:06.720
because in my own apps, I use the select method a lot.

00:15:06.720 --> 00:15:09.660
So rather than returning the objects, it returns dictionaries.

00:15:09.660 --> 00:15:12.260
And then it has this option, an output method.

00:15:12.420 --> 00:15:15.500
So you can just literally deserialize it straight into JSON.

00:15:15.500 --> 00:15:20.860
So this is what makes it fast because the query is going through asyncpg, which is super

00:15:20.860 --> 00:15:21.220
fast.

00:15:21.220 --> 00:15:24.860
And then it's coming back as a dictionary straight from asyncpg.

00:15:24.860 --> 00:15:28.640
And then it's using all JSON to stick it straight into a string.

00:15:28.640 --> 00:15:32.160
So you're kind of missing, you're skipping all this deserialization nonsense.

00:15:32.160 --> 00:15:32.880
Yeah, yeah.

00:15:32.880 --> 00:15:34.040
This is super interesting.

00:15:34.040 --> 00:15:39.220
Now that you pointed out, I'm not used to seeing projections in ORMs.

00:15:39.320 --> 00:15:44.180
What I'm used to seeing is give me back the classes that, in this case, a band, right?

00:15:44.180 --> 00:15:47.880
Do a query like where the popularity is greater than 100 or whatever, and give me a whole bunch

00:15:47.880 --> 00:15:51.020
of bands, band objects back, and then I'm going to work with them.

00:15:51.020 --> 00:15:55.440
But sometimes like the one I work with most commonly is Mongo Engine.

00:15:55.700 --> 00:15:58.320
I know it's not an ORM, it's an ODM, but close enough.

00:15:58.320 --> 00:15:59.620
Does the serialization bit.

00:15:59.620 --> 00:16:02.140
And you can say, I don't really want the other parts.

00:16:02.140 --> 00:16:04.920
Just give me the name, like the website or something.

00:16:04.920 --> 00:16:07.680
And it won't ship or deserialize those things.

00:16:07.680 --> 00:16:11.800
But you just end up with the same objects that just have none everywhere else, right?

00:16:11.800 --> 00:16:19.500
Where in your ORM, you can actually say band.select, band.name, band.url, or something like that.

00:16:19.540 --> 00:16:21.760
And that would return the dictionary with those two things, right?

00:16:21.760 --> 00:16:23.540
A list of dictionaries, probably?

00:16:23.540 --> 00:16:24.860
A list of dictionaries, yeah.

00:16:24.860 --> 00:16:28.580
And then it also has a feature, like Django has this feature, which is invaluable.

00:16:28.580 --> 00:16:30.080
It's called values list.

00:16:30.080 --> 00:16:35.120
And so if you just want one value back, it'll then condense it down to just a list of values.

00:16:35.120 --> 00:16:35.460
Right.

00:16:35.460 --> 00:16:39.800
Like I want all the IDs of the bands that play pop music or something.

00:16:39.960 --> 00:16:44.960
Yeah, and it's so much more efficient than doing like in Django, you know, band.orl,

00:16:44.960 --> 00:16:47.680
objects.all, and then looping through to get the IDs.

00:16:47.680 --> 00:16:49.520
It's just these little tricks you learn.

00:16:49.520 --> 00:16:53.040
Like if you use Django for ages, you just learn these little tricks.

00:16:53.040 --> 00:16:53.440
Right.

00:16:53.440 --> 00:16:58.020
Another one that stood out to me is the ability to do set-based operations.

00:16:58.020 --> 00:17:02.340
Because when I think of ORMs, I just, for everyone listening, I adore ORMs.

00:17:02.340 --> 00:17:04.640
I think they're really empowering for people.

00:17:04.800 --> 00:17:10.160
I think they take a lot of the modern tooling that we love, like refactoring, and allow you

00:17:10.160 --> 00:17:12.440
to apply that like over to your query.

00:17:12.440 --> 00:17:17.460
Because if you wanted to like change the casing of band.name, you could refactor, rename that,

00:17:17.460 --> 00:17:20.000
and it would affect your queries because that's still Python code, right?

00:17:20.000 --> 00:17:24.320
That said, there are places where people either abuse it or it's just inappropriate.

00:17:24.320 --> 00:17:29.240
So the places where it gets abused a lot would be the N plus one problem, right?

00:17:29.240 --> 00:17:32.400
Where you've got a lazy reference to something else.

00:17:32.620 --> 00:17:36.620
And you don't know that that's going to be a separate query for every time you touch one

00:17:36.620 --> 00:17:36.960
of those.

00:17:36.960 --> 00:17:40.960
And you get a list of objects back and you loop over them and you access like, in your example,

00:17:40.960 --> 00:17:42.080
you've got band.manager.

00:17:42.080 --> 00:17:44.740
For B and band, band.manager, right?

00:17:44.740 --> 00:17:48.100
That could be 101 queries for what should have been one, right?

00:17:48.100 --> 00:17:49.220
Yeah, that's a really good point.

00:17:49.220 --> 00:17:53.080
And even experienced developers get this wrong because they might use serializers, which are

00:17:53.080 --> 00:17:56.940
calling properties under the hood on the table, which are triggering SQL queries.

00:17:56.940 --> 00:18:02.660
So this is another design intent behind Piccolo is whenever a query is run, it's very explicit.

00:18:02.660 --> 00:18:05.680
You are literally calling .run or .runsync.

00:18:05.680 --> 00:18:07.260
So there's none of this magic.

00:18:07.260 --> 00:18:09.820
You can't accidentally create an N plus one query.

00:18:09.820 --> 00:18:11.940
You might accidentally end up with a coroutine or something.

00:18:11.940 --> 00:18:12.400
Yeah.

00:18:12.400 --> 00:18:16.460
So yeah, it's a really good point because I think N plus one is kind of like the scourge of

00:18:16.460 --> 00:18:17.480
developers with performance.

00:18:17.480 --> 00:18:22.960
And also coming back to your point about ORMs, as a backend developer, we can spend hours a day

00:18:22.960 --> 00:18:23.780
using ORMs.

00:18:23.780 --> 00:18:26.120
It's kind of like one of the main tools in our tool belt.

00:18:26.120 --> 00:18:30.180
So it's kind of quite nice to start from a blank sheet of paper and think, how can I make

00:18:30.180 --> 00:18:32.660
that experience maybe like slightly better if I can?

00:18:32.660 --> 00:18:37.320
This portion of Talk Python to Me is sponsored by Linode.

00:18:37.320 --> 00:18:42.360
Visit talkpython.fm/Linode to see why Linode has been voted the top infrastructure

00:18:42.360 --> 00:18:45.760
as a service provider by both G2 and TrustRadius.

00:18:46.240 --> 00:18:51.440
From their award-winning support, which is offered 24, 7, 365 to every level of user,

00:18:51.440 --> 00:18:56.320
to the ease of use and setup, it's clear why developers have been trusting Linode for projects

00:18:56.320 --> 00:18:58.500
both big and small since 2003.

00:18:58.500 --> 00:19:04.540
Deploy your entire application stack with Linode's one-click app marketplace, or build it all from

00:19:04.540 --> 00:19:08.420
scratch and manage everything yourself with supported centralized tools like Terraform.

00:19:08.420 --> 00:19:14.680
Linode offers the best price-to-performance value for all compute instances, including GPUs,

00:19:14.680 --> 00:19:19.060
as well as block storage, Kubernetes, and their upcoming bare-metal release.

00:19:19.060 --> 00:19:24.940
Linode makes cloud computing fast, simple, and affordable, allowing you to focus on your

00:19:24.940 --> 00:19:26.800
projects, not your infrastructure.

00:19:26.800 --> 00:19:32.100
Visit talkpython.fm/Linode and sign up with your Google account, your GitHub account,

00:19:32.100 --> 00:19:35.260
or your email address, and you'll get $100 in credit.

00:19:35.260 --> 00:19:40.340
That's talkpython.fm/Linode, or just click the link in your podcast player's show notes.

00:19:40.340 --> 00:19:42.360
And thank them for supporting Talk Python.

00:19:42.360 --> 00:19:49.120
The N plus one problem, I believe, is either there's some tool doing something behind the

00:19:49.120 --> 00:19:51.940
scenes you don't know, but often it's just a lack of understanding.

00:19:51.940 --> 00:19:57.440
Oh, that actually is a lazily loaded property, which is going to trigger a query, so I should

00:19:57.440 --> 00:19:59.700
have put a join, and then I'd be in a better place.

00:20:00.080 --> 00:20:04.260
That's a programmer pattern thing that you should pay attention to and work with.

00:20:04.260 --> 00:20:08.360
The one where I don't know how to fix it is more like the serialization thing.

00:20:08.360 --> 00:20:14.520
Like, what if I want to go through my database and go to 10,000 records and make some changes

00:20:14.520 --> 00:20:14.980
to them?

00:20:14.980 --> 00:20:20.400
So often it's do the query, loop over the 10,000 things, make a change, call save.

00:20:20.940 --> 00:20:25.560
Maybe it's in one giant transaction that you finally push the changes back, but you're

00:20:25.560 --> 00:20:27.020
pulling all the data back.

00:20:27.020 --> 00:20:33.040
And one of the things I really like about your, or I'm here, is like this update section here,

00:20:33.040 --> 00:20:37.240
where you can do set-based operations without pulling the records back.

00:20:37.240 --> 00:20:37.540
Yeah.

00:20:37.540 --> 00:20:42.980
So you can do stuff like, so this example here, wait, band.update, band.popularity, 10,000.

00:20:42.980 --> 00:20:47.380
But then you can also do band.popularity is band.popularity plus 10.

00:20:47.380 --> 00:20:50.860
And then in the database, it will then just add 10 to all of the numbers.

00:20:50.860 --> 00:20:51.520
Oh, really?

00:20:51.520 --> 00:20:52.420
That's awesome.

00:20:52.420 --> 00:20:56.880
And then it's all just magic around, you know, Python magic methods.

00:20:56.880 --> 00:20:59.780
It's just, as a library author, it gives you so much power.

00:20:59.780 --> 00:21:01.460
It's one of the things I love about Python.

00:21:01.460 --> 00:21:01.720
Yeah.

00:21:01.720 --> 00:21:06.460
Because when you're building like query languages, like ORMs, I think very few languages can

00:21:06.460 --> 00:21:08.840
really rival Python with its flexibility.

00:21:08.840 --> 00:21:09.340
Yeah.

00:21:09.340 --> 00:21:11.100
So that's really why a lot of this stuff's possible.

00:21:11.100 --> 00:21:11.960
It's really neat.

00:21:11.960 --> 00:21:17.080
And I think the ability to push these changes without actually, you're still programming

00:21:17.080 --> 00:21:21.720
in this, the ORM classes and the models, but you're not actually pushing a whole bunch of

00:21:21.720 --> 00:21:25.840
them back and forth to make the changes, but to do these set-based operations, like delete

00:21:25.840 --> 00:21:30.940
them where, or make this update to this value where this is true, and then just push that,

00:21:30.940 --> 00:21:33.860
make that happen in the best way you can with SQL, right?

00:21:33.860 --> 00:21:34.480
Yeah, exactly.

00:21:34.480 --> 00:21:39.320
I think coming back to your point around the M plus one, I think properties are something

00:21:39.320 --> 00:21:40.760
that can be a little bit evil.

00:21:40.940 --> 00:21:46.600
And I've really shy away from them in the Piccolo code because it can, you call a property

00:21:46.600 --> 00:21:49.640
and you think you're getting a value back, but it could be doing any kind of magic.

00:21:49.640 --> 00:21:55.120
And then once you've defined something as a property, you then can't add arguments to

00:21:55.120 --> 00:21:56.200
it without breaking your API.

00:21:56.200 --> 00:22:00.760
So yeah, I think that that's something I've tried to steer away from in general with Piccolo,

00:22:00.760 --> 00:22:01.560
like properties.

00:22:01.560 --> 00:22:01.880
Yeah.

00:22:01.980 --> 00:22:04.660
A lot of hidden stuff happening there, right?

00:22:04.660 --> 00:22:05.220
Yeah.

00:22:05.220 --> 00:22:06.140
It's not entirely clear.

00:22:06.140 --> 00:22:10.580
I think they're super useful, but certainly in something where I thought I was accessing

00:22:10.580 --> 00:22:13.440
a field of the class, but what I actually did is make a network call.

00:22:13.440 --> 00:22:18.280
Like that distinction is possibly too big of a bridge to just make that automatic a lot

00:22:18.280 --> 00:22:18.740
of the times.

00:22:18.740 --> 00:22:19.180
Yeah.

00:22:19.180 --> 00:22:22.040
There's no async properties in Python as well.

00:22:22.180 --> 00:22:25.640
So that's kind of one of the reasons why it doesn't use any async properties.

00:22:25.640 --> 00:22:27.280
Maybe they'll add it.

00:22:27.280 --> 00:22:30.240
If they add it, maybe I'll put a comment on the PEP saying, don't do it.

00:22:30.240 --> 00:22:31.580
Yeah, exactly.

00:22:32.080 --> 00:22:36.480
Another thing that's interesting here is on all this code, every code you've written

00:22:36.480 --> 00:22:41.680
is await band.select or await band.delete and so on or update.

00:22:41.680 --> 00:22:43.520
And then at the end, you say run.

00:22:43.520 --> 00:22:46.340
This is the explicit part that you were talking about in your API.

00:22:46.340 --> 00:22:48.200
Like I know here's where it's happening.

00:22:48.200 --> 00:22:52.340
And it probably makes a lot of sense to do that as well, because on the flip side of it,

00:22:52.340 --> 00:22:54.360
that's where you have to await it anyway, right?

00:22:54.360 --> 00:22:54.660
Yeah.

00:22:54.660 --> 00:22:58.500
So what happens is you build up this query, you just chain methods to it.

00:22:58.500 --> 00:23:02.000
And then at any point you can print out that object and I'll give you the SQL.

00:23:02.000 --> 00:23:07.220
And then until you actually await it, there's something under the hood that I don't really

00:23:07.220 --> 00:23:07.760
publicize.

00:23:07.760 --> 00:23:09.000
You don't need the dot run.

00:23:09.000 --> 00:23:12.560
If you await it, it will run as a convenience because people forget.

00:23:12.560 --> 00:23:17.460
But then it just makes it easier from a documentation perspective to say when it's async, use run.

00:23:17.460 --> 00:23:19.300
And when it's synchronous, use run sync.

00:23:19.300 --> 00:23:20.080
Right.

00:23:20.080 --> 00:23:26.160
And then if you do run sync, then I've got like a bit of magic in there where it tries to

00:23:26.160 --> 00:23:29.940
create an event loop to run it, or it tries to figure out if there's already an event

00:23:29.940 --> 00:23:30.220
loop.

00:23:30.220 --> 00:23:31.520
If there is, run it in there.

00:23:31.520 --> 00:23:37.860
So you can use Piccolo in an old school WSGI app if you wanted to just synchronously.

00:23:37.860 --> 00:23:38.220
Yeah.

00:23:38.220 --> 00:23:41.220
Well, let's dive into that because that's one of the things that really stood out to me.

00:23:41.220 --> 00:23:47.040
Many frameworks or APIs packages tell you, you're going to either have to go, you know,

00:23:47.040 --> 00:23:48.540
you're going to take a fork in the road.

00:23:48.540 --> 00:23:51.660
You're going to go down the async fork and you're going to use the async library like

00:23:51.660 --> 00:23:55.340
HTTPX or you're going to go on another fork and you're going to use the request library

00:23:55.340 --> 00:23:56.760
that has no async.

00:23:56.760 --> 00:24:00.800
And you're going to go down that path and you choose and then you just go.

00:24:00.800 --> 00:24:07.560
And with Piccolo, you can actually run, I guess the default behavior would be to be async and

00:24:07.560 --> 00:24:07.840
await.

00:24:07.840 --> 00:24:13.600
But it has this dot run sync, which will kind of cap where the asynchronous behaves and goes.

00:24:13.600 --> 00:24:18.440
And it'll just that you could run it in a regular Flask app or Django app or whatever

00:24:18.440 --> 00:24:20.960
and not worry about it being async at all.

00:24:20.960 --> 00:24:21.140
Right.

00:24:21.140 --> 00:24:21.840
Yeah, that's right.

00:24:21.840 --> 00:24:25.720
And it's actually one of the design challenges with Piccolo is how do you create an API which

00:24:25.720 --> 00:24:27.340
is synchronous and asynchronous?

00:24:27.340 --> 00:24:33.340
And there's only really two ways of achieving it is with a method like run or run sync or

00:24:33.340 --> 00:24:34.260
with context managers.

00:24:34.260 --> 00:24:40.180
So some of them you'll create either an async context manager or synchronous, and then that

00:24:40.180 --> 00:24:42.940
will then impact whether the underlying query is synchronous or not.

00:24:43.480 --> 00:24:47.880
But then it adds a little bit more boilerplate if every time you're in a query, you need

00:24:47.880 --> 00:24:49.780
a context manager to tell it to be async.

00:24:49.780 --> 00:24:55.480
So this is kind of the best outcome I could think of was just have dot run or dot run sync.

00:24:55.480 --> 00:24:59.580
I think this is great, especially since even if you forget the run, it'll still run async,

00:24:59.580 --> 00:25:01.120
but there's a way to kind of cap it.

00:25:01.120 --> 00:25:07.380
So something I wanted to talk about, it's driven me crazy ever since async and await were introduced

00:25:07.380 --> 00:25:12.160
because I don't find it to be true, but I hear it all the time spoken about in the community

00:25:12.160 --> 00:25:16.160
async and await, they're super neat, but they're like viruses.

00:25:16.160 --> 00:25:21.440
And in the sense that soon as like one of your functions way, way at the bottom has to do

00:25:21.440 --> 00:25:24.920
something async, well, then the thing that calls it has to be async and await it.

00:25:24.920 --> 00:25:27.560
And the things that call that function now all have to await it.

00:25:27.560 --> 00:25:29.960
And that percolates all the way to the top of your app.

00:25:30.060 --> 00:25:34.160
And so now you've, by using any async library, you've turned your entire thing into this like

00:25:34.160 --> 00:25:36.640
async vertical call stack.

00:25:36.640 --> 00:25:40.620
Your example here shows that that's not, it doesn't have to be that way, right?

00:25:40.620 --> 00:25:43.780
That's sort of the naive, I'm just going to like write the code without thinking about it.

00:25:43.780 --> 00:25:49.700
But if you wanted to say, have your data access layer do three things, because it's got to pull

00:25:49.700 --> 00:25:51.040
some stuff from different places.

00:25:51.040 --> 00:25:52.020
You want that to be async.

00:25:52.020 --> 00:25:53.980
It doesn't mean that function has to be async.

00:25:54.060 --> 00:25:57.920
It could just start its own event loop, do the three things faster than without it,

00:25:57.920 --> 00:25:59.620
and then return the answers, right?

00:25:59.620 --> 00:26:01.780
You can kind of cap it at any level that you want.

00:26:01.780 --> 00:26:04.660
And your run sync is kind of an example of that.

00:26:04.660 --> 00:26:08.100
Like you can choose to not have it, just turn your entire app async.

00:26:08.100 --> 00:26:09.280
You can jump between them.

00:26:09.280 --> 00:26:13.980
So typically if people use an async, then it's like, the argument is, if you need async,

00:26:13.980 --> 00:26:18.240
your whole app probably should be async because otherwise why use an async?

00:26:18.240 --> 00:26:20.340
But then you can flip between them quite easily.

00:26:20.340 --> 00:26:23.380
So if you've got a synchronous app and you want to call some async code,

00:26:23.520 --> 00:26:24.740
there's asyncio.run.

00:26:24.740 --> 00:26:29.820
And you can also do stuff like spin up an event loop in a different thread and then send

00:26:29.820 --> 00:26:30.540
work to that.

00:26:30.540 --> 00:26:31.380
Yeah, absolutely.

00:26:31.380 --> 00:26:32.400
So it is quite fluid.

00:26:32.400 --> 00:26:34.240
You can flip between them quite easily.

00:26:34.240 --> 00:26:39.180
Yeah, I mean, just one example that comes to mind is what if I wanted to go web scrape

00:26:39.180 --> 00:26:41.260
every page at a certain domain?

00:26:41.260 --> 00:26:43.380
So I've got a function that gives me a domain.

00:26:43.380 --> 00:26:49.820
I give it a domain and then I want it to return or store into the database all the pages, right?

00:26:49.820 --> 00:26:53.140
That would be perfectly reasonable to have that thing go, okay, well, let's do a,

00:26:53.140 --> 00:26:57.280
a request, figure out what all the pages are, and then just, you know, recursively sort of grab them

00:26:57.280 --> 00:26:58.160
all asynchronously.

00:26:58.160 --> 00:27:03.260
You would get a huge boost on getting every page off a site, even if that function blocked.

00:27:03.260 --> 00:27:04.040
You know what I mean?

00:27:04.040 --> 00:27:06.880
Because it itself could just go crazy against the server.

00:27:06.880 --> 00:27:08.140
Maybe it shouldn't, but it could.

00:27:08.140 --> 00:27:08.560
Yeah.

00:27:08.560 --> 00:27:10.780
I'm a huge fan of asyncio.gather as well.

00:27:11.000 --> 00:27:15.560
So that's a really beautiful API just for saying, do these 50 things now, please.

00:27:15.560 --> 00:27:17.280
And let me know when you're done.

00:27:17.280 --> 00:27:17.820
Yeah.

00:27:17.820 --> 00:27:18.580
And block, right?

00:27:18.580 --> 00:27:21.880
When you're done, give me a list of answers or errors.

00:27:21.880 --> 00:27:22.200
Yeah.

00:27:22.340 --> 00:27:23.600
Also out in the live stream, Chris May.

00:27:23.600 --> 00:27:24.020
Hey, Chris.

00:27:24.020 --> 00:27:27.360
It says, I'm so excited to use Piccolo with unsync.

00:27:27.360 --> 00:27:29.360
I have a workflow that'd be nice to parallelize.

00:27:29.360 --> 00:27:36.560
And yeah, so I think unsync is another really interesting library that wraps up asyncio plus

00:27:36.560 --> 00:27:38.560
threading plus multi-processing.

00:27:38.560 --> 00:27:43.560
But then gives you a nice way to cap it as well because you can go, like, be given a task that

00:27:43.560 --> 00:27:44.300
comes back from there.

00:27:44.300 --> 00:27:48.920
If you just ask for the result and it's not done, it'll just block like a regular thing.

00:27:48.920 --> 00:27:50.500
And it does kind of what you're talking about.

00:27:50.500 --> 00:27:54.500
It'll have a, it has a background thread with its own event loop and it just pushes all the

00:27:54.500 --> 00:27:55.500
work over to there.

00:27:55.500 --> 00:27:56.120
Yeah.

00:27:56.120 --> 00:27:56.820
So, yeah.

00:27:56.820 --> 00:27:58.240
That's a cool library.

00:27:58.240 --> 00:27:59.100
Yeah, it is.

00:27:59.100 --> 00:28:00.720
At least for the size, right?

00:28:00.720 --> 00:28:05.240
Like 126 lines and it unifies those three APIs and adds some more stuff.

00:28:05.240 --> 00:28:08.500
That's pretty big bang for the Python byte.

00:28:08.880 --> 00:28:09.480
Yeah, that's impressive.

00:28:09.480 --> 00:28:11.120
I wish Piccolo was that terse.

00:28:11.120 --> 00:28:14.540
I think thousands, tens of thousands of lines by now.

00:28:14.540 --> 00:28:15.440
Yeah.

00:28:15.440 --> 00:28:15.940
Yeah.

00:28:15.940 --> 00:28:16.180
Yeah.

00:28:16.180 --> 00:28:22.580
So another one of the new Python 3, 6 onward type of things that's really cool is the type

00:28:22.580 --> 00:28:23.140
annotations.

00:28:23.140 --> 00:28:23.600
Yeah.

00:28:23.600 --> 00:28:24.880
I love type annotations.

00:28:24.880 --> 00:28:30.480
So part of my day job in the past was using Swift and Swift is almost like hyphens, like

00:28:30.480 --> 00:28:31.500
brother or sister.

00:28:31.500 --> 00:28:33.720
It was very heavily inspired by Python.

00:28:33.720 --> 00:28:34.080
Right.

00:28:34.080 --> 00:28:37.980
It's like if Python all of a sudden decided it was incredibly strict about typing,

00:28:37.980 --> 00:28:39.420
and type definitions.

00:28:39.420 --> 00:28:40.360
Yeah.

00:28:40.360 --> 00:28:41.580
That would be a lot like Swift, right?

00:28:41.580 --> 00:28:42.180
Inward compiled.

00:28:42.180 --> 00:28:42.660
Yeah.

00:28:42.660 --> 00:28:45.700
It's a combination of type annotations and the tooling to support it.

00:28:45.700 --> 00:28:47.520
So in Python's case, it's VS Code.

00:28:47.520 --> 00:28:48.900
And in Swift's case, it's X code.

00:28:48.900 --> 00:28:53.640
And it just means that when you're refactoring, it just makes it so much more confident about

00:28:53.640 --> 00:28:54.400
what's going on.

00:28:54.400 --> 00:28:54.740
Yeah.

00:28:54.960 --> 00:28:58.800
It provides documentation because previously people were putting in a doc string anyway.

00:28:58.800 --> 00:29:02.400
So why not put it in your function definition and then you can introspect it.

00:29:02.400 --> 00:29:04.320
And my Pi is incredibly powerful.

00:29:04.320 --> 00:29:09.800
I honestly don't think I could have built Piccler without type annotations because it makes your

00:29:09.800 --> 00:29:10.980
code so much more maintainable.

00:29:10.980 --> 00:29:16.180
The click to go to VS Code as well is just a beautiful usability improvement.

00:29:16.180 --> 00:29:20.480
And then kind of one of the hidden benefits is it makes tab completion so good.

00:29:20.480 --> 00:29:26.340
So a lot of Python auto completions, they use a library called Jedi under the hood.

00:29:26.340 --> 00:29:30.360
So when I was building Piccolo, I had to look at the source code to try and figure out how

00:29:30.360 --> 00:29:31.020
it does its magic.

00:29:31.020 --> 00:29:35.740
And if you give a type annotation to something like this is what this function returns, it's

00:29:35.740 --> 00:29:40.020
a really strong indicator to Jedi that this is what's going to get returned.

00:29:40.020 --> 00:29:41.540
I don't need to do any magic anymore.

00:29:41.540 --> 00:29:41.900
Yeah.

00:29:41.900 --> 00:29:45.680
I would say that half the time, that's why I do it is to make the editor better.

00:29:45.680 --> 00:29:50.540
So both VS Code and PyCharm, like take a good look at what the type annotations are.

00:29:50.540 --> 00:29:50.800
Yeah.

00:29:50.800 --> 00:29:51.180
Right.

00:29:51.180 --> 00:29:54.240
And you just say, oh, you're trying to pass a string and that's really supposed to be

00:29:54.240 --> 00:29:54.640
an integer.

00:29:54.640 --> 00:29:59.400
But then also, like you say, tab completion or autocomplete all over the place is fantastic.

00:29:59.400 --> 00:29:59.760
Yeah.

00:29:59.760 --> 00:30:02.500
I think there's a distinction as well, where I think if you're building an application,

00:30:02.500 --> 00:30:05.760
let's say you're building a Django app or a Flask app, you don't need to care quite as

00:30:05.760 --> 00:30:06.060
much.

00:30:06.060 --> 00:30:10.440
Like I personally would still add type annotations, but for libraries, I think it's just absolutely

00:30:10.440 --> 00:30:11.000
essential.

00:30:11.000 --> 00:30:15.660
Like I don't think any new Python library should be written without it because you kind of,

00:30:15.660 --> 00:30:18.100
shortchanging your users in a way.

00:30:18.100 --> 00:30:18.700
Is there?

00:30:18.700 --> 00:30:19.860
I totally agree.

00:30:19.860 --> 00:30:20.620
Yeah.

00:30:20.760 --> 00:30:20.960
Yeah.

00:30:20.960 --> 00:30:25.560
In the Flask app, for example, that you've mentioned, you know, I would say on the boundaries,

00:30:25.560 --> 00:30:25.760
right?

00:30:25.760 --> 00:30:29.580
Like here's a data access layer, like put type annotations on those little bits there.

00:30:29.580 --> 00:30:33.480
And then the rest of the app, usually the editors and the tools will just pick it up

00:30:33.480 --> 00:30:35.860
and continue to tell you what you're working with.

00:30:35.860 --> 00:30:36.160
Yeah.

00:30:36.320 --> 00:30:37.580
But if you're doing a library, right?

00:30:37.580 --> 00:30:42.220
You want every function or every class to be kind of standalone and know everything it

00:30:42.220 --> 00:30:42.460
can.

00:30:42.460 --> 00:30:43.120
Yeah, definitely.

00:30:43.120 --> 00:30:47.180
And one more thing about type annotations is it's probably the greatest source of interview

00:30:47.180 --> 00:30:51.160
questions ever made because you can ask people in an interview, what's the difference between

00:30:51.160 --> 00:30:52.740
like a sequence and an iterable?

00:30:52.960 --> 00:30:57.360
And like when you use type annotations, you really start to think about what's going on.

00:30:57.360 --> 00:30:59.500
And it's a great learning experience too.

00:30:59.500 --> 00:30:59.740
Yeah.

00:30:59.740 --> 00:31:03.800
I want to pass a generator here, but it takes a list of things and it says that won't work.

00:31:03.800 --> 00:31:07.360
And maybe you just need to relax your type annotations to an iterator.

00:31:07.360 --> 00:31:08.080
Yeah.

00:31:08.080 --> 00:31:09.140
A thing.

00:31:09.140 --> 00:31:11.860
A quick question from Roller out there in the live stream.

00:31:11.860 --> 00:31:12.300
Hey, Roller.

00:31:12.300 --> 00:31:16.860
Can I just pick a little and play some Mongo engine or is it just for a relational stuff?

00:31:16.860 --> 00:31:17.200
Yeah.

00:31:17.200 --> 00:31:21.680
It's just relational and it's, you can use SQLite locally, but it's mostly Postgres.

00:31:21.680 --> 00:31:27.580
It was really built to take advantage of Postgres because Postgres is, it's like the fastest

00:31:27.580 --> 00:31:32.640
growing SQL database in the world, which is remarkable to think it's how old it is.

00:31:32.640 --> 00:31:37.280
And I think I'll, you know, I think adding other SQL databases would be quite easy, but

00:31:37.280 --> 00:31:40.140
adding something like Mongo would be a bit trickier.

00:31:40.140 --> 00:31:42.600
I wouldn't say it was impossible, but a bit more work.

00:31:42.600 --> 00:31:42.940
Yeah.

00:31:42.940 --> 00:31:43.640
I would think so.

00:31:43.640 --> 00:31:43.840
Yeah.

00:31:43.840 --> 00:31:47.040
It's not, certainly not impossible, but like joins and stuff would get tricky.

00:31:47.040 --> 00:31:49.500
What about SQL injection?

00:31:49.500 --> 00:31:55.360
I mean, many of us have heard about the little Bobby tables, XKCD, which is delightful, you

00:31:55.360 --> 00:31:58.160
know, you know, sort of schadenfreude sort of way.

00:31:58.160 --> 00:32:04.880
We all kind of want to relish in somebody else suffering this, but I find that this is actually

00:32:04.880 --> 00:32:10.560
one of the really nice things about ORMs most of the time is that they scrape off the ability

00:32:10.560 --> 00:32:13.820
to do SQL injection because you're not building the SQL.

00:32:13.820 --> 00:32:14.600
Yeah, definitely.

00:32:14.880 --> 00:32:16.160
So your database adapter.

00:32:16.160 --> 00:32:21.020
So something like asyncpg or psycopg in the synchronous world, what you want to do is you

00:32:21.020 --> 00:32:25.560
want to pass it the query string with placeholders for any user submitted values.

00:32:25.560 --> 00:32:29.320
And then you submit the values that separately, like in a list.

00:32:29.320 --> 00:32:29.700
Right.

00:32:29.700 --> 00:32:32.260
Like a parameterized query, basically.

00:32:32.260 --> 00:32:32.920
Yeah.

00:32:32.920 --> 00:32:34.300
And as long as you do that, you're safe.

00:32:34.700 --> 00:32:40.840
But then for a library, when people are programmatically creating very complex SQL queries, and then you

00:32:40.840 --> 00:32:45.720
need to try and make sure that you've got the right values that match the right placeholders

00:32:45.720 --> 00:32:46.800
to pass to the adapter.

00:32:46.800 --> 00:32:48.620
It is quite challenging.

00:32:48.620 --> 00:32:50.920
There's some like recursive code where it has to.

00:32:51.280 --> 00:32:53.880
So we use something called query strings internally within Piccolo.

00:32:53.880 --> 00:32:57.180
So it never concatenates strings for SQL statements.

00:32:57.180 --> 00:33:02.360
It just, it uses query strings and then it compiles them before sending it to the database adapter.

00:33:02.360 --> 00:33:06.600
And it basically looks through all of the sub query strings it might have if it's a really

00:33:06.600 --> 00:33:07.340
complex query.

00:33:07.560 --> 00:33:10.260
And then it kind of passes it to the adapter.

00:33:10.260 --> 00:33:14.320
But yeah, it's just one of the complex things about building ORMs for sure.

00:33:14.320 --> 00:33:16.140
And also one of the most dangerous to get wrong.

00:33:16.140 --> 00:33:16.520
Yeah.

00:33:16.520 --> 00:33:17.940
Yeah, it absolutely is.

00:33:17.940 --> 00:33:22.240
There's untold number of bad things that can happen with SQL injection.

00:33:22.240 --> 00:33:23.200
And it's so easy.

00:33:23.200 --> 00:33:30.160
All you have to do is put a single little tick to comment out stuff, semicolon to finish that

00:33:30.160 --> 00:33:30.460
statement.

00:33:30.460 --> 00:33:32.360
And then you can run arbitrary code.

00:33:32.360 --> 00:33:37.540
And a lot of times you can even, some database engines will let you run sub process type things.

00:33:38.100 --> 00:33:39.320
Which is even worse.

00:33:39.320 --> 00:33:41.520
But yeah, it's not good.

00:33:41.520 --> 00:33:42.580
So you definitely want to avoid it.

00:33:42.580 --> 00:33:46.600
Yeah, it's a good argument for using ORMs and query builders because it'll make it less

00:33:46.600 --> 00:33:46.960
likely.

00:33:46.960 --> 00:33:47.840
I think for sure.

00:33:47.840 --> 00:33:53.280
You know, another thing that I wanted to touch on a little bit here is the actual filtering

00:33:53.280 --> 00:33:56.260
or projection statement type bits.

00:33:56.260 --> 00:33:59.540
So I mentioned using Mongo Engine before, which I'm a big fan of.

00:33:59.540 --> 00:34:03.900
And it's basically a Mongo equivalent of the Django ORM.

00:34:03.900 --> 00:34:05.580
So in that regard, they're real similar.

00:34:05.580 --> 00:34:10.400
And you do things like, if I wanted to say where the band popularity, or let's say the

00:34:10.400 --> 00:34:12.260
band name is Pythonistas, right?

00:34:12.260 --> 00:34:16.740
You would just say name equals Pythonistas as part of the filter.

00:34:16.740 --> 00:34:19.040
And there's two things that are crummy about that.

00:34:19.040 --> 00:34:24.580
One is you get no autocomplete that there's a column called name because it doesn't really

00:34:24.580 --> 00:34:27.600
know what class, even though you started out like band.objects.

00:34:27.600 --> 00:34:31.740
It doesn't, in the filter part, it no longer knows that the name came from the band, right?

00:34:31.740 --> 00:34:33.000
That's not part of the language.

00:34:33.000 --> 00:34:38.800
And then the other one is you're doing an equals or you've got like weird operators like in

00:34:38.800 --> 00:34:43.960
the name, like name underscore underscore GT for greater than and stuff like that.

00:34:43.960 --> 00:34:48.660
Whereas yours, you just write what you would put into an if statement or a loop or something

00:34:48.660 --> 00:34:49.060
like that.

00:34:49.060 --> 00:34:51.720
So you would say like band.popularity less than a thousand.

00:34:51.720 --> 00:34:53.180
That's the thing you send in there.

00:34:53.300 --> 00:34:53.800
Yeah, that's right.

00:34:53.800 --> 00:34:58.140
So I've been caught up, tripped up so many times in the past with Django where I've had

00:34:58.140 --> 00:35:01.780
something like name double underscore something else.

00:35:01.780 --> 00:35:07.300
And then it can't really understand that's wrong, like a linter or when you, while you're

00:35:07.300 --> 00:35:09.700
coding, it only really knows at a runtime and then you've got a 500 error.

00:35:09.700 --> 00:35:14.140
So the idea here is a linter would be able to pick up these problems.

00:35:14.360 --> 00:35:14.760
Exactly.

00:35:14.760 --> 00:35:19.980
Because so much of the pieces are, they're just using star, star, kwrgs and then they

00:35:19.980 --> 00:35:25.180
figure out how to generate a query out of like looking for special keywords in the key names

00:35:25.180 --> 00:35:27.020
and then turning those to columns.

00:35:27.020 --> 00:35:28.880
Also the refactoring thing, right?

00:35:28.880 --> 00:35:29.380
The linters.

00:35:29.380 --> 00:35:34.620
And if I want to do a refactoring to rename popularity, it's not going to check popularity

00:35:34.620 --> 00:35:37.080
underscore GT as a keyword argument.

00:35:37.080 --> 00:35:38.500
It has no idea those are related.

00:35:38.500 --> 00:35:38.940
Yeah.

00:35:38.940 --> 00:35:39.780
Yeah, definitely.

00:35:40.160 --> 00:35:45.660
So the way it's implemented this, the double equals and all these operators is the amazing

00:35:45.660 --> 00:35:50.060
things about Python is how you can just overload like fundamental things about the language.

00:35:50.060 --> 00:35:52.900
So you can overload what addition means.

00:35:52.900 --> 00:35:55.880
And when someone first tells you that, it sounds like the most mental thing in the world.

00:35:55.880 --> 00:35:57.860
Cause why would you want one plus one to equal five?

00:35:57.860 --> 00:36:01.040
But then it turns out when you're building an ORM, it's golden.

00:36:01.040 --> 00:36:06.780
And this is one reason why I find Python just so compelling over and over again is because

00:36:06.780 --> 00:36:12.700
as a library author, you can do this stuff that you can get closer to more of like a DSL than

00:36:12.700 --> 00:36:14.220
like a normal programming language.

00:36:14.220 --> 00:36:14.940
Specific language.

00:36:14.940 --> 00:36:15.620
Yeah, absolutely.

00:36:15.620 --> 00:36:16.180
Yeah.

00:36:16.180 --> 00:36:19.900
So is this a be done with descriptors or what's the magic?

00:36:19.900 --> 00:36:25.140
For the less than there's like done like double underscore LT and you can override that.

00:36:25.140 --> 00:36:28.200
And then what happens is when you call that method, it returns a where object.

00:36:28.520 --> 00:36:34.340
And then you can also, you could do in brackets, band dot popularity, less than a thousand and

00:36:34.340 --> 00:36:35.960
then double and sign as well.

00:36:35.960 --> 00:36:38.460
Band dot popularity greater than 500.

00:36:38.460 --> 00:36:41.100
So you can combine them with and and all statements.

00:36:41.100 --> 00:36:44.700
So the where statements in Piccolo can get like really powerful.

00:36:44.700 --> 00:36:49.560
So you just have to teach the where clauses how to and and then structure it in a way that

00:36:49.560 --> 00:36:51.800
Python will let it kind of go through, right?

00:36:51.800 --> 00:36:52.340
Yeah.

00:36:52.340 --> 00:36:55.600
Or you can do dot where, put some stuff and then another dot where statement.

00:36:55.600 --> 00:36:58.280
And if you've got multiple where statements, it becomes like it's an and.

00:36:58.280 --> 00:36:58.640
Yeah.

00:36:58.640 --> 00:37:02.740
But yeah, it's just, it's just all Python magic, which is one of the reasons I love Python.

00:37:02.740 --> 00:37:03.100
Yeah.

00:37:03.100 --> 00:37:08.440
Speaking of overridden things, the thing that I think is the most insane, but I'm starting

00:37:08.440 --> 00:37:13.620
to love, but took a while to get used to is the way the path object works for defining

00:37:13.620 --> 00:37:14.140
paths.

00:37:14.140 --> 00:37:14.720
Yeah.

00:37:14.720 --> 00:37:21.400
So, you know, the forward slash often means like drive separation on the POSIX systems.

00:37:21.400 --> 00:37:22.520
And, you know, it's close enough.

00:37:22.520 --> 00:37:25.580
You could actually put forward slash in your strings and Python on Windows and it'll

00:37:25.580 --> 00:37:26.780
still like, okay, fine.

00:37:26.780 --> 00:37:27.600
Backslash is what you meant.

00:37:27.600 --> 00:37:34.820
So they overrode the divide operator in code to allow you to concatenate strings and paths

00:37:34.820 --> 00:37:35.220
together.

00:37:35.220 --> 00:37:36.680
And that's just crazy.

00:37:36.680 --> 00:37:37.020
Yeah.

00:37:37.020 --> 00:37:40.700
The first time I saw it, I was very confused, but when you understand that it's okay, but

00:37:40.700 --> 00:37:41.240
yeah, totally.

00:37:41.240 --> 00:37:42.400
Yeah.

00:37:42.400 --> 00:37:45.040
I'm, I've gotten okay with it as well.

00:37:45.040 --> 00:37:47.940
And I start to use it and I really like it now, but I was like, I don't know if I can

00:37:47.940 --> 00:37:48.260
get behind.

00:37:48.260 --> 00:37:49.860
This is, this is a bridge too far.

00:37:49.860 --> 00:37:51.060
This is, that's division.

00:37:51.060 --> 00:37:51.980
What are we doing here?

00:37:51.980 --> 00:37:52.720
No, it's cool.

00:37:52.720 --> 00:37:53.260
It's cool.

00:37:53.620 --> 00:37:57.080
Talking of magic to Piccolo, like all around, it uses meta classes a lot.

00:37:57.080 --> 00:38:02.420
And there's something that got added in, I don't know if it's Python 3.7 or 3.6, but they

00:38:02.420 --> 00:38:04.100
actually changed meta classes slightly.

00:38:04.100 --> 00:38:07.000
So there's now like a Dunder magic method called init subclass.

00:38:07.780 --> 00:38:08.980
And Piccolo uses this a lot.

00:38:08.980 --> 00:38:14.120
And it's, it's actually an amazing hidden feature of Python where you can now add keyword

00:38:14.120 --> 00:38:15.620
arguments to a class definition.

00:38:15.620 --> 00:38:21.140
So if you had class foo, open brackets, inherits from bar, comma, and then you can start adding

00:38:21.140 --> 00:38:24.160
keyword arguments to the class to customize its creation.

00:38:24.160 --> 00:38:29.580
And that's kind of like a new layer of magic that's been added to Python recently.

00:38:29.580 --> 00:38:33.700
And Piccolo uses it extensively, but I don't see many other libraries using it yet because

00:38:33.700 --> 00:38:37.740
it's probably not so well known, but yeah, just kind of spread that bit of magic.

00:38:37.740 --> 00:38:39.160
So hopefully people can use it too.

00:38:39.160 --> 00:38:39.480
Nice.

00:38:39.480 --> 00:38:39.640
Yeah.

00:38:39.640 --> 00:38:40.200
That sounds awesome.

00:38:40.200 --> 00:38:44.940
I can certainly see how I'm like trying to create the classes, like the band class or

00:38:44.940 --> 00:38:47.360
whatever you say that it's going to be, would definitely use that.

00:38:47.360 --> 00:38:52.160
So one of the things that you say is awesome about Piccolo is the batteries included.

00:38:52.160 --> 00:38:52.560
Yeah.

00:38:52.700 --> 00:38:54.980
So let's talk about some of the batteries.

00:38:54.980 --> 00:38:56.100
So yeah.

00:38:56.100 --> 00:39:00.960
So the main battery by far is the admin, because when I started it, I was working for a design

00:39:00.960 --> 00:39:05.540
agency and admins are incredibly important for design agencies because you want to put

00:39:05.540 --> 00:39:08.980
something in front of a customer that they like the look of and they're comfortable using.

00:39:08.980 --> 00:39:12.180
So this is a huge part of the effort that's gone into Piccolo.

00:39:12.180 --> 00:39:15.140
And so this is a, it's sister project called Piccolo admin.

00:39:15.140 --> 00:39:17.560
And what happens is it's, it's an ASCII app.

00:39:17.800 --> 00:39:21.720
So I can maybe go into more detail about ASCII later on, but all you do is you give it a

00:39:21.720 --> 00:39:25.600
list of Piccolo tables and then it uses Pydantic.

00:39:25.600 --> 00:39:30.680
So Pydantic is a serialization library and it basically creates a Pydantic model from the

00:39:30.680 --> 00:39:31.320
Piccolo table.

00:39:31.320 --> 00:39:38.200
And then Pydantic models have this really useful method where it's JSON schema and it creates

00:39:38.200 --> 00:39:39.980
a JSON schema for the Pydantic model.

00:39:39.980 --> 00:39:40.240
Right.

00:39:40.240 --> 00:39:45.240
Because the Pydantic classes know this field is an int, this one is an optional date time

00:39:45.240 --> 00:39:45.820
and so on.

00:39:45.820 --> 00:39:46.120
Yeah.

00:39:46.120 --> 00:39:50.760
So Piccolo has really good Pydantic support, but it's in a sister repo called Piccolo API.

00:39:50.760 --> 00:39:55.640
And then that, so that creates the Pydantic model and it also has something called Piccolo

00:39:55.640 --> 00:39:56.020
CRUD.

00:39:56.020 --> 00:40:02.160
So you give it a Piccolo table and it creates another ASCII app, which has got all of the CRUD

00:40:02.160 --> 00:40:03.480
operations for your database.

00:40:03.480 --> 00:40:07.860
So you can programmatically create this huge API just by giving it a few tables.

00:40:07.860 --> 00:40:12.140
And then the front end is written in Vue.js and it's completely decoupled from the back

00:40:12.140 --> 00:40:12.380
end.

00:40:12.380 --> 00:40:13.500
It's just all by API.

00:40:13.620 --> 00:40:18.100
So yeah, I'm a huge fan of Vue.js because it's, it's very natural for Python developers

00:40:18.100 --> 00:40:21.120
who are used to the template syntax in Django and Flask.

00:40:21.120 --> 00:40:24.820
If you looked at the Vue templates, you'd be like, this looks very familiar.

00:40:24.820 --> 00:40:26.520
So I'm a big fan of that.

00:40:26.520 --> 00:40:26.860
Yeah, it's nice.

00:40:26.860 --> 00:40:27.160
Yeah.

00:40:27.160 --> 00:40:31.400
I think it's super close to Chameleon because of the attribute driven behavior as well.

00:40:31.400 --> 00:40:31.580
Yeah.

00:40:31.760 --> 00:40:32.000
Yeah.

00:40:32.000 --> 00:40:36.420
But then like to make a working admin requires so much work because you've also got the security

00:40:36.420 --> 00:40:36.860
side.

00:40:36.860 --> 00:40:42.580
So Piccolo API has a bunch of really useful ASCII middleware and it has like session authentication,

00:40:42.580 --> 00:40:47.660
CSRF protection and rate limiting as well because you don't want people to spam the login.

00:40:47.800 --> 00:40:54.320
So like just to get a fairly simple admin is in, it's like a iceberg to do it properly.

00:40:54.320 --> 00:40:57.980
So yeah, a lot of efforts gone into the admin, but I'm really proud of it.

00:40:58.040 --> 00:41:02.900
And like, this is really what excites me more than anything about the future because as

00:41:02.900 --> 00:41:06.840
we add support for post GIS and stuff like that, being able to create really interesting

00:41:06.840 --> 00:41:08.240
widgets around data.

00:41:08.240 --> 00:41:14.260
So, you know, how can I design a rectangle field for post GIS or a location field or.

00:41:14.260 --> 00:41:19.340
I could see some really cool stuff that are sort of template extensions, you know, like

00:41:19.340 --> 00:41:20.680
let's just pick Jinja, for example.

00:41:20.680 --> 00:41:26.180
Like if you had one of these objects, you could pass it over and it knew, for example, here's

00:41:26.180 --> 00:41:29.280
a daytime, you could just say, make a calendar picker here.

00:41:29.280 --> 00:41:33.100
And it just, you know, as long as you have the JavaScript included and instead of just

00:41:33.100 --> 00:41:39.460
putting the text, it gives you like a nice little Ajax-y widget or these, this list goes

00:41:39.460 --> 00:41:42.260
on a map, drop in the map widget and off it goes.

00:41:42.260 --> 00:41:42.580
Yeah.

00:41:42.580 --> 00:41:48.820
So basically Piccolo admin, it's just, it's just turns Pydantic models into UI and it's

00:41:48.820 --> 00:41:50.080
actually quite, it's actually quite interesting.

00:41:50.080 --> 00:41:53.960
And I'd love to get it to the point where for a business app, you just use Piccolo admin,

00:41:53.960 --> 00:41:55.080
you don't even have to build UI.

00:41:55.300 --> 00:41:56.580
You just say, here are my tables.

00:41:56.580 --> 00:41:57.020
Yeah.

00:41:57.020 --> 00:41:58.340
And then, yeah.

00:41:58.340 --> 00:42:02.020
Well, the truth is so often, like there's a lot of these little internal apps that people

00:42:02.020 --> 00:42:04.100
build that are just like forms over data.

00:42:04.100 --> 00:42:08.600
I just need to see the details, click on one, edit it, create a new one and delete one.

00:42:08.600 --> 00:42:10.800
And like, that's the app I need for this table.

00:42:10.800 --> 00:42:11.800
Could you build that?

00:42:11.800 --> 00:42:12.060
Right?

00:42:12.060 --> 00:42:13.260
Yeah, for sure.

00:42:13.260 --> 00:42:14.680
It is a lot of it.

00:42:14.680 --> 00:42:18.400
Cause I think with the approach I talked to Piccolo is you have a lot of Python libraries

00:42:18.400 --> 00:42:20.440
and they kind of start from the outside in.

00:42:20.520 --> 00:42:24.380
So they start from the URL layer and then the views and like middleware.

00:42:24.380 --> 00:42:27.440
And then over time, they then add the data layer and the security.

00:42:27.440 --> 00:42:30.700
But then with Piccolo, it's kind of from the inside out.

00:42:30.700 --> 00:42:34.140
Like I started from the data layer and then have the admin and some middleware.

00:42:34.300 --> 00:42:36.660
So it's quite a nice companion to have a ASCII app.

00:42:36.660 --> 00:42:40.420
So just kind of pick the framework you like and then Piccolo kind of gives you the data

00:42:40.420 --> 00:42:41.160
layer and the admin.

00:42:41.160 --> 00:42:41.980
That's kind of.

00:42:41.980 --> 00:42:42.220
Yeah.

00:42:42.220 --> 00:42:42.760
Yeah.

00:42:42.760 --> 00:42:43.000
Yeah.

00:42:43.000 --> 00:42:44.740
Well, let's talk about the ASCII stuff a little bit.

00:42:44.740 --> 00:42:49.040
Cause you did mention that there's some interesting support for those things.

00:42:49.040 --> 00:42:56.440
And it's got like, to some degree, native FastAPI, Flask, and even Blacksheep, which is

00:42:56.440 --> 00:42:58.840
an interesting one, support for those frameworks, right?

00:42:58.980 --> 00:42:59.140
Yeah.

00:42:59.140 --> 00:43:04.020
So I'm a huge fan of ASCII because I was a Django Channels power user and Andrew Godwin

00:43:04.020 --> 00:43:06.580
created ASCII out of Django Channels.

00:43:06.580 --> 00:43:09.080
It's really like a beautiful thing.

00:43:09.080 --> 00:43:12.400
If you look, so Starlette was the one that really built the foundation.

00:43:12.400 --> 00:43:17.340
So this is an async library, but also kind of like a framework.

00:43:17.340 --> 00:43:20.320
Like you can build an app with Starlette or you can use it to build up frameworks.

00:43:20.320 --> 00:43:25.300
What's amazing about ASCII is like every component in an ASCII framework is ASCII.

00:43:25.700 --> 00:43:30.980
So ASCII is basically the spec where it's a function that accepts a scope, a send and

00:43:30.980 --> 00:43:31.480
a receive.

00:43:31.480 --> 00:43:35.840
And then if you look at the internals of Starlet, everything's ASCII, like the middleware's ASCII,

00:43:35.840 --> 00:43:37.560
the endpoints are ASCII, like the whole thing.

00:43:37.560 --> 00:43:39.140
And it's like super composable.

00:43:39.140 --> 00:43:44.960
So you can say, I've got an ASCII app and you can mount other ASCII apps within it.

00:43:44.960 --> 00:43:48.320
So this is what I love about ASCII as a spec.

00:43:48.320 --> 00:43:52.640
So you can say, take a FastAPI app or a Starlette app and include Piccolo admin.

00:43:52.640 --> 00:43:54.140
Same with Blacksheep.

00:43:54.360 --> 00:44:00.080
Right. You could say slash catalog is actually handled by this other app written in FastAPI

00:44:00.080 --> 00:44:02.740
where the main thing is written in Flask or something like that.

00:44:02.740 --> 00:44:04.700
And you just kind of click them together in that cool way.

00:44:04.700 --> 00:44:06.620
Maybe Core would have to be the one, but still.

00:44:06.620 --> 00:44:07.780
Yeah. And I really love that.

00:44:07.780 --> 00:44:11.800
It's quite exciting that you could kind of build an app with multiple frameworks and be like,

00:44:11.800 --> 00:44:14.480
well, this part of the app will be better served by FastAPI.

00:44:14.480 --> 00:44:19.520
But this bit, I just need Starlette or I want Blacksheep or whichever ASCII framework people

00:44:19.520 --> 00:44:20.280
can dream up.

00:44:20.280 --> 00:44:24.300
So I think it's really exciting for the Python community, the ASCII spec.

00:44:24.300 --> 00:44:30.180
Yeah. And we did talk a little bit about the challenges and the cascading effect of async and await.

00:44:30.180 --> 00:44:35.600
But if you're already running a framework that has async view methods, there's just nothing to it, right?

00:44:35.600 --> 00:44:39.460
You just write your code and you just await the bits you got to await in the view method.

00:44:39.460 --> 00:44:43.920
And it just like the server and the framework handled the vent loops and all that business.

00:44:44.080 --> 00:44:49.920
Yeah. I think as well, what kind of happened is asyncio came out and it doesn't directly affect speed.

00:44:49.920 --> 00:44:55.280
It's more about throughput, but it's like the Python community took it as a challenge to build faster frameworks.

00:44:55.280 --> 00:45:01.100
And so there's a lot of them have really quite fast internals and they do feel quite cutting edge.

00:45:01.100 --> 00:45:03.120
Yeah. Like uv loop and stuff like that.

00:45:03.120 --> 00:45:06.940
They're like, how can we do this, but have the minimal overhead of adding this?

00:45:07.460 --> 00:45:10.760
I mean, people do talk about, okay, async and await won't make your code go faster.

00:45:10.760 --> 00:45:12.620
Well, it won't make CPU code go faster.

00:45:12.620 --> 00:45:15.660
But so often what we're doing, especially in web apps is waiting.

00:45:15.660 --> 00:45:18.220
I want to wait on a database and then wait on the network.

00:45:18.220 --> 00:45:19.760
And then I want to wait on the database again.

00:45:19.760 --> 00:45:24.000
And then I'm going to wait on an API and then I'm going to send back three lines of JSON, right?

00:45:24.000 --> 00:45:27.460
Like 99.9% of that is just waiting on something else.

00:45:27.460 --> 00:45:32.660
And when you're using async and await, like you can just do other things while you're doing that 99% of waiting.

00:45:32.660 --> 00:45:35.900
Yeah. So usually if you do a database query, it takes a few milliseconds.

00:45:36.400 --> 00:45:42.200
But then if you use the time it module on Python and you see how long basic operations take, they're more like microseconds.

00:45:42.200 --> 00:45:47.380
So there's like orders of magnitude difference in how long a database query takes to basic Python stuff.

00:45:47.380 --> 00:45:53.720
But this is why having stuff like uv loops are really important because if you had a really slow event loop, it kind of wouldn't make much difference.

00:45:53.720 --> 00:45:55.220
But because the event loops fast as well.

00:45:55.220 --> 00:46:01.720
And like a lot of the projects I did in the past, the throughput is really important because some apps, you won't have a lot of traffic.

00:46:01.720 --> 00:46:04.200
And then all of a sudden you'll get a thousand users.

00:46:04.560 --> 00:46:08.420
So I was doing like live events and you'd get a thousand people at once.

00:46:08.420 --> 00:46:11.080
And in that situation, throughput is incredibly important.

00:46:11.080 --> 00:46:15.820
Right. I mean, look at how the whole healthcare rollout in 2008 went.

00:46:15.820 --> 00:46:22.400
Right. I just can't help but think there must have been more awaits available to those, that those frameworks and those web apps.

00:46:22.660 --> 00:46:24.940
Because it just kept crashing and stuff was timing out.

00:46:24.940 --> 00:46:30.000
And I'm sure it's just like, well, we're just going to wait on this other slow government API.

00:46:30.000 --> 00:46:31.580
And we're going to do it for a lot of people.

00:46:31.580 --> 00:46:32.860
And it's just going to overwhelm it.

00:46:32.860 --> 00:46:34.320
Right. And it's just crazy.

00:46:34.320 --> 00:46:39.100
It just feels natural because like in the web server world, you had Apache and a lot of people moved to Nginx.

00:46:39.100 --> 00:46:39.940
That's very similar.

00:46:39.940 --> 00:46:40.960
It's like event loop driven.

00:46:41.160 --> 00:46:43.800
And we've kind of seen how beneficial Nginx was.

00:46:43.800 --> 00:46:47.360
So it just makes perfect sense to build your backend in the same way.

00:46:47.360 --> 00:46:48.680
Yeah, absolutely. Absolutely.

00:46:48.680 --> 00:46:51.900
All right. A couple more things we got some time to talk about.

00:46:51.900 --> 00:46:59.300
So over here, you've got a Django comparison page, which I guess also could be slightly a Mongo engine comparison page.

00:46:59.300 --> 00:47:01.640
Because like I said, they're basically the same thing without the nesting.

00:47:01.640 --> 00:47:10.300
So if somebody is familiar with Django and they're like, I would like to consider using this for my framework or for part of my code or whatever, just like want to use it.

00:47:10.300 --> 00:47:12.500
But they already know how to do stuff in Django.

00:47:12.500 --> 00:47:16.560
You have like, well, here's how you would create an object and save it in the different frameworks.

00:47:16.560 --> 00:47:20.280
Here's how you would update an object and make changes and so on.

00:47:20.520 --> 00:47:24.660
And you can just go through one at a time and just sort of compare the different pieces, right?

00:47:24.660 --> 00:47:25.040
Yeah.

00:47:25.040 --> 00:47:27.040
So it's quite heavily inspired by Django.

00:47:27.040 --> 00:47:30.540
But then I think Django in its ORM, it's more Pythonic.

00:47:30.540 --> 00:47:33.180
So rather than using where it uses filter.

00:47:33.180 --> 00:47:36.720
But then with Piccolo, it's meant to be very, very close to SQL.

00:47:36.720 --> 00:47:40.200
Because the theory is, if you know SQL, it'll be super easy to learn.

00:47:40.200 --> 00:47:44.060
And when you do need to drop down to a SQL query, there's no like mismatch.

00:47:44.060 --> 00:47:47.640
You're just like, well, I'm always sort of working in a SQL mindset.

00:47:47.640 --> 00:47:50.140
But there are a lot of similarities with Django still.

00:47:50.480 --> 00:47:52.480
I think people could pick it up quite quickly.

00:47:52.480 --> 00:47:53.180
Yeah, I agree.

00:47:53.180 --> 00:47:57.000
Like instead of object that values list, you have a select projection.

00:47:57.000 --> 00:47:59.320
Or instead of filter, you have a where.

00:47:59.320 --> 00:48:02.280
But it's honestly not a huge mental jump to make.

00:48:02.280 --> 00:48:02.580
Yeah.

00:48:02.580 --> 00:48:06.500
And Piccolo also takes like huge inspiration from Django migrations,

00:48:06.500 --> 00:48:10.980
which I think is kind of like the gold standard of migrations in any language.

00:48:10.980 --> 00:48:13.520
So a lot of effort's gone into that.

00:48:13.520 --> 00:48:13.800
Yeah.

00:48:13.800 --> 00:48:16.540
That's another one of the batteries that you were kind of touching on, right?

00:48:16.540 --> 00:48:18.120
Is the migrations bit.

00:48:18.440 --> 00:48:18.600
Yeah.

00:48:18.600 --> 00:48:21.580
But it's migrations are incredibly hard to do right.

00:48:21.580 --> 00:48:23.340
I think the Django way is.

00:48:23.340 --> 00:48:24.560
I can only imagine.

00:48:24.560 --> 00:48:28.220
I don't even want to try to imagine writing that because it seems really hard.

00:48:28.220 --> 00:48:28.660
Yeah.

00:48:28.660 --> 00:48:33.460
So the way Django does it is it looks at your tables and then it creates a migration file.

00:48:33.720 --> 00:48:38.540
It then adds up the migration files to build a picture of what the schema looks like.

00:48:38.540 --> 00:48:41.920
And then that's how it then creates subsequent migrations by doing a diff.

00:48:41.920 --> 00:48:42.180
Right.

00:48:42.180 --> 00:48:42.920
That's what Piccolo does.

00:48:42.920 --> 00:48:44.540
I've got to go from this level to that level.

00:48:44.540 --> 00:48:47.360
So here's the five migrations to basically use in order.

00:48:47.360 --> 00:48:48.060
Yeah.

00:48:48.380 --> 00:48:50.860
And then you've got to do code generation as well.

00:48:50.860 --> 00:48:53.580
So like with Piccolo, it has to actually create a Python file.

00:48:53.580 --> 00:48:56.700
And that's harder than what it seems actually writing a Python file.

00:48:56.700 --> 00:49:00.700
But if you look at the Piccolo migrations, they're actually really, they look like quite beautiful

00:49:00.700 --> 00:49:01.400
Python code.

00:49:01.400 --> 00:49:03.060
And there's a little trick I use internally.

00:49:03.060 --> 00:49:07.480
I use like the black formatter on it before I write out the auto-generated code.

00:49:07.480 --> 00:49:08.200
Oh, that's cool.

00:49:08.200 --> 00:49:11.080
So your generated code is pep8 and all the goodness.

00:49:11.080 --> 00:49:11.660
Yeah.

00:49:11.900 --> 00:49:14.340
So if you look at it, you're like, oh, that's quite nice.

00:49:14.340 --> 00:49:16.140
That's clever, actually.

00:49:16.140 --> 00:49:17.620
Yeah, that's really clever.

00:49:17.620 --> 00:49:18.480
Yeah, it's cool.

00:49:18.480 --> 00:49:18.820
Black.

00:49:18.820 --> 00:49:19.420
Yeah.

00:49:19.420 --> 00:49:19.860
Yeah.

00:49:19.860 --> 00:49:24.760
I feel like other frameworks, like for example, the cookie cutter stuff, you know, you're just

00:49:24.760 --> 00:49:26.600
generating code files like crazy.

00:49:26.600 --> 00:49:31.400
I feel like you could apply that same technique as after we inject all the user entered values,

00:49:31.400 --> 00:49:33.720
let's just do a quick format on them and then drop them.

00:49:33.720 --> 00:49:33.960
Yeah.

00:49:33.960 --> 00:49:38.920
It makes sense because otherwise you'll run your linters on your project and they'll fail because

00:49:38.920 --> 00:49:40.580
your migrations aren't correctly formatted.

00:49:40.580 --> 00:49:41.240
Yeah.

00:49:41.240 --> 00:49:41.580
Yeah.

00:49:41.880 --> 00:49:42.240
Yeah.

00:49:42.240 --> 00:49:42.820
No, that's cool.

00:49:42.820 --> 00:49:45.620
A quick question from Teddy out in the live stream.

00:49:45.620 --> 00:49:48.020
It says, I don't use ORMs much in my day-to-day.

00:49:48.020 --> 00:49:52.660
What are good use cases besides web apps for them and where does Piccolo perform better?

00:49:52.660 --> 00:49:53.800
So two questions.

00:49:53.800 --> 00:49:57.320
So I think that data science is obviously a big bit.

00:49:57.320 --> 00:50:02.300
So another reason for building Piccolo is data science is so much on the ascendancy in the

00:50:02.300 --> 00:50:06.680
Python world and people are just, you know, still dealing with databases on a day-to-day

00:50:06.680 --> 00:50:06.980
basis.

00:50:06.980 --> 00:50:11.420
So you can use it in a script if you like, but there's maybe a couple of examples in the docs

00:50:11.420 --> 00:50:15.900
where, you know, you might be scraping some data from a website and then you just need

00:50:15.900 --> 00:50:16.820
to stick into Postgres.

00:50:16.820 --> 00:50:19.400
So that would be another good example for using Piccolo.

00:50:19.400 --> 00:50:19.760
Yeah.

00:50:19.760 --> 00:50:20.800
That is a good example.

00:50:20.940 --> 00:50:22.240
And then where it performs better.

00:50:22.240 --> 00:50:28.340
It's really where you need the async or you might still want a web app component, even if

00:50:28.340 --> 00:50:32.340
it's just like a data science script, you still might want an admin screen to view that data.

00:50:32.340 --> 00:50:32.740
Yeah.

00:50:32.740 --> 00:50:34.140
I think that performs better.

00:50:34.140 --> 00:50:36.020
You could maybe break into two pieces.

00:50:36.020 --> 00:50:37.740
Where does Piccolo perform better?

00:50:37.840 --> 00:50:40.720
And I think the async stuff is really important there, like you say.

00:50:40.720 --> 00:50:43.020
And then where does an ORM perform better?

00:50:43.020 --> 00:50:47.720
You know, when you talk about performance and getting stuff done, like sometimes it's how

00:50:47.720 --> 00:50:51.440
fast is the code run, but sometimes it's how fast do I get the final thing built.

00:50:51.440 --> 00:50:51.920
Right.

00:50:52.260 --> 00:50:56.780
And I think ORMs, even if they're not always the most efficient way, sometimes they're really

00:50:56.780 --> 00:50:57.700
efficient, but not always.

00:50:57.700 --> 00:51:02.000
But, you know, they could help you safely get to the other side, especially if you don't

00:51:02.000 --> 00:51:03.220
know SQL super well.

00:51:03.220 --> 00:51:03.560
Yeah.

00:51:03.560 --> 00:51:04.920
They hold your hand a little bit.

00:51:04.920 --> 00:51:05.360
Yeah.

00:51:05.440 --> 00:51:09.260
I created this while working at a design agency and speed's really important at a design

00:51:09.260 --> 00:51:13.480
agency, not really execution speed in terms of SQL queries, but in terms of scaffolding

00:51:13.480 --> 00:51:15.000
an app and being productive.

00:51:15.000 --> 00:51:19.480
So there's, so Piccolo has something called Piccolo asking you, and then to use that command,

00:51:19.480 --> 00:51:21.020
it'll basically scaffold you a web app.

00:51:21.020 --> 00:51:24.080
So it supports FastAPI, Starlet, Blacksheep.

00:51:24.080 --> 00:51:24.820
Yeah, that's really cool.

00:51:24.820 --> 00:51:28.980
So yeah, it's, you just kind of create your starter code and your starter structure from that,

00:51:28.980 --> 00:51:29.180
right?

00:51:29.180 --> 00:51:29.520
Yeah.

00:51:29.520 --> 00:51:33.260
So a bit like with Django where you, you know, you create a project on the command line,

00:51:33.620 --> 00:51:36.420
but with Piccolo, you get an option of different ASCII frameworks.

00:51:36.420 --> 00:51:40.860
And over time, I'd like to add, you know, way more because there's, there's, there's

00:51:40.860 --> 00:51:45.500
many more exciting ASCII frameworks like Quart, Sanic, Django itself is actually an ASCII

00:51:45.500 --> 00:51:46.680
app, so it could support Django.

00:51:46.680 --> 00:51:47.260
Yeah.

00:51:47.260 --> 00:51:48.360
Django has come along there.

00:51:48.360 --> 00:51:54.000
So if people were out there listening and their favorite framework wasn't listed in one

00:51:54.000 --> 00:51:59.540
of those three or wasn't one of those three, PRs are accepted, I guess, and they could

00:51:59.540 --> 00:52:03.020
integrate, you know, their, their favorite Sanic or whatever they're after.

00:52:03.220 --> 00:52:03.660
Yeah, definitely.

00:52:03.660 --> 00:52:05.680
Like any feedback's really appreciated.

00:52:05.680 --> 00:52:09.360
So like the community has definitely helped me a lot with Piccolo, just, just as much as

00:52:09.360 --> 00:52:13.400
trying it and giving feedback or, you know, obviously pull requests are also like really

00:52:13.400 --> 00:52:13.880
valued.

00:52:13.880 --> 00:52:16.980
Even if you just want to raise an issue to say, well, how did you do this?

00:52:16.980 --> 00:52:19.040
Like, you know, that's still welcome.

00:52:19.040 --> 00:52:19.820
Yeah.

00:52:19.820 --> 00:52:20.320
Awesome.

00:52:20.320 --> 00:52:23.800
Well, well, maybe that's a good place to talk about where things are going in the future

00:52:23.800 --> 00:52:26.200
and kind of wrap up our conversation a bit.

00:52:26.360 --> 00:52:26.520
Yeah.

00:52:26.520 --> 00:52:31.380
So I feel like I'll never be bored with Piccolo because Postgres is continuously developing

00:52:31.380 --> 00:52:32.300
and adding new features.

00:52:32.300 --> 00:52:36.100
And I almost feel like Postgres is almost like an operating system in a way.

00:52:36.100 --> 00:52:38.240
Like the amount it does is kind of insane.

00:52:38.240 --> 00:52:41.140
So it even has like a PubSub built in.

00:52:41.140 --> 00:52:41.780
You can do that.

00:52:41.780 --> 00:52:42.420
Listen, notify.

00:52:42.420 --> 00:52:42.820
Oh, wow.

00:52:43.080 --> 00:52:44.680
I'd like to do post GIS support.

00:52:44.680 --> 00:52:49.980
Timescale DBs are really up and coming extension as well for Postgres for time series data.

00:52:49.980 --> 00:52:54.040
But then a lot of the stuff I'm excited about is like on the admin side.

00:52:54.040 --> 00:53:00.040
So as I mentioned before, Piccolo admin effectively turns Pydantic models into UI.

00:53:00.040 --> 00:53:06.300
So the next thing I want to add is you can basically give it arbitrary Pydantic models and it will

00:53:06.300 --> 00:53:07.820
render them as forms in the admin.

00:53:08.340 --> 00:53:13.240
So if you have, for example, you want to send an email, you'll just create send email model,

00:53:13.240 --> 00:53:15.540
give it to Piccolo admin and it'll generate a form.

00:53:15.540 --> 00:53:19.700
That's stuff I'm really excited about as well, just to increase the utility of Piccolo admin.

00:53:19.700 --> 00:53:24.620
So a backend developer could build a functional app for a business without actually writing any code.

00:53:24.620 --> 00:53:27.980
That's kind of the dream is to build like a really, really great admin.

00:53:27.980 --> 00:53:28.300
Yeah.

00:53:28.300 --> 00:53:28.920
Yeah.

00:53:28.920 --> 00:53:32.620
These self-serve, like once you create the app and hand it off,

00:53:32.780 --> 00:53:38.500
how far can people go before they have to hire your design agency again or something like that?

00:53:38.500 --> 00:53:40.820
The more that they can just run with it, the better, I suspect.

00:53:40.820 --> 00:53:41.300
Yeah.

00:53:41.300 --> 00:53:44.260
It's such a huge benefit from Django, like having that admin.

00:53:44.260 --> 00:53:49.400
So I just want to kind of see what I can do with the latest technologies to build a really great one.

00:53:49.400 --> 00:53:49.720
Yeah.

00:53:49.720 --> 00:53:52.200
What's the story with Django and Piccolo?

00:53:52.200 --> 00:53:57.300
Is there a reasonable way to click them together or is it really not so much so far?

00:53:57.300 --> 00:53:58.160
I think you can.

00:53:58.160 --> 00:54:01.040
I haven't really tried it much, but it's very configurable, Piccolo.

00:54:01.040 --> 00:54:04.880
So, you know, and none of the names, they deliberately don't clash with Django.

00:54:04.880 --> 00:54:09.600
So Django has a settings.py, Piccolo has a piccolo underscore conf.py.

00:54:09.600 --> 00:54:14.380
And then Django has a migrations folder, but Piccolo has piccolo underscore migrations.

00:54:14.380 --> 00:54:16.060
So there's no clash there.

00:54:16.060 --> 00:54:17.460
So in theory, they would work together.

00:54:17.460 --> 00:54:20.120
There's no like compatibility layer between the admins.

00:54:20.120 --> 00:54:25.460
So you'd have like two separate admins or, but I'd like to add support for Django as it is an ASGII app

00:54:25.460 --> 00:54:27.500
and it's the originator of the ASGII standard.

00:54:27.500 --> 00:54:32.300
And I still think Django is one of the great kind of masterpieces in the framework world.

00:54:32.300 --> 00:54:35.920
It's lasted so long and it's still such a rock solid choice.

00:54:35.920 --> 00:54:38.620
I would like to see what I can do there.

00:54:38.620 --> 00:54:38.920
Yeah.

00:54:38.920 --> 00:54:41.000
The closer those could be, I think, right?

00:54:41.000 --> 00:54:44.460
Like this having the genesis and so many similar ideas to Django,

00:54:44.460 --> 00:54:47.320
it seems like they should be somehow working together, which is great.

00:54:47.320 --> 00:54:48.060
Yeah, that'd be cool.

00:54:48.060 --> 00:54:48.600
All right.

00:54:48.600 --> 00:54:51.860
Well, Dan, I think that might be about it for time that we got.

00:54:51.860 --> 00:54:55.000
Let me ask you the final two questions that I always ask.

00:54:55.000 --> 00:54:56.920
If you're going to write some code, you can work on Piccolo.

00:54:56.920 --> 00:54:58.480
What editor to use?

00:54:58.480 --> 00:55:00.860
I think I caught a hint of it earlier, but go ahead.

00:55:00.860 --> 00:55:01.240
Yeah.

00:55:01.240 --> 00:55:02.180
VS Code all the way.

00:55:02.180 --> 00:55:04.880
I was a huge Sublime Text and TextMate user.

00:55:04.880 --> 00:55:07.980
And I was like, I'll try out this VS Code, see what all the hype's about.

00:55:07.980 --> 00:55:10.320
And after five minutes, I was never going back.

00:55:10.320 --> 00:55:13.360
I just think it's such a great gift to the world from Microsoft.

00:55:13.360 --> 00:55:16.160
It just gets better and better as well.

00:55:16.160 --> 00:55:16.460
Yeah.

00:55:16.460 --> 00:55:17.380
Love VS Code.

00:55:17.380 --> 00:55:17.840
Right on.

00:55:17.840 --> 00:55:21.040
And then notable PyPI package you want to give a shout out to?

00:55:21.160 --> 00:55:22.380
So I'm going to cheat and pick two.

00:55:22.380 --> 00:55:26.380
So Pydantic, because I think it's such a nice serialization library.

00:55:26.380 --> 00:55:28.980
And I think it could almost be in the standard library.

00:55:28.980 --> 00:55:30.860
It feels so Pyphonic and natural.

00:55:30.860 --> 00:55:36.880
And then Starlet, because I think it's just a beautiful foundation for the ASCII world.

00:55:37.040 --> 00:55:41.660
And I'd really encourage people to look at the code to see the power of ASCII, how it

00:55:41.660 --> 00:55:43.680
is this like turtles all the way down.

00:55:43.680 --> 00:55:44.900
Everything's ASCII.

00:55:44.900 --> 00:55:45.920
It is quite interesting.

00:55:45.920 --> 00:55:48.080
So those would be my two shout outs.

00:55:48.080 --> 00:55:48.380
Yeah.

00:55:48.380 --> 00:55:48.780
Very cool.

00:55:48.780 --> 00:55:53.940
You know, FastAPI is so popular now, but FastAPI is kind of like an opinionated view on top of

00:55:53.940 --> 00:55:55.200
Starlette to a large degree.

00:55:55.200 --> 00:55:55.860
Yeah.

00:55:55.860 --> 00:55:57.160
FastAPI is great as well.

00:55:57.160 --> 00:55:57.580
Yeah.

00:55:57.580 --> 00:56:01.300
Well, I mean, it takes the two things you said, Pydantic and Starlet, and puts them together

00:56:01.300 --> 00:56:03.520
in like a nice way, which I think is pretty neat.

00:56:03.520 --> 00:56:03.760
Yeah.

00:56:03.760 --> 00:56:04.540
It's got great taste.

00:56:05.820 --> 00:56:06.560
Yeah, for sure.

00:56:06.560 --> 00:56:09.740
I'd just like to say one thing really quick, and just thanks to everyone who's contributed

00:56:09.740 --> 00:56:13.160
to Piccolo, because there's been people who've been contributing for several years by this

00:56:13.160 --> 00:56:15.040
point and have put a lot of work in.

00:56:15.040 --> 00:56:17.940
So yeah, just a shout out to anyone in the Piccolo community.

00:56:17.940 --> 00:56:18.780
Yeah.

00:56:18.780 --> 00:56:22.060
And, you know, Final Call to Action, people are interested in using this.

00:56:22.060 --> 00:56:23.360
It's good to go.

00:56:23.360 --> 00:56:26.100
It's ready for production, web apps, and all that kind of stuff.

00:56:26.100 --> 00:56:28.000
I didn't really want to promote it before it was ready.

00:56:28.000 --> 00:56:29.100
And I use it in production.

00:56:29.100 --> 00:56:29.960
I have done for years.

00:56:29.960 --> 00:56:34.000
And I am quite conservative about pushing stuff out there, unless I think it's, you know, solid.

00:56:34.400 --> 00:56:35.900
It's got 100 unit tests.

00:56:35.900 --> 00:56:37.740
You know, it's solid.

00:56:37.740 --> 00:56:42.100
I'm not saying there's not some edge case I haven't discovered yet in some version of,

00:56:42.100 --> 00:56:43.380
you know, Postgres or something.

00:56:43.380 --> 00:56:45.440
But I use it in production every single day.

00:56:45.440 --> 00:56:49.140
Well, congrats on building a really cool Pythonic ORM.

00:56:49.140 --> 00:56:51.860
I really like the way that you put things together.

00:56:51.860 --> 00:56:53.540
And yeah, it looks great.

00:56:53.540 --> 00:56:56.340
It's got a lot of nice modern Python features.

00:56:56.680 --> 00:56:57.960
And people should definitely check it out.

00:56:57.960 --> 00:56:58.160
Cool.

00:56:58.160 --> 00:56:58.420
Yeah.

00:56:58.420 --> 00:56:59.080
Thanks a lot, Michael.

00:56:59.080 --> 00:56:59.460
Yeah.

00:56:59.460 --> 00:56:59.740
You bet.

00:56:59.740 --> 00:57:00.440
See you later.

00:57:00.440 --> 00:57:00.780
Yes.

00:57:00.780 --> 00:57:01.000
Bye.

00:57:02.180 --> 00:57:04.840
This has been another episode of Talk Python to Me.

00:57:04.840 --> 00:57:07.440
Our guest on this episode was Daniel Townsend.

00:57:07.440 --> 00:57:10.660
And it's been brought to you by Linode and us over at Talk Python Training.

00:57:10.660 --> 00:57:13.420
And the transcripts are brought to you by Assembly AI.

00:57:13.420 --> 00:57:18.840
Simplify your infrastructure and cut your cloud bills in half with Linode's Linux virtual machines.

00:57:18.840 --> 00:57:22.200
Develop, deploy, and scale your modern applications faster and easier.

00:57:22.200 --> 00:57:24.820
Visit talkpython.fm/Linode.

00:57:24.820 --> 00:57:27.180
And click the create free account button to get started.

00:57:28.140 --> 00:57:31.720
Transcripts for this and all of our episodes are brought to you by Assembly AI.

00:57:31.720 --> 00:57:34.400
Do you need a great automatic speech-to-text API?

00:57:34.400 --> 00:57:36.940
Get human-level accuracy in just a few lines of code.

00:57:36.940 --> 00:57:39.780
Visit talkpython.fm/assembly AI.

00:57:39.780 --> 00:57:41.560
Want to level up your Python?

00:57:41.560 --> 00:57:45.700
We have one of the largest catalogs of Python video courses over at Talk Python.

00:57:45.700 --> 00:57:50.800
Our content ranges from true beginners to deeply advanced topics like memory and async.

00:57:50.800 --> 00:57:53.460
And best of all, there's not a subscription in sight.

00:57:53.460 --> 00:57:56.380
Check it out for yourself at training.talkpython.fm.

00:57:56.800 --> 00:57:58.260
Be sure to subscribe to the show.

00:57:58.260 --> 00:58:01.040
Open your favorite podcast app and search for Python.

00:58:01.040 --> 00:58:02.360
We should be right at the top.

00:58:02.360 --> 00:58:07.500
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

00:58:07.500 --> 00:58:11.720
and the direct RSS feed at /rss on talkpython.fm.

00:58:11.720 --> 00:58:15.140
We're live streaming most of our recordings these days.

00:58:15.140 --> 00:58:18.560
If you want to be part of the show and have your comments featured on the air,

00:58:18.560 --> 00:58:23.000
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

00:58:23.000 --> 00:58:24.820
This is your host, Michael Kennedy.

00:58:25.120 --> 00:58:26.120
Thanks so much for listening.

00:58:26.120 --> 00:58:27.280
I really appreciate it.

00:58:27.280 --> 00:58:29.200
Now get out there and write some Python code.

00:58:29.200 --> 00:58:29.800
Thank you.

00:58:29.800 --> 00:58:30.800
Bye.

00:58:30.800 --> 00:58:31.800
Bye.

00:58:31.800 --> 00:58:32.800
Bye.

00:58:32.800 --> 00:58:33.800
Bye.

00:58:33.800 --> 00:58:34.800
Bye.

00:58:34.800 --> 00:58:34.800
Bye.

00:58:34.800 --> 00:58:35.800
Bye.

00:58:35.800 --> 00:58:36.800
Bye.

00:58:36.800 --> 00:58:36.800
Bye.

00:58:36.800 --> 00:58:36.800
Bye.

00:58:36.800 --> 00:58:36.800
Bye.

00:58:36.800 --> 00:58:37.800
Bye.

00:58:37.800 --> 00:58:37.800
Bye.

00:58:37.800 --> 00:58:38.800
Bye.

00:58:38.800 --> 00:58:38.800
Bye.

00:58:38.800 --> 00:58:38.800
Bye.

00:58:38.800 --> 00:58:38.800
Bye.

00:58:38.800 --> 00:58:39.800
Bye.

00:58:39.800 --> 00:58:39.800
Bye.

00:58:39.800 --> 00:58:39.800
Bye.

00:58:39.800 --> 00:58:40.800
Bye.

00:58:40.800 --> 00:58:40.800
Bye.

00:58:40.800 --> 00:58:41.800
Bye.

00:58:41.800 --> 00:58:42.800
Bye.

00:58:42.800 --> 00:58:42.800
Bye.

00:58:42.800 --> 00:58:42.800
Bye.

00:58:42.800 --> 00:58:43.800
Bye.

00:58:43.800 --> 00:58:44.800
Bye.

00:58:44.800 --> 00:58:44.800
Bye.

00:58:44.800 --> 00:58:45.800
Bye.

00:58:45.800 --> 00:58:46.800
Bye.

00:58:46.800 --> 00:58:46.800
Bye.

00:58:46.800 --> 00:58:47.800
Bye.

00:58:47.800 --> 00:58:49.800
Thank you.

00:58:49.800 --> 00:59:19.780
Thank you.

