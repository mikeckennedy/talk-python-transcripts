WEBVTT

00:00:00.001 --> 00:00:06.200
We've evolved from, if it builds, ship it, to continuous integration, where every check-in

00:00:06.200 --> 00:00:09.340
is automatically verified by something like Travis CI.

00:00:09.340 --> 00:00:14.260
Taking that further, some people today are using continuous delivery.

00:00:14.260 --> 00:00:19.740
This means once a check-in is validated by the CI system, it's deployed automatically.

00:00:19.740 --> 00:00:22.300
There are many moving parts in these processes.

00:00:22.300 --> 00:00:27.540
On this episode, you'll meet Chris Medina, who has put together a world-class CI CD system.

00:00:27.720 --> 00:00:31.520
And he's here to share how he did it and what tools and libraries are involved.

00:00:31.520 --> 00:00:36.920
This is Talk Python to Me, episode 166, recorded June 11th, 2018.

00:00:36.920 --> 00:00:55.880
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the

00:00:55.880 --> 00:00:57.400
ecosystem, and the personalities.

00:00:57.400 --> 00:00:59.520
This is your host, Michael Kennedy.

00:00:59.520 --> 00:01:01.520
Follow me on Twitter, where I'm @mkennedy.

00:01:01.520 --> 00:01:05.420
Keep up with the show and listen to past episodes at talkpython.fm.

00:01:05.420 --> 00:01:07.940
And follow the show on Twitter via at Talk Python.

00:01:07.940 --> 00:01:11.580
This episode is sponsored by Linode and Rollbar.

00:01:11.580 --> 00:01:13.800
Please check out what they're offering during their segments.

00:01:13.800 --> 00:01:15.340
It really helps support the show.

00:01:15.340 --> 00:01:17.480
Chris, welcome to Talk Python.

00:01:17.480 --> 00:01:17.860
Hi.

00:01:17.860 --> 00:01:18.620
How's it going?

00:01:18.620 --> 00:01:19.560
Glad to be here.

00:01:19.560 --> 00:01:20.340
It's going great.

00:01:20.520 --> 00:01:21.640
Yeah, I'm happy to have you here.

00:01:21.640 --> 00:01:27.080
It feels like we were just hanging out in Cleveland just a little while ago, right?

00:01:27.080 --> 00:01:28.200
Just a little bit ago.

00:01:28.200 --> 00:01:31.080
Yeah, everybody's scattered back to where they came from.

00:01:31.080 --> 00:01:33.140
And it's sad that PyCon is over.

00:01:33.140 --> 00:01:35.400
But that was really fun to spend some time together there.

00:01:35.400 --> 00:01:36.080
Yeah, for sure.

00:01:36.080 --> 00:01:38.320
It was great to meet the PyBytes guys, too.

00:01:38.320 --> 00:01:39.140
I hadn't met them before.

00:01:39.140 --> 00:01:39.920
So that was pretty cool.

00:01:39.920 --> 00:01:42.020
Yeah, they traveled quite far to get there.

00:01:42.020 --> 00:01:43.220
From both sides of the globe.

00:01:43.220 --> 00:01:46.580
So, yeah, I mean, PyCon is such a special place.

00:01:46.580 --> 00:01:49.860
And PyCon US seems to be where the most gravity is.

00:01:49.860 --> 00:01:52.060
I know EuroPython is also large.

00:01:52.060 --> 00:01:55.020
But I feel like that PyCon US is probably the biggest.

00:01:55.020 --> 00:01:56.820
Just get the sense that I get.

00:01:56.820 --> 00:02:02.000
Anyway, I think just, you know, recommend that people next year, if they didn't get a chance

00:02:02.000 --> 00:02:03.100
to go, definitely go.

00:02:03.100 --> 00:02:04.100
Like, wouldn't you say?

00:02:04.100 --> 00:02:04.740
Did you have a good time?

00:02:04.740 --> 00:02:05.620
Yeah, definitely.

00:02:05.620 --> 00:02:09.180
So, like, I started doing PyCon maybe three years ago now.

00:02:09.320 --> 00:02:15.060
And it's definitely been a lot more interesting to so much stuff from so many different people

00:02:15.060 --> 00:02:17.820
doing so many different things with the language.

00:02:17.820 --> 00:02:21.480
Because Python has such a wide usage.

00:02:21.480 --> 00:02:24.920
It's just great to just be out there and just see what everybody's doing at.

00:02:24.920 --> 00:02:29.760
And I like just hanging out in the expo hall and just kind of just talking to everybody.

00:02:29.760 --> 00:02:31.140
So you're like, oh, what do you do with Python?

00:02:31.140 --> 00:02:38.700
And definitely the open sessions, people don't quite, you know, understand how cool that is

00:02:38.700 --> 00:02:42.720
versus, you know, your average conference where everything is just kind of like pre-configured

00:02:42.720 --> 00:02:43.020
for you.

00:02:43.020 --> 00:02:43.480
Yeah, definitely.

00:02:43.480 --> 00:02:46.060
Both you and I ran some open sessions, right?

00:02:46.060 --> 00:02:46.600
That's true.

00:02:46.600 --> 00:02:47.200
Yep.

00:02:47.200 --> 00:02:47.440
Yeah.

00:02:47.440 --> 00:02:48.220
What were yours on?

00:02:48.220 --> 00:02:48.800
I did two.

00:02:48.800 --> 00:02:53.500
I did one on just blogging and stuff, folks that are creators for Python.

00:02:53.500 --> 00:03:00.560
And I did one on virtual reality, augmented reality, and to see how, you know, experiences

00:03:00.560 --> 00:03:03.340
with people and Python and that type of stuff with those environments.

00:03:03.340 --> 00:03:04.480
Yeah, that's pretty awesome.

00:03:05.140 --> 00:03:09.340
So now that you're back to doing what you do day to day, maybe we could get your story

00:03:09.340 --> 00:03:09.840
and your background.

00:03:09.840 --> 00:03:12.640
Like, tell us how you got into programming in Python and what you do day to day.

00:03:12.640 --> 00:03:14.340
My story is more like a classic story.

00:03:14.340 --> 00:03:16.760
Dad grew up doing software.

00:03:16.760 --> 00:03:18.080
He had a consulting business.

00:03:18.080 --> 00:03:23.040
There's stories of two-year-old Chris sitting in his lap typing in the keyboard somehow.

00:03:23.040 --> 00:03:25.440
Not that any of that was intelligible, obviously.

00:03:25.440 --> 00:03:29.480
But yeah, so he started stuff with old IBM systems.

00:03:30.080 --> 00:03:33.720
Like, you know, monochrome monitor, eight and a half inch floppy integrated keyboard,

00:03:33.720 --> 00:03:34.620
no hard drive things.

00:03:34.620 --> 00:03:35.320
No hard drive.

00:03:35.320 --> 00:03:37.840
That still blows my mind that computers came with no hard drives.

00:03:37.840 --> 00:03:38.180
Yeah.

00:03:38.180 --> 00:03:43.660
So I remember the first time I actually got an idea of what, like, software was.

00:03:43.660 --> 00:03:50.660
It's because my dad wrote something for me to sit in front of his computer and learn the

00:03:50.660 --> 00:03:51.180
times tables.

00:03:52.360 --> 00:03:57.780
And it was just a short little program, but I could go into the program and fiddle with it.

00:03:57.780 --> 00:03:59.360
So I was really young for that.

00:03:59.360 --> 00:04:00.740
And I still remember it.

00:04:00.740 --> 00:04:01.240
It was pretty cool.

00:04:01.240 --> 00:04:02.700
It was an IBM system 23.

00:04:02.700 --> 00:04:03.940
Nice.

00:04:03.940 --> 00:04:08.400
Would it, like, randomly pick, like, two numbers, multiple, you know, and ask you what the answer

00:04:08.400 --> 00:04:10.300
was and say you got it right or wrong, basically?

00:04:10.300 --> 00:04:10.780
Pretty much.

00:04:10.780 --> 00:04:11.480
That's pretty nice.

00:04:11.480 --> 00:04:13.020
Like interactive flashcards, basically.

00:04:13.020 --> 00:04:17.740
I remember doing a data entry forum back in the days where you can't slurp anything in

00:04:17.740 --> 00:04:19.860
from any APIs or anything like that, right?

00:04:19.860 --> 00:04:23.480
Somebody would just hand deliver an invoice and you had to type it into the computer.

00:04:23.480 --> 00:04:28.300
When computers were not actually connected to anything, they were just there on a desk.

00:04:28.300 --> 00:04:28.900
How weird, right?

00:04:28.900 --> 00:04:29.000
Right.

00:04:29.000 --> 00:04:29.760
Exactly.

00:04:29.760 --> 00:04:34.220
So some of the first stuff I did was system 360 basic.

00:04:34.220 --> 00:04:40.080
My hello world was like a menu for, like, opening an invoicing app or something like that.

00:04:40.080 --> 00:04:45.840
Back when you had to type line numbers and make sure you left enough room between them in

00:04:45.840 --> 00:04:47.460
case you needed to add more lines before.

00:04:47.460 --> 00:04:48.300
Yeah, that's right.

00:04:48.300 --> 00:04:51.320
Like, if people don't know this, that used to be a big deal.

00:04:51.320 --> 00:04:56.200
So it used to say, you know, 10 would be like a line number and you would put a command and

00:04:56.200 --> 00:04:57.620
then 20, you'd put like another.

00:04:57.620 --> 00:05:02.400
And the reason it didn't go one, two, three is you might have to do 11, 12, and 13 someday

00:05:02.400 --> 00:05:04.300
and you don't have to rewrite the whole program.

00:05:04.300 --> 00:05:07.940
It's so insane that you had to explicitly call out the line numbers.

00:05:08.040 --> 00:05:14.040
But I guess with like the go to navigate, like a sort of branching mechanism, you had to say

00:05:14.040 --> 00:05:14.980
go to this line.

00:05:14.980 --> 00:05:17.060
So it had to be really clear what line that was.

00:05:17.060 --> 00:05:17.400
Yep.

00:05:17.400 --> 00:05:19.200
And then we added go sub.

00:05:19.200 --> 00:05:19.880
Oh, man.

00:05:19.880 --> 00:05:21.800
I was advanced concepts right there.

00:05:21.800 --> 00:05:22.020
Huh?

00:05:23.960 --> 00:05:25.600
That was amazing.

00:05:25.600 --> 00:05:26.960
All right.

00:05:26.960 --> 00:05:27.840
So you started there.

00:05:27.840 --> 00:05:29.520
Like, did you go and get a computer science degree?

00:05:29.520 --> 00:05:31.320
So I did computer engineering.

00:05:31.320 --> 00:05:36.900
I actually was like, well, I kind of halfway understand at least some of the software stuff.

00:05:36.900 --> 00:05:38.860
So let me see what all the software is built on.

00:05:38.980 --> 00:05:41.920
And I went off and figured out how to do hardware.

00:05:41.920 --> 00:05:46.060
So I did computer hardware, computer architecture, that type of stuff.

00:05:46.060 --> 00:05:51.160
And, you know, from there I went into IBM, which was the first guys that hired me.

00:05:51.160 --> 00:05:54.820
So I spent many, many years with IBM doing systems tests.

00:05:54.820 --> 00:05:56.660
Were you doing hardware stuff for IBM?

00:05:56.660 --> 00:05:59.860
I was on the side of we developed a new server.

00:05:59.860 --> 00:06:04.240
It would come into our organization and we ran validation on it.

00:06:04.240 --> 00:06:08.140
So before I made it out to the customer, we would go and check a bunch of things.

00:06:08.140 --> 00:06:11.740
Like it was gigantic organization, tens of thousands of tests that would execute.

00:06:11.740 --> 00:06:16.460
So we had like a small piece of that that had like integration with more on the integration

00:06:16.460 --> 00:06:20.340
level of the server with the firmware and the hardware.

00:06:20.340 --> 00:06:26.940
So I'd have to do hardware tools that I'd have to code and say like some sort of what is today

00:06:26.940 --> 00:06:28.460
embedded systems, right?

00:06:28.460 --> 00:06:33.640
All the way up to like high level software tools to, you know, maybe interface with that stuff

00:06:33.640 --> 00:06:37.460
or even business apps too, which was the biggest thing I wound up doing,

00:06:37.460 --> 00:06:42.260
which was kind of a management system for keeping track of all our test organizations and stuff,

00:06:42.260 --> 00:06:47.760
including status reporting, test execution, procedures, all that type of stuff.

00:06:47.760 --> 00:06:48.740
That sounds pretty interesting.

00:06:48.740 --> 00:06:52.860
I don't know a whole lot about the hardware side of computers.

00:06:52.860 --> 00:06:59.440
I mean, obviously I have some concepts, but like I couldn't, you know, design RAM or anything like that.

00:06:59.740 --> 00:07:00.040
Right.

00:07:00.040 --> 00:07:04.380
It's just, that's always, that's sort of like where, you know, the Darby Dragons sort of aspect

00:07:04.380 --> 00:07:05.480
of programming is for me.

00:07:05.480 --> 00:07:09.820
Like I have a conceptual idea of it and I don't know how close that is to reality.

00:07:09.820 --> 00:07:12.700
So it's, it's pretty cool that you kind of get a bridge to that world.

00:07:12.700 --> 00:07:13.040
Yeah.

00:07:13.120 --> 00:07:16.780
So some of the most interesting, so why some of this stuff is important too,

00:07:16.780 --> 00:07:21.320
is because you get to understand a little more, some of the more recent security things called

00:07:21.320 --> 00:07:22.800
Rowhammer, if you've heard about that.

00:07:22.800 --> 00:07:23.220
Oh yeah.

00:07:23.220 --> 00:07:24.560
Tell people what Rowhammer is.

00:07:24.620 --> 00:07:33.620
So Rowhammer is a way of essentially kind of hacking your machine to run code by accessing

00:07:33.620 --> 00:07:39.800
certain parts of memory at certain speeds such that you would make an adjacent memory cell

00:07:39.800 --> 00:07:44.120
have the data that you wanted or the code that you wanted to execute.

00:07:44.120 --> 00:07:49.080
And then maybe that adjacent memory cell is the one that's in like the privileged memory.

00:07:49.080 --> 00:07:49.640
I see.

00:07:49.640 --> 00:07:51.100
That's so tricky.

00:07:51.220 --> 00:07:55.560
Does it use like a cache hits and misses and stuff like that?

00:07:55.560 --> 00:07:57.960
Are there the prefetch stuff or where, where does that come from?

00:07:57.960 --> 00:08:03.900
So this is actually winds up in your actual, so it's a, it's a general problem with DDR3 in

00:08:03.900 --> 00:08:04.300
general.

00:08:04.300 --> 00:08:12.160
So anything that has a DRAM from DDR3, you could do that in as long as the refresh rates, you

00:08:12.160 --> 00:08:16.240
know, memory, your processor kind of controls how often memory is refreshed.

00:08:16.240 --> 00:08:20.320
So it would go in and blank out, you know, whatever charge is accumulated.

00:08:20.560 --> 00:08:26.400
So if your refresh rates are, if you wait a long time between refreshing, you have a larger

00:08:26.400 --> 00:08:28.940
window in which you can get in and make those changes.

00:08:28.940 --> 00:08:30.980
So, so it'll actually happen on your DIMMs.

00:08:30.980 --> 00:08:31.460
Oh, wow.

00:08:31.460 --> 00:08:32.340
These are crazy ideas.

00:08:32.340 --> 00:08:35.620
Like we're seeing a couple of these, right?

00:08:35.620 --> 00:08:39.640
So there's a row hammer, there's spectra, there's meltdown.

00:08:39.640 --> 00:08:42.920
I mean, these are like not even software problems, right?

00:08:42.920 --> 00:08:44.240
These are down in the chips.

00:08:44.240 --> 00:08:44.600
Yeah.

00:08:44.840 --> 00:08:48.260
So then the other, the other ones you mentioned are down at the processor level.

00:08:48.260 --> 00:08:55.280
And a lot of things, a lot of those are because optimizations to trying and execute instructions

00:08:55.280 --> 00:08:56.380
faster.

00:08:56.620 --> 00:09:01.660
And the way, the way that processor pipelines work, you want to prefetch some information.

00:09:01.660 --> 00:09:06.680
So I know some, I know one of them, I don't remember which one, which one was what, but I

00:09:06.680 --> 00:09:09.920
know one of them was more related to branch prediction.

00:09:09.920 --> 00:09:14.200
So if you, if you're going through code and you have an if then else kind of thing, it'll

00:09:14.200 --> 00:09:18.860
prefetch both sides of your if, whether it meets the condition or it doesn't.

00:09:18.860 --> 00:09:25.080
And then you can play with that a little bit and have it prefetch some memory information

00:09:25.080 --> 00:09:31.340
that, or data that, you know, it shouldn't have because it's at such a low level, stuff

00:09:31.340 --> 00:09:31.720
like that.

00:09:31.720 --> 00:09:32.020
Yeah.

00:09:32.020 --> 00:09:32.440
It's crazy.

00:09:32.440 --> 00:09:32.780
Yeah.

00:09:32.780 --> 00:09:33.740
It's going to be interesting.

00:09:33.740 --> 00:09:38.220
I think we'll probably see more of those types of things, but it, you know, it really gets

00:09:38.220 --> 00:09:41.520
scary when you mix that with cloud computing and we're going to talk about cloud computing

00:09:41.520 --> 00:09:42.280
a lot, actually.

00:09:42.280 --> 00:09:46.820
So maybe start with, yeah, maybe start with what you do day to day, let people know what

00:09:46.820 --> 00:09:47.280
you're working on.

00:09:47.280 --> 00:09:52.940
So I'm part of a small group of folks that worked for a company called Nimble Storage that was

00:09:52.940 --> 00:09:55.540
acquired by Hewlett Packard Enterprises last year.

00:09:55.540 --> 00:09:58.380
And Nimble makes storage arrays.

00:09:58.380 --> 00:10:05.060
So as in external enclosures where you have a bunch of hard drives that you access through

00:10:05.060 --> 00:10:06.460
iSCSI or Fiber Channel.

00:10:06.460 --> 00:10:07.860
And these are for like data centers, right?

00:10:07.900 --> 00:10:10.720
These are not like NAS for your home, are they?

00:10:10.720 --> 00:10:11.200
Right.

00:10:11.200 --> 00:10:12.620
These are built for data centers.

00:10:12.620 --> 00:10:18.060
So these are expensive things that have a performance, you know, way higher performance that you get

00:10:18.060 --> 00:10:19.580
something out of a consumer product.

00:10:19.580 --> 00:10:22.920
And so they have a bunch of systems management and stuff around that as well.

00:10:22.920 --> 00:10:31.040
And a bunch of guarantees in terms of data savings due to deduplication or compression and

00:10:31.040 --> 00:10:32.460
things like that.

00:10:32.460 --> 00:10:36.500
Enterprise class features, snapshotting and things of that nature.

00:10:36.500 --> 00:10:36.680
Okay.

00:10:36.680 --> 00:10:38.200
So nice.

00:10:38.200 --> 00:10:43.180
So if you run like a hundred VMs, like most of the OS is probably the same across all of

00:10:43.180 --> 00:10:43.280
them.

00:10:43.280 --> 00:10:45.900
You just need that one copy of those files.

00:10:45.900 --> 00:10:46.360
Right.

00:10:46.360 --> 00:10:47.640
So we do instant snapshots.

00:10:47.640 --> 00:10:51.580
So if you, if you have a virtual machine, so one of the use cases is say you have like

00:10:51.580 --> 00:10:55.500
a database in a virtual machine with like, say your database in it, and that's all contained

00:10:55.500 --> 00:10:58.060
in a couple volumes of which you can group together.

00:10:58.500 --> 00:11:05.300
You can go in and say snapshot that and it happens like instantly and then spit off a

00:11:05.300 --> 00:11:08.680
new VM based off of that, those volumes you just made over there.

00:11:08.680 --> 00:11:10.520
And now you have a copy of your data essentially.

00:11:10.980 --> 00:11:12.420
And it keeps track of the diffs.

00:11:12.420 --> 00:11:17.660
So it's kind of like a, if you, if you bring it back to the software world, it feels a little

00:11:17.660 --> 00:11:19.960
bit like you were playing with Git really.

00:11:20.200 --> 00:11:26.040
And, or Docker where you have like a special commits, which have your data.

00:11:26.040 --> 00:11:30.160
And then you have the diffs of your data into the next set of commits kind of thing.

00:11:30.160 --> 00:11:35.620
So when you do your snapshots and your clones, instead of having a, an entire duplicate of

00:11:35.620 --> 00:11:38.700
all of the data, you only have the difference that you write afterwards.

00:11:38.700 --> 00:11:40.880
So that's also pretty helpful.

00:11:40.880 --> 00:11:42.600
So those are the arrays that we make.

00:11:42.600 --> 00:11:46.180
And so one of the things that we're kind of experimenting with cloud stuff, we decided

00:11:46.180 --> 00:11:49.160
to go off and built what is cloud volumes.

00:11:49.960 --> 00:11:52.300
So the product is called HPE Cloud Volumes.

00:11:52.300 --> 00:11:59.940
We can, and the purpose is if you have a, an Azure or an AWS virtual machine and you want

00:11:59.940 --> 00:12:07.840
to tie it to some of our storage arrays, you can go to the website and request volume of

00:12:07.840 --> 00:12:15.240
certain size and other characteristics along with it and configure it so you can plug it into

00:12:15.240 --> 00:12:16.060
your, your VM.

00:12:16.060 --> 00:12:17.220
That's pretty interesting.

00:12:17.360 --> 00:12:23.440
So tell me why would I like pick that say, instead of just like creating a volume in AWS

00:12:23.440 --> 00:12:26.060
or Azure in their mechanism, right?

00:12:26.060 --> 00:12:26.420
Right.

00:12:26.420 --> 00:12:29.060
So one of the main things is that you can go cross cloud.

00:12:29.060 --> 00:12:34.000
So you could have your volume that you made with say your Mongo data or something.

00:12:34.780 --> 00:12:39.440
And, you know, it's attached to your AWS, but you know, if you're running a super critical

00:12:39.440 --> 00:12:45.540
application and say your AWS region goes down, you can just clone that volume and attach it

00:12:45.540 --> 00:12:49.020
to Azure and you can use it on Azure side of the world.

00:12:49.240 --> 00:12:56.040
The other thing you get out of it is we can do a higher IOPS when talking, when, when doing

00:12:56.040 --> 00:13:01.840
the IOPS is a measure of how many storage operations, IO operations you do on your drives over the

00:13:01.840 --> 00:13:02.120
array.

00:13:02.120 --> 00:13:04.880
Then you can get out of a regular EBS.

00:13:04.880 --> 00:13:11.280
And as far as I understand the instance snapshots as well, I forget if EBS does instance snapshots

00:13:11.280 --> 00:13:11.680
or not.

00:13:12.160 --> 00:13:13.080
I don't think they do.

00:13:13.080 --> 00:13:14.960
So you also get that ability.

00:13:14.960 --> 00:13:21.560
There's also extra stuff that we provide for our actual physical enclosure customers.

00:13:21.560 --> 00:13:27.120
So if you own one of our physical arrays, you can actually replicate your data up into the

00:13:27.120 --> 00:13:28.900
cloud through our service.

00:13:28.900 --> 00:13:32.300
And you don't have to worry about the ingress costs through AWS or Azure.

00:13:32.300 --> 00:13:37.080
So we provide a way of seeding information out to say different regions and things like that

00:13:37.080 --> 00:13:37.380
as well.

00:13:37.380 --> 00:13:38.240
Oh, that's pretty interesting.

00:13:38.240 --> 00:13:39.800
Cause yeah, that can get pricey real quick.

00:13:39.800 --> 00:13:40.420
Yes, it can.

00:13:40.420 --> 00:13:40.740
Yep.

00:13:40.740 --> 00:13:41.760
Yes, definitely.

00:13:41.900 --> 00:13:45.060
I know a little bit about bandwidth charges and whatnot.

00:13:45.060 --> 00:13:48.240
I think last month I paid $600 in AWS bandwidth.

00:13:48.240 --> 00:13:49.340
Oh, geez, man.

00:13:49.340 --> 00:13:50.260
You're getting lots of downloads.

00:13:50.260 --> 00:13:50.660
Woo.

00:13:50.660 --> 00:13:52.800
No, these are good problems to have, but that's a lot of bandwidth.

00:13:52.800 --> 00:13:58.400
This portion of Talk Python To Me is brought to you by Linode.

00:13:58.400 --> 00:14:02.340
Are you looking for bulletproof hosting that's fast, simple, and incredibly affordable?

00:14:02.340 --> 00:14:07.260
Look past that bookstore and check out Linode at talkpython.fm/Linode.

00:14:07.260 --> 00:14:09.180
That's L-I-N-O-D-E.

00:14:09.580 --> 00:14:13.660
Plans start at just $5 a month for a dedicated server with a gig of RAM.

00:14:13.660 --> 00:14:18.000
They have 10 data centers across the globe.

00:14:18.000 --> 00:14:18.660
They're going to run a lot of data center near you.

00:14:18.660 --> 00:14:23.940
Whether you want to run your Python web app, host a private Git server, or file server,

00:14:23.940 --> 00:14:31.040
you'll get native SSDs on all the machines, a newly upgraded 200 gigabit network, 24-7 friendly

00:14:31.040 --> 00:14:34.060
support, even on holidays, and a seven-day money-back guarantee.

00:14:34.060 --> 00:14:36.380
Do you need a little help with your infrastructure?

00:14:36.940 --> 00:14:42.120
They even offer professional services to help you get started with architecture, migrations,

00:14:42.120 --> 00:14:42.600
and more.

00:14:42.600 --> 00:14:45.700
Get a dedicated server for free for the next four months.

00:14:45.700 --> 00:14:48.540
Just visit talkpython.fm/Linode.

00:14:48.540 --> 00:14:55.720
Another thing you do is you spend a little time writing some fairly popular articles on

00:14:55.720 --> 00:14:56.160
your blog.

00:14:56.160 --> 00:15:00.040
I know because Brian and I end up covering them often on Python Bytes.

00:15:00.040 --> 00:15:01.620
Yeah, no, I appreciate that too.

00:15:01.620 --> 00:15:04.220
So I don't know if it's like a chicken before the egg thing.

00:15:04.280 --> 00:15:07.400
It's like something comes up a little bit, but then you guys post it up, and then it gets

00:15:07.400 --> 00:15:08.100
a lot more reads.

00:15:08.100 --> 00:15:17.800
But yeah, so I have tryacceptpass.org, and we do the posts include a bunch of stuff, usually

00:15:17.800 --> 00:15:18.720
things I play with.

00:15:18.720 --> 00:15:23.020
Most of the articles that get the most views usually are how-tos.

00:15:23.020 --> 00:15:28.400
I try to do a lot on async.io stuff because I'm trying to do more async.io, and that is not

00:15:28.400 --> 00:15:30.500
an easy concept as it is today in Python.

00:15:30.500 --> 00:15:34.260
Yeah, the work that you're doing there is really nice because I feel like that's a lot of

00:15:34.260 --> 00:15:37.520
areas where there's really not very much coverage.

00:15:37.520 --> 00:15:42.800
I'm definitely planning on writing a course on async.io because I feel like either people

00:15:42.800 --> 00:15:47.020
are just, they know about it and they're confused, or like, ah, it's too hard, or they just don't

00:15:47.020 --> 00:15:47.940
even know, right?

00:15:47.940 --> 00:15:52.640
They're like, I'm switching to Go because Go has better async than Python, but you don't

00:15:52.640 --> 00:15:53.000
understand.

00:15:53.000 --> 00:15:53.720
It does too.

00:15:53.720 --> 00:15:54.580
You're just not using it.

00:15:54.580 --> 00:15:57.960
I understand it's not as integrated into the web frameworks as it should be, but still.

00:15:58.100 --> 00:15:58.360
Great.

00:15:58.360 --> 00:16:02.860
But even that's changing now, so it's getting pretty good.

00:16:02.860 --> 00:16:06.860
And so I just want to try to keep playing with that and post that up there.

00:16:06.860 --> 00:16:11.280
And I also do a couple of things just on general engineering and software and a little bit of

00:16:11.280 --> 00:16:13.560
testing since I spent so many years in tests.

00:16:13.820 --> 00:16:22.200
I got this series going on called Practicality Beats Purity, mostly about that part of Python

00:16:22.200 --> 00:16:28.560
and how to, one thing sounds great, but how good is it really when you implement it kind

00:16:28.560 --> 00:16:28.760
of thing.

00:16:28.760 --> 00:16:29.180
Right.

00:16:29.300 --> 00:16:34.680
Like one of the popular articles you had was microservices versus monoliths and all

00:16:34.680 --> 00:16:36.220
the interesting trade-offs you make there.

00:16:36.220 --> 00:16:41.940
So we'll definitely dig into those, but I kind of want to focus on the whole reason we started

00:16:41.940 --> 00:16:45.860
talking about having you on the show, which is the continuous delivery you're doing around

00:16:45.860 --> 00:16:47.560
your work you're doing in HPE, right?

00:16:47.560 --> 00:16:52.540
And so maybe let's just start with what is continuous delivery.

00:16:52.660 --> 00:16:57.980
Like I know there's continuous integration and that's like something watches my repository

00:16:57.980 --> 00:17:00.820
and does some sort of build verification on check-in.

00:17:00.820 --> 00:17:02.560
So what's continuous delivery?

00:17:02.560 --> 00:17:04.040
How's that typically work?

00:17:04.040 --> 00:17:08.940
So continuous delivery expands on top of the continuous integration concept and say that

00:17:08.940 --> 00:17:14.480
build I just built, I want to do everything that I need to do to that build to make it deployable

00:17:14.480 --> 00:17:20.120
to production and have it available to be deployed to production, if not already deployed in production

00:17:20.120 --> 00:17:20.820
automatically.

00:17:21.740 --> 00:17:27.100
And so the idea is to set up your, be able to deliver code into production as quickly

00:17:27.100 --> 00:17:33.540
as possible in a way that that's maintainable while still having a set of status checks around

00:17:33.540 --> 00:17:36.140
that, that you can, that makes your job easier.

00:17:36.140 --> 00:17:36.620
Right.

00:17:36.620 --> 00:17:36.940
Okay.

00:17:36.940 --> 00:17:42.760
So maybe the Holy grail is like, I've got a GitHub repository and it has different branches.

00:17:42.760 --> 00:17:46.020
So maybe a branch is called production and a branch is called staging.

00:17:46.340 --> 00:17:53.060
And if you commit into staging it, you know, after some delay of the builds and creation

00:17:53.060 --> 00:17:58.300
of the servers and whatnot, there is now a new staging server or services based on top

00:17:58.300 --> 00:18:00.800
of that where you did nothing but wait a little bit.

00:18:00.800 --> 00:18:03.160
And that's kind of how we have our stuff set up.

00:18:03.160 --> 00:18:06.940
We have two branches and every, everything that's on our production stuff.

00:18:06.940 --> 00:18:11.100
Production branch is things that have gone already out to production.

00:18:11.100 --> 00:18:14.460
So everything there is a known working build that we can deliver to a customer.

00:18:14.700 --> 00:18:19.540
And we have our, we actually use the master branch for all our staging stuff, which is things

00:18:19.540 --> 00:18:25.660
that are fully tested or all the, we've guaranteed, we can guarantee that all the basic functions

00:18:25.660 --> 00:18:26.400
are tested.

00:18:26.400 --> 00:18:33.460
And the whole thing is completely built into a deliverable that we can actually go and put

00:18:33.460 --> 00:18:34.080
out in staging.

00:18:34.600 --> 00:18:41.420
And so as we go through our, our pull request cycle flow, GitHub flow type thing, get flow,

00:18:41.420 --> 00:18:46.640
we can automatically put the build up in our staging environment.

00:18:46.640 --> 00:18:46.940
Right.

00:18:46.940 --> 00:18:47.180
Okay.

00:18:47.180 --> 00:18:49.680
So you guys use the get flow style of work.

00:18:49.680 --> 00:18:51.680
Now this is really common in open source.

00:18:51.680 --> 00:18:56.160
Like some random outside person wants to make a contribution to a project.

00:18:56.160 --> 00:18:58.240
They don't have right privileges.

00:18:58.240 --> 00:19:02.820
So they'll fork the repository, make the change, do a PR back, and then the people can review

00:19:02.820 --> 00:19:03.440
and accept it.

00:19:03.500 --> 00:19:08.920
But some organizations, sounds like you guys, do that even for yourself on your own projects

00:19:08.920 --> 00:19:11.000
as a way of sort of like formalizing it, right?

00:19:11.000 --> 00:19:11.320
Right.

00:19:11.320 --> 00:19:17.180
So we use GitHub enterprise internally, but things like GitLab also have a similar concept for

00:19:17.180 --> 00:19:17.440
this.

00:19:17.440 --> 00:19:18.360
It's just called differently.

00:19:18.360 --> 00:19:23.780
So we have brand, our master and production branches are protected branches.

00:19:23.780 --> 00:19:28.460
And the only way to get in there is to go through a pull request merge.

00:19:28.460 --> 00:19:33.480
So we don't necessarily require the developer to have a separate, like a forked.

00:19:33.480 --> 00:19:33.980
repo.

00:19:33.980 --> 00:19:38.340
They just have permissions to push their own branch into our main repo.

00:19:38.340 --> 00:19:44.480
So once they push their branch and they open a pull request, we have a whole set of automation

00:19:44.480 --> 00:19:50.900
systems in place which receive the webhooks for the pull request and kick off automated builds,

00:19:50.900 --> 00:19:56.820
our style checking, linting, and all of the testing that goes around that pull request.

00:19:57.480 --> 00:20:04.580
And so you can even in GitHub say, I require the following statuses because the pull request

00:20:04.580 --> 00:20:07.960
object in GitHub has the concept of statuses.

00:20:07.960 --> 00:20:15.520
As you run those webhooks, the code that kicks off from those webhooks, the status is reported

00:20:15.520 --> 00:20:17.100
straight back into that pull request.

00:20:17.340 --> 00:20:23.220
And in GitHub, you can say, well, if all of these have passed, only then is your pull

00:20:23.220 --> 00:20:26.880
request valid to be merged into whatever branch it is that you want to go.

00:20:26.880 --> 00:20:28.720
Yeah, that's a really awesome feature.

00:20:28.720 --> 00:20:35.580
And to me, it sounds like this is a really nice way to sort of pre-vet what would be standard

00:20:35.580 --> 00:20:36.540
code review, right?

00:20:36.540 --> 00:20:38.740
Like instead of going, well, you've done your work.

00:20:38.740 --> 00:20:40.260
Now let's review it and see if it's good.

00:20:40.260 --> 00:20:43.060
It's going to be like it's on the verge of being merged.

00:20:43.460 --> 00:20:46.080
And then you've already had all the tests done and everything is good.

00:20:46.080 --> 00:20:46.840
You push the button.

00:20:46.840 --> 00:20:50.500
And when that happens, it automatically deploys with no further work as well.

00:20:50.500 --> 00:20:52.460
So it's just like that one gate, right?

00:20:52.460 --> 00:20:52.880
Right.

00:20:52.880 --> 00:20:57.760
Once all our tests are done and once the review is approved, we click our button.

00:20:57.760 --> 00:20:59.960
We do some other niceties around it.

00:20:59.960 --> 00:21:04.380
We kind of squash every right, our merge commit a little bit so that it's useful.

00:21:04.380 --> 00:21:06.240
And we press the button.

00:21:06.240 --> 00:21:06.500
Right.

00:21:06.500 --> 00:21:11.680
Maybe talk about that a little bit because, you know, Git can like if I'm going to do, excuse

00:21:11.680 --> 00:21:16.020
me, I'll create a branch, I'll do like 20 commits, a bunch of little tiny ones.

00:21:16.020 --> 00:21:18.600
And then eventually I'm going to create a PR from that.

00:21:18.600 --> 00:21:23.780
You might want that to not look like 20 small operations, but one holistic one, right?

00:21:23.780 --> 00:21:24.020
Right.

00:21:24.020 --> 00:21:28.740
So we try to follow a system where we abstract more as we go down the production side.

00:21:28.740 --> 00:21:33.060
So we have as much detail as possible on the branch that the developer put their things

00:21:33.060 --> 00:21:33.600
together in.

00:21:33.860 --> 00:21:36.900
So all the commits on that branch are going to be the itty bitty things.

00:21:36.900 --> 00:21:40.780
Started to work on this feature, went to lunch, came back.

00:21:40.780 --> 00:21:41.860
Oh, didn't work.

00:21:41.860 --> 00:21:43.300
Trying it again.

00:21:43.300 --> 00:21:43.540
Yeah.

00:21:43.540 --> 00:21:43.860
Yeah.

00:21:43.860 --> 00:21:44.040
Yeah.

00:21:44.040 --> 00:21:47.660
You know, there's like a bunch, there's a bunch of really funny commits that go into that.

00:21:47.660 --> 00:21:49.520
And then you say, okay, so I'm ready.

00:21:49.520 --> 00:21:54.400
So here's what I'm going to take all that group of 20 commits and merge it as one commit

00:21:54.400 --> 00:21:56.480
up into my master branch.

00:21:56.640 --> 00:22:01.220
And so I go back and clean all that stuff up and say, these are the features that are

00:22:01.220 --> 00:22:01.620
going in.

00:22:01.620 --> 00:22:04.560
These are the issues that are getting closed because GitHub has all that automation.

00:22:04.560 --> 00:22:09.920
And for us, you can say closes hashtag issue number and automatically closes the issue for

00:22:09.920 --> 00:22:10.120
me.

00:22:10.120 --> 00:22:16.000
And then when I press a squash and merge button, all that stuff gets squashed and you only get

00:22:16.000 --> 00:22:18.720
one bubble in your master branch with the summarized changes.

00:22:18.720 --> 00:22:19.660
Yeah, that's really awesome.

00:22:19.660 --> 00:22:22.220
And of course, you can go back to the other branch and see it, right?

00:22:22.220 --> 00:22:23.160
And see all the details.

00:22:23.160 --> 00:22:23.440
Yep.

00:22:23.440 --> 00:22:24.240
Yeah, that's really nice.

00:22:24.240 --> 00:22:29.140
I wonder how many people actually use that GitHub automation around like interacting with

00:22:29.140 --> 00:22:29.560
issues.

00:22:29.560 --> 00:22:36.680
I use that all the time, even just for myself, you know, hashtag some ID of an issue or PR

00:22:36.680 --> 00:22:38.300
and say, this is related to that.

00:22:38.300 --> 00:22:40.720
And it's really nice to just get those automatic links in there.

00:22:40.720 --> 00:22:41.060
Yep.

00:22:41.060 --> 00:22:43.120
And like, I'm very opinionated on issues.

00:22:43.120 --> 00:22:48.820
So I love the way that GitHub does issues, not in the UI or anything like that, just like

00:22:48.820 --> 00:22:50.380
the idea of it's an issue.

00:22:50.380 --> 00:22:54.460
It has a title, it has a description, some comments in it, and some tags, some labels,

00:22:54.460 --> 00:22:54.920
right?

00:22:54.920 --> 00:22:57.320
I don't need anything more than that.

00:22:57.320 --> 00:22:58.880
Everything else can be described with labels.

00:22:58.880 --> 00:23:03.140
Like Jira to you feels like you're swimming in too many, like UI soup.

00:23:03.140 --> 00:23:03.640
Yes.

00:23:03.640 --> 00:23:07.940
And so I've used like half a dozen different issue trackers.

00:23:07.940 --> 00:23:11.400
At the moment, the one we use internally actually is Jira.

00:23:11.800 --> 00:23:16.200
So, you know, we have the usual GitHub versus Jira thing.

00:23:16.200 --> 00:23:21.400
So we actually wound up writing a kind of a bridge to help us out, follow our business

00:23:21.400 --> 00:23:24.400
logic in Jira as we do stuff on GitHub.

00:23:24.400 --> 00:23:28.440
So we also listen for issue webhooks and update Jiras for us automatically.

00:23:28.440 --> 00:23:32.680
But this way I can go open an issue in two seconds by typing it into GitHub.

00:23:32.920 --> 00:23:36.920
And then all the stuff just kind of that goes into Jira gets all rolled into place as it

00:23:36.920 --> 00:23:37.320
should be.

00:23:37.320 --> 00:23:39.020
Oh, that's a really, really awesome way.

00:23:39.020 --> 00:23:40.380
Like, I don't really want to work in Jira.

00:23:40.380 --> 00:23:44.580
So I'm just going to automate working in Jira like my robot will.

00:23:44.580 --> 00:23:44.960
Yeah.

00:23:44.960 --> 00:23:48.820
And you got to be careful with that stuff because then you'll wind up maintaining it.

00:23:48.820 --> 00:23:50.460
But right.

00:23:50.460 --> 00:23:51.060
Nice.

00:23:51.060 --> 00:23:51.780
But yeah.

00:23:51.780 --> 00:23:57.140
So once our pull request is actually merged, more of our webhooks also say, oh, there was

00:23:57.140 --> 00:23:58.760
this pull request that got merged into master.

00:23:58.760 --> 00:24:00.540
So that means we need to deploy code.

00:24:00.740 --> 00:24:03.720
So we open a new pull request to go to production.

00:24:03.720 --> 00:24:06.480
And so that's what we call our deploy pull request.

00:24:06.480 --> 00:24:12.480
And so that one does a little bit of the different thing where it actually builds.

00:24:12.480 --> 00:24:15.960
So our deliverables are container images.

00:24:15.960 --> 00:24:16.960
Docker containers, right?

00:24:16.960 --> 00:24:23.440
Because our service runs in using Docker and AWS container, elastic container services.

00:24:23.440 --> 00:24:26.640
So just to step back on that a little bit.

00:24:27.120 --> 00:24:28.840
So a lot of people get confused.

00:24:28.840 --> 00:24:34.400
Docker containers is one thing, but there's really two concepts.

00:24:34.400 --> 00:24:35.220
There's the image.

00:24:35.220 --> 00:24:40.220
And then there's the instantiation of that image, which is your actual container, right?

00:24:40.220 --> 00:24:47.200
So when I go and say, I want an image of my REST API, that means I have the file system in

00:24:47.200 --> 00:24:47.720
place.

00:24:47.920 --> 00:24:56.100
So that when I say Docker run, I can instantiate a version of that image and execute my code inside

00:24:56.100 --> 00:24:56.700
that environment.

00:24:56.700 --> 00:25:04.720
So we deliver our two different images, one for our web service or web UI and one for our core stuff.

00:25:04.720 --> 00:25:11.840
So all of the orchestration that we have to do in order to make our service work, which involves cloud

00:25:11.840 --> 00:25:18.820
orchestration with AWS and Azure, some third party data center orchestration, switch management,

00:25:18.820 --> 00:25:25.380
array configuration, and then all resource allocation algorithms, user management, all that stuff.

00:25:25.380 --> 00:25:27.940
That's all kind of bundled into one container image.

00:25:27.940 --> 00:25:32.120
And we run it with different environment variables to have it perform different functions.

00:25:32.260 --> 00:25:37.040
So we have a microservices architecture, but with two images.

00:25:37.040 --> 00:25:44.920
The way we manage the way that AWS works, when you have the container service in it, you define

00:25:44.920 --> 00:25:48.980
a service like my core REST API service.

00:25:48.980 --> 00:25:54.800
And I say, I want this to run several tasks or one task.

00:25:55.400 --> 00:26:03.220
And I want, I wanted to run this container, but I want this image tagged in such way.

00:26:03.220 --> 00:26:12.060
So for example, in our repository for that, the REST API backend, when we deploy an image, we push up the code

00:26:12.060 --> 00:26:14.840
and then we say, okay, we're ready to move to staging.

00:26:15.120 --> 00:26:17.120
So we tag it with staging latest.

00:26:17.120 --> 00:26:23.640
So then I can go to AWS and my deployment activation work of make this image.

00:26:23.640 --> 00:26:27.440
Now the valid one in this environment is just stop the containers.

00:26:27.900 --> 00:26:30.280
And then AWS will automatically restart them.

00:26:30.280 --> 00:26:33.880
And when they start to come back up, they say, oh, there's a new staging latest image.

00:26:33.880 --> 00:26:35.360
Let me download that and use that one.

00:26:35.360 --> 00:26:35.720
I see.

00:26:35.720 --> 00:26:36.300
That's really cool.

00:26:36.300 --> 00:26:43.880
So basically the AWS container service just knows I'm going to run out of this, this get repository

00:26:43.880 --> 00:26:45.000
with this tag.

00:26:45.000 --> 00:26:46.700
And I just always look for that.

00:26:47.280 --> 00:26:48.860
If necessary, rebuild it.

00:26:48.860 --> 00:26:49.100
Right.

00:26:49.100 --> 00:26:50.180
A Docker image.

00:26:50.180 --> 00:26:50.700
A Docker image.

00:26:50.700 --> 00:26:51.160
Yeah, yeah, yeah.

00:26:51.160 --> 00:26:53.100
So, and right.

00:26:53.100 --> 00:26:55.560
So everything just builds off of that.

00:26:55.560 --> 00:27:03.560
And it's really helpful also because if you broke things for one reason or another, all you

00:27:03.560 --> 00:27:09.560
have to do is move your staging latest tag back to your previous one and restart the containers.

00:27:09.560 --> 00:27:12.560
Go now, undo it, undo it.

00:27:12.560 --> 00:27:12.860
Yep.

00:27:12.860 --> 00:27:13.720
That's all you got to do.

00:27:13.720 --> 00:27:16.580
You don't have to worry about anything else because you know that was working code and you're

00:27:16.580 --> 00:27:17.120
back in time.

00:27:17.600 --> 00:27:18.660
Now, there's other.

00:27:18.660 --> 00:27:19.540
That's really nice.

00:27:19.540 --> 00:27:25.060
Complexities when it comes to database migrations and things like that.

00:27:25.060 --> 00:27:27.980
But 90% of the time, you don't have to worry about it.

00:27:27.980 --> 00:27:28.220
Right.

00:27:28.220 --> 00:27:28.520
Okay.

00:27:28.520 --> 00:27:32.900
That's really nice because like it's one thing to roll the code back, but you're potentially

00:27:32.900 --> 00:27:37.640
making infrastructure changes and OS changes at that level as well.

00:27:37.640 --> 00:27:43.140
And the ability to go, oh no, just put everything in the back of, put it back like it was.

00:27:43.140 --> 00:27:43.680
It was working.

00:27:43.680 --> 00:27:44.540
It's pretty cool.

00:27:44.540 --> 00:27:44.760
Yeah.

00:27:44.900 --> 00:27:49.840
Because like once, so the code underwent all the testing and all that worked and the

00:27:49.840 --> 00:27:53.120
container image that we used to build that code.

00:27:53.420 --> 00:27:58.740
And I'll get a little bit into that in a minute is, it's slightly different than the one I actually

00:27:58.740 --> 00:28:03.880
wind up putting in staging because it has more stuff in it to maintain the test infrastructure

00:28:03.880 --> 00:28:06.020
or be able to get to the test infrastructure.

00:28:06.480 --> 00:28:11.100
The one that actually makes it up into staging, which is equal to the one in production at that

00:28:11.100 --> 00:28:16.780
point also has a bunch of other things like an NGINX configuration that's a bit different

00:28:16.780 --> 00:28:20.260
or a micro WSGI config along with it.

00:28:20.260 --> 00:28:22.400
So I can easily like mess that up.

00:28:22.400 --> 00:28:25.420
And it's only a problem I see when I go to deploy it.

00:28:25.420 --> 00:28:25.680
Right.

00:28:25.680 --> 00:28:25.880
Right.

00:28:25.940 --> 00:28:28.420
I just, today I would have liked to have something like this.

00:28:28.420 --> 00:28:33.460
I mean, I have multiple like staging and production servers for my various things.

00:28:34.160 --> 00:28:41.760
And one of them, I got an indication there was an upgrade for IDNA, I think some, which

00:28:41.760 --> 00:28:44.060
is some low level dependency on my, my system.

00:28:44.060 --> 00:28:45.960
And then there's requests.

00:28:46.300 --> 00:28:52.260
And so I upgraded the low level thing and said, oh no, requests forces, you know, to use an

00:28:52.260 --> 00:28:53.520
older version of that.

00:28:53.520 --> 00:28:54.500
So guess what?

00:28:54.500 --> 00:28:55.580
Your site won't even start.

00:28:55.580 --> 00:28:56.620
It's just dead.

00:28:56.620 --> 00:29:00.340
But luckily it was like running on, like I had taken that one out of the load balancer and

00:29:00.340 --> 00:29:01.060
like, oh my goodness.

00:29:01.060 --> 00:29:04.820
But I had to do a lot more work than just move the tag back.

00:29:04.820 --> 00:29:05.880
Right.

00:29:05.880 --> 00:29:08.240
It was like, all right, well now how do I unravel this?

00:29:08.240 --> 00:29:11.760
How do I make it know that it's supposed to install the right one and all that kind of stuff.

00:29:11.760 --> 00:29:14.060
So it, yeah, it sounds, I can definitely see the advantage here.

00:29:14.060 --> 00:29:20.300
And that actually happens quite often with a bunch of things, not just your Python libraries

00:29:20.300 --> 00:29:23.600
that you have to worry about and their interactions, but also your Docker images.

00:29:23.600 --> 00:29:27.420
So what happened to us in the past couple of weeks while we were going through testing, like

00:29:27.420 --> 00:29:31.700
in the middle of I'm tests are passing and then all of a sudden everything's failing, what's

00:29:31.700 --> 00:29:32.160
going on?

00:29:32.160 --> 00:29:33.540
Like a couple minutes.

00:29:33.540 --> 00:29:39.580
We actually hit where whoever maintains the base Python Docker image that we depend on

00:29:39.580 --> 00:29:40.920
iterated on it.

00:29:40.920 --> 00:29:41.840
They changed it.

00:29:41.840 --> 00:29:42.360
Oh boy.

00:29:42.360 --> 00:29:42.620
Yeah.

00:29:42.620 --> 00:29:43.180
Yeah.

00:29:43.480 --> 00:29:47.700
And the new one, and obviously we can go back to the older one, but at this point we

00:29:47.700 --> 00:29:48.820
wanted to move with a new one.

00:29:48.820 --> 00:29:51.440
The newer one changed the base.

00:29:51.440 --> 00:29:54.340
I think it moved the major version.

00:29:54.340 --> 00:29:57.660
So all the app packages and stuff like that had updated.

00:29:57.660 --> 00:30:00.760
So I needed to use different, different names to pull some stuff.

00:30:00.760 --> 00:30:02.260
So that was fun.

00:30:02.260 --> 00:30:03.740
Yeah, that's fun.

00:30:03.740 --> 00:30:07.600
And if you do that on the real machine in production while it's running, not so good.

00:30:07.600 --> 00:30:08.000
Yeah.

00:30:08.000 --> 00:30:08.600
Not so good.

00:30:08.600 --> 00:30:09.060
Right.

00:30:09.060 --> 00:30:10.640
That's why all this stuff is in place.

00:30:10.640 --> 00:30:11.300
That's right.

00:30:11.300 --> 00:30:16.480
This portion of Talk Python to Me has been brought to you by Rollbar.

00:30:16.640 --> 00:30:20.140
One of the frustrating things about being a developer is dealing with errors.

00:30:20.980 --> 00:30:26.060
relying on users to report errors, digging through log files, trying to debug issues, or getting

00:30:26.060 --> 00:30:29.160
millions of alerts just flooding your inbox and ruining your day.

00:30:29.160 --> 00:30:33.940
With Rollbar's full stack error monitoring, you get the context, insight, and control you

00:30:33.940 --> 00:30:35.920
need to find and fix bugs faster.

00:30:35.920 --> 00:30:39.880
Adding Rollbar to your Python app is as easy as pip install Rollbar.

00:30:40.120 --> 00:30:44.140
You can start tracking production errors and deployments in eight minutes or less.

00:30:44.140 --> 00:30:48.320
Are you considering self-hosting tools for security or compliance reasons?

00:30:48.320 --> 00:30:51.900
Then you should really check out Rollbar's compliant SaaS option.

00:30:51.900 --> 00:30:57.040
Get advanced security features and meet compliance without the hassle of self-hosting, including

00:30:57.040 --> 00:31:01.260
HIPAA, ISO 27001, Privacy Shield, and more.

00:31:01.260 --> 00:31:02.640
They'd love to give you a demo.

00:31:02.640 --> 00:31:04.340
Give Rollbar a try today.

00:31:04.340 --> 00:31:08.020
Go to talkpython.fm/Rollbar and check them out.

00:31:08.020 --> 00:31:13.780
One question I did have while you're describing what you're up to, and we talked about the

00:31:13.780 --> 00:31:17.680
GitHub hooks like hashtag closes, hashtag one, two, three, or whatever.

00:31:17.680 --> 00:31:23.960
Is there a way to make that happen only when it merges into the main branch?

00:31:23.960 --> 00:31:28.300
Or does that PR commit itself trigger the closing of that issue?

00:31:28.300 --> 00:31:29.960
Yes, I understand what you're asking.

00:31:29.960 --> 00:31:32.880
Yes, it only happens when you do the merge.

00:31:32.880 --> 00:31:33.300
Oh, really?

00:31:33.300 --> 00:31:33.620
Okay.

00:31:33.620 --> 00:31:36.000
Because I type it in my commits all the time.

00:31:36.000 --> 00:31:36.440
Interesting.

00:31:36.440 --> 00:31:37.000
Okay.

00:31:37.000 --> 00:31:37.660
Well, that's awesome.

00:31:37.660 --> 00:31:37.900
Yeah.

00:31:37.900 --> 00:31:38.660
Very, very nice.

00:31:38.660 --> 00:31:39.760
All right.

00:31:39.760 --> 00:31:43.880
So maybe one of the things, I think maybe the most interesting thing to cover is like,

00:31:43.880 --> 00:31:48.540
we've now set the stage of what you're building, but all the various pieces, there's so many

00:31:48.540 --> 00:31:55.580
cool little libraries and packages and things involved in the act of building this whole pipeline

00:31:55.580 --> 00:31:56.140
that you've created.

00:31:56.140 --> 00:31:57.440
So do you want to walk us through that?

00:31:57.440 --> 00:32:03.400
In order to run all the testing, we have a Docker swarm internally on premises in our data

00:32:03.400 --> 00:32:05.700
center where we orchestrate all of this stuff.

00:32:05.700 --> 00:32:09.680
So I have a container running that is my webhook receiver.

00:32:09.680 --> 00:32:15.020
And I built that one, that REST endpoint for that using a hug.

00:32:15.020 --> 00:32:23.560
Hug is a Python 3 REST API, kind of like Flask, but it's a bit smaller and a little more expressive

00:32:23.560 --> 00:32:30.780
because it uses annotations when you're defining your functions to define the input type of your

00:32:30.780 --> 00:32:32.280
parameters from your REST API.

00:32:32.280 --> 00:32:35.560
It also automatically generates documentation.

00:32:35.560 --> 00:32:36.320
Yeah, that's cool.

00:32:36.320 --> 00:32:42.240
Hug is really interesting in that it's like one of these REST only frameworks.

00:32:42.240 --> 00:32:46.760
It's not built from as far as I understand it, mostly for building web applications,

00:32:46.760 --> 00:32:48.380
but more for building web services.

00:32:48.380 --> 00:32:49.280
And there's a...

00:32:49.280 --> 00:32:54.280
Yeah, there's a host of these that are really amazing at sort of leveraging Python 3.

00:32:54.280 --> 00:32:58.140
So hug is definitely in there, which is super cool.

00:32:58.140 --> 00:32:59.000
API star.

00:32:59.000 --> 00:33:00.000
And API star.

00:33:00.000 --> 00:33:00.540
Yeah.

00:33:00.540 --> 00:33:00.800
Yeah.

00:33:00.800 --> 00:33:05.320
That's the new one I'm playing with because API star fully supports asyncio.

00:33:05.320 --> 00:33:11.280
So I can have an async function and have API star serve it up.

00:33:11.280 --> 00:33:11.820
That's awesome.

00:33:11.820 --> 00:33:12.120
Yeah.

00:33:12.120 --> 00:33:13.420
I can just await in the function.

00:33:13.420 --> 00:33:15.440
And in the meantime, it'll go off and do other things.

00:33:15.440 --> 00:33:16.240
It's pretty cool.

00:33:16.240 --> 00:33:16.780
How about hug?

00:33:16.880 --> 00:33:17.920
Does it do asyncio?

00:33:17.920 --> 00:33:18.300
Do you know?

00:33:18.300 --> 00:33:19.660
I don't think so.

00:33:19.660 --> 00:33:21.480
Last I checked, it did not.

00:33:21.480 --> 00:33:22.580
But it was...

00:33:22.580 --> 00:33:27.860
I think it was able to handle it better because it was all Python 3.

00:33:27.860 --> 00:33:29.840
Yeah, it's definitely all Python 3, which is cool.

00:33:29.840 --> 00:33:33.860
And if you look at the performance, Hug is built on a framework called Falcon.

00:33:33.860 --> 00:33:34.860
Falcon, yes.

00:33:34.860 --> 00:33:38.120
Which is also another cool web framework that probably no one else has heard...

00:33:38.120 --> 00:33:39.000
Not many people have heard of.

00:33:39.000 --> 00:33:41.000
But I had the guys building Falcon on my show.

00:33:41.000 --> 00:33:43.300
And it's like a really low level, high performance...

00:33:43.300 --> 00:33:43.640
It is.

00:33:43.640 --> 00:33:44.320
...web framework.

00:33:44.320 --> 00:33:46.360
And then Hug is actually built on top of Falcon,

00:33:46.640 --> 00:33:47.280
which is pretty cool.

00:33:47.280 --> 00:33:48.100
But they're definitely...

00:33:48.100 --> 00:33:55.320
Both of those are like right near the absolute top of performance in terms of request per second on some random piece of hardware.

00:33:55.320 --> 00:33:56.760
So, yeah, pretty cool.

00:33:56.760 --> 00:34:01.420
I find that a lot of things like Django, Pyramid, or Flask, right?

00:34:01.420 --> 00:34:03.040
These things have been along for a while.

00:34:03.040 --> 00:34:04.960
So they have a bunch of things they do for you.

00:34:05.340 --> 00:34:12.580
And the higher level of abstraction that you get out of a framework, which is what you want from a framework, usually.

00:34:12.580 --> 00:34:23.700
The more careful you got to be with performance, because in order to give you that abstraction, they needed to put you through a number of other levels, especially...

00:34:23.700 --> 00:34:27.300
Usually, function calls, which in Python are a little bit expensive.

00:34:27.300 --> 00:34:28.880
They're surprisingly expensive, actually.

00:34:28.880 --> 00:34:29.340
Yes.

00:34:29.340 --> 00:34:30.460
Yes, they are.

00:34:30.460 --> 00:34:31.420
Yeah.

00:34:31.420 --> 00:34:44.220
And so, for example, one thing that Hug says, and I think this is partly coming through the Falcon side of things, is it's compiled with Cython to basically get much higher performance, which is a pretty cool aspect as well.

00:34:44.220 --> 00:34:44.920
Yep, yep.

00:34:44.920 --> 00:34:56.760
Okay, so you've got this, and this is one of the really important things about this Docker stuff, is it's awesome to have your database in a Docker container and your web framework and then your backend services.

00:34:56.760 --> 00:34:59.140
But they all need to know, okay, where are you?

00:34:59.140 --> 00:35:00.180
We just all got rebuilt.

00:35:00.180 --> 00:35:00.880
Where are you now?

00:35:00.880 --> 00:35:01.640
Who are you, right?

00:35:01.640 --> 00:35:02.840
How do I find my backend?

00:35:02.840 --> 00:35:04.740
Right?

00:35:04.740 --> 00:35:06.340
So that's the role of this thing that you built.

00:35:06.340 --> 00:35:06.660
Right.

00:35:06.660 --> 00:35:14.720
So that receiver, the web receiver also can communicate with the Docker swarm using Docker Pi.

00:35:15.100 --> 00:35:18.260
And then orchestrate, oh, I need to build a new container.

00:35:18.260 --> 00:35:21.120
I need you to start a new container.

00:35:21.120 --> 00:35:22.660
I need to build a new image.

00:35:22.660 --> 00:35:26.260
I need you to start a new container with this existing or newly built image.

00:35:26.260 --> 00:35:36.700
So, for example, one of the things we do is when the web hook comes in, we go in and do use requests to go up to GitHub, grab some information on the repository, search for a file.

00:35:36.700 --> 00:35:39.900
That kind of works kind of like how Travis CI does.

00:35:40.220 --> 00:35:43.980
We have a YAML that says, oh, here to set up for testing.

00:35:43.980 --> 00:35:45.820
Here's your install instructions.

00:35:45.820 --> 00:35:48.040
The actual tests are these things.

00:35:48.040 --> 00:35:50.020
And there's a bunch of other settings we can do.

00:35:50.020 --> 00:35:54.780
So one of the things in there might say, well, I want all these tests to run in parallel.

00:35:55.160 --> 00:36:04.160
So that means I got to orchestrate getting the container built, the container image built off of the repository the way that the instructions say they're supposed to be done.

00:36:04.160 --> 00:36:22.460
Then taking that and committing that new image to an internal registry that we have and then telling our Docker swarm to start five to six parallel images to go and execute tests based off of that new image.

00:36:22.720 --> 00:36:27.460
And then those tests all have to require resources of their own.

00:36:27.460 --> 00:36:39.140
So we have another infrastructure piece, which is a resource manager that all it does is it sits there and receives, waits for a WebSocket.

00:36:39.560 --> 00:36:49.980
So I can, in order to pull, essentially check out a resource, I open a WebSocket connection and I say, oh, I want this type of resource.

00:36:49.980 --> 00:36:55.560
And while that WebSocket connection is open, I have a reservation on that resource.

00:36:55.560 --> 00:37:00.840
So that makes it so that I can write tests and not worry about releasing the resources when they fail.

00:37:00.840 --> 00:37:05.700
Oh, that's pretty interesting because when the thing goes away, it just, it, because it breaks.

00:37:05.700 --> 00:37:06.060
Yeah.

00:37:06.060 --> 00:37:06.620
Socket closes.

00:37:06.620 --> 00:37:06.940
Boom.

00:37:06.940 --> 00:37:07.460
It's all done.

00:37:07.460 --> 00:37:08.600
Huh.

00:37:08.600 --> 00:37:11.460
I didn't realize, I thought you were just doing push notifications.

00:37:11.460 --> 00:37:15.520
I didn't realize the WebSocket like session had such an important role.

00:37:15.520 --> 00:37:16.120
That's pretty cool.

00:37:16.120 --> 00:37:16.440
Yep.

00:37:16.440 --> 00:37:17.100
So we do that.

00:37:17.100 --> 00:37:23.420
And so for that, I used Autobom before, which is something I used inside Sophie, one of my open source modules.

00:37:23.420 --> 00:37:26.260
But I recently moved it to WebSockets.

00:37:26.260 --> 00:37:28.320
It's a module called WebSockets.

00:37:28.460 --> 00:37:35.420
It's a lot more, it's built around AsyncIO a lot better, more Pythonic using Async4 and AsyncWith.

00:37:35.420 --> 00:37:39.560
So it makes it a lot easier to interact with in a coroutine kind of way.

00:37:39.560 --> 00:37:39.800
Yeah.

00:37:39.800 --> 00:37:40.140
Interesting.

00:37:40.140 --> 00:37:44.140
So your test might just do AsyncWith WebSocket connection and then do its stuff?

00:37:44.140 --> 00:37:45.120
Something like that.

00:37:45.120 --> 00:37:55.080
So the test will, the test will, the receiver will do an Async4 around the WebSocket, around receiving something in a WebSocket.

00:37:55.080 --> 00:37:56.980
And so that's on the server side.

00:37:57.400 --> 00:38:06.080
On the client side, we just open the socket and do, I think on the client side is an AsyncWith where you just sit there and just kind of wait for messages.

00:38:06.080 --> 00:38:06.520
Interesting.

00:38:06.520 --> 00:38:07.420
That's pretty awesome.

00:38:07.940 --> 00:38:13.620
So then another thing that you do after the test pass, then you build your artifacts, right?

00:38:13.620 --> 00:38:14.700
Like your packages.

00:38:14.700 --> 00:38:19.060
And you use proper Python packaging as part of this, right?

00:38:19.060 --> 00:38:26.520
My two main deliverables are container images, but I also have a, those are built on top of a bunch of other repositories that I have.

00:38:26.520 --> 00:38:33.060
Two or three of those repositories are, their deliverables are actual Python packages, which are internal.

00:38:33.560 --> 00:38:41.360
And we use an internal Python package index for that, which we later migrated to a tool called Artifactory.

00:38:41.360 --> 00:38:42.820
I had never heard about Artifactory.

00:38:42.980 --> 00:38:44.360
This is a thing by JFrog.

00:38:44.360 --> 00:38:46.100
Yep, it's by JFrog.

00:38:46.100 --> 00:38:47.640
It is, oh my goodness.

00:38:47.640 --> 00:38:52.760
That is one serious piece of like enterprise software management software there.

00:38:52.880 --> 00:38:54.060
Yeah, it's a lot of stuff.

00:38:54.060 --> 00:38:55.200
A lot of stuff.

00:38:55.200 --> 00:39:02.020
Python package indexes, NPM indexes, whatever those are called, just NFS, Docker registries.

00:39:02.020 --> 00:39:03.320
And then you can mirror.

00:39:03.320 --> 00:39:09.780
So if you have stuff in the outside world, you can mirror those and you can have it automatically push things for you.

00:39:09.780 --> 00:39:14.080
And you can, you can add like tags and properties to things.

00:39:14.080 --> 00:39:15.680
It's, it's quite complex.

00:39:15.680 --> 00:39:17.820
It has a REST API too, to get to it.

00:39:17.820 --> 00:39:18.960
It's pretty interesting.

00:39:18.960 --> 00:39:20.160
Yeah, it's really interesting.

00:39:20.160 --> 00:39:22.560
Their website has like a bunch of cool little animations.

00:39:22.860 --> 00:39:24.420
It just makes you, it kind of draws you in.

00:39:24.420 --> 00:39:34.620
So to me, it looks like you've taken, you guys in general have taken a lot of the awesome stuff from the public open source and maybe sort of made your own private version of it.

00:39:34.620 --> 00:39:36.260
So you've got, you know, GitHub Enterprise.

00:39:36.260 --> 00:39:43.080
You've got like a private PyPI server, private Docker repositories, all sorts of stuff, registries.

00:39:43.080 --> 00:39:43.360
Yep.

00:39:43.360 --> 00:39:49.140
It just makes the whole thing easier to work with because you have, you have an existing ecosystem that can work with all of this.

00:39:49.140 --> 00:39:52.540
You don't have to build your own modules to talk to them.

00:39:52.540 --> 00:39:52.860
Yeah.

00:39:52.860 --> 00:39:53.520
Super cool.

00:39:53.520 --> 00:39:57.940
I'd never heard of Artifactory, but it definitely looks like, like worth checking out.

00:39:57.940 --> 00:39:59.960
It's no small piece of software as far as I can tell.

00:39:59.960 --> 00:40:04.260
It looks like a big, a big thing that does a whole bunch of stuff, but it definitely looks like it.

00:40:04.260 --> 00:40:04.940
It's pretty cool.

00:40:04.940 --> 00:40:05.360
Yeah.

00:40:05.360 --> 00:40:06.620
And it comes with its own complexities.

00:40:07.160 --> 00:40:15.460
So if you want, if you just want an internal package index, really, there's a bunch of existing things already you can use, or you could just build your own.

00:40:15.460 --> 00:40:17.380
I built one with Hug before Artifactory.

00:40:17.380 --> 00:40:18.840
It's just a web server.

00:40:18.840 --> 00:40:19.200
Right.

00:40:19.200 --> 00:40:21.300
It's just a web server and a couple of interactions.

00:40:21.300 --> 00:40:22.960
It's not super complicated, but yeah.

00:40:22.960 --> 00:40:23.960
Pretty cool.

00:40:23.960 --> 00:40:26.760
And so we talked a little bit about some of what happens next.

00:40:26.760 --> 00:40:31.100
You have your GitHub hooks and your PRs and all that kind of stuff.

00:40:31.580 --> 00:40:32.340
What else is involved?

00:40:32.340 --> 00:40:35.580
So you have your Hug service that you've talked about.

00:40:35.580 --> 00:40:36.600
That's pretty awesome.

00:40:36.600 --> 00:40:40.800
You used PyDocker, which you mentioned in passing there.

00:40:40.800 --> 00:40:41.580
DockerPy, sorry.

00:40:41.580 --> 00:40:44.360
Which is just pip install Docker, right?

00:40:44.360 --> 00:40:44.860
Yes.

00:40:44.860 --> 00:40:45.760
Yes.

00:40:45.760 --> 00:40:46.020
Nice.

00:40:46.020 --> 00:40:46.720
Pip install Docker.

00:40:46.720 --> 00:40:46.900
Okay.

00:40:46.900 --> 00:40:54.240
So if you wanted your Python app to, say, orchestrate creating new containers or spinning them up, that would be what you use?

00:40:54.240 --> 00:40:54.580
Right.

00:40:54.580 --> 00:40:59.240
And it's got two client layers.

00:40:59.700 --> 00:41:03.040
One is like a lot lower level, which is an API client kind of thing.

00:41:03.040 --> 00:41:04.200
I think they call it API.

00:41:04.200 --> 00:41:05.080
I forget what they call it.

00:41:05.080 --> 00:41:07.700
And then there's one which is like the Docker client.

00:41:07.700 --> 00:41:11.060
So the Docker client operates more at an object level.

00:41:11.060 --> 00:41:19.500
So you can say, so you point it to where your Docker, your main Docker master is of your swarm.

00:41:19.500 --> 00:41:27.080
And you can just do .images, .lists, .create, stuff like that.

00:41:27.080 --> 00:41:29.180
Same thing for .containers.

00:41:29.620 --> 00:41:42.580
And then with the swarm in general, things get pretty complicated when you go out to swarm or Kubernetes, mostly because things are your containers that are managed by the swarm are not really containers.

00:41:42.580 --> 00:41:43.420
They're services.

00:41:44.580 --> 00:41:48.560
And it all makes perfect sense if you're running, say, a web service.

00:41:48.560 --> 00:41:53.720
And you say, I want a web service that needs to always be up and I want two instances of it.

00:41:53.720 --> 00:41:59.200
So you run one service with two tasks, each one of this type of container.

00:41:59.340 --> 00:42:08.400
But for us that are actually creating essentially one container or two containers individually to run every time, we have to make a new service for it.

00:42:08.400 --> 00:42:12.120
So there's a lot of layers there that complicate things a little bit.

00:42:12.240 --> 00:42:16.140
But it's very easy to manage with Docker Pi because it's all kind of built by the Docker guys.

00:42:16.140 --> 00:42:16.460
Yeah.

00:42:16.460 --> 00:42:16.820
Okay.

00:42:16.820 --> 00:42:17.920
That's really, really cool.

00:42:17.920 --> 00:42:22.140
And then another thing that you use is something called ChatOps.

00:42:22.140 --> 00:42:23.240
What is ChatOps?

00:42:23.240 --> 00:42:25.040
Is that like something for DevOps?

00:42:25.040 --> 00:42:25.760
Sure.

00:42:25.940 --> 00:42:37.560
When our deploy PR is complete, that means it built a container image and it pushed that image out to our Amazon container registry.

00:42:37.560 --> 00:42:44.240
So then we need to, we could automate this, but I still want to have some manual checks in place.

00:42:44.240 --> 00:42:51.960
So what we did was we have a chat system and just made a bot.

00:42:52.280 --> 00:42:57.740
And I can tell the bot, hey, I want this image to be my staging image.

00:42:57.740 --> 00:42:58.820
Go do it.

00:42:58.820 --> 00:43:12.160
And then the bot will go in and tag that image with staging latest and it'll go in and stop all my containers in AWS and which will automatically restart and essentially do my flip over from to a new version.

00:43:12.160 --> 00:43:12.880
That's awesome.

00:43:12.880 --> 00:43:26.220
Now, ChatOps in general is kind of like a concept of being able to run, to manage a bunch of services or deliverables or code or whatever you want to do over a chat system using a bot, essentially.

00:43:26.220 --> 00:43:26.560
Yeah.

00:43:26.560 --> 00:43:27.780
That's a pretty cool idea.

00:43:27.780 --> 00:43:32.720
I mean, we saw Kelsey Hightower's thing at the 2017.

00:43:32.820 --> 00:43:40.980
Yeah, it was 2017 PyCon where he got basically Google's voice assistant to do his Kubernetes stuff, right?

00:43:40.980 --> 00:43:41.260
Yep.

00:43:41.260 --> 00:43:49.280
So I was kind of laughing through his presentation a little bit because I was like, yep, that's what I do, except I can't talk to it.

00:43:49.280 --> 00:43:52.620
But, you know, not through voice, right?

00:43:52.620 --> 00:43:57.440
Well, you're not far away from getting some Google Home or some Alexa.

00:43:57.440 --> 00:43:58.040
Yeah.

00:43:58.040 --> 00:44:00.000
You could use some of the Alexa stuff going.

00:44:00.000 --> 00:44:03.340
And my, sorry if everyone's Alexa is going off, mine is as well now.

00:44:03.340 --> 00:44:06.340
The Amazon assistant, let's call it that.

00:44:06.340 --> 00:44:09.140
There's a Python one called Calliope we were just looking at today.

00:44:09.140 --> 00:44:15.100
And there's another one, I forget the name, that's also pretty famous in the Python world.

00:44:15.240 --> 00:44:21.620
We were just laughing at it this morning saying that we should hook all our stuff up together and just say, hey, deploy to staging.

00:44:21.620 --> 00:44:24.380
Hey, restart our stuff.

00:44:24.380 --> 00:44:27.380
There's some pretty easy ways to do it, actually.

00:44:27.380 --> 00:44:27.700
Yeah.

00:44:27.700 --> 00:44:32.580
Just some random dude walks into the cubes and just kind of kills all our stuff.

00:44:32.580 --> 00:44:33.480
Deploy production.

00:44:33.480 --> 00:44:34.760
No, no, no, no.

00:44:34.760 --> 00:44:37.700
Yeah, that's pretty awesome.

00:44:37.700 --> 00:44:43.160
Another tool that I don't think I've heard of that was really impressive to me is Locus.

00:44:43.160 --> 00:44:43.900
Yes.

00:44:43.900 --> 00:44:45.100
Yeah, tell us about that.

00:44:45.100 --> 00:44:49.380
Like, use pytest for your standard level, your automated testing.

00:44:49.380 --> 00:44:51.680
But Locus is more on the performance side, right?

00:44:51.680 --> 00:44:52.420
That's right.

00:44:52.420 --> 00:44:58.460
So, Locus, the idea of Locus is to test web services.

00:44:58.460 --> 00:45:08.480
So, you can write tasks in the forms of scripts or actions that represent users of your service.

00:45:09.100 --> 00:45:15.760
And you can have, like, all set of kind of like setup and teardown and type of stuff, kind of like your regular type of test environment.

00:45:16.420 --> 00:45:32.620
But then Locus can manage that over a large amount of virtual machines to go off and test your API and then come back and tell you, well, you managed to receive these many requests per second in this endpoint and these many in that endpoint.

00:45:32.800 --> 00:45:34.800
And this one was rate limited at this point.

00:45:34.800 --> 00:45:37.660
And this one was, you know, errored out when you did this thing.

00:45:37.660 --> 00:45:38.740
And so, you get a report.

00:45:38.740 --> 00:45:39.620
That's really cool.

00:45:39.620 --> 00:45:42.020
So, you've got, like, all the different parts of your site.

00:45:42.020 --> 00:45:45.900
And it shows you, here's the number of requests in a big grid.

00:45:45.900 --> 00:45:48.720
Like, this URL got this number of requests with this many failures.

00:45:48.720 --> 00:45:50.900
And, you know, average response time is this.

00:45:50.900 --> 00:45:52.880
And, yeah, it's super cool.

00:45:52.880 --> 00:46:01.200
Like, one of the big problems with the load testing is actually it can be at least getting enough pressure on your web server, right?

00:46:01.200 --> 00:46:10.140
Like, if you just do that over, say, your broadband connection at home on your laptop, like, maybe the limit is your outbound network or something, right?

00:46:10.140 --> 00:46:10.900
Something like that.

00:46:10.900 --> 00:46:17.940
Whereas, like, if you could put it on 100 VMs, spin them all up and, like, you know, turn those loose in a slowly way.

00:46:17.940 --> 00:46:18.780
Like, that's awesome, right?

00:46:18.780 --> 00:46:19.180
Yeah.

00:46:19.180 --> 00:46:23.700
You can have a different amount of virtual machines and it just kind of orchestrates all of them for you.

00:46:23.700 --> 00:46:26.880
You just got to have Locus installed on them and the scripts that they got to run.

00:46:26.880 --> 00:46:27.300
But, yeah.

00:46:27.300 --> 00:46:28.500
Yeah, this is looking super cool.

00:46:28.500 --> 00:46:31.340
I definitely would like to look more into it.

00:46:31.340 --> 00:46:37.520
So, yeah, it says define user behavior with Python code and swarm your system with millions of simultaneous users.

00:46:37.520 --> 00:46:47.840
You know, when tools like this exist, I'm just blown away when there are websites that fail so badly when they get a lot of traffic.

00:46:47.840 --> 00:46:52.860
You know, like, I understand there's some limit where it's like, okay, it just is not going to take more.

00:46:52.860 --> 00:46:57.860
But that limit should be many thousands, not a couple hundred, right?

00:46:57.860 --> 00:46:58.140
Right.

00:46:58.140 --> 00:47:03.180
And so, another thing we did, so we used Locus to figure out where we might break.

00:47:03.180 --> 00:47:19.840
And then what I do is there's in our Docker image, whenever that actually gets executed into a container, there's a few instructions that go in and replace environment variables in our Nginx configuration.

00:47:20.220 --> 00:47:25.260
So, I can go in and tweak the request per second.

00:47:25.260 --> 00:47:28.140
So, I do it at the Nginx level so I never hit the Python code.

00:47:28.860 --> 00:47:37.640
So, if I know I'm going to break at whatever, I can put in a limit at 8 or whatever on my...

00:47:37.640 --> 00:47:40.620
And then it just queues in Nginx until...

00:47:40.620 --> 00:47:41.060
Correct.

00:47:41.060 --> 00:47:42.600
...until Microwezky's done it.

00:47:42.700 --> 00:47:52.560
So, you can configure Nginx to do that per IP address or just in general and what error codes to return, all that stuff.

00:47:52.560 --> 00:47:53.280
Oh, that's awesome.

00:47:53.280 --> 00:47:59.200
So, a couple of other tools that are at play here are some of your projects.

00:47:59.360 --> 00:48:01.940
One is Sophie and one is Corv.

00:48:01.940 --> 00:48:07.500
So, Sophie falls to a pretty interesting realm of Python, I would say.

00:48:07.500 --> 00:48:08.020
Yeah.

00:48:08.020 --> 00:48:09.680
Maybe tell people what Sophie is.

00:48:09.680 --> 00:48:15.260
Some people talk a lot about user interfaces and Python.

00:48:15.260 --> 00:48:17.100
I don't know any of those.

00:48:17.100 --> 00:48:17.900
Oh, yeah.

00:48:17.900 --> 00:48:23.920
Actually, I think it was after one of your very first, like a long time ago, conversations about user interfaces and stuff.

00:48:23.920 --> 00:48:28.000
And I was like, oh, you know, I'm pretty sure this is exactly what I was thinking.

00:48:28.340 --> 00:48:37.040
I've built so many, you know, Bootstrap-based quick interfaces with like some just jQuery default stuff.

00:48:37.040 --> 00:48:38.820
I don't want to write that anymore.

00:48:38.820 --> 00:48:40.260
I want to just write it in Python.

00:48:40.260 --> 00:48:40.800
Yeah.

00:48:40.800 --> 00:48:43.580
So, what I did is essentially...

00:48:43.580 --> 00:48:52.240
It's a module that lets you do that where I kind of wrapped the widgets that you'd get out of Bootstrap, the HTML kind of library to help put that together.

00:48:52.240 --> 00:48:58.780
But it evolved because the way I do it is through WebSockets and AsyncIO.

00:48:58.780 --> 00:49:11.120
So, in the back end, you can kick off a web page that loads off a basic JavaScript library that you only have to write once, which tells that web page how to interact with Sophie.

00:49:11.520 --> 00:49:19.860
And you run a Python web server, WebSocket server, which is Sophie, that actually sends commands out to the web page.

00:49:19.860 --> 00:49:29.560
So, you open up a website and all of your interaction and eventing can go all the way back to your Python code and you can react on that and come back out to the UI.

00:49:29.560 --> 00:49:40.080
And after that evolution, I realized that Sophie is actually really a WebSocket protocol to help you do all of this and kind of like library to help you do all of this.

00:49:40.080 --> 00:49:46.880
Because you can just drop in and replace other ways of doing these conversations between client and the server.

00:49:46.880 --> 00:49:57.200
And so, what I did after that was I went to a game engine, Unity 3D, and dropped in a WebSocket client written in C#.

00:49:57.200 --> 00:50:04.440
So, now I can, from Python, spawn game objects and things like that in Unity.

00:50:04.440 --> 00:50:05.260
That's pretty awesome.

00:50:05.860 --> 00:50:12.000
So, it's a little, a tiny bit like Electron.js type apps where there's like a Python backend.

00:50:12.000 --> 00:50:15.100
It's some sort of web front end, at least the first incarnation of it.

00:50:15.100 --> 00:50:18.920
It's also deployable kind of like that if you want as well.

00:50:18.920 --> 00:50:20.240
But you can also do it.

00:50:20.240 --> 00:50:34.480
So, the original idea was to go down a desktop application type thing, in which case you would want to build it like that, like an Electron.js thing where you distribute Chromium, the browser that Chrome is based on, which is completely open source as your front end.

00:50:34.720 --> 00:50:40.420
But you can just deploy the backend by itself onto like some service in a Docker swarm, which is what we do.

00:50:40.420 --> 00:50:42.940
And just open up a web page and talk to it.

00:50:42.940 --> 00:50:43.460
Yeah, nice.

00:50:43.460 --> 00:50:49.880
And your other project, Corv, is about sort of skipping the whole REST API entirely, right?

00:50:49.880 --> 00:50:51.760
And using actually SSH?

00:50:51.900 --> 00:50:57.080
So, in the process, over the years, working on different services, right?

00:50:57.080 --> 00:50:59.800
You always want to have, there's always the customer facing one.

00:50:59.800 --> 00:51:04.160
But then you always want some data or something you want to have in some admin mode for.

00:51:04.560 --> 00:51:08.260
So, it's always a risk to put those admin endpoints in the customer facing one.

00:51:08.260 --> 00:51:11.980
Because if they're there, somebody's going to fiddle around and bump into them.

00:51:11.980 --> 00:51:15.080
And then you've got to worry about security and all that.

00:51:15.080 --> 00:51:15.300
Right.

00:51:15.300 --> 00:51:19.420
It just takes one forgotten security check and all sorts of badness happens.

00:51:19.420 --> 00:51:19.800
Right.

00:51:19.860 --> 00:51:24.700
Especially when those checks are usually decorators around Python functions, which you could forget to put in.

00:51:24.700 --> 00:51:25.100
Right?

00:51:25.100 --> 00:51:25.320
Yeah.

00:51:25.320 --> 00:51:30.340
So, the idea is, instead of using HTTP, use SSH.

00:51:30.340 --> 00:51:38.420
And there's, the first time I came up with this was when I ran into Async SSH, which is the base library for this.

00:51:38.420 --> 00:51:41.940
Because I wanted an async way of doing SSH calls.

00:51:41.940 --> 00:51:43.860
And they let you do this.

00:51:43.860 --> 00:51:46.500
So, I let SSH take care of the authentication.

00:51:46.500 --> 00:51:58.620
You've got to have your client cert the allowed clients, known hosts as well on both, you know, your known hosts on your client and your acceptable public keys for your client on the server.

00:51:58.620 --> 00:52:01.620
And so, SSH handles your authentication.

00:52:01.620 --> 00:52:06.760
And then after that, you open a TCP socket over SSH and just send information back and forth.

00:52:07.120 --> 00:52:16.800
I just wrapped it in JSON and kind of used kind of HTTP-ish REST-like mechanisms for, like, get, store, update, and delete.

00:52:16.800 --> 00:52:19.180
So, I do that as my admin interface.

00:52:19.180 --> 00:52:20.700
It's only accessible to me.

00:52:20.700 --> 00:52:27.540
But even if I break, even if I mess it up and it somehow exposes the ports out to the internet, it's still SSH.

00:52:27.540 --> 00:52:30.440
So, you still need the proper keys to get in.

00:52:30.440 --> 00:52:30.660
Yeah.

00:52:30.660 --> 00:52:31.280
That's really awesome.

00:52:31.280 --> 00:52:33.700
I think that's quite a cool idea.

00:52:33.700 --> 00:52:38.140
Like, I have certain things where you can only get to them through SSH.

00:52:38.140 --> 00:52:42.720
You can't access them or interact with them, you know, without that.

00:52:42.720 --> 00:52:50.100
And this is kind of like, instead of just exposing, like, tunneling that through or something, you're like, no, let's just make that the API network layer.

00:52:50.100 --> 00:52:50.600
Yeah.

00:52:50.600 --> 00:52:51.800
Exchange layer.

00:52:51.800 --> 00:52:53.440
Both of those are async.

00:52:53.440 --> 00:52:57.560
So, you can just have it kick off long-running things.

00:52:57.560 --> 00:52:58.040
Doesn't matter.

00:52:58.040 --> 00:52:59.440
You'll get a callback when it's done.

00:52:59.440 --> 00:52:59.840
Kind of thing.

00:52:59.840 --> 00:53:00.060
Yeah.

00:53:00.060 --> 00:53:00.500
Really cool.

00:53:00.780 --> 00:53:01.300
Let's see.

00:53:01.300 --> 00:53:03.800
Another couple of things that were really interesting that you're using.

00:53:03.800 --> 00:53:05.460
One is PyAutoGUI.

00:53:05.460 --> 00:53:06.760
And that's from Al Swagger.

00:53:06.760 --> 00:53:07.440
What's that?

00:53:07.440 --> 00:53:10.140
These are kind of more of an experimentation thing.

00:53:10.140 --> 00:53:14.160
So, we have pytest to execute all of our tests, which is great.

00:53:14.160 --> 00:53:17.060
We use Selenium for a few things.

00:53:17.720 --> 00:53:24.980
And then we use some other JavaScript node-specific runners for the WebUI stuff as well.

00:53:24.980 --> 00:53:29.020
But you just, like, browser compatibility is always going to be an issue.

00:53:29.020 --> 00:53:33.280
We want to try to do something more at the...

00:53:33.280 --> 00:53:42.760
We ran into a couple of issues where you say, you open this thing in Firefox, but if you open it in Chrome, this one little piece of it is kind of wonky.

00:53:42.900 --> 00:53:46.340
It's larger than it should be or it's off the screen and things like that.

00:53:46.340 --> 00:53:46.520
Yeah.

00:53:46.520 --> 00:53:49.840
So, PyAutoGUI lets you...

00:53:49.840 --> 00:53:50.900
Does a lot of stuff.

00:53:50.900 --> 00:53:55.240
It's about automating your OS through GUI things.

00:53:55.240 --> 00:53:56.740
Move the mouse here.

00:53:56.740 --> 00:53:58.200
Click on this.

00:53:58.200 --> 00:54:01.080
Type this from the keyboard and things like that.

00:54:01.360 --> 00:54:04.120
Now, it also helps you take screenshots.

00:54:04.120 --> 00:54:18.260
So, one of the things that I was thinking was we could put something together that says, open browser, type this into location bar, load web page, type username, type password, click login.

00:54:18.260 --> 00:54:18.980
Right?

00:54:18.980 --> 00:54:33.400
And then take a screenshot of the result and then use OpenCV to compare that screenshot to an already existing screenshot that I should have and maybe find the next button I have to click on.

00:54:33.400 --> 00:54:37.440
And if that button is not on the screen, then error, move on.

00:54:37.440 --> 00:54:37.900
Kind of way.

00:54:37.900 --> 00:54:41.620
The advantage of using the OpenCV stuff is you can have a confidence level on it.

00:54:41.620 --> 00:54:44.700
So, if things are off, you'll know.

00:54:44.700 --> 00:54:45.520
That's totally cool.

00:54:46.520 --> 00:54:47.000
Yeah.

00:54:47.000 --> 00:54:52.180
There's a project by a friend of mine named Llewellyn Falco called Approval Tests.

00:54:52.180 --> 00:54:55.460
And it will do something similar, basically.

00:54:55.460 --> 00:55:00.580
It will go and instead of having a whole bunch of tests, it just says, here's the output.

00:55:00.580 --> 00:55:01.780
Is that good or bad?

00:55:01.780 --> 00:55:02.760
You say, yeah, this is good.

00:55:02.760 --> 00:55:03.740
And then it records that.

00:55:03.740 --> 00:55:05.420
And then unless that output changes.

00:55:05.420 --> 00:55:05.920
Oh, sure.

00:55:05.920 --> 00:55:06.280
Right?

00:55:06.280 --> 00:55:06.820
And it could do that.

00:55:06.820 --> 00:55:08.880
I think it does that with pictures as well.

00:55:08.880 --> 00:55:09.300
Right?

00:55:09.300 --> 00:55:12.120
So, you could screenshot something and go, this is the verified version.

00:55:12.120 --> 00:55:14.560
If this changes, I need to check it out.

00:55:14.620 --> 00:55:16.860
Otherwise, just keep running the tests and saying they pass.

00:55:16.860 --> 00:55:17.200
Cool.

00:55:17.200 --> 00:55:17.680
Yeah.

00:55:17.680 --> 00:55:19.480
So, something like that is what we wanted to do.

00:55:19.480 --> 00:55:19.760
Yeah.

00:55:19.760 --> 00:55:20.000
Yeah.

00:55:20.000 --> 00:55:20.680
That sounds really cool.

00:55:20.680 --> 00:55:22.640
And you were talking about using OpenCV as well, huh?

00:55:22.640 --> 00:55:23.120
That's cool.

00:55:23.120 --> 00:55:26.980
And I actually tried out a few different things and OpenCV wound up being the faster one.

00:55:26.980 --> 00:55:27.440
Yeah.

00:55:27.440 --> 00:55:27.920
Awesome.

00:55:27.920 --> 00:55:28.980
Cool.

00:55:29.100 --> 00:55:30.100
All right.

00:55:30.100 --> 00:55:38.480
There's just so many little interesting tools and steps along this whole process that I think a lot of organizations are trying to get to, right?

00:55:38.480 --> 00:55:39.840
Like I said at the beginning, right?

00:55:39.840 --> 00:55:44.720
I check in, I merge a PR, I wait, magic appears on the other side, right?

00:55:44.720 --> 00:55:45.420
With zero downtime.

00:55:45.420 --> 00:55:49.820
But it sounds like you guys have really got it pretty nearly there.

00:55:49.820 --> 00:55:50.840
That's awesome.

00:55:50.840 --> 00:55:51.740
So, was it worth it?

00:55:51.740 --> 00:55:52.760
Oh, for me, it is, right?

00:55:52.980 --> 00:55:55.280
I mean, you have to, but you have to step back.

00:55:55.280 --> 00:55:58.080
You have to do your engineering work behind it, right?

00:55:58.080 --> 00:56:00.780
Don't just do it because everybody's doing it kind of thing.

00:56:00.780 --> 00:56:05.020
If we have a service, right?

00:56:05.020 --> 00:56:16.460
So, it is in our best interest to make it as fast and as easy as possible to release a fix out to the customer.

00:56:16.460 --> 00:56:16.820
Yeah.

00:56:16.820 --> 00:56:21.320
And the last thing you want to do is like try to release a fix and then take the whole thing down and make it worse.

00:56:21.320 --> 00:56:21.900
Exactly.

00:56:22.420 --> 00:56:26.300
So, the way to go through all of this is you have to step back.

00:56:26.300 --> 00:56:27.520
You have to look at your process.

00:56:27.520 --> 00:56:31.320
You have to, it's a lot of pieces and a lot of moving parts.

00:56:31.320 --> 00:56:41.700
So, you have to say what checks do I need at which point in time of my delivery flow does it make sense to check what?

00:56:41.700 --> 00:56:47.900
So, if I say all these tests need to pass here, that means I've guaranteed this basic function is working.

00:56:47.900 --> 00:56:52.180
These tests pass here, that means my infrastructure is working, et cetera, et cetera.

00:56:52.360 --> 00:56:52.520
Right.

00:56:52.520 --> 00:56:55.380
And it also depends on the quality of your test, right?

00:56:55.380 --> 00:57:03.020
Like you need to know that if the tests pass, pushing to production without further question is okay, right?

00:57:03.520 --> 00:57:11.120
Whereas if you only test a few things and maybe they don't test that well, like if a lot of stuff slips through, then this isn't so helpful, right?

00:57:11.120 --> 00:57:12.060
It's got to be a good net.

00:57:12.060 --> 00:57:12.300
Right.

00:57:12.380 --> 00:57:21.260
And we made the decision early on to put, to invest into that because, you know, we think it's going to bear fruit for us and it has been very useful.

00:57:21.260 --> 00:57:26.720
We very, very seldomly have a really broken function into staging.

00:57:26.980 --> 00:57:30.740
And when we do, the first thing to fix is not the function.

00:57:30.740 --> 00:57:36.080
It's the test to make sure that you can't push again with it broken.

00:57:36.080 --> 00:57:36.380
Yeah.

00:57:36.380 --> 00:57:37.260
That's a really good point.

00:57:37.480 --> 00:57:39.060
It's like, why did this get through?

00:57:39.060 --> 00:57:44.960
There's actually a problem in the continuous delivery system that it got this far.

00:57:44.960 --> 00:57:46.520
Now let's fix that, right?

00:57:46.520 --> 00:57:47.340
That's awesome.

00:57:47.340 --> 00:57:47.600
Yeah.

00:57:47.600 --> 00:57:55.540
And take advantage of the situation that you're in, which is you have a real failure, not something that you thought you might have.

00:57:55.540 --> 00:57:56.420
You have a real one.

00:57:56.640 --> 00:58:02.480
So make sure that your tests fail when you have a real failure and then go fix the code to make sure that it passes.

00:58:02.480 --> 00:58:03.020
That's awesome.

00:58:03.020 --> 00:58:04.720
I think that's really great advice.

00:58:04.720 --> 00:58:05.740
All right.

00:58:05.740 --> 00:58:13.180
I want to take just a moment, let you maybe list off some of your popular articles that you've written, but don't want to take too much time since we're running out of that.

00:58:13.180 --> 00:58:25.680
The most viewed article over time from the blog has been Threaded Asynchronous Magic and How to Wield It, which is pretty much about an intro into AsyncIO and what you can do with it.

00:58:25.760 --> 00:58:27.020
Yeah, it's a really good one.

00:58:27.020 --> 00:58:29.300
Just how to manage tasks and stuff like that.

00:58:29.300 --> 00:58:45.420
The one that's like most read, as in like the most time people have spent going through all the details was the Python Ate My GUI, which was the starter article for making Sophie and kind of the state of GUIs in Python.

00:58:45.420 --> 00:58:54.060
And the most recent one I have, which is now no longer true, the most recent one is about GDPR.

00:58:54.880 --> 00:59:01.800
And the implications of the European, the new European regulation on, for software developers.

00:59:01.800 --> 00:59:10.720
But the one before that, which was the one in my list was Practicality Beats Purity about microservices and monoliths, which we talked a little bit about already.

00:59:10.720 --> 00:59:13.640
Yeah, people should check that out if they're considering one or the other.

00:59:13.640 --> 00:59:16.280
And there's a lot of interesting trade-offs that you highlight there.

00:59:16.280 --> 00:59:17.040
All right.

00:59:17.040 --> 00:59:22.100
So if this was a few weeks ago, I might ask you a little more about the GDPR and get your thoughts on that.

00:59:22.100 --> 00:59:23.580
But there's something bigger to talk about.

00:59:23.940 --> 00:59:26.360
So you talked about using GitHub Enterprise.

00:59:26.360 --> 00:59:28.900
Like I'm super invested in GitHub.

00:59:28.900 --> 00:59:34.380
I just checked like right now, the time of recording, I have 134 repositories in GitHub.

00:59:34.380 --> 00:59:36.360
That's a lot.

00:59:36.360 --> 00:59:40.960
And many of those are private ones, like supporting my various things, but a lot of them are public as well.

00:59:40.960 --> 00:59:45.540
So the big news, like last week, was that Microsoft acquired GitHub.

00:59:45.540 --> 00:59:46.180
Yes.

00:59:46.360 --> 00:59:47.080
What was your first thought?

00:59:47.080 --> 00:59:47.660
Oh boy.

00:59:47.660 --> 00:59:49.760
That was my first thought.

00:59:49.760 --> 00:59:50.080
Yeah.

00:59:50.080 --> 00:59:59.860
I'm not a Microsoft fan, but I am willing to admit that they have a different direction, which I like, which is way more embracing of open source.

00:59:59.860 --> 01:00:05.080
They are the world's greatest, biggest open source contributor today.

01:00:05.080 --> 01:00:08.900
Which is like, think about where we are, just that you said that.

01:00:08.900 --> 01:00:09.700
Like, that's crazy.

01:00:09.700 --> 01:00:10.140
Yep.

01:00:10.720 --> 01:00:17.320
They have incorporated Linux into Windows, sort of.

01:00:17.320 --> 01:00:21.520
They have contributed a significant amount of work to Docker.

01:00:21.520 --> 01:00:23.480
And GitHub, or Git itself, actually.

01:00:23.480 --> 01:00:25.140
The Git virtual file system.

01:00:25.140 --> 01:00:33.460
And Git, yes, with the Git virtual file system, which was a huge contribution, especially for folks doing large single repository code bases.

01:00:33.460 --> 01:00:37.860
So that's, for me, that's a good direction.

01:00:38.360 --> 01:00:44.300
Unfortunately, the track record so far hasn't been all that great, even with their most recent acquisitions.

01:00:44.300 --> 01:00:50.880
The most common one that I hear and that I have problems with is Skype and where that wound up with.

01:00:50.880 --> 01:00:54.600
But some folks also complain about how LinkedIn is going.

01:00:54.600 --> 01:00:55.780
I don't know.

01:00:55.780 --> 01:00:57.000
So I don't know.

01:00:57.000 --> 01:01:00.860
Internally, there was a lot of outcry from the community.

01:01:01.520 --> 01:01:09.220
But equally, there's a lot of Microsoft developers that are like, well, but we at Microsoft love GitHub just as much as you guys do.

01:01:09.220 --> 01:01:11.840
And I genuinely believe that.

01:01:11.840 --> 01:01:19.500
It's not about whether the folks contributing to the code like it or not or want to keep it going or not.

01:01:19.860 --> 01:01:40.220
It's the fact that now you've concentrated the majority of open source projects in a business that has its own languages, its own platforms, its own software, which you could maybe wind up getting biases for.

01:01:40.460 --> 01:01:43.980
And once it's there, it's just going to be more complicated.

01:01:43.980 --> 01:01:47.980
There's also questions about IP that people brought up.

01:01:47.980 --> 01:01:50.860
I don't know how much that's a thing.

01:01:50.860 --> 01:01:55.080
But, you know, technically, everybody had access to all those repos anyway.

01:01:55.080 --> 01:01:57.740
But I guess now they get access to all the private ones, too.

01:01:57.740 --> 01:01:58.860
So I don't know.

01:01:59.060 --> 01:01:59.260
Yeah.

01:01:59.260 --> 01:02:00.900
So a couple of thoughts.

01:02:00.900 --> 01:02:03.620
Yeah, I definitely sort of felt similar to what you're saying.

01:02:03.620 --> 01:02:08.960
Like, I don't think Microsoft has any sort of bad intentions towards GitHub.

01:02:08.960 --> 01:02:09.880
I think they do.

01:02:09.880 --> 01:02:10.160
Right.

01:02:10.160 --> 01:02:11.180
I think they do really love it.

01:02:11.180 --> 01:02:12.280
They're really invested in it.

01:02:12.280 --> 01:02:17.840
However, you know, they could fumble, fumble it and just make it not so nice.

01:02:17.840 --> 01:02:18.000
Right.

01:02:18.000 --> 01:02:22.780
I don't think they would like intentionally shut it down or do something to make it less good.

01:02:22.780 --> 01:02:25.400
But they certainly could try to make it better and make it worse.

01:02:25.700 --> 01:02:27.080
That is a thing that could happen.

01:02:27.080 --> 01:02:29.920
The IP part is pretty interesting.

01:02:29.920 --> 01:02:34.320
What really surprised me is there's an article called, it was on Ars Technica.

01:02:34.320 --> 01:02:38.040
That's one of my favorite places to read this kind of stuff because the comments are great.

01:02:38.040 --> 01:02:41.940
It says, everyone complaining about Microsoft buying GitHub needs to offer a better solution.

01:02:41.940 --> 01:02:47.060
And they really went through point by point, like how GitHub was actually in pretty big trouble.

01:02:47.060 --> 01:02:47.720
Yeah.

01:02:47.720 --> 01:02:53.860
And at some point, this is almost like, would you rather not have GitHub or have a GitHub that Microsoft owns?

01:02:54.340 --> 01:02:57.000
Rather than, well, I want GitHub to be this free thing.

01:02:57.000 --> 01:03:00.780
Like to me, the biggest negative here is, it's just consolidation.

01:03:00.780 --> 01:03:01.500
Right.

01:03:01.500 --> 01:03:06.580
Like there was this sort of independent place where open source could go be its thing.

01:03:06.580 --> 01:03:08.600
And everybody was on sort of equal footing.

01:03:08.600 --> 01:03:12.060
And now it's been consolidated into one of the big five tech companies.

01:03:12.060 --> 01:03:17.120
And that just, that's just different and not necessarily better.

01:03:17.120 --> 01:03:24.100
But after reading this, this Ars Technica article, I felt much better about it because I didn't realize the alternative was as bad as it.

01:03:24.100 --> 01:03:24.900
It could be.

01:03:24.900 --> 01:03:31.480
But I mostly don't like the fact that it's just consolidating further in the whole tech space.

01:03:31.480 --> 01:03:32.840
I think that is the main concern.

01:03:32.840 --> 01:03:33.580
I agree.

01:03:33.580 --> 01:03:46.460
I think after going through this, I think it becomes a bit more obvious that we kind of, I think I said this over Twitter, we kind of need like a Mozilla software foundation of open source repositories kind of thing.

01:03:46.460 --> 01:03:47.100
Yeah.

01:03:47.200 --> 01:03:57.220
Like an independent body that's somehow funded that whose sole purpose is to just, you know, you put stuff up there and it's going to stay there and, you know, we'll keep it up kind of thing.

01:03:57.220 --> 01:03:59.900
And that would alleviate the concerns a bit.

01:03:59.900 --> 01:04:00.300
It would.

01:04:00.380 --> 01:04:05.520
I think on the positive side, I think, you know, Microsoft has done a good job with Xamarin, right?

01:04:05.520 --> 01:04:12.840
And that was open source sort of, you know, they, I think that that's stronger now than it has been as part of them taking it over.

01:04:12.840 --> 01:04:17.680
So there's one, you know, check for maybe the win, win box, you know, Microsoft's part of the Linux foundation.

01:04:17.680 --> 01:04:20.480
And they're like, there's signs that this is going to go well.

01:04:20.480 --> 01:04:22.420
There's like you said, Skype example.

01:04:22.420 --> 01:04:24.580
So there's also signs where it might not go so well.

01:04:24.640 --> 01:04:26.700
So I think it's, it's up in the air.

01:04:26.700 --> 01:04:29.860
My concern is the two things like it could just get fumbled and messed up.

01:04:29.860 --> 01:04:34.220
But the fact that they're running GitHub as an independent organization, it's really good.

01:04:34.220 --> 01:04:44.780
The fact that Nate, the guy that was one of the co-founders of Xamarin is running, going to be the CEO of GitHub, where apparently they were struggling to get a CEO at all.

01:04:44.780 --> 01:04:46.080
There's like a big problem there.

01:04:46.080 --> 01:04:49.940
So anyway, it's, I think it's, it's pretty interesting.

01:04:49.940 --> 01:04:51.900
Fingers crossed for a positive result.

01:04:51.900 --> 01:04:52.260
Yeah.

01:04:52.340 --> 01:04:57.520
And from the business perspective as well, you know, Microsoft, I'm sure it makes perfect sense for them.

01:04:57.520 --> 01:05:03.880
They just spent all this time into the Git virtual file system stuff and they just moved all their stuff over to that.

01:05:03.880 --> 01:05:06.300
So they want to secure a future for that.

01:05:06.300 --> 01:05:06.600
Right.

01:05:06.600 --> 01:05:09.280
And this is their, this is their way of doing that.

01:05:09.280 --> 01:05:09.460
Yeah.

01:05:09.460 --> 01:05:17.520
I guess the other thing is that sort of gives me sort of a positive outlook, I guess, is at least the way I've seen it these days.

01:05:17.560 --> 01:05:22.740
It's like, if you want to understand what Microsoft is doing or why they're doing it, the answer is Azure.

01:05:22.740 --> 01:05:24.440
And then you've got to figure out what the question is.

01:05:24.440 --> 01:05:26.720
Like, obviously it's for Azure, Azure, Azure.

01:05:26.720 --> 01:05:28.360
They're just trying to grow Azure.

01:05:28.360 --> 01:05:32.660
Like they could just care less about windows or to some degree office, right?

01:05:32.660 --> 01:05:35.800
Like they see like the new lock-in is the cloud.

01:05:35.800 --> 01:05:37.160
And how do we go be part of that?

01:05:37.160 --> 01:05:39.740
And you know, all the different technologies run there.

01:05:39.740 --> 01:05:49.460
So I think that that's going to put some pressure to keep it more fair handed rather than say it's only .NET or it's only windows or any of these sort of pressures that you kind of hinted at at the beginning.

01:05:49.460 --> 01:05:49.840
Yep.

01:05:49.840 --> 01:05:50.400
Agreed.

01:05:50.400 --> 01:05:50.800
All right.

01:05:50.800 --> 01:05:52.200
Well, I guess we'll leave it there.

01:05:52.200 --> 01:05:54.960
We could go, we could have a whole show on the thoughts of the Git application.

01:05:54.960 --> 01:05:56.420
Maybe I will at some point.

01:05:56.420 --> 01:06:00.520
At first I was like, oh boy, this is probably going to get messed up somehow.

01:06:01.580 --> 01:06:10.160
But after spending a week doing more research, I'm kind of like, well, it looked kind of like it was necessary and it's probably the least bad outcome that we're going to get.

01:06:10.160 --> 01:06:11.920
So, you know, fingers crossed.

01:06:11.920 --> 01:06:12.760
Yeah, for sure.

01:06:12.760 --> 01:06:13.100
Cool.

01:06:13.100 --> 01:06:13.360
All right.

01:06:13.360 --> 01:06:16.540
So let me hit you with the last two questions before you get out of here, Chris.

01:06:16.540 --> 01:06:18.360
So notable PyPI package.

01:06:18.360 --> 01:06:19.480
We covered a bunch actually.

01:06:19.480 --> 01:06:27.680
The two that I would bring out out of the whole list, which since we're kind of talking about async stuff as well as async SSH.

01:06:27.680 --> 01:06:29.180
Forget about Parameco.

01:06:29.180 --> 01:06:30.460
Async SSH does it better.

01:06:31.160 --> 01:06:37.340
And there's, and the WebSockets module, which it's pretty good if you're doing anything with WebSockets.

01:06:37.340 --> 01:06:37.660
Nice.

01:06:37.660 --> 01:06:44.500
And so final call to action, people want to bring continuous delivery into their whole workflow, their life, their team.

01:06:44.500 --> 01:06:45.580
How do they get started?

01:06:45.580 --> 01:06:55.260
The first thing to do is to, we kind of touched on it a little bit earlier, is step back, analyze what benefits you get out of it and what problems you're trying to solve.

01:06:55.540 --> 01:07:03.060
And then slowly go through it and put something in place where, you know, my end result is going to be X, a delivered package of this here.

01:07:03.460 --> 01:07:08.740
And I need to guarantee that it works in pieces at different steps of the way.

01:07:08.740 --> 01:07:11.580
And figure out the effort to make that happen.

01:07:11.580 --> 01:07:16.660
If the effort is really, really, really, really, really large, then maybe it's not worth it for you.

01:07:16.660 --> 01:07:16.900
Cool.

01:07:17.060 --> 01:07:21.700
Well, I really appreciate you coming and sharing what you guys are up to because you definitely have it pretty dialed in.

01:07:21.700 --> 01:07:22.880
Yeah.

01:07:23.400 --> 01:07:24.120
Yeah, no problem.

01:07:24.120 --> 01:07:24.840
Glad to be here.

01:07:24.840 --> 01:07:26.520
It's always fun to have these conversations.

01:07:26.520 --> 01:07:26.860
Yeah.

01:07:26.860 --> 01:07:27.340
Thanks, Chris.

01:07:27.340 --> 01:07:31.280
This has been another episode of Talk Python to Me.

01:07:31.280 --> 01:07:33.240
Our guest has been Chris Medina.

01:07:33.240 --> 01:07:35.940
And this episode is brought to you by Linode and Rollbar.

01:07:35.940 --> 01:07:39.840
Linode is bulletproof hosting for whatever you're building with Python.

01:07:39.840 --> 01:07:44.160
Get four months free at talkpython.fm/Linode.

01:07:44.160 --> 01:07:45.940
That's L-I-N-O-D-E.

01:07:45.940 --> 01:07:48.640
Rollbar takes the pain out of errors.

01:07:48.720 --> 01:07:56.360
They give you the context and insight you need to quickly locate and fix errors that might have gone unnoticed until your users complain, of course.

01:07:56.360 --> 01:08:03.500
As Talk Python to Me listeners, track a ridiculous number of errors for free at rollbar.com slash Talk Python to Me.

01:08:03.500 --> 01:08:05.120
Want to level up your Python?

01:08:05.120 --> 01:08:12.160
If you're just getting started, try my Python jumpstart by building 10 apps or our brand new 100 days of code in Python.

01:08:12.160 --> 01:08:15.960
And if you're interested in more than one course, be sure to check out the Everything Bundle.

01:08:15.960 --> 01:08:18.200
It's like a subscription that never expires.

01:08:18.200 --> 01:08:20.400
Be sure to subscribe to the show.

01:08:20.400 --> 01:08:22.520
Open your favorite podcatcher and search for Python.

01:08:22.520 --> 01:08:23.840
We should be right at the top.

01:08:23.840 --> 01:08:33.140
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

01:08:33.140 --> 01:08:35.040
This is your host, Michael Kennedy.

01:08:35.040 --> 01:08:36.380
Thanks so much for listening.

01:08:36.380 --> 01:08:37.460
I really appreciate it.

01:08:37.460 --> 01:08:39.400
Now get out there and write some Python code.

01:08:39.400 --> 01:09:00.600
I really appreciate it.

