WEBVTT

00:00:00.001 --> 00:00:04.720
Python is special. It's used by the big tech companies, of course, but it's also used by

00:00:04.720 --> 00:00:10.480
those you would rarely classify as developers. On this episode, we get a look inside how Python

00:00:10.480 --> 00:00:16.960
is being used at a children's hospital to speed and improve patient care. We have Dr. Somac Roy

00:00:16.960 --> 00:00:22.800
here to share how he's using Python in his day to day job to help kids get well a little bit faster.

00:00:23.360 --> 00:00:30.080
This is Talk Python to Me, episode 470, recorded June 23rd, 2024.

00:00:30.080 --> 00:00:46.000
Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:46.000 --> 00:00:51.120
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython,

00:00:51.120 --> 00:00:57.120
both on mastodon.org. Keep up with the show and listen to over seven years of past episodes at

00:00:57.120 --> 00:01:03.040
talkpython.fm. We've started streaming most of our episodes live on YouTube. Subscribe to our

00:01:03.040 --> 00:01:09.040
YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of

00:01:09.040 --> 00:01:14.960
that episode. This episode is brought to you by Sentry. Don't let those errors go unnoticed.

00:01:14.960 --> 00:01:22.320
Use Sentry like we do here at Talk Python. Sign up at talkpython.fm/sentry. And it's brought to you

00:01:22.320 --> 00:01:27.920
by Posit Connect from the makers of Shiny. Publish, share and deploy all of your data projects that

00:01:27.920 --> 00:01:34.560
you're creating using Python. Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto, Reports,

00:01:34.560 --> 00:01:40.640
Dashboards and APIs. Posit Connect supports all of them. Try Posit Connect for free by going to

00:01:40.640 --> 00:01:47.920
talkpython.fm/posit. P-O-S-I-T. So, Mac, welcome to Talk Python. Awesome to have you here.

00:01:47.920 --> 00:01:52.800
Hey, thank you, Michael, for the introduction. I'm happy to be here. Excited.

00:01:52.800 --> 00:01:58.480
Yeah, I'm pretty excited to be talking about medicine and all the stuff that you guys are

00:01:58.480 --> 00:02:02.960
doing with Python. And I really like these kinds of shows because I think it's important to

00:02:02.960 --> 00:02:08.320
highlight that Python is not just for web developers and pure data science machine learning

00:02:08.320 --> 00:02:12.720
people, but it's used by this huge spectrum of people doing all sorts of interesting stuff and

00:02:12.720 --> 00:02:16.880
solving real problems with it. Right. And it sounds like you fall pretty solidly in that category.

00:02:16.880 --> 00:02:22.400
Yeah, absolutely. It was like, you know, Python has been sort of this discovery as I've gone

00:02:22.400 --> 00:02:27.280
through my career as a physician. And it's interesting how to begin with, when computer

00:02:27.280 --> 00:02:33.040
science, initially when I was training and growing up, it was hard to imagine medicine and computer

00:02:33.040 --> 00:02:37.680
science sort of being hand in hand together. But now I think things have progressed and there's a

00:02:37.680 --> 00:02:43.280
lot of technology that's now in medicine that allows you to do all kinds of things. And of

00:02:43.280 --> 00:02:52.880
course, as I've discovered Python, it brings in kind of the toolkit and the ability to be able to

00:02:52.880 --> 00:02:58.560
achieve and solve problems in a way that I think it's not been envisioned before. So it's a very

00:02:58.560 --> 00:03:03.120
exciting time. Yeah, it is a very exciting time. And I think it's just getting better and better.

00:03:03.120 --> 00:03:07.040
Before we get too far into this, tell people a quick bit about yourself, quick introduction.

00:03:07.040 --> 00:03:15.120
Yeah, absolutely. So I'm Somak Roy. I am a molecular pathologist. It's a type of physician

00:03:15.120 --> 00:03:26.160
who deals with looking at the genome of either a patient or patient's tissue. And we essentially

00:03:26.160 --> 00:03:35.680
look at all of these things in a way to be able to help manage patient's treatment. In my current

00:03:35.680 --> 00:03:41.440
position, I am an associate professor and the director of molecular pathology at Cincinnati

00:03:41.440 --> 00:03:48.880
Children's Hospital. My lab is a clinical lab that is under the division of pathology. And

00:03:48.880 --> 00:03:57.280
we do a lot of work that pertains to kids in terms of helping them diagnose and manage

00:03:57.280 --> 00:04:03.040
pediatric cancer, as well as infectious disease that happen in this age group.

00:04:04.640 --> 00:04:13.120
Molecular pathology, I essentially trained back in India as a physician, did my MD,

00:04:13.120 --> 00:04:16.480
and then came here, started in Pittsburgh, did my training in

00:04:16.480 --> 00:04:23.360
pathology and lab medicine. I specialized in molecular pathology. Then I was there in

00:04:23.360 --> 00:04:26.720
Pittsburgh. I worked for some time and then opened Cincinnati Children's.

00:04:26.720 --> 00:04:33.440
Excellent. Do you work directly with patients or do you get samples sent to you from other

00:04:33.440 --> 00:04:36.400
doctors and then you process them and analyze them?

00:04:36.400 --> 00:04:41.120
Yeah, that's a good question. So I do not work with patients directly. It's a kind of,

00:04:41.120 --> 00:04:48.080
it's a subspecialty in medicine where my lab works with the samples that have been collected

00:04:48.080 --> 00:04:55.120
in the patient either from the OR or a procedure or from the radiology suite. And then we work on

00:04:55.120 --> 00:05:02.080
that tissue or the blood sample or a bone marrow sample that comes to us. And yes, then all the

00:05:02.080 --> 00:05:08.480
testing that we perform is off from that specimen. And then once we generate the clinical reports

00:05:08.480 --> 00:05:15.280
back, they go back to the patient's chart and to the patients, to the clinicians who are treating

00:05:15.280 --> 00:05:21.920
and managing them. And then that way it helps how they're able to then get a diagnosis and then

00:05:21.920 --> 00:05:24.960
give the appropriate treatment and the management to the patient.

00:05:24.960 --> 00:05:30.240
Yeah, excellent. So yeah, you must see a lot of different stuff flying through the lab you have

00:05:30.240 --> 00:05:38.000
to analyze. So how did you go from, I'm studying medicine to I'm writing Python code and running

00:05:38.000 --> 00:05:45.440
automation and what was that process like? Well, that was an interesting journey for me.

00:05:45.440 --> 00:05:54.400
So before medicine and biology came into my life, I started off, it was second grade, I believe,

00:05:54.400 --> 00:06:02.800
when my dad, he got me a computer at that time, which is a 64 kilobyte small machine.

00:06:02.800 --> 00:06:09.360
I think it was for Toshiba MSX computers where you could write GW basic code and

00:06:09.360 --> 00:06:17.680
some basic predefined hex code and you can run small applications on that. That was my starting

00:06:17.680 --> 00:06:24.880
point. It was super exciting for me. And I think from there on, the journey went to, as I went

00:06:24.880 --> 00:06:34.560
through high school and then college, medicine was, I would say, biology was something that

00:06:34.560 --> 00:06:42.960
intrigued me. And at the same time, I also got interested in genetics, looking at DNA sequences.

00:06:42.960 --> 00:06:55.040
And I had a natural liking for the fact that I could study about the cell or the genome, the DNA

00:06:55.040 --> 00:07:01.120
and RNA. But also I realized that there was a lot of math and computation that you can use to slice

00:07:01.120 --> 00:07:06.880
and dice data. And at that time, the place that I grew in India was a very small place. So we didn't

00:07:06.880 --> 00:07:13.920
have access to resources like internet. So my exposure to internet was when I actually went to

00:07:13.920 --> 00:07:19.440
med school for the first time. Oh yeah, you can actually connect to other computers. So that's

00:07:19.440 --> 00:07:26.320
when I started my medicine. So obviously I did my training in medicine in medical school back in

00:07:26.320 --> 00:07:31.120
India. That's when I started to connect and talk to a lot of people. And some of my friends who

00:07:31.120 --> 00:07:40.160
actually were already writing apps at that time using Java applets and on browser. And so I started

00:07:40.160 --> 00:07:46.640
to make some connection in terms of images and learning how some of those things can be used in

00:07:46.640 --> 00:07:54.080
medicine. And so radiology, during my radiology rotation, that was my first real life, that was

00:07:54.080 --> 00:07:58.560
my realization that actually in medicine, you can use computers a lot to handle a lot of these

00:07:58.560 --> 00:08:04.560
and images, x-rays, CT scans. And I think as it went on, when I came to the US, that's where

00:08:04.560 --> 00:08:12.080
it really started off. During my residency in pathology here, I actually connected with my

00:08:12.080 --> 00:08:22.640
mentors, Dr. Anil Parwani and Dr. Leonard Pentamax. They are well-known pathology informaticists.

00:08:22.640 --> 00:08:28.640
They've spent a lot of their time sort of dwelling in the world of pathology, medicine, and

00:08:28.640 --> 00:08:34.480
computer science. And so that is when I could actually realize that, yes, you can do a lot of

00:08:34.480 --> 00:08:42.800
innovative stuff by developing apps, algorithms, analyzing either image data or molecular data.

00:08:42.800 --> 00:08:51.360
And so that is when I started to get into designing an app, which was a very simple web app that was

00:08:51.360 --> 00:08:57.040
a project I was working with one of my mentors. And so his idea was that we had a lot of these

00:08:57.040 --> 00:09:03.360
pathology images and we wanted to create a little in-browser app that would display these images as

00:09:03.360 --> 00:09:07.600
thumbnails and then clicking the art that could enlarge the image, show that on display.

00:09:07.600 --> 00:09:16.800
And so I used, at that time, it was .NET framework to be ASP.NET. And so I created a little app using

00:09:16.800 --> 00:09:23.840
Visual Basic. Slowly I then migrated to using C# in the same environment. And that time,

00:09:23.840 --> 00:09:33.760
I started my advanced fellowship training in molecular pathology. That's when I started there.

00:09:33.760 --> 00:09:37.600
That's when I realized there's a lot of genomic sequencing data where essentially you're dealing

00:09:37.600 --> 00:09:42.720
with a lot of strings and numbers. And you have to make a lot of sense in terms of this large

00:09:42.720 --> 00:09:47.840
volume of data that comes in. - If we're working with, so the kind of data that you're working with

00:09:47.840 --> 00:09:55.760
for say this genetic stuff. - Yes. - For us, for when you're studying the genomics, so how much

00:09:55.760 --> 00:10:00.320
data is in say one strand of DNA? How much of that do you actually care about? Like, give me,

00:10:00.320 --> 00:10:06.960
give us a sense of sort of how much data we're talking. - Right. So it really depends on what

00:10:06.960 --> 00:10:14.160
has been done. And so when we look at, so when we talk about genomics, it is really designed on how

00:10:14.160 --> 00:10:20.160
the experiment is done. So for example, if we just simply look at the entire human genome, we are

00:10:20.160 --> 00:10:30.160
talking about 3 billion alphabets. Essentially it's the combination of four alphabets, A, T, G,

00:10:30.160 --> 00:10:35.520
and C. So these are the four nucleotides of the DNA sequence. And the RNA has one additional one

00:10:36.080 --> 00:10:41.680
which replaces A. But the idea is that it's a mix and match of these sequences. And so if you think

00:10:41.680 --> 00:10:48.720
about the entire human genome as a single thread of A, T, G, and Cs in various combinations,

00:10:48.720 --> 00:10:54.640
you're looking at 3 billion alphabets. And so what happens is when we do these sequencing

00:10:54.640 --> 00:11:01.520
experiments where you would take the DNA molecule from a bunch of cells within a tissue, and then

00:11:02.640 --> 00:11:08.960
either we read all the 3 billion base pairs. And typically the way the sequencing is done is you

00:11:08.960 --> 00:11:16.800
read all of these sequences from many molecules. And so you'll have multiple copies of that when

00:11:16.800 --> 00:11:24.800
you're translating from a molecular, like a chemical molecular structure to a DNA sequence

00:11:24.800 --> 00:11:31.680
on say a plat file in a file system. So if you look at that large scale of data, like the entire

00:11:31.680 --> 00:11:38.000
genome, we are talking of hundreds of gigabytes, maybe even terabyte worth of data. Then there are

00:11:38.000 --> 00:11:43.200
other more practical approaches when we look at the genome. And especially this is something that

00:11:43.200 --> 00:11:48.000
we use for day-to-day patient care, which is referred to as targeted sequencing. What that

00:11:48.000 --> 00:11:54.960
means is instead of the 3 billion base pairs, we focus on those regions of the human genome

00:11:54.960 --> 00:12:01.600
that are of most pertinent use, or that we at least as a current field of genomics, that we

00:12:01.600 --> 00:12:07.120
understand what to do with. And so there are certain genes that at least in the space I work

00:12:07.120 --> 00:12:16.400
with, cancer genomics, that are, I would say close to about maybe a thousand to 2,000 genes,

00:12:16.400 --> 00:12:23.600
which are known to be cancer associated. And of that, roughly about five to 700 genes are where

00:12:23.600 --> 00:12:28.880
we know that they have been studied and demonstrated that there are certain types of

00:12:28.880 --> 00:12:33.920
abnormalities in those genes in terms of the sequence changes, that they have certain meaning

00:12:33.920 --> 00:12:42.320
in context of tumor in order to make a diagnosis or to understand if the tumor is aggressive or

00:12:42.320 --> 00:12:47.760
benign, or if there are certain treatments that could be applied to those tumors. And that's

00:12:47.760 --> 00:12:54.400
specifically linked to the kind of sequence change you see in that region of the genome.

00:12:54.400 --> 00:13:01.040
And we are talking about, practically speaking, when we talk about the targeted testing that we

00:13:01.040 --> 00:13:07.040
do, it's a very small fraction of the large genome. Typically there's a term known as exome

00:13:07.040 --> 00:13:13.600
sequencing, and exome sequencing refers to sequencing all those regions of the human genome

00:13:13.600 --> 00:13:21.120
where it at least encodes for one or the other anodic gene. That is typically about one to 2%

00:13:21.120 --> 00:13:25.680
of the entire genome. And so if we further narrow it down to about say five, 600 genes,

00:13:25.680 --> 00:13:34.160
that one would typically sequence for practical cancer molecular testing. I would say that's

00:13:34.160 --> 00:13:39.360
probably about a tenth, or maybe slightly less than that, of the genome, but it's a very high

00:13:39.360 --> 00:13:45.120
yield from a clinical standpoint, because the most alteration you will find that would help

00:13:45.120 --> 00:13:52.480
with the clinical treatment is high. So if we're going to talk about that dataset, it's complex in

00:13:52.480 --> 00:14:00.720
a different way because just looking at the raw sequence data would be somewhere in, I would say,

00:14:00.720 --> 00:14:08.080
one to 20 gigs from a single sequence file, but it entirely depends on how deep we go.

00:14:08.080 --> 00:14:13.440
So for example, when we talk about sequencing, as I mentioned before, when we sequence a molecule,

00:14:13.440 --> 00:14:20.560
we can sequence it either at certain depths, that means what level of redundancy you want

00:14:20.560 --> 00:14:27.280
to be able to read that molecule. Sometimes we read the molecules 20 to 30 times, so that's

00:14:27.280 --> 00:14:32.880
referred to as 30x, or sometimes we'll read that 500 times, so that will be 500x.

00:14:32.880 --> 00:14:38.080
>> You do that because you want to make sure you don't misread the gene?

00:14:38.080 --> 00:14:43.520
>> Yes. So, right. So what happens is the greater the depth of sequence, so typically for

00:14:43.520 --> 00:14:52.960
such large panels that we sequence in a clinical setting, we usually target about 1500x to 2000x,

00:14:52.960 --> 00:14:58.240
that means we're reading that 2000 times. So the more the depth it is, the possibility of identifying

00:14:59.520 --> 00:15:03.840
a certain variation or genomic alteration that is present at a very low level. For example, say,

00:15:03.840 --> 00:15:10.720
you have a tumor cell and within that, only 2% of the cells have this mutation, others don't.

00:15:10.720 --> 00:15:16.720
And so when you're looking for or hunting for these needles in a haystack, you really want to

00:15:16.720 --> 00:15:21.040
maximize the amount of depth you have to be able to pick those things up. So it really depends on

00:15:21.040 --> 00:15:26.400
how deep we go. The more deep we go, the more data it is, and so it can scale up to almost

00:15:26.400 --> 00:15:29.280
several hundred gigabytes. >> Sure. Yeah, I've always

00:15:29.280 --> 00:15:35.680
wondered about how you can go and read somebody's genetics and then not make a mistake when you're

00:15:35.680 --> 00:15:41.840
using chemicals to read. So, but it's really ridiculous how much data is there.

00:15:41.840 --> 00:15:46.880
Off by one, a C for a G or whatever is a bad thing, right?

00:15:46.880 --> 00:15:56.480
>> Right. But it is, I think as the technology has matured, there's not a hundred percent in terms

00:15:56.480 --> 00:16:01.200
of the error profile for the enzyme that has been used to work, the technology that is reading the

00:16:01.200 --> 00:16:07.200
actual fluorescence converting that to signal. There's always statistical values and probabilities

00:16:07.200 --> 00:16:12.160
that are associated with what is the probability that it is wrong or incorrect or correct.

00:16:12.160 --> 00:16:18.160
But within that frame and where the current technology is, it's pretty accurate for,

00:16:18.160 --> 00:16:23.520
if not all, many of the regions of the genome. And so it's mind-baffling how it works.

00:16:23.520 --> 00:16:29.120
>> Yeah, it really is quite amazing. It's one of the modern marvels of science for sure.

00:16:29.120 --> 00:16:32.640
>> It is, it is. >> This portion of Talk Python

00:16:32.640 --> 00:16:38.240
to Me is brought to you by Sentry. Code breaks, it's a fact of life. With Sentry, you can fix it

00:16:38.240 --> 00:16:44.640
faster. As I've told you all before, we use Sentry on many of our apps and APIs here at Talk Python.

00:16:44.640 --> 00:16:50.240
I recently used Sentry to help me track down one of the weirdest bugs I've run into in a long time.

00:16:50.240 --> 00:16:55.680
Here's what happened. When signing up for our mailing list, it would crash under a non-common

00:16:55.680 --> 00:17:01.440
execution path, like situations where someone was already subscribed or entered an invalid email

00:17:01.440 --> 00:17:07.440
address or something like this. The bizarre part was that our logging of that unusual condition

00:17:07.440 --> 00:17:13.920
itself was crashing. How is it possible for her log to crash? It's basically a glorified

00:17:13.920 --> 00:17:18.400
print statement. Well, Sentry to the rescue. I'm looking at the crash report right now,

00:17:18.400 --> 00:17:23.200
and I see way more information than you would expect to find in any log statement. And because

00:17:23.200 --> 00:17:28.240
it's production, debuggers are out of the question. I see the trace back, of course,

00:17:28.240 --> 00:17:34.480
but also the browser version, client OS, server OS, server OS version, whether it's production

00:17:34.480 --> 00:17:39.200
or Q&A, the email and name of the person signing up, that's the person who actually experienced

00:17:39.200 --> 00:17:44.000
the crash, dictionaries of data on the call stack, and so much more. What was the problem?

00:17:44.000 --> 00:17:51.120
I initialized the logger with the string info for the level rather than the enumeration dot info,

00:17:51.120 --> 00:17:56.720
which was an integer-based enum. So the logging statement would crash, saying that I could not

00:17:56.720 --> 00:18:04.240
use less than or equal to between strings and ints. Crazy town. But with Sentry, I captured it,

00:18:04.240 --> 00:18:09.360
fixed it, and I even helped the user who experienced that crash. Don't fly blind. Fix

00:18:09.360 --> 00:18:15.360
code faster with Sentry. Create your Sentry account now at talkpython.fm/sentry. And if you

00:18:15.360 --> 00:18:22.240
sign up with the code TALKPYTHON, all capital, no spaces, it's good for two free months of Sentry's

00:18:22.240 --> 00:18:26.880
business plan, which will give you up to 20 times as many monthly events as well as other features.

00:18:26.880 --> 00:18:34.480
So I think you're a little bit unusual, a little bit weird in the sense that you got in as your

00:18:34.480 --> 00:18:40.720
first sort of programming thing to bring to apply to your science and medicine side of things was

00:18:40.720 --> 00:18:51.040
C# rather than, or VB.NET, rather than something like Python or R or something. So maybe talk a

00:18:51.040 --> 00:18:56.160
bit about that experience, contrast it with Python. Why do you end up moving to Python?

00:18:56.160 --> 00:19:04.640
Yeah. So I think the reason I started using VB.NET C# was I would say most,

00:19:04.640 --> 00:19:12.320
it was probably influenced a lot by at the time when I was doing my med school in India. What

00:19:12.320 --> 00:19:16.160
was available at that time, it was not something I would just go to the internet and start getting a

00:19:16.160 --> 00:19:21.760
lot of resources as one would do now. So it was pretty much like, this is the book I have available

00:19:21.760 --> 00:19:32.240
and that's the only thing. So you start. But the thing is when I started applying C# and it was

00:19:32.240 --> 00:19:38.640
mostly C# and a little bit of C++ and I started to get into like with some of the non-genetic stuff

00:19:38.640 --> 00:19:44.960
initially, well, the project I'm working on, it was not too bad because I was able to accomplish

00:19:44.960 --> 00:19:51.920
most of the tasks. But then once I got into genomics and I came, so the way professionals

00:19:51.920 --> 00:19:58.160
who get into genomics and molecular pathology, there are a couple of different routes. So

00:19:58.160 --> 00:20:04.160
either the physician, people who are physician trained and they have a formal background in

00:20:04.160 --> 00:20:09.920
medicine and they do a specialized training and then they become molecular pathologists

00:20:09.920 --> 00:20:14.240
after getting board certified. There is the other route, which is more of a research background,

00:20:14.240 --> 00:20:20.240
where people have spent a lot of their time in really deep research. They've learned a lot of

00:20:20.240 --> 00:20:25.840
genomics hands-on, either from a computational background or from a more laboratory, like a

00:20:25.840 --> 00:20:32.240
wet laboratory background. And so they've obviously done their PhDs and postdoc training and then

00:20:32.240 --> 00:20:39.600
sort of come into the molecular pathology field. People starting there tend to have more of a

00:20:40.720 --> 00:20:45.760
formal computational training. So they're getting, they usually get, obviously when you start with a

00:20:45.760 --> 00:20:49.840
research lab, R, Python are sort of like the most common tools that are used for

00:20:49.840 --> 00:20:56.000
any kind of data analysis and data visualization. Coming from more of a foreign medicine background,

00:20:56.000 --> 00:21:03.360
and typically when we get training in clinical informatics or pathology informatics,

00:21:03.360 --> 00:21:11.280
often it is very, I would not say corporate based, but very formal application development space.

00:21:11.280 --> 00:21:17.680
So it's a lot of Windows based, .NET, C#, C++, that kind of thing.

00:21:17.680 --> 00:21:23.120
Standard enterprise stack. Yeah. Java or .NET is a perfect choice. Yeah. Okay.

00:21:23.120 --> 00:21:28.640
In bioinformatics, at least in genomics bioinformatics, the ecosystem of tools available,

00:21:28.640 --> 00:21:34.960
it's a mishmash of everything. For anything which is very computationally intensive, like when you're

00:21:34.960 --> 00:21:40.160
trying to align sequences to the human genome, those are very intensive tasks. And typically

00:21:40.160 --> 00:21:49.520
it's a lot of C, C++, Java, that's involved in some of these very mainstream tools that are

00:21:49.520 --> 00:21:54.480
available. More recently, I think we are seeing Rust coming into the picture as well. There's

00:21:54.480 --> 00:21:59.840
some Volang applications. And then of course, Python and R are the predominant, I think,

00:21:59.840 --> 00:22:04.560
tools as the programming language that are used to solve all of these problems.

00:22:04.560 --> 00:22:10.640
So when I started my molecular pathology fellowship and I got into, now I had to do

00:22:10.640 --> 00:22:17.120
this project that involved manipulating all the sequence data to a point where we would be able

00:22:17.120 --> 00:22:21.760
to develop an application that would help, it's a web-based application that could help

00:22:22.240 --> 00:22:30.160
for other pathologists and faculty to read that sequencing data and digest in a very way that's

00:22:30.160 --> 00:22:35.360
easy for them to look at it rather than going to the Linux terminal and opening up raw files and

00:22:35.360 --> 00:22:41.840
things like that. So I used, that was my first project was to use C# in that context. But I

00:22:41.840 --> 00:22:45.040
quickly realized that there was a lot of these algorithms that were natively either written in

00:22:45.040 --> 00:22:51.680
R or Python and then having to incorporate those functionalities was not as easily possible.

00:22:51.680 --> 00:22:57.200
So I had to rewrite a lot of those things in C#, Python primarily. It was a good learning curve,

00:22:57.200 --> 00:23:01.280
but I think from a main derivative perspective, it was getting really difficult. And so that's

00:23:01.280 --> 00:23:08.080
when we realized it was that I think a combination of Linux and Python was, I had to move towards.

00:23:08.080 --> 00:23:12.720
Yeah. C# probably from the timeframe that you're thinking about, didn't really have a great package

00:23:12.720 --> 00:23:18.720
manager story, not to the same degree that Python does. Although they do pretty good now over in

00:23:18.720 --> 00:23:24.400
the continent land. Right. Yeah. All right. So a good question from Chris in the audience says,

00:23:24.400 --> 00:23:28.880
is there a reason to use Python specifically? Like, are there some special sauce packages

00:23:28.880 --> 00:23:32.640
that make it attractive? It sounds like that's kind of what you were getting at. Like you found

00:23:32.640 --> 00:23:37.840
more solutions to these algorithms than, you know, available in Python than in C#.

00:23:37.840 --> 00:23:39.840
Yeah. Whatever languages. Yeah.

00:23:39.840 --> 00:23:45.440
Right. So I think, I mean, I think the simple answer is yes. I think the community and the

00:23:45.440 --> 00:23:49.920
amount of work that has been done in this particular space with genomics, I mean, when you

00:23:49.920 --> 00:23:54.720
are really searching for applications, it kind of falls into these three categories of, you know,

00:23:54.720 --> 00:24:01.360
anything which is a high performance compiling program that is usually in the rust, C++, C,

00:24:01.360 --> 00:24:07.520
a lot of those languages, a little bit of rust and Java. And then the other bin is essentially

00:24:07.520 --> 00:24:14.720
kind of, you know, split up into Python and R. I think for me, Python was, and I think I'm sure

00:24:14.720 --> 00:24:19.520
others have shared the same way where it's almost like, wow, this is amazing. Like coming from C#,

00:24:19.520 --> 00:24:23.600
it was a little bit of a change because there's no more, like, you know, curly braces.

00:24:23.600 --> 00:24:28.080
Think about the whole things. But I think the job

00:24:28.080 --> 00:24:29.120
You don't miss your semicolons.

00:24:29.120 --> 00:24:34.400
Kind of. Like even now, sometimes when I write like a little bit of JavaScript,

00:24:34.400 --> 00:24:36.160
I feel like, oh, yeah, okay, this semicolon is here.

00:24:36.160 --> 00:24:37.840
Exactly.

00:24:37.840 --> 00:24:43.520
The curly braces. But, you know, not too bad. I think what I got onto was like the simplicity

00:24:43.520 --> 00:24:48.720
of the language and how powerful it was when, like, if I'm thinking about, you know, it was

00:24:48.720 --> 00:24:55.840
interesting when I had to do something like there was an algorithm where I had to parse out certain,

00:24:55.840 --> 00:25:05.680
you know, strings in a way where it required some known workflows that we used to do, like,

00:25:05.680 --> 00:25:10.640
variant annotations when we're cross referencing databases and putting them together. You know,

00:25:10.640 --> 00:25:16.640
when you look for in terms of C# packages, there's really nothing there for it natively to do it. So

00:25:16.640 --> 00:25:20.880
you have to write a lot of those things. In Python, the amount of time that is spent

00:25:20.880 --> 00:25:26.720
in developing those things is much faster. Like the development time itself is quick because

00:25:26.720 --> 00:25:30.240
you either get an idea of somebody who's already done the work or there's a more

00:25:30.240 --> 00:25:34.400
formal package that you can use. So I think initially when I started off,

00:25:34.400 --> 00:25:41.600
BioPython was a very interesting collection of packages. It was like a tool suite essentially

00:25:41.600 --> 00:25:47.360
written to, you know, to have all these functions available for very common day to day tasks.

00:25:47.360 --> 00:25:53.360
You know, I want to query a certain region of the BAM file or I want to parse out certain things in

00:25:53.360 --> 00:26:00.480
the FASTQ file to look at some of the sequences or doing, you know, counting number of sequences

00:26:00.480 --> 00:26:05.040
in a given file and, you know, getting read counts, things like that was, it's all out of

00:26:05.040 --> 00:26:09.040
the box. And so that was sort of like the first thing to go, "Wow, this is amazing." I mean,

00:26:09.040 --> 00:26:13.520
somebody's already done the work and we're just using it on top of it.

00:26:13.520 --> 00:26:17.680
Yeah. Instead of creating these, I'll just like use those. Perfect.

00:26:17.680 --> 00:26:24.880
Right. So that was one. And the other motivation to use Python was, you know, say for example,

00:26:24.880 --> 00:26:29.680
why not R? Why Python? Because R offers a very rich ecosystem in, you know, at least in genomics

00:26:29.680 --> 00:26:37.280
and visualization. So I think the second thing was in terms of the idea that I was working on was

00:26:37.280 --> 00:26:42.800
having to develop a web application and all of these bioinformatics, you know, toolings and

00:26:42.800 --> 00:26:46.640
algorithms running sort of in the back. And so at that time it was like, okay, well, you know,

00:26:46.640 --> 00:26:51.440
Python, I've not heard much about in terms of web application. Mostly it was, you know, again,

00:26:51.440 --> 00:26:57.600
this big, like, you know, C#.net. That was why I started off, you know, with that. But then at that

00:26:57.600 --> 00:27:02.000
time, you know, there was Django and then Flask was sort of coming in. It was a very minimalistic,

00:27:02.000 --> 00:27:06.240
you know, sort of application. So I started focusing on that. It was very easy with Flask to,

00:27:06.240 --> 00:27:12.320
you know, get up and running with very simple, you know, applications to do that. I didn't try

00:27:12.320 --> 00:27:18.080
much into Django just because it was too bloated for me. But, you know, Flask was great. And then

00:27:18.080 --> 00:27:22.800
what I realized was you can create a simple web application, but then at the same time,

00:27:22.800 --> 00:27:27.760
you can use all your, you know, my pythons and all the wonderful bioinformatics packages in the

00:27:27.760 --> 00:27:33.360
backend. So it's like a single language that lets you do both. And so this is great. It was just,

00:27:33.360 --> 00:27:38.560
I don't have to go anywhere to learn, you know, a third or a fourth or fifth different programming

00:27:38.560 --> 00:27:42.480
language. And this just gets the job done. Yeah. Keep it in mind that your actually main,

00:27:42.480 --> 00:27:47.760
your main job is medicine, not programming, right? It's not a CS person. It's just all after

00:27:48.320 --> 00:27:52.480
out to learn all the languages, right? Right, right, right. So that definitely is,

00:27:52.480 --> 00:27:59.120
again, that's a huge, you know, I would say I'm, again, as I said, I'm in a, I'm sort of

00:27:59.120 --> 00:28:03.440
in an unusual position where I'm, you know, a physician, but I also do a lot of these

00:28:03.440 --> 00:28:09.040
application developments. So that certainly is an important point in terms of how much time I have

00:28:09.040 --> 00:28:13.360
to be able to develop these prototypes. And then obviously, you know, typically the way it works is

00:28:13.360 --> 00:28:19.760
at least right now here, you know, where I am currently working, I have an excellent and amazing

00:28:19.760 --> 00:28:25.280
team of developers and bioinformations who really do a lot of the development work on the front end,

00:28:25.280 --> 00:28:31.920
back end. And so for me to be able to take additional time out of my, you know, the clinical

00:28:31.920 --> 00:28:36.640
and the patient care work is limited. So if I can get whatever prototype I'm thinking of,

00:28:36.640 --> 00:28:40.480
we're developing the application fast, then, you know, that's, that's what I'm going for.

00:28:40.480 --> 00:28:45.360
And so you can hand it off to the team and let them polish it up and product,

00:28:45.360 --> 00:28:50.800
make it production ready, basically. Yeah. Yeah. I was wondering how much time of your,

00:28:50.800 --> 00:28:55.040
your job do you get to spend on these kinds of things, you know, finding new packages,

00:28:55.040 --> 00:29:00.480
optimizing or improving the ways that you're working on stuff versus just sort of handing

00:29:00.480 --> 00:29:05.520
it off to the folks you work with and, and keeping, you know, focus more on the medicine side.

00:29:05.520 --> 00:29:12.800
Yeah. So it you know, that, that I think it's a good question. I think it's, it's evolved over

00:29:12.800 --> 00:29:16.880
time as I've been, you know, being sort of, you know, when I was in training and then being a

00:29:16.880 --> 00:29:22.800
faculty and then, you know, faculty in this new position you know, one of the things I did was

00:29:22.800 --> 00:29:27.760
as part of my certification was to, you know, to get board certified in clinical informatics.

00:29:27.760 --> 00:29:32.960
That's a discipline by itself that, you know, involves a lot of, you know, it's a very broad

00:29:32.960 --> 00:29:37.840
field in terms of informatics and healthcare. And then one of the buckets there is, you know,

00:29:37.840 --> 00:29:44.320
software development. And so I was you know, I was quite interested sort of in that field. And so

00:29:44.320 --> 00:29:52.080
most of my time in terms of being able to devote to, you know, finding new packages or trying to,

00:29:52.080 --> 00:29:56.880
you know, write up an application that could solve a problem or coming up with prototypes.

00:29:57.600 --> 00:30:03.200
It was done in a way that sort of aligned with the work I was doing. And so it would be days

00:30:03.200 --> 00:30:07.120
when I'm on clinical service where I'm mostly, you know, working on sort of with, you know, with

00:30:07.120 --> 00:30:12.880
patient care related matters. So those weeks would be, you know, obviously very busy. I would have,

00:30:12.880 --> 00:30:17.040
you know, I would wake up at like extremely early in the morning, spend the first two hours,

00:30:17.040 --> 00:30:20.640
four to six a.m. just, you know, working on this. And then I get back to like, you know,

00:30:20.640 --> 00:30:23.920
the clinical work. And then there would be weeks when I'm off clinical service. So I,

00:30:23.920 --> 00:30:28.880
you know, I'm not responsible for any patient care related work. And those weeks would be

00:30:28.880 --> 00:30:34.800
where I would spend time in terms of, you know, doing these, you know, investigating into sort

00:30:34.800 --> 00:30:39.440
of some of these packages and, you know, coming up with new ideas, exploring what is all, you know,

00:30:39.440 --> 00:30:43.840
what is available in terms of certain problems that I was solving. And, you know, that time

00:30:43.840 --> 00:30:48.560
sort of, you know, my quote, protected time professionally was spent in that. And so that

00:30:48.560 --> 00:30:53.040
would be, you know, maybe a week spent into like, hey, we are trying to look into this

00:30:53.040 --> 00:30:58.800
variant annotation pool. And then we want to, you know, write wrappers around it. So it becomes

00:30:58.800 --> 00:31:04.000
easy for, you know, our labs operation to be able to use that. And so, so kind of that,

00:31:04.000 --> 00:31:08.880
that's how it works. So some of those either early mornings or, you know, the weeks I'm off

00:31:08.880 --> 00:31:15.360
clinical services and how, how that works. This portion of talk Python to me is brought to you

00:31:15.360 --> 00:31:21.360
by Posit, the makers of Shiny, formerly RStudio, and especially Shiny for Python.

00:31:22.080 --> 00:31:26.400
Let me ask you a question. Are you building awesome things? Of course you are. You're a

00:31:26.400 --> 00:31:31.280
developer or data scientist. That's what we do. And you should check out Posit Connect. Posit

00:31:31.280 --> 00:31:36.640
Connect is a way for you to publish, share and deploy all the data products that you're building

00:31:36.640 --> 00:31:42.400
using Python. People ask me the same question all the time, Michael, I have some cool data science

00:31:42.400 --> 00:31:47.760
project or notebook that I built. How do I share it with my users, stakeholders, teammates, I need

00:31:47.760 --> 00:31:54.560
to learn FastAPI or flask or maybe view or react.js Hold on now. Those are cool technologies,

00:31:54.560 --> 00:31:59.360
and I'm sure you'd benefit from them, but maybe stay focused on the data project. Let Posit Connect

00:31:59.360 --> 00:32:03.840
handle that side of things. With Posit Connect, you can rapidly and securely deploy the things

00:32:03.840 --> 00:32:10.800
you build in Python, Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto, Ports, Dashboards,

00:32:10.800 --> 00:32:16.560
and APIs. Posit Connect supports all of them. And Posit Connect comes with all the bells and

00:32:16.560 --> 00:32:22.160
whistles to satisfy IT and other enterprise requirements. Make deployment the easiest step

00:32:22.160 --> 00:32:27.120
in your workflow with Posit Connect. For a limited time, you can try Posit Connect for free for three

00:32:27.120 --> 00:32:35.040
months by going to talkpython.fm/posit. That's talkpython.fm/POSIT. The link is in your podcast

00:32:35.040 --> 00:32:39.040
player show notes. Thank you to the team at Posit for supporting Talk Python.

00:32:39.040 --> 00:32:45.920
Is it changing fast? So I'll give you an analogy that you could tell me about your space. So

00:32:45.920 --> 00:32:51.760
on one hand, in Python web world, you mentioned Flask and Django. Flask and Django, while they

00:32:51.760 --> 00:32:56.880
are evolving, they're kind of the way they have been and they're pretty stable. And if you learned

00:32:56.880 --> 00:33:04.000
Flask five years ago, you're still good to use Flask today. Or is it more like FastAPI, Pydantic,

00:33:04.000 --> 00:33:10.480
msgspec? There's something new all the time that you got to keep learning to bring in. Are

00:33:10.480 --> 00:33:15.520
there a ton of new packages just coming online or is there a set of really solid ones?

00:33:15.520 --> 00:33:26.160
So I think it's both yes and no. And so it depends on what area we're working on. So right now in the

00:33:26.160 --> 00:33:32.160
clinical lab that I'm directing here, when I came here in 2020, it was when we started off from

00:33:32.160 --> 00:33:38.160
scratch. So essentially, the idea was to be able to bring up a pediatric cancer sequencing

00:33:38.160 --> 00:33:43.760
infrastructure that was not available. And so it was ground up from the lab to personnel to space

00:33:43.760 --> 00:33:49.680
to competition and such. And so we kind of have these sort of two big bubbles in that operation

00:33:49.680 --> 00:33:56.720
from an informatics perspective. One of them is we essentially are in the process of developing

00:33:56.720 --> 00:34:02.000
our custom lab information system. That's essentially a web app. And so we have that

00:34:02.000 --> 00:34:07.040
space and the other space is bioinformatics. And so bioinformatics is a lot of the custom

00:34:08.160 --> 00:34:13.440
scripting or the applications we develop is Python based. Some of them we do with Golang

00:34:13.440 --> 00:34:20.160
when we need a little bit of performance aspect. And then the other aspect is the web app.

00:34:20.160 --> 00:34:26.640
So from a web app perspective, when I started here, we actually started, we use FastAPI and

00:34:26.640 --> 00:34:31.840
Python. So that's kind of, that was, so the idea was that, well, since you're starting from scratch

00:34:31.840 --> 00:34:35.200
and I came to know about FastAPI at that point of time, the whole thing was about

00:34:36.560 --> 00:34:42.240
a single way that was, I was pretty much sold on that aspect. And then, I think the whole tool

00:34:42.240 --> 00:34:46.720
segment a lot of sense. I'm like, okay, well, this is perfect. I'm to be able to, I think when

00:34:46.720 --> 00:34:53.280
I started FastAPI was, all about five or six. And so now obviously you can see a lot of change

00:34:53.280 --> 00:34:59.360
happening there. So yeah, that definitely is a lot of fast pace. And so we kind of do catching

00:34:59.360 --> 00:35:08.560
up in a sense where it has to be done in a careful way. The reason is because from, as compared to

00:35:08.560 --> 00:35:14.160
more traditional research lab testing where at the end really, there's a lot of discovery,

00:35:14.160 --> 00:35:20.400
there's a lot of excitement at the end, it all translates into being sort of, the data is

00:35:20.400 --> 00:35:25.200
presented at a conference or you publish that as a manuscript and that's the end point. So if you

00:35:25.200 --> 00:35:31.360
move off from version one to version three of an algorithm, you have to obviously make sure that

00:35:31.360 --> 00:35:35.280
your research, everything is reproducible, but beyond that is not a problem. But when we're

00:35:35.280 --> 00:35:40.240
talking about the same thing in context of a clinical care for a patient, the room for error

00:35:40.240 --> 00:35:46.480
is very, very little. You can't make mistakes. And so the entire space of clinical testing is

00:35:46.480 --> 00:35:51.840
very regulated in that sense, because there's a lot of requirement that you have to perform that

00:35:51.840 --> 00:35:56.960
any change that's happened in your pipeline, say you're using some version of an application,

00:35:56.960 --> 00:36:01.920
now you upgrade to a newer version. You have to demonstrate that the analytical performance in

00:36:01.920 --> 00:36:07.280
terms of sensitivity and specificity for that pipeline didn't change. And so a lot of work is

00:36:07.280 --> 00:36:13.440
needed when you go do a version upgrade. So we keep those things very controlled and careful

00:36:13.440 --> 00:36:18.960
versus some other things which are more in the R&D space. There's a little bit more room to

00:36:19.600 --> 00:36:24.160
play around with tools. Right. Yeah. Chris was asking an audience a great question about

00:36:24.160 --> 00:36:27.760
basically, is it more exploratory? You just move really fast and don't really worry about

00:36:27.760 --> 00:36:33.040
tests and stuff like that. It sounds like this is more of a production type thing. Like if it,

00:36:33.040 --> 00:36:37.360
you're going to run it over and over. And if it gives a different answer at some point for

00:36:37.360 --> 00:36:41.600
testing for a disease or something, that's really bad. You need it to be right all the time. And so.

00:36:41.600 --> 00:36:48.160
Yes. So the room when we do new test developments or we bring a new algorithm, obviously that

00:36:48.160 --> 00:36:52.160
part of which we refer to, there's a form of term that we use in lab medicines called

00:36:52.160 --> 00:36:58.640
familiarization and optimization or O&F phase. That's where, you know, there's a lot of flexibility,

00:36:58.640 --> 00:37:02.960
new tools, new version, trying out different things. But once it moves from that into the

00:37:02.960 --> 00:37:06.640
validation phase, and then once we deploy the application, once the deployment is there,

00:37:06.640 --> 00:37:12.080
it's a production application. We don't touch it unless something really has to be tinkered with,

00:37:12.080 --> 00:37:16.800
or there's a bug that we have to fix. Who's in charge of running those apps? Is that people

00:37:16.800 --> 00:37:23.440
on your team and your lab or is that the hospital or how? Yeah. So the way to set up here is,

00:37:23.440 --> 00:37:29.920
so when I started off, I was the end of one. So I started off with the FastAPI application.

00:37:29.920 --> 00:37:36.320
I had to build up the, we had a bioinformatics pipeline that I had initially authored. But

00:37:36.320 --> 00:37:42.400
then when we went through the validation phase, I luckily had two people on staff who kind of

00:37:42.400 --> 00:37:48.160
were handling the bioinformatics on the front end. And then eventually we had a third person who

00:37:48.160 --> 00:37:55.120
joined the team. So then they were kind of helping me out with a lot of the actual groundwork of

00:37:55.120 --> 00:38:01.120
writing the code, getting tests done, going through the validation data, summarizing that for me.

00:38:01.120 --> 00:38:05.760
Being a lab director, it is my responsibility ultimately to sign off on all those things,

00:38:05.760 --> 00:38:09.760
say, "Hey, okay, this is the validation and this is what is being demonstrated that

00:38:10.400 --> 00:38:15.280
your package or your pipeline or whatever you're working on demonstrates this level

00:38:15.280 --> 00:38:19.600
of sensibility." Then yes, I being a lab director say that, yes, this is working.

00:38:19.600 --> 00:38:25.040
And once that happens, so we then deploy those applications in production. We use GitHub and

00:38:25.040 --> 00:38:30.720
another, the usual dev, test, prod cycle. And so that's kind of how it works.

00:38:30.720 --> 00:38:35.440
Well, do you have your own hardware or do you have stuff like on DigitalOcean or AWS?

00:38:36.000 --> 00:38:43.600
So with healthcare data, there is generally a little bit of angst with data sitting on the cloud

00:38:43.600 --> 00:38:48.480
outside the support institution. I would say the institution that I work on is very,

00:38:48.480 --> 00:38:56.720
that way it's quite very forward thinking and being able to use modern technology.

00:38:56.720 --> 00:39:02.400
So what we started off and since it was everything being built up from scratch,

00:39:03.840 --> 00:39:10.480
we had taken the decision to keep things on-prem for beginning. But we also kept in mind that

00:39:10.480 --> 00:39:14.480
at some point of time, if the institution decides that, "Oh, we're going to switch our

00:39:14.480 --> 00:39:21.360
infrastructure to using AWS or Azure or whatever the platform is going to be," that we want it to

00:39:21.360 --> 00:39:30.320
be ready. And so the way we had it set up, and this is due to our amazing IS team here at our

00:39:30.320 --> 00:39:40.640
institution. So we had our own hardware that we got in terms of the actual servers. And we

00:39:40.640 --> 00:39:45.680
collaborated with the IS team to be able to help us build our Kubernetes infrastructure.

00:39:45.680 --> 00:39:54.240
So we have a test and a prod Kubernetes cluster, and then all our apps and the bioinformatics

00:39:54.240 --> 00:39:58.160
pipeline. Well, the apps for now and the bioinformatics pipeline that we're looking

00:39:58.160 --> 00:40:03.200
forward in the near future to get deployed on these things. As a matter of fact, what we've

00:40:03.200 --> 00:40:09.360
done is our dev team, we start to, we do a lot of the development on Kubernetes as well. And then we

00:40:09.360 --> 00:40:12.400
keep moving all these things as containerized applications.

00:40:12.400 --> 00:40:17.440
That's excellent. So really embracing containers and Docker and Kubernetes, and that should make

00:40:17.440 --> 00:40:21.440
it super easy to move to wherever you want to go, right? Anything that can run Kubernetes,

00:40:21.440 --> 00:40:24.000
you just push to that and you're good to go.

00:40:24.000 --> 00:40:29.360
Right. Right. I mean, it's a little bit difficult to start with, but I think once

00:40:29.360 --> 00:40:35.120
we are in that stream, it is much less effort to move things around.

00:40:35.120 --> 00:40:42.000
Yeah. Last year I rewrote all of our servers and APIs and condensed six to eight servers all into

00:40:42.000 --> 00:40:46.080
one just Docker cluster. And it was a great decision, but to me, it was also a little

00:40:46.080 --> 00:40:51.040
intimidating to like, well, here's one more thing I layer, I have to manage and understand. And if

00:40:51.040 --> 00:40:55.760
something goes wrong there, then everything else still breaks. But having it set up is really nice

00:40:55.760 --> 00:41:00.720
once you get used to it. All right. Let's talk a bit about, well, I have a question for you. I

00:41:00.720 --> 00:41:05.920
want to talk about some of these packages that you've been saying are like a lot of the reasons

00:41:05.920 --> 00:41:10.160
you chose Python and you use a lot, which is great. But before we get there, like I got the

00:41:10.160 --> 00:41:16.640
biopython.org website pulled up. And the very first line is, "Biopython is a set of freely

00:41:16.640 --> 00:41:22.480
available tools." You know, open source, freely available. How much does that matter to you guys?

00:41:22.480 --> 00:41:29.440
On one hand, you have a ton of money being in the medical space. It's really high stakes. So

00:41:29.440 --> 00:41:34.400
paying for commercial software or commercial libraries is probably not the biggest worry.

00:41:34.400 --> 00:41:38.800
On the other hand, open source is really nice. Being able to look inside is really nice.

00:41:38.800 --> 00:41:44.240
Free means you don't have to deal with getting permission. How does that fit into your world?

00:41:44.240 --> 00:41:49.920
I know how it fits into like small startups and things like that, but for a hospital, for example,

00:41:49.920 --> 00:41:55.520
what does free and open source mean to you guys? I think it does have a lot of impact in terms of

00:41:55.520 --> 00:42:04.320
how we end up working and setting up these things. And obviously, whatever I'm speaking

00:42:04.320 --> 00:42:11.440
is representing what it means from sort of an operational standpoint. When we talk about

00:42:11.440 --> 00:42:18.880
molecular pathology, generally being able to bring up a clinical service like that is a huge investment.

00:42:18.880 --> 00:42:24.560
And so a lot of the investment is... And this is generally applicable to any institution where

00:42:24.560 --> 00:42:29.440
something like this has been set up for patient care or clinical use.

00:42:29.440 --> 00:42:40.320
The investment is primarily in a lot of the instrumentation and the reagents that we use

00:42:40.320 --> 00:42:47.120
are generally quite expensive, which is sort of the... I would say when we talk about what is the

00:42:47.120 --> 00:42:54.640
cost of a test when it's offered, that cost factors in a lot of these operational costs

00:42:54.640 --> 00:43:00.640
that we need to buy these expensive sequencing instruments, the reagents that are used as

00:43:00.640 --> 00:43:05.120
consumable as we do the test over and over again, every week, every month.

00:43:06.240 --> 00:43:11.520
So from that standpoint, traditionally, the way things have been designed is,

00:43:11.520 --> 00:43:18.400
I would say 10 years back when we would work with our finance team to say, "Okay,

00:43:18.400 --> 00:43:23.440
the cost of the test is going to be so and so based on all of these different inputs." And so

00:43:23.440 --> 00:43:30.400
10 years back, computation, bioinformatics, all of these were not factored in at all.

00:43:30.400 --> 00:43:38.880
But now as we are in that era where using GPUs on a regular basis to be able to do simple...

00:43:38.880 --> 00:43:45.760
I would not say simple, but routine work to get from the raw sequence data to be able to identify

00:43:45.760 --> 00:43:51.280
genomic variants, that's getting common. Using FPGAs, using large clusters to be able to perform

00:43:51.280 --> 00:43:56.560
these tests. And so now we are starting to see those costs getting in as part of the ultimate

00:43:57.200 --> 00:44:01.280
cost that goes to the patient for a test. And so we try to minimize those things.

00:44:01.280 --> 00:44:04.560
One of the ways to be able to minimize those things is to be able to choose between

00:44:04.560 --> 00:44:08.560
free open source versus something which is a commercial product. And it's always a balance

00:44:08.560 --> 00:44:13.840
between the reliability and the service that you're able to get back saying, "Hey, something

00:44:13.840 --> 00:44:20.560
breaks down. We know there's an SLA. There's a certain assurance that this thing is going to

00:44:20.560 --> 00:44:27.120
have help," versus open source free would be where we feel very confident in the code base.

00:44:27.120 --> 00:44:34.880
Sometimes what happens is when we use some of these open source tools, we end up almost

00:44:34.880 --> 00:44:39.760
invariably having some wrapper around it to change things or being able to have some insight

00:44:39.760 --> 00:44:43.840
into the source code. So it depends on that balance, what we choose.

00:44:44.720 --> 00:44:51.360
How often do you fork it and use your self-maintained version versus just run what

00:44:51.360 --> 00:44:55.760
is publicly on PyPI and then maybe wrap it to orchestrate it a bit?

00:44:55.760 --> 00:45:02.160
So I would say for the web application part of it, we don't really do a lot of forking. We kind

00:45:02.160 --> 00:45:07.440
of go with what it is. The only thing what we do is since we have the luxury of using a combination

00:45:07.440 --> 00:45:13.040
of GitHub and containers and knowing the fact that the regulatory requirements require that

00:45:13.040 --> 00:45:17.680
you tightly version control all these things with history and all those things, we tend to,

00:45:17.680 --> 00:45:22.320
when we are developing these things, when we are validating it, before we do that, we try to stick

00:45:22.320 --> 00:45:28.240
to a fairly stable version. So for example, things like beta or release candidates, we try to stay

00:45:28.240 --> 00:45:33.040
away from that. Even if they have some desirable features, but unless we see a full production

00:45:33.040 --> 00:45:38.960
version of that, we don't tend to switch to it. So we keep things like that without maintaining

00:45:38.960 --> 00:45:44.160
or without forking or making modifications. When we get into more of the bioinformatics stuff,

00:45:44.160 --> 00:45:49.120
where we are actually trying to use an algorithm to solve a particular piece of

00:45:49.120 --> 00:45:55.520
part of the pipeline that is doing some data transformation, it depends on how much we want to

00:45:55.520 --> 00:46:02.720
change or modify. That's when we sometimes fork it. Sometimes we fork where we know that,

00:46:02.720 --> 00:46:07.600
and this is the unfortunate reality in many of the scenarios where you have great open source tool,

00:46:07.600 --> 00:46:12.720
but after some time due to whatever financial or business or other reasons that they stop

00:46:12.720 --> 00:46:17.600
maintaining. And so essentially we get into this freeze mode. We tend to fork that so that at least

00:46:17.600 --> 00:46:22.480
we have that available. And then if we make any changes that we keep it to that fork.

00:46:22.480 --> 00:46:30.320
But generally I would say it's probably in the 80, 20, where 20% is where we fork it,

00:46:30.320 --> 00:46:36.960
make some change. Most of the times we try not to do that. But yes, open source,

00:46:36.960 --> 00:46:41.520
free tools have a big impact. A lot of their tools that we use as part of our

00:46:41.520 --> 00:46:44.800
bioinformatics pipelines, as a matter of fact, which is kind of used in the community of

00:46:44.800 --> 00:46:51.200
molecular pathology to build these bioinformatics pipeline. They tend to use a lot of open source

00:46:51.200 --> 00:46:55.360
tools. And the reason for that is, for example, it's not written in Python, but we have,

00:46:55.360 --> 00:47:02.400
there's an algorithm called BWA. It's written by Professor Heng Li. That's one of the algorithms

00:47:02.400 --> 00:47:07.840
that is almost like a de facto, I would say, when it comes to doing sequence alignment,

00:47:07.840 --> 00:47:15.200
that's a part of the pipeline. And so it's a tried and tested application for more than a decade now.

00:47:15.200 --> 00:47:20.240
So really there's not a, and this is a fairly stable algorithm or application. So we don't

00:47:20.240 --> 00:47:24.800
tend to, it's well maintained from an open source perspective. So those obviously are highly,

00:47:24.800 --> 00:47:30.560
we highly rely on those. But there is this whole ecosystem of softwares that come under this

00:47:31.280 --> 00:47:34.880
rubric term of variant calling, where we're trying to identify these different variants.

00:47:34.880 --> 00:47:42.000
There's a whole bunch of those and some are fairly well maintained. They are open source.

00:47:42.000 --> 00:47:48.880
Sometimes depending on the context you're using, you need a license if it is used in a commercial

00:47:48.880 --> 00:47:54.080
setting. You don't need a license if it is in an academic setting. Like for example,

00:47:54.080 --> 00:48:00.560
when we do clinical testing in institutions such as where I am right now, that's an academic

00:48:00.560 --> 00:48:09.440
institution. So typically it's not for profit. And so obviously we don't need licenses for that use.

00:48:09.440 --> 00:48:14.000
But once this goes into a pure commercial space where if the lab is doing all of this testing

00:48:14.000 --> 00:48:21.600
for profit, then there's a license requirement. So we see a combination of these things showing

00:48:21.600 --> 00:48:28.320
up in the, it's actually becoming more common now with open source tools that, at least in the

00:48:28.320 --> 00:48:33.920
genomic bioinformatics space. Yeah. Oh, excellent. I think another benefit probably for you guys,

00:48:33.920 --> 00:48:39.600
I know it's a benefit for a lot of organizations is if you use the open source tools and you need

00:48:39.600 --> 00:48:44.960
to hire somebody new, there's a good chance that they have experience already with those tools.

00:48:44.960 --> 00:48:49.520
Whereas if you use something private, expensive, you might have to teach them from scratch what

00:48:49.520 --> 00:48:55.440
the thing is, right? Yes, that is correct. As a matter of fact, it's fortunate that a lot of the

00:48:55.440 --> 00:49:01.760
people who've done a lot of good work and have contributed to the genomics bioinformatics space

00:49:01.760 --> 00:49:10.960
have, the general tendency is whenever we are setting up any sort of pipelines or DNA sequencing,

00:49:10.960 --> 00:49:17.440
RNA sequencing, or more from a research perspective, methylation sequencing, single cell RNA-seq,

00:49:20.480 --> 00:49:25.280
UMI-based error-corrected variant calling, there's a lot of, there's a very thriving open

00:49:25.280 --> 00:49:32.320
source space. And so that really helps with people who come in, even if they're not familiar with

00:49:32.320 --> 00:49:37.280
these tools, it's easy to get familiar with because there's a lot of community backing that up.

00:49:37.280 --> 00:49:44.560
Or as you said, when we hire people who already are coming from a different lab or they've had

00:49:44.560 --> 00:49:49.440
some experience, but they come and say, "Oh yeah, we know how to do alignment, or I'm aware of these

00:49:49.440 --> 00:49:54.480
applications that use that." It is much, much easier from a learning curve perspective rather

00:49:54.480 --> 00:50:00.720
than having to now open up a manual and this will be a proprietary thing that only works here.

00:50:00.720 --> 00:50:08.480
Yes, exactly. Cool. All right. Well, we coordinated a bit on a list of packages that you've used in

00:50:08.480 --> 00:50:13.600
your lab or find really helpful for your work. And maybe we could touch on those just a little bit.

00:50:13.600 --> 00:50:14.160
Yeah.

00:50:14.160 --> 00:50:20.080
Yeah. So CNV kit, genome-wide copy number from high throughput sequencing. I don't know what

00:50:20.080 --> 00:50:21.200
that means, but tell us about it.

00:50:21.200 --> 00:50:28.800
Yeah, yeah, absolutely. So CNV or copy number variation, this is a type of genomic operation

00:50:28.800 --> 00:50:36.800
where what happens is in a simplistic way, at least when we talk about cancer, the cancer cells,

00:50:36.800 --> 00:50:42.480
sometimes for it to be able to survive, it tries to use different ways of doing that biologically.

00:50:42.480 --> 00:50:48.720
One of the way to do that is certain genes that help a cell to grow in the absence of nutrients

00:50:48.720 --> 00:50:54.560
or with very little nutrition is certain genes. If it has more copies of those genes than normal,

00:50:54.560 --> 00:50:59.200
then you'll go, "Oh, okay." It's like you have more money than expected, you can do a lot of

00:50:59.200 --> 00:51:05.120
things. So typically what happens is in a normal human genome, any cell that we pick up, it will

00:51:05.120 --> 00:51:08.640
only have two copies of the gene. One is coming from your mom, one is coming from your dad.

00:51:08.640 --> 00:51:15.280
In cancer, what happens is in certain scenarios, if a gene that helps with growth of the cell or

00:51:15.280 --> 00:51:20.640
it helps the cell to survive even without signal or nutrition, if it has more copies of that,

00:51:20.640 --> 00:51:26.480
it'll make six, eight, 20, 50 copies, it can survive. Versus there are certain scenarios

00:51:26.480 --> 00:51:31.200
where if there is a gene that is supposed to regulate the cells, so it doesn't go haywire,

00:51:31.200 --> 00:51:36.000
if the cancer is able to delete one of the genes out, then you only have one gene left.

00:51:36.000 --> 00:51:39.760
You knock out a thing and then that protective mechanism is gone. So then the cancer cell can

00:51:39.760 --> 00:51:46.240
easily survive. So what happens is with CNV or copy number variations, the idea is that we use

00:51:46.240 --> 00:51:51.920
the high throughput sequencing data to be able to infer how many copies of these genes do we have.

00:51:51.920 --> 00:51:56.880
Is it more than two? Is it less than two? And so this particular package, it's a very, very

00:51:56.880 --> 00:52:04.320
well-established, well-maintained package in the community that essentially does this thing.

00:52:04.320 --> 00:52:10.480
Is you give it the sequencing data and define the regions of the genome that you're interested in.

00:52:10.480 --> 00:52:18.880
You can also provide names for the regions, like this region is gene B-RAF or this is EGFR,

00:52:18.880 --> 00:52:23.680
whatever you're interested in. And then what I do is I will do all the analysis to be able to

00:52:23.680 --> 00:52:29.760
tell you that, okay, well, when we are comparing this particular tumor against this reference set

00:52:29.760 --> 00:52:34.720
of 20 normal samples, where we know that you should only have two copies of the gene,

00:52:34.720 --> 00:52:37.520
in this particular tumor, we are seeing there are 50 copies of the gene.

00:52:37.520 --> 00:52:46.240
So it gives you an output data that numerical can tell you that what it does is it does a

00:52:46.240 --> 00:52:52.560
log-2-based transformation of the tracing there. Okay. After all this computation,

00:52:52.560 --> 00:52:57.600
when I compare to the normal, this is 50 times more, or this is 20 times more the

00:52:57.600 --> 00:53:03.120
expected copy, or it is half of the amount of copy we need in terms of deletions.

00:53:03.120 --> 00:53:13.200
So that's what really it does. And it's written in Python. It has Python dependencies that have

00:53:13.200 --> 00:53:22.320
been written in either C or Python C bindings. But at the end, it gives you that data. And it

00:53:22.320 --> 00:53:29.200
has an internal visualization tool, but I was not very happy with how it was written. So

00:53:29.200 --> 00:53:34.960
I ended up writing a wrapper, which is called CNA plotter. It's open source. It essentially

00:53:34.960 --> 00:53:42.880
uses the end data from CNBKid, and then it gives you a nice visualization of the copy numbers.

00:53:42.880 --> 00:53:45.680
I think if you go down, if you scroll down, there's my example images.

00:53:45.680 --> 00:53:51.120
- Yeah, you have this on GitHub, so if people want to use this, it's right there, right?

00:53:51.120 --> 00:53:55.920
- Yep, it's right there. So I think at the very bottom of the images,

00:53:55.920 --> 00:53:56.880
by the screenshots there.

00:53:56.880 --> 00:53:57.680
- Oh, yeah.

00:53:57.680 --> 00:54:01.680
- Yep, right here. So for example, the first image over here, you can see this,

00:54:01.680 --> 00:54:07.280
it's a thin band of all these multicolor things, and each one of them is a single

00:54:07.280 --> 00:54:14.080
human chromosome. So chromosome one, two, three, four, so on and so forth. And if you look at the

00:54:14.080 --> 00:54:20.000
image, it is at, the white scale essentially is log two, which is zero. And going up,

00:54:20.000 --> 00:54:25.280
it is one, two, three, and then it's a negative scale on the lower side. So anything going above

00:54:25.280 --> 00:54:30.960
zero means you have more copies than two, going below is less than two copies. And so if you see

00:54:30.960 --> 00:54:37.040
here in this example, the plot here, you see the very end, which is chromosome X, is a single,

00:54:37.040 --> 00:54:44.400
the band over here is lower at negative one. That means this is a male patient with a single X

00:54:44.400 --> 00:54:49.120
chromosome, as compared to females who have two X chromosomes. And so when you look at this plot

00:54:49.120 --> 00:54:56.480
below here, this is actually a plot from a cell line, a tumor cell line that is abnormal. And

00:54:56.480 --> 00:55:02.000
here we see there are two genes which are amplified. One of them is a gene known as TERT,

00:55:02.000 --> 00:55:08.480
and the other gene is MDM2. So these two genes are, again, one of those examples where it gives

00:55:08.480 --> 00:55:13.520
the tumor survival advantage over other. And so you can see here there are multiple copies of

00:55:13.520 --> 00:55:18.640
these genes as compared to the baseline over here. - I see. So that might predict something like the

00:55:19.120 --> 00:55:24.960
how survivable the cancer is. - Yes. Right. So if it is, is it going to be localized,

00:55:24.960 --> 00:55:28.320
say, where it happened, or it's going to like spread to other parts of the body,

00:55:28.320 --> 00:55:31.200
or be difficult to treat, or be resistant to treatment. Yes.

00:55:31.200 --> 00:55:34.960
- So if this is you, you want higher numbers, not lower numbers.

00:55:34.960 --> 00:55:39.920
- It all depends. I mean, certain genes are good genes, for example, if there is a,

00:55:39.920 --> 00:55:44.560
there are certain checkpoint genes, if those numbers, you know, if they have lower numbers,

00:55:44.560 --> 00:55:48.080
you want to have two copies of them, because if that protective mechanism is gone,

00:55:48.080 --> 00:55:52.000
you know, the tumor becomes very aggressive. - I see.

00:55:52.000 --> 00:55:56.320
- So it is all in the context. So if you're looking at the good genes, you want to have

00:55:56.320 --> 00:56:00.000
two copies of the good gene. If you're looking at some of the bad genes, you don't want to have

00:56:00.000 --> 00:56:03.520
more than two copies of the bad genes. - One or zero is better. I got it. I got it.

00:56:03.520 --> 00:56:09.600
Okay. Okay. HGVS. - Yes. This is, again, a wonderful package

00:56:09.600 --> 00:56:16.160
that was initially, I think it was started by a person named Vishat. He's, I think he still

00:56:16.160 --> 00:56:20.000
maintains it, but there's a lot of like, you know, it's a very well publicly maintained

00:56:20.000 --> 00:56:27.280
open source package. It's a lot of, you know, community involvement in that as well.

00:56:27.280 --> 00:56:35.440
So what HGVS is, it's a nomenclature system for, you know, giving a name to all these variations.

00:56:35.440 --> 00:56:39.200
So when you talk about, I'm not sure if Michael, if you've heard about the term mutation.

00:56:39.200 --> 00:56:45.680
So mutation is a very commonly used term that refers to some kind of abnormality in the

00:56:45.680 --> 00:56:52.640
genome. In this case, so what happens is there are these standards that are, that, you know,

00:56:52.640 --> 00:56:57.280
most clinical labs follow when they're putting all of this information in the patient's report

00:56:57.280 --> 00:57:03.040
saying, okay, you know, this particular tumor has, you know, mutation in beta, mutation in EGFR,

00:57:03.040 --> 00:57:08.560
some other gene. And there's a certain way that those mutations are described in terms of what

00:57:08.560 --> 00:57:14.000
sequence alterations happening, say at the mRNA level and what sequence alterations are happening

00:57:14.000 --> 00:57:18.800
at the protein level. So now in your protein, you know, you're missing these amino acids or

00:57:18.800 --> 00:57:22.320
you have excess of these amino acids or something got switched from here to there.

00:57:22.320 --> 00:57:28.240
So there's a formal way of defining that. And the guidelines of the group that defines that is

00:57:28.240 --> 00:57:34.000
referred to as HGVS, Human Genome Variation Society. And so it's a very complicated process

00:57:34.000 --> 00:57:38.960
where you have to do all these translations from the, you know, the genomic scale where

00:57:38.960 --> 00:57:44.000
the numbering system starts from one to like, and you know, whatever the length of your chromosome

00:57:44.000 --> 00:57:48.480
is in terms of ATGCs and each chromosome has a different number. And if you have a certain

00:57:48.480 --> 00:57:53.920
alteration that is happening, say in chromosome seven at this particular position, then you have

00:57:53.920 --> 00:57:58.000
to translate that to the mRNA of that gene and then the protein of that gene. So it's a lot of

00:57:58.000 --> 00:58:04.240
math, a lot of strings involved in that process. And so essentially this HGVS Python package

00:58:05.200 --> 00:58:10.320
provides all of those functionality as a wrap. You can create your translation. You can essentially

00:58:10.320 --> 00:58:17.600
project the variant from your genomic to the, you know, the mRNA to a protein level or vice versa.

00:58:17.600 --> 00:58:24.480
You can validate things. So we ended up, I actually wrote a paper about this when we,

00:58:24.480 --> 00:58:29.040
you know, we did a validation of how well this particular package works. And so now, you know,

00:58:29.040 --> 00:58:34.000
in the lab that I'm currently in, we implement this thing for generating those nomenclatures.

00:58:34.000 --> 00:58:39.600
So what happens is when we put a report out for the, in the patient's chart and when our, you know,

00:58:39.600 --> 00:58:45.280
say our oncology, oncologist was treating the patient, they want to know, okay, what is,

00:58:45.280 --> 00:58:49.440
you know, what did you identify in this tumor genome? They will read that nomenclature saying,

00:58:49.440 --> 00:58:54.640
oh, okay, this particular change in this BF gene, this is significant. I know that there are

00:58:54.640 --> 00:59:00.000
therapies that are out there that we can use to treat this patient tumor. So that's what this

00:59:00.000 --> 00:59:04.560
nomenclature system is about. So it's a very complicated automated system.

00:59:04.560 --> 00:59:08.080
Yeah. And it normalizes it if there's multiple ways to represent it.

00:59:08.080 --> 00:59:14.880
Very, very nice. All right. This one I'm familiar with, OpenPyXL.

00:59:14.880 --> 00:59:15.200
Yes.

00:59:15.200 --> 00:59:17.440
You probably have a lot of data that either goes,

00:59:17.440 --> 00:59:20.960
comes from or goes, it's shared out into Excel, right?

00:59:20.960 --> 00:59:25.600
Yes. So what we do is we sort of are right now in our lab, we're kind of in this sort of,

00:59:26.960 --> 00:59:35.360
you know, kind of an interim phase where we sometimes use Excel to look at some data. So

00:59:35.360 --> 00:59:42.880
traditionally speaking before, you know, typically any lab that goes from, you know,

00:59:42.880 --> 00:59:45.760
zero to the point where you have a web application that automates everything,

00:59:45.760 --> 00:59:50.400
the intermediate phase is using a lot of Excel. So it's very common in many labs

00:59:51.280 --> 00:59:56.640
to use Excel for a lot of different things, you know, for QC, for charts, for tracking. So

00:59:56.640 --> 01:00:05.760
we use this OpenPyXL for a few things. One of them is when we have a lot of,

01:00:05.760 --> 01:00:10.960
you know, the sequencing data that we have to summarize and then generate a QC to be able to

01:00:10.960 --> 01:00:17.360
present that to essentially create an Excel document on the fly from the backend to provide

01:00:17.360 --> 01:00:21.360
that, you know, whatever data they want to look at in terms of statistics or, you know,

01:00:21.360 --> 01:00:26.240
list of variants or some form of, you know, calculation they want to do further. That's

01:00:26.240 --> 01:00:30.880
where we use this package. Typically we use it as part of our bioinformatics pipeline when we

01:00:30.880 --> 01:00:35.760
have to generate those things. But it's a very handy tool. We actually use something similar,

01:00:35.760 --> 01:00:43.280
and I'm forgetting the name of the package that is used to generate our document. Like we use some

01:00:43.280 --> 01:00:48.000
Word documents for creating reports, but we also use Python there to be able to summarize a lot of

01:00:48.000 --> 01:00:52.640
these data points and then create a Word document that, you know, it starts with a template of a

01:00:52.640 --> 01:00:57.920
Word document and then use Python to fill up all these, you know. Right. Here's where the graph

01:00:57.920 --> 01:01:02.800
goes. Here's where the summary goes. Here's where the detected, whatever it goes. Yeah. Right. Yeah.

01:01:02.800 --> 01:01:09.600
Cool. Are you, here's two things that overlap. Are you familiar with this thing where scientists

01:01:09.600 --> 01:01:17.520
rename human genes to stop Excel from misreading? Oh yes. Yes, absolutely. Oh my gosh. This is

01:01:17.520 --> 01:01:25.840
crazy. Yes. Yes. It happens. When we import a lot of this data coming from somewhere, we'll see

01:01:25.840 --> 01:01:34.960
entries like September 14th or March 19th. Yeah. This is a big problem going in and out of Excel.

01:01:34.960 --> 01:01:40.160
And so as much as you can do in Python or any proper programming language, rather than using

01:01:40.160 --> 01:01:48.000
Excel, but there was one that was M-A-R-C-H one or March one. Yes. Or S-E-P-T one.

01:01:48.000 --> 01:01:55.600
It's very funny. Some of the gene names are funny, but then Excel, you know, gets it to the next

01:01:55.600 --> 01:02:02.560
level when it changes the names. This doesn't make any sense. Yeah. Yeah. It doesn't make any sense.

01:02:02.560 --> 01:02:08.080
Yeah. All right. On to the next one. Hera. Yes. Hera. This is very interesting. So this is where

01:02:08.080 --> 01:02:16.880
I think, you know, where in our instance, we are going away from standard web applications,

01:02:16.880 --> 01:02:21.760
standard bioinformatics pipeline to really touching DevOps using Python. And so one of the things

01:02:21.760 --> 01:02:27.440
that typically we get to the point when we scale up our bioinformatics pipeline, where we have

01:02:27.440 --> 01:02:33.200
multiple samples and multiple runs and everything needs to be orchestrated in a way where you have,

01:02:33.200 --> 01:02:37.360
you know, while you're running your pipeline, you have a lot of visibility into how it works.

01:02:37.360 --> 01:02:44.400
And so this is one of our projects we're working on to move our current bioinformatics pipeline,

01:02:44.400 --> 01:02:49.840
the way it works, you know, kind of on a single server to be able to use the Kubernetes cluster

01:02:49.840 --> 01:02:55.600
to actually deploy the long running pipelines onto that. And so there are many options. You know,

01:02:55.600 --> 01:03:02.320
there are a more standard sort of, you know, a little based, you know, kind of, you know,

01:03:02.320 --> 01:03:09.840
protocols that you can use to run on either cloud or HPC environments. There is a very popular tool

01:03:09.840 --> 01:03:15.600
called Nextflow that is used to be able to, you know, kind of create your data analysis pipeline.

01:03:15.600 --> 01:03:21.280
We can sort of define that and then use any backend to deploy it. One of the things that we

01:03:21.280 --> 01:03:28.960
kind of, when I was exploring the space, one of the things I came across was, you know, the whole

01:03:28.960 --> 01:03:35.040
sort of ecosystem that Argo maintains with, you know, Argo workflow and Argo CI/CD and all those

01:03:35.040 --> 01:03:39.520
things. So workflow was interesting because Argo provides that way where you can sort of, you know,

01:03:39.520 --> 01:03:43.920
write your pipelines in a YAML format and then have it, you know, deployed on the Kubernetes

01:03:43.920 --> 01:03:49.760
cluster. It really is very native to the Kubernetes cluster. It sounds a little bit like Ansible,

01:03:49.760 --> 01:03:55.440
but for specifically for bio type of projects, right?

01:03:55.440 --> 01:04:00.800
Yeah. So Argo, so interesting thing is Argo, when, you know, when this Argo workflows was set

01:04:00.800 --> 01:04:06.720
up really for a lot of CI/CD automations in mind. So, you know, it is, yes, you can run data

01:04:06.720 --> 01:04:11.360
pipelines in general, but never, it was never, at least in its description, it never describes

01:04:11.360 --> 01:04:17.920
use case sort of in bioinformatics or, you know, biology pipeline analysis. And similarly,

01:04:17.920 --> 01:04:22.240
you know, it was like, okay, it's a generic tool. You can use it for whatever you want.

01:04:22.240 --> 01:04:28.880
So I tried it out with using, you know, like a YAML file and it was a simple four-step pipeline.

01:04:28.880 --> 01:04:35.680
It was wonderful. It was magical. And the good thing was with Argo, like the Argo workflow,

01:04:35.680 --> 01:04:43.520
when you install that on your Kubernetes cluster, it comes with a native web interface. So it's,

01:04:43.520 --> 01:04:49.840
you know, I'm sure if you've heard about the workflow option with Airflow. So Airflow is a

01:04:49.840 --> 01:04:54.640
package that also, you know, there's a nice Python SDK for that, where you have, you know,

01:04:54.640 --> 01:04:59.520
you deploy it on a Kubernetes cluster. We have all these amazing visualizations to show what step

01:04:59.520 --> 01:05:04.640
you're on, or if there's some error there, it'll do that. Argo does the same thing. So it has,

01:05:04.640 --> 01:05:09.520
it has obviously the built-in capability to interact with it as an API, but then also there's

01:05:09.520 --> 01:05:14.000
a web interface that it'll deploy and it can have visibility into every step of the process. You can

01:05:14.000 --> 01:05:18.240
summarize and see the entire tree. So that was very interesting for us because we could get all

01:05:18.240 --> 01:05:24.880
that thing done in a single thing, in a single go. But then our challenge was, well, our desire was

01:05:24.880 --> 01:05:29.760
that if you could integrate that with our LIMP system that we were working on using FastAPI,

01:05:29.760 --> 01:05:33.920
so the idea was, hey, if there's any Python SDK. And so that's where Hera comes. So Hera

01:05:33.920 --> 01:05:40.720
essentially is a SDK, a wrapper that's essentially talking to Argo, but you can define your pipeline

01:05:40.720 --> 01:05:48.400
steps as, you know, DAGs in Python. And so that makes the process super simple, where you're now

01:05:48.400 --> 01:05:55.200
natively, essentially we can integrate that as a backend to our web application. And so then it's

01:05:55.200 --> 01:05:59.840
almost like, you know, it's Python again, from start to finish, you're not getting out of that.

01:05:59.840 --> 01:06:04.960
And it's, again, it's a very well-maintained application. So we are currently doing a

01:06:04.960 --> 01:06:09.840
validation to be able to make sure that, or demonstrate that, you know, it's equally

01:06:09.840 --> 01:06:15.920
performant when we compare to a more sort of native shell-based, you know, execution on the

01:06:15.920 --> 01:06:20.400
pipeline. Okay. Yeah. This is new to me. I mean, of course I know Airflow, but not Hera. Cool.

01:06:20.400 --> 01:06:23.760
All right. Hi, in Sim, did I grab the right one here?

01:06:26.160 --> 01:06:32.800
No, I think it's similar. Let me see if I can, I can send you the link.

01:06:32.800 --> 01:06:35.760
Yeah. Throw it in the private chat here and I'll pull it up.

01:06:35.760 --> 01:06:39.200
Yeah. Okay.

01:06:39.200 --> 01:06:40.960
Here we go. In Sim.

01:06:40.960 --> 01:06:43.280
Yeah. Okay. Got it.

01:06:43.280 --> 01:06:51.280
Yeah. So this is a, this is a very interesting space in next generation sequencing assay or for,

01:06:52.080 --> 01:06:56.320
you know, high throughput sequencing assays. So what happens is, as I mentioned, that one of the

01:06:56.320 --> 01:07:01.280
things that is required for a clinical lab is to be able to perform a validation on multiple samples

01:07:01.280 --> 01:07:05.680
of tumors that have certain mutations. And then you can demonstrate that, you know, yes,

01:07:05.680 --> 01:07:12.000
the assay works because you have tested, you know, a hundred samples that have 300 different,

01:07:12.000 --> 01:07:16.320
you know, mutations or genetic alterations. And then you can demonstrate that, yes,

01:07:16.320 --> 01:07:20.880
your pipeline or your assay was able to pick it up. So you can say that, you know, your assay is,

01:07:20.880 --> 01:07:24.880
you know, X percentage sensitive, X percentage specific, and you know, your

01:07:24.880 --> 01:07:28.000
recall rate and things like that. So what happens is when you're trying to

01:07:28.000 --> 01:07:35.120
get those samples that have these very difficult or challenging variants to detect, because

01:07:35.120 --> 01:07:40.800
they're just, you know, complex in how they occur biologically in the cell, it's very difficult.

01:07:40.800 --> 01:07:45.840
Some of these are very rare. There may be only two samples in the entire world. Or it's just

01:07:45.840 --> 01:07:50.960
not possible practically to get those samples unless we wait for like, you know, 10 years to

01:07:50.960 --> 01:07:56.960
validate that. So the idea is that if it is possible to be able to use algorithms, which can

01:07:56.960 --> 01:08:04.080
manipulate the existing sequence. So for example, we have a sequence data from an existing real

01:08:04.080 --> 01:08:10.080
tumor sample, but we can manipulate that in a way where we introduce these mutations in silico.

01:08:10.080 --> 01:08:14.160
So we can introduce, you know, SNBs or insertion, deletion mutations, and then

01:08:14.720 --> 01:08:18.320
use that same file to then feed into our pipeline, bioinformatics pipeline and say,

01:08:18.320 --> 01:08:22.640
okay, run through the entire data pipeline. And then let's see if we are able to identify

01:08:22.640 --> 01:08:26.240
those variants that we inserted. And so that's where this silico mutagenesis comes.

01:08:26.240 --> 01:08:32.400
It's a very hot topic. It's a very relevant topic of interest to really fill this large

01:08:32.400 --> 01:08:39.520
gap in terms of availability of rare variants and their samples and how we can really improve

01:08:40.320 --> 01:08:44.640
sort of some of these rare, but very clinically significant edge cases where we don't want to

01:08:44.640 --> 01:08:50.240
miss those variants and actually see those in real tumor samples. And so this is a Python package

01:08:50.240 --> 01:08:56.640
that was developed by at the University of Chicago as part of their clinical lab. And so what really

01:08:56.640 --> 01:09:02.960
it does is it will take in a list of different, you know, mutations, for example, in this plot,

01:09:02.960 --> 01:09:07.280
I think they give examples of, you know, insertion, deletion, insertions, where you have extra

01:09:07.280 --> 01:09:11.920
sequence or deletion where you have certain signals which are missing or SNVs or single

01:09:11.920 --> 01:09:16.640
nucleotide variants where you have one nucleotide that got switched with another one. And so these

01:09:16.640 --> 01:09:22.960
are typically that we practically see in like real samples or real tumor samples, but this is a way

01:09:22.960 --> 01:09:29.760
to mimic that, you know, in a sample that does not have it. And so this Python package is able to,

01:09:29.760 --> 01:09:35.040
you know, take that list from you say, okay, I have a list of these 20 important mutations that

01:09:35.040 --> 01:09:40.560
I know from the public databases have been reported, but I want them to be inserted into

01:09:40.560 --> 01:09:46.800
my dataset that was created from say, a set of three or four real tumors, and then use that to

01:09:46.800 --> 01:09:50.480
challenge the pipeline to say that, hey, can you still pick it up? And so I see.

01:09:50.480 --> 01:09:56.640
I see. Simulate these rare changes and then test or exercise your setup.

01:09:56.640 --> 01:09:57.920
Yeah, right.

01:09:57.920 --> 01:10:01.600
We've got a few more to cover, but I think we're getting a little bit short on time. So let me just

01:10:01.600 --> 01:10:06.640
close this out with a final question for you, because I know this is the topic du jour.

01:10:06.640 --> 01:10:14.960
What does AI and LLMs look like for you guys? Does it matter? Is it really powerful? Is it

01:10:14.960 --> 01:10:19.040
super important? I mean, genetics is kind of text data in a sense. And so,

01:10:19.040 --> 01:10:22.320
yes, sort of in the space of how it could apply.

01:10:22.320 --> 01:10:30.320
Right. It is a text data and it's a lot of, you know, there's a, when you talk about like a search

01:10:30.320 --> 01:10:34.960
space, a lot of the search space is very text-based. You know, there is some numerical

01:10:34.960 --> 01:10:40.800
base, but there's a lot of text-based search as well. And I think across the entire spectrum from

01:10:40.800 --> 01:10:44.160
where we start with very raw sequencing data to the point that we are trying to,

01:10:44.160 --> 01:10:51.360
you know, ask the question that, okay, I found this rare or novel mutation in this particular

01:10:51.360 --> 01:10:56.320
gene. What does it mean? What tumor has been described? What disease does it relate to?

01:10:57.760 --> 01:11:02.560
One of the things that we do as molecular pathologists, and this is sort of where a lot

01:11:02.560 --> 01:11:06.560
of the medical work comes in, is where we really go through a lot of the medical literature,

01:11:06.560 --> 01:11:11.760
what we have learned before, new publications, papers out there that, you know, that have a lot

01:11:11.760 --> 01:11:16.080
of data in terms of, you know, studies that are done on this particular gene. And they've described

01:11:16.080 --> 01:11:20.800
like, okay, these alterations actually activate the gene or is bad for the tumor or, you know,

01:11:20.800 --> 01:11:26.240
makes it treatment resistant. So you can see the natural, there's a lot of text as it happens.

01:11:26.240 --> 01:11:31.040
And so in that space, we are seeing in the, I would say in the past, you know, three to four

01:11:31.040 --> 01:11:36.880
years, there's been a lot of application of AI tools that have come out, you know, particularly

01:11:36.880 --> 01:11:41.120
in the space of variant calling, where we have this genomic sequence data and we're trying to

01:11:41.120 --> 01:11:46.320
identify variants. You know, one of the examples that's been talked about a lot is the

01:11:46.320 --> 01:11:51.600
deep variant caller. It's called deep variant from the team at Google who developed that.

01:11:52.720 --> 01:11:56.160
That uses a lot of the AI techniques to be able to pick those things up.

01:11:56.160 --> 01:12:02.640
There are some genomic databases that we use for in silico prediction. For example,

01:12:02.640 --> 01:12:09.040
if you have a variant, we have no idea about it. It uses, there's a database called DB-SC-SNV that

01:12:09.040 --> 01:12:14.800
uses random forest techniques. And I think it uses another algorithm to predict if a certain

01:12:14.800 --> 01:12:21.280
site where there's a mutation can enhance abnormal mechanism called splicing versus not.

01:12:21.840 --> 01:12:26.080
Similarly, there's a lot of tools that are coming in and the LLMs, I think are,

01:12:26.080 --> 01:12:29.600
I would say not mainstream, but I think there's a lot of interesting research that is coming

01:12:29.600 --> 01:12:36.160
around there, but people are trying to use LLMs for doing these more broader excerpts saying that,

01:12:36.160 --> 01:12:41.840
hey, you know, I have these, you know, I don't know, a thousand articles, and I want to find

01:12:41.840 --> 01:12:49.200
these particular combination of words that, you know, you know, it's a combination of a disease

01:12:49.200 --> 01:12:54.720
and a mutation and what do I get back on that? I personally tried, you know, the ChatGPT with

01:12:54.720 --> 01:13:01.600
different, you know, like phrases and questions about it. What I've seen so far is, and this is

01:13:01.600 --> 01:13:08.000
purely my personal experience. I think a lot of it reads very real, but when you start to look

01:13:08.000 --> 01:13:14.800
into the references as to what it references, then you quickly figure it out. This is not the

01:13:14.800 --> 01:13:21.920
real deal. And so I think, I think it's, you know, I'm not a very pessimistic person. I would say,

01:13:21.920 --> 01:13:26.800
oh no, this is all garbage, but I think there is opportunity there. It's just how do you train it.

01:13:26.800 --> 01:13:31.760
Maybe there's a space or an opportunity, and it probably already has been,

01:13:31.760 --> 01:13:37.760
people are pursuing this as training a smaller model, but really deeply in genetics,

01:13:37.760 --> 01:13:41.760
whereas trying, not trying to use a model that tries to understand everything.

01:13:41.760 --> 01:13:46.960
Right. Right. Yeah. It's more, yeah. More in the medical literature or the genomic literature

01:13:46.960 --> 01:13:51.360
to be able to like, meaning is enhancement. Yes. So I think there's active work going on there,

01:13:51.360 --> 01:13:55.680
but it's, yeah, it's, I think it's making, you know, a lot of, a lot of interesting

01:13:55.680 --> 01:14:01.040
research, a lot of potential impact on how, you know, we do things. And obviously the tool sets

01:14:01.040 --> 01:14:04.640
that we currently use, we might expect in the next 10 years to change.

01:14:04.640 --> 01:14:10.960
Yeah, for sure. All right. Final thought here, people are listening. They're maybe doing similar

01:14:10.960 --> 01:14:15.440
work to you. How do they get started? What would you tell them? Get going with Python and some of

01:14:15.440 --> 01:14:21.200
these packages? Yeah. I mean, I would, you know, my reflecting on my own experience sort of, you

01:14:21.200 --> 01:14:30.400
know, in a very winded way that I ended up here, I think, you know, Python is, I feel the program

01:14:30.400 --> 01:14:36.000
in general, and I think Python particularly as a programming language is a very low, you know,

01:14:36.000 --> 01:14:41.040
sort of, you know, entry point in terms of being able to really quickly get things done, like learn

01:14:41.040 --> 01:14:47.120
it easily and get things done. I think it should be to me, anybody, anybody who's trying to pursue

01:14:47.120 --> 01:14:52.960
something in biology or competition biology or bioinformatics, I think this is the first thing.

01:14:52.960 --> 01:14:58.720
It's something easy to do to be, you know, I would say relatively easy to do, to be able to get in

01:14:58.720 --> 01:15:07.280
that. Anybody with, you know, a desire to learn this has analytical thinking. I mean, I think

01:15:07.280 --> 01:15:13.280
investing into Python is probably the best bet because you can pretty much do anything you want.

01:15:13.280 --> 01:15:18.960
That's what I tell, you know, when I train people in my lab or I talk to other students, is that

01:15:18.960 --> 01:15:22.640
if you want to spend your time, you have very little time because you're busy, you know, with

01:15:22.640 --> 01:15:27.520
your other things. I think the one thing that can get some of the job done and be still aligned with

01:15:27.520 --> 01:15:34.080
what you're doing is Python. And after that, I think it's, you know, it's a lot of self-driven

01:15:34.080 --> 01:15:38.240
learning where, you know, you kind of, you know, look into things. But the whole thing is,

01:15:38.240 --> 01:15:42.800
I think the Python community is wonderful. It's almost like I sit down and I think about, oh,

01:15:42.800 --> 01:15:47.520
I have to solve this problem. Probably there are 50 other people who are thinking about that and

01:15:47.520 --> 01:15:49.680
maybe two people have already worked on it. So it's-

01:15:49.680 --> 01:15:52.800
Right, and you've already published it to PyPI and you're good to go.

01:15:53.360 --> 01:15:58.240
Absolutely. I totally agree with that. And, you know, people should take the couple of weeks,

01:15:58.240 --> 01:16:02.720
get good at it, and it'll amplify. It'll save you time, definitely, in the long run.

01:16:02.720 --> 01:16:08.560
It is, yeah. Oh, absolutely. Yes. The only thing that I, that I, the only thing I would say,

01:16:08.560 --> 01:16:15.280
like an added thing is if somebody is learning Python and then they do have an intention,

01:16:15.280 --> 01:16:19.520
you know, to take it to the point where they will be involved in more serious,

01:16:20.560 --> 01:16:24.160
like, you know, application development or maintaining an open source package or,

01:16:24.160 --> 01:16:27.760
you know, however they contribute to that. I think learning a little bit more,

01:16:27.760 --> 01:16:33.600
like learning Python in its real sense in terms of how to do it right. You know, there are five

01:16:33.600 --> 01:16:38.960
ways of doing something correctly. But I think there's one way that is consistent so that it's,

01:16:38.960 --> 01:16:43.120
again, you know, easily shared, it's easily maintainable, others can easily understand.

01:16:43.120 --> 01:16:47.120
I think that would be my second advice. It is, it takes a little bit of time, but I think it's

01:16:47.120 --> 01:16:53.120
well worth the effort to spend the time writing, you know, idiomatic Python code. So it's,

01:16:53.120 --> 01:16:58.480
it's portable. Absolutely. All right. So, Mac, thank you for being on the show. It's been

01:16:58.480 --> 01:17:01.200
great to get this look inside of what you all are doing with Python.

01:17:01.200 --> 01:17:03.440
Yeah. Thank you for having me on the show. I appreciate that.

01:17:03.440 --> 01:17:04.240
Yep. Bye.

01:17:04.240 --> 01:17:05.200
Okay. Bye, bye.

01:17:05.200 --> 01:17:11.520
This has been another episode of Talk Python to Me. Thank you to our sponsors. Be sure to check

01:17:11.520 --> 01:17:16.000
out what they're offering. It really helps support the show. Take some stress out of your life.

01:17:16.000 --> 01:17:20.480
Get notified immediately about errors and performance issues in your web or mobile

01:17:20.480 --> 01:17:26.960
applications with Sentry. Just visit talkpython.fm/sentry and get started for free. And

01:17:26.960 --> 01:17:33.040
be sure to use the promo code talkpython, all one word. This episode is sponsored by Posit Connect

01:17:33.040 --> 01:17:37.440
from the makers of Shiny. Publish, share, and deploy all of your data projects that you're

01:17:37.440 --> 01:17:44.480
creating using Python. Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto, Reports, Dashboards,

01:17:44.480 --> 01:17:49.760
and APIs. Posit Connect supports all of them. Try Posit Connect for free by going to

01:17:49.760 --> 01:17:53.280
talkpython.fm/posit. P-O-S-I-T.

01:17:53.280 --> 01:17:58.560
Want to level up your Python? We have one of the largest catalogs of Python video courses over at

01:17:58.560 --> 01:18:04.480
Talk Python. Our content ranges from true beginners to deeply advanced topics like memory and async.

01:18:04.480 --> 01:18:08.240
And best of all, there's not a subscription in sight. Check it out for yourself at

01:18:08.240 --> 01:18:13.760
training.talkpython.fm. Be sure to subscribe to the show, open your favorite podcast app,

01:18:13.760 --> 01:18:18.240
and search for Python. We should be right at the top. You can also find the iTunes feed at

01:18:18.240 --> 01:18:25.360
/iTunes, the Google Play feed at /play, and the Direct RSS feed at /rss on talkpython.fm.

01:18:25.360 --> 01:18:30.000
We're live streaming most of our recordings these days. If you want to be part of the show and have

01:18:30.000 --> 01:18:35.200
your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:18:35.200 --> 01:18:40.800
This is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it.

01:18:40.800 --> 01:18:44.800
Now get out there and write some Python code.

