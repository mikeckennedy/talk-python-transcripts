WEBVTT

00:00:00.001 --> 00:00:02.680
You've probably heard the term syntactic sugar.

00:00:02.680 --> 00:00:05.140
That is syntax within a programming language

00:00:05.140 --> 00:00:08.820
that is designed to make things easier to read or to express.

00:00:08.820 --> 00:00:11.980
It makes the language sweeter for humans to use.

00:00:11.980 --> 00:00:16.140
It turns out Brett Cannon has spent two years diving into

00:00:16.140 --> 00:00:19.200
and writing about Python's sweet language features

00:00:19.200 --> 00:00:22.260
and how they really work down inside CPython.

00:00:22.260 --> 00:00:26.180
He joins me on the show today to dive into a few of the more relevant posts

00:00:26.180 --> 00:00:27.000
he's written about.

00:00:27.400 --> 00:00:32.620
This is Talk Python to Me, episode 441, recorded November 1st, 2023.

00:00:32.620 --> 00:00:50.260
Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:50.260 --> 00:00:52.000
This is your host, Michael Kennedy.

00:00:52.000 --> 00:00:54.660
Follow me on Mastodon, where I'm @mkennedy,

00:00:54.660 --> 00:00:57.100
and follow the podcast using @talkpython.

00:00:57.100 --> 00:00:59.480
Both on fosstodon.org.

00:00:59.480 --> 00:01:03.060
Keep up with the show and listen to over seven years of past episodes

00:01:03.060 --> 00:01:04.580
at talkpython.fm.

00:01:04.580 --> 00:01:08.360
We've started streaming most of our episodes live on YouTube.

00:01:08.360 --> 00:01:12.120
Subscribe to our YouTube channel over at talkpython.fm/youtube

00:01:12.120 --> 00:01:15.900
to get notified about upcoming shows and be part of that episode.

00:01:17.080 --> 00:01:21.340
This episode is sponsored by us over at Talk Python Training.

00:01:21.340 --> 00:01:25.960
Did you know that we have over 250 hours of Python courses?

00:01:25.960 --> 00:01:27.140
Yeah, that's right.

00:01:27.140 --> 00:01:29.760
Check them out at talkpython.fm/courses.

00:01:29.760 --> 00:01:34.620
Brett, welcome back to Talk Python to Me.

00:01:34.620 --> 00:01:35.720
You've been here a time or two.

00:01:35.720 --> 00:01:37.220
Always great to have you here.

00:01:37.220 --> 00:01:38.880
Well, thanks for having me yet again, Michael.

00:01:38.880 --> 00:01:40.900
I'm glad I've not worn out my welcome quite yet.

00:01:41.040 --> 00:01:42.760
You always have so much cool stuff going on

00:01:42.760 --> 00:01:44.760
and so many interesting perspectives.

00:01:44.760 --> 00:01:47.120
Some would call them interesting.

00:01:47.120 --> 00:01:51.020
Whether that's a positive or negative is still open to interpretation.

00:01:51.020 --> 00:01:53.320
May you program in interesting times,

00:01:53.320 --> 00:01:55.200
as the old ancient proverb goes.

00:01:55.200 --> 00:01:55.720
Mm-hmm.

00:01:56.380 --> 00:01:57.880
So, been here a bunch of times,

00:01:57.880 --> 00:02:01.340
but real quick, just tell people a bit about yourself before we jump in.

00:02:01.340 --> 00:02:01.780
Sure.

00:02:01.780 --> 00:02:02.940
Just in case they don't know you.

00:02:02.940 --> 00:02:03.220
Yeah.

00:02:03.220 --> 00:02:04.780
Name's Brett Cannon.

00:02:04.780 --> 00:02:07.040
I live in Vancouver on the unceded territories

00:02:07.040 --> 00:02:10.180
of the Squamish, Tsleil-Waututh, and Musqueam First Nations.

00:02:10.180 --> 00:02:14.760
I am currently the dev manager for the Python extension in VS Code.

00:02:14.760 --> 00:02:19.460
I am serving my fifth and, as of now, final term

00:02:19.460 --> 00:02:20.780
on the Python Steering Council.

00:02:20.780 --> 00:02:24.300
I'm stepping down just because when we first created the Steering Council,

00:02:24.300 --> 00:02:26.340
I said five years seemed like a good term limit.

00:02:26.340 --> 00:02:29.240
We actually don't have term limits, but figured I'd stick to my word.

00:02:29.240 --> 00:02:32.780
And I'm also, thus, also a core developer.

00:02:32.780 --> 00:02:34.880
I've been doing it for just over 20 years.

00:02:34.880 --> 00:02:38.260
Lucky for me, I got it, my first commit bit right after the,

00:02:38.260 --> 00:02:40.400
sorry, my first commit bit after the first PyCon.

00:02:40.400 --> 00:02:43.620
So, I get to use the PyCon anniversaries as a way to keep track of that.

00:02:43.620 --> 00:02:44.320
So, that's convenient.

00:02:44.320 --> 00:02:46.140
That's kind of the biggies.

00:02:46.140 --> 00:02:46.860
Have a cap.

00:02:46.860 --> 00:02:47.160
Yeah.

00:02:47.160 --> 00:02:48.440
That's usually the other thing people like.

00:02:48.440 --> 00:02:49.540
Something about VS Code?

00:02:49.540 --> 00:02:50.520
I've heard that word.

00:02:50.520 --> 00:02:51.300
It's an editor, right?

00:02:51.300 --> 00:02:52.040
Yeah, I know.

00:02:52.040 --> 00:02:54.040
Someday, you'll say you use it,

00:02:54.100 --> 00:02:55.440
and I'll be very happy that day.

00:02:55.440 --> 00:02:57.060
I had it open today.

00:02:57.060 --> 00:02:57.900
Oh, all right.

00:02:57.900 --> 00:02:59.220
Well, there, I'm happy today then.

00:02:59.220 --> 00:02:59.920
Yes, indeed.

00:02:59.920 --> 00:03:01.220
No, awesome.

00:03:01.220 --> 00:03:03.060
So many cool things you got going on.

00:03:03.060 --> 00:03:10.960
And despite all of that background in steering council, core dev, here, this time, you're

00:03:10.960 --> 00:03:15.140
here to give us, like, diet advice, eating advice, like something about sugar.

00:03:15.140 --> 00:03:15.920
What is it?

00:03:15.920 --> 00:03:16.480
Yeah.

00:03:16.480 --> 00:03:18.380
Just a slight story behind all this.

00:03:18.740 --> 00:03:24.100
My wife was taking the certificate in data science course at the University of British Columbia,

00:03:24.100 --> 00:03:26.640
which is actually our alma mater and where we met.

00:03:26.640 --> 00:03:34.880
And she was doing her homework in a JupyterLab notebook through the browser via JupyterHub.

00:03:35.140 --> 00:03:39.020
And she stopped doing the homework to go, I can't remember if it was lunch or dinner, but

00:03:39.020 --> 00:03:40.540
basically stepped away for like an hour or so.

00:03:40.540 --> 00:03:44.480
And then she came back and the run buttons on the cells weren't working anymore.

00:03:44.480 --> 00:03:45.720
I was like, well, what's going on?

00:03:45.720 --> 00:03:48.740
And I looked and I was like, oh, well, you got disconnected from the server.

00:03:48.740 --> 00:03:51.100
I said, well, isn't that happening in the browser?

00:03:51.440 --> 00:03:54.120
Like, no, Python doesn't run in the browser right now.

00:03:54.120 --> 00:03:55.100
It's not a thing.

00:03:55.100 --> 00:03:55.960
Oh, OK.

00:03:55.960 --> 00:04:01.220
I think about a day or two later after she thought about it, we were in the car and I

00:04:01.220 --> 00:04:03.960
still remember the exact location in Vancouver where this occurred.

00:04:03.960 --> 00:04:08.180
My wife said, you know, you should probably fix that problem of Python not working in the

00:04:08.180 --> 00:04:08.440
browser.

00:04:08.440 --> 00:04:12.560
And I explained like what WebAssembly was and how big of a thing that would be to make

00:04:12.560 --> 00:04:13.620
that all happen and all that.

00:04:13.620 --> 00:04:17.940
And she literally took about a beat to wait and said, no, you should go fix that.

00:04:18.460 --> 00:04:24.200
Part of that led me down the road of trying to figure out what the minimum viable Python

00:04:24.200 --> 00:04:24.900
was, right?

00:04:24.900 --> 00:04:29.200
Like, what is the minimal amount of Python I would have to implement in the browser or in

00:04:29.200 --> 00:04:32.340
WebAssembly in this case to make Python work?

00:04:32.340 --> 00:04:37.560
And I had realized that, you know, a decent amount of Python is actually what's called syntactic

00:04:37.560 --> 00:04:43.360
sugar, which is really just syntax that you could actually devolve and unravel into other

00:04:43.360 --> 00:04:47.420
syntax of a language and have it do the exact same thing, right?

00:04:47.420 --> 00:04:49.680
It's just basically syntax that's a shortcut.

00:04:49.680 --> 00:04:56.160
And so I ended up going on this very long journey, unexpectedly long, of trying to go through

00:04:56.160 --> 00:05:01.040
all of Python syntax and trying to figure out which parts of the syntax was like crucial

00:05:01.040 --> 00:05:05.780
and you couldn't actually re-implement it in pure Python itself and which parts you could

00:05:05.780 --> 00:05:08.820
actually just make it work with Python code itself.

00:05:08.820 --> 00:05:13.580
With the idea that at the end, it would have basically a list of the bits of Python that an

00:05:13.580 --> 00:05:17.540
interpreter would have to implement and the other bits of syntax where you could run some

00:05:17.540 --> 00:05:18.980
tool over it ahead of time.

00:05:18.980 --> 00:05:21.700
It would just translate from Python to different Python code.

00:05:21.700 --> 00:05:25.140
And in that way, I would just know what the exact target would have to be.

00:05:25.140 --> 00:05:26.500
It might not run very fast.

00:05:26.500 --> 00:05:27.340
Don't get me wrong.

00:05:27.340 --> 00:05:33.000
But it would at least be a very clear definition of kind of what you have to have to really call

00:05:33.000 --> 00:05:33.760
something Python.

00:05:33.760 --> 00:05:34.620
It's everything else.

00:05:34.620 --> 00:05:34.840
Right.

00:05:34.840 --> 00:05:36.200
kind of just work around.

00:05:36.200 --> 00:05:36.520
Right.

00:05:36.520 --> 00:05:40.100
So the standard Python syntax we expect still works.

00:05:40.100 --> 00:05:43.080
But how much do you have to work behind the scenes to make that happen?

00:05:43.080 --> 00:05:47.620
So examples that come to mind for me are context managers, the width block.

00:05:47.620 --> 00:05:48.280
Awesome.

00:05:48.280 --> 00:05:49.100
I love them.

00:05:49.100 --> 00:05:50.380
But we have try finally.

00:05:50.380 --> 00:05:57.200
And you could simulate a context manager effectively with maybe a try finally, maybe an accepts in

00:05:57.200 --> 00:05:57.880
there as well.

00:05:57.880 --> 00:06:02.680
But you don't actually need width in the language to accomplish what it does.

00:06:02.680 --> 00:06:02.920
Right.

00:06:03.080 --> 00:06:03.200
Yeah.

00:06:03.200 --> 00:06:05.360
Decorators are also another really good example, right?

00:06:05.360 --> 00:06:09.640
Like where the concepts for that syntax predates it.

00:06:09.640 --> 00:06:15.680
And it happened to just be something where Python core development team looked at where people

00:06:15.680 --> 00:06:20.040
were in terms of development and what they needed from Python and realized, you know what?

00:06:20.040 --> 00:06:26.120
That common pattern that people are doing would actually be would be very well served via

00:06:26.120 --> 00:06:26.960
a piece of syntax.

00:06:26.960 --> 00:06:28.120
So why don't we just do that?

00:06:28.120 --> 00:06:29.820
Why don't we introduce that piece of syntax?

00:06:29.820 --> 00:06:30.620
Make things happen.

00:06:30.680 --> 00:06:33.900
As you said, with context managers were a perfect example, right?

00:06:33.900 --> 00:06:40.160
Where before, if you wanted to do the right thing when you opened a file is you call the

00:06:40.160 --> 00:06:44.440
open function for your file, sign it to a variable, do your try block of everything you want to

00:06:44.440 --> 00:06:46.020
do with the file.

00:06:46.020 --> 00:06:51.700
And then in the finally part of the try finally close that file, which I mean, if you just think

00:06:51.700 --> 00:06:57.120
about it compared to a with statement is four lines, assuming you're doing reasonable formatting for

00:06:57.120 --> 00:07:03.380
the assignment, the try, the finally, then the close call versus the single with open to get the exact

00:07:03.380 --> 00:07:03.700
effect.

00:07:03.700 --> 00:07:08.140
And then you've also got the possibility that the context manager, the thing that's used in

00:07:08.140 --> 00:07:12.080
the with block can do something different if there's an exception, right?

00:07:12.080 --> 00:07:15.660
Like if there's an exception, it could say if it's a database transaction, it could roll back the

00:07:15.660 --> 00:07:16.980
transaction automatically.

00:07:17.180 --> 00:07:19.540
Rather, if there's no exception, it could commit it automatically.

00:07:19.540 --> 00:07:21.060
But there's no real magic there.

00:07:21.060 --> 00:07:23.680
If you think about it in the end, you could have written that all out by hand.

00:07:23.680 --> 00:07:25.300
It just would have been cumbersome.

00:07:25.300 --> 00:07:29.440
But that makes the with statement very much a piece of syntactic sugar where you could totally

00:07:29.440 --> 00:07:31.980
write it out, get the exact same semantic outcome.

00:07:31.980 --> 00:07:33.520
It might be a little slower.

00:07:33.520 --> 00:07:35.380
Probably similar performance as well.

00:07:35.380 --> 00:07:37.200
And maybe similar.

00:07:37.560 --> 00:07:38.960
It really depends on the syntax, right?

00:07:38.960 --> 00:07:43.560
Like how complicated it is, how much of it's going to call into, at least in CPython's

00:07:43.560 --> 00:07:46.580
case, into the C code and stay in the C code versus not.

00:07:46.580 --> 00:07:50.780
Like with context managers, probably won't just because the point is you're going to call

00:07:50.780 --> 00:07:53.260
that dunder enter method or that dunder exit method.

00:07:53.260 --> 00:07:54.560
So you're calling Python code.

00:07:54.560 --> 00:07:56.500
So no real, probably big shift.

00:07:56.500 --> 00:08:01.380
But for stuff that we'll probably cover in this podcast, there are other bits that go into

00:08:01.380 --> 00:08:03.000
the C code and stay in the C code.

00:08:03.000 --> 00:08:05.460
And when that happens, stuff can go really, really fast.

00:08:05.600 --> 00:08:09.220
Yeah, especially with all the work the faster CPython team's done around stuff and all that.

00:08:09.220 --> 00:08:13.860
So the point is you can just start to just kind of leap into C code, stay there and get

00:08:13.860 --> 00:08:14.800
stuff done way faster.

00:08:14.800 --> 00:08:19.140
Comparative to writing out by hand where you're staying in the Python world, it can just take

00:08:19.140 --> 00:08:19.580
a bit longer.

00:08:19.580 --> 00:08:19.880
Yeah.

00:08:19.880 --> 00:08:23.180
So the word sugar, I think it's a good one here.

00:08:23.180 --> 00:08:27.360
I love like these ideas like code smells, code sugar, all the things.

00:08:27.360 --> 00:08:33.300
It makes it sound a little frivolous, maybe like little, it's nice to have.

00:08:33.300 --> 00:08:34.020
It sweetens it up.

00:08:34.020 --> 00:08:34.700
You don't really need it.

00:08:34.980 --> 00:08:40.400
But I do think having these different constructs, like when you see a with block, it instantly

00:08:40.400 --> 00:08:41.600
conveys meaning.

00:08:41.600 --> 00:08:43.220
It means we're going to create a thing.

00:08:43.220 --> 00:08:44.500
We have a cleanup section.

00:08:44.500 --> 00:08:45.680
We don't have to deal with it.

00:08:45.680 --> 00:08:50.380
As opposed to if you see a try except finally, you have to read it and process it and see,

00:08:50.380 --> 00:08:53.180
okay, does it actually do the things that would be accomplished?

00:08:53.180 --> 00:08:59.000
I think these sugars let you also think, not just write less good, but think in different

00:08:59.000 --> 00:08:59.980
levels of abstraction.

00:09:00.400 --> 00:09:00.640
Yeah.

00:09:00.640 --> 00:09:05.340
I mean, as you said, the use of the word sugar is meant to mean something sweet, something

00:09:05.340 --> 00:09:05.580
nice.

00:09:05.580 --> 00:09:06.240
It's a treat.

00:09:06.240 --> 00:09:07.120
It's a bonus.

00:09:07.860 --> 00:09:11.760
So from the perspective of if you didn't have it, you could still accomplish it.

00:09:11.760 --> 00:09:18.680
But that can potentially, in a way, as you've suggested, not quite denote the benefit of it,

00:09:18.680 --> 00:09:19.080
right?

00:09:19.080 --> 00:09:22.960
Like if we think of sugar in terms of not something good for your diet.

00:09:22.960 --> 00:09:23.220
Yeah.

00:09:23.220 --> 00:09:25.160
What is your perspective on sugar, right?

00:09:25.160 --> 00:09:27.360
Are you a fan of desserts or are you trying to cut it out?

00:09:27.360 --> 00:09:27.560
Yeah.

00:09:27.740 --> 00:09:32.980
But yeah, I mean, the hope is whenever we add syntax to Python, it's for everyone's

00:09:32.980 --> 00:09:34.040
general benefit, right?

00:09:34.040 --> 00:09:35.540
This is why we don't do it very often.

00:09:35.540 --> 00:09:40.360
And when we do do it, it's a very thoughtful discussion, very long discussion, sometimes

00:09:40.360 --> 00:09:41.600
contentious discussion.

00:09:41.600 --> 00:09:45.000
Walrus operator is the famous one for that.

00:09:45.000 --> 00:09:47.100
I don't understand the contention in the Walrus operator.

00:09:47.100 --> 00:09:50.600
It's such a small change to the language.

00:09:50.600 --> 00:09:53.300
There's so many other things that are bigger changes that could have been battles.

00:09:53.300 --> 00:09:56.480
But I guess it just came to a head at that point or something, right?

00:09:56.620 --> 00:10:00.020
For those of you who don't know the Walrus operator is the thing that pushed Guido kind

00:10:00.020 --> 00:10:03.920
of over the edge to finally step down as being the bit of a dictator for life.

00:10:03.920 --> 00:10:10.860
And it was just due to the veracity of the opposition to it and just how basically angry

00:10:10.860 --> 00:10:11.640
it made people.

00:10:11.640 --> 00:10:13.140
And you're right.

00:10:13.140 --> 00:10:13.820
It's very small.

00:10:13.820 --> 00:10:16.400
And to be honest, I've used it and I like it.

00:10:16.400 --> 00:10:17.260
I get use out of it.

00:10:17.260 --> 00:10:18.540
It means it.

00:10:18.540 --> 00:10:23.540
I use it for its purpose, which was to add some basic syntax for those up those situations

00:10:23.540 --> 00:10:26.600
where you always have that assignment and then you do something like an if.

00:10:26.600 --> 00:10:30.800
for something and then you're going to do something like just be able to inline certain

00:10:30.800 --> 00:10:32.160
things to just do the right thing.

00:10:32.160 --> 00:10:35.220
It's not a huge thing, but it's a nice thing.

00:10:35.220 --> 00:10:37.380
And in that case, I don't know.

00:10:37.380 --> 00:10:43.960
Honestly, a lot of people got really concerned that they didn't see the usefulness enough that

00:10:43.960 --> 00:10:49.320
they thought it was going to be a slippery slope or people are always very concerned about

00:10:49.320 --> 00:10:53.240
Python getting too big and it's no longer fitting in their brain.

00:10:53.460 --> 00:10:53.560
Yeah.

00:10:53.560 --> 00:10:57.820
Maybe it was kind of the last straw sort of thing rather than like maybe stuff came before

00:10:57.820 --> 00:10:58.680
and they're like, all right, that's it.

00:10:58.680 --> 00:11:02.320
And now the walrus, the walrus, like, you know, I don't know.

00:11:02.320 --> 00:11:03.220
I don't know.

00:11:03.220 --> 00:11:06.740
I mean, I don't think people realize that we actually cut syntax out when we moved from Python

00:11:06.740 --> 00:11:07.780
two to Python three.

00:11:07.780 --> 00:11:08.240
Yeah.

00:11:08.240 --> 00:11:09.560
That was all kind of brewing.

00:11:09.560 --> 00:11:09.920
Yeah.

00:11:09.920 --> 00:11:11.160
Like the back ticks went away.

00:11:11.240 --> 00:11:14.780
Like no one knows about the back ticks anymore, but we used to have syntax for using back

00:11:14.780 --> 00:11:16.800
ticks and that's now that's gone now.

00:11:16.800 --> 00:11:20.020
So it's not like it's always been a add, add, add.

00:11:20.020 --> 00:11:23.140
But I think it's just one of these things where it's just people were very concerned that

00:11:23.140 --> 00:11:26.800
Python would get too big, too complicated, and it wouldn't be fully understandable.

00:11:26.800 --> 00:11:32.040
I will say whenever we do this, we very much consider how easy it would be to understand

00:11:32.040 --> 00:11:35.540
if you saw it for the first time and never received any instruction about it.

00:11:35.580 --> 00:11:35.740
Right.

00:11:35.740 --> 00:11:39.860
Like I would argue that walrus operator is a bit obvious if you look at the code around

00:11:39.860 --> 00:11:41.240
it of what it does.

00:11:41.240 --> 00:11:45.700
And so you can probably figure out what it does without being told ahead of time versus

00:11:45.700 --> 00:11:49.020
other syntax and other languages where you go, I have no clue what this does.

00:11:49.020 --> 00:11:49.640
Right.

00:11:49.640 --> 00:11:50.060
Exactly.

00:11:50.060 --> 00:11:50.500
Right.

00:11:50.500 --> 00:11:55.880
Like why does plus plus and C do different things if it's in the front or the back?

00:11:55.880 --> 00:11:56.700
And what's the difference?

00:11:56.700 --> 00:12:02.420
Like unless you know prefix versus suffix increment and the difference in terms of referencing the

00:12:02.420 --> 00:12:05.500
pointer and all this crazy stuff, like you're not going to necessarily pick up

00:12:05.500 --> 00:12:08.160
on the difference unless you run your code versus something where you can just look at

00:12:08.160 --> 00:12:09.900
it and just learn on the spot.

00:12:09.900 --> 00:12:14.420
Well, I want to give you all a bit of a compliment, I guess, or encouragement.

00:12:14.420 --> 00:12:17.940
I think the Python language is not changing too fast.

00:12:17.940 --> 00:12:21.080
I think it's the stability over time is really good.

00:12:21.080 --> 00:12:22.840
You compare that to other languages.

00:12:22.840 --> 00:12:26.940
I mean, here's one that's kind of close to home for you since you're at Microsoft, like

00:12:26.940 --> 00:12:27.320
C Sharp.

00:12:27.320 --> 00:12:30.500
I feel like that language is pretty nice, at least in the early days.

00:12:30.500 --> 00:12:33.860
And now there's a whole team who are employed.

00:12:33.860 --> 00:12:35.100
You don't have to make any comment.

00:12:35.160 --> 00:12:41.040
I know you work there, but there's a whole team who's employed to shepherd that language.

00:12:41.040 --> 00:12:45.540
And I feel like there's a feeling they always need to have some new language features because

00:12:45.540 --> 00:12:47.600
it's their job to have language features.

00:12:47.600 --> 00:12:51.880
There's just like a constant kind of turn, like for properties, like we have properties,

00:12:51.880 --> 00:12:52.480
they have properties.

00:12:52.480 --> 00:12:56.480
But I think there's four to five different ways that properties in C Sharp that have evolved

00:12:56.480 --> 00:12:57.200
over time.

00:12:57.200 --> 00:13:01.220
And you're just like, yeah, it's a little better, but it's why do we have so many ways if you're

00:13:01.220 --> 00:13:01.740
going to be there?

00:13:01.820 --> 00:13:01.980
Right.

00:13:01.980 --> 00:13:08.900
And so when I at least look at Python compared to like my background in C++ or in C Sharp

00:13:08.900 --> 00:13:11.420
or JavaScript, I feel like it's comfortable.

00:13:11.420 --> 00:13:13.720
It's not stale, but it's not.

00:13:13.720 --> 00:13:15.460
We don't have five ways to do properties.

00:13:15.460 --> 00:13:17.740
That's a good thing.

00:13:17.740 --> 00:13:22.280
Even if there's a better way to do it, it might not be worth having two to three ways just

00:13:22.280 --> 00:13:23.660
for that for a slight advantage.

00:13:23.660 --> 00:13:24.880
Well, thank you for the kind words.

00:13:24.880 --> 00:13:25.320
Yeah.

00:13:25.320 --> 00:13:30.240
I mean, we do have the Zen of Python does kind of outline the general guidelines we try to

00:13:30.240 --> 00:13:32.840
follow when doing making these discussions decisions.

00:13:32.840 --> 00:13:37.100
For those who've never read the Zen of Python, look, just run, import this from the REPL and

00:13:37.100 --> 00:13:38.220
you'll find it.

00:13:38.220 --> 00:13:40.700
And yeah, it's just the way it's designed, right?

00:13:40.700 --> 00:13:45.680
We don't, hopefully there's one and hopefully only one obvious way to do anything.

00:13:46.080 --> 00:13:50.060
And so it's just something we've kind of leaned into now, granted things shift.

00:13:50.060 --> 00:13:54.860
Like I'm sure someone will point out the myriad of ways you can format a string now, but a

00:13:54.860 --> 00:13:57.240
lot of that's backwards compatibility and just realizing, you know what?

00:13:57.240 --> 00:14:02.200
We just have to accept the fact the first way we got it is no longer the best way we

00:14:02.200 --> 00:14:02.840
can think of.

00:14:02.840 --> 00:14:07.460
And it's enough of a jump from using string interpolation with the percent sign to using

00:14:07.460 --> 00:14:11.300
f-strings that it was worth adding a second way.

00:14:11.300 --> 00:14:14.420
Now, maybe someday we'll take out string interpolation.

00:14:14.540 --> 00:14:18.100
I doubt it because it just works and it's just sitting there and it's not worth breaking

00:14:18.100 --> 00:14:19.160
really old code.

00:14:19.160 --> 00:14:21.740
But I mean, it's just the way we approach things.

00:14:21.740 --> 00:14:22.880
And luckily, most people like it.

00:14:22.880 --> 00:14:26.060
And I think that's kind of why some people always freak out is the words afraid somehow

00:14:26.060 --> 00:14:30.380
we're going to go downhill from here and it's just the start of things or somehow Python

00:14:30.380 --> 00:14:31.500
is going to be harder to learn.

00:14:31.500 --> 00:14:35.420
Well, we very much try to make sure Python is a gradual curve of learning, right?

00:14:35.420 --> 00:14:37.540
The basics are very straightforward and good.

00:14:37.540 --> 00:14:40.360
And as you get into more advanced things like the match statement, right?

00:14:40.360 --> 00:14:42.440
You'll be able to see it and understand it.

00:14:42.520 --> 00:14:46.140
It'll make sense, but not something you'll necessarily learn the first month or two,

00:14:46.140 --> 00:14:48.020
but it's there for when you do need it, right?

00:14:48.020 --> 00:14:53.880
Like we very much try to make sure that everything makes sense on a curve from beginner to advanced

00:14:53.880 --> 00:14:57.580
and try to make sure the language is useful to everyone from both a beginner to advanced

00:14:57.580 --> 00:14:57.860
user.

00:14:57.860 --> 00:15:00.380
It's tricky, but I like to think we're doing a decent job.

00:15:00.600 --> 00:15:00.840
Yeah.

00:15:00.840 --> 00:15:05.960
One of Python's really, one of its powers is that you can be super effective with it with

00:15:05.960 --> 00:15:08.680
a really partial understanding of what it is, right?

00:15:08.680 --> 00:15:12.420
You don't have to understand namespaces, classes, async, et cetera, et cetera.

00:15:12.420 --> 00:15:15.860
You're just like, well, I think I can write these four lines in a, without even a function

00:15:15.860 --> 00:15:18.840
and I'll get a cool graph that'll show my, my work or whatever, right?

00:15:18.840 --> 00:15:19.060
Yep.

00:15:19.060 --> 00:15:19.600
Exactly.

00:15:19.600 --> 00:15:19.900
Yep.

00:15:20.160 --> 00:15:22.960
And I think I have a pretty partial understanding of the match statement.

00:15:22.960 --> 00:15:27.540
I know it can get pretty advanced in like how it captures and changes values, but I wrote

00:15:27.540 --> 00:15:29.400
one yesterday with a partial understanding.

00:15:29.400 --> 00:15:29.840
It went great.

00:15:29.840 --> 00:15:30.180
Nice.

00:15:30.300 --> 00:15:30.480
Yeah.

00:15:30.480 --> 00:15:31.000
Indeed.

00:15:31.000 --> 00:15:31.640
All right.

00:15:31.640 --> 00:15:37.120
Before we move on though, got to go back to the, the, your opening because you said,

00:15:37.120 --> 00:15:43.220
I created this to understand, like, if I were to solve that problem, your wife had about like,

00:15:43.220 --> 00:15:44.840
you got to fix that thing about the browser.

00:15:44.840 --> 00:15:48.800
And I know there's some folks in Texas who have thoughts on this as well in the PyScript

00:15:48.800 --> 00:15:55.540
team, but is this project you're actively working on or just, let me gather up, do some

00:15:55.540 --> 00:15:59.820
research and deep thinking about what is actually in the language that would have to carry

00:15:59.820 --> 00:16:01.360
over or where's it coming from?

00:16:01.360 --> 00:16:01.720
I guess.

00:16:01.720 --> 00:16:04.540
No, it's not an active project of mine at the moment.

00:16:04.540 --> 00:16:10.360
It ended up being mostly just an exercise and just snowballed into a thing where I just

00:16:10.360 --> 00:16:11.820
didn't want to stop until I completed it.

00:16:11.820 --> 00:16:12.080
Yeah.

00:16:12.080 --> 00:16:18.140
How do you feel about the, the micro Python, PyScript angle of approaching this?

00:16:18.140 --> 00:16:18.600
Yeah.

00:16:18.600 --> 00:16:22.400
I mean, I think it's great that, I mean, that was the other hopeful benefit about all of this

00:16:22.400 --> 00:16:26.660
is trying to nail down the definition of what Python is.

00:16:26.660 --> 00:16:27.000
Yeah.

00:16:27.000 --> 00:16:31.980
Cause I've heard those arguments made against micro Python that it's not quite Python cause

00:16:31.980 --> 00:16:35.920
it doesn't quite run all the syntax or it doesn't have the entire standard library.

00:16:35.920 --> 00:16:41.540
I've gotten into arguments with people online where they got very upset when I suggested that

00:16:41.540 --> 00:16:44.820
the REPL was an optional part of Python and actually not a requirement.

00:16:45.480 --> 00:16:50.340
And I just viewed it as a learning experience for me, hopefully a learning experience for

00:16:50.340 --> 00:16:51.020
others as well.

00:16:51.140 --> 00:16:55.880
And then after that was just trying to hopefully clarify and like, like, look, this is truly

00:16:55.880 --> 00:16:57.580
what you have to have to really be Python.

00:16:57.580 --> 00:17:01.520
You literally cannot implement the rest of the language without this, but everything else,

00:17:01.520 --> 00:17:02.740
you could totally just do it yourself.

00:17:02.740 --> 00:17:05.120
You could totally just write your tool and make it all work.

00:17:05.120 --> 00:17:08.140
And as long as this existed, you could totally get it by with it.

00:17:08.140 --> 00:17:10.260
And so that's kind of where I ended up.

00:17:10.340 --> 00:17:14.500
I luckily the tooling around WebAssembly got far enough along.

00:17:14.500 --> 00:17:16.160
Pyodide's continued to do well in the browser.

00:17:16.160 --> 00:17:21.320
I've been working on the WebAssembly, the system interface, WASI side of things, and that's

00:17:21.320 --> 00:17:22.200
been going pretty well.

00:17:22.200 --> 00:17:24.780
So that's at least taken care of itself.

00:17:25.360 --> 00:17:31.740
So I've ultimately not tackled the huge problem of trying to reimplement Python from scratch,

00:17:31.740 --> 00:17:36.280
probably in Rust, just in a minimal fashion to try to make it work better in the browser.

00:17:36.280 --> 00:17:38.800
That's probably a project for when I retire.

00:17:38.800 --> 00:17:42.080
And I suspect that's at least a decade out, if not more.

00:17:42.080 --> 00:17:44.860
So that's probably going to be put on the back burner for a while.

00:17:44.860 --> 00:17:45.160
Right.

00:17:45.160 --> 00:17:45.480
Yeah.

00:17:45.480 --> 00:17:49.160
We could all install Bpython and run Brett Python built in Rust.

00:17:49.160 --> 00:17:49.860
There you go.

00:17:49.860 --> 00:17:54.560
Rust does seem to be having quite the influence.

00:17:55.000 --> 00:18:00.100
an outsized influence for how popular Rust is in terms of the number of developers, but

00:18:00.100 --> 00:18:05.280
it seems to be really leaving its mark on Python and other areas as well these days.

00:18:05.280 --> 00:18:05.980
Yeah.

00:18:05.980 --> 00:18:11.240
Well, I mean, I will fully admit I have bias because I am a fan and I do like using the

00:18:11.240 --> 00:18:15.460
language, but it's one of those things where if you've been living in the C and C++ world

00:18:15.460 --> 00:18:18.840
and it never was that satisfying to you, but you had to be there for whatever reason.

00:18:18.840 --> 00:18:24.640
And then you discover Rust and it does things that saves you from very chronic problems.

00:18:24.640 --> 00:18:25.020
Yeah.

00:18:25.020 --> 00:18:25.800
Including yourself.

00:18:25.800 --> 00:18:26.220
Yeah.

00:18:26.220 --> 00:18:29.800
You would hope that you, people would notice and latch onto it.

00:18:29.800 --> 00:18:32.780
And I mean, that's, I think that's basically what's happened is people have just discovered

00:18:32.780 --> 00:18:35.640
that, oh yeah, this is useful and good.

00:18:35.640 --> 00:18:41.540
And just there's enough C and C++ code in the Python community due to CPython C API that

00:18:41.540 --> 00:18:44.100
I think there's just a nice cross section, right?

00:18:44.100 --> 00:18:47.220
I think it's just one of these things where people have just gone like, well, I've got to

00:18:47.220 --> 00:18:49.540
be, I got to do the system level programming anyway.

00:18:49.540 --> 00:18:53.140
So I might as well use something that's seems like a better, a little more modern language.

00:18:53.140 --> 00:18:53.480
Yeah.

00:18:53.480 --> 00:18:53.700
Yeah.

00:18:53.820 --> 00:18:54.180
Yeah.

00:18:54.180 --> 00:18:54.720
A bit more modern.

00:18:54.720 --> 00:18:56.740
And so I think that's kind of what's happened here.

00:18:56.740 --> 00:18:57.000
Yeah.

00:18:57.000 --> 00:18:57.440
That makes sense.

00:18:57.440 --> 00:18:58.060
All right.

00:18:58.060 --> 00:18:59.360
Let's talk about the sugar.

00:18:59.360 --> 00:18:59.760
Okay.

00:18:59.760 --> 00:19:02.740
So I think we covered pretty much what syntactic sugar is.

00:19:02.740 --> 00:19:07.700
And you started this whole thing out saying the goal of this is really to kind of nail

00:19:07.700 --> 00:19:09.380
down that minimum Python.

00:19:09.380 --> 00:19:11.400
And I agree that the REPL is optional.

00:19:11.600 --> 00:19:16.360
I like the REPL, but just, just so I can also get mail about it.

00:19:16.360 --> 00:19:17.840
I like the language.

00:19:17.840 --> 00:19:21.060
Like you can't take away these features once you add them.

00:19:21.060 --> 00:19:21.280
Right.

00:19:21.280 --> 00:19:25.360
And so it's like, what could you survive with as a minimum?

00:19:25.360 --> 00:19:28.320
And then you can kind of like, what are the, what's the extras?

00:19:28.320 --> 00:19:29.640
What could you build up from there?

00:19:29.640 --> 00:19:30.420
Yes, exactly.

00:19:30.420 --> 00:19:34.340
And the final destination maybe being, you know, CPython proper.

00:19:34.340 --> 00:19:34.820
Yeah.

00:19:35.160 --> 00:19:41.660
So you've got a whole bunch of different aspects of Python that you are unraveling in

00:19:41.660 --> 00:19:42.900
this syntactic sugar.

00:19:42.900 --> 00:19:47.740
And basically to highlight what's actually happening, how much of this is going on as you've already

00:19:47.740 --> 00:19:48.420
laid out.

00:19:48.420 --> 00:19:53.900
So I want to point out that I'll link to how many articles you've got here, but two years.

00:19:53.900 --> 00:19:55.000
20, I think.

00:19:55.000 --> 00:19:55.500
Yeah.

00:19:55.500 --> 00:19:57.780
Like looking like close to 30, maybe.

00:19:57.780 --> 00:19:58.120
I don't know.

00:19:58.120 --> 00:19:59.040
Just eyeball it.

00:19:59.040 --> 00:19:59.820
There's a lot there.

00:19:59.820 --> 00:20:05.080
So I think I picked a, you know, half of those out or some, some reasonable subset.

00:20:05.080 --> 00:20:06.140
That we can talk about.

00:20:06.140 --> 00:20:08.100
And there's some code and stuff in here.

00:20:08.100 --> 00:20:12.600
So we'll kind of have like, my thought was we could just talk about kind of like, what is

00:20:12.600 --> 00:20:13.500
the essence of this?

00:20:13.500 --> 00:20:16.180
Like what's really happening when you do attribute access?

00:20:16.180 --> 00:20:21.420
What's really happening when you write the word pass or use a width block as we've talked

00:20:21.420 --> 00:20:22.260
about a little bit.

00:20:22.260 --> 00:20:26.520
So the first one here is unraveling attribute access in Python.

00:20:26.520 --> 00:20:31.480
You want to tell us a bit about what actually happens if you just say, you know, like object

00:20:31.480 --> 00:20:32.400
dot attribute.

00:20:32.400 --> 00:20:33.940
It seems so simple, Brett.

00:20:33.940 --> 00:20:35.320
There's just one dot.

00:20:35.320 --> 00:20:36.320
That's the big deal.

00:20:36.320 --> 00:20:36.660
Yeah.

00:20:36.660 --> 00:20:38.700
Why doesn't this just, what's there to talk about?

00:20:38.700 --> 00:20:44.860
I mean, when I just do something dot something magically, I get back what I expected, but there's

00:20:44.860 --> 00:20:46.140
actually a lot going on there.

00:20:46.140 --> 00:20:46.540
Right.

00:20:46.540 --> 00:20:51.460
And it, it comes down to multiple layers, but it's all ties around Python's object model.

00:20:51.460 --> 00:20:51.700
Right.

00:20:51.700 --> 00:20:57.140
How do all, because I always find this weird to say, but Python's more object oriented in

00:20:57.140 --> 00:20:58.020
my opinion than Java.

00:20:58.020 --> 00:21:03.680
Java has these primitive types like instant quotes that have to get boxed and unboxed to

00:21:03.680 --> 00:21:06.820
fake, to make them look like an object to Java itself.

00:21:06.820 --> 00:21:07.900
Python doesn't have that.

00:21:07.900 --> 00:21:08.860
Everything is an object.

00:21:08.860 --> 00:21:09.980
A function is an object.

00:21:09.980 --> 00:21:11.040
An integer is an object.

00:21:11.040 --> 00:21:12.100
True is an object.

00:21:12.100 --> 00:21:13.340
Seven is an object.

00:21:13.340 --> 00:21:14.020
Exactly.

00:21:14.020 --> 00:21:16.080
There's nothing you can name in Python.

00:21:16.080 --> 00:21:17.420
That's not somehow an object.

00:21:17.420 --> 00:21:17.780
Yep.

00:21:17.780 --> 00:21:22.020
This idea of attributes and all this permeates all the way down into the object model, which

00:21:22.020 --> 00:21:24.780
once again, defines kind of everything in a way.

00:21:24.780 --> 00:21:27.580
So the key thing here is there's kind of two parts to it.

00:21:27.580 --> 00:21:34.100
It's how do you look up based on inheritance, what thing is going to service the call asking

00:21:34.100 --> 00:21:36.240
what is this attribute value?

00:21:36.240 --> 00:21:39.640
Basically, what object is bound to this name for the attribute?

00:21:39.640 --> 00:21:43.600
And after that is what methods are going to get called to make that happen?

00:21:43.800 --> 00:21:48.540
Because effectively, almost everything in Python at the end of the day leads to a method call

00:21:48.540 --> 00:21:49.440
or a function call.

00:21:49.440 --> 00:21:49.700
Yeah.

00:21:49.700 --> 00:21:54.840
First of all, it leads to a lot of times to an op code, which leads to a method call, right?

00:21:54.840 --> 00:21:57.040
A Python bytecode thing.

00:21:57.040 --> 00:22:01.760
And I think it's maybe also worth pointing out, like have you point out to everyone listening

00:22:01.760 --> 00:22:08.180
is Python compiles to this intermediate language like Java and .NET compiled to intermediate languages.

00:22:08.180 --> 00:22:11.180
It's just what happens then, right?

00:22:11.220 --> 00:22:13.980
Like in those other ones, they JIT compiled to machine instructions.

00:22:13.980 --> 00:22:19.040
Here it goes through like the big C eval loop and delegates to some internal C operations.

00:22:19.040 --> 00:22:23.420
And a lot of those, these unravelings, like kind of look at what happens at that step, right?

00:22:23.420 --> 00:22:23.980
Yeah.

00:22:23.980 --> 00:22:27.540
So CPython itself is an interpreter, right?

00:22:27.540 --> 00:22:33.300
So what happens is when you load up your Python code is Python parses it, what's called an abstract

00:22:33.300 --> 00:22:34.680
syntax tree or AST.

00:22:34.960 --> 00:22:41.220
It then takes that AST, does some stuff with it, and then it compiles it down to Python bytecode.

00:22:41.220 --> 00:22:46.140
I actually gave a talk on this at PyCon Canada way back when, for those who are interested,

00:22:46.140 --> 00:22:51.480
that basically goes from the steps of literally source code all the way to execution, if you

00:22:51.480 --> 00:22:52.000
want more detail.

00:22:52.000 --> 00:22:57.840
But effectively, yeah, we compile it down to bytecode of our own design to then execute

00:22:57.840 --> 00:23:01.680
in more or less what's a big for loop in C.

00:23:01.680 --> 00:23:03.040
That is a really big for loop.

00:23:03.040 --> 00:23:03.880
Very big for loop.

00:23:03.880 --> 00:23:08.000
And it's gotten a bit fancier thanks to the faster CPython team, right?

00:23:08.000 --> 00:23:12.300
Like there's now kind of like lower level opcodes that are very type specific.

00:23:12.300 --> 00:23:18.060
And we actually auto-generate the loop now thanks to them so that it's easier to maintain and

00:23:18.060 --> 00:23:18.720
make tweaks to.

00:23:18.720 --> 00:23:23.520
But essentially, it's literally just a set of instructions that are extreme, that kind of

00:23:23.520 --> 00:23:27.120
encompass key bits of semantics in Python.

00:23:27.120 --> 00:23:34.500
So for instance, for attribute access, there's literally a opcode called load adder, where on

00:23:34.500 --> 00:23:38.580
the execution stack, you basically push the object you care about, the name of the thing you

00:23:38.580 --> 00:23:42.740
want, and then you just call load adder on it, and it'll just look it up.

00:23:42.740 --> 00:23:44.780
Actually, technically, I guess it doesn't push the name on it.

00:23:44.780 --> 00:23:47.040
That's technically stored in the function.

00:23:47.040 --> 00:23:51.680
There's little details I'm kind of hand-waving over, literally hand-waving if you're watching

00:23:51.680 --> 00:23:52.160
the live stream.

00:23:52.160 --> 00:23:57.060
But effectively, you push the object you want, you call load adder, give it an argument of

00:23:57.060 --> 00:24:01.240
what it should, what attribute it wants, and then load adder opcode behind the scenes is

00:24:01.240 --> 00:24:04.120
the thing that does all the magic of calling everything you'd expect, et cetera, et cetera.

00:24:04.120 --> 00:24:04.980
Yeah, excellent.

00:24:05.360 --> 00:24:10.220
And to view that, a lot of times what you'll do is you'll just use the dis module.

00:24:10.220 --> 00:24:15.640
So if people haven't used dis, you can just dis.dis, a lot of disrespect on this function,

00:24:15.640 --> 00:24:19.160
and then it tells you what the opcodes it's made of are, yeah?

00:24:19.160 --> 00:24:19.740
Yeah, exactly.

00:24:19.740 --> 00:24:21.560
I mean, dis is short for disassemble.

00:24:21.560 --> 00:24:26.740
So literally, you can pass it a function, and it will effectively disassemble what the

00:24:26.740 --> 00:24:32.300
function does into the bytecode, which is just stored as an attribute of bytes on the

00:24:32.300 --> 00:24:37.700
function object and print it out nicely because the disk module knows how to map the bytes

00:24:37.700 --> 00:24:42.260
to what the opcode's name is and just gives it a nice way to look and actually read and

00:24:42.260 --> 00:24:42.840
understand it.

00:24:43.080 --> 00:24:43.440
Okay.

00:24:43.440 --> 00:24:47.800
In this example, you said, all right, look, here is the case statement in that tremendous

00:24:47.800 --> 00:24:51.340
for loop switch thing that does the execution.

00:24:51.340 --> 00:24:53.500
What do we do if we see load adder?

00:24:53.500 --> 00:24:58.280
And ultimately, it comes down to this pyobject underscore get adder.

00:24:58.720 --> 00:25:00.180
So it seems so simple.

00:25:00.180 --> 00:25:02.840
It's just object dot attribute, object dot field, whatever.

00:25:02.840 --> 00:25:07.220
But it turns out there's just so many variations and so much going on down here.

00:25:07.220 --> 00:25:11.440
And I don't necessarily want you to go through all the details because it's pretty, some of

00:25:11.440 --> 00:25:15.140
it's pretty intense C and like a lot of it, you know, optimizations and stuff.

00:25:15.140 --> 00:25:21.560
But just give people a sense of what actually happens down in the guts when you try to do it.

00:25:21.860 --> 00:25:27.580
Well, so in the case of attribute access, right, that effectively ends up calling the

00:25:27.580 --> 00:25:29.900
get adder built-in function, right?

00:25:29.900 --> 00:25:34.740
And in that case, it needs to check how many arguments it gets to start, right?

00:25:34.740 --> 00:25:38.660
Did you give it two arguments or did you give it three arguments so you return a default value

00:25:38.660 --> 00:25:40.700
if the attribute doesn't exist?

00:25:40.700 --> 00:25:44.420
And then at the C level, we have to check whether or not what you gave it, right?

00:25:44.420 --> 00:25:50.180
Because there's like a Python level, the C code all types to what's called the to py object,

00:25:50.180 --> 00:25:55.660
which is basically a massive struct in the C that represents any and all Python objects.

00:25:55.660 --> 00:26:02.800
So even at the C level, we don't know if you gave us a string or an integer or what did you

00:26:02.800 --> 00:26:05.780
give us for the name of the attribute that you want.

00:26:05.780 --> 00:26:07.640
So we got to do that, right?

00:26:07.640 --> 00:26:12.700
And so there's just basic, like just safety checks to go like, nope.

00:26:12.700 --> 00:26:17.660
Like when you, if you call get adder with wanting the attribute 42, which is a number,

00:26:17.660 --> 00:26:19.060
it's going to throw a type error.

00:26:19.060 --> 00:26:22.660
Well, that code's got to exist somewhere and this is where it exists.

00:26:22.660 --> 00:26:23.400
Yeah.

00:26:23.400 --> 00:26:23.800
Yeah.

00:26:23.800 --> 00:26:24.020
Right.

00:26:24.020 --> 00:26:28.900
And then effectively just bubbles all down to the C API where a lot of this stuff gets exposed

00:26:28.900 --> 00:26:29.560
in its own way.

00:26:29.560 --> 00:26:33.260
And specifically in this case, it ends up calling py object get adder.

00:26:33.260 --> 00:26:33.500
Yeah.

00:26:33.500 --> 00:26:38.420
And I think another thing that's pretty interesting here is it's not always just a value, right?

00:26:38.420 --> 00:26:41.260
That object dot adder, that adder could be a property.

00:26:41.720 --> 00:26:45.980
That adder could be a descriptor, which I guess is a generalization of a property.

00:26:45.980 --> 00:26:49.180
It could be on the class type, but not on the instance type.

00:26:49.180 --> 00:26:50.120
So you got to find that.

00:26:50.120 --> 00:26:52.960
It could be on the instant type overriding, but only there, right?

00:26:52.960 --> 00:26:54.340
Like it could not exist.

00:26:54.340 --> 00:26:57.280
All of these scenarios that you got to go through.

00:26:57.280 --> 00:27:02.860
And so it really, you know, it really emphasizes how much is actually going on in the runtime while

00:27:02.860 --> 00:27:05.980
this single simple line seems to be running, right?

00:27:05.980 --> 00:27:06.400
Yeah.

00:27:06.400 --> 00:27:10.280
I mean, in the simple case, hitting the dots, not complicated.

00:27:10.280 --> 00:27:15.400
Like in general, what you end up doing is you have your object, you hit dot.

00:27:15.400 --> 00:27:19.380
And what it does is it looks in the dunder decked attribute of the object.

00:27:19.380 --> 00:27:21.420
And there's a key matching the attribute name.

00:27:21.420 --> 00:27:23.800
And it just gets the thing in the dictionary and that's it.

00:27:23.800 --> 00:27:24.120
You're done.

00:27:24.320 --> 00:27:28.400
But as you alluded to, how the heck do you even get to that basic case?

00:27:28.400 --> 00:27:32.140
Or those more complicated cases, as you said, descriptors, right?

00:27:32.140 --> 00:27:34.640
Which are how we actually implement properties.

00:27:34.640 --> 00:27:38.600
Or if it's on the class versus the instance.

00:27:38.600 --> 00:27:43.560
And what happens if there's inheritance or multiple inheritance?

00:27:43.560 --> 00:27:44.100
Yeah.

00:27:44.100 --> 00:27:45.820
Or dunder get adder was defined, right?

00:27:45.820 --> 00:27:51.080
Like basically almost all of this ends up flowing through the get adder built in, which effectively

00:27:51.080 --> 00:27:55.180
ends up calling the appropriate dunder get attribute method off of an object.

00:27:55.180 --> 00:27:58.700
And this is one of those bare level kind of things, right?

00:27:58.700 --> 00:28:01.460
Where you have to implement this to make Python work.

00:28:01.460 --> 00:28:03.860
You have to basically implement the get adder built in.

00:28:03.860 --> 00:28:09.460
And it has to understand how objects are structured underneath the hood to know how basically methods

00:28:09.460 --> 00:28:10.860
and stuff are attached to an object.

00:28:10.860 --> 00:28:12.300
You really can't fake that.

00:28:12.300 --> 00:28:17.780
There's no way to not kind of have that as a low level detail that you can just unravel.

00:28:17.780 --> 00:28:19.380
It has to be implemented by the interpreter.

00:28:19.380 --> 00:28:24.640
And in this case, effectively, the way Python does things is it knows the order.

00:28:24.640 --> 00:28:29.180
You can always actually call the MRO method on any object in order to use the method resolution

00:28:29.180 --> 00:28:29.660
order.

00:28:29.660 --> 00:28:35.660
And effectively what Python is doing is if it checks on something to see if it has it or not,

00:28:35.660 --> 00:28:40.640
it will effectively end up calling the dunder get attribute object of method, sorry, on

00:28:40.640 --> 00:28:41.140
object.

00:28:41.480 --> 00:28:42.900
That's usually where it bottoms out.

00:28:42.900 --> 00:28:47.220
And unless you happen to have a dunder get adder, if that fails, but that's only in the

00:28:47.220 --> 00:28:47.880
failure case.

00:28:47.880 --> 00:28:52.640
But really, in the end, almost everything passes through object dot dunder get attribute.

00:28:52.640 --> 00:28:54.460
And that's really where all this ends up going.

00:28:54.460 --> 00:28:56.600
But as you said, there's a lot of little twists and turns.

00:28:56.600 --> 00:29:01.760
Yeah, a lot of these internals, you'll see the method resolution order calls.

00:29:01.760 --> 00:29:05.260
And it's all about, well, there's a lot of classes and a lot of objects.

00:29:05.260 --> 00:29:08.280
They can override things and they can override operators.

00:29:08.600 --> 00:29:11.640
And so there's a lot of navigation to just figure it out.

00:29:11.640 --> 00:29:17.940
Not just calling these get adder type of things, but what level does that even supposed to happen

00:29:17.940 --> 00:29:20.080
on, given what I'm working with, right?

00:29:20.240 --> 00:29:21.000
Yeah, exactly.

00:29:21.000 --> 00:29:23.580
And I think this is a good example.

00:29:23.580 --> 00:29:26.820
And the reason I started with this is so fundamental, right?

00:29:26.820 --> 00:29:31.220
Like, how do you unravel something if you don't know how to even get an attribute off of something?

00:29:31.220 --> 00:29:33.540
So this is why this was the very first post in this series.

00:29:33.740 --> 00:29:37.800
Partly why I went into such detail on how to figure all this out, right?

00:29:37.800 --> 00:29:41.840
Like, kind of one, this is almost a template for anyone else who wanted to go exploring on their own.

00:29:41.840 --> 00:29:53.340
But I think it's also a good example of how much complexity and flexibility Python hides from users in order to make the simple work, but give you the flexibility to make the complicated possible.

00:29:53.340 --> 00:29:53.840
Right.

00:29:53.840 --> 00:29:54.040
Yeah.

00:29:54.040 --> 00:30:00.260
Like for the vast majority of any of us for our code, it's not just does what you would think it would do.

00:30:00.260 --> 00:30:01.080
And it's pretty straightforward.

00:30:01.080 --> 00:30:04.920
But as soon as you get into the fancy world of descriptors.

00:30:04.920 --> 00:30:06.220
SQLAlchemy.

00:30:06.220 --> 00:30:07.280
Yeah.

00:30:07.280 --> 00:30:10.640
I can both have a value or I can do a database query with the same thing.

00:30:10.640 --> 00:30:11.420
How is that possible?

00:30:11.420 --> 00:30:11.720
Right.

00:30:11.920 --> 00:30:12.140
Yeah.

00:30:12.140 --> 00:30:13.220
You want that magic?

00:30:13.220 --> 00:30:14.680
Language has to support it somehow.

00:30:14.680 --> 00:30:22.700
And it requires a lot of finesse and thinking through and a lot of mechanisms that generally get hidden from you.

00:30:22.700 --> 00:30:24.680
But someone's got to write that code somewhere.

00:30:24.680 --> 00:30:26.720
And in this case, it's a Python.

00:30:26.720 --> 00:30:30.180
And this kind of outlines how that all happens.

00:30:30.180 --> 00:30:32.340
And it's surprisingly complicated.

00:30:32.340 --> 00:30:33.740
It's not horrible.

00:30:33.740 --> 00:30:35.500
That was my main takeaway, too.

00:30:35.500 --> 00:30:36.020
Yeah.

00:30:36.020 --> 00:30:37.580
I mean, you can totally read it and follow it.

00:30:37.580 --> 00:30:40.260
I don't want to scare anyone saying it's so complex you can't follow it.

00:30:40.280 --> 00:30:45.100
It's just it's not just a simple two if statements and you're done.

00:30:45.100 --> 00:30:46.000
It's no.

00:30:46.000 --> 00:30:51.300
There's subtlety to it to make sure the common semantics make sense to people.

00:30:51.300 --> 00:30:54.260
It's not going to trip people up because it's doing something weird.

00:30:54.260 --> 00:30:59.120
There's a lot of thought that goes into these semantics to make sure it makes sense for the common case.

00:30:59.120 --> 00:31:03.940
This portion of Talk Python to Me is brought to you by us.

00:31:03.940 --> 00:31:08.200
Have you heard that Python is not good for concurrent programming problems?

00:31:08.660 --> 00:31:13.780
Whoever told you that is living in the past because it's prime time for Python's asynchronous features.

00:31:13.780 --> 00:31:18.360
With the widespread adoption of async methods and the async and await keywords,

00:31:18.360 --> 00:31:23.460
Python's ecosystem has a ton of new and exciting frameworks based on async and await.

00:31:23.460 --> 00:31:28.580
That's why we created a course for anyone who wants to learn all of Python's async capabilities,

00:31:28.580 --> 00:31:31.020
async techniques and examples in Python.

00:31:31.500 --> 00:31:36.920
Just visit talkpython.fm/async and watch the intro video to see if this course is for you.

00:31:36.920 --> 00:31:39.380
It's only $49 and you own it forever.

00:31:39.380 --> 00:31:40.420
No subscriptions.

00:31:40.420 --> 00:31:43.180
And there are discounts for teams as well.

00:31:45.340 --> 00:31:49.780
Another takeaway I got from looking at this is, wow, it's nice that dictionaries are fast.

00:31:49.780 --> 00:31:54.520
And how fast are they to make this impossible to lean on them so much to make this happen?

00:31:54.520 --> 00:31:54.920
Yeah.

00:31:54.920 --> 00:32:01.160
I mean, I will say when Guido chose to use dictionaries as the namespace, it was kind of a unique decision at the time.

00:32:01.160 --> 00:32:02.820
It might still be, honestly.

00:32:03.220 --> 00:32:14.800
But it did simplify some things conceptually and also made it so that any wins in how dictionaries work is just a massive win universally across language.

00:32:14.800 --> 00:32:15.180
Right.

00:32:15.180 --> 00:32:24.200
Like if you make dictionaries work in any way better, you not only make it work when you just you personally use it as a data structure, as a container,

00:32:24.200 --> 00:32:27.820
but also literally every attribute access will get faster.

00:32:27.820 --> 00:32:28.300
Right.

00:32:28.300 --> 00:32:40.660
Like, yeah, there's a reason why it's so fine tuned and why we don't really touch it very much because it's been tweaked over the decades by a lot of people to be extremely fast and for good reason.

00:32:40.660 --> 00:32:40.960
Yep.

00:32:40.960 --> 00:32:41.480
Indeed.

00:32:41.480 --> 00:32:42.780
One final thought on this.

00:32:42.780 --> 00:32:51.120
You know, you think of optimizing both the memory and also the performance a little bit by doing things like slots on your classes to maybe like short circuit some of this.

00:32:51.280 --> 00:33:00.900
It feels like somewhere in this world lives like some kind of massive optimization that maybe that if you said I'm going to for this class, I'm going to give up some flexibility.

00:33:00.900 --> 00:33:04.640
Is there some way attribute reads and writes could get lots faster?

00:33:04.640 --> 00:33:05.380
I don't know.

00:33:05.380 --> 00:33:05.720
What are you?

00:33:05.720 --> 00:33:09.140
I'm sure this has gone round and round because it's such a hot.

00:33:09.140 --> 00:33:12.980
It's just involved in almost every line of Python code, stuff like this.

00:33:12.980 --> 00:33:13.180
Right.

00:33:13.180 --> 00:33:13.740
Oh, yeah.

00:33:13.740 --> 00:33:13.780
Yeah.

00:33:13.780 --> 00:33:18.280
I mean, this plays into what the faster CPython team has been doing, right?

00:33:18.280 --> 00:33:24.480
Trying to make things faster by looking at what the patterns are and if you can just kind of skip stuff.

00:33:24.480 --> 00:33:25.020
Right.

00:33:25.020 --> 00:33:26.780
Like, how do you short circuit this thing?

00:33:26.780 --> 00:33:29.920
Can you go like, well, I just know this object's always looked this way.

00:33:29.920 --> 00:33:38.140
Like, this is some of the stuff that the self programming language team at UC Santa Barbara did, I think, in the 70s, maybe 80s.

00:33:38.140 --> 00:33:41.880
I'm just like, well, if we know the layout of the object is going to be consistent.

00:33:42.320 --> 00:33:44.720
Yeah. Can we go seven bytes in and get four bytes?

00:33:44.720 --> 00:33:45.900
That kind of thing, right?

00:33:45.900 --> 00:33:46.420
Exactly.

00:33:46.420 --> 00:33:51.040
And you just kind of have to, and you start to be able to calculate the shortcuts.

00:33:51.040 --> 00:33:54.760
You know, like, hey, did anything change from the last time I made this assumption?

00:33:54.760 --> 00:33:55.440
No? Okay.

00:33:55.440 --> 00:33:56.620
Well, then I can use my assumption.

00:33:56.620 --> 00:33:57.420
That's way fast.

00:33:57.420 --> 00:33:57.880
Right.

00:33:57.880 --> 00:33:59.100
Nobody's mocked it.

00:33:59.100 --> 00:34:01.020
Nobody's dynamically messed with it.

00:34:01.020 --> 00:34:03.520
Like, maybe it is just a plain thing.

00:34:03.520 --> 00:34:07.480
Until somebody puts it into an edge case, is there a short circuit, right?

00:34:07.480 --> 00:34:07.900
Yeah.

00:34:08.220 --> 00:34:12.620
And, I mean, I don't want to go off on a tangent, but...

00:34:12.620 --> 00:34:14.560
Well, I'm one of 17 topics here, Brett.

00:34:14.560 --> 00:34:15.940
Like, I know probably we got lots of time.

00:34:15.940 --> 00:34:20.460
I have thought about, like, after doing this, what...

00:34:20.460 --> 00:34:22.620
Is there something syntactic here to add, right?

00:34:22.680 --> 00:34:31.240
Is there a way to kind of come up with effectively a class definition that's way simpler for the really common cases?

00:34:31.240 --> 00:34:31.800
Yeah.

00:34:31.800 --> 00:34:41.080
That could be optimized extremely fast because you give away some flexibility and then the interpreter can make assumptions.

00:34:41.080 --> 00:34:44.440
PyPy could make assumptions, et cetera, et cetera.

00:34:44.440 --> 00:34:48.220
And would there be enough wins on that to warrant doing it, right?

00:34:48.220 --> 00:34:55.180
Like, could we take the concept of kind of a data class that was just data, roughly, or something along those lines?

00:34:55.180 --> 00:34:55.660
Yeah.

00:34:55.660 --> 00:34:57.320
And just what could we get out of it?

00:34:57.320 --> 00:34:59.760
And what kind of perf wins could we get out of it?

00:34:59.760 --> 00:35:00.600
And would it be worth it?

00:35:00.600 --> 00:35:04.140
Would it be worth adding syntax to the language for that case?

00:35:04.140 --> 00:35:07.100
If you look at Mojo, for instance, they have a struct.

00:35:07.100 --> 00:35:15.660
And that struct works in a very specific way for performance because when you say, like, this thing can't have new attributes, which you can do with slots.

00:35:15.660 --> 00:35:23.240
And for those of you who don't know what slots are, if you define a dunder slots attribute on your class, you're effectively telling Python, don't create a dictionary for me.

00:35:23.240 --> 00:35:25.940
Just create effectively a list underneath.

00:35:25.940 --> 00:35:27.140
It's technically a C array.

00:35:27.140 --> 00:35:31.400
And when I need to access something, just get it off this array.

00:35:31.400 --> 00:35:32.460
So there's no dictionary.

00:35:32.620 --> 00:35:34.440
You can skip all that dictionary overhead.

00:35:34.440 --> 00:35:44.980
Plus, you shrink the memory because now the only amount of memory you need is that array for pointers to the PyObjects and not a dictionary, which grows and shrinks and who knows what size it's going to be.

00:35:44.980 --> 00:35:49.040
If we had that built in syntactically, would that be beneficial to people or not?

00:35:49.040 --> 00:35:53.360
And I have a prototype in Python code of what I'm thinking of.

00:35:53.360 --> 00:36:02.220
I did a blog post on this earlier this year to try to feel out people in the community and what they thought in terms of restrictions and would it be too much or too little?

00:36:02.220 --> 00:36:04.320
I subsequently prototyped what I wanted.

00:36:04.320 --> 00:36:08.620
And there'll be a follow-up blog post about this is where it sits now.

00:36:08.620 --> 00:36:09.400
What do people think?

00:36:09.400 --> 00:36:12.280
And do people think this is worth trying to get syntax for?

00:36:12.280 --> 00:36:13.740
Just don't worry about it.

00:36:13.740 --> 00:36:16.160
It's too close to data classes or what?

00:36:16.420 --> 00:36:21.640
Maybe it could be a keyword to the data class decorator that just makes it behave differently.

00:36:21.640 --> 00:36:22.280
Who knows?

00:36:22.280 --> 00:36:22.580
Yeah.

00:36:22.580 --> 00:36:26.300
But so unfortunately, the tricky bit with that is it's still flowing through Python code, right?

00:36:26.300 --> 00:36:28.600
Data classes is still just a module in the standard library.

00:36:28.840 --> 00:36:35.760
So you can't, it's really hard to optimize that stuff without syntax to specifically say, hey, this will be different.

00:36:35.760 --> 00:36:43.900
You get to treat it differently and we can literally lock it down by literally creating a different type of object at the C level that just literally doesn't give you access, right?

00:36:43.900 --> 00:36:45.440
Like tuples are a good example.

00:36:45.440 --> 00:36:49.940
Tuples at the C level very much just don't implement the stuff that you mutated.

00:36:50.320 --> 00:36:51.860
What happens if we want to do that for classes?

00:36:51.860 --> 00:36:53.940
Like how do you do frozen data classes?

00:36:53.940 --> 00:36:55.560
It's a ton of properties.

00:36:55.560 --> 00:36:59.460
But what happens if we had a way to just say, yep, nope, we're just literally not giving you access.

00:36:59.460 --> 00:37:01.340
Would that, how much faster could that be?

00:37:01.340 --> 00:37:02.620
I don't know.

00:37:02.620 --> 00:37:04.880
But I suspect it would be decently faster.

00:37:04.880 --> 00:37:05.180
Yeah.

00:37:05.180 --> 00:37:07.320
Computers are surprisingly fast.

00:37:07.320 --> 00:37:08.560
Dictionaries are surprisingly fast.

00:37:08.560 --> 00:37:13.220
But there's a lot of stuff here that could be skipped that I think might be.

00:37:13.220 --> 00:37:15.400
To me, I had the same thought at least.

00:37:15.400 --> 00:37:17.500
Probably not with the level of sophistication you did.

00:37:17.500 --> 00:37:23.820
But like, wow, there's some way to sort of do a more of a C style, just like we know the structure and the offsets.

00:37:23.820 --> 00:37:24.100
Yeah.

00:37:24.100 --> 00:37:28.880
Like for a restricted set, because that restricted set is mostly what people do actually do in Python.

00:37:28.880 --> 00:37:33.740
They don't go crazy dynamic with stuff coming and going like sometimes, but not usually.

00:37:33.740 --> 00:37:34.160
Yeah.

00:37:34.160 --> 00:37:36.340
I mean, you can go read my original blog posts.

00:37:36.340 --> 00:37:39.400
And if you follow me on Mastodon, you can see the follow up conversations.

00:37:39.560 --> 00:37:47.680
But like the original thing, if you've been a longtime Java user, you'll know the acronym POJO, plain old Java object.

00:37:47.680 --> 00:37:49.780
It was effectively the equivalent for Python.

00:37:49.780 --> 00:37:51.400
Some people love that idea.

00:37:51.400 --> 00:37:53.480
Some people were like, I really need methods.

00:37:53.480 --> 00:37:56.300
I can't not have methods kind of thing.

00:37:56.300 --> 00:38:01.060
It really depends on what people are after and what they think makes sense.

00:38:01.280 --> 00:38:03.080
But there will be a follow up blog post.

00:38:03.080 --> 00:38:08.840
So if you follow my blog, you'll eventually see what this hopefully all leads to, which may be nowhere beyond what I put up on PyPI.

00:38:08.840 --> 00:38:09.880
But who knows?

00:38:09.880 --> 00:38:11.840
Maybe it'll become Zindax someday.

00:38:11.840 --> 00:38:14.480
It really depends on how the community reacts to it.

00:38:14.480 --> 00:38:14.640
Cool.

00:38:14.640 --> 00:38:17.000
Well, I didn't know you're looking into that.

00:38:17.000 --> 00:38:17.680
So very interesting.

00:38:17.680 --> 00:38:18.640
Next one.

00:38:18.640 --> 00:38:23.160
Let's move on to something that also seems pretty straightforward is A minus B.

00:38:25.660 --> 00:38:26.500
Yeah, right.

00:38:26.500 --> 00:38:27.520
Yeah, exactly.

00:38:27.520 --> 00:38:28.360
You think it makes.

00:38:28.360 --> 00:38:28.740
Yeah.

00:38:28.740 --> 00:38:30.960
How hard can A minus B be, right?

00:38:30.960 --> 00:38:35.260
Like two objects just subtracting from one another, right?

00:38:35.260 --> 00:38:36.400
We all know how this works.

00:38:36.400 --> 00:38:39.200
There's I mean, there's an opcode just called binary subtract.

00:38:39.200 --> 00:38:42.360
Just like there's a binary add, a binary multiply, binary divide.

00:38:42.360 --> 00:38:44.160
You put the numbers on the register.

00:38:44.160 --> 00:38:47.980
You do the instruction set on the CPU and you're good to go.

00:38:47.980 --> 00:38:48.420
Yeah.

00:38:48.420 --> 00:38:50.020
Hey, I know what five minus three is.

00:38:50.020 --> 00:38:51.740
How much work can it be to make that work in Python?

00:38:51.740 --> 00:38:52.940
Oh, yeah.

00:38:52.940 --> 00:38:57.020
The numbers happen to be arbitrarily large and sometimes they're not numbers.

00:38:57.020 --> 00:38:59.100
Sometimes they're matrices or strings or.

00:38:59.100 --> 00:38:59.760
Oh, boy.

00:38:59.760 --> 00:39:00.020
Okay.

00:39:00.020 --> 00:39:00.560
Exactly.

00:39:00.560 --> 00:39:02.760
And subtraction is not communicative.

00:39:02.760 --> 00:39:04.240
So what matters here.

00:39:04.240 --> 00:39:07.040
So, yeah, it gets surprisingly complicated very quickly.

00:39:07.040 --> 00:39:07.380
Yeah.

00:39:07.380 --> 00:39:08.260
So, yeah.

00:39:08.260 --> 00:39:09.940
From from a conceptual level.

00:39:09.940 --> 00:39:10.900
Yeah, it seems simple.

00:39:10.900 --> 00:39:14.760
But when you figure out what that opcode actually does, it becomes way fancier.

00:39:14.760 --> 00:39:15.080
Yeah.

00:39:15.120 --> 00:39:20.780
And so as you dig into this, you start to realize like, OK, so this is actually controlled

00:39:20.780 --> 00:39:23.840
by the Dunder sub operator on the type.

00:39:23.840 --> 00:39:24.380
Right.

00:39:24.380 --> 00:39:25.740
And then how do you get that method?

00:39:25.740 --> 00:39:29.120
Well, this is the method resolution order on that type.

00:39:29.120 --> 00:39:30.700
So you got to start navigating that.

00:39:30.700 --> 00:39:32.640
And that gets pretty interesting.

00:39:32.640 --> 00:39:32.920
Right.

00:39:32.920 --> 00:39:33.380
Yeah.

00:39:33.380 --> 00:39:33.420
Yeah.

00:39:33.420 --> 00:39:35.020
Well, and let's be clear here.

00:39:35.020 --> 00:39:38.920
You're a bit foreshadowing because you said, oh, you called the Dunder sub.

00:39:38.920 --> 00:39:39.380
Yeah.

00:39:39.380 --> 00:39:40.300
To start.

00:39:40.300 --> 00:39:41.740
If that works.

00:39:41.740 --> 00:39:42.580
Right.

00:39:42.680 --> 00:39:46.980
Like for a lot of these things, there's lots of fallback to once again, give you that

00:39:46.980 --> 00:39:49.160
flexibility to make things work as necessary.

00:39:49.160 --> 00:39:55.100
So for a lot of things in Python, you can return the not implemented singleton, which you may

00:39:55.100 --> 00:39:57.700
have some people may have noticed and wonder what the hell is this thing for?

00:39:57.700 --> 00:40:03.580
And it's a singleton to signal to Python that, hey, there's not it's not an error happened.

00:40:03.580 --> 00:40:05.620
It's just I just don't know how to handle this.

00:40:05.620 --> 00:40:06.100
Right.

00:40:06.100 --> 00:40:12.260
So for instance, if let's say you have left hand side minus right hand side, the first

00:40:12.260 --> 00:40:17.140
step is you check to see if the left hand side has a Dunder sub method.

00:40:17.140 --> 00:40:23.180
If it does, you can call that with left hand side dot Dunder sub and pass in right hand side.

00:40:23.180 --> 00:40:28.120
Well, that method has the option to do something and return a value.

00:40:28.120 --> 00:40:30.800
And that's what left hand side minus right hand side becomes.

00:40:30.800 --> 00:40:35.300
Or it can return not implemented and say, just tell Python, nope, I don't know how to do this.

00:40:35.300 --> 00:40:36.620
Probably should ask someone else.

00:40:36.620 --> 00:40:36.860
Right.

00:40:36.860 --> 00:40:42.380
And then this adds an extra little wrinkle now, because suddenly when you do that, that

00:40:42.380 --> 00:40:43.500
says, OK, well, you know what?

00:40:43.500 --> 00:40:45.060
Let's give the right hand side a try.

00:40:45.060 --> 00:40:48.660
Maybe the right hand side knows how to do left hand side minus right hand side.

00:40:48.660 --> 00:40:51.740
It might not be the front thing, but it might just magically know.

00:40:51.740 --> 00:40:52.020
Right.

00:40:52.020 --> 00:40:57.680
So in this case, for instance, you could have something of your fancy object minus four,

00:40:57.680 --> 00:41:00.380
which would be your Dunder sub method.

00:41:00.380 --> 00:41:02.700
And so you know how to handle integers and it works.

00:41:02.700 --> 00:41:05.620
What happens if it's four minus your object?

00:41:05.620 --> 00:41:06.040
Yeah.

00:41:06.040 --> 00:41:07.260
Four doesn't know what to do.

00:41:07.260 --> 00:41:07.600
Yeah.

00:41:07.600 --> 00:41:09.060
Four's never seen your thing before.

00:41:09.060 --> 00:41:10.260
I don't know what the heck to do here.

00:41:10.260 --> 00:41:14.440
So in that case, four would return not implemented thing.

00:41:14.440 --> 00:41:15.660
I don't know what to do here.

00:41:15.660 --> 00:41:16.600
Good luck to you.

00:41:16.600 --> 00:41:17.700
Maybe you'll figure it out.

00:41:17.700 --> 00:41:22.220
And in this case, your object Dunder, our sub would get called with four.

00:41:22.220 --> 00:41:25.760
And then maybe you'll be able to say like, hey, I might not be on the left hand side,

00:41:25.760 --> 00:41:27.740
but I know how to handle myself on the right hand side.

00:41:27.840 --> 00:41:28.920
And I can make this work.

00:41:28.920 --> 00:41:33.020
So we try to make sure that even if some other objects don't know how to work with you,

00:41:33.020 --> 00:41:36.680
as if you're involved, there's at least the opportunity for you to make it work.

00:41:36.680 --> 00:41:36.940
Yeah.

00:41:36.940 --> 00:41:37.880
That's pretty interesting.

00:41:37.880 --> 00:41:38.480
Yes.

00:41:38.480 --> 00:41:43.760
An example could be like the number four, a constant minus a vector that's meant to be

00:41:43.760 --> 00:41:45.020
like a mathematical vector.

00:41:45.020 --> 00:41:47.480
And it's like, okay, we just subtract that from every dimension.

00:41:47.480 --> 00:41:47.920
Right.

00:41:47.920 --> 00:41:49.360
And that would be totally reasonable.

00:41:49.360 --> 00:41:51.060
But the four has no idea how to do that.

00:41:51.060 --> 00:41:51.380
Yes.

00:41:51.480 --> 00:41:52.920
And this is still the simple case.

00:41:52.920 --> 00:41:53.240
Yeah.

00:41:53.240 --> 00:42:02.040
So if I'll need a, I need a slight refresher on this one, but effectively there's scenarios

00:42:02.040 --> 00:42:07.700
here where you call the right hand side first.

00:42:07.700 --> 00:42:12.780
If it's the left hand side, one can say, I don't know what to do with this object, I think

00:42:12.780 --> 00:42:16.540
in return and not implemented from the subtract, something like that.

00:42:16.600 --> 00:42:16.800
Right.

00:42:16.800 --> 00:42:24.720
There's also a subtle optimization in these binary operators where if it is a direct subclass

00:42:24.720 --> 00:42:28.260
of the other object, you get first dibs.

00:42:28.260 --> 00:42:29.540
Oh, right, right, right.

00:42:29.540 --> 00:42:30.760
So that's the thing.

00:42:30.760 --> 00:42:30.940
Yeah.

00:42:30.940 --> 00:42:36.020
There's a lot of spam and bacon and vegetable spam and stuff that you did in here that people

00:42:36.020 --> 00:42:36.640
can check out.

00:42:36.640 --> 00:42:37.740
It gets surprisingly complicated.

00:42:37.740 --> 00:42:42.200
But the thing here, basically, this is, let's see, you have a left hand side and a right hand

00:42:42.200 --> 00:42:42.680
side, right?

00:42:42.680 --> 00:42:44.780
Once again, left hand side minus right hand side.

00:42:45.060 --> 00:42:46.640
Left hand side might be an integer.

00:42:46.640 --> 00:42:51.080
Your right hand side, though, might be a subclass of integer, like fancy integer.

00:42:51.080 --> 00:42:51.560
Okay.

00:42:51.560 --> 00:42:57.700
Now, if you do int minus fancy int, it will understand how to do it because you're a subclass.

00:42:57.700 --> 00:42:59.100
So it's just going to do it.

00:42:59.100 --> 00:43:01.860
And it'll just do the math and return you whatever it is.

00:43:01.860 --> 00:43:07.500
So like if you did five minus fancy three, five is going to return the integer two.

00:43:07.500 --> 00:43:09.960
But maybe that's not what you want with your fancy int.

00:43:09.960 --> 00:43:12.440
Maybe you would always, maybe you'd rather get fancy int two.

00:43:12.760 --> 00:43:16.120
So how does Python make sure that you get that opportunity if you happen to be on the right

00:43:16.120 --> 00:43:17.580
hand side instead of the left hand side?

00:43:17.580 --> 00:43:17.900
Yeah.

00:43:17.900 --> 00:43:20.700
Well, in that case, Python checks first.

00:43:20.700 --> 00:43:21.340
Okay.

00:43:21.340 --> 00:43:24.080
I have a left hand side and a right hand side for subtraction.

00:43:24.080 --> 00:43:28.120
Is the right hand side a direct subclass of the left hand side?

00:43:28.120 --> 00:43:29.660
If that's true, then you know what?

00:43:29.660 --> 00:43:34.600
I'm going to give the right hand side a chance first so that they can return their subclass

00:43:34.600 --> 00:43:39.140
and not have the left hand side kind of just blindly not realize that it's a different type

00:43:39.140 --> 00:43:40.320
and return something else.

00:43:40.320 --> 00:43:45.600
So that when it's, as I said, five minus fancy three, we actually give fancy three the first

00:43:45.600 --> 00:43:50.760
chance instead of five so that you have the chance to return fancy two like you wanted and

00:43:50.760 --> 00:43:52.800
not have five self-return.

00:43:52.800 --> 00:43:53.320
Boring two.

00:43:53.320 --> 00:43:53.700
Yeah.

00:43:53.700 --> 00:43:59.960
So I think one example that comes to mind that I think might be relevant would be working with

00:43:59.960 --> 00:44:00.720
units.

00:44:00.720 --> 00:44:06.640
So we've got cool libraries like pint and others where you can say this is not just the

00:44:06.640 --> 00:44:09.140
number five, but this is five kilograms.

00:44:09.140 --> 00:44:14.640
And if I subtract, you know, a hundred milligrams from it, it's not negative 95.

00:44:14.640 --> 00:44:18.120
It's, you know, four point, whatever, nine, five or whatever it turns out to be.

00:44:18.120 --> 00:44:23.540
And so in this case, if you took a regular number and one of these numbers with units, you

00:44:23.540 --> 00:44:25.720
could get a number with units back potentially.

00:44:25.720 --> 00:44:26.380
Yeah.

00:44:26.380 --> 00:44:27.860
No, that's a very good example, right?

00:44:27.860 --> 00:44:28.160
Yeah.

00:44:28.160 --> 00:44:33.060
This is where those, once again, very simple syntax that in the common case and in your

00:44:33.060 --> 00:44:38.400
general use day to day makes total sense and happens has some really important, but subtle,

00:44:38.400 --> 00:44:44.600
if you don't know about them semantics to make sure that those reasonable expectations are met,

00:44:44.600 --> 00:44:44.880
right?

00:44:44.880 --> 00:44:48.940
Like I totally didn't even think about this when I was doing, when I was writing this blog

00:44:48.940 --> 00:44:51.300
post that like, oh yeah, God, that's a good point.

00:44:51.300 --> 00:44:56.620
Like I do want to make sure that I get my special version of everything when I happen to be on the

00:44:56.620 --> 00:44:59.180
right-hand side, just because I happen to be written on the right-hand side.

00:44:59.180 --> 00:44:59.600
Yeah.

00:44:59.600 --> 00:45:01.040
Plus is a really good example.

00:45:01.040 --> 00:45:01.540
This one, right?

00:45:01.540 --> 00:45:05.100
Like you could have written a plus B or B plus a makes zero difference.

00:45:05.100 --> 00:45:07.340
I mean, that operator is supposed to be communicative.

00:45:07.340 --> 00:45:11.680
So it can be totally just dumb luck based on how I just happened to be thinking that day,

00:45:11.680 --> 00:45:13.840
what I put on the left side and what I put on the right side.

00:45:14.200 --> 00:45:15.680
And that would suddenly make a difference.

00:45:15.680 --> 00:45:21.200
And in this case, it just helps make sure that what you would think is the priority order of who you'd

00:45:21.200 --> 00:45:23.980
want to handle this for you gets that priority.

00:45:23.980 --> 00:45:27.920
But once again, it's a thing you just never think about day to day.

00:45:27.920 --> 00:45:32.600
But in actuality, when you think about the really key ways that Python operates, makes a surprising

00:45:32.600 --> 00:45:33.000
difference.

00:45:33.140 --> 00:45:33.260
Yeah.

00:45:33.260 --> 00:45:37.560
That seemingly leakiness of the language of like, well, sometimes it gives you an answer.

00:45:37.560 --> 00:45:38.240
Some it doesn't.

00:45:38.240 --> 00:45:39.080
Depends on how you add.

00:45:39.080 --> 00:45:40.240
People wouldn't love that.

00:45:40.240 --> 00:45:40.540
Yeah.

00:45:40.540 --> 00:45:47.100
And then the last bit of subtlety on that one is this only happens if, by the way, Dunder

00:45:47.100 --> 00:45:48.520
Sub and Dunder R Sub are different.

00:45:48.740 --> 00:45:53.160
So that's another check we do because at the C level, they're actually equivalent.

00:45:53.160 --> 00:45:56.420
Like there is no left side versus right side thing here.

00:45:56.420 --> 00:46:00.940
So we actually check to make sure we don't waste our time asking you, hey, can you do this

00:46:00.940 --> 00:46:05.220
and get back not implemented and then calling it the reverse and give me the exact same result

00:46:05.220 --> 00:46:07.360
because underneath it all is the exact same method.

00:46:07.360 --> 00:46:07.600
Right.

00:46:07.600 --> 00:46:11.700
So it's one of those fun things of, once again, lots of little things here to try to optimize,

00:46:11.700 --> 00:46:13.140
as you said, as best we can.

00:46:13.140 --> 00:46:15.340
And in this case, it's one of those.

00:46:15.340 --> 00:46:18.720
Well, if we know you're not going to work this way with the exact same method, we just swap

00:46:18.720 --> 00:46:19.540
the order of this stuff.

00:46:19.540 --> 00:46:20.600
Why are we going to ask you again?

00:46:20.600 --> 00:46:22.160
So we just skip that.

00:46:22.160 --> 00:46:26.640
So it's a minor thing, but semantics are there to try to help with the performance.

00:46:26.640 --> 00:46:31.300
I think people, as people go through your series here, I think they're going to get a deep

00:46:31.300 --> 00:46:33.520
appreciation for edge cases.

00:46:33.520 --> 00:46:33.860
Yeah.

00:46:33.860 --> 00:46:34.260
Subtlety.

00:46:34.260 --> 00:46:34.960
Yeah.

00:46:34.960 --> 00:46:35.480
Yeah.

00:46:35.480 --> 00:46:37.940
I learned a lot.

00:46:37.940 --> 00:46:41.760
I mean, it was one of the reasons I finished it is I finished this series as well, even though

00:46:41.760 --> 00:46:44.260
I part way through went like, yeah, you know what?

00:46:44.260 --> 00:46:48.600
I'm not going to implement Python from scratch, but I was learning.

00:46:48.700 --> 00:46:50.040
And it was fun.

00:46:50.040 --> 00:46:52.180
Like I got to dive a bit deep.

00:46:52.180 --> 00:46:56.980
I got to ask the Python core team is like from people, primarily Guido, who obviously

00:46:56.980 --> 00:46:59.800
were there when these decisions were like, why this way?

00:46:59.800 --> 00:47:02.000
Like, why do we choose this?

00:47:02.000 --> 00:47:06.960
And just trying to understand somewhat historically, how did these things happen?

00:47:06.960 --> 00:47:07.180
Right?

00:47:07.180 --> 00:47:11.500
Like I think a lot of people don't realize how old Python is, right?

00:47:11.500 --> 00:47:14.140
Like February of 1991 is when Python came out.

00:47:14.140 --> 00:47:16.140
It predates Linux going public.

00:47:16.140 --> 00:47:18.020
Like people really forget that fact.

00:47:18.020 --> 00:47:20.860
It's been around for over 32 years.

00:47:20.860 --> 00:47:21.200
Yeah.

00:47:21.200 --> 00:47:23.080
Decisions were made a long time ago.

00:47:23.080 --> 00:47:26.460
And I know everyone got all upset over the two to three transition.

00:47:26.460 --> 00:47:29.400
And some people still got upset whenever we push new changes or whatever.

00:47:29.400 --> 00:47:30.780
But do realize.

00:47:30.780 --> 00:47:31.040
Yeah.

00:47:31.040 --> 00:47:32.880
I can't believe you just canceled three, seven.

00:47:32.880 --> 00:47:33.900
I like that version.

00:47:35.560 --> 00:47:39.140
But the key thing here is the core concepts still work.

00:47:39.140 --> 00:47:41.740
Subtraction still works, right?

00:47:41.740 --> 00:47:43.300
From the way it worked back then.

00:47:43.300 --> 00:47:45.020
There's not been a massive upheaval here.

00:47:45.020 --> 00:47:48.460
It's just a lot of us end up using stuff that's kind of fancy.

00:47:48.460 --> 00:47:51.260
And sometimes the fancy stuff gets a little tweaked and stuff.

00:47:51.260 --> 00:47:54.240
But the really core low level stuff really hasn't shifted very much.

00:47:54.240 --> 00:47:57.340
So if at all, depending on your view.

00:47:57.340 --> 00:47:58.220
Give people a sense of the timing.

00:47:58.220 --> 00:48:02.060
Like the release of Python predates by a couple of years, the release of the web.

00:48:02.060 --> 00:48:02.560
Right?

00:48:02.560 --> 00:48:03.920
The web was 93, I think.

00:48:03.920 --> 00:48:05.400
And so, yeah.

00:48:05.400 --> 00:48:05.800
Yeah.

00:48:05.800 --> 00:48:09.960
One of the early browsers was actually Guido was writing in Python and TK.

00:48:09.960 --> 00:48:10.420
Incredible.

00:48:10.420 --> 00:48:10.880
Gradle.

00:48:10.880 --> 00:48:15.320
So we talked about simple things like thing dot value A minus B.

00:48:15.320 --> 00:48:18.360
The next simple one is the import statement because imports are simple.

00:48:18.360 --> 00:48:23.820
Honestly, I think imports are, if you come from a compiled language,

00:48:23.820 --> 00:48:26.520
they're really, you've really got to change your mindset.

00:48:26.520 --> 00:48:27.100
Right?

00:48:27.100 --> 00:48:30.620
And so I think this one actually is maybe the opposite end of that spectrum a little.

00:48:30.620 --> 00:48:31.200
Oh, yes.

00:48:31.200 --> 00:48:32.420
I will fully out my code.

00:48:32.420 --> 00:48:37.700
Some of my coworkers who are, because VS Code is written in TypeScript as an electron

00:48:37.700 --> 00:48:38.060
app.

00:48:38.540 --> 00:48:41.280
So they live in TypeScript all day long.

00:48:41.280 --> 00:48:45.580
The fact that Python's imports work the way they are in terms of flexibility and just the

00:48:45.580 --> 00:48:46.340
way it works.

00:48:46.340 --> 00:48:50.220
And you're not just specifying file paths to everything just really throws them for a loop

00:48:50.220 --> 00:48:51.940
and they go like, why is it so complicated?

00:48:52.500 --> 00:48:57.520
Once again, the flexibility that Python gives you where the base case, normal case of if you

00:48:57.520 --> 00:49:02.340
just do things the way just kind of just it's Python code and directory kind of thing just

00:49:02.340 --> 00:49:06.960
works versus I can also import something from a URL if I want.

00:49:06.960 --> 00:49:08.100
That's totally optional.

00:49:08.100 --> 00:49:12.380
You know, I could keep all my code in a SQLite database and import from there.

00:49:12.380 --> 00:49:13.480
Totally possible.

00:49:13.480 --> 00:49:14.080
Right?

00:49:14.220 --> 00:49:18.320
So it's one of these things, once again, where if you're coming from a Python mindset

00:49:18.320 --> 00:49:21.800
of just what makes sense, it all just works.

00:49:21.800 --> 00:49:25.560
I realize when you come in with an outside perspective, it can look kind of crazy.

00:49:25.560 --> 00:49:30.100
But you also have to understand that a lot of the designs were made A, decades ago.

00:49:30.100 --> 00:49:34.820
And B, there's a lot of flexibility there that you may or may not be taken advantage of.

00:49:34.820 --> 00:49:36.320
But there are others who are.

00:49:36.320 --> 00:49:38.220
And so that's kind of why it exists that way.

00:49:38.220 --> 00:49:38.820
Yeah, indeed.

00:49:38.820 --> 00:49:40.440
And yes, this posts.

00:49:40.440 --> 00:49:41.100
Yeah.

00:49:41.100 --> 00:49:47.080
So for those of you who don't know, I actually am responsible for Import Lib and re-implementing

00:49:47.080 --> 00:49:49.180
Python's import system in Python itself.

00:49:49.180 --> 00:49:51.500
And so I know these details a little too well.

00:49:51.500 --> 00:49:53.800
This one you live deep in this world.

00:49:53.800 --> 00:49:54.520
Yeah.

00:49:54.520 --> 00:49:55.320
So.

00:49:55.320 --> 00:49:56.900
You still have nightmares about some of them?

00:49:56.900 --> 00:49:57.700
No, luckily.

00:49:57.700 --> 00:49:58.360
I'm just kidding.

00:49:58.360 --> 00:50:05.720
Luckily, Import Lib, in terms of actual import itself, like this, I'm ignoring Import Lib.resources

00:50:05.720 --> 00:50:06.980
or Import Lib.metadata.

00:50:07.400 --> 00:50:09.560
Jason Coons mainly manages those modules.

00:50:09.560 --> 00:50:14.340
It's been stable enough for long enough now that there's no real crazy surprises anymore.

00:50:14.340 --> 00:50:18.760
Honestly, the biggest headache is people doing imports in their threads.

00:50:18.760 --> 00:50:21.880
So my word of advice to everyone, don't do imports in threads.

00:50:21.880 --> 00:50:24.960
If you're going to do imports, do them on your main thread up front.

00:50:24.960 --> 00:50:26.340
Then spawn your threads.

00:50:26.340 --> 00:50:29.660
Don't do imports as a side effect of anything either.

00:50:29.660 --> 00:50:31.140
It's circular imports.

00:50:31.140 --> 00:50:32.140
Same thing.

00:50:32.140 --> 00:50:34.120
It's just, just, just don't.

00:50:34.120 --> 00:50:35.500
Your life will be so much easier.

00:50:35.900 --> 00:50:40.200
But that's honestly where any of the bug reports that ever come in come from is due to either

00:50:40.200 --> 00:50:45.500
circular imports and people wondering why or weird race conditions with threads on imports

00:50:45.500 --> 00:50:49.580
and just trying to get the locking down such that things lead to the right outcome.

00:50:49.580 --> 00:50:50.020
Yeah.

00:50:50.120 --> 00:50:55.760
Actually 3.12 almost got held up a little bit due to a slight memory leak from the newest

00:50:55.760 --> 00:50:59.080
version of tracking imports via threads.

00:50:59.080 --> 00:51:00.540
There was a slight leak of it.

00:51:00.540 --> 00:51:00.720
Wow.

00:51:00.720 --> 00:51:04.180
Basically an empty dictionary every time you did an important thread and we didn't want to have

00:51:04.180 --> 00:51:04.520
that leak.

00:51:04.520 --> 00:51:05.500
So we cleaned it up.

00:51:05.500 --> 00:51:08.000
But yeah, it once had a lot of subtlety.

00:51:08.100 --> 00:51:09.320
Oh, we got lots of memory, bro.

00:51:09.320 --> 00:51:10.820
We don't need to worry about those things anymore.

00:51:10.820 --> 00:51:11.820
No, just kidding.

00:51:11.820 --> 00:51:12.060
Yeah.

00:51:12.060 --> 00:51:17.900
There's no reason everyone gets excited every time Apple launches a new M chip, right?

00:51:17.900 --> 00:51:22.580
We've had enough processing power since we got someone on the moon with how many hertz?

00:51:22.580 --> 00:51:23.500
Exactly.

00:51:23.500 --> 00:51:25.520
No one needs more than seven hertz.

00:51:25.520 --> 00:51:26.940
You know the favorite thing.

00:51:27.080 --> 00:51:32.320
You know, one of the real big differences I think here is that like import runs code,

00:51:32.320 --> 00:51:32.580
right?

00:51:32.580 --> 00:51:37.520
Like rather than tells the compiler these things are in scope if you want them.

00:51:37.520 --> 00:51:39.480
But no, it's like running code.

00:51:39.480 --> 00:51:46.260
And if people are wondering where that weird dunder name equals dunder main, so you don't

00:51:46.260 --> 00:51:49.780
run too much code during imports and those sorts of things, right?

00:51:49.780 --> 00:51:50.440
Yeah, actually.

00:51:50.440 --> 00:51:55.820
And this is an interesting case where it's very much syntactic sugar, but it's also very much

00:51:55.820 --> 00:51:58.020
syntactic sugar actually for the bytecode.

00:51:58.020 --> 00:51:58.360
Yeah.

00:51:58.360 --> 00:52:02.360
So the thing here is when you do import spam, right?

00:52:02.360 --> 00:52:07.060
Or whatever module you want to import, it effectively ends up being a call to the dunder

00:52:07.060 --> 00:52:11.360
import built-in function where it passes in spam as the name, and then it passes in all

00:52:11.360 --> 00:52:16.500
the globals and the locals for where it gets called for name resolution and stuff like this

00:52:16.500 --> 00:52:20.260
is where you do relative imports with dot, you know, like dot, dot something.

00:52:20.260 --> 00:52:21.120
Yeah, exactly.

00:52:21.120 --> 00:52:23.680
When I first saw it, like, why are all these arguments going to import?

00:52:23.780 --> 00:52:28.240
You just need to know where a, a dot pi or the package a lives and you're good to go

00:52:28.240 --> 00:52:32.940
until you say, you know, dot, dot this or from dots.

00:52:32.940 --> 00:52:33.280
Yeah.

00:52:33.280 --> 00:52:35.580
From dot, dot a import B kind of stuff.

00:52:35.580 --> 00:52:39.860
Like there's a surprising amount of information you need to pass in to do those kinds of resolutions

00:52:39.860 --> 00:52:42.400
and such from imports, right?

00:52:42.400 --> 00:52:44.820
All that kind of thing to make sure those things all exist.

00:52:44.820 --> 00:52:49.020
Because what you're effectively doing, you know, from import is if you list multiple ones, you're

00:52:49.020 --> 00:52:53.240
basically importing the module that those things are in and making sure that attribute gets set

00:52:53.240 --> 00:52:57.280
on the thing you're wanting so that you can then grab it later and all sorts of stuff.

00:52:57.700 --> 00:53:02.460
But the other key thing is, is the Dunder import function is structured to kind of make the

00:53:02.460 --> 00:53:03.880
up code easier, right?

00:53:03.880 --> 00:53:09.260
Because it's very structured to just push things onto the snack that Python's executing and then

00:53:09.260 --> 00:53:12.360
make the call to Dunder import where it's just like, yeah, everything's already there.

00:53:12.360 --> 00:53:12.560
Right.

00:53:12.560 --> 00:53:14.460
But it's also why it's so funky.

00:53:14.460 --> 00:53:17.200
You should never call it directly in your own code, right?

00:53:17.200 --> 00:53:18.560
Like Dunder imports very much.

00:53:18.560 --> 00:53:21.560
It's borderline implementation detail on this kind of thing.

00:53:21.560 --> 00:53:24.940
This is why you choose import lib dot import module, right?

00:53:24.940 --> 00:53:26.540
That function exists specifically.

00:53:26.540 --> 00:53:30.700
And I designed it specifically for those cases where you need to do dynamic imports.

00:53:30.700 --> 00:53:36.740
And you want a very clean, simple API because like the return type for Dunder import very much

00:53:36.740 --> 00:53:42.460
is designed for the op code so that whether you're doing an import something or from

00:53:42.460 --> 00:53:44.500
something import other thing, right?

00:53:44.500 --> 00:53:49.160
Like the return value makes sense or that for the bytecode level does not make sense for

00:53:49.160 --> 00:53:50.260
human beings, right?

00:53:50.260 --> 00:53:52.660
So once again, do not call Dunder import directly.

00:53:52.660 --> 00:53:57.800
You should always be calling import lib dot import module if you need something dynamically to

00:53:57.800 --> 00:53:58.020
import.

00:53:58.020 --> 00:53:59.320
Or just use the word import.

00:53:59.320 --> 00:53:59.700
Yeah.

00:53:59.700 --> 00:54:00.420
Or just import.

00:54:00.420 --> 00:54:01.300
Yeah.

00:54:01.300 --> 00:54:01.940
Just import.

00:54:01.940 --> 00:54:02.660
Yeah.

00:54:02.660 --> 00:54:05.600
In your right up here, you have all the different variations.

00:54:05.600 --> 00:54:11.000
Like what does it mean to say from thing import something as or just import something or

00:54:11.000 --> 00:54:12.180
relative imports?

00:54:12.360 --> 00:54:17.120
So people can see all the different, again, back to that flexibility that you talked about.

00:54:17.120 --> 00:54:17.640
Exactly.

00:54:17.640 --> 00:54:22.200
So it's definitely one of these things though where in the end, it effectively just boils

00:54:22.200 --> 00:54:23.560
down to a function call, right?

00:54:23.560 --> 00:54:29.320
Like that piece of syntax of import really is just a function call with an assignment in

00:54:29.320 --> 00:54:29.660
the end.

00:54:29.660 --> 00:54:29.860
Yeah.

00:54:29.860 --> 00:54:31.120
And it's really all it is.

00:54:31.120 --> 00:54:32.980
It's the unraveling.

00:54:32.980 --> 00:54:37.280
All the trickery is really behind the Dunder import function, but the actual syntax is

00:54:37.280 --> 00:54:38.740
not, it's not crazy actually.

00:54:38.740 --> 00:54:40.620
But it literally is a function call.

00:54:40.620 --> 00:54:40.820
Yeah.

00:54:40.820 --> 00:54:42.700
You can fully re-implement import.

00:54:42.700 --> 00:54:43.160
Yeah.

00:54:43.160 --> 00:54:45.360
But just calling Dunder import and just doing the proper assignment.

00:54:45.360 --> 00:54:45.660
Nice.

00:54:45.660 --> 00:54:48.040
Some confirmation of your advice out there.

00:54:48.040 --> 00:54:50.780
Nathan says, my data science professor always says the same thing.

00:54:50.780 --> 00:54:52.360
Import first, which is good.

00:54:52.700 --> 00:55:00.060
But also, is there a way to remove syntactical sugar on an example, but not fully through disassembly?

00:55:00.060 --> 00:55:04.580
You can actually write a tool that will take Python syntax and unravel it.

00:55:04.580 --> 00:55:08.540
I actually started it, but it was just too much of a headache because there's so many variations

00:55:08.540 --> 00:55:10.240
and edge cases and all that stuff to handle.

00:55:10.340 --> 00:55:14.680
And there was no package out there that was going to, that quite did what I needed it

00:55:14.680 --> 00:55:16.300
to do to make my life easier.

00:55:16.300 --> 00:55:17.780
And I had other things to do.

00:55:17.780 --> 00:55:17.940
Yeah.

00:55:17.940 --> 00:55:20.580
What's the canonical, what's the destination, right?

00:55:20.580 --> 00:55:25.800
Like if I undo a with statement on a lock, like how far do I want to go back?

00:55:25.800 --> 00:55:26.320
You know?

00:55:26.320 --> 00:55:26.740
Yeah.

00:55:26.740 --> 00:55:32.100
Well, and I can understand people wanting to do it to maybe learn, but I mean, it's going

00:55:32.100 --> 00:55:35.000
to be a learning thing, not really a performance thing.

00:55:35.000 --> 00:55:37.120
It might be slower, right?

00:55:37.120 --> 00:55:39.340
Because some of this stuff is happening at the sea level.

00:55:39.340 --> 00:55:40.280
Oh yeah, exactly.

00:55:40.280 --> 00:55:45.840
Like, like if you go back to our A plus B example, it actually definitely will be slower

00:55:45.840 --> 00:55:53.040
as things, as things happen in Python, because once again, with the speed performance improvements

00:55:53.040 --> 00:55:58.080
that have been going in, like, like the, the byte code is able to go like, all right, is

00:55:58.080 --> 00:55:59.100
this an intent and an end?

00:55:59.100 --> 00:55:59.660
Okay.

00:55:59.660 --> 00:56:02.120
Well then we're, we know exactly how to do integer math.

00:56:02.120 --> 00:56:02.760
Let's just do it.

00:56:02.760 --> 00:56:03.140
Right.

00:56:03.140 --> 00:56:06.600
And then it can add cards in and go like, okay, quick check AB.

00:56:06.600 --> 00:56:07.000
Yes.

00:56:07.000 --> 00:56:07.260
Okay.

00:56:07.400 --> 00:56:10.900
Do the binary int add thing.

00:56:10.900 --> 00:56:11.360
Right.

00:56:11.360 --> 00:56:14.460
Where it just very, very obviously does that.

00:56:14.460 --> 00:56:17.600
But if you unravel it, you can't do that because now you're just doing method calls.

00:56:17.600 --> 00:56:18.100
Right.

00:56:18.100 --> 00:56:20.500
You can't hide those details anymore and put all that.

00:56:20.500 --> 00:56:20.900
Exactly.

00:56:21.300 --> 00:56:24.400
But yeah, but to answer the question, you totally could write a tool to do this.

00:56:24.400 --> 00:56:27.900
And I kind of started one and it just wasn't fun.

00:56:27.900 --> 00:56:31.060
So I just stopped because I just had a thing.

00:56:31.060 --> 00:56:35.580
You know, sometimes you see this in the editor as well, when like editors will give you previews.

00:56:35.640 --> 00:56:41.700
So for example, if you use optional of a thing or thing pipe none, and then you hover over

00:56:41.700 --> 00:56:45.660
it in the editor, it'll say, even if you used optional, it'll say thing pipe none, because

00:56:45.660 --> 00:56:47.660
it, it's like, those mean the same thing.

00:56:47.660 --> 00:56:49.520
I'm going to just represent them in one way.

00:56:49.520 --> 00:56:50.300
And yeah.

00:56:50.300 --> 00:56:50.900
Yeah.

00:56:50.900 --> 00:56:51.600
Interesting.

00:56:51.600 --> 00:56:52.060
Okay.

00:56:52.140 --> 00:56:54.360
We have a bunch more things covered, but we don't have really any time.

00:56:54.360 --> 00:56:58.080
Like my goal with this, having you on here to talk about this stuff, it's really kind of

00:56:58.080 --> 00:57:00.200
like the highlight, the whole series and people should go.

00:57:00.200 --> 00:57:06.520
And we've been kind of hand waving because reading C code on air is not ideal to give people

00:57:06.520 --> 00:57:11.360
an idea, but really to highlight your whole series and people can just dive into this pretty

00:57:11.360 --> 00:57:11.660
deep.

00:57:11.660 --> 00:57:16.620
And, and I think they'll have a much better appreciation for when you write this one line.

00:57:16.620 --> 00:57:17.820
Oh my goodness.

00:57:17.820 --> 00:57:18.980
This is actually what's happening.

00:57:18.980 --> 00:57:21.200
And how I actually found a bug in Python.

00:57:21.200 --> 00:57:22.060
Thanks to it.

00:57:22.100 --> 00:57:22.340
Okay.

00:57:22.340 --> 00:57:23.280
Tell us quick about that.

00:57:23.280 --> 00:57:23.560
Yeah.

00:57:23.560 --> 00:57:28.940
It's covered in the in place binary operator, augmented assignment post.

00:57:28.940 --> 00:57:34.540
So, you know how you can do a plus equals B and it's like doing a equals a plus B.

00:57:34.540 --> 00:57:34.800
Yeah.

00:57:34.800 --> 00:57:35.380
Yeah.

00:57:35.380 --> 00:57:36.900
So it turned out it was broken for pal.

00:57:36.900 --> 00:57:41.320
So when, you know, when you could do a star, star B, that's a to the B power.

00:57:41.320 --> 00:57:41.980
Yeah.

00:57:41.980 --> 00:57:45.200
It turned out the semantics were busted for star, star equals.

00:57:45.200 --> 00:57:45.900
Wow.

00:57:45.900 --> 00:57:46.280
Okay.

00:57:46.280 --> 00:57:51.300
And no one had ever noticed because obviously people do not write custom implementations of

00:57:51.300 --> 00:57:52.200
thunder pal.

00:57:52.200 --> 00:57:52.320
Yeah.

00:57:52.320 --> 00:57:52.600
Yeah.

00:57:52.600 --> 00:57:52.680
Yeah.

00:57:52.680 --> 00:57:52.760
Yeah.

00:57:52.760 --> 00:57:53.140
Yeah.

00:57:53.140 --> 00:57:56.360
turned out was, and someone actually discovered it and reported it.

00:57:56.360 --> 00:57:57.520
Uh, I just didn't know about it.

00:57:57.720 --> 00:58:00.080
that basically when you did that.

00:58:00.080 --> 00:58:04.460
So the in place augmented assignment, there's I versions of everything.

00:58:04.460 --> 00:58:06.360
Like I add a dunder.

00:58:06.360 --> 00:58:07.260
I add dunder.

00:58:07.260 --> 00:58:08.660
I mall dunder.

00:58:08.660 --> 00:58:09.560
I pow, right?

00:58:09.780 --> 00:58:13.440
It turns out for all of them, they did the right thing except for power where it would

00:58:13.440 --> 00:58:14.440
check for I pow.

00:58:14.440 --> 00:58:20.000
And I mean, in all these scenarios, because a plus equals B is the same as a equals a plus

00:58:20.000 --> 00:58:20.220
B.

00:58:20.220 --> 00:58:26.060
If the I version returns, not implemented, it falls back to just doing the binary operator

00:58:26.060 --> 00:58:27.180
and then doing the assignment.

00:58:27.180 --> 00:58:27.680
Right.

00:58:27.740 --> 00:58:35.920
So like if I plus, so I plus equals B unravels to a dot I pap, I, a dot dunder I pow with

00:58:35.920 --> 00:58:36.700
B as an argument.

00:58:36.700 --> 00:58:42.560
If that returns not implemented, then it devolves into a plus B a equals the result of that.

00:58:42.560 --> 00:58:42.800
Right.

00:58:42.800 --> 00:58:47.780
In the pow case, if you return not implemented on dunder I pow, it didn't fall back to pow,

00:58:47.780 --> 00:58:48.380
dunder pow.

00:58:48.380 --> 00:58:49.420
Okay.

00:58:49.420 --> 00:58:50.400
It just crashed.

00:58:50.400 --> 00:58:51.480
You said, I don't know what to do here.

00:58:51.480 --> 00:58:52.360
It was just an exception.

00:58:52.360 --> 00:58:53.180
It was like, yeah, no.

00:58:53.180 --> 00:58:54.860
I suppose that's better than the wrong answer.

00:58:54.860 --> 00:58:57.380
Like actually the square of nine is 18.

00:58:57.380 --> 00:58:58.180
Carry on.

00:58:58.180 --> 00:59:04.320
It threw me for a loop because I wrote code to verify all my unraveling and how did the

00:59:04.320 --> 00:59:06.680
augmented assignment for power just kept not working.

00:59:06.680 --> 00:59:08.300
It was like, what the heck's going on?

00:59:08.300 --> 00:59:09.780
And then I had to dig into the C code.

00:59:09.780 --> 00:59:11.180
I was like, what am I doing wrong here?

00:59:11.180 --> 00:59:11.820
Yeah.

00:59:11.820 --> 00:59:12.620
Wait a second.

00:59:12.620 --> 00:59:15.480
That code unravels calling this C code, calling this C code.

00:59:15.480 --> 00:59:19.980
And it didn't check that return value on calling it under ipow.

00:59:19.980 --> 00:59:21.400
It's like, well, did it return not implemented?

00:59:21.400 --> 00:59:23.560
And if it did, then we've got to try the other version.

00:59:23.560 --> 00:59:24.260
It just didn't.

00:59:24.260 --> 00:59:27.340
It's like, oh, no, it's just the value just got returned.

00:59:27.340 --> 00:59:28.560
It just didn't even check.

00:59:28.560 --> 00:59:33.080
I think we figured out it happened when the third argument to pow got added and it was just

00:59:33.080 --> 00:59:33.920
someone overlooked it.

00:59:33.920 --> 00:59:36.940
But I see it been sitting there for years.

00:59:36.940 --> 00:59:38.780
Like I think it was a decade.

00:59:38.780 --> 00:59:39.040
Yeah.

00:59:39.040 --> 00:59:40.220
You're looking through these things.

00:59:40.220 --> 00:59:42.160
You can tell that they're pretty subtle.

00:59:42.160 --> 00:59:44.360
There's a lot going on in the different special cases.

00:59:44.360 --> 00:59:47.980
So I can see it wouldn't hit you in the face that you necessarily miss something right

00:59:47.980 --> 00:59:48.220
away.

00:59:48.220 --> 00:59:48.700
Exactly.

00:59:48.700 --> 00:59:49.300
Yeah.

00:59:49.300 --> 00:59:49.560
Yeah.

00:59:49.560 --> 00:59:49.800
Yeah.

00:59:49.800 --> 00:59:51.260
I don't fault anyone at all.

00:59:51.380 --> 00:59:54.620
I think we were just missing a test case somewhere to make sure that that happened.

00:59:54.620 --> 00:59:59.820
Because and once again, I don't think people define their own custom pow operator for their

00:59:59.820 --> 01:00:00.140
types.

01:00:00.140 --> 01:00:02.840
There's a whole bunch of mathematicians going, we do.

01:00:02.840 --> 01:00:03.540
We do.

01:00:03.540 --> 01:00:05.780
Or physicists or something.

01:00:05.780 --> 01:00:06.120
Yeah.

01:00:06.120 --> 01:00:06.520
All right.

01:00:06.520 --> 01:00:08.960
We're pretty much out of time to go any deeper on this.

01:00:08.960 --> 01:00:13.280
And I think that I think people got a really good sense of what's happening, you know,

01:00:13.280 --> 01:00:15.420
like what you mean with your series here.

01:00:15.420 --> 01:00:17.260
And hopefully they're inspired to go check it out.

01:00:17.260 --> 01:00:17.640
But I do.

01:00:17.640 --> 01:00:21.980
While I have this import stuff on the screen and you've done so much work with import lib,

01:00:21.980 --> 01:00:27.940
will there ever be a time where like hot reload type of stuff is a thing?

01:00:27.940 --> 01:00:31.880
You know, like I edit this file in this web app and it's got this project.

01:00:31.880 --> 01:00:32.680
It's been running.

01:00:32.920 --> 01:00:38.060
And I just, just maybe could we have a file watcher trigger this module to re-import?

01:00:38.060 --> 01:00:40.300
Not necessarily saying it's a good idea, but have you.

01:00:40.300 --> 01:00:43.500
Do you mean like you want automatic import lib.reload?

01:00:43.500 --> 01:00:44.180
Yes.

01:00:44.180 --> 01:00:46.480
Or, you know, even like the lib reload stuff.

01:00:46.480 --> 01:00:50.800
A lot of times like you can do it, but it's kind of discouraged because I think largely because

01:00:50.800 --> 01:00:51.560
of the side effects.

01:00:51.560 --> 01:00:52.880
What can happen there?

01:00:53.000 --> 01:00:58.620
No, so to be very specific, if you call a module, if you call import lib.reload on a

01:00:58.620 --> 01:01:01.900
module, it effectively reruns import on that module.

01:01:01.900 --> 01:01:07.120
The problem is, is all the references you have to objects don't change.

01:01:07.120 --> 01:01:07.900
Yeah, exactly.

01:01:07.900 --> 01:01:13.480
So if you got something out of that module, like let's say there was a global dictionary

01:01:13.480 --> 01:01:15.720
that you stored a reference to a way that you expected.

01:01:15.720 --> 01:01:15.980
Right.

01:01:15.980 --> 01:01:17.760
Or a function or a class.

01:01:17.760 --> 01:01:18.120
Maybe.

01:01:18.120 --> 01:01:19.040
Yeah.

01:01:19.260 --> 01:01:23.100
And then you call reload, everyone else in the future is going to get the new module

01:01:23.100 --> 01:01:26.340
and they'll get the new version of all the things that were in that module.

01:01:26.340 --> 01:01:30.020
But all that stuff you still have reference to do, that didn't get magically taken away

01:01:30.020 --> 01:01:30.760
or garbage collected.

01:01:30.760 --> 01:01:34.440
And we can't really necessarily swap it underneath you either because the whole type could have

01:01:34.440 --> 01:01:34.780
changed.

01:01:34.780 --> 01:01:35.580
Right, right, right.

01:01:35.580 --> 01:01:40.660
So, I mean, if you really wanted to set up your own import system that does file monitoring

01:01:40.660 --> 01:01:43.460
and Omnic calls import.reload, you could totally do that today.

01:01:43.460 --> 01:01:45.200
There's nothing stopping you.

01:01:45.200 --> 01:01:48.160
But you have to just be very aware that.

01:01:48.320 --> 01:01:50.500
Only sometimes will it have a good effect.

01:01:50.500 --> 01:01:52.440
Yeah, it'll have an effect.

01:01:52.440 --> 01:01:52.700
Yeah.

01:01:52.700 --> 01:01:55.140
It's just whether it's going to do what you expect.

01:01:55.140 --> 01:02:01.760
And that's why import.reload is discouraged because people often don't quite understand

01:02:01.760 --> 01:02:05.440
the side effects and the things you have to watch out for to understand that it's going

01:02:05.440 --> 01:02:06.400
to do what you expect.

01:02:06.400 --> 01:02:11.100
And especially when you import, do from imports, right?

01:02:11.100 --> 01:02:14.760
Because then you're getting the direct objects off the module instead of the module itself.

01:02:14.760 --> 01:02:17.340
Because if it doesn't in place reimport.

01:02:17.340 --> 01:02:23.540
So, if you did import spam and you reloaded spam, the attributes off of spam will now be

01:02:23.540 --> 01:02:24.160
the new stuff.

01:02:24.160 --> 01:02:26.660
Because we actually changed that dictionary in place.

01:02:26.660 --> 01:02:30.660
But if you did from spam import function, function is not going to change.

01:02:30.660 --> 01:02:34.880
There's another reason why I always tell everybody, don't import the objects from a module, import

01:02:34.880 --> 01:02:35.480
to the module.

01:02:35.860 --> 01:02:39.340
I personally find it more readable because I can look at the code no matter where I am

01:02:39.340 --> 01:02:41.660
in the file and know where that function came from.

01:02:41.660 --> 01:02:42.540
It's not from this module.

01:02:42.540 --> 01:02:43.140
It's from somewhere else.

01:02:43.140 --> 01:02:43.900
I am always with you.

01:02:43.900 --> 01:02:46.780
I'm almost never from thing import other thing.

01:02:46.780 --> 01:02:47.220
Yeah.

01:02:47.220 --> 01:02:50.500
Unless it's a deep module in a package, in which case that makes sense.

01:02:50.500 --> 01:02:53.040
Because you'll still do module dot thing.

01:02:53.040 --> 01:02:53.480
Right.

01:02:53.480 --> 01:02:53.700
Right.

01:02:53.700 --> 01:02:57.380
Well, even though I have that, if it's like four levels deep, I'll do the first three.

01:02:57.540 --> 01:03:01.240
And then from the first three, import the last step of the module.

01:03:01.240 --> 01:03:03.780
So, you can say like data layer dot, you know.

01:03:03.780 --> 01:03:04.200
Exactly.

01:03:04.200 --> 01:03:05.780
Update rather than just update.

01:03:05.780 --> 01:03:06.700
Like, well, what does update mean?

01:03:06.700 --> 01:03:07.220
I don't know.

01:03:07.220 --> 01:03:07.680
Exactly.

01:03:07.680 --> 01:03:08.160
Yeah.

01:03:08.160 --> 01:03:10.300
I mean, the canonical example is random.

01:03:10.300 --> 01:03:12.080
You see the function random in your code.

01:03:12.080 --> 01:03:13.300
Whose random is that?

01:03:13.300 --> 01:03:14.760
Is that from the random module?

01:03:14.760 --> 01:03:15.840
Is that from NumPy?

01:03:15.840 --> 01:03:17.320
Did you implement random?

01:03:17.320 --> 01:03:18.820
Whose random is that?

01:03:18.820 --> 01:03:19.280
Yeah.

01:03:19.280 --> 01:03:19.840
You just know.

01:03:19.840 --> 01:03:21.740
But if you saw np.random, you'd know.

01:03:21.740 --> 01:03:22.320
Exactly.

01:03:22.320 --> 01:03:22.720
Yeah.

01:03:22.720 --> 01:03:23.720
If you knew what np was.

01:03:23.720 --> 01:03:23.980
Yeah.

01:03:23.980 --> 01:03:24.760
If you did.

01:03:24.760 --> 01:03:25.280
Of course.

01:03:25.280 --> 01:03:26.240
Right.

01:03:26.340 --> 01:03:29.100
I guess give you a chance to kind of summarize.

01:03:29.100 --> 01:03:34.220
Final, final thoughts here on your Syntactic Sugar series and, you know, tell people how

01:03:34.220 --> 01:03:34.980
to get it and stuff.

01:03:34.980 --> 01:03:35.940
You can go to my blog.

01:03:35.940 --> 01:03:37.100
It's on Snarky.ca.

01:03:37.100 --> 01:03:39.160
It has the tag Syntactic Sugar.

01:03:39.160 --> 01:03:41.080
I'm sure Michael will include it in the show notes.

01:03:41.080 --> 01:03:47.460
Don't feel the need to read all of it, but do look at at least the first one or two because

01:03:47.460 --> 01:03:52.480
I do go into more detail on how you can kind of go exploring on your own in way more detail

01:03:52.480 --> 01:03:56.240
in those posts than I do towards Anne because I'll be honest, I lost a bit of steam and

01:03:56.240 --> 01:03:58.820
going diving into all the deep layers.

01:03:58.820 --> 01:04:01.380
I wanted to get the blog post series done after two years.

01:04:01.380 --> 01:04:02.040
It was one of those.

01:04:02.040 --> 01:04:02.700
Okay.

01:04:02.700 --> 01:04:03.620
Go look at the earlier ones.

01:04:03.620 --> 01:04:08.160
They'll explain how to how to figure out how to go from syntax to the bytecode to the C code

01:04:08.160 --> 01:04:11.920
and then know where to look in the C code, which, by the way, you don't have to understand

01:04:11.920 --> 01:04:12.500
the C code.

01:04:12.500 --> 01:04:16.560
It's not a is not crazy C code, but it's also not necessarily critical.

01:04:16.560 --> 01:04:19.580
I do try to write down the Python equivalents for everything.

01:04:19.580 --> 01:04:23.660
So it's there if you do understand C, but don't feel intimidated if you don't.

01:04:23.660 --> 01:04:25.820
And hopefully you just find it interesting, right?

01:04:25.820 --> 01:04:27.720
Like you've always wondered how the heck does this work?

01:04:27.720 --> 01:04:33.000
If it's in that, if it's in the blog post, you'll be able to have a better understanding

01:04:33.000 --> 01:04:33.900
hopefully of how things work.

01:04:33.920 --> 01:04:37.920
Because as I said, I honestly even learned some details that I forgot or never even knew

01:04:37.920 --> 01:04:42.820
about some of the semantics behind Python and how, like how things actually work underneath

01:04:42.820 --> 01:04:43.120
the hood.

01:04:43.120 --> 01:04:46.560
And it just gave me a better understanding to understand when things do and don't happen

01:04:46.560 --> 01:04:47.260
the way I expect.

01:04:47.260 --> 01:04:52.400
And honestly, appreciate all the work everyone's put into language over the decades to make it

01:04:52.400 --> 01:04:53.920
all seemingly seem simple.

01:04:53.920 --> 01:04:55.700
And yet it's surprisingly complex.

01:04:55.700 --> 01:04:55.940
Yeah.

01:04:55.940 --> 01:04:59.080
I don't think you need to read them all either as somebody who read most of them the last couple

01:04:59.080 --> 01:04:59.400
of days.

01:04:59.560 --> 01:05:00.580
No, you don't.

01:05:00.580 --> 01:05:03.300
I mean, if you're a completionist, go for it.

01:05:03.300 --> 01:05:04.580
But yes, you definitely do not need to.

01:05:04.580 --> 01:05:08.600
But I do think going through it, you know, pick out the ones, there's a whole bunch of

01:05:08.600 --> 01:05:09.180
different topics.

01:05:09.180 --> 01:05:11.980
Pick out the ones that are like, oh, I did always wonder how that one worked.

01:05:11.980 --> 01:05:18.040
And pretty much with the exception of pass, I think you'll be like, oh my gosh, I had no

01:05:18.040 --> 01:05:19.220
idea what was involved here.

01:05:19.220 --> 01:05:19.520
Yeah.

01:05:19.520 --> 01:05:24.460
Pass was very much just a, I had a checklist of every piece of syntax and every single keyword.

01:05:24.460 --> 01:05:29.840
And that was that the blog post on pass, I think is like three sentences and half of

01:05:29.840 --> 01:05:32.480
it saying this is going to be the shortest, shortest post in this whole series.

01:05:32.480 --> 01:05:33.040
Yeah.

01:05:33.040 --> 01:05:33.640
Pass is.

01:05:33.640 --> 01:05:34.800
Yeah.

01:05:34.800 --> 01:05:38.820
It was contending with dot, dot, dot, which we haven't even had a chance to talk about

01:05:38.820 --> 01:05:42.260
ellipses versus pass, but I think we're out of time, Brett.

01:05:42.260 --> 01:05:44.020
So thanks for being here.

01:05:44.020 --> 01:05:45.700
Thanks for all you do.

01:05:45.700 --> 01:05:50.640
I mean, steering council, core dev, author, VS Code, et cetera.

01:05:50.640 --> 01:05:51.700
A lot of contributions.

01:05:51.700 --> 01:05:52.140
Thanks.

01:05:52.140 --> 01:05:53.740
Thanks for having me back on yet again.

01:05:53.740 --> 01:05:55.720
And hopefully I've not worn out my welcome still.

01:05:55.720 --> 01:06:01.220
No, you're already thinking about what next WebAssembly Rust thing we'll get together on.

01:06:01.220 --> 01:06:02.660
Thanks for being here.

01:06:02.660 --> 01:06:03.020
See you later.

01:06:03.020 --> 01:06:03.440
Thanks, Michael.

01:06:03.440 --> 01:06:07.120
This has been another episode of Talk Python to Me.

01:06:07.120 --> 01:06:08.940
Thank you to our sponsors.

01:06:08.940 --> 01:06:10.540
Be sure to check out what they're offering.

01:06:10.540 --> 01:06:11.980
It really helps support the show.

01:06:11.980 --> 01:06:14.100
Want to level up your Python?

01:06:14.100 --> 01:06:18.160
We have one of the largest catalogs of Python video courses over at Talk Python.

01:06:18.160 --> 01:06:23.340
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:06:23.340 --> 01:06:26.020
And best of all, there's not a subscription in sight.

01:06:26.020 --> 01:06:28.900
Check it out for yourself at training.talkpython.fm.

01:06:28.900 --> 01:06:30.980
Be sure to subscribe to the show.

01:06:30.980 --> 01:06:33.760
Open your favorite podcast app and search for Python.

01:06:33.760 --> 01:06:35.080
We should be right at the top.

01:06:35.080 --> 01:06:40.240
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:06:40.240 --> 01:06:44.420
and the direct RSS feed at /rss on talkpython.fm.

01:06:44.420 --> 01:06:47.400
We're live streaming most of our recordings these days.

01:06:47.400 --> 01:06:50.800
If you want to be part of the show and have your comments featured on the air,

01:06:50.800 --> 01:06:55.180
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:06:55.180 --> 01:06:57.280
This is your host, Michael Kennedy.

01:06:57.280 --> 01:06:58.580
Thanks so much for listening.

01:06:58.580 --> 01:06:59.740
I really appreciate it.

01:06:59.740 --> 01:07:01.640
Now get out there and write some Python code.

01:07:01.640 --> 01:07:22.440
I'll see you next time.

