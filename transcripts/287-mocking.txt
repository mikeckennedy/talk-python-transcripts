00:00:00 We know our tests should be relatively independent from other parts of the system.

00:00:03 For example, running a test shouldn't generally call a credit card processing API and talk to a database

00:00:09 when our goal is just to test the argument validation.

00:00:12 And yet, your method that you want to test, it does all three of those things and more.

00:00:17 What do you do?

00:00:18 Some languages use elaborate dependency passing mechanisms and frameworks

00:00:23 that go under the banner of inversion of control and dependency injection.

00:00:27 In Python, we do sometimes have that, but it's much more common to just temporarily redefine

00:00:33 what those two functions do using patching and mocking.

00:00:36 On this episode, we welcome back Annalena Popkas to talk us through the whole spectrum of

00:00:42 test doubles, dummies, mocks, and more.

00:00:44 This is Talk Python To Me, episode 287, recorded August 24th, 2020.

00:00:50 Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the

00:01:08 ecosystem, and the personalities.

00:01:09 This is your host, Michael Kennedy.

00:01:11 Follow me on Twitter, where I'm @mkennedy.

00:01:13 Keep up with the show and listen to past episodes at talkpython.fm.

00:01:17 And follow the show on Twitter via at talkpython.

00:01:20 This episode is brought to you by Linode and monday.com.

00:01:23 Please check out what they're offering during their segments.

00:01:25 It really helps support the show.

00:01:28 Do you want to learn Python, but you can't bear to subscribe to yet another service?

00:01:32 At Talk Python Training, we hate subscriptions too.

00:01:36 That's why our course bundle gives you full access to the entire library of courses for

00:01:40 one fair price.

00:01:41 That's right.

00:01:42 With the course bundle, you save 70% off the full price of our courses, and you own them

00:01:47 all forever.

00:01:48 That includes courses published at the time of the purchase, as well as courses released

00:01:53 within about a year of the bundle.

00:01:54 So stop subscribing and start learning at talkpython.fm/everything.

00:02:00 Anna Lena, welcome back to Talk Python To Me.

00:02:03 Thanks.

00:02:04 It's great to be back.

00:02:05 Yeah, it's super to have you back.

00:02:06 Last time we spoke about 100 days of code and Harry Potter and things like that, if I recall

00:02:13 correctly.

00:02:13 Is that right?

00:02:14 Yes, that's correct.

00:02:16 Yeah, that was really fun.

00:02:17 And that was right at the height of the 100 days of code when everyone was really using

00:02:21 that to learn to code.

00:02:22 And so you had this unusual, but I think really engaging way of taking code and making it not

00:02:27 just silly technical stuff, but making it this fun Harry Potter adventure world.

00:02:31 Yeah, I still love that approach.

00:02:33 So I always try to find something I'm passionate about and then trying to use it to learn.

00:02:39 Yeah, excellent.

00:02:40 So now we're going to come back and talk about writing code that we're more likely to be

00:02:46 sure that works, testing code and using mocking and all that.

00:02:49 But when we spoke last time, you were a, was it an internship at Microsoft?

00:02:55 What kind of?

00:02:56 It's something in between.

00:02:57 It was called an AI residency at Microsoft Research in Cambridge in the UK.

00:03:02 So it's like an intensive one year program where you learn a lot about how to apply machine

00:03:07 learning, how to become a great research engineer.

00:03:09 So cool.

00:03:10 It's like, yeah, it's more than an internship, like a really long extended internship.

00:03:16 I'm sure that was a really fun project experience.

00:03:19 Oh yeah, it was amazing.

00:03:21 Also the place Microsoft Research in Cambridge is just great.

00:03:25 I really loved it there.

00:03:26 Yeah, I can imagine.

00:03:28 And how about now?

00:03:30 What are you up to now?

00:03:31 Yeah, so I finished the residency and I moved back to Germany and joined a German company

00:03:35 called InnoVex.

00:03:36 I also like it here a lot.

00:03:38 And I'm working as a machine learning engineer, similar to what I did at Microsoft Research,

00:03:43 but not so research heavy.

00:03:46 So I'm doing more production code or production work.

00:03:50 And I'm currently working in a pure data engineering project.

00:03:53 So I've been learning a lot more about the work that comes before actually applying the machine

00:03:57 learning algorithms, which is also very interesting.

00:04:00 Yeah.

00:04:00 So I would guess that involves a lot of pandas, a lot of cleaning up data, like getting stuff

00:04:04 in the right format.

00:04:05 Yes.

00:04:07 Yeah.

00:04:07 And then we give the data to the data scientists, which can just use the clean data to do their

00:04:12 nice machine learning stuff.

00:04:14 Yeah, you make them look good.

00:04:16 You're like, oh, here, you just feed this over and it works great.

00:04:18 Like it didn't start out that way.

00:04:21 What kind of problems are you trying to solve or answer?

00:04:23 It really depends on what the customer wants.

00:04:26 So it can go from supply chain management and apply machine learning there to right now in

00:04:32 the cloud, where we just create kind of a data lake in the Google cloud, where we have different

00:04:38 data sources that have to be processed and brought together and all the other stuff.

00:04:44 So there's just a lot going on.

00:04:46 It's a very huge project with several teams working on it.

00:04:49 Wow.

00:04:49 Yeah.

00:04:50 It sounds really fun.

00:04:51 And it sounds like one of these big data projects that people talk about a lot, but not

00:04:55 that many people actually do.

00:04:56 Yeah.

00:04:57 And it's also very interesting for me to see this other side.

00:05:00 I've been working on machine learning for most of my computer science life.

00:05:04 So seeing something different is also always very nice.

00:05:08 Yeah, absolutely.

00:05:09 And you also have some project going on in your spare time, yeah?

00:05:12 Yes, exactly.

00:05:13 So Kai Macht Schule.

00:05:15 Yeah, it's I think like it's a German project.

00:05:19 I'm doing voluntary work there.

00:05:21 It's called Kai Macht Schule.

00:05:22 That's like, I think you could translate it as AI goes to school.

00:05:27 Yeah, where we teach AI and machine learning skills to kids in German schools.

00:05:31 So we do classes usually on site, but now online due to the COVID crisis.

00:05:37 And yeah, it was somewhat similar to what you talked about in the last episode or some recent

00:05:43 episode with Nick Winter on Code Combat.

00:05:45 Yeah, Code Combat is really a fun thing for kids as well.

00:05:49 I think that's super neat what they're doing.

00:05:51 I want to try it as well, even if I know how to write code in Python.

00:05:55 It sounded so much fun.

00:05:56 Yeah, it's really neat.

00:05:58 I really enjoyed just kind of poking around with it and seeing it's, again, kind of like

00:06:03 your Harry Potter world.

00:06:04 It's a very different way to present programming to kids where you still type.

00:06:08 It doesn't feel like the burden of being exactly right.

00:06:11 You can kind of type it wrong and it'll mostly correct it for you.

00:06:15 So it's pretty interesting.

00:06:16 So with this project, you're teaching kids AI and machine learning.

00:06:21 What does that even look like?

00:06:22 What kind of stuff are you teaching them?

00:06:24 What do they get when they're building little libraries and so on?

00:06:27 Yeah.

00:06:27 So we try different approaches.

00:06:29 We always have a bit of theory.

00:06:31 So what is AI?

00:06:33 How does it work?

00:06:34 We also have a part on the ethics behind AI, which I think is really important.

00:06:39 And there's also some practical exercises with Jupyter Notebooks.

00:06:43 Before we used an approach was where you have these blocks of programming parts, which you

00:06:49 can stick together, like the for loops and so on.

00:06:52 But we didn't like that so much.

00:06:54 So right now we are using Jupyter Notebooks.

00:06:57 And I think it's amazing since right now there's one, it's called KI Camp.

00:07:01 It's like a four-day course.

00:07:02 And the youngest one is in fifth grade.

00:07:06 So it's like 11 or 12.

00:07:08 And the oldest one is just about to graduate.

00:07:10 And it's so nice to see these kids fascinated by this topic.

00:07:14 Yeah.

00:07:15 It's definitely going to give them a leg up, learn these types of things early and know

00:07:19 about them and just to learn about Jupyter and computational thinking at all.

00:07:23 Yeah.

00:07:23 And Germany is also really not so good with the computer science work in school.

00:07:28 I think in the US you are much better with teaching kids how to code in school already.

00:07:34 For German kids, it's really hard to get to know AI or to find somewhat a way to get familiar

00:07:41 with the topic without going out there and looking for yourself what's out on the internet.

00:07:48 Yeah.

00:07:48 There's the small percentage of kids who will do that.

00:07:51 They'll go find it themselves.

00:07:51 But the majority don't even know they would be interested until they get exposed to it.

00:07:56 Exactly.

00:07:56 Yeah.

00:07:57 It was the same for me.

00:07:58 So that's why I'm really passionate about this project.

00:08:01 Yeah.

00:08:01 Awesome.

00:08:02 And you've definitely taken it quite far what you're doing these days.

00:08:04 That's definitely the pinnacle.

00:08:06 It's great.

00:08:06 All right.

00:08:07 Well, let's focus on our main topic for a little while on mocking.

00:08:12 So how'd you get interested in it?

00:08:14 How'd you get started?

00:08:14 Yeah.

00:08:15 So I stumbled upon this topic a few months back when I started working in this data engineering

00:08:20 project I was just talking about.

00:08:21 And we have lots of production code there.

00:08:24 And I never heard of mocking before.

00:08:26 So it was the first time I used it.

00:08:28 And since then, I've been using it in almost all of the tests I write.

00:08:32 It's a very controversial topic.

00:08:34 So I watched quite a few PyCon talks on it and read quite a few blog posts.

00:08:39 And yeah, it's just a big but very interesting thing to talk about.

00:08:45 Yeah.

00:08:45 So I think one of the controversies has to do with you can write your code in certain ways

00:08:50 so it's more easy to test or it's harder to test.

00:08:53 And some people see mocking as kind of covering over the bad code you've written or something

00:09:00 to that effect, right?

00:09:01 Hopefully that sort of summarizes it.

00:09:03 Yeah, exactly.

00:09:04 And I completely understand that.

00:09:06 So you shouldn't use mocking to fix your badly written code.

00:09:10 So you, of course, you should first think about, is my code good?

00:09:14 Do I want to refactor it?

00:09:16 Are there changes I can make to make it easier to test?

00:09:20 But sometimes it can be a really good tool.

00:09:23 I think it's a great tool.

00:09:24 I think when it's used in the right ways and right places, it's just what you need.

00:09:28 Yes, I agree.

00:09:29 Yeah.

00:09:29 I mean, Python is so much about the sort of practicality beats purity.

00:09:34 You know, it's part of the Zen of Python and all that.

00:09:36 And it's just, let's just do what we need to do to make stuff work.

00:09:41 And I think one of the examples where this is really different from other languages is in

00:09:45 Python, we don't have things like protected variables.

00:09:49 We don't have as often like concrete interfaces.

00:09:53 We don't have type enforcement, right?

00:09:55 Like the thing you passed here must be this interface.

00:09:58 And if it's not, we're going to raise an exception.

00:10:00 We have type hints, but that's like an editor or like tool helper.

00:10:04 It doesn't mean that runtime it's not going to work or it won't compile or whatever.

00:10:08 Yeah.

00:10:08 Right.

00:10:09 And so I feel like mocking and patching is like, it's sort of, it's more embraced in this

00:10:15 world where it's like, look, if we just do this little thing, we can avoid all this complexity

00:10:19 and all of these design patterns and all of this stuff that technically would be maybe a

00:10:24 more official, pure computer sciencey way.

00:10:27 But if you look at the stuff that gets built from it, it gets really hard to deal with it

00:10:31 and ugly.

00:10:31 Yeah.

00:10:32 Yeah.

00:10:33 I agree.

00:10:33 Yeah.

00:10:34 I remember I worked on this one project and it was originally written, I think in Java

00:10:39 and then converted to C#.

00:10:40 And it used, I think every design pattern that you could possibly name.

00:10:44 And it used every single thing that used some sort of dependency.

00:10:49 It had an interface for that dependency.

00:10:51 It would pass that in into the constructor.

00:10:53 And then when it created objects, it would pass that further down.

00:10:56 And what you ended up with was the entire code that you wrote was all this abstract stuff.

00:11:01 And you would look at it like, well, I see all the functions, but I just don't even know

00:11:06 where I would go to find out what actually does this.

00:11:09 It's just, it was so insanely complicated.

00:11:12 So I've seen that far in and I've seen the world where people just go, you know, okay, we're

00:11:17 not going to set up all those structures, but we're just going to do a patch like deep down

00:11:21 inside of some function call.

00:11:23 And if I had to pick one of those two worlds, I would definitely live in the world where

00:11:27 we just keep things simple as it's, it was not fun to work on that project in that way.

00:11:31 It sounds terrible.

00:11:33 Yeah.

00:11:33 Yeah.

00:11:34 It was like a, probably a six month project.

00:11:36 I'm just like, I'm constantly frustrated on this project.

00:11:38 So let's, I guess, start at the beginning.

00:11:42 Like what is mocking?

00:11:44 There's a lot of folks who listen, who come from a sort of scientific background where they

00:11:48 haven't done official computer science or they're self-taught.

00:11:51 Maybe, maybe this idea is new to them.

00:11:52 What is, what's mocking?

00:11:53 Yeah.

00:11:54 So a mock simulates the existence and behavior of a real object.

00:11:58 I guess we can go over a few examples, but if you use mocking, you as a developer can

00:12:04 improve the quality of your tests and also test code in a controlled environment.

00:12:08 And it's especially useful if you have external dependencies, like if you want to write to a

00:12:13 database or do stuff like that.

00:12:15 And there's a nice Python library, which is included in unit test, which is called unit

00:12:21 test.mock, which can be used for mocking.

00:12:23 I think there are also some more specialized libraries out there.

00:12:27 I think there's one, especially for mocking date time, but I've never used it.

00:12:32 So I'm only using unit test.mock.

00:12:34 Yes.

00:12:35 I think the one out there called that is called freeze gun.

00:12:38 Yes, exactly.

00:12:40 Yeah.

00:12:40 That's it.

00:12:40 Yes.

00:12:41 A freeze gun.

00:12:42 And that one basically, you know, like you said, allows you to control the date time module.

00:12:48 So there's obvious dependencies that you would think of.

00:12:52 Like if I have a traditional web application, maybe it calls some API, like my online courses

00:12:58 thing.

00:12:58 It's going to call Stripe.

00:13:00 It's probably going to call MailChimp APIs, does some other stuff.

00:13:03 It's going to talk to a database.

00:13:05 So when you think about dependencies, you think, okay, database, maybe the file system,

00:13:09 external APIs, and those are all things you can mock and you probably want to.

00:13:13 But when I first got into this world, one of the things that really surprised me was how

00:13:18 hard it is to work with time.

00:13:20 If I want to say, I would like to call this thing before, like, let's just say it's e-commerce.

00:13:26 Like I want to make sure that this discount code is not expired now.

00:13:29 So it gives me the discount, but in a week it will be expired.

00:13:32 You know, like that's really hard to deal with.

00:13:34 Right.

00:13:35 Yeah.

00:13:35 I think that's a very good place to use mocking for like, it's a great example for that,

00:13:40 where it can be really useful.

00:13:41 Yeah.

00:13:42 And the alternative, I talked about this dystopian world that I lived in for a while.

00:13:46 The alternative would be, you would have to create a fake class that read, like that you

00:13:52 used to get what now is, right?

00:13:55 Instead of just saying datetime.now, you have to create a class like time provider now, and

00:14:01 then everybody has to agree to not use datetime.now, but they'll have to share

00:14:05 this other thing that you're going to pass around.

00:14:07 And that's just, that's just crazy.

00:14:08 Right.

00:14:08 Like it makes no sense.

00:14:10 Yeah.

00:14:10 It's unnecessarily complicated.

00:14:11 Yeah.

00:14:12 It's just so complicated.

00:14:14 And so you can, if you just mock out what now means.

00:14:18 That's it.

00:14:18 Yeah.

00:14:18 Then you're good.

00:14:19 It's fixed.

00:14:20 Right.

00:14:20 So yeah, it's pretty cool.

00:14:22 And Freezegun is one of the libraries.

00:14:23 I'm sure there's a bunch out there, but that's a cool one for doing this kind of stuff with

00:14:27 specifically with time.

00:14:30 This portion of Talk Python To Me is brought to you by Linode.

00:14:33 Whether you're working on a personal project or managing your enterprise's infrastructure,

00:14:37 Linode has the pricing, support, and scale that you need to take your project to the next

00:14:41 level.

00:14:42 With 11 data centers worldwide, including their newest data center in Sydney, Australia, enterprise

00:14:47 grade hardware, S3 compatible storage, and the next generation network, Linode delivers the

00:14:54 performance that you expect at a price that you don't.

00:14:56 Get started on Linode today with a $20 credit and you get access to native SSD storage, a 40

00:15:02 gigabit network, industry leading processors, their revamped cloud manager at cloud.linode.com,

00:15:08 root access to your server, along with their newest API and a Python CLI.

00:15:12 Just visit talkpython.fm/Linode when creating a new Linode account and you'll automatically

00:15:18 get $20 credit for your next project.

00:15:20 Oh, and one last thing.

00:15:22 They're hiring.

00:15:22 Go to linode.com slash careers to find out more.

00:15:26 Let them know that we sent you.

00:15:27 So you talked about replacing dependencies.

00:15:31 I guess give us some more examples.

00:15:34 Time is one that maybe doesn't first come up, but what are some of the type of dependencies

00:15:37 you all were working with?

00:15:39 So I've been working a lot with the Google Cloud client.

00:15:42 So where you want to write or either you want to communicate with the Google Cloud with

00:15:46 different services there, or you want to write to the storage and you need to someone, you

00:15:52 have a client and you want to communicate with the Google Cloud.

00:15:55 And that's the part where we mostly use mocking.

00:15:59 So to somewhat make sure that we test that the file is written, or at least that we have

00:16:05 the correct paths, the correct function call, but we don't actually want to write the file

00:16:10 to the Google Cloud every time or remove it.

00:16:13 Right.

00:16:14 You know, cloud computing, I think it has a really interesting challenge around testing.

00:16:20 It just, in a lot of ways, right?

00:16:22 Like you don't, if you're going to work with the API, you obviously have to not talk to the

00:16:26 real API.

00:16:26 You don't really want to create a virtual machine or a Kubernetes node or whatever, but you do

00:16:31 want to test that that code's going to work.

00:16:33 But at the same time, a lot of times the tests depend on something meaningful coming back.

00:16:37 Yeah.

00:16:38 Right.

00:16:38 There's so much going on in the cloud side that I think it's pretty tricky.

00:16:43 Do you guys do anything special there?

00:16:44 Like I know in AWS, there's like a fake local AWS type thing you can run.

00:16:49 And I know I've talked about it a while ago and I forgot what it's called, but do you guys

00:16:53 do anything like that?

00:16:54 Not at the moment.

00:16:55 I think someone is working on finding ways to improve this since we are using mocking

00:17:00 quite a lot, but it's a really complicated and complex thing since we have a huge code base

00:17:06 already and you would have to change all the code again.

00:17:08 So doing kind of refactoring at this point is always a big deal.

00:17:14 But right now we are just...

00:17:16 Yeah, it might not even be worth it.

00:17:17 Yeah.

00:17:17 Yeah.

00:17:18 Yeah, exactly.

00:17:19 Yeah.

00:17:19 And I think there's also something to be said for that, right?

00:17:22 Like sometimes it's like we could create a mock or fake or we'll talk about the different

00:17:27 terminologies here in a minute.

00:17:28 Yeah.

00:17:29 But sometimes it's like, you know what?

00:17:31 I'm just going to let it ride to the file system.

00:17:33 It's not the end of the world.

00:17:34 We're going to keep going.

00:17:35 One of the really tricky ones I think has to do with data access, right?

00:17:41 I'm going to go talk to the database and get this and then I need to get this other thing

00:17:44 that's related to that.

00:17:45 And I think it's a constant challenge to figure out how much of that you replace and how much

00:17:50 of it you just test against the database or test against a file or something.

00:17:54 Yeah.

00:17:54 It's sometimes difficult to find the right way.

00:17:56 Also, if you are working in a team and other like different people have different opinions

00:18:01 and like different things, but there's also a middle ground somewhere.

00:18:05 Yeah, for sure.

00:18:06 Yeah.

00:18:06 I could see one person on the team is all about like we have to do it the right way where there's

00:18:11 no external dependencies.

00:18:12 And the other person's like, we also have to get stuff done.

00:18:14 You know, I also have to.

00:18:16 I can't spend all my time recreating all of these systems that you're trying to talk

00:18:20 to in ways that are sufficiently accurate so that when you call them, the test data comes

00:18:25 back, but it's as accurate or realistic enough that you're really getting a meaningful test.

00:18:30 So it's tricky.

00:18:31 So you have a example class speaking of Harry Potter and all that.

00:18:36 Yes.

00:18:37 That we're going to use.

00:18:38 We're going to kind of build up some ideas.

00:18:40 And it's always hard to talk about code in audio format.

00:18:42 So we'll keep it simple.

00:18:44 But maybe just give us a quick introduction.

00:18:46 Yeah.

00:18:47 So we have very simple spell class, which where you have just the constructor in the beginning.

00:18:53 And a spell has, of course, a name.

00:18:54 It has an incantation and a description.

00:18:57 So for example, I think there's Accio in Harry Potter, where it moves an object towards the

00:19:05 person who is casting the spell.

00:19:08 And a description could be what I just said.

00:19:11 And then you have the incantation.

00:19:12 Yeah, moves object towards person.

00:19:14 Yeah, exactly.

00:19:14 Exactly.

00:19:15 So that would be an example.

00:19:16 Okay, cool.

00:19:17 All right.

00:19:18 So we'll build up on this as we go through these different ideas here.

00:19:21 And we've been talking about mocking as if it's all kind of the same.

00:19:26 But if you dig into it, there's actually like a spectrum of ways in which you can do mocking.

00:19:32 One of those might be, I just, when I call this function, I want it to not write to the

00:19:38 log on the file system.

00:19:39 And it might be enough that it just doesn't do that.

00:19:41 You don't care what it does.

00:19:43 It just doesn't do that.

00:19:44 On the other hand, there's like very advanced, tricky usage.

00:19:48 Like when I call this function, I want to make sure that it checks whether the person is an admin.

00:19:54 If I say yes, I want to do one thing.

00:19:56 But I want to make sure that it actually always, always calls this function to make sure that it

00:20:00 checked for them, even though you couldn't observe that as a side effect.

00:20:04 I want to make sure that it's like calling this once and this twice or in this order.

00:20:08 Like there's a lot of tricky things.

00:20:10 And those feel like very different things.

00:20:12 So in the mocking world, there's different names for these things, right?

00:20:16 Yes.

00:20:16 And there's also disagreement, I guess, about the terminology and also the definitions of

00:20:22 these different kinds of mocking behaviors that you can distinguish.

00:20:25 Yeah.

00:20:26 And it may or may not be useful.

00:20:28 Like people can decide how much they care about being very precise about calling it one thing

00:20:33 or the other.

00:20:34 But yeah, let's talk about it in the fine grained view, just so people get the full exposure

00:20:40 and they can decide to ignore the differences if they want, right?

00:20:43 Yes, I think that's a good idea.

00:20:45 So yeah, I think the overall name or the name for these kinds of mocking behaviors is called

00:20:52 test doubles.

00:20:52 So there are the fine grained view objects, which are not real, can be either dummies,

00:20:59 fakes, stubs, mocks, or spies.

00:21:02 And all of these are so-called test doubles.

00:21:05 Yeah.

00:21:05 And as I just said, these definitions are also controversial.

00:21:09 And there are sometimes so different sources describe them slightly differently.

00:21:14 But I think it's still possible to get an idea of what they are about.

00:21:19 Yeah.

00:21:19 Yeah, absolutely.

00:21:20 So let's start, I guess, at the simple side of things.

00:21:24 I feel like this whole concept has a little bit of a I'm making fun of you thing.

00:21:29 So mocking to like insult somebody.

00:21:31 And then you've got dummies, you've got fakes.

00:21:34 So let's start with the dummies.

00:21:37 Yeah, I think the dummies are the easiest to understand.

00:21:40 I agree.

00:21:41 Yeah.

00:21:41 And a dummy is just an object which is passed around, but never actually used.

00:21:46 So a dummy is not intended to be used in your tests.

00:21:49 And it does not have any effect on the behavior of the test.

00:21:52 And an example would be when you have attributes that you need to instantiate a class,

00:21:58 but you don't really care about what they are.

00:22:01 For example, for the spell class, if you need a spell instance in your tests,

00:22:06 but you don't care about the description, then you could just pause in an empty string or write whatever you want to in that string.

00:22:14 And that would be then a dummy.

00:22:15 Right.

00:22:15 If you don't supply it, it's going to crash.

00:22:17 Yes.

00:22:18 But you don't actually ever use it or care about it.

00:22:21 You just have to make it get out of the way and keep working.

00:22:23 Yes.

00:22:24 Yeah.

00:22:24 Okay.

00:22:25 So that's dummies.

00:22:27 Next up is fakes.

00:22:28 Yes.

00:22:29 So a fake implements a fake version of a class or method.

00:22:32 It has a working implementation, but it takes some kind of shortcut such that it's not suitable

00:22:38 for production.

00:22:39 And that could be in a memory database.

00:22:42 So usually in production, you would have a database that you write your files to.

00:22:47 But during testing, you could have some in-memory database that you only use during your tests.

00:22:53 Yeah.

00:22:53 That makes a lot of sense.

00:22:54 And that's definitely one of the tricky things, I think, is databases.

00:22:58 The other one that would be really tricky would be, say, an API call.

00:23:03 Like, for example, one of the things I have to do in my code is I have to figure out where

00:23:08 is this person located physically so that I can pick the right video server to deliver

00:23:14 the fastest video to them.

00:23:16 And so there's a call to go to the API that tells me where they are based on their IP address,

00:23:21 like what country basically they're in.

00:23:23 So I can work out what one to send, right?

00:23:26 Every time I run a test, I don't want to call that API, right?

00:23:30 Yeah.

00:23:30 And I don't really...

00:23:31 That's also a good example.

00:23:33 Yeah.

00:23:33 And I mean, probably the test doesn't actually care where it said they were.

00:23:36 But it's, you know, it's going to have to have some kind of behavior because it's going

00:23:40 to have to return a value so the program works.

00:23:42 Like, so maybe I could come up with a mock or a fake specifically that says whenever they

00:23:48 ask where they are, they're always in Kansas City.

00:23:51 It doesn't matter where they really are.

00:23:52 Just tell them it's in Kansas City so that something can happen where the thing keeps working,

00:23:57 right?

00:23:57 Yes.

00:23:58 That's also somewhat a good introduction of the next one, Stubs.

00:24:02 Stubs returns.

00:24:04 It has some pre-programmed behavior.

00:24:07 Most of the times they simply return fixed values or canned data.

00:24:11 Like you just said, for example, always return Kansas City.

00:24:14 And yeah, let's look at the spell class again.

00:24:18 Maybe the spell class could have a method get similar spells, which searches some database

00:24:24 and then you would get similar spells back.

00:24:27 And this is, of course, quite complex since finding these similar spells will probably be very difficult.

00:24:33 And you would.

00:24:34 Right.

00:24:34 Maybe the real version is running machine learning or some sort of crazy system.

00:24:40 And you don't want that to happen all the time, right?

00:24:42 Yes.

00:24:43 Since it would probably slow down your whole testing.

00:24:45 And then you could just replace the real implementation with a stop that returns hard-coded values and would only take a fraction of the time to complete.

00:24:55 Yeah.

00:24:55 Yeah.

00:24:56 That seems like a really good example there.

00:24:58 So I don't know.

00:24:59 I do have a hard time knowing exactly.

00:25:01 Okay.

00:25:02 I've got this idea of which one does it fit into.

00:25:04 It's almost like a spectrum saying that color is purple and that color is red.

00:25:10 What is the color that's purple but sort of towards red?

00:25:13 You know what I mean?

00:25:14 Yeah.

00:25:15 Yeah.

00:25:16 Cool.

00:25:17 All right.

00:25:17 So making our way across this rainbow, I guess, we have mocks.

00:25:21 Yeah.

00:25:22 So mocks are closely related to stops.

00:25:24 And there's this huge stack overflow post on the differences between mocks and stops.

00:25:29 And there you can also get a bit of an idea of the controversy surrounding this topic.

00:25:35 But yeah.

00:25:36 Yeah.

00:25:36 And I'll put that link in the show notes so people can find it.

00:25:38 Yeah.

00:25:39 That's a good idea.

00:25:40 So a mock does not have predetermined behavior, which stops have.

00:25:44 Instead, it has to be configured.

00:25:46 So an important difference between mocks and stops is that a mock records which calls have

00:25:52 been executed.

00:25:53 So it can be used to verify not only the result.

00:25:56 That's something that a stop can do too.

00:25:59 But a mock can verify how the result was achieved so that the correct methods have been invoked

00:26:05 on the mock object.

00:26:06 Yeah.

00:26:06 And this is where it starts to get complicated, I think.

00:26:10 One of the ideas of just programming in general functions and classes, but also testing is

00:26:16 you shouldn't depend upon the internal implementation of a thing when you're testing it or calling

00:26:24 it from the outside.

00:26:25 So if I have a thing that says register a new user, maybe I want to just check if I give

00:26:30 it valid information, it gives me a new user.

00:26:32 If I give it like a malformed email, it'll give me an exception, right?

00:26:36 Like that would be totally straightforward.

00:26:38 But all of a sudden with the this level of mocking, you're like, well, I want to make sure that it checks that the user is not already existing, that this other thing is happening.

00:26:48 And then you're getting more and more tied to the internal details of what that piece is doing, which is fine, maybe.

00:26:55 But then you change your code.

00:26:56 And all of a sudden, all your tests break.

00:26:58 You're like, well, now we got to go rewrite these tests because we don't have this thing that we were

00:27:01 checking that got called inside and it gets this sort of they kind of get glued together a little bit more, which I think can make maintenance hard.

00:27:10 Yeah.

00:27:10 Yeah.

00:27:11 We had that problem, too.

00:27:12 So, yeah, that's something you have to think about, too.

00:27:15 But at the same time, there's good uses for this.

00:27:18 Like I came up with that admin example, because one of the things that scares me a lot is you've got some protected part of an API or an application or something.

00:27:27 And somebody forgets to check whether someone is permitted to go in there.

00:27:32 That's really bad if that ever gets discovered.

00:27:34 You know what I mean?

00:27:35 Like, oh, did we forget to check in the show me all the users and their private information part?

00:27:40 We forget to check if you're logged in.

00:27:42 Whoops.

00:27:43 You know, that kind of stuff could totally happen.

00:27:45 And with this, you could say you are going to have a test for every one of these admin pieces that says you checked whether or not they were an admin.

00:27:52 Right.

00:27:53 That function was called no matter what.

00:27:55 Right.

00:27:55 Yeah.

00:27:56 Yeah.

00:27:56 This portion of Talk Python To Me is sponsored by Monday.com.

00:28:02 Monday.com is an online platform that powers over 100,000 teams daily work.

00:28:07 It's an easy to use, flexible and visual teamwork platform beautifully designed to manage any team, organization or online process.

00:28:15 Now, for most of us, we missed our chance to build the first apps ever in the mobile app stores.

00:28:20 It was a once in a lifetime opportunity, but it's one that's coming around again.

00:28:25 Monday.com is launching their marketplace and running a contest for the best new apps featured right from the get-go.

00:28:31 Want to be one of the first in the Monday.com apps marketplace?

00:28:35 Start building today.

00:28:36 They're even giving away $184,000 in prizes, including three Teslas, 10 MacBooks and more.

00:28:43 Build your idea for an app and get in front of hundreds of thousands of users on day one.

00:28:47 Start building today by visiting Monday.com slash Python or just click the link in your podcast player's show notes.

00:28:56 And so, these mocks, I think that's the thing you could do, right?

00:28:58 You could say, like, expect that this was, what is it, assert called once or something like that, right?

00:29:03 Yes, there are different kinds of assert calls there.

00:29:05 Okay.

00:29:06 We can talk about this later as well.

00:29:07 So, there is assert called once.

00:29:09 You can assert that was called with certain arguments, that it was called not called, that it was called, like, independent of the number of times.

00:29:18 So, there are kind of different things you can do.

00:29:21 And that can be very helpful.

00:29:22 Right.

00:29:23 I forgot about that.

00:29:24 You have the reverse as well.

00:29:25 You can say, I want to make sure in this situation, it never, ever calls this other function.

00:29:29 Yeah.

00:29:30 Right.

00:29:31 Right.

00:29:31 Yeah, that's true.

00:29:32 That would be another good type of test.

00:29:34 Okay.

00:29:34 So, that's mocks.

00:29:36 And then we have spies, which is next level stuff.

00:29:39 Yeah.

00:29:40 Yeah.

00:29:40 I find them really hard to grasp.

00:29:42 So, I haven't used spies yet myself.

00:29:45 But from what I read, it's that spies are used to wrap real objects.

00:29:50 And by default, they route all the method calls to the original object.

00:29:54 So, they somewhat intercept and record all calls that are made to the real object.

00:30:01 Yeah.

00:30:01 Okay.

00:30:02 So, this sounds like you might want to do those verification things that I was talking about, but not actually change the implementation.

00:30:09 Just let it do what it's going to do.

00:30:11 But you can kind of record that all the stuff was interacted with in certain ways or something like that.

00:30:17 Yeah.

00:30:18 It's kind of, it's a bit similar to a mock in that sense that you can assert that certain things are called, but it does not replace the original object.

00:30:27 That's what mocks are doing.

00:30:29 Yeah.

00:30:29 One of the tricky things with a lot of these, and the more you use them, the more you have to deal with it is, well, they're going to call this function.

00:30:37 So, what are you going to return from them, right?

00:30:39 So, if they're going to ask, is admin, well, you have to say, if they call, is admin, return true or return false, right?

00:30:46 And so, you have to sort of, at the beginning of your test, you have to configure the mock to say, they're going to try to do these four things to you.

00:30:54 Here's the answer.

00:30:55 Here's the return value.

00:30:56 Throw an exception if they try that or something along those lines.

00:31:00 Exactly.

00:31:00 Yeah.

00:31:01 That said, I think it's, you know, there's certain types of errors you want to test for that are really tricky, right?

00:31:07 Like, I want to see a SQL operational error.

00:31:10 Like, hmm, how am I going to make it do that without talking to the real database?

00:31:16 Well, you could come up with a mock that just says, if they call connect, throw this exception right away, right?

00:31:21 Like, that would be a good example, I guess.

00:31:23 Definitely.

00:31:24 Okay.

00:31:24 So, we have this spectrum of mocks, the dummies, the spies, the fakes, and so on.

00:31:30 When should we use them?

00:31:31 So, you can use a mock.

00:31:33 Like, I'm not talking about a mock, not all of the other things, but I guess it depends on whether you want to all call them mocks or not.

00:31:42 But, yeah, you would use mocking whenever you don't actually want to call an object.

00:31:46 For example, when you have the spell class and you want to, or you have a function in that class that saves some version of the spell, for example, as a JSON file,

00:31:56 and you have a function remove, which deletes that file again.

00:32:00 Then when you test those methods, you don't actually want to write the file to disk every time the test runs.

00:32:07 And the same holds for functions that remove objects.

00:32:11 But that's just one example of many things that you, where you could use mocks when you don't actually want to do the operation that you're testing.

00:32:21 Yeah.

00:32:21 Basically, when any behavior of the system is in the way of you testing it, either that's you just don't want to call an API, or you just don't want to write to the file system, or something like that, right?

00:32:32 Yeah.

00:32:33 Yeah.

00:32:33 I guess the other one is, if you need to reach down inside the system and make it do something unexpected.

00:32:39 Like I said, if you want the connect call to throw a SQL exception, it's hard from the outside, potentially, to set it up in that way.

00:32:47 But with a mock, you can just say, if they call this function, throw this exception, see how the system deals with it, right?

00:32:52 Yeah, that's also a very good use case.

00:32:54 Yeah, I think testing errors, a lot of people don't test for errors.

00:32:58 I feel like they're like, okay, well, this is what it's supposed to do, so let's test that.

00:33:01 And I think testing for the opposite is almost as important.

00:33:05 Yeah, definitely.

00:33:06 I agree.

00:33:06 Yeah, yeah, yeah.

00:33:07 Cool.

00:33:09 So when I look at mocking, there's actually multiple ways to do mocks, and I honestly don't know when I should be using them.

00:33:16 Yeah, so there are three core functionalities in the unit test.mock library.

00:33:20 One is the class mock, one is the class magic mock, and then there is the patch function.

00:33:26 And those have different properties, but maybe we can just go through them one by one.

00:33:32 I think that's the easiest.

00:33:34 Yeah, yeah.

00:33:35 Well, if you think, okay, I'm going to mock something, you probably would start with the mock class, right?

00:33:38 That's where you think you would start.

00:33:40 Yeah, I think that's the best start.

00:33:41 So you can use the mock class to mock any object, where the mock object, so the class instance, just simulates the object it replaces.

00:33:52 And I love this, since it's also kind of magic, since the mock, to achieve this, to really simulate the object, it creates attributes on the fly.

00:34:01 So when you, let's say you import the unit test.mock library, and you create an instance of the mock class, and then you can just call some attribute on it.

00:34:11 Let's call it fancy attribute.

00:34:12 And it was just create a child mock and return it to you.

00:34:17 So it would create this fancy attribute on the fly.

00:34:20 The same holds for any kind of method, and you can call methods with different kinds of inputs, so you can just do whatever you want to do.

00:34:29 And I really like that.

00:34:30 I find that really fascinating.

00:34:32 Yeah, it's quite interesting.

00:34:33 And you don't have to do too much to set it up.

00:34:35 You don't have to anticipate everything that's going to happen to it.

00:34:38 You just create one, and if people think there's a function there, hey, guess what?

00:34:43 All of a sudden, there's a function there.

00:34:45 The only part where it gets tricky is where you have to make sure the function returns something so you don't get like, you know, none attribute doesn't have whatever type of errors.

00:34:53 Yeah.

00:34:54 Yeah.

00:34:54 It's really powerful, the mock class, but that also sometimes makes it dangerous to use, since you can really just call in everything on it.

00:35:04 And yeah, there's also some problems with it, but I guess we can talk about that separately.

00:35:10 Yeah, absolutely.

00:35:11 One of the challenges, I think, is, let's say you've got some kind of database class, and you're going to make calls on it.

00:35:19 It would be easy to create a mock and say, here's the mock database.

00:35:22 You call stuff on it.

00:35:24 It's just going to kind of go along with that.

00:35:26 The challenge is, how do you provide that through, right?

00:35:29 You know, I was talking about that crazy system that everything is passing every dependency everywhere abstractly, right?

00:35:36 In this world, you've got to find a way to get the mock down inside the system so that it'll use it in the right place.

00:35:42 Yeah.

00:35:43 And you have to configure it exactly like you want it to behave.

00:35:46 Right.

00:35:47 Right.

00:35:47 If they call this with these parameters, return this value, right?

00:35:51 Yeah, since that's also something I stumbled across in the beginning.

00:35:55 So let's say you create a mock object that mocks the JSON library.

00:35:59 So you would just have JSON equals mock, where mock is the class.

00:36:04 And then you could just call JSON.dumps and give it any kind of argument you want to.

00:36:10 But it's not the actual JSON.dumps method.

00:36:14 So it has nothing to do with that implementation.

00:36:16 And you could just give it any kind of input variables.

00:36:22 And that's a bit confusing, I think, at the beginning.

00:36:24 You have to understand that when you create a mock object and you haven't configured it yet,

00:36:29 it has nothing to do with original function or class you're replacing.

00:36:34 That's right.

00:36:35 And the dumps, that one's fine, right?

00:36:38 There's no problem.

00:36:38 You usually don't care in a test what happens.

00:36:41 But the reverse, the load, when it loads something, you've got to get something back to work with afterwards, right?

00:36:47 Exactly.

00:36:47 Yeah, that's tricky.

00:36:48 The other thing, though, that you can do with these mocks is you can set a side effect.

00:36:52 Yes.

00:36:53 Which I think is actually cool.

00:36:54 Yeah, you can set all kinds of things.

00:36:56 So you can set a return value.

00:36:58 We talked about that earlier.

00:36:59 But also the exceptions.

00:37:01 So when you, for example, want that a certain exception is thrown when you call the mock object, then you can just set a side effect.

00:37:10 That's a property of the mock class.

00:37:12 And then you can set it to any kind of exception you want.

00:37:16 Yeah, that's a really good way to test.

00:37:18 If this error happens at this function call, what are we going to do?

00:37:22 Yeah, it's great.

00:37:22 So we've got, that's the standard mock.

00:37:25 And when you call one of these functions, like you said, let's say JSON load us, it'll give you back something, probably, which is another mock.

00:37:34 But if you print it out, it'll just say that it's a mock of that.

00:37:38 And it has, you know, just be kind of useless, right?

00:37:41 Yeah.

00:37:41 So the next level up would be to bring in some magic.

00:37:45 Yeah.

00:37:45 So there is the second class called magic mock, which is actually subclass of the mock class.

00:37:52 But it contains all the magic methods pre-created and ready to use.

00:37:57 So, for example, if you want to compute the length of an object, then the magic mock could be very useful.

00:38:03 Since the dunder len, how do you call that in English?

00:38:08 Dunder len, I guess?

00:38:09 Len?

00:38:10 Yeah.

00:38:10 Let's call it dunder len.

00:38:12 It's already pre-implemented and ready to use.

00:38:16 Yeah.

00:38:16 Yeah, exactly.

00:38:17 So all the so-called magic methods, dunder stir, dunder len, dunder repper, all those things are there, right?

00:38:24 Yes.

00:38:24 And usually I use the mock class if I don't need magic methods.

00:38:29 And otherwise I use the magic mock.

00:38:32 But when you look, for example, a step further and you look at the patch method, that actually returns a magic mock.

00:38:38 So you're also fine using the magic mock, but it's then sometimes implementing things that you actually don't need.

00:38:44 Right, right.

00:38:45 Maybe that makes it a little bit slower.

00:38:47 I don't know.

00:38:47 I haven't tried, but possibly.

00:38:48 Yeah, that might be the case.

00:38:50 I also haven't tried it yet.

00:38:52 All right.

00:38:53 So the one that I end up using directly most often, it's got to be the patch.

00:38:59 Unit test.mock.patch, right?

00:39:01 This one is the, I'm not going to pass a bunch of things around, but just reach down inside this thing.

00:39:06 I know it's going to try to call this function or create one of these things.

00:39:09 Just make that at whatever level it's going to be down there.

00:39:12 Just make that work.

00:39:13 You know, make that go away or make it return this value instead and so on.

00:39:17 Yeah, I also mostly use the patch method and I like it because you can be very specific about what you want to actually patch.

00:39:23 So it's very easy to see from the patch statement where you're going in the code to change its behavior.

00:39:32 And I think I like this being most precise or as precise as possible with the mocking or the patching.

00:39:40 Yeah, and I feel like it doesn't force you into these design patterns like I described.

00:39:46 Like just explode in complexity and say, well, if you're going to have a dependency that you want to replace, you have to pass the dependencies around so you can pass the mock versions of them.

00:39:54 And that's fine when there's one, but then one thing requires two more, which requires four.

00:39:59 And it just explodes into like all this stuff, right?

00:40:02 And so with patch, you don't have to have the structure of every single possible dependencies passed everywhere it goes.

00:40:09 You can just say, if you see this function called or this object created deep down inside, do this instead.

00:40:16 Yeah.

00:40:16 So that's also actually what the patch function is doing.

00:40:19 So it looks up, you give it a path and it looks up the object in this given module and replaces that object with a magic mock.

00:40:27 So it's by default a new magic mock, but you can also configure this so you can create some class or then configure the patch statement such that it returns not a magic mock, but an instance of the class that you hand it.

00:40:42 Oh, interesting.

00:40:43 So you can say, I'm going to get like a little test double like sort of thing that I'm going to create.

00:40:48 And if I call this function, it has this little fake implementation or something and just say use that?

00:40:53 Yes.

00:40:54 So you don't have to use the magic mock.

00:40:56 Okay.

00:40:57 Yeah, that's pretty cool.

00:40:58 Actually, I didn't realize I could do that.

00:40:59 There's different ways you can use it.

00:41:01 It could be a decorator, context manager, other stuff, right?

00:41:04 Yeah.

00:41:04 So the syntax in general is that you have patch and then in brackets and as a string, you have package.module.target.

00:41:13 And there's a really nice example from one of the PyCon talks from Lisa Roach, I think.

00:41:19 It's called demystifying the patch function.

00:41:21 I really like that talk.

00:41:22 We can also link it in the show notes.

00:41:24 Yeah.

00:41:24 And yeah, so let's say you have an example file, which is called just example.py.

00:41:30 And you have one import statement from db, import dbwrite.

00:41:34 So you want to write to some database.

00:41:36 And then you have a single function, which is called foo or whatever you want to call it.

00:41:41 And it just calls dbwrite and returns the return value that you get from dbwrite.

00:41:47 I like this example because it's so simple, but it actually uncovers some tricky bits.

00:41:52 Yeah, it brings the point across very well.

00:41:55 And it's so easy to understand since you don't actually have to care about how dbwrite is implemented,

00:42:00 but you know it writes to database and that's something that you don't want to do in the test.

00:42:04 Yeah, exactly.

00:42:05 Yeah.

00:42:06 So we, in this case, we would want to patch or mock the dbwrite call.

00:42:12 And you can do that with a decorator.

00:42:14 You can do that with context manager or with manual starting and stopping.

00:42:18 And which one you use would depend on the scope.

00:42:22 So how the scope looks like that you want the object to be patched in.

00:42:27 Yeah.

00:42:28 So it seems like there's a couple of ways that are pretty straightforward, kind of comparable.

00:42:32 You could do a decorator and say on your test function, put the decorator, say patch this,

00:42:37 this object or this function call.

00:42:39 Or you could do a context manager inside your test function.

00:42:41 And I guess it really depends on how many things are you patching, how complicated is it to set up some of the stuff and so on.

00:42:49 But they seem pretty comparable, those two.

00:42:51 And the other is I could turn it on and turn it off.

00:42:54 But this is a system-wide change of what that function means.

00:42:58 And so if for some reason the test fails and you don't have a try finally to turn it off or something like that, it's going to be bad because it'll permanently change what that function means, which maybe you only wanted it for a few.

00:43:09 Yeah.

00:43:10 But I guess the scenario I see that you might want to do it is like test set up and test tear down.

00:43:14 Like for this whole class, we're going to just set it up and no one has to worry about it.

00:43:18 You just write all the tests.

00:43:19 So maybe that's the turn it on, turn it off scenario.

00:43:22 Yeah, I think that was also the scenario where I've seen it.

00:43:26 Since then it can be useful.

00:43:28 Otherwise, you would always have to apply the patch decorator again or use it to context manager in each test.

00:43:34 And that looks very messy.

00:43:35 And if you can just do it centrally in a single place, that's, I think, the nicest solution.

00:43:41 Yeah, and it can get super complicated about setting these things up because first you're going to call this and it needs to return that value.

00:43:47 But if it gets called with other value, then return the, like there's a lot of stuff that can get done on these.

00:43:52 And it's, you know, maybe simple for one.

00:43:54 But if you have three or four of them, all of a sudden, like there's a lot of setup to do a little test.

00:43:59 Yeah.

00:43:59 And it can also become messy to have all these patch statements stacked on top of each other.

00:44:05 I think two or three are maybe fine, but then it becomes really messy.

00:44:10 Yeah.

00:44:11 Yeah, absolutely.

00:44:12 So I guess I'm starting to come around to the idea of having it just set up in the test setup or maybe a test fixture in pytest or something like that.

00:44:21 Yeah, that's also a nice way.

00:44:22 Yeah.

00:44:23 Another thing that I think is interesting about this example is it seems so simple, but you have to be a little bit aware of how those functions are being used internally.

00:44:33 Right.

00:44:33 So the import statement in the example that you talked about says from DB import DB write.

00:44:39 And you have to explicitly say in a string the full like namespace style name of the thing that it's going to patch.

00:44:46 So in this example, you would say example dot DB write.

00:44:50 And if you get it wrong, it crashes.

00:44:52 Right.

00:44:52 Yeah, I think that's what most people find confusing in the beginning.

00:44:57 But I think it's great because you start to understand what it means if you import something and what is happening in the program.

00:45:06 And I found it very helpful to just inspect then the module and what kind of attributes it has.

00:45:15 So it is important to know that you have to patch where the object is looked up.

00:45:20 And this might not be the place where it is defined.

00:45:22 So if we have this DB write example where you have the from DB import DB write statement in the file example dot pi, then you are importing the DB write function from the DB module.

00:45:37 So the consequence is that the example module now knows about the DB write method, but it does not know about DB.

00:45:45 So if you patch it, but I think it's nice that you can see that actually.

00:45:51 So if you open an IPython shell and you import this example module, then you can call directory.

00:45:58 So dear, dir.

00:45:59 Yeah.

00:46:00 How do you pronounce that?

00:46:01 I would say dir, but I could be wrong.

00:46:04 Yeah.

00:46:04 Dir.

00:46:04 Okay.

00:46:05 I will trust you on that.

00:46:07 So you would call dir example, and then you would see a list of the attributes for this example module.

00:46:13 And there you will see DB write and foo, but you won't see DB.

00:46:17 So therefore, to mock the call to the DB write function in the test, you would have to patch example dot DB write.

00:46:26 Right.

00:46:27 And it's tricky because conceptually, what you think you're patching is the DB write thing out of the DB module.

00:46:36 So my first thought was, well, that should probably be just DB dot write, but that doesn't work in this case.

00:46:42 Yeah.

00:46:42 But what's interesting is if they had said import DB, and then in the implementation of foo, they said DB dot DB write, then it would work.

00:46:51 And actually, this example where you say example dot DB write, patch that, it would crash and say, well, that thing doesn't have this function, so we can't patch it.

00:46:59 And so you have to be a little bit aware of how these are written.

00:47:03 And like you said, where they're defined, it does take a little bit of awareness.

00:47:06 So I think you can look with dir, which is great.

00:47:09 You just also have to just be a little bit aware of what's going on there.

00:47:12 Yeah, I think once you wrap your head around it, then it's easy.

00:47:16 Once you understand the basic idea and you have used it a few times, then it would become natural or much easier to understand which patch statement you have to use.

00:47:27 Yeah, I think we can look at another example where you would not import from DB import DB write, but you would just import the DB module.

00:47:36 And then the foo function would call DB dot DB write instead of just DB write.

00:47:42 And now the example module knows about DB, but not DB write.

00:47:48 So again, if you would call dir on example, you would get DB and foo in the namespace, but you would not have DB write.

00:47:57 So now when you patch it, you would either have to use example dot DB dot DB write or just DB dot DB write.

00:48:05 And yeah, it can be a bit confusing, but I think that's also the hardest thing to understand.

00:48:13 And once you get that, then you have the most important idea.

00:48:17 Right.

00:48:17 Once you understand it, it's not too bad, I think.

00:48:20 But it does.

00:48:20 You do have to put some ideas together to figure out what to put there.

00:48:24 Yeah.

00:48:25 One of the challenges, I think, of the more that you kind of reach inside of things and you make these changes, like we're saying here, your testing can become a little bit harder to maintain.

00:48:36 So, for example, suppose we have the first scenario where they had the from DB import DB write.

00:48:40 Everything was fine.

00:48:41 And then somebody decides we're going to refactor the code to be more explicit and use the namespaces.

00:48:47 And then they go change the example pi to use the different types of imports and rewrite the functions to say DB dot DB write versus just the function call.

00:48:55 All of a sudden, your test doesn't work anymore.

00:48:57 You're like, what is going on here?

00:48:59 And that's just the nature of this mocking stuff.

00:49:01 Like, as you reach inside to make these changes, you're now somewhat dependent on the structure of the inside.

00:49:08 Yeah.

00:49:08 Yeah.

00:49:09 You always have to keep that in mind when you adapt the code.

00:49:11 Yeah.

00:49:12 So, I guess maybe try to do as little as possible.

00:49:15 I mean, sometimes you have to do it to not talk to Google Cloud or not to charge the credit card for real.

00:49:21 But, you know, don't if you can avoid it, do so maybe.

00:49:25 I don't know, because it's just one more dependency, right?

00:49:27 Yes.

00:49:28 Well, what about using mock versus patch?

00:49:31 So, I don't think there are any clear rules.

00:49:34 At least I have not come across any clear rules.

00:49:37 I guess that's similar to the whole topic that it's somewhat controversial.

00:49:43 But personally, I mostly use patch, just as you just said.

00:49:47 I like it since it's so specific, and I rarely use mock.

00:49:51 And I don't think I ever use magic mock specifically.

00:49:54 So, I use mock if we have this dependency injection we talked about in the very beginning.

00:50:00 For example, if you have a client, and I use clients to interact with Google Cloud,

00:50:07 and then I can just, instead of passing in the client, I can just pass in a mock object.

00:50:13 But in all the other cases, I use the patch function.

00:50:18 Yeah, I would totally, 100% agree with that.

00:50:21 And I think in Python, this place where you pass in all of your dependencies,

00:50:27 it's less common than other languages.

00:50:29 So, I think that naturally makes patch a little more common.

00:50:32 Yeah, that might be the reason.

00:50:34 Yeah, which is generally a good thing.

00:50:36 Also, I think some other languages, it's very hard for them to do this idea of patching.

00:50:41 So, they have to pass all their stuff around.

00:50:43 So, we've talked a little bit about some of the challenges.

00:50:48 And like, if the import statement's like this, you got to mirror that in the way that you write your patch statement.

00:50:53 And if it changes, that changes.

00:50:55 But there's also some other common problems and some things to keep in mind.

00:50:59 You want to run us through those?

00:51:01 Yeah, sure.

00:51:01 So, we saw that we can configure mock objects.

00:51:04 So, we can set the return value, side effects like exceptions and so on.

00:51:09 And the fact that the mock objects create attributes and methods on the fly makes them very sensitive to mistakes.

00:51:16 So, a typical example is that you misspell something.

00:51:20 So, for example, you can call assert called once on a patch or mocked object.

00:51:28 And you could just have a spelling mistake there.

00:51:31 For example, you could have assert called once with a single S instead of assert called once.

00:51:36 But the test will just pass.

00:51:38 It won't raise an assertion error because you just created a new method on the mock object that is called assert called once instead of calling the actual function.

00:51:48 Yeah, and this is really tricky because the successful behavior is exactly the same as just calling a function that doesn't exist.

00:51:55 It's just do nothing.

00:51:56 It's fine.

00:51:57 But the verification won't happen, right?

00:52:00 Because only the verification will happen if you actually call the right one.

00:52:03 Yeah.

00:52:04 I think also a typical problem is that a mock object does not know the interface of your class.

00:52:10 That's also what I tried to explain earlier, that you have to understand that the mock object actually has nothing to do with the class that it replaces.

00:52:19 But you have to configure it to behave like your class.

00:52:23 So, let's say going back to the spell class, when we called dir on the mocked object, then you can see all the kinds of attributes.

00:52:34 So, maybe like if you have IPython open again and you would import the spell class, you would import the patch function from unit test.mock.

00:52:43 And then you can just look at the attributes of a mocked spell instance by calling with patch and then spell class.spell as mocked spell.

00:52:52 That would just be the name of this mocked object.

00:52:55 And then you could print the call of dir on the mocked spell object.

00:53:00 And then you would see all these different things that you can use.

00:53:03 Assert any call, assert call once, assert call once with, and so on.

00:53:08 But you would actually...

00:53:09 Yeah, but none of them have anything to do with spell.

00:53:11 Yes.

00:53:14 So, you wouldn't see all the methods that are included in the spell class, like save, remove, or cast.

00:53:21 Of course, you have to cast a spell.

00:53:23 Be able to cast a spell.

00:53:24 And that can be quite tricky, since it can lead to behavior that you don't want.

00:53:31 So, the magic mocked object that's returned by the patch call, which is completely unrelated to the spell class.

00:53:38 Yeah.

00:53:39 And that's really tricky.

00:53:40 So, I've seen spec equals true in various testing things.

00:53:44 And I didn't, until just now, really put together what that actually did.

00:53:48 So, you can sort of fix that sometimes.

00:53:51 Yes.

00:53:52 So, some of the problems can be solved, at least those with the spelling mistakes,

00:53:56 and also that you want your class to somewhat look like the...

00:54:00 Or you want your mock to look somewhat like the class that it's replacing.

00:54:05 You can use the spec equals true attribute in the patch call.

00:54:09 And this will cause the magic mock to look like the object that is being patched.

00:54:14 So, it would cause this misspelled assert call once to raise an exception.

00:54:19 And also, you can only call methods with the correct arguments.

00:54:24 And you can only call methods that actually exist in the class.

00:54:28 Yeah, exactly.

00:54:29 So, one of the problems with these mocks could be, inside a function, you're calling something on what you think is the real spell or the data access layer or whatever.

00:54:40 And you're calling a function that doesn't exist or you misspelled it.

00:54:43 And all of your tests pass because the mock is like, fine.

00:54:48 We'll just...

00:54:50 You called a function that didn't exist, just like all the others.

00:54:52 So, we're just going to return a mock object there.

00:54:55 But in production, when it really goes to run and it gets a real thing that has no method there,

00:55:00 it's going to crash.

00:55:01 So, with the spec equals true, you can be a little more restrictive and catch some of those errors as well, maybe.

00:55:07 Yeah.

00:55:08 What I find in the beginning when I saw spec equals true, I thought, oh, this is great.

00:55:12 Then I just have exactly the thing I'm patching.

00:55:16 But it turns out, yeah, almost, that all the attributes you create in the constructor,

00:55:22 so in the Dunder init call, are not contained in the mocked class in the end.

00:55:27 So, that's due to the internal workings of spec and auto spec.

00:55:31 And I think there's also spec set.

00:55:34 I'm not sure how it works.

00:55:35 But when you use that in the end, your mock object does not know about any of this dynamically created attributes.

00:55:44 Yeah, really, the only way it would know is either if it disassembled the constructor,

00:55:49 which would be kind of weird, or if it actually called the constructor.

00:55:53 And those constructors could have side effects like creating files or trying to open a database or whatever, right?

00:55:58 So, it can't really do those.

00:56:00 So, it can't see them.

00:56:02 I guess if you really wanted it to work exactly in that way, you could put all the field definitions as type level, as class level stuff,

00:56:11 and then just set them, right?

00:56:13 That's not as common in Python.

00:56:14 Sometimes it is, sometimes it isn't.

00:56:16 But that would be the way to fix it, I guess.

00:56:18 Yeah.

00:56:19 So, yeah, spec and spec set, like auto spec, spec set, spec, they can be used to solve some of these problems.

00:56:26 But you should be aware that they also create problems that you might not be aware of in the beginning.

00:56:32 And also, I think it will slow down testing.

00:56:36 I have not noticed that really, that it slows them down a lot.

00:56:40 But I guess it depends on how much you actually use this functionality.

00:56:43 Yeah, yeah, for sure.

00:56:44 How much are you doing computationally in your test versus just a whole bunch of creation of mocks to just call one little function?

00:56:51 Yeah.

00:56:51 I also like besides spec and auto spec and all these other things, there is so much more that you can do with patching and mocking.

00:57:00 And it's a huge topic.

00:57:02 I guess you can have a whole another podcast about how to prevent mocking or how not to get into mock hell.

00:57:10 There's also PyCon talk on this.

00:57:11 It's just, yeah, it's a huge topic.

00:57:14 Yeah, I can definitely see being a mock hell.

00:57:17 I've been on both sides of it.

00:57:18 And I think Python has a pretty good middle ground with the ability to patch stuff and not completely rewrite your code to deal with it.

00:57:25 Yeah, it's pretty nice.

00:57:27 Yeah, I also like using it.

00:57:28 Yeah, cool.

00:57:29 All right.

00:57:30 Well, maybe you want to do a quick wrap up, just summarize all that before we wrap things up?

00:57:35 Yes, sure.

00:57:35 So I guess we learned that mocking is controversial.

00:57:39 And that it should be used with care, not to just fix your badly written code.

00:57:44 There are a few ways in which you can design your code such that you don't need patching all the time,

00:57:51 like the dependency injection we talked about, where you pass in a mock to client, as an example.

00:57:58 Yeah.

00:57:59 Oh, yeah.

00:57:59 And we talked about these different naming conventions that you should not get confused by them.

00:58:03 And maybe if you think it's unnecessarily complicated, then just don't use them.

00:58:09 That's also fine.

00:58:10 There are people on both sides of the spectrum.

00:58:12 Yeah, I've always found that the distinction, trying to be very precise about, oh, no, this is a mock and this is a fake and this is a stub.

00:58:20 It doesn't necessarily help you, but it just makes things a little bit messy.

00:58:24 Like, you know what you're trying to do?

00:58:26 To me, the big distinction is, are you just trying to stop something from being called and maybe just return a value or create a side effect versus are you trying to understand what functions have been called?

00:58:38 Like, I want to make sure they always, always call, you know, check for admin or something like that.

00:58:43 Right.

00:58:43 Like, that to me is a big distinction.

00:58:44 Are you trying to observe the behavior or just the outcome?

00:58:47 Yeah, I agree.

00:58:48 It's also because there are no clear cut definitions.

00:58:51 It's all a bit blurry.

00:58:53 And the definitions are, in some cases, similar.

00:58:56 So, it can be really hard to tear them apart and understand what each one is about.

00:59:02 Yeah.

00:59:03 So, we also talked about the library, the mocking library, unit test.mock, and the three core functionalities, mock, magic, mock, and patch.

00:59:10 And mocking can be or seem confusing in the beginning.

00:59:14 But once you understand the basics, for example, that you have to patch where something is used, which might not be where it's defined, then it can be really helpful, especially with production code.

00:59:26 And I see that every day.

00:59:27 Yeah.

00:59:27 Awesome.

00:59:28 Well, this is definitely a very powerful tool in the testing tool set.

00:59:33 And it can make testing possible where it was impossible or much easier where it was previously really, really hard.

00:59:39 So, hopefully, this helps people write more testable code and test more of their code.

00:59:44 Yeah.

00:59:44 And maybe at least motivate them to look into what mocking is and maybe see that they can use it as well.

00:59:52 Absolutely.

00:59:53 All right.

00:59:53 Before we call the show, you're going to write some Python code, mock out some libraries,

00:59:57 what editor do you use?

00:59:58 I still use Vim.

01:00:00 Like, I think I will use it the rest of my life.

01:00:03 It's hard to get away from it.

01:00:05 All of my colleagues use PyCharm now, or most of them.

01:00:08 But yeah, I will still continue using Vim.

01:00:11 Awesome.

01:00:12 And the notable PyPI package or library?

01:00:14 Yeah, I guess I have to say unit test.mock.

01:00:17 But one thing I really like is that I was always using the IPython debugger for debugging.

01:00:24 But a few, like a month back, I switched to PDB++.

01:00:29 Yeah.

01:00:30 We can also link that in the show notes if people don't know it yet.

01:00:33 And what I really like it.

01:00:34 So, it's very easy to install.

01:00:36 It just wraps around the standard PDB debugger.

01:00:40 And it has a few nice features.

01:00:42 I mostly love the sticky command.

01:00:44 And when you...

01:00:46 So, you enter the debugger and you type sticky.

01:00:48 And then you will...

01:00:50 While you're debugging, you will see the code command stick to the top of the screen.

01:00:56 And you can really see where you are in your code, stepping through the lines one by one.

01:01:00 And I find that very helpful when debugging.

01:01:03 Yeah, that's cool.

01:01:04 It's like a little bit of a blend between a GUI debugger and a command line style debugger.

01:01:10 Yeah.

01:01:11 Yeah, yeah.

01:01:11 Very good.

01:01:12 I don't think I've heard of that one.

01:01:13 That's excellent.

01:01:13 Thanks.

01:01:14 All right.

01:01:14 Final call to action.

01:01:15 People trying to write some tests.

01:01:17 They want to get out there.

01:01:17 They want to use mocking.

01:01:18 What do they do?

01:01:19 I think a good start is the documentation.

01:01:21 I think it's a very comprehensive one.

01:01:25 There's also a real Python...

01:01:28 How do you call it?

01:01:28 Blog post on the topic.

01:01:30 Yeah.

01:01:30 I think those two places are good to start.

01:01:34 I just...

01:01:35 In general, I like the Python documentation.

01:01:36 I always...

01:01:37 In most cases, it's just the best source.

01:01:40 Yeah.

01:01:40 Awesome.

01:01:41 All right.

01:01:42 Well, thanks again for being on the show and diving into the nuances and all the different

01:01:46 names in the mocking world.

01:01:48 It's been fun.

01:01:48 Yeah.

01:01:49 Thanks for having me.

01:01:50 It was fun.

01:01:50 Yeah.

01:01:50 It's great to have you back.

01:01:51 Bye.

01:01:52 Bye.

01:01:53 This has been another episode of Talk Python To Me.

01:01:56 Our guest in this episode was Annalena Popkes.

01:01:59 And it's been brought to you by Linode and Monday.com.

01:02:02 Start your next Python project on Linode's state-of-the-art cloud service.

01:02:07 Just visit talkpython.fm/Linode.

01:02:09 L-I-N-O-D-E.

01:02:11 You'll automatically get a $20 credit when you create a new account.

01:02:14 Build your idea for an app and get it in front of hundreds of thousands of users on day one.

01:02:19 Start building today at the Monday.com marketplace by visiting Monday.com slash Python.

01:02:25 Want to level up your Python?

01:02:27 If you're just getting started, try my Python Jumpstart by Building 10 Apps course.

01:02:32 Or if you're looking for something more advanced, check out our new async course that digs into

01:02:37 all the different types of async programming you can do in Python.

01:02:40 And of course, if you're interested in more than one of these, be sure to check out our

01:02:44 Everything Bundle.

01:02:45 It's like a subscription that never expires.

01:02:47 Be sure to subscribe to the show.

01:02:49 Open your favorite podcatcher and search for Python.

01:02:51 We should be right at the top.

01:02:52 You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:02:57 and the direct RSS feed at /rss on talkpython.fm.

01:03:01 This is your host, Michael Kennedy.

01:03:03 Thanks so much for listening.

01:03:05 I really appreciate it.

01:03:06 Now get out there and write some Python code.

01:03:08 I'll see you next time.

