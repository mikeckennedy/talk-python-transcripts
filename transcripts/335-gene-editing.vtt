WEBVTT

00:00:00.001 --> 00:00:04.280
Gene therapy holds the promise to permanently cure diseases that have been considered

00:00:04.280 --> 00:00:09.940
lifelong challenges, but the complexity of rewriting DNA is truly huge and lives in its

00:00:09.940 --> 00:00:15.320
own special kind of big data world. On this episode, you'll meet David Born, a computational

00:00:15.320 --> 00:00:20.540
biologist who uses Python to help automate genetics research and helps move that work

00:00:20.540 --> 00:00:27.320
to production. This is Talk Python to Me, episode 335, recorded September 15th, 2021.

00:00:27.320 --> 00:00:44.980
Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:44.980 --> 00:00:49.620
Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes

00:00:49.620 --> 00:00:56.020
at talkpython.fm and follow the show on Twitter via at talkpython. We've started streaming most

00:00:56.020 --> 00:01:00.920
of our episodes live on YouTube. Subscribe to our YouTube channel over at talkpython.fm

00:01:00.920 --> 00:01:07.060
slash YouTube to get notified about upcoming shows and be part of that episode. This episode

00:01:07.060 --> 00:01:12.260
is brought to you by Shortcut, formerly known as clubhouse.io, and us over at Talk Python

00:01:12.260 --> 00:01:18.140
Training. And the transcripts are brought to you by Assembly AI. David, welcome to Talk Python

00:01:18.140 --> 00:01:18.360
to Me.

00:01:18.360 --> 00:01:19.780
Thanks, Michael. It's great to be here.

00:01:19.780 --> 00:01:24.540
Yeah, it's great to have you here. One of the things I really love to explore is the

00:01:24.720 --> 00:01:30.280
somewhat non-traditional use cases of Python that are not straight down the, I'm building

00:01:30.280 --> 00:01:35.480
an API and something that talks to a database or a startup, right? Something like that, but

00:01:35.480 --> 00:01:41.880
blending it with other technologies and science and whatnot and genetics plus Python, it's going

00:01:41.880 --> 00:01:42.380
to be interesting.

00:01:42.380 --> 00:01:43.180
It sure is.

00:01:43.180 --> 00:01:48.220
When you got into this, did you start out on the biology side or the programming side of

00:01:48.220 --> 00:01:48.520
the world?

00:01:48.520 --> 00:01:53.580
I definitely started out on the biology side. Yeah. So I went all the way through grad school

00:01:53.580 --> 00:01:57.060
with relatively minimal formal programming experience.

00:01:57.060 --> 00:02:03.040
Yeah. Okay. So you studied biology and genetics and whatnot. And then how'd you end up here

00:02:03.040 --> 00:02:04.340
on a Python podcast?

00:02:04.340 --> 00:02:09.540
Yeah. So I always thought that programming would be cool, but I didn't really have much of an

00:02:09.540 --> 00:02:15.800
opportunity through my undergraduate studies to really do much formal programming. I took our one

00:02:15.800 --> 00:02:21.340
computer science class that my college had to offer. It was in C++. I think I wrote a Boggle program,

00:02:21.340 --> 00:02:26.220
something with some recursion in there. It was pretty fun. Didn't really get to use Python until

00:02:26.220 --> 00:02:33.260
graduate school. I was in a genetics course and we were basically tasked with doing some data analysis

00:02:33.260 --> 00:02:38.920
on published data and then reproducing some plots in a figure, then extending it further.

00:02:38.920 --> 00:02:45.160
My partner and I decided to learn Python, teach it to ourselves so that we could do this. We heard that

00:02:45.160 --> 00:02:52.160
it was a good way to do data analysis in biology. And so we basically taught it to ourselves and we used

00:02:52.160 --> 00:03:00.380
NumPy, some basic string searching and things to redo this analysis. And it was really amazing what we could

00:03:00.380 --> 00:03:02.540
do with Python for that civil project.

00:03:02.540 --> 00:03:06.780
That's awesome. How'd the learning project go? Like coming from not having a ton of programming,

00:03:06.780 --> 00:03:08.480
what was your experience like?

00:03:08.600 --> 00:03:13.320
It was relatively easy. I would say I think my brain sort of fits pretty well with how

00:03:13.320 --> 00:03:18.600
programming languages work, but it was definitely a lot in a short amount of time to really dive into

00:03:18.600 --> 00:03:24.480
how to make sure your while loops don't stay open. And then someone tells you maybe you shouldn't use

00:03:24.480 --> 00:03:28.860
a while loop at all. I was learning a lot of things not to do right away.

00:03:28.860 --> 00:03:33.440
Yeah, of course. But you had to get all the analysis done, right? So you got to solve all the problems

00:03:33.440 --> 00:03:34.020
and power through.

00:03:34.020 --> 00:03:40.180
Yeah, we did. We got our analysis done there and we got some, we reproduced some plots and got some

00:03:40.180 --> 00:03:45.660
new analysis made. And I think we really just, I really came to appreciation of how much you can do

00:03:45.660 --> 00:03:49.960
in a short amount of time with just a little bit of coding knowledge or essentially none.

00:03:49.960 --> 00:03:54.820
Yeah. I think that's really an important takeaway that a lot of people, you know, maybe many people

00:03:54.820 --> 00:03:59.960
listen to podcasts already kind of know, but I think looking in from the outside, it feels like,

00:03:59.960 --> 00:04:06.280
oh, I've got to, you know, go get a degree in this to be productive or useful. And really what you need

00:04:06.280 --> 00:04:10.280
is like a couple of weeks and a small problem and you're already already there.

00:04:10.280 --> 00:04:15.100
Absolutely. Yeah. I've all, I've definitely found that just learning through, through doing has been

00:04:15.100 --> 00:04:20.380
the way I've, I've worked entirely. I have essentially no formal programming training, no,

00:04:20.380 --> 00:04:22.900
no coursework and I'm using Python every day.

00:04:23.120 --> 00:04:27.000
Yeah. That's fantastic. Yeah. I didn't take that much computer science and college either. Just

00:04:27.000 --> 00:04:32.920
enough to do the extra stuff from my math degree. Very cool. All right. Now how about today? You're

00:04:32.920 --> 00:04:37.320
working at Beam Therapeutics doing genetic stuff. Tell us about what you do day to day.

00:04:37.320 --> 00:04:44.420
Yeah. So I'm on the computational sciences team at Beam Therapeutics. We're a gene editing company. So

00:04:44.420 --> 00:04:50.980
we develop these precision genetic medicines that are, we're trying to develop them to cure genetic

00:04:50.980 --> 00:04:56.520
diseases that are caused by single genetic changes in the genome.

00:04:56.520 --> 00:04:59.180
Like a point shift mutation or something like that.

00:04:59.180 --> 00:05:06.200
Yep. Yep. And so if you have one of these genetic changes, you might have a disease that is lifelong

00:05:06.200 --> 00:05:12.360
and there aren't any cures for most of these diseases. So we're trying to create these, we call

00:05:12.360 --> 00:05:18.500
them hopefully lifelong cures for patients by changing the genetic code back to what it should be.

00:05:18.500 --> 00:05:24.180
That's incredible. It seems really out of the future. I mean, it's, I think it's one thing to

00:05:24.180 --> 00:05:31.280
understand genetics at play and it's even amazing to be able to read the gene sequences, but it's

00:05:31.280 --> 00:05:34.440
entirely another thing I think to say, and let's rewrite that.

00:05:34.440 --> 00:05:41.220
Yeah. We're definitely at the cutting edge of a lot of biotechnology and science that has really come

00:05:41.220 --> 00:05:54.000
to have had in the last decade with the, with CRISPR and technologies that use CRISPR, which ours do be able to precisely target genetic sequences. It's a really fascinating place to work and it's a privilege.

00:05:54.000 --> 00:06:10.680
I bet a lot of people go to work and they end up writing what you might classify as forms over data. It's like, well, I need a view into this bit of our database or I need to make, be able to run a query to just see who's got the most sales this week or, you know, something like that.

00:06:10.680 --> 00:06:20.880
And that's important work and it's, it's useful and there's cool design patterns and whatnot you can focus on, but it's also, it's not like what people dream of necessarily building when they wake up.

00:06:21.000 --> 00:06:39.280
But this kind of science, like maybe so, right? Like these are the really interesting problems that both have a positive outcome, right? You're helping cure disease, not just, you know, shave another one, one hundredth of a percent off of a transaction that you get to keep or, you know, something like that. Right. From like in finance.

00:06:39.280 --> 00:06:39.620
Yeah.

00:06:39.620 --> 00:06:42.600
You get to use really cool tech to do it too, like programming wise.

00:06:42.600 --> 00:07:09.780
Yeah. I mean, one of our dreams that we joke about on the computational team is that like it's conceivable one day we could, you know, say like, Hey Alexa, how do we cure sickle cell disease? And it'll tell you what parts of our technology we should put together to cure that disease. That's sort of like the pipe dream of, of where we could go if we combine all our data in the right ways. And I think all of the stuff we'll talk about today is really just laying out the framework for that.

00:07:09.780 --> 00:07:14.800
Yeah, absolutely. So you mentioned CRISPR. Maybe tell people a bit about that biotechnology.

00:07:14.800 --> 00:07:38.200
Yeah. So CRISPR is molecular machine, which a lot, which targets a very specific place in a specific genetic sequence. And so usually people are using CRISPR to target a specific place in the genome, a specific sequence. And what CRISPR does naturally is to cut at that sequence.

00:07:38.200 --> 00:08:00.200
So it'll cut in a very specific place in the genome. And as people were using CRISPR, we could actually decide where it's going to cut by giving it a different targeting sequence. This sort of like directed molecular machine is a basis of a whole new field of biotechnology using CRISPR and CRISPR derived technology.

00:08:00.200 --> 00:08:15.920
So our technology is like kind of a CRISPR 2.0 where we don't use CRISPR to cut. We use the localization machinery and we add onto it another protein, which just changes a base instead of cutting the DNA itself.

00:08:16.140 --> 00:08:20.620
So it's slight variation, but it's still using this same CRISPR technology.

00:08:20.620 --> 00:08:46.940
Okay. So let me see if my not very knowledge filled background understand here is kind of a, has a decent analogy. So does it work basically like you give it like almost like find and replace, like you give it a sequence of pairs and it says, okay, if I find a TTCAT, like enough specificity and that it's like, that's the unique one. And then it does like cut at that point. Is that kind of how it works?

00:08:46.940 --> 00:09:00.860
Yep. It's pretty much just like that. We give it the sequence you want to target. And then if it finds that sequence in the genome, it will cut the genetic material, the DNA at that position for normal CRISPR.

00:09:00.860 --> 00:09:14.780
When you're coming up with these and you say, we're going to rewrite the DNA to solve this problem. How do you do it on a large enough scale? Right. Like how do you, I mean, how much of the body has to be changed for this to be kind of, to be permanent, right?

00:09:14.780 --> 00:09:41.120
Right. It's definitely a tricky question. I think we are, we definitely leverage human biology, how the human body works for a lot of these problems. For example, our, some of our leading drug candidates are for sickle cell disease. And because of the way sickle cell disease manifests in red blood cells and red blood cells are created through a set of, through, there's a specific type of cell that creates red blood cells.

00:09:41.120 --> 00:09:54.820
And we can, if you access that type of cell and you cure, cure a sickle cell in these progenitor cells, the stem cells, then you can create all red blood cells from a cured population.

00:09:54.820 --> 00:10:13.260
So if you can target it to the regenerative cells, you can cure sickle cell throughout the body essentially, because the symptoms are from red blood cells. There's a lot of diseases that, which by curing a single organ, you can cure the symptoms of the disease because that's where it actually manifests.

00:10:13.520 --> 00:10:17.000
Right. Like, like, like diabetes or sickle cell anemia or something like that?

00:10:17.000 --> 00:10:27.000
Yeah. Like sickle cell diseases in the liver, like some blindnesses in the eye. By just targeting specifically where the symptoms occur, you can cure the disease.

00:10:27.000 --> 00:10:32.520
Yeah. That's amazing. Is it a shot? Is it a blood transfusion or like, how do you deliver this stuff?

00:10:32.520 --> 00:10:41.560
Yeah. Delivery is a huge place of research and it definitely depends on the type of targeting we're doing. So for something in the eye, it would probably be an injection.

00:10:41.560 --> 00:10:54.220
For something in the blood, it's slightly more complicated and it's not an injection. For something in the liver, it would probably be more akin to a injection or dosing regimen.

00:10:54.220 --> 00:11:22.980
Okay. It sounds really fascinating. Like I said, it feels like it's a little bit out of the future to be able to come up with these and just say, no, we're just going to rewrite this little bit of the genetics and I think it'll be good. But if you can make it happen, it's pretty clear how it's obviously a benefit, right? Like those progenitor cells, they eventually have to recreate new ones. And then the way they do that is they clone their, their current copy of the DNA, which is the fixed one, right? So if you can get enough of them going, it'll just sort of propagate from there.

00:11:22.980 --> 00:11:31.560
Yep. And we're also the benefit that sometimes you only need to cure a small fraction to remove the symptom. So lots of things going for us.

00:11:31.560 --> 00:11:39.740
That's awesome. So I'm sure there's a lot of people involved in this type of work. What exactly are you and your team working on?

00:11:39.740 --> 00:12:07.360
Yeah. So our team, we call ourselves the computational sciences team. We really sit in the, in the middle of the research and development arm of the organization, processing all of our sequencing data and some other data as well. And as you can imagine, with our technology changing DNA, changing genomes, there's a lot of sequencing data because what we're trying to do is change a genetic sequence.

00:12:07.360 --> 00:12:14.620
So we have to read out that genetic sequence and then figure out has it changed, how many copies are changed and things like that.

00:12:14.620 --> 00:12:14.840
Yeah.

00:12:14.840 --> 00:12:14.860
Yeah.

00:12:14.860 --> 00:12:36.880
The field of the techniques of next generation sequencing NGS are pretty broad. And we deal with a lot of different types of these next generation sequencing assays that are being done at the end. Our team really processes, analyzes, and collaborates with the experimental scientists on performing and developing these experiments.

00:12:36.880 --> 00:12:50.020
Cool. So the scientists will do some work and they'll attempt to use CRISPR-like technology to make changes. And then they measure the changes that they've made. And it's, you all sort of take that data and compare it and work with it.

00:12:50.020 --> 00:13:03.740
Right. Yeah. The act of measuring the changes itself is relatively computationally intensive. So we run and support pipelines for all of these standard assays as well, which is, is part of our, our job.

00:13:03.740 --> 00:13:20.660
How much data is in DNA? I mean, I know that human biology stores or just biology stores an insane amount of data, but also computers store an insane amount of data and processing. So I'm not sure like which, where the sort of trade-off is, but what sort of data are we talking about? How much?

00:13:20.660 --> 00:13:39.000
Yeah. I mean, it definitely depends on the type of assay that we're doing, like the scale of the data. I would say usually we're not looking, sometimes we're looking at things that are looking at all the bases in the genome. More often we're looking at defined regions of the genome where we're trying to make the change.

00:13:39.000 --> 00:13:42.540
Right. You're like, this one gene is the problem, right? And let's look at that.

00:13:42.540 --> 00:13:52.620
Right. Yeah. We're trying to target here. So that's where we're looking. It definitely depends on the assay, but, but I guess in terms of data scale, in terms of file sizes, perhaps that would be accessible.

00:13:52.620 --> 00:13:54.620
Yeah.

00:13:54.620 --> 00:14:04.080
For standard things, it would be on the order of a few gigabytes per experimental run. For some of our larger assays, it's 10 to 100 times that.

00:14:04.080 --> 00:14:04.360
Right.

00:14:04.360 --> 00:14:05.420
Per experiment.

00:14:05.420 --> 00:14:10.920
That's a lot of data, but not impossible to transmit sort of amounts of data, right? Or store.

00:14:10.920 --> 00:14:22.300
Right. Every little piece of it is, is pretty manageable. When you start combining them together and looking at some doubt, like your downstream results of things, the data does get pretty, pretty large.

00:14:22.300 --> 00:14:26.860
But I wouldn't say we're at the scale of like big data analytics at Google or anything like that.

00:14:26.860 --> 00:14:36.940
Yeah. Yeah. Or the LHC. If you've ever looked at the data flow layers at LHC, it's like the stuff near the collectors is just unimaginable amounts of data. Right.

00:14:36.940 --> 00:14:39.680
Yeah. I haven't looked, but I'm sure it's certainly.

00:14:39.680 --> 00:14:51.980
Yeah. They've got a lot of stuff built in, like onboard the detectors to filter it down a bunch. And then it goes for processing. Then it gets filtered down some more. And then like eventually it gets to a point where like now we have enough space.

00:14:51.980 --> 00:14:53.220
on hard drives to save it.

00:14:53.220 --> 00:14:54.460
But before that, it was like,

00:14:54.460 --> 00:14:56.020
it couldn't be saved on hard drives.

00:14:56.020 --> 00:14:56.760
It was just too much.

00:14:56.760 --> 00:14:58.240
Yeah, very interesting.

00:14:58.240 --> 00:14:59.480
But it sounds to me like

00:14:59.480 --> 00:15:01.420
some of the real big challenges for you all

00:15:01.420 --> 00:15:03.360
is the computational bits, right?

00:15:03.360 --> 00:15:05.060
Because if you take all these things

00:15:05.060 --> 00:15:06.380
and you can end up in like

00:15:06.380 --> 00:15:09.240
combinatorial comparison scenarios,

00:15:09.240 --> 00:15:11.420
I'm sure that that can really blow up

00:15:11.420 --> 00:15:12.500
the computing time.

00:15:12.500 --> 00:15:13.880
Yeah, I think definitely

00:15:13.880 --> 00:15:16.240
there's a lot of the challenges

00:15:16.240 --> 00:15:18.980
sometimes in these combinatorics.

00:15:18.980 --> 00:15:21.620
And there's also just a lot of,

00:15:21.620 --> 00:15:23.280
there's steps that have to go on

00:15:23.280 --> 00:15:24.680
to process a lot of this data.

00:15:24.680 --> 00:15:27.300
There's a lot of biology specific

00:15:27.300 --> 00:15:29.400
pieces of software that we use

00:15:29.400 --> 00:15:30.820
for various things.

00:15:30.820 --> 00:15:33.000
And we have to string them together

00:15:33.000 --> 00:15:35.700
to create a complete

00:15:35.700 --> 00:15:37.240
data processing pipeline.

00:15:37.240 --> 00:15:40.660
And a lot of that art is part of our job,

00:15:40.660 --> 00:15:42.980
how to get all these tools to behave together

00:15:42.980 --> 00:15:44.900
and act in unison

00:15:44.900 --> 00:15:46.900
to actually process the data effectively.

00:15:46.900 --> 00:15:47.940
I can just imagine

00:15:47.940 --> 00:15:49.260
some of these pipelines are tricky.

00:15:49.260 --> 00:15:50.620
It's like, well, okay,

00:15:50.680 --> 00:15:52.200
so it starts over here

00:15:52.200 --> 00:15:53.520
where the robot gets it

00:15:53.520 --> 00:15:54.740
and it reads this data

00:15:54.740 --> 00:15:56.500
and we can access that off the hard drive.

00:15:56.500 --> 00:15:57.580
And then it has to be sent

00:15:57.580 --> 00:15:59.360
to this Windows app

00:15:59.360 --> 00:16:00.820
that actually doesn't have an API.

00:16:00.820 --> 00:16:02.240
So we got to somehow like

00:16:02.240 --> 00:16:03.560
automate that thing

00:16:03.560 --> 00:16:05.000
and then get data out of it.

00:16:05.000 --> 00:16:06.700
And then is that what it's like?

00:16:06.700 --> 00:16:07.840
That's some of it for sure.

00:16:07.840 --> 00:16:08.540
Tell us about your life.

00:16:08.540 --> 00:16:09.000
Okay.

00:16:09.000 --> 00:16:09.520
Yeah.

00:16:09.520 --> 00:16:10.880
I mean, there's a couple aspects

00:16:10.880 --> 00:16:12.140
and I think we might touch on them,

00:16:12.140 --> 00:16:14.060
but for sequencing experiments,

00:16:14.060 --> 00:16:16.380
the pipelines are more defined

00:16:16.380 --> 00:16:17.700
because we usually get the data

00:16:17.700 --> 00:16:19.700
from a source that's already in the cloud,

00:16:19.700 --> 00:16:21.320
which I'm always happy about.

00:16:21.320 --> 00:16:22.800
If we can start in the cloud,

00:16:22.800 --> 00:16:23.580
we'll stay in the cloud

00:16:23.580 --> 00:16:24.960
and that's a nice place to be.

00:16:24.960 --> 00:16:27.240
For data that's coming directly

00:16:27.240 --> 00:16:29.880
from instruments on premises,

00:16:29.880 --> 00:16:32.300
there is another layer of art

00:16:32.300 --> 00:16:34.180
that has to do with software

00:16:34.180 --> 00:16:34.880
on the instrument,

00:16:34.880 --> 00:16:37.340
software that gets the data to the cloud

00:16:37.340 --> 00:16:38.600
and moves it around

00:16:38.600 --> 00:16:41.040
between our other database sources.

00:16:41.220 --> 00:16:43.840
And that is a fun project in itself there.

00:16:43.840 --> 00:16:44.240
Yeah.

00:16:44.240 --> 00:16:44.980
I can imagine.

00:16:44.980 --> 00:16:46.440
I've worked in some areas

00:16:46.440 --> 00:16:48.140
where it's like collecting data

00:16:48.140 --> 00:16:49.420
from all these different things

00:16:49.420 --> 00:16:50.340
and then, you know,

00:16:50.340 --> 00:16:52.160
to process it and move it along.

00:16:52.160 --> 00:16:53.940
And yeah, it's not always just

00:16:53.940 --> 00:16:56.780
send it from this Python function

00:16:56.780 --> 00:16:57.940
to that Python function

00:16:57.940 --> 00:16:58.820
to that Python function.

00:16:58.820 --> 00:17:00.640
There's a lot of janky stuff

00:17:00.640 --> 00:17:01.620
that wasn't really meant

00:17:01.620 --> 00:17:03.440
to be part of pipelines possibly.

00:17:03.440 --> 00:17:04.060
Absolutely.

00:17:04.060 --> 00:17:04.540
Yeah.

00:17:06.620 --> 00:17:08.280
This portion of Talk Python to Me

00:17:08.280 --> 00:17:09.740
is brought to you by Shortcut,

00:17:09.740 --> 00:17:11.900
formerly known as clubhouse.io.

00:17:11.900 --> 00:17:13.760
Happy with your project management tool?

00:17:13.760 --> 00:17:15.740
Most tools are either too simple

00:17:15.740 --> 00:17:17.160
for a growing engineering team

00:17:17.160 --> 00:17:18.040
to manage everything

00:17:18.040 --> 00:17:19.620
or way too complex

00:17:19.620 --> 00:17:20.980
for anyone to want to use them

00:17:20.980 --> 00:17:22.140
without constant prodding.

00:17:22.140 --> 00:17:24.000
Shortcut is different though,

00:17:24.000 --> 00:17:25.080
because it's worse.

00:17:25.080 --> 00:17:26.520
No, wait, no, I mean it's better.

00:17:26.520 --> 00:17:28.340
Shortcut is project management

00:17:28.340 --> 00:17:30.280
built specifically for software teams.

00:17:30.280 --> 00:17:32.780
It's fast, intuitive, flexible, powerful,

00:17:32.780 --> 00:17:35.060
and many other nice positive adjectives.

00:17:35.060 --> 00:17:36.340
Key features include

00:17:36.340 --> 00:17:37.660
team-based workflows.

00:17:37.660 --> 00:17:39.560
Individual teams can use

00:17:39.560 --> 00:17:40.460
default workflows

00:17:40.460 --> 00:17:41.580
or customize them

00:17:41.580 --> 00:17:42.740
to match the way they work.

00:17:42.740 --> 00:17:44.760
Org-wide goals and roadmaps.

00:17:44.760 --> 00:17:46.220
The work in these workflows

00:17:46.220 --> 00:17:47.420
is automatically tied

00:17:47.420 --> 00:17:48.860
into larger company goals.

00:17:48.860 --> 00:17:50.140
It takes one click

00:17:50.140 --> 00:17:51.260
to move from a roadmap

00:17:51.260 --> 00:17:52.640
to a team's work

00:17:52.640 --> 00:17:54.440
to individual updates and back.

00:17:54.440 --> 00:17:56.320
Type version control integration.

00:17:56.320 --> 00:17:57.440
Whether you use GitHub,

00:17:57.440 --> 00:17:58.840
GitLab, or Bitbucket,

00:17:58.840 --> 00:18:00.780
clubhouse ties directly into them

00:18:00.780 --> 00:18:02.220
so you can update progress

00:18:02.220 --> 00:18:03.160
from the command line.

00:18:03.160 --> 00:18:04.980
Keyboard-friendly interface.

00:18:04.980 --> 00:18:06.020
The rest of Shortcut

00:18:06.020 --> 00:18:07.080
is just as friendly

00:18:07.080 --> 00:18:08.280
as their power bar,

00:18:08.280 --> 00:18:09.520
allowing you to do

00:18:09.520 --> 00:18:10.560
virtually anything

00:18:10.560 --> 00:18:11.880
without touching your mouse.

00:18:11.880 --> 00:18:13.140
Throw that thing in the trash.

00:18:13.140 --> 00:18:14.740
Iteration planning.

00:18:14.740 --> 00:18:16.300
Set weekly priorities

00:18:16.300 --> 00:18:18.120
and let Shortcut run the schedule

00:18:18.120 --> 00:18:18.680
for you

00:18:18.680 --> 00:18:20.020
with accompanying burndown charts

00:18:20.020 --> 00:18:20.880
and other reporting.

00:18:20.880 --> 00:18:22.380
Give it a try

00:18:22.380 --> 00:18:23.040
over at

00:18:23.040 --> 00:18:24.440
talkpython.fm

00:18:24.440 --> 00:18:25.720
slash shortcut.

00:18:25.720 --> 00:18:26.260
Again,

00:18:26.260 --> 00:18:26.800
that's

00:18:26.800 --> 00:18:28.100
talkpython.fm

00:18:28.100 --> 00:18:29.280
slash shortcut.

00:18:29.280 --> 00:18:30.680
Choose shortcut

00:18:30.680 --> 00:18:31.820
because you shouldn't have

00:18:31.820 --> 00:18:32.700
to project manage

00:18:32.700 --> 00:18:33.860
your project management.

00:18:33.860 --> 00:18:37.700
with robots,

00:18:37.700 --> 00:18:38.600
do you have to actually

00:18:38.600 --> 00:18:39.620
talk to the robots

00:18:39.620 --> 00:18:41.160
and like any of the

00:18:41.160 --> 00:18:42.800
type of automated things?

00:18:42.800 --> 00:18:43.320
Yeah,

00:18:43.320 --> 00:18:44.720
for lab automation

00:18:44.720 --> 00:18:45.440
is what we

00:18:45.440 --> 00:18:46.220
call our

00:18:46.220 --> 00:18:47.280
team that has

00:18:47.280 --> 00:18:48.420
the robots

00:18:48.420 --> 00:18:49.420
as we like to

00:18:49.420 --> 00:18:50.300
call them.

00:18:50.300 --> 00:18:51.080
As you can imagine

00:18:51.080 --> 00:18:51.980
with a lot of

00:18:51.980 --> 00:18:53.500
these types of experiments,

00:18:53.500 --> 00:18:54.560
they can be

00:18:54.560 --> 00:18:55.780
made much more efficient

00:18:55.780 --> 00:18:56.620
if we can have

00:18:56.620 --> 00:18:57.440
robots doing

00:18:57.440 --> 00:18:58.220
the actual

00:18:58.220 --> 00:18:59.960
transfer of liquids

00:18:59.960 --> 00:19:01.640
and incubation

00:19:01.640 --> 00:19:03.140
and centrifugation,

00:19:03.140 --> 00:19:03.900
these scientific

00:19:03.900 --> 00:19:04.980
techniques that

00:19:04.980 --> 00:19:06.100
sometimes you need

00:19:06.100 --> 00:19:06.780
someone in the lab

00:19:06.780 --> 00:19:07.120
to do,

00:19:07.120 --> 00:19:07.800
but oftentimes

00:19:07.800 --> 00:19:09.220
you can automate them.

00:19:09.220 --> 00:19:10.100
So the

00:19:10.100 --> 00:19:11.440
lab robotics

00:19:11.440 --> 00:19:12.660
aspect is an

00:19:12.660 --> 00:19:13.680
important part

00:19:13.680 --> 00:19:14.840
of how we can

00:19:14.840 --> 00:19:15.820
efficiently generate

00:19:15.820 --> 00:19:16.260
data.

00:19:16.260 --> 00:19:17.100
A lot of the

00:19:17.100 --> 00:19:18.020
issues around that

00:19:18.020 --> 00:19:18.580
come with

00:19:18.580 --> 00:19:19.480
how to

00:19:19.480 --> 00:19:20.300
pass

00:19:20.300 --> 00:19:21.160
instructions

00:19:21.160 --> 00:19:22.280
to the instrument

00:19:22.280 --> 00:19:23.540
and how to get

00:19:23.540 --> 00:19:24.220
back

00:19:24.220 --> 00:19:25.520
data from the

00:19:25.520 --> 00:19:25.840
instrument

00:19:25.840 --> 00:19:26.520
when it's done.

00:19:26.520 --> 00:19:27.140
and then

00:19:27.140 --> 00:19:27.400
there's a

00:19:27.400 --> 00:19:27.920
whole other

00:19:27.920 --> 00:19:28.560
art of

00:19:28.560 --> 00:19:29.320
making the

00:19:29.320 --> 00:19:29.640
instruments

00:19:29.640 --> 00:19:30.020
actually

00:19:30.020 --> 00:19:30.820
orchestrate

00:19:30.820 --> 00:19:31.220
together,

00:19:31.220 --> 00:19:31.760
which is

00:19:31.760 --> 00:19:32.820
held in a

00:19:32.820 --> 00:19:33.900
different world

00:19:33.900 --> 00:19:34.480
of software.

00:19:34.480 --> 00:19:35.480
I don't actually

00:19:35.480 --> 00:19:36.020
work on that

00:19:36.020 --> 00:19:36.660
part myself.

00:19:36.660 --> 00:19:37.280
Yeah,

00:19:37.280 --> 00:19:38.100
that part of

00:19:38.100 --> 00:19:38.440
programming

00:19:38.440 --> 00:19:39.220
definitely seems

00:19:39.220 --> 00:19:39.640
a little bit

00:19:39.640 --> 00:19:40.060
magical,

00:19:40.060 --> 00:19:41.500
getting factories

00:19:41.500 --> 00:19:42.940
or automations

00:19:42.940 --> 00:19:43.780
of different

00:19:43.780 --> 00:19:44.360
machines to

00:19:44.360 --> 00:19:44.880
work together.

00:19:44.880 --> 00:19:45.660
It's very cool.

00:19:45.660 --> 00:19:46.200
There's a whole

00:19:46.200 --> 00:19:46.760
lot of

00:19:46.760 --> 00:19:47.800
proprietary software

00:19:47.800 --> 00:19:48.700
involved in

00:19:48.700 --> 00:19:49.360
actually running

00:19:49.360 --> 00:19:50.080
the instruments,

00:19:50.080 --> 00:19:51.080
but in terms of

00:19:51.080 --> 00:19:51.720
the problems

00:19:51.720 --> 00:19:52.780
in getting the

00:19:52.780 --> 00:19:53.380
data to them,

00:19:53.380 --> 00:19:54.680
I think it's

00:19:54.680 --> 00:19:55.520
one of those,

00:19:55.520 --> 00:19:56.140
it could be a

00:19:56.140 --> 00:19:56.760
relatively common

00:19:56.760 --> 00:19:57.460
software problem

00:19:57.460 --> 00:19:57.900
of getting

00:19:57.900 --> 00:19:59.240
information from

00:19:59.240 --> 00:20:00.200
somewhere in

00:20:00.200 --> 00:20:01.120
the cloud.

00:20:01.120 --> 00:20:01.940
We have

00:20:01.940 --> 00:20:03.300
electronic lab

00:20:03.300 --> 00:20:04.220
notebooks and

00:20:04.220 --> 00:20:05.360
laboratory data

00:20:05.360 --> 00:20:06.520
systems that

00:20:06.520 --> 00:20:07.060
are in the

00:20:07.060 --> 00:20:08.140
cloud and

00:20:08.140 --> 00:20:09.300
users will be

00:20:09.300 --> 00:20:09.700
submitting

00:20:09.700 --> 00:20:11.160
information about

00:20:11.160 --> 00:20:11.720
how they want

00:20:11.720 --> 00:20:12.300
their samples

00:20:12.300 --> 00:20:13.580
processed by

00:20:13.580 --> 00:20:14.140
the robots.

00:20:14.140 --> 00:20:14.880
There's the

00:20:14.880 --> 00:20:15.380
problem of

00:20:15.380 --> 00:20:16.000
getting that

00:20:16.000 --> 00:20:17.300
to the

00:20:17.300 --> 00:20:17.620
instruments

00:20:17.620 --> 00:20:18.080
themselves.

00:20:18.080 --> 00:20:18.860
And I think

00:20:18.860 --> 00:20:19.580
it actually

00:20:19.580 --> 00:20:20.100
sort of

00:20:20.100 --> 00:20:21.180
reminded me of

00:20:21.180 --> 00:20:22.040
the talks you

00:20:22.040 --> 00:20:22.520
guys had in

00:20:22.520 --> 00:20:22.880
episode,

00:20:22.880 --> 00:20:23.640
I think it was

00:20:23.640 --> 00:20:24.600
327, the

00:20:24.600 --> 00:20:25.660
small automation

00:20:25.660 --> 00:20:26.200
projects.

00:20:26.200 --> 00:20:27.420
We end up

00:20:27.420 --> 00:20:28.180
with quite a

00:20:28.180 --> 00:20:28.760
few of those

00:20:28.760 --> 00:20:29.500
here where we

00:20:29.500 --> 00:20:29.940
have these

00:20:29.940 --> 00:20:31.240
relatively small

00:20:31.240 --> 00:20:32.160
tasks of

00:20:32.160 --> 00:20:33.320
take data from

00:20:33.320 --> 00:20:33.880
an API,

00:20:33.880 --> 00:20:35.160
put it somewhere

00:20:35.160 --> 00:20:36.460
where a robot

00:20:36.460 --> 00:20:37.320
can access it.

00:20:37.320 --> 00:20:38.660
Usually we use

00:20:38.660 --> 00:20:40.120
AWS S3,

00:20:40.120 --> 00:20:41.160
and these sort

00:20:41.160 --> 00:20:42.200
of very small

00:20:42.200 --> 00:20:43.120
data handling

00:20:43.120 --> 00:20:44.280
tasks end up

00:20:44.280 --> 00:20:44.940
being these nice

00:20:44.940 --> 00:20:45.880
little projects

00:20:45.880 --> 00:20:47.200
for Python to

00:20:47.200 --> 00:20:47.960
come into play.

00:20:47.960 --> 00:20:48.480
Awesome.

00:20:48.480 --> 00:20:49.320
I can see that

00:20:49.320 --> 00:20:50.160
that definitely

00:20:50.160 --> 00:20:50.860
happens, right?

00:20:51.340 --> 00:20:51.980
if a file

00:20:51.980 --> 00:20:52.540
shows up

00:20:52.540 --> 00:20:53.780
here, grab

00:20:53.780 --> 00:20:54.280
it, upload

00:20:54.280 --> 00:20:54.700
it to that

00:20:54.700 --> 00:20:55.400
bucket, and

00:20:55.400 --> 00:20:56.040
name it

00:20:56.040 --> 00:20:56.720
whatever the

00:20:56.720 --> 00:20:57.440
active experiment

00:20:57.440 --> 00:20:58.120
is with the

00:20:58.120 --> 00:20:58.680
data or

00:20:58.680 --> 00:20:59.140
something like

00:20:59.140 --> 00:20:59.480
that, right?

00:20:59.480 --> 00:21:00.160
That's a very

00:21:00.160 --> 00:21:00.920
small program

00:21:00.920 --> 00:21:01.980
to write, but

00:21:01.980 --> 00:21:02.760
then that becomes

00:21:02.760 --> 00:21:03.540
a building block

00:21:03.540 --> 00:21:04.800
in this flow,

00:21:04.800 --> 00:21:05.400
putting these

00:21:05.400 --> 00:21:06.040
pieces and

00:21:06.040 --> 00:21:06.660
machines together.

00:21:06.660 --> 00:21:07.580
Right, yeah.

00:21:07.580 --> 00:21:08.300
Once it comes

00:21:08.300 --> 00:21:08.960
into the cloud,

00:21:08.960 --> 00:21:10.260
we do another

00:21:10.260 --> 00:21:11.320
set of data

00:21:11.320 --> 00:21:12.160
processing on it,

00:21:12.160 --> 00:21:13.060
we upload it

00:21:13.060 --> 00:21:13.540
to our

00:21:13.540 --> 00:21:14.540
current databases,

00:21:15.000 --> 00:21:15.980
and all of

00:21:15.980 --> 00:21:16.360
that we

00:21:16.360 --> 00:21:18.100
orchestrate on

00:21:18.100 --> 00:21:19.500
AWS using,

00:21:19.500 --> 00:21:20.460
I guess they

00:21:20.460 --> 00:21:21.200
call it their

00:21:21.200 --> 00:21:22.640
serverless design

00:21:22.640 --> 00:21:24.200
patterns, so we

00:21:24.200 --> 00:21:24.520
don't have to

00:21:24.520 --> 00:21:25.280
handle anything on

00:21:25.280 --> 00:21:26.440
our own computers.

00:21:26.440 --> 00:21:27.140
Yeah, that's

00:21:27.140 --> 00:21:27.680
really nice, and

00:21:27.680 --> 00:21:28.200
the serverless

00:21:28.200 --> 00:21:28.920
stuff probably

00:21:28.920 --> 00:21:30.320
helps you avoid

00:21:30.320 --> 00:21:31.200
running just tons

00:21:31.200 --> 00:21:32.520
of VMs in the

00:21:32.520 --> 00:21:33.000
cloud, right?

00:21:33.000 --> 00:21:33.680
Like, it can all

00:21:33.680 --> 00:21:34.280
be on demand,

00:21:34.280 --> 00:21:35.420
like the Lambda

00:21:35.420 --> 00:21:36.660
trigger is a file

00:21:36.660 --> 00:21:37.420
appears in this

00:21:37.420 --> 00:21:38.400
S3 bucket, so

00:21:38.400 --> 00:21:39.280
then it starts

00:21:39.280 --> 00:21:40.320
down the flow,

00:21:40.320 --> 00:21:40.580
right?

00:21:40.580 --> 00:21:41.520
Absolutely, yeah.

00:21:41.520 --> 00:21:42.360
I really don't

00:21:42.360 --> 00:21:43.280
like maintaining a

00:21:43.280 --> 00:21:43.880
lot of infrastructure,

00:21:43.880 --> 00:21:44.660
although we do

00:21:44.660 --> 00:21:44.960
have,

00:21:44.960 --> 00:21:45.820
a good amount

00:21:45.820 --> 00:21:46.340
of it that we

00:21:46.340 --> 00:21:46.740
do have to

00:21:46.740 --> 00:21:47.620
maintain, I

00:21:47.620 --> 00:21:48.440
find that these

00:21:48.440 --> 00:21:49.440
small Python

00:21:49.440 --> 00:21:50.820
functions are

00:21:50.820 --> 00:21:51.380
the perfect

00:21:51.380 --> 00:21:52.240
use case for

00:21:52.240 --> 00:21:54.060
those event-driven

00:21:54.060 --> 00:21:55.340
Lambda functions,

00:21:55.340 --> 00:21:56.260
which are running

00:21:56.260 --> 00:21:57.220
these very simple

00:21:57.220 --> 00:21:58.000
pieces of code.

00:21:58.000 --> 00:21:59.420
When an object

00:21:59.420 --> 00:22:00.420
appears in S3,

00:22:00.420 --> 00:22:01.220
they get a

00:22:01.220 --> 00:22:02.280
small event about

00:22:02.280 --> 00:22:03.180
when the object

00:22:03.180 --> 00:22:03.720
was uploaded,

00:22:03.720 --> 00:22:04.460
and then they

00:22:04.460 --> 00:22:05.680
do their thing,

00:22:05.680 --> 00:22:06.480
a little bit of

00:22:06.480 --> 00:22:07.140
data conversion,

00:22:07.140 --> 00:22:08.140
send it to an

00:22:08.140 --> 00:22:09.400
API, and now

00:22:09.400 --> 00:22:10.320
the data is in

00:22:10.320 --> 00:22:11.780
our data store.

00:22:11.780 --> 00:22:12.720
And those

00:22:12.720 --> 00:22:13.360
things just

00:22:13.360 --> 00:22:14.100
happen, and

00:22:14.100 --> 00:22:14.620
they're super

00:22:14.620 --> 00:22:15.140
consistent,

00:22:15.140 --> 00:22:15.840
they don't

00:22:15.840 --> 00:22:16.640
require anything

00:22:16.640 --> 00:22:17.820
on my end to

00:22:17.820 --> 00:22:18.160
maintain.

00:22:18.160 --> 00:22:18.940
It's a pretty

00:22:18.940 --> 00:22:20.120
beautiful pattern.

00:22:20.120 --> 00:22:20.780
That's awesome.

00:22:20.780 --> 00:22:21.420
They don't need

00:22:21.420 --> 00:22:22.480
things like,

00:22:22.480 --> 00:22:24.240
oh, there's a

00:22:24.240 --> 00:22:25.140
new kernel for

00:22:25.140 --> 00:22:26.100
Linux that

00:22:26.100 --> 00:22:26.620
patches a

00:22:26.620 --> 00:22:27.380
vulnerability, so

00:22:27.380 --> 00:22:28.180
let's go and

00:22:28.180 --> 00:22:29.360
patch our

00:22:29.360 --> 00:22:30.220
functions, right?

00:22:30.220 --> 00:22:31.060
Just it's all

00:22:31.060 --> 00:22:31.340
magic.

00:22:31.340 --> 00:22:31.920
It all happens

00:22:31.920 --> 00:22:32.340
on its own.

00:22:32.340 --> 00:22:32.780
Right.

00:22:32.780 --> 00:22:33.480
It does feel

00:22:33.480 --> 00:22:34.500
like magic a

00:22:34.500 --> 00:22:34.840
lot of the

00:22:34.840 --> 00:22:35.360
time, yeah.

00:22:35.360 --> 00:22:36.100
Setting them up

00:22:36.100 --> 00:22:36.860
can be a little

00:22:36.860 --> 00:22:37.480
bit of a challenge,

00:22:37.480 --> 00:22:38.400
but once they're

00:22:38.400 --> 00:22:39.060
there, they are

00:22:39.060 --> 00:22:39.780
very consistent.

00:22:40.080 --> 00:22:40.580
Yeah, yeah,

00:22:40.580 --> 00:22:40.940
cool.

00:22:40.940 --> 00:22:41.600
One of the

00:22:41.600 --> 00:22:41.920
things you

00:22:41.920 --> 00:22:42.520
talked about

00:22:42.520 --> 00:22:43.540
doing, you

00:22:43.540 --> 00:22:44.140
seen, was

00:22:44.140 --> 00:22:44.980
the AWS

00:22:44.980 --> 00:22:46.020
CDK, or

00:22:46.020 --> 00:22:46.240
Cloud

00:22:46.240 --> 00:22:46.680
Development

00:22:46.680 --> 00:22:47.020
Kit.

00:22:47.020 --> 00:22:47.960
I think I've

00:22:47.960 --> 00:22:48.320
heard of this

00:22:48.320 --> 00:22:49.060
before, but

00:22:49.060 --> 00:22:50.140
it's like, I've

00:22:50.140 --> 00:22:50.680
definitely not

00:22:50.680 --> 00:22:51.200
used this

00:22:51.200 --> 00:22:51.660
personally.

00:22:51.660 --> 00:22:52.940
Tell us, what

00:22:52.940 --> 00:22:53.220
is this?

00:22:53.220 --> 00:22:53.580
How does it

00:22:53.580 --> 00:22:53.920
help you?

00:22:53.920 --> 00:22:54.540
Right, so

00:22:54.540 --> 00:22:55.520
when I started

00:22:55.520 --> 00:22:56.400
dabbling with

00:22:56.400 --> 00:22:57.460
these Lambda

00:22:57.460 --> 00:22:58.920
functions, what

00:22:58.920 --> 00:23:00.440
I found pretty

00:23:00.440 --> 00:23:01.160
soon after I

00:23:01.160 --> 00:23:02.540
had four or

00:23:02.540 --> 00:23:03.720
five of these

00:23:03.720 --> 00:23:04.700
functions, which

00:23:04.700 --> 00:23:05.900
I had uploaded

00:23:05.900 --> 00:23:06.660
on the

00:23:06.660 --> 00:23:07.700
AWS Council,

00:23:07.700 --> 00:23:08.380
and if

00:23:08.380 --> 00:23:09.180
anyone's used

00:23:09.180 --> 00:23:10.020
that, know

00:23:10.020 --> 00:23:10.420
that it can

00:23:10.420 --> 00:23:10.800
be pretty

00:23:10.800 --> 00:23:11.660
tedious once

00:23:11.660 --> 00:23:12.200
you have a

00:23:12.200 --> 00:23:12.660
few things

00:23:12.660 --> 00:23:13.540
running, getting

00:23:13.540 --> 00:23:13.980
all your

00:23:13.980 --> 00:23:14.800
permissions and

00:23:14.800 --> 00:23:15.460
things set up.

00:23:15.460 --> 00:23:16.840
And I was

00:23:16.840 --> 00:23:17.580
looking for

00:23:17.580 --> 00:23:19.060
better ways to

00:23:19.060 --> 00:23:19.760
do this, and

00:23:19.760 --> 00:23:20.560
at that point,

00:23:20.560 --> 00:23:21.480
it was early

00:23:21.480 --> 00:23:22.460
days for this

00:23:22.460 --> 00:23:23.720
AWS Cloud

00:23:23.720 --> 00:23:24.000
Development,

00:23:24.000 --> 00:23:25.900
AWS CDK, and

00:23:25.900 --> 00:23:27.520
what it is, is

00:23:27.520 --> 00:23:28.720
a way to write

00:23:28.720 --> 00:23:29.980
your infrastructure

00:23:29.980 --> 00:23:31.680
as code in

00:23:31.680 --> 00:23:32.880
essentially any

00:23:32.880 --> 00:23:34.120
common language,

00:23:34.120 --> 00:23:35.140
programming language.

00:23:35.460 --> 00:23:36.780
write JavaScript,

00:23:36.780 --> 00:23:38.040
TypeScript, I

00:23:38.040 --> 00:23:38.320
think you can

00:23:38.320 --> 00:23:39.720
do Java, Go,

00:23:39.720 --> 00:23:40.320
and Python

00:23:40.320 --> 00:23:40.840
perhaps.

00:23:40.840 --> 00:23:42.940
And using it,

00:23:42.940 --> 00:23:44.040
you can define

00:23:44.040 --> 00:23:45.000
your cloud

00:23:45.000 --> 00:23:46.220
infrastructure in

00:23:46.220 --> 00:23:47.000
an object-oriented

00:23:47.000 --> 00:23:48.380
way with all the

00:23:48.380 --> 00:23:49.020
parameters they

00:23:49.020 --> 00:23:50.320
need, and you

00:23:50.320 --> 00:23:51.620
can deploy it to

00:23:51.620 --> 00:23:52.560
different AWS

00:23:52.560 --> 00:23:53.320
accounts, you

00:23:53.320 --> 00:23:53.740
can take it

00:23:53.740 --> 00:23:54.600
down, you can

00:23:54.600 --> 00:23:55.480
reconfigure it,

00:23:55.480 --> 00:23:56.160
you can look at

00:23:56.160 --> 00:23:57.100
how it's changed

00:23:57.100 --> 00:23:57.920
since your last

00:23:57.920 --> 00:23:59.120
commit, and you

00:23:59.120 --> 00:23:59.820
can store all

00:23:59.820 --> 00:24:00.620
that configuration

00:24:00.620 --> 00:24:01.700
in source

00:24:01.700 --> 00:24:02.060
control.

00:24:02.060 --> 00:24:03.500
And this has

00:24:03.500 --> 00:24:04.480
allowed us to

00:24:04.480 --> 00:24:05.420
scale up,

00:24:05.420 --> 00:24:06.040
in terms of

00:24:06.040 --> 00:24:06.760
number of

00:24:06.760 --> 00:24:07.720
Lambda functions,

00:24:07.720 --> 00:24:08.120
I think we

00:24:08.120 --> 00:24:08.780
have maybe

00:24:08.780 --> 00:24:09.680
60 or

00:24:09.680 --> 00:24:10.340
something now,

00:24:10.340 --> 00:24:11.040
which would

00:24:11.040 --> 00:24:12.400
be unmaintainable

00:24:12.400 --> 00:24:12.720
in the

00:24:12.720 --> 00:24:13.620
console, but

00:24:13.620 --> 00:24:14.040
they're

00:24:14.040 --> 00:24:14.780
essentially just

00:24:14.780 --> 00:24:15.800
completely maintained

00:24:15.800 --> 00:24:16.360
inside of

00:24:16.360 --> 00:24:17.220
source control

00:24:17.220 --> 00:24:18.060
these days using

00:24:18.060 --> 00:24:19.860
AWS CDK and

00:24:19.860 --> 00:24:20.200
Python.

00:24:20.340 --> 00:24:20.940
Yeah, it seems

00:24:20.940 --> 00:24:21.420
super neat.

00:24:21.420 --> 00:24:22.120
I have not used

00:24:22.120 --> 00:24:23.620
it, but on

00:24:23.620 --> 00:24:24.380
the page, which

00:24:24.380 --> 00:24:24.900
I'll link to in

00:24:24.900 --> 00:24:25.380
the show notes,

00:24:25.380 --> 00:24:26.560
they have

00:24:26.560 --> 00:24:28.320
Werner Vogels,

00:24:28.320 --> 00:24:29.980
the CTO of

00:24:29.980 --> 00:24:32.100
Amazon, AWS, and

00:24:32.100 --> 00:24:33.360
talks about some

00:24:33.360 --> 00:24:34.180
of the benefits and

00:24:34.180 --> 00:24:35.240
kind of how it all

00:24:35.240 --> 00:24:35.800
fits together.

00:24:35.800 --> 00:24:36.660
And like you

00:24:36.660 --> 00:24:37.000
said, you can

00:24:37.000 --> 00:24:38.680
store your cloud

00:24:38.680 --> 00:24:39.740
structure definition

00:24:39.740 --> 00:24:40.760
in source control.

00:24:40.760 --> 00:24:41.600
You can run unit

00:24:41.600 --> 00:24:42.540
tests against your

00:24:42.540 --> 00:24:43.280
infrastructure to

00:24:43.280 --> 00:24:44.040
say, if I apply

00:24:44.040 --> 00:24:44.760
all these commands

00:24:44.760 --> 00:24:45.640
to AWS, so I

00:24:45.640 --> 00:24:46.900
actually get what I

00:24:46.900 --> 00:24:47.600
was hoping to get

00:24:47.600 --> 00:24:48.140
out of it.

00:24:48.220 --> 00:24:49.620
yeah, it seems

00:24:49.620 --> 00:24:50.380
like a really neat

00:24:50.380 --> 00:24:51.980
thing for this

00:24:51.980 --> 00:24:52.820
infrastructure's code

00:24:52.820 --> 00:24:53.040
bits.

00:24:53.040 --> 00:24:53.680
Yeah, and I

00:24:53.680 --> 00:24:54.520
think it definitely

00:24:54.520 --> 00:24:56.100
really shines when

00:24:56.100 --> 00:24:57.360
you're developing

00:24:57.360 --> 00:24:58.960
larger pieces of

00:24:58.960 --> 00:25:00.020
infrastructure, but

00:25:00.020 --> 00:25:01.100
I would encourage

00:25:01.100 --> 00:25:02.140
people to check it

00:25:02.140 --> 00:25:02.780
out, even if they

00:25:02.780 --> 00:25:04.000
have a small

00:25:04.000 --> 00:25:05.260
automation type

00:25:05.260 --> 00:25:05.700
project.

00:25:05.700 --> 00:25:06.720
This is what I

00:25:06.720 --> 00:25:07.280
was thinking of

00:25:07.280 --> 00:25:07.840
when I was

00:25:07.840 --> 00:25:08.340
listening to

00:25:08.340 --> 00:25:09.620
episode 327 the

00:25:09.620 --> 00:25:10.020
other day.

00:25:10.020 --> 00:25:10.440
When you have

00:25:10.440 --> 00:25:11.840
these things you

00:25:11.840 --> 00:25:12.660
want to run on

00:25:12.660 --> 00:25:14.100
your computer with

00:25:14.100 --> 00:25:15.320
a cron job, you

00:25:15.320 --> 00:25:16.180
can actually run

00:25:16.180 --> 00:25:18.000
them for free on

00:25:18.000 --> 00:25:19.020
AWS Lambda.

00:25:19.020 --> 00:25:19.980
You get a bunch

00:25:19.980 --> 00:25:21.180
of free time on

00:25:21.180 --> 00:25:22.980
the free tier, and

00:25:22.980 --> 00:25:23.940
you try it out.

00:25:23.940 --> 00:25:24.720
You don't need to

00:25:24.720 --> 00:25:25.480
make sure your

00:25:25.480 --> 00:25:26.980
system D processor

00:25:26.980 --> 00:25:27.880
for whatever is

00:25:27.880 --> 00:25:29.100
running, and it's

00:25:29.100 --> 00:25:29.820
a pretty cool way

00:25:29.820 --> 00:25:30.620
to get familiar

00:25:30.620 --> 00:25:32.260
with how to do

00:25:32.260 --> 00:25:32.640
some of these

00:25:32.640 --> 00:25:33.660
things on AWS.

00:25:33.660 --> 00:25:35.540
I'm not sure if

00:25:35.540 --> 00:25:36.520
this also exists for

00:25:36.520 --> 00:25:36.980
other cloud

00:25:36.980 --> 00:25:37.400
providers.

00:25:37.400 --> 00:25:39.200
We use AWS in

00:25:39.200 --> 00:25:40.020
particular, so that's

00:25:40.020 --> 00:25:40.760
what I know, but

00:25:40.760 --> 00:25:41.980
it might also exist

00:25:41.980 --> 00:25:42.780
for things like

00:25:42.780 --> 00:25:43.720
Azure and Google

00:25:43.720 --> 00:25:43.900
Cloud.

00:25:43.900 --> 00:25:44.180
Sure.

00:25:44.180 --> 00:25:44.980
Yeah, maybe.

00:25:44.980 --> 00:25:45.580
I don't know if it

00:25:45.580 --> 00:25:46.500
does either, but it

00:25:46.500 --> 00:25:47.100
definitely seems

00:25:47.100 --> 00:25:48.140
useful for what

00:25:48.140 --> 00:25:48.660
you all are doing

00:25:48.660 --> 00:25:48.960
there.

00:25:48.960 --> 00:25:50.220
One of the things

00:25:50.220 --> 00:25:51.320
it could be useful

00:25:51.320 --> 00:25:51.960
for, and one of the

00:25:51.960 --> 00:25:52.940
challenges I suspect

00:25:52.940 --> 00:25:53.960
that you run into

00:25:53.960 --> 00:25:54.800
more than a lot of

00:25:54.800 --> 00:25:55.760
places, certainly more

00:25:55.760 --> 00:25:56.660
than like an e-commerce

00:25:56.660 --> 00:25:57.520
site or something like

00:25:57.520 --> 00:25:58.220
that, is

00:25:58.220 --> 00:25:59.520
reproducibility.

00:25:59.520 --> 00:26:00.860
If you're going to

00:26:00.860 --> 00:26:01.600
say, we're going to

00:26:01.600 --> 00:26:02.960
come up with a

00:26:02.960 --> 00:26:03.940
treatment that

00:26:03.940 --> 00:26:04.880
literally gets

00:26:04.880 --> 00:26:05.900
injected into people,

00:26:05.900 --> 00:26:06.880
you've got to go

00:26:06.880 --> 00:26:08.480
through FDA, you've

00:26:08.480 --> 00:26:09.120
got to have

00:26:09.120 --> 00:26:11.180
possibly peer-reviewed

00:26:11.180 --> 00:26:11.540
stuff.

00:26:11.540 --> 00:26:13.080
There's a lot of

00:26:13.080 --> 00:26:14.180
reproducibility and

00:26:14.180 --> 00:26:15.700
data stewardship

00:26:15.700 --> 00:26:16.920
going on, I

00:26:16.920 --> 00:26:17.480
imagine, right?

00:26:17.480 --> 00:26:18.100
Absolutely.

00:26:18.100 --> 00:26:19.400
That's definitely the

00:26:19.400 --> 00:26:19.640
case.

00:26:19.640 --> 00:26:20.540
We are very

00:26:20.540 --> 00:26:21.780
cognizant of the

00:26:21.780 --> 00:26:22.600
fact that we have

00:26:22.600 --> 00:26:23.240
to make our

00:26:23.240 --> 00:26:24.300
software as

00:26:24.300 --> 00:26:25.280
reproducible as

00:26:25.280 --> 00:26:25.780
possible.

00:26:25.780 --> 00:26:27.300
I think a lot of

00:26:27.300 --> 00:26:28.240
that lends itself to

00:26:28.240 --> 00:26:29.320
just using good

00:26:29.320 --> 00:26:30.340
development practices,

00:26:30.340 --> 00:26:32.600
containerizing everything

00:26:32.600 --> 00:26:34.100
that you're doing for

00:26:34.100 --> 00:26:34.800
data processing,

00:26:34.800 --> 00:26:35.960
getting all your

00:26:35.960 --> 00:26:37.640
versions, appropriate

00:26:37.640 --> 00:26:39.220
source control, all

00:26:39.220 --> 00:26:39.920
of these things.

00:26:40.440 --> 00:26:40.900
And the

00:26:40.900 --> 00:26:41.780
infrastructure is

00:26:41.780 --> 00:26:43.040
definitely a piece

00:26:43.040 --> 00:26:44.480
of that because if

00:26:44.480 --> 00:26:45.700
we can't deploy the

00:26:45.700 --> 00:26:46.520
pipeline in the same

00:26:46.520 --> 00:26:47.880
way a year from

00:26:47.880 --> 00:26:49.100
now, we won't be

00:26:49.100 --> 00:26:50.280
able to get the same

00:26:50.280 --> 00:26:51.180
results from the

00:26:51.180 --> 00:26:51.420
data.

00:26:51.420 --> 00:26:52.900
And that's a

00:26:52.900 --> 00:26:53.240
problem.

00:26:53.240 --> 00:26:53.980
That's a big

00:26:53.980 --> 00:26:54.380
challenge.

00:26:54.380 --> 00:26:55.620
It's tricky, right?

00:26:55.620 --> 00:26:57.120
Because things like

00:26:57.120 --> 00:26:58.180
containers and source

00:26:58.180 --> 00:26:58.900
control, they'll

00:26:58.900 --> 00:27:00.420
absolutely get you

00:27:00.420 --> 00:27:00.980
very far.

00:27:00.980 --> 00:27:02.460
But then you're also

00:27:02.460 --> 00:27:03.220
depending on these

00:27:03.220 --> 00:27:05.120
external things that

00:27:05.120 --> 00:27:06.280
have been very

00:27:06.280 --> 00:27:07.140
stable and very likely

00:27:07.140 --> 00:27:08.060
will be, like

00:27:08.060 --> 00:27:08.820
Lambda, for

00:27:08.820 --> 00:27:10.540
example, but what

00:27:10.540 --> 00:27:11.380
if Amazon went out

00:27:11.380 --> 00:27:12.440
of business, right?

00:27:12.440 --> 00:27:14.040
Which, you know, is

00:27:14.040 --> 00:27:14.800
kind of laughable,

00:27:14.800 --> 00:27:15.020
right?

00:27:15.020 --> 00:27:15.660
It's only like

00:27:15.660 --> 00:27:16.580
doubled its revenue

00:27:16.580 --> 00:27:17.680
this year or

00:27:17.680 --> 00:27:17.920
something.

00:27:17.920 --> 00:27:18.840
But, you know,

00:27:18.840 --> 00:27:20.280
theoretically, it's

00:27:20.280 --> 00:27:21.800
possible that AWS

00:27:21.800 --> 00:27:22.880
decided to shut down

00:27:22.880 --> 00:27:23.480
or something like

00:27:23.480 --> 00:27:24.140
that, right?

00:27:24.140 --> 00:27:25.060
Yeah, it's

00:27:25.060 --> 00:27:25.560
definitely true.

00:27:25.560 --> 00:27:26.060
So you got to

00:27:26.060 --> 00:27:26.880
think, these are

00:27:26.880 --> 00:27:27.560
trade-offs, right?

00:27:27.560 --> 00:27:28.320
But at the same

00:27:28.320 --> 00:27:28.880
time, it's so

00:27:28.880 --> 00:27:29.900
enabling for you to

00:27:29.900 --> 00:27:31.160
just scale out all

00:27:31.160 --> 00:27:31.680
this workload.

00:27:31.680 --> 00:27:32.720
Yeah, I mean, in

00:27:32.720 --> 00:27:33.480
terms of how we

00:27:33.480 --> 00:27:35.340
create data pipelines,

00:27:35.340 --> 00:27:36.360
I think a lot of

00:27:36.360 --> 00:27:37.720
the ways we do it,

00:27:37.780 --> 00:27:39.040
we do have to be

00:27:39.040 --> 00:27:40.220
aware of creating

00:27:40.220 --> 00:27:40.840
them in a way that

00:27:40.840 --> 00:27:41.900
you can run them

00:27:41.900 --> 00:27:43.380
outside of the cloud.

00:27:43.380 --> 00:27:45.060
Sometimes we need to

00:27:45.060 --> 00:27:46.740
allow a third party

00:27:46.740 --> 00:27:47.880
to run our data

00:27:47.880 --> 00:27:48.960
analysis in a

00:27:48.960 --> 00:27:49.720
regulated way.

00:27:49.720 --> 00:27:51.140
And that requires us

00:27:51.140 --> 00:27:52.860
to have essentially

00:27:52.860 --> 00:27:54.180
running it internally,

00:27:54.180 --> 00:27:55.280
we run it in the

00:27:55.280 --> 00:27:56.080
cloud, which is

00:27:56.080 --> 00:27:57.220
efficient for scaling,

00:27:57.220 --> 00:27:58.840
but we also need to

00:27:58.840 --> 00:27:59.580
be able to take that

00:27:59.580 --> 00:28:00.720
same piece of

00:28:00.720 --> 00:28:02.320
software and run it

00:28:02.320 --> 00:28:03.040
in a way that may

00:28:03.040 --> 00:28:04.020
not be on AWS,

00:28:04.020 --> 00:28:04.660
may not be in the

00:28:04.660 --> 00:28:05.260
cloud at all.

00:28:05.620 --> 00:28:06.840
And that creates

00:28:06.840 --> 00:28:07.720
some interesting

00:28:07.720 --> 00:28:08.640
software challenges.

00:28:08.640 --> 00:28:09.640
Yeah, I'm sure,

00:28:09.640 --> 00:28:10.380
because so many of

00:28:10.380 --> 00:28:11.620
the APIs are, you

00:28:11.620 --> 00:28:12.320
know, cloud native,

00:28:12.320 --> 00:28:12.620
right?

00:28:12.620 --> 00:28:14.120
You import Bodo,

00:28:14.120 --> 00:28:15.380
Bodo do this thing,

00:28:15.380 --> 00:28:16.780
or something like

00:28:16.780 --> 00:28:17.340
that, right?

00:28:17.340 --> 00:28:18.220
How do you deal

00:28:18.220 --> 00:28:18.480
with that?

00:28:18.480 --> 00:28:19.300
I think a lot of it

00:28:19.300 --> 00:28:20.360
comes down to

00:28:20.360 --> 00:28:21.880
structuring your

00:28:21.880 --> 00:28:24.160
workflows and your

00:28:24.160 --> 00:28:25.100
data pipelines in

00:28:25.100 --> 00:28:26.180
ways that are,

00:28:26.180 --> 00:28:27.280
they're not really

00:28:27.280 --> 00:28:28.620
using the cloud as

00:28:28.620 --> 00:28:29.180
much as they're,

00:28:29.180 --> 00:28:29.820
they're using the

00:28:29.820 --> 00:28:30.680
cloud as a, well,

00:28:30.720 --> 00:28:31.520
the file system

00:28:31.520 --> 00:28:33.120
and a way to

00:28:33.120 --> 00:28:34.340
gain compute,

00:28:34.340 --> 00:28:35.140
but they're not

00:28:35.140 --> 00:28:36.440
using any piece of

00:28:36.440 --> 00:28:37.260
the cloud to actually

00:28:37.260 --> 00:28:38.620
affect the data

00:28:38.620 --> 00:28:39.540
processing itself.

00:28:39.540 --> 00:28:41.760
So ideally, if you

00:28:41.760 --> 00:28:42.400
create the data

00:28:42.400 --> 00:28:43.220
pipeline in a way

00:28:43.220 --> 00:28:44.400
that is appropriate,

00:28:44.400 --> 00:28:45.760
you can both run it

00:28:45.760 --> 00:28:47.100
in the cloud and run

00:28:47.100 --> 00:28:48.640
it locally and

00:28:48.640 --> 00:28:49.240
achieve identical

00:28:49.240 --> 00:28:50.860
results because it's

00:28:50.860 --> 00:28:52.020
containerized.

00:28:52.020 --> 00:28:53.320
Primarily, that's the

00:28:53.320 --> 00:28:54.340
reason, I guess.

00:28:54.340 --> 00:28:54.660
Yeah.

00:28:54.800 --> 00:28:55.760
But doing that, I

00:28:55.760 --> 00:28:56.740
think, is a challenge

00:28:56.740 --> 00:28:57.520
in itself.

00:28:57.520 --> 00:28:58.720
It's really like the

00:28:58.720 --> 00:29:00.140
process of getting a

00:29:00.140 --> 00:29:01.880
data pipeline built is

00:29:01.880 --> 00:29:03.220
a big ask in our

00:29:03.220 --> 00:29:03.440
field.

00:29:03.440 --> 00:29:04.520
I think a lot of

00:29:04.520 --> 00:29:05.820
companies spend a lot

00:29:05.820 --> 00:29:06.660
of time thinking about

00:29:06.660 --> 00:29:06.980
this.

00:29:06.980 --> 00:29:07.280
Yeah.

00:29:07.280 --> 00:29:08.300
I'm sure they do.

00:29:08.300 --> 00:29:10.400
Getting it right is a

00:29:10.400 --> 00:29:11.460
huge enabler, right?

00:29:11.460 --> 00:29:12.660
So let's talk about the

00:29:12.660 --> 00:29:13.820
process of maybe coming

00:29:13.820 --> 00:29:14.680
up with a new data

00:29:14.680 --> 00:29:15.060
pipeline.

00:29:15.060 --> 00:29:16.520
What does a software

00:29:16.520 --> 00:29:17.640
project look like for

00:29:17.640 --> 00:29:17.940
you all?

00:29:17.940 --> 00:29:18.280
Yeah.

00:29:18.280 --> 00:29:19.780
So it usually begins

00:29:19.780 --> 00:29:21.660
with a collaborative

00:29:21.660 --> 00:29:23.320
meeting with some

00:29:23.320 --> 00:29:24.300
experimental scientists

00:29:24.300 --> 00:29:25.600
where we discuss

00:29:25.600 --> 00:29:27.000
what's the experimental

00:29:27.000 --> 00:29:27.880
design going to be

00:29:27.880 --> 00:29:28.180
like?

00:29:28.180 --> 00:29:28.820
What are we going to

00:29:28.820 --> 00:29:29.900
be looking at in the

00:29:29.900 --> 00:29:30.180
data?

00:29:30.180 --> 00:29:31.460
And then the

00:29:31.460 --> 00:29:32.660
experimentalists will

00:29:32.660 --> 00:29:33.520
go and they'll

00:29:33.520 --> 00:29:35.440
generate some form of

00:29:35.440 --> 00:29:36.360
sequencing data.

00:29:36.360 --> 00:29:37.980
At that point, we

00:29:37.980 --> 00:29:39.120
generally take the

00:29:39.120 --> 00:29:40.880
data, open up some

00:29:40.880 --> 00:29:42.140
Jupyter notebooks or

00:29:42.140 --> 00:29:43.680
some small Python,

00:29:43.680 --> 00:29:44.740
sometimes even just

00:29:44.740 --> 00:29:46.200
bash scripts to try

00:29:46.200 --> 00:29:47.560
to use some of those

00:29:47.560 --> 00:29:48.660
standard third-party

00:29:48.660 --> 00:29:49.100
tools.

00:29:49.100 --> 00:29:50.460
These are things like

00:29:50.460 --> 00:29:51.360
making sure all the

00:29:51.360 --> 00:29:52.540
sequences are aligned

00:29:52.540 --> 00:29:53.520
to each other so that

00:29:53.520 --> 00:29:54.280
you know when there's

00:29:54.280 --> 00:29:56.360
differences and making

00:29:56.360 --> 00:29:57.600
sure the quality is

00:29:57.600 --> 00:29:58.640
correct, things like

00:29:58.640 --> 00:29:58.920
that.

00:29:58.920 --> 00:29:59.660
These are pretty

00:29:59.660 --> 00:30:01.440
standard bioinformatics

00:30:01.440 --> 00:30:02.460
things.

00:30:02.460 --> 00:30:02.780
Right.

00:30:02.780 --> 00:30:04.880
Then for sequencing

00:30:04.880 --> 00:30:06.400
assays, there's usually

00:30:06.400 --> 00:30:07.880
a couple spots where

00:30:07.880 --> 00:30:09.940
there's some real

00:30:09.940 --> 00:30:11.760
experimental logic going

00:30:11.760 --> 00:30:12.980
into it where often

00:30:12.980 --> 00:30:13.860
we'll have to write

00:30:13.860 --> 00:30:15.820
custom code in Python

00:30:15.820 --> 00:30:17.980
to say, if there's this

00:30:17.980 --> 00:30:19.500
sequence here, it means

00:30:19.500 --> 00:30:20.080
we should keep the

00:30:20.080 --> 00:30:20.400
sequence.

00:30:20.400 --> 00:30:21.080
And if there's this

00:30:21.080 --> 00:30:21.800
sequence here, we

00:30:21.800 --> 00:30:22.720
should divide the

00:30:22.720 --> 00:30:23.580
sequence in half or

00:30:23.580 --> 00:30:24.840
something like that.

00:30:24.840 --> 00:30:26.140
And so that code gets

00:30:26.140 --> 00:30:27.600
written in Python, maybe

00:30:27.600 --> 00:30:28.320
it's in the Jupyter

00:30:28.320 --> 00:30:29.720
notebook or another

00:30:29.720 --> 00:30:30.180
script.

00:30:30.180 --> 00:30:31.460
And we sort of do this

00:30:31.460 --> 00:30:33.100
really slow testing

00:30:33.100 --> 00:30:34.080
depending on the size of

00:30:34.080 --> 00:30:34.440
the data.

00:30:34.440 --> 00:30:36.000
It might be locally on

00:30:36.000 --> 00:30:37.820
a laptop or in a small

00:30:37.820 --> 00:30:40.140
cloud-based HPC type

00:30:40.140 --> 00:30:40.680
cluster.

00:30:40.680 --> 00:30:40.920
Right.

00:30:40.920 --> 00:30:41.880
This is like where we're

00:30:41.880 --> 00:30:42.180
doing...

00:30:42.180 --> 00:30:42.840
You're not trying to

00:30:42.840 --> 00:30:44.560
process all the results.

00:30:44.560 --> 00:30:45.940
You just want to spot

00:30:45.940 --> 00:30:46.840
check and see if it's

00:30:46.840 --> 00:30:47.640
coming out right before

00:30:47.640 --> 00:30:48.700
you turn it loose,

00:30:48.700 --> 00:30:48.900
right?

00:30:48.900 --> 00:30:49.360
Right.

00:30:49.360 --> 00:30:50.680
Or we're very patient.

00:30:50.680 --> 00:30:51.940
It's a little bit above.

00:30:52.500 --> 00:30:53.400
Sometimes it's very

00:30:53.400 --> 00:30:55.300
difficult to take only a

00:30:55.300 --> 00:30:56.160
small fraction of the

00:30:56.160 --> 00:30:57.500
data, but we try when we

00:30:57.500 --> 00:30:57.720
can.

00:30:57.720 --> 00:30:59.520
Once we settle on

00:30:59.520 --> 00:31:00.240
something that we think

00:31:00.240 --> 00:31:01.540
is pretty locked down,

00:31:01.540 --> 00:31:02.620
we'll take it out of the

00:31:02.620 --> 00:31:03.420
Jupyter notebooks.

00:31:03.420 --> 00:31:04.620
We don't try to use

00:31:04.620 --> 00:31:05.700
Paperville or anything

00:31:05.700 --> 00:31:06.240
like that.

00:31:06.240 --> 00:31:07.300
We try to get it out of

00:31:07.300 --> 00:31:08.220
there as soon as

00:31:08.220 --> 00:31:10.020
possible into some more

00:31:10.020 --> 00:31:11.200
complex scripts.

00:31:11.200 --> 00:31:12.880
They might be a shell

00:31:12.880 --> 00:31:14.440
script that runs a number

00:31:14.440 --> 00:31:15.660
of other scripts in order,

00:31:15.660 --> 00:31:17.640
or we might start using

00:31:17.640 --> 00:31:19.060
some sort of workflow

00:31:19.060 --> 00:31:19.600
manager.

00:31:20.100 --> 00:31:21.620
workflow managers in

00:31:21.620 --> 00:31:23.320
bioinformatics are pretty

00:31:23.320 --> 00:31:24.780
common because everyone

00:31:24.780 --> 00:31:26.020
has the same problem of

00:31:26.020 --> 00:31:26.980
running all these third

00:31:26.980 --> 00:31:29.100
party tools together and

00:31:29.100 --> 00:31:29.780
custom code.

00:31:29.780 --> 00:31:30.080
Right.

00:31:30.080 --> 00:31:30.860
It's a lot of shared

00:31:30.860 --> 00:31:32.100
tools as well, probably.

00:31:32.100 --> 00:31:32.480
Right.

00:31:32.480 --> 00:31:33.460
They all use this library

00:31:33.460 --> 00:31:34.060
or that app.

00:31:34.060 --> 00:31:34.540
Absolutely.

00:31:34.540 --> 00:31:34.900
Yeah.

00:31:34.900 --> 00:31:36.320
There's definitely...

00:31:36.320 --> 00:31:37.180
Whatever it is, right?

00:31:37.180 --> 00:31:38.540
There's a whole bunch of

00:31:38.540 --> 00:31:40.240
standard bioinformatics

00:31:40.240 --> 00:31:41.880
tools that we run on

00:31:41.880 --> 00:31:42.700
almost everything.

00:31:42.960 --> 00:31:44.380
And so some of the

00:31:44.380 --> 00:31:45.300
workflow managers are

00:31:45.300 --> 00:31:46.740
designed to specifically

00:31:46.740 --> 00:31:47.980
work very well with those

00:31:47.980 --> 00:31:49.820
tools and others are

00:31:49.820 --> 00:31:51.320
pretty agnostic of what

00:31:51.320 --> 00:31:52.000
you're doing with them.

00:31:52.000 --> 00:31:52.280
Yeah.

00:31:52.280 --> 00:31:53.820
One of the things I find

00:31:53.820 --> 00:31:55.600
interesting and listening

00:31:55.600 --> 00:31:56.600
to you talk about this,

00:31:56.600 --> 00:31:58.220
it just reminded me, is

00:31:58.220 --> 00:32:00.180
so often we see these

00:32:00.180 --> 00:32:01.260
problems that people are

00:32:01.260 --> 00:32:02.140
solving, right?

00:32:02.140 --> 00:32:03.020
Like, oh, here we're

00:32:03.020 --> 00:32:05.660
using CRISPR to do all

00:32:05.660 --> 00:32:06.100
this work.

00:32:06.100 --> 00:32:07.120
And then you talk about

00:32:07.120 --> 00:32:07.740
the tools you use.

00:32:07.740 --> 00:32:08.300
It's like, oh, yeah,

00:32:08.300 --> 00:32:09.540
we're using like NumPy

00:32:09.540 --> 00:32:11.000
and Pandas and Jupyter

00:32:11.000 --> 00:32:12.240
and these kinds of

00:32:12.240 --> 00:32:12.540
things.

00:32:12.540 --> 00:32:14.280
And the thing that I find

00:32:14.280 --> 00:32:16.120
really interesting is for

00:32:16.120 --> 00:32:17.420
software development,

00:32:17.420 --> 00:32:18.600
there's so much of the

00:32:18.600 --> 00:32:19.980
stuff that is, it's just

00:32:19.980 --> 00:32:21.640
the same for everyone,

00:32:21.640 --> 00:32:22.100
right?

00:32:22.100 --> 00:32:23.620
They're doing the same

00:32:23.620 --> 00:32:23.980
thing.

00:32:23.980 --> 00:32:25.220
And then there's 10 or

00:32:25.220 --> 00:32:26.780
20% that like, yeah,

00:32:26.780 --> 00:32:28.120
this field does this part

00:32:28.120 --> 00:32:28.920
different, but there's

00:32:28.920 --> 00:32:30.840
like 80% of, yeah, we

00:32:30.840 --> 00:32:31.600
kind of, we should use

00:32:31.600 --> 00:32:32.180
source control.

00:32:32.180 --> 00:32:33.000
We're using Python.

00:32:33.000 --> 00:32:34.620
We're using notebooks.

00:32:34.620 --> 00:32:36.000
We're using Pandas and

00:32:36.000 --> 00:32:37.180
that kind of stuff.

00:32:37.240 --> 00:32:38.080
and it's the

00:32:38.080 --> 00:32:40.240
similarities are way

00:32:40.240 --> 00:32:42.040
more common than I

00:32:42.040 --> 00:32:43.640
think they appear from

00:32:43.640 --> 00:32:44.180
the outside.

00:32:44.180 --> 00:32:45.120
It's a great point.

00:32:45.120 --> 00:32:46.500
And I think we'd, we'd

00:32:46.500 --> 00:32:47.500
all be better off if we

00:32:47.500 --> 00:32:48.580
reminded ourselves of

00:32:48.580 --> 00:32:49.960
that more often that

00:32:49.960 --> 00:32:51.160
we're not just because

00:32:51.160 --> 00:32:52.780
we're doing biotechnology

00:32:52.780 --> 00:32:54.280
and things with Python

00:32:54.280 --> 00:32:57.000
that we're largely very

00:32:57.000 --> 00:32:58.420
similar to other

00:32:58.420 --> 00:32:59.700
software developers doing

00:32:59.700 --> 00:33:01.880
data science on business

00:33:01.880 --> 00:33:03.720
topics or finance or

00:33:03.720 --> 00:33:05.080
just standard web

00:33:05.080 --> 00:33:05.500
development.

00:33:05.500 --> 00:33:06.380
You could be at a hedge

00:33:06.380 --> 00:33:07.000
fund and you're like,

00:33:07.040 --> 00:33:08.280
this is that different

00:33:08.280 --> 00:33:09.120
than what I'm used to

00:33:09.120 --> 00:33:09.520
actually.

00:33:09.520 --> 00:33:09.980
Yeah.

00:33:09.980 --> 00:33:10.760
And if you think like

00:33:10.760 --> 00:33:11.680
that, we, you end up

00:33:11.680 --> 00:33:12.620
with, I think, better

00:33:12.620 --> 00:33:14.480
practices overall in

00:33:14.480 --> 00:33:14.940
software.

00:33:14.940 --> 00:33:15.600
Yeah.

00:33:15.600 --> 00:33:16.540
Oh, I totally agree.

00:33:16.540 --> 00:33:18.460
Also, I suspect that

00:33:18.460 --> 00:33:21.220
this fact is what also

00:33:21.220 --> 00:33:22.680
makes the data science

00:33:22.680 --> 00:33:23.320
tools and all the

00:33:23.320 --> 00:33:24.520
tooling around Python,

00:33:24.520 --> 00:33:25.500
the libraries and

00:33:25.500 --> 00:33:25.980
whatnot.

00:33:25.980 --> 00:33:27.580
So good because it's

00:33:27.580 --> 00:33:28.620
not just like, oh, the

00:33:28.620 --> 00:33:30.020
biologists have made this

00:33:30.020 --> 00:33:30.860
part of it really good.

00:33:30.860 --> 00:33:32.320
It's like most of the

00:33:32.320 --> 00:33:33.580
people are all really

00:33:33.580 --> 00:33:35.260
refining like the, the

00:33:35.260 --> 00:33:35.980
core parts.

00:33:36.200 --> 00:33:36.320
Right.

00:33:36.320 --> 00:33:36.660
Yeah.

00:33:36.660 --> 00:33:37.660
I think that's, that's

00:33:37.660 --> 00:33:38.340
definitely the case.

00:33:38.340 --> 00:33:39.400
And some of the biology

00:33:39.400 --> 00:33:40.960
specific tools are, are

00:33:40.960 --> 00:33:41.620
a little, a little

00:33:41.620 --> 00:33:43.080
walkie when you, when

00:33:43.080 --> 00:33:43.860
you start using them.

00:33:43.860 --> 00:33:44.980
I think, I mean, things

00:33:44.980 --> 00:33:46.400
like pandas are, are

00:33:46.400 --> 00:33:47.340
really amazing.

00:33:47.340 --> 00:33:48.820
You can tell the amount

00:33:48.820 --> 00:33:49.780
of attention or something

00:33:49.780 --> 00:33:50.460
is different.

00:33:50.460 --> 00:33:51.060
Cool.

00:33:51.520 --> 00:33:52.980
what is moving to production

00:33:52.980 --> 00:33:54.240
look like for you.

00:33:54.240 --> 00:33:55.140
So you talked about

00:33:55.140 --> 00:33:56.460
sometimes it's, you start

00:33:56.460 --> 00:33:57.560
the exploration and stuff

00:33:57.560 --> 00:33:58.460
in notebooks, which is

00:33:58.460 --> 00:33:59.680
exactly what they're built

00:33:59.680 --> 00:33:59.940
for.

00:33:59.940 --> 00:34:02.180
And then moving to maybe a

00:34:02.180 --> 00:34:03.640
little more composition of

00:34:03.640 --> 00:34:04.480
scripts and whatnot.

00:34:04.480 --> 00:34:05.800
And eventually somehow you

00:34:05.800 --> 00:34:06.820
end up with, you know,

00:34:06.820 --> 00:34:08.360
Lambda, cloud databases,

00:34:08.360 --> 00:34:09.820
things like that.

00:34:09.820 --> 00:34:10.660
What's that flow?

00:34:10.660 --> 00:34:11.080
Yeah.

00:34:11.080 --> 00:34:12.840
So the process of, I

00:34:12.840 --> 00:34:13.700
guess we say like

00:34:13.700 --> 00:34:15.260
productionizing a pipeline

00:34:15.260 --> 00:34:17.340
is we've had pretty well

00:34:17.340 --> 00:34:17.900
set now.

00:34:17.900 --> 00:34:19.240
and generally how it

00:34:19.240 --> 00:34:21.020
works as we say this

00:34:21.020 --> 00:34:22.900
pipeline is about done

00:34:22.900 --> 00:34:25.380
and we'll hand it off to

00:34:25.380 --> 00:34:27.020
myself or one of my

00:34:27.020 --> 00:34:28.740
colleagues to start the

00:34:28.740 --> 00:34:29.660
process of getting it

00:34:29.660 --> 00:34:31.920
fully cloud capable and

00:34:31.920 --> 00:34:32.480
scalable.

00:34:32.480 --> 00:34:34.640
And what that means for us

00:34:34.640 --> 00:34:36.420
is to take the software

00:34:36.420 --> 00:34:37.560
in whatever form we've

00:34:37.560 --> 00:34:38.540
gotten it from our

00:34:38.540 --> 00:34:40.340
colleagues and put it

00:34:40.340 --> 00:34:42.220
into a workflow manager.

00:34:42.220 --> 00:34:43.780
And we, I think every

00:34:43.780 --> 00:34:44.920
company has their own

00:34:44.920 --> 00:34:45.960
version of workflow

00:34:45.960 --> 00:34:47.080
manager that they, they

00:34:47.080 --> 00:34:47.540
choose.

00:34:47.760 --> 00:34:49.780
we're using Luigi, which

00:34:49.780 --> 00:34:51.440
is fully Python based.

00:34:51.440 --> 00:34:52.740
It was originally

00:34:52.740 --> 00:34:55.100
developed at Spotify to

00:34:55.100 --> 00:34:57.300
do this sort of task.

00:34:57.300 --> 00:34:59.380
It uses like a GNU make

00:34:59.380 --> 00:35:02.160
type target file dag

00:35:02.160 --> 00:35:02.820
creation.

00:35:02.820 --> 00:35:04.360
I don't know all the

00:35:04.360 --> 00:35:05.200
technical terms to

00:35:05.200 --> 00:35:06.600
describe how the tasks

00:35:06.600 --> 00:35:07.560
are built, but you

00:35:07.560 --> 00:35:08.920
essentially, you have a

00:35:08.920 --> 00:35:10.540
task at the end and you

00:35:10.540 --> 00:35:11.940
say it requires the

00:35:11.940 --> 00:35:13.240
output of this other

00:35:13.240 --> 00:35:13.620
task.

00:35:13.620 --> 00:35:14.840
And then that task

00:35:14.840 --> 00:35:16.540
requires the more.

00:35:16.680 --> 00:35:17.840
And as they build up,

00:35:17.840 --> 00:35:20.020
you create a graph of

00:35:20.020 --> 00:35:20.940
what tasks need to be

00:35:20.940 --> 00:35:21.960
done to get to our

00:35:21.960 --> 00:35:22.400
output.

00:35:22.400 --> 00:35:22.680
Right.

00:35:22.680 --> 00:35:24.280
A directed acyclic

00:35:24.280 --> 00:35:24.740
graph.

00:35:24.740 --> 00:35:26.160
And then the workflow

00:35:26.160 --> 00:35:27.060
can decide like, oh,

00:35:27.060 --> 00:35:27.760
these two things are

00:35:27.760 --> 00:35:28.160
independent.

00:35:28.160 --> 00:35:29.240
So let's scale them out

00:35:29.240 --> 00:35:29.660
separately.

00:35:30.280 --> 00:35:31.480
now this one has to wait for

00:35:31.480 --> 00:35:32.400
these two to finish and

00:35:32.400 --> 00:35:33.200
then get its results.

00:35:33.200 --> 00:35:34.760
And that coordination can

00:35:34.760 --> 00:35:35.400
be really tricky.

00:35:35.400 --> 00:35:36.000
Exactly.

00:35:36.000 --> 00:35:37.420
And there's a number of

00:35:37.420 --> 00:35:38.500
common workflow managers

00:35:38.500 --> 00:35:39.660
and bioinformatics.

00:35:39.660 --> 00:35:40.640
I think the two most

00:35:40.640 --> 00:35:42.680
common are snake make and

00:35:42.680 --> 00:35:43.340
next flow.

00:35:43.340 --> 00:35:45.580
Luigi is, has also been

00:35:45.580 --> 00:35:47.100
really good for us.

00:35:47.100 --> 00:35:48.400
We like it primarily

00:35:48.400 --> 00:35:49.740
because it is fully

00:35:49.740 --> 00:35:51.060
Python based and it uses

00:35:51.060 --> 00:35:52.720
standard Python syntax,

00:35:52.720 --> 00:35:54.600
which allows us to

00:35:54.600 --> 00:35:56.080
really, if we need to,

00:35:56.080 --> 00:35:57.160
get out of the hood and

00:35:57.160 --> 00:35:58.460
add some customization,

00:35:58.460 --> 00:36:00.240
extend it where we need

00:36:00.240 --> 00:36:02.220
to, or, or fix things

00:36:02.220 --> 00:36:03.020
that we don't like about

00:36:03.020 --> 00:36:03.200
it.

00:36:03.200 --> 00:36:04.220
And that was a really

00:36:04.220 --> 00:36:05.520
important part of our

00:36:05.520 --> 00:36:06.440
decision and choosing

00:36:06.440 --> 00:36:07.800
Luigi over some of these

00:36:07.800 --> 00:36:09.340
other workflow managers.

00:36:09.340 --> 00:36:10.480
Yeah, for sure.

00:36:10.480 --> 00:36:11.960
I had a nice conversation

00:36:11.960 --> 00:36:13.160
with the Airflow, Apache

00:36:13.160 --> 00:36:14.540
Airflow folks, and not

00:36:14.540 --> 00:36:15.320
too long ago.

00:36:15.320 --> 00:36:16.760
And one of the things

00:36:16.760 --> 00:36:17.720
that really struck me

00:36:17.720 --> 00:36:19.520
about this is the ability

00:36:19.520 --> 00:36:21.440
for people to work on

00:36:21.440 --> 00:36:22.600
little parts of the

00:36:22.600 --> 00:36:23.620
processing, a little bit

00:36:23.620 --> 00:36:25.400
like that, little Python

00:36:25.400 --> 00:36:26.700
automation tools or a

00:36:26.700 --> 00:36:28.360
little Python projects

00:36:28.360 --> 00:36:29.480
that you described

00:36:29.480 --> 00:36:30.840
earlier in episode 327

00:36:30.840 --> 00:36:32.620
in that instead of

00:36:32.620 --> 00:36:33.220
trying to figure out

00:36:33.220 --> 00:36:34.300
all this orchestration,

00:36:34.300 --> 00:36:35.140
you just have to figure

00:36:35.140 --> 00:36:36.240
out, well, this little

00:36:36.240 --> 00:36:37.220
task is going to do a

00:36:37.220 --> 00:36:37.560
thing.

00:36:37.560 --> 00:36:38.700
And that, like I said,

00:36:38.700 --> 00:36:40.080
maybe it means see the

00:36:40.080 --> 00:36:41.860
file and then copy it

00:36:41.860 --> 00:36:42.360
over there.

00:36:42.360 --> 00:36:43.860
And if your job was

00:36:43.860 --> 00:36:45.400
see a file here, copy

00:36:45.400 --> 00:36:46.100
it over there, like

00:36:46.100 --> 00:36:47.340
that's a really simple

00:36:47.340 --> 00:36:47.780
job.

00:36:47.780 --> 00:36:49.040
You can totally nail

00:36:49.040 --> 00:36:49.320
that.

00:36:49.320 --> 00:36:49.980
You know what I mean?

00:36:49.980 --> 00:36:50.280
Yeah.

00:36:50.280 --> 00:36:51.560
Whereas if your job is

00:36:51.560 --> 00:36:52.760
to orchestrate this,

00:36:52.760 --> 00:36:54.000
this graph and make sure

00:36:54.000 --> 00:36:55.060
that it runs on time

00:36:55.060 --> 00:36:55.920
and here's the failure

00:36:55.920 --> 00:36:56.860
case, all of a sudden

00:36:56.860 --> 00:36:57.800
that becomes super,

00:36:57.800 --> 00:36:58.400
super hard.

00:36:58.400 --> 00:36:59.340
So these seem really

00:36:59.340 --> 00:37:01.020
empowering, almost like

00:37:01.020 --> 00:37:01.920
the promise of

00:37:01.920 --> 00:37:03.140
microservices is like

00:37:03.140 --> 00:37:03.960
you get to focus on

00:37:03.960 --> 00:37:05.520
one little part and do

00:37:05.520 --> 00:37:05.780
that.

00:37:05.780 --> 00:37:06.700
Yeah, it definitely,

00:37:06.700 --> 00:37:08.060
it definitely helps.

00:37:08.060 --> 00:37:09.500
And it helps with that

00:37:09.500 --> 00:37:10.340
idea of having these

00:37:10.340 --> 00:37:11.720
small tasks.

00:37:11.720 --> 00:37:13.380
It really helps with how

00:37:13.380 --> 00:37:14.900
you can develop it and

00:37:14.900 --> 00:37:16.560
reuse the components

00:37:16.560 --> 00:37:18.020
for each task.

00:37:18.020 --> 00:37:19.040
Like we might, as we

00:37:19.040 --> 00:37:19.860
said earlier, that there

00:37:19.860 --> 00:37:20.540
are these third party

00:37:20.540 --> 00:37:21.840
tools that end up being

00:37:21.840 --> 00:37:23.360
used in almost all of

00:37:23.360 --> 00:37:24.960
our pipelines and using

00:37:24.960 --> 00:37:26.520
something like Luigi or

00:37:26.520 --> 00:37:27.900
any workflow manager.

00:37:27.900 --> 00:37:29.820
You can reuse the tasks

00:37:29.820 --> 00:37:31.480
in different contexts as

00:37:31.480 --> 00:37:33.020
need be and you can have

00:37:33.020 --> 00:37:34.560
your perfectly optimized

00:37:34.560 --> 00:37:36.340
way of using that task

00:37:36.340 --> 00:37:37.100
everywhere.

00:37:37.100 --> 00:37:39.180
That reuse is really nice

00:37:39.180 --> 00:37:39.920
and it's something I think

00:37:39.920 --> 00:37:40.580
a lot of software

00:37:40.580 --> 00:37:41.500
developers appreciate.

00:37:41.780 --> 00:37:42.480
Yeah, for sure.

00:37:42.480 --> 00:37:43.640
So if you look at some of

00:37:43.640 --> 00:37:44.660
the folks that are using

00:37:44.660 --> 00:37:47.120
Luigi, so Spotify, as you

00:37:47.120 --> 00:37:49.280
said, created it, but also

00:37:49.280 --> 00:37:51.420
Foursquare, Stripe, Asana,

00:37:51.420 --> 00:37:54.440
SeatGeek, a lot of companies

00:37:54.440 --> 00:37:55.680
that people probably heard

00:37:55.680 --> 00:37:57.120
of like, oh, these places

00:37:57.120 --> 00:37:58.060
are doing awesome stuff.

00:37:58.060 --> 00:37:58.800
Let's be like them.

00:37:58.800 --> 00:37:59.240
Yeah.

00:37:59.240 --> 00:38:01.260
A lot of places use it for

00:38:01.260 --> 00:38:03.460
like Hadoop and things like

00:38:03.460 --> 00:38:03.820
that.

00:38:03.820 --> 00:38:05.400
And one of the nice things is

00:38:05.400 --> 00:38:07.240
you mentioned about like how

00:38:07.240 --> 00:38:08.560
Airflow has the same model

00:38:08.560 --> 00:38:10.400
where you can create these

00:38:10.400 --> 00:38:13.080
contributions, which are

00:38:13.080 --> 00:38:14.640
different connectors for

00:38:14.640 --> 00:38:16.440
Luigi or for Airflow, where

00:38:16.440 --> 00:38:17.520
you can connect them to

00:38:17.520 --> 00:38:18.260
their different cloud

00:38:18.260 --> 00:38:20.100
providers or different data

00:38:20.100 --> 00:38:21.660
stores, things like that.

00:38:21.660 --> 00:38:24.740
And that allows you to use

00:38:24.740 --> 00:38:26.420
Luigi or any workflow manager

00:38:26.420 --> 00:38:27.840
in numerous different

00:38:27.840 --> 00:38:29.060
contexts, whether it's

00:38:29.060 --> 00:38:29.960
locally on your own

00:38:29.960 --> 00:38:31.440
computer running things in

00:38:31.440 --> 00:38:33.840
Docker containers or whether

00:38:33.840 --> 00:38:35.920
it's deploying out to AWS

00:38:35.920 --> 00:38:37.940
and scaling massively

00:38:37.940 --> 00:38:38.500
horizontal.

00:38:38.500 --> 00:38:40.000
These workflow managers

00:38:40.000 --> 00:38:41.200
really support that.

00:38:41.200 --> 00:38:42.380
And that's why they're a

00:38:42.380 --> 00:38:44.280
necessary component in how

00:38:44.280 --> 00:38:45.860
we productionize our data

00:38:45.860 --> 00:38:46.140
pipelines.

00:38:46.140 --> 00:38:46.740
Yeah.

00:38:46.740 --> 00:38:48.280
Again, they just seem so

00:38:48.280 --> 00:38:49.460
empowering for allowing

00:38:49.460 --> 00:38:50.500
people to focus on just

00:38:50.500 --> 00:38:51.840
each step independently,

00:38:51.840 --> 00:38:53.180
which is excellent.

00:38:53.180 --> 00:38:54.460
Did you consider other ones

00:38:54.460 --> 00:38:55.460
like did you consider

00:38:55.460 --> 00:38:57.720
Airflow or DAXer or any

00:38:57.720 --> 00:38:59.420
of these other ones or did

00:38:59.420 --> 00:39:00.160
you find this fit and

00:39:00.160 --> 00:39:00.920
you're like, we're going

00:39:00.920 --> 00:39:01.260
with this?

00:39:01.260 --> 00:39:02.900
We did look at some

00:39:02.900 --> 00:39:03.360
other ones.

00:39:03.360 --> 00:39:05.980
We were using Nextflow

00:39:05.980 --> 00:39:07.220
for a little bit, which is

00:39:07.220 --> 00:39:08.420
a bioinformatic

00:39:08.420 --> 00:39:10.120
flavored workflow

00:39:10.120 --> 00:39:10.480
manager.

00:39:10.480 --> 00:39:12.080
It's very focused on

00:39:12.080 --> 00:39:13.320
bioinformatics as its

00:39:13.320 --> 00:39:14.760
primary use case,

00:39:14.760 --> 00:39:15.540
although you could use it

00:39:15.540 --> 00:39:16.000
for anything.

00:39:16.000 --> 00:39:18.280
Syntax is similar to

00:39:18.280 --> 00:39:19.620
Groovy and it's based

00:39:19.620 --> 00:39:20.180
in Groovy.

00:39:20.180 --> 00:39:22.340
And that was one of the

00:39:22.340 --> 00:39:23.740
detractives for us is that

00:39:23.740 --> 00:39:24.660
it was a little hard to get

00:39:24.660 --> 00:39:26.380
under the hood and use

00:39:26.380 --> 00:39:27.220
that because of it.

00:39:27.220 --> 00:39:28.920
I did briefly look at DAXer

00:39:28.920 --> 00:39:30.580
after hearing a few

00:39:30.580 --> 00:39:31.420
episodes, I think.

00:39:31.420 --> 00:39:32.420
No, maybe a different

00:39:32.420 --> 00:39:32.840
podcast.

00:39:32.920 --> 00:39:34.500
Yeah, I did have Tobias

00:39:34.500 --> 00:39:35.900
Macy on to give us an

00:39:35.900 --> 00:39:36.980
overview of the whole data

00:39:36.980 --> 00:39:37.740
engineering landscape.

00:39:37.740 --> 00:39:39.120
So possibly, I know he

00:39:39.120 --> 00:39:40.280
spoke about it then, but I'm

00:39:40.280 --> 00:39:41.200
not sure when you heard

00:39:41.200 --> 00:39:41.560
about it.

00:39:41.560 --> 00:39:42.920
Yeah, so I heard about it

00:39:42.920 --> 00:39:44.080
on a podcast and probably

00:39:44.080 --> 00:39:44.840
this one as well.

00:39:44.840 --> 00:39:46.600
And I did look into it, but

00:39:46.600 --> 00:39:48.040
it didn't have it at that

00:39:48.040 --> 00:39:48.320
time.

00:39:48.320 --> 00:39:49.440
It was pretty early and it

00:39:49.440 --> 00:39:50.620
didn't have any connectors

00:39:50.620 --> 00:39:53.220
to AWS in the ways that we

00:39:53.220 --> 00:39:54.120
like to use.

00:39:54.120 --> 00:39:55.720
The connectors, right?

00:39:55.720 --> 00:39:56.660
That's such an important

00:39:56.660 --> 00:39:57.540
thing because otherwise

00:39:57.540 --> 00:39:59.040
you've got to learn the API

00:39:59.040 --> 00:40:00.360
of every single thing you're

00:40:00.360 --> 00:40:00.860
talking to.

00:40:01.080 --> 00:40:01.340
Yeah.

00:40:01.340 --> 00:40:02.960
These days, knowing how

00:40:02.960 --> 00:40:04.860
Luigi works, it actually

00:40:04.860 --> 00:40:05.660
wouldn't have been that big

00:40:05.660 --> 00:40:07.220
of a task to look under

00:40:07.220 --> 00:40:07.560
the hood.

00:40:07.560 --> 00:40:09.260
But yeah, so we did choose

00:40:09.260 --> 00:40:11.460
Luigi and particularly we

00:40:11.460 --> 00:40:13.060
like how it handles

00:40:13.060 --> 00:40:16.600
deployment to AWS and we

00:40:16.600 --> 00:40:18.260
use it on the service

00:40:18.260 --> 00:40:20.100
called AWS Batch, which

00:40:20.100 --> 00:40:22.740
is, I guess it might be

00:40:22.740 --> 00:40:23.860
similar to like

00:40:23.860 --> 00:40:25.780
Kubernetes pod, although I

00:40:25.780 --> 00:40:27.260
haven't done anything with

00:40:27.260 --> 00:40:29.260
K8s or anything like that.

00:40:29.320 --> 00:40:31.160
so I'm not speaking from

00:40:31.160 --> 00:40:32.600
experience, but it

00:40:32.600 --> 00:40:34.980
essentially scales up EC2

00:40:34.980 --> 00:40:36.240
instances, these elastic

00:40:36.240 --> 00:40:39.520
compute instances on the

00:40:39.520 --> 00:40:41.260
cloud as you need them.

00:40:41.260 --> 00:40:43.540
And it gives out jobs to

00:40:43.540 --> 00:40:45.920
the virtual computers as

00:40:45.920 --> 00:40:46.520
necessary.

00:40:46.520 --> 00:40:48.080
So it spins them up,

00:40:48.080 --> 00:40:49.620
allocates jobs in a

00:40:49.620 --> 00:40:50.320
Docker container.

00:40:50.320 --> 00:40:52.400
They run when there's no

00:40:52.400 --> 00:40:53.640
more jobs on the instance,

00:40:53.640 --> 00:40:54.640
it shuts off.

00:40:54.840 --> 00:40:55.080
Okay.

00:40:55.080 --> 00:40:57.220
So you come up with like an

00:40:57.220 --> 00:40:58.740
AMI, an Amazon machine

00:40:58.740 --> 00:41:00.560
image that's pre-configured,

00:41:00.560 --> 00:41:01.980
set up, ready to run.

00:41:01.980 --> 00:41:03.500
And then you say, I'm going

00:41:03.500 --> 00:41:04.300
to give you a bunch of

00:41:04.300 --> 00:41:04.940
data.

00:41:04.940 --> 00:41:06.480
Each one of these data gets

00:41:06.480 --> 00:41:07.440
passed to the machine and

00:41:07.440 --> 00:41:08.860
it runs and then maybe even

00:41:08.860 --> 00:41:09.860
shuts down when it's done.

00:41:09.860 --> 00:41:10.480
Yeah.

00:41:10.480 --> 00:41:11.540
There is an AMI.

00:41:11.540 --> 00:41:12.640
We keep the AMI pretty

00:41:12.640 --> 00:41:14.200
simple because it's the sort

00:41:14.200 --> 00:41:15.340
of the base for all of

00:41:15.340 --> 00:41:15.460
them.

00:41:15.500 --> 00:41:16.840
And then the way batch

00:41:16.840 --> 00:41:19.240
works is you have your top

00:41:19.240 --> 00:41:20.880
level AMI that's called the

00:41:20.880 --> 00:41:22.600
compute environment, I

00:41:22.600 --> 00:41:22.940
believe.

00:41:22.940 --> 00:41:25.260
And then inside of it, you

00:41:25.260 --> 00:41:27.040
run the actual job and the

00:41:27.040 --> 00:41:28.720
job runs inside of a

00:41:28.720 --> 00:41:29.440
Docker container.

00:41:29.440 --> 00:41:29.980
Oh, I see.

00:41:29.980 --> 00:41:31.440
So the Docker container is

00:41:31.440 --> 00:41:32.800
pre-configured with like all

00:41:32.800 --> 00:41:34.420
the Python dependencies and

00:41:34.420 --> 00:41:35.540
the settings that it needs and

00:41:35.540 --> 00:41:35.760
whatnot.

00:41:35.760 --> 00:41:36.300
Right.

00:41:36.300 --> 00:41:38.740
So we have each task in

00:41:38.740 --> 00:41:41.040
Luigi, each little piece of

00:41:41.040 --> 00:41:43.120
work as its own Docker

00:41:43.120 --> 00:41:43.560
container.

00:41:43.780 --> 00:41:46.160
and then we push those

00:41:46.160 --> 00:41:47.880
out into the cloud and they

00:41:47.880 --> 00:41:49.520
get allocated out onto these

00:41:49.520 --> 00:41:50.100
machines.

00:41:50.100 --> 00:41:51.440
They run their task.

00:41:51.440 --> 00:41:54.400
Data comes in from S3, goes

00:41:54.400 --> 00:41:55.500
back out to S3.

00:41:55.500 --> 00:41:57.200
Nothing is left on the hard

00:41:57.200 --> 00:41:58.500
drives and then they

00:41:58.500 --> 00:41:59.200
disappear.

00:41:59.200 --> 00:42:01.080
They're these little ephemeral

00:42:01.080 --> 00:42:02.380
compute instances.

00:42:02.380 --> 00:42:04.800
And that's all managed by a

00:42:04.800 --> 00:42:05.920
workflow manager such as

00:42:05.920 --> 00:42:07.540
Luigi or Airflow or

00:42:07.540 --> 00:42:07.940
Nexflow.

00:42:07.940 --> 00:42:08.380
Wow.

00:42:08.380 --> 00:42:09.540
That's pretty awesome.

00:42:09.540 --> 00:42:11.280
One of the things that I

00:42:11.280 --> 00:42:13.220
remember reading and

00:42:13.220 --> 00:42:14.740
thinking that's a pretty

00:42:14.740 --> 00:42:16.460
crazy use of the cloud was

00:42:16.460 --> 00:42:18.440
this Ars Technica article

00:42:18.440 --> 00:42:20.160
from look at that year,

00:42:20.160 --> 00:42:21.060
2011.

00:42:21.060 --> 00:42:21.780
Oh, wow.

00:42:21.780 --> 00:42:23.220
So if you think back to

00:42:23.220 --> 00:42:25.200
2011, like the cloud was

00:42:25.200 --> 00:42:27.700
really new and the idea of

00:42:27.700 --> 00:42:28.860
spending a ton of money on

00:42:28.860 --> 00:42:29.800
it and getting a bunch of

00:42:29.800 --> 00:42:31.100
compute out of it was still

00:42:31.100 --> 00:42:32.600
somewhat foreign to people.

00:42:32.600 --> 00:42:34.020
So there's this article I'll

00:42:34.020 --> 00:42:35.820
link to called the 100 or

00:42:35.820 --> 00:42:39.220
1,279 per dollar per hour,

00:42:39.700 --> 00:42:42.840
30,000 core cluster built on

00:42:42.840 --> 00:42:45.380
Amazon EC2 cloud, which is

00:42:45.380 --> 00:42:46.260
this company, this

00:42:46.260 --> 00:42:47.540
pharmaceutical company that

00:42:47.540 --> 00:42:49.120
needed to do a lot of

00:42:49.120 --> 00:42:49.880
computing.

00:42:49.880 --> 00:42:51.420
And they said, instead of

00:42:51.420 --> 00:42:52.960
buying a supercomputer,

00:42:52.960 --> 00:42:54.520
basically, we're going to

00:42:54.520 --> 00:42:56.420
come up and just fire off an

00:42:56.420 --> 00:42:57.420
insane amount of cores.

00:42:57.420 --> 00:42:58.480
And I think if I remember

00:42:58.480 --> 00:43:00.400
reading this correctly, that

00:43:00.400 --> 00:43:01.740
they weren't allowed to make

00:43:01.740 --> 00:43:04.400
that many cores in a single

00:43:04.400 --> 00:43:05.180
data center.

00:43:05.180 --> 00:43:06.680
so they had to do this

00:43:06.680 --> 00:43:07.380
across.

00:43:07.380 --> 00:43:08.780
They also had to coordinate

00:43:08.780 --> 00:43:10.320
in like multi data center

00:43:10.320 --> 00:43:12.440
type of processing as well

00:43:12.440 --> 00:43:14.640
because, yeah, it's just the

00:43:14.640 --> 00:43:15.760
scale of everything.

00:43:15.760 --> 00:43:17.500
This seems like the type of

00:43:17.500 --> 00:43:18.420
work that you all might be

00:43:18.420 --> 00:43:18.660
doing.

00:43:18.660 --> 00:43:20.980
Yeah, it does look very

00:43:20.980 --> 00:43:21.380
familiar.

00:43:21.380 --> 00:43:22.820
Okay.

00:43:22.820 --> 00:43:24.040
You got any war stories?

00:43:24.040 --> 00:43:24.700
Can you tell us anything

00:43:24.700 --> 00:43:25.200
about this?

00:43:25.200 --> 00:43:26.900
Yeah, we do occasionally have

00:43:26.900 --> 00:43:28.820
a certain type of molecular

00:43:28.820 --> 00:43:31.860
modeling job that we can scale

00:43:31.860 --> 00:43:33.760
very wide.

00:43:33.760 --> 00:43:36.420
And I think these, this sort

00:43:36.420 --> 00:43:38.080
of 30,000 number looks pretty

00:43:38.080 --> 00:43:38.340
familiar.

00:43:38.340 --> 00:43:40.780
I think our largest jobs

00:43:40.780 --> 00:43:43.180
today have been about 10,000

00:43:43.180 --> 00:43:46.540
CPUs wide and running for a

00:43:46.540 --> 00:43:47.180
few days.

00:43:47.180 --> 00:43:48.320
So maybe like four or five

00:43:48.320 --> 00:43:48.760
days.

00:43:48.760 --> 00:43:50.140
I think the number was like

00:43:50.140 --> 00:43:52.280
four or five days on the 10,000

00:43:52.280 --> 00:43:52.660
cores.

00:43:52.660 --> 00:43:53.200
Yeah.

00:43:53.200 --> 00:43:53.800
Yeah.

00:43:53.800 --> 00:43:56.100
It's a, it's, it's a lot.

00:43:56.100 --> 00:43:57.280
And I, so I think it was like

00:43:57.280 --> 00:44:01.280
over a million CPU hours on AWS

00:44:01.280 --> 00:44:01.780
batch.

00:44:01.780 --> 00:44:04.880
And that was just something that

00:44:04.880 --> 00:44:06.280
we could really heavily

00:44:06.280 --> 00:44:08.120
parallelize and we needed the

00:44:08.120 --> 00:44:10.540
data fast and it worked.

00:44:10.540 --> 00:44:12.560
You pull it all back and

00:44:12.560 --> 00:44:13.900
aggregate it all together at the

00:44:13.900 --> 00:44:16.560
end that it was a really useful

00:44:16.560 --> 00:44:17.080
data set.

00:44:17.080 --> 00:44:19.220
And it's pretty amazing what you

00:44:19.220 --> 00:44:21.100
can do on some of these cloud

00:44:21.100 --> 00:44:23.120
providers by going really wide.

00:44:23.120 --> 00:44:23.540
Yeah.

00:44:23.540 --> 00:44:24.560
It's crazy.

00:44:25.000 --> 00:44:26.020
You know, I mean, there's some

00:44:26.020 --> 00:44:27.500
places where it makes sense to

00:44:27.500 --> 00:44:29.620
like build true supercomputers

00:44:29.620 --> 00:44:31.680
like Oak Ridge has this thing

00:44:31.680 --> 00:44:33.140
called summit, which is like

00:44:33.140 --> 00:44:35.280
this insane supercomputer that

00:44:35.280 --> 00:44:35.780
they have.

00:44:35.780 --> 00:44:38.040
But a lot of times there's the

00:44:38.040 --> 00:44:39.560
latency of getting something like

00:44:39.560 --> 00:44:40.160
this set up.

00:44:40.160 --> 00:44:42.340
There's the overhead of, guess

00:44:42.340 --> 00:44:42.540
what?

00:44:42.540 --> 00:44:44.000
Now you're an admin for like an

00:44:44.000 --> 00:44:45.620
insane, there's only three in

00:44:45.620 --> 00:44:47.260
the world supercomputer type

00:44:47.260 --> 00:44:47.820
system.

00:44:47.820 --> 00:44:49.520
It's got to be empowering to be

00:44:49.520 --> 00:44:51.900
able to just go hit go and then

00:44:51.900 --> 00:44:53.520
let all this happen and not worry

00:44:53.520 --> 00:44:54.880
about all those details.

00:44:54.900 --> 00:44:55.160
Right.

00:44:55.160 --> 00:44:55.600
Yeah.

00:44:55.600 --> 00:44:56.640
And there's definitely still

00:44:56.640 --> 00:44:58.400
some stress involved in, in

00:44:58.400 --> 00:44:59.420
starting one of these jobs.

00:44:59.420 --> 00:45:00.980
If you just, you know, it's not

00:45:00.980 --> 00:45:03.140
cheap anyway, slice it.

00:45:03.140 --> 00:45:04.400
We do, we do try to, you know,

00:45:04.400 --> 00:45:05.880
do everything we can to make it

00:45:05.880 --> 00:45:08.020
as, as efficient in cost as

00:45:08.020 --> 00:45:08.420
possible.

00:45:08.420 --> 00:45:09.880
But yeah, I'm sure there's,

00:45:09.880 --> 00:45:11.460
there's two aspects to it that

00:45:11.460 --> 00:45:12.640
really jump out to me.

00:45:12.640 --> 00:45:14.560
One is the, Oh, was that the

00:45:14.560 --> 00:45:15.740
wrong version of the code?

00:45:15.740 --> 00:45:17.040
The one that still had the bug?

00:45:17.040 --> 00:45:18.140
We got to throw away all the

00:45:18.140 --> 00:45:18.440
data.

00:45:18.440 --> 00:45:18.860
Whoops.

00:45:18.860 --> 00:45:20.720
We just ran for five days and,

00:45:20.720 --> 00:45:22.560
you know, thousands of dollars

00:45:22.560 --> 00:45:24.520
got burned up and there's a bit

00:45:24.520 --> 00:45:25.620
of a problem there.

00:45:25.620 --> 00:45:26.760
So whoops.

00:45:26.760 --> 00:45:28.260
And now it's five days later until

00:45:28.260 --> 00:45:29.400
you get the answer as well.

00:45:29.400 --> 00:45:29.680
Right.

00:45:29.680 --> 00:45:31.560
That's one.

00:45:31.560 --> 00:45:33.640
And then I'm losing track of my

00:45:33.640 --> 00:45:34.280
thought on my other one, but

00:45:34.280 --> 00:45:36.280
yeah, anyway, it's just got to be

00:45:36.280 --> 00:45:38.900
stressful to be like, to set that

00:45:38.900 --> 00:45:39.720
up and then press go.

00:45:39.720 --> 00:45:40.000
Right.

00:45:40.160 --> 00:45:41.080
it definitely is.

00:45:41.080 --> 00:45:42.960
I think one of the benefits of a

00:45:42.960 --> 00:45:44.500
lot of our computational team does

00:45:44.500 --> 00:45:46.820
have a spare metal background and

00:45:46.820 --> 00:45:49.700
doing experiments in the lab, these

00:45:49.700 --> 00:45:51.440
sort of numbers, like tens of

00:45:51.440 --> 00:45:52.380
thousands of dollars for an

00:45:52.380 --> 00:45:54.460
experiment are not really that

00:45:54.460 --> 00:45:54.900
uncommon.

00:45:54.900 --> 00:45:56.620
And those kinds of things, you get

00:45:56.620 --> 00:45:58.180
really careful and you check all

00:45:58.180 --> 00:45:59.280
the boxes and double check

00:45:59.280 --> 00:45:59.660
everything.

00:45:59.660 --> 00:46:00.960
And so I think a lot of us have

00:46:00.960 --> 00:46:02.480
had that, that experience.

00:46:02.480 --> 00:46:03.920
And so even when we're dealing

00:46:03.920 --> 00:46:05.960
with software, we'll be very

00:46:05.960 --> 00:46:08.260
careful and we'll do the tests and

00:46:08.260 --> 00:46:09.660
quality control before we really

00:46:09.660 --> 00:46:10.280
let her rip.

00:46:10.280 --> 00:46:10.660
Yeah.

00:46:10.660 --> 00:46:11.680
I, you know, I worked on some

00:46:11.680 --> 00:46:13.240
projects when I was in grad school

00:46:13.240 --> 00:46:16.360
that were on a Silicon graphics, big

00:46:16.360 --> 00:46:17.680
mainframe type thing.

00:46:17.680 --> 00:46:20.720
And obviously much lower importance

00:46:20.720 --> 00:46:23.140
than, you know, solving diseases and

00:46:23.140 --> 00:46:24.640
stuff is just solving math problems.

00:46:24.640 --> 00:46:27.140
But I remember coming in to work on

00:46:27.140 --> 00:46:29.040
the project one day and none of our

00:46:29.040 --> 00:46:31.960
workstations could log in to the

00:46:31.960 --> 00:46:33.020
Silicon graphics machine.

00:46:33.020 --> 00:46:34.960
And what is wrong with this thing?

00:46:34.960 --> 00:46:35.840
And it was so loud.

00:46:35.840 --> 00:46:36.660
It was in the other room.

00:46:36.660 --> 00:46:38.240
You could hear it roaring away.

00:46:38.240 --> 00:46:38.680
in there.

00:46:38.680 --> 00:46:40.100
It clearly was loud.

00:46:40.100 --> 00:46:42.080
And what happened was it wasn't

00:46:42.080 --> 00:46:42.460
me.

00:46:42.460 --> 00:46:44.960
It was someone else in the group

00:46:44.960 --> 00:46:47.060
had written some code.

00:46:47.060 --> 00:46:48.140
And these, these things would run

00:46:48.140 --> 00:46:48.460
all night.

00:46:48.460 --> 00:46:49.360
We'd come in in the morning and

00:46:49.360 --> 00:46:49.960
we'd check them.

00:46:49.960 --> 00:46:52.160
And what had happened was they had

00:46:52.160 --> 00:46:53.900
a bug in their code, which they

00:46:53.900 --> 00:46:55.260
knew they were trying to diagnose

00:46:55.260 --> 00:46:55.520
it.

00:46:55.520 --> 00:46:56.880
So they were printing out a bunch

00:46:56.880 --> 00:46:58.280
of log stuff or something like

00:46:58.280 --> 00:46:58.560
that.

00:46:58.560 --> 00:47:00.260
Well, they did that in a tight

00:47:00.260 --> 00:47:03.560
loop on a high-end computer for a

00:47:03.560 --> 00:47:03.880
night.

00:47:03.880 --> 00:47:05.600
And it filled up the hard drive

00:47:05.600 --> 00:47:06.740
till it had zero bytes left.

00:47:06.840 --> 00:47:07.880
And apparently the Silicon

00:47:07.880 --> 00:47:09.920
graphics machine couldn't operate

00:47:09.920 --> 00:47:12.020
anymore was literally zero bytes.

00:47:12.020 --> 00:47:13.340
And so it just stopped working.

00:47:13.340 --> 00:47:14.640
They couldn't get it eternal.

00:47:14.640 --> 00:47:16.120
I was like, it took days to get it

00:47:16.120 --> 00:47:16.720
back, I believe.

00:47:16.720 --> 00:47:17.800
Oh, oops.

00:47:18.500 --> 00:47:19.960
But it's like that kind of stuff,

00:47:19.960 --> 00:47:20.180
right?

00:47:20.180 --> 00:47:21.200
I mean, this, you're not going to

00:47:21.200 --> 00:47:23.540
break EC2, but, you know, you don't

00:47:23.540 --> 00:47:25.540
know until the next day that, oh, look,

00:47:25.540 --> 00:47:26.640
you filled up the computer and it

00:47:26.640 --> 00:47:27.600
doesn't work anymore, right?

00:47:27.600 --> 00:47:28.640
When you're doing that much

00:47:28.640 --> 00:47:30.920
computing, you could run out of

00:47:30.920 --> 00:47:31.640
different resources.

00:47:31.640 --> 00:47:32.820
You could run into all kinds of

00:47:32.820 --> 00:47:33.180
problems.

00:47:33.180 --> 00:47:33.900
Absolutely.

00:47:34.180 --> 00:47:37.180
And we are without our worst stories

00:47:37.180 --> 00:47:40.180
of doing this, but I think we've

00:47:40.180 --> 00:47:41.820
definitely learned a lot of lessons

00:47:41.820 --> 00:47:43.980
along the way of how to monitor your

00:47:43.980 --> 00:47:46.120
jobs effectively and double check

00:47:46.120 --> 00:47:46.480
things.

00:47:46.480 --> 00:47:49.740
But sometimes, yeah, you run a big

00:47:49.740 --> 00:47:51.300
job and it doesn't quite turn out

00:47:51.300 --> 00:47:51.540
right.

00:47:51.540 --> 00:47:53.160
But it's the cost of doing business,

00:47:53.160 --> 00:47:53.540
I guess.

00:47:53.540 --> 00:47:53.860
Yeah.

00:47:53.860 --> 00:47:54.400
Yeah.

00:47:54.400 --> 00:47:56.000
I mean, it's very computational to

00:47:56.000 --> 00:47:57.820
explore stuff like this kind of stuff.

00:47:57.880 --> 00:47:59.260
But that's also what enables it,

00:47:59.260 --> 00:47:59.480
right?

00:47:59.480 --> 00:48:01.380
Without this computing power, it would

00:48:01.380 --> 00:48:02.420
just not be a thing.

00:48:02.420 --> 00:48:02.940
Absolutely.

00:48:02.940 --> 00:48:04.940
A lot of the data just takes a lot of

00:48:04.940 --> 00:48:06.540
time to process and there's just not

00:48:06.540 --> 00:48:07.460
really any way around it.

00:48:07.460 --> 00:48:08.880
And even when you're iterating, you

00:48:08.880 --> 00:48:11.380
have to go through all the hoops to

00:48:11.380 --> 00:48:12.640
look at the data at the end.

00:48:12.640 --> 00:48:12.880
Yeah.

00:48:12.880 --> 00:48:14.880
So you talked about APIs.

00:48:14.880 --> 00:48:16.640
You talked about data store.

00:48:16.640 --> 00:48:18.740
What are you using for a database?

00:48:18.740 --> 00:48:22.640
Is this like a hosted RDS AWS thing or

00:48:22.640 --> 00:48:24.300
what is the story with that?

00:48:24.300 --> 00:48:24.600
Yeah.

00:48:24.600 --> 00:48:26.500
So we have a few different places to

00:48:26.500 --> 00:48:27.000
store data.

00:48:27.460 --> 00:48:30.940
our larger scale internal data, we

00:48:30.940 --> 00:48:35.120
store in Django-based web app and we

00:48:35.120 --> 00:48:37.720
use the Django ORM for SQL-based

00:48:37.720 --> 00:48:40.500
database, so MySQL database on AWS.

00:48:40.500 --> 00:48:43.120
And that has worked surprisingly

00:48:43.120 --> 00:48:44.200
effectively, actually.

00:48:44.200 --> 00:48:47.000
I've heard some people say that the

00:48:47.000 --> 00:48:49.760
Django ORM is really slow when you

00:48:49.760 --> 00:48:50.760
scale out and things.

00:48:50.760 --> 00:48:53.580
But if you design it correctly, I

00:48:53.580 --> 00:48:55.240
think it'll surprise you.

00:48:55.240 --> 00:48:57.040
I think that's so true.

00:48:57.040 --> 00:48:59.880
I hear so many things about ORMs are

00:48:59.880 --> 00:49:02.620
slow or this thing is slow in this way.

00:49:02.620 --> 00:49:04.840
And wow, if you have the queries

00:49:04.840 --> 00:49:07.300
structured well, you do the joins ahead

00:49:07.300 --> 00:49:07.760
of time.

00:49:07.760 --> 00:49:10.180
If you have indexes and you've put the

00:49:10.180 --> 00:49:12.180
work into finding all these things, it's

00:49:12.180 --> 00:49:12.600
mind-blowing.

00:49:12.600 --> 00:49:15.200
When I go to sites, I won't call any

00:49:15.200 --> 00:49:15.420
out.

00:49:15.620 --> 00:49:17.300
I don't know if they've been updated or whatever.

00:49:17.300 --> 00:49:20.800
But you go to a site and you're like, this site is taking four or five seconds to load.

00:49:20.800 --> 00:49:22.580
What could it possibly be doing?

00:49:22.580 --> 00:49:27.580
I mean, I know it has some data, but it doesn't have unimaginable amounts of data.

00:49:27.580 --> 00:49:27.940
Right?

00:49:27.940 --> 00:49:32.540
Surely somebody could just put an index in here or a worst case, a cache in something.

00:49:32.680 --> 00:49:34.340
And it would just transform it.

00:49:34.340 --> 00:49:34.600
Right?

00:49:34.600 --> 00:49:37.140
So yeah, I'm glad to hear you're having good experiences.

00:49:37.140 --> 00:49:42.540
Yeah, we definitely fairly regularly run into slow queries.

00:49:42.540 --> 00:49:44.800
They're usually not too bad to solve.

00:49:44.800 --> 00:49:48.820
I'm sure at some point we'll get to something really wonky that will be challenging.

00:49:48.820 --> 00:49:54.180
But I think for the most part, yeah, we've been able to solve it through better query design

00:49:54.180 --> 00:49:56.280
and better indexing.

00:49:56.280 --> 00:49:56.560
Yeah.

00:49:56.560 --> 00:50:02.700
Do you ever do things where you opt out of the sort of class-based query syntax and go

00:50:02.700 --> 00:50:07.040
straight to SQL queries here and there to make sure that that part works better?

00:50:07.040 --> 00:50:13.780
We have tried it for some particular sequence-based searches that we do.

00:50:13.780 --> 00:50:17.960
And I actually found that most of the time you can write it in the ORM.

00:50:17.960 --> 00:50:19.600
It's just a little more complicated.

00:50:19.600 --> 00:50:25.060
But I do expect that at some point we will be writing raw SQL queries because out of necessity.

00:50:25.060 --> 00:50:26.520
Yeah, but it's not the majority.

00:50:26.520 --> 00:50:29.360
Mainly you're using the ORM and then it's okay.

00:50:29.360 --> 00:50:29.760
Yeah.

00:50:29.860 --> 00:50:35.600
And I think a lot of benefits from the appropriate data model will help the queries along the way.

00:50:35.600 --> 00:50:36.400
Yeah, absolutely.

00:50:36.400 --> 00:50:41.540
The thing I found the slowest about ORMs and ODM, if you're doing document databases,

00:50:41.540 --> 00:50:44.240
is the deserialization, actually.

00:50:44.240 --> 00:50:49.920
It's not the query time, but it's like, I got to generate 100,000 Python objects

00:50:49.920 --> 00:50:53.700
and that just happens to be not that fast relative to other things.

00:50:53.700 --> 00:50:56.360
You're talking about my Monday morning pipeline.

00:50:58.360 --> 00:51:05.360
And in those cases, I think that's the place where it makes sense to maybe do some kind of like a projection or something.

00:51:05.360 --> 00:51:09.640
I don't know how to do it in Django ORM, but in say Mongo Engine, you can say,

00:51:09.640 --> 00:51:15.780
I know what I'm going to get back is an iterable set of these objects that match to the data,

00:51:15.780 --> 00:51:18.520
but only actually add, just fill out these two fields.

00:51:18.520 --> 00:51:20.380
Most of the data, just throw it away.

00:51:20.380 --> 00:51:22.020
Don't try to parse it and convert it.

00:51:22.020 --> 00:51:23.900
Just like, I just want these two fields.

00:51:24.200 --> 00:51:26.360
And that usually makes it dramatically faster.

00:51:26.360 --> 00:51:31.280
Yeah, we've run into a number of bottlenecks at the serialization layer.

00:51:31.780 --> 00:51:37.360
And we have been experimenting with a variety of different ways to solve those issues.

00:51:37.360 --> 00:51:42.740
And sometimes it means putting fewer Python objects between you and the data.

00:51:42.740 --> 00:51:49.700
And that often speeds it up, even if it makes it a little bit harder to interpret in your development environment.

00:51:49.700 --> 00:51:50.720
Yeah, absolutely.

00:51:50.720 --> 00:51:51.820
Or just say, you know what?

00:51:51.820 --> 00:51:53.200
I just need dictionaries this time.

00:51:53.420 --> 00:51:56.960
I know it's going to be less fun, but that's what it takes.

00:51:56.960 --> 00:51:58.560
That was the fix on Monday morning.

00:51:58.560 --> 00:52:04.140
We do try to extensively use data classes for a lot of our interoperability.

00:52:04.140 --> 00:52:11.380
When data comes in and out of a pipeline, we like to have it in a data class, in a centrally stored repository.

00:52:11.380 --> 00:52:15.080
And then our Django web app also has access to that.

00:52:15.160 --> 00:52:20.960
So it knows what the structure of the data coming in is, and it knows what to serialize it to when it's coming out.

00:52:20.960 --> 00:52:25.400
And the Python data classes has been a really useful tool for that.

00:52:25.400 --> 00:52:30.240
But I think we were talking about that on another podcast a few weeks ago.

00:52:30.240 --> 00:52:31.380
Maybe it was the Python bytes one.

00:52:31.380 --> 00:52:33.940
The data classes can be slow.

00:52:33.940 --> 00:52:40.340
And sometimes it's better to just have a dictionary, even if it is a very highly structured dictionary.

00:52:40.720 --> 00:52:43.040
Yeah, and the problem is maintainability and whatnot.

00:52:43.040 --> 00:52:45.980
But, you know, if it's five times slower, you know what?

00:52:45.980 --> 00:52:47.240
This time it matters.

00:52:47.240 --> 00:52:49.620
So we're going to just bite the bullet and have to deal with it.

00:52:49.620 --> 00:52:50.140
Let's see.

00:52:50.140 --> 00:52:52.980
We had time for just a little bit more digging into it.

00:52:52.980 --> 00:52:56.700
So you talked about the Django ORM, Django REST framework, which is all great.

00:52:56.700 --> 00:53:00.160
What's the server deployment story?

00:53:00.160 --> 00:53:01.400
Like, how do you run that thing?

00:53:01.400 --> 00:53:03.040
Is it with G-Unicorn?

00:53:03.040 --> 00:53:04.280
Is it Micro Whiskey?

00:53:04.280 --> 00:53:07.080
You know, what's your setup on that side of things?

00:53:07.080 --> 00:53:09.860
Ours is a little custom.

00:53:10.380 --> 00:53:12.900
I guess in some ways it's pretty standard.

00:53:12.900 --> 00:53:16.660
I think we're blanking on exactly how it's set up now.

00:53:16.660 --> 00:53:21.420
But there's an NGINX proxy I am blanking on.

00:53:21.420 --> 00:53:22.740
It might be G-Unicorn.

00:53:22.740 --> 00:53:25.340
I feel like G-Unicorn and Django go together frequently.

00:53:25.340 --> 00:53:28.160
I'm not sure why they got paired up specifically.

00:53:28.160 --> 00:53:29.960
But yeah, it's a good one.

00:53:30.120 --> 00:53:39.300
And we end up deploying it out to AWS Elastic Beanstalk, which is a source of some conversation in our team.

00:53:39.300 --> 00:53:41.240
Because there's some things we really like about it.

00:53:41.240 --> 00:53:47.580
And there's some things that are really annoying in terms of the deployment is much more complicated than we would like it to be.

00:53:47.580 --> 00:53:54.460
But we have everything wrapped up in a pretty gnarly CDK stack that does a lot of this work.

00:53:54.460 --> 00:53:57.540
It was messy, but you've solved it with a CDK.

00:53:57.540 --> 00:53:59.540
Now it's just you push the button and it's okay.

00:53:59.540 --> 00:54:00.980
It's exactly like that.

00:54:00.980 --> 00:54:03.840
We have a very automated deployment process.

00:54:03.840 --> 00:54:09.160
I wouldn't like to refactor it, but it's there and it works.

00:54:09.520 --> 00:54:10.900
So that works for us.

00:54:10.900 --> 00:54:14.620
But I think, yeah, it's a pretty standard Django deployment on the cloud.

00:54:14.620 --> 00:54:16.740
And it works well.

00:54:16.740 --> 00:54:17.480
Yeah, cool.

00:54:17.480 --> 00:54:17.940
All right.

00:54:17.940 --> 00:54:22.960
Well, I think that's probably about it for time to talk about the specifics of what you all are doing.

00:54:22.960 --> 00:54:25.900
But there's the last two questions, as always.

00:54:25.900 --> 00:54:27.640
So let's start with the editor.

00:54:27.640 --> 00:54:30.580
If you're going to write some Python code, what editor do you use?

00:54:30.580 --> 00:54:31.380
The yes code.

00:54:31.380 --> 00:54:34.380
A lot of the remote development environment on that.

00:54:34.380 --> 00:54:34.780
Oh, yeah.

00:54:34.780 --> 00:54:37.060
You use the remote aspect of it?

00:54:37.060 --> 00:54:37.340
Yeah.

00:54:37.380 --> 00:54:41.860
We're doing a lot of work on EC2 instances as our day-to-day work.

00:54:41.860 --> 00:54:47.860
And the yes code, the way it works with instances in the cloud is really amazing.

00:54:47.860 --> 00:54:51.080
So I would encourage anyone to check out that extension.

00:54:51.080 --> 00:54:55.280
Yeah, you get access to the file system on the remote machine.

00:54:55.280 --> 00:54:58.340
And basically, it's just your view into that server.

00:54:58.340 --> 00:55:00.260
But it's more or less standard VS Code, right?

00:55:00.260 --> 00:55:02.000
But when you hit run, it just runs up there.

00:55:02.000 --> 00:55:04.260
It feels exactly like you're on your own computer.

00:55:04.480 --> 00:55:07.340
Sometimes I actually get confused whether I'm on or not.

00:55:07.340 --> 00:55:08.580
Oh, so does it work?

00:55:08.580 --> 00:55:09.700
Because I'm in Virginia.

00:55:09.700 --> 00:55:10.100
I see.

00:55:10.100 --> 00:55:10.420
Yeah.

00:55:10.420 --> 00:55:10.720
All right.

00:55:10.720 --> 00:55:12.120
And then notable PyPI package?

00:55:12.120 --> 00:55:14.340
I'll have to shout out some of the ones that we talked about.

00:55:14.340 --> 00:55:17.560
I would encourage people to look at AWS CDK.

00:55:17.560 --> 00:55:21.680
If they're on AWS, I think it has some really interesting things there.

00:55:21.680 --> 00:55:28.000
And then also, Luigi as a workflow manager, if people are doing any of these types of data pipelines

00:55:28.000 --> 00:55:31.380
that have tasks that get reused, these sort of workflow managers are really cool.

00:55:31.380 --> 00:55:35.180
And Luigi is a pretty accessible one, probably one that's familiar with Python.

00:55:35.180 --> 00:55:35.520
Yeah.

00:55:35.520 --> 00:55:36.140
All right.

00:55:36.140 --> 00:55:36.760
Fantastic.

00:55:36.760 --> 00:55:37.140
Yeah.

00:55:37.140 --> 00:55:41.760
I'm just learning to embrace these workflow managers, but they do seem really amazing.

00:55:41.760 --> 00:55:42.520
All right.

00:55:42.520 --> 00:55:47.080
So for all the biologists and scientists out there listening, thinking you've got this really

00:55:47.080 --> 00:55:50.940
cool setup and all this cool computational infrastructure, what do you tell them?

00:55:50.940 --> 00:55:51.680
How do they get started?

00:55:51.680 --> 00:55:54.200
Maybe biology or wherever?

00:55:54.200 --> 00:55:55.980
I think biology is a good place to start.

00:55:55.980 --> 00:55:59.660
We're also happy to have people come from a software background that are really interested

00:55:59.660 --> 00:56:00.980
in learning the biology.

00:56:00.980 --> 00:56:04.960
And I guess as a final plug, we do have a few open positions.

00:56:04.960 --> 00:56:09.960
So if you're interested, check out our careers page and give us an application.

00:56:09.960 --> 00:56:11.940
Are you guys a remote place?

00:56:11.940 --> 00:56:13.000
Remote friendly?

00:56:13.000 --> 00:56:14.580
Or what's the story these days?

00:56:14.580 --> 00:56:14.940
Yep.

00:56:14.940 --> 00:56:15.880
We're remote friendly.

00:56:15.880 --> 00:56:19.520
I'm actually living in Philadelphia and our company is based in Cambridge.

00:56:19.520 --> 00:56:20.480
So we are.

00:56:20.480 --> 00:56:25.400
I mean, it's a short trip to the cloud, no matter where you come from, basically.

00:56:25.500 --> 00:56:25.900
Absolutely.

00:56:25.900 --> 00:56:26.980
Right on.

00:56:26.980 --> 00:56:32.280
David, thank you for being here and giving us this look inside all the gene editing Python

00:56:32.280 --> 00:56:33.140
stuff you're doing.

00:56:33.140 --> 00:56:33.800
Thank you, Michael.

00:56:33.800 --> 00:56:34.260
It was a pleasure.

00:56:34.260 --> 00:56:34.980
Yeah, you bet.

00:56:34.980 --> 00:56:35.360
Bye.

00:56:35.360 --> 00:56:35.640
Bye.

00:56:35.640 --> 00:56:39.400
This has been another episode of Talk Python to Me.

00:56:39.400 --> 00:56:44.400
Our guest on this episode was David Bourne, and it's been brought to you by Shortcut, us

00:56:44.400 --> 00:56:48.200
over at Talk Python Training, and the transcripts were brought to you by Assembly AI.

00:56:48.200 --> 00:56:54.940
Choose Shortcut, formerly Clubhouse.io, for tracking all of your project's work, because you shouldn't

00:56:54.940 --> 00:56:57.060
have to project manage your project management.

00:56:57.060 --> 00:56:59.860
Visit talkpython.fm/shortcut.

00:56:59.860 --> 00:57:03.280
Do you need a great automatic speech-to-text API?

00:57:03.280 --> 00:57:05.820
Get human-level accuracy in just a few lines of code.

00:57:05.820 --> 00:57:08.660
Visit talkpython.fm/assembly AI.

00:57:09.500 --> 00:57:10.440
Want to level up your Python?

00:57:10.440 --> 00:57:10.520
Want to level up your Python?

00:57:10.520 --> 00:57:14.480
We have one of the largest catalogs of Python video courses over at Talk Python.

00:57:14.480 --> 00:57:19.680
Our content ranges from true beginners to deeply advanced topics like memory and async.

00:57:19.680 --> 00:57:22.340
And best of all, there's not a subscription in sight.

00:57:22.340 --> 00:57:25.240
Check it out for yourself at training.talkpython.fm.

00:57:25.380 --> 00:57:27.140
Be sure to subscribe to the show.

00:57:27.140 --> 00:57:29.920
Open your favorite podcast app and search for Python.

00:57:29.920 --> 00:57:31.240
We should be right at the top.

00:57:31.240 --> 00:57:37.320
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct

00:57:37.320 --> 00:57:40.600
RSS feed at /rss on talkpython.fm.

00:57:41.440 --> 00:57:44.040
We're live streaming most of our recordings these days.

00:57:44.040 --> 00:57:51.860
If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

00:57:51.860 --> 00:57:53.720
This is your host, Michael Kennedy.

00:57:53.720 --> 00:57:55.000
Thanks so much for listening.

00:57:55.000 --> 00:57:56.180
I really appreciate it.

00:57:56.180 --> 00:57:58.080
Now get out there and write some Python code.

00:57:58.080 --> 00:58:18.840
I really appreciate it.

