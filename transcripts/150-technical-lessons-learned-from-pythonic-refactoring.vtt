WEBVTT

00:00:00.001 --> 00:00:04.760
Does your code smell? Does it have a weird fragrance? It turns out code smells are a real

00:00:04.760 --> 00:00:09.980
thing and an amazing conceptualization of suboptimal design. This week you'll meet Yanni

00:00:09.980 --> 00:00:16.060
Chung who has some practical and real-world advice on using refactoring and Python to improve your

00:00:16.060 --> 00:00:23.360
code and wash away those bad smells. This is Talk Python To Me, episode 150, recorded January 31st, 2018.

00:00:23.360 --> 00:00:42.660
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the ecosystem,

00:00:42.660 --> 00:00:47.880
and the personalities. This is your host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy.

00:00:47.880 --> 00:00:53.160
Keep up with the show and listen to past episodes at talkpython.fm and follow the show on Twitter

00:00:53.160 --> 00:00:59.320
via at talkpython. This episode is brought to you by ParkMyCloud and Rollbar. Please check out what

00:00:59.320 --> 00:01:03.620
they're offering during their segments. It really helps support the show. Talk Python To Me is partially

00:01:03.620 --> 00:01:09.940
supported by our training courses. Python's async and parallel programming support is highly underrated.

00:01:09.940 --> 00:01:14.740
Have you shied away from the amazing new async and await keywords because you've heard it's way too

00:01:14.740 --> 00:01:20.200
complicated or that it's just not worth the effort? With the right workloads, a hundred times speed up

00:01:20.200 --> 00:01:25.580
is totally possible with minor changes to your code. But you do need to understand the internals and

00:01:25.580 --> 00:01:31.340
that's why our course, async techniques and examples in Python show you how to write async code

00:01:31.340 --> 00:01:37.160
successfully as well as how it works. Get started with async and await today with our course at

00:01:37.160 --> 00:01:39.500
 talkpython.fm/async.

00:01:39.500 --> 00:01:41.360
Yeni, welcome to Talk Python.

00:01:41.360 --> 00:01:43.600
Hey, yeah, very excited to be on here.

00:01:43.740 --> 00:01:49.700
Yeah, it's great to have you. I saw your talk, you know, virtually via YouTube, PyCon.de, and that was

00:01:49.700 --> 00:01:53.480
really, really interesting. So I wanted to make, give you an opportunity to come here and share

00:01:53.480 --> 00:01:58.000
your technical lessons learned from a refactoring with everybody.

00:01:58.000 --> 00:02:02.120
Yeah, thanks. It was also a great learning experience for me with that many Pythonistas

00:02:02.120 --> 00:02:06.880
there. And I also learned a lot from people's opinions. We had a great chat.

00:02:07.000 --> 00:02:10.740
You know, one of the things I think is a little bit counterintuitive or ironic is

00:02:10.740 --> 00:02:15.840
probably when you see those presentations given, the person that learned the most from that

00:02:15.840 --> 00:02:18.340
presentation is the person presenting it, right?

00:02:18.340 --> 00:02:19.320
Yeah.

00:02:19.320 --> 00:02:23.680
Because you had to do all the research and the thinking and it's not just what came out,

00:02:23.680 --> 00:02:25.280
but it's like the whole experience, right?

00:02:25.280 --> 00:02:26.840
Yeah, pretty cool.

00:02:27.260 --> 00:02:31.800
So before we get though into the details of all the refactoring stuff that you talked about,

00:02:31.800 --> 00:02:35.420
which is really interesting, let's talk about your story. How'd you get into programming in Python?

00:02:35.420 --> 00:02:41.000
Yeah, that's a long story. So when I was in high school, I don't actually know programming as a

00:02:41.000 --> 00:02:47.420
thing. So I was just really into math and sciences. So yeah, like I like the problem solving part of it.

00:02:47.420 --> 00:02:53.060
I even liked physics as a subject. And yeah, like from there, I kind of know that I like the

00:02:53.060 --> 00:02:57.420
application side of things because I feel like, you know, by doing those high school problems,

00:02:57.420 --> 00:03:03.740
I can solve real world problems. Not really, but that's how I got into it. And in university,

00:03:03.740 --> 00:03:10.120
very naturally, I just applied for engineering. And I didn't really think about pursuing software

00:03:10.120 --> 00:03:15.240
engineering at all because I didn't know it's a profession, but there's one requirement course

00:03:15.240 --> 00:03:21.160
that I need to take for engineering. And that was CS21, Intro to Programming. So after I took it-

00:03:21.160 --> 00:03:21.760
What language was that?

00:03:21.760 --> 00:03:28.300
That was in Python. So yeah, after that, taking that class, I think Python set a very high bar for me.

00:03:28.300 --> 00:03:35.400
So I didn't really get too much into other languages anymore because of how much I liked Python. It's

00:03:35.400 --> 00:03:41.660
such a neat and beautiful language, I would say. So yeah, pretty much after that class, I decided to

00:03:41.660 --> 00:03:45.620
switch my major into computing science instead, and I dropped engineering.

00:03:45.620 --> 00:03:51.660
That's really wild. So it really connected with you and you're like, I found something I like,

00:03:51.660 --> 00:03:57.020
better. I think that's an important part of college actually, is I'm always kind of blown

00:03:57.020 --> 00:04:01.540
away that people just go into college knowing what they want and they just do that. Because to me,

00:04:01.540 --> 00:04:07.500
college was you go and you try a bunch of things and a few things connect and you sort of follow that

00:04:07.500 --> 00:04:11.360
path. Yeah. So what kind of engineering were you doing before you switched into programming?

00:04:11.600 --> 00:04:21.280
So it's general engineering. We didn't really pick the discipline yet. By the time I had to do that, I already switched out. So I didn't get to that part of it.

00:04:21.280 --> 00:04:27.200
Yeah. I think it's a pretty smart thing to use Python as the first language to teach to people.

00:04:27.200 --> 00:04:32.260
Because I really feel like in Python, you spend less time thinking about the syntax.

00:04:32.260 --> 00:04:37.340
You get to think much more about the logic of the code and computer science itself.

00:04:37.440 --> 00:04:47.280
So compared to other languages, which we learn later, like C++, C, which are great because you get more of the happenings under the hood.

00:04:47.280 --> 00:04:52.740
I think Python really took all these distractions out from the get go.

00:04:52.880 --> 00:05:04.560
Yeah, I agree. I think it's a really good learning language. What surprises me about Python is there's a lot of languages that are kind of simple in that regard, like Visual Basic, like six, you know, the early Visual Basics and things like that.

00:05:04.560 --> 00:05:11.480
They were kind of like that, but they would always they would hit this really hard limit as soon as you try to do very complicated stuff with them.

00:05:11.480 --> 00:05:19.360
And Python seems to have struck a balance where it's simple in the beginning, but it can grow into larger applications still.

00:05:19.360 --> 00:05:22.720
Yeah, it's totally an art how to write good Python code.

00:05:22.720 --> 00:05:26.680
Yeah, that's for sure. So what do you do these days?

00:05:26.680 --> 00:05:34.900
Recently, I've been leading a project. So I'm a full stack engineer. I don't only code on Python. I also work on JavaScript and React stuff.

00:05:34.900 --> 00:05:45.560
So recently we've been working on such a project. Sometimes I could be doing interviewing or mentoring some other people in the company or preparing for a Python podcast.

00:05:45.560 --> 00:05:48.580
Of course, of course. And you work at Yelp, right?

00:05:48.580 --> 00:05:49.080
Yeah.

00:05:49.080 --> 00:05:51.120
Yeah. That sounds like a really fun place to be.

00:05:51.300 --> 00:05:56.020
Yeah, I think so. So I work in Yelp and Hamburg. So not in the San Francisco office.

00:05:56.020 --> 00:06:12.200
Here we focus more on the business side of things. So selling ads, helping local businesses find customers and things like that, which I find I find it to be very interesting.

00:06:12.740 --> 00:06:14.740
Yeah, like I really enjoy being here.

00:06:14.740 --> 00:06:21.940
I'm sure. Is Yelp pretty big in Europe? I only know it through the US. When I lived in Germany, I didn't actually use Yelp very much.

00:06:21.940 --> 00:06:27.580
There are definitely like some competitors in Europe as well, but it's growing. It's getting its ground.

00:06:27.580 --> 00:06:32.540
Yeah. And you actually have more offices in Europe, which is kind of cool, right? London and Hamburg.

00:06:32.740 --> 00:06:42.320
Yeah. Well, the good thing about like working in a European office is you get to fly around in Europe, you know, like you get to go to all these like fun European conferences, which is very nice.

00:06:42.460 --> 00:06:50.120
Yeah, that's one of the things I really liked about being there is you're so much closer to many amazing places to visit.

00:06:50.120 --> 00:06:54.780
Like where I live in Portland, it's three hours to Seattle to the north.

00:06:54.780 --> 00:06:59.680
It's 10 hours to San Francisco to the south, and it's eight hours to Boise to the east.

00:06:59.680 --> 00:07:10.120
And those are the three closest cities. Like you're in Paris in two and a half hours, or you're in Vienna or wherever. It's really just such a different experience there. So enjoy it. That's cool.

00:07:10.120 --> 00:07:22.160
Yeah. But like the tech scene, I would say it's like very much concentrated in the US. Like say SF, you have such a huge technical community. But in Europe, it's definitely more spread out. So you need to like fly from one place to another.

00:07:22.160 --> 00:07:27.400
Maybe like a bigger tech hub would be Berlin. But still, it's really, really widespread.

00:07:27.400 --> 00:07:28.980
Yeah, that's an interesting observation.

00:07:28.980 --> 00:07:41.360
Cool. So let's talk about your topic that you covered at your talk, which is refactoring. And I think refactoring, you know, it's interesting that we've had programming.

00:07:41.360 --> 00:07:47.960
I don't know, like what you might consider programming, maybe since the 60s, right? Do you consider punch cards? I don't know.

00:07:47.960 --> 00:07:58.840
But we've had programming for quite a while. But refactoring as an idea didn't really come out until, I don't know, was it early 90s, mid 90s, something like that?

00:07:58.840 --> 00:08:00.960
With the whole Martin Fowler thing? Yeah.

00:08:00.960 --> 00:08:01.060
Yeah.

00:08:01.060 --> 00:08:11.360
So it finally got sort of formalized an idea. So maybe just really quickly for everyone listening, because I know people kind of use refactoring and just changing your code to be better.

00:08:11.940 --> 00:08:19.060
And maybe adding features and whatnot while you're doing it as interchangeable. So maybe just quickly give us like a definition of refactoring.

00:08:19.060 --> 00:08:24.160
So code refactoring is pretty much the process of restructuring existing computer code.

00:08:24.840 --> 00:08:33.940
So that's pretty much meaning changing the refactoring without changing its external behavior. And it also improves the non-functional attributes of the software.

00:08:33.940 --> 00:08:44.160
So from the outside, it should appear as if it didn't change, but you might change the way the algorithm is implemented or something to that effect, right?

00:08:44.340 --> 00:08:51.600
Yeah. Pretty much changing the design, like improving the design of it, but without changing the functionality of what your software is supposed to do.

00:08:51.600 --> 00:08:56.820
Book that kind of announced that was Martin Fowler's book. And you talked a little bit about that in the internet talk as well.

00:08:56.820 --> 00:09:04.540
And I just looked it up. It was published in 1999. I mean, that's like height of dot com boom days, right?

00:09:04.620 --> 00:09:08.360
It seems pretty far down the line for when that came into existence.

00:09:08.360 --> 00:09:14.980
Yeah, but this is kind of like, I don't know, the Bible for refactoring. In a lot of ways, I feel it's like a start of discussion.

00:09:14.980 --> 00:09:21.960
But in a way, a lot of those principles can still be applied to other languages and in other situations.

00:09:21.960 --> 00:09:27.760
So I would really like to use this book as like an introduction to what refactoring means.

00:09:28.280 --> 00:09:35.440
But later on in the podcast, I think we'll also touch on Python might not need that many of these refactoring patterns.

00:09:35.440 --> 00:09:41.360
Right. So one of the things that was interesting, you know, so there was a lot of stuff that came around the same time.

00:09:41.360 --> 00:09:51.240
So Martin Fowler's refactoring concepts, we had Kent Beck and I think maybe Martin Fowler was also participating in that with sort of extreme programming, paired programming.

00:09:51.240 --> 00:09:54.780
We had the whole design patterns in the Gang of Four book.

00:09:54.960 --> 00:09:59.600
There were some really interesting foundational ideas brewing in that time.

00:09:59.600 --> 00:10:03.280
And certainly the design patterns thinking.

00:10:03.280 --> 00:10:19.660
And it seems like just from looking at Martin Fowler's work, that it's very much based on languages like Java or Smalltalk or these heavily object oriented sort of object only languages.

00:10:20.140 --> 00:10:37.020
So I think it's interesting to compare that back to Python because it doesn't always make sense or there's problems you'll find in Python that don't appear in the list of, say, the code smells, which we'll talk about or the refactoring techniques because it's fundamentally a different way to structure code in Python.

00:10:37.220 --> 00:10:39.000
Yeah, I would totally agree with that.

00:10:39.000 --> 00:10:47.020
Like a lot of the problems that the refactoring patterns try to solve, I think inherently in Python's language design, it's already solved.

00:10:47.020 --> 00:10:50.580
So we can definitely explore into that a little bit later.

00:10:50.580 --> 00:10:50.980
Right.

00:10:51.100 --> 00:11:03.480
And then at the same, yeah, I think another one, though, so for example, that I think is kind of an issue you might run into is what I don't know, I would call is like a long module or something, right?

00:11:03.480 --> 00:11:10.360
Where everything is just crammed into one file and it probably should be broken apart to be more easily understood.

00:11:10.620 --> 00:11:11.060
Right.

00:11:11.060 --> 00:11:19.480
But that doesn't appear anywhere in the traditional literature because they're talking about things like Java where you just have one class per file.

00:11:19.480 --> 00:11:21.620
So if the file is long, that means the class is long.

00:11:21.620 --> 00:11:21.820
Right.

00:11:21.820 --> 00:11:24.120
But that's not necessarily the case in Python.

00:11:24.120 --> 00:11:33.740
I feel like there's like refactoring obviously applies to Python, but some of the traditional history of it is maybe an 80% match.

00:11:33.740 --> 00:11:34.620
Yeah, I would agree.

00:11:34.620 --> 00:11:41.280
Like a lot of the ideas translate, but like how you achieve that might change because of the language and how to apply that.

00:11:41.280 --> 00:11:41.940
Yeah, for sure.

00:11:41.940 --> 00:11:42.900
All right.

00:11:42.900 --> 00:11:47.780
So let's start by thinking about just why, what are the benefits of refactoring?

00:11:47.780 --> 00:11:51.000
So first of all, I think it cleans up tech debt.

00:11:51.000 --> 00:11:58.020
And for those who are not as familiar, tech debt tends to build up when you take shortcuts during development.

00:11:58.240 --> 00:12:04.020
There might be a better solution, but instead you took like a shorter one so that you can save some developer time.

00:12:04.020 --> 00:12:08.860
But these tradeoffs, you need to pay pretty much like pay for your debt later.

00:12:08.860 --> 00:12:12.880
You need to spend more time to fix the implementation, things like that.

00:12:12.880 --> 00:12:19.520
Or maybe when you have the spec, it's not complete yet or, you know, the products change, the code changes.

00:12:19.520 --> 00:12:23.520
So the thing you design right now might not be applicable for the future.

00:12:23.520 --> 00:12:27.360
And in this case, refactoring really helps it get into shape again.

00:12:27.360 --> 00:12:30.280
But I just think that it's like a good habit to have.

00:12:30.280 --> 00:12:35.440
Whenever I write a function, like it's very few times that I can get it right the first time.

00:12:35.440 --> 00:12:43.300
So upon like thinking a little bit more about it or look at it the next day, there has to be, you know, there can be a lot of improvements can be done.

00:12:43.420 --> 00:12:47.820
You know, maybe you can extract it to the function, name it better, things like that.

00:12:47.820 --> 00:12:53.360
And also, I just think that it really saves productivity because I've worked on legacy code before.

00:12:53.360 --> 00:13:01.220
And my experience was just, you know, I come to work, I look at all these code and I, okay, finally, I understood what it means.

00:13:01.220 --> 00:13:01.520
Okay.

00:13:01.520 --> 00:13:04.320
The next day I'll start implementing new features.

00:13:04.540 --> 00:13:07.220
And then I go home, like I had a nice sleep.

00:13:07.220 --> 00:13:09.520
I came back and then I just forgot what it does.

00:13:09.520 --> 00:13:13.080
And the code doesn't really help because it's so convoluted.

00:13:13.080 --> 00:13:18.440
So imagine that, but like times 10, you know, the whole team pretty much does the same thing.

00:13:18.440 --> 00:13:25.440
So if some people can be responsible for refactoring this, then everybody doesn't have to face the same problem.

00:13:25.440 --> 00:13:36.960
It's almost like a golden rule of programming in a professional environment is you talked about the Boy Scout rule, which was let's leave the place.

00:13:36.960 --> 00:13:41.800
In this case, the code in a better state than we found it every time we interact with it.

00:13:41.800 --> 00:13:43.400
So that's a pretty interesting idea.

00:13:43.400 --> 00:13:43.840
Yeah.

00:13:43.840 --> 00:13:46.540
That was one of the first things they tell us at Yelp.

00:13:46.540 --> 00:13:47.960
You know, it's like a common courtesy.

00:13:47.960 --> 00:13:52.800
You don't want to hand worse code to your colleagues, you know, than you found it.

00:13:52.800 --> 00:13:55.480
So that's where the Boy Scout rule comes from.

00:13:55.480 --> 00:13:57.120
Yeah, that's pretty cool.

00:13:57.120 --> 00:14:05.080
I think another sort of real world analogy applied to code that would be appropriate there would be the broken window theory.

00:14:05.080 --> 00:14:10.140
So like for those of you who don't know about that, that's in, I believe it came out of New York City.

00:14:10.140 --> 00:14:13.960
And there used to be, the city was kind of run down and there's a lot of crime.

00:14:13.960 --> 00:14:15.820
And they said, what can we do to make these neighborhoods nicer?

00:14:15.820 --> 00:14:27.680
And there was some psychologist or something that realized that just a few broken windows and a little bit of decay sort of communicated to the people of that neighborhood that, oh, this place, we don't care what it's like.

00:14:27.680 --> 00:14:28.660
It's kind of broken.

00:14:28.660 --> 00:14:31.240
And what does it matter if we break it a little bit more?

00:14:31.960 --> 00:14:38.420
Whereas if you come upon really nicely factored code that's really clean and beautiful to read, you don't want to go in there and mess it up, right?

00:14:38.420 --> 00:14:38.680
Yeah.

00:14:38.680 --> 00:14:41.420
The expectation is if I'm going to contribute to this, this is beautiful.

00:14:41.420 --> 00:14:43.760
I'm not just going to throw junk on it, right?

00:14:44.000 --> 00:14:47.120
So I think that's an interesting psychology about it as well.

00:14:47.120 --> 00:14:48.940
Yeah, that's a very good analogy.

00:14:48.940 --> 00:14:52.660
At the same time, I like what Martin Fowler mentioned in his book.

00:14:52.660 --> 00:14:54.600
He said he's a lazy developer.

00:14:54.600 --> 00:15:00.520
So the fact that he's working on this code right now means that it's very likely for him to work on this in the future.

00:15:00.520 --> 00:15:05.880
So just refactoring right now makes sure he can understand it easier in the future.

00:15:05.880 --> 00:15:06.760
Yeah, yeah.

00:15:06.760 --> 00:15:09.280
Yeah, a lazy developer is a good developer.

00:15:09.280 --> 00:15:10.760
Productive laziness.

00:15:10.760 --> 00:15:12.180
Yeah, exactly.

00:15:12.480 --> 00:15:20.200
Yeah, so you said also, in addition to cleaning up technical debt, it'll actually save you productivity now and over time, right?

00:15:20.200 --> 00:15:21.440
Yeah, I would agree.

00:15:21.440 --> 00:15:27.300
Because after refactoring, supposedly your code should look simpler, increase the readability.

00:15:27.300 --> 00:15:32.620
So in this case, the code can also be more usable and easier to maintain.

00:15:32.620 --> 00:15:33.900
It's good for you.

00:15:33.900 --> 00:15:36.560
And this is the good thing about Python.

00:15:36.560 --> 00:15:39.700
Python already reads very nicely, I would say.

00:15:39.700 --> 00:15:41.980
Like semantics is very easy to read.

00:15:41.980 --> 00:15:46.900
So if you can write good Python code, your code pretty much self-document.

00:15:46.900 --> 00:15:48.680
And that's a huge win.

00:15:48.680 --> 00:15:51.780
Imagine an organization like Yelp, right?

00:15:51.780 --> 00:15:54.740
We have over 300 microservices.

00:15:55.140 --> 00:15:58.140
And then we have even like a monolith of code base.

00:15:58.140 --> 00:16:04.380
There is it's impossible for you to write documentation to cover every line of what you write, right?

00:16:04.380 --> 00:16:10.760
So in this case, if you can write code that is readable, that is easy to read, then onboarding new people.

00:16:10.760 --> 00:16:16.180
If they if you have like a new hire and intern in your team, then they can immediately jump on.

00:16:16.260 --> 00:16:20.680
Like it really, I think it really brings a lot of value to the team.

00:16:21.180 --> 00:16:25.560
This portion of Talk Python To Me is brought to you by ParkMyCloud.

00:16:26.500 --> 00:16:28.760
The last time you parked your car, did you leave it running?

00:16:28.760 --> 00:16:29.440
No?

00:16:29.440 --> 00:16:32.420
Well, then why are you leaving your cloud resources running?

00:16:32.420 --> 00:16:38.100
Every year, $13 billion are wasted on cloud instances that no one is using.

00:16:38.100 --> 00:16:40.360
Don't let any of those be yours.

00:16:40.360 --> 00:16:49.440
ParkMyCloud automatically identifies and eliminates wasted cloud spend, saving you 65% on AWS, Azure, and Google's cloud.

00:16:49.700 --> 00:16:53.420
You're up and running quickly with a 10 minute setup and no scripting required.

00:16:53.420 --> 00:16:57.880
Plus, govern users and easily integrate into your DevOps process.

00:16:57.880 --> 00:17:02.460
See why ParkMyCloud was chosen by McDonald's, Unilever, Fox, and more.

00:17:02.460 --> 00:17:07.600
Start a free trial today at parkmycloud.com slash talkpython.

00:17:07.600 --> 00:17:15.040
So you talked about these 300 microservices and some monolithic code as well.

00:17:15.720 --> 00:17:23.760
How do you guys think about, say, refactoring from one larger service into microservices?

00:17:23.760 --> 00:17:27.880
Or maybe the reverse, maybe taking, say, five microservices.

00:17:27.880 --> 00:17:30.160
These are really not doing enough to be independent things.

00:17:30.160 --> 00:17:31.760
We're going to smush them back together.

00:17:31.760 --> 00:17:36.440
Whenever we build new features, definitely, it's always in the back of our mind.

00:17:36.440 --> 00:17:38.320
Can we make that into a separate service?

00:17:38.320 --> 00:17:44.500
Can we modularize it a little bit better so that we don't have to contribute code to the giant monolith?

00:17:44.820 --> 00:17:49.580
But yeah, at the same time, you know, if you have more microservices, there is always overhead.

00:17:49.580 --> 00:17:55.720
So it's really a decision that is, you need to, like, find a good balance between it, I would say.

00:17:55.720 --> 00:17:56.500
Yeah, for sure.

00:17:56.500 --> 00:17:58.120
There's definitely trade-offs there.

00:17:58.120 --> 00:18:03.260
Another benefit to refactoring, I think, is maybe overlooked.

00:18:03.260 --> 00:18:09.640
I'm not entirely sure how often, say, managers take this into account in business, like sort of decision makers.

00:18:09.640 --> 00:18:23.120
But it seems to me, as a developer working at a company, if you always work on code that seems to have no care, no craft, it's just kind of thrown together and not well factored.

00:18:23.260 --> 00:18:26.740
You might decide either you'll be unhappy or you might just leave.

00:18:26.740 --> 00:18:32.500
And so maybe you are actually losing your best developers because they don't want to work with the crappy code.

00:18:32.500 --> 00:18:39.900
And so refactoring it into, you know, for all the reasons you already talked about, cleaning up debt and stuff, it seems like it almost could be like an HR issue.

00:18:39.900 --> 00:18:40.960
Yeah, for sure.

00:18:41.460 --> 00:18:44.560
Like, who doesn't like to work on clean code, nicely designed code?

00:18:44.560 --> 00:18:46.000
Exactly.

00:18:46.000 --> 00:18:52.640
Like, I've certainly worked on some projects where I'm like, wow, this does not look fun to work on.

00:18:52.640 --> 00:18:55.620
Like, why do I, what is even going on here, you know?

00:18:55.620 --> 00:19:01.560
Like, crazy variable names and huge stuff crammed into one function or a store procedure or something, right?

00:19:01.560 --> 00:19:02.520
Yeah, for sure.

00:19:02.520 --> 00:19:04.560
Yeah, another benefit, maybe, what do you think?

00:19:04.560 --> 00:19:05.600
Flexible software?

00:19:05.600 --> 00:19:19.680
I think there are different thoughts into how you should write software because some people think that, you know, software is kind of like a throwaway thing because products evolve so quickly that, you know, your code probably doesn't live very long.

00:19:19.680 --> 00:19:22.140
Like, after one year, two years, you have to rewrite it.

00:19:22.140 --> 00:19:27.320
Things come up and then, you know, you look at code that's supposedly to be very well designed before.

00:19:27.320 --> 00:19:30.960
But, you know, two years after it's not, you know, code tends to rot.

00:19:31.340 --> 00:19:37.840
And so, one thing about refactoring is the thing that came out from refactoring should be easy to modify.

00:19:37.840 --> 00:19:42.820
So, I think refactoring actually complies with this thinking, you know.

00:19:42.820 --> 00:19:45.480
If it's easy to read, you know exactly what to change.

00:19:45.480 --> 00:19:47.100
You know exactly what to throw away.

00:19:47.100 --> 00:19:48.200
And that's very important.

00:19:48.200 --> 00:19:49.200
Yeah, absolutely.

00:19:49.200 --> 00:19:59.460
And so, a lot of the refactory stuff also applies to breaking things into smaller, more well-understood pieces, right?

00:19:59.460 --> 00:20:05.840
Instead of one huge log function, maybe, like, a couple of functions and, like, a class that represents the data or something.

00:20:05.840 --> 00:20:10.940
So, it actually just makes it easier to evolve and change over time anyway.

00:20:10.940 --> 00:20:11.460
Yeah.

00:20:11.460 --> 00:20:13.500
Like, a counter example would be CSS.

00:20:13.500 --> 00:20:19.860
You know, you can only add lines to it and not really take it out because you don't know, like, you know, once you take out something, it breaks.

00:20:19.860 --> 00:20:22.660
So, this is exactly the situation we want to avoid.

00:20:23.560 --> 00:20:25.340
That's a really good way of thinking of CSS.

00:20:25.340 --> 00:20:32.960
And I definitely noticed that because you're like, well, but what about that one page that nobody realizes there?

00:20:32.960 --> 00:20:35.760
Or there's that admin section that you don't want to redesign that.

00:20:35.760 --> 00:20:42.000
So, you know, I find, like, the changes go into, like, the bottom of the CSS file.

00:20:42.000 --> 00:20:50.440
Or if it gets really out of control, like, you'll create, like, this page overrides those CSS settings and we'll include that file after this one, right?

00:20:50.440 --> 00:20:52.540
Yeah, I think it's, like, a nightmare.

00:20:52.540 --> 00:20:57.600
But, like, recently I'm working on a React project, which makes it better because you have CSS modules.

00:20:57.600 --> 00:21:04.380
But, you know, again, these theories of, hey, like, modularize your code can apply to every language, even CSS.

00:21:04.380 --> 00:21:04.920
Yeah.

00:21:04.920 --> 00:21:08.640
Do you use anything like less or SAS or just straight CSS?

00:21:08.640 --> 00:21:11.240
Yeah, we do use SAS as well.

00:21:11.240 --> 00:21:17.660
But I think the good thing about CSS module is you can declare, you know, this element is what needs this class.

00:21:17.660 --> 00:21:22.160
So, in a way, you can know exactly what is used and what is not used.

00:21:22.160 --> 00:21:22.600
Right.

00:21:22.600 --> 00:21:23.220
Yeah, yeah.

00:21:23.220 --> 00:21:26.040
The dead selector stuff is really bad.

00:21:26.580 --> 00:21:28.160
It's even worse than regular code.

00:21:28.160 --> 00:21:28.540
Yeah.

00:21:28.540 --> 00:21:29.100
Yeah.

00:21:29.100 --> 00:21:32.860
So, that's sort of the benefits of refactoring.

00:21:32.860 --> 00:21:34.860
When do you think we should refactor?

00:21:34.860 --> 00:21:39.340
Like, what are some of the best times in sort of the software lifecycle?

00:21:39.340 --> 00:21:41.400
I think, yeah, that's a very good question.

00:21:41.400 --> 00:21:44.400
I think it's really an iterative process.

00:21:44.400 --> 00:21:53.060
So, whenever you add code, you know, remove code, or when you're understanding code, when you're fixing bugs, those are always very good timings for it.

00:21:53.480 --> 00:21:56.760
And another thing I would also want to point out is during code review.

00:21:56.960 --> 00:22:06.460
So, if after this podcast, you're more into this refactoring things during code review, then maybe you can comment, hey, actually, you can do this better.

00:22:06.460 --> 00:22:10.300
And you can raise the code quality for your entire team.

00:22:10.300 --> 00:22:14.360
And, yeah, I would really want to push for the value of code review.

00:22:14.580 --> 00:22:20.060
I think part of this might be, like, deciding what's important during code review, right?

00:22:20.060 --> 00:22:22.380
Like, are you reviewing for performance?

00:22:22.380 --> 00:22:25.600
Are you reviewing just for our code standards?

00:22:25.600 --> 00:22:28.080
Are you reviewing for correctness?

00:22:28.300 --> 00:22:36.860
Like, this sort of cleanliness aspect of refactoring probably would make a really good checkbox in the review process.

00:22:36.860 --> 00:22:37.700
Yeah, definitely.

00:22:37.700 --> 00:22:41.680
I've also read up some articles on how to do code reviews and stuff.

00:22:41.680 --> 00:22:43.580
And your suggestion is perfect.

00:22:43.580 --> 00:22:51.340
I think it's, you know, assigning one reviewer to review that part of the code or that aspect of writing code is very helpful.

00:22:51.340 --> 00:23:01.180
Because, yeah, it can also come with one problem with refactoring is, say, if your whole team is all, like, very enthusiastic about refactoring.

00:23:01.360 --> 00:23:06.520
And you can imagine how much ideas people can have, you know, asking you to rewrite the code.

00:23:06.520 --> 00:23:12.480
And it can also get into not so great of a situation because you'll have a lot of iterations, right?

00:23:12.480 --> 00:23:18.960
One suggestion can be having several people in the design, like, involving several people in the design phase.

00:23:18.960 --> 00:23:20.240
So come up with something.

00:23:20.240 --> 00:23:26.240
And then one person can be responsible to work with the person who's writing code to do refactoring.

00:23:26.240 --> 00:23:29.580
That tends to streamline the process a little bit.

00:23:29.580 --> 00:23:37.480
I think also there's probably what you might consider, like, micro refactorings versus we're going to change the whole architecture, right?

00:23:37.480 --> 00:23:39.120
Like, I have some long function.

00:23:39.120 --> 00:23:45.480
I broke it into three and I changed the parameters to be more clear versus, oh, this actually should be another service.

00:23:45.480 --> 00:23:46.780
We should use queuing here.

00:23:46.780 --> 00:23:48.520
And this, let's make the database NoSQL.

00:23:48.520 --> 00:23:51.700
And, like, that's kind of, like, that's another level, right?

00:23:51.700 --> 00:23:54.540
Yeah, I think that's definitely, like, a do-later.

00:23:54.540 --> 00:23:57.120
Let's follow up on that.

00:23:57.120 --> 00:23:57.960
Exactly.

00:23:58.040 --> 00:24:02.460
But that's the thing about, like, refactoring on a legacy, a system versus a new project.

00:24:02.460 --> 00:24:10.380
Definitely, it's much harder when it comes to a legacy system, especially code that you're not familiar with, code that some other people wrote.

00:24:10.380 --> 00:24:13.340
There are so many things that you think you can improve.

00:24:13.340 --> 00:24:16.840
But how do you, you know, when do you start and when do you stop?

00:24:16.840 --> 00:24:17.760
You know, it's important.

00:24:17.760 --> 00:24:19.580
You can't just, like, it's a black hole.

00:24:19.580 --> 00:24:22.660
You just continue to refactoring until the end of time.

00:24:22.860 --> 00:24:25.920
So I think it's important to time box yourself as well.

00:24:25.920 --> 00:24:29.920
One suggestion will be, say, like, this week I spent one day on this.

00:24:29.920 --> 00:24:33.260
And I'll wait a bit, you know, like, I'll learn a little bit more about the code.

00:24:33.260 --> 00:24:37.500
And then next week I'll come back again and do another day of refactoring.

00:24:37.780 --> 00:24:37.960
Yeah.

00:24:37.960 --> 00:24:41.140
And you could probably do a couple of interesting things.

00:24:41.140 --> 00:24:45.180
You could probably run things like Flake 8 against it or other.

00:24:45.180 --> 00:24:48.460
There's probably not just pure refactoring problems.

00:24:48.460 --> 00:24:50.080
There's probably a host of problems.

00:24:50.080 --> 00:24:58.280
And so, you know, you could approach it sort of, I'm just going to make it a little bit better every day until it's not so bad.

00:24:58.380 --> 00:24:59.480
Right, the Boy Scout rule.

00:24:59.480 --> 00:25:00.220
Yeah, exactly.

00:25:00.220 --> 00:25:01.020
Apply it to this.

00:25:01.020 --> 00:25:14.760
One particularly tricky challenge with legacy systems, I think, you know, this typically happens at larger organizations, is there's some not very high profile project.

00:25:14.760 --> 00:25:22.360
But it's somehow really important that if it stops working, it's going to be a big problem, some kind of back-end thing or something.

00:25:22.360 --> 00:25:27.780
And the person who created it is either no longer on the project or left the company.

00:25:27.780 --> 00:25:28.600
Right.

00:25:28.600 --> 00:25:32.580
It's written in, like, you know, Python 2.5 or some old thing.

00:25:32.580 --> 00:25:37.340
And it's not currently your problem, but you would like to make it better.

00:25:37.340 --> 00:25:40.180
But you know if you break it, it's your problem all of a sudden, right?

00:25:40.180 --> 00:25:46.080
Like, if you try to make it better and you break it, you now own it because it was working and you're the one who made it not work.

00:25:46.080 --> 00:25:48.200
And who even knows how to deploy this thing again, right?

00:25:48.200 --> 00:25:49.400
That can be a real quick challenge.

00:25:49.400 --> 00:25:51.600
That sounds like a government problem.

00:25:51.600 --> 00:25:52.820
Yes.

00:25:52.820 --> 00:25:55.840
Yeah, I've definitely seen this at some big companies.

00:25:55.840 --> 00:25:56.720
Yeah.

00:25:56.720 --> 00:26:04.660
There's actually a book I want to give a quick shout-out to about this legacy system in particular called Working Effectively with Legacy Code by Michael Feathers.

00:26:05.260 --> 00:26:23.600
And he has some really interesting ideas of how to basically take a huge existing system and partition off little parts you're going to change and make them testable, flexible, refactorable without overwhelming – without trying to, you know, boil the ocean and change everything all at the same time.

00:26:23.600 --> 00:26:24.900
So it's pretty cool.

00:26:24.900 --> 00:26:26.160
A lot of techniques there.

00:26:26.160 --> 00:26:26.880
Oh, yeah.

00:26:26.880 --> 00:26:28.040
I'll definitely check it out.

00:26:28.040 --> 00:26:28.820
Yeah, it's really cool.

00:26:28.820 --> 00:26:33.500
Unfortunately, a lot of it is sort of C and Java, but the ideas in there are really interesting.

00:26:33.500 --> 00:26:35.880
I mean, some of them are so insane.

00:26:35.880 --> 00:26:45.300
It's like we're actually going to change the way the linker works to trick the system to do certain things consistently while we're making other changes in C, right?

00:26:45.300 --> 00:26:47.440
I mean, it's like really quite far out there.

00:26:47.440 --> 00:26:51.160
But you're like, oh, I didn't even think that we could take it that far.

00:26:51.160 --> 00:26:54.600
There's a lot of – I'm sure people will get good ideas from it even if it's not in Python.

00:26:54.600 --> 00:26:55.760
Yeah, for sure.

00:26:55.760 --> 00:27:05.880
Another problem that I think you run into around this kind of improvement but no features has to do with selling this idea to your manager.

00:27:05.880 --> 00:27:22.460
And I think while a lot of the modern software development methodologies are really nice, like Scrum, for example, the concept of a sprint in, you know, like a two-week or a month-long sprint, you know, you're going to sign up for some work, right?

00:27:22.500 --> 00:27:24.300
Like, well, where does refactoring fit?

00:27:24.300 --> 00:27:31.880
Like if I'm already fully booked on time, how do I go and say I'm actually going to do only half as much because I'm going to make things better?

00:27:31.880 --> 00:27:33.480
Like, well, we actually just need new features.

00:27:33.480 --> 00:27:34.260
This is really important.

00:27:34.260 --> 00:27:35.080
So forget the better.

00:27:35.080 --> 00:27:35.840
All right.

00:27:35.840 --> 00:27:37.500
How do you have that conversation, do you think?

00:27:37.640 --> 00:27:40.260
Yeah, I think it's a very important conversation to have.

00:27:40.260 --> 00:27:46.640
But the fact that you're thinking about refactoring, you know, like when you're adding new features, you know, you sense that something is wrong.

00:27:46.640 --> 00:27:49.920
That might be an indication that we need to do it right now.

00:27:50.040 --> 00:27:59.420
So I think the way to communicate with a product manager or with your engineering manager is, hey, if we don't do the refactoring right now, it's actually going to take six weeks.

00:27:59.420 --> 00:28:04.060
But if we do the refactoring, you know, spend one week on it, it'll be easier to add feature.

00:28:04.060 --> 00:28:05.060
So four weeks.

00:28:05.260 --> 00:28:08.600
I think that usually communicates the idea across.

00:28:08.600 --> 00:28:11.040
Yeah, I find that does work sometimes.

00:28:11.040 --> 00:28:16.520
What I've done in certain circumstances where it was like, look, we're just really busy right now.

00:28:16.520 --> 00:28:19.980
We just need to go fast and we'll deal with it later sort of mentality.

00:28:19.980 --> 00:28:26.280
It wasn't super as explicit as that, but where that's kind of implied, you know what I mean?

00:28:26.280 --> 00:28:31.540
Where it's clear that the people would much just rather have that feature right now.

00:28:31.780 --> 00:28:39.360
But that was if that seemed like it was always the case, you know, it's sort of like if everything is urgent, then nothing is urgent.

00:28:39.360 --> 00:28:40.340
It's kind of like that.

00:28:40.340 --> 00:28:40.620
Right.

00:28:40.620 --> 00:28:42.540
There is also the tech debt thing, right?

00:28:42.540 --> 00:28:47.200
Like, you know, we need to deal with it later if we keep on building out this tech debt.

00:28:47.200 --> 00:28:49.460
You know, it's not like we don't have to do it.

00:28:49.460 --> 00:28:49.760
Never.

00:28:49.760 --> 00:28:51.280
It's going to come back to you.

00:28:51.280 --> 00:28:52.520
It's going to haunt you one day.

00:28:52.520 --> 00:28:53.200
Yeah, absolutely.

00:28:53.200 --> 00:28:57.480
I feel like that will work well in a place like Yelp where it's a pretty technical company.

00:28:58.320 --> 00:29:03.220
Let's say I'm just going to completely make up a company that I don't really know whether they're technical or not.

00:29:03.220 --> 00:29:08.320
But let's say I work for like a food production company that makes like cereal.

00:29:08.320 --> 00:29:08.800
Right.

00:29:08.800 --> 00:29:13.200
Like those managers probably don't know or care about what technical debt is.

00:29:13.200 --> 00:29:16.020
They just want like the new feature for their website or something.

00:29:16.020 --> 00:29:21.920
What I found in those situations, I was just start adjusting my estimates.

00:29:22.700 --> 00:29:30.260
To include refactoring and testing instead of saying, well, I'm going to spend this much time on the feature and this much time on refactoring, this much time on testing.

00:29:30.260 --> 00:29:31.980
I'm going to say this feature takes X.

00:29:31.980 --> 00:29:33.160
Exactly.

00:29:33.160 --> 00:29:38.980
If I'm going to work as a professional developer, that means refactoring and cleaning up technical debt and putting in tests.

00:29:38.980 --> 00:29:42.520
And you ask how long it takes, this is how long it takes.

00:29:42.520 --> 00:29:42.960
Right.

00:29:42.960 --> 00:29:43.980
You just don't say it's done.

00:29:43.980 --> 00:29:44.300
Right.

00:29:44.300 --> 00:29:45.940
You're giving a professional opinion.

00:29:45.940 --> 00:29:47.100
I totally agree with that.

00:29:47.100 --> 00:29:47.400
Yeah.

00:29:47.440 --> 00:29:52.080
So I think you've got to adjust maybe per like what kind of environment you're in.

00:29:52.080 --> 00:29:59.560
But it's, it is a little tricky to say, I'm going to take a bunch of time and do nothing in terms of what you see that we get.

00:29:59.560 --> 00:30:00.820
I'm going to not do anything.

00:30:00.820 --> 00:30:01.080
Right.

00:30:01.080 --> 00:30:05.140
But of course, it's actually making it much better for all the reasons we talked about.

00:30:05.140 --> 00:30:05.440
Yeah.

00:30:05.440 --> 00:30:06.200
Yeah, exactly.

00:30:06.200 --> 00:30:06.780
Yeah.

00:30:07.180 --> 00:30:21.720
I do think that your, your warning earlier was really interesting though, is because there's an absolute possibility that you just like go refactoring and pattering crazy and just go like, all right, we're going to keep changing this and keep changing this.

00:30:21.720 --> 00:30:24.600
And I always see this, like it could really be unended.

00:30:24.600 --> 00:30:33.060
So I guess one of the things that might be interesting to talk about is like, when do you know that you should refactor and how should you go about that?

00:30:33.060 --> 00:30:33.660
Yeah.

00:30:33.660 --> 00:30:35.720
This is a very interesting topic.

00:30:35.900 --> 00:30:39.940
So in the same book, actually, Ken Beck coined the term of code smell.

00:30:39.940 --> 00:30:47.180
So pretty much means it's a surface indication that usually corresponds to a deeper problem in the system.

00:30:47.180 --> 00:30:50.800
So I would like to make a metaphor with cheese.

00:30:50.800 --> 00:30:54.540
Sometimes like, you know, the key word of this is the indication.

00:30:54.540 --> 00:30:59.180
So sometimes cheese can smell very strong, you know, especially those like French cheese.

00:30:59.180 --> 00:31:03.240
And then like you think there is something wrong, but when you eat it, it's actually good.

00:31:03.820 --> 00:31:06.640
So code smell is an indication of a problem.

00:31:06.640 --> 00:31:11.740
But you really need to take some time to investigate into it if, you know, it's actually a problem.

00:31:11.740 --> 00:31:15.240
So you have like a very long function, but it actually does one thing.

00:31:15.240 --> 00:31:15.980
So, okay, perfect.

00:31:15.980 --> 00:31:25.200
This concept of a code smell is absolutely just like captured my imagination when I first heard of it because it's so perfectly captures what is wrong.

00:31:25.200 --> 00:31:30.280
It's like if you look at some code and your nose kind of wrinkles up, you know, like, oh, look at that.

00:31:30.280 --> 00:31:33.460
Like if it works, it's actually working just fine.

00:31:33.460 --> 00:31:36.840
But to get in there and to be with it is a little unpleasant.

00:31:36.840 --> 00:31:40.380
Like that is just the perfect idea of this code smell, right?

00:31:40.380 --> 00:31:40.720
Yeah.

00:31:40.720 --> 00:31:41.540
Well, that's the thing.

00:31:41.540 --> 00:31:45.620
Like, you know, any programmer can write things the machine can compile.

00:31:45.800 --> 00:31:50.020
But then only good programmers can write code that, you know, humans can read.

00:31:50.020 --> 00:31:51.000
Yeah, absolutely.

00:31:51.940 --> 00:32:09.320
And so I think what's interesting about the code smells is it's not just like, hey, there's this idea of smelly code, but there are actually smells, flavors of smell, like types of smells that then are prescriptive of different refactorings, which is super interesting.

00:32:09.320 --> 00:32:15.520
And that's kind of what we were talking about at the beginning where some of the smells are more applicable to, say, like Java than they are to Python.

00:32:15.520 --> 00:32:18.900
But still, there's plenty of Python analogies here.

00:32:19.240 --> 00:32:31.720
Before we get into the code smells, one thing that also Martin Fowler talks about that just I think is so perfect is he talks about the idea of code comments being deodorant for code smells.

00:32:31.720 --> 00:32:32.240
Yeah.

00:32:32.240 --> 00:32:34.140
I really like that analogy.

00:32:34.140 --> 00:32:41.200
So if, you know, if you have a lot of comments on your code, then that probably indicates that you didn't write it very clearly.

00:32:41.200 --> 00:32:44.380
That's why you need to write comments to explain yourself.

00:32:44.600 --> 00:32:52.220
So it's important to know that, you know, when you write a comment, you should address why you're writing this, but not what you're trying to say.

00:32:52.220 --> 00:32:59.220
If it's a what problem, then maybe you should rename it or try to use some variables to explain what you're trying to do here.

00:32:59.220 --> 00:33:09.160
I think this might be the most important idea of this entire code smell thing is literally every time I go to write a comment, I stop and go, why am I writing this comment?

00:33:09.160 --> 00:33:12.460
Is it really that I should just stop and rename the function?

00:33:12.460 --> 00:33:14.420
Is the function badly named?

00:33:14.420 --> 00:33:15.940
Are the parameters badly named?

00:33:15.940 --> 00:33:17.360
Is the function too big?

00:33:17.360 --> 00:33:18.960
And so I could break it into smaller pieces.

00:33:18.960 --> 00:33:24.320
So each one can then be really clearly named because right now it seems like the name would be a paragraph, right?

00:33:24.320 --> 00:33:25.640
All of those types of things.

00:33:25.640 --> 00:33:26.140
Right.

00:33:26.140 --> 00:33:26.620
Exactly.

00:33:26.620 --> 00:33:27.160
Yeah.

00:33:27.160 --> 00:33:30.140
And people all the time try to fix these with code comments.

00:33:30.140 --> 00:33:35.620
And it's just like, just delete the comment, make the variable name three characters longer, but understandable.

00:33:35.620 --> 00:33:36.180
Right.

00:33:36.180 --> 00:33:36.780
Exactly.

00:33:36.780 --> 00:33:38.220
Totally agree.

00:33:38.220 --> 00:33:39.640
That's awesome.

00:33:39.640 --> 00:33:40.240
All right.

00:33:40.240 --> 00:33:44.320
So maybe take us through some of the various code smells and how we might fix them.

00:33:44.320 --> 00:33:44.820
Sure.

00:33:44.820 --> 00:33:48.820
I can like vaguely categorize them into different classes.

00:33:48.820 --> 00:33:51.840
So first you have long and complex code.

00:33:51.840 --> 00:33:55.620
You have useless code, coupled code and inappropriate naming.

00:33:55.620 --> 00:33:57.760
I think we can go through them one by one.

00:33:57.760 --> 00:34:00.800
So let's start with the long and complex code.

00:34:00.800 --> 00:34:05.420
Sometimes in your program, you can see very long functions and classes.

00:34:05.420 --> 00:34:11.000
That might be an indication that your class or function is not doing one thing, just one thing.

00:34:11.420 --> 00:34:17.940
So, you know, that violates the single responsibility principle and the drive principle, you know, don't repeat yourself.

00:34:17.940 --> 00:34:25.020
So in this case, maybe we can extract the function or classes so that everything is encapsulated well.

00:34:25.340 --> 00:34:33.280
When you're doing this, like when you're using this technique of extracting functions, though, beware of pass by reference versus pass by value.

00:34:33.280 --> 00:34:40.360
It's like this mistake everybody makes and you pass in a dictionary rather than just viewing, just getting it.

00:34:40.360 --> 00:34:45.080
You're modifying what is inside and, you know, the list dictionary, there are mutables.

00:34:45.080 --> 00:34:46.180
It's very dangerous.

00:34:46.180 --> 00:34:46.740
It's evil.

00:34:47.400 --> 00:34:47.880
Yeah.

00:34:47.880 --> 00:34:51.200
Yeah, you do have to be careful about that.

00:34:51.200 --> 00:35:01.800
I think this is probably one of the most common things you run into is just something started out small and it grew and it grew and it grew and nobody wanted to really mess with it.

00:35:01.800 --> 00:35:03.080
They just wanted their feature in there.

00:35:03.080 --> 00:35:09.200
And so they added a little bit more, you know, another if clause, another conditional or whatever, right?

00:35:09.300 --> 00:35:17.360
Yeah, adding new keys to your dictionary, like you don't even know when you like pass by, you passed in the dictionary and in the end, the dictionary totally got muted.

00:35:17.360 --> 00:35:20.020
And yeah, it's very hard to keep track in this way.

00:35:20.020 --> 00:35:20.800
Yeah, for sure.

00:35:20.800 --> 00:35:25.880
And some other long and complex code problems as well, say temporary field.

00:35:25.880 --> 00:35:30.000
So that pretty much means you call a function and you cast it into a variable.

00:35:30.000 --> 00:35:35.120
But sometimes if you're not using this variable for a few times, you can just call it in line.

00:35:35.120 --> 00:35:37.040
Otherwise, it gets really confusing.

00:35:37.440 --> 00:35:42.800
And when you're trying to extract functions, those are the things that can prevent you from doing it very simply.

00:35:42.800 --> 00:35:50.000
And one other thing I want to point out is the conditional complexity, which I think most developers probably encountered.

00:35:50.000 --> 00:35:50.780
Me too.

00:35:50.780 --> 00:35:58.880
You know, you just want to write something very simple if else and you ended up having three, four layers of nested conditional logic.

00:35:58.880 --> 00:36:01.620
And that's just really, really hard to read.

00:36:01.620 --> 00:36:06.000
Yeah, I find that people do that a lot because they, how is the right word?

00:36:06.120 --> 00:36:07.920
They're testing for success.

00:36:07.920 --> 00:36:11.340
So I'm going to say, I'm going to do a loop.

00:36:11.340 --> 00:36:16.160
And then if this thing I want to work on is true, I'm going to go into that part.

00:36:16.160 --> 00:36:19.480
And then if this other condition also is true, I'm going to go in it.

00:36:19.480 --> 00:36:24.040
You end up like almost scrolling right just to read what the code is doing, you know?

00:36:24.040 --> 00:36:28.000
That's where the line limit came in for PEP 8, I guess, you know.

00:36:28.000 --> 00:36:29.820
But 79 is very, very strict.

00:36:29.820 --> 00:36:33.700
I would have to say, you know, you can probably modify it for your own need.

00:36:33.940 --> 00:36:37.960
But that could possibly stop people from writing too long of a code.

00:36:37.960 --> 00:36:41.280
Maybe you're trying to encompass too much information on one line.

00:36:41.280 --> 00:36:42.060
Yeah, for sure.

00:36:42.060 --> 00:36:48.020
Well, and if people are looking for something concrete, you're like, okay, I know this is not good, but what do I do?

00:36:48.280 --> 00:36:50.320
Like you can reverse the if statements.

00:36:50.320 --> 00:36:57.760
You can do what's called a guarding clause that'll say, if it's not good, either skip this time to the loop or return early.

00:36:57.960 --> 00:37:04.060
Instead of if yes, yes, yes, if yes, if yes, if you just go, if no, return, if not this, return, if not that, return.

00:37:04.060 --> 00:37:07.280
And then what's flat below is the actual thing you want to do.

00:37:07.280 --> 00:37:08.000
That can really help.

00:37:08.000 --> 00:37:08.520
Exactly.

00:37:08.520 --> 00:37:09.400
Yeah, like totally.

00:37:09.400 --> 00:37:11.360
Like guarding clauses is a good way to go.

00:37:11.360 --> 00:37:14.600
And in here, I would even value simplicity.

00:37:14.600 --> 00:37:20.960
And I would even sacrifice, you know, the shortness for the conditional complexity.

00:37:21.420 --> 00:37:29.780
So even being more verbals, having more verbal statements, I think it would help instead of introducing the nested conditionals.

00:37:29.780 --> 00:37:30.700
Yeah, nesting is bad.

00:37:30.700 --> 00:37:31.660
Yeah, exactly.

00:37:31.660 --> 00:37:34.600
I think that's also mentioned in the send of Python.

00:37:34.600 --> 00:37:36.760
You have flat is better than nested.

00:37:36.760 --> 00:37:38.800
So it's good to remember that.

00:37:38.800 --> 00:37:41.640
Just import this if you find yourself three levels deep.

00:37:41.640 --> 00:37:42.580
Yeah, exactly.

00:37:42.580 --> 00:37:48.480
This portion of Talk Python To Me has been brought to you by Rollbar.

00:37:48.480 --> 00:37:52.160
One of the frustrating things about being a developer is dealing with errors.

00:37:52.160 --> 00:37:57.200
Relying on users to report errors, digging through log files, trying to debug issues,

00:37:57.200 --> 00:38:01.160
or getting millions of alerts just flooding your inbox and ruining your day.

00:38:01.160 --> 00:38:07.920
With Rollbar's full stack error monitoring, you get the context, insight, and control you need to find and fix bugs faster.

00:38:07.920 --> 00:38:11.900
Adding Rollbar to your Python app is as easy as pip install Rollbar.

00:38:11.900 --> 00:38:16.140
You can start tracking production errors and deployments in eight minutes or less.

00:38:16.460 --> 00:38:20.320
Are you considering self-hosting tools for security or compliance reasons?

00:38:20.320 --> 00:38:23.900
Then you should really check out Rollbar's compliant SaaS option.

00:38:23.900 --> 00:38:33.280
Get advanced security features and meet compliance without the hassle of self-hosting, including HIPAA, ISO 27001, Privacy Shield, and more.

00:38:33.280 --> 00:38:34.660
They'd love to give you a demo.

00:38:34.660 --> 00:38:36.360
Give Rollbar a try today.

00:38:36.360 --> 00:38:40.020
Go to talkpython.fm/Rollbar and check them out.

00:38:40.800 --> 00:38:42.960
So what are some more in this area?

00:38:42.960 --> 00:38:45.080
As we mentioned, the mutable problem.

00:38:45.080 --> 00:38:48.000
Using dictionary as a param is pretty dangerous.

00:38:48.000 --> 00:38:49.640
Just now we talked about why.

00:38:49.640 --> 00:38:53.880
So I would suggest using named tuple because that's the thing.

00:38:53.880 --> 00:39:01.260
If I see a function and I'm debugging something, I see it passing in as a param, I'll probably cry a little bit inside.

00:39:01.260 --> 00:39:03.620
Say it's just like a location, right?

00:39:03.660 --> 00:39:06.120
I have so much imagination in my mind.

00:39:06.120 --> 00:39:08.260
Could it be like a latitude, longitude?

00:39:08.260 --> 00:39:09.480
Like is it a number?

00:39:09.480 --> 00:39:10.600
A string?

00:39:10.600 --> 00:39:12.000
Could it be like city, country?

00:39:12.000 --> 00:39:13.780
I have no idea.

00:39:13.780 --> 00:39:15.680
I need to throw in the debugger.

00:39:15.840 --> 00:39:20.060
I need to like try to run the program and see what exactly is inside.

00:39:20.060 --> 00:39:22.860
But if you use named tuple, it's defined.

00:39:22.860 --> 00:39:24.760
You know exactly what is inside.

00:39:24.760 --> 00:39:28.940
And when it comes to Python 3.6, there's type annotation.

00:39:28.940 --> 00:39:31.300
So really like no questions asked.

00:39:31.300 --> 00:39:32.520
You don't have to guess anything.

00:39:32.520 --> 00:39:39.540
I think it's a very good way to go to prevent a lot of the work that has to be done and prevent bugs.

00:39:39.540 --> 00:39:40.960
I really like that suggestion.

00:39:41.160 --> 00:39:48.720
It's great because it takes this kind of unknown thing and captures it into something that you know exactly what's there, how to access it.

00:39:48.720 --> 00:39:53.900
And the type annotation reinforces that that is actually the thing that's going there.

00:39:53.900 --> 00:39:54.540
Exactly.

00:39:54.540 --> 00:40:00.300
So you don't have to worry about the, because it's immutable, you don't have to worry about it being changed.

00:40:00.300 --> 00:40:02.620
So less bug will be introduced.

00:40:02.620 --> 00:40:03.460
Yeah, that's true.

00:40:03.460 --> 00:40:04.260
Yeah, very, very cool.

00:40:04.260 --> 00:40:09.980
Another one that I want to throw in here that does not have a code smell, but I want to give it a name.

00:40:09.980 --> 00:40:11.820
I'll run this name by you and see what you think.

00:40:11.820 --> 00:40:14.260
You know, you talked about dictionaries and parameters.

00:40:14.260 --> 00:40:15.420
That's kind of hard.

00:40:15.420 --> 00:40:21.740
When I see a method that takes star args, star star, kwrgs, just like I'll just take anything.

00:40:21.740 --> 00:40:22.940
You name it, you don't name it.

00:40:22.940 --> 00:40:23.480
I don't care.

00:40:23.480 --> 00:40:24.400
Just give it to me.

00:40:24.400 --> 00:40:25.780
I'm just like, oh my goodness.

00:40:25.780 --> 00:40:26.660
What do I do here?

00:40:26.660 --> 00:40:35.760
Like I had such a hard problem switching data centers in S3 because I needed to change like the encryption mode.

00:40:35.820 --> 00:40:37.720
It was like the craziest thing with the Bodo API.

00:40:37.720 --> 00:40:40.560
And I went to look in the, it was like this.

00:40:40.560 --> 00:40:41.860
And I went to look at the documentation.

00:40:41.860 --> 00:40:49.760
And one of the kwrgs was itself a dictionary, which only had a name and had no description of what even goes into the dictionary.

00:40:49.760 --> 00:40:51.780
I'm just like, oh, how do I supposed to do this?

00:40:51.780 --> 00:40:57.060
So my proposed code smell name for those types of methods are starry calls.

00:40:57.060 --> 00:40:58.600
Yeah, perfect.

00:40:58.600 --> 00:41:00.140
You're coining the term today.

00:41:00.140 --> 00:41:00.780
Starry call.

00:41:00.780 --> 00:41:01.480
I like it.

00:41:01.480 --> 00:41:02.220
Starry call.

00:41:02.220 --> 00:41:02.760
There you go.

00:41:02.920 --> 00:41:06.440
Yeah, some people call it black magic, you know, the quarks that got passed in.

00:41:06.440 --> 00:41:12.460
Yeah, I guess like Python, the structure of Python, it really lets you do so many powerful things.

00:41:12.460 --> 00:41:18.440
But at the same time, you really have to be responsible about it because with great power comes with great responsibility.

00:41:18.440 --> 00:41:19.940
Yeah, for sure.

00:41:19.940 --> 00:41:23.160
Yeah, I understand why these methods sometimes exist.

00:41:23.160 --> 00:41:29.560
But I feel like a lot of times people are just like, well, it's easier than just like making people name the orders and we'll just let them put whatever and we'll figure it out.

00:41:29.560 --> 00:41:32.080
It's like, yeah, but that doesn't actually help them use it.

00:41:32.080 --> 00:41:32.780
You know what I mean?

00:41:32.780 --> 00:41:33.680
Yeah, exactly.

00:41:33.680 --> 00:41:35.820
So the next section is useless code.

00:41:35.820 --> 00:41:36.320
Right.

00:41:36.320 --> 00:41:40.340
So as you mentioned, too many comments is definitely a deodorant.

00:41:40.340 --> 00:41:44.980
Definitely we should write down why, but not what you're trying to do.

00:41:44.980 --> 00:41:49.340
If that's the case, then you probably should consider renaming or explaining it.

00:41:49.340 --> 00:41:52.960
One very common one is just the duplicated code.

00:41:53.660 --> 00:41:59.880
So yeah, adhering to the dry principle, you should extract functions or considering an inheritance.

00:41:59.880 --> 00:42:04.480
Well, in Python, you have other ways to do it as well, which we might cover later.

00:42:04.480 --> 00:42:09.140
It's the composition pattern, which might work a little bit better in Python's case.

00:42:09.140 --> 00:42:11.740
And sometimes you have dead code.

00:42:11.740 --> 00:42:17.620
Well, because your code is not modularized, it's very hard to tell if your line is being executed.

00:42:18.280 --> 00:42:24.940
But there are some IDs that are smart enough to tell you if the code is not executed or if some variables are not used.

00:42:24.940 --> 00:42:26.900
So that can be a good help.

00:42:26.900 --> 00:42:29.380
Or sometimes you have lazy classes.

00:42:29.800 --> 00:42:35.520
So you have this one class that doesn't really have any functions, only have some fields.

00:42:35.520 --> 00:42:37.520
Yeah, like pretty much some fields.

00:42:37.520 --> 00:42:40.660
And in this case, you can just replace it with a named tuple.

00:42:40.660 --> 00:42:46.140
And that just makes things easier because maintaining classes takes energy, takes time.

00:42:46.140 --> 00:42:46.460
Yeah.

00:42:46.460 --> 00:42:49.560
And actually, named tuples use less memory than I ever give a class anyway.

00:42:49.720 --> 00:42:51.960
So it's probably slightly more efficient.

00:42:51.960 --> 00:42:53.120
Yeah, I would agree.

00:42:53.120 --> 00:42:53.480
Yeah.

00:42:53.480 --> 00:42:54.920
So one tool, these are all great.

00:42:54.920 --> 00:42:56.620
And they all can drive me crazy.

00:42:56.620 --> 00:43:07.320
Like I've spent untold hours getting hold of some project, looking at some method, going, I don't understand how this is working in this environment.

00:43:07.320 --> 00:43:09.420
Like it really seems like this doesn't work.

00:43:09.520 --> 00:43:11.000
And so I'm trying to understand this code.

00:43:11.000 --> 00:43:20.840
And then it turns out that like after a lot of piecing stuff together, like, oh, the reason it doesn't seem to have any effect is because it's never called.

00:43:20.840 --> 00:43:23.020
Like, oh, my gosh.

00:43:23.020 --> 00:43:23.520
Oh, no.

00:43:23.520 --> 00:43:23.960
Right.

00:43:23.960 --> 00:43:24.500
Yeah.

00:43:24.500 --> 00:43:25.920
You know, no, it's just so frustrating.

00:43:25.920 --> 00:43:27.760
It's a little bit of the broken window syndrome.

00:43:27.760 --> 00:43:30.580
It's just like people left it in there, but they were afraid to take it out.

00:43:30.580 --> 00:43:30.800
Right.

00:43:30.800 --> 00:43:31.080
Yeah.

00:43:31.080 --> 00:43:31.660
The CSS.

00:43:31.660 --> 00:43:32.800
Yeah, exactly.

00:43:32.800 --> 00:43:33.760
It's like the CSS problem.

00:43:33.760 --> 00:43:37.960
The other one I want to give a shout out to, which is really just like it's so delightful,

00:43:37.960 --> 00:43:42.180
is in PyCharm, you can open up a huge project.

00:43:42.180 --> 00:43:43.460
Let's say it has like 100 files.

00:43:43.460 --> 00:43:45.160
You don't have to select anything or do anything.

00:43:45.160 --> 00:43:46.560
You can just go to a menu.

00:43:46.560 --> 00:43:47.480
I can't remember where it is.

00:43:47.480 --> 00:43:52.420
But you can say find duplicate code and it will compare like blocks.

00:43:52.420 --> 00:43:56.520
It'll just go, oh, this sort of test here is done actually in 20 places.

00:43:56.520 --> 00:43:57.660
You could just make that a method.

00:43:57.660 --> 00:43:58.120
Yeah.

00:43:58.120 --> 00:44:00.240
And that's pretty cool because you don't have to guide it.

00:44:00.240 --> 00:44:03.300
You just say go find the duplicates and it'll somehow like put that all together.

00:44:03.300 --> 00:44:06.180
I love all these like tools that can help us refactor code.

00:44:06.180 --> 00:44:07.040
It's awesome.

00:44:07.040 --> 00:44:07.880
Yeah, for sure.

00:44:08.180 --> 00:44:09.460
So what's the next section?

00:44:09.460 --> 00:44:11.780
So we'll talk a little bit more about coupled code.

00:44:11.780 --> 00:44:14.700
So you have something called the message chains.

00:44:14.700 --> 00:44:20.420
Pretty much means function A calls function B and then function B calls function C.

00:44:20.420 --> 00:44:26.360
So when one thing changes, say in the chain, right, function C changes, there is a ripple

00:44:26.360 --> 00:44:26.720
effect.

00:44:26.720 --> 00:44:28.060
So everything has to change.

00:44:28.060 --> 00:44:29.300
All your functions have to change.

00:44:29.300 --> 00:44:34.900
And for functions that have this message chain problem, it's very, very hard to test.

00:44:35.100 --> 00:44:41.260
So in this case, you know, the productivity is just drained away from first writing the function,

00:44:41.260 --> 00:44:45.580
understanding the function and then writing tests, which is really not great.

00:44:45.780 --> 00:44:50.640
Yeah, that can be one of those problems where you try to make some small change down at some

00:44:50.640 --> 00:44:54.680
lower level and it like cascades through every layer of the application.

00:44:54.680 --> 00:44:59.740
You feel like you're changing so many files just in order to like, well, like let's take

00:44:59.740 --> 00:45:00.020
an example.

00:45:00.160 --> 00:45:04.460
Like I want to add an extra parameter to the creation of an object way down low.

00:45:04.460 --> 00:45:07.720
Well, that means the method that calls that has to pass it, but the class that calls it

00:45:07.720 --> 00:45:08.220
doesn't have it.

00:45:08.220 --> 00:45:14.200
So its constructor has to take another parameter, which, and then just creates this like this

00:45:14.200 --> 00:45:17.980
sort of combinatorial explosion of like, why am I just doing this everywhere?

00:45:17.980 --> 00:45:18.700
This is crazy.

00:45:18.700 --> 00:45:19.780
Right.

00:45:20.240 --> 00:45:21.840
Yeah, I would totally agree.

00:45:21.840 --> 00:45:26.540
So if we can flatten it out a little bit, maybe function A can call function B and then

00:45:26.540 --> 00:45:28.360
function A can call function C.

00:45:28.360 --> 00:45:31.080
That'll make it a little bit better and easier to test.

00:45:31.080 --> 00:45:32.060
Yeah, for sure.

00:45:32.060 --> 00:45:36.660
Or maybe even there's some other mechanism from getting that information deep down there.

00:45:36.660 --> 00:45:39.680
Like maybe it's stored in the database instead of passed or I don't know.

00:45:39.680 --> 00:45:40.740
It really depends.

00:45:40.980 --> 00:45:41.280
Yeah.

00:45:41.280 --> 00:45:42.960
Or create static functions.

00:45:42.960 --> 00:45:44.140
Those are always great.

00:45:44.140 --> 00:45:45.200
Pure functions.

00:45:45.200 --> 00:45:46.160
They're dumber.

00:45:46.160 --> 00:45:47.580
It's easier to test.

00:45:47.580 --> 00:45:49.480
I don't know what to make the next one.

00:45:49.480 --> 00:45:50.440
Indecent exposure.

00:45:50.440 --> 00:45:51.720
Oh, it's very clear.

00:45:51.720 --> 00:45:55.360
It's exposing your privates to other classes.

00:45:55.360 --> 00:45:56.140
That sounds very indecent.

00:45:56.140 --> 00:45:57.620
Yeah.

00:45:57.620 --> 00:46:02.620
If your class is consistently calling like functions from another class, then it's better

00:46:02.620 --> 00:46:03.760
to combine it probably.

00:46:03.760 --> 00:46:10.880
So that means you have code that's too modularized in a way that maybe if they share the same

00:46:10.880 --> 00:46:12.380
context, they should be put together.

00:46:12.380 --> 00:46:17.220
That's an interesting comment because I feel like one of the things that's funny about

00:46:17.220 --> 00:46:25.320
refactoring and the code smells is they often have what I want to coin as refactorial inverses,

00:46:25.320 --> 00:46:25.540
right?

00:46:25.540 --> 00:46:27.380
Like multiplicative inverses, right?

00:46:27.380 --> 00:46:30.180
Like there's inline variable and there's create variable.

00:46:30.180 --> 00:46:31.560
There's inline method.

00:46:31.560 --> 00:46:33.920
There's extract method.

00:46:33.920 --> 00:46:35.800
There's push this to subclass.

00:46:35.800 --> 00:46:37.380
Pull it down.

00:46:37.380 --> 00:46:38.260
Pull the subclass.

00:46:38.260 --> 00:46:40.620
Push it to all the derivative ones.

00:46:40.780 --> 00:46:45.920
There seems to be like this thing and this undoing thing often in refactoring.

00:46:45.920 --> 00:46:47.560
And it really is context driven, right?

00:46:47.560 --> 00:46:47.940
Yeah.

00:46:47.940 --> 00:46:52.820
That's why I say it's an iterative process because once you have added some code, the situation

00:46:52.820 --> 00:46:53.740
is different again.

00:46:53.740 --> 00:46:57.480
And maybe what could be code smell before is not a code smell now.

00:46:57.480 --> 00:47:02.200
Or if you, upon investigating, the code smell actually doesn't point to anything.

00:47:02.200 --> 00:47:09.060
So it really, it's a constant effort, I would say, to keep your code good along the lines.

00:47:09.060 --> 00:47:09.340
Yeah.

00:47:09.340 --> 00:47:14.920
It's also why you can basically refactor for infinite time because you can do the thing

00:47:14.920 --> 00:47:15.780
and then you undo the thing.

00:47:15.780 --> 00:47:17.200
Then you do the thing in a different way.

00:47:17.200 --> 00:47:18.100
Yeah.

00:47:18.100 --> 00:47:23.020
So the last section you wanted to cover in this area was inappropriate naming.

00:47:23.020 --> 00:47:23.600
Yeah.

00:47:23.600 --> 00:47:28.360
I would love to cover this area because it's one of the three hardest problems in computing,

00:47:28.360 --> 00:47:28.760
right?

00:47:29.240 --> 00:47:33.200
You have cache invalidation, you have threading, and then you have naming.

00:47:33.200 --> 00:47:34.780
That's right.

00:47:34.780 --> 00:47:37.640
And this is something I care a lot about as well.

00:47:37.640 --> 00:47:41.420
Like it's kind of really closely tied to the code comment stuff and so on.

00:47:41.420 --> 00:47:41.780
Yeah.

00:47:41.780 --> 00:47:45.300
That I would totally agree because Python is dynamically typed.

00:47:45.820 --> 00:47:50.200
So in a way, when you create a variable, it doesn't really have to type information stuck

00:47:50.200 --> 00:47:50.640
to it.

00:47:50.640 --> 00:47:55.040
And in this case, you know, with great power comes with great responsibility.

00:47:55.040 --> 00:48:00.980
We need to name things right because we kind of didn't have this, some extra information

00:48:00.980 --> 00:48:03.220
as other languages would have had.

00:48:03.220 --> 00:48:06.360
You know, naming variables correctly, naming modules correctly.

00:48:06.960 --> 00:48:11.820
One thing you recommend are keyword arguments or at least calling functions in the keyword

00:48:11.820 --> 00:48:12.940
argument style, right?

00:48:12.940 --> 00:48:13.340
Definitely.

00:48:13.340 --> 00:48:18.960
So in this case, you don't have to have like 10 terminals open to see the function definition

00:48:18.960 --> 00:48:21.720
when you're stumbled upon this code, right?

00:48:21.720 --> 00:48:24.420
Immediately, you know what is being passed into the function.

00:48:24.420 --> 00:48:30.060
So I think it's just a more efficient way because it's always good to be explicit than implicit

00:48:30.060 --> 00:48:31.560
by the sense of Python.

00:48:31.560 --> 00:48:32.400
Yeah, for sure.

00:48:32.880 --> 00:48:40.360
Another thing that I think can be challenging is sort of implicit values or magic values.

00:48:40.360 --> 00:48:41.080
See what I mean by that?

00:48:41.080 --> 00:48:46.480
It's like you had an example around a function that took the mood of a person and the mood

00:48:46.480 --> 00:48:50.320
could be like one, two, three, or the sets of numbers.

00:48:50.320 --> 00:48:51.960
And is three good?

00:48:51.960 --> 00:48:52.720
You don't know, right?

00:48:52.720 --> 00:48:55.060
Like it's really hard to understand that stuff, right?

00:48:55.060 --> 00:48:56.320
Yeah, I would totally agree.

00:48:56.320 --> 00:48:59.700
Like it's definitely like indicating the direction is important, right?

00:48:59.700 --> 00:49:01.100
So mood bigger than three.

00:49:01.100 --> 00:49:01.760
What does that mean?

00:49:01.760 --> 00:49:02.640
Is it happy?

00:49:02.640 --> 00:49:03.520
Is it sad?

00:49:03.520 --> 00:49:09.500
So casting it into a variable called is happy equals mood bigger than three can have a

00:49:09.500 --> 00:49:12.060
wonderful effect of documenting your own code.

00:49:12.060 --> 00:49:12.480
For sure.

00:49:12.480 --> 00:49:17.160
And Python recently added enumerations as well, enum classes.

00:49:17.160 --> 00:49:21.960
And if there's only four moods, you know, making that an explicit enumeration.

00:49:22.220 --> 00:49:28.940
So there's like a sad sort of blase or like hair, like then there's happy, super excited, right?

00:49:28.940 --> 00:49:31.160
Like it would be really clear that way.

00:49:31.160 --> 00:49:32.540
And that'd be a pretty good refactoring too.

00:49:32.540 --> 00:49:33.500
Yeah, for sure.

00:49:33.900 --> 00:49:35.420
So this is all well and good.

00:49:35.420 --> 00:49:41.120
And I would like a better list of Python code smells to guide us, but there's still plenty

00:49:41.120 --> 00:49:46.160
to work with from sort of existing, existing literature and writing and stuff.

00:49:46.160 --> 00:49:50.740
So how do you go about developing your code nose?

00:49:51.060 --> 00:49:56.300
I definitely agree on reading literature on this, but I think it's just a skill that you develop

00:49:56.300 --> 00:49:57.060
over time.

00:49:57.060 --> 00:50:02.260
So if you actually just look at some legacy code, you can find a bunch for sure.

00:50:02.760 --> 00:50:09.120
And just seeing it day to day, you know, like just read more of that and try to refactor

00:50:09.120 --> 00:50:09.800
more of that.

00:50:09.800 --> 00:50:13.920
I guess we can learn, you know, at which point we need to refactor this.

00:50:13.920 --> 00:50:16.180
Is this an indication of a problem?

00:50:16.180 --> 00:50:18.000
It really comes with experience.

00:50:18.000 --> 00:50:23.740
And also the code review process can help you learn from other people in your team or, you

00:50:23.740 --> 00:50:24.600
know, whoever is reviewing.

00:50:24.600 --> 00:50:29.080
Yeah, I think the code review process is super helpful if at least that's being incorporated

00:50:29.080 --> 00:50:30.040
to the code review.

00:50:30.040 --> 00:50:30.500
Yeah.

00:50:30.500 --> 00:50:34.880
If you're working more on your own and, you know, there's plenty of people who work even

00:50:34.880 --> 00:50:38.120
in companies, but there's, they're kind of more or less on their own.

00:50:38.120 --> 00:50:39.660
They're not in a technology company.

00:50:39.660 --> 00:50:42.200
That code review can be more or less absent.

00:50:42.200 --> 00:50:46.160
And so one of the things that came to mind while you're thinking about this is like, or

00:50:46.160 --> 00:50:49.980
you're speaking about this to me is, you know, there's all these code smells.

00:50:49.980 --> 00:50:55.100
You could take like one code smell a week and say, all right, I'm going to work on the conditional

00:50:55.100 --> 00:50:56.740
complexity problem this week.

00:50:56.740 --> 00:51:01.620
So anytime I'm writing code, if I see, I feel myself writing like that fourth indentation

00:51:01.620 --> 00:51:06.480
level, I'm going to like remind myself to apply this refactoring or this, this, this technique.

00:51:06.480 --> 00:51:08.500
And you could just take them one at a time, right?

00:51:08.500 --> 00:51:12.540
Cause they seem overwhelming altogether, but they're pretty simple by themselves.

00:51:12.540 --> 00:51:13.880
That's definitely a good idea.

00:51:14.120 --> 00:51:18.920
One of the dangers of refactoring, I mean, it's extra high in legacy systems, but in

00:51:18.920 --> 00:51:24.500
general, it's a danger is that your intention is to refactor code, but your actual outcome

00:51:24.500 --> 00:51:25.760
is you've changed code, right?

00:51:25.760 --> 00:51:26.600
It behaves differently.

00:51:26.600 --> 00:51:28.960
So what's the role of testing here?

00:51:28.960 --> 00:51:31.700
I think testing is very important in the workflow.

00:51:32.000 --> 00:51:37.020
So what I would suggest is writing integration tests first for the code you're about to refactor,

00:51:37.020 --> 00:51:38.580
if it's not present yet.

00:51:38.580 --> 00:51:43.120
And then during your refactoring process, you know, after you extract the function, after

00:51:43.120 --> 00:51:48.680
you change the variable names, run it over again to check if the functionality of your code

00:51:48.680 --> 00:51:49.440
base has changed.

00:51:49.440 --> 00:51:51.740
So that really helps you to limit loss.

00:51:51.880 --> 00:51:56.160
You know, like after you change one thing, it's very easy to spot out what has been changed.

00:51:56.160 --> 00:52:02.260
And after refactoring is done, you can start introducing unit tests to test that the functions

00:52:02.260 --> 00:52:05.000
you've introduced actually uses the right logic.

00:52:05.000 --> 00:52:09.480
So with this workflow, I think we got our ground covered.

00:52:09.480 --> 00:52:09.900
Yeah.

00:52:09.900 --> 00:52:10.160
Yeah.

00:52:10.160 --> 00:52:12.680
That sounds like a good, a good way to do it.

00:52:12.680 --> 00:52:16.420
And what test frameworks use like the built-in one, use pytest, use Nose?

00:52:16.420 --> 00:52:16.740
Yeah.

00:52:16.740 --> 00:52:20.800
At Yelp, we definitely have a built-in one, but there is pytest as well, which is very, very

00:52:20.800 --> 00:52:21.240
similar.

00:52:21.240 --> 00:52:23.180
You can just assert things.

00:52:23.180 --> 00:52:26.280
You know, there are a lot of inbuilt functions that you can use.

00:52:26.280 --> 00:52:30.080
Also, one thing that Python is great is you can use mocks.

00:52:30.080 --> 00:52:35.340
So that's, you know, if you have a network call that you don't want to actually make during

00:52:35.340 --> 00:52:37.580
your testing, then you can mock things out.

00:52:37.580 --> 00:52:38.940
And that's really, really convenient.

00:52:38.940 --> 00:52:39.360
Yeah.

00:52:39.360 --> 00:52:39.820
Very nice.

00:52:39.820 --> 00:52:45.880
So maybe let's talk about some of the tools that you could apply here, because in Martin

00:52:45.880 --> 00:52:52.380
Fowler's 1999 book, he literally shows you the manual steps at every level.

00:52:52.380 --> 00:52:56.560
Like, okay, here, first you create this variable, you put this piece here, and then you do this

00:52:56.560 --> 00:52:56.800
step.

00:52:56.800 --> 00:53:01.680
And it's really painful, but there's more we can do these days, right?

00:53:01.820 --> 00:53:02.580
I do think so.

00:53:02.580 --> 00:53:06.520
So one thing is, you know, the styling part of it first.

00:53:06.520 --> 00:53:07.960
So we have PEP 8, right?

00:53:07.960 --> 00:53:14.740
PEP 8 is a Python enhancement proposal that talks about, it's essentially a Python style guide.

00:53:14.860 --> 00:53:20.620
So how you're supposed to structure the white spaces, how do you comment things, how do you

00:53:20.620 --> 00:53:23.100
use the string quotes, things like that.

00:53:23.100 --> 00:53:25.720
So that there are a lot of tools that can help you.

00:53:25.720 --> 00:53:32.100
There's the PEP 8 tool, there's Flake8 that can also help you check conditionals as well, I believe.

00:53:32.100 --> 00:53:36.140
Does it check for things like dead code and stuff like that as well, like unused parameters

00:53:36.140 --> 00:53:37.300
or methods not called?

00:53:37.300 --> 00:53:38.300
Yeah, that's big.

00:53:38.300 --> 00:53:39.620
Yeah, or PyLint.

00:53:39.620 --> 00:53:44.160
And there are a lot of things that we can use that can be programmatic about it.

00:53:44.160 --> 00:53:47.100
I would want to mention Raymond Hedinger's talk.

00:53:47.100 --> 00:53:52.600
He was mentioning how PEP 8 can become a nightmare because you just have someone from the team

00:53:52.600 --> 00:53:58.220
that bugs everyone about, hey, your trailing comma is off, you know, your white space is off.

00:53:58.220 --> 00:54:01.140
But you know, there are actually tools that can do that.

00:54:01.140 --> 00:54:07.060
And also, you should PEP 8 onto thyself, you know, not to bug everyone in a team about it.

00:54:07.060 --> 00:54:08.040
It's like a style guide.

00:54:08.040 --> 00:54:10.200
And it should surf like one, right?

00:54:10.200 --> 00:54:16.280
Because if at the same time you're pissing off your colleagues or if readability is not

00:54:16.280 --> 00:54:20.980
improving because of this style guide, then maybe it's not worth it to do it in the first

00:54:20.980 --> 00:54:21.320
place.

00:54:21.320 --> 00:54:21.620
Yeah.

00:54:21.620 --> 00:54:23.940
And you mentioned it is beyond PEP 8 talk.

00:54:23.940 --> 00:54:26.080
That is really quite insightful.

00:54:26.440 --> 00:54:33.200
It's a good example of how just following strict rules can lead to actually less readable code.

00:54:33.200 --> 00:54:38.400
Whereas if you let it slip just a little bit, but you're creative about it, there's actually

00:54:38.400 --> 00:54:45.280
better ways or maybe even not so much that you break PEP 8, but that PEP 8 is not the end.

00:54:45.280 --> 00:54:49.920
There's actually more important stuff to think about than PEP 8 about how you structure code,

00:54:49.920 --> 00:54:52.440
whether it's more Pythonic and the way that it works.

00:54:52.500 --> 00:54:53.460
It's a really good talk.

00:54:53.460 --> 00:54:57.880
I think it's done during PyCon as a PyCon talk beyond PEP 8.

00:54:57.880 --> 00:55:03.140
One thing he also mentioned is rather than thinking too much about PEP 8, maybe you should

00:55:03.140 --> 00:55:05.600
think about the problem P versus NP.

00:55:05.600 --> 00:55:07.460
So, you know, like silence.

00:55:07.460 --> 00:55:08.280
What is the P?

00:55:08.280 --> 00:55:08.960
What is the NP?

00:55:08.960 --> 00:55:12.320
It's Pythonic versus not Pythonic.

00:55:12.320 --> 00:55:13.640
That's right.

00:55:13.640 --> 00:55:14.200
That's right.

00:55:14.560 --> 00:55:21.500
Because you could write perfectly PEP 8 compliant, very non-Pythonic code, or you could just think

00:55:21.500 --> 00:55:23.860
beyond it and actually make the code better.

00:55:23.860 --> 00:55:24.800
Yeah, it's a good talk.

00:55:24.800 --> 00:55:26.920
And it was at PyCon, I believe, in that.

00:55:26.920 --> 00:55:30.000
So there's a video version, which I'll try to add in the show notes for people.

00:55:30.000 --> 00:55:31.700
Yeah, I really like that talk.

00:55:31.700 --> 00:55:32.000
Yeah.

00:55:32.000 --> 00:55:37.260
So maybe that's a good place to leave it for the refactoring stuff directly.

00:55:37.260 --> 00:55:39.020
But this was super interesting to talk about.

00:55:39.020 --> 00:55:40.720
Thanks for sharing your thoughts on that.

00:55:41.220 --> 00:55:46.560
One thing I did want to point out to people, folks ask me often about like where to get

00:55:46.560 --> 00:55:48.620
jobs and how to get into Python.

00:55:48.620 --> 00:55:52.760
Maybe they're doing C and they want to like move over to a place that actually does Python.

00:55:52.760 --> 00:55:55.780
So you at Yelp, you guys are hiring, right?

00:55:55.780 --> 00:55:56.260
Definitely.

00:55:56.260 --> 00:56:00.280
We have so many empty seats to fill and we really want you to be here.

00:56:00.280 --> 00:56:01.900
We use a Python backend.

00:56:01.900 --> 00:56:07.600
We have over 300 microservices and we have millions of search requests per year.

00:56:07.600 --> 00:56:11.680
There are a lot of interesting projects, you know, data for you to play with.

00:56:11.680 --> 00:56:14.600
So definitely we would love to have you here.

00:56:14.600 --> 00:56:18.140
Yeah, it sounds like a fun place that cares about code quality and craft.

00:56:18.140 --> 00:56:18.600
Very nice.

00:56:18.600 --> 00:56:18.980
Yeah.

00:56:18.980 --> 00:56:24.180
And we have offices in San Francisco or if you want to go to Europe as well, we have London

00:56:24.180 --> 00:56:24.720
and Hamburg.

00:56:24.720 --> 00:56:25.100
Cool.

00:56:25.100 --> 00:56:26.140
All right.

00:56:26.140 --> 00:56:29.280
So before we get out of here, let me ask you the two questions.

00:56:29.280 --> 00:56:32.580
So if you're going to write some Python code, what editor do you use?

00:56:32.580 --> 00:56:36.760
Well, since I'm a full stack engineer, I would actually suggest using Cloud9.

00:56:37.260 --> 00:56:38.800
I don't know if you've heard of it before.

00:56:38.800 --> 00:56:41.220
So it's pretty much you can code on the browser.

00:56:41.220 --> 00:56:42.720
It's super easy to set up.

00:56:42.720 --> 00:56:47.160
You can just like get clone the whole repo into whatever environment you're working with

00:56:47.160 --> 00:56:49.400
and you can pair programming real time.

00:56:49.400 --> 00:56:52.280
And it's just seamless for full stack development.

00:56:52.280 --> 00:56:54.420
Good for Python down to CSS.

00:56:54.420 --> 00:56:55.400
It's great.

00:56:55.400 --> 00:56:56.040
That's really cool.

00:56:56.040 --> 00:56:58.040
And I really like the real time collaboration.

00:56:58.040 --> 00:57:00.400
It's sort of like Google Docs for code.

00:57:00.400 --> 00:57:01.280
Yeah, definitely.

00:57:01.280 --> 00:57:06.100
And, you know, it's in the cloud, so you can pick up your progress wherever you left it.

00:57:06.200 --> 00:57:07.720
You could code on your iPad if you want.

00:57:07.720 --> 00:57:08.880
Perfect.

00:57:08.880 --> 00:57:09.260
Yeah.

00:57:09.260 --> 00:57:10.360
Yeah, that's right.

00:57:10.360 --> 00:57:11.200
All right.

00:57:11.200 --> 00:57:13.120
And then notable PyPI package.

00:57:13.120 --> 00:57:16.760
Like what's one out there that maybe people don't know about that is pretty cool.

00:57:16.760 --> 00:57:18.740
Just now we mentioned PEP 8 or Flake8.

00:57:18.740 --> 00:57:23.620
There are pretty cool links that can help you get your quote quality there.

00:57:23.620 --> 00:57:28.840
And yeah, I think definitely you should check out the sign of Python because I think it's

00:57:28.840 --> 00:57:32.240
pretty much the key rules of this Python language.

00:57:32.240 --> 00:57:36.780
There are a lot of things that we covered already, like flat is better than nested.

00:57:36.780 --> 00:57:40.160
Simple is better than complex or visibility counts.

00:57:40.160 --> 00:57:46.360
But whenever you make a decision when it comes to writing code, then when in doubt, import this.

00:57:46.360 --> 00:57:47.480
Yeah, that's perfect.

00:57:47.480 --> 00:57:49.060
All right.

00:57:49.060 --> 00:57:49.800
Final call to action.

00:57:49.800 --> 00:57:53.100
People are excited to get started with refactoring or do it better.

00:57:53.100 --> 00:57:54.340
What would you say to them?

00:57:54.400 --> 00:57:55.300
Just start right now.

00:57:55.300 --> 00:57:56.720
Like you don't need a lot of tools.

00:57:56.720 --> 00:57:57.860
You don't need anything.

00:57:57.860 --> 00:57:59.400
Start reading materials.

00:57:59.400 --> 00:58:02.800
Start learning the patterns or code smells one by one.

00:58:02.800 --> 00:58:04.580
I think it's a fun journey ahead.

00:58:04.580 --> 00:58:05.680
Yeah, I totally agree.

00:58:05.680 --> 00:58:06.240
Thanks for that.

00:58:06.240 --> 00:58:07.240
And thanks for being on the show.

00:58:07.240 --> 00:58:08.020
It was great to talk to you.

00:58:08.020 --> 00:58:08.880
Yeah, thank you.

00:58:08.880 --> 00:58:09.560
It was great.

00:58:09.560 --> 00:58:09.840
Yep.

00:58:09.840 --> 00:58:10.060
Bye.

00:58:10.060 --> 00:58:13.980
This has been another episode of Talk Python To Me.

00:58:13.980 --> 00:58:16.480
Today's guest has been Yeni Chong.

00:58:16.480 --> 00:58:20.600
And this episode has been brought to you by ParkMyCloud and Rollbar.

00:58:20.600 --> 00:58:22.720
Do you hear that sucking noise?

00:58:23.340 --> 00:58:26.260
That's your cloud provider making you pay for your idle instances.

00:58:26.260 --> 00:58:29.560
Turn on ParkMyCloud, plug the leaks, and save money.

00:58:29.560 --> 00:58:32.680
Visit talkpython.fm/park to get started.

00:58:32.680 --> 00:58:35.680
Rollbar takes the pain out of errors.

00:58:35.680 --> 00:58:40.760
They give you the context and insight you need to quickly locate and fix errors that might have

00:58:40.760 --> 00:58:43.400
gone unnoticed until your users complain, of course.

00:58:43.400 --> 00:58:48.220
As Talk Python To Me listeners, track a ridiculous number of errors for free at

00:58:48.220 --> 00:58:50.480
rollbar.com slash talkpythontome.

00:58:51.320 --> 00:58:53.300
Are you or a colleague trying to learn Python?

00:58:53.300 --> 00:58:57.980
Have you tried books and videos that just left you bored by covering topics point by point?

00:58:57.980 --> 00:59:03.620
Well, check out my online course, Python Jumpstart, by building 10 apps at talkpython.fm slash

00:59:03.620 --> 00:59:06.600
course to experience a more engaging way to learn Python.

00:59:06.600 --> 00:59:11.380
And if you're looking for something a little more advanced, try my Write Pythonic Code course

00:59:11.380 --> 00:59:13.960
at talkpython.fm/pythonic.

00:59:13.960 --> 00:59:16.660
Be sure to subscribe to the show.

00:59:16.660 --> 00:59:18.860
Open your favorite podcatcher and search for Python.

00:59:18.860 --> 00:59:20.100
We should be right at the top.

00:59:20.100 --> 00:59:25.880
You can also find the iTunes feed at /itunes, Google Play feed at /play, and

00:59:25.880 --> 00:59:29.400
direct RSS feed at /rss on talkpython.fm.

00:59:29.800 --> 00:59:31.300
This is your host, Michael Kennedy.

00:59:31.300 --> 00:59:32.660
Thanks so much for listening.

00:59:32.660 --> 00:59:33.720
I really appreciate it.

00:59:33.720 --> 00:59:35.660
Now, get out there and write some Python code.

00:59:35.660 --> 00:59:55.600
I'll see you next time.

00:59:55.600 --> 00:59:56.180
Thank you.

