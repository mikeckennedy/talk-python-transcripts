WEBVTT

00:00:00.001 --> 00:00:01.980
Have you heard of IronPython and Jython?

00:00:01.980 --> 00:00:05.740
These two alternate implementations of Python were created by Jim Hugenin.

00:00:05.740 --> 00:00:08.720
They run on top of the .NET and JVM runtimes.

00:00:08.720 --> 00:00:12.260
On this episode, we're going to look at the story of IronPython.

00:00:12.260 --> 00:00:16.860
It's been around for many years, although the last few years it's been somewhat stagnant.

00:00:16.860 --> 00:00:19.640
That's why I'm thrilled to introduce you to Alex Earle,

00:00:19.640 --> 00:00:24.140
who, along with Benedict Eggers, has become the maintainer of the IronPython project.

00:00:24.140 --> 00:00:27.420
It's great to see IronPython getting the attention that it deserves.

00:00:27.420 --> 00:00:32.560
We'll talk about IronPython past, present, and future in this episode of Talk Python To Me.

00:00:32.560 --> 00:00:37.580
This is episode number 74, recorded August 31, 2016.

00:00:54.840 --> 00:01:09.160
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:01:09.160 --> 00:01:11.300
This is your host, Michael Kennedy.

00:01:11.300 --> 00:01:13.300
Follow me on Twitter, where I'm @mkennedy.

00:01:13.300 --> 00:01:17.180
Keep up with the show and listen to past episodes at talkpython.fm.

00:01:17.180 --> 00:01:19.760
And follow the show on Twitter via at Talk Python.

00:01:21.040 --> 00:01:23.780
This episode is brought to you by Hired and SnapCI.

00:01:23.780 --> 00:01:30.480
Thank them for supporting the show on Twitter via at Hired underscore HQ and at Snap underscore CI.

00:01:30.480 --> 00:01:33.220
Hi, Alex. Welcome to the show.

00:01:33.220 --> 00:01:34.280
Hey, thanks for having me on, Michael.

00:01:34.280 --> 00:01:40.060
Yeah, I'm excited to talk to you about IronPython and its history and its future, even more importantly.

00:01:40.060 --> 00:01:41.020
Where is it going, right?

00:01:41.020 --> 00:01:42.380
So that's going to be a great conversation.

00:01:42.380 --> 00:01:42.720
Yeah, definitely.

00:01:42.720 --> 00:01:44.360
Yeah, I'm looking forward to share it with everyone.

00:01:44.360 --> 00:01:46.340
Before we do, though, let's get to your story.

00:01:46.340 --> 00:01:47.880
Like, how did you get into programming in Python?

00:01:47.880 --> 00:01:53.940
You know, as of probably most people my age, mid-30s or so, I kind of got started programming back in the Q&A days.

00:01:53.940 --> 00:02:00.840
I like, there's a game that came with a computer called Gorillas, where there are two gorillas and you threw bananas at each other.

00:02:00.840 --> 00:02:06.600
And I like to go in and modify that and make the bananas like purple or just change things about it.

00:02:06.600 --> 00:02:09.200
So that's kind of my first introduction to programming.

00:02:09.420 --> 00:02:15.000
From there, I didn't really do much until high school when I took a computer programming class for C++.

00:02:15.000 --> 00:02:17.700
And it was really fun and I enjoyed it.

00:02:17.700 --> 00:02:20.620
But my first introduction to Python was in college.

00:02:20.620 --> 00:02:23.460
I had a buddy who I was in several classes with.

00:02:23.460 --> 00:02:24.500
His name is Travis Hartwell.

00:02:24.500 --> 00:02:26.060
He introduced me to Python.

00:02:26.060 --> 00:02:28.560
I'd never even heard of scripting languages or anything like that.

00:02:28.560 --> 00:02:29.960
I'd only done C or C++.

00:02:30.400 --> 00:02:31.660
You're like, where's the compiler?

00:02:31.660 --> 00:02:32.560
Exactly.

00:02:32.560 --> 00:02:32.820
Yeah.

00:02:32.820 --> 00:02:34.660
I can just run these files, you know.

00:02:34.660 --> 00:02:35.760
So it was pretty awesome.

00:02:35.760 --> 00:02:41.080
And it was so easy to do things that were like way more complex in C++.

00:02:41.080 --> 00:02:46.040
You know, the lists, dictionaries are awesome.

00:02:46.040 --> 00:02:49.640
Functions you can use to sort or find things in them.

00:02:49.900 --> 00:02:53.320
And then he introduced me to lists, comprehensions and stuff like that.

00:02:53.320 --> 00:02:58.500
My mind was blown about how easy it was to do things in Python compared to C or C++.

00:02:58.500 --> 00:03:02.280
And so I've just had a love of Python ever since then.

00:03:02.280 --> 00:03:08.200
I didn't use it a ton in college except for in one class our professor actually let us.

00:03:08.200 --> 00:03:12.640
He said, if you can write a program to do your homework for you, go ahead and do that.

00:03:12.640 --> 00:03:14.260
It is a math class.

00:03:14.600 --> 00:03:21.000
And so I used Python and basically wrote some easy functions to do all my homework for me for certain assignments.

00:03:21.000 --> 00:03:23.880
And so that made me love Python even more.

00:03:23.880 --> 00:03:24.940
I could do my homework for me.

00:03:24.940 --> 00:03:26.800
So that was pretty awesome.

00:03:26.800 --> 00:03:32.120
Credit to that professor who's like, look, if you can think outside of the box and solve this problem, do it.

00:03:32.120 --> 00:03:32.980
That's really cool.

00:03:32.980 --> 00:03:33.380
Yeah.

00:03:33.380 --> 00:03:37.420
It was like a math for algorithms type class.

00:03:37.420 --> 00:03:40.640
It was kind of breaking down algorithms into math.

00:03:40.640 --> 00:03:46.460
And it was really cool to apply Python to that because, I mean, Python is great at that sort of thing.

00:03:46.460 --> 00:03:46.960
Yeah, sure.

00:03:46.960 --> 00:03:49.420
Was that like graph theory type stuff and those kinds of things?

00:03:49.420 --> 00:03:50.100
Exactly.

00:03:50.100 --> 00:03:50.480
Yeah.

00:03:50.480 --> 00:03:50.840
Yeah.

00:03:50.840 --> 00:03:51.060
Yeah.

00:03:51.060 --> 00:03:53.820
It seems like you could totally automate that for a lot of them.

00:03:53.820 --> 00:03:55.440
Find the most efficient path here.

00:03:55.440 --> 00:03:56.020
Well, guess what?

00:03:56.020 --> 00:03:56.720
We'll just try them.

00:03:56.720 --> 00:03:57.900
Beautiful.

00:03:57.900 --> 00:03:58.260
Okay.

00:03:58.260 --> 00:04:01.520
So that was, yeah, that's how you got into programming in Python.

00:04:01.520 --> 00:04:02.620
What do you do today?

00:04:02.620 --> 00:04:03.660
Where do you focus now?

00:04:03.940 --> 00:04:06.560
I work for a validation group, actually.

00:04:06.560 --> 00:04:11.860
So most of my work is actually done in Assembly or C.

00:04:11.860 --> 00:04:14.840
I write code that runs on embedded chips.

00:04:14.840 --> 00:04:23.780
As part of my job as well, I also develop some software tools that we use to automate our tests and so forth.

00:04:23.780 --> 00:04:26.720
And that's where I really got into Iron Python.

00:04:27.520 --> 00:04:32.700
So I write software tools and develop a software infrastructure for embedded processor testing.

00:04:32.700 --> 00:04:33.080
Okay.

00:04:33.080 --> 00:04:34.100
Yeah, that sounds fun.

00:04:34.100 --> 00:04:34.840
All right.

00:04:34.840 --> 00:04:35.900
So you mentioned Iron Python.

00:04:35.900 --> 00:04:44.280
And I think Iron Python is definitely one of the interesting alternative Python interpreters or runtimes out there.

00:04:44.280 --> 00:04:50.020
And we've talked about alternate runtimes before on the show, like PyPy, for example.

00:04:50.620 --> 00:05:00.220
But I think it's maybe worth just touching on the concept that there are other interpreters or runtimes out there because maybe not everybody's heard of what the options are.

00:05:00.220 --> 00:05:03.440
Could you give us like a little bit of a rundown of what the options are?

00:05:03.440 --> 00:05:03.840
Sure.

00:05:03.840 --> 00:05:09.080
So as you mentioned, you mentioned PyPy, which is a JIT-enabled fast interpreter for Python.

00:05:09.080 --> 00:05:11.860
There's also what we call it from Iron Python.

00:05:11.860 --> 00:05:17.740
And I don't know if other Python interpreters call it this, but CPython, which is the main one developed.

00:05:17.740 --> 00:05:25.540
You know, you can go to python.org and download the installation or it comes on if you're running like Linux or something, it usually comes on Linux.

00:05:25.540 --> 00:05:28.920
We call that CPython because it's based on the C language.

00:05:28.920 --> 00:05:29.580
Yep.

00:05:29.580 --> 00:05:32.880
And I feel like if people don't really know what version of Python they have.

00:05:32.880 --> 00:05:33.880
Yeah, it's definitely true.

00:05:33.880 --> 00:05:39.980
You know, you type like Python something and that's usually the CPython, but there are other Pythons.

00:05:39.980 --> 00:05:42.020
JIT-enabled Python is another option.

00:05:42.300 --> 00:05:45.080
It's developed on the Java framework.

00:05:45.080 --> 00:05:48.340
So it runs on the JVM, the Java virtual machine.

00:05:48.340 --> 00:05:52.840
And then there's us, Iron Python, which is developed on the .NET runtime.

00:05:52.840 --> 00:05:56.400
So those are kind of the main ones that I know about.

00:05:56.400 --> 00:06:06.800
We've kind of looked at those ones in particular as kind of the main areas where we can focus on compatibility and optimization so that we can perform well.

00:06:07.080 --> 00:06:08.360
Yeah, those are definitely the main ones.

00:06:08.360 --> 00:06:09.120
That's great.

00:06:09.120 --> 00:06:24.200
And so if you don't realize that there's a bunch of interpreters or runtimes, however you want to think of them, for Python, you know, there may be a better choice than the default Python, the CPython implementation for your project, depending on what you're trying to do.

00:06:24.420 --> 00:06:29.000
So let's talk about Iron Python, because that one's been around for a while.

00:06:29.000 --> 00:06:31.080
A lot of the ones you mentioned, they're not brand new.

00:06:31.080 --> 00:06:37.460
There are some new things coming out that maybe we'll touch on a little bit later, some of the JIT-based ones like Pigeon and so on.

00:06:37.460 --> 00:06:40.080
But let's talk about Iron Python.

00:06:40.080 --> 00:06:40.940
It's been around for a while.

00:06:40.940 --> 00:06:41.720
When did it get started?

00:06:41.720 --> 00:06:42.080
Do you know?

00:06:42.080 --> 00:06:47.520
It got started at Microsoft, I think it was around 2006.

00:06:47.520 --> 00:06:50.060
It's been around for about 10 years.

00:06:50.060 --> 00:06:53.540
Right now it has an Apache license.

00:06:53.540 --> 00:06:59.480
Microsoft kind of took it to a certain point and then they decided to open it up to be run by the community.

00:06:59.480 --> 00:07:03.260
And so they open sourced it as Apache license.

00:07:03.260 --> 00:07:06.200
And so that's the license we currently have.

00:07:06.200 --> 00:07:13.460
Yeah, I remember it was licensed under a different license, like the Microsoft open source license or something that people are like, what is this?

00:07:13.460 --> 00:07:13.880
Right?

00:07:13.880 --> 00:07:16.320
And then finally they switched it to the Apache license.

00:07:16.320 --> 00:07:18.240
Just go, here's something you're totally familiar with.

00:07:18.240 --> 00:07:19.280
Already approved.

00:07:19.280 --> 00:07:19.960
Go with that.

00:07:19.960 --> 00:07:20.260
Yeah.

00:07:20.260 --> 00:07:22.440
It was MSPL, I think.

00:07:22.440 --> 00:07:24.560
The MS public license or something like that.

00:07:24.560 --> 00:07:31.320
And it had some weird stuff within the license that people were like, I don't really want to touch this because, you know, it's a Microsoft license.

00:07:31.320 --> 00:07:35.040
So moving it to Apache was a huge benefit to the project.

00:07:35.040 --> 00:07:35.860
Yeah, that's great.

00:07:36.440 --> 00:07:39.020
So it was started by Jim Hugenin, is that right?

00:07:39.020 --> 00:07:41.320
Yeah, he was the one who did Jython as well.

00:07:41.320 --> 00:07:43.640
So it's kind of a funny story.

00:07:43.640 --> 00:07:50.780
The whole way that Iron Python came around is Jim had started working on Jython and he saw this .NET framework come out.

00:07:50.780 --> 00:07:57.660
And he said, oh, I'm going to go show that a Python implementation would be horrible to run on the .NET framework.

00:07:57.660 --> 00:08:03.080
And so he kind of started out Iron Python as a way to show that .NET was a horrible platform to work with.

00:08:03.080 --> 00:08:04.640
But it ended up being great.

00:08:04.640 --> 00:08:06.360
He said, it's a wonderful platform.

00:08:06.360 --> 00:08:08.780
It's great to write these languages for.

00:08:08.780 --> 00:08:11.180
And they run really well on top of it.

00:08:11.180 --> 00:08:15.040
He started out as kind of trying to attack .NET and ended up loving it.

00:08:15.040 --> 00:08:18.860
And he even was hired by Microsoft to continue development on Iron Python.

00:08:19.220 --> 00:08:20.000
Yeah, I remember that.

00:08:20.000 --> 00:08:23.480
And I think he worked there for like six years before he moved on to Google.

00:08:23.480 --> 00:08:24.900
It's really funny.

00:08:24.900 --> 00:08:28.280
You start out to prove something that is totally inadequate.

00:08:28.280 --> 00:08:30.680
You're like, wait, it's not totally inadequate for this thing.

00:08:30.680 --> 00:08:31.520
That's pretty interesting.

00:08:31.520 --> 00:08:31.900
Yeah.

00:08:32.440 --> 00:08:35.260
Do you know how similar Jython and Iron Python are?

00:08:35.260 --> 00:08:40.500
I've never really done a lot of work with Jython because I don't do tons of Java.

00:08:40.500 --> 00:08:47.920
They kind of aim at similar ideas, kind of bridging the gap between either Java and Python or the .NET framework and Python.

00:08:47.920 --> 00:08:58.220
The implementation is very different, mainly because there's while Java and the .NET framework or C# are similar in ideas because they have garbage collector.

00:08:58.220 --> 00:09:01.120
They're all object-oriented and that sort of thing.

00:09:01.120 --> 00:09:05.700
Really, the way that the different platforms solve things can be quite different.

00:09:05.700 --> 00:09:12.560
The way that they implemented things in Jython is actually, I believe, quite different in how things are implemented in Iron Python.

00:09:12.560 --> 00:09:21.900
Like their object structure, how they interact with the actual Python modules and then represent those in the Java runtime.

00:09:21.900 --> 00:09:25.820
That can be very different from how we do it in Iron Python.

00:09:25.820 --> 00:09:27.040
Okay.

00:09:27.240 --> 00:09:28.380
I forgot one detail.

00:09:28.380 --> 00:09:31.920
I just wanted to make sure people understood why it's called Iron Python.

00:09:31.920 --> 00:09:35.660
Iron stands for implementation runs on .NET.

00:09:35.660 --> 00:09:36.200
Okay.

00:09:36.200 --> 00:09:38.200
So that's why it's in Python.

00:09:38.200 --> 00:09:39.160
Right, right.

00:09:39.160 --> 00:09:40.680
You have a couple of languages.

00:09:40.680 --> 00:09:42.440
Like you had Iron Ruby as well.

00:09:42.440 --> 00:09:44.460
Well, they did when they started out at least.

00:09:44.460 --> 00:09:46.960
And it is under the project that you're maintaining.

00:09:46.960 --> 00:09:54.240
Before we get to that, though, maybe tell us a little bit about why would I choose Iron Python over CPython?

00:09:54.860 --> 00:09:57.500
The .NET framework has a lot of capabilities.

00:09:57.500 --> 00:09:58.660
And there's a lot of things.

00:09:58.660 --> 00:10:00.220
There's the WPF.

00:10:00.220 --> 00:10:03.300
There's Windows Forms for writing GUI apps.

00:10:03.300 --> 00:10:08.540
There's network libraries that may or may not be available in Python as a module.

00:10:09.420 --> 00:10:17.700
And so really the place that I use Python the most or Iron Python the most is creating a scripting environment for my applications.

00:10:18.020 --> 00:10:24.940
When I write my tools, I generally develop in C# and I use Windows Forms or WPF to create these tools.

00:10:24.940 --> 00:10:39.220
And to provide a scripting interface for those tools, Iron Python is very good at embedding into a C# application and accessing the components that you give it access to.

00:10:39.420 --> 00:10:44.540
It's very easy to provide it access to like a text output window.

00:10:44.540 --> 00:10:49.660
And so it can write to a text output window very easily that's developed in C#.

00:10:49.660 --> 00:10:52.500
I've tried doing similar things with CPython.

00:10:52.500 --> 00:10:56.720
I've used Boost Python to try embedding Python into an application.

00:10:56.720 --> 00:11:01.140
And I ran into some issues with wanting to rerun scripts over and over and over.

00:11:01.680 --> 00:11:05.180
I got weird assertions and seg faults and stuff like that.

00:11:05.180 --> 00:11:10.420
So for me, embedding Python in an application is very easy with Iron Python.

00:11:10.420 --> 00:11:15.740
And that's my biggest use case as a software engineer using Iron Python.

00:11:15.740 --> 00:11:16.240
Okay.

00:11:16.240 --> 00:11:22.340
So I guess, yeah, you can embed CPython pretty easily, especially if you're doing a C-based application.

00:11:22.340 --> 00:11:24.480
Then that probably makes a lot of sense.

00:11:24.960 --> 00:11:32.500
But if you're already writing in C#, this might be better because you can share information across it better, right?

00:11:32.500 --> 00:11:36.620
Like your classes and libraries in one language are available to the other.

00:11:36.620 --> 00:11:37.540
Does it go both ways?

00:11:37.540 --> 00:11:42.240
Yeah, you can definitely access Iron Python objects and stuff from C#.

00:11:42.240 --> 00:11:50.940
One of the tools I actually developed was we have a hardware team that they develop boards with FPGAs and stuff on there.

00:11:51.040 --> 00:11:54.600
And they wanted a way to test their hardware platforms.

00:11:54.600 --> 00:11:58.800
And so I created a GUI that interfaces with Iron Python.

00:11:58.800 --> 00:12:01.140
And they write scripts to test these boards.

00:12:01.140 --> 00:12:02.900
And I use the unit test module.

00:12:02.900 --> 00:12:05.900
And so they write their tests in the standard unit test format.

00:12:05.900 --> 00:12:12.520
But I can parse those objects and find all the unit tests from my C# GUI and present those.

00:12:12.520 --> 00:12:17.240
And they can select which ones they want to run and run those tests to test the hardware boards out.

00:12:17.240 --> 00:12:17.920
Oh, that's nice.

00:12:17.920 --> 00:12:24.760
So you, like, load the Python modules and inspect what tests are there and then present some kind of custom runner on top of it?

00:12:24.760 --> 00:12:25.140
Exactly.

00:12:25.140 --> 00:12:25.520
Yep.

00:12:25.520 --> 00:12:25.880
Okay.

00:12:25.880 --> 00:12:27.000
Oh, that sounds really cool.

00:12:27.000 --> 00:12:29.660
So we were talking about C#.

00:12:29.660 --> 00:12:34.080
And a lot of people say, you know, C# means Windows only.

00:12:34.080 --> 00:12:37.020
And a lot of people doing Python are not interested in Windows.

00:12:37.020 --> 00:12:40.200
Does it run outside of Windows or is that required?

00:12:40.200 --> 00:12:40.680
Yeah.

00:12:40.680 --> 00:12:46.460
So we do have pretty basic support for running on Linux under Mono right now.

00:12:46.460 --> 00:12:53.400
We definitely want to improve that because, you know, we want to be everywhere that people want to use C# and Python.

00:12:53.760 --> 00:13:01.260
So whether that's Linux or, you know, OSX or Windows, we really want to provide a solution to everybody.

00:13:01.260 --> 00:13:10.280
So we're going to put some focus on improving our support for Mono as well as .NET Core, which runs on Linux right now.

00:13:10.280 --> 00:13:10.800
Yeah, yeah.

00:13:10.800 --> 00:13:11.680
That's really interesting.

00:13:11.680 --> 00:13:25.660
I think that that's going to unlock a lot of things like this that used to be tethered more or less to Windows to set them free to run on, you know, Linux machines in a data center or something like that, which definitely opens up the appeal, I think.

00:13:25.660 --> 00:13:27.920
What about performance?

00:13:27.920 --> 00:13:33.540
Like, is there a performance benefit doing this versus CPython?

00:13:33.540 --> 00:13:37.080
Are there performance penalties, but you get the integration?

00:13:37.080 --> 00:13:38.100
What's the story?

00:13:38.100 --> 00:13:43.920
So one, I think, so performance benefits, we do outperform CPython in several benchmarks.

00:13:43.920 --> 00:13:46.480
I don't have the details right now.

00:13:46.480 --> 00:13:47.640
Recently, someone ran that.

00:13:47.640 --> 00:13:50.260
They compared CPython, PyPy, and IronPython.

00:13:50.260 --> 00:13:56.760
And we outperform CPython in many cases, but PyPy definitely outperforms us right now.

00:13:56.760 --> 00:14:03.640
I think that really probably is related to the global interpreter lock because we don't have that in IronPython.

00:14:03.640 --> 00:14:06.360
It can help us in a lot of those benchmarks.

00:14:06.360 --> 00:14:12.160
One of the things that we do have, something that we definitely need to look into optimization and performance problems is startup time.

00:14:12.160 --> 00:14:18.160
It takes us a lot longer than CPython to get started, you know, actually executing the Python code.

00:14:18.160 --> 00:14:20.480
And so that's something that we're planning on looking at.

00:14:20.480 --> 00:14:20.880
Sure.

00:14:20.880 --> 00:14:21.420
Yeah.

00:14:21.420 --> 00:14:25.540
If you're just going to run a little bit of code and then shut back down, maybe it doesn't make so much sense.

00:14:25.960 --> 00:14:31.560
I think PyPy also has that challenge that it takes a lot longer to get rolling at a high speed.

00:14:31.560 --> 00:14:38.700
But once it's up in a sort of like a web app type of environment where it starts and runs for a long time, then it's better.

00:14:38.700 --> 00:14:39.440
Yeah, definitely.

00:14:39.640 --> 00:14:40.320
Okay, great.

00:14:40.320 --> 00:14:48.660
Now, one of the things I thought was really intriguing about IronPython, and you brought it up, is the lack of the GIL or the global interpreter lock.

00:14:48.660 --> 00:14:55.940
And that seems to be one of the challenges for doing real parallel, computational parallelism in Python.

00:14:55.940 --> 00:15:00.700
You can do it and you can use the, you know, multi-process support and things like that.

00:15:00.700 --> 00:15:05.780
But, you know, straight up threading when you're just doing computational stuff is challenging, right?

00:15:05.780 --> 00:15:08.360
Is that more doable in IronPython?

00:15:08.360 --> 00:15:09.660
Yeah, I would say so.

00:15:09.660 --> 00:15:23.820
Because we don't have that, the GIL in IronPython, when we have something that can be spread across multiple cores, which .NET supports very well, you can really take advantage of multiple cores and not running into that, the GIL, which can slow you down.

00:15:23.820 --> 00:15:28.240
Okay, so people are out there and maybe they have some project and they're trying to use parallelism.

00:15:28.740 --> 00:15:35.560
How hard would it be for them to switch from running, you know, CPython to try out IronPython with their code?

00:15:35.560 --> 00:15:41.460
Like, what's the chances of them taking what they have and running it with a different interpreter and having it work?

00:15:41.460 --> 00:15:44.060
It depends quite a bit on what modules they're using.

00:15:44.060 --> 00:15:52.920
Because we're running as a .NET application, we really can't use C modules, C-based modules.

00:15:52.920 --> 00:15:58.240
So if you have something that's based on a C module, it's hard for us to interact with that right now.

00:15:58.240 --> 00:16:11.100
Now, we do have a side project that had started a while ago when we were working on 2.6, Python 2.6 compatibility called Ironclad, which allowed us to interact with C modules.

00:16:11.100 --> 00:16:22.960
It was kind of abandoned for a while, and now we're going to try and bring it back so that we can reuse some of those C modules that CPython provides so that more things are compatible under IronPython.

00:16:22.960 --> 00:16:26.120
Okay, yeah, I mean, that seems really important to me.

00:16:26.120 --> 00:16:36.740
I think one of the lessons from PyPy is it's really great, but it had these huge challenges around some of the popular packages that relied heavily on C, like NumPy, for example.

00:16:37.380 --> 00:16:44.620
And they went so far as to try to implement their own version of NumPy in PyPy or in Python, in pure Python.

00:16:44.620 --> 00:16:52.900
And that just seems like such a hard battle to, like, look at all the open source projects that are successful out there and go, let's just reimplement all of those.

00:16:52.900 --> 00:16:55.080
And instead have to date, right?

00:16:55.080 --> 00:16:55.740
Yeah.

00:16:55.740 --> 00:16:56.760
It seems almost impossible.

00:16:56.760 --> 00:16:58.400
Yeah, it's hard to play catch up.

00:16:58.660 --> 00:17:01.980
It feels like you're always playing catch up, and that's a hard position to be in.

00:17:01.980 --> 00:17:10.780
For one thing, you're trying to maintain compatibility with the language itself, which can change slightly from rev to rev, even on just the 2.7 baseline.

00:17:10.780 --> 00:17:19.600
But then you have the open source projects that provide modules that are native or written in C, and those can be difficult to keep up with as well.

00:17:19.600 --> 00:17:23.440
So it's definitely a trial that we're trying to work on and figure out.

00:17:23.440 --> 00:17:27.680
Yeah, it sounds like Ironclad would be really important, or something filling that role at least.

00:17:27.680 --> 00:17:30.960
How do you end up becoming one of the maintainers?

00:17:30.960 --> 00:17:33.160
And you have a co-maintainer as well, right?

00:17:33.160 --> 00:17:33.500
Yeah.

00:17:33.500 --> 00:17:36.120
So my co-maintainer is Benedict Eggers.

00:17:36.120 --> 00:17:37.640
He's located in Germany.

00:17:37.640 --> 00:17:44.840
He was kind of what really kind of kicked off the resurgence of IronPython, I would say.

00:17:44.840 --> 00:17:51.640
Ever since Microsoft open sourced it, I had been working, doing some stuff, because I was using it in my job.

00:17:51.640 --> 00:17:54.260
So I wanted it to be a good piece of software.

00:17:54.260 --> 00:17:57.620
And Jeff Hardy was the maintainer at the time.

00:17:58.600 --> 00:18:06.680
And he's gotten, as with all of us, we go through hills and valleys of how busy we are with our jobs and family and stuff.

00:18:06.680 --> 00:18:12.340
And he just reached a point where his job and his family were taking up a lot of time, as they should.

00:18:12.340 --> 00:18:17.560
And he just didn't have the time that he thought he could put into helping IronPython be successful.

00:18:17.560 --> 00:18:27.820
And so Benedict kind of pushed some buttons using some Twitter conversations between Jeff and myself and Benedict to kind of push.

00:18:27.820 --> 00:18:32.360
And Jeff finally realized that he could pass it off to myself and Benedict.

00:18:32.860 --> 00:18:41.900
Myself, because I had some history with the project and so forth, and Benedict, because he really had some excitement about it to get it going again.

00:18:41.900 --> 00:18:43.720
So that's kind of how I got in there.

00:18:43.720 --> 00:18:47.280
And Benedict is good at making people excited about things.

00:18:47.280 --> 00:18:49.200
And so I got excited about IronPython again.

00:18:49.200 --> 00:18:50.200
How nice.

00:18:50.460 --> 00:18:52.260
We started making plans for the future.

00:18:52.260 --> 00:18:53.840
Yeah, yeah, that's cool.

00:18:53.840 --> 00:18:55.880
And it's interesting that was over Twitter.

00:18:55.880 --> 00:19:07.320
I feel like people outside the development space don't really appreciate how special Twitter is in connecting you to people you would otherwise not be connected to.

00:19:07.440 --> 00:19:13.480
Yeah, I mean, you can go to a site for a project and see like an email address for a developer, but you don't know, is it current?

00:19:13.480 --> 00:19:16.360
Are they using that email address?

00:19:16.360 --> 00:19:18.560
But Twitter, it's so easy to connect real fast.

00:19:18.560 --> 00:19:21.640
Yeah, and the messages are small enough, you're likely to get a response.

00:19:21.640 --> 00:19:27.340
If you write some 500-word email, people are just going to ignore you most of the time if they're busy or whatever.

00:19:27.340 --> 00:19:31.240
But yeah, so I think it's really cool that that started out over Twitter.

00:19:31.240 --> 00:19:45.560
This portion of Talk Python is brought to you by Hired.

00:19:45.560 --> 00:19:48.580
Hired is the platform for top Python developer jobs.

00:19:48.580 --> 00:19:53.380
Create your profile and instantly get access to 3,500 companies who will work to compete with you.

00:19:53.380 --> 00:19:56.240
Take it from one of Hired's users who recently got a job and said,

00:19:56.240 --> 00:20:01.560
I had my first offer on Thursday after going live on Monday and I ended up getting eight offers in total.

00:20:01.560 --> 00:20:05.000
I've worked with recruiters in the past, but they've always been pretty hit and miss.

00:20:05.000 --> 00:20:07.840
I tried LinkedIn, but I found Hired to be the best.

00:20:07.840 --> 00:20:09.940
I really like knowing the salary up front.

00:20:09.940 --> 00:20:12.300
Privacy was also a huge seller for me.

00:20:12.300 --> 00:20:13.980
Sounds awesome, doesn't it?

00:20:13.980 --> 00:20:16.000
Well, wait until you hear about the sign-in bonus.

00:20:16.000 --> 00:20:19.400
Everyone who accepts a job from Hired gets $1,000 sign-in bonus.

00:20:19.400 --> 00:20:22.080
And as Talk Python listeners, it gets way sweeter.

00:20:22.400 --> 00:20:27.320
Use the link Hired.com slash Talk Python To Me and Hired will double the signing bonus to $2,000.

00:20:27.320 --> 00:20:29.100
Opportunity's knocking.

00:20:29.100 --> 00:20:32.880
Visit Hired.com slash Talk Python To Me and answer the door.

00:20:32.880 --> 00:20:44.380
So do you want to talk a little bit about the internals, about how this works?

00:20:44.840 --> 00:20:46.620
I know how it works in CPython.

00:20:46.620 --> 00:20:53.600
We have Python bytecode and we have this eval loop that will go through and pull out this bytecode.

00:20:53.600 --> 00:20:57.700
Instead of a JIT compiling it, it will just interpret it and piece it all together.

00:20:57.700 --> 00:20:59.580
What happens in IronPython?

00:20:59.580 --> 00:21:00.960
How is it the same or different?

00:21:00.960 --> 00:21:01.740
Sure.

00:21:01.740 --> 00:21:04.280
It's kind of a similar concept.

00:21:04.900 --> 00:21:08.760
We parse the Python code into an abstract syntax tree.

00:21:08.760 --> 00:21:14.960
And then we kind of do some optimization or, yeah, you can call it optimization.

00:21:14.960 --> 00:21:20.260
So when something is executed, we generate what's called a call site for that operation.

00:21:20.260 --> 00:21:24.920
So that in the future, if we execute the same code or similar code,

00:21:24.920 --> 00:21:28.060
we have an optimized version of that code that we can then call.

00:21:28.560 --> 00:21:33.220
So we basically take the Python and we convert that into the abstract syntax tree.

00:21:33.220 --> 00:21:38.640
And then that gets converted into like a Lambda, basically, in the .NET world.

00:21:38.640 --> 00:21:40.080
Something that we can execute.

00:21:40.080 --> 00:21:48.200
And we cache off the compiled or optimized version of that call so that if we get another get adder call,

00:21:48.200 --> 00:21:51.560
for instance, we have an optimized version of that that we can call

00:21:51.560 --> 00:21:55.400
and we don't have to recompile it into the Lambda format from the abstract syntax tree.

00:21:55.640 --> 00:21:56.780
Okay. That's interesting.

00:21:56.780 --> 00:22:04.100
So every instruction when I run Python code in IronPython is JIT compiled eventually?

00:22:04.100 --> 00:22:10.120
Yes. Because it gets converted into a .NET IL, which is the intermediate language,

00:22:10.120 --> 00:22:15.540
the JIT will run on that code when it's executed and can get cached off.

00:22:15.540 --> 00:22:18.520
All right. That's a really interesting difference than, say, PyPy.

00:22:18.520 --> 00:22:24.320
Because when I talked to the PyPy guys, they said it initially runs through CPython,

00:22:24.600 --> 00:22:27.160
but if it runs enough, they're like, all right, this is the hotspot.

00:22:27.160 --> 00:22:29.060
We're going to JIT this part.

00:22:29.060 --> 00:22:32.900
But it doesn't always JIT, which is interesting.

00:22:32.900 --> 00:22:37.680
I think it makes it a little less predictable, perhaps, in the way that PyPy works.

00:22:37.680 --> 00:22:38.980
So that's pretty cool.

00:22:38.980 --> 00:22:43.480
So I guess that means things like garbage collection apply as well, right?

00:22:43.480 --> 00:22:47.020
The standard garbage collection that you would know from there.

00:22:47.020 --> 00:22:47.940
Yeah, definitely.

00:22:48.260 --> 00:22:50.540
So the .NET framework includes garbage collection.

00:22:50.540 --> 00:22:56.840
And so we don't, unlike the CPython, which has to do reference counting on objects in the internals,

00:22:56.840 --> 00:22:58.300
we don't have to do that.

00:22:58.300 --> 00:23:00.400
It's all done automatically for us.

00:23:00.400 --> 00:23:03.160
And the GC takes care of anything that's not around anymore.

00:23:03.720 --> 00:23:06.440
Well, that definitely makes it easier on you as an implementer.

00:23:06.440 --> 00:23:11.540
What are the benefits or drawbacks of that versus, say, reference counting in CPython?

00:23:11.540 --> 00:23:18.460
In CPython, it's deterministic because you're telling the runtime when something is no longer needed.

00:23:18.460 --> 00:23:20.480
And so it can clean it up right then.

00:23:20.960 --> 00:23:26.700
In running under .NET with IronPython, the garbage collection is non-deterministic.

00:23:26.700 --> 00:23:32.800
So it can run even during a critical point in your app and slow things down slightly.

00:23:32.800 --> 00:23:36.760
Now, because we're running on .NET, we can have multi-core stuff.

00:23:36.760 --> 00:23:39.860
So the garbage collector may be running on one core.

00:23:39.860 --> 00:23:44.620
And so you still have, like, three cores out of four that can actually execute code.

00:23:44.620 --> 00:23:47.120
But there is a non-deterministic garbage collector.

00:23:47.120 --> 00:23:48.820
And Jython would have the same issue.

00:23:49.500 --> 00:23:52.640
Java runtime garbage collection is also non-deterministic.

00:23:52.640 --> 00:23:58.060
So it's a similar issue or problem between the two managed frameworks.

00:23:58.060 --> 00:23:58.640
Interesting.

00:23:58.640 --> 00:24:03.800
Yeah, I remember playing around with some of those ideas and checking out the performance,

00:24:03.800 --> 00:24:09.360
realizing that allocation was actually faster a lot of the times in some of the GC spaces.

00:24:09.360 --> 00:24:13.680
But you paid for it later when it had to be cleaned up because that was way more complicated

00:24:13.680 --> 00:24:16.640
because the compacting GCs and simplifying.

00:24:16.640 --> 00:24:20.300
You don't have to, like, find an empty slot in the free space.

00:24:20.300 --> 00:24:22.020
Those usually get compacted.

00:24:22.020 --> 00:24:23.780
Okay, that's pretty cool.

00:24:23.780 --> 00:24:29.120
So you brought up some of the different types of apps that you can build with IronPython.

00:24:29.120 --> 00:24:31.260
Want to give us a bit of a rundown on that?

00:24:31.260 --> 00:24:37.300
So you said you could build WPF apps, which is sort of the standard Windows UI framework these days.

00:24:37.300 --> 00:24:38.400
What else?

00:24:38.820 --> 00:24:41.240
So we actually have a module, a WPF module.

00:24:41.240 --> 00:24:49.700
So you can import WPF, and it provides kind of higher-level ways of interacting with WPF that are more Python-like.

00:24:49.700 --> 00:24:52.520
So it makes it easier to develop those sort of things.

00:24:52.520 --> 00:24:56.180
Benedict actually does quite a bit with WPF on IronPython.

00:24:56.600 --> 00:25:03.680
We also have, you can write Windows Forms, which is kind of the older format of Windows applications.

00:25:03.680 --> 00:25:08.520
WPF is supposed to replace Windows Forms, but it hasn't happened yet.

00:25:08.520 --> 00:25:10.060
People still write Windows Forms apps.

00:25:10.060 --> 00:25:13.460
You can write Windows Forms apps under IronPython.

00:25:13.880 --> 00:25:19.840
Now, you have to start them differently than you would a, like a command line application.

00:25:19.840 --> 00:25:28.960
On Windows, when you're running a Windows application, it has to have an event loop in order for it to process Windows events and things like that.

00:25:28.960 --> 00:25:37.640
The normal command line client doesn't have that message loop, so it can't run Windows Forms apps or WPF apps.

00:25:37.640 --> 00:25:48.580
So we actually have a separate interpreter executable, which allows or has an event loop started up so that your forms applications and stuff work correctly.

00:25:48.580 --> 00:25:49.520
Oh, that's interesting.

00:25:49.520 --> 00:25:54.660
Yeah, because it has to plug in basically to that already running event loop or something like that, right?

00:25:54.660 --> 00:25:55.320
Exactly.

00:25:55.320 --> 00:25:56.000
Yep.

00:25:56.000 --> 00:25:56.620
Okay.

00:25:56.620 --> 00:26:00.100
And can you build, what do you distribute, I guess?

00:26:00.100 --> 00:26:04.980
Like, do people have to have IronPython installed in the system?

00:26:05.320 --> 00:26:09.120
Can you give them, like, an executable that's self-contained?

00:26:09.120 --> 00:26:11.200
What thing do you give to people to run?

00:26:11.200 --> 00:26:19.120
We do have what's called the IronPython compiler, which is basically what it does is takes any .py files that you want,

00:26:19.120 --> 00:26:22.620
and you can actually also include the Python standard library,

00:26:22.620 --> 00:26:31.980
and you can build a standalone executable that is basically a, has the Python code as a resource embedded inside,

00:26:32.180 --> 00:26:40.460
and then some wrapper code to pull out those resources and execute it as if you were running it from the command line using the IPy interpreter.

00:26:40.460 --> 00:26:44.040
So you can create pretty standalone executables.

00:26:44.040 --> 00:26:46.660
They are pretty large because you're embedding everything inside,

00:26:46.660 --> 00:26:53.820
but you can distribute a single executable that has all of the data inside for running your application.

00:26:54.040 --> 00:26:54.780
Oh, that's pretty awesome.

00:26:54.780 --> 00:26:57.280
Does that take, like, external packages?

00:26:57.280 --> 00:27:04.400
Like, if I'm using requests or passlib or some of these things, will it get sucked in and become part of my project?

00:27:04.560 --> 00:27:09.040
Right now, we don't have automatic dependency checking for that,

00:27:09.040 --> 00:27:14.180
so you would have to specify the path to the .py file on your system.

00:27:14.180 --> 00:27:16.040
But that is something we're looking into.

00:27:16.040 --> 00:27:22.280
I recently created a patch for Module Finder for IronPython because we don't have bytecode,

00:27:22.280 --> 00:27:27.020
and Module Finder uses bytecode, the Python bytecode, to determine what's being imported.

00:27:27.720 --> 00:27:34.320
But I created a patch that uses the AST module to find all the imports within your project as well.

00:27:34.320 --> 00:27:36.800
And that's something I'm going to roll into the IronPython compiler

00:27:36.800 --> 00:27:42.160
so that it can automatically find the dependencies that you're using and include them.

00:27:42.160 --> 00:27:43.820
Okay. What's the timeline on that?

00:27:43.820 --> 00:27:48.800
Probably in the next major release of the 2.7 branch that we're working on.

00:27:49.000 --> 00:27:53.940
We are working on IronPython 3, which would be 3.x support,

00:27:53.940 --> 00:27:58.120
but we're still maintaining the 2.7 release track as well.

00:27:58.120 --> 00:27:59.740
And so probably the next major release.

00:27:59.740 --> 00:28:04.060
We're going to do another minor release here pretty soon because we had some regressions.

00:28:04.060 --> 00:28:08.720
It was our first release as project owners, and we were human, so we made a few mistakes.

00:28:08.720 --> 00:28:13.240
But we're working to fix those and get out kind of a minor release.

00:28:13.240 --> 00:28:17.380
But I think in the next major release, we can include that type of support.

00:28:18.000 --> 00:28:22.840
So what's the story with Python 3 versus Python 2 since you brought it up?

00:28:22.840 --> 00:28:26.060
Sure. So in .NET, all strings are Unicode.

00:28:26.060 --> 00:28:31.640
So we've had some Python 3-esque support for a while now because of that.

00:28:31.640 --> 00:28:36.140
It also caused us problems with some of the 2.7 modules, but that's kind of a different story.

00:28:36.140 --> 00:28:43.400
But we are working on implementing all of the features for the most recent 3.x series.

00:28:43.400 --> 00:28:47.840
It's in a separate code repository from the IronPython 2.

00:28:47.840 --> 00:28:56.720
Because we're going to make some fairly significant changes to the parsing logic for the new language features and things like that.

00:28:56.760 --> 00:29:05.600
But it also allows, you know, a lot of those Unicode issues will go away with IronPython 3, which, because Python 3 switched to Unicode as well.

00:29:05.600 --> 00:29:09.940
Sure. So is that something I can use today or is it still being worked on?

00:29:10.040 --> 00:29:13.800
It's still being worked on. We don't have all the language features in yet.

00:29:13.800 --> 00:29:21.760
We're working on trying to get out a first release in the end of October that has language features implemented.

00:29:21.760 --> 00:29:26.520
And then we're going to work on fixing bugs and making sure all the tests are passing.

00:29:26.520 --> 00:29:35.200
And we're really trying to push standard library features upstream so that you can use the normal Python standard library.

00:29:35.200 --> 00:29:38.880
Right now we have some changes in the standard library and have a local version of it.

00:29:39.140 --> 00:29:44.300
So you can't just go and grab the standard library of CPython and use it with IronPython and have it work.

00:29:44.300 --> 00:29:52.960
But we want to push those changes upstream so that you can use the normal CPython standard library with IronPython 3.

00:29:52.960 --> 00:29:54.580
Okay. Yeah. It seems like a great plan.

00:29:54.980 --> 00:29:59.580
You touched on threading. And one thing I did want to ask you about, since we're talking about Python 3,

00:29:59.580 --> 00:30:06.840
is there's some coroutine parallelism features in Python 3 with the async and await keywords.

00:30:06.840 --> 00:30:10.180
And C# also has async and await keywords.

00:30:10.180 --> 00:30:19.940
So is there some special tie-in, like does async and await do anything extra cool on IronPython versus regular Python 3?

00:30:20.220 --> 00:30:30.320
The async and await stuff is something we haven't implemented yet, but I think it's going to be fairly easy because C# and .NET have the async and await already built in.

00:30:30.320 --> 00:30:34.440
But that's something we haven't implemented yet in the IronPython 3 yet.

00:30:34.440 --> 00:30:39.880
Okay. And speaking of implementation, we said that CPython is not mostly Python.

00:30:39.880 --> 00:30:43.400
Mostly it's C code in the actual low-level parts, right?

00:30:43.400 --> 00:30:47.560
So I had some of the standard library. But what is IronPython written in?

00:30:47.560 --> 00:30:49.860
IronPython is written in C#.

00:30:49.920 --> 00:30:54.620
And so the native modules or some of the built-in modules are implemented in C#.

00:30:54.620 --> 00:31:03.980
We replicate the functionality of the native C modules, things like underscore hashlib, underscore SSL,

00:31:03.980 --> 00:31:09.420
things that are imported in the Python module like SSL.py or hashlib.py.

00:31:09.420 --> 00:31:14.580
We implement those and try and create them as feature-complete as possible in C#.

00:31:14.580 --> 00:31:23.040
Okay. And how hard is it to match those things up? Do you have like tons of tests? Do you run the standard Python tests to verify your code or anything like that?

00:31:23.140 --> 00:31:28.920
Yeah, we definitely use all the tests that are already there for the CPython in the standard library.

00:31:28.920 --> 00:31:37.460
We use those heavily. In addition, we have some features that we test for like COM, which is a Windows technology, the common object model.

00:31:37.700 --> 00:31:42.300
We have some stuff that makes it easier to work with COM objects. And so we have some tests that do that.

00:31:42.300 --> 00:31:53.160
We have tests for interaction between C# and IronPython to make sure that if you're hosting IronPython in your application, it continues to run well.

00:31:53.360 --> 00:31:58.140
So we do use the CPython tests and then we add additional tests on top of that.

00:31:58.140 --> 00:32:01.980
Right, because you're trying to add additional functionality, I guess, in addition to what they're providing.

00:32:01.980 --> 00:32:08.980
Okay. So also you talked about Windows apps. Can you build web apps, which is maybe where Python is used more?

00:32:09.360 --> 00:32:20.780
Yeah. So Benedict has been working on something that we recently imported into the Iron Languages repository or organization on GitHub, which is IronPython ASP.NET MVC.

00:32:20.780 --> 00:32:28.780
And basically what it does is allows you to write ASP.NET MVC apps, web apps in IronPython or in Python.

00:32:28.780 --> 00:32:34.260
So you can define your routes and that sort of thing in Python. So it's a really exciting thing.

00:32:34.260 --> 00:32:37.560
And that's one of the things we really want to get running under .NET Core as well.

00:32:37.560 --> 00:32:46.080
Yeah, that sounds awesome. If you could get that running on .NET Core so I could develop that on my Mac and deploy it on Linux, that's pretty interesting.

00:32:46.080 --> 00:32:53.260
Yeah, and you still get the power of some of the .NET libraries that may not have a Python module to do.

00:32:53.260 --> 00:32:56.420
Sure. Okay. Well, yeah, that sounds pretty exciting. I'm looking forward to that.

00:32:56.420 --> 00:33:00.540
What about managing local environments?

00:33:00.540 --> 00:33:06.960
CPython has great support for virtual environments, especially in Python 3. It's got VEMD built in.

00:33:06.960 --> 00:33:10.700
Do you guys have this concept of virtual environments with what you built?

00:33:10.700 --> 00:33:17.960
We had some patches upstream to virtual ENV because there are some things that we were having some issues with.

00:33:17.960 --> 00:33:25.380
They requested us to make some changes and all that kind of happened back when development was really kind of dying out on IronPython.

00:33:26.020 --> 00:33:33.860
So it's something we need to resurrect and re-look at, but it's definitely something we want to support because people love that as part of CPython.

00:33:33.860 --> 00:33:37.180
So we'd really like to provide that as part of IronPython as well.

00:33:37.180 --> 00:33:40.200
Yeah, yeah. It's definitely pretty important. Okay, cool.

00:33:40.340 --> 00:33:42.040
And then you also have something called PyLauncher.

00:33:42.040 --> 00:33:49.380
How does that relate? Is that like the thing that will sort of associate with Python files and run them, or what's the story of that?

00:33:49.380 --> 00:33:53.300
It is a launcher. I don't know if you're familiar with Visual Studio at all.

00:33:53.300 --> 00:33:59.560
Visual Studio has a bunch of different formats for their project files, and so they have what's called a Visual Studio Launcher.

00:33:59.560 --> 00:34:08.020
Visual Studio Launcher will get the format of the file that it's received and determine which version of Visual Studio that you have on your system you should open it with.

00:34:08.340 --> 00:34:10.440
And that's kind of what PyLauncher does as well.

00:34:10.440 --> 00:34:19.060
It allows you to have multiple different Python versions on your system and launch a different one based on different things within the files.

00:34:19.060 --> 00:34:19.720
Right, okay.

00:34:19.720 --> 00:34:27.380
So you mentioned Visual Studio, and Visual Studio is fine if you're on Windows, but if you're not, then you don't really have it.

00:34:27.380 --> 00:34:30.860
And I'm also a fan of PyCharm, as people listening to the show know.

00:34:30.860 --> 00:34:34.860
Could I, say, open PyCharm and write IronPython apps with it?

00:34:34.860 --> 00:34:37.900
Yeah, I mean, we do run on Mona right now.

00:34:38.060 --> 00:34:41.200
So, which we'll install on OSX or on Linux.

00:34:41.200 --> 00:34:51.180
And so, you know, some people I know who are working on IronPython itself use like Emacs or Vim or, you know, their favorite editor.

00:34:51.180 --> 00:34:56.160
And they write the Python and then they execute it from the command line using the ipy.exe.

00:34:56.780 --> 00:35:02.960
So if you're developing the Python itself, you can write it anywhere and run it under the interpreter.

00:35:03.360 --> 00:35:12.420
Now, there is an awesome tool from Microsoft called the Python Tools for Visual Studio, which is basically a free Python ID if you're running on Windows.

00:35:12.420 --> 00:35:15.800
They do an awesome job of a lot of stuff.

00:35:15.800 --> 00:35:18.260
And that kind of started out of IronPython initially.

00:35:18.920 --> 00:35:20.720
And so that's kind of why I like it.

00:35:20.720 --> 00:35:23.880
But, yeah, you can use basically any ID you want to write the Python.

00:35:23.880 --> 00:35:27.200
And then you just execute it under the IronPython interpreter.

00:35:27.200 --> 00:35:27.660
All right.

00:35:27.660 --> 00:35:29.180
Yeah, that sounds really cool.

00:35:29.180 --> 00:35:36.200
Yeah, I remember the IronPython tools for Visual Studio just became the Python tools for Visual Studio at some point, right?

00:35:36.380 --> 00:35:38.440
Yeah, and so they work with IronPython.

00:35:38.440 --> 00:35:39.740
They work with CPython.

00:35:39.740 --> 00:35:41.940
I don't know if it works with PyPy.

00:35:41.940 --> 00:35:43.040
I've never tried that.

00:35:43.040 --> 00:35:53.960
But as I've created this tools here at work that use IronPython, I've had to recommend, you know, GUIs for people who are, you know, hardware engineers and stuff like that to write Python.

00:35:53.960 --> 00:36:01.720
They can get syntax highlighting, IntelliSense type stuff or auto-completion stuff of methods and parameters, documentation.

00:36:01.720 --> 00:36:04.640
So, yeah, Python tools is very good for that.

00:36:04.640 --> 00:36:06.040
Most people here run Windows.

00:36:06.040 --> 00:36:08.580
So, it's easy for me to recommend Windows tools to them.

00:36:08.580 --> 00:36:10.940
Yeah, it's an easy sell if it already runs there.

00:36:10.940 --> 00:36:30.680
We all want to ship our software faster, respond to user requests quicker, and build an edge on the competition.

00:36:30.680 --> 00:36:35.700
But the faster you go, the more likely a bug or issue will slip by and cause your users grief.

00:36:35.700 --> 00:36:38.980
I have the same trade-offs with my Talk Python websites and infrastructure.

00:36:38.980 --> 00:36:40.660
That's why I use SnapCI.

00:36:40.660 --> 00:36:44.260
Every time I check in at GitHub, SnapCI springs into action.

00:36:44.260 --> 00:36:46.560
A clean copy of code is pulled from GitHub.

00:36:46.560 --> 00:36:48.580
A Python 3 virtual environment is created.

00:36:48.580 --> 00:36:50.740
All the packages and dependencies are installed.

00:36:50.740 --> 00:36:52.040
The unit tests are run.

00:36:52.380 --> 00:36:55.820
Finally, I'm notified in Slack and a menu bar on my Mac about the outcome.

00:36:55.820 --> 00:36:59.440
That way, I know it's safe to ship a shiny new version of my web app.

00:36:59.440 --> 00:37:04.840
Ship your software faster with a 30-day free trial at snap.ci slash Talk Python.

00:37:13.340 --> 00:37:25.800
Yeah, there's a whole, let's say, vibrant debate that we could start about whether you should use IDEs or you should use something minimalistic like Emacs or Sublime, relatively speaking.

00:37:25.800 --> 00:37:27.680
Maybe we shouldn't really go into it.

00:37:27.740 --> 00:37:31.720
I kind of lean a little more towards the ID side myself on the PyCharm space.

00:37:31.720 --> 00:37:37.600
And I think the tools, if you are on Windows, I think the Visual Studio tools are pretty sweet as well.

00:37:37.600 --> 00:37:38.560
I've played with them a little.

00:37:38.560 --> 00:37:46.480
So one thing that I thought was interesting that I saw on the mailing list going around was about the time that you took over, I think,

00:37:46.600 --> 00:37:53.100
there was a meeting that said there's a bunch of urgent issues and we're going to sort of reset the direction of IronPython.

00:37:53.100 --> 00:37:54.700
Yeah, when was that?

00:37:54.700 --> 00:37:58.200
So we had our first community meeting a couple months ago.

00:37:58.200 --> 00:38:01.300
We've been trying to have them every two weeks on Thursday.

00:38:01.300 --> 00:38:03.060
And we have them on Gitter.

00:38:03.060 --> 00:38:04.920
I don't know if you're familiar with Gitter.

00:38:04.920 --> 00:38:12.020
It basically allows you to use your GitHub credentials and organizations to have meeting rooms in a web page.

00:38:12.020 --> 00:38:15.020
Yeah, and they're generally like around a project on GitHub, right?

00:38:15.020 --> 00:38:16.140
Exactly, yeah.

00:38:16.240 --> 00:38:19.860
So we have one for our organization, which is the Iron Languages organization.

00:38:19.860 --> 00:38:21.960
Sure, so tell people what the GitHub URL is.

00:38:21.960 --> 00:38:23.180
Of course, I'll put it in the show notes.

00:38:23.180 --> 00:38:36.000
Sure, so we're at github.com forward slash iron languages forward slash main is currently the main repository for the Python 2.7 branch.

00:38:36.000 --> 00:38:44.980
Then there's github.com forward slash iron languages forward slash iron Python 3 for the work we're doing for Python 3 support.

00:38:44.980 --> 00:38:46.000
All right, excellent, yeah.

00:38:46.000 --> 00:38:47.700
Cool, I'll definitely link to those.

00:38:48.120 --> 00:38:54.260
So the meeting, the first meeting, some of the issues that people brought up were this idea of Iron Ruby.

00:38:54.260 --> 00:38:55.980
What is it doing here?

00:38:55.980 --> 00:38:57.340
Does it make sense in Iron Python?

00:38:57.340 --> 00:38:59.680
Do you want to talk about that a little?

00:38:59.680 --> 00:39:00.080
Sure.

00:39:00.320 --> 00:39:14.840
So when Microsoft open source the code, they had two languages are basically implemented on top of what's called the dynamic language runtime, which is kind of a set of classes or objects that make writing dynamic languages on top of .NET a little easier.

00:39:15.280 --> 00:39:26.780
It does all that stuff about the call sites that I talked about, caching things and converting an abstract syntax tree into the lambdas for calling the code and so forth.

00:39:26.780 --> 00:39:34.540
So they had Iron Python, which is an implementation of Python, and they had Iron Ruby, which was an implementation of the Ruby language on top of the DLR.

00:39:35.100 --> 00:39:40.720
So what we kind of did is we split out Iron Ruby into its own repository under the organization.

00:39:41.220 --> 00:39:51.100
And I submitted a message to the Ruby mailing list, say if there's anybody interested in taking up Iron Ruby and keeping it alive.

00:39:51.100 --> 00:39:53.640
And so there were a couple of people who responded.

00:39:53.640 --> 00:39:57.160
And, you know, we're willing to help them in any way we can.

00:39:57.160 --> 00:40:02.720
But we really kind of just split it out so that they could lead their own destiny wherever they want to take it.

00:40:02.720 --> 00:40:09.940
Yeah, that makes a lot of sense to me because while there's some similarities, there's a lot of differences between those two communities and languages.

00:40:09.940 --> 00:40:23.340
And I feel, I mean, maybe correct me if I'm wrong, but I feel like the mission of Iron Python these days is no longer to say we're going to be this cool thing that shows off the ability to do dynamic languages on .NET.

00:40:23.340 --> 00:40:29.680
It's all about making the Python as an alternate implementation special, right?

00:40:29.680 --> 00:40:33.700
And so then that makes Iron Ruby being tied up in it make a lot less sense, right?

00:40:33.700 --> 00:40:39.320
Yeah, and it really, we don't want to tie them down either with the decisions that we make going forward.

00:40:39.320 --> 00:40:43.540
We don't want to impact them in a negative way if they want to keep it alive and keep it going.

00:40:43.540 --> 00:40:55.680
So allowing them to have their own space is, I think, a good way to let them do what they need to do and let us do what we need to do to make both of our languages the best we can.

00:40:55.680 --> 00:40:56.440
Yeah, excellent.

00:40:56.440 --> 00:40:58.460
Okay, I'd say that's a good choice.

00:40:59.100 --> 00:41:08.860
And then when you moved over from where it used to be hosted to GitHub, there was something like 960 issues that were just sort of stale out there.

00:41:08.860 --> 00:41:10.700
And you're like, what do we do with these?

00:41:10.700 --> 00:41:12.520
Did you end up throwing them all away?

00:41:12.520 --> 00:41:13.340
Did you keep them?

00:41:13.340 --> 00:41:15.360
Like, how do you manage that transition?

00:41:15.360 --> 00:41:24.120
So, and all those issues were originally filed on CodePlex, which was Microsoft's open source competitor, if you will, to GitHub.

00:41:24.120 --> 00:41:30.960
I actually wrote a Python script that ported them, did a screen scrape using Beautiful Soup on CodePlex because they didn't have an API to do this.

00:41:31.140 --> 00:41:35.600
And then importing them into GitHub using one of the GitHub Python modules.

00:41:35.600 --> 00:41:36.220
Nice.

00:41:36.220 --> 00:41:37.340
That was a lot of fun.

00:41:37.340 --> 00:41:38.880
Yeah, who says they don't have an API?

00:41:38.880 --> 00:41:40.260
They do, they just don't know it.

00:41:40.260 --> 00:41:40.720
That's right.

00:41:40.720 --> 00:41:44.700
So anyway, there were these 960-odd issues.

00:41:44.700 --> 00:41:52.220
Some of them were as old as 2006 or 2007, pretty old.

00:41:52.220 --> 00:41:59.500
And so what we decided to do in the meeting is to go through and we marked them all as what we called untriaged,

00:41:59.700 --> 00:42:05.020
where we said we just basically didn't know what was going on, what needed to happen, or anything like that.

00:42:05.020 --> 00:42:14.380
And we have about 10 people who were in the community meeting that said that they would go through issues and try and triage whether they're a valid issue still,

00:42:14.380 --> 00:42:19.780
whether it's something that doesn't exist anymore so we can just close it out, or things along those lines.

00:42:19.780 --> 00:42:21.180
And so we've been working on that.

00:42:21.180 --> 00:42:22.940
I think we're down to about 800.

00:42:22.940 --> 00:42:28.480
So we haven't made a huge amount of progress, but we are making progress on triaging the issues

00:42:28.480 --> 00:42:30.840
and seeing, you know, we need to fix these issues.

00:42:30.840 --> 00:42:33.460
Some of them that we've triaged, we've fixed as well.

00:42:33.460 --> 00:42:36.040
So some of them were very simple fixes to make.

00:42:36.040 --> 00:42:40.320
We just had to know that we're still an issue and then go in and fix it.

00:42:40.320 --> 00:42:48.060
But we're slowly making our way through those and porting things from the untriage state to either closed or,

00:42:48.620 --> 00:42:52.140
yes, this is still an issue, to I don't know what we do with this.

00:42:52.140 --> 00:42:54.000
Let's talk about this one further.

00:42:54.000 --> 00:42:54.460
Sure.

00:42:54.460 --> 00:43:02.980
I think that highlights one of the real big challenges, the unglamorous side of running a large open source project, right?

00:43:03.100 --> 00:43:10.800
Like, probably if you could have your dream, whatever you want to do technically for your time, what do you want to dream about?

00:43:10.800 --> 00:43:15.920
It's probably not triaging 900 old issues that might not even be relevant, right?

00:43:15.920 --> 00:43:17.820
But it's important work.

00:43:17.820 --> 00:43:18.400
Yeah.

00:43:18.400 --> 00:43:21.140
It can be very satisfying to see that count go down.

00:43:21.140 --> 00:43:22.380
Yes, I'm sure.

00:43:22.560 --> 00:43:25.140
You know, it's been sitting around this 906 time.

00:43:25.140 --> 00:43:28.540
And so seeing it go down is very satisfying.

00:43:28.540 --> 00:43:28.980
Sure.

00:43:28.980 --> 00:43:38.940
Well, when I look at open source projects, you know, on GitHub or whatever, that's one of the indications of whether or not I want to trust this thing still being around, right?

00:43:38.940 --> 00:43:40.300
How old are the issues?

00:43:40.300 --> 00:43:41.760
Are they getting responded to?

00:43:41.760 --> 00:43:42.960
Also, pull requests.

00:43:42.960 --> 00:43:50.760
Like, you'll see projects that have year-old pull requests, which seems just so sad because somebody went to the extra effort of fixing code for you,

00:43:50.960 --> 00:43:53.620
and you didn't bother to pull it in or even respond, you know?

00:43:53.620 --> 00:43:54.020
Yeah.

00:43:54.020 --> 00:43:54.820
I agree completely.

00:43:54.820 --> 00:43:56.000
Yeah, it's tough.

00:43:56.000 --> 00:43:57.820
You also talked about release schedules.

00:43:57.820 --> 00:43:58.700
What's the story there?

00:43:58.700 --> 00:43:59.740
How often?

00:43:59.740 --> 00:44:00.980
What versions?

00:44:00.980 --> 00:44:02.200
Two, three, so on?

00:44:02.200 --> 00:44:02.640
Sure.

00:44:02.640 --> 00:44:11.020
Well, we're going from having like one release every four years to we'd really like to get on a more regular release schedule.

00:44:11.320 --> 00:44:22.700
So we did three beta releases or RC releases, release candidate releases, before we did the most recent 2.7.6.3 release.

00:44:22.700 --> 00:44:27.380
That was our final or our most recent final release or stable release.

00:44:27.380 --> 00:44:37.120
And so we really want to do that, you know, every couple months, do a full release with the fixes and stuff so people know that we're actively working on it and we're actively fixing issues.

00:44:37.320 --> 00:44:38.100
Yeah, okay, cool.

00:44:38.100 --> 00:44:43.700
Every couple months, we'd like to do a final release or, you know, either a minor release or a major release.

00:44:43.700 --> 00:44:45.420
Yeah, that's way better than every four years.

00:44:45.420 --> 00:44:45.860
Yeah.

00:44:45.860 --> 00:44:46.920
Yeah.

00:44:46.920 --> 00:44:47.520
Nice.

00:44:48.360 --> 00:44:48.880
All right.

00:44:48.880 --> 00:44:57.640
Then you also talked about continuous integration, IronPython 3, which we touched on a little bit, and then IronCloud or the ability to support C extensions.

00:44:57.640 --> 00:45:11.900
And I definitely want to just put my vote in to say, from what I've seen, the challenges that PyPy ran into, if you can support C extensions in a super clear, automatic way, that could seriously unlock the adoption.

00:45:12.200 --> 00:45:12.320
Yeah.

00:45:12.320 --> 00:45:13.320
Yeah, definitely.

00:45:13.320 --> 00:45:16.840
It would be a huge benefit for people using IronPython.

00:45:16.840 --> 00:45:22.020
And we wouldn't have to implement as many of the native modules in C# or whatever.

00:45:22.020 --> 00:45:27.760
Now, there may be cases where we want to because we can optimize it better without the GIL.

00:45:27.760 --> 00:45:32.760
But because the native libraries would assume there's a GIL there.

00:45:33.300 --> 00:45:39.080
So there are some things we'd probably still keep in C# or implement in C# because we would want to avoid the GIL.

00:45:39.080 --> 00:45:39.920
Yeah, that makes sense.

00:45:39.920 --> 00:45:42.900
But it would be nice to let that be a choice and not a necessity.

00:45:42.900 --> 00:45:43.500
Definitely.

00:45:43.500 --> 00:45:44.260
Definitely.

00:45:44.260 --> 00:45:45.200
Yeah, yeah.

00:45:45.200 --> 00:45:45.520
Awesome.

00:45:45.520 --> 00:45:47.000
All right, Alex.

00:45:47.000 --> 00:45:48.600
We're getting near the end of the show.

00:45:48.600 --> 00:45:51.680
At the end of the show, I always ask people a couple of questions.

00:45:51.680 --> 00:45:53.120
So let me put them to you now.

00:45:53.840 --> 00:46:03.080
On PyPI, there's over 80,000 packages, so many out there that you can use and just, you know, so many people probably haven't even heard of.

00:46:03.080 --> 00:46:06.480
Like, what's an amazing one that you'd like to sort of shine a light on?

00:46:06.480 --> 00:46:10.100
It's not a super, like, glamorous module, I would say.

00:46:10.100 --> 00:46:14.440
But my brother and I use Python with the PySerial module.

00:46:14.440 --> 00:46:18.840
We actually wrote an application that allowed us to interact with our body bugs.

00:46:18.840 --> 00:46:20.780
So I don't know if you're familiar with body bug.

00:46:20.780 --> 00:46:28.460
Like, it's an armband that you wear that tracks different things, like your bolts, and it's got a step counter and stuff like that.

00:46:28.460 --> 00:46:29.040
Oh, nice.

00:46:29.040 --> 00:46:33.380
And you have to have a subscription on their website to interact with it.

00:46:33.380 --> 00:46:39.780
And so we kind of looked around on the web and found some information on how to interact with it over the serial port.

00:46:39.780 --> 00:46:44.800
And so we use PySerial to interact with our body bug and get the same data that the website would get.

00:46:44.800 --> 00:46:46.080
Oh, that's awesome.

00:46:46.200 --> 00:46:51.920
It's not a glamorous module, but it was a lot of fun to be able to reverse engineer and do stuff like that with our body bugs.

00:46:51.920 --> 00:46:52.220
Sure.

00:46:52.220 --> 00:46:53.180
No, but it's a cool story.

00:46:53.180 --> 00:46:57.660
And, you know, you have these companies with weird restrictions and business models or whatever.

00:46:57.660 --> 00:46:58.700
You're like, you know, that's my data.

00:46:58.700 --> 00:46:59.420
It's on my arm.

00:46:59.420 --> 00:46:59.880
Come on.

00:46:59.880 --> 00:47:00.320
Exactly.

00:47:00.320 --> 00:47:00.640
Yeah.

00:47:00.640 --> 00:47:01.280
Yeah.

00:47:01.280 --> 00:47:01.580
Nice.

00:47:01.580 --> 00:47:05.360
I could probably guess what you're going to give me for the next question as an answer.

00:47:05.360 --> 00:47:07.800
But what's your favorite editor when you write Python code?

00:47:08.000 --> 00:47:11.300
Actually, I use Vim for most of my Pythons.

00:47:11.300 --> 00:47:18.140
I know I said Python tools from Visual Studio is awesome, but a lot of times I'm doing some quick edits to the Python code or something like that.

00:47:18.140 --> 00:47:23.860
So I got introduced to Vim years ago in college, and I use that quite a bit.

00:47:23.860 --> 00:47:29.700
I've tried using SpaceMax, which has a Vim mode for Emacs.

00:47:29.700 --> 00:47:33.280
But plain old vanilla Vim is kind of my go-to editor.

00:47:33.280 --> 00:47:34.020
Oh, right on.

00:47:34.020 --> 00:47:34.580
Very cool.

00:47:35.380 --> 00:47:35.660
All right.

00:47:35.660 --> 00:47:37.340
Well, any final call to action?

00:47:37.340 --> 00:47:40.420
Are you looking for people to help out on the project, people to try it out?

00:47:40.420 --> 00:47:41.140
What do you guys need?

00:47:41.140 --> 00:47:41.840
Oh, absolutely.

00:47:41.840 --> 00:47:44.760
We'd love to have anybody who wants to.

00:47:44.760 --> 00:47:47.180
You don't even need to, you know, write C#.

00:47:47.180 --> 00:47:50.540
There's all sorts of documentation we need to figure out.

00:47:50.540 --> 00:47:56.100
We do reuse a lot of the Python docs, but there are some things specific to Iron Python.

00:47:56.100 --> 00:47:59.220
Testing things out, see if there's still issues.

00:47:59.220 --> 00:48:01.660
We're still in that issue disposition time.

00:48:01.920 --> 00:48:08.500
So anybody's on to GitHub and look at the issues and see if they can reproduce it or give us a little bit more information.

00:48:08.500 --> 00:48:10.860
They'll kind of push us towards getting a fix faster.

00:48:10.860 --> 00:48:14.380
So anybody who wants to get involved, we'd love to have them on there.

00:48:14.380 --> 00:48:18.700
They can add on the mailing list, which we have through Python.org.

00:48:18.700 --> 00:48:19.800
It's Iron Python users.

00:48:19.800 --> 00:48:22.440
Yeah, we would welcome anybody who wants to help out.

00:48:22.560 --> 00:48:23.140
That sounds great.

00:48:23.140 --> 00:48:23.560
All right.

00:48:23.560 --> 00:48:26.100
If it sounds interesting to you, get out there and check it out.

00:48:26.100 --> 00:48:28.420
Alex, it's been fun to talk about Iron Python.

00:48:28.420 --> 00:48:30.920
I'm excited to see this coming back to life.

00:48:30.920 --> 00:48:34.240
It plays an interesting role in the ecosystem.

00:48:34.240 --> 00:48:36.040
So nice work and keep it up.

00:48:36.040 --> 00:48:37.040
Hey, thanks for having me on.

00:48:37.040 --> 00:48:38.220
It's been a blast.

00:48:38.220 --> 00:48:38.600
You bet.

00:48:38.600 --> 00:48:39.020
Talk to you later.

00:48:40.340 --> 00:48:43.520
This has been another episode of Talk Python To Me.

00:48:43.520 --> 00:48:45.880
Today's guest was Alex Earl.

00:48:45.880 --> 00:48:48.800
And this episode has been sponsored by Hired and SnapCI.

00:48:48.800 --> 00:48:50.880
Thank you both for supporting the show.

00:48:50.880 --> 00:48:53.640
Hired wants to help you find your next big thing.

00:48:53.640 --> 00:48:59.420
Visit Hired.com slash Talk Python To Me to get five or more offers with salary and equity presented right up front.

00:48:59.420 --> 00:49:02.120
And a special listener signing bonus of $2,000.

00:49:02.120 --> 00:49:06.460
SnapCI is modern, continuous integration and delivery.

00:49:06.460 --> 00:49:12.340
Build, test, and deploy your code directly from GitHub, all in your browser with debugging, Docker, and parallels included.

00:49:12.340 --> 00:49:15.380
Try them for free at snap.ci slash Talk Python.

00:49:15.380 --> 00:49:18.460
Are you or a colleague trying to learn Python?

00:49:18.460 --> 00:49:23.100
Have you tried books and videos that just left you bored by covering topics point by point?

00:49:23.100 --> 00:49:31.740
Well, check out my online course, Python Jumpstart by Building 10 Apps at talkpython.fm/course to experience a more engaging way to learn Python.

00:49:32.140 --> 00:49:39.060
And if you're looking for something a little more advanced, try my WritePythonic code course at talkpython.fm/Pythonic.

00:49:39.060 --> 00:49:46.400
You can find the links from this episode at talkpython.fm/episodes slash show slash 74.

00:49:46.400 --> 00:49:49.060
Be sure to subscribe to the show.

00:49:49.060 --> 00:49:51.260
Open your favorite podcatcher and search for Python.

00:49:51.260 --> 00:49:52.500
We should be right at the top.

00:49:52.880 --> 00:50:01.800
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

00:50:01.800 --> 00:50:06.740
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:50:06.740 --> 00:50:13.440
Corey just recently started selling his tracks on iTunes, so I recommend you check it out at talkpython.fm/music.

00:50:13.440 --> 00:50:18.780
You can browse his tracks he has for sale on iTunes and listen to the full-length version of the theme song.

00:50:19.280 --> 00:50:20.860
This is your host, Michael Kennedy.

00:50:20.860 --> 00:50:22.160
Thanks so much for listening.

00:50:22.160 --> 00:50:23.360
I really appreciate it.

00:50:23.360 --> 00:50:25.500
Smix, let's get out of here.

00:50:25.500 --> 00:50:46.960
Outro Music.

00:50:46.960 --> 00:50:47.760
*outro music*

