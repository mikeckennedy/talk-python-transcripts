WEBVTT

00:00:00.001 --> 00:00:02.880
Google runs millions of lines of Python code.

00:00:02.880 --> 00:00:07.440
The front-end servers that drive YouTube.com and YouTube's API

00:00:07.440 --> 00:00:09.940
are primarily written in Python,

00:00:09.940 --> 00:00:13.920
and they serve millions of requests per second.

00:00:13.920 --> 00:00:16.760
On this episode, you'll meet Dylan Trotter,

00:00:16.760 --> 00:00:19.420
who is working to increase the performance and concurrency

00:00:19.420 --> 00:00:20.900
of these servers powering YouTube.

00:00:20.900 --> 00:00:25.780
He just launched Grumpy, a Python implementation based on Go,

00:00:25.780 --> 00:00:27.880
the highly concurrent language from Google.

00:00:28.480 --> 00:00:33.180
This is Talk Python to Me, recorded January 12, 2017.

00:00:56.960 --> 00:01:01.240
Welcome to Talk Python to Me, a weekly podcast on Python,

00:01:01.240 --> 00:01:04.320
the language, the libraries, the ecosystem, and the personalities.

00:01:04.320 --> 00:01:06.420
This is your host, Michael Kennedy.

00:01:06.420 --> 00:01:08.420
Follow me on Twitter, where I'm @mkennedy.

00:01:08.420 --> 00:01:12.300
Keep up with the show and listen to past episodes at talkpython.fm,

00:01:12.300 --> 00:01:14.880
and follow the show on Twitter via at Talk Python.

00:01:15.660 --> 00:01:19.420
This episode has been sponsored by Hired and, as a new sponsor,

00:01:19.420 --> 00:01:21.580
pyimagesearch.com.

00:01:21.580 --> 00:01:26.320
They're announcing a Kickstarter campaign called Deep Learning for Computer Vision with Python,

00:01:26.320 --> 00:01:28.640
launching on Kickstarter right now.

00:01:28.640 --> 00:01:32.680
Thank both of these companies for supporting the show by checking out what they have to offer

00:01:32.680 --> 00:01:33.560
during their segments.

00:01:33.560 --> 00:01:35.800
Dylan, welcome to Talk Python.

00:01:35.800 --> 00:01:36.340
Thanks.

00:01:36.340 --> 00:01:36.920
Nice to be here.

00:01:37.060 --> 00:01:41.000
Yeah, I'm really excited to talk about Grumpy, actually.

00:01:41.000 --> 00:01:42.920
Grumpy, your Python project.

00:01:42.920 --> 00:01:43.580
It's going to be fun.

00:01:43.580 --> 00:01:47.080
Yeah, it's been pretty exciting a couple weeks since the release.

00:01:47.080 --> 00:01:48.500
So, yeah, I'm excited to talk about it, too.

00:01:48.500 --> 00:01:52.080
Yeah, it's definitely gotten a lot of attention in the open source world on GitHub.

00:01:52.600 --> 00:01:55.500
And we're going to dig into a lot of the details behind it.

00:01:55.500 --> 00:01:56.660
But let's start with you and your story.

00:01:56.660 --> 00:01:58.140
How did you get into programming in Python?

00:01:58.140 --> 00:02:01.780
I started programming, I guess, when I was in high school.

00:02:01.780 --> 00:02:07.020
I took, like, an intro programming course and kind of got the bug.

00:02:07.020 --> 00:02:10.060
And I just kind of took it from there.

00:02:10.060 --> 00:02:13.660
I was really into, like, programming little games and stuff like that back then.

00:02:13.660 --> 00:02:17.880
I did not do CS in university.

00:02:17.880 --> 00:02:23.280
I actually did physics, but I continued to work on programming in my own time a lot.

00:02:23.280 --> 00:02:30.780
And after or during university, actually, I got a gig at a sort of summer gig at a software company.

00:02:30.780 --> 00:02:35.680
And that gave me a leg up when I graduated, which was pretty lucky.

00:02:35.680 --> 00:02:41.680
And so I got a job at a visual effects company doing software there.

00:02:42.620 --> 00:02:48.800
So there was a bunch of different things, like a lot of sort of proprietary languages for the different packages.

00:02:48.800 --> 00:02:56.120
But Python sort of came out as a front runner in terms of integration with different visual effects packages and stuff like that.

00:02:56.120 --> 00:03:03.460
And so that's where I started to dig into Python, especially not so much on the sort of, like, effect side,

00:03:03.560 --> 00:03:07.980
but more on the pipeline data management kind of side of things.

00:03:07.980 --> 00:03:11.980
So there's a lot of asset management and stuff going on in visual effects studios.

00:03:11.980 --> 00:03:14.440
And Python's great for that sort of stuff.

00:03:14.440 --> 00:03:15.580
Yeah, that's really cool.

00:03:15.580 --> 00:03:22.300
I did a whole episode on Python and, like, game development studios and movies and production and stuff.

00:03:22.300 --> 00:03:27.080
I was really surprised how much Python glues all the tooling together for those folks.

00:03:27.440 --> 00:03:28.960
Yeah, it's really deep in there.

00:03:28.960 --> 00:03:35.980
In fact, when I was working in that area, that's when Python sort of started to come to the fore.

00:03:35.980 --> 00:03:44.540
And so, like, Maya, which is a big, like, modeling and animation package, built Python integration around that time.

00:03:44.540 --> 00:03:48.940
And Houdini is another one, similar use cases that integrate.

00:03:48.940 --> 00:03:53.580
Or actually, I think from pretty early on, Houdini had Python integration.

00:03:53.580 --> 00:03:58.500
So, yeah, it sort of became the de facto visual effects integration language.

00:03:58.500 --> 00:03:58.960
Okay.

00:03:58.960 --> 00:04:00.180
Yeah, yeah, very cool.

00:04:00.180 --> 00:04:01.920
And I think that's only growing.

00:04:01.920 --> 00:04:06.980
It seems like there's a couple areas where Python is sort of past critical mass.

00:04:06.980 --> 00:04:09.140
It's kind of like a black hole now.

00:04:09.140 --> 00:04:10.480
It's just sucking everything into it.

00:04:10.480 --> 00:04:10.840
Totally.

00:04:10.840 --> 00:04:11.340
Yeah, yeah.

00:04:11.340 --> 00:04:12.000
And that's a good thing.

00:04:12.000 --> 00:04:19.120
So you don't do visual effects anymore, although you kind of work in the video world these days.

00:04:19.120 --> 00:04:20.480
Why don't you tell everybody what you're up to?

00:04:20.480 --> 00:04:21.540
Yeah, sure.

00:04:21.540 --> 00:04:23.380
So I'm at YouTube now.

00:04:23.380 --> 00:04:25.700
I started there about seven years ago.

00:04:25.700 --> 00:04:28.040
It was kind of a big shift for me.

00:04:28.040 --> 00:04:35.000
Visual effects was a fun environment, but it was always kind of a dream to work at Google and stuff.

00:04:35.000 --> 00:04:36.800
So I took a gig at YouTube.

00:04:36.800 --> 00:04:40.540
And I've worked on a number of different teams there, actually.

00:04:40.540 --> 00:04:43.540
I've worked on sort of user-facing features.

00:04:43.540 --> 00:04:50.280
I was on the channels team for a long time, working on YouTube channels and stuff around that.

00:04:50.280 --> 00:04:54.540
And eventually got more into the infrastructure side.

00:04:54.540 --> 00:05:00.740
And so now I'm working on what's called, I guess, the application infrastructure group.

00:05:01.100 --> 00:05:10.020
And our team specifically looks after the application server that serves YouTube.com and YouTube APIs and those sorts of things.

00:05:10.020 --> 00:05:10.380
Excellent.

00:05:10.380 --> 00:05:18.980
So when we're all watching various things on YouTube, be it cat videos or something educational, we have you to thank for keeping those servers running.

00:05:19.660 --> 00:05:22.340
Yeah, well, me and a lot of other people.

00:05:22.340 --> 00:05:22.600
Yep.

00:05:22.600 --> 00:05:24.460
Yeah, yeah, I'm sure.

00:05:24.460 --> 00:05:26.800
Well, I'll thank you individually.

00:05:26.800 --> 00:05:27.720
So, yeah, awesome.

00:05:27.720 --> 00:05:30.240
Yeah, it sounds like a really fun place to work.

00:05:30.240 --> 00:05:31.320
Where's YouTube?

00:05:31.320 --> 00:05:33.400
Where's the center of the universe for YouTube?

00:05:33.400 --> 00:05:34.720
Is that Mountain View or somewhere else?

00:05:34.720 --> 00:05:38.580
San Bruno actually is where the main YouTube campus is.

00:05:38.580 --> 00:05:42.840
So there's a few different offices around the world.

00:05:42.840 --> 00:05:49.480
But the biggest group of the biggest sort of geographical concentration is in San Bruno.

00:05:49.480 --> 00:05:52.380
So there's a few buildings there that are YouTube.

00:05:52.380 --> 00:05:52.920
Okay.

00:05:52.920 --> 00:05:53.460
Yeah.

00:05:53.460 --> 00:05:53.920
Nice.

00:05:53.920 --> 00:05:55.000
That sounds like so much fun.

00:05:55.000 --> 00:05:59.060
So Python actually plays a really important role at YouTube these days.

00:05:59.060 --> 00:06:02.560
Let's talk about how it's used now and then how that kind of came to be.

00:06:02.560 --> 00:06:02.900
Sure.

00:06:02.900 --> 00:06:03.140
Yeah.

00:06:03.140 --> 00:06:10.960
So Python is what is running the main application server and a lot of the application code for

00:06:10.960 --> 00:06:18.940
the YouTube front end and for that serves like the website and the API service APIs that,

00:06:18.940 --> 00:06:21.540
you know, service your phone and those sorts of things.

00:06:21.540 --> 00:06:26.800
So it's sort of like the gateway for most user traffic.

00:06:26.800 --> 00:06:27.160
Right.

00:06:27.160 --> 00:06:31.540
And then maybe the Python code branches back into all sorts of Google services behind the

00:06:31.540 --> 00:06:34.220
scenes that are in a variety of technologies or something like that.

00:06:34.220 --> 00:06:34.440
Right.

00:06:34.440 --> 00:06:34.740
Yeah.

00:06:34.740 --> 00:06:38.960
There's a, there's a lot of different technologies and servers involved in the whole thing.

00:06:38.960 --> 00:06:39.120
Yep.

00:06:39.120 --> 00:06:39.400
Okay.

00:06:39.400 --> 00:06:43.000
So YouTube wasn't initially a Google creation, right?

00:06:43.000 --> 00:06:44.540
It was created by some other folks.

00:06:44.540 --> 00:06:50.360
It was founded in, in 2005, I think by three guys.

00:06:50.780 --> 00:06:55.060
One of the one of the one of the one of the one of the ones that I joined in 2009 is Chad Hurley.

00:06:55.060 --> 00:06:59.000
I think at the time he was the president or something.

00:06:59.000 --> 00:07:01.820
He left shortly after I joined.

00:07:01.820 --> 00:07:07.280
But yeah, they, they built it in 2005 and it gained a lot of traction really early on.

00:07:08.080 --> 00:07:16.880
And I guess Google took an interest at some point in 2006 and, and ended up buying YouTube in

00:07:16.880 --> 00:07:17.940
November, 2006.

00:07:17.940 --> 00:07:18.380
Yeah.

00:07:18.380 --> 00:07:22.660
I'd say that was a great move for them because it's, it's such a central part of the internet.

00:07:22.660 --> 00:07:23.320
Yeah.

00:07:23.320 --> 00:07:25.960
I feel like it, it had YouTube.

00:07:25.960 --> 00:07:30.100
The idea was something that a lot of people probably had the idea.

00:07:30.100 --> 00:07:32.620
It was a thing that clearly should exist.

00:07:33.080 --> 00:07:39.900
But when you think of the infrastructure and the bandwidth costs and just the actual act

00:07:39.900 --> 00:07:44.660
of creating such, such a huge video network seems prohibitive.

00:07:44.660 --> 00:07:47.940
But, you know, once it came into existence, you know, I guess Google jumped on it.

00:07:47.940 --> 00:07:48.240
That's cool.

00:07:48.240 --> 00:07:54.760
I actually remember thinking what a simple idea it was and, and how like, it seemed so crazy

00:07:54.760 --> 00:07:58.520
at the time that I think the acquisition cost was like 1.6 billion or something like that.

00:07:58.520 --> 00:08:02.940
And, and I remember reading about that and I was like, good Lord, like, you know, you

00:08:02.940 --> 00:08:06.820
could, how, how is something so simple worth so much?

00:08:06.820 --> 00:08:11.380
But now that number seems so quaint compared to recent, recent stuff.

00:08:11.380 --> 00:08:13.420
So, yeah, yeah, of course, of course.

00:08:13.420 --> 00:08:18.560
I mean, a lot of companies go through the thinking, it's easy to go through the thinking of you

00:08:18.560 --> 00:08:19.880
could have just built that yourself.

00:08:19.880 --> 00:08:20.400
Yeah.

00:08:20.400 --> 00:08:20.640
Right.

00:08:20.640 --> 00:08:24.860
I mean, Facebook bought Instagram for like an insane amount of money and that's like a team

00:08:24.860 --> 00:08:25.900
of 12 people, right?

00:08:25.900 --> 00:08:28.160
For whatever it was like 19 billion or something.

00:08:28.160 --> 00:08:32.800
They, they could have easily paid 12 people to build another Instagram, but it's, it's also

00:08:32.800 --> 00:08:35.560
also got people's interests.

00:08:35.560 --> 00:08:36.780
It's got the users.

00:08:36.780 --> 00:08:37.960
It's got the momentum.

00:08:37.960 --> 00:08:40.300
And that, that's the thing I think people buy.

00:08:40.300 --> 00:08:40.960
Absolutely.

00:08:40.960 --> 00:08:41.940
That's what you're paying for.

00:08:41.940 --> 00:08:42.220
Yeah.

00:08:42.220 --> 00:08:44.100
But they didn't write it in Python at first, did they?

00:08:44.100 --> 00:08:47.500
No, they, the first implementation I believe was PHP.

00:08:47.500 --> 00:08:49.560
And I don't think that lasted very long.

00:08:49.560 --> 00:08:53.600
I think it was, most of that was rewritten in Python pretty early on.

00:08:53.600 --> 00:08:54.600
Well, before I was there.

00:08:54.600 --> 00:08:54.900
Sure.

00:08:54.900 --> 00:08:55.180
Sure.

00:08:56.020 --> 00:09:01.540
I suspect the way YouTube looks today with the growth of cloud computing and all the

00:09:01.540 --> 00:09:06.600
different APIs and services is probably super different from when, what you guys got back

00:09:06.600 --> 00:09:07.700
in 2006, right?

00:09:07.700 --> 00:09:08.440
Yeah.

00:09:08.440 --> 00:09:11.680
It's, I mean, I think, you know, the company has grown a lot.

00:09:11.780 --> 00:09:14.000
The, the use cases have grown a lot.

00:09:14.000 --> 00:09:16.320
It's just, I mean, it's kind of night and day.

00:09:16.320 --> 00:09:21.540
It's when I, when I first joined, you know, everyone was kind of in one floor of one building.

00:09:21.540 --> 00:09:24.640
And since then, you know, there's distributed all over the world.

00:09:24.640 --> 00:09:27.280
And so, yeah, it's, it's, it's changed a lot.

00:09:27.280 --> 00:09:27.540
Sure.

00:09:27.540 --> 00:09:28.440
Wow.

00:09:29.160 --> 00:09:29.560
Okay.

00:09:29.560 --> 00:09:37.240
So that brings us to today, to YouTube and what this project that you, was this something

00:09:37.240 --> 00:09:40.920
that you created this project called grumpy or where did this come from?

00:09:40.920 --> 00:09:41.340
Yeah.

00:09:41.340 --> 00:09:46.080
I talked about some of the challenges we were having with, you know, running Python at scale

00:09:46.080 --> 00:09:48.260
and on, on the blog post.

00:09:48.260 --> 00:09:56.720
And it basically, there's a few different aspects that, that affects our ability to run, you know,

00:09:56.720 --> 00:09:58.200
that many Python servers.

00:09:58.420 --> 00:10:05.880
The CPython runtime, well, it's, it's really great and it's highly optimized and, and it

00:10:05.880 --> 00:10:09.940
does a lot of things really well for our use case.

00:10:09.940 --> 00:10:14.460
It's never really been a focus for CPython as a project.

00:10:14.460 --> 00:10:22.120
You know, we thought, you know, maybe it makes sense to rethink how the runtime is built with

00:10:22.120 --> 00:10:27.040
a focus on concurrency and, and running large server applications.

00:10:27.040 --> 00:10:27.540
Yeah.

00:10:27.620 --> 00:10:31.820
And you're not, you guys are not the first people to have this idea of, well, maybe we

00:10:31.820 --> 00:10:37.440
could replace the CPython runtime interpreter with something else.

00:10:37.440 --> 00:10:44.000
There's like Jython, there's IronPython, there's PyPy, there's plugin JIT.

00:10:44.000 --> 00:10:48.860
So there's a lot of stuff happening there, but nobody's gone in the direction that you went

00:10:48.860 --> 00:10:49.320
in, right?

00:10:49.500 --> 00:10:49.800
Yeah.

00:10:49.800 --> 00:10:49.840
Yeah.

00:10:49.840 --> 00:10:53.520
It was, it was, it was an interesting, I mean, it's, you know, in a lot of ways it's kind

00:10:53.520 --> 00:10:53.940
of crazy.

00:10:53.940 --> 00:11:01.360
And the thing about Go, the Go runtime that Grumpy is based on is that it is kind of designed

00:11:01.360 --> 00:11:06.020
for very similar use cases to what we are interested in.

00:11:06.360 --> 00:11:14.480
So Go tends to be, tends to be used for writing highly concurrent server applications with,

00:11:14.480 --> 00:11:20.320
you know, a lot of like sort of message passing and things within the, within the application

00:11:20.320 --> 00:11:21.480
between threads.

00:11:21.480 --> 00:11:25.020
It seemed like kind of a good fit.

00:11:25.020 --> 00:11:30.800
And once I started to flesh things out and to build out some of the core functionality,

00:11:30.800 --> 00:11:35.700
some of the pieces started to fall into place and it started to look actually really compelling.

00:11:35.700 --> 00:11:37.780
And you're like, Hey, we could actually do this.

00:11:37.780 --> 00:11:39.100
We should stop for just a second.

00:11:39.100 --> 00:11:45.980
I don't think we've explicitly said your project is called Grumpy, which is a replacement for

00:11:45.980 --> 00:11:51.920
the CPython implementation with a entirely different Go implementation, right?

00:11:51.920 --> 00:11:52.680
Yeah, that's right.

00:11:52.680 --> 00:11:52.920
Yeah.

00:11:52.920 --> 00:11:53.200
Yeah.

00:11:53.200 --> 00:11:54.380
So, so very interesting.

00:11:54.380 --> 00:12:00.420
I think, you know, Go, obviously it makes sense for Google to be the ones experimenting

00:12:00.420 --> 00:12:01.240
with Go, right?

00:12:01.240 --> 00:12:03.120
Go comes from Google, doesn't it?

00:12:03.120 --> 00:12:03.540
It does.

00:12:03.540 --> 00:12:03.780
Yep.

00:12:03.780 --> 00:12:11.660
It was developed, I think, originally by, well, Rob Pike and I'm going to mix it up.

00:12:11.660 --> 00:12:15.740
It's either Ken Thompson or no, it's, yeah, it's Ken Thompson, I believe.

00:12:15.740 --> 00:12:16.660
Yeah.

00:12:16.660 --> 00:12:23.860
It was, it was developed for, I guess they had observed that I get similar to, you know, the,

00:12:23.860 --> 00:12:29.880
what the observations that we made about running Python programs for Python server programs.

00:12:29.920 --> 00:12:36.060
They had made sort of more general observations about writing server applications and how languages

00:12:36.060 --> 00:12:40.200
that existed didn't, didn't quite fit what our use cases.

00:12:40.200 --> 00:12:40.480
Yeah.

00:12:40.480 --> 00:12:45.400
Go is really quite, it's one of the newest languages out there that I would consider a mainstream

00:12:45.400 --> 00:12:46.040
language.

00:12:46.580 --> 00:12:51.780
It's not as mainstream as C, but it's definitely getting there and came out in 2012 in version

00:12:51.780 --> 00:12:52.840
one sort of officially.

00:12:52.840 --> 00:13:01.880
So it's born within this world of multi-core microservices, distributed cloud computing stuff,

00:13:01.880 --> 00:13:02.160
right?

00:13:02.160 --> 00:13:03.140
Yeah.

00:13:03.140 --> 00:13:03.600
Yeah.

00:13:04.140 --> 00:13:04.540
Okay.

00:13:04.540 --> 00:13:08.260
So let's dig into the, what is grumpy?

00:13:08.260 --> 00:13:09.200
Let's dig in a little bit.

00:13:09.200 --> 00:13:13.220
Like how do I take, so I can take my Python code.

00:13:13.220 --> 00:13:20.240
I can write some, presumably some web app or something in a web service, and then I can run

00:13:20.240 --> 00:13:20.920
that on grumpy.

00:13:20.920 --> 00:13:22.580
Like what, what does grumpy do?

00:13:22.580 --> 00:13:24.760
How does it take my Python code and run it?

00:13:24.760 --> 00:13:29.200
So grumpy is, takes a little bit of a different tack than CPython.

00:13:29.200 --> 00:13:36.420
It's actually a trans compiler and a runtime, whereas you can kind of think of CPython as

00:13:36.420 --> 00:13:40.560
a, it's like a virtual machine bytecode interpreter and runtime.

00:13:40.560 --> 00:13:48.360
And in that sense, it's kind of like a combination of Cython and, you know, a bundling of Cython and

00:13:48.360 --> 00:13:50.600
CPython, except that it's all in Go.

00:13:50.600 --> 00:13:50.940
Right.

00:13:51.240 --> 00:13:58.320
So Cython takes a flavor of Python and then compiles it to C directly.

00:13:58.320 --> 00:14:04.500
And like C, Go is a statically typed compiled language.

00:14:04.500 --> 00:14:07.800
And so it's no longer interpreted.

00:14:07.800 --> 00:14:11.300
It's not even like JIT compiled like Java or .NET.

00:14:11.300 --> 00:14:12.980
It's full on compiled, right?

00:14:12.980 --> 00:14:13.760
That's correct.

00:14:13.760 --> 00:14:14.140
Okay.

00:14:14.140 --> 00:14:18.880
So the sort of runtime side of things is actually like the correspondence is like this Python

00:14:18.880 --> 00:14:19.700
C API.

00:14:20.020 --> 00:14:22.260
There's actually a Go grumpy API.

00:14:22.260 --> 00:14:31.580
And so what it's compiling is code that uses that API to mutate objects, to pull out a state

00:14:31.580 --> 00:14:32.860
and those sorts of things.

00:14:32.860 --> 00:14:40.960
And so whereas CPython or vanilla CPython uses a bytecode interpreter to actually drive those

00:14:40.960 --> 00:14:49.060
API calls, the Grumpy and Cython are actually generating code that drives those API calls.

00:14:49.060 --> 00:14:49.380
Okay.

00:14:49.380 --> 00:14:50.240
Yeah.

00:14:50.240 --> 00:14:51.040
Very, very cool.

00:14:51.040 --> 00:14:56.580
Now in your GitHub repo or the blog post, I don't remember where I got this, but you said

00:14:56.580 --> 00:15:00.900
it's intended to be a near drop-in replacement for CPython 2.7.

00:15:00.900 --> 00:15:02.360
How's that going?

00:15:02.360 --> 00:15:04.200
How far are you towards that goal?

00:15:04.200 --> 00:15:07.080
That's a pretty big set of APIs to cover.

00:15:07.300 --> 00:15:07.480
Yeah.

00:15:07.480 --> 00:15:10.960
I'm learning every day like how big Python is.

00:15:10.960 --> 00:15:14.660
Nobody told me about this weird case I'm going to have to support.

00:15:14.660 --> 00:15:15.720
Oh yeah, totally.

00:15:15.720 --> 00:15:16.560
Yeah.

00:15:16.560 --> 00:15:22.860
I mean, I've been the amount of sort of spelunking I've done in CPython internals is I did not

00:15:22.860 --> 00:15:23.800
expect all that.

00:15:24.360 --> 00:15:27.500
But yeah, so it's going pretty well.

00:15:27.500 --> 00:15:29.600
The core functionality is there.

00:15:29.600 --> 00:15:35.040
So like the basic semantics of the language in terms of attribute access and how types work

00:15:35.040 --> 00:15:42.160
and how method dispatch works, all of that functions basically fine.

00:15:42.160 --> 00:15:43.540
The basic types are all there.

00:15:43.700 --> 00:15:47.980
So lists and dictionaries and things all kind of work.

00:15:47.980 --> 00:15:53.080
Do those mostly map directly to the underlying Go structures?

00:15:53.080 --> 00:15:58.140
Like does a list in Python map to a slice in Go and things like that?

00:15:58.140 --> 00:16:00.820
Or do you have to do more complicated things to map it?

00:16:00.820 --> 00:16:01.840
It's more complicated.

00:16:01.840 --> 00:16:06.120
And the reason is that Python is so dynamic, right?

00:16:06.140 --> 00:16:10.280
Like method dispatch is so dynamic and attribute access.

00:16:10.280 --> 00:16:12.800
You can put attributes on just about anything.

00:16:12.800 --> 00:16:20.280
You know, if it was just this native Go types, then you wouldn't be able to put an attribute

00:16:20.280 --> 00:16:23.200
on a list or on a slice, right?

00:16:23.200 --> 00:16:23.700
Right.

00:16:23.700 --> 00:16:29.980
So it's actually, there's sort of wrapper types, basically structures that actually map very closely

00:16:29.980 --> 00:16:32.700
to CPython's object structures.

00:16:32.700 --> 00:16:33.700
Okay.

00:16:33.900 --> 00:16:38.740
Yeah, I can see that because you're working with a non-dynamic language and yet it has

00:16:38.740 --> 00:16:40.880
to support dynamic capabilities.

00:16:40.880 --> 00:16:43.980
So you got to somehow put a shim in there for that, right?

00:16:43.980 --> 00:16:44.680
That's right.

00:16:44.680 --> 00:16:45.020
Okay.

00:16:45.020 --> 00:16:50.700
I guess the biggest kind of gaps in terms of supporting or being a drop-in replacement are

00:16:50.700 --> 00:16:53.320
the standard library still needs a lot of work.

00:16:53.320 --> 00:17:00.880
So CPython has a lot of its standard library is actually written as C extension modules, which

00:17:00.880 --> 00:17:02.580
Grumpy does not support.

00:17:02.680 --> 00:17:06.720
So that's one area of significant divergence between the two words.

00:17:06.720 --> 00:17:08.440
And we could talk about that more.

00:17:08.440 --> 00:17:13.940
That's turned out to be sort of a big kind of beast to slay.

00:17:13.940 --> 00:17:20.240
The nice thing is that with, you know, all those other Python runtimes out there, there's

00:17:20.240 --> 00:17:24.700
actually, you know, you can find pure Python versions of most things.

00:17:24.860 --> 00:17:30.540
So like PyPy, for example, implements a number of libraries that are in Python that aren't implemented

00:17:30.540 --> 00:17:31.740
in CPython.

00:17:31.740 --> 00:17:32.100
Right.

00:17:32.100 --> 00:17:39.140
So you could say, start this transition or this backfilling of APIs by just moving to

00:17:39.140 --> 00:17:45.340
pure Python implementations that then get sent through Grumpy that actually get compiled

00:17:45.340 --> 00:17:46.600
or run on Go, right?

00:17:46.960 --> 00:17:47.160
Yep.

00:17:47.160 --> 00:17:48.020
That's exactly right.

00:17:48.020 --> 00:17:51.200
And maybe do some profiling and say, well, you know, people use lists a lot.

00:17:51.200 --> 00:17:55.120
Let's write that directly in Go or something like this, right?

00:17:55.120 --> 00:17:56.160
You can optimize later.

00:17:56.160 --> 00:17:56.700
Exactly.

00:17:56.700 --> 00:17:57.140
Yep.

00:17:57.180 --> 00:17:57.360
Okay.

00:17:57.360 --> 00:17:57.620
Yeah.

00:17:57.620 --> 00:18:00.440
I suspect that there's a long tail of like stuff.

00:18:00.440 --> 00:18:03.380
This doesn't really need to be optimized that last 5%.

00:18:03.380 --> 00:18:06.300
Whereas these are the few things that we really should focus on, right?

00:18:06.300 --> 00:18:06.580
Yeah.

00:18:06.580 --> 00:18:13.100
So right now, you know, I'm kind of focused on getting support for the whole, like I want

00:18:13.100 --> 00:18:17.860
to be able to run some common libraries that are written in Python.

00:18:17.860 --> 00:18:22.860
Some, I want some program, Python programs that are out there, like open source programs to

00:18:22.860 --> 00:18:24.740
be able to just use Grumpy.

00:18:24.860 --> 00:18:30.120
So like just getting it to the point where everything runs is the first step and then

00:18:30.120 --> 00:18:30.880
you make it fast.

00:18:30.880 --> 00:18:31.280
Okay.

00:18:31.280 --> 00:18:31.960
Yeah, of course.

00:18:31.960 --> 00:18:35.680
Making it work and then making it fast seems like the right order to me as well.

00:18:35.680 --> 00:18:40.520
So you said in your blog post that there's going to be some things that Grumpy will never

00:18:40.520 --> 00:18:44.820
support and then there's things that it doesn't support yet, but you're working towards.

00:18:44.820 --> 00:18:45.300
Yeah.

00:18:45.300 --> 00:18:50.800
So one of the things I mentioned already is the C extension support.

00:18:51.680 --> 00:18:58.700
The API for CPython is a bit different than the API for Grumpy because it's, well, for one

00:18:58.700 --> 00:19:02.960
thing it's a different language, but also the data structures are a little bit different.

00:19:02.960 --> 00:19:05.700
The function return values and things are a little bit different.

00:19:05.700 --> 00:19:14.680
And so there wasn't a good mapping between those APIs and it would be too constraining for,

00:19:14.940 --> 00:19:20.200
you know, to try to make Grumpy map perfectly to the C API.

00:19:20.200 --> 00:19:20.760
Sure.

00:19:20.760 --> 00:19:25.020
Have you looked at the CFFI stuff that PyPy was using?

00:19:25.020 --> 00:19:25.520
Right.

00:19:25.520 --> 00:19:29.480
So that's, I have not looked very closely at that.

00:19:29.480 --> 00:19:33.660
That is something that we've looked at internally for other reasons as well.

00:19:33.920 --> 00:19:38.620
But that is an interesting way to approach the problem.

00:19:38.620 --> 00:19:45.540
And, and potentially, you know, there are ways to bridge the two APIs that C and CFFI may

00:19:45.540 --> 00:19:46.200
be one of those.

00:19:46.200 --> 00:19:46.560
Yeah.

00:19:46.560 --> 00:19:46.840
Okay.

00:19:46.840 --> 00:19:51.280
Does go must have a C C integration option somewhere, right?

00:19:51.280 --> 00:19:51.840
It does.

00:19:51.840 --> 00:19:52.000
Yeah.

00:19:52.000 --> 00:19:52.260
Yeah.

00:19:52.260 --> 00:19:52.480
Okay.

00:19:52.480 --> 00:19:55.940
And the other thing you said is not going to support is things like eval.

00:19:55.940 --> 00:20:03.680
And again, this is like, it is possible to implement something that's a little bit hokey to support

00:20:03.680 --> 00:20:04.840
eval or exec.

00:20:04.840 --> 00:20:06.100
Shell out and compile.

00:20:06.100 --> 00:20:07.320
Oh yeah, exactly.

00:20:07.320 --> 00:20:11.740
I mean, like that's, well, I mean, it's funny you think about it and like, that's, that's actually

00:20:11.740 --> 00:20:13.680
what Python is doing, right?

00:20:13.680 --> 00:20:18.100
It's like, except that it's a bytecode compiler and then it's executing in a VM.

00:20:18.360 --> 00:20:26.080
If you instead are actually doing a, you know, an actual static compilation and then executing

00:20:26.080 --> 00:20:26.580
that.

00:20:26.580 --> 00:20:32.300
It's not conceptually that much different, except that the tool chain that you have to use to

00:20:32.300 --> 00:20:33.860
do the compilation and stuff is much heavier.

00:20:33.860 --> 00:20:38.060
So it's going to be slower and it just, it kind of doesn't make a lot of sense.

00:20:38.060 --> 00:20:43.660
I think I could see maybe supporting it for, you know, debugging use cases and things like

00:20:43.660 --> 00:20:44.000
that.

00:20:44.140 --> 00:20:50.500
I don't think I kind of want to avoid having to worry too much about like, you know,

00:20:50.500 --> 00:20:52.320
making that performant or whatever.

00:20:52.320 --> 00:20:52.960
Yeah, sure.

00:20:52.960 --> 00:20:56.060
I, I, for one would, don't think I would miss it.

00:20:56.060 --> 00:20:56.820
I think it's fine.

00:20:56.820 --> 00:20:57.240
Yeah.

00:20:57.240 --> 00:21:04.480
The other thing about exec and eval is there's very few cases I've ever come across in all

00:21:04.480 --> 00:21:07.620
my years of programming Python where exec or eval was a good idea.

00:21:08.380 --> 00:21:14.220
So actually like, I kind of think that it's an unnecessary aspect of that language.

00:21:14.220 --> 00:21:14.700
Yeah.

00:21:14.700 --> 00:21:15.300
That's interesting.

00:21:15.300 --> 00:21:20.300
And you know, it is kind of keeping with go in the sense that go is very strict about

00:21:20.300 --> 00:21:23.680
conventions and some of the best practices that it believes.

00:21:23.680 --> 00:21:29.000
Like for example, if you have an import of a package and you're not using that package,

00:21:29.000 --> 00:21:30.420
that's a compilation error, right?

00:21:30.420 --> 00:21:31.260
Things like that.

00:21:31.260 --> 00:21:31.680
Right.

00:21:31.680 --> 00:21:32.160
Absolutely.

00:21:32.160 --> 00:21:32.580
Yep.

00:21:32.580 --> 00:21:32.820
Yeah.

00:21:32.820 --> 00:21:35.560
So eval skipping eval seems like that's all right.

00:21:35.560 --> 00:21:51.940
This portion of talk Python to me is brought to you by hired hired is the platform for

00:21:51.940 --> 00:21:56.560
top Python developer jobs, create your profile and instantly get access to 3,500 companies

00:21:56.560 --> 00:21:58.120
who will work to compete with you.

00:21:58.120 --> 00:22:02.380
Take it from one of hired users who recently got a job and said, I had my first offer on

00:22:02.380 --> 00:22:06.280
Thursday after going live on Monday and I ended up getting eight offers in total.

00:22:06.280 --> 00:22:09.740
I've worked with recruiters in the past, but they've always been pretty hit and miss.

00:22:09.740 --> 00:22:12.580
I tried LinkedIn, but I found hired to be the best.

00:22:12.580 --> 00:22:14.640
I really liked knowing the salary upfront.

00:22:14.640 --> 00:22:17.040
Privacy was also a huge seller for me.

00:22:17.040 --> 00:22:18.260
Sounds awesome.

00:22:18.260 --> 00:22:18.720
Doesn't it?

00:22:18.720 --> 00:22:20.740
Well, wait until you hear about the signing bonus.

00:22:20.740 --> 00:22:24.180
Everyone who accepts the job from hired gets a thousand dollars signing bonus.

00:22:24.180 --> 00:22:26.820
And as talk Python listeners, it gets way sweeter.

00:22:27.140 --> 00:22:31.220
Use the link hired.com slash talk Python to me and hired will double the signing bonus

00:22:31.220 --> 00:22:32.060
to $2,000.

00:22:32.060 --> 00:22:33.840
Opportunities knocking.

00:22:33.840 --> 00:22:37.600
Visit hired.com slash talk Python to me and answer the door.

00:22:37.600 --> 00:22:49.120
Then you said there's a set of things that you're going to support, but it doesn't yet.

00:22:49.120 --> 00:22:50.760
What are those?

00:22:50.760 --> 00:22:55.800
We talked a little bit about some of this stuff, but like the standard library is not there yet.

00:22:56.080 --> 00:23:00.460
There's a subset of the standard libraries is available currently.

00:23:00.460 --> 00:23:04.440
Can you give us like a percentage of what, how far you are down that path?

00:23:04.440 --> 00:23:09.320
I mean, everyone listening, this, this whole project has been like, I don't get up for three

00:23:09.320 --> 00:23:09.800
or four weeks.

00:23:09.800 --> 00:23:12.460
So it's not like you should have implemented at all.

00:23:12.460 --> 00:23:14.200
It's just curious, like how far you've gotten.

00:23:14.200 --> 00:23:16.120
It's really hard to put a percentage on it.

00:23:16.120 --> 00:23:19.540
I guess, I mean, I probably could like, you know, compare lines of code or something, but

00:23:19.540 --> 00:23:25.120
I think that what's going to happen is you're going to get sort of a core set of libraries

00:23:25.120 --> 00:23:29.060
that run all the other libraries and everything will just kind of fall into place.

00:23:29.500 --> 00:23:33.420
So I think it's, it's sort of more important to count those core libraries.

00:23:33.420 --> 00:23:38.660
And you know, that's, that's things like types and collections and operator and all those

00:23:38.660 --> 00:23:38.980
things.

00:23:38.980 --> 00:23:42.300
And some of those are already there.

00:23:42.300 --> 00:23:46.640
I mean, I feel like, yeah, it's hard to put a number on it.

00:23:46.640 --> 00:23:47.140
Yeah, sure.

00:23:47.140 --> 00:23:52.680
Maybe it's one of those things where it's, it seems like you're not very far and then all

00:23:52.680 --> 00:23:55.220
of a sudden it kind of unlocks and things go really quick.

00:23:55.420 --> 00:23:56.280
That's the dream.

00:23:56.280 --> 00:24:02.320
That's a good way to like, it's a, it's a optimistic view of the future.

00:24:02.320 --> 00:24:03.040
That's right.

00:24:03.040 --> 00:24:09.380
If you're going to clone the repo off GitHub and try things out, like you may be disappointed

00:24:09.380 --> 00:24:12.060
that, that your favorite libraries aren't there.

00:24:12.480 --> 00:24:18.200
There's a good chance that if you have a program that's, that's at all, you know, complex that

00:24:18.200 --> 00:24:20.680
there are some libraries that are missing for you.

00:24:20.680 --> 00:24:23.800
I'd say, I don't know, maybe 20% or something like that.

00:24:23.800 --> 00:24:24.260
Okay.

00:24:24.260 --> 00:24:25.220
Well, that's good.

00:24:25.220 --> 00:24:27.580
And you said you also want to support all the built-ins.

00:24:27.580 --> 00:24:28.240
That's right.

00:24:28.240 --> 00:24:28.720
Yeah.

00:24:28.880 --> 00:24:30.440
That's obviously a good idea.

00:24:30.440 --> 00:24:30.900
Yeah.

00:24:30.900 --> 00:24:32.440
Those are important.

00:24:32.440 --> 00:24:37.960
And again, you know, there's a bunch of stuff that just hasn't a bunch of like functions

00:24:37.960 --> 00:24:45.340
like map and, and reduce and things like that, that I haven't got around to, haven't needed

00:24:45.340 --> 00:24:50.440
to support them yet, but they're actually pretty straightforward to implement by and large.

00:24:50.620 --> 00:24:54.440
So, so I think we're, we're pretty far along on, on that stuff.

00:24:54.440 --> 00:25:01.620
So how much of your focus on Grumpy is going to be to make this a project that you guys could

00:25:01.620 --> 00:25:09.280
use for your specific use cases at Google and then make that a skeleton or base and people can

00:25:09.280 --> 00:25:14.020
come along and add other features and contribute to the open source project to make it more broad

00:25:14.020 --> 00:25:19.720
versus how much are you trying to make this like we're trying to re entirely replace CPython.

00:25:19.720 --> 00:25:24.320
So I think that we, I want to see, I like, okay.

00:25:24.320 --> 00:25:25.420
So, so I put it this way.

00:25:25.420 --> 00:25:33.020
I'm interested in, you know, solving some of these concurrent use cases that don't have a great answer

00:25:33.020 --> 00:25:34.020
in CPython.

00:25:34.020 --> 00:25:35.880
That's the primary focus.

00:25:35.880 --> 00:25:41.880
But I, again, it might be my optimism is showing again, but like, I feel like once you kind of have

00:25:41.880 --> 00:25:48.920
some of those use cases locked down, now people start to use it for, for things you didn't expect

00:25:48.920 --> 00:25:49.500
right away.

00:25:49.500 --> 00:25:57.000
I know that like scientific computing is an area where Python has a really well-established

00:25:57.000 --> 00:26:01.640
libraries and, and NumPy is, is sort of crucial to some of this stuff.

00:26:01.640 --> 00:26:05.140
And that's got, that's C, you know, involves C extensions.

00:26:05.680 --> 00:26:11.640
And I think in the near term, I don't see Grumpy being useful for numerical analysis.

00:26:11.640 --> 00:26:17.740
And, you know, that's kind of compounded by Go doesn't have too many sort of inroads in that

00:26:17.740 --> 00:26:19.160
direction either.

00:26:19.400 --> 00:26:25.140
So, but on the other hand, you know, some of the static, the advantages of like being

00:26:25.140 --> 00:26:33.240
statically compiled and, and type inferencing and compiling down to native operations, that is

00:26:33.240 --> 00:26:37.100
potentially useful for, you know, scientific computing and those sorts of things.

00:26:37.100 --> 00:26:42.720
So, so I kind of see, you know, I want to focus on our, our immediate use cases, but I have this

00:26:42.720 --> 00:26:44.100
kind of idea that there's.

00:26:44.100 --> 00:26:48.800
You know, more opportunities out there once that's, once things are kind of working.

00:26:48.800 --> 00:26:49.460
Okay.

00:26:49.460 --> 00:26:49.700
Yeah.

00:26:49.700 --> 00:26:49.740
Yeah.

00:26:49.740 --> 00:26:51.680
That, that seems like a good roadmap to me.

00:26:51.680 --> 00:26:52.680
It makes a lot of sense.

00:26:52.680 --> 00:26:59.640
So let's talk about the execution engine, which effectively, effectively is the execution engine

00:26:59.640 --> 00:27:01.420
of Go versus CPython.

00:27:01.420 --> 00:27:06.560
So CPython, the Python code gets converted to bytecode.

00:27:06.560 --> 00:27:13.340
Those bytecode instructions are sent to like a super large force for loop switch sort of thing.

00:27:13.340 --> 00:27:15.800
And those are interpreted and run.

00:27:15.800 --> 00:27:17.560
How does Go work?

00:27:17.960 --> 00:27:25.420
Go has a runtime, which is to say that there's code that is running, that's managing things

00:27:25.420 --> 00:27:32.020
like Go routines, which are the equivalent of threads and, and Go programs and garbage collection

00:27:32.020 --> 00:27:33.200
and things like that.

00:27:33.200 --> 00:27:39.780
But much of what is actually happening throughout a Go program is just, is actually, you know,

00:27:39.780 --> 00:27:41.320
low level machine instruction.

00:27:41.320 --> 00:27:47.520
So the Go program, much like a C program is compiled down to a machine code and actually

00:27:47.520 --> 00:27:48.440
executed natively.

00:27:48.440 --> 00:27:48.840
Right.

00:27:48.840 --> 00:27:49.940
That makes sense.

00:27:49.940 --> 00:27:55.420
So you say Go has a garbage collection, which is, is awesome.

00:27:55.420 --> 00:27:57.080
Do you know what kind it is?

00:27:57.080 --> 00:28:02.880
Is it reference counting or is it like mark and sweep or what, what kind of garbage is it

00:28:02.880 --> 00:28:03.480
deterministic?

00:28:03.480 --> 00:28:04.980
How's the garbage collector work and go?

00:28:04.980 --> 00:28:07.280
This is not my area of expertise.

00:28:07.280 --> 00:28:07.780
Nor mine.

00:28:07.980 --> 00:28:10.340
But it is not reference counted.

00:28:10.340 --> 00:28:15.380
So I believe that it is a, and actually this has changed significantly.

00:28:15.380 --> 00:28:22.240
I believe in 1.7, they significantly re retro or sort of retrofitted the garbage collector.

00:28:22.900 --> 00:28:31.440
It mostly just around the way that garbage for particular Go routines is managed garbage that

00:28:31.440 --> 00:28:33.700
is sort of local to particular Go routines.

00:28:33.700 --> 00:28:40.280
And, but it's, it's sort of a traditional, otherwise it's pretty, it's kind of a traditional garbage

00:28:40.280 --> 00:28:45.400
collector that much similar to what Java has.

00:28:46.080 --> 00:28:47.920
But it's actually much simpler.

00:28:47.920 --> 00:28:52.900
Java has a, a number of different algorithms it supports and a lot of tuning parameters.

00:28:52.900 --> 00:28:59.880
Go's garbage collection is fairly, is much simpler and is targeted for the use case of,

00:28:59.880 --> 00:29:03.620
you know, handling requests in a server application and those sorts of things.

00:29:03.620 --> 00:29:04.000
Yeah.

00:29:04.000 --> 00:29:04.520
It makes sense.

00:29:04.600 --> 00:29:07.760
I suspect they highly parallelize that thinking of Go as well.

00:29:07.760 --> 00:29:13.720
One thing you said that's nice about executing ultimately on Go is you said the deployment story

00:29:13.720 --> 00:29:15.080
is a little bit simpler.

00:29:15.080 --> 00:29:23.620
You know, Python, you do, when you deploy a Python program, you are actually including your like

00:29:23.620 --> 00:29:27.460
PY files or at least your PYC files in the deployment.

00:29:28.360 --> 00:29:33.740
And so you have to have some way to sort of package them together and ship them off to

00:29:33.740 --> 00:29:36.040
production or wherever you're running your program.

00:29:36.040 --> 00:29:36.420
Right.

00:29:36.420 --> 00:29:39.880
And beyond that, also the dependencies and the runtime, right?

00:29:39.880 --> 00:29:41.780
So you got to have all of those things.

00:29:41.780 --> 00:29:42.540
That's right.

00:29:42.540 --> 00:29:44.020
Which can make it really tricky.

00:29:44.020 --> 00:29:48.820
And there's things like PY2 AMP, PY2 XE, CX freeze, the Bware project.

00:29:48.820 --> 00:29:53.720
There's a lot of project trying to make that something you can ship around, but it's not simple.

00:29:53.720 --> 00:29:54.680
Yeah, that's right.

00:29:54.800 --> 00:29:59.560
And, you know, so I'm sure people who have run Python in production have run into, you

00:29:59.560 --> 00:30:04.700
know, version mismatches, things like that, using the system Python version, which was,

00:30:04.700 --> 00:30:07.800
you know, different than the one they were developing on and so on.

00:30:07.800 --> 00:30:13.660
The nice thing about statically compiled programs in general is that you, you produce a binary

00:30:13.660 --> 00:30:17.400
and you just, you can put that just about anywhere and it'll run.

00:30:18.000 --> 00:30:21.020
And that's very true for Go programs.

00:30:21.020 --> 00:30:24.720
There's few dependencies in most cases.

00:30:24.720 --> 00:30:30.700
Most of the runtime is actually compiled or is actually linked into the executable.

00:30:30.700 --> 00:30:31.600
Yeah, that's really cool.

00:30:31.600 --> 00:30:35.620
What's the size of like a Hello World compiled output?

00:30:35.620 --> 00:30:35.980
Do you know?

00:30:35.980 --> 00:30:38.460
I have not looked at the size myself.

00:30:38.700 --> 00:30:44.060
I think I saw some comment somewhere that said it was something like three megabytes.

00:30:44.060 --> 00:30:49.320
So it's, it's pretty substantial, but you know, that, that includes a lot of overhead for

00:30:49.320 --> 00:30:54.420
the runtime that, that wouldn't increase significantly if your program grew.

00:30:54.420 --> 00:30:54.780
Right.

00:30:54.780 --> 00:30:55.240
Absolutely.

00:30:55.240 --> 00:30:58.680
Like, you know, the next 10,000 lines add 10 K or something.

00:30:58.680 --> 00:30:58.980
Right.

00:30:58.980 --> 00:30:59.440
Exactly.

00:30:59.440 --> 00:30:59.700
Yeah.

00:30:59.940 --> 00:31:04.180
I think three megs is totally fine to get a good deployment story, stability.

00:31:04.180 --> 00:31:06.640
You run what you shipped, all those things.

00:31:06.640 --> 00:31:11.380
Like if this was 1994, three megs would be a problem, but it's not today, right?

00:31:11.380 --> 00:31:12.700
Yeah, that's right.

00:31:12.700 --> 00:31:13.220
Nice.

00:31:13.220 --> 00:31:20.400
So what sort of optimizations do you think are possible if you run Python on Go, if rather

00:31:20.400 --> 00:31:22.840
than as an interpreted system?

00:31:22.840 --> 00:31:26.660
This is not an area I've dug into significantly yet.

00:31:27.160 --> 00:31:33.560
My thinking is that if you can determine that a particular, for example, a particular integer

00:31:33.560 --> 00:31:40.560
counter in a function is only ever an integer type and it only, you know, uses integer operations

00:31:40.560 --> 00:31:46.000
like increment or, or whatever, then there's no need to go through the whole Python method

00:31:46.000 --> 00:31:50.080
dispatch and creating new integer objects.

00:31:50.080 --> 00:31:56.540
Every time you increment that counter, you can actually just use a native integer and increment

00:31:56.540 --> 00:31:57.960
using native operations.

00:31:57.960 --> 00:32:02.500
So that's a, that's a really simple example, but not, not uncommon.

00:32:02.500 --> 00:32:08.900
I think once you kind of broaden that to a whole program optimization, that's when things

00:32:08.900 --> 00:32:12.520
start to get interesting because then you can think about like, well, if you know that a

00:32:12.520 --> 00:32:18.860
function is only ever called with particular parameters or parameters of a particular type,

00:32:18.940 --> 00:32:25.060
then you can make some assumptions and again, use native, maybe use native data types.

00:32:25.060 --> 00:32:25.420
Sure.

00:32:25.420 --> 00:32:27.480
What about type annotations?

00:32:27.480 --> 00:32:35.220
And I know that's more a Python three thing, but would you be able to, or interested in having some flavor that

00:32:35.220 --> 00:32:39.400
takes type annotations and then uses that for certain types of optimizations?

00:32:39.400 --> 00:32:40.120
Yeah.

00:32:40.120 --> 00:32:46.160
I thought about this and, and I'm a little ambivalent because, you know, type annotations, the way that

00:32:46.160 --> 00:32:52.540
they are sort of used today, they're not intended to actually, you know, raise or anything if they're

00:32:52.540 --> 00:32:53.420
not respected.

00:32:53.920 --> 00:33:01.280
it's mostly for analysis before you ship your program to like, you know, make the linting, the

00:33:01.280 --> 00:33:02.920
linters job easier and things like that.

00:33:02.920 --> 00:33:03.420
Right.

00:33:03.420 --> 00:33:09.720
And so, when, once it actually in CPython, once your type annotations, once you're actually

00:33:09.720 --> 00:33:12.600
running your program, the type annotations basically have no effect.

00:33:12.600 --> 00:33:21.500
And so I'm a little hesitant to say that grumpy should use these in a more, in sort of a more

00:33:21.500 --> 00:33:27.760
strict way, because I think that might have affect programs compatibility and stuff like

00:33:27.760 --> 00:33:27.980
that.

00:33:27.980 --> 00:33:28.220
Yeah.

00:33:28.220 --> 00:33:29.260
It will absolutely do that.

00:33:29.260 --> 00:33:29.620
Wouldn't it?

00:33:29.620 --> 00:33:29.840
Yeah.

00:33:29.840 --> 00:33:31.580
There's some real advantages there.

00:33:31.580 --> 00:33:36.000
If you, if you do make them strict, then you say that a type, an argument is an integer,

00:33:36.000 --> 00:33:40.660
then yeah, it makes the optimizer's job way easier because it can, you know, it doesn't have

00:33:40.660 --> 00:33:43.480
to do any inferencing to determine that relationship.

00:33:43.480 --> 00:33:49.440
Obviously it would break the sort of contract with type annotations that these are just for editors

00:33:49.440 --> 00:33:53.720
and linters and to help you, but not actually meant to affect the runtime.

00:33:53.720 --> 00:33:54.500
That's right.

00:33:54.500 --> 00:33:59.800
On the other hand, if, if you could make some part of code that's like really critical go,

00:33:59.800 --> 00:34:05.320
you know, 10 or a hundred times faster by putting a type annotation that's strict, you know,

00:34:05.320 --> 00:34:06.960
you might be willing to make that trade off.

00:34:06.960 --> 00:34:10.600
So I have no, I don't know which way would be the right way to go either, but it's interesting

00:34:10.600 --> 00:34:11.180
to think about.

00:34:11.180 --> 00:34:11.500
Yeah.

00:34:11.780 --> 00:34:15.700
I'm very curious how that sort of evolves.

00:34:15.700 --> 00:34:16.040
Yeah.

00:34:16.040 --> 00:34:16.460
Yeah.

00:34:16.460 --> 00:34:16.640
Yeah.

00:34:16.640 --> 00:34:18.060
I'm going to keep an eye on it.

00:34:18.060 --> 00:34:18.380
That's cool.

00:34:18.380 --> 00:34:20.220
So let's talk about when you launched.

00:34:20.220 --> 00:34:22.260
So this should be pretty fresh in your mind, right?

00:34:22.260 --> 00:34:23.420
Yeah.

00:34:23.420 --> 00:34:25.000
It's not a very old project.

00:34:25.000 --> 00:34:27.160
It's about a week, week and a day.

00:34:27.160 --> 00:34:27.480
Yeah.

00:34:28.060 --> 00:34:28.380
Yeah.

00:34:28.380 --> 00:34:37.700
So we, well, I guess we migrated the code to GitHub in mid-December and I spent some time

00:34:37.700 --> 00:34:42.560
over the next month kind of cleaning it or the next few weeks cleaning up the code and adding

00:34:42.560 --> 00:34:50.920
some functionality for the build system that we were not able to use, obviously the internal

00:34:50.920 --> 00:34:53.440
Google build system in the open source project.

00:34:53.540 --> 00:34:59.260
So I had to build some of that out and then I guess January 4th.

00:34:59.260 --> 00:34:59.780
Yeah.

00:34:59.780 --> 00:35:01.080
I guess it was the 4th.

00:35:01.080 --> 00:35:03.900
That's eight days ago just for the day of the recording.

00:35:03.900 --> 00:35:04.100
Yeah.

00:35:04.100 --> 00:35:04.580
Yeah.

00:35:04.580 --> 00:35:05.380
We did.

00:35:05.380 --> 00:35:11.960
We, we sort of coordinated an open source blog post with, with the actual making the GitHub

00:35:11.960 --> 00:35:18.020
repo public and got a little bit of traction on hacker news and, and yeah, it was kind of

00:35:18.020 --> 00:35:21.140
astonishing how great the reception was.

00:35:21.140 --> 00:35:21.380
Yeah.

00:35:21.380 --> 00:35:22.500
It's going like crazy.

00:35:22.660 --> 00:35:27.580
Like when I took notes to, for this conversation, like four or five days ago, I had said there

00:35:27.580 --> 00:35:28.860
were 5,000 stars in GitHub.

00:35:28.860 --> 00:35:31.420
Now, maybe that was three days ago.

00:35:31.420 --> 00:35:35.880
Now there's 6,000, almost 6,317 contributors.

00:35:35.880 --> 00:35:40.400
That's, that's a pretty serious uptake for a project that's been out for eight days.

00:35:40.400 --> 00:35:40.860
Yeah.

00:35:40.860 --> 00:35:46.180
I, I think the thing that kind of blew me away most was the number of pull requests that

00:35:46.180 --> 00:35:46.800
I got.

00:35:46.800 --> 00:35:52.440
I mean, right on day one, people were digging into the code and, you know, doing like it,

00:35:52.440 --> 00:35:56.960
it, the code, there are tricky parts to the code and it's not necessarily obvious how you

00:35:56.960 --> 00:35:58.800
ought to write certain features.

00:35:59.060 --> 00:36:04.140
And people, you know, really dug in and started filling out some of this functionality that's

00:36:04.140 --> 00:36:09.260
missing and started talking about, you know, well, how are we going to support programs or

00:36:09.260 --> 00:36:15.100
libraries, Python, third party Python libraries out of the box and stuff like that.

00:36:15.100 --> 00:36:16.540
So it's been great.

00:36:16.540 --> 00:36:20.740
I've had a really good time working with some, some of these people that have been contributing.

00:36:20.740 --> 00:36:21.100
Yeah.

00:36:21.100 --> 00:36:21.400
Yeah.

00:36:21.400 --> 00:36:22.700
I would say that's really cool.

00:36:22.700 --> 00:36:28.340
You talked about the code a little bit, looking on GitHub, GitHub thinks it's 77% go

00:36:28.340 --> 00:36:31.740
code, 22% Python code and a bit of a make file.

00:36:31.740 --> 00:36:32.160
Yeah.

00:36:32.160 --> 00:36:32.780
That's about right.

00:36:32.780 --> 00:36:33.860
Yeah, that's about right.

00:36:33.860 --> 00:36:38.380
And, and a lot of that Python code is actually just tests, and benchmarks and things.

00:36:38.380 --> 00:36:41.300
So it's, it, most of it is, is go.

00:36:41.300 --> 00:36:47.360
And, and actually, I guess the standard libraries, which most of which are copied from, from

00:36:47.360 --> 00:36:51.760
other places like CPython, there's pretty substantial amount of Python, but that's not like, you know,

00:36:51.760 --> 00:36:55.960
I don't think about too much about that code since we don't have to write it or maintain it.

00:36:55.960 --> 00:36:56.520
Yeah, absolutely.

00:36:56.520 --> 00:36:59.320
So how do you ensure compatibility in this?

00:36:59.320 --> 00:37:01.760
Like, are you running the standard CPython test?

00:37:01.760 --> 00:37:03.160
That's something that we're working to.

00:37:03.160 --> 00:37:05.620
So that's sort of milestone number one.

00:37:05.700 --> 00:37:11.080
I haven't published a roadmap document yet, but getting to the point where we can run

00:37:11.080 --> 00:37:16.460
the unit test library is going to be a huge milestone because it means we can then run

00:37:16.460 --> 00:37:19.720
the unit tests that are written for CPython.

00:37:19.720 --> 00:37:21.960
That would be a huge milestone just on compatibility.

00:37:21.960 --> 00:37:22.900
Exactly.

00:37:22.900 --> 00:37:30.620
Before, we get there, we've been writing small tests to that, you know, demonstrate,

00:37:30.620 --> 00:37:32.700
um, compatibility concerns and stuff like that.

00:37:32.700 --> 00:37:36.460
And then running those in both Python and Crumpy.

00:37:36.460 --> 00:37:36.900
Okay.

00:37:36.900 --> 00:37:37.540
Yeah.

00:37:37.540 --> 00:37:37.940
Very cool.

00:37:37.940 --> 00:37:44.700
So let's talk about why you chose Go because are there three sort of officially blessed languages

00:37:44.700 --> 00:37:45.140
at Google?

00:37:45.140 --> 00:37:47.640
There's Python, there's Go and Java.

00:37:47.640 --> 00:37:48.100
Is that?

00:37:48.100 --> 00:37:48.780
And C++.

00:37:48.780 --> 00:37:49.980
Is that the story these days?

00:37:49.980 --> 00:37:50.280
Yeah.

00:37:50.280 --> 00:37:50.460
Right.

00:37:50.460 --> 00:37:50.740
Of course.

00:37:50.740 --> 00:37:51.200
And C++.

00:37:51.200 --> 00:37:51.720
So four.

00:37:51.720 --> 00:37:53.420
So why did you choose Go?

00:37:53.420 --> 00:37:55.740
Like you could have tried Jython or something, right?

00:37:55.740 --> 00:38:00.060
Jython is something that we, we've looked into.

00:38:00.960 --> 00:38:03.940
Jython is a really great mature product.

00:38:03.940 --> 00:38:11.840
it's our experience that it's better to start a project on Jython, than to migrate

00:38:11.840 --> 00:38:12.620
to Jython.

00:38:12.620 --> 00:38:18.480
There's a number of compatibility issues, not so much like the kinds of compatibility issues

00:38:18.480 --> 00:38:24.920
like, oh, on an, on CPython, this function returns, a different type or something like

00:38:24.920 --> 00:38:31.700
that more that there are certain constraints of running in the JVM that make certain programs

00:38:31.700 --> 00:38:34.960
not work very well or, or those sorts of things.

00:38:34.960 --> 00:38:37.980
So like performance issues that sort of crop up in those sorts of things.

00:38:37.980 --> 00:38:45.020
It sounds like running on the JVM was not the best concurrency server story as it might've

00:38:45.020 --> 00:38:49.780
been running on Go because Go is more focused on concurrency from the beginning and things

00:38:49.780 --> 00:38:50.240
like that.

00:38:50.240 --> 00:38:52.180
That might be more important to you guys.

00:38:52.180 --> 00:38:52.580
Yeah.

00:38:52.580 --> 00:38:53.640
I think that was part of it.

00:38:53.680 --> 00:38:59.260
I mean, like lightweight Go routines are definitely a big advantage to Go.

00:38:59.260 --> 00:39:02.940
So Java has native threads, which have large stacks.

00:39:02.940 --> 00:39:09.520
And so it has sort of a different performance characteristics for concurrent workloads.

00:39:09.660 --> 00:39:15.600
and so you have to kind of write programs, parallel programs in a slightly different way

00:39:15.600 --> 00:39:23.960
for Java, but also, for real time server applications, the JIT actually can be a liability.

00:39:23.960 --> 00:39:31.940
It becomes difficult to, you know, reproduce certain kinds of, certain kinds of issues,

00:39:31.940 --> 00:39:39.420
debug certain kinds of problems and consistent because consistency of, how requests are handled,

00:39:39.420 --> 00:39:42.160
is really important in these kinds of applications.

00:39:42.160 --> 00:39:48.180
And, and the JIT can make, you know, identical requests behave very differently depending on

00:39:48.180 --> 00:39:50.120
where in the life cycle the program is.

00:39:50.120 --> 00:39:50.420
Sure.

00:39:50.420 --> 00:39:50.780
Yeah.

00:39:50.780 --> 00:39:51.600
That makes a lot of sense.

00:39:51.600 --> 00:39:54.460
Being statically typed, you get a little more predictability.

00:39:54.460 --> 00:39:55.040
Absolutely.

00:39:55.040 --> 00:39:59.660
Well, not, sorry, not statically typed, compiled to like machine instructions rather than digits.

00:39:59.660 --> 00:39:59.960
Yeah.

00:39:59.960 --> 00:40:00.340
Yeah.

00:40:00.340 --> 00:40:00.600
Yeah.

00:40:00.600 --> 00:40:01.040
That's right.

00:40:01.040 --> 00:40:01.240
Yep.

00:40:01.240 --> 00:40:02.520
Hey everyone.

00:40:02.520 --> 00:40:06.500
Let me take just a moment and tell you about a new sponsor with a cool and timely offer.

00:40:06.900 --> 00:40:11.300
This portion of talk Python to me is brought to you by deep learning for computer vision

00:40:11.300 --> 00:40:16.560
with Python, a new book from pi image search.com launching on Kickstarter right now.

00:40:16.560 --> 00:40:21.560
Have you ever wondered how Facebook can not only detect your face in an image, but also recognize

00:40:21.560 --> 00:40:22.820
and tag you as well.

00:40:22.820 --> 00:40:24.140
It's not magic.

00:40:24.140 --> 00:40:30.060
Facebook uses specialized machine learning algorithms called deep learning in pi image search wants

00:40:30.060 --> 00:40:32.920
to pull back the curtain and show you how these algorithms work.

00:40:32.920 --> 00:40:37.220
Their new book is designed from the ground up to help you reach expert status.

00:40:37.220 --> 00:40:41.880
Even if you've never worked with machine learning or neural networks before inside deep learning

00:40:41.880 --> 00:40:46.320
for computer vision with Python, you'll find super practical walkthroughs, hands-on tutorials

00:40:46.320 --> 00:40:50.940
with lots of code and a no fluff teaching style that is guaranteed to cut through all the cruft

00:40:50.940 --> 00:40:53.580
and help you master deep learning for visual recognition.

00:40:53.580 --> 00:40:59.520
To learn more about this book and back the Kickstarter campaign, just head to pi image search.com

00:40:59.520 --> 00:41:00.560
slash Kickstarter.

00:41:01.560 --> 00:41:01.960
Yeah.

00:41:01.960 --> 00:41:03.980
So how do you run apps on, on Grumpy?

00:41:03.980 --> 00:41:09.080
Like if I have Python code and I want to make it, make it go, how do I make it go on Grumpy?

00:41:09.080 --> 00:41:14.760
This is sort of a hot topic right now in the issue tracker on GitHub because like the

00:41:14.760 --> 00:41:20.400
build system that I have and is strictly focused on, you know, getting the internal libraries working.

00:41:20.400 --> 00:41:25.860
And so it doesn't have good support for building a program that's outside that directory structure

00:41:25.860 --> 00:41:29.000
or using libraries that are in your Python path or anything like that.

00:41:29.160 --> 00:41:32.680
And so we're debating kind of how exactly it should be supported.

00:41:32.680 --> 00:41:38.580
So right now, if you want to run a program or compile a library, you have to kind of drop

00:41:38.580 --> 00:41:45.160
it into that directory structure and the make system will pick up on it and, and, try

00:41:45.160 --> 00:41:46.400
to compile it into go.

00:41:46.400 --> 00:41:53.940
But, ideally, you know, you have some kind of Python path style construct where it can find

00:41:53.940 --> 00:41:58.000
Python code and build it in a sort of standard way.

00:41:58.000 --> 00:42:00.280
That's something that we're working towards.

00:42:00.280 --> 00:42:01.640
Okay, cool.

00:42:01.640 --> 00:42:08.180
Now, if people want to contribute to Grumpy, there's like three major areas that, that make it up.

00:42:08.180 --> 00:42:11.480
You want to talk about those three areas so they maybe can use it as a roadmap?

00:42:11.700 --> 00:42:19.280
You can kind of think of it as the trans compiler, which is the tool called Grump C and that takes

00:42:19.280 --> 00:42:23.460
Python code and it actually uses it's written in Python and it uses the AST module.

00:42:23.460 --> 00:42:24.500
So it's kind of cheating.

00:42:25.380 --> 00:42:33.600
Another milestone will be when Grump C can compile Grump C and, that takes, the Python

00:42:33.600 --> 00:42:36.060
code and spits out some go code.

00:42:36.060 --> 00:42:41.680
And then you're going to, the second part is the Grumpy runtime, which is kind of the parallel

00:42:41.680 --> 00:42:42.840
of the C API.

00:42:42.840 --> 00:42:48.160
The trans compiled go code will depend on that runtime.

00:42:48.160 --> 00:42:53.660
So it imports the runtime and uses the, constructs and functions and things in the runtime.

00:42:53.660 --> 00:42:58.500
And so that's another sort of component that's written strictly in go.

00:42:58.500 --> 00:43:02.180
And that's where all the sort of data structures and things are defined.

00:43:02.180 --> 00:43:09.280
and finally there's the standard library that is a mostly written in or actually exclusively

00:43:09.280 --> 00:43:15.320
written in Python, but also has some uses some of the Grumpy native extensions to actually

00:43:15.320 --> 00:43:19.280
interface directly with go packages and, and functions and things.

00:43:19.280 --> 00:43:23.440
so those are, so there's sort of the three areas and there's a lot of work to do in,

00:43:23.440 --> 00:43:24.800
in all of those different areas.

00:43:24.800 --> 00:43:29.480
I'd say like the standard library is, is the biggest chunk of work to do at this point.

00:43:29.480 --> 00:43:34.100
Presumably you guys chose go because of the concurrency story, right?

00:43:34.100 --> 00:43:40.680
And if you have Python code running on go, you want to leverage that concurrency.

00:43:40.680 --> 00:43:42.760
Do you have to use a different API?

00:43:43.400 --> 00:43:44.820
this is Python two seven.

00:43:44.820 --> 00:43:47.040
So you don't have things like async or wait.

00:43:47.040 --> 00:43:50.880
How do I interact with the concurrency model of go?

00:43:50.880 --> 00:43:57.340
Currently, the way that go routines are made available is through the threading library.

00:43:57.340 --> 00:44:00.960
So the standard Python threading library, you create a thread and start it.

00:44:00.960 --> 00:44:09.040
And that actually starts a go routine instead of a native thread that will work pretty seamlessly with existing code.

00:44:09.040 --> 00:44:15.580
I don't foresee huge problems there in terms of like the differences between those kinds of threads.

00:44:15.780 --> 00:44:22.220
And again, like, you know, go has the concept of channels, which are sort of a message passing mechanism.

00:44:22.420 --> 00:44:31.420
And whereas in Python, you have a queue, the queue data structure, and this isn't actually implemented, but I plan to implement a queue using channels.

00:44:31.420 --> 00:44:36.200
And so you should be able to just write Python concurrent Python code like you always have.

00:44:36.200 --> 00:44:48.200
But I think to really take advantage of sort of the concurrency model, you probably, eventually I'd, I'd like to implement the async and await Python construct.

00:44:48.200 --> 00:44:50.420
I think that would be a huge win.

00:44:50.420 --> 00:44:52.880
Yeah, that would be, that would be a huge win.

00:44:52.880 --> 00:45:02.180
And it seems to me like using the threading API is much more coarse grained concurrency than go is really built for.

00:45:02.180 --> 00:45:06.120
And while it would work, it's not, not taking full advantage.

00:45:06.120 --> 00:45:20.400
The idea with go is you can start a go routine or starting a go routine is extremely lightweight and passing messages back and forth is the way to sort of share state rather than with sharing memory.

00:45:20.400 --> 00:45:21.400
Or sharing objects.

00:45:21.400 --> 00:45:34.780
So I think that programs that are written with sort of heavyweight threads in mind aren't necessarily going to be the best possible way to express that functionality.

00:45:34.960 --> 00:45:44.900
And so, you know, long-term I could see, you know, maybe, well, actually because you can access native go constructs.

00:45:44.900 --> 00:45:49.960
For example, you will be able to, in a grumpy program, use go channels directly.

00:45:50.360 --> 00:45:52.580
You know, that has upsides and downsides.

00:45:52.580 --> 00:45:55.840
It starts to diverge from the Python language and those sorts of things.

00:45:55.840 --> 00:46:00.460
Yeah, but it's not unlike, Iron Python or Jython or those things, right?

00:46:00.460 --> 00:46:05.700
Where you can reach down into the underlying JVM or CLR or something like that.

00:46:05.700 --> 00:46:06.100
That's right.

00:46:06.100 --> 00:46:06.340
Yep.

00:46:06.340 --> 00:46:06.880
Absolutely.

00:46:07.740 --> 00:46:08.020
Okay.

00:46:08.020 --> 00:46:13.700
So if you're going towards async and await, what's the story on Python three?

00:46:13.700 --> 00:46:17.260
Since I feel like the threading concurrency story is a lot better in Python three.

00:46:17.260 --> 00:46:17.720
Yeah.

00:46:17.720 --> 00:46:19.460
I'd love to support Python three.

00:46:19.460 --> 00:46:22.480
The long-term goal is definitely to support it.

00:46:22.480 --> 00:46:29.840
The reason for 2.7 is that we have a large, YouTube had a large existing Python code base and

00:46:29.840 --> 00:46:31.800
that was a 2.7.

00:46:31.800 --> 00:46:37.400
So that was the main reason for choosing 2.7 out of the gate, but certainly long-term,

00:46:37.400 --> 00:46:39.820
I'd like to see all Python three supported.

00:46:39.820 --> 00:46:40.280
Right.

00:46:40.280 --> 00:46:41.540
Oh, that'd be, that'd be fantastic.

00:46:41.540 --> 00:46:42.600
I'd like to see that as well.

00:46:42.600 --> 00:46:45.200
I mean, it certainly makes sense if you're working on the YouTube team.

00:46:45.200 --> 00:46:51.780
YouTube has a tremendously large and widely adopted deployment of Python two seven.

00:46:51.780 --> 00:46:55.760
Like you want to, you know, work where you can have the biggest impact locally, right?

00:46:55.760 --> 00:46:56.280
Absolutely.

00:46:56.280 --> 00:46:56.840
Yeah.

00:46:56.840 --> 00:47:02.400
So reading the tea leaves, does this mean that Grumpy might someday run YouTube?

00:47:02.400 --> 00:47:04.120
I want to hedge a little bit on that.

00:47:04.120 --> 00:47:10.940
I think there's a sort of a long road ahead before Grumpy's ready to handle the kinds of

00:47:10.940 --> 00:47:13.740
large applications that we run on YouTube.

00:47:13.740 --> 00:47:18.700
So I wouldn't want to speculate about the long-term outcomes there.

00:47:18.700 --> 00:47:18.880
Sure.

00:47:18.880 --> 00:47:19.280
Yeah.

00:47:19.280 --> 00:47:19.440
Yeah.

00:47:19.440 --> 00:47:19.760
Of course.

00:47:19.760 --> 00:47:23.620
You know, let me just imagine, let's imagine a world where it did.

00:47:23.620 --> 00:47:30.280
That would be, probably the first few weeks that it switched to Grumpy would be a little

00:47:30.280 --> 00:47:31.280
bit nerve wracking, right?

00:47:31.280 --> 00:47:31.680
Yeah.

00:47:31.680 --> 00:47:33.540
It would definitely.

00:47:33.540 --> 00:47:36.360
If YouTube goes down and it's your fault, that's going to be a problem.

00:47:36.360 --> 00:47:37.200
Yeah, exactly.

00:47:37.200 --> 00:47:39.240
I don't want to be that guy.

00:47:39.240 --> 00:47:40.380
Exactly.

00:47:40.380 --> 00:47:40.860
Exactly.

00:47:40.860 --> 00:47:42.520
Here's the four pages we're giving you.

00:47:42.520 --> 00:47:43.100
No, just kidding.

00:47:43.100 --> 00:47:47.460
But it would, if, if someday that, that came to be, that would be a really cool outcome of

00:47:47.460 --> 00:47:47.860
this project.

00:47:47.860 --> 00:47:48.500
Yeah, absolutely.

00:47:48.500 --> 00:47:50.080
that's, that's sort of the dream.

00:47:50.080 --> 00:47:50.440
Excellent.

00:47:50.440 --> 00:47:51.020
Okay.

00:47:51.020 --> 00:47:52.820
So maybe that's, that's a good place to leave it.

00:47:52.820 --> 00:47:56.200
Let me ask you just a couple of questions before we let you out of here.

00:47:56.200 --> 00:47:58.820
If you're going to write some code, what editor do you use?

00:47:58.820 --> 00:47:59.480
Vim.

00:47:59.480 --> 00:47:59.880
Vim.

00:47:59.880 --> 00:48:00.460
All right.

00:48:00.460 --> 00:48:00.680
Yeah.

00:48:00.680 --> 00:48:01.360
Very cool.

00:48:01.360 --> 00:48:06.200
And there's over 96,000 packages on PyPI these days.

00:48:06.200 --> 00:48:09.020
And I'm sure you've come across some that are kind of unique.

00:48:09.020 --> 00:48:11.180
You're like, Hey, have you heard about this package?

00:48:11.180 --> 00:48:11.740
It's pretty cool.

00:48:11.740 --> 00:48:12.360
You should check it out.

00:48:12.360 --> 00:48:13.800
You got any, coming to mind?

00:48:13.800 --> 00:48:14.540
You know, it's funny.

00:48:14.540 --> 00:48:20.560
I mean, because I do a lot of my, most of my development inside Google, you know, we

00:48:20.560 --> 00:48:25.640
kind of have a different set of tools we tend to use.

00:48:26.020 --> 00:48:30.580
I don't have a ton of, experience with a lot of PyPI packages.

00:48:30.580 --> 00:48:30.940
Yeah.

00:48:30.940 --> 00:48:33.240
So it's a little bit more a dark matter.

00:48:33.240 --> 00:48:38.040
We out here in the larger universe don't get to see a lot of the cool stuff you guys get

00:48:38.040 --> 00:48:38.280
to use.

00:48:38.280 --> 00:48:39.560
I'm sure it's pretty neat though.

00:48:39.560 --> 00:48:40.220
Absolutely.

00:48:40.220 --> 00:48:41.140
All right.

00:48:41.140 --> 00:48:41.800
Awesome.

00:48:41.800 --> 00:48:43.360
So how about a final call for action?

00:48:43.360 --> 00:48:44.900
Like how can people get started grumpy?

00:48:44.900 --> 00:48:48.180
What can they do if they, if this resonates with them, things like that?

00:48:48.180 --> 00:48:48.680
yeah.

00:48:48.720 --> 00:48:52.860
I mean, we're, we're super interested in, in seeing where the project goes.

00:48:52.860 --> 00:48:57.700
I, I don't have, like I said, I would like to see, where grumpy can be useful

00:48:57.700 --> 00:49:01.460
besides just, you know, large concurrent server applications.

00:49:01.460 --> 00:49:04.120
Community feedback around that is great.

00:49:04.120 --> 00:49:08.220
I, people have been filing, issues asking about, you know, support for different things.

00:49:08.220 --> 00:49:12.160
And that's been really illuminating seeing where people are thinking about where this might

00:49:12.160 --> 00:49:12.520
be useful.

00:49:12.520 --> 00:49:13.880
So that's huge.

00:49:13.880 --> 00:49:20.820
if, you have the time and the inclination, try it out, just clone the repo and type make

00:49:20.820 --> 00:49:25.820
run and, and try out Python and go and, report any issues.

00:49:25.820 --> 00:49:27.320
That's really useful to us.

00:49:27.320 --> 00:49:30.700
And, and obviously there's a ton of work to do.

00:49:30.700 --> 00:49:36.240
we talked about some of the different things and, you know, contributions, via PR,

00:49:36.240 --> 00:49:38.680
pull requests on GitHub are really appreciated.

00:49:38.680 --> 00:49:42.460
It's been kind of amazing how much people effort people have put in already.

00:49:42.460 --> 00:49:45.700
So that's been, really exciting for us.

00:49:45.700 --> 00:49:45.920
Yeah.

00:49:45.920 --> 00:49:47.480
It's, it's a cool project.

00:49:47.480 --> 00:49:54.100
And I think if we have yet another powerful, flexible runtime that has some different trade

00:49:54.100 --> 00:49:56.760
offs that we can make for Python, that's great for everyone.

00:49:56.760 --> 00:50:00.200
So congratulations on your project and thanks for sharing it with everyone.

00:50:00.200 --> 00:50:00.460
Yeah.

00:50:00.460 --> 00:50:01.360
Thanks very much, Michael.

00:50:01.360 --> 00:50:01.780
You bet.

00:50:01.780 --> 00:50:02.380
Talk to you later.

00:50:02.380 --> 00:50:06.660
This has been another episode of talk Python to me.

00:50:06.660 --> 00:50:09.000
Today's guest has been Dylan Trotter.

00:50:09.000 --> 00:50:12.600
And this episode has been sponsored by hired and pie image search.

00:50:12.600 --> 00:50:14.620
Thank you both for supporting the show.

00:50:14.620 --> 00:50:17.800
Hired wants to help you find your next big thing.

00:50:17.800 --> 00:50:22.500
Visit hired.com slash talk Python to me to get five or more offers with salary and equity

00:50:22.500 --> 00:50:26.380
presented right up front and a special listener signing bonus of $2,000.

00:50:27.700 --> 00:50:31.460
Struggling to get started with neural networks, deep learning and image recognition.

00:50:31.460 --> 00:50:33.900
Pie image search.com can help with that.

00:50:33.900 --> 00:50:39.080
To learn more about their new book, deep learning for visual recognition with Python and back the

00:50:39.080 --> 00:50:39.900
Kickstarter campaign.

00:50:39.900 --> 00:50:43.560
Just head to pie image search.com slash Kickstarter.

00:50:44.500 --> 00:50:46.520
Are you or a colleague trying to learn Python?

00:50:46.520 --> 00:50:51.180
Have you tried books and videos that just left you bored by covering topics point by point?

00:50:51.180 --> 00:50:57.180
Well, check out my online course Python Jumpstart by building 10 apps at talkpython.fm/course

00:50:57.180 --> 00:50:59.800
to experience a more engaging way to learn Python.

00:50:59.800 --> 00:51:04.580
And if you're looking for something a little more advanced, try my Write Pythonic Code course

00:51:04.580 --> 00:51:07.120
at talkpython.fm/pythonic.

00:51:08.520 --> 00:51:10.180
Be sure to subscribe to the show.

00:51:10.180 --> 00:51:12.380
Open your favorite podcatcher and search for Python.

00:51:12.380 --> 00:51:13.620
We should be right at the top.

00:51:13.620 --> 00:51:19.740
You can also find the iTunes feed at /itunes, Google Play feed at /play and direct

00:51:19.740 --> 00:51:22.920
RSS feed at /rss on talkpython.fm.

00:51:22.920 --> 00:51:28.020
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:51:28.020 --> 00:51:31.040
Corey just recently started selling his tracks on iTunes.

00:51:31.040 --> 00:51:34.720
So I recommend you check it out at talkpython.fm/music.

00:51:34.720 --> 00:51:38.480
You can browse his tracks he has for sale on iTunes and listen to the

00:51:38.480 --> 00:51:40.080
full length version of the theme song.

00:51:40.080 --> 00:51:42.140
This is your host, Michael Kennedy.

00:51:42.140 --> 00:51:43.420
Thanks so much for listening.

00:51:43.420 --> 00:51:44.640
I really appreciate it.

00:51:44.640 --> 00:51:46.760
Smix, let's get out of here.

00:52:08.440 --> 00:52:09.020
Don't forget.

00:52:09.020 --> 00:52:11.080
you

