WEBVTT

00:00:00.020 --> 00:00:04.540
The folks over at Astral have made some big-time impacts in the Python space with uv and Ruff.

00:00:05.020 --> 00:00:08.080
They are back with another amazing project namedty.

00:00:08.740 --> 00:00:16.720
You may have known it as Red Knot, but it's coming up on release time for the first version, and with its release comes a new official name, ty.

00:00:17.440 --> 00:00:22.940
We have Charlie Marsh and Carl Meyer on the show to tell us all about this new type-checking project.

00:00:23.740 --> 00:00:28.100
This is Talk Python to Me, episode 506, recorded May 1st, 2025.

00:00:28.859 --> 00:00:30.820
Are you ready for your host, please?

00:00:31.720 --> 00:00:34.480
You're listening to Michael Kennedy on Talk Python to Me.

00:00:35.100 --> 00:00:38.200
Live from Portland, Oregon, and this segment was made with Python.

00:00:41.440 --> 00:00:44.320
Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:44.800 --> 00:00:46.560
This is your host, Michael Kennedy.

00:00:46.930 --> 00:00:54.920
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython, both accounts over at fosstodon.org.

00:00:55.280 --> 00:00:59.820
And keep up with the show and listen to over nine years of episodes at talkpython.fm.

00:01:00.380 --> 00:01:04.280
If you want to be part of our live episodes, you can find the live streams over on YouTube.

00:01:04.780 --> 00:01:10.560
Subscribe to our YouTube channel over at talkpython.fm/youtube and get notified about upcoming shows.

00:01:11.160 --> 00:01:14.860
This episode is sponsored by Posit Connect from the makers of Shiny.

00:01:15.340 --> 00:01:19.200
Publish, share, and deploy all of your data projects that you're creating using Python.

00:01:19.900 --> 00:01:25.900
Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto, Reports, Dashboards, and APIs.

00:01:26.800 --> 00:01:28.440
Posit Connect supports all of them.

00:01:28.740 --> 00:01:34.060
Try Posit Connect for free by going to talkpython.fm/posit, B-O-S-I-T.

00:01:34.920 --> 00:01:36.960
And it's brought to you by Auth0.

00:01:37.660 --> 00:01:41.920
Auth0 is an easy-to-implement, adaptable authentication and authorization platform.

00:01:42.620 --> 00:01:54.380
Think easy user logins, social sign-on, multi-factor authentication, and robust role-based access control. With over 30 SDKs and quick starts, Auth0 scales with your product at every stage.

00:01:55.060 --> 00:02:00.620
Get 25,000 monthly active users for free at talkpython.fm/auth0.

00:02:01.240 --> 00:02:04.180
Hey, Charlie. Hey, Carl. Welcome to Talk Python To Me. Awesome to have you here.

00:02:04.320 --> 00:02:04.420
Thank

00:02:04.420 --> 00:02:09.759
you so much for, I guess, having me back on and having Carl here too. We're really excited to be here.

00:02:09.880 --> 00:02:14.980
Yeah, great to be here. Yes, I've had you both on before, but never together, here side by side on the screen.

00:02:15.320 --> 00:02:15.560
Yes.

00:02:15.920 --> 00:02:16.720
So amazing.

00:02:17.200 --> 00:02:20.240
You folks over at Astral, you're doing things in the Python space.

00:02:21.040 --> 00:02:23.680
You're making people talk about it, which is pretty interesting.

00:02:23.980 --> 00:02:25.800
Yeah, that's kind of our, that's our goal.

00:02:26.140 --> 00:02:28.280
We want to get people to talk about Python.

00:02:28.750 --> 00:02:30.440
And so it's a good mix for what we're doing on the podcast.

00:02:31.480 --> 00:02:40.140
Yeah, I mean, a big part of what we've been doing is just trying to like inject as much energy as we can into the Python ecosystem and like see what comes of it.

00:02:40.440 --> 00:02:43.540
So yeah, this new project that we're working on, I think hopefully we'll

00:02:43.540 --> 00:02:45.520
shake things up a little bit more too.

00:02:45.680 --> 00:02:46.660
It's absolutely going to.

00:02:47.020 --> 00:02:57.880
I was just thinking this morning, as I was realizing we were going to be talking today and not some other day, that I was using both Ruff and uv on a project, multiple projects already this morning.

00:02:58.260 --> 00:02:59.680
And I smile every time I do.

00:02:59.820 --> 00:03:00.660
They're both great projects.

00:03:00.780 --> 00:03:01.100
Thank you.

00:03:01.340 --> 00:03:01.860
I appreciate that.

00:03:02.020 --> 00:03:02.120
I

00:03:02.120 --> 00:03:07.780
do want to talk about uv for just a moment before we kind of go down the other side of the branch there.

00:03:08.280 --> 00:03:12.540
But before we do either of those, it's been a while, Carl, since you've been on.

00:03:12.640 --> 00:03:16.080
And then Charlie, not everyone listens to every episode, so maybe I'll sit on it.

00:03:16.180 --> 00:03:18.380
Just maybe a quick round of introductions from you guys.

00:03:18.960 --> 00:03:19.580
Charlie, you want to go first?

00:03:19.860 --> 00:03:20.260
Yeah, sure.

00:03:20.480 --> 00:03:21.360
Hey, I'm Charlie.

00:03:22.000 --> 00:03:24.480
I am the founder of a company called Astral.

00:03:24.680 --> 00:03:27.320
We build developer tools for the Python ecosystem.

00:03:27.700 --> 00:03:31.100
So we're best known for two tools, the first of which is called Ruff.

00:03:31.400 --> 00:03:33.540
It's a Python static analysis tool.

00:03:33.630 --> 00:03:38.320
So it kind of looks at your code, tries to identify problems, and then in a lot of cases fix them.

00:03:38.460 --> 00:03:39.780
It can also reformat your code.

00:03:39.920 --> 00:03:45.180
So if you've used tools like Flake 8 or Black before, Ruff is an alternative to those kinds of tools.

00:03:45.760 --> 00:03:48.420
And then UV, which is a Python package manager.

00:03:48.960 --> 00:03:52.800
So if you've used tools like pip or Poetry in the past, uv would be an alternative to those tools.

00:03:53.440 --> 00:03:56.260
It helps you manage all your dependencies, manage your Python installation itself.

00:03:57.200 --> 00:04:01.360
So yeah, I've been working on Python tooling full-time for about two and a half years.

00:04:02.500 --> 00:04:08.200
And Astral as a company, we're now 14, 15 people working on this stuff full-time.

00:04:08.300 --> 00:04:16.620
So yeah, I spent all my time either thinking about Python or writing code to try to make Python better or talking to people about Python.

00:04:16.900 --> 00:04:17.280
That's awesome.

00:04:17.500 --> 00:04:18.140
I'm Carl Meyer.

00:04:18.519 --> 00:04:21.959
I've been hanging around the Python community for a long time now.

00:04:22.760 --> 00:04:30.320
Way back in the day, I used to maintain pip and VirtualEnv along with Giannis Liddell and Brian Rosner back in the day.

00:04:31.100 --> 00:04:46.800
And for a while, I was on the Django core team, spent some time at Instagram, worked on the cinder compiler there. And then a little more than a year ago, Charlie came along and said, hey, would you like to come to Astral and build a Python type checker in Rust? And that sounded like a lot of fun. So here

00:04:46.800 --> 00:04:47.100
I am.

00:04:49.560 --> 00:04:51.760
I guess that's our segue into the next topic then.

00:04:51.920 --> 00:04:55.200
Yeah, it is. And what a storied history you got there. That's awesome.

00:04:55.600 --> 00:05:50.560
It is. Now, I want to take the second half of your sentence there, Carl, and focus on that just for a second, just the Rust side and just the tooling side. I want to talk a little bit about uv because I feel like you should shine a bit of a light on it while you two are here, even though it's not the main topic. So before we dive down the rabbit hole of the new project, let's talk just a little bit of uv. Maybe give us a bit of an update. And also I want to point out that when I said the opening statement, I think you're making people talk about Python things. pip proper got quite a big update recently. And I think a lot of these, a lot of the energy that's being put into other torrents is like, whoa, if we're going to keep doing this, we better keep up. I think you're making a lot of interesting changes. There's the new lock file. Is it pylock.toml, let's call it, I think, and Brett Cannon and crew were advocating for. So yeah, maybe give us a quick update on these things.

00:05:50.820 --> 00:06:04.180
Yeah, we're still very focused on uv and uv continues to grow just in terms of the number of users that we have, the amount of companies that are using it, the amount of individuals that are using it.

00:06:04.300 --> 00:06:19.880
I think I ran the numbers the other week and over the previous seven-day period, it was over 20% of PyPI traffic came from people using UV, which is just an unfathomably large number because PyPI is over 2 billion requests a day.

00:06:20.150 --> 00:06:23.960
So that's hundreds and hundreds of millions of requests a day from people using uv.

00:06:24.800 --> 00:06:24.880
I

00:06:24.880 --> 00:06:25.900
mean, a lot of things have been happening.

00:06:26.160 --> 00:06:56.180
We've been participating in some of the newer peps. So yeah, there was a lock file PEP that was accepted that Brett heroically spent a lot of time getting approved. And I'm just laughing because I also felt like I spent a lot of time, but then I just think about how much time he spent, which is so much more. And just I realized how it's just a lot of work to build consensus. So that proposal now exists. It's kind of like an upgraded requirements TXT format, a tool agnostic way to record the exact dependencies and files that you want to install.

00:06:56.670 --> 00:06:56.920
And we

00:06:56.920 --> 00:06:57.720
ship support for that.

00:06:57.840 --> 00:06:59.260
What's the status on that?

00:06:59.330 --> 00:07:01.420
Are you 100% that's ready to go?

00:07:01.620 --> 00:07:04.620
Or is there any sort of caveats like it's tentative, it's new?

00:07:04.900 --> 00:07:05.220
Parts

00:07:05.220 --> 00:07:11.480
of it are technically behind the preview flag, but that just means that you'll get warned if you don't pass the preview flag.

00:07:11.680 --> 00:07:12.740
So it exists.

00:07:13.240 --> 00:07:30.820
I think the thing that's maybe a little tricky to convey is we still use our own uv.lock format and we view the pylock.toml as sort of like an export format or an interoperability format because it doesn't quite support everything that we need in our format.

00:07:31.380 --> 00:07:41.080
So if you just like use uv to resolve and install and manage your dependencies, you'll still use a uv.lock, but you can export out to pylock.toml and then you could use that with other tools.

00:07:41.620 --> 00:07:47.820
You could also like generate a pylock.toml with pip, for example, and then install from that in uv.

00:07:48.400 --> 00:08:06.320
So it's really meant as an interoperability format with other tools, but it's supported throughout the API. And we'll try and just make that support better and better over time. And also, hopefully, if we can find time, do a few more iterations on the spec to try and expand the scope of what that format can do too.

00:08:06.780 --> 00:08:09.140
But it's a big upgrade over requirements.txt.

00:08:09.330 --> 00:08:13.520
A lot of people historically used requirements.txt as a quote-unquote lock file.

00:08:14.020 --> 00:08:15.180
Like you'd write out, yeah.

00:08:15.540 --> 00:08:22.520
And it was kind of like the best thing that we had for a while where it's just like the package equals equals the version and then maybe the hashes.

00:08:23.060 --> 00:08:26.240
And that's just not, it's not a great interoperable format.

00:08:26.760 --> 00:08:28.360
For one thing, it's not standardized.

00:08:28.880 --> 00:08:30.620
There's not really a specification around it.

00:08:30.820 --> 00:08:33.640
It's basically defined by like what pip does.

00:08:34.060 --> 00:08:44.760
So when we have wanted support for it, We just constantly had to ask, well, how does pip handle this syntax or this grammar or this case and do that or make maybe small improvements to it if we thought we could.

00:08:45.100 --> 00:08:48.020
The other is that it's not super secure.

00:08:48.620 --> 00:08:50.580
The ability to put hashes in it helped a lot.

00:08:50.760 --> 00:08:55.200
But with PyLock.toml, for example, it'll list the exact URLs that you should use.

00:08:55.580 --> 00:08:59.140
And you can say that this package needs to come from this index and all that kind of stuff.

00:08:59.360 --> 00:09:01.380
So it's a really nice improvement over those.

00:09:01.580 --> 00:09:02.340
That's pretty interesting.

00:09:02.600 --> 00:09:04.800
Yeah, I'm glad that we tried to ship support for it pretty quickly.

00:09:04.840 --> 00:09:11.740
So I'm sure there's a lot of like, there's sort of like a long tail of things we could do to make it a little bit better, but I'm pretty happy with the state of that so far.

00:09:11.940 --> 00:09:16.640
Fantastic. Carl, anything you want to add? I know you're not quite working on uv most of the time, probably.

00:09:17.000 --> 00:09:20.300
I don't think I have anything to add on uv. I enjoy using it, but.

00:09:21.560 --> 00:09:26.260
There's no uv --check types or nothing like that? No flags in there?

00:09:26.440 --> 00:09:26.820
In the future.

00:09:27.060 --> 00:09:28.060
Yeah, it's on the roadmap.

00:09:29.819 --> 00:09:34.440
Nice. I will not install a package that lies about its types. This is how it's going to be.

00:09:35.040 --> 00:09:36.380
the new version check. You

00:09:36.380 --> 00:09:42.260
laugh, but I think that being able to integrate these tools together is actually something that we're very interested in.

00:09:42.460 --> 00:09:43.540
Interesting. Okay. We'll

00:09:43.540 --> 00:10:07.840
sort of get into it, but we're building a type checker and there's a lot of powerful things we could do in terms of making the type checking, like just work. If you're in a uv structured project that like uv understands and uv can manage the dependencies. There's a lot of like interesting interop that we could do between the tools. I mean, we want them to all work great standalone if you're like just using it in however way you want. But when you bring those things together, I think there are some cool opportunities to make the experience a lot more powerful and seamless.

00:10:08.100 --> 00:10:40.260
There's definitely room to grow. It's super popular, over 50,000 GitHub stars, which is incredible, right? That's almost as many as Flask or Django has. But, you know, Armin Roeneker did a Twitter thread that said, if you're not using UV, tell me why. And there was a bunch of misconceptions and other things. So there's still room for you guys to grow, right? 100%. Where's that 80% of IPI traffic, Right. But let's talk about your new project, which I guess doesn't really show up here, but I'm going to sort of. No, it doesn't show up here. It's secret and not an announcement.

00:10:40.480 --> 00:10:44.840
Possibly group. So I think let's start with an announcement. Let's start with an announcement.

00:10:44.900 --> 00:10:55.440
The title of the show at the working title, the working title that I put here for, because at the time that was its name or the live stream at least is Red Knot, Ruff's new type checker. Yes.

00:10:55.720 --> 00:10:57.760
That still lasts a week. What's going on here? Tell me about it.

00:10:57.820 --> 00:10:57.960
When

00:10:57.960 --> 00:11:04.680
we start a new project, we always develop it under a codename because we don't want to spend a bunch of time trying to figure out the right name up front.

00:11:04.930 --> 00:11:06.440
It takes a lot of time to pick a name.

00:11:06.810 --> 00:11:13.240
And so I shouldn't even say this part on the air, but like uv for a long time, for all of its development, it was called Puffin.

00:11:14.500 --> 00:11:14.800
Puffin?

00:11:14.900 --> 00:11:15.840
P-U-F-F-I-N?

00:11:15.840 --> 00:11:15.960
Yeah,

00:11:16.260 --> 00:11:16.320
yeah.

00:11:16.790 --> 00:11:18.880
And the names are always birds.

00:11:19.520 --> 00:11:21.880
And it's a little bit of an inside joke.

00:11:22.300 --> 00:12:02.200
but like I didn't know that when I chose the name rough for rough that a rough is actually a kind of bird and Mika on our team after making bird jokes that I didn't understand and I thought it was just being like silly and then eventually we had a conversation where he brought up to me that it's a bird and then it finally made sense because I had no idea so now we always use birds for the code name so when we started the type checker we used the code name red knot and that's really meant to be a code name although it sort of takes on a life of its own but we're going to release type checker under a different name, which is T-Y, just the letters T-Y. So that's what we'll be publishing it on PyPI and everywhere else. And that will be, anyway, so we'll have to change the name of the show.

00:12:02.320 --> 00:12:06.860
Yeah, we'll update it. We'll update it. Red Knot is now T-Y, it's going to be the new title. Well, now we'll see.

00:12:07.320 --> 00:12:09.220
Yeah, you heard it here first on Talk Python.

00:12:09.440 --> 00:12:14.980
That's right. That's awesome. Yeah. It keeps with the nice, concise names that you got. Does T-Y have anything to do with birds?

00:12:15.240 --> 00:12:15.860
Not to my knowledge.

00:12:16.180 --> 00:12:21.420
Maybe someone will tell us it does. I don't know. Exactly, Carl, in some language, it's like a parrot or something. I don't know.

00:12:21.960 --> 00:12:32.180
Yeah, we like names. When we go through this exercise of trying to pick a name, I mean, it's super hard and actually probably my least favorite part of the job, which is maybe saying something. I mean, it's good that that's my least favorite part of the job.

00:12:32.560 --> 00:12:40.960
But when we try to pick a name, we're looking for a few things. We want something that's short and ideally very easy to type. That's one of the things that we actually think about a lot.

00:12:41.360 --> 00:12:45.280
And we want something that's kind of distinctive and in some way thematic.

00:12:45.740 --> 00:12:48.980
So we liked ty because we could get it.

00:12:49.260 --> 00:12:50.400
It's very short.

00:12:50.780 --> 00:12:51.540
It's pretty distinctive.

00:12:52.160 --> 00:12:57.640
And it ambiguously ties into lots of different things like type checking, but it's also an acronym for thank you.

00:12:58.060 --> 00:13:03.220
And so it actually shouldn't really be clear why it's called that ideally, but

00:13:03.220 --> 00:13:03.800
it has a bunch

00:13:03.800 --> 00:13:05.760
of ambiguous reasons why it could be called that.

00:13:06.020 --> 00:13:07.160
And it's incredibly easy to type.

00:13:07.540 --> 00:13:11.220
And you get to write ty space check to detect your types, which is like somewhat invaluable.

00:13:11.520 --> 00:13:15.860
Well, I do think that having a short CLI command is an ergonomics thing, right?

00:13:16.000 --> 00:13:16.840
It is useful.

00:13:17.160 --> 00:13:17.300
Yes.

00:13:17.480 --> 00:13:30.620
I did find out this morning from David on our team who's in Germany that he was confused why we kept saying ty was easy to type because apparently on a German keyboard the Y and the Z are swapped and so the Y is kind of like way off

00:13:30.620 --> 00:13:31.840
to the side with your pinky finger.

00:13:32.120 --> 00:13:32.340
Wow.

00:13:32.560 --> 00:13:32.640
So

00:13:32.640 --> 00:13:37.780
I have to apologize in advance to all of our German keyboard users that it won't be quite as easy to type for you.

00:13:37.840 --> 00:13:38.760
That's interesting, yeah.

00:13:38.980 --> 00:13:43.040
So what are you guys going to do if they download it like a thousand times you'll send them like an alternate keyboard or something?

00:13:43.260 --> 00:13:45.120
Yeah, we have multiple people on the team in Germany.

00:13:45.390 --> 00:13:45.500
So

00:13:45.500 --> 00:13:47.100
we'll publish a keyboard

00:13:47.100 --> 00:13:48.680
shortcut that smobsters ZNY.

00:13:49.020 --> 00:13:49.100
Yeah.

00:13:49.230 --> 00:13:49.360
Yeah.

00:13:49.390 --> 00:13:54.480
When I lived in Germany, one of my concerns was I was changing jobs and stuff.

00:13:54.480 --> 00:13:56.920
I'm like, oh, please don't make me buy a MacBook here.

00:13:57.580 --> 00:13:57.840
Please.

00:13:58.400 --> 00:13:59.260
I can't handle the keyboard.

00:13:59.660 --> 00:14:00.200
I got

00:14:00.200 --> 00:14:05.440
to get one with the layout that I'm used to, which I guess that wherever you are, that probably that goes for same.

00:14:05.640 --> 00:14:07.400
But luckily I got to keep my US layout.

00:14:07.760 --> 00:14:09.480
I mean, we should all be using Dvorak anyway.

00:14:09.640 --> 00:14:11.500
We're all doing it wrong in just slightly different ways.

00:14:13.480 --> 00:14:16.600
This portion of Talk Python to Me is brought to you by the folks at Posit.

00:14:17.160 --> 00:14:20.100
Posit has made a huge investment in the Python community lately.

00:14:20.800 --> 00:14:25.660
Known originally for RStudio, they've been building out a suite of tools and services for Team Python.

00:14:26.680 --> 00:14:33.100
Previously, we've talked about how Posit Connect makes it easy to deploy and share the data science assets you make with Python.

00:14:33.640 --> 00:14:36.440
Today, I want to talk about sharing those assets securely.

00:14:36.980 --> 00:14:51.700
If the mention of laws like HIPAA, GDPR, or even just company policies make the hair on the back of your neck stand up, you'll know you want a trusted partner to help your data become shareable, but also follow the data safety rules we all have to live by.

00:14:52.240 --> 00:15:03.180
Posit Connect is here to help. Posit Connect lets you securely deploy and share what you build in Python with Streamlit, Dash, Plotly, Bokeh, FastAPI, Shiny, Flask, Quarto, Reports, and APIs.

00:15:03.640 --> 00:15:13.620
Here's how. You or your IT team set up Posit Connect on a secure server within your org or on a trusted cloud service protected by your org's existing authentication system.

00:15:14.460 --> 00:15:22.180
When you publish a piece of content, Posit Connect lets you set user-level permissions for that content, making it visible to some users, but not everyone.

00:15:22.960 --> 00:15:29.380
You can also use Posit Connect to collect credentials from your users to pass on to data sources that your content draws from.

00:15:29.840 --> 00:15:35.900
so you can devise dashboards and apps that show each user only what they have permission to see in your data warehouse.

00:15:36.720 --> 00:15:41.960
So if you work on a data science team where security matters, you owe it to you and your org to check out Posit Connect.

00:15:42.620 --> 00:15:47.980
Visit talkpython.fm/connect today and get a three-month free trial to see if it's a good fit.

00:15:48.500 --> 00:15:50.680
That's talkpython.fm/connect.

00:15:51.160 --> 00:15:52.920
The link is in your podcast player show notes.

00:15:53.600 --> 00:15:55.860
Thank you to Posit for supporting Talk Python To Me.

00:15:57.060 --> 00:16:13.840
So Red Knot is now TUI and that has been a major focus for, not the name, but the project itself has been a major focus for our team for the past, wow, a while, almost a year, maybe a little bit less. But we've been, yeah, we've been working on this for a long time. So I'm excited that we're in a position where we can finally start talking about it. I'm

00:16:13.840 --> 00:16:16.920
excited. When I saw it, I'm like, oh, I have to have you guys on the show. We've

00:16:16.920 --> 00:16:17.220
got to talk

00:16:17.220 --> 00:16:34.560
about this because this is a big deal. So let's just start by talking about like why a type checker at all. We've had a couple of type checkers. There's a few benefits you can get from them, but I'll let you all riff on that a bit. Python itself is a dynamic language. Let the ducks be ducks. What are we doing here?

00:16:34.720 --> 00:16:36.640
Python gets used in a lot of different ways.

00:16:37.400 --> 00:16:58.000
And I think compared to the initial vision for Python back in 1990 or whenever Guido released the first version, it's used for a lot bigger projects and more sort of serious software engineering than it was maybe initially envisioned to be for. And I think when you get larger projects, larger amounts of code, larger numbers of people working on the projects.

00:16:58.670 --> 00:17:07.860
There can be a lot of value in having some machine enforceable documentation about your intention when you wrote this function.

00:17:08.030 --> 00:17:10.740
What were you envisioning that it should operate on?

00:17:10.860 --> 00:17:12.079
What were you envisioning that it should return?

00:17:12.939 --> 00:17:31.280
I know certainly when I was at Instagram and working on the very large Python code base there and thousands of developers with a lot of turnover coming in and out of that project, you can waste a lot of time digging kind of through layers and layers of code, just trying to understand even what is this variable?

00:17:31.520 --> 00:17:32.240
Where could it come from?

00:17:32.480 --> 00:17:33.220
What could it look like?

00:17:33.920 --> 00:17:37.760
And a type annotation can give you that information kind of just right up front immediately.

00:17:38.460 --> 00:17:40.820
So there can be a lot of value in that.

00:17:40.980 --> 00:17:48.800
And certainly I don't think anyone, or at least we are not aiming to change Python into a fully statically typed language.

00:17:48.940 --> 00:17:51.620
I don't think that would be possible or desirable.

00:17:51.860 --> 00:17:55.160
It's great to have that flexibility for a continuum of use cases.

00:17:56.100 --> 00:18:05.280
But for those who want to have types available and type enforcement, we can make that available where in an opt-in kind of gradual way.

00:18:05.460 --> 00:18:15.420
There's a couple of different elements to it, all of which Carl touched on in some way, but one helps prevent you from shipping bugs, helps you write correct code.

00:18:15.710 --> 00:19:22.840
But the other piece is, I think the types and the typing have actually played more and more of a role over time because what you end up getting is the way that the types feed into the editor experience. So it's not just about running a type checker to check that your code is correct, but I actually talked to teams that don't even run a type checker, but they still add type annotations to their code because when they add type annotations to the code, the editor is more useful to them. The auto-completion is better and they get real-time diagnostics. So even if you're not actually running a type checker on your code for whatever for whatever reason like adding types to your code can actually make you more productive by integrating with the language server in the editor so i don't know for me it's actually a really big part of how i write python i try to write pretty stupid python and do that with like a fair number of types and i find that that's what helps me like scale so i don't know i think i think the typing it's like it's useful both in the context of i want to run this in ci and like make sure that i'm not shipping code that has like obvious problems and in the context of how I make myself just like more productive when I'm like sitting in my editor writing code trying to figure out like how to implement the given function.

00:19:23.100 --> 00:20:21.820
I was going to jump in and say that but you you articulate it very well for me I don't run a type yeah I don't run a type checker but I want my editor if I am going to the documentation for stuff that I kind of understand how it works I'm probably doing it wrong in my mind if I see star args star star kw args and I'm just like ah what am I going to do but most of the time you can just hit dot or parentheses and then there's all the information provided either the editor can detect the type somehow through some chain or you just type them there and then it's just bam bam bam and until you kind of don't understand stuff or it's really new then you maybe go to the docs but like you're saying you can just fly and I will throw out a new one that is now relevant in the last couple years if I am going to take some python code and share it with an ai of some variation some agent code generator or chat or whatever if that code has types in it it's way better because it probably doesn't have the possibility of getting the right context otherwise

00:20:21.820 --> 00:20:57.400
yeah that's a big part and it also creates a feedback loop for if you are running like an agent or you if you're using like cursor or cloud code or one of those systems you actually create a feedback loop whereby they can iterate on the code without executing it right because they can run your code run it through a type checker, look at the diagnostics, and then modify it in turn. So it's like, I sort of think some of this stuff will potentially become like even more important, like the static, providing good static analysis, because it's your opportunity as a human to like hit the computer in a given way and inject some context. So I mean, we'll see, I could be like completely wrong about that.

00:20:57.860 --> 00:21:00.640
But I at least find it to be really helpful in those contexts too.

00:21:00.860 --> 00:21:38.640
Yeah, I see some comments out there in the chat that are like, yeah, same thing. I also, I liked Carl's comments that sort of for large real projects, you can opt into this. And I like, one of the powers of Python, I think, I guess, to put it this way is I feel like you can be incredibly productive and you can get a lot done with Python with a very partial understanding of what it is, like incredibly partial, right? You don't have to know what a class is, maybe not even a function, but if you can string together 10 lines of interacting with some library, you might have accomplished something that would make you, wow, I'm not a programmer, but look what it did.

00:21:39.040 --> 00:22:05.380
And that's great that it has that level, but as it grows bigger and more serious, I've heard the comment from somebody on some podcast somewhere, like they were lamenting the fact that there's so much Python in data science, machine learning. They're like, oh, this is a language for unserious people. Well, it can be used in an unserious way, but things like this are part of like, I choose to use it in a serious way, right?

00:22:05.920 --> 00:22:06.660
It's not a

00:22:06.660 --> 00:22:07.540
flaw of it.

00:22:07.660 --> 00:22:14.420
It's actually a power of it that you, when you don't need a systems level language, you don't have to write systems level code.

00:22:14.610 --> 00:22:20.320
But when you're ready to, you can sort of progressively add on these layers and run things like Ty to check it.

00:22:20.540 --> 00:22:21.140
Wait, is that what happened?

00:22:21.270 --> 00:22:22.160
Do we T-Y or Ty?

00:22:22.400 --> 00:22:23.020
What's our pronunciation?

00:22:23.360 --> 00:22:23.500
T

00:22:23.500 --> 00:22:24.180
-Y, Michael, come on.

00:22:24.460 --> 00:22:54.120
No, that's funny you say that because like that's off, that is sometimes how I think about actually like what we're trying to do here, like with this company and this like set of projects the first place, which is Python is this like enormous programming ecosystem, like the largest or the second largest programming ecosystem on earth. And yet there's a lot of people who just don't take it very seriously or are constantly predicting its demise. And yet it just keeps growing. And so my approach has generally been, well, what if we just take it really seriously?

00:22:55.220 --> 00:23:03.460
We'll just bring in the smartest people. Hopefully I'll try to recruit the smartest people I can come in and build like really serious software.

00:23:04.020 --> 00:23:10.200
And the net effect is like, you can have an enormous impact because we build, like I was talking about UV, right?

00:23:10.300 --> 00:23:16.100
Like we build uv and suddenly we have like, I don't know, hundreds of millions of requests running through that project a day.

00:23:16.210 --> 00:23:24.620
And so you just think about the scope of impact because Python may not be a perfect language, but a lot of programming and technology is about path dependence, right?

00:23:24.920 --> 00:23:31.680
Like people, it's very hard, like Python is going to continue to be used in tons of places, even if despite its problems.

00:23:32.140 --> 00:23:41.780
And so my perspective has always been, well, how can we like meet that world where it is and like try to build really great tooling because the amount of impact, it's like a huge lever.

00:23:42.260 --> 00:23:46.900
So yes, I feel that way about like kind of everything we build, but it was funny to hear you say it.

00:23:46.900 --> 00:23:55.340
And we spend a lot of time now with companies that are like have hundreds and hundreds of engineers, like Python programmers working on like a single code base.

00:23:56.260 --> 00:24:00.380
And yeah, for them also the performance is a big piece of it.

00:24:00.580 --> 00:24:04.320
So how do they get these tools to like scale to very large projects?

00:24:04.840 --> 00:24:16.900
And our goal is to basically build tooling that can scale to very large projects, but is also useful and helpful for people like beginners and people working on very small projects.

00:24:17.200 --> 00:24:22.700
We want to have something in the tool that's useful and valuable to both of those demographics, which are very different.

00:24:23.020 --> 00:24:27.760
So we often think about kind of like building for scale, but like designing for everyone.

00:24:28.100 --> 00:24:33.340
Like we want to build a tool that can scale to like tens of millions plus lines of code.

00:24:33.880 --> 00:24:40.360
And what is also like meets a beginner where they are and like helps them like get started and like get productive with Python.

00:24:40.560 --> 00:24:48.500
So either one of you want to take this one, like why, so we understand why types are important, but why are you all building a type checker, right?

00:24:48.640 --> 00:24:50.600
We have myPy, myPyRite.

00:24:50.860 --> 00:24:55.080
Why don't I say why I decided that we should build a type checker and then we'll see what Carl says.

00:24:55.460 --> 00:24:58.960
So I think for me, like when I, there's a couple of pieces to it.

00:24:59.060 --> 00:25:08.120
One is like when I started working on RAP and then I started the company, there was always a vision in my mind of this like unified set of tools that we wanted to build and put together.

00:25:08.680 --> 00:25:11.160
And we did the linter and then we did the formatter.

00:25:11.560 --> 00:25:22.320
And the type checker was kind of like always the missing piece there of, well, if I had like a suite of static analysis tools that handled everything for my project, I would want like a lint or a formatter and a type checker.

00:25:22.720 --> 00:25:24.180
And we didn't have that.

00:25:24.240 --> 00:25:28.240
And I was like, I think that would really help complete the story for what we're trying to provide to people.

00:25:28.500 --> 00:25:33.120
So one piece was, this is the experience we want of like, you can use Astral's tools.

00:25:33.460 --> 00:25:35.880
It like gives you everything you need really to be productive with Python.

00:25:36.740 --> 00:25:44.160
But the other piece is, this has been the thing that people have asked me for probably more than anything else ever since we released Ruff.

00:25:44.580 --> 00:25:50.960
So I think it's natural that people would ask for it because this is like sort of in a similar space of things that you do.

00:25:51.300 --> 00:25:54.000
Like, but everyone's saying, hey, I'm having problems with my type checker.

00:25:54.040 --> 00:25:55.300
I'm having problems with my type checker.

00:25:55.640 --> 00:25:59.200
When I switched to rough, I experienced this great, this change and how I work.

00:25:59.560 --> 00:26:02.140
Can you bring that same experience to, to type checking?

00:26:02.740 --> 00:26:05.760
And I think for me, the answer was like, yeah, we absolutely can.

00:26:05.880 --> 00:26:09.500
I don't see any reason why we can't provide the same like level of quality of life improvement.

00:26:10.300 --> 00:26:18.060
So, you know, part of it was I saw a big opportunity and within that opportunity, I think there were like two things that really stuck out to me.

00:26:18.460 --> 00:26:19.840
One was performance.

00:26:20.480 --> 00:26:24.640
And this is more about people working companies that we talk to where they're working on really large projects.

00:26:25.140 --> 00:26:25.700
Maybe the type

00:26:25.700 --> 00:26:26.020
checker.

00:26:26.050 --> 00:26:27.700
Your little demo app probably is going to be fine.

00:26:27.740 --> 00:26:28.440
Yeah, demo app's fine.

00:26:28.620 --> 00:26:28.740
Yeah.

00:26:28.850 --> 00:26:34.880
But like the, if you have a really, if you have a big company with a lot of people working on a Python project, this comes into play in a couple of different ways.

00:26:35.100 --> 00:26:41.040
One is like some companies can't even really run the type checker locally anymore, or they're spending a lot of money running it on huge machines.

00:26:41.660 --> 00:26:42.780
That's a real thing that happens.

00:26:43.480 --> 00:26:45.060
Other times it's the language server.

00:26:45.260 --> 00:26:57.020
the thing that lives in your editor that gets slowed down. So we'll talk to companies where like, they're like the language server can't index our project anymore. So go to definition doesn't work. Or every time I change branches.

00:26:57.420 --> 00:26:59.740
Yeah, let me throw a little background information on there.

00:26:59.860 --> 00:27:25.960
For people who don't know, the way your editor autocompletes, goes to definition and all that kind of stuff is there's this language server that parses and understand the code almost like an abstract syntax tree and it needs to read all the all of the code and allow you to basically use that live information as you interact with it and what you're saying charlie is if it's too big then basically it's always behind or just can't quite handle it it's always

00:27:25.960 --> 00:27:29.100
behind or can't fit all the context into the system or

00:27:29.100 --> 00:27:32.480
something like that and so and what you're hinting at is you might fix this yeah

00:27:32.480 --> 00:28:09.980
we want to fix that so it's not just about building a type checker we also want to build a language server and these two things are like intimately related like pylance which is a very language server, you might not even know you're using it, but it's like the primary language server in VS Code is powered by PyRite, which is another type checker. And those tools are very interconnected. It's like when you try to autocomplete something in your editor, the editor needs to go through a process of understanding, well, what are the valid options that could fit here? And that is similar in shape to a type checking problem. So part of it was performance of seeing these huge projects and all these companies that were coming to us saying, we're having all these problems with the scaling of the tooling to our projects.

00:28:10.740 --> 00:28:56.280
and the other was the ability to build i think like a really different experience by integrating more of our tooling like we've thought about this with rough which is a linter and then rough we have like rules that for example should only run on dictionaries and so we might need to understand like could this object be a dictionary in order to know whether we should flag a certain rule and right now we do basically like bad unreliable things to understand like is this variable could it be a dictionary? And if you kind of take that to an extreme, you could imagine we could build a much better lender if we actually had access to type information. Like if we knew what all the variables were in the program and like what types they could take on, we could give people much better information about the problems that they have. So part of it was like performance. Part of it was this opportunity to build something that I thought was really different. I

00:28:56.280 --> 00:30:22.000
think those are the primary motivations, performance for sure. I think we're already seeing that we can be quite a lot faster than the existing type checkers. I think another thing that's become clear as we've worked on ty is that there are areas where we do want to provide a little different experience than some of the existing type checkers. And I think this connects to what we were talking about before about the way Python scales with you as a project grows and the way you can kind of start out with something quick and simple and realize it's successful and grow to make it bigger and kind of gradually opt in to stricter typing. One thing that has been part of the experience in Python typing up until now is that even though it's supposed to be something that you can gradually adopt, the reality has been that if you have a code base that's working but isn't really typed and you start to run a type checker on it, you'll probably get a pretty long list of type errors the first time that you run it. And you really have to spend a lot of time adding type annotations and even reworking the way some of your code works in order to make the type checker even happy with your code. Because the type checkers, for various reasons, they're sort of opinionated often and making kind of assumptions about, well, if you assigned an integer to this variable here, then clearly you never meant to ever assign anything else to that same variable later in the function or whatever. And so you sort of have to adjust your code to work around the assumptions the type checker is making.

00:30:23.040 --> 00:30:52.160
And one thing that we're aiming to do with ty is to try to smooth that curve a little bit in the sense that we try not to make assumptions about what you meant and rely on what you've explicitly told us about your types so that if you run it on a code base that isn't typed, we'd like to, but that is working correctly, we'd like to not issue a bunch of false positive errors right off the bat and just start to issue errors gradually as you start to gradually add type annotations.

00:30:53.680 --> 00:30:56.480
This portion of Talk Python to Me is brought to you by Auth0.

00:30:57.040 --> 00:30:58.140
Do you struggle with authentication?

00:30:59.260 --> 00:31:05.580
Sure, you can start with usernames and passwords, but what about single sign-on, social auth, integration with AI agents?

00:31:06.200 --> 00:31:11.520
It can quickly become a major time sink, and rarely is authentication your core business.

00:31:12.180 --> 00:31:16.740
It's just table stakes that you've got to get right before you can move on to building your actual product.

00:31:17.360 --> 00:31:19.240
That's why you should consider Auth0.

00:31:19.760 --> 00:31:24.020
Auth0 is an easy-to-implement, adaptable authentication and authorization platform.

00:31:24.860 --> 00:31:31.140
Think easy user logins, social sign-on, multi-factor authentication, and robust role-based access control.

00:31:31.860 --> 00:31:38.280
With over 30 different SDKs and quick starts, Auth0 scales with your product at every stage.

00:31:38.980 --> 00:31:44.060
Auth0 lets you implement secure authentication and authorization for your preferred deployment environment.

00:31:44.580 --> 00:31:52.480
You can use all of your favorite tools and frameworks, whether it's Flask, Django, FastAPI, or something else, to manage user logins, roles, and permissions.

00:31:53.220 --> 00:31:58.120
Leave authentication to Auth0 so that you can start focusing on the features your users will love.

00:31:58.980 --> 00:32:03.420
Auth0's latest innovation, Auth4GenAI, which is now available in developer preview.

00:32:03.700 --> 00:32:14.800
secure your Agenic apps, and integrate with the Gen.AI ecosystem using features like user authentication for AI agents, token vault, async authorization, and FGA for RAG.

00:32:15.560 --> 00:33:59.640
So if you're a Python developer or data scientist looking for an easy and powerful way to secure your applications, get started now with up to 25,000 monthly active users for free at talkpython.fm/auth0. That's talkpython.fm/auth0. The link is in your podcast player's show notes. Thank you to Auth0 for supporting the show. I think it makes a lot of sense. We talked about the different motivations and reasons that people might use types. And so I can certainly see why that would lead to different expectations or roles or whatever from your tools, right? If you're adding types so that your editor is better or so you can talk to AI better, you might not want it to be just super complaining at you that every little thing is wrong. I know on some of the projects that I run, I did some decorator and the decorator was just, it was super complicated because it can do both sync and async functions. And like it just somehow I got the type. It's just a little bit wrong, but I didn't ever notice it. You don't ever call the view functions directly in your code because that's what the frameworks call, right? And you put the at get on it or whatever. However, some people running that through the type checker are sending me things, say, well, look, you're getting this warning for using this decorator here. I'm just like, okay, I'm going to fix it. It's fine. And understand that. But, you know, is the type checker actually helping you to say, we expected the thing that you never called to look like this, but it looks slightly different. Like, well, tree falls in forest, no one's there kind of thing, right? I pulled up this GitHub issue here on rough. And this points at two questions I want to get to. The one on the screen is not the first one. That's the second one. Perfect. First one is, will this be part of rough or is ty its own separate uv tool install type thing?

00:33:59.860 --> 00:34:01.340
How will I manage it, right?

00:34:01.440 --> 00:34:03.640
We're planning to release it as a separate tool.

00:34:03.810 --> 00:34:10.899
So you'd install it separately and uv tool install ty or uv install ty and then run it asty.

00:34:11.220 --> 00:34:11.360
Okay,

00:34:11.879 --> 00:34:17.360
because it came out, I feel like its motivation, as you guys are saying as well, came out of Ruff, right?

00:34:17.540 --> 00:34:18.780
The linter and formatter.

00:34:19.280 --> 00:34:24.659
But as you thought about it, I guess, this is actually its own thing now, right?

00:34:24.720 --> 00:34:28.139
But if you look at all the GitHub issues, like a lot of them are on Ruff actually.

00:34:28.440 --> 00:34:30.280
Yeah, it's currently built in the Ruff code base.

00:34:30.520 --> 00:34:36.620
So they share a code base and that's mostly just for convenience because we share a lot of common infrastructure with Ruff.

00:34:36.690 --> 00:34:42.159
So like the parser and the abstract syntax tree and all of that are shared between Ruff andty.

00:34:43.200 --> 00:35:19.080
But yeah, and we initially did consider the possibility that we would develop the type checker kind of more under the covers in rough and sort of gradually start to power more and more rough lint rules with type information without really shipping a type checker per se. But we kind of debated those two options and decided that it just really seemed like there was a high demand for a type checker, a full type checker like my pyrepyrite. And we thought we could reach that goal more efficiently and quickly if we did it a little more separately from rough at the product level.

00:35:19.220 --> 00:35:22.020
Makes sense to me. All right. Now the real question I actually have on the screen.

00:35:22.680 --> 00:35:32.460
Will Redknot, aka ty, because that was the code name, right? Will ty be a drop-in replacement for mypy or PyRite? The

00:35:32.460 --> 00:36:18.200
thing I'm slightly buoyed by, and Carl is in a much better position to comment on whether this is actually true, but from my perspective, at least, a focus area for typing in Python broadly as an ecosystem has been increased conformance. So trying to create rigorous specifications around how some of the typing features that are a little underspecified should work. And then ensuring that the type checkers can implement common behaviors on not all dimensions, but on some of those dimensions. I think there's still, my feeling is the intent is still that there's actually room for some subjectivity in how type checkers work, but that in a lot of areas, they actually want to standardize how things are supposed to work so that there can be less deviation.

00:36:18.680 --> 00:36:24.920
Yeah, particularly when it comes to, yeah, particularly when it comes to typing a public API for like a library author.

00:36:25.380 --> 00:36:30.500
I mean, if you just have your own project that you're running your type checker on, you're probably going to pick one type checker and run it.

00:36:30.610 --> 00:36:32.940
And so it's okay if it behaves differently from some other ones.

00:36:33.500 --> 00:36:41.460
But if you have a popular library and you want to provide types for your library, you may have some users of your library using mypy and some using PyRite.

00:36:42.080 --> 00:37:11.100
some are going to use ty and so we need to in particular have some standardization in the type system that allows a library author to provide types for their library that will actually work for all their users and so in ty we do aim to to pass we don't yet we're not that stage yet but we do aim to pass the conformance suite for the python typing specification and be a standards conformant type checker there may be some points of tension where we have a different opinion about how some things should be done.

00:37:11.250 --> 00:37:20.100
And we'll probably have some discussions there about changing or suggesting some possible changes to the spec in some areas, but we will aim to be conformant.

00:37:20.260 --> 00:37:20.880
Yeah, that's excellent.

00:37:21.260 --> 00:37:24.340
I was just messing with my rough.toml for one of my projects.

00:37:24.920 --> 00:37:28.720
Are you going to have a tie.toml or something like that, that we can tweak the rules?

00:37:29.080 --> 00:37:29.300
Oh yeah.

00:37:29.660 --> 00:37:34.240
Currently we already have a not.json, which I think probably needs to become tie.json.

00:37:35.140 --> 00:37:36.960
Or I guess it's tie.not.toml.

00:37:37.090 --> 00:37:38.340
So it'll be tie.toml, yeah.

00:37:38.500 --> 00:37:41.720
I think it's JSON in the web playground, probably, because,

00:37:42.380 --> 00:37:42.700
yeah, we

00:37:42.700 --> 00:37:44.180
have a web playground for this stuff.

00:37:44.580 --> 00:37:52.260
And in those contexts, it's much easier to, you can have a JSON schema, so it's, like, much easier to use JSON also because it's all natively built.

00:37:52.440 --> 00:37:53.720
Like, JavaScript just supports JSON.

00:37:54.180 --> 00:37:54.340
Excellent.

00:37:55.020 --> 00:37:57.080
A couple of thoughts here from the audience.

00:37:57.340 --> 00:37:58.020
Let's jump over there.

00:37:58.060 --> 00:37:59.920
Richard Ellison asks, this sounds awesome.

00:38:00.160 --> 00:38:02.060
What will the client setup look like?

00:38:02.420 --> 00:38:03.460
Will it all be server-side?

00:38:03.820 --> 00:38:09.240
Please don't put magic into the client like PyLance does with PyRite NeoVim user here, by the way.

00:38:09.400 --> 00:38:29.300
I wish some of our other developers here who work on the LSP stuff more were here to answer this one, but I think we're aiming to just follow the LSP standard and not put magic into the extension for, say, VS Code that wouldn't be something you could replicate on NeoVim or any other editor that uses LSP.

00:38:29.540 --> 00:38:29.640
A

00:38:29.640 --> 00:38:37.640
core goal for us here is like, I mean, this will, of course, be open source and permissively licensed just like our other tools.

00:38:38.070 --> 00:38:41.040
I guess it's probably MIT right now, just by way of being in RUV.

00:38:41.160 --> 00:38:44.220
UV is dual MIT in Apache, but RUV is MIT.

00:38:44.520 --> 00:38:46.820
So I think that implicitly this is all MIT.

00:38:48.200 --> 00:38:57.560
And an explicit goal here is by building an open source language server, it should be possible to use it in any editor that supports language server protocol equally well.

00:38:57.900 --> 00:39:19.800
So if you have people on your team using NeoVim, VS Code, whatever, Zed, like any of these editors, you should be able to plug in our LSP and get an equally good experience in all of them. And I actually view that as like a big, a big advantage and kind of like reason to do this, which is that I think we can build a language server that you can use in

00:39:19.800 --> 00:39:20.860
any editor

00:39:21.260 --> 00:39:30.700
and have the same experience across your team and on the command line. So yes, we want it to be like, it's very intentional that we don't want there to be like any magic in the server or whatnot.

00:39:30.980 --> 00:39:36.680
Like we want this to just be a thing that implements language server protocol that you can use from any editor that supports it.

00:39:37.000 --> 00:39:44.860
I guess the analogy would be like Rust Analyzer, which maybe isn't actually a great analogy for this audience because it entirely depends on whether you've written Rust before.

00:39:45.800 --> 00:39:52.280
But Rust Analyzer is the Rust language server and you can use that in any editor and that works great.

00:39:52.500 --> 00:39:52.700
Nice.

00:39:52.980 --> 00:39:53.160
All right.

00:39:53.510 --> 00:40:02.000
Other question I thought was good is Andrew Alder asked, just started listening, will this be accessible as a library from the Python side.

00:40:02.440 --> 00:40:04.680
I could be interested to be able to write scripts against types.

00:40:05.040 --> 00:40:06.260
Yeah, we're just like laughing.

00:40:06.620 --> 00:40:07.480
I think you go, Carl.

00:40:07.800 --> 00:40:14.060
My answer to this one would be that I don't see any strong technical barriers to this.

00:40:14.200 --> 00:40:20.200
We already sort of have an internal API where you can just say, given an expression in the AST, what is its type?

00:40:20.880 --> 00:40:25.760
And so exposing that to Python should be technically not too difficult.

00:40:25.840 --> 00:40:30.300
I think the challenges here are just prioritization of that versus other things.

00:40:30.920 --> 00:40:35.900
and wanting to be a little careful about what we lock ourselves into API-wise.

00:40:36.800 --> 00:40:37.940
So I would say it

00:40:37.940 --> 00:40:39.620
should be possible, but not an immediate priority.

00:40:39.800 --> 00:40:44.620
Sure. What about plugins or extensions or extensibility, something like that?

00:40:44.820 --> 00:40:46.660
Plugins and extensions are somewhat unlikely.

00:40:47.050 --> 00:40:47.980
I mean, maybe.

00:40:48.810 --> 00:40:57.520
I think we would prioritize plugins and extensions for lint rules over type inference, which is sort of a fuzzy line to draw.

00:40:57.820 --> 00:41:04.140
but a lot of people want plugins and extensions in rough often to do things that they want to identify certain patterns or whatnot.

00:41:04.360 --> 00:41:08.040
And I think we would support that before we supported extensions in the type checker.

00:41:08.200 --> 00:41:13.880
Sure, I can see things like, we want to detect this general usage pattern that is indicative of...

00:41:13.940 --> 00:41:14.100
Yeah,

00:41:14.280 --> 00:41:24.620
or like this library should never be imported in this part of the code base, or this function should never be called without first calling this function or something like that.

00:41:24.760 --> 00:41:27.160
Sort of what I think of as proprietary rules.

00:41:27.740 --> 00:41:30.200
basically, like things that are very specific to your project.

00:41:30.680 --> 00:41:34.540
But Carl, what's the thing that David implemented, the Python typing, the import?

00:41:34.820 --> 00:41:36.060
We have a module.

00:41:36.860 --> 00:41:39.580
It's kind of a fake module because it doesn't exist in Python.

00:41:39.730 --> 00:41:41.900
It just exists in the mind ofty.

00:41:42.780 --> 00:41:44.660
It's currently called NotExtensions.

00:41:44.750 --> 00:41:47.400
I suppose we'll probably rename it to TYExtensions.

00:41:47.900 --> 00:42:00.380
It has a bunch of interesting tools in it that you can kind of import and use to sort of ask the type system what it thinks of the type of a certain value is or make some assertions that this type is a subtype of this other type.

00:42:00.770 --> 00:42:12.220
So if you're kind of interested in getting into the nitty-gritty of what's happening under the hood with a type system, we do expose something you can import and use in your code to do some of those things.

00:42:12.360 --> 00:42:18.300
It's a little different, but it's sort of vaguely at the intersection of importing something.

00:42:18.360 --> 00:42:18.460
In

00:42:18.460 --> 00:42:52.420
terms of plugins, I think, at least on the type checker side, there's sort of both philosophical and technical reasons to be pretty cautious, like philosophically on the type system side. I think we believe that there is value in having a specified and standardized type system that's the same for everybody. And so that you can have a project that's using one type checker and decide to switch to another one. And we don't really want to have, so plugins are kind of antithetical to that in the sense that if you have a plugin, it's clearly specific to one type checker. And then if you're relying on that plugin, well, then that's kind of a barrier to be able to switch to a different type checker.

00:42:52.870 --> 00:43:04.640
And so I think we have a preference for having, if there's patterns that people need, we should find a way to include those in the typing specification so that all type checkers implement them rather than having them in a plugin.

00:43:05.080 --> 00:43:10.460
And on the technical level, it's, I think, difficult for us just because what language do people write their plugins in?

00:43:10.980 --> 00:43:13.500
If it's, I mean, is it like a shared library?

00:43:13.680 --> 00:43:18.100
If it's written in Python or Lua or something, then potentially we lose a lot of the speed.

00:43:18.720 --> 00:43:22.120
So I think there's a few different reasons that we are hesitant to do that.

00:43:22.240 --> 00:43:23.520
Let's play around a little bit here.

00:43:24.239 --> 00:43:32.020
So over at types.rought.rs, you actually have a type checker in your browser, I guess, that you can play with.

00:43:32.500 --> 00:43:33.340
First of all, how does this run?

00:43:33.400 --> 00:43:34.160
Is this WebAssembly?

00:43:34.640 --> 00:43:35.700
Is this the server-side thing?

00:43:35.820 --> 00:43:36.100
What's happening?

00:43:36.460 --> 00:43:39.100
This is TY's Rust code compiled to WASM.

00:43:39.460 --> 00:43:41.740
So it's literally ty running in your browser.

00:43:42.160 --> 00:43:44.260
It also makes it very fast in your browser, which is nice.

00:43:44.360 --> 00:43:47.420
What if I go over here and I put like a 7 or something?

00:43:47.820 --> 00:43:48.800
I don't know what's going to happen.

00:43:49.040 --> 00:43:50.220
That's testing against 7.

00:43:50.380 --> 00:43:51.780
But I'm going to make it.

00:43:52.020 --> 00:43:52.660
Moment of truth

00:43:52.660 --> 00:43:52.880
here.

00:43:53.100 --> 00:43:55.520
It came up as a literal of seven, which I don't want.

00:43:55.620 --> 00:44:00.480
I saw somebody in the chat was asking about inlay type hints, and I was going to point out that they exist right here.

00:44:01.250 --> 00:44:03.980
As soon as you type that in, it gave you a little inlay showing the type.

00:44:04.140 --> 00:44:04.800
Define what that is.

00:44:04.920 --> 00:44:06.880
So if I type like style.

00:44:07.200 --> 00:44:07.340
So

00:44:07.340 --> 00:44:09.000
like if you type style equals seven there.

00:44:09.360 --> 00:44:10.100
Not the dot.

00:44:10.740 --> 00:44:13.060
So you didn't type colon literal seven.

00:44:13.110 --> 00:44:14.680
You didn't put any type annotation there.

00:44:15.020 --> 00:44:18.680
We're just putting an inlay right into your code to show you that that's what we understand the type to be.

00:44:18.780 --> 00:44:19.020
I see.

00:44:19.160 --> 00:44:23.660
So this is not actually in the code, but the editor sort of deal displays it.

00:44:23.700 --> 00:44:23.880
It's

00:44:23.880 --> 00:44:27.660
showing you the type that the type checker inferred despite the lack of annotations.

00:44:27.860 --> 00:44:30.240
And you could put style colon int, for example.

00:44:30.780 --> 00:44:32.620
Even up there, you could put something.

00:44:33.080 --> 00:44:33.480
I don't know.

00:44:33.680 --> 00:44:34.400
Maybe put an int.

00:44:34.680 --> 00:44:35.040
Yeah, yeah.

00:44:35.120 --> 00:44:37.260
If I put appears, like you always have a type.

00:44:37.280 --> 00:44:38.420
So I'll put this as a style.

00:44:38.560 --> 00:44:39.220
I'll do it like that.

00:44:39.260 --> 00:44:39.640
There we go.

00:44:39.740 --> 00:44:40.760
Now I'm getting my warning.

00:44:41.260 --> 00:44:41.780
There we go.

00:44:42.100 --> 00:44:43.000
That's what I was expecting.

00:44:43.520 --> 00:44:44.780
So I can just play around here.

00:44:45.140 --> 00:44:46.340
Yeah, and then you also have an error

00:44:46.340 --> 00:44:47.140
there on the bottom,

00:44:47.420 --> 00:44:47.540
right?

00:44:48.320 --> 00:44:49.560
because online 24,

00:44:50.000 --> 00:44:51.440
because you're passing the string in.

00:44:51.780 --> 00:44:52.020
Yeah,

00:44:52.200 --> 00:44:55.160
you pass in underlined, but the real value is underlined.

00:44:55.300 --> 00:44:59.380
Yeah, so I'll be sure to put this in the show notes and people can go to the playground and play around.

00:45:00.020 --> 00:45:02.600
So you also got your not.json.

00:45:02.640 --> 00:45:05.380
You can specify your Python version and rules can be warnings.

00:45:05.880 --> 00:45:15.580
Yeah, and like Charlie said, that's actually specific to the web playground in the terminal, I mean, outside of the playground context, that would be a toml file, not a JSON file.

00:45:15.880 --> 00:45:16.120
Yeah.

00:45:16.340 --> 00:45:18.640
We spent a lot of time up front.

00:45:19.170 --> 00:45:19.500
Thank you.

00:45:19.650 --> 00:45:20.520
Yeah, perfect for this

00:45:20.520 --> 00:45:21.080
screenshot.

00:45:21.280 --> 00:45:21.480
Perfect.

00:45:21.800 --> 00:45:30.960
We spent a lot of time up front, which makes sense, but really on the architecture and the core design of how should this all work.

00:45:31.500 --> 00:45:36.040
And we wanted to build, we had some fairly specific design goals.

00:45:36.340 --> 00:45:39.800
We wanted to build a type checker that could power a language server.

00:45:40.070 --> 00:45:43.120
I would say that was the first thing that we were trying to do.

00:45:43.510 --> 00:46:38.520
And that imposes some pretty specific, I don't know about constraints, but it really informs like kind of how you build it. Because if you think about a language server, like what happens is you open up your editor, and you open up like a file, okay, to understand like what's happening in that file, you don't necessarily have to like, look at everything in the editor, like every other file in the project, like you should be able to like quickly give people some analysis and some information just based on looking at like the current scope, and then like the things that imports, right? And kind of like figuring out like, what do I need to look at in order to answer these questions? And the thing that you also want is that if the user like edits that file, you don't want to have to reanalyze like the whole world. You want to reanalyze basically as little as possible, like maybe that file and like anything that's affected by it, et cetera, et cetera. So to like, to just like sit in a terminal and like check the types of a program is like one problem.

00:46:38.940 --> 00:46:50.460
But building a language server is pretty different because what's happening is things are changing in real time and you want to be able to do like the minimal amount of analysis at all times to like get people the answers to the questions that they're implicitly asking.

00:46:50.700 --> 00:46:53.340
Right. That's a per keystroke thing rather than I run a command.

00:46:53.540 --> 00:46:53.920
From

00:46:53.920 --> 00:47:12.000
that perspective, we needed the whole thing to be highly, I mean, the word we would use is incremental. So we're incrementally pulling in more context. Or if the user makes an edit to a file, we're recomputing just incrementally the things that might have changed and to update our view of the world.

00:47:12.340 --> 00:47:14.280
So that informed a lot of the design.

00:47:14.400 --> 00:47:26.180
The fact that we wanted this not only to work as a standalone tool that you run on the command line and CI, but also could power this language server experience, that ended up informing a lot of how we approached the design.

00:47:26.600 --> 00:47:30.320
And we spent a lot of time trying to get that right and give us a good foundation for building that.

00:47:30.440 --> 00:47:35.620
So does it do progressive stuff if there's some huge code base and it makes some changes?

00:47:35.900 --> 00:47:39.880
Will it try to give you answers sooner than it reanalyzed everything?

00:47:39.920 --> 00:47:40.620
Yeah,

00:47:40.710 --> 00:47:50.440
so if you're checking a very big code base or a code base that, say, has a lot of big third-party dependencies, whichever files you actually ask us to check, we'll check that whole file.

00:47:51.010 --> 00:48:02.400
And then each individual thing that it imports, like say you import one little constant that's just like a string or something from a massive third-party file that has a whole bunch of stuff in it.

00:48:02.460 --> 00:48:27.960
we will literally ignore all of that file and just go straight to the one like constant the definition of that one constant that you actually imported and we'll just look at that and so that we've seen that that makes i mean it's good obviously for being incremental when you make changes but that also just gives a big speed up for just the initial cold check of a project because we're able to just ignore all the things that you aren't using that might be sitting there

00:48:27.970 --> 00:48:32.620
in your dependencies i mean a little like tree shaking css or whatever like i know it's there but these things don't matter.

00:48:32.820 --> 00:48:34.640
We're just going to look at the things you're actually touching.

00:48:34.700 --> 00:48:34.920
It's like,

00:48:35.000 --> 00:48:37.980
let's figure out exactly what we need to look at and then like go just do that work.

00:48:38.240 --> 00:48:38.740
A

00:48:38.740 --> 00:48:53.180
lot of how we power that is through a library called Salsa, which this is getting a little bit into the weeds of Rust, but it's also powers the Rust Analyzer, the Rust language server that I mentioned before is also powered by Salsa.

00:48:54.260 --> 00:49:01.360
So we've been collaborating like with the Salsa team basically since the start of this project saying like, hey, like we really want to use this.

00:49:01.760 --> 00:49:05.100
And like, here are things that we really would need and like, blah, blah.

00:49:05.340 --> 00:49:15.540
And we've actually spent, I mean, I shouldn't speak for the team because I've done basically zero work here, but like we've been contributing back to Salsa and like investing a lot in making Salsa better.

00:49:15.720 --> 00:49:22.180
So, and also learning from Salsa and learning from like Nico Matsakis and like the people who work on REST Analyzer and everyone else.

00:49:22.340 --> 00:49:30.440
So it's been cool to kind of like have this community of people who cared about building language servers or other things that rely on highly incremental computation.

00:49:31.060 --> 00:49:41.060
And that's been a big part of actually like the design and building of the type checker has been the choice to use Salsa and then our investments like back in it to try and improve it in different ways that are important to us.

00:49:41.500 --> 00:49:43.760
But Carl can speak to that much better, that process at least.

00:49:43.940 --> 00:49:44.080
Yeah,

00:49:44.080 --> 00:49:45.240
I don't know if I have a lot to add to that.

00:49:45.360 --> 00:49:56.900
I mean, I think the cool thing about Salsa and about building on top of Salsa is that it provides a very kind of abstracted general framework for incremental computation is what it's called.

00:49:57.160 --> 00:50:06.740
So like you basically define your program or your type checker in our case as a bunch of queries and every query should have an output based on only on its input.

00:50:07.020 --> 00:50:08.640
So it should be deterministic, right?

00:50:09.050 --> 00:50:13.700
So like a query could be something like given the input is this assignment statement.

00:50:14.230 --> 00:50:18.420
The output is what is the type that was assigned to the variable in that statement.

00:50:19.140 --> 00:50:22.640
And so we kind of build up the entire program in terms of those queries.

00:50:23.100 --> 00:50:32.160
And we can kind of build it ignoring the whole incrementality problem, like the idea that one thing might change and we don't want to analyze a bunch of stuff unnecessarily.

00:50:32.760 --> 00:50:34.820
And Salsa just handles that for us automatically.

00:50:35.340 --> 00:50:48.280
So if we build in terms of all of these queries, Salsa will automatically track when we're doing our initial type check of everything, which queries depended on which other queries and ultimately depended on like which file contents.

00:50:49.080 --> 00:51:02.100
And so then if you just change one part of one file, Salsa can just flow that change through the graph of queries and figure out exactly which queries may have been affected and need to re-execute, and all the others can just be left alone.

00:51:02.800 --> 00:51:11.200
So it allows us to kind of have that level of very fine-grained incrementality without really having to think a lot about it as we're building the type checker.

00:51:11.320 --> 00:51:12.500
It's honestly like super cool.

00:51:12.660 --> 00:51:16.080
Yeah, it sounds like a reactive sort of data structure almost.

00:51:16.640 --> 00:51:18.140
You know, it just keeps itself in sync.

00:51:18.300 --> 00:51:18.560
That's cool.

00:51:18.940 --> 00:51:21.700
I do want to talk about the roadmap a little bit here.

00:51:21.840 --> 00:51:25.460
And by way of introduction there, I'll ask a question from Islam here.

00:51:25.480 --> 00:51:27.660
It says, is there a date for the release of this?

00:51:27.980 --> 00:51:28.480
You know what, Carl?

00:51:28.560 --> 00:51:31.620
I give you that one in your hands.

00:51:33.860 --> 00:51:34.280
Well, thank you.

00:51:34.860 --> 00:51:36.880
It depends what you mean by the release.

00:51:37.600 --> 00:51:50.120
I think we are targeting a sort of general availability release where we really feel like this is ready to be used in production and could be, you can swap out mypyrePyrite for it.

00:51:50.920 --> 00:51:54.100
And we're targeting that for sometime later this year, probably in the fall sometime.

00:51:54.940 --> 00:51:56.860
We don't have a solid date on that yet.

00:51:57.620 --> 00:52:04.520
We are aiming for an initial, what we would call maybe an early experimental preview alpha release.

00:52:05.980 --> 00:52:06.540
And we're aiming...

00:52:06.540 --> 00:52:06.980
There's a lot

00:52:06.980 --> 00:52:08.000
of good qualifiers there.

00:52:08.960 --> 00:52:13.340
I mean, there's definitely things that will be missing, like type system features that we won't have yet.

00:52:13.680 --> 00:52:15.680
and there'll be bugs, et cetera.

00:52:15.950 --> 00:52:17.020
You should expect all of that.

00:52:17.700 --> 00:52:21.880
But it's just something to sort of play with and kind of get a little flavor of what we're trying to do.

00:52:22.400 --> 00:52:28.680
And we're aiming to have that available so that you can install it by PyCon, which is coming up, I guess, May 16.

00:52:29.160 --> 00:52:30.920
So by that week, we're hoping to have something out.

00:52:31.100 --> 00:52:32.480
Yeah, a couple of weeks from right now.

00:52:32.580 --> 00:52:32.780
Yeah,

00:52:32.860 --> 00:52:34.380
that'll be a very early release.

00:52:34.920 --> 00:52:39.340
I was laughing and I made Carl answer the question because I wanted to see how exactly he would describe it.

00:52:39.560 --> 00:52:45.880
But that release, our goal there is not necessarily for people to like take it and migrate over to the tool.

00:52:46.100 --> 00:52:57.280
It's more like to kind of, it's just kind of a milestone for, we have a thing now that we can put out there and people can play around with and see like where it's strong and where it needs work.

00:52:57.400 --> 00:53:09.220
And we'll know, there'll be a long list of features that like aren't yet implemented, but it will be able to check some of your types and understand your code and it will be highly incremental and it will be very fast and et cetera, et cetera.

00:53:09.380 --> 00:53:13.960
So that'll be like a very early release, but we wanted to get something out there for people to kind of play around with.

00:53:14.200 --> 00:53:19.440
And then, yeah, from there, we'll look to do a beta a little later in the year.

00:53:19.780 --> 00:53:26.180
And the framing there will probably be something like motivated users should be able to migrate over.

00:53:26.620 --> 00:53:28.160
And then we'll do, again, we'll do a

00:53:28.160 --> 00:53:28.240
general.

00:53:28.240 --> 00:53:29.320
If you don't mind the rough edges.

00:53:29.680 --> 00:53:30.080
Yeah, yeah.

00:53:30.560 --> 00:53:30.820
Motivated

00:53:30.820 --> 00:53:32.640
users is a phrase I like to use.

00:53:33.210 --> 00:53:34.560
So, but we want to do, yeah.

00:53:34.590 --> 00:53:41.140
I mean, hopefully we get this sort of like general available full public release a little later this year.

00:53:41.460 --> 00:53:43.140
So that's the goal that we're working towards.

00:53:43.270 --> 00:53:46.420
I know it's a vague timeline, but that's the goal that we're working towards.

00:53:46.620 --> 00:53:47.360
That's how software goes.

00:53:47.720 --> 00:53:52.140
So when you say all this stuff about timelines and things that people can try and so on, are you talking language server?

00:53:52.360 --> 00:53:53.640
Are you talking type checker?

00:53:54.140 --> 00:53:54.200
Both?

00:53:54.640 --> 00:53:55.140
We're talking both.

00:53:56.480 --> 00:53:56.600
Yeah.

00:53:56.840 --> 00:53:57.680
No sleep for Carl.

00:53:57.860 --> 00:53:58.060
Come on.

00:53:58.360 --> 00:53:59.260
Yeah, sorry, Carl.

00:54:00.100 --> 00:54:00.860
Carl, are we talking both

00:54:00.860 --> 00:54:01.060
now?

00:54:01.180 --> 00:54:01.720
Yeah, we're talking both.

00:54:01.920 --> 00:54:02.000
For

00:54:02.000 --> 00:54:12.160
the language server in particular, there's kind of a long tail of features that we want to support in the language server, just like lots of things that a great complete language server can do.

00:54:12.680 --> 00:54:24.180
And we, to start, we're very focused on like code navigation, like a smaller number of things, like being able to go to definition, being able to do auto-completion, auto-import, all that kind of stuff.

00:54:24.460 --> 00:54:33.740
So we're going to, the first versions of the language server will be very focused on a smaller number of features, like code navigation and the things that you need, in addition to the kind of diagnostics that you see on the screen.

00:54:34.160 --> 00:54:36.820
So like type errors and like things are undefined.

00:54:36.940 --> 00:54:41.960
But beyond that, the focus will be like code navigation and auto completion, auto import, those kinds of things.

00:54:42.160 --> 00:54:51.880
And I should say that for this initial preview alpha for PyCon, the focus is really on the online playground and running it on the command line on your code.

00:54:52.760 --> 00:55:01.280
The LSP support is there and it will be possible for you to try it out, but we're not going to really push that at this point because it's very early stages.

00:55:01.480 --> 00:55:06.740
So we're not going to be like releasing a VS Code extension or any other editor extensions or anything at this point yet.

00:55:06.900 --> 00:55:07.580
That'll come later.

00:55:07.760 --> 00:55:08.540
Yeah, of course.

00:55:08.920 --> 00:55:10.120
Got to build the foundation first.

00:55:10.400 --> 00:55:14.880
One of the things I was thinking about when you two were talking about, well, why does it need to be fast?

00:55:15.000 --> 00:55:17.080
Well, there's large code bases and there's the editors.

00:55:17.600 --> 00:55:24.360
Another thing that came to mind, for me at least, was thinking about continuous integration and large teams and large code bases.

00:55:24.920 --> 00:55:36.000
And soon as the time your CI takes to run outruns the gaps between check-ins, you're getting into a bad place where they fall further and further behind, right?

00:55:36.280 --> 00:55:40.340
And so certainly having a good CI story seems important.

00:55:40.680 --> 00:55:47.080
I'm guessing you guys might have thoughts about, I don't know, pre-commit hooks, CI, GitHub integration, stuff like that.

00:55:47.420 --> 00:55:48.620
I know you have that for UV, Charlie.

00:55:48.900 --> 00:55:50.860
Yeah, I mean, I think we want to have a good experience there.

00:55:51.200 --> 00:55:54.120
We want to have a lot of the similar niceties that we have for Ruff.

00:55:54.280 --> 00:55:58.760
It will like take maybe a little bit of time to get to all of them, but Ruff obviously has like a pre-commit integration.

00:55:59.160 --> 00:56:00.420
It also has a GitHub Action.

00:56:00.960 --> 00:56:05.800
And I think we'll probably provide basically all those things for ty as well, or at least that would be my expectation.

00:56:05.840 --> 00:56:45.360
we haven't built them yet but the good news is we have a lot of infrastructure that we can leverage from rough for for everything really like also even like releases and like the release pipeline like thankfully we've done all this now once arguably twice because we've done uv too although like uv doesn't have quite as many of those things because they just don't make as much sense but the good news is like we've built a lot of that infrastructure already and we've been able to leverage it for for this project i think similarly like fuzzing like we can probably leverage a lot fuzzing infrastructure that we have for rough for for this program too so the good news is we've built a static analysis tool before and so we have like things we can leverage to make that happen

00:56:45.780 --> 00:56:50.940
yeah that's cool and shout out to the uv caching github action thing that's pretty excellent yes set up uv the

00:56:50.940 --> 00:57:04.640
biggest ci feature in my mind is performance right so like we're talking to people who are today waiting 25 or 30 minutes for feedback in ci from the type checker and we want that to be 10 to 15 seconds instead of minutes.

00:57:05.040 --> 00:57:07.620
So it's looking at this point, like we're on track for that.

00:57:07.660 --> 00:57:07.800
I

00:57:07.800 --> 00:57:17.380
think it's hard for people to actually, I think people don't actually realize that, but there are Python projects out there that are taking dozens of minutes to type check.

00:57:18.020 --> 00:57:20.920
And we want to get that down to, yeah, two seconds.

00:57:21.520 --> 00:57:23.560
And so that's like, that's what we're aiming to do.

00:57:23.900 --> 00:57:29.520
And I hope, I think there will be a lot of other benefits to the type checker in the language server, even for smaller projects.

00:57:29.820 --> 00:57:31.040
That's something that we think about a lot.

00:57:31.100 --> 00:57:36.700
Again, how can we build things that are useful and interesting and powerful for products of all shapes and sizes?

00:57:37.080 --> 00:57:44.600
And I think having the language server that works in all these different editors and it's tightly integrated with the type checker that you run, I think that will be really helpful for people.

00:57:44.770 --> 00:57:46.580
I think the type inference will be really powerful.

00:57:46.840 --> 00:57:50.640
There's all these things we want to do, but the performance is a little bit of a North Star.

00:57:50.940 --> 00:57:55.540
It's like we should be building things that are orders of magnitude faster than what else

00:57:55.540 --> 00:57:55.680
is.

00:57:55.700 --> 00:57:56.280
That would be on brand.

00:57:56.820 --> 00:58:03.660
So I'm sitting here looking at this playground, and I have Python code in the browser, and you're telling me WebAssembly is checking it.

00:58:03.940 --> 00:58:09.820
So is there a way I could actually use this if I'm doing Pyodide or PyScript type of things?

00:58:10.420 --> 00:58:14.840
Do you have any expectations to worry about that, or is it just more CPython-like?

00:58:15.000 --> 00:58:21.140
I mean, the ty just operates on source code, so if it's Python source, we should be able to check it.

00:58:21.220 --> 00:58:28.100
Speaking of Pyodide, though, one cool little feature of the playground here is there should be, you see that little run arrow over on the right-hand side?

00:58:28.480 --> 00:58:34.160
That will actually, whatever code you have in the playground that you're type checking, that will run it using Pyodide.

00:58:34.960 --> 00:58:36.640
Yeah, you have to click the run button there.

00:58:37.080 --> 00:58:37.240
That's

00:58:37.240 --> 00:58:37.540
our goal.

00:58:38.900 --> 00:58:45.780
Today we have Ruff, we have the linter, we have the formatter, and we want to build a similar experience for type checking and for the editor.

00:58:46.960 --> 00:58:48.340
There'll be a lot of tie-ins with Ruff.

00:58:49.040 --> 00:58:59.380
You hint at this, but if you go to the rough issue tracker, there's a lot of issues that have been raised in rough over the years that we've now basically assigned as being part of the scope of Red

00:58:59.380 --> 00:58:59.660
Knot.

00:58:59.760 --> 00:59:04.340
What other color could you pick for the label, right? There's a GitHub label you can go and pull them all up.

00:59:04.520 --> 00:59:07.660
Yeah, sorry, part of ty, but the GitHub label is Red Knot.

00:59:07.760 --> 00:59:08.000
Only

00:59:08.000 --> 00:59:13.840
the people who were really early believers will know why the colors red are involved withty.

00:59:13.860 --> 00:59:14.280
I

00:59:14.280 --> 00:59:20.840
had a very incredible experience. I went to EuroRust in maybe in November of last year.

00:59:21.660 --> 00:59:53.560
And when I was there, I gave a talk about uv. And after the talk, a bunch of people came up to me and were like, it was a Rust conference, but a bunch of people were like, hey, like, we really like your like Python tools, like blah, blah, blah. And then I like a bunch of them just brought up and started talking to me about Redknot. And I was like, what's going on here? Because we didn't, we had not talked to anyone about that project. It's never been hidden. It's been developed in the rough repo from the start, but we didn't advertise it at all. And so it was like only like really deep rough heads knew that this was even happening. And I was like, okay, this is the degree.

00:59:53.740 --> 00:59:54.420
Incredible. We

00:59:54.420 --> 01:00:02.200
must be doing something right. Because these people just came up to me and started talking to me about a top secret public project that we haven't advertised anywhere.

01:00:03.000 --> 01:00:04.800
Hidden in plain sight. That's awesome. Yeah.

01:00:05.160 --> 01:00:14.260
We did uv in a little bit of a similar way, actually, where we had two major releases. We did the initial launch, which was all the UVPIP stuff.

01:00:14.520 --> 01:00:24.440
And then we did a bigger launch later with lock files and all this other stuff. And all that stuff was developed just in the repo. But we didn't talk about it at all until it was publicly launched.

01:00:24.800 --> 01:00:42.040
And yet we had this steady stream of people, avid users who were testing it and giving us lots of feedback over time. So that's the attitude that we've taken, I think, here too, is we just build it in public. And some people choose to get involved and choose to use it and choose to give us feedback, but we don't really advertise it until we're kind of ready to unleash it to the world.

01:00:42.160 --> 01:00:50.580
I guess this is a little bit of an exception, but we'll have our early experimental alpha preview release in a couple of weeks and then it will be released to the world.

01:00:50.700 --> 01:01:00.100
Let's do a final call to action. People who maybe didn't know about it before, but now they do. Pretty excited. They might want to give you feedback or try it out or whatever. What are you telling them? If

01:01:00.100 --> 01:01:21.820
you're highly motivated, you could go clone the rough repo and build the experimental Red Knot codename binary and run that on your project and see what works. But if you're not incredibly motivated, then you should wait several weeks and we'll have something for you that I think will be a lot more useful.

01:01:22.060 --> 01:01:29.500
Type.rough.rs and play around with it in your web browser. That's the least motivated thing you could probably do. Thank you both for being here and

01:01:29.500 --> 01:01:41.560
congratulations on all the projects and cranking out and the continued work. And we didn't even get to talk about an update with Python Build standalone, but thanks for that as well. It makes a lot of things really great.

01:01:41.740 --> 01:01:51.680
This is what we love to do. We love to build stuff that hopefully people like to use as the ambitious slogan for our approach to tooling. Hopefully people like to use it.

01:01:51.780 --> 01:01:55.040
Yeah, they'll say thank you every time they run it, every time they check their code, right?

01:01:55.700 --> 01:01:56.960
Yeah, well,

01:01:57.140 --> 01:01:57.940
thanks so much for having us on.

01:01:58.080 --> 01:01:58.900
It's always a pleasure.

01:01:59.260 --> 01:02:04.460
And yeah, well, I think this stuff's going to be launching in the next few weeks and months.

01:02:04.890 --> 01:02:05.720
And so stay tuned.

01:02:05.920 --> 01:02:06.240
Thanks, guys.

01:02:06.820 --> 01:02:07.020
See you later.

01:02:07.280 --> 01:02:07.440
Thank you.

01:02:07.660 --> 01:02:07.740
Thanks.

01:02:10.700 --> 01:02:13.060
This has been another episode of Talk Python to Me.

01:02:13.900 --> 01:02:14.820
Thank you to our sponsors.

01:02:15.310 --> 01:02:16.520
Be sure to check out what they're offering.

01:02:16.700 --> 01:02:17.940
It really helps support the show.

01:02:18.900 --> 01:02:22.560
This episode is sponsored by Posit Connect from the makers of Shiny.

01:02:23.040 --> 01:03:19.780
Publish, share, and deploy all of your data projects you're creating using Python. Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto, Reports, Dashboards, and APIs. Posit Connect supports all of them. Try Posit Connect for free by going to talkpython.fm/posit, P-O-S-I-T. And it's brought to you by Auth0. Auth0 is an easy to implement adaptable authentication and authorization platform. Think easy user login, social sign-on, multi-factor authentication, and robust role-based access control. With over 30 SDKs and quick starts, Auth0 scales with your product at every stage. Get 25,000 monthly active users for free at talkpython.fm/auth0. Want to level up your Python? We have one of the largest catalogs of Python video courses over at Talk Python. Our content ranges from true beginners to deeply advanced topics like memory and async.

01:03:20.240 --> 01:03:22.320
And best of all, there's not a subscription in sight.

01:03:22.830 --> 01:03:25.320
Check it out for yourself at training.talkpython.fm.

01:03:26.020 --> 01:03:30.200
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

01:03:30.650 --> 01:03:31.540
We should be right at the top.

01:03:32.040 --> 01:03:40.900
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

01:03:41.560 --> 01:03:43.800
We're live streaming most of our recordings these days.

01:03:44.180 --> 01:03:51.640
If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:03:52.660 --> 01:03:53.780
This is your host, Michael Kennedy.

01:03:54.200 --> 01:03:55.060
Thanks so much for listening.

01:03:55.240 --> 01:03:56.180
I really appreciate it.

01:03:56.500 --> 01:03:58.140
Now get out there and write some Python code.

