WEBVTT

00:00:00.001 --> 00:00:04.340
Every year, the PSF and JetBrains team up to do a Python community survey.

00:00:04.340 --> 00:00:10.660
The most recent one was fall of 2021. For this episode, I've gathered a great group of Python

00:00:10.660 --> 00:00:15.920
enthusiasts to discuss the results. I think you'll really enjoy the group discussion on this episode.

00:00:15.920 --> 00:00:21.680
You have Gina Houska, Emily Morehouse, Tanya Sims, Brett Cannon, Jay Miller, and Paul Everett

00:00:21.680 --> 00:00:28.980
here to help us with the episode. This is Talk Python To Me, episode 374, recorded June 30th,

00:00:28.980 --> 00:00:47.360
2022. Welcome to Talk Python To Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:47.360 --> 00:00:52.020
Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes

00:00:52.020 --> 00:00:58.400
at talkpython.fm and follow the show on Twitter via at talkpython. We've started streaming most

00:00:58.400 --> 00:01:03.300
of our episodes live on YouTube. Subscribe to our YouTube channel over at talkpython.fm

00:01:03.300 --> 00:01:07.820
slash YouTube to get notified about upcoming shows and be part of that episode.

00:01:07.820 --> 00:01:14.280
This episode is brought to you by Sentry and their awesome error monitoring product, and it's brought

00:01:14.280 --> 00:01:20.160
to you by Compiler from Red Hat. Listen to an episode of their podcast as they demystify the tech industry

00:01:20.160 --> 00:01:26.360
over at talkpython.fm/compiler. Transcripts for this and all of our episodes are brought to you by

00:01:26.360 --> 00:01:31.820
assembly.ai. Do you need a great automatic speech to text API? Get human level accuracy in just a few

00:01:31.820 --> 00:01:35.200
lines of code. Visit talkpython.fm/assembly.ai.

00:01:36.880 --> 00:01:41.940
Brett, Jay, Tanya, Emily, Paul, and Gina, welcome all of you to Talk Python To Me.

00:01:41.940 --> 00:01:42.420
Thanks, Michael.

00:01:42.420 --> 00:01:42.920
Hey, everyone.

00:01:42.920 --> 00:01:43.240
Hey.

00:01:43.240 --> 00:01:43.540
Hello.

00:01:43.540 --> 00:01:49.420
It's really great to have you here. I'm super excited to have a conversation around the whole

00:01:49.420 --> 00:01:55.520
community of Python survey results. Thank you to the PSF and JetBrains for putting the survey

00:01:55.520 --> 00:02:00.520
together. Thank you all for being here. And I want to invite a bunch of you so that we could have a bunch

00:02:00.520 --> 00:02:05.980
of different perspectives and thoughts and ideas on where we are. So that's going to be so much fun.

00:02:05.980 --> 00:02:12.260
But let's do a quick round of introductions. Brett, open source contributor extraordinaire.

00:02:12.260 --> 00:02:19.400
So my name is Brett Cannon. I'm in charge of the Python experience for VS Code. I'm also a core

00:02:19.400 --> 00:02:23.920
developer for 19 years now. I'm a member of the Python Steering Council since its founding,

00:02:24.180 --> 00:02:29.300
and I'm calling from Vancouver on the unceded territory of the Squamish, Musqueam, and Tsleil-Waututh

00:02:29.300 --> 00:02:29.780
First Nation.

00:02:29.780 --> 00:02:33.580
All right. Great to have you here. Thanks for all the Python things you've done. Jay.

00:02:33.580 --> 00:02:38.900
Yeah. I'm Jay Miller. I'm a senior cloud advocate at Microsoft. I work with our Python advocates.

00:02:38.900 --> 00:02:46.440
And yeah, it's my job to keep Brett looking so amazing. Or at least talk about the amazing stuff he's

00:02:46.440 --> 00:02:46.600
done.

00:02:46.600 --> 00:02:48.500
That's right. Spread the word.

00:02:48.500 --> 00:02:49.260
Tanya.

00:02:49.260 --> 00:02:53.720
Hey, everyone. My name is Tanya. I'm currently a Python developer advocate at

00:02:53.720 --> 00:03:00.340
Deepgram. We're an AI speech-to-text company. So before I got into Python, I was a professional

00:03:00.340 --> 00:03:04.500
athlete. So I'm like a pro athlete, turned, worked in sales for a little bit, and then

00:03:04.500 --> 00:03:07.260
gotten the tech after. But thanks for having me today. It's good to be here.

00:03:07.260 --> 00:03:10.900
It's great to have you. And I love your story because it shows you don't have to just grow

00:03:10.900 --> 00:03:15.320
up doing code from a young age to be really great at this and how fun it must have been

00:03:15.320 --> 00:03:16.520
to be a pro athlete. So cool.

00:03:16.520 --> 00:03:16.980
Thank you.

00:03:16.980 --> 00:03:19.240
Yeah. Emily, great to have you here.

00:03:19.240 --> 00:03:23.260
Yeah, absolutely. Hi, I'm Emily. I am the director of engineering at

00:03:23.260 --> 00:03:29.000
at a software consultancy called Cuddlesoft. I'm also a CPython core developer and the

00:03:29.000 --> 00:03:32.040
recovering PyCon US chair from the last three years.

00:03:32.040 --> 00:03:36.380
Yeah, great work. It sounded like people I talked to had a wonderful time there. So

00:03:36.380 --> 00:03:39.180
good job on PyCon. Paul, nice to have you back.

00:03:39.180 --> 00:03:47.240
Hi, everybody. I'm Paul Everett, developer advocate at JetBrains, a teller of semi-true stories

00:03:47.240 --> 00:03:53.700
of Python history and really happy to be with the six of you. This is a cool panel.

00:03:53.820 --> 00:03:59.100
Yeah, I'm happy to have you here. It is a cool panel. Gina, you were not too long ago on Python

00:03:59.100 --> 00:04:03.180
Bytes, as was Tanya as well. But it's great to have you over here on Talk Python.

00:04:03.180 --> 00:04:08.140
Yeah, thank you for having me. Yeah. So my name is Gina Huiske. I'm the creator and maintainer

00:04:08.140 --> 00:04:12.640
of something called Octoprint, which is the snappy web interface for your 3D printer and which is

00:04:12.640 --> 00:04:15.360
written at Python, which is why I'm here, I guess. So hi.

00:04:15.360 --> 00:04:21.500
Hi. And people who are not watching, I think you've got just the coolest office setup. You've

00:04:21.500 --> 00:04:26.400
got your laser cutter and 3D printer and stuff that you've created with your your makerspace

00:04:26.400 --> 00:04:30.180
that set up a really nice camera AV setup. So it's fantastic.

00:04:30.180 --> 00:04:31.060
And a three headed monkey.

00:04:31.060 --> 00:04:32.560
And a three headed monkey, of course.

00:04:32.560 --> 00:04:33.880
Right behind you.

00:04:33.880 --> 00:04:39.780
I love it. All right. Paul, do you want to maybe say a few things about the relationship

00:04:39.780 --> 00:04:45.640
of the PSF and JetBrains and sort of a little bit of background in the survey to just maybe

00:04:45.640 --> 00:04:50.480
introduce a virtual quick since JetBrains was part of it? If I go and look at the results

00:04:50.480 --> 00:04:55.580
here when we get to them, it's at jetbrains.com. But it's not really a JetBrains survey, is it?

00:04:55.580 --> 00:05:00.620
No, not at all. It's interesting. When I was doing the prep for this, I was like, how far back

00:05:00.620 --> 00:05:06.600
does this go? Damn, this thing goes back to 2016. Wow. Which is interesting to see some changes

00:05:06.600 --> 00:05:12.460
over time. But this was kind of a brainchild back then. Well, we got a need. Python has a

00:05:12.460 --> 00:05:17.800
need. Let's do it together. But then it kind of turned into PSF steering the ship and JetBrains

00:05:17.800 --> 00:05:24.460
just doing what it was told for. Conducting the survey, doing a little bit of throwing smart

00:05:24.460 --> 00:05:30.640
brains at it from our research folks to do statistical validity, trying to add new questions, but preserve

00:05:30.640 --> 00:05:36.560
old ones so that we could see trends over time. So this is now the PSF survey. And I think that's

00:05:36.560 --> 00:05:41.940
a great resource because we all have these questions, right? Yeah. Yeah, we absolutely do. And one of the

00:05:41.940 --> 00:05:47.840
things I remember when I was reading about it is it wasn't conducted on the JetBrains site. This was on

00:05:47.840 --> 00:05:54.200
python.org, right? Yeah. It's hard because it can feel like, well, it becomes a selection bias because

00:05:54.200 --> 00:05:58.960
it's affiliated with JetBrains. And so over the years, we've really tried to turn this into kind of a

00:05:58.960 --> 00:06:04.920
contribution to the community. Let the PSF kind of dictate what it wants to see and how things should

00:06:04.920 --> 00:06:09.420
be organized and conducted. Yeah. Yeah. Brett or Emily, anything you want to add to that since

00:06:09.420 --> 00:06:14.220
you're a little bit on the inside? No, I mean, Paul nailed it on the head. It's a great partnership

00:06:14.220 --> 00:06:19.780
between the PSF and JetBrains. Like, as I said, it's mainly questions coming from the PSF and the JetBrains.

00:06:19.780 --> 00:06:25.880
Folk happened to help do it. Make the Spiffy website with the awesome cookie policy pop up in the

00:06:25.880 --> 00:06:28.840
corner. I still think you all have the best one in the industry. Yes. You could

00:06:28.840 --> 00:06:32.380
type in it. It's a console, right? Yeah. That's pretty cool. We can talk about it later,

00:06:32.380 --> 00:06:35.560
but like the development residence questions, for instance, all came straight from Wukash.

00:06:35.560 --> 00:06:40.460
And it's basically asked Wukash to come up with those and such. So it's great collaboration.

00:06:40.460 --> 00:06:47.500
Yeah, absolutely. Cool. All right. Let's, I'm going to pull this up here. And for folks who want to

00:06:47.500 --> 00:06:51.720
check it out, obviously there's not going to be probably that many links in the show notes,

00:06:51.720 --> 00:06:59.100
but there's the one, the one important one, which is the Python developer survey 2021 results. So

00:06:59.100 --> 00:07:04.980
one thing to keep in mind as we talk about this is it's a bit of a historical look a little bit. So

00:07:04.980 --> 00:07:12.080
this was conducted in the fall of 2021. And here we are in the summer of 2022. So for example,

00:07:12.080 --> 00:07:16.600
there's questions about Python 310, right? I'm sure the adoption is higher of that now than it was,

00:07:16.600 --> 00:07:22.560
was that eight months, seven months ago, something like that. So keep that in mind. And so, yeah,

00:07:22.560 --> 00:07:26.980
what do we want to say that actually links back to the previous results as well, which is really good.

00:07:26.980 --> 00:07:31.160
I went through a bunch of different areas. And so I think the first, we're just going to go through it

00:07:31.160 --> 00:07:36.860
in order and maybe skip some that are not, you know, maybe too detailed or something. But the first one

00:07:36.860 --> 00:07:45.080
is, are you a Python developer or are you a developer that also happens to use Python? And for the people

00:07:45.080 --> 00:07:49.160
who took the survey, you know, granted, they're going to python.org to see this, or they were

00:07:49.160 --> 00:07:55.240
encouraged on Twitter from Python people to go take the survey. And it's 84% of the people are using

00:07:55.240 --> 00:08:00.780
Python as their main language. I personally think that's pretty high. I think that's, that's a pretty

00:08:00.780 --> 00:08:03.440
positive number here. What do you all think?

00:08:03.440 --> 00:08:07.660
I'd be curious what the bias is. Like, I wonder what would happen if this made the front of Hacker News

00:08:07.660 --> 00:08:13.880
and what this number would then be. Because for instance, I know plenty of people who complain at

00:08:13.880 --> 00:08:18.620
me at work about why is this Python stuff kicking up? I only use this script every two months kind of

00:08:18.620 --> 00:08:24.940
thing. So I know lots of ancillary uses of Python all over the world. So I'd be really curious.

00:08:24.940 --> 00:08:30.540
Obviously, this does not really represent the world itself. So I think it just at least helps set a

00:08:30.540 --> 00:08:36.460
guideline as it is, as it were, as to how to view these results more than an actual number we can rely

00:08:36.460 --> 00:08:38.280
on for the overall computing world.

00:08:38.280 --> 00:08:42.440
Yeah, I think it's interesting, because if I remember correctly, this question was sort of a

00:08:42.440 --> 00:08:49.880
self-selection of how you identify. So I definitely say like, yeah, I am a Python developer. But if I am

00:08:49.880 --> 00:08:55.120
realistic about the actual code that I'm writing on a daily basis, I'm definitely not like primarily

00:08:55.120 --> 00:09:01.440
writing Python. So I think that this really sort of frames the perspective of the person filling out

00:09:01.440 --> 00:09:06.860
the survey to say like, yes, Python is my main language of choice in whatever way that might be,

00:09:06.860 --> 00:09:09.940
but it might not actually be the thing that they're writing the most code for.

00:09:09.940 --> 00:09:15.720
Sure. I'd like to hear your thoughts of this from everyone. But my view of the Python world

00:09:15.720 --> 00:09:21.760
is it basically breaks into three pieces. We've got the web developer, web API sort of folks.

00:09:22.160 --> 00:09:29.520
We've got the data scientists, and we have this massive other, you know, scientists, economists,

00:09:29.520 --> 00:09:37.340
maker folks, programming little devices. And it seems to me that the first two, the web and the

00:09:37.340 --> 00:09:43.360
data science would probably really be the main, right? They would just live in Python. But that other

00:09:43.360 --> 00:09:48.600
group, they might drop into Python to just, oh, I heard there's this library, and it'll give me this

00:09:48.600 --> 00:09:51.600
picture that I need and then go back to whatever they were doing, something like that.

00:09:51.600 --> 00:09:56.020
Yeah, I guess too. Like I was, that actually made me think about like, like when you were collecting the

00:09:56.020 --> 00:10:01.620
survey results for this one, like what levels, like, did you ask like what level they were at? Like

00:10:01.620 --> 00:10:06.500
maybe more junior, senior, mid-level? Because I feel like maybe someone maybe just starting out in Python,

00:10:06.500 --> 00:10:11.040
you know, maybe that's like their own, like their main language that they're using versus someone who's

00:10:11.040 --> 00:10:15.700
more senior or more experienced. Maybe they were using, you know, secondary languages as well.

00:10:15.700 --> 00:10:20.720
Yeah, that's a very good observation. There's a section on the how junior or senior people are,

00:10:20.720 --> 00:10:25.680
which I think is pretty interesting. Jay, you're, you've been doing some of the developer

00:10:25.680 --> 00:10:29.420
relationship stuff. You probably got to think about this sort of breakdown a lot. What are your thoughts?

00:10:29.540 --> 00:10:37.880
I do. And my history comes from being a tinker slash automator. So often had to use whatever tools

00:10:37.880 --> 00:10:46.520
I was told to use and find ways to inject Python into it. What I'm glad to see is now, I think that's

00:10:46.520 --> 00:10:52.300
the case for most people. Like you said, that is that, that bubble that the Python community is vastly

00:10:52.300 --> 00:10:58.180
growing in of people who are, I'm using Python to do this thing in my job that isn't as a developer.

00:10:58.180 --> 00:11:05.040
And it's nice to see that I think more and more use cases of Python are becoming available so that

00:11:05.040 --> 00:11:11.100
I don't have to go reach for whatever the parent language is in my project. I can go and just use

00:11:11.100 --> 00:11:16.060
Python for most things. I think that while a part of this is, you know, we're looking at this data set

00:11:16.060 --> 00:11:20.300
as people who love Python, wanting to come in and talk about Python and share their thoughts and

00:11:20.300 --> 00:11:27.460
feelings about it. But I also recognize that had you asked me this very question three years ago,

00:11:27.460 --> 00:11:32.220
I would have had to give a different answer. So yeah, I think that it's great that that number can

00:11:32.220 --> 00:11:36.260
go up because of the growth of Python from a technical standpoint.

00:11:36.260 --> 00:11:37.760
Yeah, great point. Gina?

00:11:37.760 --> 00:11:43.160
Yeah, that pretty much mirrors what I was about to say, because when I started with Python, when I

00:11:43.160 --> 00:11:49.000
got the first time into touch with it, that must have been sometime around 2007,

00:11:49.660 --> 00:11:56.820
2008-ish. So a really long time ago when I actually was still a system administrator at university in the

00:11:56.820 --> 00:12:03.620
computer science department. And I used Python to automate some stuff like maintenance things and

00:12:03.620 --> 00:12:10.660
bookkeeping and whatnot. So I distinctly remember writing a label tool for the backup drives. And back

00:12:10.660 --> 00:12:14.940
then, if you had asked me this question, I would certainly not have said I'm a Python programmer. And I'm not

00:12:14.940 --> 00:12:22.100
even sure I would have said that Python is my secondary language because it would probably rather have been my tertiary or whatever the word is for forces.

00:12:22.100 --> 00:12:47.060
And even 10 years ago, I would still have identified as a Java developer with maybe a bit of background in Python and a lot of JavaScript, HTML, CSS, and Bash stuff thrown in. But these days, yeah, I've also moved to someone who would call themselves a Python developer. And I kind of find it funny that apparently many more people have made the same transition over the years. That is kind of amazing to see.

00:12:47.060 --> 00:13:03.940
Yeah, there's definitely a large influx of people moving in. So related to that, you said you had done Java. And actually, right now I'm working on Dart. I'm trying to maybe do some Flutter mobile app stuff to augment our courses and whatnot. And there's, you know, it's,

00:13:04.220 --> 00:13:23.820
Tanya had a great point where she said, you know, the more junior you are, you might just be learning one language now. But then as you grow, you're like, well, I really need to learn this other language to do this thing. So the next question was, well, what are you using in addition to your Python code, regardless of whether it's your primary or second? You know, are you doing JavaScript?

00:13:24.220 --> 00:13:47.220
Do you in HTML? Are you doing C#? Or Rust? Or Go? And I think these questions are, they're always really hard to pick. Because for example, HTML and CSS, that seems like a valid question. But on the other hand, it's not really a standalone programming language. Like no one would introduce themselves like, hey, I'm Michael. I'm a CSS developer, full stack, by the way.

00:13:47.220 --> 00:14:17.200
You know, it's so should it really be a thing that pairs with that or not? It's a tricky for me to decide. But for that question, the most paired up language is JavaScript, and then HTML and CSS. And then we've got, you know, sort of to genius point, bash or shell scripting and SQL. I guess if you look at programming languages, we probably have JavaScript, and then C++, and then Java, and then C#. This is pretty interesting what people pair it with. I think you got to, you know, I talked about the third of sort of web developer side.

00:14:17.200 --> 00:14:26.200
That clearly is the 40-30% of, you know, JavaScript and HTML. And then I think it gets pretty interesting. What stands out to everyone here?

00:14:47.180 --> 00:14:49.460
and may not quite view themselves as Python developers,

00:14:49.460 --> 00:14:50.900
even though they are, right?

00:14:50.900 --> 00:14:52.720
And I think this kind of plays into that

00:14:52.720 --> 00:14:54.100
with the whole JavaScript, HTML, CSS,

00:14:54.100 --> 00:14:56.040
covering that web group and then Bash shell

00:14:56.040 --> 00:14:58.380
covering that cohort.

00:14:58.380 --> 00:15:00.800
And then SQL kind of cross-cuts across web and data science.

00:15:00.800 --> 00:15:02.640
So I think it kind of is interesting.

00:15:02.640 --> 00:15:05.440
I also personally hope C++ group drops

00:15:05.440 --> 00:15:07.960
because people write more Python and less C and C++

00:15:07.960 --> 00:15:10.320
with all the performance coming in Python 3.11

00:15:10.320 --> 00:15:11.180
in the future.

00:15:11.180 --> 00:15:13.060
But that's just a personal wish.

00:15:13.060 --> 00:15:13.480
Yeah.

00:15:13.480 --> 00:15:15.400
Paul, you're pumping your fist there

00:15:15.400 --> 00:15:18.220
at some C++ being overtaken by more Python.

00:15:18.220 --> 00:15:22.220
I will start by giving the first of 20 consecutive compliments

00:15:22.220 --> 00:15:28.040
to Brett, who is reviewing WebAssembly pull requests,

00:15:28.040 --> 00:15:29.540
probably as we speak.

00:15:29.540 --> 00:15:31.900
He's got two or three other Bretts back in the back

00:15:31.900 --> 00:15:34.400
that are doing the pull request reviews.

00:15:34.400 --> 00:15:37.120
But as WebAssembly becomes a thing,

00:15:37.120 --> 00:15:40.820
then maybe Brett's mission to demolish C#

00:15:40.820 --> 00:15:41.880
will take effect.

00:15:42.200 --> 00:15:45.540
I'll take exception to the HTML ain't a language.

00:15:45.540 --> 00:15:47.280
The L language.

00:15:47.280 --> 00:15:48.060
Come on.

00:15:48.060 --> 00:15:49.160
Give it some love.

00:15:49.160 --> 00:15:51.500
And Stack Overflow says it's the number one language.

00:15:51.500 --> 00:15:53.060
So maybe the only thing I'll add

00:15:53.060 --> 00:15:54.320
that was interesting to me on this

00:15:54.320 --> 00:15:56.620
is seeing the change since 2016,

00:15:56.620 --> 00:15:59.000
because this is a question that's been asked every time.

00:15:59.000 --> 00:16:00.820
Fairly stable wording on it.

00:16:00.820 --> 00:16:02.200
Hasn't changed that much.

00:16:02.200 --> 00:16:04.540
The top five are the top five.

00:16:04.540 --> 00:16:06.480
SQL has bounced around.

00:16:06.600 --> 00:16:10.580
If I remember correctly, last year it was number one ahead of JavaScript

00:16:10.580 --> 00:16:12.740
at 43% or something like that.

00:16:12.740 --> 00:16:15.620
And I kind of thought, well, that's data science kicking in.

00:16:15.620 --> 00:16:17.320
But then this year it took a little bit of a drop.

00:16:17.320 --> 00:16:19.120
Question about the makeup of this language.

00:16:19.120 --> 00:16:21.080
Was this a kind of a multiple choice thing?

00:16:21.080 --> 00:16:22.460
Or did you have to?

00:16:22.460 --> 00:16:22.720
Okay.

00:16:22.720 --> 00:16:24.820
So you could say JavaScript, HTML, dash.

00:16:24.820 --> 00:16:26.280
I remember taking the survey,

00:16:26.280 --> 00:16:28.720
but I cannot remember the question on it.

00:16:28.960 --> 00:16:29.820
Yeah, yeah.

00:16:29.820 --> 00:16:34.140
Gina, the little giveaway is that there's this 100 plus at the top,

00:16:34.140 --> 00:16:36.540
which means like people can pick more than one.

00:16:36.540 --> 00:16:37.680
Okay, okay, okay.

00:16:37.680 --> 00:16:39.900
When you see that at the top by a second, yeah.

00:16:39.900 --> 00:16:43.100
I should add that the anonymized cleaned up data sets

00:16:43.100 --> 00:16:46.740
are available for all you smart people who can do cross.

00:16:46.740 --> 00:16:51.240
If they want to do SQL against their CSV.

00:16:51.240 --> 00:16:55.080
I have tried to escape JavaScript for a while.

00:16:55.080 --> 00:16:56.900
And I just feel like I'm not able to escape it.

00:16:56.900 --> 00:16:58.360
And it's like, you know, I have, you know.

00:16:58.360 --> 00:16:59.460
There is no escape.

00:16:59.460 --> 00:17:01.000
I'm going to still escape from JavaScript.

00:17:01.000 --> 00:17:02.000
I've just given up.

00:17:02.000 --> 00:17:02.300
Yeah.

00:17:02.300 --> 00:17:04.780
I am curious to see though, how, you know,

00:17:04.780 --> 00:17:06.880
like as the development of, you know, PyScript,

00:17:06.880 --> 00:17:09.780
as it develops, like if that JavaScript number will stay the same

00:17:09.780 --> 00:17:11.840
or if it's going to like kind of drop off a little bit.

00:17:11.840 --> 00:17:14.600
And then, I mean, I know Bootstrap isn't a language.

00:17:14.600 --> 00:17:16.240
It's more of a front end framework.

00:17:16.240 --> 00:17:18.840
But, you know, this kind of made me curious, you know,

00:17:18.840 --> 00:17:21.980
like are Python developers using Bootstrap more with their applications

00:17:21.980 --> 00:17:23.300
or are they using straight JavaScript?

00:17:23.300 --> 00:17:26.600
Are they using, you know, vanilla HTML and CSS?

00:17:26.600 --> 00:17:31.300
I could imagine that React is pretty much featuring very highly there

00:17:31.300 --> 00:17:34.900
and maybe also Angular and Vue.js as well,

00:17:34.900 --> 00:17:38.480
which is also how I explain that maybe JavaScript is actually ranked up higher

00:17:38.480 --> 00:17:42.160
than HTML and CSS because if you write React in these days,

00:17:42.160 --> 00:17:44.660
you pretty much only interact with JavaScript code

00:17:44.660 --> 00:17:48.000
and you might throw snippets of stuff in there that looks like HTML

00:17:48.000 --> 00:17:49.060
but actually isn't.

00:17:49.220 --> 00:17:52.940
So people in that case would probably more identify as the JavaScript crowd

00:17:52.940 --> 00:17:54.480
or maybe the TypeScript crowd.

00:17:54.480 --> 00:17:55.520
So, yeah.

00:17:55.520 --> 00:17:57.320
Dina, do you use a lot of other languages

00:17:57.320 --> 00:18:01.260
or technologies for your devices and embedded things and so on?

00:18:01.260 --> 00:18:04.480
I used to have this thing that I try to learn a new language

00:18:04.480 --> 00:18:06.380
every other year or so,

00:18:06.380 --> 00:18:09.000
but then life happened and I haven't been up to that

00:18:09.000 --> 00:18:11.280
for the last, I don't know, 13 years or so now.

00:18:11.400 --> 00:18:13.720
I can say that in my day-to-day,

00:18:13.720 --> 00:18:18.280
I probably mostly use Python, JavaScript, Bash as well a lot.

00:18:18.280 --> 00:18:19.800
No Java anymore, thankfully.

00:18:19.800 --> 00:18:22.000
SQL here and there maybe as well,

00:18:22.000 --> 00:18:24.600
but I think that is about that.

00:18:24.600 --> 00:18:27.700
I mean, sometimes I also have to touch C or C++ code,

00:18:27.700 --> 00:18:29.560
but I try to really avoid it

00:18:29.560 --> 00:18:31.780
because I know my weaknesses,

00:18:31.780 --> 00:18:33.080
pointer arithmetics,

00:18:33.080 --> 00:18:34.860
and forgetting to free up memory,

00:18:34.860 --> 00:18:36.520
so I stay away from languages

00:18:36.520 --> 00:18:38.540
that allow to shoot myself a little too much.

00:18:38.680 --> 00:18:40.040
Yeah, even if you're good at it,

00:18:40.040 --> 00:18:42.180
it's just, it's a hassle if you can avoid it.

00:18:42.180 --> 00:18:43.480
Final thought on this one,

00:18:43.480 --> 00:18:46.220
Emily, you said you were doing other languages as well.

00:18:46.220 --> 00:18:47.740
One, being a core developer,

00:18:47.740 --> 00:18:50.980
C++ is probably something that you've got to mess with,

00:18:50.980 --> 00:18:53.320
or C rather, being CPython,

00:18:53.320 --> 00:18:55.460
but what stands out to you here?

00:18:55.460 --> 00:18:57.800
Yeah, I think that most of my contributions

00:18:57.800 --> 00:19:00.280
to CPython have been C and not Python.

00:19:00.280 --> 00:19:01.640
Yeah, I think it's interesting.

00:19:01.640 --> 00:19:03.260
I think it's very clear that web development

00:19:03.260 --> 00:19:04.500
is very much at the forefront.

00:19:04.500 --> 00:19:08.080
I think being able to sort of ingest this data

00:19:08.080 --> 00:19:10.160
and make meaning of it does get really difficult

00:19:10.160 --> 00:19:12.360
because you look at HTML, CSS,

00:19:12.360 --> 00:19:15.160
and there's so many different ways that it can be used.

00:19:15.160 --> 00:19:16.340
So it's like, oh, like,

00:19:16.340 --> 00:19:19.580
are these people writing Django or Flask applications

00:19:19.580 --> 00:19:20.960
and they're also including that?

00:19:20.960 --> 00:19:23.920
Or do they happen to be writing a React front end

00:19:23.920 --> 00:19:25.640
and are considering it in there?

00:19:25.640 --> 00:19:27.280
So I do think that that's interesting

00:19:27.280 --> 00:19:29.480
and just sort of a difficult thing

00:19:29.480 --> 00:19:31.340
to really like take that meaning out of it.

00:19:31.480 --> 00:19:36.600
But I think it's very clear that there is some section of people

00:19:36.600 --> 00:19:42.900
who are still looking for things that are more similar to Python elsewhere, right?

00:19:42.900 --> 00:19:44.360
So you can't get away from JavaScript.

00:19:44.360 --> 00:19:47.500
As we all know, there's really not a good substitution

00:19:47.500 --> 00:19:50.440
for something like HTML, CSS, if that's what you're building.

00:19:50.440 --> 00:19:52.460
But you see things in here where there's, you know,

00:19:52.460 --> 00:19:53.680
there's Go, there's Rust,

00:19:53.680 --> 00:19:55.940
things that people might be leaning towards

00:19:55.940 --> 00:19:58.260
when they need something that's a bit more performant

00:19:58.260 --> 00:19:59.640
or feeling a different need for them.

00:19:59.640 --> 00:20:01.640
I think it's interesting that those are still

00:20:01.640 --> 00:20:03.460
making a meaningful enough impact

00:20:03.460 --> 00:20:04.860
that they're making this list.

00:20:04.860 --> 00:20:07.820
And I think it will be interesting to see how this changes

00:20:07.820 --> 00:20:10.260
over the next few years with, you know,

00:20:10.260 --> 00:20:11.980
improvements of Python performance.

00:20:11.980 --> 00:20:17.120
This portion of Talk Python To Me is brought to you by Sentry.

00:20:17.120 --> 00:20:19.980
How would you like to remove a little stress from your life?

00:20:19.980 --> 00:20:22.880
Do you worry that users may be encountering errors,

00:20:22.880 --> 00:20:25.980
slowdowns, or crashes with your app right now?

00:20:26.440 --> 00:20:29.020
Would you even know it until they sent you that support email?

00:20:29.020 --> 00:20:31.240
How much better would it be to have the error

00:20:31.240 --> 00:20:33.800
or performance details immediately sent to you,

00:20:33.800 --> 00:20:36.780
including the call stack and values of local variables

00:20:36.780 --> 00:20:39.440
and the active user recorded in the report?

00:20:39.440 --> 00:20:42.840
With Sentry, this is not only possible, it's simple.

00:20:42.840 --> 00:20:46.420
In fact, we use Sentry on all the Talk Python web properties.

00:20:46.420 --> 00:20:49.640
We've actually fixed a bug triggered by a user

00:20:49.640 --> 00:20:51.620
and had the upgrade ready to roll out

00:20:51.620 --> 00:20:52.960
as we got the support email.

00:20:52.960 --> 00:20:54.940
That was a great email to write back.

00:20:55.440 --> 00:20:58.340
Hey, we already saw your error and have already rolled out the fix.

00:20:58.340 --> 00:20:59.760
Imagine their surprise.

00:20:59.760 --> 00:21:01.960
Surprise and delight your users.

00:21:01.960 --> 00:21:06.040
Create your Sentry account at talkpython.fm/sentry.

00:21:06.040 --> 00:21:09.460
And if you sign up with the code talkpython, all one word,

00:21:09.460 --> 00:21:13.040
it's good for two free months of Sentry's business plan,

00:21:13.040 --> 00:21:16.440
which will give you up to 20 times as many monthly events

00:21:16.440 --> 00:21:17.700
as well as other features.

00:21:17.700 --> 00:21:20.640
Create better software, delight your users,

00:21:20.640 --> 00:21:22.120
and support the podcast.

00:21:22.120 --> 00:21:24.820
Visit talkpython.fm/sentry

00:21:24.820 --> 00:21:27.100
and use the coupon code talkpython.

00:21:29.600 --> 00:21:32.980
It's hard to tell from these little graphs that shows year over year change.

00:21:32.980 --> 00:21:35.740
And the one that seems to have grown the most is Rust.

00:21:35.740 --> 00:21:39.640
And I feel like there's a lot of people starting to pair Rust with Python

00:21:39.640 --> 00:21:42.440
instead of C with Python for some of those internals.

00:21:42.440 --> 00:21:43.240
Pretty interesting.

00:21:43.240 --> 00:21:43.700
Okay.

00:21:43.700 --> 00:21:45.820
Languages for web and data science.

00:21:45.820 --> 00:21:47.180
They break this stuff all down.

00:21:47.760 --> 00:21:49.200
This next question here asks,

00:21:49.200 --> 00:21:54.900
Python usage as a main or secondary language for a certain purpose.

00:21:54.900 --> 00:21:58.360
So maybe we could touch on top four or five here.

00:21:58.360 --> 00:22:00.520
Data analytics.

00:22:00.520 --> 00:22:05.300
Python is the main language, but only by 4%, right?

00:22:05.300 --> 00:22:06.920
And then web development.

00:22:06.920 --> 00:22:10.720
It seems like Python is more of the main language and so on.

00:22:10.720 --> 00:22:13.900
But for example, DevOps, as Gino was sort of talking about

00:22:13.900 --> 00:22:14.680
in system administration,

00:22:15.020 --> 00:22:17.580
it's a secondary language that people bring in.

00:22:17.580 --> 00:22:19.840
So yeah, Tanya, were you going to jump in there?

00:22:19.840 --> 00:22:23.160
I was just kind of nodding my head about the data analysis,

00:22:23.160 --> 00:22:26.280
the, you know, the 52% and just thinking like, you know,

00:22:26.280 --> 00:22:27.000
what else are they using?

00:22:27.000 --> 00:22:30.460
Are they using R instead of Python for data analysis or something else?

00:22:30.460 --> 00:22:32.200
Or just kind of made me think of that.

00:22:32.200 --> 00:22:33.000
It's a real good question.

00:22:33.000 --> 00:22:33.820
I don't know the answer.

00:22:33.820 --> 00:22:35.200
Maybe some other folks do.

00:22:35.200 --> 00:22:36.240
What are they using?

00:22:36.240 --> 00:22:37.220
If not the second language.

00:22:37.220 --> 00:22:39.120
I don't even think it was necessarily like a language.

00:22:39.120 --> 00:22:39.980
I think it was,

00:22:39.980 --> 00:22:43.140
where is the data coming from and how do you get into it?

00:22:43.140 --> 00:22:48.140
That was one of the things where I've been a massive advocate for working with public data

00:22:48.140 --> 00:22:52.360
and using tools like Socrata that provide REST APIs for a lot of that data.

00:22:52.360 --> 00:22:58.280
But when all of a sudden you're working at a project and you have a map and the map is only GIS data

00:22:58.280 --> 00:23:01.180
and you're like, well, yes, I could.

00:23:01.180 --> 00:23:07.280
I could start doing like neonatum stuff or I could just use what they give me.

00:23:07.280 --> 00:23:14.260
And unfortunately, a lot of data like that is kind of locked into however they decide to give it to you,

00:23:14.260 --> 00:23:20.360
albeit sometimes a CSV file that has, you know, 2,000 columns to it.

00:23:20.500 --> 00:23:28.980
So you're like, you know, it's almost terrifying to open up Pandas or open up, you know, just Python import CSV and run with it.

00:23:28.980 --> 00:23:31.600
So you just kind of use whatever they've given you to use.

00:23:31.600 --> 00:23:33.880
But I'm glad that there are services.

00:23:33.880 --> 00:23:40.120
Again, like that's going to be my repeating sentiment is I'm glad that there are more and more things coming out

00:23:40.120 --> 00:23:46.520
that make using Python with a lot of these tools a little bit more accessible to beginners.

00:23:46.520 --> 00:23:48.200
And I would say enthusiasts.

00:23:48.200 --> 00:23:50.000
I'm not a data analyst.

00:23:50.000 --> 00:23:51.160
I'm not a data scientist.

00:23:51.160 --> 00:23:53.120
I don't even pretend to be one.

00:23:53.120 --> 00:23:58.380
I'm just someone that loves looking at data and says, what can I discover from it?

00:23:58.460 --> 00:23:59.260
Yeah, very cool.

00:23:59.260 --> 00:24:02.560
Gina, how does that DevOps system administration breakdown for you?

00:24:02.560 --> 00:24:03.560
Does that resonate?

00:24:03.560 --> 00:24:04.220
Absolutely.

00:24:04.220 --> 00:24:08.140
Because frankly, even though I now consider myself a Python developer,

00:24:08.140 --> 00:24:11.000
whenever I have to get into DevOps administration stuff,

00:24:11.000 --> 00:24:16.920
the first thing that I try to use to solve any given problem that I have is shell script.

00:24:16.920 --> 00:24:24.400
Once that reaches a certain level of complexity and I start to slowly but surely lose my sanity over it,

00:24:24.400 --> 00:24:25.560
then I switch it over to Python.

00:24:25.820 --> 00:24:29.940
The first approach is usually just, I don't know, three or four lines of best script.

00:24:29.940 --> 00:24:32.680
Then suddenly all ton of logic ends up in it.

00:24:32.680 --> 00:24:34.740
Then I might need an argument parser.

00:24:34.740 --> 00:24:35.440
It's a point.

00:24:35.440 --> 00:24:39.180
And then Python starts to look more attractive at that point.

00:24:39.180 --> 00:24:45.460
But if it's really just chaining a bunch of units commands together and throwing JQ against the JSON dump

00:24:45.460 --> 00:24:47.640
or something like that, then it's just, I don't know.

00:24:47.640 --> 00:24:48.840
The shell script is just faster.

00:24:48.840 --> 00:24:49.160
Yeah.

00:24:49.160 --> 00:24:50.440
And no dependencies.

00:24:50.440 --> 00:24:51.260
It's just right there.

00:24:51.260 --> 00:24:51.600
Yeah.

00:24:51.600 --> 00:24:52.380
It just works.

00:24:52.640 --> 00:24:57.280
Like maybe I have to install one single command line tool or statically linked even maybe.

00:24:57.280 --> 00:24:58.540
And then I'm done.

00:24:58.540 --> 00:25:04.200
So yeah, when I can do that, I prefer doing that because then I don't feel like I have to maintain something now.

00:25:04.200 --> 00:25:12.080
Emily, the one that stands out to me most here is that the biggest I'm using Python as my primary language is for web development.

00:25:12.420 --> 00:25:14.620
You probably run into a lot of web projects at Cuddlesoft.

00:25:14.620 --> 00:25:15.960
What are your thoughts on that?

00:25:15.960 --> 00:25:16.240
Yeah.

00:25:16.240 --> 00:25:22.420
I mean, I think that at least for the space that I operate in, Python really is sort of a sweet spot.

00:25:22.420 --> 00:25:25.780
Python and Ruby, don't kick me off the show.

00:25:25.780 --> 00:25:26.360
We're not judging.

00:25:26.360 --> 00:25:26.960
We're not judging.

00:25:26.960 --> 00:25:33.060
I think that as a whole, web development is something that needs to be very accessible.

00:25:33.060 --> 00:25:34.820
You need to be able to hire for it.

00:25:34.820 --> 00:25:37.620
It needs to be something that's maintainable over time.

00:25:38.080 --> 00:25:41.780
And so I do think that there's kind of like a sweet spot of like getting something started.

00:25:41.780 --> 00:25:53.340
And a lot of times, especially if it's your first iteration of building something out, Python is a much more accessible language than trying to jump into something where you're maybe over optimizing or over engineering for something in the future.

00:25:53.340 --> 00:25:56.300
I think Python just really shines with web development.

00:25:56.300 --> 00:26:00.260
And it's such a rich ecosystem that why wouldn't you reach for it if you could?

00:26:00.500 --> 00:26:04.360
Yeah. And you have to hand off these projects as being a consulting firm, right?

00:26:04.360 --> 00:26:06.480
You build them and you probably hand them off.

00:26:06.480 --> 00:26:22.300
And I bet it feels more reasonable to hand off a Django or a Flask app than it would be to some highly configured ASP.NET type thing or a Java type of app that requires a bunch of steps even just to get the thing to run, you know?

00:26:22.300 --> 00:26:22.920
Yeah, absolutely.

00:26:23.080 --> 00:26:27.040
Anything that's going to wind up being like operating system restricted is really tricky.

00:26:27.040 --> 00:26:36.280
We've also been working with especially back-end applications that require a really complex ecosystem and architecture to deploy them.

00:26:36.280 --> 00:26:44.120
And my goodness, like if you can't easily spin up your local environment within, you know, 5-10 minutes, you're probably doing something wrong.

00:26:44.120 --> 00:26:50.860
Like all of these cloud infrastructures that exist have their place, but a lot of times people really want to grab onto those as well.

00:26:50.860 --> 00:26:52.220
It complicates things.

00:26:52.220 --> 00:26:55.800
So I definitely see why Python is still shining in web development.

00:26:55.800 --> 00:26:56.280
For sure.

00:26:56.280 --> 00:26:58.220
Brett, I'll give you the final word on this section.

00:26:58.220 --> 00:26:59.980
And it's a two-part question.

00:26:59.980 --> 00:27:00.420
Uh-oh.

00:27:00.420 --> 00:27:02.400
One, educational purposes.

00:27:02.400 --> 00:27:04.120
Python's a primary language there.

00:27:04.120 --> 00:27:04.900
That's pretty interesting.

00:27:04.900 --> 00:27:05.900
It's fantastic.

00:27:05.900 --> 00:27:10.320
I mean, way back when I started programming, definitely, I didn't have Python.

00:27:10.320 --> 00:27:13.720
I wish I did as an easier language to get tied into it.

00:27:13.720 --> 00:27:17.380
But I definitely see it and I appreciate it.

00:27:17.380 --> 00:27:22.600
And I wish I had convinced my professors when I was in grad school to switch to Python instead of some of their choices.

00:27:22.600 --> 00:27:25.200
But luckily, Python still went out years later.

00:27:25.200 --> 00:27:29.080
I've gone back and looked at, yeah, all my previous schools I attended have all switched.

00:27:29.080 --> 00:27:29.840
So that's fantastic.

00:27:29.840 --> 00:27:31.860
But yeah, and I hope it grows too, right?

00:27:31.860 --> 00:27:34.300
Like Paul alluded to WebAssembly and such.

00:27:34.300 --> 00:27:38.140
And I think we have some opportunity here to make getting started for education.

00:27:38.140 --> 00:27:43.320
As Emily also pointed out, just getting up and going is a really important friction point to lower.

00:27:43.320 --> 00:27:46.100
So I'm hoping we can continue to improve that to get us somewhere.

00:27:46.100 --> 00:27:50.040
Yeah, that was the part two of the two-part question is the WebAssembly stuff.

00:27:50.720 --> 00:27:53.760
I think traction is finally starting to take there.

00:27:53.760 --> 00:27:57.360
And that's post the time the survey was run, but I think it is.

00:27:57.360 --> 00:27:58.800
I just want to toss in two things here.

00:27:58.800 --> 00:28:07.640
One, I love this question because it's got the most, I find, odd specific point of programming of web parsers, scrapers, and crawlers out of all the other options.

00:28:07.640 --> 00:28:10.260
It always throws me every time I take this question.

00:28:10.260 --> 00:28:12.240
It's like, why that specific line?

00:28:12.340 --> 00:28:17.020
And I know it's historical because what Python's been used for over the years, but it's always so specific.

00:28:17.020 --> 00:28:22.900
The other thing I look at this, and this shows how weird my relationship with Python is, I don't view this as Python for today.

00:28:22.900 --> 00:28:28.460
I view it as what I wanted to see change for Python tomorrow, and specifically three, five, ten years from now.

00:28:28.460 --> 00:28:39.800
I hope we can move the education, the desktop development, and the embedded and mobile development more on our screen to the left, but higher percentages.

00:28:39.800 --> 00:28:42.560
Yeah, put them higher in that list for sure.

00:28:42.560 --> 00:28:43.220
Absolutely.

00:28:43.220 --> 00:28:44.720
Yeah, great point.

00:28:44.720 --> 00:28:45.660
Okay, totally agree.

00:28:45.660 --> 00:28:47.640
I believe Paul had something you want to bring up.

00:28:47.640 --> 00:28:48.620
Oh, Paul, get in here.

00:28:48.620 --> 00:28:50.220
Yeah, a quick point.

00:28:50.220 --> 00:28:56.140
First, on the historical anomaly, Brett, when you said that, I just went back and looked at 2017.

00:28:56.480 --> 00:28:58.660
And web crawlers was a big thing, man.

00:28:58.660 --> 00:29:00.120
It was 32% back then.

00:29:00.120 --> 00:29:02.960
So it is a little bit of an anomaly.

00:29:02.960 --> 00:29:04.340
So I guess it still is.

00:29:04.340 --> 00:29:07.780
What I'd like to call everyone's attention to is look at data analysis.

00:29:07.780 --> 00:29:13.860
The difference between the 52 and the 46, it's gone down for people who identify to that.

00:29:13.860 --> 00:29:17.140
If you go look at the two previous years, it went down then as well.

00:29:17.140 --> 00:29:18.100
Counterintuitive.

00:29:18.100 --> 00:29:19.200
Yeah, it really is.

00:29:19.200 --> 00:29:23.400
It must mean that the data analysis folks have a lot of different languages to juggle.

00:29:23.400 --> 00:29:24.180
All right.

00:29:24.180 --> 00:29:26.340
A bunch of other things that we could dive into.

00:29:26.900 --> 00:29:28.360
Kind of touched on a bunch of these.

00:29:28.360 --> 00:29:30.260
I think this is a really interesting question.

00:29:30.260 --> 00:29:31.120
I've always enjoyed it.

00:29:31.120 --> 00:29:34.000
And the question is, do you consider yourself a data scientist?

00:29:34.000 --> 00:29:38.640
And let's see, 66% say no.

00:29:38.640 --> 00:29:41.700
29% say yes.

00:29:41.700 --> 00:29:43.260
And then there's an other.

00:29:43.260 --> 00:29:44.500
And I'm not really sure.

00:29:44.500 --> 00:29:46.800
If I looked at the results, I guess that makes sense.

00:29:46.900 --> 00:29:49.160
But it sounds like a yes or no question.

00:29:49.160 --> 00:29:51.380
But there's some uncertainty in there.

00:29:51.380 --> 00:29:58.920
But when I describe the world as one-third, one-third, one-third, at least for the data science folks, here's the one-third.

00:29:59.300 --> 00:30:12.900
I do think there's a very interesting trend in the Python space where people who do data science, they feel like they are more isolated in the minority than, say, web developers and other folks.

00:30:13.080 --> 00:30:15.760
Because I think you have a team of web developers.

00:30:15.760 --> 00:30:20.600
And often you have one data scientist at the company that's doing the processing and analyzing and whatnot.

00:30:20.600 --> 00:30:26.440
But if you look at the usage for Python, the highest use, it's 50% is data analysis.

00:30:26.440 --> 00:30:30.880
And yet only 29% of the people say they consider themselves data scientists.

00:30:31.200 --> 00:30:33.560
So I think there's something interesting.

00:30:33.560 --> 00:30:40.760
I think there's more data science happening in Python than even the people in the trenches of that space of it see it as.

00:30:40.760 --> 00:30:47.660
I think it gets even a bit weirder because it's not that two-thirds of everyone who got asked here doesn't consider themselves data scientists.

00:30:47.660 --> 00:30:56.480
But two-thirds of all the people that were asked that stated that they work in data analysis and machine learning said they are not data scientists, as it says there.

00:30:56.880 --> 00:31:04.920
So that is something that throws me completely off here because, I don't know, I may be imposter syndrome, but I don't know.

00:31:04.920 --> 00:31:05.960
Yeah.

00:31:05.960 --> 00:31:10.900
Yeah, I think a lot of this goes to what Jay was saying earlier.

00:31:10.900 --> 00:31:17.920
When we look at data analysis as these questions were asked, that's not necessarily data science for a lot of people.

00:31:17.920 --> 00:31:24.060
So Jay was talking about using Python to pull data from public APIs and do analysis on them.

00:31:24.180 --> 00:31:27.480
We're like, we use Python to run our accounting department, right?

00:31:27.480 --> 00:31:33.360
Like, we pull together spreadsheets and do analysis and budgeting and automatically generate invoices.

00:31:33.360 --> 00:31:41.760
So I think that there's just like so much more within that data analysis section that just doesn't necessarily apply to data science.

00:31:41.760 --> 00:31:42.080
Right.

00:31:42.080 --> 00:31:47.800
They're not doing machine learning with TensorFlow and Jupyter, so it might not feel like I'm a data scientist type.

00:31:47.840 --> 00:31:47.960
Yeah.

00:31:47.960 --> 00:31:48.480
Yeah.

00:31:48.480 --> 00:31:51.640
To me, this is an industry direction question.

00:31:51.640 --> 00:31:56.520
You know, the industries that we work in are becoming more and more data focused, more and more data driven.

00:31:56.520 --> 00:31:58.920
And we've been saying that for a decade now.

00:31:58.920 --> 00:32:01.140
So I'm just going to keep the pattern going.

00:32:01.140 --> 00:32:17.200
But it seems like even in newer industries, even in industries that are popping up, like I think about how many people are social media influencers that have to deal with things like impressions and stuff like that.

00:32:17.200 --> 00:32:26.540
So it's like, yes, you have high school kids and younger folks and people who like get it that I just don't.

00:32:26.540 --> 00:32:36.380
And they're having to look at data and they're having to think about things from a data driven perspective a lot earlier in life.

00:32:36.520 --> 00:32:43.220
And I think as it becomes more commonplace, what we'll see is people will do anything and everything to make their jobs easier.

00:32:43.220 --> 00:32:49.600
And in fact, that was what originally got me into Python was how do I make this job easier?

00:32:49.600 --> 00:32:51.320
Oh, I can script this out.

00:32:51.320 --> 00:33:00.220
And I think we have some I mean, I talked to the high school kids, you know, from time to time just about, you know, their careers in computer science in the future.

00:33:00.220 --> 00:33:06.560
And a lot of them are thinking about everything that they do now from a data perspective.

00:33:06.560 --> 00:33:13.340
And I think that's where, you know, you have more people doing data analytics that aren't necessarily doing data science.

00:33:13.340 --> 00:33:14.840
Yeah, that's a great perspective.

00:33:14.840 --> 00:33:18.820
I'm very excited, especially for Brett and Emily on this one.

00:33:18.820 --> 00:33:21.940
This next question, Python versions, Python 3 versus 2.

00:33:21.940 --> 00:33:25.580
There was a little bit of uncertainty back in 2017.

00:33:25.580 --> 00:33:28.900
25% of the people were still now I'm doing Python 2.

00:33:29.220 --> 00:33:33.100
Now it's just down to the ones I suspect you have no choice.

00:33:33.100 --> 00:33:35.300
It's 95% Python 3.

00:33:35.300 --> 00:33:38.380
Brett, can you do a celebration lap on this one?

00:33:38.380 --> 00:33:39.000
Oh, yeah.

00:33:39.000 --> 00:33:44.080
I mean, I started to celebrate when we got past 50% and the trend continued to go down.

00:33:44.080 --> 00:33:49.360
I mean, I basically had on faith alone and partially because this is somewhat my fault.

00:33:49.360 --> 00:33:51.980
I did play a part in trying to make this all happen.

00:33:51.980 --> 00:33:54.400
I kind of had to have faith that this would all trend this way.

00:33:54.400 --> 00:33:57.940
I feel sorry for the people, those 5% that are still stuck on Python 2.

00:33:58.300 --> 00:34:00.120
I know they're keeping friends of ours.

00:34:00.120 --> 00:34:09.080
Yeah, there's some of the banks that have like 5,000 Python developers working on some forked, specialized version of Python 2 that has millions of lines of code.

00:34:09.080 --> 00:34:11.060
I mean, that could be 3% right there.

00:34:11.060 --> 00:34:12.200
Yeah.

00:34:12.200 --> 00:34:16.500
And I mean, and I do know people are still actively working on this, right?

00:34:16.580 --> 00:34:23.600
Like a friend of some of us, Jeff Triplett, like I know, part of his consulting work is to help companies move from Python 2 to 3.

00:34:23.600 --> 00:34:26.160
So I know it's not that people aren't trying to do it.

00:34:26.160 --> 00:34:35.120
My worry about those folk that can't move is how much of an island will become to themselves just because they'll slowly just be able to use less and less of the open source stuff.

00:34:35.260 --> 00:34:36.360
But not much we can do there.

00:34:36.360 --> 00:34:38.940
But yes, I am very happy about this.

00:34:38.940 --> 00:34:44.540
And at work, all of our stuff, we draw Python 2 support officially beginning of this year.

00:34:44.540 --> 00:34:48.440
So it was a nice day when that happened.

00:34:48.440 --> 00:34:50.280
Fantastic.

00:34:50.520 --> 00:34:53.580
Emily, being on the inside, what are your thoughts on this as well?

00:34:53.580 --> 00:34:58.360
Yeah, it's interesting because I feel two very like conflicted feelings about this.

00:34:58.360 --> 00:35:05.560
So my gut reaction when I look at this is like, wow, like, was it really 75% of people who were already on it in 2017?

00:35:05.560 --> 00:35:11.160
Like in my soul, I feel like there was still this big push to like get people on Python 3.

00:35:11.160 --> 00:35:14.860
And it doesn't feel like we were that successful that long ago.

00:35:14.860 --> 00:35:16.040
So that's the first thing.

00:35:16.040 --> 00:35:25.740
And then the other thing is like, I just I am lucky to function in a space that we were so able to jump on Python 3 right from the beginning.

00:35:25.740 --> 00:35:38.620
I do kind of share a lot of Brett's concerns and hesitations about, you know, the people who are still on Python 2 right now are probably really stuck on Python 2 and will be for the foreseeable future.

00:35:38.620 --> 00:35:44.420
Yeah, you're going to have to leave that job and go to a different place where you no longer have to touch that software to make that change.

00:35:44.420 --> 00:35:44.820
I'm sure.

00:35:44.820 --> 00:35:45.540
That actually happened.

00:35:45.620 --> 00:35:49.580
I mean, a company I was working for in 2019, they were on Python 2.7.

00:35:49.580 --> 00:35:51.540
They're still on Python 2.7.

00:35:51.540 --> 00:35:56.440
So unfortunately, they're in that small percentage that's using Python 2.7.

00:35:56.440 --> 00:35:57.940
But yeah.

00:35:57.940 --> 00:36:08.620
For me, this graph represents a struggle that I actually am still fighting or was fighting until very recently in Octoprint's maintenance.

00:36:08.820 --> 00:36:12.780
Octoprint is something that is deployed at the end user space.

00:36:12.780 --> 00:36:15.420
So I do not control the Python environment it is running in.

00:36:15.420 --> 00:36:21.540
And so until the very latest stable version, Octoprint still supported Python 2 and 3.

00:36:21.540 --> 00:36:36.260
And dropping Python 2 support was something that I dreaded because I feared a huge backlash from the community along the lines of, but then this and this plugin will no longer work because the maintainer has not upgraded it yet to support Python 3 as well.

00:36:36.260 --> 00:36:39.140
And I'm currently looking at my own tracking stats.

00:36:39.140 --> 00:36:44.700
And for Octoprint, the split is still 15% of all instances are still on Python 2.

00:36:44.700 --> 00:36:46.960
But at least we now have 85%.

00:36:46.960 --> 00:36:50.100
So we are slowly catching up to these survey results.

00:36:50.100 --> 00:36:52.840
But still, the journey was long and hard.

00:36:52.840 --> 00:36:58.000
And I'm really, really glad that I can finally now say, no, I'm exclusively developing in Python 3.

00:36:58.000 --> 00:36:58.740
f-strings.

00:36:58.740 --> 00:36:59.260
Yes.

00:36:59.480 --> 00:36:59.780
Yes.

00:36:59.780 --> 00:37:00.560
Yes.

00:37:00.560 --> 00:37:01.780
3.6 is all you need.

00:37:01.780 --> 00:37:02.800
That's where the magic is.

00:37:02.800 --> 00:37:04.240
You got async and await and you got f-strings.

00:37:04.240 --> 00:37:04.600
Yeah.

00:37:04.600 --> 00:37:09.560
I think that's an interesting microcosm to think about how your app has these plugins.

00:37:09.560 --> 00:37:13.640
And so there's that cascading dependency as well.

00:37:13.640 --> 00:37:13.840
Yeah.

00:37:13.840 --> 00:37:20.580
It also means that if I make decisions like dropping Python 2 support, I pretty much nuke a whole part of my ecosystem.

00:37:20.580 --> 00:37:24.600
And that is obviously bad because I depend on my ecosystem.

00:37:24.600 --> 00:37:28.660
It makes up like it's one of the biggest selling points of the whole thing.

00:37:28.860 --> 00:37:34.600
So that always was, or stuff like this is always decisions that are especially hard to make.

00:37:34.600 --> 00:37:41.340
This portion of Talk Python To Me is brought to you by the Compiler podcast from Red Hat.

00:37:41.340 --> 00:37:44.680
Just like you, I'm a big fan of podcasts.

00:37:44.680 --> 00:37:49.060
And I'm happy to share a new one from a highly respected and open source company.

00:37:49.060 --> 00:37:52.380
Compiler, an original podcast from Red Hat.

00:37:52.380 --> 00:37:57.740
With more and more of us working from home, it's important to keep our human connection with technology.

00:37:58.160 --> 00:37:59.880
With Compiler, you'll do just that.

00:37:59.880 --> 00:38:07.840
The Compiler podcast unravels industry topics, trends, and things you've always wanted to know about tech through interviews with people who know it best.

00:38:07.840 --> 00:38:12.020
These conversations include answering big questions like, what is technical debt?

00:38:12.020 --> 00:38:14.740
What are hiring managers actually looking for?

00:38:14.740 --> 00:38:18.080
And do you have to know how to code to get started in open source?

00:38:18.740 --> 00:38:27.480
I was a guest on Red Hat's previous podcast, Command Line Heroes, and Compiler follows along in that excellent and polished style we came to expect from that show.

00:38:27.480 --> 00:38:31.340
I just listened to episode 12 of Compiler, How Should We Handle Failure?

00:38:31.340 --> 00:38:41.260
I really valued their conversation about making space for developers to fail so that they can learn and grow without fear of making mistakes or taking down the production website.

00:38:41.480 --> 00:38:44.060
It's a conversation we can all relate to, I'm sure.

00:38:44.200 --> 00:38:48.860
Listen to an episode of Compiler by visiting talkpython.fm/compiler.

00:38:48.860 --> 00:38:51.000
The link is in your podcast player's show notes.

00:38:51.000 --> 00:38:57.420
You can listen to Compiler on Apple Podcasts, Overcast, Spotify, Pocket Cast, or anywhere you listen to your podcasts.

00:38:57.420 --> 00:39:01.720
And yes, of course, you could subscribe by just searching for it in your podcast player,

00:39:01.720 --> 00:39:08.020
but do so by following talkpython.fm/compiler so that they know that you came from Talk Python To Me.

00:39:08.020 --> 00:39:13.300
My thanks to the Compiler Podcast for keeping this podcast going strong.

00:39:13.300 --> 00:39:18.080
There's a Zed Shaw quote for everything.

00:39:18.080 --> 00:39:21.220
And I wondered if there was a Zed Shaw quote for this.

00:39:21.220 --> 00:39:22.140
Guess what?

00:39:22.140 --> 00:39:23.480
There's a Zed Shaw quote.

00:39:23.480 --> 00:39:23.900
There is.

00:39:23.900 --> 00:39:25.240
That's November 2016.

00:39:25.240 --> 00:39:30.880
There's a high probability that Python 3 is such a failure it will kill Python.

00:39:30.880 --> 00:39:33.460
So, Brett, I mean, you killer.

00:39:33.460 --> 00:39:35.960
I'm okay with that.

00:39:36.060 --> 00:39:39.960
Python 2 can go hang out with Cobol in the back of the room and just live on forever,

00:39:39.960 --> 00:39:46.720
well beyond all of us, and do its thing for the few that are stuck on it forever and just can't do anything better.

00:39:46.720 --> 00:39:51.260
I am curious about that box next to the graph here about, I'm saying,

00:39:51.260 --> 00:39:56.780
compared to Python 3, Python 2 is more often applied to computer graphics, games, and mobile development.

00:39:56.780 --> 00:39:57.580
I know for Mac.

00:39:57.580 --> 00:39:58.840
Yeah, I'm curious about that as well.

00:39:58.840 --> 00:39:59.780
Yeah, it was interesting.

00:39:59.780 --> 00:40:00.860
Kind of really stood out to me.

00:40:00.860 --> 00:40:07.020
I know for Mac, right, they're dropping Python 2.7 support, I believe, right, which happened at the beginning of this year.

00:40:07.020 --> 00:40:10.480
So, yeah, that just was, this was just, I was curious about that.

00:40:10.480 --> 00:40:12.080
It's got to be embedded in something.

00:40:12.080 --> 00:40:14.880
I can also kind of indirectly talk to this.

00:40:14.880 --> 00:40:26.100
I have a friend who used to be in the gaming industry professionally, and chats with him suggest the gaming industry is very slow to pick up on new stuff, ironically.

00:40:26.520 --> 00:40:33.700
Right, like cutting edge graphics and all that, but like modern, like development practices and stuff, extremely slow to switch.

00:40:33.700 --> 00:40:41.000
I don't know if it's the just culture or the velocity tempo we do development at causes them to not stop and look at how things change.

00:40:41.000 --> 00:40:48.760
So I think it's a combination of the embedding comment just made, plus just literally, it works, why make a change?

00:40:48.760 --> 00:40:51.360
And we don't have time to move anything we've written in two to three.

00:40:51.360 --> 00:40:56.920
I think Paul Hildebrandt talks about that in Hollywood and video production, right?

00:40:56.920 --> 00:40:58.480
Yeah, Maya and all that switching over.

00:40:58.480 --> 00:41:04.760
Yeah, I gave a talk at Disney for Paul at one point to help him try to convince folks to move to Python 3.

00:41:04.760 --> 00:41:07.800
And they had to get the whole industry on board, right?

00:41:07.800 --> 00:41:15.940
Like, because there's a whole industry group that controls, control sounds a little extreme, but works together to come up with standards of software.

00:41:16.060 --> 00:41:20.000
So the whole industry works together and they, as a group, had to decide to move to Python 3.

00:41:20.000 --> 00:41:23.240
And I think they did it a bit later than some people might know.

00:41:23.240 --> 00:41:28.100
And then that's what got like Maya and all those graphics tools to move over and all that.

00:41:28.100 --> 00:41:30.760
And if you're still running all the versions, I'm sure you haven't switched.

00:41:30.760 --> 00:41:36.080
So that's my guess as to why those specific areas are kind of taking a bit longer to switch.

00:41:36.260 --> 00:41:38.500
Yeah, I totally agree with the game, computer graphics.

00:41:38.500 --> 00:41:41.700
I'm not so sure about mobile because I don't even know what is happening there.

00:41:41.700 --> 00:41:45.000
This game at one point just kind of made me wonder.

00:41:45.000 --> 00:41:49.160
A long time ago in a galaxy far, far away, I doubled briefly in Unity.

00:41:49.160 --> 00:41:51.900
And back then, I think it didn't have Python bindings.

00:41:51.900 --> 00:41:52.620
And I just checked.

00:41:52.620 --> 00:41:55.580
Apparently, they introduced Python bindings in 2020.

00:41:55.580 --> 00:41:58.820
And they started with Python 2 in 2020.

00:41:59.480 --> 00:42:03.980
So then I currently have the blog post in front of me, Python for Unity editor,

00:42:03.980 --> 00:42:06.720
and where they said Python 3 support is in the works.

00:42:06.720 --> 00:42:09.020
And that was on February 26th in 2020.

00:42:09.020 --> 00:42:11.120
So I don't know if they have shipped it by now.

00:42:11.120 --> 00:42:12.360
I sincerely hope so.

00:42:12.360 --> 00:42:17.900
But that kind of explains why it might still be a factor in games development.

00:42:17.900 --> 00:42:21.860
Because if you started, for example, on a Unity game and developed everything in Python 2,

00:42:21.860 --> 00:42:23.320
then why port it over?

00:42:23.320 --> 00:42:27.500
No one will look into the source anyhow because you shipped the whole game binary and stuff like that.

00:42:27.500 --> 00:42:28.540
Yeah, very good.

00:42:28.540 --> 00:42:29.080
Very good point.

00:42:29.200 --> 00:42:31.780
Okay, let's move on to the next one.

00:42:31.780 --> 00:42:35.040
And this one, I think more than most, you've got to keep in mind,

00:42:35.040 --> 00:42:36.420
this is from the fall of 2021.

00:42:36.420 --> 00:42:38.220
And this is for Python 3.

00:42:38.220 --> 00:42:40.160
What versions are you using?

00:42:40.160 --> 00:42:43.960
You know, you hear about a lot of libraries these days being 3.7 or above.

00:42:43.960 --> 00:42:48.560
I believe official support for 3.6 is no longer there, right, Emily?

00:42:48.560 --> 00:42:49.860
It's now retired.

00:42:49.860 --> 00:42:52.940
So it breaks down what percentage is being used.

00:42:52.940 --> 00:42:56.520
So 3.5 or lower is only 2%.

00:42:56.520 --> 00:42:57.540
3.6 is 7.

00:42:57.540 --> 00:42:58.920
7 is 13.

00:42:58.920 --> 00:43:04.760
Then it was 27% and 35% for 3.9 and 16% for 3.10.

00:43:04.760 --> 00:43:09.620
And so there's sort of this right side heavy normal distribution type of thing.

00:43:09.620 --> 00:43:14.820
And I suspect it would move a little more to the right with 3.10, you know, being seven months later or something like that.

00:43:14.820 --> 00:43:15.020
Yeah.

00:43:15.100 --> 00:43:18.500
I was going to say the timeframe, I think, as you pointed out, Michael, really important to keep in mind.

00:43:18.500 --> 00:43:26.460
Because in the fall, 3.10 would have been brand spanking new because it comes out at the beginning of October on the broadcast anniversary of Monty Python's Flying Circus.

00:43:27.260 --> 00:43:37.500
So it's so new that if the community hadn't caught up yet with releasing usually the extension modules that everyone relies on, right, that scientific stack and all that being ready to go, that would probably hold that up.

00:43:37.600 --> 00:43:48.000
So actually 16% is kind of nice because it does show that at least some people are ready to go day one versus everyone being on 3.9, which for the majority of the year that this survey covers was the latest and greatest, right?

00:43:48.260 --> 00:43:56.440
And talking about the Python 2 stuff, I love this chart because for the longest time, right, Python 2 was up over here on the left side and everything was slowly keeping up on the other side.

00:43:56.440 --> 00:44:05.160
Now we're back to what would have been normal way back in my beginner days of Python of, oh, yeah, pretty much everyone just is on the newest version like three months, six months later.

00:44:05.160 --> 00:44:15.840
And I see Paul shaking his head, remembering at the same time as I do, where the whole community just moved together on the same versions versus the old split that we had where it's just like, well, some people are moving, some aren't.

00:44:15.840 --> 00:44:17.700
And it's nice to be back on this cadence.

00:44:17.980 --> 00:44:30.880
Not to fast forward any of your conversation, Mike, but I think the point below it also speaks to why a lot of people were on 3.9 at this point in time, which is how they're installing it.

00:44:30.880 --> 00:44:31.260
Oh, yeah.

00:44:31.260 --> 00:44:37.000
If you're installing it from your OS provider or some other form, you're going to get an older version of Python.

00:44:37.000 --> 00:44:47.700
And if you're learning Python, just from surveys that I've seen from Python communities, the largest member of Python communities are often...

00:44:47.700 --> 00:44:50.580
Often students and people wanting to learn.

00:44:50.580 --> 00:44:52.640
So how do they install Python?

00:44:52.640 --> 00:44:55.140
Well, if it's already there, they're just going to use what's there.

00:44:55.140 --> 00:45:02.220
If they don't, then they're probably going to go to the website and download it and then and just run the installer.

00:45:02.760 --> 00:45:10.760
I think that we as Python professionals like to think that the way that we do things is normal or normalized, I guess.

00:45:10.760 --> 00:45:11.440
No.

00:45:11.440 --> 00:45:12.540
But often not.

00:45:12.540 --> 00:45:20.180
Me using, you know, ASDF to manage all of my different Python versions that I'm using back and forth is very much the outlier.

00:45:20.180 --> 00:45:27.920
I feel like 3.9 is the largest in this case because teachers are telling their students, go here, install this, do this thing.

00:45:27.920 --> 00:45:33.360
And if that's what they're using and that's what they're, you know, being forced to use, then they're just going to tell their students to do the same thing.

00:45:33.360 --> 00:45:33.600
Yeah.

00:45:33.600 --> 00:45:39.540
The other thing is if you the main way you get Python here that people got Python is by downloading the installer.

00:45:39.540 --> 00:45:41.460
If you do that, it doesn't auto update.

00:45:41.460 --> 00:45:42.080
Right.

00:45:42.080 --> 00:45:45.480
And so if you did that a year and a half ago, you're just going to have that.

00:45:45.480 --> 00:45:46.640
Oh, I have Python 3.

00:45:46.640 --> 00:45:47.060
I'm good.

00:45:47.060 --> 00:45:48.400
There's no auto update.

00:45:48.400 --> 00:45:50.960
Whereas if you did brew install.

00:45:50.960 --> 00:45:51.620
Right.

00:45:51.620 --> 00:45:52.680
It'll say, oh, there's a new version.

00:45:52.680 --> 00:45:52.980
There's new.

00:45:52.980 --> 00:45:55.740
And you just generally just accept whatever the updates are.

00:45:55.740 --> 00:45:58.520
So I think that actually has a big influence here as well.

00:45:58.520 --> 00:46:08.020
And then, Brett, to your point, I remember right as 3.10 came out, there was a few things I wanted that didn't have wheels for 3.10 that also had to be on M1.

00:46:08.140 --> 00:46:16.720
There was like, there were certain libraries that didn't, not that they didn't support it, but they weren't quite ready to deliver you the stuff you actually needed to use it, you know?

00:46:16.720 --> 00:46:22.580
Tanya, Paul, Jay, you all are talking to customers and working with folks.

00:46:22.580 --> 00:46:29.200
Does this influence how you might think of working with people or presenting stuff like tutorials or things along those lines?

00:46:29.200 --> 00:46:29.860
Yeah, I think so.

00:46:29.860 --> 00:46:35.820
I think it would depend on like, you know, which level they're at and like which operating system that they're using maybe.

00:46:36.220 --> 00:46:39.900
I know for myself, like I just, I literally like just started using IAM.

00:46:39.900 --> 00:46:44.180
It just makes it a lot easier to like also switch between, you know, different Python versions.

00:46:44.180 --> 00:46:47.340
But yeah, I think this is definitely something to think about, like when we're writing content.

00:46:47.340 --> 00:46:48.080
For sure.

00:46:48.080 --> 00:46:48.460
For sure.

00:46:48.460 --> 00:46:56.680
I may have been told once or twice to not lean on the walrus operator and some of my match case operators as much.

00:46:56.680 --> 00:47:01.840
But, you know, you do have to think about how you're writing code and some of the benefits.

00:47:01.840 --> 00:47:17.300
And I think that's I know 311 isn't on here for obvious reasons, but that's one of the things that we think about when we talk about what's happening in the future, too, is yes, it's great to be able to extol the virtues of all the efficiency improvements.

00:47:17.360 --> 00:47:22.780
But at the same time, we have to also understand that we might be talking to someone that says, yeah, that's great.

00:47:22.780 --> 00:47:25.240
We're not going to touch 311 for another three years.

00:47:25.240 --> 00:47:26.660
So it works.

00:47:26.660 --> 00:47:27.640
We're not touching it.

00:47:27.640 --> 00:47:28.440
Yeah.

00:47:28.440 --> 00:47:36.580
It's fun to encourage that conversation, but also to remember that not every blog post can have the latest and greatest features included.

00:47:36.580 --> 00:47:37.480
Yeah, for sure.

00:47:37.480 --> 00:47:38.620
Three quick points for me.

00:47:38.700 --> 00:47:42.740
First, Emily's first contribution to CPython was walrus.

00:47:42.740 --> 00:47:45.600
So you will address walrus with love and respect.

00:47:45.600 --> 00:47:47.360
I love the walrus operator.

00:47:47.360 --> 00:47:51.300
I, for one, reach for it every time I can in my personal code.

00:47:51.300 --> 00:47:51.900
However.

00:47:51.900 --> 00:47:59.500
Second, I find myself blocked sometimes by, of all things, has black gotten to it yet, which is kind of funny.

00:47:59.500 --> 00:48:07.700
And third, I believe all these problems will be solved when Brett adds install Python to the Python launcher feature set.

00:48:07.860 --> 00:48:10.880
I think that we'll all be in good shape when that happens.

00:48:10.880 --> 00:48:13.820
I'm curious, Emily, I want to put you on the spot.

00:48:13.820 --> 00:48:14.900
Make a prediction.

00:48:14.900 --> 00:48:15.960
310.

00:48:15.960 --> 00:48:17.960
What's its number going to be next time?

00:48:17.960 --> 00:48:19.520
Think it'll hit 35%?

00:48:19.520 --> 00:48:20.420
Yeah, absolutely.

00:48:20.420 --> 00:48:21.060
All right.

00:48:21.060 --> 00:48:28.860
I think what we're seeing here, at least to a certain extent, is that we haven't inflicted too much trauma on the community that they've said,

00:48:28.860 --> 00:48:36.940
no, I finally got to Python 3.6 or 3.5 or wherever they were at when they migrated over and that they wanted to kind of like stay there.

00:48:37.020 --> 00:48:49.720
And I think that the core team takes great care, especially now, to not introduce any sort of deprecations or breaking changes that are going to impact the majority of users.

00:48:49.900 --> 00:48:58.760
Because we know, like we have this talk internally all the time, like there is not going to be a Python 4 because we don't want to see that sort of transition that we saw from 2 to 3.

00:48:59.180 --> 00:49:04.480
And so I'm hoping that in a way we've broken that stigma that a Python upgrade is a pain.

00:49:04.480 --> 00:49:10.380
And I don't think I was really around to see the better days before we introduced that.

00:49:10.380 --> 00:49:19.660
But I do think at this point there's much lower friction and much better tooling for somebody to say, hey, you know, yeah, like Python 3.10 just came out.

00:49:19.720 --> 00:49:21.120
Let's upgrade our Docker container.

00:49:21.120 --> 00:49:21.900
Let's run CI.

00:49:21.900 --> 00:49:23.140
Let's see if our tests pass.

00:49:23.140 --> 00:49:32.400
And like we should be good to go and just kind of like more readily upgrade on a regular basis because we look at these more as incremental changes.

00:49:32.640 --> 00:49:40.420
One, and two, I think there is, there's a lot of cool new features that go into each release that people want to grab for.

00:49:40.420 --> 00:49:44.780
And I think that will drive people to continue to upgrade as much as they possibly can.

00:49:44.780 --> 00:49:45.800
Yeah, absolutely.

00:49:45.800 --> 00:49:50.500
I do think it's been a very smooth ride from 3.5 onward.

00:49:50.500 --> 00:49:53.520
I can't think of anything that's been a problem.

00:49:53.520 --> 00:49:55.640
So people are encouraged to keep going.

00:49:55.640 --> 00:49:57.260
I do think there's two things.

00:49:57.260 --> 00:50:02.520
One, I love the Waller's operator as well, although I've taken down my website with it on accident.

00:50:02.520 --> 00:50:09.340
Because there were some utility scripts that were not loaded by the website that I thought, oh, I can put my newer code over here.

00:50:09.340 --> 00:50:11.220
And that was 3.7 on the server.

00:50:11.220 --> 00:50:17.740
But the server, the web framework scans all the files to try to find routes, URLs, even if you don't call it.

00:50:17.740 --> 00:50:19.040
And it didn't work so well.

00:50:19.040 --> 00:50:20.540
But I also love it.

00:50:20.540 --> 00:50:28.720
I think the other thing is there's going to be an interesting blip in this graph over time from going, because it goes 3.8, 3.9, then 3.10.

00:50:28.820 --> 00:50:32.740
And it's sort of this curve, what you would expect, like a normal-ish distribution.

00:50:32.740 --> 00:50:38.220
I think the performance that's coming in 3.11 is going to make a lot of people say, no, no, no, no.

00:50:38.220 --> 00:50:39.740
It's time to be cutting edge.

00:50:39.740 --> 00:50:45.280
We're going to get such a boost from it that we're willing to jump not just to 3.10, but to 3.11.

00:50:45.280 --> 00:50:48.980
Trying to pull up the graph here for us.

00:50:49.060 --> 00:50:52.340
Yeah, there's some amazing numbers for that.

00:50:52.340 --> 00:50:54.280
And maybe the core data is on the team.

00:50:54.280 --> 00:50:55.360
I want to speak real quick to this.

00:50:55.360 --> 00:50:58.920
But there was, Eduardo pointed out, there's this article.

00:50:58.920 --> 00:51:00.180
Maybe you all have seen it.

00:51:00.180 --> 00:51:04.460
This says the Python 3.11 performance benchmarks are looking fantastic.

00:51:04.460 --> 00:51:07.060
And it's kind of hard to navigate this thing.

00:51:07.060 --> 00:51:16.080
But if you cruise through here, you see some really meaningful performance improvements, like 40% for certain use cases and so on.

00:51:16.340 --> 00:51:18.000
So, Brett and Emily, what do you think about this?

00:51:18.000 --> 00:51:22.060
More people kind of jump in over 3.10 to get to this faster Python.

00:51:22.060 --> 00:51:24.200
I think in general, you're right.

00:51:24.200 --> 00:51:32.460
I think when 3.11 comes out and people start talking about how they're getting like bare minimum 5% and certain benchmarks 60%,

00:51:32.460 --> 00:51:35.800
which averages out probably roughly to 20% for most people, right?

00:51:35.800 --> 00:51:39.480
I think that's going to cause a lot of people to park up and go like, yeah, we should jump.

00:51:39.480 --> 00:51:46.000
Now, having said that, there is the potential for compatibility concerns because so much of the internals have had to be,

00:51:46.000 --> 00:51:47.520
uprooted and changed.

00:51:47.520 --> 00:51:54.620
That if you're depending on an extension module, that there's some really deep mucking around with CPython internals.

00:51:54.620 --> 00:51:57.200
They might have to spend some time still to get updated.

00:51:57.200 --> 00:52:01.900
So there might also be some cohort of users that get kind of held up because of that.

00:52:01.960 --> 00:52:06.020
But yeah, I suspect most people are not in that group.

00:52:06.020 --> 00:52:10.800
And so they will be able to jump straight over and people are going to go, oh, wow, this is so much faster.

00:52:11.020 --> 00:52:16.720
For literally just business reasons alone of just literally saving on your compute costs, let's switch to the other.

00:52:16.720 --> 00:52:18.760
Like, I think this is going to be one of those.

00:52:18.760 --> 00:52:27.480
You can go to management and convince them that you update your code because the amount of money you're going to save on your costs is going to be high enough that it's worth putting the time and effort in.

00:52:27.480 --> 00:52:31.420
Versus other times where it's the engineers coming to management going, I want the waller's wall operator.

00:52:31.420 --> 00:52:32.700
Why will you let me have this?

00:52:32.700 --> 00:52:32.940
Right?

00:52:32.980 --> 00:52:35.320
And they're all like, well, it's not worth it.

00:52:35.320 --> 00:52:35.960
Just keep doing it.

00:52:35.960 --> 00:52:38.980
Versus now, like, we can save 20% off our compute costs.

00:52:38.980 --> 00:52:39.640
Oh, okay.

00:52:39.640 --> 00:52:40.160
Yeah, let's go ahead.

00:52:40.160 --> 00:52:40.520
Yep.

00:52:40.520 --> 00:52:41.140
Exactly.

00:52:41.140 --> 00:52:44.200
Everyone will eventually get Emily's waller's operator, hell or high water.

00:52:44.200 --> 00:52:54.280
And me, I'll probably, for all eternity of Octoprint's development, will be stuck on whatever is the latest that is still supported kind of thing.

00:52:54.280 --> 00:52:55.200
Or the oldest.

00:52:55.200 --> 00:52:55.800
Right, right.

00:52:55.800 --> 00:52:56.620
So 3.7.

00:52:56.620 --> 00:52:57.120
Yep.

00:52:57.120 --> 00:52:57.400
Yeah.

00:52:57.400 --> 00:52:59.140
So currently, I'm still stuck on 3.7.

00:52:59.140 --> 00:53:02.200
I mean, I'm happy I'm finally on 3.7 and not on 2.7.

00:53:02.300 --> 00:53:04.300
But I hear waller's operator.

00:53:04.300 --> 00:53:06.820
I hear matching and pattern matching.

00:53:06.820 --> 00:53:07.820
And I hear all this stuff.

00:53:07.820 --> 00:53:09.000
And this looks so amazing.

00:53:09.000 --> 00:53:10.600
And I would love to play around with it.

00:53:10.600 --> 00:53:13.100
But maybe in five years or so.

00:53:13.100 --> 00:53:13.840
I don't know.

00:53:13.840 --> 00:53:15.560
For now, it's like, yeah.

00:53:15.560 --> 00:53:22.360
If you have to support something that people install on their OS providers, Python, then you are a bit out of luck.

00:53:22.360 --> 00:53:22.940
Absolutely.

00:53:22.940 --> 00:53:25.680
Very interesting angle there that you're constrained by.

00:53:25.680 --> 00:53:26.200
All right.

00:53:26.200 --> 00:53:27.840
I want to just, we only have time for one more.

00:53:27.840 --> 00:53:31.160
I want to find out how long people, two things, actually.

00:53:31.360 --> 00:53:36.760
Let's just, I think since we have two, a representative for the two major editors.

00:53:36.760 --> 00:53:44.700
Let's real quick, maybe Brett and Paul give us your thoughts on if I'm going to use, write some code.

00:53:44.700 --> 00:53:46.220
You know, what editor do I use, right?

00:53:46.220 --> 00:53:50.500
It's VS Code and PyCharm pretty close, neck and neck.

00:53:50.500 --> 00:53:53.000
And then it just tails off to some insane long tail after that.

00:53:53.000 --> 00:53:57.980
Honestly, this must make both of you pretty happy that playing such an important role up front.

00:53:57.980 --> 00:53:58.560
Yeah.

00:53:58.560 --> 00:54:03.380
Especially, I mean, PyCharm has been up there from the get-go, the start of this survey.

00:54:03.380 --> 00:54:08.380
And us little spunky folk over at VS Code have finally caught up to PyCharm.

00:54:08.380 --> 00:54:10.400
Because if you go back to 2017, we were...

00:54:10.400 --> 00:54:11.500
You and all your extensions.

00:54:11.500 --> 00:54:12.540
That's what it is.

00:54:13.040 --> 00:54:19.540
Because if you go back to 2017, when this was actually added, we were sixth or seventh on that list.

00:54:19.540 --> 00:54:25.940
So we're fairly lucky that the community has decided that we are worthy, as it were, to be up there with PyCharm.

00:54:25.940 --> 00:54:26.560
So, yeah.

00:54:26.560 --> 00:54:26.800
Yeah.

00:54:26.800 --> 00:54:27.360
Awesome.

00:54:27.460 --> 00:54:32.460
I think an interesting story for this is just smart editing in general.

00:54:32.460 --> 00:54:46.680
When we're just looking at the distribution of Python releases, for me, I think 78% is 3.8 or higher, which is great news for me because I like the typing convenience, type hinting conveniences that started to appear in 3.8 and after.

00:54:47.360 --> 00:55:00.040
And it's just a wonderful surprise to me that the Python community values typing and values tooling that puts that to work to help you write better code.

00:55:00.040 --> 00:55:06.320
So for when I look at this, I see this to a degree as a demand for smart tooling, smart editing.

00:55:06.320 --> 00:55:06.740
Yeah.

00:55:06.740 --> 00:55:10.380
And I think that's a really good point that not only...

00:55:10.380 --> 00:55:11.660
I think it's two signals.

00:55:11.660 --> 00:55:15.780
It's one, the community, as Paul said, picking up on typing and smart tooling, I want you to do that.

00:55:15.840 --> 00:55:24.100
But also the tool makers, speaking for myself, realizing that the Python community is big enough and important enough to invest in it, right?

00:55:24.100 --> 00:55:29.600
Because there's always been a conflict of, oh, smart tooling for Python's hard.

00:55:29.600 --> 00:55:31.820
I don't want to do it, right?

00:55:31.820 --> 00:55:37.520
Which is honestly kind of good in a weird way because it led to us having such a good tradition of documentation, right?

00:55:37.520 --> 00:55:39.140
And people care to so much about this.

00:55:39.140 --> 00:55:45.720
I mean, like I know what Michael and Paul have done around Mist and their tutorials and that coming up and being a thing and what's continuously caring about our documentation.

00:55:45.720 --> 00:55:46.460
And all that.

00:55:46.460 --> 00:55:57.720
But it's also, I think, just a showing of, yeah, just where we've all come from all directions, both from a support perspective, the community perspective, and just getting to the point where this...

00:55:57.720 --> 00:56:02.200
Everyone views this as totally reasonable and possible and something people can totally rely on and push on.

00:56:02.200 --> 00:56:05.600
And the community going along with it and going like, yeah, this is fantastic.

00:56:05.600 --> 00:56:08.480
We now have the equivalent tooling, more or less, of other languages.

00:56:08.480 --> 00:56:09.420
Isn't this fantastic?

00:56:09.420 --> 00:56:12.520
Versus, oh, I don't want to use Python because I don't get autocomplete, right?

00:56:12.520 --> 00:56:20.840
Because I know that used to be a big complaint I used to get, which is, once again, the history of us pushing for good documentation, good names and caring and all that stuff and API design.

00:56:21.360 --> 00:56:34.380
So I think, ironically, not having this at the start of the community, back in the 90s and early 2000s, actually has become a benefit long term because we have good practices that have now paid tenfold because good practices plus tooling now.

00:56:34.380 --> 00:56:40.120
Versus, oh, we'll just lean on the tooling and who cares what the name is because everyone's just going to hit dot anyway and just choose the first answer.

00:56:40.120 --> 00:56:40.540
Yeah.

00:56:40.540 --> 00:56:43.860
You know you can't bring me on the show without knowing I'm going to troll a little bit.

00:56:43.860 --> 00:56:51.080
So I just want to point out that the Vim slash Vim mode users are winning in the war between Vim and Emacs.

00:56:51.080 --> 00:56:53.500
Yeah, it's a three to one.

00:56:53.500 --> 00:56:54.940
Yeah, I'm going to leave that.

00:56:54.940 --> 00:56:58.160
Yeah, the Notepad++ folks, they're out there too, but excellent.

00:56:58.160 --> 00:57:02.880
All right, well, we are getting a little bit long on time for everyone on the show's time.

00:57:02.880 --> 00:57:05.060
I could sit here and talk for hours about this.

00:57:05.060 --> 00:57:08.300
This is such a great panel to be here and talking with you all about it.

00:57:08.300 --> 00:57:09.440
It's been super fascinating.

00:57:09.440 --> 00:57:15.580
So maybe we could just close this out with if you have any thoughts on where Python has recently come from and where it's going.

00:57:15.580 --> 00:57:24.940
I'll start it off with just WebAssembly, PyScript, very exciting new PySlice of where Python might show up and make big impact.

00:57:24.940 --> 00:57:27.960
So thank you to everyone who's done that in particular, Brett.

00:57:27.960 --> 00:57:30.340
And I know, Paul, you're working on PyScript stuff as well.

00:57:30.340 --> 00:57:34.140
I'll just say I just hope the community continues to be as fantastic and wonderful as it is.

00:57:34.400 --> 00:57:41.740
I'm sure Emily and anyone else who got to be at PyCon in person this year got to relive that experience after a two-year high-dice and got to see it still alive and thriving.

00:57:41.740 --> 00:57:44.360
And I mean, I've said this before, and I'll continue to say it.

00:57:44.360 --> 00:57:47.160
I came for the language, but I stayed for the community, and I continue to stay for the community, right?

00:57:47.160 --> 00:57:54.320
Like, I literally just had a career conversation with my manager last month, and I opened with saying the reason I'm here and the passion I hold is for this community.

00:57:54.320 --> 00:57:56.180
It's not even specifically for the language anymore.

00:57:56.180 --> 00:58:03.360
The language is the enabler to allow me to help bring more wonderful people to this community and to help others get to enjoy and benefit from this community.

00:58:03.360 --> 00:58:10.520
And I hope that's the future is this community continues to thrive and grow and be that open, welcoming place for everyone who needs that place in their lives.

00:58:10.520 --> 00:58:12.000
I just want to say seven years.

00:58:12.000 --> 00:58:17.160
It took me seven years to go from, hey, this Python thing looks cool.

00:58:17.260 --> 00:58:23.120
I would love to work with this in my day-to-day to now I'm in a job where my focus is working on Python.

00:58:23.120 --> 00:58:27.960
And I don't think that, you know, part of that is just me being persistent and ornery, I guess.

00:58:27.960 --> 00:58:34.120
But then like the other part of that is the fact that the community continues to grow, the resources continue to grow.

00:58:34.120 --> 00:58:36.320
I feel Emily's pain with working with Ruby.

00:58:36.320 --> 00:58:38.780
My first programming language was learning Ruby.

00:58:38.780 --> 00:58:42.960
And the thing that made me switch from Ruby to Python was that community.

00:58:43.500 --> 00:58:47.100
So we have a couple of PSF folks and core maintainers here.

00:58:47.100 --> 00:58:50.740
You know, thank you for making the language what it is, but also thank you for making the community what it is.

00:58:50.740 --> 00:58:54.020
Because without it, I don't think I would be in the role that I'm at today.

00:58:54.020 --> 00:59:00.640
I would like to just hook into this as well, because I went to my very first German PyCon in 2018.

00:59:00.640 --> 00:59:03.280
I felt utterly out of my space.

00:59:03.280 --> 00:59:06.000
I had large imposter syndrome because who was I?

00:59:06.000 --> 00:59:13.240
I was this open source project maintainer who had actually self-taught herself Python because she developed a project in that.

00:59:13.340 --> 00:59:19.300
And now I had the courage to go to a PyCon and I sat there and people just started talking to me.

00:59:19.300 --> 00:59:20.820
And I had so very nice chats.

00:59:20.820 --> 00:59:24.740
And actually the next PyCon, I held my first talk at one.

00:59:24.740 --> 00:59:31.880
So I cannot say that I have ever felt so welcome in the community ever before the Python community.

00:59:31.880 --> 00:59:33.840
So thank you very much for that.

00:59:33.840 --> 00:59:35.180
Yeah, that's awesome.

00:59:35.580 --> 00:59:38.920
Yeah, that seems to be a common trend on our talk.

00:59:38.920 --> 00:59:41.800
So yeah, I actually started out programming with Java.

00:59:41.800 --> 00:59:43.040
Then I moved to Ruby.

00:59:44.380 --> 00:59:45.460
Some other people here did.

00:59:45.460 --> 00:59:49.960
And then I just wasn't, I didn't feel that like the community was that supportive.

00:59:49.960 --> 00:59:55.500
And then when I moved to Python, it was just like, you know, a light bulb came on and the community has been absolutely amazing.

00:59:55.500 --> 00:59:58.840
So thank you to everyone who is supporting me in the community.

00:59:58.840 --> 01:00:00.580
Thank you to our core developers as well.

01:00:00.580 --> 01:00:08.440
I'm definitely excited to see where, you know, of course, where PyScript goes and also to see where like some of the other types of things go, like mobile development and game development as well.

01:00:08.440 --> 01:00:14.540
Looking at all you hear on the screen and just realizing what a great community it is, what awesome contributions you all have made.

01:00:14.540 --> 01:00:16.480
So thank you for being on the show.

01:00:16.480 --> 01:00:20.060
Thank you for reflecting on the survey and the state of community with me.

01:00:20.060 --> 01:00:21.160
It's been great to have you here.

01:00:21.160 --> 01:00:21.840
See y'all later.

01:00:21.840 --> 01:00:22.300
Thanks, Michael.

01:00:22.300 --> 01:00:22.740
Thank you.

01:00:22.740 --> 01:00:22.960
Yep.

01:00:22.960 --> 01:00:23.560
Bye.

01:00:23.560 --> 01:00:27.380
This has been another episode of Talk Python To Me.

01:00:27.380 --> 01:00:29.200
Thank you to our sponsors.

01:00:29.200 --> 01:00:30.800
Be sure to check out what they're offering.

01:00:30.800 --> 01:00:32.220
It really helps support the show.

01:00:32.220 --> 01:00:34.720
Take some stress out of your life.

01:00:34.720 --> 01:00:40.500
Get notified immediately about errors and performance issues in your web or mobile applications with Sentry.

01:00:40.500 --> 01:00:45.500
Just visit talkpython.fm/sentry and get started for free.

01:00:45.500 --> 01:00:49.080
And be sure to use the promo code talkpython, all one word.

01:00:49.080 --> 01:00:53.500
Listen to an episode of Compiler, an original podcast from Red Hat.

01:00:53.500 --> 01:01:00.940
Compiler unravels industry topics, trends, and things you've always wanted to know about tech through interviews with the people who know it best.

01:01:01.060 --> 01:01:05.060
Subscribe today by following talkpython.fm/compiler.

01:01:05.060 --> 01:01:06.780
Want to level up your Python?

01:01:06.780 --> 01:01:10.820
We have one of the largest catalogs of Python video courses over at Talk Python.

01:01:10.820 --> 01:01:16.000
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:01:16.000 --> 01:01:18.680
And best of all, there's not a subscription in sight.

01:01:18.680 --> 01:01:21.580
Check it out for yourself at training.talkpython.fm.

01:01:21.580 --> 01:01:23.480
Be sure to subscribe to the show.

01:01:23.480 --> 01:01:26.340
Open your favorite podcast app and search for Python.

01:01:26.340 --> 01:01:27.560
We should be right at the top.

01:01:27.560 --> 01:01:36.920
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

01:01:36.920 --> 01:01:40.360
We're live streaming most of our recordings these days.

01:01:40.360 --> 01:01:48.140
If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:01:48.140 --> 01:01:50.040
This is your host, Michael Kennedy.

01:01:50.040 --> 01:01:51.340
Thanks so much for listening.

01:01:51.340 --> 01:01:52.500
I really appreciate it.

01:01:52.500 --> 01:01:54.420
Now get out there and write some Python code.

01:01:54.420 --> 01:02:15.280
I really appreciate it.

