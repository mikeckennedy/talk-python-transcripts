00:00:00 Do you have horrible convoluted things that need parsing?

00:00:02 Well, you're in luck because this week we're covering parsing horrible things in Python.

00:00:08 Obviously, you'll learn a bunch of tips and tricks from this episode, but you'll see that advanced parsing is actually a gateway to many interesting computer science

00:00:16 techniques. Listen in as I speak with Eric Rose about his journey to parse weird things at Mozilla.

00:00:21 This is Talk Python To Me, episode 85, recorded October 27, 2016.

00:00:28 Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the

00:00:57 ecosystem, and the personalities. This is your host, Michael Kennedy. Follow me on Twitter where

00:01:02 I'm at mkennedy. Keep up with the show and listen to past episodes at talkpython.fm and follow the

00:01:08 show on Twitter via at Talk Python. This episode has been sponsored by GoCD and Hired. Thank them

00:01:14 both for supporting the show by checking out what they have to offer during their segments.

00:01:17 Hey, everyone. A little bit of news for you. So first of all, I'm doing a webcast next week,

00:01:24 Tuesday, November 22, at 11 a.m. Pacific time. The topic is Write Pythonic Code for Better Data Science.

00:01:31 And I've partnered with Kevin Markham from Data School. And this is 100% free. You can drop in.

00:01:36 And it's kind of like a super miniature version of my Write Pythonic Code course. So if you want to come

00:01:42 check it out and register, just go to crowdcast.io slash e slash Pythonic or click that same link in

00:01:49 the show notes. I was talking to the PyCharm team this week, and they agreed to give away a free copy

00:01:55 of PyCharm Professional every week to one lucky listener. So all you have to do to be in the running

00:02:01 for this is be a friend of the show. Just visit talkpython.fm/friends, enter your email address,

00:02:07 and randomly I'll choose an email address out of the list, and somebody will win. And because we're

00:02:12 doing every week, the odds are pretty decent for you to get a copy. Let's get to this excellent

00:02:16 interview about parsing horrible things with Eric Rose. Eric, welcome to Talk Python.

00:02:22 Thanks for having me, Michael. Pleasure to be here.

00:02:23 Yeah, it's great to have you. I'm really looking forward to parsing horrible things and a bunch of

00:02:28 other stuff.

00:02:29 Well, nobody in their right mind really looks forward to parsing horrible things, but it's something we

00:02:33 have to do.

00:02:33 Well, when you have horrible things and you want to parse them, someone's got to do it, right?

00:02:37 That's right.

00:02:38 So I think it's, we're going to talk about some really cool techniques, some libraries,

00:02:42 some algorithms, and whatnot to pull that off, and some interesting work and talks that you've done.

00:02:47 But of course, before we get into those, let's start with your story. How do you get into

00:02:50 programming in Python?

00:02:50 Well, I mean, I used to be a Legos kid, right? You know, like snapping those things together.

00:02:55 And of course, the thing about being a kid is you have no economic power, so you've only got the

00:02:59 ones you've got in the box, and you get at birthdays, and you get at Christmas or what have you.

00:03:03 And so I kind of discovered programming as a way to program with, to build with Legos without ever

00:03:09 worrying about running out of parts. And so I became kind of an early collector of programming

00:03:13 languages, you know, before the internet. So you have to get these things kind of happen upon them

00:03:17 on floppy disks or whatever. And I did basic and I did hyper card and kind of learned programming

00:03:22 through mimicry like we all did in the 80s. You know, you get these magazines with program listings

00:03:28 in them. And you just kind of have to type them in if you want to play with them. And so you're just forced to plow

00:03:34 linearly through these things, making mistakes throughout. And that kind of teaches you debugging and proofreading.

00:03:39 And you come to all kinds of wrong conclusions. Like I remember in hyper card, there's this statement global

00:03:45 start flag, which of course the global variable declaration, but I thought it was this round checkerboard cursor,

00:03:51 which totally looked like a global start flag to me. So, you know, fast forward two dozen languages later

00:03:57 and I ended up working at a university over at Penn State and we had this crazy seminar registration

00:04:03 system called SEMREG. Maybe they're still running it. I really hope not. And it was, well, the simple thing

00:04:10 I could say is it was written in VBScript, but really it was written in PHP and then transliterated into

00:04:17 VBScript via a series of regular expressions. Wow. That's crazy. I've never heard of anything

00:04:22 being compiled from PHP to VBScript. Absolutely insane. And compiled is probably too kind of a word,

00:04:27 but, so I didn't realize this when I took the job, you know, I've become a lot smarter about

00:04:33 interviewing since then, I hope. And I thought I'm going to give this a chance. You know, I'm this big

00:04:37 Mac guy and I, it was, it was the height of the platform wars and windows was terrible, but I, you know

00:04:42 what? I'm going to, I'm going to not be a jerk. I'm going to give this thing a chance. I'm going to see if I

00:04:45 can write stuff in VBScript. And the short answer is you can't write anything in VBScript.

00:04:49 The thing has classes, but no inheritance. And, so, you know, with a little detour through making

00:04:56 my own, prototype based inheritance language out of the call statement, I thought, okay, we need to

00:05:03 bridge this over to something more usable. And Python was very well supported at the time on Windows

00:05:09 scripting host, which allowed me to do ridiculous things like share a database connection between the

00:05:14 legacy VBScript code and the new Python code. And that's how I got into Python, believe it or not.

00:05:20 Interesting. Because if you can get a drawer in the script host, you can basically get it the same

00:05:24 environment as this other bad thing, right? Yeah. You can kind of mash it all together. It'll bridge

00:05:28 strings to strings. It'll actually bridge objects to objects and methods to methods, numbers to numbers.

00:05:34 And if you bang on it hard enough, you can get database handles shared and share a single

00:05:38 transaction between the two languages. So I was very fortunate to happen upon Python that way.

00:05:43 Yeah, that's great. And it looks like you've been doing a bunch of Python since then, huh?

00:05:47 Well, Python is a really, nice little patchwork of, of, of stolen bits of language.

00:05:53 There's not a whole lot unique about Python, which I think is one of its strengths apart from maybe the

00:05:57 width statement, but it knows where to steal all the best things, the list comprehensions out of Haskell,

00:06:03 for example. And, you know, Hey, we're going to steal, you know, class-based object orientation

00:06:08 from wherever that came from small talk, I guess, but we'll also have top level functions from any

00:06:13 number of languages. So I've been pretty happy with it. Yeah, absolutely. And it's still,

00:06:17 still on its way to doing that thing with like async and await in the latest version, right? Which is

00:06:22 a fantastic language feature. Yeah. We'll see where that goes. I haven't played with it myself.

00:06:26 Yeah. I'm still looking for a good use case for that as well, but it's, it's definitely a neat

00:06:29 concept. So how about now? What do you work on these days?

00:06:33 Well, day to day, I maintain a project called DXR over at Mozilla, which doesn't really stand for

00:06:39 anything, but is a language analysis and navigation tool for large code bases. So

00:06:45 Firefox is something like 17 million lines of code. You know, if you want to make a change,

00:06:50 you've got to be thinking, well, what am I going to break with this change? Who am I affecting?

00:06:53 What functions call this function that I want to change? What, what eats the result of the

00:07:00 contents of this variable that I want to alter or, what invariant might I be violating here?

00:07:06 And DXR answers those kinds of questions through a structured query language and through both text

00:07:12 search and a cleverly accelerated regular expressions search. So you can get through these 17 million

00:07:17 lines with a regex in, you know, sub second. Wow. And how you said 17 million lines of code. That's,

00:07:24 that's quite impressive. That's bigger even than I thought it would be, but I knew that was huge.

00:07:29 How many languages are involved in that? Oh, that's a crazy question to ask. Well,

00:07:34 okay, I'll just go with language. So HTML is a language though, not programming language,

00:07:39 arguably CSS is Turing complete. Someone has proved as long as it's level three. So that's a programming

00:07:45 language. Now a lot of the UI is written in JavaScript. A lot of the down and dirty stuff

00:07:50 is written in C++. And more recently we've begun importing, Rust into the code base.

00:07:55 Rust is now a part of the released Firefox and, and more and more with the release of project quantum,

00:08:01 which was just announced last week, will be ported over to rust. So it's, so we can make more

00:08:07 guarantees so it can be safer and more concurrent. Nice. And what's, what is project quantum?

00:08:12 Project quantum. Let's see if I can get this right. Is a Mozilla project just became unsecret to import a lot of our

00:08:22 experimental, a Rust based rendering pipeline into Gecko, which is the current released,

00:08:28 Firefox pipeline. So project, that I mentioned serve already. I forget.

00:08:33 No, the sort of thing we're importing things from is servo an experimental web renderer written in rust,

00:08:40 a CSS renderer, HTML, all that jazz. And, yeah, we're, we're pulling bits of that into Gecko.

00:08:47 Okay. That's awesome. It's a very exciting time that'll let us be more concurrent and use all these

00:08:52 different cores on all these different things. You know, phones even have four cores now.

00:08:55 Yeah. Watches even have multi cores now.

00:08:57 Yeah. It's crazy. It's a crazy time to live.

00:08:59 It is a crazy time. You said another thing you're working on is fathom. What's fathom?

00:09:03 So fathom kind of, fits into all this, this parsing subject. Fathom is my new kind of toy over at

00:09:08 Mozilla. It's a mad scientist project to see if we can make it easier to write semantic extractors for the web.

00:09:14 So an example of a semantic extractor you might know is something along the lines of readability

00:09:18 or a browser's reader mode, where it just pulls the content text out and dispenses with headers and

00:09:24 footers and ads and such. But other things you might want to extract are, Hey, let's, let's teach a browser

00:09:30 to recognize what a previous or next button looks like. So that maybe the browser can let you assign

00:09:35 a keystroke to that in the general sense and not have to chase them as they bounce around as you advance

00:09:40 through a slideshow. Or maybe we can teach the browser at a deeper level to appreciate what an

00:09:45 advertisement is or what a navigation element is. So maybe we can collapse those on small screens and

00:09:50 hide them in a menu. There really, there's really endless potential to this. And I'm trying to

00:09:56 fix it. So those extractors are easier to maintain, faster to write and become less of a mess.

00:10:02 If you were to read the readability source code, which is kind of the thing that both Firefox's

00:10:08 reader mode and Safari's reader mode are based on, you get the sense that it's been written by hand,

00:10:13 maintained over time. There is state flying everywhere. It's hard to tell where to make tweaks.

00:10:21 So what Fathom does is express these extractors as lists of unordered rules in a prologue sense. If

00:10:28 you've ever played with prologue, it's just a whole bunch of kind of, logical statements. And then

00:10:32 the environment figures out how to fit those together and run them. Well, Fathom, works along those

00:10:37 same lines. And as a result, since order doesn't matter, third parties can tweak and, can tweak an

00:10:45 existing extractor just by inserting their own rules. They can say here, whenever you see a,

00:10:50 whatever kind of element, for example, I want to boost the score by this much or lower it by that

00:10:55 much. Nice. So you could put like understanding of time of calendars and dates and whatnot, possibly

00:11:01 as another rule. Exactly. Hey, this looks like a calendar or, Hey, this looks like a payment form.

00:11:05 Let me help you fill it. Yeah. Okay. Yeah. That's awesome. Is that in Firefox yet? Or is this,

00:11:11 this is just a project so far? We hope to get it in so that, other things,

00:11:15 can make use of it more easily, but, it's already embeddable within Firefox add-ons and has

00:11:20 been embedded in, at least one add-on. It's kind of a Fathom debugging add-on.

00:11:25 it runs on the server side. It's all just kind of vanilla ES6. You can compile it down to ES5 for

00:11:30 older browsers. It kind of runs all over the place. I wrote it in JavaScript despite not liking

00:11:35 JavaScript myself so that we could get it, popular. Yeah. Sometimes, sometimes you got to go with

00:11:41 that. Well, that sounds really cool. And then another thing that you're involved in is

00:11:44 let's encrypt, which is very exciting. Yes. Let's encrypt has probably got the easiest

00:11:49 business plan I've ever heard, which is to give away a hundred dollar bills.

00:11:52 How's that work? How do I, how do I get my a hundred dollar bill?

00:11:55 Well, if you've ever bought a, well, it's very easy. So certificates, this is all certificates have historically been fairly expensive on the order of a hundred bucks.

00:12:04 And there are some other ways to get cheaper ones through start SSL or Komodo or whatever is kind

00:12:09 of a hassle. But what we do is we have a little command line tool that you run. And if,

00:12:14 if you can authenticate yourself to our little, certificate creating server through a DNS record or

00:12:21 putting a little thing on your server temporarily, then we will give you a cert, which is recognized by

00:12:27 all the major browsers. So really there's no way, no reason not to use it at this point.

00:12:32 Yeah. So having encrypted content is obviously important if you're doing like e-commerce or something

00:12:38 like that, but it's also just becoming increasingly important to be a first class citizen on the web,

00:12:43 right?

00:12:44 It really is. It, I mean, it gives you the impression of trust. First of all, if people are

00:12:48 watching their URL bars, but also it's important for your visitors just to have the requests be private.

00:12:53 If I'm surfing to Wikipedia and, not doing anything particularly suspicious, but say I have a

00:12:59 suspect, I have a medical condition and I'm reading about all these different skin diseases or whatever

00:13:04 is ailing me. I don't want my ISP logging that away and selling it to their marketing partners,

00:13:10 which until the FCC's ruling last week was perfectly legal to do state actors. I mean,

00:13:16 the best defense we have against really anybody in the future coming to power and looking into our past

00:13:23 and seeing things they don't like, and then coming down on us is keeping things that are our business,

00:13:27 our business and using, SSL certificates and surfing to secure sites is the best way to do that

00:13:34 right now.

00:13:34 Yeah. And the fact that let's encrypt is, is free makes that very, very possible. And I think that's,

00:13:40 that's great. You know, there's a really interesting studies quoted in the original Edward Snowden book

00:13:47 that came out, I think, by Greenwald. I can't remember that guy's glad Greenwald, I believe.

00:13:52 Yes. That guy. And it was a great book. And basically, you know, a lot of people say, look,

00:13:56 I don't care about this privacy stuff. Like I have nothing to hide, but there've been psychological

00:14:01 studies and social, social studies saying people behave differently. If they know somebody's listening,

00:14:07 they might not break a rule in private, but they behave differently. They are slightly more private,

00:14:13 less willing to think, you know, sort of contrarian ideas and at least share them. And the less that

00:14:19 people are watching the better as far as I'm concerned for, for people in general.

00:14:24 Yeah. It's really the idea of chilling effects, which came out of some academic institution. It's

00:14:29 a wonderful phrase. And when you have chilling effects in operation, where you are afraid to do

00:14:35 perfectly legal things, which otherwise you might not do, democracy really cannot function.

00:14:40 How democracy works is by means of, well, really the Overton window, this range of things that you're

00:14:46 allowed to say and think that don't get you kicked out of cocktail parties.

00:14:50 And this window moves around over time. It's, you know, yesterday's conservative, rather yesterday's

00:14:56 progressive is today's conservative. And if we're not allowed to play with ideas that are just outside

00:15:02 the bounds of the Overton window, then the future really has nowhere to pick its new ideas from.

00:15:07 And we just kind of stagnate and the powers that be become the powers that always will be.

00:15:12 And the ideas that are, are the ideas that always will be, and we can't really go anywhere.

00:15:17 So, yeah, I think privacy is key to having a functioning democracy at all.

00:15:22 Yeah, I totally agree. And if you don't buy that, Google ranks sites higher if they have SSL.

00:15:28 We all want to rank higher in Google, right? So there's the Google juice.

00:15:31 There's the final straw to, like, start encrypting stuff. My blog's encrypted. This podcast site is encrypted and so on.

00:15:38 And I think it's great. Happy to do that on as much as I can.

00:15:42 I'm wondering, how did you become interested in parsing all these horrible things? Where did you get started with that?

00:15:48 Well, I guess, I guess it probably started when I was seven years old and playing around with basic and hypercard and thinking,

00:15:54 oh, you know, I want to write my own programming language because, of course, you're seven and no one has told you that it's hard.

00:15:59 And if you spend a couple of days trying to do that with just if statements, you end up in this spaghetti-fied mess and you can't get anywhere.

00:16:07 And you're just amazed that anyone has ever managed to write a language ever.

00:16:11 So, you know, then put in a little pause of about 25 years and it came up at work.

00:16:17 Over at Mozilla, we had a support site. We still have a support site.

00:16:22 Support.mozilla.org. And it's got a wiki and it's got a Stack Overflow clone and all this different stuff to help out people who are using Firefox and our other products.

00:16:30 And our wiki is powered by not MediaWiki itself, but the MediaWiki syntax for various hysterical purposes, as we like to say.

00:16:41 And not only do we want the MediaWiki syntax, but we wanted to be able to add our own little directives to the syntax.

00:16:48 Crazy little things that'll maybe, well, one example is we wanted to change the text that would come up according to which version of Firefox someone was using to visit the site.

00:16:57 It was very, very difficult to make those edits to the implementation of MediaWiki that we were using, which was a port by David Kramer, very nice little port, of the original MediaWiki machinery.

00:17:10 Such a direct port, in fact, that it still had dollar signs in the comments from the PHP.

00:17:15 Right. Yeah, it was originally PHP and you guys translated it over to Python and that helped because at least you were working in Python.

00:17:22 But you said the way that it worked was the parser was pretty insane.

00:17:25 Like it was just like a crazy bunch of regexes, right?

00:17:28 Yeah, there were, I think, 41 regexes.

00:17:31 And then there was another 2,100 lines of PHP, which just ran them over and over again against the source text, finding and replacing and finding and replacing, hopefully in the right order, interacting with each other, dropping little markers so that they didn't smash over each other when they shouldn't.

00:17:47 And then hopefully at the end out comes the proper rendered text.

00:17:51 Of course, in reality, MediaWiki language changes from release to release as they find little corner cases that this crazy slapdash loopy way didn't handle.

00:18:01 Yeah, you called it the Klingon MediaWiki.

00:18:04 Yeah, I look at these regexes and I think, well, this is the original Klingon, clearly.

00:18:08 Yes, obviously.

00:18:09 Nice.

00:18:11 And so you were looking for a way to escape this Klingon parser world and create something nicer.

00:18:19 Like one of the problems you said that was inherent in the algorithm was it would directly parse into its new representation.

00:18:26 Right.

00:18:27 There was never an intermediate representation.

00:18:29 So tell people what, like, is, like, why do you care?

00:18:32 Like, what's the intermediate representation do for you?

00:18:35 Well, it gives you flexibility, like any abstraction.

00:18:37 So let's say we have this imaginary intermediate representation for MediaWiki syntax.

00:18:42 We bring in the MediaWiki syntax.

00:18:43 We parse it into a tree because that's what all these things end up as in parsing land.

00:18:48 And then we have a lot of options.

00:18:49 We can output plain text from that, ignoring the bits of the tree that say bold or italic.

00:18:55 We can render out HTML from that, not ignoring those things.

00:18:59 We can go hunting through for just, say, date or time elements and pull out some date and timey entities.

00:19:06 Once you have this abstraction, you have any kind of output you like.

00:19:09 Or you can do any kind of analysis or transformation you like.

00:19:12 Nice.

00:19:12 So, for example, if you wanted to possibly represent stuff by a markdown output or an HTML output or plain text, those are super easy because both, like, markdown and HTML have a bold concept.

00:19:25 One is a bracket, you know, angle bracket strong.

00:19:27 One is a star.

00:19:29 But it's, you know, you can do that final translation pretty easily once you have the tree, right?

00:19:34 Exactly.

00:19:34 That's the trivial part, going from tree back to a linear representation.

00:19:38 So the hard part is getting it into a tree, huh?

00:19:41 Right.

00:19:41 Now, we're doing that as we talk, which is nice.

00:19:44 Now, you make a linear sequence of sounds.

00:19:46 And I hear them.

00:19:47 And I deconstruct them back into, you know, phrases and word pairs and things and idioms.

00:19:51 And I say, wow, that's probably what he means.

00:19:53 And then you do it back from my end.

00:19:55 Yeah, exactly.

00:19:55 So pretty much pulling structure out of any flat, linear stream of data is parsing, right?

00:20:02 Exactly.

00:20:03 And so the applications are as wide as you like.

00:20:06 I mean, anything that has any kind of structure, text, sound, you can think of musical phrases

00:20:11 and the sorts of, a lot of music has a theme in variations or development of a thematic statement.

00:20:17 On one hand, I sort of can see how you would do some of this with regular expressions.

00:20:22 But it's really the goal is to move it into this parse tree because then it's not just transforming

00:20:27 one bit of text into another text, but it's actually transforming into the structure that

00:20:30 we can do all kinds of interesting things, huh?

00:20:33 Well, right.

00:20:33 And more formally, regular expressions can't really support nesting.

00:20:37 Now, there are little corner cases that people were going to write in about where things that

00:20:42 are called regular expressions nowadays, like in Perl, have support for nesting bolted on,

00:20:47 but then they cease to become proper regular expressions.

00:20:49 Exactly.

00:20:50 Proper parsers, on the other hand, descend into the, what we call, like, Chomsky type one or

00:20:56 two grammar and can support nesting.

00:20:59 So you could say, understand sets of nested parentheses of arbitrary depth.

00:21:04 And that's how things like, well, HTML, for example, are.

00:21:08 You could have a bold tag with an italic tag in it with another bold tag in it at infinitum.

00:21:13 Yeah.

00:21:13 Div, span, A, all sorts of stuff.

00:21:17 Yeah.

00:21:17 More div.

00:21:18 And in addition to the nesting, a proper parser gives you the ability to read what you're doing,

00:21:22 essentially.

00:21:23 Regexes are famous for being a write-only language.

00:21:27 Absolutely.

00:21:27 I definitely think of them as write-only.

00:21:29 Yeah.

00:21:29 And you can comment them as much as you like and put white space in there, but it still

00:21:33 becomes, you know, at least awkward to name sub-patterns, to repeat sub-patterns, and to

00:21:39 maintain something where you have repeated bits of regex.

00:21:42 Sure.

00:21:42 Well, and as it gets increasingly complicated, the more you need the regular expression, the

00:21:46 less you can understand it, I think.

00:21:48 Yeah, for sure.

00:21:48 There seems to be a ceiling for one reason or another with straight-out regexes.

00:21:52 Yeah.

00:21:52 So you talked about there being different types of grammars that are different complexities

00:21:58 of grammars.

00:21:59 Yeah.

00:21:59 There's the idea of the Chomsky hierarchy of grammars.

00:22:02 And Chomsky is really a linguist.

00:22:05 And so he spoke of these grammars in terms of generative power, where, you know, I can

00:22:11 start from a production, a production name, something like sentence, and then descend in

00:22:16 one level and say, well, sentences, you know, phrase, and then maybe another phrase, and maybe

00:22:20 another phrase.

00:22:21 And what are the phrases?

00:22:22 Well, we have a subject, and we have verb, and we have an object.

00:22:25 And he's interested in creating sentences from the top level.

00:22:28 Now, as computer scientists, we're usually more interested in going in the opposite direction,

00:22:34 starting with this complete sentence, and then kind of inferring out the structure, recognizing,

00:22:40 as they call it in the literature.

00:22:41 So Chomsky came out with Chomsky hierarchy of grammar, something like that.

00:22:46 Anyway, levels 0, 1, 2, 3, and 4.

00:22:49 And type 0 is basically a free-for-all.

00:22:53 It kind of comes out looking like a directed graph.

00:22:56 And there's not really, really available kit for parsing that sort of thing, or any algorithmic

00:23:02 bounds to its complexity.

00:23:03 When we get down to a level 1, that's your context-sensitive grammars.

00:23:08 And Python is actually a context-sensitive grammar, I believe only for the reason that it has,

00:23:13 only because it has whitespace sensitivity.

00:23:15 So I was actually trying to parse something like Python the other day, a little side project

00:23:20 of mine called Turtles.

00:23:21 And I ran up against this.

00:23:23 When you indent in Python, in a normal language, in a curly brace language, when you go inward

00:23:29 a block, you say, curly brace.

00:23:31 And then when you end a block, you say, end brace.

00:23:34 Now, in Python, think about trying to write a tokenizer for Python, trying to find those

00:23:40 instances where we go in a level or out a level.

00:23:42 You're reading along, you're reading along.

00:23:45 You're at the beginning of a line, and you see eight spaces.

00:23:48 Did you go in a level?

00:23:49 I don't know.

00:23:50 What is the previous line?

00:23:52 Is it four spaces?

00:23:53 If so, I went in a level.

00:23:54 So you can see that eight space span is interpreted differently depending on our context, depending

00:24:01 on what the previous line had done.

00:24:02 So Python is a context-sensitive grammar.

00:24:05 Now, the rest of Python is at Chomsky level two, which is a context-free grammar.

00:24:12 So if you were to dig into the Python source code, one of these files there, there's a little,

00:24:16 let's see if I have it sitting here, a nice little sort of summary where it says, okay,

00:24:22 here's what a suite is, a series of statements.

00:24:24 A suite is a statement, statement, statement, or statement star.

00:24:27 But it's always that.

00:24:28 A suite is always this.

00:24:30 An if statement is always that.

00:24:31 You know, a function definition is always this.

00:24:34 It doesn't matter what came before or what comes after.

00:24:36 It's context-free.

00:24:38 Right.

00:24:38 Like, the if statement doesn't mean something different if it's in a while loop.

00:24:43 It always means the same thing.

00:24:45 So if you know what an if is, like, if you can define the structure of an if, you can define

00:24:49 its meaning.

00:24:50 And you don't have to do more interesting parsing.

00:24:52 Yep.

00:24:52 All the time.

00:24:53 All the time, if means the same thing.

00:24:54 There are no modes to go into or out of.

00:25:11 This portion of Talk Python To Me is brought to you by GoCD from ThoughtWorks.

00:25:16 GoCD is the on-premise, open-source, continuous delivery server.

00:25:20 With GoCD's comprehensive pipeline and model, you can model complex workflows for multiple

00:25:26 teams with ease.

00:25:27 And GoCD's value stream map lets you track changes from commit to deployment at a glance.

00:25:33 GoCD's real power is in the visibility it provides over your end-to-end workflow.

00:25:38 You get complete control of and visibility into your deployments across multiple teams.

00:25:43 Say goodbye to release day panic and hello to consistent, predictable deliveries.

00:25:47 Commercial support and enterprise add-ons, including disaster recovery, are available.

00:25:52 To learn more about GoCD, visit talkpython.fm/gocd for a free download.

00:25:58 That's talkpython.fm/gocd.

00:26:02 Check them out.

00:26:03 It helps support the show.

00:26:04 One of the things that you said, a quote from your PyCon 2012 talk, which I'll link to

00:26:18 the show notes, of course, was that parsing is a gateway drug to other areas of computer

00:26:24 science.

00:26:24 It's true.

00:26:25 I mean, once you have this tree-shaped intermediate representation, you can do anything you want.

00:26:30 You can get into natural language processing, which if you're doing any of this in Python,

00:26:35 NLTK is a not-to-be-missed library.

00:26:38 It, first of all, is a shining example of what all library documentation should be.

00:26:43 There is an NLTK book freely available and is a fantastic place to start if you want to

00:26:48 start understanding human language with a computer or doing sorts of data mining and machine learning.

00:26:53 It's also full of those sorts of algorithms.

00:26:55 Great piece of kit.

00:26:56 Yeah.

00:26:56 Awesome.

00:26:57 Awesome.

00:26:57 Also, from the intermediate representation, you can get into programming language design.

00:27:01 That's fun.

00:27:02 Make your own little toy language.

00:27:04 Anybody can make a lisp in a couple of days because the parsing is so darn simple.

00:27:10 It's just a bunch of nested parentheticals.

00:27:13 There's a lot of parentheses there.

00:27:16 Yeah.

00:27:16 Now I'm a lot less intimidated to reach for custom little query languages.

00:27:21 Like, DXR has a custom little query language, which looks a lot like Google's custom little

00:27:25 query language.

00:27:26 And it's, you know, 10 or 20 lines of grammar description that I feed into my library parsimonious.

00:27:32 And out comes the tree.

00:27:33 Yeah.

00:27:34 That's really cool.

00:27:35 I feel like when you learn these new techniques and these data structures and algorithms, like, you see problems where you just saw opaqueness before.

00:27:44 You're like, oh, I could actually apply this thing.

00:27:46 And out would pop interesting answers.

00:27:48 Whereas before, you're just like, there's no way I can answer that.

00:27:50 That's just text blobs, not structure.

00:27:53 Yeah, for sure.

00:27:53 It's just pattern recognition.

00:27:54 The more you've exposed yourself to, the more you'll say, hey, this is just one of those.

00:27:59 Let's review some of the various options for parsing text in Python today.

00:28:04 So there's two pretty well-known ones that have been around for a while.

00:28:09 There's PyParsing and there's PLY.

00:28:11 So David Beasley's Python Lex Yak.

00:28:14 Yeah, PLY is fantastic.

00:28:16 And anything that David Beasley does is fantastic.

00:28:19 You should immediately pause the podcast and go watch all of his talks.

00:28:24 PLY came out of when he was teaching a course on building your own little Pascal interpreter, I believe.

00:28:31 PLY has the advantage of being tripped over by hundreds and hundreds of students.

00:28:36 And they've hit every little corner case and made every possible mistake.

00:28:39 And so the error reporting is top notch.

00:28:42 And really, I would seriously recommend taking a look at PLY if the complexity of what you're parsing is amenable to it.

00:28:50 Now, the limit of PLY and why I couldn't use it for the MediaWiki stuff is that it implements what we call LR1 parsing, which you can look up the formalisms.

00:29:00 And I probably forget most of them.

00:29:01 But this is something we did.

00:29:02 I think most languages that are currently in production probably use something along the lines of LR1 just because it's very, very memory efficient and CPU efficient as well.

00:29:13 So it was a thing that we implemented when we had tiny little computers.

00:29:15 But where you run into problems is that LR1, that one means we can only look ahead one token to decide what kind of thing we're recognizing.

00:29:27 And in the case of MediaWiki, that wasn't actually enough.

00:29:31 For example, I believe it was internal links that begin with two brackets, bracket, bracket.

00:29:37 So it's not every time that bracket, bracket means an internal link.

00:29:42 It has to be followed by, oh, I'm going to get this wrong, but something along the lines of maybe a URL or page name, and then maybe a vertical bar, and then maybe a page title.

00:29:56 And so you might have to look ahead two or three tokens to see if your internal link is going to work out.

00:30:02 And if it doesn't, that bracket, bracket is just part of plain text and should be emitted verbatim.

00:30:07 And so we couldn't use any LR1 parser, and I put that on my shopping list and ruled out a whole lot of libraries because of it.

00:30:14 Right.

00:30:14 It just needs to keep more of it in its head, in the algorithm, all at once, right?

00:30:19 Pretty much, yeah.

00:30:20 All right.

00:30:20 So what's the story with py parsing?

00:30:22 So py parsing is what I consider or was the canonical, I reached for it first, Python parsing library before I wrote my own, of course, because I'm in that bad habit.

00:30:32 And py parsing is, you know, fairly Pythonic.

00:30:35 It mashes all the grammar definition stuff into Python objects.

00:30:42 So you literally say in a piece of Python, bold toggle equals literal parentheses, and then you construct an object, you say, quote, quote, quote, and say, okay, well, quote, quote, quote, is the thing that turns on bold in media wiki syntax.

00:30:57 And then on that object, you call methods like set name bold toggle, so that when you have this tree, you can actually tell that this thing was a bold toggle as you're walking the tree.

00:31:07 And kind of on you go.

00:31:09 Now, the disadvantage of this is it's kind of hard to read.

00:31:14 It's kind of wordy because, after all, we had to make this a valid Python.

00:31:18 And you can't do certain things like make forward references.

00:31:22 And oftentimes there are cyclical references in a non-trivial grammar.

00:31:26 In the case of py parsing, they had to put a little hack around that and say, you know, bold toggle equals forward, which is sort of a promise that I'm going to declare something later.

00:31:37 And then later on, you kind of jam that on.

00:31:40 For people who haven't seen the syntax of py parsing, it's kind of like formalized Python that acts as regular expressions.

00:31:49 So you'll see like Python objects, but they're clearly coming from sort of regular expression land like groups and whatnot, right?

00:31:58 Well, I mean, groups is a valid word to use when you're talking about parsing.

00:32:02 After all, we're talking about trees here, and a tree is nothing more than a nested list.

00:32:06 And so every sub list you can think of as a group.

00:32:09 So that's what py parsing is doing with the groups.

00:32:11 Yeah, okay.

00:32:12 And py parsing is of, I think, equal power with parsimonious.

00:32:17 They're both able to describe all the context-free grammars and probably a subset of context-sensitive ones.

00:32:25 And parsimonious is your library that you wrote, right?

00:32:28 Yes, it's my mad scientist experiment.

00:32:30 Though its version number starts with zero point, I have it in production all over the place.

00:32:35 There are lots of people using it, so.

00:32:36 Nice.

00:32:36 Do you have some examples for what it's being used for?

00:32:39 Yeah, well, I'm using it in DXR to parse our little query language.

00:32:42 What awesome people are using it for?

00:32:44 You know, they don't report back to me, but it gets a lot of downloads.

00:32:47 Yeah, excellent.

00:32:48 So it's out there somewhere.

00:32:49 Excellent.

00:32:49 So to me, it seems like parsimonious, it's a little simpler to define the grammar.

00:32:54 Is that right?

00:32:55 That was really my goal, both to make it simpler, to make it run fast, and to make it optimizable.

00:33:01 One of the goals you said was frugal RAM use, which I thought was just a great way to phrase it.

00:33:08 Yeah, and I haven't done a lot of RAM profiling, so I'm not ready to make any claims about that just yet.

00:33:13 But the formalism underneath parsimonious, which is parsing expression grammars, which come out of a 2004 paper by Brian Ford, meet that goal just fine.

00:33:22 I think RAM use is something along the lines of order n to the third, but n is the grammar size, so it's actually not that big an n.

00:33:31 And as a result of blowing that RAM, it's caches for each individual little production, each individual little context-free equals.

00:33:40 You get linear parse time.

00:33:42 Yeah, which is great.

00:33:43 Yeah, that's really, really nice.

00:33:44 So the reason people care about RAM is, I mean, if you're running this over some text and you're just going to dump it out and produce a text version, that's fine.

00:33:54 But if you're wanting to keep that in memory and say like a web server and continuously serve requests from it or something, then all of a sudden you care way more about RAM, right?

00:34:04 Well, just imagine serving up a bunch of media wiki pages and you've got to be parsing 100 of these at a time on a web server.

00:34:10 You know, RAM is not free.

00:34:12 No, it's definitely not free, especially if you've got a lot of traffic.

00:34:15 So one of the algorithms involved in here is you said that it uses something called the PackRat algorithm, which sounds fun.

00:34:23 What's that?

00:34:25 Yeah, I think Ryan Ford came up with that too.

00:34:26 It's really simple.

00:34:28 It's what you would come up with yourself if you're implementing one of these.

00:34:31 These PEG parsers, PEG parsers, they're really just recursive descent parsers.

00:34:36 And as you descend, you might find out, hey, now that I've looked ahead to tokens and I find out this internal link isn't going to work out for me, I need to rewind a little.

00:34:45 Let me take a couple steps back up the stack and let me try parsing it as plain text, for example, or maybe as an external link, for example.

00:34:52 And in the course of that, you may need to use a partial parse from a previous stack frame.

00:34:58 And rather than redoing that work, it makes sense oftentimes to cache the results of each partial parse.

00:35:04 And that's all the PackRat does.

00:35:06 Just keeps all these intermediate results around.

00:35:08 I see.

00:35:09 Basically to allow you to look ahead an arbitrary number of tokens and then adjust.

00:35:14 Without paying a penalty of redoing work.

00:35:16 Exactly.

00:35:16 Right.

00:35:17 Yeah.

00:35:17 Yeah.

00:35:17 Very cool.

00:35:18 Well, one of the things I was mostly trying to do with parsimonious, one of the things that really the thing that differentiates it so much, was that its grammars look a lot like what you'd find if you looked up the definition of the grammar in a book or in the documentation.

00:35:30 They're just big blobs of multi-line text in the Python quote, quote, quote, quote way.

00:35:35 And so it's able to do forward references because it's not bound to the idea of undefined symbols in an outer programming language.

00:35:42 We're able to do compile time optimizations on it really without limit because we haven't lost anything in its transformation down to a bunch of Python objects prematurely.

00:35:54 And it's also very easy to read as a result.

00:35:56 And you also keep the representation part as a separate phase so you can render to multiple formats, which is cool.

00:36:04 Yes, exactly.

00:36:05 A lot of these Python, not Python rather, but a lot of these parsing kits tend to inter-twingle output rendering with parsing.

00:36:12 And that way leads to pain in my experience.

00:36:17 Certainly rigidity.

00:36:19 Interesting.

00:36:20 It sounds like your parsimonious project is really cool.

00:36:24 And it's on GitHub.

00:36:24 People can check it out, right?

00:36:26 Please.

00:36:26 Send feedback.

00:36:27 Play around with it.

00:36:28 Send patches.

00:36:29 Okay, cool.

00:36:29 Yeah, one of the things that made me a little bit sad about PyParsing is it's on SourceForge, which I don't know.

00:36:35 Wow, still?

00:36:36 Yeah, when I see things on SourceForge, it kind of makes me feel like, oh, I'm not really sure that thing's actually still going.

00:36:42 Yeah, right on the homepage it says, download now from SourceForge.

00:36:45 It's like, oh.

00:36:46 Oh.

00:36:46 Oh.

00:36:47 Oh.

00:36:47 Okay, that's unfortunate.

00:36:49 It's still fine code.

00:36:50 I mean.

00:36:51 Yeah, of course.

00:36:52 It is a single 3,000 line file.

00:36:54 But, you know, old doesn't mean bad.

00:36:58 It means proven.

00:36:59 Yeah, absolutely.

00:37:00 Absolutely.

00:37:00 So that was a really cool talk on parsing horrible things you gave.

00:37:04 Do you have some other favorites?

00:37:04 Oh, let's see.

00:37:05 What else have I done?

00:37:06 I have a talk called Poetic APIs, where I kind of will expand on the idea that, you know, these grammars, they should be really easy to read.

00:37:15 In fact, all programs should be easy to read.

00:37:17 In fact, here are seven, you know, kind of checklist-y things you can bang against what you're writing to make sure that you set a good language for the users of your API.

00:37:27 Oh, interesting.

00:37:27 Yeah.

00:37:28 What we're doing when we're programming is always creating language.

00:37:31 Every time we name a function, name a variable, create semantics of an object, we're kind of creating the mental model in which everybody who interacts with that code in the future has to play.

00:37:44 So if we do that irresponsibly, we can really make people think terrible, stupid thoughts that make their jobs hard.

00:37:50 But if we give them really good symbols that correspond well to reality and are easily composable and flexible, like the requests package is a great example.

00:38:00 Like, hey, you know what?

00:38:01 We could just totally represent HTTP requests instead of making everyone think about raw sockets all the time, like URL lib.

00:38:07 Then people can have their efforts magnified.

00:38:09 Yeah, it really does define the way that you think about a problem, the APIs and whatnot you have to work with, and the language itself, right?

00:38:17 And so I think Python itself is something, an example of, like, why that's important, right?

00:38:22 Well, yeah, I mean, so Python is a fairly close match to what we tend to write as pseudocode.

00:38:29 Right, and the reason we write pseudocode is it's easy to understand and communicate, so.

00:38:33 Exactly.

00:38:34 I was just reading the topographical sort algorithms on Wikipedia, and you know what?

00:38:38 If you put some colons in there and take out the eaches, it's about valid Python.

00:38:42 That's awesome.

00:38:43 Yeah, I've heard that before, that people have copied algorithms out of Wikipedia, more or less, just straight up.

00:38:48 Turn that into Python, and it works beautifully.

00:38:50 That's great.

00:38:51 Which is also interesting verification of Wikipedia content.

00:38:54 Yes.

00:38:55 This portion of Talk Python To Me is brought to you by Hired.

00:39:10 Hired is the platform for top Python developer jobs.

00:39:13 Create your profile and instantly get access to 3,500 companies who will work to compete with you.

00:39:18 Take it from one of Hired's users who recently got a job and said, I had my first offer on Thursday after going live on Monday, and I ended up getting eight offers in total.

00:39:26 I've worked with recruiters in the past, but they've always been pretty hit and miss.

00:39:29 I tried LinkedIn, but I found Hired to be the best.

00:39:32 I really like knowing the salary up front.

00:39:34 Privacy was also a huge seller for me.

00:39:37 Sounds awesome, doesn't it?

00:39:38 Well, wait until you hear about the sign-in bonus.

00:39:41 Everyone who accepts a job from Hired gets $1,000 signing bonus.

00:39:44 And as Talk Python listeners, it gets way sweeter.

00:39:46 Use the link Hired.com slash Talk Python To Me, and Hired will double the signing bonus to $2,000.

00:39:52 Opportunity's knocking.

00:39:53 Visit Hired.com slash Talk Python To Me and answer the door.

00:40:04 There's another one that you talked about called the Code Review Review.

00:40:07 What's the story of that?

00:40:08 Yeah, this is a newer talk.

00:40:09 So something we're trying to do at Mozilla is make sure we don't drive people away by being jerks,

00:40:16 doing code review or otherwise having kind of unwelcoming culture.

00:40:20 Mozilla is historically and today largely driven by volunteer contributions.

00:40:25 I mean, even the guy who owns our security sockets layer or something, or the NSS, whatever that is, like the module owner for this, the one who has the final say,

00:40:36 he doesn't get paid by Mozilla.

00:40:37 He does something else, and he just takes it on this responsibility out of his own free time.

00:40:42 And so it's really important for Mozilla to keep that rolling, you know,

00:40:46 welcome people into the community, take in contributions, help people level up to become better programmers and more familiar with the project.

00:40:52 And so the Code Review Review is a piece of our onboarding right now that I'm turning into a more generically applicable talk where we talk about,

00:41:00 well, you know, how do we create that kind of welcoming atmosphere?

00:41:02 How do we do a proper review so that good programs come out?

00:41:07 And how do we do a review such that better programmers come out of it?

00:41:11 Yeah, that's really important that people, when they come to these new projects

00:41:15 or when they stick around, that they feel like it's a delightful experience

00:41:18 because they're doing it of their own free time and energy, right?

00:41:22 Yeah, for sure.

00:41:24 You definitely don't want it to be like slugging through a hard code.

00:41:27 I mean, I think an example of the opposite comes to mind is the old Python packaging,

00:41:33 PyPI web code.

00:41:35 I talked to Donald Stuffed on episode 64, and he was like, a lot of people want to come along and help maintain and evolve this,

00:41:44 but it's like two files in this hugely complicated old custom web framework that they built for it.

00:41:52 It's just people look at it, you know, actually, thanks, but no thanks.

00:41:56 And finally, they're rewriting it at pypi.org, and it's in Pyramid and Bootstrap, and it's lovely.

00:42:05 But for a long time, I think it turned people away from pushing that project forward,

00:42:09 and you could tell that it kind of, it was just getting maintained, which is good,

00:42:13 but it's also evidence of this anti-approachability, I guess.

00:42:17 Yeah, it's kind of funny how all those old projects tend to be like two enormous files.

00:42:22 All I can think of is folders must have been expensive 20 years ago.

00:42:24 Yes, exactly.

00:42:25 Really expensive.

00:42:26 All right, so what else?

00:42:28 We've got a few moments to talk about a few other things, and I know you've got a lot of interesting pieces out there.

00:42:34 What else is going on?

00:42:35 You're doing something with pip, right?

00:42:36 Oh, pip, yes.

00:42:37 So we deploy a lot of Python at Mozilla, and we used to check everything into a vendor library,

00:42:44 you know, just to be sure no one had slipped anything under the radar, anything malicious like that.

00:42:48 And vendor libraries are a pain to maintain.

00:42:50 You know, you have to update the versions of things, and that creates enormous diffs in your version control,

00:42:55 and then checkouts take forever, and your checkouts are huge.

00:42:57 And so we, for a while, ran an internal PIPI mirror.

00:43:02 A lot of people run their own little index server, and you kind of keep track of who's allowed to upload what to the server,

00:43:08 and then who did it last, and what versions are going to work with your own projects,

00:43:13 and you have to keep an access control list and an audit trail.

00:43:15 And that was a pain, and it slowed things down.

00:43:18 And then I thought, well, you know, we were actually having a beer and tell.

00:43:22 We have these little sessions where we have a beverage of our choice and talk about something that we've been playing around with as a side project.

00:43:28 And I needed something to talk about one day, and I thought, well, why not just hash the results of what you download from PIPI

00:43:37 and make sure they match some local hash that you've pre-vetted, and then go ahead and install it?

00:43:44 And so I put this thing together as this little tool called PEEP for prudently examine every package.

00:43:50 And we ended up moving the whole production lifecycle over to that for a number of years, year or two.

00:43:57 And then I thought, well, okay, this is proven out.

00:43:59 And PEEP called deep into pip's internal APIs, and so it would break all the time.

00:44:04 And it was a pain to maintain.

00:44:06 I thought, you know what?

00:44:06 I'm going to lift this up into pip, see if I can get people interested.

00:44:10 And long story short, I did.

00:44:12 People were interested, and it's in pip 8 and above.

00:44:15 So if you're out there deploying Python and running your own index server

00:44:21 or keeping up to date with a vendor library, hey, consider just putting a bunch of SHA-256 hashes into your requirements file

00:44:29 with a funny little syntax and running pip 8 over it.

00:44:32 And it'll vet these things for you.

00:44:34 I mean, it won't vet them for you.

00:44:35 You have to make sure that there's nothing malicious in a given version of a package,

00:44:38 but it'll make sure that what you got that first time is the same thing you got.

00:44:42 Yeah, once vetted, it'll verify it can't change.

00:44:44 So what do you do?

00:44:45 You can't just say, I depend upon SQLAlchemy.

00:44:48 You've got to say, I depend upon SQLAlchemy 1.0.whatever, and here's its SHA.

00:44:54 Dash, dash, hash equals whatever it is.

00:44:57 Right, because obviously if the version changes, you'd imagine the code would change and the package would change.

00:45:01 Absolutely.

00:45:01 I see.

00:45:02 And I try to keep the handholding in there so that if you forget to pin the version but provide a hash,

00:45:09 it'll say, you know what?

00:45:10 You should really pin the version because you're going to have an unpleasant surprise down the line.

00:45:14 This is a really stable product.

00:45:16 You're going to find out that this is not the same.

00:45:19 Awesome.

00:45:20 And you mentioned Turtles before.

00:45:21 What's Turtles?

00:45:22 Turtles is a real mad scientist project.

00:45:25 So I used to do a lot of Zope and Plone consulting back in the day, and I watched a lot of really smart people from all different walks of life.

00:45:36 You know, it was in higher ed, so there were professors, and there were very good writers,

00:45:40 and there were sys-ops, and there were chemists, and they'd come in, and we'd have to teach them,

00:45:44 okay, how do I build a website, or how do I use this content management system that has Python underlying it?

00:45:50 And they'd have to learn HTML, and CSS, and JavaScript, and Python, and then ZCML as a control language,

00:45:58 and DTML for dynamic CSS back in the day, and all these crazy different languages.

00:46:03 And it was ridiculous, and they would get discouraged and go away, a lot of them,

00:46:08 or at least not work to the potential that I thought we could provide them.

00:46:11 And so Turtles kind of had its genesis there.

00:46:14 I thought, you know, if only we had a single language that we could use end-to-end,

00:46:19 and we didn't need to constantly reinvent, say, for loops, or variables that allow us to not repeat ourselves,

00:46:28 and have a different way to do variables in Python, and a different way in CSS, and another way in JavaScript,

00:46:32 wouldn't things be easier to learn, and easier to remember, and heck, easier to read?

00:46:37 And wouldn't we have all of these synergies?

00:46:40 Turtles is one of those.

00:46:48 Turtles is a single-language system, or will be, I hope, for web development.

00:46:53 Right now, it is just a context-sensitive parser that does run, but everything else is still up in the air.

00:47:01 Interesting.

00:47:02 So basically, instead of teaching people these three or four languages, when they come, plus the frameworks, you're like, look, learn this one thing,

00:47:09 and you'll have a website, a full-on website.

00:47:12 That is the idea, to teach them, you know, an hour or two's worth of stuff,

00:47:16 and then have them be able to make real progress without an internet connection.

00:47:21 You know, make this thing explorable, like the old small talk environments used to be,

00:47:25 where you can drill into an example and take it apart and rip out pieces that you want to use,

00:47:30 where you can make changes to a live system and see what happens.

00:47:34 I mean, that's really how I learned programming, by mimicry, which we don't really do anymore.

00:47:39 You know, I had to type this stuff out of magazines, make mistakes, see what the effects of the mistakes were, fix the mistakes,

00:47:45 and then screw around and make my own new mistakes and see what effects they had.

00:47:50 I think that's how we learn human language, and I think it's a powerful way to learn programming.

00:47:53 It is a powerful way, but we've definitely moved beyond that in lots of areas.

00:47:57 I mean, I try to, I think of getting started with, like, Node.js and, like, the crazy packaging and requirements and all that,

00:48:04 and it's like, I thought that was a simple thing to get started with, you know?

00:48:07 But I feel like I've done a better job of keeping it simple.

00:48:11 But still, how do I know where a package comes from?

00:48:14 If I type import requests, why doesn't that run, right?

00:48:17 Like, when you're new, all these challenges that we are just like, yeah, whatever, just pip install or whatever,

00:48:22 I just, you forgot that step.

00:48:23 These are all levels of friction.

00:48:25 Yeah, that's one of the things that I'm trying to solve in Turtles by making the answer always the same.

00:48:30 You ask, where does this come from?

00:48:32 Or where do I put this?

00:48:33 And the answer is always in Turtles, it goes on a page.

00:48:37 Your config goes on a page.

00:48:39 Your program goes on a page.

00:48:41 Everything goes on a page.

00:48:43 The thing that we've lost in the web, because the web is a state-free kind of environment,

00:48:48 is that the default behavior is for everything to go poof.

00:48:51 You put something in a forum, you leave the page, poof, it's gone.

00:48:55 Unless you're, you know, using a nice browser like Firefox where you can say, hey, reopen that tab,

00:48:59 and then your content comes back.

00:49:01 But as a developer, you have the same problem, right?

00:49:03 You end up writing these template languages, and you end up having to take state and shuttle it aside

00:49:07 into some other process, into a relational database or a document store or something,

00:49:12 and then reconstitute, rehydrate these pages all the time out of these databases,

00:49:17 where the representation may not look anything like the structure you're actually trying to pull out.

00:49:23 And so the idea with turtles is put everything on pages and have a single representation for everything,

00:49:28 which I think is going to be trees.

00:49:30 Because as we said with the parsing stuff, trees are a very good choice for universal representation of things.

00:49:38 You can do a lot with trees.

00:49:39 It definitely sounds like an interesting project.

00:49:41 So there's nothing quite yet that we can go play with, but you're working on it, huh?

00:49:44 Nothing but 100K of design notes and parser up on GitHub.

00:49:48 But yeah, not quite ready yet.

00:49:49 All right, cool.

00:49:50 I'll keep us posted on that.

00:49:51 That's great.

00:49:52 All right, so another thing that you said you're into these days is GTD or getting things done, right?

00:49:57 Oh, my gosh.

00:49:58 Changed my life.

00:49:58 So as a repeat offender of Python library creation, I have the open source guilt.

00:50:06 I put this thing out there, and people are like, oh, well, it's broken this way, and it's broken this way,

00:50:11 and I wish it did this, and here's a patch, and why don't you review my patch,

00:50:14 and shouldn't you be doing this instead of watching Netflix and spending time with your family?

00:50:17 I'm like, well, I guess.

00:50:18 And the guilt builds and builds and builds, and you're just kind of, you know, you're just kind of shaking all the time, and you can't relax.

00:50:25 So GTD, I got this book at work seven years ago.

00:50:31 Somebody gave me a copy and it sat on the shelf for seven years, and I picked it up,

00:50:34 and it has all these little helpful practices for getting rid of that guilt

00:50:37 and making sure you're always working on the most important thing at any one given time.

00:50:42 And you know what?

00:50:43 It's really changed my life.

00:50:44 I no longer have the guilt to such a degree.

00:50:46 Hardly at all, really.

00:50:48 My response time has gone way down.

00:50:50 My email box has been at zero.

00:50:51 I mean, my work one and my home one were 5,000 before.

00:50:55 Now they've been zero for months.

00:50:57 And it's been easy.

00:50:58 It's a crazy thing.

00:51:00 That sounds delightful.

00:51:01 Yeah.

00:51:02 Yeah.

00:51:02 I've read that book, and I've lived the GTD lifestyle.

00:51:06 And I found it didn't quite work for me, but I gained a huge value from doing it.

00:51:13 And so if you can find a few techniques to help tame the world, whether it's so you have

00:51:20 better response time on your open source project, or you're not stressed all the time, or you

00:51:23 can go home and see the family and not have the weight of 5,000 unread emails on you, these

00:51:31 are all good.

00:51:31 The biggest thing that helps me these days is Google Inbox with its ability to snooze items

00:51:38 for two weeks until that item comes back right when I'm supposed to deal with it and things

00:51:42 like that, that's actually been sort of where I've evolved to.

00:51:45 But GTD is great.

00:51:47 Yeah.

00:51:47 For real.

00:51:48 And nobody, you know, you say you don't use GTD per se because it didn't work out for you.

00:51:53 Well, nobody uses vanilla GTD.

00:51:55 It's, you know, it's made to be customized.

00:51:57 It's a grab bag of tricks.

00:51:58 And some of them are, you know, more important than others.

00:52:00 Some of them are, you know, kind of vital, and some of them are optional.

00:52:03 Yeah, absolutely.

00:52:03 And you ran into something with that inbox that really rings true to me.

00:52:07 I had been trying for years to use my email inbox as a sort of quasi-touching.

00:52:12 To-do list.

00:52:13 I'll leave this in my box because I'm going to need it in three days.

00:52:17 And so for some reason I thought it's expensive to do a find.

00:52:20 I don't know why I thought that, but that's what I thought apparently.

00:52:23 Or, you know, oh, I need to respond to this mail, so it's going to stay in there.

00:52:27 And it ended up just being this mixture of chronologically sorted things, some of which were reference material, some of which were things to do, some of which I couldn't do for a certain period, like you said, and needed to be snoozed for two weeks.

00:52:38 And yet the only way it would present them to me is as this linear kind of last-touched first list of things.

00:52:46 It's not a useful presentation.

00:52:47 And I have been unable to make any email client really bend to my will as a to-do list.

00:52:54 And so the reason my boxes are empty these days is any time there's an actionable email item that takes me more than two minutes to do, because otherwise I would do it immediately as part of GTD, it goes into my to-do system.

00:53:05 And it pops up, like you say, when you're able to take action on it.

00:53:09 It's really a wonderful thing.

00:53:11 I do agree with that.

00:53:12 So I would be remiss not asking which to-do system you use for this.

00:53:16 So I went shopping.

00:53:17 I wanted something that – so I'm kind of weird.

00:53:19 I wanted something that was expressly not cross-platform, because I think that the platform-specific stuff usually ends up with a better UI, and I'm kind of a UI enthusiast.

00:53:28 So I looked at OmniFocus.

00:53:29 I love all of Omni's stuff.

00:53:31 I love OmniGraffle and OmniOutliner.

00:53:33 I read all my talks on OmniOutliner.

00:53:34 And I really wanted to like OmniFocus.

00:53:36 But there were a couple things that it was just grating against me, and it wouldn't do what I wanted.

00:53:41 I couldn't reorder tasks except within projects.

00:53:44 And I kind of like to plan my day out.

00:53:45 And so I ended up with something called Things by a little German company called Cultured Code.

00:53:51 And it's a Mac and iPhone-only gadget.

00:53:54 It uses their own little cloud sync service.

00:53:56 And the UI has been thought out in great detail.

00:54:00 Development goes glacially slowly.

00:54:03 That's the downside.

00:54:05 These people seem very, very intent on getting things exactly right and not releasing until then.

00:54:09 So that's the downside.

00:54:10 But Things is great.

00:54:11 Things lets you schedule things out ahead of time and not bother you until then.

00:54:15 It lets you express due dates like, well, this drop dead has to happen now.

00:54:19 And it does all the D2D-style contexts.

00:54:22 Let me know about this when I'm at home or at work or in the car or what have you.

00:54:26 It's nothing particularly, you know, whizzy from a technical point of view.

00:54:31 But it has those kind of three core features of contexts and due dates and hide until that any large-scale to-do system needs.

00:54:40 Oh, yeah.

00:54:41 It looks really, really cool.

00:54:42 All right.

00:54:42 Well, thanks for sharing your research results there.

00:54:44 That's cool.

00:54:45 Great.

00:54:46 Okay.

00:54:46 So it looks like we're just about out of time.

00:54:49 We've covered all the horrible things.

00:54:50 Now let's talk about some cool things.

00:54:52 How about your favorite PyPI package?

00:54:54 Well, I mean, there's a lot of good ones out there.

00:54:57 I enjoy Flask.

00:54:58 I've used that to power DXR.

00:55:00 It's a nice little lightweight web framework by Armin Roniker.

00:55:05 Yeah.

00:55:05 I can't remember exactly who it is.

00:55:06 Yeah.

00:55:06 I hit him on one of the early shows.

00:55:08 Yeah.

00:55:08 All of Armin's stuff is fantastic.

00:55:09 It is.

00:55:10 Likewise, Click is a fantastic one by Armin.

00:55:12 It's, I think he kind of, did he pull it out of Flask?

00:55:16 No, he's pulling it into Flask, in fact.

00:55:18 Click is a kit for making command line tools.

00:55:22 And I pulled it into DXR as well because it makes it so easy to do nested subcommands.

00:55:27 Like if you use homebrew or something, homebrew install, brew this, brew that.

00:55:31 It helps you brew up commands like that.

00:55:34 And like all of Armin's stuff, it's sort of a decorator soup that I like very much.

00:55:39 Absolutely.

00:55:39 And then one of my own things that I always pull off the shelf when I start a new project

00:55:44 is more iter tools.

00:55:46 And it is, as the name says, more iter tools.

00:55:49 The ones that got left behind.

00:55:50 Collations and such that come in handy in almost every project.

00:55:54 Yeah.

00:55:54 Okay.

00:55:55 Excellent.

00:55:55 I'll be sure to link to all of those.

00:55:57 That's great.

00:55:57 And how about the editor?

00:55:59 Favorite editor?

00:56:00 Are you going to write some Python code?

00:56:01 What do you pull up?

00:56:01 I pull up a little Mac app called BBEdit.

00:56:04 It's been around for, must be 40 years or something.

00:56:07 Yeah.

00:56:08 They're on BBEdit 11.

00:56:09 I like their little subtitle.

00:56:12 I don't know.

00:56:12 It doesn't suck.

00:56:14 All rights reserved.

00:56:14 Yeah.

00:56:15 Bare-bones software.

00:56:15 It doesn't suck.

00:56:16 And they typically make software that looks like nothing.

00:56:18 You pull it up and their mailer looks like a big empty window of white.

00:56:22 And their text editor looks like a big empty window full of white.

00:56:25 Not a lot of toolbars.

00:56:26 Not a lot of fluff.

00:56:27 But under the hood, they do a really nice job.

00:56:31 The text editor uses what must be ropes because I can edit very large, you know, multi-tens

00:56:37 of megabyte files without a lot of lag.

00:56:39 It's incredibly stable.

00:56:41 It just doesn't lose data.

00:56:42 On the off chance that it maybe crashes every couple of weeks, its magical little implicit

00:56:50 auto-save thing will bring up your windows in exactly the state that they were.

00:56:53 Even your untitled documents, it won't save and plow over your stuff.

00:56:57 It'll save it in its own little buffer and just make sure nothing is unduly lost.

00:57:00 Yeah.

00:57:01 That sounds really cool.

00:57:02 All right.

00:57:02 Awesome.

00:57:02 So check that out, people.

00:57:04 That's cool.

00:57:04 And final call to action.

00:57:06 Well, if you're parsing in Python, give parsimonies a try and send feedback and complaints and

00:57:12 patches my way.

00:57:12 Yeah, definitely.

00:57:13 It's on GitHub.

00:57:14 I'll put the links to it in the show notes so people can find it there.

00:57:17 Thank you.

00:57:17 And second, be safe out there.

00:57:19 If you're running a web server, get a certificate.

00:57:22 Use Let's Encrypt or something else.

00:57:24 And if you're deploying Python, again, be safe.

00:57:26 Use pip hashing.

00:57:28 I really appreciate this look inside of the whole parsing world and how we can move beyond

00:57:33 regular expressions to do something way cooler.

00:57:36 So thanks for your project and your talk and being on the show.

00:57:38 It was a pleasure to speak with you, Michael.

00:57:40 Yeah.

00:57:40 Bye, Eric.

00:57:41 This has been another episode of Talk Python To Me.

00:57:45 Today's guest has been Eric Rose, and this episode has been sponsored by GoCD and Hired.

00:57:51 Thank you both for supporting the show.

00:57:53 GoCD is the on-premise, open-source, continuous delivery server.

00:57:58 Want to improve your deployment workflow but keep your code and builds in-house?

00:58:02 Check out GoCD at talkpython.fm/gocd and take control over your process.

00:58:08 Hired wants to help you find your next big thing.

00:58:11 Visit hired.com slash talkpythontome to get five or more offers with salary and equity presented

00:58:16 right up front and a special listener signing bonus of $2,000.

00:58:20 Are you or a colleague trying to learn Python?

00:58:23 Have you tried books and videos that just left you bored by covering topics point by point?

00:58:28 Well, check out my online course, Python Jumpstart, by building 10 apps at talkpython.fm/course

00:58:34 to experience a more engaging way to learn Python.

00:58:37 And if you're looking for something a little more advanced, try my WritePythonic code course at talkpython.fm/pythonic.

00:58:43 Be sure to subscribe to the show.

00:58:46 Open your favorite podcatcher and search for Python.

00:58:48 We should be right at the top.

00:58:49 You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

00:58:59 Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:59:04 Corey just recently started selling his tracks on iTunes, so I recommend you check it out at talkpython.fm/music.

00:59:10 You can browse his tracks he has for sale on iTunes and listen to the full-length version of the theme song.

00:59:16 This is your host, Michael Kennedy.

00:59:18 Thanks so much for listening.

00:59:19 I really appreciate it.

00:59:20 Smix, let's get out of here.

00:59:22 I'll see you next time.

00:59:44 Don't believe.

00:59:45 Thank you.

