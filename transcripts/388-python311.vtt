WEBVTT

00:00:00.001 --> 00:00:05.080
Python 3.11 is here! Keeping with the annual release cycle, the Python Core devs have released

00:00:05.080 --> 00:00:10.180
the latest version of Python, and this one is a big one. It has more friendly error messages

00:00:10.180 --> 00:00:18.100
and is massively faster than 3.10, being between 10 to 60% faster in general, which is a big deal

00:00:18.100 --> 00:00:23.460
for a year-over-year release of a 30-year-old platform. On this episode, we have Erit Katril,

00:00:23.460 --> 00:00:28.560
Pablo Galindo-Sogato, Mark Shannon, and Brant Booker, all of whom participated in releasing

00:00:28.560 --> 00:00:32.860
Python this week, the hero on Talk Python, to tell us all about that process and some of the

00:00:32.860 --> 00:00:39.400
highlight features. This is Talk Python To Me, episode 388, recorded October 28, 2022.

00:00:39.400 --> 00:00:57.440
Welcome to Talk Python To Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:57.600 --> 00:01:01.640
Follow me on Twitter, where I'm @mkennedy, and keep up with the show and listen to past

00:01:01.640 --> 00:01:08.080
episodes at talkpython.fm. And follow the show on Twitter via at Talk Python. We've started streaming

00:01:08.080 --> 00:01:13.400
most of our episodes live on YouTube. Subscribe to our YouTube channel over at talkpython.fm

00:01:13.400 --> 00:01:19.140
slash YouTube to get notified about upcoming shows and be part of that episode. This episode is sponsored

00:01:19.140 --> 00:01:25.320
by Sentry. Don't let those errors go unnoticed. Use Sentry. Get started at talkpython.fm slash

00:01:25.320 --> 00:01:30.660
Sentry. And it's brought to you by Command Line Heroes, an original podcast from Red Hat that

00:01:30.660 --> 00:01:36.380
chronicles the history of the software industry. Listen to an episode at talkpython.fm slash

00:01:36.380 --> 00:01:43.380
heroes. Transcripts for this episode are sponsored by Assembly AI, the API platform for state-of-the-art

00:01:43.380 --> 00:01:49.520
AI models that automatically transcribe and understand audio data at a large scale. To learn more,

00:01:49.520 --> 00:01:55.440
visit talkpython.fm/assemblyai. Hey, everyone. Welcome to Talk Python To Me. It's

00:01:55.440 --> 00:02:00.940
great to have you all here. Erit, Brant, Pablo, and Mark. It's going to be super fun to speak with

00:02:00.940 --> 00:02:06.300
all of you about Python 3.11. Before we get into it, I guess, just real quickly, I know some of you

00:02:06.300 --> 00:02:11.120
have been on the show before, but not all of you. So let's just do a quick introduction about who you

00:02:11.120 --> 00:02:14.700
are and how you ended up here on the show. Erit, you want to start first?

00:02:14.700 --> 00:02:20.620
Yeah. Hi, I'm Erit, I'm a Python Core Dev. Earlier in the week, we streamed the release

00:02:20.620 --> 00:02:25.860
of Python 3.11. And on the back of that, Michael just invited us all here for chat.

00:02:25.860 --> 00:02:30.480
Fantastic. Yeah. That was a great live stream. And we'll talk about that for sure in a second.

00:02:30.480 --> 00:02:32.000
But Brant, welcome back.

00:02:32.000 --> 00:02:37.740
Hello. My name is Brant Bucher. I have been a Core Dev for like two years now. And I work with

00:02:37.740 --> 00:02:40.240
Mark and Erit on the Faster CPython team at Microsoft.

00:02:40.240 --> 00:02:40.720
Right on.

00:02:40.720 --> 00:02:42.540
And I was on the show like a month ago.

00:02:42.540 --> 00:02:46.500
Yeah, you were talking about the Faster Python stuff, which we'll touch on again.

00:02:46.500 --> 00:02:53.060
Hello. I'm Pablo Galindo. I'm the infamous release manager. I released Python 3.11. And you can

00:02:53.060 --> 00:02:58.700
redirect all your complaints to my email address. No, please don't do that. So I'm a cPython

00:02:58.700 --> 00:03:04.660
core dev. I'm also serving this year and the last year on the Python steering council. And I

00:03:04.660 --> 00:03:10.500
also released a release manager for Python 3.10 and 3.11, which is now the best version of Python.

00:03:10.500 --> 00:03:15.180
Download it today. Apart from that, I do a bunch of parser stuff. But now we are not talking about

00:03:15.180 --> 00:03:17.700
Yeah, fantastic. Well, welcome. Mark, welcome back.

00:03:17.700 --> 00:03:25.700
Hi there. I'm Mark Chan. I'm the tech lead of the Faster CPython team. I work with Erit and Brant. I've been a Core Dev for some number of years. I don't

00:03:25.700 --> 00:03:37.360
recall. You've been spending a couple years working on this Faster CPython thing and very excited to see some of the fruits of those labors, you know, starting to show up and get in the hands of everyone with this release.

00:03:37.360 --> 00:03:45.100
Yeah, it's good to have the stuff out actually in public and in people's hands. It's really rewarding to know that stuff you're working on is actually used and used by a lot of people.

00:03:45.180 --> 00:04:03.920
Yeah, that is totally true. It's it's one thing to build software. I mean, just by itself, but it's fun. But all of you are working on code that touches so many people. Think about there's layers, right? One layer is how many people use Python? Many millions, millions. Does anyone know a reasonable estimate of this number?

00:04:03.920 --> 00:04:15.460
I think some I don't remember who came with the number, but I think they were estimating like 6 million Python developers, something like that. I mean, probably is between zero and 10 million, let's say.

00:04:15.460 --> 00:04:32.300
Yeah, that's a massive impact. But and also maybe nervousness about pushing code out to that group. But then, you know, those people will build software for others, right? If you're using Instagram or using YouTube or other things, right? It's also having massive knock on effects there.

00:04:32.300 --> 00:04:42.980
So thanks for putting all this together. Thanks for improving the tools that we all get to use. So yeah, big news. The big news is that Python 3.11 is out.

00:04:42.980 --> 00:04:58.100
And as Eric had said, you all live streamed that release. So here we're all together. We're having an awesome chat about the features and the what people can do to take advantage of it and why they might care about new features and want to learn them.

00:04:58.100 --> 00:05:07.100
But there you did a little bit of that. But also Pablo, you actually step by step did the release of CPython mostly live, right?

00:05:07.100 --> 00:05:22.520
Yeah, I did. It was except the boring part. This is something that I started last year because apparently I didn't have enough things to worry. And I decided to make my life even more difficult. I'm an expert on that. Quite proficient.

00:05:22.520 --> 00:05:25.820
I'm also an expert. I'm very bad at doing too many things.

00:05:25.820 --> 00:05:43.860
And you could be a release manager is the only requirement. So yeah, the idea is that the kind of releasing Python is a process that is quite complicated. It's also quite boring. So it's not like, you know, you need to be have a galaxy brain kind of thing to do it. But it's just a lot of steps and it's very easy to do it wrong.

00:05:44.520 --> 00:05:53.520
And it's very glamorous. So I said, Oh, wow, I'm sure people really would like to see a very glamorous process happen in life. And then I said, Let's do it.

00:05:53.520 --> 00:06:06.920
And I asked around and I was surprised about how many people enjoy and glamorous processes. And then I did the release of Python 310 beta one, which turned out to be much funnier than I thought because we just broke GitHub. That happened live. Yes.

00:06:06.920 --> 00:06:13.360
Was that when you imported all the, you imported all the issues and did that migration or was that separate?

00:06:13.520 --> 00:06:22.520
You will think that that is a good candidate, but no, that was not the thing that broke GitHub. We renamed master to main on the CPython repo and the whole GitHub platform was down. What about that?

00:06:22.520 --> 00:06:23.520
Wow.

00:06:23.520 --> 00:06:38.520
Yeah, you can see those Ruby workers really struggling with the renaming, all those forks. I think we were the, I don't know, someone at GitHub may confirm this, but I think we were the first big project to do the renaming. Something went wrong.

00:06:38.520 --> 00:06:54.520
And it was very funny because I literally said, How funny will it be if now I get a 500? There you go. A 500 on the screen. Yeah. Yeah. It's recorded. There is someone actually recorded that clip. Yeah. Yeah. So I said, Wow, man, this has been a such exciting thing that I can break such a big project. Let's do it more.

00:06:54.520 --> 00:07:11.680
So I decided also to stream the 3.10 release itself. And I said, Well, technically the release, the final release is even more boring and longer. So that is actually probably not going to be even like, you know, something that someone went to see. So I said, Okay, let's not do it alone.

00:07:11.680 --> 00:07:41.660
So I invited a bunch of friends and core developers. So they can actually talk about, you know, the things that they worked on the Python 3.10 release and brand unneeded were there. So that they can, they can probably tell you how they found out. But like, apparently, it was something that a lot of people enjoy. Because, you know, it's not only an opportunity to see how the sausage is made. Because, you know, I was just explaining all the commands and all the faces and whatnot. But like, when something became very boring, then, you know, like brand unneeded were there to save the day.

00:07:41.660 --> 00:07:54.000
And explain the cool things they work on. So, you know, which is a very good opportunity. Because, you know, when is the last time you could hear the author of the feature that you love talk about the feature that you love? That is fantastic. And it happened.

00:07:54.000 --> 00:08:06.100
Right. And not only did it happen, but as they were explaining the feature that they built, the action of it being delivered to the entire world was right. It was like all coming together in a pretty awesome way.

00:08:06.100 --> 00:08:10.920
Exactly. And I could only do that just to be fair also. And, you know, credit where credit is due.

00:08:11.140 --> 00:08:22.900
I could only do that because the first time I did the live thing, I was also doing all the, you know, pushing all the buttons and at the same time doing all the video stuff with, I don't know what is the software to the stream or like whatever.

00:08:23.480 --> 00:08:40.040
And the second time we used the help of the Python Discord team, which are fantastic. And they help us a lot. They have this fantastic UI where, you know, all the questions that were asked on the chat are on the screen and we couldn't use it.

00:08:40.040 --> 00:08:47.080
Do you know why? Because Facebook or now Meta decided to break DNS globally. What an incredible feat.

00:08:47.820 --> 00:08:48.820
Just in time.

00:08:48.820 --> 00:08:48.820
Just in time.

00:08:48.820 --> 00:08:49.820
I think wanna.

00:08:49.820 --> 00:08:55.820
So what I'm learning is if we need some sort of like big cloud global outage, you all just need to live stream.

00:08:55.820 --> 00:08:56.820
Just call Pablo.

00:08:56.820 --> 00:08:57.820
Yes. Exactly. Exactly.

00:08:57.820 --> 00:08:59.820
Exactly. Just hire me today.

00:08:59.820 --> 00:09:00.820
Okay.

00:09:00.820 --> 00:09:13.820
So yes, now we were like two big outages on Python release. The, you know, there is only a line that passes through two points, but I, you know, it was a, it was a, it's a good, a good statistic already.

00:09:13.820 --> 00:09:26.820
So we said, what can I, what else can we break? So there you go. We decided to do the 3.11 release again. And Mark was there as well, which increases the probability of things being broken by a lot.

00:09:26.820 --> 00:09:34.820
Sorry, Mark. I had to do the joke. He also fixes them. So, you know, it's fine. And nothing broke. So, so kudos to Mark. Everything. Thanks to that.

00:09:34.820 --> 00:09:46.820
And we did the release. So, so we did the same thing. We explained the whole thing. So people could see from the authors themselves, like why all the switches are very cool. And I did the non boring parts of the release.

00:09:46.820 --> 00:10:00.820
And then we have a bit of some dramas in backstage because my Jubi key that I used to sign release broke and I freak out quite a lot, but I thankfully have a backup Jubi key. So no, I have, yeah. Yeah. So crazy.

00:10:00.820 --> 00:10:15.820
Because if I didn't have that, then I will have to stop the whole thing, but we didn't have to do that. It was just backstage. So yeah, quite, quite exciting. Nothing broke except my Jubi key. I suppose that's the third thing that broke. It's not a global, you know, software, but I still mourn it. It's here.

00:10:15.820 --> 00:10:20.820
Yeah. It served you well, but now it's, it gave its life for Python 3.11.

00:10:20.820 --> 00:10:23.820
Too much power. Like 3.11 was too powerful. It just broke.

00:10:23.820 --> 00:10:27.820
This is a dangerous job that you got.

00:10:27.820 --> 00:10:28.820
Yeah.

00:10:28.820 --> 00:10:33.820
But you've handed it off, right? This is your last time, last main release.

00:10:33.820 --> 00:10:56.820
Yeah. Yeah. I need to do the security and bug fix releases, but I don't need to do the ones that, you know, you need to chase people down and ask for like cherry picking. And there was a bunch of things of the release that were quite boring. Like normally we release the previous version. Like before the final version, there is something called the release candidate, which is, you know, like the last version that people need to try out before we do the final release.

00:10:56.820 --> 00:11:01.820
And ideally that is the last version that we publish. Normally it means that you publish from that commit.

00:11:01.820 --> 00:11:07.820
But, but this was not the case. This is the first release that had 130 something commits on top of that.

00:11:07.820 --> 00:11:13.820
But I have to painstakingly cherry pick and it was not fun, but I did that before the release. It's like two hours.

00:11:13.820 --> 00:11:14.820
Yeah.

00:11:14.820 --> 00:11:22.820
You need to fix conflicts and things like that. Yeah. Very, very boring. But yeah, I started the stream with that already done. So, so it was fine.

00:11:22.820 --> 00:11:40.820
Yeah. Fantastic. Now, before we get into all the features and I want to maybe just talk a little bit about some of the tools for actually doing the release and maybe start with you is, what, what is 3.11 mean for you all getting this out? What does that mean for the Python community from your perspective?

00:11:40.820 --> 00:11:59.820
Well, 3.11 is, it is a huge release. There's a lot packed into it compared to the last few releases. There are no features. There's the performance work. It's, it's just massive changes internally. It's, it's just a huge release. And personally, I've started working on, you know, exception groups about two years ago.

00:11:59.820 --> 00:12:13.960
So for me, this is, it almost feels like finishing another PhD or something. It's, it's a massive kind of effort and here it is. It's done. It's, you know, it was a big day Monday. I had a bottle of champagne ready for the stream. It was a celebration.

00:12:13.960 --> 00:12:15.920
Yeah, it was. Brent, how about you?

00:12:15.920 --> 00:12:28.140
I'm really excited about 3.11 because I think there's something for everyone. And I think you'd be hard pressed to find someone who doesn't want their code to run faster and who doesn't want better error messages. And then you have all these other improvements on top of that.

00:12:28.140 --> 00:12:40.140
It's really nice to see both these like new features, which are something that we get in most Python releases, but also just the stuff that's there for everyone else who just wants to upgrade Python and just have a better experience all around.

00:12:40.140 --> 00:12:41.500
Yeah, I totally agree with that.

00:12:41.500 --> 00:12:58.120
It's cool to see people's responses to that too, because responses have been really, really positive, which is another thing that I liked about the live stream because we did, you know, live Q&A and we had the chat and everything going on. And when you're starting at the same code base for like a year, you're like, okay, I'm pretty sure that what we've done here is really, really cool.

00:12:58.120 --> 00:13:08.900
Cool. But, you know, like, is it actually as awesome as I think it is? You know, or have I just been staring at it for too long and then release it to the world and people are even more stoked about it than you are. And that's a really good feeling.

00:13:08.900 --> 00:13:10.920
Yeah, it is. Awesome. Mark?

00:13:10.920 --> 00:13:16.640
Yeah, well, I guess I started on trying to get Python faster 15 years ago, I guess, early PhD time.

00:13:16.640 --> 00:13:17.760
Yeah, with Hot Pie, right?

00:13:17.760 --> 00:13:29.060
Yeah, yeah. So that was a long, long. This has been a long time coming. So yeah, it's amazing to have it actually out and starting to see the speed ups. And obviously we're keeping working on it. So it's pretty good.

00:13:29.200 --> 00:13:42.500
Yeah, fantastic. You must be really proud because, like you said, you have been proposing this for a really long time. You've had a lot of ideas. And finally, you've got a group of people working on it. And you're all on the same team with Mark and Guido.

00:13:42.500 --> 00:13:43.040
Yes.

00:13:43.040 --> 00:13:51.320
Yeah. And just making legitimate, serious progress here. So it's, you must be really proud to just sort of see this actually go out the door.

00:13:51.320 --> 00:13:52.220
Yes, definitely.

00:13:52.220 --> 00:13:58.180
Especially in main iPhone too. It's really nice that we're able to, you know, deliver this for everyone.

00:13:58.180 --> 00:14:08.240
Yeah. For me, I see basically three things, like, kind of like you said, Brent, I see that obviously there's these new features like exception groups, which are lovely and make the language better.

00:14:08.240 --> 00:14:22.680
But it also gets friendlier for, especially for beginners, but for everyone, of course, with the better error messages and better reporting and tracebacks. And it gets faster. And so, I mean, it, and all the axes that seem to matter. It's, it's really fantastic.

00:14:22.760 --> 00:14:44.580
Okay. So let's dive in. I just, Pablo, let's go back just a little bit to the release process because people got to watch you do it, but they didn't actually, you know, see exactly what you're typing on your screen the whole time. It was more of about a, like an event of it. Sometimes your screen was up, sometimes it wasn't, but there's an official PEP that talks about like, here's the recipe for doing this, right?

00:14:44.580 --> 00:15:01.320
But it's correct. It's PEP 101 doing Python releases. And that is a curious document. It's peculiar document. Talks about how it's done, but it's like, it's kind of weird. So the document is up to date. Like you can actually, you know, search PEP 101 and it will show you the thing.

00:15:01.580 --> 00:15:16.180
So what is there is the actual process. It's just, it also contains these weird sentences. Like if you search for it, there is a bunch of places that says stop, stop, stop, stop, stop. Quite funny. And that was, if I recall correctly, Larry Hastings.

00:15:17.540 --> 00:15:37.180
That he wrote those things and the idea is that he could search for those places. And he knows that at that stage, he needs to wait for something to happen or something. And we left it there. So there's a bunch of like weird artifacts and, you know, it's full of bullet points because you, at some stages, you need to do some things and some others and things like that.

00:15:37.440 --> 00:15:58.260
And, you know, it says, okay, if you're running a beta release, then you need to do this bunch of things. And if you're running an alpha release, you need to do this bunch of things. And I have done the, I have done a state machine that goes through the whole thing because like, if you actually write this down, it's quiet, is, you know, the, the, how is this called? The maintainability index of this process is insane. It just rejects your thing.

00:15:58.260 --> 00:16:28.240
Right. And I said like, yeah, I'm not doing this reading. So one thing I did, which is the thing that I was using at the, at the stream, my first work as a release manager is say, I'm not going to do this by hand. And that is the vision. And then I did this script that is on a GitHub slash Python slash release tools. And it's a, it's my attempt at automating this process as much as possible, which unfortunately, you know, it still requires a bunch of manual steps because like that's a lot of work.

00:16:28.240 --> 00:16:58.220
that's life and things happen. But, it's quite automatic, like at least things that are not like final releases. So alpha and release candidates. And now that we are in backfix releases, it mostly runs automatically, except that, you know, in the final release, everything fails because there's the final release for you. And then you need to fix things manually. So you, I think you saw me, you know, executing a bunch of those fixes at some point. And I added a division by zero just to know that something was hit and that was seen on the screen because like, and people

00:16:58.220 --> 00:17:03.760
like division by zero, why do you need that to release Python? I don't know. That's very complicated.

00:17:03.760 --> 00:17:06.820
I could have asserted false. Come on. Anything would have worked.

00:17:06.820 --> 00:17:09.720
No, no. We divide by zero. I'm a physicist. So that's what I do.

00:17:09.720 --> 00:17:10.060
Okay.

00:17:10.060 --> 00:17:13.240
You studied black holes, right?

00:17:13.240 --> 00:17:13.800
Yeah.

00:17:14.480 --> 00:17:18.940
You were looking for some sort of like infinite sort of thing there. Divide by zero. Yeah.

00:17:18.940 --> 00:17:30.140
I'm too tired for today. Let's just collapse the universe. Divide by zero. Oh, but Python was too friendly. Instead of collapsing the universe, it sold me an exception. You know, quite nice. Only in 311. No, no, I'm joking.

00:17:32.880 --> 00:18:01.700
This portion of Talk Python To Me is brought to you by Sentry. How would you like to remove a little stress from your life? Do you worry that users may be encountering errors, slowdowns, or crashes with your app right now? Would you even know it until they sent you that support email? How much better would it be to have the error or performance details immediately sent to you, including the call stack and values of local variables and the active user recorded in the report? With Sentry, this is not only possible, it's simple.

00:18:01.700 --> 00:18:20.820
In fact, we use Sentry on all the Talk Python web properties. We've actually fixed a bug triggered by a user and had the upgrade ready to roll out as we got the support email. That was a great email to write back. Hey, we already saw your error and have already rolled out the fix. Imagine their surprise. Surprise and delight your users.

00:18:21.020 --> 00:18:45.940
Create your Sentry account at talkpython.fm/sentry. And if you sign up with the code Talk Python, all one word, it's good for two free months of Sentry's business plan, which will give you up to 20 times as many monthly events as well as other features. Create better software, delight your users, and support the podcast. Visit talkpython.fm/sentry and use the coupon code Talk Python.

00:18:47.940 --> 00:19:01.040
Anyway, so yes, yes, you can follow this PEP and, you know, just enjoy the whole process on its glory or you can see the script. But yeah, it's quite verbose. You can see that it's very, it's lots of places when everything can go wrong and you can panic.

00:19:01.440 --> 00:19:02.900
Now we know one more.

00:19:02.900 --> 00:19:04.160
Apparently your jubi key can break.

00:19:04.160 --> 00:19:05.740
So that's something that can happen as well.

00:19:05.740 --> 00:19:07.720
But like, you know, it's quite annoying.

00:19:07.720 --> 00:19:10.620
And that's the main job of the release manager.

00:19:10.620 --> 00:19:12.160
I go through this annoying process.

00:19:12.160 --> 00:19:15.320
So yeah, I see that there's some parts in here.

00:19:15.320 --> 00:19:16.580
You should have a few more stops.

00:19:16.580 --> 00:19:17.760
I should say stop, stop, stop.

00:19:17.760 --> 00:19:19.080
Make sure GitHub still works.

00:19:19.080 --> 00:19:19.900
Stop, stop, stop.

00:19:19.900 --> 00:19:21.080
Make sure Azure still works.

00:19:21.080 --> 00:19:22.260
Stop, stop, stop.

00:19:22.260 --> 00:19:23.300
Yeah, don't cry.

00:19:23.300 --> 00:19:24.300
Don't cry at this stage.

00:19:24.300 --> 00:19:26.640
Everyone is looking at you.

00:19:26.640 --> 00:19:30.160
But yeah, the one thing that is knowing this is that you also are in charge

00:19:30.160 --> 00:19:34.920
in theory of this extreme abstract mandate, which is that you're in charge

00:19:34.920 --> 00:19:37.840
of the stability of the release, whatever that means.

00:19:37.840 --> 00:19:41.140
That translates mostly on chasing people because they broke things.

00:19:41.140 --> 00:19:45.960
Another unfortunate event that we are trying to also fix a bit for the for the releases

00:19:45.960 --> 00:19:49.920
is that most people turn to the release manager to solve problems.

00:19:49.920 --> 00:19:54.760
So they say, hey, this person says that we should do X while this other person says

00:19:54.760 --> 00:19:55.840
that we should do Y.

00:19:55.840 --> 00:19:57.100
We need someone to decide.

00:19:57.100 --> 00:19:59.520
Let's let's let's let's reach the release manager.

00:19:59.520 --> 00:20:01.740
But the release manager is this guy on the corner.

00:20:01.740 --> 00:20:02.900
Like he doesn't know shit.

00:20:02.900 --> 00:20:06.400
So I like, you know, it's not the best person to fetch it.

00:20:06.400 --> 00:20:08.200
But everybody was like, what do you think, Pablo?

00:20:08.200 --> 00:20:09.080
So we merge this.

00:20:09.080 --> 00:20:09.940
I like, I don't know, man.

00:20:09.940 --> 00:20:11.400
This is some in-and thanks.

00:20:11.400 --> 00:20:12.660
Like, I don't know about this.

00:20:12.660 --> 00:20:14.200
I have no context whatsoever.

00:20:14.200 --> 00:20:17.040
Your only concern is will it still build and shift?

00:20:17.040 --> 00:20:17.400
Exactly.

00:20:17.400 --> 00:20:18.040
Like how?

00:20:18.040 --> 00:20:19.200
I like it.

00:20:19.200 --> 00:20:19.380
Yeah.

00:20:19.380 --> 00:20:20.700
What about these 2000 lines?

00:20:20.700 --> 00:20:22.080
Of course, it's all this tiny bag.

00:20:22.080 --> 00:20:24.040
It was like, well, maybe let's not merge to that.

00:20:24.040 --> 00:20:28.300
But yeah, like we are trying to also like, you know, redirect all of these to the steering

00:20:28.300 --> 00:20:30.260
council, which also I am in the steering council.

00:20:30.260 --> 00:20:32.420
So apparently I'm not going to get rid of these questions.

00:20:32.420 --> 00:20:33.500
I'm joking.

00:20:33.500 --> 00:20:34.520
I enjoy all these questions.

00:20:34.520 --> 00:20:35.920
But as a release manager, I don't.

00:20:35.920 --> 00:20:39.640
So I like the key here is that the release manager should not take unilateral decisions

00:20:39.640 --> 00:20:42.580
on the evolution of these things because like it's just the release manager.

00:20:42.760 --> 00:20:44.640
the reason the steering council is five people.

00:20:44.640 --> 00:20:46.520
But you are the one who delivers the code.

00:20:46.520 --> 00:20:48.860
You could kind of, you could sneak a feature in there.

00:20:48.860 --> 00:20:49.060
No, no, no.

00:20:49.060 --> 00:20:49.160
Come on.

00:20:49.160 --> 00:20:50.880
I don't decide important things.

00:20:50.880 --> 00:20:52.700
I just execute and chase people.

00:20:52.700 --> 00:20:54.980
And I'm this annoying guy that says, you broke this, fix it.

00:20:54.980 --> 00:20:59.600
But like then if there is some important decisions to be taken, you know, that's the steering

00:20:59.600 --> 00:21:03.660
council job, which is five people because, you know, one person shouldn't decide these

00:21:03.660 --> 00:21:03.900
things.

00:21:03.900 --> 00:21:05.400
It's like, and this happens.

00:21:05.400 --> 00:21:09.700
Like sometimes I say, hey, there is this PR when people are asking, what should we do?

00:21:09.700 --> 00:21:13.740
And then this is my opinion as the member of the steering council and the other four

00:21:13.740 --> 00:21:16.540
members, maybe they say, well, actually that's not a good opinion.

00:21:16.540 --> 00:21:17.340
So what about this?

00:21:17.340 --> 00:21:21.760
You know, we ended up in a much better place because it was five people, five persons doing

00:21:21.760 --> 00:21:22.900
a decision instead of one.

00:21:22.900 --> 00:21:23.260
But yeah.

00:21:23.260 --> 00:21:23.500
Yeah.

00:21:23.500 --> 00:21:24.980
Amazing.

00:21:24.980 --> 00:21:25.380
Okay.

00:21:25.380 --> 00:21:28.460
So if people want to follow along with the process, they can check out PEP 101.

00:21:28.460 --> 00:21:29.780
Let's keep over here.

00:21:29.780 --> 00:21:33.700
You also talked about the Python build bot that people can check out, but I think maybe we

00:21:33.700 --> 00:21:35.720
want to jump into our first feature.

00:21:36.040 --> 00:21:41.180
There's, as Arit said, there's a ton of features and things in here, but there's also maybe

00:21:41.180 --> 00:21:44.560
some top level ones that'll be really important for a lot of folks.

00:21:44.560 --> 00:21:47.180
And Arit, you want to tell us about your work?

00:21:47.180 --> 00:21:49.840
You mentioned before the exception groups and exception star.

00:21:49.840 --> 00:21:52.180
This is kind of a major new feature that we added.

00:21:52.180 --> 00:21:59.140
And the idea is that sometimes you'll have a situation where you did several things and

00:21:59.140 --> 00:22:01.420
maybe more than one of them raised an exception.

00:22:01.420 --> 00:22:05.380
And now you need to report that there was more than one error in whatever you did.

00:22:05.380 --> 00:22:10.140
And what you did could have been a bunch of asynchronous tasks, which is that that was

00:22:10.140 --> 00:22:12.000
the use case that motivated this whole thing.

00:22:12.000 --> 00:22:17.920
But there are also kind of situations where you just iterate over a few things and repeat

00:22:17.920 --> 00:22:19.380
them and accumulate exceptions.

00:22:19.380 --> 00:22:21.720
And you want to kind of report all of them.

00:22:22.360 --> 00:22:26.920
And the PEP lists a bunch of examples of where this can happen.

00:22:26.920 --> 00:22:32.440
So people typically what they do is they'll take a list of exceptions, wrap it in another

00:22:32.440 --> 00:22:36.940
exception, multi-error, some other kind of wrapper and throw that.

00:22:36.940 --> 00:22:37.900
And then you have to catch it.

00:22:37.900 --> 00:22:40.760
And then you have to iterate over the list and look at the exceptions.

00:22:40.760 --> 00:22:43.840
But you don't have a method to handle the exceptions.

00:22:44.300 --> 00:22:47.700
Like you have try accept, like catch these, but not catch exceptions.

00:22:47.700 --> 00:22:48.060
Right.

00:22:48.060 --> 00:22:48.360
Right.

00:22:48.360 --> 00:22:53.740
Because in accept, you might have like accept socket error, or you might have accept like

00:22:53.740 --> 00:22:54.880
file not found type of thing.

00:22:54.880 --> 00:23:00.320
But if those both happen, neither of those would run in Python 3.10, right?

00:23:00.320 --> 00:23:03.320
Because it's some kind of weird wrapper and it's not a socket exception.

00:23:03.320 --> 00:23:05.660
It's not a file exception, but it kind of contains both.

00:23:05.660 --> 00:23:07.820
And so in a sense, you would both run?

00:23:07.820 --> 00:23:08.280
I don't know.

00:23:08.280 --> 00:23:12.020
And then if you catch the wrapper, even you do something with some of the exceptions,

00:23:12.020 --> 00:23:15.420
you better not forget to erase the rest because you're not handling them.

00:23:15.420 --> 00:23:20.440
So yeah, there are a lot of problems when you try to work around this and like what happened

00:23:20.440 --> 00:23:21.260
with Trio.

00:23:21.260 --> 00:23:27.840
So Trio had multi-error, would raise this wrapper and it had to do a lot of complicated

00:23:27.840 --> 00:23:30.140
acrobatics just to have some error handling.

00:23:30.140 --> 00:23:35.960
So the motivation was, yeah, we have task groups in Python 3.11, which are kind of like Trio

00:23:35.960 --> 00:23:41.280
nurseries, kind of a structured collection of asynchronous tasks.

00:23:41.280 --> 00:23:43.640
And task groups were on the cards.

00:23:43.640 --> 00:23:48.680
They started like Yuri Selibanov, who was kind of maintaining asyncio in the beginning.

00:23:48.680 --> 00:23:49.900
He wrote a lot of asyncio.

00:23:49.900 --> 00:23:55.500
He wanted to add task groups since 2017, 2018, something like that.

00:23:55.500 --> 00:23:58.360
And what was holding it up was error handling.

00:23:58.360 --> 00:24:00.640
There was no good way to handle errors.

00:24:00.800 --> 00:24:05.980
So now we have accept star, which is what generalizes accept and works with groups.

00:24:05.980 --> 00:24:08.740
So you can say accept star socket error.

00:24:08.740 --> 00:24:13.980
And then it will just extract all the socket errors from the group and give you those and

00:24:13.980 --> 00:24:15.780
automatically re-erase everything else.

00:24:15.780 --> 00:24:17.360
That's basically the idea.

00:24:17.360 --> 00:24:18.320
This is pretty interesting.

00:24:18.320 --> 00:24:24.020
We have try, do your thing, and then accept star, you know, one error type, accept star,

00:24:24.020 --> 00:24:27.140
another error type, accept star, a set of errors potentially.

00:24:27.480 --> 00:24:34.620
So what happens if I'm in this situation and say the first error type and maybe something

00:24:34.620 --> 00:24:40.320
from the third error catch clause is thrown in one of these task groups, exception groups?

00:24:40.320 --> 00:24:44.380
Each exception in the group will be handled by at most one of the clauses.

00:24:44.380 --> 00:24:47.760
So the first clause that matches its type will consume it.

00:24:48.020 --> 00:24:49.880
And each clause executes once.

00:24:49.880 --> 00:24:56.160
So if there are more than one errors of that type, then what gets kind of bound in the accept

00:24:56.160 --> 00:25:00.260
star full error as E, what gets bound to E is a group of full errors.

00:25:00.260 --> 00:25:05.280
So you get all the full errors in a group, execute that clause, and then move on to the next clause

00:25:05.280 --> 00:25:07.500
with whatever is not handled yet.

00:25:07.500 --> 00:25:08.220
Interesting.

00:25:08.500 --> 00:25:10.920
So it might run two of the clauses.

00:25:10.920 --> 00:25:11.860
Exactly.

00:25:11.860 --> 00:25:16.500
Whereas in traditional exception handling, it goes from top to bottom and it looks for an

00:25:16.500 --> 00:25:17.620
inheritance type of match.

00:25:17.620 --> 00:25:19.420
And the first one that matches, that's it.

00:25:19.420 --> 00:25:22.640
But in this case with the star, you could get multiple ones.

00:25:22.640 --> 00:25:29.360
I guess the star to me, when I look at this, the star is reminiscent of Args star where you

00:25:29.360 --> 00:25:29.760
have...

00:25:29.760 --> 00:25:30.380
Unpacking.

00:25:30.380 --> 00:25:30.780
Yeah.

00:25:30.900 --> 00:25:31.180
Yeah.

00:25:31.180 --> 00:25:32.020
Yeah, exactly.

00:25:32.020 --> 00:25:37.080
It's not exactly unpacking, but it was kind of the intention to make it look a bit like

00:25:37.080 --> 00:25:37.640
unpacking.

00:25:37.640 --> 00:25:37.960
Nice.

00:25:37.960 --> 00:25:38.240
Yeah.

00:25:38.240 --> 00:25:39.720
This looks like a really cool feature.

00:25:39.720 --> 00:25:43.780
You talked about the task groups and trio and those things.

00:25:43.780 --> 00:25:48.620
So when I saw this, concurrent errors obviously come to mind because if I try to both write

00:25:48.620 --> 00:25:53.300
something to a database and call a web service asynchronously and I start both of those and

00:25:53.300 --> 00:25:56.780
they both crash or multiple ones crash, which error do you want?

00:25:56.780 --> 00:25:58.520
The database error or do you want the API error?

00:25:58.520 --> 00:26:00.200
You probably want to know about both of them, right?

00:26:00.240 --> 00:26:03.100
So that's a real natural reason to bring these together.

00:26:03.100 --> 00:26:07.800
But maybe you'll also list out some of the other reasons that you might run into this.

00:26:07.800 --> 00:26:09.380
Maybe give people some other ideas.

00:26:09.380 --> 00:26:13.280
So the example of in the socket module, we have the create connection function.

00:26:13.280 --> 00:26:16.040
And that function, I was showing it in the stream.

00:26:16.040 --> 00:26:20.940
It iterates over all the configurations that you could try to connect with.

00:26:20.940 --> 00:26:24.600
And then depending on what's going on the other side, hopefully one of them works.

00:26:24.600 --> 00:26:27.100
But if none of them work, you have to report errors.

00:26:27.460 --> 00:26:30.800
And what we do in Python 3.10 is we just raise the last exception.

00:26:30.800 --> 00:26:33.020
So you don't know what happened really.

00:26:33.020 --> 00:26:35.640
You only know why the last attempt failed.

00:26:35.640 --> 00:26:38.060
You don't even know how many attempts were made to connect to.

00:26:38.060 --> 00:26:40.200
How many configurations did we try?

00:26:40.580 --> 00:26:43.120
So that was a long-standing open problem.

00:26:43.120 --> 00:26:45.740
Can we do better than just report the last error?

00:26:45.740 --> 00:26:47.180
And we closed it.

00:26:47.180 --> 00:26:48.860
We just added it for us to that.

00:26:48.860 --> 00:26:50.340
Give me a demo for in a group.

00:26:50.340 --> 00:26:54.940
Another place that comes to mind is maybe you're all familiar with some of these retry libraries.

00:26:54.940 --> 00:26:55.340
Yeah.

00:26:55.400 --> 00:26:57.920
Like, I think there's others as well.

00:26:57.920 --> 00:27:00.620
Where you put a decorator onto some function.

00:27:00.620 --> 00:27:03.000
You say, try this multiple times.

00:27:03.000 --> 00:27:07.760
And if it fails, do some sort of exponential backoff because maybe the server is overloaded.

00:27:07.760 --> 00:27:08.160
Right?

00:27:08.160 --> 00:27:10.200
Those types of things would be really great.

00:27:10.200 --> 00:27:15.180
Like, if it retries all the times it's supposed to and it fails, it'd be good to get all the errors.

00:27:15.180 --> 00:27:18.840
Not just the last one or the first one or whatever it decided it was going to give you.

00:27:18.840 --> 00:27:19.260
Yeah.

00:27:19.340 --> 00:27:20.380
It's the kind of thing.

00:27:20.380 --> 00:27:21.140
Yeah.

00:27:21.140 --> 00:27:21.660
Nice.

00:27:21.660 --> 00:27:22.200
Okay.

00:27:22.200 --> 00:27:24.140
Well, congratulations on getting that feature out.

00:27:24.140 --> 00:27:24.820
That's great.

00:27:24.820 --> 00:27:25.480
All right.

00:27:25.480 --> 00:27:26.560
What do we got next here?

00:27:26.560 --> 00:27:32.520
I think also related to this, I wanted to talk about this PEP678.

00:27:32.520 --> 00:27:39.060
That's a very small and simple feature that Zach Hadford Dodds wrote this PEP.

00:27:39.060 --> 00:27:40.900
He was trying out Exception Groups.

00:27:40.900 --> 00:27:42.760
He was the first kind of user.

00:27:42.760 --> 00:27:45.340
Even before the PR was merged, he was trying it out.

00:27:45.340 --> 00:27:48.480
He was trying to integrate it with the hypothesis library.

00:27:48.660 --> 00:27:53.680
So there you write a test and the library executes it many times with different inputs and you

00:27:53.680 --> 00:27:56.760
get failures in some of the inputs and you want to report all of them.

00:27:56.760 --> 00:28:01.840
So Zach had an Exception Group, kind of an Exception Rapper, kind of like Trio Multi-Error.

00:28:01.840 --> 00:28:08.960
He had his own version that he built in his library and he could associate each exception he attached

00:28:08.960 --> 00:28:13.260
to it, which input generated this error, which is very important.

00:28:13.260 --> 00:28:16.840
You need to tell people what the input was and what happened with it.

00:28:17.280 --> 00:28:21.700
And he couldn't do that in a convenient way with Exception Groups.

00:28:22.300 --> 00:28:27.320
He added this to base exception.

00:28:27.320 --> 00:28:29.340
You can add strings.

00:28:29.340 --> 00:28:40.180
You call it add note, give it a string and you can call it as many times as you want and add notes to the exceptions and they will appear in the default traceback that the interpreter prints.

00:28:40.180 --> 00:28:41.180
So that's all it is.

00:28:41.180 --> 00:28:45.140
It's a very simple feature, but it was received surprisingly well.

00:28:45.140 --> 00:28:49.700
It's a very simple feature that you can enrich an exception after you catch it.

00:28:49.700 --> 00:28:55.320
So you have the information that, you know, the error message and the type, you decide that when you raise the exception.

00:28:55.320 --> 00:29:01.720
But then sometimes when you're catching, there's some more information, some context, like what was I trying to do when this error happened?

00:29:02.040 --> 00:29:02.660
Sure. Yeah.

00:29:02.660 --> 00:29:09.400
Because often you'll see, except some type, some exception type, you'll deal with what you can, but you can't really handle it there.

00:29:09.400 --> 00:29:10.380
So you got to raise it again.

00:29:10.380 --> 00:29:14.640
And this is a place to add more information without completely wrapping it.

00:29:14.640 --> 00:29:14.940
Right.

00:29:14.940 --> 00:29:15.300
Right.

00:29:15.300 --> 00:29:15.740
Exactly.

00:29:15.740 --> 00:29:18.140
A lot of people have to chain it.

00:29:18.140 --> 00:29:19.900
Say this raised from that.

00:29:20.060 --> 00:29:23.680
So there will be situations where maybe you won't need to do that.

00:29:23.680 --> 00:29:24.020
Yeah.

00:29:24.020 --> 00:29:25.600
I'd love to see that go away.

00:29:25.600 --> 00:29:28.980
I sort of template libraries and stuff in the web all the time.

00:29:28.980 --> 00:29:33.940
I see like there's all these different errors and you got to hunt through a bunch of stuff to figure out what happened.

00:29:33.940 --> 00:29:34.260
Yeah.

00:29:34.260 --> 00:29:38.760
Also think about, for instance, like I think this is super useful actually for end users.

00:29:38.760 --> 00:29:42.700
Even like we think about that you're doing some query to the database.

00:29:42.700 --> 00:29:42.960
Right.

00:29:42.960 --> 00:29:45.740
And then, I don't know, it may fail for 6 million reasons.

00:29:45.740 --> 00:29:48.620
And then you want to add what you're asking for.

00:29:48.620 --> 00:29:48.820
Right.

00:29:48.840 --> 00:29:51.980
So you add your query or your user or whatever.

00:29:51.980 --> 00:29:59.020
Because probably the exception that the Postgres thingy that is underneath is not going to contain your actual thing.

00:29:59.020 --> 00:30:01.860
So this actually may save you hours.

00:30:01.860 --> 00:30:02.180
Right.

00:30:02.180 --> 00:30:07.480
Because in many enterprise environments, you don't even have easy access to that.

00:30:07.480 --> 00:30:08.180
Sorry, to prod.

00:30:08.180 --> 00:30:11.360
So you cannot just go there and see what's going on.

00:30:11.360 --> 00:30:18.760
So it would be super cool that you say, oh, if something fails, you know, I was trying to do this with this data and like with these things.

00:30:18.820 --> 00:30:23.500
So like if it fails now, you can know what's going on and you don't even need to log in, which is, I think it's a.

00:30:23.500 --> 00:30:24.620
Yeah.

00:30:24.620 --> 00:30:24.900
Yeah.

00:30:24.900 --> 00:30:25.880
It's a great idea.

00:30:25.880 --> 00:30:30.980
Or if you know, look, here's probably why this happened as a library developer.

00:30:30.980 --> 00:30:32.480
You're like, look, this is the error.

00:30:32.600 --> 00:30:33.520
But here's a note.

00:30:33.520 --> 00:30:37.300
This is probably because you didn't initialize the connection before you called this.

00:30:37.300 --> 00:30:46.620
So make sure, you know, like another area where I see this could be useful is I want to raise like the example you have in the docs is type error.

00:30:47.000 --> 00:30:51.120
But it could also, you know, it could be value error or some other built in low level type.

00:30:51.120 --> 00:30:56.740
You know, like really, this is just I want to raise that error, but it doesn't have a place for me to put additional information.

00:30:56.740 --> 00:30:59.480
And so I want to kind of enrich that with more.

00:30:59.480 --> 00:31:02.460
And so not just catch, add the data and then raise it again.

00:31:02.460 --> 00:31:07.220
But actually, I want to use a base error type that doesn't let me put more details in it and then just raise that.

00:31:07.220 --> 00:31:07.480
Right.

00:31:07.480 --> 00:31:08.260
That would also work.

00:31:08.260 --> 00:31:08.840
I think so.

00:31:08.840 --> 00:31:17.120
I mean, I think the intention was there was some discussions about using notes in the interpreter and I pushed back on it because I said this is owned by the application.

00:31:17.120 --> 00:31:21.420
The interpreter shouldn't touch the notes, you know, because people can wipe out the notes.

00:31:21.420 --> 00:31:22.360
They can change the order.

00:31:22.360 --> 00:31:23.240
They can do what they want.

00:31:23.240 --> 00:31:26.360
It's the applications, at least the way I see it.

00:31:26.360 --> 00:31:27.360
The application owns it.

00:31:27.360 --> 00:31:29.440
You put whatever context you want to put.

00:31:29.440 --> 00:31:30.900
Is there only one note?

00:31:31.040 --> 00:31:34.780
When I say add note, does that set the note or can I have a list of notes?

00:31:34.780 --> 00:31:36.020
It's a list of notes.

00:31:36.020 --> 00:31:36.520
Okay, got it.

00:31:36.520 --> 00:31:36.700
Yeah.

00:31:36.700 --> 00:31:38.040
And you can wipe it out if you want.

00:31:38.040 --> 00:31:38.360
You can.

00:31:38.360 --> 00:31:40.340
It's just a list.

00:31:40.340 --> 00:31:41.660
It's attached to the exception.

00:31:41.660 --> 00:31:43.100
You can do what you want with it, really.

00:31:43.100 --> 00:31:43.380
Yeah.

00:31:43.380 --> 00:31:43.640
Cool.

00:31:43.640 --> 00:31:44.160
Okay.

00:31:44.160 --> 00:31:44.680
Yeah.

00:31:44.680 --> 00:31:45.100
It's a great.

00:31:45.100 --> 00:31:46.040
It's a really great feature.

00:31:46.040 --> 00:31:51.760
I mean, it's I'm sure it was way less work than except star, but it's also going to be really valuable.

00:31:51.760 --> 00:31:52.140
I think.

00:31:52.140 --> 00:32:00.520
This portion of Talk Python To Me is brought to you by Command Line Heroes, an original podcast from Red Hat.

00:32:01.280 --> 00:32:04.440
Command Line Heroes chronicles the history of the software industry.

00:32:04.440 --> 00:32:15.280
If you want to get the big picture on how macOS and Windows became dominant players, as well as how Linux brought its radical open source opinion to the scene, then Season 1 is a fascinating lesson.

00:32:15.280 --> 00:32:20.740
In particular, check out OS Wars Part 1 and OS Wars Part 2, The Rise of Linux.

00:32:21.500 --> 00:32:28.920
Season 3 is all about programming languages, and it kicks off with a topic near and dear to all the Talk Python listeners, Python's tale.

00:32:28.920 --> 00:32:37.280
I even got to be a guest on that episode, as well as Emily Morehouse, who makes a connection between Python's technical extensibility and its inclusive community.

00:32:37.280 --> 00:32:43.120
I talk about how Python is both easy to learn and powerful enough to build apps like YouTube and Instagram.

00:32:43.700 --> 00:32:51.580
And Diane Mueller highlights how the Python community took the lead on so many inclusive practices that are spreading in tech, including the rise of community-led decision-making.

00:32:51.580 --> 00:32:54.880
This award-winning podcast is hosted by Saran Yiparak.

00:32:54.880 --> 00:32:58.720
Saran is a fantastic host, and the show is highly polished.

00:32:58.720 --> 00:33:04.980
Seriously, if you love the history of software development, jump over to talkpython.fm/heroes and check it out for yourself.

00:33:04.980 --> 00:33:08.220
Thank you to Command Line Heroes for keeping this show going strong.

00:33:11.460 --> 00:33:18.580
So, Mark, I had you and Guido on back, wow, almost to the day a year ago.

00:33:18.580 --> 00:33:24.940
We're off by November 1st, 2021, so not that long ago.

00:33:24.940 --> 00:33:27.960
Let's talk a little bit about the work that you're doing there.

00:33:27.960 --> 00:33:38.560
I guess the headline is that Python 3.11 is 10 to 60, 10 to 50% faster than previous, sort of on a reasonable range of applications.

00:33:38.560 --> 00:33:39.400
Is that the story?

00:33:39.400 --> 00:33:45.580
Yeah, somewhere between minus a few percent and plus 100, but it varies a huge amount.

00:33:45.580 --> 00:33:53.260
I mean, if you've got some application that basically spends all its time in NumPy or something like that, you're not really going to speed up at all.

00:33:53.260 --> 00:33:58.200
But if it's pure Python, you'd expect it to be a good 40, 50% faster.

00:33:58.200 --> 00:33:59.880
But it depends.

00:34:00.020 --> 00:34:06.700
Right, that's a good point because a lot of people do make Python faster by writing C or Rust or other languages.

00:34:06.700 --> 00:34:08.960
And at that point, it's out of your hands, right?

00:34:08.960 --> 00:34:09.280
Yeah.

00:34:09.280 --> 00:34:15.920
So, I mean, we're looking, hopefully, for 3.12 to start looking at the sort of interface between Python and C code.

00:34:16.060 --> 00:34:18.940
So, we should speed up code even though there's quite a lot of C code.

00:34:18.940 --> 00:34:26.140
We won't spend up the time spent in the C code in doing the actual work in the C code, but there's still quite a lot of sort of marshalling of data that happens.

00:34:26.140 --> 00:34:27.520
And hopefully, we'll streamline that.

00:34:27.900 --> 00:34:37.600
The existence of C extensions is sort of, in some ways, limits our opportunity to speed things up, but it's also why Python is so proper in the first place are one of the main reasons.

00:34:37.600 --> 00:34:39.320
So, definitely need to acknowledge it.

00:34:39.320 --> 00:34:40.240
Yeah, absolutely.

00:34:40.240 --> 00:34:48.840
So, Brandt, I'll definitely have you talk about the specializing interpreters, but Mark, maybe give us a rundown of some of the things from your plan that made it in here.

00:34:48.840 --> 00:34:52.220
I know some were aimed for 3.10, but they didn't make it until here, right?

00:34:52.220 --> 00:34:59.020
Yeah, so the whole thing, oh, that original plan I put up, that was more of a just to get the discussion going sort of thing.

00:34:59.020 --> 00:35:01.080
And it's basically, it's more or less a year off.

00:35:01.080 --> 00:35:03.260
So, if you just shift everything one forward.

00:35:03.260 --> 00:35:11.280
I mean, there was a lot of discussion on speeding up the interpreter in the first iteration and then looking more to the data structures in the second thing.

00:35:11.280 --> 00:35:12.880
It's much more jumbled than that.

00:35:12.880 --> 00:35:14.180
We're doing sort of a bit of everything.

00:35:14.180 --> 00:35:17.740
So, obviously, I was planning on, you know, expecting a smaller team.

00:35:17.740 --> 00:35:19.560
So, things are being a bit shuffled.

00:35:19.700 --> 00:35:23.220
So, yeah, there's a specializing interpreter, obviously, that's kind of key.

00:35:23.220 --> 00:35:25.840
There's also quite a lot of stuff we've done with data structures.

00:35:25.840 --> 00:35:28.360
I mean, we shrunk the Python object.

00:35:28.360 --> 00:35:31.780
So, I mean, the Python object, you know, has been shrinking for years.

00:35:31.780 --> 00:35:34.000
I mean, I've got some numbers here.

00:35:34.000 --> 00:35:42.160
So, like in 2.7 and 3.2, like an object with just four attributes would take 352 bytes on a 64-bit machine.

00:35:42.160 --> 00:35:44.120
And for 3.11, we've got it down to 112.

00:35:44.120 --> 00:35:46.340
And for 3.12, it would be 96.

00:35:46.740 --> 00:35:49.780
Well, before you get too excited, it's only 32 in C++.

00:35:49.780 --> 00:35:51.920
So, you know, we've got a bit of a way to go.

00:35:51.920 --> 00:35:55.460
Yeah, but, you know, it's going in the right direction for sure.

00:35:55.460 --> 00:36:01.640
And, you know, sure, some people out there listening just say like, okay, well, it's half the size roughly and it's going to be less than that.

00:36:01.640 --> 00:36:03.740
So, yay, we can use less memory.

00:36:04.260 --> 00:36:14.540
But maybe you could talk a little bit about how that affects things like L1, L2, L3 cache hits and other sort of, like, it's more important than just I need less RAM, right?

00:36:14.540 --> 00:36:14.980
Yeah, yeah.

00:36:14.980 --> 00:36:17.080
So, there's two things that happen.

00:36:17.080 --> 00:36:20.520
There's, yeah, things are faster because the hardware is just happier.

00:36:20.600 --> 00:36:23.360
If you pack everything together, it's in a high-level cache.

00:36:23.360 --> 00:36:27.240
So, you're not getting these sort of long pauses as you hit main memory.

00:36:27.240 --> 00:36:31.880
And the other thing is just the data structures are, because there's less of them, there's less indirection.

00:36:31.880 --> 00:36:37.760
So, for example, to load an attribute, we've got it down for basically an old, you know, older versions of Python.

00:36:37.760 --> 00:36:40.180
It was sort of effectively five memory reads.

00:36:40.180 --> 00:36:41.340
And they were dependent memory.

00:36:41.340 --> 00:36:43.580
You just have to read one before the next one and so on.

00:36:43.780 --> 00:36:47.280
Go to the class, find its, go to the object, find its dictionary.

00:36:47.280 --> 00:36:50.220
Then find the pointer that's in the dictionary and then go to that, right?

00:36:50.220 --> 00:36:50.840
Like, it's...

00:36:50.840 --> 00:36:52.420
Yeah, yeah, very much that.

00:36:52.420 --> 00:36:54.420
And it's down to more or less two now.

00:36:54.420 --> 00:36:58.140
So, I mean, obviously, there's still interpretive overhead on that.

00:36:58.140 --> 00:37:03.140
So, it's not quite that much faster, but it's getting there.

00:37:03.140 --> 00:37:04.900
So, yeah, there's a data structure.

00:37:04.900 --> 00:37:13.460
And then the frames, the Python frames, every time you call a Python function, we used to just allocate a heap object for the frame and all this stuff would go in there.

00:37:13.820 --> 00:37:17.420
And now they're all basically in a big contiguous sort of block of memory.

00:37:17.420 --> 00:37:21.900
So, it's just bumping a pointer rather than allocating, which is also faster.

00:37:21.900 --> 00:37:29.840
And frames are just more anyway because of the zero cost exceptions, which I think we mentioned on the release thing.

00:37:29.840 --> 00:37:30.920
But, yeah, this is...

00:37:30.920 --> 00:37:33.040
Well, let's tell people about zero cost exceptions.

00:37:33.040 --> 00:37:33.640
Okay.

00:37:33.640 --> 00:37:34.300
Well, zero cost...

00:37:34.300 --> 00:37:37.160
You shouldn't have to pay for errors if you're not raising errors, right?

00:37:37.160 --> 00:37:38.340
Yeah, that's the idea.

00:37:38.340 --> 00:37:39.580
And that's why they're called zero cost.

00:37:39.580 --> 00:37:41.400
But zero cost is in quotes in this.

00:37:41.760 --> 00:37:43.540
And the reason for that is it's just...

00:37:43.540 --> 00:37:44.780
That's the name it has got.

00:37:44.780 --> 00:37:46.540
They're definitely not zero cost.

00:37:46.540 --> 00:37:50.360
The idea is that they're pretty low cost if you don't have an exception.

00:37:50.360 --> 00:37:54.720
But they tend to be even more expensive if you do get an exception because you have to do more lookup.

00:37:54.720 --> 00:38:00.300
The important thing here is that just there was lots of runtime information we need to maintain and we don't now.

00:38:00.300 --> 00:38:05.960
So, that, again, shrinks the frames and just makes calls faster because calls in Python were notoriously slow.

00:38:06.120 --> 00:38:08.540
So, that's one thing we've sped up significantly.

00:38:08.540 --> 00:38:08.900
Yeah.

00:38:08.900 --> 00:38:13.780
So, the idea was in previous releases of Python, if you...

00:38:13.780 --> 00:38:22.000
Just to enter a try block, even if it was successful, there was a little bit of overhead to set up the mechanisms of potentially handling the errors and the information you needed, right?

00:38:22.000 --> 00:38:22.440
Yeah.

00:38:22.440 --> 00:38:24.160
And this wasn't just the overhead.

00:38:24.160 --> 00:38:25.280
You defer more of that, right?

00:38:25.280 --> 00:38:25.640
Yeah.

00:38:25.640 --> 00:38:35.380
I mean, it's actually not so much that overhead as just the space you had to put that data in had to be allocated every time you made a call in case there was an exception.

00:38:35.380 --> 00:38:36.580
And then we had to...

00:38:36.580 --> 00:38:39.780
It was massively over-allocated to the amount of space anyone ever needed.

00:38:39.780 --> 00:38:41.900
So, just that was the big sort of advantage.

00:38:41.900 --> 00:38:42.440
Nice.

00:38:42.440 --> 00:38:42.780
Yeah.

00:38:42.780 --> 00:38:43.760
This is fantastic.

00:38:43.760 --> 00:38:48.440
You don't want to discourage people from putting proper error handling in their code.

00:38:48.440 --> 00:38:49.720
Yeah.

00:38:49.720 --> 00:38:50.460
What do you think...

00:38:50.460 --> 00:38:53.060
I see your name on this feature here in GitHub.

00:38:53.060 --> 00:38:54.200
What are your thoughts on it?

00:38:54.200 --> 00:38:56.040
Yeah, I think it's cool.

00:38:56.040 --> 00:38:57.960
And I was kind of...

00:38:57.960 --> 00:39:06.240
You know, it was a nice touch that Mark implemented it between when I wrote the prototype for exception groups and when the PEP was approved.

00:39:06.240 --> 00:39:10.640
So, that got in the way a little bit.

00:39:10.640 --> 00:39:11.460
But it was good.

00:39:11.460 --> 00:39:17.000
I got intimately acquainted with zero-cost exceptions through that exercise.

00:39:17.000 --> 00:39:20.220
Well, it's zero-cost for some people.

00:39:20.220 --> 00:39:21.080
Yeah.

00:39:21.080 --> 00:39:23.740
I tease Mark a lot about that.

00:39:24.060 --> 00:39:25.900
No, I think it's a cool feature.

00:39:25.900 --> 00:39:28.940
And I mean, I followed up on that.

00:39:28.940 --> 00:39:30.780
We now have...

00:39:30.780 --> 00:39:32.900
After we removed that, we still had a...

00:39:32.900 --> 00:39:34.180
I was talking about this on Monday.

00:39:34.180 --> 00:39:36.200
We had to jump over the exception handler.

00:39:36.200 --> 00:39:39.120
And then I told them, wait a minute, there's a jump.

00:39:39.120 --> 00:39:39.780
It's not zero.

00:39:39.780 --> 00:39:42.940
You have to jump over the exception handler if there's no exception.

00:39:42.940 --> 00:39:44.780
So, now we have...

00:39:44.780 --> 00:39:45.740
We did...

00:39:45.740 --> 00:39:48.540
We identify exception handlers as cold blocks.

00:39:48.540 --> 00:39:52.600
And before we lay out the code of the function, we put all the code blocks in the end.

00:39:52.600 --> 00:39:57.440
So, now if there's no exception, there isn't even an exception handler to jump over.

00:39:57.440 --> 00:39:58.800
That would be in 312.

00:39:58.800 --> 00:40:00.200
Excellent.

00:40:00.200 --> 00:40:02.300
You made zero-cost even faster.

00:40:02.300 --> 00:40:03.380
So, now it's...

00:40:03.380 --> 00:40:04.840
Zero even smaller.

00:40:04.840 --> 00:40:05.180
Yeah.

00:40:05.780 --> 00:40:08.340
It's asymptotically approaching zero.

00:40:08.340 --> 00:40:09.040
Yeah.

00:40:09.040 --> 00:40:14.020
So, but it's kind of nice that we have this notion of cold blocks and hot blocks and we

00:40:14.020 --> 00:40:15.540
can maybe do other things with it.

00:40:15.540 --> 00:40:17.860
Kind of nice that all the happy...

00:40:17.860 --> 00:40:23.200
But the fast code is kind of in the beginning of the functions bytecode block.

00:40:23.200 --> 00:40:26.740
And, you know, in terms of caches and all that, you don't have to...

00:40:26.740 --> 00:40:30.520
I think it will bring a few benefits beyond just not having to jump.

00:40:30.520 --> 00:40:30.760
Yeah.

00:40:30.760 --> 00:40:31.260
Yeah.

00:40:31.260 --> 00:40:31.860
This is excellent.

00:40:31.860 --> 00:40:33.920
It's a really great feature and pretty straightforward.

00:40:33.920 --> 00:40:34.300
All right.

00:40:34.300 --> 00:40:37.440
Brent, tell us about the specializing adaptive interpreter.

00:40:37.440 --> 00:40:38.480
That's a big deal.

00:40:38.480 --> 00:40:41.340
You and I spoke about that about six weeks ago, I think.

00:40:41.340 --> 00:40:41.880
Yeah.

00:40:41.880 --> 00:40:42.260
Yeah.

00:40:42.260 --> 00:40:46.940
Basically, the headline is the bytecode changes while it's running to adapt to your code,

00:40:46.940 --> 00:40:47.780
which is really neat.

00:40:47.780 --> 00:40:54.240
So, it's kind of finding places where we can do the same thing, but using less work by like

00:40:54.240 --> 00:40:55.220
cheating a little bit.

00:40:55.920 --> 00:40:58.520
But cheating in a way that is not visible at all.

00:40:58.520 --> 00:41:04.660
A good example is something like a global load or a load from the built-in.

00:41:04.660 --> 00:41:09.040
So, if I'm looking at like the len function, that requires two dictionary lookups.

00:41:09.040 --> 00:41:12.900
Every time I want to look at the len function anywhere, I first need to check the global namespace

00:41:12.900 --> 00:41:14.480
and that's going to be a failed lookup.

00:41:14.480 --> 00:41:17.700
Then I need to check the built-ins dictionary and that's going to be a successful lookup.

00:41:17.700 --> 00:41:23.720
So, every time I want to use len or range or list or any of those built-ins, that's the

00:41:23.720 --> 00:41:24.960
cost that I have to pay.

00:41:25.220 --> 00:41:27.880
But people don't change the global namespace that often.

00:41:27.880 --> 00:41:31.680
And people change the built-ins namespace even less often, or at least they shouldn't be

00:41:31.680 --> 00:41:32.840
changing it very often.

00:41:32.840 --> 00:41:35.180
I'm going to make false true and true false.

00:41:35.180 --> 00:41:36.120
Let's see what that is.

00:41:36.960 --> 00:41:43.000
And so, you can make these observations where it's like, okay, well, if the set of keys in

00:41:43.000 --> 00:41:47.120
the global namespace hasn't changed since last time this bytecode instruction ran, then I

00:41:47.120 --> 00:41:48.620
know that that lookup is going to fail.

00:41:48.620 --> 00:41:52.620
Because if it failed last time and the keys are the same, then it's going to fail this time

00:41:52.620 --> 00:41:52.940
as well.

00:41:52.940 --> 00:41:53.860
So, we can just skip that.

00:41:54.120 --> 00:41:56.380
And same for the built-ins dictionary.

00:41:56.380 --> 00:42:01.500
You know, if we know that the keys in that dictionary haven't changed, that actually means that the

00:42:01.500 --> 00:42:03.620
internal layout of the dictionary is the same.

00:42:03.620 --> 00:42:07.960
And we don't even need to look up len in the built-ins dictionary.

00:42:07.960 --> 00:42:12.560
We can reach directly to the last location where it was before and give you that instead.

00:42:12.900 --> 00:42:18.820
So, you obviously see in a lot of code as like an older code as a kind of a micro-optimization.

00:42:18.820 --> 00:42:23.560
Whenever someone was using a built-in in like a very hot Python loop, sometimes you'd see

00:42:23.560 --> 00:42:28.000
them like do this kind of quark trick where they make it a local variable by saying like

00:42:28.000 --> 00:42:31.400
len equals len or something like that as part of the functions arguments.

00:42:31.400 --> 00:42:34.100
So that you turn it into a fast local load.

00:42:34.100 --> 00:42:39.820
And what we've essentially done is, you know, made ugly acts like that totally unnecessary.

00:42:39.820 --> 00:42:40.340
Yeah.

00:42:40.340 --> 00:42:40.720
Which is really cool.

00:42:40.720 --> 00:42:42.260
You do that behind the scenes transparently.

00:42:42.260 --> 00:42:42.620
Yeah.

00:42:42.740 --> 00:42:43.060
Exactly.

00:42:43.060 --> 00:42:45.260
And so that's just, you know, one example.

00:42:45.260 --> 00:42:50.380
We've done tons of specializations for all sorts of things ranging from calls to attribute

00:42:50.380 --> 00:42:52.720
lookups to attribute stores, et cetera.

00:42:52.720 --> 00:42:56.020
So yeah, it's a really, really powerful thing.

00:42:56.020 --> 00:42:57.480
What was it?

00:42:57.480 --> 00:42:59.560
It's the 569?

00:42:59.560 --> 00:43:00.200
Yeah.

00:43:00.200 --> 00:43:00.960
Mark wrote it.

00:43:00.960 --> 00:43:01.620
It was 659.

00:43:01.620 --> 00:43:02.440
659.

00:43:02.440 --> 00:43:03.240
Almost there.

00:43:03.240 --> 00:43:03.440
Yeah.

00:43:03.440 --> 00:43:03.940
Yeah.

00:43:03.940 --> 00:43:06.060
So this interpreter is Mark's baby.

00:43:06.060 --> 00:43:07.820
He could tell you much more about it than I could.

00:43:07.820 --> 00:43:08.080
Yeah.

00:43:08.080 --> 00:43:10.380
I just want to give you a chance to give a shout out about specialist.

00:43:10.380 --> 00:43:10.960
Yeah.

00:43:10.960 --> 00:43:11.280
Yeah.

00:43:11.280 --> 00:43:12.520
So this is why I was on your show.

00:43:12.580 --> 00:43:13.180
A couple of weeks ago.

00:43:13.180 --> 00:43:16.860
So looking at bytecode disassemblies is not fun.

00:43:16.860 --> 00:43:20.920
And so one thing that's kind of cool is, you know, if you upgrade to Python 3.11, you run

00:43:20.920 --> 00:43:23.840
your code and you saw it got, you know, 10, 20, 30% faster.

00:43:23.840 --> 00:43:26.800
You might be wondering like, okay, where did it get faster?

00:43:26.900 --> 00:43:28.760
Like what is faster about my code?

00:43:28.760 --> 00:43:32.820
And so specialist is basically a package that I made.

00:43:32.820 --> 00:43:33.740
It's pip installable.

00:43:33.740 --> 00:43:34.920
It only works on 3.11.

00:43:34.920 --> 00:43:39.200
And basically if you run your code using specialist instead of Python.

00:43:39.560 --> 00:43:40.900
So you just type specialist, my project.

00:43:40.900 --> 00:43:42.340
So you just type specialist, my project.by or whatever.

00:43:42.340 --> 00:43:48.660
It will open a web browser and show you your code, but color highlighted to show you where

00:43:48.660 --> 00:43:51.960
the interpreter was able to specialize your code, where it wasn't.

00:43:52.320 --> 00:43:53.200
And that's really neat.

00:43:53.200 --> 00:43:56.840
So you can see like, oh, actually, you know, these are the attribute loads that got faster.

00:43:56.840 --> 00:43:59.480
These are the places where my global loads are being cached.

00:43:59.480 --> 00:44:00.120
That's perfect.

00:44:00.120 --> 00:44:00.500
Yeah.

00:44:00.500 --> 00:44:00.820
That's awesome.

00:44:00.820 --> 00:44:01.080
Yeah.

00:44:01.080 --> 00:44:02.000
This is a really cool project.

00:44:02.000 --> 00:44:06.780
And it has some proactive features, not just informational aspects.

00:44:06.780 --> 00:44:11.920
I think anyway, you know, if you run a profiler, it'll show you where your code's spending time,

00:44:11.920 --> 00:44:15.400
but it doesn't mean you should go change everything to make it faster.

00:44:15.400 --> 00:44:19.580
You should look at like, oh, well, this loop or this one function is like the thing that maybe

00:44:19.580 --> 00:44:24.060
we should think about slightly changing the algorithm or the way we do a loop or something.

00:44:24.060 --> 00:44:29.120
And it's a little bit similar here because the specializing adaptive interpreter only specializes

00:44:29.120 --> 00:44:35.280
some things like it doesn't specialize floats interacting with ints or those types of things.

00:44:35.280 --> 00:44:37.220
And, or I think division as well.

00:44:37.220 --> 00:44:41.160
And so there's certain ways you might be able to slightly change inside of a really hot loop,

00:44:41.160 --> 00:44:43.580
you know, make something to float ahead of time.

00:44:43.580 --> 00:44:45.980
If you know, it's going to be involved in floating point operations.

00:44:45.980 --> 00:44:46.420
Right.

00:44:46.420 --> 00:44:47.740
Yeah.

00:44:47.740 --> 00:44:52.460
The idea is that this is show us how we can fix things so that you don't need to mess with

00:44:52.460 --> 00:44:52.980
your code.

00:44:52.980 --> 00:44:54.460
I see.

00:44:54.460 --> 00:44:56.200
So this is in the future.

00:44:56.200 --> 00:44:56.640
Okay.

00:44:56.640 --> 00:44:56.920
Yeah.

00:44:56.920 --> 00:44:57.180
Awesome.

00:44:57.180 --> 00:45:02.100
I would not necessarily encourage people to start tuning individual bytecode instructions

00:45:02.100 --> 00:45:04.620
in their code due to our implementation details.

00:45:04.620 --> 00:45:06.460
Otherwise you will end coding in C.

00:45:06.460 --> 00:45:10.080
You all mean I need to, I got to take all those decimal points back out of my code.

00:45:10.080 --> 00:45:10.560
No, just kidding.

00:45:10.560 --> 00:45:10.820
Yeah.

00:45:10.820 --> 00:45:13.080
I want to get every single bytecode instruction green.

00:45:13.080 --> 00:45:17.160
Some things will never specialize and that's just an artifact of programs.

00:45:17.160 --> 00:45:21.080
But, you know, if we can specialize enough and we typically do, you know, one line, maybe

00:45:21.080 --> 00:45:26.780
20 bytecode instructions if, you know, four of them get specialized successfully and two

00:45:26.780 --> 00:45:28.660
of them don't generally, that will still be faster.

00:45:28.660 --> 00:45:31.240
Do you know what you should do for April Fool?

00:45:31.240 --> 00:45:36.520
Like you should do a pytest plugin that shows you the percentage of specialized instructions

00:45:36.520 --> 00:45:41.960
in your code and people can fix the percentage so they can say, fail my test suite if my code

00:45:41.960 --> 00:45:43.840
is not specialized more than 50%.

00:45:43.840 --> 00:45:47.800
If you de-specialize it, it's like a performance regression.

00:45:47.800 --> 00:45:48.920
Drop it.

00:45:48.920 --> 00:45:49.100
Yeah.

00:45:49.100 --> 00:45:50.040
Yeah.

00:45:50.040 --> 00:45:51.160
It's like a coverage thing.

00:45:51.160 --> 00:45:51.360
Yeah.

00:45:51.360 --> 00:45:53.340
No, I was kind of thinking about this.

00:45:53.340 --> 00:45:58.720
So Pablo can tell you more about this, but his cool new tracebacks, the whole reason

00:45:58.720 --> 00:46:03.380
specialist is able to do these cool, you know, column level highlighting of your source code

00:46:03.380 --> 00:46:07.020
is because we do have that fine grain position information under the hood.

00:46:07.020 --> 00:46:11.140
So it's, we kind of just piggybacked on that feature in order to give you that.

00:46:11.140 --> 00:46:16.100
But I was kind of thinking another, another thing, another April Fool's project could

00:46:16.100 --> 00:46:19.000
be, you know, column level coverage information.

00:46:19.000 --> 00:46:21.760
So to get to a hundred percent coverage, you have to cover every single column.

00:46:21.760 --> 00:46:22.120
Exactly.

00:46:22.120 --> 00:46:22.420
Yeah.

00:46:22.420 --> 00:46:24.540
I feel like people might take that too seriously.

00:46:24.540 --> 00:46:27.020
Even the white space, all this white space is not covered.

00:46:27.020 --> 00:46:28.700
Yeah.

00:46:28.700 --> 00:46:32.200
You think you're intense by having branch coverage turned on, just wait till you have column coverage

00:46:32.200 --> 00:46:32.480
turned on.

00:46:32.480 --> 00:46:32.680
Yeah.

00:46:32.680 --> 00:46:35.020
You can only cover two white spaces per line.

00:46:35.020 --> 00:46:36.180
So you got to call that a lot.

00:46:36.180 --> 00:46:36.660
All right.

00:46:36.660 --> 00:46:42.960
I think that's a perfect segue over to one of the most tangible contributions from Pablo

00:46:42.960 --> 00:46:43.360
here.

00:46:43.360 --> 00:46:47.260
Maybe tell us about this new fine grained error locations and tracebacks.

00:46:47.260 --> 00:46:48.120
This is fantastic.

00:46:48.120 --> 00:46:53.960
This will save people being in debuggers or rewriting their code with tons of print statements to

00:46:53.960 --> 00:46:54.740
figure out what's going on.

00:46:54.740 --> 00:46:55.240
Yeah.

00:46:55.240 --> 00:46:55.980
Thank you very much.

00:46:55.980 --> 00:46:57.980
We put a lot of effort into this.

00:46:57.980 --> 00:46:59.920
So this is a man.

00:46:59.920 --> 00:47:01.240
I don't even remember my pep.

00:47:01.240 --> 00:47:01.980
So I don't know.

00:47:01.980 --> 00:47:03.020
It's PEP something, something.

00:47:03.020 --> 00:47:04.840
And it has a horrendous name.

00:47:04.840 --> 00:47:06.140
Six, five, seven.

00:47:06.140 --> 00:47:07.440
And let's see.

00:47:07.440 --> 00:47:08.180
Six, five, seven.

00:47:08.180 --> 00:47:08.720
Thanks.

00:47:08.720 --> 00:47:11.960
Include fine grained error locations and tracebacks.

00:47:11.960 --> 00:47:12.340
Yeah.

00:47:12.340 --> 00:47:13.220
The worst name.

00:47:13.220 --> 00:47:16.480
Even I think I was talking with Mark in the Python code of press print.

00:47:16.580 --> 00:47:21.520
And he was saying like, what it means like fine grained, like, you know, like, is this

00:47:21.520 --> 00:47:22.200
very fine grained?

00:47:22.200 --> 00:47:25.320
Like, so I think we are renaming the PEP to fancy tracebacks.

00:47:25.320 --> 00:47:26.860
I think that's much better.

00:47:26.860 --> 00:47:32.960
Anyway, so this is a project I worked together with Batuhan, Tazkaya, and Omar Azkar.

00:47:32.960 --> 00:47:36.320
So kudos to them as well, because they participated equally on this.

00:47:36.320 --> 00:47:41.920
And the idea is that we were like, we started this project to make, you know, to improve the

00:47:41.920 --> 00:47:45.240
error messages in the interpreter and the general experience.

00:47:45.500 --> 00:47:49.000
Not only for, you know, people, because when people talk about this, they normally refer

00:47:49.000 --> 00:47:51.460
to people starting to learn Python.

00:47:51.460 --> 00:47:55.240
But like, to be honest, most of these things also affect people that are experts.

00:47:55.240 --> 00:48:00.100
Like, I always say that when I implemented the suggestions, I was the first one benefiting

00:48:00.100 --> 00:48:03.680
from them because like, I make a lot of typos and, you know, like, this is odd.

00:48:03.680 --> 00:48:04.380
You mean this?

00:48:04.380 --> 00:48:09.640
So the idea that we have is that most of the time, the lack of, you know, the interpreter

00:48:09.640 --> 00:48:13.080
shows you kind of the position when the error happens, but it's quite limited because

00:48:13.080 --> 00:48:19.180
most of the time you people tend to have due to Python flexible syntax, a huge amount of

00:48:19.180 --> 00:48:21.260
like complexity, even in a single line.

00:48:21.260 --> 00:48:23.260
In the pep, there is a bunch of examples.

00:48:23.260 --> 00:48:28.280
Like you access a bunch of keys in a dictionary and some of them doesn't work or is not there

00:48:28.280 --> 00:48:29.900
or is none or something like that.

00:48:29.900 --> 00:48:30.040
Right.

00:48:30.080 --> 00:48:31.260
And then it fails.

00:48:31.260 --> 00:48:35.200
Or sometimes you have like several function calls or several additions.

00:48:35.200 --> 00:48:37.540
And, you know, it's quite difficult.

00:48:37.540 --> 00:48:43.120
And most of the time fixing these things involve going into a debugger like PDB and then trying

00:48:43.120 --> 00:48:47.860
to inspect every single object and say, okay, this dictionary doesn't have this key at this

00:48:47.860 --> 00:48:48.300
level.

00:48:48.300 --> 00:48:49.760
And like, you know, that sucks.

00:48:49.920 --> 00:48:55.120
Like it's not because like the buggers are cool, but like it's cooler not to use them.

00:48:55.120 --> 00:48:55.400
Right.

00:48:55.400 --> 00:48:58.480
And, you know, we thought, what can we do here?

00:48:58.480 --> 00:49:04.380
And we, we arrived to this idea actually also to mention, everyone involved, this was

00:49:04.380 --> 00:49:10.980
originally inspired by some kind of prototype that car from the pipe I team made very long

00:49:10.980 --> 00:49:14.760
ago when he saw like a kind of minimal version of this.

00:49:14.760 --> 00:49:17.040
And then I said, okay, can we do this?

00:49:17.040 --> 00:49:23.260
And what we do now is that we propagate because the parser, our super cool PEG parser knows

00:49:23.260 --> 00:49:25.720
position of all the tokens and things like that.

00:49:25.720 --> 00:49:31.880
So we are propagating those, that information through the interpreter and we store this information

00:49:31.880 --> 00:49:33.000
now in code objects.

00:49:33.000 --> 00:49:37.080
So aside the fact of this PEG actually is that code objects are slightly bigger, although,

00:49:37.080 --> 00:49:40.900
you know, because code objects don't tend to be a huge percentage of your application.

00:49:40.900 --> 00:49:42.320
It doesn't really matter that much.

00:49:42.320 --> 00:49:46.920
Maybe PYC files are a bit bigger, but you know, you have a lot of this disk space, I'm

00:49:46.920 --> 00:49:47.160
sure.

00:49:47.160 --> 00:49:51.040
And the idea is that, you know, we, we store this information in code objects.

00:49:51.040 --> 00:49:55.880
So when you raise an exception, we say, well, what is the instruction that is raised this

00:49:55.880 --> 00:49:56.220
exception?

00:49:56.220 --> 00:50:00.460
And then once we know which is the instruction that raised the exception, then we go and say,

00:50:00.460 --> 00:50:04.100
okay, what is the position information that generated this instruction?

00:50:04.100 --> 00:50:08.620
And because we propagated it, we know, and then we can say, okay, here is kind of like

00:50:08.620 --> 00:50:12.220
the, like the lines, the columns that this instruction spans.

00:50:12.220 --> 00:50:17.460
So that kind of allows us to underline the specific location, but we go a bit further.

00:50:17.460 --> 00:50:18.160
Oh, sorry.

00:50:18.160 --> 00:50:18.380
Sorry.

00:50:18.380 --> 00:50:19.000
Go ahead, Michael.

00:50:19.000 --> 00:50:20.940
I was going to say, this is super valuable.

00:50:20.940 --> 00:50:26.560
The example you have in the PEP is you have a dictionary, you say bracket of key A, and

00:50:26.560 --> 00:50:28.580
then the thing that comes back is another dictionary.

00:50:28.580 --> 00:50:32.160
So you say bracket B and then another dictionary, bracket C and then bracket D.

00:50:32.220 --> 00:50:36.400
And if you own three 10, the error is just like, if one of those is miss is, is, is none,

00:50:36.400 --> 00:50:38.460
say none type is object.

00:50:38.460 --> 00:50:43.540
Object is not subscriptable, or maybe, you know, does not contain that key or some weird thing

00:50:43.540 --> 00:50:44.020
like that.

00:50:44.020 --> 00:50:46.160
But is it A, B, C, or D?

00:50:46.160 --> 00:50:47.020
You have no idea.

00:50:47.020 --> 00:50:51.340
You're in a debugger printing them out separately or something, but now it just goes, nope, it's

00:50:51.340 --> 00:50:51.920
the C one.

00:50:51.920 --> 00:50:53.480
That's it's the third.

00:50:53.480 --> 00:50:53.960
Exactly.

00:50:53.960 --> 00:50:54.900
Subscript one.

00:50:54.900 --> 00:50:56.540
And that's just, just jump right to it.

00:50:56.540 --> 00:50:56.940
Oh, okay.

00:50:56.940 --> 00:50:57.100
Yeah.

00:50:57.100 --> 00:50:59.820
Also this error, none type is not subscriptable.

00:50:59.820 --> 00:51:02.280
It's kind of like, thanks for the info.

00:51:02.280 --> 00:51:04.620
Like, it's like, you know, water is wet.

00:51:04.620 --> 00:51:05.160
Okay.

00:51:05.160 --> 00:51:05.600
Thanks.

00:51:05.600 --> 00:51:07.380
It's not, it's not super useful.

00:51:07.380 --> 00:51:08.120
No, exactly.

00:51:08.120 --> 00:51:09.420
So tell me when it's going to rain.

00:51:09.420 --> 00:51:14.300
Anyway, we did like the first version of this and then we realized, realized that there was

00:51:14.300 --> 00:51:16.220
some kind of like, you know, it was cool.

00:51:16.220 --> 00:51:21.100
Like most people really like it, but like, especially for instance, with the example, with the dictionary

00:51:21.100 --> 00:51:22.960
that has many dictionaries inside.

00:51:23.240 --> 00:51:26.640
There was some confusion because like, you know, it underlines the whole thing.

00:51:26.640 --> 00:51:31.480
And then, you know, the order of operations and, you know, also with complex mathematical

00:51:31.480 --> 00:51:35.260
expressions, like you do a plus b plus c and the last addition fails.

00:51:35.260 --> 00:51:40.040
It needs to underline a plus b plus c because what happened is that it first added a plus b

00:51:40.040 --> 00:51:42.900
and that gives you something that then you added to c.

00:51:42.900 --> 00:51:47.280
And what happened is that the last addition failed, but that includes a plus b.

00:51:47.280 --> 00:51:48.580
So you need to underline the whole thing.

00:51:48.820 --> 00:51:53.860
If you know the order of operations and I just underline a plus b plus c, you know that

00:51:53.860 --> 00:51:57.480
what will fail is the last one because that's the last one that is executed.

00:51:57.480 --> 00:52:01.380
But it's still confusing because, you know, specifically also with the dictionary, people

00:52:01.380 --> 00:52:05.260
were saying, yeah, okay, but like you're underlining three keys here, which is the one that failed.

00:52:05.260 --> 00:52:08.720
I mean, you know, you can learn by experience that is the last one, but it's kind of like,

00:52:08.720 --> 00:52:10.380
it was not a great experience.

00:52:10.380 --> 00:52:12.240
So we went a step farther.

00:52:12.620 --> 00:52:17.520
So what we do is that once we know the kind of range in the line that shows the problem,

00:52:17.520 --> 00:52:20.760
we reparse that chunk of expression.

00:52:20.760 --> 00:52:24.140
And then we know, okay, so we know now that this expression has this AST.

00:52:24.140 --> 00:52:29.720
And then we analyze the AST and then we say, okay, is this AST something that we can further

00:52:29.720 --> 00:52:31.360
improve the error message?

00:52:31.360 --> 00:52:36.000
Like for instance, is this AST a bunch of key access in a dictionary or a bunch of attribute

00:52:36.000 --> 00:52:40.160
access or a bunch of function calls or maybe binary operations?

00:52:40.620 --> 00:52:45.400
And if it's the case, then we use a specialized, like, you know, on the line, I don't know,

00:52:45.400 --> 00:52:47.760
tildes or squiggles or whatever it's called.

00:52:47.760 --> 00:52:53.360
And, you know, the dictionary ones have this different one that marks which key access it

00:52:53.360 --> 00:52:56.160
was known, the same thing for binary operations and things like that.

00:52:56.160 --> 00:53:01.320
So we do this extra step at the end that, you know, does a bunch of extra work, but it

00:53:01.320 --> 00:53:07.080
tries to improve even upon the kind of just underlining the line just so we can offer even more

00:53:07.080 --> 00:53:08.040
rich information.

00:53:08.040 --> 00:53:09.640
And I'm quite happy.

00:53:09.760 --> 00:53:11.040
I'm very pleased about this.

00:53:11.040 --> 00:53:14.640
Sorry, Mark, but I think it's the best feature of 3.11.

00:53:14.640 --> 00:53:16.000
Yeah.

00:53:16.000 --> 00:53:18.980
This is probably the second stream when I said this, but it's true.

00:53:18.980 --> 00:53:20.500
Totally, totally true.

00:53:20.500 --> 00:53:21.260
100% true.

00:53:21.260 --> 00:53:22.740
So I'm very excited about this.

00:53:22.740 --> 00:53:24.060
I literally use this every day.

00:53:24.060 --> 00:53:25.940
Today I was deploying Python 3.11.

00:53:25.940 --> 00:53:27.180
Well, this week, sorry.

00:53:27.180 --> 00:53:30.200
I was deploying Python 3.11 at Bloomberg and something went wrong.

00:53:30.200 --> 00:53:32.200
And literally, this thing saved my day.

00:53:32.200 --> 00:53:36.160
This thing saved me to just logging into some forsaken machine and understanding what's going

00:53:36.160 --> 00:53:36.420
on.

00:53:36.420 --> 00:53:37.420
What about that?

00:53:37.700 --> 00:53:38.520
So super cool.

00:53:38.520 --> 00:53:39.020
Very happy.

00:53:39.020 --> 00:53:43.640
I hope that everybody that uses this and is happy reach to us and say, I am happy.

00:53:43.820 --> 00:53:47.040
Because normally people reach to us when they are not happy.

00:53:47.040 --> 00:53:49.880
And they say, evil core developers, you break everything.

00:53:49.880 --> 00:53:52.800
But instead of that, you should reach to us and say, nice.

00:53:52.800 --> 00:53:55.380
I did this cool thing.

00:53:55.440 --> 00:53:57.640
You should tweet at Pablo or something, though.

00:53:57.640 --> 00:53:59.580
Don't open issues saying you're happy.

00:53:59.580 --> 00:54:00.000
Exactly.

00:54:00.000 --> 00:54:00.120
Exactly.

00:54:00.120 --> 00:54:04.220
Just tweet a couple of tildes if you care.

00:54:04.220 --> 00:54:05.400
It's in a smiley face, Adam.

00:54:05.400 --> 00:54:05.760
Exactly.

00:54:05.760 --> 00:54:07.580
Tweet happy at python.org.

00:54:07.580 --> 00:54:10.060
I will take that email address.

00:54:10.060 --> 00:54:10.600
Awesome.

00:54:10.900 --> 00:54:13.220
It's that we improve it a bit further.

00:54:13.220 --> 00:54:17.480
One of the things that happen is that, you know, like sometimes if the whole line is wrong,

00:54:17.480 --> 00:54:21.300
because this example you have there, if you, sorry, for the ones listening to the podcast,

00:54:21.300 --> 00:54:25.060
we have here some, we are seeing some output, but doesn't matter.

00:54:25.060 --> 00:54:25.520
Don't worry.

00:54:25.520 --> 00:54:26.460
I will describe it.

00:54:26.720 --> 00:54:30.520
So, for instance, you're calling a function and that's the whole thing that is in the line.

00:54:30.520 --> 00:54:32.560
We used to underline the whole thing.

00:54:32.560 --> 00:54:38.220
So, we'll say, okay, even if the whole line is failing, so it's not like a part of the line is failing,

00:54:38.220 --> 00:54:40.680
the whole thing is failing, we used to underline that.

00:54:40.680 --> 00:54:42.280
And that apparently is still on the pep.

00:54:42.280 --> 00:54:45.420
Maybe I should change that because that is not like that anymore.

00:54:45.420 --> 00:54:49.400
Because someone suggested, I mean, come on, like if it's the whole line is failing,

00:54:49.400 --> 00:54:51.500
underline the whole line is actually not that useful.

00:54:51.500 --> 00:54:54.540
And, you know, you are spending vertical space.

00:54:54.540 --> 00:54:56.160
So, you need to scroll a lot.

00:54:56.440 --> 00:54:59.800
And at the beginning, I say, yeah, but it's inconsistent.

00:54:59.800 --> 00:55:00.720
I don't like it.

00:55:00.720 --> 00:55:05.200
And I push back a bit, but like then, you know, more people say, Pablo, you're wrong.

00:55:05.200 --> 00:55:06.880
And then I say, okay, okay, I'm wrong.

00:55:06.880 --> 00:55:08.400
We improve this further.

00:55:08.400 --> 00:55:11.680
So, you say, but don't take this as an advice.

00:55:11.680 --> 00:55:14.260
Don't tell me that I'm wrong collectively, please.

00:55:14.260 --> 00:55:20.040
But, right, so now if the whole line is underlined, we don't underline it

00:55:20.040 --> 00:55:22.220
because it doesn't really add any new information, right?

00:55:22.300 --> 00:55:26.580
So, only if a part of the line contains the error and not the whole line.

00:55:26.580 --> 00:55:31.540
So, this means that we are not going to, you know, consume a lot of vertical space for no reason.

00:55:31.540 --> 00:55:35.900
And the last thing I wanted to say is that, you know, there is some people somewhere in the universe

00:55:35.900 --> 00:55:43.220
that may care about that extra disk space on their PYC files, or they just really, really hate squiggles.

00:55:43.440 --> 00:55:48.780
I don't know if that is even physically possible, but, you know, there are very different and diverse set of people.

00:55:48.780 --> 00:55:50.200
You are one of those.

00:55:50.200 --> 00:55:54.160
There is a collection of different ways you can deactivate this feature.

00:55:54.160 --> 00:56:00.740
There is an environment variable with a super long name, and there is minus X option when you launch the interpreter.

00:56:00.740 --> 00:56:03.340
So, you can say Python minus X something, something.

00:56:03.340 --> 00:56:04.420
I don't know how it's called.

00:56:04.420 --> 00:56:06.700
I think it's called no the back ranges.

00:56:06.700 --> 00:56:07.740
What about that?

00:56:07.740 --> 00:56:09.200
What an incredible naming.

00:56:09.640 --> 00:56:13.920
And then you set no the back ranges to one, and it deactivates the feature.

00:56:13.920 --> 00:56:14.460
Incredible.

00:56:14.460 --> 00:56:15.220
Like magic.

00:56:15.220 --> 00:56:15.780
It's gone.

00:56:15.780 --> 00:56:21.560
And you can reclaim your PYC files, and you can even generate PYC files without this information

00:56:21.560 --> 00:56:25.800
if when you are compiling PYC files, you set this evil variable variable.

00:56:25.800 --> 00:56:27.300
But don't do that, listeners.

00:56:27.300 --> 00:56:27.900
Don't do that.

00:56:27.900 --> 00:56:28.400
It's evil.

00:56:28.400 --> 00:56:29.000
Don't do that.

00:56:29.000 --> 00:56:29.960
Just use it.

00:56:29.960 --> 00:56:30.600
It's great.

00:56:30.600 --> 00:56:30.840
Yeah.

00:56:30.840 --> 00:56:37.400
There's another kind of type of errors that I think we're going to get is about edge cases

00:56:37.400 --> 00:56:42.360
where the compiler doesn't get the line numbers right, because all these kind of fine-grained

00:56:42.360 --> 00:56:44.260
locations, it's all new.

00:56:44.260 --> 00:56:46.440
And, you know, we're still ironing out.

00:56:46.440 --> 00:56:47.380
The front future.

00:56:47.380 --> 00:56:51.580
There is a front future, I think, that you put like a bunch of things with the front future.

00:56:51.580 --> 00:56:53.120
It just complains on a random place.

00:56:53.120 --> 00:56:53.480
Yeah.

00:56:53.480 --> 00:56:55.460
Today I found that one.

00:56:55.600 --> 00:57:00.740
I've been looking at the compiler and line numbers, location information, and it's a

00:57:00.740 --> 00:57:01.580
bit off here and there.

00:57:01.580 --> 00:57:04.960
And we have received bug reports from other people as well.

00:57:04.960 --> 00:57:06.580
The range here doesn't look right.

00:57:06.580 --> 00:57:08.660
The range here looks too broad.

00:57:08.660 --> 00:57:13.620
So, yeah, we're going to be ironing that out, I guess, for 312s.

00:57:13.680 --> 00:57:16.960
Yeah, it's really nice when people are using betas and release candidates, though, because

00:57:16.960 --> 00:57:19.700
we were able to catch a lot of those before the release.

00:57:19.700 --> 00:57:23.920
Because there were a couple people, I forget exactly the name of the project, but they were

00:57:23.920 --> 00:57:27.380
working on like a code animation tool where it animates your code while it's running.

00:57:27.380 --> 00:57:31.100
And they were using these new ranges to identify AST nodes and stuff.

00:57:31.100 --> 00:57:34.960
And so they did this thing, I guess, where they like run their tool on the entire standard

00:57:34.960 --> 00:57:36.100
library, make sure it's correct.

00:57:36.200 --> 00:57:40.480
And so we got a bunch of bug reports that basically say, oh, you know, this column information

00:57:40.480 --> 00:57:43.240
is off for this weird multi-line attribute access or something.

00:57:43.240 --> 00:57:46.200
If you recall, I think you fixed an error.

00:57:46.200 --> 00:57:52.020
That was super weird because it was like a method access, like, you know, my instance of

00:57:52.020 --> 00:57:52.200
full.

00:57:52.200 --> 00:57:57.300
And if the method access has like some like vowel or something like that, it was wrong.

00:57:57.300 --> 00:58:00.180
And if you added some extra letter, it was fine.

00:58:00.180 --> 00:58:06.180
Yeah, it was like if you split your method access across two lines, if you do like x dot

00:58:06.180 --> 00:58:13.440
method or x dot method or x dot method on three lines or two lines or something, the way

00:58:13.440 --> 00:58:18.840
we trace those lines, we always trace the method when we're actually loading the method, even

00:58:18.840 --> 00:58:22.160
if it's on a different line, it's like where the actual method load started.

00:58:22.160 --> 00:58:25.980
And then we were doing some weird math to like figure out where the dot is.

00:58:25.980 --> 00:58:28.060
So we would try to put it on the same line as the dot.

00:58:28.060 --> 00:58:31.240
And so we just like subtract one from the length of the name.

00:58:31.240 --> 00:58:32.940
So there's all sorts of crazy stuff.

00:58:33.120 --> 00:58:35.660
And that came from the grave because we fixed that.

00:58:35.660 --> 00:58:39.800
And then it was wrong again because like we were like miscalculating the name.

00:58:39.800 --> 00:58:41.340
It's just so easy.

00:58:41.340 --> 00:58:42.620
Oh my goodness.

00:58:42.620 --> 00:58:42.920
Yeah.

00:58:42.920 --> 00:58:44.380
So all sorts of fun stuff like that.

00:58:44.380 --> 00:58:44.700
Yeah.

00:58:44.700 --> 00:58:45.400
Amazing.

00:58:45.400 --> 00:58:49.380
Well, yeah, this is definitely one of the highlight features for sure.

00:58:49.380 --> 00:58:51.260
And also the performance work that you're all doing.

00:58:51.260 --> 00:58:51.520
All right.

00:58:51.520 --> 00:58:53.460
We're getting very, very short on time.

00:58:53.460 --> 00:58:56.260
So I think maybe a super, super lightning round here.

00:58:56.260 --> 00:58:59.340
Let me just say we also got Tomolib support built in.

00:58:59.560 --> 00:59:03.620
We've got the asyncio task groups a la trio nurseries.

00:59:03.620 --> 00:59:09.620
We've got new features for atomic grouping and regular expressions, a self-type.

00:59:09.620 --> 00:59:11.600
A lot of type things have been added.

00:59:11.600 --> 00:59:16.980
So we've got the self-type, bariatric generics, literal strings, which is very interesting.

00:59:17.180 --> 00:59:20.680
Lukash did a talk about that on the release live stream.

00:59:20.680 --> 00:59:23.480
Stuff for type dict and data class transformations.

00:59:23.480 --> 00:59:24.900
So great stuff.

00:59:24.900 --> 00:59:27.900
Now let's just really quickly round out.

00:59:27.900 --> 00:59:31.860
What's the Python 3.11 story for PyScript, Pyodide?

00:59:31.860 --> 00:59:34.640
Is there, do you know, have anyone out there know?

00:59:34.640 --> 00:59:35.400
I don't know.

00:59:35.400 --> 00:59:36.300
I suppose it works.

00:59:36.420 --> 00:59:41.020
I think WebAssembly is now a tier two or tier three supported platform, right?

00:59:41.020 --> 00:59:45.500
So he has been making a lot of improvements to the build process, which, you know, is not easy.

00:59:45.500 --> 00:59:47.700
So kudos to Christian Himes.

00:59:47.700 --> 00:59:49.020
If you're listening, you're great.

00:59:49.020 --> 00:59:55.480
I suppose that PyScript can, through Pyodide, this is how many layers is this?

00:59:55.480 --> 01:00:02.120
So Pyodide through this can leverage all these improvements because I don't know how the whole

01:00:02.120 --> 01:00:07.220
layer that word thing is working, but Pyodide has a bunch of patches that, you know, you

01:00:07.220 --> 01:00:10.700
need to modify CPython so it builds nicely on WebAssembly platforms.

01:00:10.700 --> 01:00:12.080
I don't know the details on that.

01:00:12.080 --> 01:00:14.400
I just know that some of them are okayish.

01:00:14.400 --> 01:00:16.800
Some of them are not okay and quite difficult to maintain.

01:00:16.800 --> 01:00:22.000
And Christian Himes has been making a lot of great effort to, you know, change here and

01:00:22.000 --> 01:00:25.400
there and like put a lot of macros and if devs and things like that.

01:00:25.400 --> 01:00:27.840
So CPython kind of builds easier.

01:00:28.220 --> 01:00:34.580
This probably translates that Pyodide, I hope, kind of, you know, can consume this build in

01:00:34.580 --> 01:00:35.620
an easier way with less patches.

01:00:35.620 --> 01:00:41.140
And I suppose that translates into PyScript, like just using the Pyodide thing easier.

01:00:41.140 --> 01:00:46.880
But yeah, I don't think that there is a huge amount of improvements more than, you know,

01:00:46.880 --> 01:00:50.280
we are working towards official support as Brian was mentioning.

01:00:50.280 --> 01:00:52.060
We have this next year system.

01:00:52.060 --> 01:00:52.800
It's super cool.

01:00:52.800 --> 01:00:57.960
And as like an unrelated fun fact, Mike Drapu, one of the early developers of Pyodide,

01:00:57.960 --> 01:01:00.000
is actually managing our team at Microsoft.

01:01:00.000 --> 01:01:04.240
Oh, it's funny how the circle comes back around indeed.

01:01:04.240 --> 01:01:05.720
How the darn tables.

01:01:05.720 --> 01:01:07.860
That's right.

01:01:07.860 --> 01:01:08.920
All right.

01:01:08.920 --> 01:01:11.840
We are out of time, but super exciting.

01:01:11.840 --> 01:01:13.640
I wish we had some champagne.

01:01:13.640 --> 01:01:16.840
And Pablo, we didn't even bring hats to celebrate Python 3.11.

01:01:16.840 --> 01:01:19.200
But I know everyone out there is extremely excited.

01:01:19.200 --> 01:01:21.240
People cannot see it, but they have a Python 3.11.

01:01:21.240 --> 01:01:22.080
Yes.

01:01:22.080 --> 01:01:22.380
Yeah.

01:01:22.380 --> 01:01:25.100
It's a great new logo for 3.11 and stuff.

01:01:25.100 --> 01:01:27.040
Not for in general, but just for the release.

01:01:27.040 --> 01:01:27.560
It's awesome.

01:01:27.560 --> 01:01:28.060
All right.

01:01:28.060 --> 01:01:31.800
Before we get out of here, let me just ask you one final question and then we'll call it

01:01:31.800 --> 01:01:32.140
a show.

01:01:32.140 --> 01:01:33.720
Notable PyPI package.

01:01:33.720 --> 01:01:34.880
Something you want to give a shout out to.

01:01:34.880 --> 01:01:37.000
We'll go top to bottom in the picture here.

01:01:37.000 --> 01:01:37.360
Pablo?

01:01:37.360 --> 01:01:38.900
Notable PyPI package.

01:01:39.380 --> 01:01:42.800
And I'm going to say memory.

01:01:42.800 --> 01:01:43.740
Use memory.

01:01:43.740 --> 01:01:46.280
The one and only Python memory profiler.

01:01:46.280 --> 01:01:49.940
Solve your problems on production today with memory.

01:01:49.940 --> 01:01:52.140
That and the underlying errors, you'll be all good.

01:01:52.140 --> 01:01:52.520
Exactly.

01:01:52.520 --> 01:01:52.840
Yeah.

01:01:52.840 --> 01:01:53.440
A combination.

01:01:53.440 --> 01:01:56.300
Arit, how are you?

01:01:56.300 --> 01:02:00.560
Well, I've had some interaction with the author of bytecode, Ration King, because I was

01:02:00.560 --> 01:02:05.240
looking at things to do in the testing and in the interpreter that are kind of like that.

01:02:05.240 --> 01:02:10.740
So this is a library you can kind of from Python write bytecode and it's pretty neat.

01:02:10.740 --> 01:02:15.280
And it's struggling with zero cost exceptions, but that's what it is.

01:02:15.280 --> 01:02:17.720
It's like inline assembly, but for Python.

01:02:17.720 --> 01:02:18.840
Yeah.

01:02:18.840 --> 01:02:23.660
It's like from a Python script, you can kind of write a bit of bytecode and get it to,

01:02:23.660 --> 01:02:26.260
I don't know, do a lot of interesting stuff.

01:02:26.260 --> 01:02:26.780
That's awesome.

01:02:26.780 --> 01:02:27.740
Brent, how about you?

01:02:27.740 --> 01:02:31.600
Well, I'm partial towards specialist, but if I had to choose something else, speaking

01:02:31.600 --> 01:02:34.820
of speed, I really like the scaling profiler.

01:02:34.820 --> 01:02:38.060
I've been using it a lot of my own projects and it's awesome.

01:02:38.060 --> 01:02:40.460
I don't know how it's memory profiling compares to memory.

01:02:40.460 --> 01:02:46.280
I'm sure memory is better, but scaling is really nice for measuring the performance across

01:02:46.280 --> 01:02:47.940
both Python and C code, which is cool.

01:02:47.940 --> 01:02:48.280
Excellent.

01:02:48.280 --> 01:02:48.900
Mark?

01:02:48.900 --> 01:02:50.680
Well, it's not actually a PyPI package.

01:02:50.680 --> 01:02:55.040
I was going to say the sys module, which is pretty much the most fundamental module going.

01:02:55.040 --> 01:02:55.280
Come on.

01:02:55.280 --> 01:02:57.880
There's all sorts of fun things in there.

01:02:57.880 --> 01:02:59.900
You can change the recursion limit and C.

01:02:59.900 --> 01:03:00.880
You can muddle it.

01:03:00.880 --> 01:03:04.580
If you're interested in how Python works, it's actually quite a sort of fun thing to play with.

01:03:04.580 --> 01:03:06.900
Thank you all for all the hard work.

01:03:06.900 --> 01:03:11.080
And I know there are many people who did a ton of work as well who are not on the show here,

01:03:11.080 --> 01:03:12.620
but you can represent them as well.

01:03:12.620 --> 01:03:14.220
So thanks all for being here.

01:03:14.220 --> 01:03:15.440
Final call to action.

01:03:15.440 --> 01:03:16.680
People want to get started at 3.11.

01:03:16.680 --> 01:03:17.760
What do you tell them?

01:03:17.760 --> 01:03:19.740
Is it ready for them to get going?

01:03:19.740 --> 01:03:20.540
What do you think?

01:03:20.540 --> 01:03:21.160
It's awesome.

01:03:21.160 --> 01:03:21.820
It's awesome.

01:03:21.820 --> 01:03:31.260
And also now 3.11 comes with a bunch of wheels for all your packages because there has been a lot of good work in the people of third-party libraries.

01:03:31.260 --> 01:03:43.500
And now that people are using CI build wheel, 3.11 was released with wheels for NumPy and Pandas and a bunch of other things that previously was failing massively because nobody could compile them on their crappy laptop.

01:03:43.500 --> 01:03:44.740
But now you don't need that.

01:03:44.740 --> 01:03:46.460
You can just download them and it works.

01:03:46.460 --> 01:03:47.480
So just use 3.11.

01:03:47.480 --> 01:03:48.320
There is no reason.

01:03:48.320 --> 01:03:49.240
Yeah, that's excellent.

01:03:49.240 --> 01:03:49.700
It's just boring.

01:03:49.700 --> 01:03:50.560
That would be a reason.

01:03:50.680 --> 01:03:53.460
If you're boring and you don't want to use 3.11, then don't use it.

01:03:53.460 --> 01:03:54.440
You didn't break anything.

01:03:54.440 --> 01:03:56.680
Not even a package, much less GitHub.

01:03:56.680 --> 01:03:57.580
Right.

01:03:57.580 --> 01:03:59.760
And we need more benchmarks.

01:03:59.760 --> 01:04:01.300
Well, that's true.

01:04:01.300 --> 01:04:02.240
Yeah, absolutely.

01:04:02.240 --> 01:04:04.360
That's how people can help us make things faster.

01:04:04.360 --> 01:04:05.100
There's more benchmarks.

01:04:05.100 --> 01:04:11.520
So, yeah, we have a, there's a sort of standard Python performance suite, but it's kind of a bunch of toy programs and so on.

01:04:11.520 --> 01:04:19.680
So if you've got something that might make a nice sort of benchmark, you know, sort of self-contained but sort of realistic program, then, yeah, let us know.

01:04:19.880 --> 01:04:20.020
All right.

01:04:20.020 --> 01:04:20.400
Cool.

01:04:20.400 --> 01:04:21.240
Well, thanks again.

01:04:21.240 --> 01:04:22.060
Great work on it.

01:04:22.060 --> 01:04:24.920
Cam Gearlock out in the audience says, yay, CI Buildwheel.

01:04:24.920 --> 01:04:25.860
Yeah, absolutely.

01:04:25.860 --> 01:04:26.600
Great stuff.

01:04:26.600 --> 01:04:28.220
So thanks again, everyone.

01:04:28.220 --> 01:04:31.060
I'm super excited to start using 3.11 myself.

01:04:31.060 --> 01:04:32.920
Thank you, Michael, for inviting us.

01:04:32.920 --> 01:04:34.040
Yeah, it's great to have you here.

01:04:34.040 --> 01:04:34.400
Thank you.

01:04:34.500 --> 01:04:35.120
Bye, all.

01:04:35.940 --> 01:04:38.860
This has been another episode of Talk Python To Me.

01:04:38.860 --> 01:04:40.660
Thank you to our sponsors.

01:04:40.660 --> 01:04:42.280
Be sure to check out what they're offering.

01:04:42.280 --> 01:04:43.700
It really helps support the show.

01:04:43.700 --> 01:04:45.860
Take some stress out of your life.

01:04:45.860 --> 01:04:51.640
Get notified immediately about errors and performance issues in your web or mobile applications with Sentry.

01:04:52.100 --> 01:04:56.640
Just visit talkpython.fm/sentry and get started for free.

01:04:56.640 --> 01:05:00.220
And be sure to use the promo code talkpython, all one word.

01:05:00.220 --> 01:05:05.940
Command Line Heroes is an original podcast from Red Hat that chronicles the history of the software industry.

01:05:06.200 --> 01:05:14.060
From the origins of the first high-level programming languages to Python's tale, each episode is a fascinating look back at how we got to where we are.

01:05:14.060 --> 01:05:17.720
Listen to an episode at talkpython.fm/heroes.

01:05:17.720 --> 01:05:19.340
Want to level up your Python?

01:05:19.340 --> 01:05:23.400
We have one of the largest catalogs of Python video courses over at Talk Python.

01:05:23.400 --> 01:05:28.560
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:05:28.560 --> 01:05:31.240
And best of all, there's not a subscription in sight.

01:05:31.240 --> 01:05:34.140
Check it out for yourself at training.talkpython.fm.

01:05:34.280 --> 01:05:38.820
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

01:05:38.820 --> 01:05:40.120
We should be right at the top.

01:05:40.120 --> 01:05:49.480
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

01:05:49.480 --> 01:05:52.920
We're live streaming most of our recordings these days.

01:05:52.920 --> 01:06:00.700
If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:06:00.700 --> 01:06:02.600
This is your host, Michael Kennedy.

01:06:02.600 --> 01:06:03.900
Thanks so much for listening.

01:06:03.900 --> 01:06:05.060
I really appreciate it.

01:06:05.060 --> 01:06:06.980
Now get out there and write some Python code.

01:06:06.980 --> 01:06:27.600
See you soon.

01:06:27.600 --> 01:06:57.580
Thank you.

