WEBVTT

00:00:00.001 --> 00:00:03.720
If you're a .NET developer or work in a place that has some of those folks,

00:00:03.720 --> 00:00:09.220
wouldn't it be great to fully leverage the entirety of PyPI with its almost 600,000 packages

00:00:09.220 --> 00:00:16.060
inside your .NET code? But how would you do this? Previous efforts have let you write Python syntax,

00:00:16.060 --> 00:00:22.040
but using the full libraries, especially the C and Rust-based ones, has been out of reach

00:00:22.040 --> 00:00:27.960
until Seasnakes. This project by Anthony Shaw and Aaron Powell unlocks some pretty serious

00:00:27.960 --> 00:00:33.000
integration between the two languages. And we have them both on the show today to tell us all about it.

00:00:33.000 --> 00:00:38.780
This is Talk Python to Me, episode 486, recorded Monday, November 4th, 2024.

00:00:38.780 --> 00:00:41.720
Are you ready for your host? Here he is.

00:00:41.720 --> 00:00:46.840
You're listening to Michael Kennedy on Talk Python to Me. Live from Portland, Oregon,

00:00:46.840 --> 00:00:48.840
and this segment was made with Python.

00:00:48.840 --> 00:00:57.160
Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:57.160 --> 00:01:02.400
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using at Talk Python,

00:01:02.400 --> 00:01:08.460
both accounts over at fosstodon.org. And keep up with the show and listen to over nine years of

00:01:08.460 --> 00:01:14.200
episodes at talkpython.fm. If you want to be part of our live episodes, you can find the live streams

00:01:14.200 --> 00:01:19.980
over on YouTube. Subscribe to our YouTube channel over at talkpython.fm/youtube and get notified

00:01:19.980 --> 00:01:26.220
about upcoming shows. This episode is sponsored by Posit Connect from the makers of Shiny. Publish,

00:01:26.220 --> 00:01:31.360
share and deploy all of your data projects that you're creating using Python. Streamlit, Dash,

00:01:31.360 --> 00:01:38.880
Shiny, Bokeh, FastAPI, Flask, Quarto, Reports, Dashboards, and APIs. Posit Connect supports all of

00:01:38.880 --> 00:01:44.660
them. Try Posit Connect for free by going to talkpython.fm/Posit, P-O-S-I-T.

00:01:45.160 --> 00:01:50.940
And this episode is brought to you by Bluehost. Do you need a website fast? Get Bluehost. Their AI

00:01:50.940 --> 00:01:56.460
builds your WordPress site in minutes, and their built-in tools optimize your growth. Don't wait.

00:01:56.460 --> 00:02:02.700
Visit talkpython.fm/bluehost to get started. Hey, everyone. Before we jump into the conversation,

00:02:02.700 --> 00:02:09.200
I want to talk about infrastructure. Actually, there are a couple of interesting things going on over here

00:02:09.200 --> 00:02:16.020
at Talk Python. And I've written them up on our new Talk Python blog, which I will link to both of these

00:02:16.020 --> 00:02:24.360
articles in the show notes. First, we moved our web hosting over to a brand new hosting center in the

00:02:24.360 --> 00:02:30.120
U.S. run by a German company called Hetzner. And it's super interesting. I wrote this all up. And I

00:02:30.120 --> 00:02:34.220
think people who are considering, like, where should we run our apps? Or if they're unhappy where they are,

00:02:34.320 --> 00:02:42.280
it's worth thinking about. And I just rewrote all of talkpython.fm's code, about 10,000 lines of Python,

00:02:42.280 --> 00:02:50.260
to move to an async web framework. Which one was it? Well, that was part of the journey. And so I did a

00:02:50.260 --> 00:02:57.900
big long write-up on migrating from Pyramid to Quart, which is async Flask, all the other frameworks I

00:02:57.900 --> 00:03:03.380
considered doing that, how I went through the migration, and how it's working. So if either of these two sound

00:03:03.380 --> 00:03:09.040
interesting to you, check out the links to the articles in the show notes. As always, thank you

00:03:09.040 --> 00:03:15.940
so much for listening. Let's jump in the conversation. Hello, Anthony. Hello, Aaron. Welcome to Talk Python.

00:03:15.940 --> 00:03:21.240
Hi, Michael. Hi, thanks for having us. It's great to have you here. Anthony, always, always good to have

00:03:21.240 --> 00:03:27.820
you back on the show. You're one of the most popular guests, and we'll see where it lands, where this puts

00:03:27.820 --> 00:03:33.100
you in the list. But you're right near the top of the guest page out of all of them. I love having you

00:03:33.100 --> 00:03:38.560
on the show. Thank you. And Aaron, welcome. It's great to have you here. So even though you've been

00:03:38.560 --> 00:03:42.760
on a bunch of times, Anthony, maybe a real quick introduction, just who you are for those who have

00:03:42.760 --> 00:03:49.260
not met you yet. Yeah, I'm Anthony Shaw. I work at Microsoft. I'm the lead Python advocate. And I do a

00:03:49.260 --> 00:03:55.220
bunch of open source projects. And I wrote a book called CPython Internals, which is how most people

00:03:55.220 --> 00:04:00.600
know me these days. That's me. Yeah. So we're going to talk about more CPython Internals or maybe putting

00:04:00.600 --> 00:04:06.320
Python inside of .NET. I don't know. It's something's going into the internals of the something else. We'll figure

00:04:06.320 --> 00:04:10.900
out which way that goes. It's a very cool project. Hello, Aaron. Tell people a bit about yourself.

00:04:10.900 --> 00:04:16.840
Sure. Well, I'm definitely the odd one out here. I am someone who is pretty much never written Python in my life.

00:04:17.260 --> 00:04:21.800
Millie, I now know a bit more about it, having worked on this project with Anthony. But I'm a .NET developer

00:04:21.800 --> 00:04:29.080
by trade. I've been doing that for longer than I'll admit on a recorded audio. At least 10 years. Okay, got it.

00:04:29.080 --> 00:04:34.800
Yes, we'll go with at least 10 years. I'm setting a lower bound for us. That's a good one.

00:04:34.800 --> 00:04:43.260
I also work at Microsoft. I mean, a team adjacent to Anthony's doing advocacy around .NET. And yeah, but otherwise, I also write

00:04:43.260 --> 00:04:49.060
JavaScript. So I do everything I can to avoid having to get into the Python space in my time.

00:04:49.060 --> 00:05:03.320
And yet here you are. And here I am. Yes. Amazing. Yeah. So it's a different world, right? Coming from .NET, that's guaranteed static typing, a lot of semicolons, a lot of ceremony around the types. And then Python kind of says, hold on now.

00:05:03.320 --> 00:05:15.680
And white space. Python loves its white space. But then again, I have a very soft spot for F sharp. So I'm not like, I kind of get the white space significance aspect of a Python language. But at the same time, I do miss McCurley brackets.

00:05:15.680 --> 00:05:27.520
Yeah. The trick is, if you use a good editor, you don't really notice it. If you don't, it's pretty bad. So use a good editor. I mean, that's all there is to it. Anthony, what have you been up to? What's new in your world?

00:05:27.520 --> 00:05:32.800
I've been up to this project for a few months now.

00:05:32.800 --> 00:05:34.540
Is this primarily what you're focused on?

00:05:34.540 --> 00:05:46.500
It was for a few months. Yeah. I'm trying to get ready for we've got a massive conference, one of our two big conferences of the year coming up in a couple of weeks. I'm working hard on demos to try and get ready for that. But is that .NET Conf? What is that?

00:05:46.500 --> 00:05:49.160
No, this is for Ignite. It's the partner conference.

00:05:49.160 --> 00:05:51.320
Oh, yeah, yeah. Ignite is so big.

00:05:51.320 --> 00:05:53.160
It's like 15,000 people or something.

00:05:53.160 --> 00:05:57.400
Yes, exactly. I went to a pre pandemic. I think it was 30,000 people.

00:05:57.540 --> 00:06:13.320
Yeah, it was in Florida. And there was a whole podcast row. So Microsoft had me out as one of 10 podcasts or something. I thought, Oh, what is this? I hardly ever heard of this. I've heard of build and some others. And I show up like, this is something else. Where'd all these people come from? It's a big conference. It's crazy.

00:06:13.320 --> 00:06:25.980
Yeah, I'm getting ready for that at the moment. But yeah, I've been working on this project for a few months. And we kind of kicked it off in May. Idea kind of floated around in May at the build conference, which is Microsoft's developer conference.

00:06:25.980 --> 00:06:38.240
After talking to a lot of different developers and people in Microsoft, we were kind of kicking around the idea of if we looked at this again, so like running Python code from .NET, like how would you approach it?

00:06:38.240 --> 00:06:51.620
I kind of had some ideas, put some ideas together and then started working with Aaron on a really early prototype just to see like if it was even possible. And then we kind of got something working, chucked it in the bin, pretty much started again.

00:06:51.620 --> 00:06:56.820
And then redesigned it. And then yeah, we've been sort of fiddling with it ever since.

00:06:56.820 --> 00:07:15.060
From my perspective, I said before, I'm not a Python person. But as someone in the .NET ecosystem, looking at the breadth of libraries that exist for Python, there's a lot of things that I would have loved to have used, particularly doing some of the AI stuff that we've been doing in projects recently.

00:07:15.060 --> 00:07:30.340
And then finally, there's just not as many packages or options in the .NET space. So it's always been that like, "Ah, okay, well, if I want to learn this, the tutorial is in Python or the package it recommends using is in Python." So it was always kind of like, how do we bridge that gap?

00:07:30.340 --> 00:07:43.540
That was kind of one of the early thinkings of just, you know, that's a clear problem space, right? Like a lot of people are learning that, but then going into industry and maybe Python isn't the language that the organization they're working with is using.

00:07:43.540 --> 00:07:48.820
How do we still have that? A fundamental knowledge that they've gained or the like the tooling they want to use available to them?

00:07:48.820 --> 00:08:07.540
Well, just think about me. I'm sure you have thought about how much of an explosion in possibility it is if you can say, and by the way, there's almost 600,000 other libraries, including the biggest community of AI based resources that are now, as far as you're concerned, native to .NET, right?

00:08:07.540 --> 00:08:11.540
Yeah. But from the way you consume it, not the way it runs is what I mean.

00:08:11.540 --> 00:08:24.540
Exactly. Yeah. Like you mentioned there, nearly 600,000 Python packages and you add that to, there's like 400,000 packages on NuGet for .NET. Like you got quite literally a million possibilities.

00:08:24.540 --> 00:08:32.540
Yeah, it's amazing. And just for people listening, primarily Python audience, NuGet is .NET's equivalent of our PyPI.

00:08:32.540 --> 00:08:33.540
Yeah.

00:08:33.540 --> 00:08:39.540
Yep. Yep. Yep. Okay. So Anthony, you had this idea. Somebody said, "Hey, how would you go about doing this?" And then you were sucked in?

00:08:39.540 --> 00:08:52.540
Yeah. It was actually one of the sort of lead designers on .NET asked me at Build. They said, "Oh, we've been looking at how you might integrate Python into .NET for a while. Like if you were to approach it, how would you do it?"

00:08:52.540 --> 00:08:53.540
Mm-hmm.

00:08:53.540 --> 00:09:05.540
And I kind of went through all the projects that have tried this in the past or there are different ways of doing it and pros and cons of each and kind of the pros and cons of a really low level integration and a high level one.

00:09:05.540 --> 00:09:12.540
So like a high level one would be stick a FastAPI on top of your Python app and just call it via HTTP REST.

00:09:12.540 --> 00:09:17.540
And somehow auto-generate some REST endpoints and then make those do their thing.

00:09:17.540 --> 00:09:23.540
Yeah. And you could use it like an open API spec on top of it and auto-generate a client and stuff like that.

00:09:23.540 --> 00:09:33.540
So that's like the high level option. And then like the lowest level option is like, you know, you could get into the bytecode level, which I've explored years ago with Pigeon.

00:09:33.540 --> 00:09:36.540
And yeah, that's a very deep, dark tunnel.

00:09:36.540 --> 00:09:41.540
It's full of terrible edge cases and corners and sharp edges, huh?

00:09:41.540 --> 00:09:47.540
And one of the challenges there is that the like Python's implementation is changing so rapidly right now.

00:09:47.540 --> 00:09:56.540
Like, but just in Python 3.13 and looking at 3.14 now and like all the changes and stuff in there, like it's just continuously changing.

00:09:56.540 --> 00:10:01.540
So it needs to be a happy medium in terms of how we blend the two together.

00:10:01.540 --> 00:10:05.540
Right. There has to be some level of disconnectedness a little bit, right?

00:10:05.540 --> 00:10:10.540
So that Python can do it, have its changes without constantly chasing it, right?

00:10:10.540 --> 00:10:11.540
Yeah, exactly.

00:10:11.540 --> 00:10:18.540
So yeah, kind of what we kind of came up with was we would do the integration at the C level using Python C API.

00:10:18.540 --> 00:10:23.540
There's a way of consuming Python through sort of like an embedded mode.

00:10:23.540 --> 00:10:26.540
Not many projects do this, but it is definitely possible.

00:10:26.540 --> 00:10:32.540
So you can spin up a Python interpreter inside another process, which in our case is a net process.

00:10:32.540 --> 00:10:34.540
Yeah. And I think Blender does that.

00:10:34.540 --> 00:10:41.540
I'm pretty sure that there's a bunch in the film and movie industry that do that for their automation pipelines.

00:10:41.540 --> 00:10:43.540
I don't think it's that great.

00:10:43.540 --> 00:10:56.540
One, I talked to some of the people from the movie and video space, and they, most of them are still running on Python 2 because when they wrote the implementation to integrate the thing, integrate CPython, they're like, well, it's done.

00:10:56.540 --> 00:11:00.540
And like you kind of said, Python moved on and they're like, well, that's a lot of work.

00:11:00.540 --> 00:11:03.540
And then we got to, we'll just leave it on Python 2.

00:11:03.540 --> 00:11:04.540
And that's not, that's not great.

00:11:04.540 --> 00:11:05.540
Yeah, exactly.

00:11:05.540 --> 00:11:09.540
So we looked at this and said, we want to be, we want to support the newest version of Python.

00:11:09.540 --> 00:11:18.540
We want to support the sort of practically old version, which I think you settled around 3.8 was like as old as I was willing to go.

00:11:18.540 --> 00:11:24.540
And I think we maybe push that forward to 3.9 because there were some specific features we need on the .NET side.

00:11:24.540 --> 00:11:26.540
Again, there's a lot of changes happening in .NET.

00:11:26.540 --> 00:11:32.540
Oh, Sharon, maybe you can share a bit more, but like, you know, there's .NET is going through just as many changes.

00:11:32.540 --> 00:11:38.540
So we've got like two moving, constantly moving platforms and we want to make an integration between the two of them.

00:11:38.540 --> 00:11:45.540
So let's think about like, how can we do this in a way which is actually maintainable and we can make it, you know, we can test it and we can make it stable as well.

00:11:45.540 --> 00:11:46.540
Yeah.

00:11:46.540 --> 00:11:55.540
One thing maybe you could speak to as part of this, people might know .NET as this Windows programming library that you use Visual Studio with.

00:11:55.540 --> 00:11:56.540
Right.

00:11:56.540 --> 00:11:58.540
But it's, it's changed a lot since then.

00:11:58.540 --> 00:12:00.540
There's .NET Core, there's open source.

00:12:00.540 --> 00:12:01.540
It runs on Linux.

00:12:01.540 --> 00:12:04.540
There's, there's a lot of different things that have been changed about it.

00:12:04.540 --> 00:12:04.540
Right.

00:12:04.540 --> 00:12:05.540
Yeah.

00:12:05.540 --> 00:12:11.540
And it's a fairly common misconception that we've got is that, that people equate .NET with Windows and like historically that's, that's true.

00:12:11.540 --> 00:12:14.540
Like that's, that's where I got started is developing on Windows.

00:12:14.540 --> 00:12:17.540
And I, I'll be honest, I'm still a Windows developer.

00:12:17.540 --> 00:12:20.540
It's what my primary OS has been.

00:12:20.540 --> 00:12:26.540
I've, I've flirted with macOS and Linux over the years, but Windows is just where I'm more comfortable with.

00:12:26.540 --> 00:12:35.540
But I think it's been a bit over a decade now since the, they essentially relaunched .NET was originally called .NET Core.

00:12:35.540 --> 00:12:38.540
So, so now we kind of have these two streams concurrently.

00:12:38.540 --> 00:12:43.540
You've got .NET framework, which is the one that is what we traditionally thought of as .NET.

00:12:43.540 --> 00:12:46.540
It, it ships kind of like with Windows and stuff like that.

00:12:46.540 --> 00:12:53.540
So it's, it's very much designed around that longer tail support lifecycle and, and, and whatnot.

00:12:53.540 --> 00:13:03.540
It is fairly stable, but also getting minimalistic investment just because it has that kind of need to be stable and consistent year in year out.

00:13:03.540 --> 00:13:08.540
Then we have .NET Core, or now we just kind of refer to it as .NET.

00:13:08.540 --> 00:13:10.540
Just naming things is hard.

00:13:10.540 --> 00:13:11.540
Let's, let's be honest.

00:13:11.540 --> 00:13:20.540
But so we, we have .NET and every year a new release comes out and this is like a, like a major framework, like a major revision to the runtime.

00:13:20.540 --> 00:13:25.540
So .NET 9 is actually coming out next week, at least at the time of recording, it's next week.

00:13:25.540 --> 00:13:29.540
And this is considered a, like a short term support lifecycle.

00:13:29.540 --> 00:13:34.540
So if you're familiar with support lifecycle of a lot of runtimes out there now.

00:13:34.540 --> 00:13:37.540
So like Node popularized this quite a lot now.

00:13:37.540 --> 00:13:45.540
And Python is starting to adopt it a bit more that kind of you have this yearly rolling lifecycle and, and you'll have long-term supports and short-term support.

00:13:45.540 --> 00:13:47.540
So the long-term is every even number.

00:13:47.540 --> 00:13:51.540
So .NET 8 being the most recent long-term support.

00:13:51.540 --> 00:13:56.540
.NET 6 was the previous one, which is actually going out of support next week at the time of recording.

00:13:56.540 --> 00:13:59.540
Yeah, being realistic of where people are and developing their applications.

00:13:59.540 --> 00:14:08.540
Where we couldn't just target Python 3.13 and .NET 9 as the only supported versions, because be honest, that's not where most packages are.

00:14:08.540 --> 00:14:10.540
That's not where most projects are going to be.

00:14:10.540 --> 00:14:12.540
So we have to make, you know, some, some calls there.

00:14:12.540 --> 00:14:13.540
Yeah.

00:14:13.540 --> 00:14:16.540
You do have to have a little bit of, a little bit of slack in there.

00:14:16.540 --> 00:14:25.540
Even for me and some of my web apps and stuff, I had to wait a few weeks to upgrade to 3.13 because some dependency of a dependency had something that had been removed.

00:14:25.540 --> 00:14:28.540
You know, been deprecated for a while and was removed and it didn't work.

00:14:28.540 --> 00:14:30.540
Like, well, try that again in a few weeks and see how it works.

00:14:30.540 --> 00:14:34.540
And eventually they, they caught up, but yeah, it's definitely a challenge.

00:14:34.540 --> 00:14:44.540
This portion of Talk Python to Me is brought to you by Posit, the makers of Shiny, formerly RStudio and especially Shiny for Python.

00:14:44.540 --> 00:14:46.540
Let me ask you a question.

00:14:46.540 --> 00:14:47.540
Are you building awesome things?

00:14:47.540 --> 00:14:48.540
Of course you are.

00:14:48.540 --> 00:14:50.540
You're a developer or data scientist.

00:14:50.540 --> 00:14:51.540
That's what we do.

00:14:51.540 --> 00:14:53.540
And you should check out Posit Connect.

00:14:53.540 --> 00:15:00.540
Posit Connect is a way for you to publish, share and deploy all the data products that you're building using Python.

00:15:00.540 --> 00:15:03.540
People ask me the same question all the time.

00:15:03.540 --> 00:15:07.540
Michael, I have some cool data science project or notebook that I built.

00:15:07.540 --> 00:15:10.540
How do I share it with my users, stakeholders, teammates?

00:15:10.540 --> 00:15:15.540
Do I need to learn FastAPI or Flask or maybe Vue or ReactJS?

00:15:15.540 --> 00:15:16.540
Hold on now.

00:15:16.540 --> 00:15:21.540
Those are cool technologies and I'm sure you'd benefit from them, but maybe stay focused on the data project.

00:15:21.540 --> 00:15:23.540
Let Posit Connect handle that side of things.

00:15:23.540 --> 00:15:28.540
With Posit Connect you can rapidly and securely deploy the things you build in Python.

00:15:28.540 --> 00:15:35.540
Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto, Ports, Dashboards and APIs.

00:15:35.540 --> 00:15:37.540
Posit Connect supports all of them.

00:15:37.540 --> 00:15:43.540
And Posit Connect comes with all the bells and whistles to satisfy IT and other enterprise requirements.

00:15:43.540 --> 00:15:47.540
Make deployment the easiest step in your workflow with Posit Connect.

00:15:47.540 --> 00:15:53.540
For a limited time, you can try Posit Connect for free for three months by going to talkpython.fm/posit.

00:15:53.540 --> 00:15:56.540
That's talkpython.fm/posit.

00:15:56.540 --> 00:15:59.540
The link is in your podcast player show notes.

00:15:59.540 --> 00:16:02.540
Thank you to the team at Posit for supporting Talk Python.

00:16:02.540 --> 00:16:08.540
Anthony, when we opened this, you mentioned there had been other attempts, other ways.

00:16:08.540 --> 00:16:11.540
The one that comes to mind for me is IronPython.

00:16:11.540 --> 00:16:15.540
IronPython is a CLR implementation of Python.

00:16:15.540 --> 00:16:23.540
And that's a pretty big difference right there than what you're trying to maybe contrast it with some of the things that people have done previously.

00:16:23.540 --> 00:16:30.540
Yeah, so probably three projects, I think, that have been done previously that kind of sit in the same space, but they have different goals.

00:16:30.540 --> 00:16:38.540
So, I mean, the main goal for our project is that there are loads of .NET developers that have existing applications.

00:16:38.540 --> 00:16:42.540
They are typically quite, it like sits in the enterprise space, a lot of it.

00:16:42.540 --> 00:16:44.540
So they're like quite big, big applications.

00:16:44.540 --> 00:16:49.540
They've got teams working on them and there's a technology in Python that they want to use.

00:16:49.540 --> 00:16:59.540
And that technology is often a package or a library or an example, especially in like data science now, and a lot of the ML and AI libraries that are floating around.

00:16:59.540 --> 00:17:09.540
So a lot of the idea for this and the demand from developers was from, you know, we want to use these libraries or we want to use this particular package in Python.

00:17:09.540 --> 00:17:12.540
And like, how do we import that into our .NET application?

00:17:12.540 --> 00:17:18.540
So like, that's kind of the angle that we've come at this from, which is like, how can we make the best of both worlds?

00:17:18.540 --> 00:17:23.540
Like you've got a big, you're like a fast, mature enterprise application in .NET.

00:17:23.540 --> 00:17:26.540
And it is like a piece of technology that's in Python that you want to use.

00:17:26.540 --> 00:17:30.540
Iron Python is an implementation of Python written in .NET.

00:17:30.540 --> 00:17:33.540
And that was done quite a while ago, I think.

00:17:33.540 --> 00:17:37.540
And yeah, like older versions of .NET, older versions of Python.

00:17:37.540 --> 00:17:41.540
And it's kind of similar to Jython as well.

00:17:41.540 --> 00:17:44.540
Like I think I put it in the same bucket as Jython, which is...

00:17:44.540 --> 00:17:45.540
I would as well. Yeah.

00:17:45.540 --> 00:17:52.540
It would like, and at that time, a lot of people were making different implementations of Python, the language in other frameworks.

00:17:52.540 --> 00:17:58.540
And so, yes, you can write Python syntax and run it in the CLR, but you couldn't do something like import NumPy.

00:17:58.540 --> 00:18:05.540
And that's the difference is that most packages in the ecosystem these days are designed and tested for CPython.

00:18:05.540 --> 00:18:09.540
And this is all, at least they're tested for PyPy.

00:18:09.540 --> 00:18:12.540
But all the other implementations are pretty much a no.

00:18:12.540 --> 00:18:17.540
Like Pandas, NumPy, scikit-learn, like all the data science ML tools.

00:18:17.540 --> 00:18:20.540
Especially the C interop type of stuff.

00:18:20.540 --> 00:18:21.540
Yeah.

00:18:21.540 --> 00:18:24.540
And I've sort of written about this in the past, how, you know, Python's...

00:18:24.540 --> 00:18:31.540
But one of the solutions to Python's performance problem is that you implement extension modules in C, which is a great solution.

00:18:31.540 --> 00:18:34.540
Or you use Cython, which is the same kind of thing, which is a great solution.

00:18:34.540 --> 00:18:39.540
It just means that the ecosystem is more and more tied to CPython as the interpreter of choice.

00:18:39.540 --> 00:18:42.540
So what I didn't want to do is write a whole new interpreter.

00:18:42.540 --> 00:18:47.540
Like that goes back to the compatibility problem and the maintainability issue.

00:18:47.540 --> 00:18:53.540
Like by the time we published it, it would be out of date and we'd just be opening up stuff up for a whole load of work.

00:18:53.540 --> 00:18:58.540
It's not even about, it's not even a matter whether you can do it and you can keep up with the language.

00:18:58.540 --> 00:19:02.540
As we talked about, you know, as Aaron mentioned, there's a million libraries you can use.

00:19:02.540 --> 00:19:04.540
But if you did this, you wouldn't be able to.

00:19:04.540 --> 00:19:06.540
Yeah, I'm Python is one.

00:19:06.540 --> 00:19:08.540
Pigeon, we've covered in a past episode.

00:19:08.540 --> 00:19:09.540
Oh, that's not going to work.

00:19:09.540 --> 00:19:12.540
Is a P-Y-G...

00:19:12.540 --> 00:19:13.540
There we go.

00:19:13.540 --> 00:19:14.540
Is a weird spelling.

00:19:14.540 --> 00:19:16.540
P-Y-J-I-O-N.

00:19:16.540 --> 00:19:17.540
No, that's right.

00:19:17.540 --> 00:19:18.540
I remember now.

00:19:18.540 --> 00:19:19.540
P-Y-J-I-O-N.

00:19:19.540 --> 00:19:31.540
This is a JIT for CPython that happens to use the .NET Core JIT engine because that was one of the most pluggable JITs at the time.

00:19:31.540 --> 00:19:32.540
There are other JITs available.

00:19:32.540 --> 00:19:34.540
It could have been written in ASM JIT.

00:19:34.540 --> 00:19:37.540
It could have been written in LLVM JIT.

00:19:37.540 --> 00:19:39.540
Dino who actually worked on Iron Python.

00:19:39.540 --> 00:19:41.540
So like he knows this space really well.

00:19:41.540 --> 00:19:43.540
Brett Cannon worked on Pigeon originally.

00:19:43.540 --> 00:19:46.540
And then I rewrote it like a few years later.

00:19:46.540 --> 00:19:48.540
That's a different problem.

00:19:48.540 --> 00:19:51.540
That doesn't help you integrate .NET and Python together.

00:19:51.540 --> 00:19:55.540
It just happens to use components from .NET to implement a JIT.

00:19:55.540 --> 00:19:57.540
That project is effectively dead.

00:19:57.540 --> 00:20:03.540
Some of the benefits of it have been rolled into CPython in versions 3.10 and 3.11.

00:20:03.540 --> 00:20:05.540
The things that made it faster.

00:20:05.540 --> 00:20:07.540
Most of those were sort of picked up anyway.

00:20:07.540 --> 00:20:13.540
And then the third one is Python.NET, which is probably the closest to the project that we've started.

00:20:13.540 --> 00:20:16.540
This one has been around for a while.

00:20:16.540 --> 00:20:17.540
This one's been around for a while.

00:20:17.540 --> 00:20:21.540
It's a similar thing, but they mostly focus on the integration the other way around.

00:20:21.540 --> 00:20:26.540
So like how do you call .NET libraries and things from Python?

00:20:26.540 --> 00:20:27.540
You can call Python.

00:20:27.540 --> 00:20:28.540
Oh, right.

00:20:28.540 --> 00:20:29.540
Yeah.

00:20:29.540 --> 00:20:31.540
A lot of the focus is actually the other way around.

00:20:31.540 --> 00:20:37.540
So if there was a popular .NET library that you wanted to use in your Python app, you might Python.NET your way to that.

00:20:37.540 --> 00:20:39.540
And this project has been around for a while.

00:20:39.540 --> 00:20:41.540
So the API is pretty stable.

00:20:41.540 --> 00:20:50.540
And we originally looked at this one actually as a potential solution, but found a number of things that they'd kind of tied themselves to in the design, which are going to go away in .NET 9.

00:20:50.540 --> 00:20:54.540
So it wasn't really an option for us.

00:20:54.540 --> 00:20:58.540
And also like a lot of the way the C API was used was different to how we wanted to do it.

00:20:58.540 --> 00:21:01.540
So yeah, that's kind of the alternatives.

00:21:01.540 --> 00:21:05.540
And so you ended up writing your own because just none of these really match, right?

00:21:05.540 --> 00:21:12.540
The Iron Python was just never going to keep up and it didn't have this package support for data science mostly.

00:21:12.540 --> 00:21:14.540
And then the other one was the other way around.

00:21:14.540 --> 00:21:21.540
And yeah, so well, I guess a good thing to think about is, well, why did you think you could do that?

00:21:21.540 --> 00:21:24.540
Like a lot of people, a lot of smart people put a lot of time into this.

00:21:24.540 --> 00:21:27.540
Why did you think, oh, this is going to be, this is going to work well.

00:21:27.540 --> 00:21:29.540
Do you have a fresh take on it or what were you thinking?

00:21:29.540 --> 00:21:37.540
I really wanted to use some of the modern benefits of both Python and .NET to do this, to design it.

00:21:37.540 --> 00:21:44.540
And one of the biggest changes in actually, as we've been implementing this, we're learning 80% of the challenges are related to typing.

00:21:44.540 --> 00:21:48.540
And Aaron's smiling because he's agreeing with me.

00:21:48.540 --> 00:21:56.540
Like integrating two different ecosystems together like this is about calling functions, methods, whatever.

00:21:56.540 --> 00:21:59.540
But calling things is about calling them with arguments really.

00:21:59.540 --> 00:22:05.540
And it's passing data backwards and forwards, marshaling information and getting things backwards and forwards between different types.

00:22:05.540 --> 00:22:16.540
Like that's if you integrated, I don't know, some function that you wrote in Python into .NET, you're going to be calling it with something like you're going to be sending it some data and expecting some data back.

00:22:16.540 --> 00:22:18.540
Now in Python, there are types.

00:22:18.540 --> 00:22:21.540
It is dynamically typed, but the types do exist.

00:22:21.540 --> 00:22:28.540
Even if you don't put it in your function signature, there's still instant strings and stuff being sent all over the place behind the scenes.

00:22:28.540 --> 00:22:29.540
Yeah, exactly.

00:22:29.540 --> 00:22:39.540
And when we looked at Python.NET, like, you know, you could call a function in from .NET in Python, but you'd have to write a load of code that said like, oh, I think this parameter is probably this type.

00:22:39.540 --> 00:22:44.540
So convert that to this and then when it comes back, then it's probably this one to try that one first.

00:22:44.540 --> 00:22:50.540
And so we sort of said, like, now typing type annotations are more popular in Python.

00:22:50.540 --> 00:22:59.540
What we wanted to do was basically you give it some Python code and you write like a function, which is the one that you want to call and you annotate the function.

00:22:59.540 --> 00:23:05.540
So you say it takes, you know, has these arguments and they are these types and it returns back this type.

00:23:05.540 --> 00:23:15.540
And then what we did is wrote a code generators called a source generator for .NET that would in in your project, it would look at the Python file that you wanted to embed.

00:23:15.540 --> 00:23:19.540
It would see what functions are defined, what their signatures are and what types they take.

00:23:19.540 --> 00:23:24.540
And then it would generate a function that can call that for you with .NET equivalence.

00:23:24.540 --> 00:23:32.540
And then it handles the the marshalling, like the transfer of the types backwards and forwards between .NET and Python.

00:23:32.540 --> 00:23:36.540
And like that's most of the project is really about that particular problem.

00:23:36.540 --> 00:23:37.540
Okay.

00:23:37.540 --> 00:23:42.540
So it's leveraging the C API of Python kind of talk directly to the runtime.

00:23:42.540 --> 00:23:48.540
You can write a function in Python, you know, that takes a string, a list and a tuple and returns back a dictionary.

00:23:48.540 --> 00:23:50.540
Like it's a fairly common thing to do.

00:23:50.540 --> 00:23:51.540
Yeah.

00:23:51.540 --> 00:24:07.540
You would give it type annotations in Python and you drop that Python file into your .NET project and you run build again and you would see a type in .NET with the same name, with a function that is the one you just defined and with arguments which are .NET equivalents to that.

00:24:07.540 --> 00:24:09.540
And you just call the function and it just runs in Python.

00:24:09.540 --> 00:24:12.540
How complicated can this data exchange be?

00:24:12.540 --> 00:24:17.540
Can I come up with my own types and exchange them or do they have to be six or seven core types?

00:24:17.540 --> 00:24:21.540
I think the data exchange is actually one of the really tricky bits, right?

00:24:21.540 --> 00:24:23.540
Here's a list of a million items.

00:24:23.540 --> 00:24:34.540
Why don't you copy them all over to a .NET type, run it or copy it over to a Python list, run the thing and then copy the back to a .NET list with one more item in it or something crazy like that, right?

00:24:34.540 --> 00:24:41.540
Yeah. If you jump to the documentation and then in the reference page, there's a list of the ones that we support at the moment.

00:24:41.540 --> 00:24:42.540
Oh, yeah.

00:24:42.540 --> 00:24:44.540
Then there's a list of the core ones that we support.

00:24:44.540 --> 00:24:46.540
And then anything beyond that.

00:24:46.540 --> 00:24:48.540
So we do generics, for example.

00:24:48.540 --> 00:24:54.540
So if you say it's a list of strings, we will give you back a read only list of string in .NET.

00:24:54.540 --> 00:24:59.540
If it's a dictionary and you type the key and the value, we will give you back a .NET key and value.

00:24:59.540 --> 00:25:06.540
Now in Python, often it could be an any or it could be a union or it could be something complicated.

00:25:06.540 --> 00:25:10.540
So you've got the option to say it could be a dynamically defined type.

00:25:10.540 --> 00:25:12.540
It does still support it.

00:25:12.540 --> 00:25:16.540
And then at runtime, you can look at the type to see what it is and then convert it into something that you need.

00:25:16.540 --> 00:25:19.540
I see a lot of read only on the .NET side.

00:25:19.540 --> 00:25:22.540
And this is the thing receiving the data from Python.

00:25:22.540 --> 00:25:29.540
I'm glad that you picked up on that because that was something that I made a decision when we're doing the .NET service area for this of it.

00:25:29.540 --> 00:25:47.540
So that's the thing that I think that anytime we're receiving data back or when we're sending data to is it should be represented as read only just to indicate that if you're calling a function that's been exposed from Python from .NET and it's returning a collection like a dictionary or a list or anything like that.

00:25:47.540 --> 00:25:48.540
So that's the thing that you're going to do.

00:26:08.540 --> 00:26:13.540
So that's the thing that you're going to do is you're going to do that.

00:26:13.540 --> 00:26:14.540
And then you're going to do that.

00:26:31.540 --> 00:26:39.540
That you're very familiar for .NET developers for doing like creating an array from an existing collection of data.

00:26:39.540 --> 00:26:59.540
And then that becomes obviously a more mutable data structure or like a list, like the read-only list, for example, that then plugs straight into links so that you can do the query syntax or the expression methods syntax to perform operations on those collections of data inside of .NET space.

00:26:59.540 --> 00:27:02.540
Kind of once it's being hydrated back out of Python.

00:27:02.540 --> 00:27:05.540
So I guess you get a lot of these read-only innumerable type of things.

00:27:05.540 --> 00:27:07.540
You could do link on them, L-I-N-Q.

00:27:07.540 --> 00:27:08.540
Yeah.

00:27:08.540 --> 00:27:09.540
I wish we had this in Python.

00:27:09.540 --> 00:27:12.540
I know we have something kind of like it with list compreemptions, but it's not the same.

00:27:12.540 --> 00:27:21.540
One thing that I really wanted to make sure that we were tackling with this and to Anthony's point before of the, that you've got two very different type systems that you're working with.

00:27:21.540 --> 00:27:27.540
And structurally, the way that you write code in Python is going to look different to the way that you write in .NET.

00:27:27.540 --> 00:27:37.540
So we didn't want to feel like the code gen that we do for you is that we've just made this, it's just .NET casing of Python code.

00:27:37.540 --> 00:27:41.540
So I wanted to feel like as a .NET developer, I'm working against a .NET interface.

00:27:41.540 --> 00:27:55.540
So when you work with the types and the modules that you expose out to .NET and we do code gen against, we then generate you a class behind the scenes that is then, we then generate an interface for you.

00:27:55.540 --> 00:28:00.540
And then that's registered into the dependency injection container.

00:28:00.540 --> 00:28:03.540
So you then can just resolve that elsewhere with inside of your application.

00:28:03.540 --> 00:28:12.540
So now as a .NET developer, I'm getting an interface injected into a class that I'm using elsewhere with inside of my code base.

00:28:12.540 --> 00:28:24.540
I haven't had to go, okay, well, no, I'm calling some kind of like an import or I'm doing some kind of resolve or something that might be unfamiliar to me as a .NET developer.

00:28:24.540 --> 00:28:31.540
This is what I'm doing is just, it just feels like I'm writing, or I shouldn't say necessarily .NET developer, I'm running C#.

00:28:31.540 --> 00:28:33.540
And we've optimized this for C#.

00:28:33.540 --> 00:28:39.540
I said earlier on, I have soft swap for F# and it kind of works in F#.

00:28:39.540 --> 00:28:47.540
And then similarly, if you're a .NET developer, we optimize this to the kind of development experience you would expect when you're writing C# code.

00:28:47.540 --> 00:28:52.540
We just so happen to have, you, you haven't written this, some of this C# code.

00:28:52.540 --> 00:28:57.540
We've just automatically generated it for you and injected it into a dependency injection container.

00:28:57.540 --> 00:28:58.540
Amazing.

00:28:58.540 --> 00:29:03.540
So when we're talking about exchanging this data, this is CPython in the same process.

00:29:03.540 --> 00:29:04.540
Is that right, Anthony?

00:29:04.540 --> 00:29:04.540
Yeah.

00:29:04.540 --> 00:29:05.540
How's that work?

00:29:05.540 --> 00:29:12.540
Python's C API, normally if you call, so CPython is the interpreter that you would use to run your Python code.

00:29:12.540 --> 00:29:15.540
It is implemented in C mostly.

00:29:15.540 --> 00:29:19.540
The standard library modules are written, some of them are in Python, some of them are in C.

00:29:19.540 --> 00:29:22.540
You can write modules for Python in C.

00:29:22.540 --> 00:29:28.540
And the way that you would do things like create numbers and dictionaries and lists is you use this API.

00:29:28.540 --> 00:29:29.540
It's a C API.

00:29:29.540 --> 00:29:34.540
And part of that C API is the ability to spin up a Python in C.

00:29:34.540 --> 00:29:38.540
You can spin up a Python interpreter inside another process.

00:29:38.540 --> 00:29:40.540
And that's embedded Python.

00:29:40.540 --> 00:29:42.540
There's different APIs for doing it.

00:29:42.540 --> 00:29:44.540
There's a lot of different ways of approaching it.

00:29:44.540 --> 00:29:53.540
But really what we do is that when you spin up .NET and you use CSnakes, you inject a Python interpreter into the environment.

00:29:53.540 --> 00:29:55.540
It's not like a separate process.

00:29:55.540 --> 00:29:59.540
Like it's not, it hasn't got like a ship command line windows running in the background.

00:29:59.540 --> 00:30:01.540
It's embedded into the process.

00:30:01.540 --> 00:30:02.540
It's like loading the library.

00:30:02.540 --> 00:30:04.540
It's running inside the process.

00:30:04.540 --> 00:30:07.540
And then we have full control over everything in CPython.

00:30:07.540 --> 00:30:10.540
So we can then import modules.

00:30:10.540 --> 00:30:14.540
We can convert things, types backwards and forwards.

00:30:14.540 --> 00:30:20.540
So we're kind of doing a lot of the work that often gets done either in a C extension module or inside the interpreter.

00:30:20.540 --> 00:30:27.540
So if we want to create a Python number, for example, like an integer from a .NET integer, we do that at the C level.

00:30:27.540 --> 00:30:30.540
So we can do that like a really high performance API.

00:30:30.540 --> 00:30:36.540
If we want to look at the size of dictionaries or the types and stuff like that, we do that at the C level.

00:30:36.540 --> 00:30:38.540
So again, it's super high performance.

00:30:38.540 --> 00:30:43.540
And then really importantly, well, the typing stuff is really important.

00:30:43.540 --> 00:30:52.540
The other major challenge with this is, you know, .NET freely uses threading and thread pools and coroutines and stuff like that.

00:30:52.540 --> 00:30:55.540
Python can use threading, but there is a lock.

00:30:55.540 --> 00:30:58.540
So you have to be really, really careful.

00:30:58.540 --> 00:31:05.540
And this is something I don't didn't see like a novel solution from the other projects that are looking in this kind of space about how they would tackle it.

00:31:05.540 --> 00:31:10.540
Or it was kind of based around like older styles of Python and things have changed so much recently.

00:31:10.540 --> 00:31:19.540
So we kind of wanted to make sure that you could run this in a multi threaded environment, whether that's like a UI, for example, like a desktop interface or it's a web app.

00:31:19.540 --> 00:31:27.540
So like one of our demos is like a .NET web app, like API, that each request can run a Python function if it wants to.

00:31:27.540 --> 00:31:30.540
And they're all running in separate threads in a thread pool in .NET.

00:31:30.540 --> 00:31:32.540
And you shouldn't have to worry about the gill.

00:31:32.540 --> 00:31:36.540
Like you shouldn't have to know too much in terms of what it is and how it works.

00:31:36.540 --> 00:31:41.540
So we've done quite a lot of work to make sure that that can happen.

00:31:41.540 --> 00:31:45.540
This portion of Talk Python to Me is brought to you by Bluehost.

00:31:45.540 --> 00:31:48.540
Got ideas, but no idea how to build a website?

00:31:48.540 --> 00:31:49.540
Get Bluehost.

00:31:49.540 --> 00:31:56.540
With their AI design tool, you can quickly generate a high quality, fast loading WordPress site instantly.

00:31:56.540 --> 00:31:59.540
Once you've nailed the look, just hit enter and your site goes live.

00:31:59.540 --> 00:32:00.540
It's really that simple.

00:32:00.540 --> 00:32:05.540
And it doesn't matter whether you're a hobbyist, entrepreneur or just starting your side hustle.

00:32:05.540 --> 00:32:12.540
Bluehost has you covered with built-in marketing and e-commerce tools to help you grow and scale your website for the long haul.

00:32:12.540 --> 00:32:22.540
Since you're listening to my show, you probably know Python, but sometimes it's better to focus on what you're creating rather than a custom built website and add another month till you launch your idea.

00:32:22.540 --> 00:32:31.540
When you upgrade to Bluehost cloud, you get 100% uptime and 24/7 support to ensure your site stays online through heavy traffic.

00:32:31.540 --> 00:32:34.540
Bluehost really makes building your dream website easier than ever.

00:32:34.540 --> 00:32:35.540
So what's stopping you?

00:32:35.540 --> 00:32:36.540
You've already got the vision.

00:32:36.540 --> 00:32:37.540
Make it real.

00:32:37.540 --> 00:32:41.540
Visit talkpython.fm/bluehost right now and get started today.

00:32:41.540 --> 00:32:45.540
And thank you to Bluehost for supporting the show.

00:32:45.540 --> 00:32:47.540
Python has async and await.

00:32:47.540 --> 00:32:49.540
C# has async and await.

00:32:49.540 --> 00:32:51.540
They're similar, but not the same.

00:32:51.540 --> 00:32:52.540
Yeah.

00:32:52.540 --> 00:32:57.540
Can I have an async function in Python that is called by C#?

00:32:57.540 --> 00:32:58.540
No, not yet.

00:32:58.540 --> 00:33:03.540
Just a task.run, async.io.run to completion sort of thing.

00:33:03.540 --> 00:33:04.540
And then keep going.

00:33:04.540 --> 00:33:04.540
Yeah.

00:33:04.540 --> 00:33:17.540
I would love to do this, but there is no API for it on the Python side to manage event loops and embed an event loop into another process or to write a custom event loop.

00:33:17.540 --> 00:33:22.540
It's all kind of built into the standard library or was put into another module.

00:33:22.540 --> 00:33:26.540
There's been a couple of proposals in draft peps, but none of them have been accepted.

00:33:26.540 --> 00:33:31.540
And if they were, then it might be in 3.14 anyway, which we can't backward compatible support.

00:33:31.540 --> 00:33:33.540
Yeah, you're not quite there time wise yet.

00:33:33.540 --> 00:33:37.540
Do you find that async.io event loops and Python are hard to juggle?

00:33:37.540 --> 00:33:38.540
Right?

00:33:38.540 --> 00:33:42.540
Like you have to create one if it doesn't exist, but if it does exist, then it doesn't want you to create a new one.

00:33:42.540 --> 00:33:44.540
But there's not a great way to see if it exists.

00:33:44.540 --> 00:33:52.540
And if you don't have direct access to it, how do you get like, it's just, it always feels to me a little bit out of touch to fully take control over that and work with it.

00:33:52.540 --> 00:33:54.540
And it changes between Python versions.

00:33:54.540 --> 00:33:57.540
Like it gets, it's gotten easier recently.

00:33:57.540 --> 00:34:00.540
Like there's a, there's like a dot run function now.

00:34:00.540 --> 00:34:04.540
And whereas previously you have to like get the event loop and create one and stuff like that.

00:34:04.540 --> 00:34:06.540
But now you can just kind of run the coroutine.

00:34:06.540 --> 00:34:07.540
It's still tricky.

00:34:07.540 --> 00:34:18.540
And the idea of basically writing a custom event loop and then giving it coroutine objects and like polling them and looping them from another runtime.

00:34:18.540 --> 00:34:20.540
I just couldn't figure out the API.

00:34:20.540 --> 00:34:21.540
I'd love to do it.

00:34:21.540 --> 00:34:23.540
If anyone knows, then please ping me.

00:34:23.540 --> 00:34:26.540
Well, UV loop does it.

00:34:26.540 --> 00:34:27.540
Yeah.

00:34:27.540 --> 00:34:30.540
Somehow, but maybe they just swap out some pieces of it.

00:34:30.540 --> 00:34:31.540
Not all of it.

00:34:31.540 --> 00:34:34.540
Yeah. I'm not sure how, but you can set the event loop from UV loop.

00:34:34.540 --> 00:34:37.540
So maybe, I don't know, maybe there's a breadcrumb there to chase.

00:34:37.540 --> 00:34:38.540
All right.

00:34:38.540 --> 00:34:46.540
So I see in the steps, install Python, put your projects in a C# file, use annotations on your Python functions, right?

00:34:46.540 --> 00:34:48.540
That's a really important step that you talked about.

00:34:48.540 --> 00:34:51.540
Install the Csnakes runtime package.

00:34:51.540 --> 00:34:55.540
So maybe from this point on, let's talk a little bit about some of the steps.

00:34:55.540 --> 00:34:59.540
So this Csnakes runtime, this is a NuGet package that you put into your .NET project.

00:34:59.540 --> 00:35:01.540
Is that what I'm reading here?

00:35:01.540 --> 00:35:02.540
Yeah.

00:35:02.540 --> 00:35:05.540
So we essentially have two binaries that we ship.

00:35:05.540 --> 00:35:08.540
One, which is going to do all the code generation for you.

00:35:08.540 --> 00:35:25.540
So from a .NET perspective, you'd be, it wouldn't be uncommon to have multiple different projects with inside of your solution, which is then like one might just be a bunch of services, which are then going to then talk to a database or whatever the case may be.

00:35:25.540 --> 00:35:31.540
So you might have that as just a, like, that would be where you would have the code gen that you want to do.

00:35:31.540 --> 00:35:35.540
So where the Python files are actually getting their C# interop generated for you.

00:35:35.540 --> 00:35:37.540
So you have one project with that.

00:35:37.540 --> 00:35:44.540
And then we have a second binary, which is then the runtime to actually like make that work when your application is running.

00:35:44.540 --> 00:35:55.540
Now we do ship this as a single consolidated package just for ease of use, but that's kind of why we differentiate some of it in terms of like code gen versus runtime because they're different concepts.

00:35:55.540 --> 00:35:58.540
And one is a compilation step versus obviously runtime step.

00:35:58.540 --> 00:35:59.540
Yeah. Okay.

00:35:59.540 --> 00:36:03.540
With our runtime package and the documentation talks a little bit more about this.

00:36:03.540 --> 00:36:09.540
There's just a few steps you've got to do to make sure that the C# compiler is capable of finding the Python files.

00:36:09.540 --> 00:36:16.540
So we actually do stuff with inside of the C# compiler pipeline to generate code that is then added to it.

00:36:16.540 --> 00:36:22.540
So this also means that we can very early on find out if you're going to have compatibility issues.

00:36:22.540 --> 00:36:36.540
So if something is type of the type that we don't understand or the Python code is syntactically obscure, because what I've learned is that there are ways that you can write valid Python code that is very obscure.

00:36:36.540 --> 00:36:41.540
And they showed me some, yes, some things that you can do, but please don't do it.

00:36:41.540 --> 00:36:45.540
And yeah, so you'll actually fail a compilation step rather than fail runtime process.

00:36:45.540 --> 00:37:05.540
And I think like, again, from a from a .NET developers perspective, like you were used to that static typing that compilation step that that belief that the compiler has done a whole bunch of checks for us to give us code that should just work rather than just like that more dynamic or typing system that you get out of Python or like in my experience, like the JavaScript side of things.

00:37:05.540 --> 00:37:06.540
Yeah, that's definitely the expectation.

00:37:06.540 --> 00:37:13.540
the expectation if you're doing C#, C++, if it compiles, at least it's clicked together in a coherent way.

00:37:13.540 --> 00:37:17.540
Right. Whereas, whereas Python, we're pretty sure we don't know for sure, but we're pretty sure.

00:37:17.540 --> 00:37:20.540
So in Python typing, you can lie.

00:37:20.540 --> 00:37:26.540
Right. I could say it takes a list of integers and really what it took was strings, which had numbers as characters.

00:37:26.540 --> 00:37:27.540
Who knows? Right.

00:37:27.540 --> 00:37:30.540
What happens if I lie to the C# code gen thing?

00:37:30.540 --> 00:37:31.540
So it just crashes.

00:37:31.540 --> 00:37:32.540
Don't do it.

00:37:32.540 --> 00:37:33.540
Yeah.

00:37:34.540 --> 00:37:40.540
It does actually just crash when it calls because it has to make the assumption that what you've told it is correct.

00:37:40.540 --> 00:37:47.540
So in .NET, if I've got a tuple of ints and I give it across and it's like, I actually wanted strings.

00:37:47.540 --> 00:37:48.540
No, it's not going to have it.

00:37:48.540 --> 00:38:01.540
It will raise a, yeah, because to get, for example, if it returns a list of strings, but you actually return a list of integers, you know, in order to give you back a list of strings in C#, we first check that it's a list.

00:38:01.540 --> 00:38:09.540
And if it isn't, or if it's not a sequence type, like it could be a, you could have inherited from this to major and custom list, or you could make something which is a sequence.

00:38:09.540 --> 00:38:12.540
Like if it's not that, then we will raise an exception.

00:38:12.540 --> 00:38:13.540
It doesn't just crash.

00:38:13.540 --> 00:38:14.540
I was joking.

00:38:14.540 --> 00:38:23.540
And we've got a lot of testing to make sure there's a whole, like a test environment that's around like lying code and type hints and stuff, which are completely invalid.

00:38:23.540 --> 00:38:26.540
And then for the strings, you know, we need to look at the Python string.

00:38:26.540 --> 00:38:34.540
And then because Python mostly uses UTF-8 and .NET mostly uses UTF-16, you know, we need to convert from one to the other.

00:38:34.540 --> 00:38:38.540
And if it's, and if it's an integer, not a string in the first place, then that's never going to work.

00:38:38.540 --> 00:38:42.540
So we would raise an exception there and say, you taught us it was a string and you lied.

00:38:42.540 --> 00:38:43.540
But you lied exception is thrown.

00:38:43.540 --> 00:38:44.540
Yeah.

00:38:44.540 --> 00:38:47.540
I think it's like a cast, invalid cast exception or something like that.

00:38:47.540 --> 00:38:48.540
Yeah.

00:38:48.540 --> 00:38:49.540
With the description.

00:38:49.540 --> 00:38:57.540
We've tried to raise like the exceptions we raise are .NET exceptions, which are relevant to the concept of the problem that we've covered.

00:38:57.540 --> 00:39:02.540
But at the same time, it actually will give you, imagine if something failed in the Python code as well.

00:39:02.540 --> 00:39:09.540
Like you type annotated that it was like a bunch of strings and we, and I know a bunch of ints and we, we gave you a bunch of strings.

00:39:09.540 --> 00:39:10.540
Well, okay.

00:39:10.540 --> 00:39:12.540
The Python code is going to fail there.

00:39:12.540 --> 00:39:19.540
So where we then surface out the Python exceptions as well as like embedded with inside of the .NET exception.

00:39:19.540 --> 00:39:26.540
So you can, you can actually get down to like the, the lines of code with inside of Python that failed, which I think is kind of.

00:39:26.540 --> 00:39:31.540
The stack trace actually includes C#, C#, C#, Python, Python, Python, potentially.

00:39:31.540 --> 00:39:32.540
Yeah.

00:39:32.540 --> 00:39:33.540
That's pretty awesome.

00:39:33.540 --> 00:39:38.540
In Python, if you didn't raise from it, that will show up as an inner exception in .NET as well.

00:39:38.540 --> 00:39:43.540
So we did a lot of work on exceptions, mostly because we had to like debug this stuff when we're developing it.

00:39:43.540 --> 00:39:45.540
And it was pretty amazing.

00:39:45.540 --> 00:39:48.540
We saw the pain that someone else was going to feel.

00:39:48.540 --> 00:39:52.540
So yeah, you see the, you can see the stack trace, you get like all the frame variables and stuff like that.

00:39:52.540 --> 00:39:57.540
So things that you would probably want from like a PDB, you can see on the .NET side.

00:39:57.540 --> 00:40:06.540
So if you're running the debugger in .NET and it crashes in Python, like it or raises an exception or something, you see the Python exception with all the details.

00:40:06.540 --> 00:40:13.540
And then you see like inner exceptions and stuff like that as well, as well as the locals and the globals and any other frame information.

00:40:13.540 --> 00:40:21.540
Yeah, I was pretty impressed when I saw that, that how integrated, how much I felt from both directions, kind of natural and not just bolted on.

00:40:21.540 --> 00:40:22.540
Yeah.

00:40:22.540 --> 00:40:25.540
Another step is mark these for code for source generation.

00:40:25.540 --> 00:40:32.540
This feels like a Visual Studio 20, whatever year the last release of Visual Studio was.

00:40:32.540 --> 00:40:33.540
Aaron, where are we?

00:40:33.540 --> 00:40:34.540
What's the number?

00:40:34.540 --> 00:40:35.540
22.

00:40:35.540 --> 00:40:36.540
Okay.

00:40:36.540 --> 00:40:41.540
So the reason I bring this up is a lot of people hear Visual Studio, especially in the Python space and think Visual Studio code.

00:40:41.540 --> 00:40:45.540
Does this work in Visual Studio code or is it just a other Visual Studio?

00:40:45.540 --> 00:40:47.540
No, it definitely works in VS Code.

00:40:47.540 --> 00:40:49.540
They sometimes open it in VS Code.

00:40:49.540 --> 00:40:54.540
And obviously you'd likely just installed the C# extension to get a better developer experience on that.

00:40:54.540 --> 00:41:04.540
But what we have to do is because the source generator is actually running as they step with inside of the C# compiler pipeline, we need it to know how to find these files.

00:41:04.540 --> 00:41:08.540
And we kind of toyed with the idea of just to like, just do a directory scan.

00:41:08.540 --> 00:41:10.540
Everything that ends in .py, we're going after.

00:41:10.540 --> 00:41:12.540
That's not particularly efficient.

00:41:12.540 --> 00:41:22.540
And also like if you've just got like modules that are using other modules, like you want to, what's, how do you craft a surface error in Python that you actually want to expose rather than just expose everything?

00:41:22.540 --> 00:41:26.540
So we're inside of the csproj file.

00:41:26.540 --> 00:41:33.540
So this is the file that is the instructions on how to compile a more complex .NET application.

00:41:33.540 --> 00:41:39.540
We can then add nodes to that XML structure to say, like, here's a Python file.

00:41:39.540 --> 00:41:47.540
It's an annotate that for the C# compiler to pick up so that when the source generator hits it, it hits our steps.

00:41:47.540 --> 00:41:52.540
It goes, okay, I'm going to find all of these additional files that you've said I need to be aware of.

00:41:52.540 --> 00:42:01.540
And then I can read them in and it's actually got some optimizations for how like internally it will read that file in rather than us then having to do file IO or anything like that.

00:42:01.540 --> 00:42:14.540
So it just, it's more in physically aware of them and that it will make those available so that it can then generate out the code rather than, rather than like I said, us having to try and guess what Python files you want available.

00:42:14.540 --> 00:42:21.540
Like, you know, they have to be in a special folder or they had to be named a certain way or we just directory scan everything that ended with .py.

00:42:21.540 --> 00:42:31.540
Yeah. You want to be really careful about which ones you're trying to do this to because they require type annotation and you don't want to just expose all the guts of some bit of code.

00:42:31.540 --> 00:42:33.540
You want to maybe talk about the surface area, right?

00:42:33.540 --> 00:42:38.540
As .NET people, you have these protected private internal, protected internal, et cetera, things.

00:42:38.540 --> 00:42:40.540
We don't talk about them in Python.

00:42:40.540 --> 00:42:41.540
I want to be consistent with that, right?

00:42:41.540 --> 00:42:47.540
So Anthony, it says last step to instantiate the Python environment.

00:42:47.540 --> 00:42:50.540
This is, it feels almost like a, an import statement.

00:42:50.540 --> 00:42:53.540
Then you use it namespace style later.

00:42:53.540 --> 00:42:54.540
Do you want to talk about that real quick?

00:42:54.540 --> 00:43:00.540
In order to start like into embed Python into the .NET process, you need to create a Python environment.

00:43:00.540 --> 00:43:03.540
And there's a few things we have to know, like where is Python installed?

00:43:03.540 --> 00:43:04.540
What version is it?

00:43:04.540 --> 00:43:06.540
Do you have a virtual environment?

00:43:06.540 --> 00:43:08.540
Is it just like the global environment?

00:43:08.540 --> 00:43:10.540
Do you have like packages?

00:43:10.540 --> 00:43:16.540
There's like additional things that we need to know that you would have in Python, you would have kind of set those elsewhere.

00:43:16.540 --> 00:43:19.540
Like if there was a virtual environment, you would have activated it.

00:43:19.540 --> 00:43:24.540
You know, if you were running Python, then you would have set which version it was and where it's installed.

00:43:24.540 --> 00:43:28.540
So you've in .NET, you haven't done those steps.

00:43:28.540 --> 00:43:34.540
So we need you to tell us like which version of Python do you want to, do you want to create and where is it?

00:43:34.540 --> 00:43:37.540
And we've created a whole bunch of code to help you find it.

00:43:37.540 --> 00:43:44.540
The UV team actually have been solving a similar problem with like spitting up Python and running Python.

00:43:44.540 --> 00:43:47.540
So I'm kind of curious to see like how they've tackled it.

00:43:47.540 --> 00:43:52.540
And we might even try and look at bringing UV in as one of the mechanisms for finding Python for you.

00:43:52.540 --> 00:43:53.540
Because it's such a complicated.

00:43:53.540 --> 00:43:54.540
Yeah.

00:43:54.540 --> 00:43:59.540
It's something I wanted to talk to you about is you've got to have Python installed and you've got to get the dependencies.

00:43:59.540 --> 00:44:02.540
And yeah, we're not going to install Python for you.

00:44:02.540 --> 00:44:02.540
Yeah.

00:44:02.540 --> 00:44:06.540
But with UV, V and V, give it a Python version.

00:44:06.540 --> 00:44:07.540
It can fetch it.

00:44:07.540 --> 00:44:09.540
It can fetch it and just run it and it's cached.

00:44:09.540 --> 00:44:12.540
And maybe you could embed that as a resource at compile time.

00:44:12.540 --> 00:44:15.540
There's interesting possibilities there.

00:44:15.540 --> 00:44:20.540
Virtual environment support uses either condor or pip as the package manager, depending on what you want.

00:44:20.540 --> 00:44:25.540
And you can say, here's my requirements file, and it will go in and pip install them as well.

00:44:25.540 --> 00:44:34.540
Like it can do all of those things for you because we're kind of assuming that, yeah, you've developing this locally and you're running it locally, but it's going to be deployed somewhere else.

00:44:34.540 --> 00:44:41.540
So you don't want to have to like log into the production servers and like create virtual environments on the command line and stuff like that.

00:44:41.540 --> 00:44:45.540
That's like with hopefully 15, 20 years past people doing that.

00:44:45.540 --> 00:44:54.540
Like, so you should be able to programmatically say this project needs a virtual environment and it needs these packages installed and needs this version of Python.

00:44:54.540 --> 00:45:03.540
And then you can either use the version of Python that comes with your Linux container, for example, or you can pull in one from somewhere else.

00:45:03.540 --> 00:45:06.540
For Windows, you can actually download it from NuGet.

00:45:06.540 --> 00:45:09.540
It's like you can actually add it as a dependency in .NET.

00:45:09.540 --> 00:45:12.540
And that's a really simple solution for Windows development for macOS.

00:45:12.540 --> 00:45:22.540
If you've installed it from Python.org, like using the official installer, you just you just tell it that you just say, use like the macOS Python and give it the version number.

00:45:22.540 --> 00:45:27.540
And then for Linux, it's a lot more complicated because there's no standards.

00:45:27.540 --> 00:45:31.540
So, yeah, we've kind of support every which way of finding it on Linux.

00:45:31.540 --> 00:45:36.540
And then once you've kind of put the Python environment into the process, there should only be one of them.

00:45:36.540 --> 00:45:43.540
Python itself does not want you to ever spin up more than one Python environment in the same like operating process.

00:45:43.540 --> 00:45:45.540
It will have all sorts of problems if you if you do that.

00:45:45.540 --> 00:45:52.540
So it's basically put in as a singleton and then you import a module by creating an instance of it.

00:45:52.540 --> 00:45:57.540
And then on that module, you can then call methods which are the functions in the module.

00:45:57.540 --> 00:46:08.540
So like if you had a module called demo.py, then in your environment, you'd see like a factory for like effectively like import demo and giving back an instance of it.

00:46:08.540 --> 00:46:12.540
And then on that instance, you'd have methods which are the functions.

00:46:12.540 --> 00:46:19.540
And the example you've got on your screen, you know, there's a function called hello world that takes some arguments in a in a file called demo.py.

00:46:19.540 --> 00:46:22.540
So you just say environment.demo, like make a demo instance.

00:46:22.540 --> 00:46:28.540
And then on that instance, you can call dot hello world with the arguments and it gives you back the results.

00:46:28.540 --> 00:46:35.540
So there's no really like in a few lines of code, like four or five, you can spin up a Python environment, import a module run a function.

00:46:35.540 --> 00:46:41.540
So we'd really try to minimize the border plate code by and then following the patterns that are best for both platforms.

00:46:41.540 --> 00:46:44.540
So a lot of places you could go with this is really cool.

00:46:44.540 --> 00:46:47.540
For example, if you if you got a singleton, which is great.

00:46:47.540 --> 00:46:49.540
And that's kind of how Python typically is one environment.

00:46:49.540 --> 00:46:54.540
But with the sub interpreters, you could theoretically create these in parallel.

00:46:54.540 --> 00:47:03.540
But one thing that stands out as maybe a little non expected in this is like you have var module equals env a demo, right where you're creating this.

00:47:03.540 --> 00:47:06.540
But in Python, this thing is called demo.

00:47:06.540 --> 00:47:11.540
Would it be a pattern to maybe name the variable the same as the module name?

00:47:11.540 --> 00:47:14.540
That's probably just more from laziness in the way we've written our docs.

00:47:14.540 --> 00:47:15.540
Yeah.

00:47:15.540 --> 00:47:33.540
But what we're probably lacking from because this is obviously docs and just markdown code is that so when you were so we would get back our IPython environment from our dependency injection container and then things like the demo methods exposed there would then return an i demo.

00:47:33.540 --> 00:47:40.540
I think it is or and that is then the representation of the that demo dot PY file that you've imported.

00:47:40.540 --> 00:47:42.540
So, yeah, probably.

00:47:42.540 --> 00:47:42.540
Yeah.

00:47:42.540 --> 00:47:45.540
So then then all those methods are then exposed on that.

00:47:45.540 --> 00:47:54.540
So, yeah, a module from it like conceptually, if I'm if I'm thinking about this as a dotnet developer looking at it from Python, like, okay, that the module is that Python file.

00:47:54.540 --> 00:48:00.540
And that's what I get back when I say, like, I want an instance of the interface into that file.

00:48:00.540 --> 00:48:04.540
Yeah, and it does honestly it doesn't matter how I feel about this as a Python person.

00:48:04.540 --> 00:48:09.540
It feels about it matters how dotnet people feel about this when they look because that's this is C# code.

00:48:09.540 --> 00:48:10.540
That's their code.

00:48:10.540 --> 00:48:11.540
That's their world.

00:48:11.540 --> 00:48:16.540
It just so happens that C snakes make it makes it really nice possible to talk to the Python world.

00:48:16.540 --> 00:48:17.540
Yeah.

00:48:17.540 --> 00:48:39.540
So one thing I wanted maybe could spend a couple minutes talking about this Anthony is I saw an example where you you showed integrating open telemetry and ASP dotnet and Postgres and all sorts of stuff together, not just a, you know, hello world sort of example, which shows some really cool stuff, but maybe doesn't convince people that they could do cool stuff with it.

00:48:39.540 --> 00:48:44.540
You want to just maybe talk us through some of the moving parts of that to give people a sense of a more realistic example.

00:48:44.540 --> 00:48:49.540
Yeah, so we have a another demo, which is a web app medicine in the project.

00:48:49.540 --> 00:48:53.540
Well, this is kind of what we thought was a more realistic integration example.

00:48:53.540 --> 00:48:56.540
So you've got a web app written in.

00:48:56.540 --> 00:48:59.540
Yeah, well, the front end written in HTML and JavaScript.

00:48:59.540 --> 00:49:01.540
The API is written in dotnet.

00:49:01.540 --> 00:49:04.540
You're using Postgres as the database.

00:49:04.540 --> 00:49:11.540
And you've got like a feature that you want to add to your app where you want to use some Python libraries and some Python code.

00:49:11.540 --> 00:49:14.540
And we were looking at whether everyone loves the weather demo.

00:49:14.540 --> 00:49:15.540
Just real enough.

00:49:15.540 --> 00:49:16.540
Come on.

00:49:16.540 --> 00:49:17.540
It's just real enough.

00:49:17.540 --> 00:49:24.540
The weather demo is like the canonical dotnet demo of when you do file new API projects like here is a weather app.

00:49:24.540 --> 00:49:27.540
So I from a dotnet developer, I feel very much at home.

00:49:27.540 --> 00:49:29.540
Yeah, you're already on board.

00:49:29.540 --> 00:49:30.540
Okay, got it.

00:49:30.540 --> 00:49:32.540
Yeah, we're creating the one that people would expect.

00:49:32.540 --> 00:49:34.540
Now on the dotnet side, we also said, right.

00:49:34.540 --> 00:49:47.540
Yeah, let's be realistic about what people would want to do, because like modern applications, you would write the API in ASP.net and you would, you know, have API endpoints that you would and routes and configure those.

00:49:47.540 --> 00:49:54.540
And you would have a probably a relational database like Postgres or SQL Server or something as the storage environment.

00:49:54.540 --> 00:50:01.540
And then now we support open telemetry in a platform called Aspire, which Aaron can probably explain in a second.

00:50:01.540 --> 00:50:12.540
So open telemetry is a new standard for like tracing and instrumentation and observability generally of applications written in any language.

00:50:12.540 --> 00:50:14.540
And in dotnet you can have.

00:50:14.540 --> 00:50:26.540
So for this app, for example, like, you know, somebody makes a request to the web app and you see the request come in and all the timing and there's any log records in dotnet or if anything crashes or like it's all associated with the same request.

00:50:26.540 --> 00:50:35.540
Now, if we're going to spin up and run a Python function and in Python, you do import logging, you know, logger logging dot info or logging dot error.

00:50:35.540 --> 00:50:36.540
Like, where does that go?

00:50:36.540 --> 00:50:39.540
Because you've just logged something in Python.

00:50:39.540 --> 00:50:41.540
Does it just disappear into the ether?

00:50:41.540 --> 00:50:45.540
Is it like it goes into the terminal output of the container?

00:50:45.540 --> 00:50:46.540
It runs it.

00:50:46.540 --> 00:50:46.540
Who knows?

00:50:46.540 --> 00:50:47.540
Right?

00:50:47.540 --> 00:50:47.540
Yeah, exactly.

00:50:47.540 --> 00:50:51.540
Like it would be kind of useless and not easy to manage.

00:50:51.540 --> 00:50:56.540
And we're coming at this at the angle, like people write big enterprise apps in dotnet.

00:50:56.540 --> 00:51:00.540
So like they would expect that they do logging and it's all in the same system.

00:51:00.540 --> 00:51:09.540
So this demo basically says, OK, one of the API endpoints in on dotnet, it runs a function in Python, which spins up.

00:51:09.540 --> 00:51:20.540
It uses pandas and as a data frame to look at the weather or in it, like calculate some averages and shifting means and stuff like that to give you back like a prediction for what the weather is going to be like this week.

00:51:20.540 --> 00:51:24.540
And we just use Seattle was the data set because it's easy because it's always going to rain.

00:51:24.540 --> 00:51:27.540
And then it's not actually most of the time it doesn't.

00:51:27.540 --> 00:51:28.540
It's not fair.

00:51:28.540 --> 00:51:30.540
So it runs that in Python.

00:51:30.540 --> 00:51:36.540
And in the Python code, we use open telemetry to show the trace of it talking to the database.

00:51:36.540 --> 00:51:42.540
And we we use Python logging and that log information on the trace information all gets put into the same trace.

00:51:42.540 --> 00:51:47.540
So from dotnet from start to finish, you see the request come in on the front end.

00:51:47.540 --> 00:51:49.540
You see the dotnet code executing.

00:51:49.540 --> 00:51:50.540
You see the Python code.

00:51:50.540 --> 00:51:55.540
And then if Python crashes or if the log entries go in, they're all in the same environment.

00:51:55.540 --> 00:52:04.540
So in like an open telemetry dashboard, you see the whole trace across both dotnet and Python or in the same environment.

00:52:04.540 --> 00:52:06.540
And you can just use logging as you would normally.

00:52:06.540 --> 00:52:13.540
And dotnet aspire comes with a like a free open telemetry dashboard that you can run locally.

00:52:13.540 --> 00:52:15.540
It's like a Docker container.

00:52:15.540 --> 00:52:19.540
It's really nice to save you kind of spinning up Jaeger or something.

00:52:19.540 --> 00:52:23.540
Yeah, this is really cool because you've got an ASP.net API.

00:52:23.540 --> 00:52:28.540
But then when it's called, it uses one of these code gen CSnakes Python integrations.

00:52:28.540 --> 00:52:40.540
But a lot of stuff just flows through like the Postgres connection string flows through the open telemetry context flows through the logging kind of goes tangentially off.

00:52:40.540 --> 00:52:43.540
Then it talks to the database in Python and then it returns back.

00:52:43.540 --> 00:52:47.540
And your example is just pure SQL connections and stuff.

00:52:47.540 --> 00:52:48.540
But it's like a PG2.

00:52:48.540 --> 00:52:52.540
But you could use pretty much any ORM or anything, right?

00:52:52.540 --> 00:52:53.540
There's no real constraint there.

00:52:53.540 --> 00:52:54.540
Yeah.

00:52:54.540 --> 00:53:05.540
And it uses a few modules which are tricky like pandas and psycho PG is a anyone who's deployed that to production in containers or in different environments.

00:53:05.540 --> 00:53:11.540
And those is it's hard because like it's like which binary do you use and like importing it is hard.

00:53:11.540 --> 00:53:16.540
And, you know, you need libpq and like it's a bit of a nightmare.

00:53:16.540 --> 00:53:20.540
So it's just demonstrate that they're like, this is this is a real thing you can do.

00:53:20.540 --> 00:53:30.540
And it shows something which is practical in Python and something which is practical in .NET, which is like a proper app with tracing and logging and all the, you know, all those kind of features.

00:53:30.540 --> 00:53:36.540
And on the Python side, we're using pandas, which, you know, and we're using numpy, which is the C extension.

00:53:36.540 --> 00:53:42.540
And we're using psycho PG, which is like depends on a whole bunch of like third party libraries as well.

00:53:42.540 --> 00:53:46.540
And stringing it all together and it just looks and feels seamless.

00:53:46.540 --> 00:53:55.540
Like you see the demo working and you would never know that the, the weather prediction comes from Python or even that it's running in this way.

00:53:55.540 --> 00:53:59.540
Like it just looks like and it's implemented like it's part of the same API.

00:53:59.540 --> 00:54:02.540
It's call a function and one of the libraries and off it goes.

00:54:02.540 --> 00:54:04.540
But yeah, it's all connected together like this.

00:54:04.540 --> 00:54:05.540
All right. I'll let either.

00:54:05.540 --> 00:54:08.540
We're about out of time, but I'll let either of you take this.

00:54:08.540 --> 00:54:10.540
That was a web example.

00:54:10.540 --> 00:54:17.540
What about something like WPF or Maui or any other desktop app possible?

00:54:17.540 --> 00:54:24.540
Yeah. So because I'll talk about Maui because obviously that's the, the more modern UI framework.

00:54:24.540 --> 00:54:29.540
Give a really, really quick definition to listeners who probably think of that as part of Hawaii.

00:54:29.540 --> 00:54:38.540
It's kind of the, the next evolution of Xamarin, which people may be familiar with the way that you do cross-platform UIs.

00:54:38.540 --> 00:54:46.540
I'm definitely not the expert on Maui, but the idea is that, you know, you can have something that is a bit more portable from a application experience,

00:54:46.540 --> 00:54:53.540
if you want to target like a mobile application, like an Android or an iOS or run as a desktop application on Windows or something like that.

00:54:53.540 --> 00:54:58.540
So just like a level of portability and some structure between UI concepts.

00:54:58.540 --> 00:55:01.540
But fundamentally that's just running .NET behind the scenes.

00:55:01.540 --> 00:55:11.540
So there's no reason why we couldn't also drop in a, a bit of a sea snakes in there and have that, yeah, work with some kind of backend service.

00:55:11.540 --> 00:55:18.540
Like you could use this and this is something that Anthony and I have talked about trying to, trying to get a demo of doing like a local model running with,

00:55:18.540 --> 00:55:29.540
like, so you, you pull a model off of hugging face or something like that, just runs it locally to do some kind of AI inference or whatever the case may be for the scenario you want to tackle.

00:55:29.540 --> 00:55:33.540
But that way you don't have to be, you know, calling out to an external service.

00:55:33.540 --> 00:55:38.540
Now, while sure running like a local model, it's doable with .NET.

00:55:38.540 --> 00:55:41.540
It is just way easier to do that with Python.

00:55:41.540 --> 00:55:46.540
And all the examples you would find are going to be written in Python first and foremost.

00:55:46.540 --> 00:55:49.540
So trying to then go, okay, well, so this is doable in Python.

00:55:49.540 --> 00:55:51.540
So what's the C# equivalent?

00:55:51.540 --> 00:55:54.540
How do I find the equivalent .NET libraries on you yet?

00:55:54.540 --> 00:55:56.540
And so on and so forth.

00:55:56.540 --> 00:56:08.540
Well, you know, like with sea snakes, you could expose that model, create some surface areas in just Python APIs that is then going to be consumable by a .NET application.

00:56:08.540 --> 00:56:13.540
So yeah, it's something you can definitely do not 100% sure whether you can do it on mobile.

00:56:13.540 --> 00:56:19.540
I think that's probably stretching it a bit far just because of the way that we have to bootstrap Python with inside of it.

00:56:19.540 --> 00:56:25.540
And you'd probably be limited from a mobile OS runtime to be able to do that kind of bootstrapping.

00:56:25.540 --> 00:56:32.540
But at the very least, like a desktop application, or if you wanted to tackle with like a cross platform UI framework like Avalonia.

00:56:32.540 --> 00:56:41.540
So Avalonia is a cross platform .NET UI framework that means you could build for Linux and Windows and macOS at the same time.

00:56:41.540 --> 00:56:51.540
You could then run sea snakes under the hood of that to then have that desktop experience that is leveraging Python for where Python is going to be better suited to tackle a problem.

00:56:51.540 --> 00:57:00.540
.NET for a different set of problems that's better suited for that just inside this application where you would have no idea as the end user that you're like that that's what's actually happening.

00:57:00.540 --> 00:57:02.540
Very compelling. Very compelling.

00:57:02.540 --> 00:57:03.540
Very compelling.

00:57:03.540 --> 00:57:05.540
All right, Anthony, let's close this out with one final thing.

00:57:05.540 --> 00:57:07.540
I think this is important and we haven't really touched on it yet.

00:57:07.540 --> 00:57:11.540
You guys started the conversation by saying this is really important for data science, right?

00:57:11.540 --> 00:57:12.540
Data science use cases.

00:57:12.540 --> 00:57:15.540
And I made the joke about copying a million items to add one to the list.

00:57:15.540 --> 00:57:24.540
But what about sharing data like NumPy across different, you know, the .NET side and the Python side and so on?

00:57:24.540 --> 00:57:26.540
We have tackled that specifically.

00:57:26.540 --> 00:57:28.540
So there's something called the buffer protocol.

00:57:28.540 --> 00:57:31.540
It's a PEP from a few years ago.

00:57:31.540 --> 00:57:39.540
It's a kind of an API for the internals of something like an ND array in NumPy.

00:57:39.540 --> 00:57:44.540
And the buffer protocol with it, we support that.

00:57:44.540 --> 00:57:54.540
So if your function returns a buffer, which is a type, then we can access the internals of that buffer directly without having to convert the data.

00:57:54.540 --> 00:58:13.540
What this means in reality is that if your function returns a like a NumPy array, like an ND array and the internal values in the ND array are a specific type like a 32 bit integer, you can access them as 32 bit integers in .NET without having to marshal or copy data.

00:58:13.540 --> 00:58:14.540
That's awesome.

00:58:14.540 --> 00:58:20.540
You reach inside of the the ND array, just grab its actual memory and just say, got it. Let's go.

00:58:20.540 --> 00:58:21.540
Got it. Let's go.

00:58:21.540 --> 00:58:22.540
Yeah, that's exactly what we do.

00:58:22.540 --> 00:58:24.540
And so that's a is in .NET.

00:58:24.540 --> 00:58:28.540
It's called a read only span, which is the you can write the data as well.

00:58:28.540 --> 00:58:36.540
So you can do it and you can actually just modify the values inside the NumPy array directly from .NET without having to copy backwards and forwards.

00:58:36.540 --> 00:58:42.540
And we support pretty much every like low level types that NumPy supports.

00:58:42.540 --> 00:58:49.540
And that means you don't have to do a .2 list on the NumPy array because like that is really expensive.

00:58:49.540 --> 00:58:54.540
And also .NET works in a similar low level numeric types that NumPy does.

00:58:54.540 --> 00:59:00.540
You know, it will work with 32 bit ints and 32 or 64 bit floats, for example.

00:59:00.540 --> 00:59:17.540
So like if you're storing a 2D matrices in 32 bit floats in NumPy and then you want to send that to to .NET to I don't know, like pick out some specific values or like do some calculations in .NET, then you can just chuck that back as a buffer.

00:59:17.540 --> 00:59:23.540
And there's information in the docs about how to do this and then you can just access the values directly out of memory.

00:59:23.540 --> 00:59:25.540
So it's super fast.

00:59:25.540 --> 00:59:32.540
And if you even want to like fill a buffer with values from .NET, then you can do that using the writable span.

00:59:32.540 --> 00:59:33.540
That's pretty awesome.

00:59:33.540 --> 00:59:37.540
So, yeah, that really is leaning into the data science benefits here as well, isn't it?

00:59:37.540 --> 00:59:42.540
Nothing ever goes wrong if you're sharing memory across runtimes for different programming languages.

00:59:42.540 --> 00:59:44.540
It's no, I don't see how this could go wrong.

00:59:44.540 --> 00:59:46.540
Yeah, perfectly fine.

00:59:46.540 --> 00:59:49.540
And that's why I pushed to make sure we supported read only span.

00:59:49.540 --> 00:59:50.540
Yeah, right.

00:59:50.540 --> 00:59:51.540
Okay.

00:59:51.540 --> 00:59:52.540
No, I think it's great.

00:59:52.540 --> 00:59:53.540
I think it's great.

00:59:53.540 --> 00:59:57.540
And the UI stuff with Avalonia is something I'm going to look at.

00:59:57.540 --> 00:59:58.540
That sounds really cool to play with.

00:59:58.540 --> 00:59:59.540
So, all right.

00:59:59.540 --> 01:00:00.540
Final thoughts, you guys.

01:00:00.540 --> 01:00:08.540
People out there going, oh my gosh, I cannot believe we can finally do this with our .NET app and plug in some of the other things we're already doing in Python.

01:00:08.540 --> 01:00:09.540
Should they?

01:00:09.540 --> 01:00:10.540
Is it ready?

01:00:10.540 --> 01:00:13.540
If somebody were to take this and build a thing, is that a good idea or should they wait?

01:00:13.540 --> 01:00:14.540
Yep.

01:00:14.540 --> 01:00:16.540
They should download it, give it a go.

01:00:16.540 --> 01:00:20.540
The only thing we're possibly changing at the moment is the API based on feedback.

01:00:20.540 --> 01:00:22.540
We're trying to keep that as stable as possible right now.

01:00:22.540 --> 01:00:25.540
So we're only making changes that are backward compatible.

01:00:25.540 --> 01:00:30.540
And yeah, we just want to see more use cases and people can get more feedback.

01:00:30.540 --> 01:00:36.540
So yeah, please pull it, grab the samples, spin them up, build something, tell us what you made, and then give us any feedback.

01:00:36.540 --> 01:00:37.540
Well, congrats.

01:00:37.540 --> 01:00:38.540
It looks really, really nice.

01:00:38.540 --> 01:00:40.540
Definitely, definitely looks promising.

01:00:40.540 --> 01:00:43.540
And I think it's, it solves a lot of the problems that the other attempts had.

01:00:43.540 --> 01:00:44.540
So nice work.

01:00:44.540 --> 01:00:44.540
Thanks, Mike.

01:00:44.540 --> 01:00:45.540
Thanks.

01:00:46.540 --> 01:00:47.540
Yep.

01:00:47.540 --> 01:00:48.540
Bye guys.

01:00:52.540 --> 01:00:53.660
Be sure to check out what they're offering.

01:00:53.660 --> 01:00:55.060
It really helps support the show.

01:00:55.060 --> 01:00:58.120
This episode is sponsored by Posit Connect

01:00:58.120 --> 01:00:59.480
from the makers of Shiny.

01:00:59.480 --> 01:01:02.260
Publish, share, and deploy all of your data projects

01:01:02.260 --> 01:01:04.000
that you're creating using Python.

01:01:04.000 --> 01:01:08.200
Streamlit, Dash, Shiny, Bokeh, FastAPI, Flask, Quarto,

01:01:08.200 --> 01:01:10.560
Reports, Dashboards, and APIs.

01:01:10.560 --> 01:01:12.960
Posit Connect supports all of them.

01:01:12.960 --> 01:01:14.360
Try Posit Connect for free

01:01:14.360 --> 01:01:18.620
by going to talkpython.fm/posit, P-O-S-I-T.

01:01:18.620 --> 01:01:21.720
And this episode is brought to you by Bluehost.

01:01:22.020 --> 01:01:23.300
Do you need a website fast?

01:01:23.300 --> 01:01:24.200
Get Bluehost.

01:01:24.200 --> 01:01:26.940
Their AI builds your WordPress site in minutes

01:01:26.940 --> 01:01:29.560
and their built-in tools optimize your growth.

01:01:29.560 --> 01:01:30.520
Don't wait.

01:01:30.520 --> 01:01:34.140
Visit talkpython.fm/bluehost to get started.

01:01:34.140 --> 01:01:36.100
Want to level up your Python?

01:01:36.100 --> 01:01:38.260
We have one of the largest catalogs

01:01:38.260 --> 01:01:40.240
of Python video courses over at Talk Python.

01:01:40.240 --> 01:01:42.520
Our content ranges from true beginners

01:01:42.520 --> 01:01:45.340
to deeply advanced topics like memory and async.

01:01:45.340 --> 01:01:48.000
And best of all, there's not a subscription in sight.

01:01:48.000 --> 01:01:50.920
Check it out for yourself at training.talkpython.fm.

01:01:51.500 --> 01:01:53.020
Be sure to subscribe to the show,

01:01:53.020 --> 01:01:54.740
open your favorite podcast app,

01:01:54.740 --> 01:01:55.800
and search for Python.

01:01:55.800 --> 01:01:57.100
We should be right at the top.

01:01:57.100 --> 01:02:00.060
You can also find the iTunes feed at /itunes,

01:02:00.060 --> 01:02:02.260
the Google Play feed at /play,

01:02:02.260 --> 01:02:06.460
and the direct RSS feed at /rss on talkpython.fm.

01:02:06.460 --> 01:02:09.440
We're live streaming most of our recordings these days.

01:02:09.440 --> 01:02:10.800
If you want to be part of the show

01:02:10.800 --> 01:02:12.840
and have your comments featured on the air,

01:02:12.840 --> 01:02:14.920
be sure to subscribe to our YouTube channel

01:02:14.920 --> 01:02:17.260
at talkpython.fm/youtube.

01:02:17.940 --> 01:02:19.320
This is your host, Michael Kennedy.

01:02:19.320 --> 01:02:20.620
Thanks so much for listening.

01:02:20.620 --> 01:02:21.760
I really appreciate it.

01:02:21.760 --> 01:02:23.680
Now get out there and write some Python code.

01:02:23.680 --> 01:02:24.280
Thank you.

01:02:24.280 --> 01:02:44.880
We'll see you next time.

