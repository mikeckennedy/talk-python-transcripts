WEBVTT

00:00:00.380 --> 00:00:09.880
This podcast episode that you're listening to right now was delivered to you in part by MongoDB and Python, powering our web apps and production processes.

00:00:09.880 --> 00:00:17.740
But if you're using PyMongo, the native driver from MongoDB, to talk to the server, then you might be doing it wrong.

00:00:17.740 --> 00:00:23.620
Basing your app on a foundation of exchanging raw dictionaries is a castle built on sand.

00:00:23.620 --> 00:00:26.480
And by the way, see the joke at the end of the show about that.

00:00:26.480 --> 00:00:30.100
You should be using an ODM, an object document mapper.

00:00:30.100 --> 00:00:38.420
This time we're talking about Beanie, which is one of the exciting new MongoDB ODMs, which is based on Pydantic and is async native.

00:00:38.420 --> 00:00:41.940
Join me as I discuss this project with its creator, Roman Wright.

00:00:41.940 --> 00:00:47.460
This is Talk Python To Me, episode 349, recorded November 18th, 2021.

00:00:47.460 --> 00:01:04.120
Welcome to Talk Python To Me, a weekly podcast on Python.

00:01:04.120 --> 00:01:05.860
This is your host, Michael Kennedy.

00:01:05.860 --> 00:01:12.040
Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes at talkpython.fm.

00:01:12.040 --> 00:01:15.100
And follow the show on Twitter via at Talk Python.

00:01:16.000 --> 00:01:20.680
This episode is brought to you by Sentry and us over at Talk Python Training.

00:01:20.680 --> 00:01:23.420
Please check out what we're both offering during our segments.

00:01:23.420 --> 00:01:25.300
It really helps support the show.

00:01:25.300 --> 00:01:28.040
Hey folks, it's great to have you listening as always.

00:01:28.040 --> 00:01:30.120
A quick bit of news before we talk with Roman.

00:01:30.980 --> 00:01:36.760
I've been looking for a way to explore ideas teaching Python, get some feedback, and then bring what I've learned back to the course content.

00:01:36.760 --> 00:01:39.960
So I'm kicking off a new initiative over on YouTube.

00:01:39.960 --> 00:01:41.520
It's called Python Shorts.

00:01:41.520 --> 00:01:47.300
And the goal is to teach you one thing, both interesting and useful, as well as actionable, about Python.

00:01:47.740 --> 00:01:49.700
I have three videos out so far.

00:01:49.700 --> 00:01:52.420
The first, parsing data with Pydantic.

00:01:52.420 --> 00:01:56.340
The second, counting the number of times an item appears in a list with counter.

00:01:56.340 --> 00:01:58.920
And third, do you even need loops in Python?

00:01:58.920 --> 00:02:08.060
I also published a fourth video about using the Stream Deck, that little button device that a lot of gamers use, to make Python developers more productive.

00:02:08.420 --> 00:02:12.820
Check out all four of those videos on my personal YouTube channel, not the Talk Python one.

00:02:12.820 --> 00:02:13.960
Links in the show notes.

00:02:13.960 --> 00:02:15.480
Now, let's talk Beanie.

00:02:15.480 --> 00:02:19.360
Roman, welcome to Talk Python To Me.

00:02:19.360 --> 00:02:20.880
Hey, I'm happy to be here.

00:02:20.880 --> 00:02:22.280
Yeah, it's great to have you here.

00:02:22.280 --> 00:02:25.760
Oh, we get to talk about one of my favorite topics, MongoDB.

00:02:25.760 --> 00:02:26.880
I'm so excited.

00:02:26.880 --> 00:02:29.820
Yeah, my favorite topic, obviously too.

00:02:29.820 --> 00:02:32.060
Oh, yeah, you definitely put a lot of time into it.

00:02:32.060 --> 00:02:34.520
We're going to talk about your ODM.

00:02:34.520 --> 00:02:45.800
People often hear about ORMs, Object Relational Mappers, but traditionally, MongoDB and other document databases and NoSQL databases haven't modeled things through relationships.

00:02:45.800 --> 00:02:46.880
It's more through documents.

00:02:46.880 --> 00:02:49.960
So the D instead of R, ODM.

00:02:49.960 --> 00:02:52.380
Beanie, which is going to be super fun.

00:02:52.380 --> 00:02:56.000
It brings together so many cool topics and even relationships.

00:02:56.000 --> 00:03:00.340
So maybe if you really wanted, I guess you could put the R back in there as of recently.

00:03:00.340 --> 00:03:04.180
Anyway, super fun topic on deck for us.

00:03:04.340 --> 00:03:06.340
Before we get to that, let's just start with your story.

00:03:06.340 --> 00:03:07.940
How did you get into programming in Python?

00:03:07.940 --> 00:03:12.440
I started when I was a student, more than 10 years ago now.

00:03:12.440 --> 00:03:14.020
But I started not with Python.

00:03:14.020 --> 00:03:18.300
I started, it was 2008, I think, 2007 probably.

00:03:18.300 --> 00:03:22.820
I started with Flash, and nobody knew that Flash will die soon.

00:03:22.820 --> 00:03:25.860
Flash was such a big thing when it was new.

00:03:25.860 --> 00:03:32.300
I remember people were just completely getting amazing consulting jobs and building websites with Flash.

00:03:32.300 --> 00:03:32.980
I'm like, what is this?

00:03:33.020 --> 00:03:35.660
I'm not sure I want to learn this, but do I have to learn this?

00:03:35.660 --> 00:03:36.140
I hope not.

00:03:36.140 --> 00:03:37.360
But yeah, anyway, yeah.

00:03:37.360 --> 00:03:39.840
It did kind of get killed by HTML5.

00:03:39.840 --> 00:03:43.380
And, you know, I think, honestly, maybe it got killed by Steve Jobs, really.

00:03:43.380 --> 00:03:45.280
At least earlier than it would have been.

00:03:45.280 --> 00:03:45.860
Definitely.

00:03:45.860 --> 00:03:46.400
Yeah.

00:03:47.800 --> 00:03:49.500
So, but that time I didn't know that.

00:03:49.500 --> 00:03:51.760
And ActionScript, two and three.

00:03:51.760 --> 00:03:52.980
Right on.

00:03:53.420 --> 00:03:56.140
And then I decided to move to backend problem.

00:03:56.140 --> 00:03:59.820
So Flash is a client technology, if anybody don't know.

00:03:59.820 --> 00:04:00.580
There's no.

00:04:00.580 --> 00:04:06.240
And then I moved to, I just wanted to build websites and wanted to move to backend.

00:04:06.240 --> 00:04:09.120
And I chose Django.

00:04:09.120 --> 00:04:09.600
Mm-hmm.

00:04:09.600 --> 00:04:10.940
Not Python, but Django.

00:04:10.940 --> 00:04:13.000
Because Django was super fancy at that time.

00:04:13.000 --> 00:04:14.860
And now also, but that time, yes.

00:04:14.860 --> 00:04:18.960
And I was a Django developer, not Python developer, but Django developer for a year, probably.

00:04:18.960 --> 00:04:25.080
Because I knew a few tricks and tips about Django tools, models, views, and et cetera, templating.

00:04:25.080 --> 00:04:28.080
And then somehow I learned Python also.

00:04:28.080 --> 00:04:30.640
And now I'm always a good Python developer.

00:04:30.640 --> 00:04:32.020
Yeah, fantastic.

00:04:32.020 --> 00:04:38.760
I think I just realized as you were speaking, we might have to tell people what Flash is.

00:04:38.760 --> 00:04:42.560
I feel like it's just one of these, you know, iconic things out of the tech industry.

00:04:42.560 --> 00:04:45.180
But it might be like talking about AltaVista.

00:04:45.180 --> 00:04:48.180
At some point, the kids, they won't know what Flash is.

00:04:48.400 --> 00:04:52.920
They won't know there was this battle about getting this thing on people's computer.

00:04:52.920 --> 00:04:57.060
And it was always like viruses are being found in them, but it could always do this magical stuff.

00:04:57.060 --> 00:04:57.660
How interesting.

00:04:57.660 --> 00:04:58.560
Yeah, yeah.

00:04:58.560 --> 00:04:59.920
How old we are.

00:04:59.920 --> 00:05:01.180
Exactly.

00:05:01.180 --> 00:05:05.660
The other thing that is interesting is you said you chose Django.

00:05:05.660 --> 00:05:08.220
You didn't choose Python.

00:05:08.220 --> 00:05:09.000
Yeah.

00:05:09.000 --> 00:05:16.080
Yeah, I think that that's, you know, now people are often choosing Python because of the data science and computational story.

00:05:16.220 --> 00:05:21.300
But before 2012, there was not this massive influx of data science people.

00:05:21.300 --> 00:05:28.500
And I think that the big influx was people becoming Django developers and like, well, I guess I'll learn Python.

00:05:28.500 --> 00:05:30.980
Kind of like people becoming Ruby on Rails developers.

00:05:30.980 --> 00:05:33.120
Like, I don't know Ruby, but I want to do Ruby on Rails.

00:05:33.120 --> 00:05:34.300
So I guess I got to learn Ruby.

00:05:34.500 --> 00:05:36.460
Django is kind of our version of that, right?

00:05:36.460 --> 00:05:36.900
Right.

00:05:36.900 --> 00:05:37.140
Yeah.

00:05:37.140 --> 00:05:44.360
Then I think Flask appeared after a few years and everyone started to do microservices with Flask.

00:05:44.360 --> 00:05:47.220
And after that, the game started.

00:05:48.360 --> 00:05:49.140
That's right.

00:05:49.140 --> 00:05:50.340
That's right.

00:05:50.340 --> 00:05:50.880
Oh, my goodness.

00:05:50.880 --> 00:05:55.840
Out in the live stream, we're getting some high fives from Pradvan on Django.

00:05:55.840 --> 00:05:59.200
And Jeff says, he says Django the right way.

00:05:59.200 --> 00:05:59.720
Fantastic.

00:05:59.720 --> 00:06:01.360
So awesome.

00:06:01.360 --> 00:06:01.940
Yeah.

00:06:01.940 --> 00:06:05.680
And I think Django has been massively important for Python.

00:06:05.680 --> 00:06:07.000
And very, very cool.

00:06:07.000 --> 00:06:07.360
Yeah.

00:06:07.480 --> 00:06:07.920
How about now?

00:06:07.920 --> 00:06:08.840
What are you doing day to day?

00:06:08.840 --> 00:06:11.760
So I'm principal Python developer now.

00:06:11.760 --> 00:06:13.620
And this is interesting.

00:06:13.620 --> 00:06:17.020
Actually, I changed my job three months ago.

00:06:17.020 --> 00:06:19.640
And I didn't look for a new job.

00:06:19.640 --> 00:06:28.480
But one day, Moot, my current manager, just texted me into Twitter that, hey, I saw your library, Bini.

00:06:28.480 --> 00:06:30.160
And it's interesting.

00:06:30.160 --> 00:06:32.680
And we need something like this in our project.

00:06:32.940 --> 00:06:39.520
And probably you would like to participate in and integrate Bini into our project and develop Bini at the work time.

00:06:39.520 --> 00:06:39.820
Oh, how cool.

00:06:39.820 --> 00:06:41.240
And I decided, yeah.

00:06:41.240 --> 00:06:42.300
Yeah.

00:06:42.300 --> 00:06:43.620
That's amazing.

00:06:43.620 --> 00:06:49.220
I mean, on one hand, it would just be cool to have a fun job doing cool MongoDB stuff, right?

00:06:49.220 --> 00:06:56.180
On the other, it's like, oh, my gosh, I get to use my library and build up my library in a real production environment.

00:06:56.180 --> 00:06:57.340
Like, that's awesome, right?

00:06:57.340 --> 00:06:58.060
Yeah, yeah.

00:06:58.060 --> 00:07:01.780
And so I decided the same day, I think.

00:07:01.780 --> 00:07:04.180
Let me think about it.

00:07:04.180 --> 00:07:04.840
Yes, okay.

00:07:04.840 --> 00:07:08.280
We'll figure out how long it takes me to quit my current job.

00:07:08.280 --> 00:07:09.300
Awesome.

00:07:09.300 --> 00:07:10.080
Well, congratulations.

00:07:10.080 --> 00:07:10.800
That's really cool.

00:07:10.800 --> 00:07:12.120
Yeah, thank you.

00:07:12.120 --> 00:07:14.000
That only means good things for Bini, right?

00:07:14.000 --> 00:07:16.480
It only means more time and energy on it, I would suspect.

00:07:16.480 --> 00:07:17.300
Yeah, yeah.

00:07:17.300 --> 00:07:26.360
All this, the current release, the huge release is possible only because I can work a little bit time on work time, not only on weekend.

00:07:26.360 --> 00:07:27.400
Yeah, absolutely.

00:07:27.640 --> 00:07:32.140
It's easy to justify, like, the library needs this feature to work right for us.

00:07:32.140 --> 00:07:36.280
So let me add that feature to the library as just part of the sprint or whatever, right?

00:07:36.280 --> 00:07:44.120
And also probably it's even more important that when I can work on production with Bini, I can also see what does it mean.

00:07:44.120 --> 00:07:44.420
Yeah.

00:07:44.520 --> 00:07:47.160
Which feature and which improvement.

00:07:47.160 --> 00:07:50.780
It's so true because there's just these little edge cases.

00:07:50.780 --> 00:07:56.180
They don't show up under even a complicated little example you build for yourself.

00:07:56.180 --> 00:08:00.340
You know, you've got to put it into production and live with it.

00:08:00.340 --> 00:08:02.440
You know, some of that stuff might be migrations, right?

00:08:02.440 --> 00:08:03.880
Like, I never need these migrations.

00:08:03.880 --> 00:08:04.420
Oh, wait.

00:08:04.420 --> 00:08:07.140
We have the zero downtime promise.

00:08:07.140 --> 00:08:09.280
We kind of need migrations now or something, right?

00:08:09.280 --> 00:08:09.680
Right.

00:08:09.680 --> 00:08:10.660
Totally correct.

00:08:11.260 --> 00:08:12.000
Yeah, yeah.

00:08:12.000 --> 00:08:12.340
Cool.

00:08:12.340 --> 00:08:13.640
Well, that's great to hear.

00:08:13.640 --> 00:08:14.260
Congratulations.

00:08:14.260 --> 00:08:22.480
Now, I wanted to start our chat off not talking about Bini precisely, but like a little lower in the tech stack here.

00:08:22.480 --> 00:08:27.200
Let's just talk about MongoDB for a little bit.

00:08:27.200 --> 00:08:32.600
I'm a huge fan of MongoDB, as I'm sure many of the listeners know out there.

00:08:32.600 --> 00:08:39.740
I've been running Talk Python, Talk Python training those things on top of MongoDB for quite some time.

00:08:39.900 --> 00:08:46.180
In the very, very early days, some of that was SQLAlchemy stuff, but then I switched over to Mongo and whatnot.

00:08:46.180 --> 00:08:47.840
So I'm a huge fan of it.

00:08:47.840 --> 00:08:49.920
I definitely think there's a lot of value.

00:08:49.920 --> 00:08:57.960
And there's a lot of these architectures where people talk about, oh, we have a Redis middle tier cache because we got to have our website fast.

00:08:57.960 --> 00:08:59.020
You know what?

00:08:59.020 --> 00:09:02.780
We get 10 millisecond response time and there's no cache.

00:09:02.780 --> 00:09:06.900
It's just talking to the database because, you know, everything is structured the right way.

00:09:06.900 --> 00:09:09.040
I think it's, anyway, I'm kind of going on too much.

00:09:09.140 --> 00:09:15.660
But what I wanted to start with was I want to hear your thoughts on just sort of why build on top of Mongo.

00:09:15.660 --> 00:09:20.400
You know, so many people in the Python space build on Postgres, which is fine.

00:09:20.400 --> 00:09:23.860
It's a good database and all is just a completely different modeling story.

00:09:24.000 --> 00:09:26.120
So why are you interested in Mongo?

00:09:26.120 --> 00:09:30.260
First of all, Mongo is super flexible database by design.

00:09:30.260 --> 00:09:34.320
And I really like to do prototypes.

00:09:35.100 --> 00:09:49.820
So when I just come up with new idea of new project, home project and et cetera, it's quite simple to work with MongoDB instead of Postgres when you have to change painfully schema of your data.

00:09:49.820 --> 00:09:53.260
But with Mongo, you can just do what you want to.

00:09:53.260 --> 00:10:00.700
That's been my experience as well that I remember almost every release of my code would involve some migration on the SQLAlchemy version.

00:10:01.240 --> 00:10:06.480
I think I've done one, what you would consider a migration in like five years on MongoDB.

00:10:06.480 --> 00:10:12.960
Whereas everything else is like, I'm going to add this equivalent of a table or I'm going to add a field to this document.

00:10:12.960 --> 00:10:16.320
But it just goes in and it just, it adapts.

00:10:16.320 --> 00:10:17.140
It's fantastic.

00:10:17.140 --> 00:10:20.160
It's like plastic instead of something brittle.

00:10:20.160 --> 00:10:21.240
Even in the indexes.

00:10:21.240 --> 00:10:21.600
Yeah.

00:10:21.600 --> 00:10:23.160
That's why it's great for me, I think.

00:10:23.160 --> 00:10:24.920
Yeah, it's really easy for prototyping, right?

00:10:24.920 --> 00:10:31.040
You just, instead of trying to keep the database in sync or whatever, you just work on your models and magic happens.

00:10:31.040 --> 00:10:31.380
Yeah.

00:10:31.380 --> 00:10:32.340
Yeah, you're right.

00:10:32.340 --> 00:10:40.180
And then for sure for production, you have to understand your profile and your needs.

00:10:40.180 --> 00:10:47.080
And then you can move to Postgres or you can move to something like timestamp database, ClickHouse, for example.

00:10:47.080 --> 00:10:47.320
Yeah.

00:10:47.320 --> 00:10:49.520
But in most cases, Mongo is enough.

00:10:49.520 --> 00:10:57.120
And for some cases, Mongo is the best choice because of flexibility and because of many cool stuff like indexes and such.

00:10:57.120 --> 00:10:58.120
Yeah, absolutely.

00:10:58.320 --> 00:11:00.700
I think indexes.

00:11:00.700 --> 00:11:01.100
I don't know.

00:11:01.100 --> 00:11:06.420
This is maybe getting ahead of ourselves, but I think indexes are just so underappreciated in databases.

00:11:06.420 --> 00:11:12.460
I mean, I know a lot of people out there make sure their queries have the right indexes and stuff in it.

00:11:12.500 --> 00:11:17.020
But there's also so many websites I visit that take three seconds to load a page.

00:11:17.020 --> 00:11:18.800
I'm like, there's no way there's an index on this query.

00:11:18.800 --> 00:11:20.080
There's just no way.

00:11:20.080 --> 00:11:24.840
I don't know what it's doing, but somebody has just not even thought about it.

00:11:24.840 --> 00:11:27.520
And if it was a weird little, oh, here's like the reporting page.

00:11:27.520 --> 00:11:27.960
Fine.

00:11:28.200 --> 00:11:29.860
But it's like the homepage or something.

00:11:29.860 --> 00:11:30.360
You know what I mean?

00:11:30.360 --> 00:11:36.300
Like, how are they not making this faster even in like a Postgres story, right?

00:11:36.300 --> 00:11:41.860
Like, I feel like there's one thing to have a database that does something.

00:11:41.860 --> 00:11:46.740
There's another to like tune it to do the right thing, regardless of whether it's relational or NoSQL.

00:11:46.740 --> 00:11:47.120
Yeah.

00:11:47.120 --> 00:11:47.960
Totally correct.

00:11:47.960 --> 00:11:48.200
Yeah.

00:11:48.580 --> 00:11:50.100
You have a lot of experience with databases.

00:11:50.100 --> 00:11:52.000
I mean, you must have that feeling as well.

00:11:52.000 --> 00:11:54.100
You go to some website, you're like, what is it doing?

00:11:54.100 --> 00:11:55.560
Why is this thing spinning?

00:11:55.560 --> 00:11:57.160
What could it possibly be doing here?

00:11:57.160 --> 00:12:00.500
Yeah, probably somebody's going, you know, to get data.

00:12:00.500 --> 00:12:02.180
Exactly.

00:12:02.180 --> 00:12:04.020
I mean, you're thinking through the ideas.

00:12:04.020 --> 00:12:04.380
Okay.

00:12:04.380 --> 00:12:06.200
Is it just not half an index?

00:12:06.200 --> 00:12:09.560
Or is it an N plus one problem with some ORM?

00:12:09.560 --> 00:12:11.540
Or where, why am I waiting here?

00:12:11.540 --> 00:12:12.760
What mistake have they made?

00:12:12.760 --> 00:12:14.980
Fantastic.

00:12:14.980 --> 00:12:16.200
All right.

00:12:16.200 --> 00:12:21.840
So the next thing I want to sort of touch on is this tweet from Scott Stoltzman sent this out yesterday.

00:12:21.840 --> 00:12:26.200
I don't think he knew that we were coming up with this conversation, actually.

00:12:26.200 --> 00:12:29.440
So there was this programming humor joke.

00:12:29.440 --> 00:12:35.880
It says, it has like two, I guess one of them is like a kitchen.

00:12:35.880 --> 00:12:38.420
The other is an office, but it doesn't really matter.

00:12:38.420 --> 00:12:41.380
Like the kitchen is super organized and it says MySQL.

00:12:41.380 --> 00:12:44.440
Everything's little buckets and put away nice.

00:12:44.620 --> 00:12:53.760
And then there's a desk area that's just, it looks like a hoarder house or like a, you know, earthquake hit and destroyed this area.

00:12:53.760 --> 00:12:55.220
And it says MongoDB.

00:12:55.220 --> 00:12:57.160
And it's actually true.

00:12:57.160 --> 00:12:58.960
It is.

00:12:58.960 --> 00:13:00.000
It can be true.

00:13:00.000 --> 00:13:06.120
And the reason I bring this up is Scott said, you know, I know a guy who made this course that saved me from this chaos with Mongo Engine.

00:13:07.120 --> 00:13:11.180
Because it can happen with, it can happen in about 15 seconds without a strong plan.

00:13:11.180 --> 00:13:22.440
And so out of the box, the way MongoDB, the dev folks there suggest that you, or at least provide, let's put it that way.

00:13:22.500 --> 00:13:27.340
The tools they provide for you to work with MongoDB are dictionaries.

00:13:27.340 --> 00:13:32.200
Like you can give us dictionaries and put them somewhere and then you can get dictionaries back.

00:13:32.200 --> 00:13:35.720
And Python dictionaries are just whatever, right?

00:13:35.720 --> 00:13:37.480
There's zero structure.

00:13:37.480 --> 00:13:38.960
There's zero discoverability.

00:13:38.960 --> 00:13:40.920
There's zero type safety, right?

00:13:40.920 --> 00:13:43.180
Sometimes it's a string that looks like a number.

00:13:43.180 --> 00:13:44.220
Other times it's a number.

00:13:44.220 --> 00:13:44.720
Good luck.

00:13:44.800 --> 00:13:46.020
Those don't match in a query.

00:13:46.020 --> 00:13:47.240
You know, like it's horrible.

00:13:47.240 --> 00:14:00.140
And so for me, I feel like what you need to do when you're working with databases that have less structure in the thing itself, like this is MySQL, say Postgres.

00:14:00.140 --> 00:14:02.600
Like Postgres says the table looks like this.

00:14:02.600 --> 00:14:05.900
This column is that size of a string.

00:14:05.900 --> 00:14:07.940
This is a number and that's it.

00:14:07.940 --> 00:14:15.780
You know, like the structure is in the database where in these document databases, the structure is in the code.

00:14:15.780 --> 00:14:21.100
And so you should have some kind of code that helps you not end up in a situation like this, right?

00:14:21.100 --> 00:14:21.400
Yeah.

00:14:21.400 --> 00:14:25.580
Honestly, Postgres also came up with JSONB fields now.

00:14:25.580 --> 00:14:26.280
Yeah.

00:14:26.280 --> 00:14:30.240
So they're kind of, maybe they fall into that bottom bucket like in a small little area.

00:14:30.240 --> 00:14:30.640
Yeah.

00:14:30.640 --> 00:14:35.980
This portion of Talk Python To Me is brought to you by Sentry.

00:14:36.300 --> 00:14:38.860
How would you like to remove a little stress from your life?

00:14:38.860 --> 00:14:44.840
Do you worry that users may be encountering errors, slowdowns, or crashes with your app right now?

00:14:44.840 --> 00:14:47.880
Would you even know it until they sent you that support email?

00:14:47.880 --> 00:14:52.660
How much better would it be to have the error or performance details immediately sent to you,

00:14:52.660 --> 00:14:58.300
including the call stack and values of local variables and the active user recorded in the report?

00:14:58.300 --> 00:15:01.720
With Sentry, this is not only possible, it's simple.

00:15:01.720 --> 00:15:05.280
In fact, we use Sentry on all the Talk Python web properties.

00:15:05.720 --> 00:15:11.840
We've actually fixed a bug triggered by a user and had the upgrade ready to roll out as we got the support email.

00:15:11.840 --> 00:15:13.820
That was a great email to write back.

00:15:13.820 --> 00:15:17.200
Hey, we already saw your error and have already rolled out the fix.

00:15:17.200 --> 00:15:18.620
Imagine their surprise.

00:15:18.620 --> 00:15:20.840
Surprise and delight your users.

00:15:20.840 --> 00:15:24.900
Create your Sentry account at talkpython.fm/sentry.

00:15:25.140 --> 00:15:49.660
It's also one of the things.

00:15:49.660 --> 00:15:53.180
Why schemas about structure?

00:15:53.180 --> 00:15:59.120
So the thing I think saves you from, you know, Scott mentioned MongoVidgin, which is pretty good.

00:15:59.120 --> 00:16:01.900
But I think the thing that saves you from this are these ODMs.

00:16:01.900 --> 00:16:07.060
Like you have a lot more structure in your classes and your Python layer, right?

00:16:07.220 --> 00:16:08.340
Yeah, yeah, correct.

00:16:08.340 --> 00:16:10.940
And also, so, yeah.

00:16:10.940 --> 00:16:13.840
Beanie is ODM based on Pydantic.

00:16:13.840 --> 00:16:17.700
Pydantic is Python library, the data and stuff.

00:16:17.700 --> 00:16:20.440
Yeah, let me read the little introduction bit here.

00:16:20.440 --> 00:16:23.440
Because I think there's so much in this first sentence.

00:16:23.440 --> 00:16:29.840
So Beanie is an asynchronous Python object document mapper, ODM, for MongoDB.

00:16:30.700 --> 00:16:37.380
So ODM we talked about, Mongo we talked about, asynchronous, and also I didn't finish the sentence,

00:16:37.380 --> 00:16:40.360
based on motor, which comes from MongoDB, and Pydantic.

00:16:40.360 --> 00:16:43.620
So it's also asynchronous, right?

00:16:43.620 --> 00:16:46.780
Which is pretty awesome, as in async and await.

00:16:46.780 --> 00:16:55.740
And so often, the models that we build for the databases are their own special thing.

00:16:55.740 --> 00:16:59.640
And then you've got to build maybe an API, and you might use Pydantic or something like that.

00:16:59.640 --> 00:17:07.760
But Pydantic's been really coming on strong as a super cool way to build object trees and object graphs and stuff.

00:17:07.760 --> 00:17:12.080
And so Pydantic is a perfect thing to say, well, let's just use that.

00:17:12.080 --> 00:17:13.520
Everyone already knows how to use that.

00:17:13.520 --> 00:17:17.840
And things like APIs can already exchange those on the wire.

00:17:17.840 --> 00:17:19.100
Yeah, yeah.

00:17:19.100 --> 00:17:21.220
And that's why I chose this.

00:17:23.160 --> 00:17:30.660
It's just such a neat combination of bringing the async and await stuff together, along with Pydantic,

00:17:30.660 --> 00:17:35.700
and saying, let's see if we can use those ideas for the basically for the ODM.

00:17:35.700 --> 00:17:36.820
So there's other ones.

00:17:36.820 --> 00:17:38.460
You know, Scott mentioned Mongo Engine.

00:17:38.460 --> 00:17:41.920
That's actually what I'm using right now for my MongoDB stuff in Python.

00:17:41.920 --> 00:17:43.920
It's Mongo Engine's pretty good.

00:17:43.920 --> 00:17:48.220
I feel like it's kind of wherever it's going to be.

00:17:48.220 --> 00:17:52.940
There's not a ton of excitement in terms of like new features and pushing stuff forward.

00:17:52.940 --> 00:17:58.200
For example, there's, to my knowledge, there's no async and await stuff happening in there.

00:17:58.200 --> 00:18:01.000
There's, I think it's synchronous.

00:18:01.000 --> 00:18:03.960
Possibly there's something that's happened that's changed up.

00:18:03.960 --> 00:18:05.840
But the last time I looked, it was synchronous still.

00:18:05.840 --> 00:18:07.260
Weeks ago, it was synchronous, yeah.

00:18:07.260 --> 00:18:07.820
Yeah, okay.

00:18:07.820 --> 00:18:09.980
That's much more recent than I've looked.

00:18:09.980 --> 00:18:11.800
And what are some of the other ones?

00:18:11.880 --> 00:18:15.880
I'm trying to think of some of the other MongoDB ODMs out there.

00:18:15.880 --> 00:18:20.020
I know in another language is probably like Mongoose in JavaScript.

00:18:20.020 --> 00:18:20.360
Yeah.

00:18:20.360 --> 00:18:24.220
Active record stuff for Ruby and things like that.

00:18:24.220 --> 00:18:24.880
Yeah, yeah.

00:18:24.880 --> 00:18:29.600
So a lot of these systems were based on the Django ORM model.

00:18:29.600 --> 00:18:36.980
So for example, like Mongo Engine is basically Django ORM, but adapted for documents in Mongo, right?

00:18:36.980 --> 00:18:39.340
Like the terminology and everything is quite similar.

00:18:39.940 --> 00:18:43.440
Being based on Pydantic, yours is a little bit different, right?

00:18:43.440 --> 00:18:47.980
I feel like there's a lot of interesting things you've, choices you've made.

00:18:47.980 --> 00:18:51.240
One, to be based on Pydantic and how that works.

00:18:51.240 --> 00:18:54.000
But two, we'll get into the API and stuff.

00:18:54.000 --> 00:19:00.420
But when you look at the API, I feel like you've chosen to be very near MongoDB's native query syntax or query language.

00:19:00.760 --> 00:19:08.420
So for example, instead of doing a select, you would do like a find or find one or the updates.

00:19:08.420 --> 00:19:13.720
And like a set operator is one of the things you can do, like a set a value on there.

00:19:13.720 --> 00:19:14.860
Was that conscious?

00:19:14.860 --> 00:19:18.700
Did it say, like, I'm going to try to be really close to MongoDB or what was the thinking there?

00:19:18.700 --> 00:19:22.180
When I started to work on Beanie, it was not Beanie.

00:19:22.520 --> 00:19:26.400
It was just a side project because, so yeah.

00:19:26.400 --> 00:19:29.400
On the very beginning, I started to play with FastAPI.

00:19:29.400 --> 00:19:33.360
It was a very modern web framework at that time.

00:19:33.360 --> 00:19:36.060
Now it's still modern and great web framework.

00:19:36.060 --> 00:19:39.980
But at that time, it was quite new around a few years ago.

00:19:39.980 --> 00:19:43.740
And this is a synchronous also and uses Pydantic under the hood.

00:19:43.740 --> 00:19:49.480
And there were no ODM, no sync ODM for Python and MongoDB.

00:19:49.480 --> 00:19:51.040
I had the same experience.

00:19:51.040 --> 00:19:54.100
Like, I wanted to use MongoDB with some FastAPI stuff.

00:19:54.100 --> 00:19:57.200
I'm like, there's not a great library that I can pick here.

00:19:57.200 --> 00:20:00.500
So I guess I'll just use SQLAlchemy or something, right?

00:20:00.500 --> 00:20:04.500
And what I did, I just started with Pydantic.

00:20:05.220 --> 00:20:07.260
I've got Motor.

00:20:07.260 --> 00:20:10.180
It is PyMongo.

00:20:10.180 --> 00:20:13.740
So yeah, this is an engine over PyMongo.

00:20:13.740 --> 00:20:16.220
And it is a synchronous engine.

00:20:16.220 --> 00:20:16.920
Yeah, yeah.

00:20:16.920 --> 00:20:24.220
Let's talk about Motor a little bit because I suspect that most people who work with MongoDB work with PyMongo.

00:20:24.220 --> 00:20:25.040
Right?

00:20:25.040 --> 00:20:31.380
When I opened the conversation, I said, the tools they give you are just, here's a dictionary to put in.

00:20:31.380 --> 00:20:32.860
And then I get dictionaries back out.

00:20:32.860 --> 00:20:36.860
I was exactly thinking of the PyMongo library.

00:20:36.860 --> 00:20:37.360
Right?

00:20:37.360 --> 00:20:39.640
And so what's this Motor thing?

00:20:39.640 --> 00:20:41.140
This is also from MongoDB.

00:20:41.140 --> 00:20:43.100
This is also from MongoDB, right?

00:20:43.100 --> 00:20:48.260
And it also reflects each method and function from PyMongo.

00:20:48.260 --> 00:20:54.240
But it's converted, let's say, into a synchronous method and function.

00:20:54.600 --> 00:21:01.780
So it uses the same, mostly the same syntax as MongoDB itself and as PyMongo also.

00:21:01.780 --> 00:21:02.080
Okay.

00:21:02.080 --> 00:21:02.740
Yeah.

00:21:02.740 --> 00:21:03.900
So it's a lot like PyMongo.

00:21:03.900 --> 00:21:12.380
It says Motor supports nearly every method PyMongo does, but Motor methods that do network I.O.

00:21:12.380 --> 00:21:13.500
are coroutines.

00:21:13.500 --> 00:21:16.080
So async and await type of things, right?

00:21:16.080 --> 00:21:17.480
Yeah.

00:21:17.640 --> 00:21:17.860
Yeah.

00:21:17.860 --> 00:21:18.480
Yeah.

00:21:18.480 --> 00:21:18.780
Yeah.

00:21:18.780 --> 00:21:29.380
And what I did, I just combined together Pydantic and Motor without any query builder stuff and other ODM fancy stuff.

00:21:29.380 --> 00:21:33.860
Just querying, using dictionaries, the same dictionaries as Motor does.

00:21:33.860 --> 00:21:37.340
And PyMongo for models and nothing more.

00:21:37.340 --> 00:21:38.500
Small library.

00:21:38.500 --> 00:21:40.120
It wasn't Bini at that time.

00:21:40.120 --> 00:21:43.460
It was an internal project just to play with FastAPI.

00:21:43.460 --> 00:21:50.340
And then after a few months of working, I decided probably I can make it open source.

00:21:50.340 --> 00:21:53.280
I came up with the name Bini.

00:21:53.280 --> 00:22:00.340
And mostly that's why I'm following MongoDB naming, not select, not join, et cetera.

00:22:00.340 --> 00:22:04.880
Just find the many, find one, update, et cetera.

00:22:04.880 --> 00:22:11.820
Because I'm using, I started to use directly Motor functions inside of Pydantic stuff.

00:22:11.820 --> 00:22:18.200
And only after that, I just started to update Bini stuff with more fancy stuff.

00:22:18.200 --> 00:22:19.680
Yeah.

00:22:19.680 --> 00:22:28.220
So it was a pretty close match to like, how do I take Motor and just make it send and receive Pydantic instead of send and receiving straight dictionaries, right?

00:22:28.220 --> 00:22:28.620
Yeah.

00:22:28.620 --> 00:22:33.000
So the first project was just a parser from Motor to Pydantic and back.

00:22:33.000 --> 00:22:34.460
Cool.

00:22:34.460 --> 00:22:35.860
Well, I think it's really neat.

00:22:35.860 --> 00:22:40.460
And I, you know, however you got there, I think it's really nice that you have the API that matches that.

00:22:40.460 --> 00:22:50.320
Because then I can go to the MongoDB documentation and, or I can find some other example that somebody has on, well, here's how you do it with PyMongo.

00:22:50.320 --> 00:22:54.480
And you're like, well, that looks really close to the same thing over here.

00:22:54.480 --> 00:22:56.600
So we can talk about that.

00:22:56.900 --> 00:23:01.020
Now, I want to dig into some of the other features and stuff there.

00:23:01.020 --> 00:23:04.800
For example, data and schema migrations and support and whatnot.

00:23:04.800 --> 00:23:05.420
That's pretty cool.

00:23:05.420 --> 00:23:05.860
Yeah.

00:23:05.860 --> 00:23:08.540
But let's talk about modeling data here.

00:23:08.540 --> 00:23:13.720
That's, you know, the first letter in ODM, the object bit.

00:23:14.360 --> 00:23:16.020
So what does it look like?

00:23:16.020 --> 00:23:21.700
I know, well, maybe not everyone listening knows what it looks like to model something with Pydantic.

00:23:21.700 --> 00:23:27.800
So maybe we could give us a Pydantic example, and then we could talk about how to turn that into something that can be stored in MongoDB.

00:23:27.800 --> 00:23:28.240
Yeah.

00:23:28.240 --> 00:23:28.300
Yeah.

00:23:28.300 --> 00:23:29.920
Pydantic is base model.

00:23:29.920 --> 00:23:32.680
The main class of Pydantic is base model.

00:23:32.680 --> 00:23:35.120
And you inherit everything from base model.

00:23:35.120 --> 00:23:37.820
And it looks like data classes of Python.

00:23:37.820 --> 00:23:43.800
But it also supports validation and parsing, which data classes does.

00:23:43.960 --> 00:23:44.200
Yeah.

00:23:44.200 --> 00:23:46.380
And the conversions and stuff, it's really cool.

00:23:46.380 --> 00:23:49.140
That's one of the things I think Pydantic is so good about.

00:23:49.140 --> 00:23:49.600
Yeah.

00:23:49.840 --> 00:24:02.320
If you look at their example, the way you define these classes is you have a class and you just as a class level, not instance level, you'd say name, colon, or variable, colon, type, variable, colon, type.

00:24:02.320 --> 00:24:08.540
So in this example, you've got a category, say name, colon, str, description, colon, str.

00:24:08.540 --> 00:24:11.400
And this just means this thing has two fields.

00:24:11.400 --> 00:24:12.260
They're both strings.

00:24:12.260 --> 00:24:19.160
But the Pydantic example on their website has got some kind of model where it's got multiple fields.

00:24:19.220 --> 00:24:22.700
And one of them is a list of things that are supposed to be numbers.

00:24:22.700 --> 00:24:33.220
And if you pass it a data and that list happens to have a list of strings that can be parsed to numbers, it'll just convert it straight to numbers as part of loading it.

00:24:33.220 --> 00:24:34.400
It's really, really nice, right?

00:24:34.400 --> 00:24:34.860
Yeah.

00:24:34.860 --> 00:24:35.240
Yeah.

00:24:35.240 --> 00:24:36.020
This is a great feature.

00:24:36.020 --> 00:24:36.460
Yeah.

00:24:36.460 --> 00:24:40.920
This exchange across, especially across either files or API boundaries, right?

00:24:40.920 --> 00:24:44.720
Somebody writes some code and they send you some data.

00:24:45.340 --> 00:24:51.580
Well, if they didn't really use the native data type, but it could be turned into it, then, you know, that's really nice.

00:24:51.580 --> 00:24:55.660
And you also can add your own parser, like your own validation step.

00:24:56.020 --> 00:25:02.840
And then it will convert this here rule, like from string to number, to date.

00:25:02.840 --> 00:25:04.080
So, yeah.

00:25:04.080 --> 00:25:07.060
And the Bini uses the same schema.

00:25:07.060 --> 00:25:07.680
The same.

00:25:07.680 --> 00:25:09.680
So, document is a main class of Bini.

00:25:09.980 --> 00:25:19.660
And it's inherited from Pydantic base model and inherits all the methods, all the aspects of base model of Pydantic.

00:25:19.660 --> 00:25:24.440
So, it can use the same validation stuff, the same parsing stuff, and et cetera.

00:25:24.440 --> 00:25:24.740
Right.

00:25:24.740 --> 00:25:29.900
So, whatever people know and think about Pydantic, that's what the modeling looks like here.

00:25:29.900 --> 00:25:43.200
I guess the one difference is when you talk about, when you model the top-level documents that are going to be stored and queried in MongoDB, you don't derive from base model, right?

00:25:43.200 --> 00:25:44.620
Drive from something else?

00:25:44.620 --> 00:25:44.960
Yeah.

00:25:44.960 --> 00:25:45.900
From document.

00:25:45.900 --> 00:25:46.520
Right.

00:25:46.520 --> 00:25:48.080
And document, it comes from Bini.

00:25:48.080 --> 00:25:53.500
But that document itself is derived from base model, ultimately, right?

00:25:53.500 --> 00:25:59.060
So, even though you got to do this little more specialized class, it's still a Pydantic model in its behavior, right?

00:25:59.060 --> 00:25:59.340
Yeah.

00:25:59.340 --> 00:25:59.980
Yeah, correct.

00:25:59.980 --> 00:26:06.000
That's why you can use it as a response model, for example, in FastAPI, if you're familiar with.

00:26:06.000 --> 00:26:06.620
Yes.

00:26:06.620 --> 00:26:12.300
Because it uses identity base models and submodels of base models.

00:26:12.300 --> 00:26:15.500
Yeah, if people haven't seen that, let me, here's an example.

00:26:15.500 --> 00:26:27.560
One of the things you can do with FastAPI that's super, super neat is you can go and say, as part of returning the values out of the API, one of the things you can do in the decorator is you can just say,

00:26:28.220 --> 00:26:30.480
the response model is some Pydantic class.

00:26:30.480 --> 00:26:41.360
And if you just add that one line and that class happens to be a Pydantic model, you get all sorts of live documentation and API definition stuff.

00:26:41.360 --> 00:26:43.340
And there's even code that will consume that.

00:26:43.420 --> 00:26:51.000
So, I built this little weather thing in FastAPI for one of my classes over at weather.talkpython.fm.

00:26:51.000 --> 00:26:52.220
And you just go to slash docs.

00:26:52.220 --> 00:26:57.080
It pulls up, oh, here's all the APIs you can call.

00:26:57.080 --> 00:27:01.640
And here's like the return value with, you know, exactly what the schema is.

00:27:01.640 --> 00:27:03.720
And all of that's just from that one line of code.

00:27:04.180 --> 00:27:07.400
So, what you're saying is you could do that with these database models.

00:27:07.400 --> 00:27:11.680
You could just say, I'm going to return this directly from my API back to you.

00:27:11.680 --> 00:27:17.640
And if you just say response model equals your data entity model, you get all this for free, right?

00:27:17.840 --> 00:27:20.180
Yeah, it's also invalidated based on this model.

00:27:20.180 --> 00:27:28.400
If you're, for example, using some external source of data and they changed schema and you received it and responded back.

00:27:28.800 --> 00:27:34.880
And if the format is not correct, it just will erase an error and you can gracefully handle this.

00:27:34.880 --> 00:27:35.100
Yeah.

00:27:35.100 --> 00:27:35.440
Nice.

00:27:35.440 --> 00:27:38.740
Yeah, the error that it returns is also meaningful.

00:27:38.740 --> 00:27:45.620
Like, the third entry in this list cannot be parsed to an integer rather than, you know, 400 invalid data.

00:27:45.620 --> 00:27:46.100
Good luck.

00:27:46.100 --> 00:27:51.240
Okay, so we've modeled these objects in here.

00:27:51.240 --> 00:27:53.900
And I guess one more thing to throw in while we're talking about modeling.

00:27:54.460 --> 00:27:59.540
In your example, right at the bottom of the GitHub page, you have a category which has the name and description.

00:27:59.540 --> 00:28:02.880
And you have a product that has its own name and description.

00:28:02.880 --> 00:28:04.780
And then a price.

00:28:04.780 --> 00:28:07.620
And the product has a category.

00:28:07.620 --> 00:28:10.420
And here you just say colon category, right?

00:28:10.420 --> 00:28:18.040
And that would make, I guess, would make this, in this case, an embedded document inside of the product document, right?

00:28:18.040 --> 00:28:19.180
Yeah, totally correct.

00:28:19.180 --> 00:28:21.160
It will just create embedded documents.

00:28:21.160 --> 00:28:23.160
Yeah, so the way that you model.

00:28:23.660 --> 00:28:29.740
This is why Pydantic's a really good match because Pydantic allows you to compose these Pydantic models in this, like, hierarchy.

00:28:29.740 --> 00:28:37.320
You can have, like, lists of other Pydantic models within a Pydantic model, which is exactly the same modeling you get with document databases like Mongo, right?

00:28:37.320 --> 00:28:38.280
Yeah, yeah.

00:28:38.280 --> 00:28:39.740
So you don't have to do anything.

00:28:39.740 --> 00:28:42.540
It's like, it just, it keeps modeling the things I wanted to model.

00:28:42.540 --> 00:28:42.980
Cool.

00:28:42.980 --> 00:28:52.360
So, in other database systems, like SQLAlchemy or something, you would be able to say, this field is nullable.

00:28:52.360 --> 00:28:56.900
Or not, or it's required, or something like that.

00:28:56.900 --> 00:28:59.320
So how do you say that in this model?

00:28:59.320 --> 00:29:04.700
If it's nullable, yeah, I can just use Python type in optional.

00:29:04.700 --> 00:29:08.120
It's not a class, but optional, optional.

00:29:08.120 --> 00:29:09.120
Yeah.

00:29:09.120 --> 00:29:10.580
Mark it as optional.

00:29:10.580 --> 00:29:14.160
Like optional bracket str versus just str, right?

00:29:14.160 --> 00:29:14.440
Yeah.

00:29:14.640 --> 00:29:18.760
And I guess for a default value, you just set it equal to its default value, right?

00:29:18.760 --> 00:29:19.380
You're right.

00:29:19.380 --> 00:29:28.560
But if it's optional, so it's explicitly marked here, but Pydantic allows you to use optional without default value, and default would be none in that case.

00:29:28.560 --> 00:29:30.540
Because Pydantic is...

00:29:30.540 --> 00:29:34.220
I'm thinking, like, false or none or something like that.

00:29:34.220 --> 00:29:35.840
In this case, you probably wouldn't make it optional.

00:29:35.840 --> 00:29:37.460
You would just give it a default value, right?

00:29:37.460 --> 00:29:37.860
Yeah.

00:29:37.860 --> 00:29:38.580
Correct.

00:29:38.700 --> 00:29:44.480
Now, one of the things that I can do in, say, Mongo Engine, is I can say the default is a function.

00:29:44.480 --> 00:29:51.540
Because maybe this is incredibly common in my world, is I want to know when something was created.

00:29:51.540 --> 00:29:53.440
You know, when did this user create an account?

00:29:53.440 --> 00:29:54.940
When was this purchase made?

00:29:54.940 --> 00:29:57.320
When did this person watch this video or whatever?

00:29:57.320 --> 00:30:01.740
And so almost all of my models have some kind of created date type of thing.

00:30:01.740 --> 00:30:07.700
And the default value is datetime.datetime.now without parentheses.

00:30:07.700 --> 00:30:11.260
You know, like, I want you to call the now function when you do an insert.

00:30:11.260 --> 00:30:13.420
How would I model that in Beanie?

00:30:13.420 --> 00:30:15.500
Again, you can use Pydantic stuff here.

00:30:15.500 --> 00:30:17.180
So I really like Pydantic.

00:30:17.180 --> 00:30:19.080
They did half a fork.

00:30:19.080 --> 00:30:22.540
You can use field class, equal field.

00:30:22.540 --> 00:30:29.660
And inside of that, you can use default factory parameter, where you can just provide function you want to.

00:30:29.660 --> 00:30:29.960
Okay.

00:30:29.960 --> 00:30:31.180
Oh, that's right.

00:30:31.180 --> 00:30:36.640
So you can, instead of setting it, like, you could say it's a string, but its value is, what is it?

00:30:36.820 --> 00:30:38.380
You say field factory or something?

00:30:38.380 --> 00:30:41.100
You said it to be one of these things that Pydantic knows about.

00:30:41.100 --> 00:30:42.200
Didn't get you.

00:30:42.200 --> 00:30:42.460
Sorry.

00:30:42.920 --> 00:30:44.940
Is that thing that I'm setting it to equal to?

00:30:44.940 --> 00:30:46.240
Does that come out of Pydantic?

00:30:46.240 --> 00:30:47.720
Like, that's not a Beanie thing?

00:30:47.720 --> 00:30:48.820
This is Pydantic stuff.

00:30:48.820 --> 00:30:49.060
Yeah.

00:30:49.060 --> 00:30:51.160
Default factory stuff.

00:30:51.160 --> 00:30:54.320
But there is interesting Beanie feature about this.

00:30:55.120 --> 00:30:57.880
I can show you in another code example here.

00:30:57.880 --> 00:31:03.440
For example, if you want to use not create at, field but updated at.

00:31:03.440 --> 00:31:07.380
So, and each time when you update, you want to update time.

00:31:07.380 --> 00:31:10.540
And for that case, default factory will not work.

00:31:10.540 --> 00:31:11.400
Because default factory...

00:31:11.400 --> 00:31:12.420
It's already got a value.

00:31:12.420 --> 00:31:12.680
Yeah.

00:31:12.680 --> 00:31:13.440
It's only on create.

00:31:13.440 --> 00:31:13.700
Yeah.

00:31:13.700 --> 00:31:14.060
Yeah.

00:31:14.060 --> 00:31:19.600
And Beanie allows you to use event-based actions for this.

00:31:19.600 --> 00:31:22.940
And you can just create a method of the class.

00:31:22.940 --> 00:31:27.400
And there, mark it like run before event.

00:31:27.400 --> 00:31:28.440
Before event decorator.

00:31:28.440 --> 00:31:28.660
Yeah.

00:31:28.660 --> 00:31:30.020
Before event.

00:31:30.020 --> 00:31:33.980
And inside of this, you can just write your logic.

00:31:33.980 --> 00:31:37.420
Self updated at field equals current time.

00:31:37.420 --> 00:31:38.740
And it will work.

00:31:38.740 --> 00:31:43.500
For events, you will choose like insert, replace, and anything else.

00:31:43.500 --> 00:31:43.780
Yeah.

00:31:43.780 --> 00:31:44.960
This is one of the new features.

00:31:44.960 --> 00:31:46.440
We're going to talk about some of the new things.

00:31:46.440 --> 00:31:49.160
But one of them are these event actions.

00:31:49.300 --> 00:31:56.720
So, you can say before the insert event or before the save event happens or after the

00:31:56.720 --> 00:32:01.580
thing's been replaced or any of those types of things, you can sort of put a decorator and

00:32:01.580 --> 00:32:06.400
say run this function when that happens on this type or in this collection effectively.

00:32:06.400 --> 00:32:06.680
Right?

00:32:06.680 --> 00:32:06.880
Yeah.

00:32:06.880 --> 00:32:07.620
Very, very cool.

00:32:07.620 --> 00:32:07.980
All right.

00:32:07.980 --> 00:32:10.060
We're going to dive back into that because that's good.

00:32:10.060 --> 00:32:12.200
And so, that would be actually a pretty good way, wouldn't it?

00:32:12.200 --> 00:32:14.920
Just do an event on insert.

00:32:14.920 --> 00:32:18.600
And when on insert happens, set my created date to be datetime.now.

00:32:19.000 --> 00:32:19.180
Yeah.

00:32:19.180 --> 00:32:19.540
Okay.

00:32:19.540 --> 00:32:20.180
Good.

00:32:20.180 --> 00:32:20.340
Good.

00:32:20.340 --> 00:32:25.040
And then, I guess, the other part that's interesting now is doing queries and inserts on this.

00:32:25.040 --> 00:32:30.080
So, you would create your objects just exactly the same as you would Pydantic, right?

00:32:30.080 --> 00:32:33.060
Just class name, key value, key value, key value.

00:32:33.060 --> 00:32:34.240
Like that?

00:32:34.240 --> 00:32:34.680
Yeah.

00:32:35.020 --> 00:32:40.680
Or even parse object like category dot parse object and dictionary with values.

00:32:40.680 --> 00:32:41.440
And yeah.

00:32:41.440 --> 00:32:43.640
If you want to parse more than one object.

00:32:43.640 --> 00:32:44.140
Right.

00:32:44.140 --> 00:32:44.140
If it's coming.

00:32:44.140 --> 00:32:44.740
Okay.

00:32:44.740 --> 00:32:47.240
Or if it's coming out of an API or something like that, right?

00:32:47.580 --> 00:32:49.660
And then you would say, here's where it gets interesting.

00:32:49.660 --> 00:32:56.340
You say await object dot insert or await class dot find one, right?

00:32:56.340 --> 00:32:58.840
Or await set some value there.

00:32:58.840 --> 00:32:59.480
Yeah.

00:32:59.480 --> 00:33:02.300
Because this is, I think, await library.

00:33:02.520 --> 00:33:07.640
So, that's why you have to use await here based on the asynchronous nature of the library.

00:33:07.640 --> 00:33:07.980
Sure.

00:33:07.980 --> 00:33:09.200
And that's the whole point, right?

00:33:09.200 --> 00:33:11.680
Is that it's built around that.

00:33:11.680 --> 00:33:15.900
I think, I mean, there's ways in which you could use it in asynchronous situations, right?

00:33:15.900 --> 00:33:20.260
You could always create your own event loop and just run the function and just block right that way.

00:33:20.260 --> 00:33:23.760
Or use something like unsync, which maybe we'll touch on a little bit later.

00:33:23.760 --> 00:33:25.160
But yeah.

00:33:25.160 --> 00:33:32.400
So, but if you're doing something like Flask or FastAPI, where the functions themselves,

00:33:32.400 --> 00:33:38.440
the thing being called by the framework is already handling it, it's basically no work, right?

00:33:38.440 --> 00:33:42.800
You just make an async method and then you just await things and you get this,

00:33:42.800 --> 00:33:44.980
you unlock this scalability right there.

00:33:44.980 --> 00:33:45.340
Yeah.

00:33:45.340 --> 00:33:45.920
Yeah.

00:33:45.920 --> 00:33:50.320
I think modern Python world is pretty everywhere asynchronous already.

00:33:50.320 --> 00:33:56.360
I don't know if I think framework development now, like most of them are asynchronous.

00:33:56.360 --> 00:33:58.060
Yeah, exactly.

00:33:58.060 --> 00:34:02.700
I think with Flask, there's limited support for async.

00:34:02.700 --> 00:34:07.640
And then if you want full async, you have to use court for the moment, but maybe stuff's happening.

00:34:07.640 --> 00:34:11.000
I know Django is working on an async story as well.

00:34:11.000 --> 00:34:11.000
Yeah.

00:34:11.000 --> 00:34:15.720
I think the big holdup for like full on async and Django has actually been the Django ORM.

00:34:15.720 --> 00:34:17.840
So this would fix that.

00:34:17.840 --> 00:34:24.680
Although, does it make any sense to use Beanie or another ODM or something like that out with Django?

00:34:24.680 --> 00:34:28.120
Or I mean, it's so tied into its ORM itself, right?

00:34:28.340 --> 00:34:31.960
I think for Django, it's a little bit tricky.

00:34:31.960 --> 00:34:31.960
Yeah.

00:34:31.960 --> 00:34:38.240
Probably things changed, but Django works with relative databases, yeah, with SQL databases,

00:34:38.240 --> 00:34:41.200
and also the Django model stuff.

00:34:41.200 --> 00:34:41.700
Yeah.

00:34:41.700 --> 00:34:45.300
It's possible.

00:34:45.300 --> 00:34:46.340
Definitely it's possible.

00:34:46.340 --> 00:34:47.460
It's Python.

00:34:47.460 --> 00:34:48.360
Everything is possible.

00:34:48.360 --> 00:34:49.660
Yeah.

00:34:49.660 --> 00:34:59.220
It's just, you know, if you're fighting against the system, then you maybe should just choose a different framework rather than try to fight the way that it works, right?

00:34:59.220 --> 00:35:08.580
Like if you're going to choose something like Django that gives you a lot of opinionated workflow, but a lot of benefit if you stay in that workflow, then just, I'd say, follow that.

00:35:08.580 --> 00:35:11.340
But the other frameworks are pretty wide open, right?

00:35:11.340 --> 00:35:13.900
You could easily use this with Flask.

00:35:13.900 --> 00:35:16.200
You could use this with pretty much anything.

00:35:16.200 --> 00:35:18.600
It's better if it supports async, right?

00:35:18.600 --> 00:35:21.220
There's not a synchronous version, is there?

00:35:21.220 --> 00:35:26.420
Yeah, there is no synchronous version of this, unless it uses a motor insight, as we said.

00:35:26.420 --> 00:35:30.740
I'm thinking about by Mongo support without motor.

00:35:30.740 --> 00:35:33.440
In that case, it would be just synchronous.

00:35:33.440 --> 00:35:35.080
I would think that would be great, honestly.

00:35:35.080 --> 00:35:38.760
I'm very excited that this is async first.

00:35:38.760 --> 00:35:40.260
I think that's really good.

00:35:40.260 --> 00:35:41.960
But let me give you an example.

00:35:41.960 --> 00:35:48.300
So for my website, I would love to be able to make all the view methods be async, right?

00:35:48.300 --> 00:35:50.220
That would give it a little bit more scalability.

00:35:50.640 --> 00:35:56.480
It's pretty quick, like I said, but it would still be way more scalable if it could do more while it's waiting on the server.

00:35:56.480 --> 00:36:00.800
But at the same time, I have all these little scripts that I run.

00:36:00.800 --> 00:36:15.160
And here's how I want to go and just show me all of the podcast episodes who is sponsoring them to make sure that if I had to reorder things, I don't mess up some sponsorship detail.

00:36:15.160 --> 00:36:21.240
Or show me all the people who have signed up for this class this month and whatnot.

00:36:21.880 --> 00:36:23.100
Those little scripts, right?

00:36:23.100 --> 00:36:28.520
It would be nice if I could just say these little things are going to be synchronous because it's the easier programming model.

00:36:28.520 --> 00:36:35.900
I don't have to do that.

00:36:35.900 --> 00:36:36.540
I don't have to do that.

00:36:36.540 --> 00:36:37.440
What do you think of that?

00:36:37.440 --> 00:36:38.300
I do agree totally.

00:36:38.300 --> 00:36:39.900
But I have limited time.

00:36:39.900 --> 00:36:40.380
That's why.

00:36:42.380 --> 00:36:43.640
Yes, of course you do.

00:36:43.640 --> 00:36:51.500
And I guess that pull requests are accepted or contributions are accepted if there's meaningful good work, right?

00:36:51.500 --> 00:36:52.220
Yeah, sure.

00:36:52.220 --> 00:36:52.740
Sure.

00:36:53.020 --> 00:36:53.420
Yeah, cool.

00:36:53.420 --> 00:36:56.320
I'm not suggesting that it's like a super shortcoming, right?

00:36:56.320 --> 00:37:00.680
It's not that hard to create an async method and just call async io.run on it.

00:37:00.680 --> 00:37:09.220
But having this ability to say this situation is really a synchronous one, don't need to go through the hoops to make that happen.

00:37:09.220 --> 00:37:15.260
Even I had this situation in the past, you know, and I had to create a loop inside of synchronous function.

00:37:16.860 --> 00:37:17.760
Yeah, exactly.

00:37:17.760 --> 00:37:18.260
Exactly.

00:37:18.260 --> 00:37:26.040
I think that's worth touching on a little bit because people say that async and await is like a virus or something.

00:37:26.040 --> 00:37:37.740
Like once one part of your code base gets async, like it sort of expands upward so that anything that might touch that function itself has to become async and then its colors have to become async and so on.

00:37:37.740 --> 00:37:41.440
In the most naive, straightforward way, that's totally true.

00:37:41.440 --> 00:37:46.640
But it's not true if you don't want it to be, right?

00:37:46.640 --> 00:37:54.060
Like halfway through that function, that call stack, you could say on this part, I'm going to create an async io event loop and just run it and just block.

00:37:54.060 --> 00:37:54.780
Right?

00:37:54.780 --> 00:37:57.880
And anyone who calls that function doesn't have to know it's async io, right?

00:37:57.880 --> 00:37:58.140
Yeah.

00:37:58.140 --> 00:38:01.340
You can sort of stop that async propagation.

00:38:01.340 --> 00:38:05.780
And that sounds like that's what you're talking about, like creating a loop and running it inside of a synchronous function.

00:38:05.780 --> 00:38:06.280
Yeah.

00:38:06.280 --> 00:38:08.560
But this looks really super ugly.

00:38:08.560 --> 00:38:10.000
Yeah.

00:38:10.000 --> 00:38:14.920
You even don't have any chance to await this.

00:38:14.920 --> 00:38:16.620
You're creating a task.

00:38:16.620 --> 00:38:17.800
Yeah.

00:38:17.800 --> 00:38:18.200
Yeah.

00:38:18.200 --> 00:38:20.800
It is a little bit weird if you haven't seen it.

00:38:20.800 --> 00:38:21.800
I, okay.

00:38:21.800 --> 00:38:24.440
So it's time for my requisites required.

00:38:24.440 --> 00:38:32.440
Shout out to the unsync library, which I think is just so neat in the way that it simplifies async and await in Python.

00:38:32.440 --> 00:38:41.860
We're talking about this just a little bit before I hit record, but it has basically two things that are frustrations that make this kind of stuff.

00:38:41.860 --> 00:38:42.920
We're talking about a little bit harder.

00:38:42.920 --> 00:38:47.780
Like one, wouldn't it be nice if you could just call an async function and it just runs?

00:38:47.780 --> 00:38:52.240
Like I want to write this to the log, but let's do that asynchronously and just go, go right to the log.

00:38:52.240 --> 00:38:53.600
I don't want to see from you again.

00:38:53.600 --> 00:38:54.560
I want to hear from you again.

00:38:54.560 --> 00:38:55.860
Go put it in the log.

00:38:56.040 --> 00:38:57.280
I'm going to keep on working, right?

00:38:57.280 --> 00:38:58.900
You can't do that with Python's async.

00:38:58.900 --> 00:39:01.500
You've got to like put it in a loop and make sure the loop is running.

00:39:01.500 --> 00:39:04.120
So this fire and forget model doesn't work.

00:39:04.120 --> 00:39:05.760
And the other is you can't block.

00:39:05.760 --> 00:39:09.580
You can't call dot result to make it block.

00:39:09.580 --> 00:39:11.500
If it's not done, it's going to throw an exception, right?

00:39:11.840 --> 00:39:17.680
So this unsync thing lets you put an at unsync decorator on an async method.

00:39:17.680 --> 00:39:23.680
And then if you need to stop the async propagation, you just call dot result and it'll block and then give you the answer.

00:39:23.680 --> 00:39:24.820
Builds done.

00:39:24.820 --> 00:39:30.200
And there's all sorts of cool integration with like threads plus asyncio plus multiprocessing.

00:39:30.200 --> 00:39:34.460
It's, I think this fixes a lot of those like little weird edge cases.

00:39:34.700 --> 00:39:40.160
I think I will try this after this podcast and will create a page on documentation.

00:39:40.160 --> 00:39:43.780
So if you need to try it out and see if it's a good idea.

00:39:43.780 --> 00:39:46.480
It might not be a good fit, but I think it is actually.

00:39:46.480 --> 00:39:47.260
I think it would be.

00:39:47.260 --> 00:39:47.980
I will try.

00:39:47.980 --> 00:39:49.420
So if it will not work, I will not.

00:39:49.420 --> 00:39:55.100
So basically the way it works is it creates, when it starts up, it creates a background thread.

00:39:55.100 --> 00:39:59.120
That its only job is to run an asyncio event loop.

00:39:59.120 --> 00:40:04.360
And then when you do stuff, when you call functions on this, instead of running the main thread, it just runs on that background thread.

00:40:04.520 --> 00:40:08.000
And when you block, it just waits for that background thread to finish its work and stuff like that.

00:40:08.000 --> 00:40:12.440
So it's, that's sort of the trick around it, but super big fan of unsync.

00:40:12.440 --> 00:40:17.720
I think it's, it does a lot of good for these situations that we're talking about where you're like, okay, almost all the time.

00:40:17.720 --> 00:40:22.360
And definitely in production, I want it async, but every now and then I want it to just stop.

00:40:22.360 --> 00:40:29.080
Talk Python To Me is partially supported by our training courses.

00:40:29.080 --> 00:40:31.840
We have a new course over at Talk Python.

00:40:32.580 --> 00:40:33.740
HTMLX plus Flask.

00:40:33.740 --> 00:40:36.060
Modern Python web apps hold the JavaScript.

00:40:36.060 --> 00:40:40.240
HTMLX is one of the hottest properties in web development today.

00:40:40.240 --> 00:40:41.220
And for good reason.

00:40:41.220 --> 00:40:46.320
You might even remember all the stuff we talked about with Carson Gross back on episode 321.

00:40:46.320 --> 00:40:53.820
HTMLX, along with the libraries and techniques we introduced in our new course, will have you writing the best Python web apps you've ever written.

00:40:53.820 --> 00:40:57.380
Clean, fast, and interactive, all without that front-end overhead.

00:40:57.700 --> 00:41:09.980
If you're a Python web developer that has wanted to build more dynamic, interactive apps, but don't want to or can't write a significant portion of your app in rich front-end JavaScript frameworks, you'll absolutely love HTMLX.

00:41:10.540 --> 00:41:15.960
Check it out over at talkpython.fm/HTMX or just click the link in your podcast player show notes.

00:41:18.520 --> 00:41:20.440
So let's talk about some of the other features.

00:41:20.440 --> 00:41:26.460
Back to this example here, there's one thing I wanted to highlight that I think was really neat that I saw.

00:41:26.460 --> 00:41:29.580
So you've got the standard.

00:41:29.580 --> 00:41:34.740
I've created an object that goes in the database, and I call insert, and I await that.

00:41:34.740 --> 00:41:35.940
That puts it in the database, right?

00:41:35.940 --> 00:41:36.380
Yeah.

00:41:36.500 --> 00:41:38.240
So I don't see a return value here.

00:41:38.240 --> 00:41:42.880
Does that actually set the ID on this thing that's being inserted after that function call?

00:41:42.880 --> 00:41:44.120
It updates.

00:41:44.120 --> 00:41:44.920
Okay.

00:41:44.920 --> 00:41:45.300
Perfect.

00:41:45.300 --> 00:41:46.300
Yeah.

00:41:46.300 --> 00:41:48.600
So .id is good to go after that, right?

00:41:48.600 --> 00:41:48.980
Yeah.

00:41:48.980 --> 00:41:49.460
Yeah.

00:41:49.460 --> 00:41:49.860
Okay, cool.

00:41:49.860 --> 00:41:52.900
And then the other one, you've got your await find one.

00:41:53.460 --> 00:41:57.620
The filter syntax is the first thing I wanted to talk about, which I think is really nice.

00:41:57.620 --> 00:41:58.920
Thank you.

00:41:58.920 --> 00:42:08.080
So even though these things are, does it have to be one of these indexed ones, or can you do these queries of the style on any of these?

00:42:08.080 --> 00:42:12.960
Could I do a category or a description equals something or a name equals something?

00:42:12.960 --> 00:42:13.400
Yeah.

00:42:13.400 --> 00:42:13.920
Yeah, sure.

00:42:13.920 --> 00:42:14.960
You can do it with everything.

00:42:14.960 --> 00:42:25.620
And you can do it even in the same line, in find one, price less than 10, comma, and name equals, I don't know, your name.

00:42:25.620 --> 00:42:27.620
So it will work.

00:42:27.620 --> 00:42:27.960
Nice.

00:42:27.960 --> 00:42:39.080
So the way that you would say, I want to find the product, or all the products, that has a price less than 10, is you just say, in this case, a product is a class with a price field.

00:42:39.080 --> 00:42:42.280
You just say product.price less than 10, right?

00:42:42.340 --> 00:42:45.220
Just like you would in an if statement or a while loop or something like that.

00:42:45.220 --> 00:42:45.440
Yeah.

00:42:45.440 --> 00:42:58.400
This is really nice because the alternative is something like what you have in Mongo Engine, where what you would say is you would say price underscore underscore LLT equals 10.

00:42:58.400 --> 00:42:58.720
Yeah.

00:42:58.720 --> 00:42:59.360
Right?

00:42:59.360 --> 00:43:03.920
You would say, like, separate the operators on the field with double underscores.

00:43:03.920 --> 00:43:07.560
And so LT means less than, and then you equal the value you want it to be less than.

00:43:07.560 --> 00:43:10.080
And that is entirely not natural.

00:43:10.080 --> 00:43:11.140
It's not horrible.

00:43:11.920 --> 00:43:15.960
You can get used to it, but it sure isn't the same as price less than 10.

00:43:15.960 --> 00:43:16.820
Right?

00:43:16.820 --> 00:43:17.000
Yeah.

00:43:17.000 --> 00:43:17.740
That is really nice.

00:43:17.740 --> 00:43:22.880
On the very beginning, when I told that I was Django developer, not Python developer, it was about this.

00:43:22.880 --> 00:43:29.400
Because I knew how to do this stuff about Django, but it's not Python syntax, honestly.

00:43:29.400 --> 00:43:31.800
It's Django syntax, which moved to.

00:43:32.480 --> 00:43:32.880
Exactly.

00:43:32.880 --> 00:43:35.040
So you can do these natural queries.

00:43:35.040 --> 00:43:38.940
You got, like, less than, greater than, equal, not equal to, and so on.

00:43:38.940 --> 00:43:39.360
Yeah, yeah.

00:43:39.360 --> 00:43:45.360
For if it was none, I mean, thing is none is the most natural way, but you would just say equal, equal none.

00:43:45.360 --> 00:43:46.940
Is that how you would test this?

00:43:46.940 --> 00:43:47.320
Yeah.

00:43:47.320 --> 00:43:48.660
You cannot hear.

00:43:48.660 --> 00:43:50.960
So it's not supported to use is.

00:43:51.260 --> 00:43:51.720
That's fine.

00:43:51.720 --> 00:43:53.080
You can use only equal.

00:43:53.080 --> 00:44:00.660
It's better than underscore, you know, price equals 10 or equals none, just as an assignment.

00:44:00.660 --> 00:44:01.660
That's even weirder.

00:44:01.660 --> 00:44:02.260
So that's cool.

00:44:03.100 --> 00:44:16.660
Then the other thing that I thought was neat is so often in these ORMs, and it is worse in the Mongo story because each record that comes back represents more of the data, right?

00:44:16.660 --> 00:44:24.680
In this case, you've got a product, and the product has a category, whereas those might be two separate tables in a relational database.

00:44:24.680 --> 00:44:28.240
So the problem is I get one of these objects back from the database.

00:44:28.500 --> 00:44:36.420
I make a small change to it, like I want to change the name, and then I call save, and it's going to completely write everything back to the database, right?

00:44:36.420 --> 00:44:39.220
It's going to override everything, which can be a big problem.

00:44:39.220 --> 00:44:52.660
There's a couple of solutions you have for that, and one is you have the in-place update operators, like set, and I'm guessing do you have like increment and decrement and add to set and those kinds of things?

00:44:52.660 --> 00:44:55.700
Yeah, literally everything from which MongoDB supports.

00:44:55.700 --> 00:44:56.380
Yeah.

00:44:56.380 --> 00:44:56.740
Right.

00:44:56.820 --> 00:45:04.060
So in this case, you can say product.set, and then product name is gold bar, right?

00:45:04.060 --> 00:45:05.940
Rather than what was it before?

00:45:05.940 --> 00:45:08.060
It was Tony's or something like that, right?

00:45:08.060 --> 00:45:08.300
Yeah.

00:45:08.300 --> 00:45:14.960
And that'll do a MongoDB dollar set operation, which is an atomic operation.

00:45:14.960 --> 00:45:20.580
So somebody else could be updating, say, the category at the same time and sort of transactionally safe.

00:45:20.580 --> 00:45:23.820
And so this way you're both way more efficient.

00:45:23.820 --> 00:45:27.820
And it's also safer that you're not possibly overriding other changes.

00:45:27.820 --> 00:45:28.320
Yeah.

00:45:28.320 --> 00:45:37.060
And also in current version, it's possible to, so Beanie tracks all the changes of the object.

00:45:37.060 --> 00:45:42.300
And when you call instead of set, you can call a safe changes.

00:45:42.300 --> 00:45:48.300
And it will call set inside for all the changes which was happened with this object.

00:45:48.300 --> 00:45:49.300
Yeah.

00:45:49.300 --> 00:45:51.540
This was the other way that I was hinting at.

00:45:51.540 --> 00:45:52.540
And it's super cool.

00:45:52.540 --> 00:45:53.540
Where is this?

00:45:53.540 --> 00:45:54.540
Save changes.

00:45:54.540 --> 00:45:55.540
There we go.

00:45:55.540 --> 00:46:00.760
On all of these documents, you can optionally have a class, an inner class called settings.

00:46:00.760 --> 00:46:04.060
And then you can do things like use state management equals true.

00:46:04.060 --> 00:46:10.480
And you don't have to figure out how to write those set operations or increment operations or whatever.

00:46:10.480 --> 00:46:14.060
You can just make changes and call save changes and off it goes, right?

00:46:14.060 --> 00:46:14.500
Yeah.

00:46:14.500 --> 00:46:15.020
Yeah.

00:46:15.020 --> 00:46:17.280
So it's quite simple.

00:46:17.280 --> 00:46:17.740
Yeah.

00:46:17.740 --> 00:46:18.760
This is really, really cool.

00:46:18.760 --> 00:46:27.960
I like that about this, that it gives you that option to sort of use the most natural way of making very small changes to the data, right?

00:46:27.960 --> 00:46:32.460
Because so often ORMs and ODMs are, give me the object back and make a change to it.

00:46:32.460 --> 00:46:35.480
Put the whole thing back wherever it came from, you know?

00:46:35.480 --> 00:46:35.800
Yeah.

00:46:35.800 --> 00:46:36.340
Yeah.

00:46:36.340 --> 00:46:36.760
I agree.

00:46:36.760 --> 00:46:44.780
And also, if you don't want to fetch object at all and you want to set something to object, you can use update query here, right?

00:46:44.780 --> 00:46:45.000
Yeah.

00:46:45.840 --> 00:46:49.420
And you will not even fetch object into your application.

00:46:49.420 --> 00:46:57.220
That's a really good point because so often with ORMs and ODMs, the set-based behaviors are super hard to do, right?

00:46:57.220 --> 00:47:00.340
Like, let's suppose I've got 100,000 users.

00:47:00.340 --> 00:47:06.960
I want to go and, you know, set some field to like a default value that didn't previously exist in the database.

00:47:06.960 --> 00:47:11.480
Or I want to compute something that's a computed field that wasn't previously there.

00:47:11.480 --> 00:47:14.980
So I've got to go to each one, make a change or something.

00:47:14.980 --> 00:47:27.880
I mean, if it's always the same value, you still would need to go in the ORM stories, like, do a query, get the 100,000 records back, loop over them, set the little one value on the class and call save.

00:47:28.180 --> 00:47:38.080
But what you're saying is you could just do, like, product, or in my case, users.update, value equals what you want it to, and just update all of them, right?

00:47:38.080 --> 00:47:40.340
Update many, you might have to call or something like that.

00:47:40.340 --> 00:47:42.880
Or you can even find something and then .update.

00:47:42.880 --> 00:47:45.800
And it will update on only...

00:47:45.800 --> 00:47:46.240
Oh, really?

00:47:46.240 --> 00:47:49.120
So you could do like a find all, then a .update?

00:47:49.120 --> 00:47:49.800
Yeah.

00:47:49.800 --> 00:47:51.640
And it wouldn't actually pull them back from the database?

00:47:51.640 --> 00:47:52.860
It will not fetch them, yeah.

00:47:52.940 --> 00:47:53.780
Oh, my goodness.

00:47:53.780 --> 00:47:54.240
Okay.

00:47:54.240 --> 00:47:54.920
It's a bit magical.

00:47:54.920 --> 00:47:56.000
That's very magical.

00:47:56.000 --> 00:47:57.340
That's awesome, actually.

00:47:57.340 --> 00:48:04.700
Then, again, the other things you have on here that are really just simple is, like, you can do a find and then just a to list on it.

00:48:04.700 --> 00:48:07.340
You know, like, I don't want to loop over it or whatever.

00:48:07.340 --> 00:48:08.700
Just give me the list back.

00:48:08.700 --> 00:48:09.920
That's also nice.

00:48:09.920 --> 00:48:10.160
Yeah.

00:48:10.220 --> 00:48:10.380
Yeah.

00:48:10.380 --> 00:48:10.960
Let's see.

00:48:10.960 --> 00:48:12.060
How are we doing on time?

00:48:12.060 --> 00:48:14.280
We're getting a little short on time.

00:48:14.280 --> 00:48:14.720
Let me...

00:48:14.720 --> 00:48:16.900
Let's talk through a little bit of some...

00:48:16.900 --> 00:48:26.020
There's a really nice tutorial here that starts out with defining documents, setting up the code, which is pretty much just standard MongoDB, right?

00:48:26.020 --> 00:48:30.600
Like, you have to create one of these clients, but what you're really creating is just a motor client.

00:48:30.600 --> 00:48:36.240
So I'm guessing you can send as, like, complex of a MongoDB configuration as you need to, and it doesn't affect Beanie.

00:48:36.240 --> 00:48:44.700
Yeah, and also now it's not documented yet because I'm lazy, but Anthony Shaw, you know him, I think?

00:48:44.700 --> 00:48:47.200
Anthony Shaw makes common appearances here, yes.

00:48:47.200 --> 00:48:47.900
Yeah.

00:48:47.900 --> 00:48:59.480
He suggested me to add optional, so you can pass a connection string instead of all this stuff with database, just init, Beanie, and connection string, and it will work.

00:48:59.480 --> 00:48:59.900
Nice.

00:48:59.900 --> 00:49:02.260
But I have to add documentation about this because...

00:49:02.260 --> 00:49:11.940
Sure, so in the documentation, you create a motor client, and then you pass the client over to Beanie init, or you just create the client first, right?

00:49:11.940 --> 00:49:17.620
But if you just call init Beanie with the right connection string, it'll do that behind the scenes for you.

00:49:17.620 --> 00:49:18.640
Yeah, thanks, Anthony.

00:49:18.640 --> 00:49:19.780
That's really good.

00:49:19.780 --> 00:49:30.220
So, but if you're working with, like, sharded clusters and replica sets and all the kind of stuff that is, like, on the outer edge of these use cases, that should be supported, right?

00:49:30.260 --> 00:49:30.880
Yeah.

00:49:30.880 --> 00:49:33.400
It's just under, behind the scenes, you don't have to know about it.

00:49:33.400 --> 00:49:43.060
The other thing that's interesting is when you initialize it, you pass it all the document classes, like product or user or whatever, right, as a list?

00:49:43.060 --> 00:49:54.640
Yeah, yeah, because you have to, so under the hood, document must know to which database it's picked because, so for some use cases, you can use different databases in the same application.

00:49:55.020 --> 00:49:59.700
And in that case, you have to init Beanie for different databases with different set of models.

00:49:59.700 --> 00:50:04.620
So, yeah, you have to pass models there, in that case.

00:50:04.620 --> 00:50:05.620
Yeah, I do that in mine.

00:50:05.700 --> 00:50:18.380
I have multiple databases, like logging and analytics and all that kind of stuff goes to one database that gets managed and backed up less frequently because it's, like, gigs and gigs of data.

00:50:18.900 --> 00:50:24.860
But, you know, if you lost it, the only person who would care in the world is me, like, I lost my history of stuff, right?

00:50:24.860 --> 00:50:29.940
As opposed to the thing the website needs to run or user accounts or whatever.

00:50:29.940 --> 00:50:34.160
Like, those need to be backed up frequently and treated really specially.

00:50:34.620 --> 00:50:38.440
So, I actually have those as two separate databases based on classes.

00:50:38.440 --> 00:50:46.500
So, I guess what you're saying here is you can also call init Beanie on multiple times with different databases and different lists of documents.

00:50:46.500 --> 00:50:46.740
Yeah.

00:50:46.740 --> 00:50:47.820
And it will work.

00:50:47.820 --> 00:50:48.780
Nice.

00:50:48.780 --> 00:50:50.220
Yeah, that's really cool.

00:50:50.220 --> 00:50:52.940
Can you give it, like, a star type of thing?

00:50:52.940 --> 00:50:58.160
Like, everything in this folder, in this module or this sub package?

00:50:58.360 --> 00:51:00.280
Not yet, unfortunately.

00:51:00.280 --> 00:51:03.000
But it's a nice feature, I think.

00:51:03.000 --> 00:51:03.220
Yeah.

00:51:03.220 --> 00:51:05.280
Sounds like a feature request, yeah?

00:51:05.280 --> 00:51:06.720
Okay, sounds like a feature request.

00:51:06.720 --> 00:51:13.340
Yeah, so if you could give it something like, all my models live in this sub package of my project or in this folder.

00:51:13.340 --> 00:51:14.740
Like, there you go.

00:51:14.740 --> 00:51:15.500
That might be nice.

00:51:15.500 --> 00:51:26.640
Because, you know, one of the things that happens to me often is I'll add, like, a view to some part of my site and I'll forget to register it somewhere.

00:51:26.640 --> 00:51:27.980
Like, why is this a 404?

00:51:28.100 --> 00:51:29.840
Oh, yeah, yeah, yeah.

00:51:29.840 --> 00:51:31.920
I got to go and make sure the thing can see this file.

00:51:31.920 --> 00:51:38.720
It will erase an error, an exception, errorless, and then you will call an endpoint.

00:51:38.720 --> 00:51:39.720
Nice.

00:51:39.720 --> 00:51:43.040
If you will try to touch any document without initialization, it will erase an error.

00:51:43.040 --> 00:51:43.780
Yeah, cool.

00:51:43.780 --> 00:51:45.060
So, let's see.

00:51:45.060 --> 00:51:46.220
Let's talk indexes.

00:51:46.220 --> 00:51:52.100
I started our conversation with my utter disbelief that there are websites that take five seconds to load.

00:51:52.100 --> 00:51:55.320
And I'm like, I know they don't have more data than I have.

00:51:56.160 --> 00:51:58.380
I just know they've done something wrong.

00:51:58.380 --> 00:52:00.500
There's no way this has more data.

00:52:00.500 --> 00:52:03.080
So, indexes are critical, right?

00:52:03.080 --> 00:52:04.480
What is the index story?

00:52:04.480 --> 00:52:06.060
How do you create them over here?

00:52:06.200 --> 00:52:08.960
It's an interesting story about indexes, honestly.

00:52:08.960 --> 00:52:17.920
Like, I published my first version of Beanie and one guy texted me that probably it's possible to add indexes there.

00:52:17.920 --> 00:52:20.460
I don't see if it's supported or not.

00:52:20.460 --> 00:52:24.120
And in a few days, I added them.

00:52:24.120 --> 00:52:25.600
Yeah, that's right.

00:52:25.600 --> 00:52:28.420
We covered Beanie when it first came out on Python Bytes.

00:52:28.420 --> 00:52:30.140
I'm like, this is awesome, but where are the indexes?

00:52:30.820 --> 00:52:32.660
A bit of a stickler for those.

00:52:32.660 --> 00:52:33.060
That's awesome.

00:52:33.060 --> 00:52:43.400
So, yeah, the way you do it is instead of saying when you define a class, say the type is, say, a str or an int, you would say it's an index of int.

00:52:43.820 --> 00:52:45.780
And that just creates the index.

00:52:45.780 --> 00:52:49.960
And it looks like, you know, in Mongo, you have all these parameters and control.

00:52:49.960 --> 00:52:52.060
Is it a sparse index?

00:52:52.060 --> 00:52:54.400
Is it a uniqueness constraint as well?

00:52:54.400 --> 00:52:55.520
Is it ascending?

00:52:55.520 --> 00:52:56.320
Is it descending?

00:52:56.320 --> 00:52:57.320
And whatnot.

00:52:57.320 --> 00:53:02.920
And so, you can pass additional information like that it's a text index or something like that, right?

00:53:02.920 --> 00:53:03.260
Yeah.

00:53:03.260 --> 00:53:04.700
Yeah, it supports all the parameters.

00:53:04.700 --> 00:53:05.620
And uniqueness.

00:53:05.620 --> 00:53:07.100
This isn't super important, right?

00:53:07.180 --> 00:53:11.400
Like, your email on your user account had better be unique.

00:53:11.400 --> 00:53:13.660
Otherwise, a reset password is going to get really weird.

00:53:13.660 --> 00:53:20.260
You support multi-field indexes, which is something that's pretty common, like a composite index.

00:53:20.260 --> 00:53:29.720
If I'm going to do a query where the product is in this category and it's on sale, you want to have the index take both of those into account to be super fast, right?

00:53:29.720 --> 00:53:30.640
So, you have support for that?

00:53:30.640 --> 00:53:31.760
Yeah, it supports also.

00:53:31.760 --> 00:53:34.340
But it's not that neat, let's say.

00:53:34.340 --> 00:53:35.440
It's not that beautiful.

00:53:35.860 --> 00:53:36.920
But it supports it.

00:53:36.920 --> 00:53:37.380
Yeah.

00:53:37.380 --> 00:53:40.380
The payoff is worth it.

00:53:40.380 --> 00:53:43.780
It's also in this class called collection, right?

00:53:43.780 --> 00:53:51.640
So, it's kind of in its own special inner class of the model, in which case, you know, a lot of the IDs have a little chevron.

00:53:51.640 --> 00:53:53.840
You can just collapse that thing and not look at it anymore.

00:53:53.840 --> 00:53:58.340
So, it's easy to hide the complexity, I guess, there.

00:53:58.340 --> 00:53:58.660
Yeah.

00:53:58.660 --> 00:53:58.940
Cool.

00:53:58.940 --> 00:53:59.560
All right.

00:53:59.560 --> 00:54:00.220
What else?

00:54:00.220 --> 00:54:01.120
Aggregation.

00:54:01.120 --> 00:54:05.980
It sounds like that when we talk about, I'll have to get to it pretty quick.

00:54:05.980 --> 00:54:13.480
When we talk about relationships and stuff, you said that this is super efficient because it's using the aggregation framework.

00:54:13.480 --> 00:54:16.420
So, MongoDB has like two ways to query stuff, right?

00:54:16.420 --> 00:54:18.900
It's like the straight query style.

00:54:18.900 --> 00:54:24.220
And then it has something that's honestly harder to use but more flexible called aggregations.

00:54:24.900 --> 00:54:29.380
And so, you guys support, your library supports aggregation queries as well, right?

00:54:29.380 --> 00:54:29.800
Yeah.

00:54:29.800 --> 00:54:30.140
Yeah.

00:54:30.140 --> 00:54:36.060
And also, as before, with updates, it also supports find queries together with aggregations.

00:54:36.060 --> 00:54:41.380
Like an example, for example, there are some presets of aggregations, average here.

00:54:41.380 --> 00:54:46.240
And you can use this average with find queries together and you will see the result.

00:54:46.240 --> 00:54:50.880
And also, for sure, you can pass a list pipeline in MongoDB terms.

00:54:50.880 --> 00:54:55.880
You can pass pipeline of your aggregation steps there and it will work.

00:54:55.880 --> 00:54:56.220
Yeah.

00:54:56.220 --> 00:55:00.440
It's not super easy to write if you haven't done it before, but yes, it will work.

00:55:00.440 --> 00:55:01.140
Yeah.

00:55:01.740 --> 00:55:07.280
And also, the thing is, with aggregations, you have to set up what schema of the result

00:55:07.280 --> 00:55:11.680
would be because with find, everybody knows it would be the same schema of the document,

00:55:11.680 --> 00:55:12.460
of the original document.

00:55:12.460 --> 00:55:16.880
But with aggregations, it definitely can be any schema of results.

00:55:16.880 --> 00:55:17.120
Right.

00:55:17.120 --> 00:55:21.780
Because the whole point of aggregation and other people might know something similar with

00:55:21.780 --> 00:55:28.600
MapReduce is I want to take, say, a collection of sales and I want to get a result of show

00:55:28.600 --> 00:55:32.280
me the sales by country and the total sales for that country.

00:55:32.280 --> 00:55:32.560
Right.

00:55:32.560 --> 00:55:34.560
So you're not going to get a list of sales back.

00:55:34.560 --> 00:55:38.940
You're going to get a thing, a list of things that has a country and a total sales.

00:55:38.940 --> 00:55:39.220
Right.

00:55:39.220 --> 00:55:39.560
Yeah.

00:55:39.560 --> 00:55:40.180
For sure.

00:55:40.180 --> 00:55:44.740
It's optional and you cannot pass output model.

00:55:44.740 --> 00:55:48.680
And in that case, it will return dictionaries, but it's not that fancy.

00:55:48.680 --> 00:55:50.280
So it would be better to.

00:55:50.280 --> 00:55:51.000
Yeah.

00:55:51.000 --> 00:55:51.760
This is super cool.

00:55:51.760 --> 00:55:53.240
I love this projection model idea.

00:55:53.240 --> 00:55:56.160
Mario in the audience says, I created a model loader.

00:55:56.160 --> 00:56:03.780
Speaking of the passing the documents to Beanie and init, I created a model loader as a utility

00:56:03.780 --> 00:56:08.620
function that pulls dot separated pass and then passes it to document models.

00:56:08.620 --> 00:56:09.480
Works really well.

00:56:09.480 --> 00:56:10.140
Great.

00:56:10.140 --> 00:56:11.760
There you go.

00:56:11.760 --> 00:56:13.700
Right on.

00:56:13.700 --> 00:56:15.720
So let's talk about relationships.

00:56:16.140 --> 00:56:21.800
Because I started out talking about, you don't use the R, you use the D because you model documents,

00:56:21.800 --> 00:56:22.720
not relationships.

00:56:22.720 --> 00:56:25.280
And yet Beanie supports relationships.

00:56:25.280 --> 00:56:28.260
I'm super excited about this.

00:56:28.260 --> 00:56:28.500
Yeah.

00:56:28.500 --> 00:56:29.140
Tell us about this.

00:56:29.140 --> 00:56:29.540
Yeah.

00:56:29.900 --> 00:56:34.860
So it took around three months to come up how to do relations.

00:56:34.860 --> 00:56:37.780
MongoDB doesn't support relations.

00:56:37.780 --> 00:56:45.240
But relations is very popular feature in Orium and ODIMs.

00:56:45.240 --> 00:56:47.400
And I had to implement it finally.

00:56:47.400 --> 00:56:49.140
And I did it.

00:56:49.900 --> 00:56:56.940
For now, it's supported limited version of relations, like only top level fields are supported and

00:56:56.940 --> 00:57:02.600
only two kinds of relations, direct relation and list of relations.

00:57:02.600 --> 00:57:02.880
Right.

00:57:02.880 --> 00:57:05.840
A one-to-one or a one-to-many, I guess.

00:57:05.840 --> 00:57:06.740
One-to-one, one-to-many.

00:57:06.740 --> 00:57:06.960
Yeah.

00:57:06.960 --> 00:57:07.420
Uh-huh.

00:57:07.540 --> 00:57:11.540
And so the syntax is by tonic, I'd say.

00:57:11.540 --> 00:57:18.860
It uses generic class link inside of bracket, of square brackets, pass your document.

00:57:18.860 --> 00:57:19.400
Right.

00:57:19.400 --> 00:57:23.180
So maybe you would specify, normally you would say an optional int.

00:57:23.180 --> 00:57:25.760
Here you would say like link int.

00:57:25.760 --> 00:57:27.400
And that might, int doesn't make sense.

00:57:27.400 --> 00:57:29.580
But, you know, that type thing would be the relationship, right?

00:57:29.580 --> 00:57:31.880
It's like the same syntax as optional basically here.

00:57:31.880 --> 00:57:32.200
Yeah.

00:57:32.200 --> 00:57:36.400
It's a little bit tricky and with a black magic under the hood.

00:57:36.400 --> 00:57:39.320
But as long as I don't have to know about it.

00:57:39.320 --> 00:57:40.660
Thanks for creating the black magic.

00:57:40.660 --> 00:57:44.620
So you could say here your model is there's a door and a house.

00:57:44.620 --> 00:57:47.940
And then the door is of type link of door.

00:57:47.940 --> 00:57:49.560
And then you have another one.

00:57:49.560 --> 00:57:52.060
You have windows where the house has many windows.

00:57:52.060 --> 00:57:58.600
And you would say the windows is a list of link of window, which is, it's a little bit

00:57:58.600 --> 00:58:02.480
intense on the nesting there, but it's not bad, right?

00:58:02.480 --> 00:58:04.460
It's just, it's a list of relationships.

00:58:04.460 --> 00:58:04.760
Yeah.

00:58:04.760 --> 00:58:05.060
Yeah.

00:58:05.060 --> 00:58:05.400
Yeah.

00:58:05.500 --> 00:58:06.740
And for sure it's possible.

00:58:06.740 --> 00:58:09.880
And I think later it would be implemented.

00:58:09.880 --> 00:58:13.740
I will, you know, shorten this list of link to another.

00:58:13.740 --> 00:58:15.180
Links.

00:58:15.180 --> 00:58:16.160
Links.

00:58:16.160 --> 00:58:17.240
No, just kidding.

00:58:17.240 --> 00:58:17.820
Don't do that.

00:58:17.820 --> 00:58:20.160
Although it would be kind of awesome.

00:58:20.160 --> 00:58:22.960
As a syntax, I think it would be less discoverable.

00:58:25.640 --> 00:58:26.020
Yeah.

00:58:26.020 --> 00:58:26.100
Yeah.

00:58:26.100 --> 00:58:27.640
And it works.

00:58:27.640 --> 00:58:34.080
You can insert data inside of this linked documents to linked collections.

00:58:34.140 --> 00:58:35.380
And you can fetch data from linked collections.

00:58:35.380 --> 00:58:35.380
Yeah.

00:58:35.380 --> 00:58:39.480
And you can even have it cascade things.

00:58:39.480 --> 00:58:45.580
So for example, you could have created a house object and say dot windows is this list of window

00:58:45.580 --> 00:58:46.060
objects.

00:58:46.060 --> 00:58:47.300
And then you would say house dot save.

00:58:47.300 --> 00:58:54.300
And if you pass the link rule, then that says write the cascade the changes.

00:58:54.300 --> 00:58:57.540
It'll also go and insert all those windows and associate them.

00:58:57.540 --> 00:58:58.480
Right?

00:58:58.480 --> 00:58:58.800
Yeah.

00:58:58.800 --> 00:58:59.300
Correct.

00:58:59.300 --> 00:59:06.720
And I didn't use cascade term because it's not SQL database and a little bit different

00:59:06.720 --> 00:59:07.680
things.

00:59:07.680 --> 00:59:07.840
Sure.

00:59:07.840 --> 00:59:10.400
With relations, it would be a little different.

00:59:10.400 --> 00:59:10.840
Yeah.

00:59:10.840 --> 00:59:13.360
How does this look in the database itself?

00:59:13.360 --> 00:59:19.380
So if I go to MongoDB and I pull up the house, what is in its windows?

00:59:19.380 --> 00:59:23.160
Is that a list of the IDs of the window objects or what is that?

00:59:23.160 --> 00:59:28.080
In MongoDB, there is a special data type called ref ID.

00:59:28.080 --> 00:59:28.680
Okay.

00:59:28.680 --> 00:59:30.460
It's combined under the hood.

00:59:30.460 --> 00:59:36.480
It's binary and data type, but under the hood, it's a combination of ID of the document,

00:59:36.480 --> 00:59:39.380
name of the collection and name of the database.

00:59:39.380 --> 00:59:40.740
So it's a two point.

00:59:40.740 --> 00:59:41.600
Oh, interesting.

00:59:41.600 --> 00:59:42.320
Okay.

00:59:42.320 --> 00:59:46.840
So that's what I, in the document, what I end up with is a list of those things.

00:59:46.840 --> 00:59:47.120
Yeah.

00:59:47.120 --> 00:59:47.460
Yeah.

00:59:47.460 --> 00:59:48.200
Okay.

00:59:48.200 --> 00:59:54.600
And you will see a few collections like here, house, window and door, three collections

00:59:54.600 --> 00:59:57.160
with objects, separated objects.

00:59:57.160 --> 00:59:58.100
Okay.

00:59:58.100 --> 00:59:58.900
Cool.

00:59:58.900 --> 01:00:02.940
You can also tell it that you don't want to propagate those changes, right?

01:00:02.940 --> 01:00:04.700
As you save the house, which is interesting.

01:00:04.700 --> 01:00:06.940
Let's talk about refetch.

01:00:07.300 --> 01:00:13.420
So I told you one of the, when I see those websites that are just dragging super slow, I go through

01:00:13.420 --> 01:00:13.780
my thing.

01:00:13.780 --> 01:00:14.000
All right.

01:00:14.000 --> 01:00:15.120
Did they forget the index?

01:00:15.120 --> 01:00:18.860
Are they doing some terrible seven way join?

01:00:18.860 --> 01:00:20.820
Probably without indexes.

01:00:20.820 --> 01:00:21.820
Or the third thing.

01:00:21.820 --> 01:00:25.920
Is it an N plus one ORM problem where they get one thing, but then they've got to go back

01:00:25.920 --> 01:00:31.520
and back and back because they're touching this related field, which you could potentially run

01:00:31.520 --> 01:00:32.560
into that problem as well.

01:00:32.660 --> 01:00:37.620
So you have this prefetch idea, which is kind of like a joined load or something like that,

01:00:37.620 --> 01:00:37.800
right?

01:00:37.800 --> 01:00:38.140
Yeah.

01:00:38.140 --> 01:00:38.400
Yeah.

01:00:38.400 --> 01:00:42.360
It uses lookup aggregation in terms of MongoDB.

01:00:42.360 --> 01:00:48.700
it's not just find query, but aggregation and it avoids this N plus one problem.

01:00:48.700 --> 01:00:49.100
Yeah.

01:00:49.100 --> 01:00:49.620
As you said.

01:00:49.620 --> 01:00:50.080
Right.

01:00:50.080 --> 01:00:51.260
So you just do, and you're fine.

01:00:51.260 --> 01:00:53.060
You just say fetch links equals true.

01:00:53.060 --> 01:00:57.480
And that'll just go get the doors, the windows, everything in your house example, right?

01:00:57.480 --> 01:00:57.780
Yeah.

01:00:58.020 --> 01:01:00.980
And I like the speed of this.

01:01:00.980 --> 01:01:05.820
Like it's much faster than do it, you know, one by one, especially for list of objects.

01:01:05.820 --> 01:01:06.540
Yeah, absolutely.

01:01:06.540 --> 01:01:10.620
So you also have the ability to say fetch all links retroactively.

01:01:10.620 --> 01:01:14.680
If you've been like, oh, I should have, I should have done this join, but I didn't.

01:01:14.680 --> 01:01:15.160
Yeah.

01:01:15.160 --> 01:01:16.420
That might sound silly, right?

01:01:16.420 --> 01:01:18.440
Well, why not just always do the join, right?

01:01:18.440 --> 01:01:22.480
That's one, probably slower than not doing it, I would guess.

01:01:22.480 --> 01:01:25.900
And two, this happens to me all the time.

01:01:25.900 --> 01:01:30.840
Like for example, on the courses website, I want to show, I want to be able to get the

01:01:30.840 --> 01:01:35.280
courses, but the courses have like chapter information and other stuff inside of them.

01:01:35.280 --> 01:01:41.680
And then those have like links effectively over to say like all the details about each chapter,

01:01:41.680 --> 01:01:44.480
like the lectures and videos and all that.

01:01:44.480 --> 01:01:49.040
On say the page that lists the courses, I do not want those things.

01:01:49.040 --> 01:01:53.880
But on the course details page where it shows you like, here's all the stuff in the course

01:01:53.880 --> 01:01:56.400
and how long it is, like I definitely do want those things.

01:01:56.400 --> 01:02:01.780
So in my data access layer, I have a thing that says, should you get all the data or just

01:02:01.780 --> 01:02:02.760
the top level data?

01:02:02.760 --> 01:02:03.820
Basically.

01:02:03.820 --> 01:02:05.880
And this would be exactly the code you'd write.

01:02:05.880 --> 01:02:09.340
Like, well, if you want all the data, you'd say fetch all links on it, right?

01:02:09.340 --> 01:02:09.660
Yeah.

01:02:09.660 --> 01:02:10.660
Yeah, correct.

01:02:10.660 --> 01:02:11.300
This is cool.

01:02:11.300 --> 01:02:13.380
Is there a way to do that on a set?

01:02:13.380 --> 01:02:15.300
Like this is on one record.

01:02:15.420 --> 01:02:19.880
Is there a way to say I got 20 houses back, fetch all of their links?

01:02:19.880 --> 01:02:21.300
Or do I have to do it?

01:02:21.300 --> 01:02:22.200
Is that 20 calls?

01:02:22.200 --> 01:02:23.880
So it would be 20 calls, unfortunately.

01:02:23.880 --> 01:02:25.000
That's okay.

01:02:25.000 --> 01:02:29.420
I think in my example, it's also 20 calls or however many.

01:02:29.420 --> 01:02:31.580
The same setup is exactly the same.

01:02:31.580 --> 01:02:33.380
But I will improve it.

01:02:33.380 --> 01:02:34.740
I hope.

01:02:34.740 --> 01:02:35.200
Yeah.

01:02:35.200 --> 01:02:36.300
This is worth pointing out.

01:02:36.300 --> 01:02:37.680
This is a brand new feature, right?

01:02:37.680 --> 01:02:42.340
You announced this as one of the new features just two days ago.

01:02:42.340 --> 01:02:43.400
On Monday, yeah.

01:02:43.400 --> 01:02:43.920
Yeah.

01:02:43.920 --> 01:02:47.400
And for the people listening, we're recording on Wednesday morning.

01:02:47.400 --> 01:02:50.220
So yeah, this is not, this is like your first pass.

01:02:50.220 --> 01:02:54.540
But I really like how this looks with the relationships and the querying and whatnot.

01:02:54.540 --> 01:03:00.640
It would be nice, I think, if you could have some way to kind of globally configure to save.

01:03:00.640 --> 01:03:10.780
In general, if I call save, the rule to write the relationships is to not, to do nothing or to always write them or something and then only have to override it potentially.

01:03:10.780 --> 01:03:11.120
Yeah.

01:03:11.120 --> 01:03:11.360
Yeah.

01:03:11.360 --> 01:03:12.840
Sounds like default, default rule.

01:03:12.840 --> 01:03:13.600
Yeah, exactly.

01:03:13.600 --> 01:03:14.240
Exactly.

01:03:14.240 --> 01:03:14.840
That'd be pretty cool.

01:03:14.840 --> 01:03:19.000
So let's see a few other things we could talk about.

01:03:19.000 --> 01:03:27.900
We talked a little bit about the event-based actions, but you want to just kind of talk about them directly because it was like a quick, well, how do I add my default value?

01:03:28.120 --> 01:03:31.740
What's the overall picture with these default, with these event actions?

01:03:31.740 --> 01:03:32.240
Yeah.

01:03:32.240 --> 01:03:35.160
A lot of, somehow a lot of people wanted this.

01:03:35.160 --> 01:03:41.580
And I didn't know about this pattern before.

01:03:41.580 --> 01:03:47.300
Like it's implemented something like this, implemented in ActiveRap record pattern of Rails.

01:03:47.300 --> 01:03:50.940
And so finally I was inspired by this.

01:03:50.940 --> 01:03:53.360
I like this word inspired by.

01:03:53.360 --> 01:03:56.620
Not stolen, but inspired by.

01:03:56.620 --> 01:03:57.380
Exactly.

01:03:57.380 --> 01:03:57.560
Yeah.

01:03:57.560 --> 01:03:59.740
And we met this, yeah.

01:03:59.740 --> 01:04:04.000
And now it's supported only four types of events.

01:04:04.000 --> 01:04:09.640
There are events on each insert, replace, save, changes, and validate on save.

01:04:09.640 --> 01:04:15.740
It creates an event and two events before it called and after it called.

01:04:16.280 --> 01:04:23.860
And based on these events, actions already registered to the document would be called also.

01:04:23.860 --> 01:04:28.120
It supports and asynchronous and asynchronous methods for this.

01:04:28.120 --> 01:04:30.440
And you can do a lot of stuff with this.

01:04:30.440 --> 01:04:31.060
Yeah, that's cool.

01:04:31.060 --> 01:04:31.140
Yeah, that's cool.

01:04:31.140 --> 01:04:37.900
You can put the decorator on just an async version or a non-async version and being able to just call it correctly, right?

01:04:37.900 --> 01:04:38.280
Yeah.

01:04:38.280 --> 01:04:38.800
Yeah.

01:04:38.800 --> 01:04:39.420
Yeah, that's cool.

01:04:39.420 --> 01:04:46.180
I'm guessing if you're not doing any awaits, it'd be better if it was not asynchronous, but it doesn't matter that much, right?

01:04:46.380 --> 01:04:49.280
It's one and a half faster if it's not asynchronous.

01:04:49.280 --> 01:04:50.000
Yeah.

01:04:50.200 --> 01:04:52.100
So probably it's critical for something.

01:04:52.100 --> 01:04:55.420
Yeah, if it's doing something where it's waiting on something else, then maybe it should be.

01:04:55.420 --> 01:04:55.700
Yeah.

01:04:55.700 --> 01:04:56.000
Okay.

01:04:56.000 --> 01:04:59.600
Another feature that just came out is cache.

01:04:59.600 --> 01:05:00.780
Yeah, cache.

01:05:00.780 --> 01:05:01.740
Tell us about this.

01:05:01.740 --> 01:05:04.000
It's also an interesting feature.

01:05:04.000 --> 01:05:06.040
Like, so yeah, it's cache.

01:05:06.040 --> 01:05:09.620
I don't know if I have to explain what is cache.

01:05:09.620 --> 01:05:16.080
It's when you save data somewhere locally and use a copy of data for some time.

01:05:16.080 --> 01:05:27.320
Yeah, and what you're talking about is not using MongoDB as a caching backend, but caching the queries that would run through Beanie to not hit the database again if it knows the answer.

01:05:27.320 --> 01:05:27.640
Yeah.

01:05:27.640 --> 01:05:32.620
Yeah, and somehow it's a really important feature even for my projects.

01:05:32.620 --> 01:05:45.920
For example, if you have to validate stuff with user and you already asked for a user in this application with this ID, but you don't know the place where you did it and you don't want to provide this.

01:05:45.920 --> 01:05:50.660
It's an object through the whole pipeline because probably it will not be used in the end of this pipeline.

01:05:50.660 --> 01:05:53.080
But user is already cached in Beanie.

01:05:53.080 --> 01:06:00.260
And if you just will ask in the end of the pipeline again about the same user data, so it would be there.

01:06:00.260 --> 01:06:05.000
And with a bigger field of find queries, it works the same way.

01:06:05.000 --> 01:06:07.500
Yeah, the more complicated the query, the better.

01:06:07.500 --> 01:06:11.320
This makes a lot of sense, I think, for data that doesn't change much.

01:06:11.320 --> 01:06:14.580
Like if you've got a bookstore, you might have categories and books.

01:06:14.580 --> 01:06:17.020
And maybe the books change often.

01:06:17.020 --> 01:06:19.240
The reviews of the books change often.

01:06:19.240 --> 01:06:21.780
The books that are in different categories change.

01:06:21.780 --> 01:06:25.100
But the categories themselves very rarely change, right?

01:06:25.100 --> 01:06:28.420
So that could be something like the category query could just be like, you know what?

01:06:28.420 --> 01:06:29.420
This is cached.

01:06:29.420 --> 01:06:30.700
Yeah, definitely.

01:06:30.980 --> 01:06:36.540
So for now, it supports only local cache like dictionaries of Python.

01:06:36.540 --> 01:06:41.800
But I plan to add another cache backends like Redis and things like this.

01:06:41.800 --> 01:06:42.480
Yeah, that's cool.

01:06:42.480 --> 01:06:47.780
Or even possibly you could put, it might even make sense to use MongoDB itself as a cache.

01:06:47.780 --> 01:06:48.120
Yeah.

01:06:48.240 --> 01:06:49.520
Because it's more native.

01:06:49.520 --> 01:06:53.060
I mean, it'd be weird to kind of store the same thing back into it.

01:06:53.060 --> 01:07:03.040
But at the same time, if you've got a complicated query, what you're storing is like, these are the three things that came back from running that query against possibly hundreds of millions of records.

01:07:03.040 --> 01:07:03.620
Right?

01:07:03.620 --> 01:07:09.120
So in that case, it might make sense to just put it back in Mongo so it's just a straight, you know, table scan read.

01:07:09.120 --> 01:07:12.100
Something like Lambda architecture inside of the single database.

01:07:12.540 --> 01:07:12.720
Yeah.

01:07:12.720 --> 01:07:20.680
So I wanted to ask you, your example says, okay, what we're going to do is say sample.find num greater than 10 to list.

01:07:20.680 --> 01:07:25.040
And then if you call it again with the caching on, then you get the same thing.

01:07:25.040 --> 01:07:28.920
Well, it looks at the actual query, right?

01:07:28.920 --> 01:07:34.840
So if I said num greater than 11, I would get, that would be a separate result and a separate cached thing, right?

01:07:34.840 --> 01:07:35.260
Yeah.

01:07:35.260 --> 01:07:36.000
Yeah, totally.

01:07:36.000 --> 01:07:36.500
Cool.

01:07:36.500 --> 01:07:41.380
The other thing I guess that's worth noting is you can set an expiration date on the cache, right?

01:07:41.380 --> 01:07:46.320
Like I want this to live for 10 minutes or whatever to get the answer back.

01:07:46.320 --> 01:07:47.100
Yeah.

01:07:47.100 --> 01:07:47.420
Yeah.

01:07:47.420 --> 01:07:47.920
Yeah.

01:07:47.920 --> 01:07:48.340
Cool.

01:07:48.340 --> 01:07:49.040
All right.

01:07:49.040 --> 01:07:50.520
Let's talk about revisions.

01:07:50.520 --> 01:07:56.700
And then I'm going to propose one more idea that I think I could build out of revisions and events.

01:07:56.700 --> 01:07:58.800
So what are revisions?

01:07:58.800 --> 01:08:01.040
So it's not my idea again.

01:08:01.040 --> 01:08:03.260
It's neither one user asked me for this.

01:08:03.260 --> 01:08:08.880
And I really like users of Winnie because I have not that many ideas.

01:08:10.080 --> 01:08:12.000
And yeah, what is this?

01:08:12.000 --> 01:08:18.220
You, sometimes you have to protect document inside of the database of changes.

01:08:18.220 --> 01:08:24.520
So yeah, sometimes you have old version of the data in your backend and you do some updates.

01:08:24.520 --> 01:08:31.800
And if you update your document with this old data, you will lose data updated by another

01:08:31.800 --> 01:08:33.580
backend for the same document.

01:08:33.900 --> 01:08:38.080
So let me, let me give people some examples because I think understanding the context is

01:08:38.080 --> 01:08:38.700
really important.

01:08:38.700 --> 01:08:41.740
Like it could be even the same function basically.

01:08:41.740 --> 01:08:42.160
Right.

01:08:42.200 --> 01:08:45.320
So I could have a function that do complicated things.

01:08:45.320 --> 01:08:49.620
I could say, get me my user object for the current user who wants to make some changes.

01:08:49.620 --> 01:08:55.280
I could call, do a bunch of work, call a function with the past, say like the user ID over.

01:08:55.280 --> 01:08:59.640
Maybe that gets the user back, makes some changes, saves it to the database.

01:08:59.640 --> 01:09:04.320
And then I go to the end, I make some more changes, not realizing that to my in-memory version.

01:09:04.320 --> 01:09:09.820
And I call save and it overwrote what that intermediate function might have, whatever was there is gone

01:09:09.820 --> 01:09:10.100
now.

01:09:10.100 --> 01:09:10.700
You know what I mean?

01:09:11.060 --> 01:09:18.560
So you would want to know, is there, is the thing that I got back, if I'm going to replace

01:09:18.560 --> 01:09:24.280
it in the database, is it still the same thing or somebody somewhere behind the scenes changed

01:09:24.280 --> 01:09:24.500
it?

01:09:24.500 --> 01:09:27.860
You know, often I think that people think about very complicated.

01:09:27.860 --> 01:09:32.180
Well, some other process did some other thing, but it could just be some other part of your

01:09:32.180 --> 01:09:35.300
code that you didn't realize called save after a query.

01:09:35.300 --> 01:09:35.740
Yeah.

01:09:35.740 --> 01:09:36.020
Yeah.

01:09:36.020 --> 01:09:40.840
And for this case, I'm using a revision ID, a special token, which

01:09:40.840 --> 01:09:45.300
generates each time when data saves into the database.

01:09:45.300 --> 01:09:53.180
And when you save again, it will check if this ID is the same or it's already updated.

01:09:53.180 --> 01:09:58.080
If it's updated, it will raise an error, like you have all data in memory, but if it's the

01:09:58.080 --> 01:09:59.300
same, it will allow you to.

01:09:59.300 --> 01:09:59.760
Nice.

01:09:59.760 --> 01:10:00.620
That's really cool.

01:10:00.620 --> 01:10:02.020
I think it's a great feature.

01:10:02.020 --> 01:10:02.700
It's good.

01:10:02.700 --> 01:10:03.580
It definitely is.

01:10:03.580 --> 01:10:08.340
Because the alternative of this pattern is to do a blocking transaction.

01:10:08.340 --> 01:10:08.780
Yeah.

01:10:08.780 --> 01:10:09.060
Right.

01:10:09.260 --> 01:10:11.440
And that's also potentially possible.

01:10:11.440 --> 01:10:14.820
I think MongoDB does have transactions now, but I still haven't used them.

01:10:14.820 --> 01:10:16.400
I don't really have a use for that.

01:10:16.400 --> 01:10:23.660
But the alternative model in databases is to say, we're going to do a transaction that blocks

01:10:23.660 --> 01:10:27.820
and anyone else who tries to do a database thing whatsoever, they just wait until we're

01:10:27.820 --> 01:10:28.100
done.

01:10:28.460 --> 01:10:32.280
And that way, there's no chance of them seeing it in this intermediate state.

01:10:32.280 --> 01:10:39.420
A lot of the scalable systems don't end up doing that even in relational databases because

01:10:39.420 --> 01:10:41.880
this blocking model can really kill the concurrency.

01:10:41.880 --> 01:10:42.240
Yeah.

01:10:42.240 --> 01:10:42.700
Right.

01:10:42.700 --> 01:10:45.980
And so they end up doing optimistic concurrency with these types of revisions.

01:10:45.980 --> 01:10:49.880
Anyway, it's just so I think it's a really cool pattern.

01:10:49.980 --> 01:10:50.220
I love it.

01:10:50.220 --> 01:10:50.520
Yeah.

01:10:50.520 --> 01:10:51.500
This is great.

01:10:51.500 --> 01:10:52.360
It's great.

01:10:52.360 --> 01:10:54.660
It's not my idea, but it's great.

01:10:54.660 --> 01:10:55.280
It's really good.

01:10:55.640 --> 01:11:01.820
It's also, I guess, worth discussing set and increment and those types of things.

01:11:01.820 --> 01:11:08.700
So if I say I want to add a category to a product, I could do add to set on that thing

01:11:08.700 --> 01:11:12.940
and just put this thing in its category list.

01:11:12.940 --> 01:11:15.380
Will that also increment the revision?

01:11:15.380 --> 01:11:18.320
So only set, I think, yeah.

01:11:18.320 --> 01:11:24.100
Because if you will use internal methods of MongoDB, it will not understand that it needs

01:11:24.100 --> 01:11:25.700
to update another field.

01:11:25.700 --> 01:11:26.260
Got it.

01:11:26.260 --> 01:11:26.580
Okay.

01:11:26.580 --> 01:11:27.740
Interesting.

01:11:27.740 --> 01:11:29.000
But yeah, that's a good feature.

01:11:29.000 --> 01:11:29.500
I like it.

01:11:29.500 --> 01:11:30.540
This is a big release.

01:11:30.540 --> 01:11:31.740
It's a huge one.

01:11:31.740 --> 01:11:32.700
Cool.

01:11:32.700 --> 01:11:35.200
Well, we've been talking for a long time.

01:11:35.200 --> 01:11:37.480
As you can tell, I'm very excited about it.

01:11:37.480 --> 01:11:38.700
What else?

01:11:38.700 --> 01:11:39.640
What's coming next?

01:11:39.640 --> 01:11:42.680
So next, I have a big plan sales.

01:11:42.680 --> 01:11:44.260
I really like Pydantic.

01:11:44.260 --> 01:11:46.040
I'm a huge fan of Pydantic.

01:11:46.040 --> 01:11:47.200
You can see it.

01:11:47.200 --> 01:11:51.980
But for some cases, Pydantic is a heavy tool.

01:11:52.560 --> 01:11:59.840
And probably, I don't know how I will implement it, but I want to add support of native Python

01:11:59.840 --> 01:12:06.160
data classes here or here or to separate it smaller project like Bini data classes.

01:12:06.160 --> 01:12:06.880
I don't know yet.

01:12:07.440 --> 01:12:11.960
But anyway, I have planned to add native classes without Pydantic.

01:12:11.960 --> 01:12:18.620
Just with not, let's say, fancy parsing stuff without that great validation stuff.

01:12:18.620 --> 01:12:24.080
But somewhere in between, I just want to, you're just getting dictionaries back.

01:12:24.080 --> 01:12:24.600
Good luck.

01:12:24.600 --> 01:12:26.240
And you're getting Pydantic.

01:12:26.240 --> 01:12:30.360
Somewhere in the middle is you're getting classes back, but they don't necessarily, they're not

01:12:30.360 --> 01:12:32.980
as precise as, say, Pydantic.

01:12:32.980 --> 01:12:33.340
Yeah.

01:12:33.340 --> 01:12:35.480
There are cases.

01:12:35.480 --> 01:12:39.200
And people use Bini with these cases also.

01:12:39.200 --> 01:12:46.960
When you have a lot of huge JSONs as a document, and when you parse it on a fetching, it keeps

01:12:46.960 --> 01:12:48.620
a lot of time.

01:12:48.620 --> 01:12:48.940
Yeah.

01:12:49.100 --> 01:12:51.920
So it takes a lot of time just for parsing.

01:12:51.920 --> 01:12:56.840
And then for encoding back to dictionary to store this dictionary.

01:12:56.840 --> 01:12:57.200
Yeah.

01:12:57.300 --> 01:13:01.460
It's not Pydantic fault, definitely, because Pydantic is, again, it's great.

01:13:01.460 --> 01:13:06.540
But I need to avoid this step somehow.

01:13:06.540 --> 01:13:11.100
And probably, probably I will use data classes for this.

01:13:11.100 --> 01:13:11.460
Sure.

01:13:11.460 --> 01:13:12.460
They look very similar.

01:13:12.460 --> 01:13:12.820
Yeah.

01:13:12.820 --> 01:13:17.300
Another scenario where I find that Pydantic is not a good fit is where I might be getting

01:13:17.300 --> 01:13:20.120
bad data, but I don't want it just to be an exception.

01:13:20.120 --> 01:13:25.700
I want to be able to get all the bad data and say, here's the three errors that you made

01:13:25.700 --> 01:13:27.220
passing me this data.

01:13:27.220 --> 01:13:31.680
And I'm not going to accept it, but here's what you gave me.

01:13:31.680 --> 01:13:34.740
If you're doing like form exchange, right?

01:13:34.740 --> 01:13:37.160
Like from an HTML form.

01:13:37.160 --> 01:13:42.260
What you need to do is put the old value back in and say, that value right there, that's wrong.

01:13:42.260 --> 01:13:49.020
But with Pydantic, if you get the value from the form and you try to read it, it's just

01:13:49.020 --> 01:13:49.760
going to know it's wrong.

01:13:49.760 --> 01:13:51.960
And you're like, wait, but I need to give it back to them.

01:13:51.960 --> 01:13:52.940
Just don't run away.

01:13:52.940 --> 01:13:53.320
Come back.

01:13:53.320 --> 01:13:53.840
Where'd you go?

01:13:54.440 --> 01:13:58.860
And so there's situations like that where you need to kind of keep that exchange going,

01:13:58.860 --> 01:14:03.100
but you still want some sort of, you just got to do the validation yourself.

01:14:03.100 --> 01:14:07.840
But anyway, there's certainly times where Pydantic is as cool as it is, it's not the right fit

01:14:07.840 --> 01:14:08.560
for that situation.

01:14:08.560 --> 01:14:08.820
Yeah.

01:14:08.820 --> 01:14:09.280
Yeah.

01:14:09.280 --> 01:14:09.840
I agree.

01:14:09.840 --> 01:14:10.240
Totally.

01:14:10.240 --> 01:14:11.360
Good example.

01:14:11.360 --> 01:14:12.480
Thanks.

01:14:12.480 --> 01:14:13.520
All right.

01:14:13.520 --> 01:14:16.200
Well, this is a very cool project.

01:14:16.200 --> 01:14:21.880
I've, as you hinted at earlier, I've seen it from the beginning, at least when you open

01:14:21.880 --> 01:14:24.380
sourced it and it's really come a long ways.

01:14:24.380 --> 01:14:25.760
It's super compelling.

01:14:25.760 --> 01:14:30.340
It looks like something that I could possibly use on my next project.

01:14:30.340 --> 01:14:35.720
I constantly, as many people out there are, I'm sure as you are, I'm constantly resisting

01:14:35.720 --> 01:14:37.760
the urge to go, you know, I should rewrite that.

01:14:37.760 --> 01:14:41.280
I should rewrite that in FastAPI or I should rewrite that in this.

01:14:42.400 --> 01:14:47.460
I should rewrite my Mongo Engine stuff with Beanie, but you know, maybe one day I'll break

01:14:47.460 --> 01:14:48.040
down and do it.

01:14:48.040 --> 01:14:48.580
It'd be fun.

01:14:48.580 --> 01:14:48.960
Yeah.

01:14:48.960 --> 01:14:49.900
Thank you.

01:14:49.900 --> 01:14:50.380
Thank you.

01:14:50.380 --> 01:14:51.920
Yeah.

01:14:51.920 --> 01:14:52.480
Very cool.

01:14:52.480 --> 01:14:54.640
So nice work on this project.

01:14:54.640 --> 01:14:56.460
You're looking for contributors and PR.

01:14:56.460 --> 01:15:00.400
Would you be, PRs, would you be happy to have people make contributions?

01:15:00.400 --> 01:15:02.700
I make a bunch of issues now.

01:15:02.700 --> 01:15:08.900
A lot of people found some, something doesn't fit to different use cases.

01:15:09.400 --> 01:15:13.260
And so, yes, it would be great to have other contributors here.

01:15:13.260 --> 01:15:17.780
I already have 15 contributors.

01:15:17.780 --> 01:15:18.320
Yeah.

01:15:18.320 --> 01:15:18.980
Yeah.

01:15:18.980 --> 01:15:22.460
That's why I saw there's quite a few people in the sidebar there.

01:15:22.460 --> 01:15:22.720
Yeah.

01:15:22.720 --> 01:15:25.020
That's awesome.

01:15:25.280 --> 01:15:25.520
Yeah.

01:15:25.520 --> 01:15:27.920
But I need more, more and more.

01:15:27.920 --> 01:15:34.660
And especially for documentation, because I don't know, I really much better in Python

01:15:34.660 --> 01:15:35.760
than in English.

01:15:35.760 --> 01:15:40.220
And documentation is my weak point.

01:15:40.220 --> 01:15:40.840
Yeah.

01:15:40.840 --> 01:15:41.140
Okay.

01:15:41.140 --> 01:15:41.620
Cool.

01:15:41.620 --> 01:15:43.180
Well, definitely a neat project.

01:15:43.180 --> 01:15:45.060
So thank you for building it.

01:15:45.060 --> 01:15:48.500
Now, before you get out of here, you have to answer the final two questions.

01:15:49.000 --> 01:15:53.000
If you're going to write some Python code, what editor are you using these days?

01:15:53.000 --> 01:15:55.160
What did you use to create Beanie with, for example?

01:15:55.160 --> 01:15:56.720
I'm using Pesharm.

01:15:56.720 --> 01:16:03.440
JetBrains also gave me ProVersion for Beanie as support program, I think.

01:16:03.440 --> 01:16:03.860
Yeah.

01:16:03.860 --> 01:16:04.660
Yeah.

01:16:04.660 --> 01:16:05.200
Fantastic.

01:16:05.200 --> 01:16:06.820
It's really great tool.

01:16:07.940 --> 01:16:15.080
I'm expecting a new one I don't remember the name of, but so they have a new idea.

01:16:15.080 --> 01:16:16.140
I don't remember the name.

01:16:16.140 --> 01:16:16.780
Fleet.

01:16:16.780 --> 01:16:17.020
Yeah.

01:16:17.020 --> 01:16:17.340
Yeah.

01:16:17.340 --> 01:16:18.940
I was about to mention Fleet.

01:16:18.940 --> 01:16:20.520
Fleet is interesting.

01:16:20.520 --> 01:16:23.900
Fleet is like JetBrains' response to VS Code.

01:16:23.900 --> 01:16:24.480
Yeah.

01:16:24.480 --> 01:16:27.500
I'm pretty excited about it.

01:16:27.500 --> 01:16:29.160
You know, I really love PyCharm.

01:16:29.160 --> 01:16:31.740
Nobody's going to be surprised that I say that.

01:16:31.740 --> 01:16:38.720
But if I've got just one file, like I'm going to open that in VS Code because all the JetBrains

01:16:38.720 --> 01:16:42.520
IDE tools, they expect like a project and they're going to create all these things.

01:16:42.520 --> 01:16:43.620
I'm like, I just want to look at the files.

01:16:43.620 --> 01:16:45.000
Just the files, please.

01:16:45.000 --> 01:16:46.120
Like just not too much.

01:16:46.120 --> 01:16:51.180
And this is kind of like that where you can later turn on some of the IDE features, right?

01:16:51.180 --> 01:16:52.000
It looks pretty cool.

01:16:52.000 --> 01:16:53.060
You're going to try it out?

01:16:53.060 --> 01:16:53.780
Not yet.

01:16:53.780 --> 01:16:58.240
I asked for it, but so JetBrains, if you hear me, please.

01:16:58.240 --> 01:16:59.460
Yes, exactly.

01:16:59.460 --> 01:16:59.920
JetBrains.

01:16:59.920 --> 01:17:01.860
I'm already on the early access list too.

01:17:01.860 --> 01:17:03.140
And I have an email.

01:17:03.140 --> 01:17:04.780
Maybe I haven't checked it this morning.

01:17:04.780 --> 01:17:05.820
Maybe it's there.

01:17:05.820 --> 01:17:08.420
Fantastic.

01:17:08.420 --> 01:17:09.360
Yeah.

01:17:09.360 --> 01:17:10.020
All right.

01:17:10.020 --> 01:17:12.880
So PyCharm, maybe Fleet in the future, potentially.

01:17:12.880 --> 01:17:13.320
Cool.

01:17:13.320 --> 01:17:15.620
And then notable PyPI package.

01:17:15.620 --> 01:17:18.360
I mean, we've talked about a bunch of libraries already.

01:17:18.360 --> 01:17:19.080
Yeah.

01:17:19.080 --> 01:17:20.700
So I really like one.

01:17:20.700 --> 01:17:27.620
It's not about Pydanticum or FastAPI stuff, but it's a great package called YARL.

01:17:27.620 --> 01:17:30.000
Y-A-R-L.

01:17:30.000 --> 01:17:30.760
Yeah.

01:17:30.760 --> 01:17:34.560
It's like a pass library, but for URLs.

01:17:34.560 --> 01:17:36.100
And it's great.

01:17:36.100 --> 01:17:42.040
You can combine strings with this URL stuff together and you can parse it.

01:17:42.040 --> 01:17:42.680
You can...

01:17:42.680 --> 01:17:43.400
Oh, that's cool.

01:17:43.400 --> 01:17:44.180
Yeah.

01:17:44.180 --> 01:17:47.440
So you can pass it a URL as a string, just like whatever you'd expect.

01:17:47.440 --> 01:17:53.040
But then you can say, give me the scheme, which is like HTTP, HTTPS, the host, the path,

01:17:53.180 --> 01:17:53.960
the query string.

01:17:53.960 --> 01:17:55.020
Yeah.

01:17:55.020 --> 01:17:57.980
I really like how they use this divide operator.

01:17:57.980 --> 01:18:01.640
You probably see it in the bottom of your page now.

01:18:01.640 --> 01:18:04.080
Like URL, divide full, divide bar.

01:18:04.080 --> 01:18:04.920
Oh, interesting.

01:18:04.920 --> 01:18:07.600
It's like Pathlib style.

01:18:07.600 --> 01:18:08.540
It's like Pathlib, yeah.

01:18:08.540 --> 01:18:10.420
It's like Pathlib for URLs.

01:18:10.420 --> 01:18:11.440
Cool.

01:18:11.440 --> 01:18:12.600
It's super great.

01:18:12.600 --> 01:18:12.980
All right.

01:18:12.980 --> 01:18:14.040
This is totally new to me.

01:18:14.040 --> 01:18:14.440
Awesome.

01:18:14.440 --> 01:18:15.500
Good recommendation.

01:18:15.500 --> 01:18:16.360
Good recommendation.

01:18:16.680 --> 01:18:16.920
Yeah.

01:18:16.920 --> 01:18:18.460
I use it in each project now.

01:18:18.460 --> 01:18:20.660
I don't know how to live without this.

01:18:20.660 --> 01:18:21.420
All right.

01:18:21.420 --> 01:18:23.000
Well, I'm going to check it out for sure.

01:18:23.000 --> 01:18:26.260
One quick follow from the audience here.

01:18:26.260 --> 01:18:28.040
Mario says, thank you for this project.

01:18:28.040 --> 01:18:31.380
I'm about to launch my FastAPI Beanie blog soon.

01:18:31.380 --> 01:18:32.760
Couldn't have done it without it.

01:18:32.760 --> 01:18:33.460
Thank you.

01:18:33.460 --> 01:18:33.840
Yeah.

01:18:33.840 --> 01:18:35.180
And Ollie's on it.

01:18:35.180 --> 01:18:37.980
He says, Pathlibs for URLs.

01:18:37.980 --> 01:18:39.680
Indeed, it's Pathlib for URLs.

01:18:39.680 --> 01:18:40.740
Cool.

01:18:40.740 --> 01:18:41.460
That's a great one.

01:18:41.460 --> 01:18:42.060
All right.

01:18:42.060 --> 01:18:43.300
Final call to action.

01:18:43.300 --> 01:18:44.540
People want to get started with Beanie.

01:18:44.540 --> 01:18:45.300
What do you say?

01:18:45.300 --> 01:18:47.360
I would say, have fun.

01:18:47.360 --> 01:18:49.740
Awesome.

01:18:49.740 --> 01:18:55.260
I would recommend that people go and check out the, if you go to the documentation, there's

01:18:55.260 --> 01:18:59.660
a tutorial that walks you through this pretty well right there on the left.

01:18:59.660 --> 01:19:03.240
It just starts by defining a document and then initialization and so on.

01:19:03.240 --> 01:19:03.480
Yeah.

01:19:03.480 --> 01:19:03.700
Yeah.

01:19:03.700 --> 01:19:08.120
We try to do this as much simple to understand as possible.

01:19:08.120 --> 01:19:08.620
Fantastic.

01:19:08.620 --> 01:19:09.620
All right.

01:19:09.620 --> 01:19:11.120
Roman, thank you for being here.

01:19:11.120 --> 01:19:13.160
Thank you very much for being here.

01:19:14.760 --> 01:19:17.460
This has been another episode of Talk Python To Me.

01:19:17.460 --> 01:19:19.280
Thank you to our sponsors.

01:19:19.280 --> 01:19:20.880
Be sure to check out what they're offering.

01:19:20.880 --> 01:19:22.300
It really helps support the show.

01:19:22.300 --> 01:19:24.620
Take some stress out of your life.

01:19:24.620 --> 01:19:30.100
Get notified immediately about errors and performance issues in your web or mobile applications with

01:19:30.100 --> 01:19:30.400
Sentry.

01:19:30.400 --> 01:19:35.400
Just visit talkpython.fm/sentry and get started for free.

01:19:35.520 --> 01:19:39.000
And be sure to use the promo code talkpython, all one word.

01:19:39.000 --> 01:19:40.780
Want to level up your Python?

01:19:40.780 --> 01:19:44.840
We have one of the largest catalogs of Python video courses over at Talk Python.

01:19:44.840 --> 01:19:50.020
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:19:50.020 --> 01:19:52.680
And best of all, there's not a subscription in sight.

01:19:52.680 --> 01:19:55.580
Check it out for yourself at training.talkpython.fm.

01:19:55.800 --> 01:19:57.480
Be sure to subscribe to the show.

01:19:57.480 --> 01:20:00.260
Open your favorite podcast app and search for Python.

01:20:00.260 --> 01:20:01.580
We should be right at the top.

01:20:01.580 --> 01:20:06.740
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:20:06.740 --> 01:20:10.940
and the direct RSS feed at /rss on talkpython.fm.

01:20:11.780 --> 01:20:14.380
We're live streaming most of our recordings these days.

01:20:14.380 --> 01:20:17.780
If you want to be part of the show and have your comments featured on the air,

01:20:17.780 --> 01:20:22.200
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:20:22.200 --> 01:20:24.060
This is your host, Michael Kennedy.

01:20:24.060 --> 01:20:25.340
Thanks so much for listening.

01:20:25.340 --> 01:20:26.500
I really appreciate it.

01:20:26.500 --> 01:20:28.420
Now get out there and write some Python code.

01:20:28.420 --> 01:20:49.200
I'll see you next time.

