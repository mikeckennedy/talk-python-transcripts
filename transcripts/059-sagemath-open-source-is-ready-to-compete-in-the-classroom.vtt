WEBVTT

00:00:00.001 --> 00:00:03.760
What do you do when you're a high caliber mathematician or a scientist and you want to

00:00:03.760 --> 00:00:08.640
share your algorithms and code? Sounds like a job for GitHub, doesn't it? But the problem is often

00:00:08.640 --> 00:00:12.800
this work is done on proprietary platforms such as Magma, MATLAB, Mathematica, and others.

00:00:12.800 --> 00:00:18.280
Not only can you not share your licenses for, say, MATLAB, but there are often proprietary

00:00:18.280 --> 00:00:23.360
separate libraries and tools for specialized work. These are expensive products. One example

00:00:23.360 --> 00:00:29.180
from my distant past was using the wavelet toolbox on MATLAB. MATLAB itself is over $2,000

00:00:29.180 --> 00:00:35.480
and the wavelet library is another $1,000. So to share my code, you must have both licenses

00:00:35.480 --> 00:00:40.360
yourself. This is a problem. Well, if you're William Stein, you take this problem and you turn

00:00:40.360 --> 00:00:44.780
it into an opportunity to build an open source competitor to MATLAB and related platforms.

00:00:44.780 --> 00:00:50.520
This episode is all about SageMath, an open source feature-rich option for scientists and mathematicians

00:00:50.520 --> 00:00:56.580
built by over 500 contributors and consisting of over 500,000 lines of Python and Cython code.

00:00:57.080 --> 00:01:01.620
This is Talk Python To Me, episode 59, recorded May 10th, 2016.

00:01:24.340 --> 00:01:30.840
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the

00:01:30.840 --> 00:01:35.460
ecosystem, and the personalities. This is your host, Michael Kennedy. Follow me on Twitter

00:01:35.460 --> 00:01:40.380
where I'm @mkennedy. Keep up with the show and listen to past episodes at talkpython.fm

00:01:40.380 --> 00:01:46.620
and follow the show on Twitter via at Talk Python. This episode is brought to you by Hired and SnapCI.

00:01:47.000 --> 00:01:53.340
Thank them for supporting the show on Twitter via at Hired underscore HQ and at Snap underscore CI.

00:01:53.340 --> 00:01:59.080
During the conversation, we talked about running SageMath on Windows and some of the challenges there.

00:01:59.080 --> 00:02:04.100
We mentioned that the new Ubuntu subsystem coming to Windows 10 this summer may make this easier.

00:02:04.100 --> 00:02:09.520
Well, just after we recorded this episode, someone did indeed post a message to the SageMath mailing list

00:02:09.520 --> 00:02:15.780
showing it running on the Ubuntu subsystem on Windows 10. So look for more goodness in that area down the line.

00:02:15.780 --> 00:02:17.420
Now, let's chat with William.

00:02:17.420 --> 00:02:19.660
William, welcome to the show.

00:02:19.660 --> 00:02:20.120
Thank you.

00:02:20.300 --> 00:02:23.860
Yeah, it's super exciting what we have to talk about today. We're going to talk about

00:02:23.860 --> 00:02:33.300
building quite a large ecosystem of computational mathematical tools with Python and a bunch of

00:02:33.300 --> 00:02:38.820
other related technologies, Cython, C, IPython, lots of stuff, right?

00:02:38.820 --> 00:02:39.260
Mm-hmm.

00:02:39.260 --> 00:02:43.940
Yeah, it'll be a lot of fun. But before we get into it, of course, tell me your story. How do you get

00:02:43.940 --> 00:02:47.280
into programming and Python? You're a mathematician by training, right?

00:02:47.560 --> 00:02:56.540
Yes. Yeah. So I've always been into programming since I was like five years old, but I got very

00:02:56.540 --> 00:03:01.100
much into mathematics. As an undergraduate, I was a computer science major for a little while,

00:03:01.100 --> 00:03:06.260
and then I switched to mathematics since I love it, especially number theory. And then I went to

00:03:06.260 --> 00:03:13.080
graduate school at UC Berkeley from 1995 to 2000. And while I was at graduate school, I got heavily

00:03:13.080 --> 00:03:19.760
involved into computing with various objects that come up in number theory. And so I had to write a

00:03:19.760 --> 00:03:27.080
lot of code in order to compute with those objects. So I just wrote a huge amount of C++ code using a lot

00:03:27.080 --> 00:03:32.820
of the libraries in the mid-1990s. It was really painful. It would take like 30 minutes or an hour to

00:03:32.820 --> 00:03:38.960
compile, do lots of templating. And I wrote a little interpreter so I could create modular forms and

00:03:38.960 --> 00:03:47.800
other mathematical objects and compute with them. And I was doing this sort of all in isolation without

00:03:47.800 --> 00:03:53.360
using much beyond some C++ libraries. And then I found out about a computer algebra system called

00:03:53.360 --> 00:04:01.140
Magma, which was extremely powerful for computing in abstract mathematical domains. It's kind of,

00:04:01.520 --> 00:04:07.880
it's in a way, kind of a competitor to Mathematica or MATLAB, but aimed much more abstract mathematics.

00:04:07.880 --> 00:04:14.680
So it has heavy support for group theory, abstract algebra, graph theory, etc. And very little support

00:04:14.680 --> 00:04:20.060
for symbolic calculus. But it's what I needed for my PhD thesis work. So I worked really heavily on it.

00:04:20.060 --> 00:04:26.820
It's extremely powerful system. And I wrote maybe 30 or 40,000 lines of code that are included with

00:04:26.820 --> 00:04:33.980
that software. I went down and visited them in Sydney, Australia a few times. But one frustrating

00:04:33.980 --> 00:04:40.520
thing about Magma is that it's closed source. I saw a talk by Manjul Bhargava, who recently won the

00:04:40.520 --> 00:04:47.520
Fields Medal. But back in 2003, he was talking in Paris about using Magma for some research on quadratic

00:04:47.520 --> 00:04:53.820
forms. And he was running into some brick walls due to it being closed source. And I also kind of took

00:04:53.820 --> 00:05:00.620
stock of my own computing environment at the time. I used Linux, LaTeX, Emacs, and everything on my

00:05:00.620 --> 00:05:05.820
computer was open source, except Magma, which was the one program that I cared about, and which really

00:05:05.820 --> 00:05:08.420
mattered for my research. So I thought that was ridiculous.

00:05:08.420 --> 00:05:12.960
Right. That's the most important thing. Yeah, the most important thing that you actually were working

00:05:12.960 --> 00:05:17.540
with was the one that you had the least control or visibility into, right?

00:05:17.880 --> 00:05:25.160
Yeah, exactly. And at that time, I was also using Python a lot, not for mathematics, but for

00:05:25.160 --> 00:05:30.360
kind of scripting mathematics. So if I wanted to do a bunch of computations on a cluster, I would start

00:05:30.360 --> 00:05:35.680
them. I would write little scripts via Python to start up the computations. I wrote websites using

00:05:35.680 --> 00:05:41.240
Python. So I was using Python a lot, kind of as a complementary tool to mathematical computation.

00:05:41.720 --> 00:05:47.980
And so I was at least familiar with Python because of this. And it was back in 2002, 2003, when Python

00:05:47.980 --> 00:05:50.580
was more primitive than it is now.

00:05:50.580 --> 00:05:57.580
Right. That's just a little before it started to get its scientific legs under it with things like

00:05:57.580 --> 00:06:02.520
NumPy and SciPy. And it wasn't quite there, but it was on the verge of that breakout, right?

00:06:02.520 --> 00:06:08.160
Yeah. But it still was a pleasant interpreter environment. And it had modern features like

00:06:08.160 --> 00:06:13.420
multiple inheritance, you could define your own data types, had good exception handling, etc.

00:06:13.420 --> 00:06:18.880
And so I really appreciated some of the functionality it had over, say, Magma. Magma,

00:06:18.880 --> 00:06:25.740
though, has a massive library and is incredibly powerful. It misses a lot of basic features of a modern

00:06:25.740 --> 00:06:32.840
programming language, which by modern, I mean, say, at least as good as C++ in 1993. I was used to at

00:06:32.840 --> 00:06:36.600
least having exception handling and being able to define my own classes and so on.

00:06:36.820 --> 00:06:42.440
Right. That's one of the challenges of not just Magma, I would say, but, you know, things like

00:06:42.440 --> 00:06:49.580
R to some degree, MATLAB, Mathematica, all these various highly specialized tools that are great at

00:06:49.580 --> 00:06:54.760
solving some type of computation or some kind of problem. But when you have to go and build a full

00:06:54.760 --> 00:06:58.920
application out of it or something, it kind of hits a wall, right?

00:06:58.920 --> 00:07:04.900
Yeah, exactly. There are a whole bunch of special purpose math languages designed by mathematicians.

00:07:04.900 --> 00:07:12.020
And though they are pretty good for mathematics, they don't really compete with what you get when

00:07:12.020 --> 00:07:17.660
you have computer science people systematically put full-time effort into designing a language

00:07:17.660 --> 00:07:22.920
and then a whole ecosystem around that language. And so the difference between trying to write a

00:07:22.920 --> 00:07:28.560
non-trivial program in Python versus Magma is that with Python, you have this massive ecosystem of

00:07:28.560 --> 00:07:33.100
tools plus a language that's very general purpose. Whereas with Magma or Mathematica or MATLAB,

00:07:33.520 --> 00:07:39.640
it's really good maybe for parts of the math things, but for the other parts, just manipulating strings

00:07:39.640 --> 00:07:41.080
or whatever, it can be pretty painful.

00:07:41.080 --> 00:07:48.720
Yeah, absolutely. So you were working with Magma and you couldn't really use it in the way that you

00:07:48.720 --> 00:07:54.240
wanted to, sort of like a web front end or as the backend for a web front end. And that's one of the

00:07:54.240 --> 00:07:59.620
problems you run into a lot with these types of software. I'm specifically thinking of MATLAB because

00:07:59.620 --> 00:08:03.900
I have the most experience with it, but there's all sorts of little, you know, pay for this bit,

00:08:03.900 --> 00:08:10.600
pay for that bit. It's registered on that machine. Like the rules are just crazy, right? And so you got

00:08:10.600 --> 00:08:11.600
frustrated with this. Yeah.

00:08:11.600 --> 00:08:18.940
Yeah. So in particular with Magma, the project director sent me in a message saying that I wasn't

00:08:18.940 --> 00:08:25.100
allowed to use it as a general purpose compute engine on the backend for my websites. And that

00:08:25.100 --> 00:08:28.980
was very frustrating. It wasn't just a matter of pay them or not pay them or get the right license

00:08:28.980 --> 00:08:32.660
since they're a little more informal than that. And they don't really have kind of official licenses.

00:08:33.160 --> 00:08:39.820
So that was like a huge wake up call that I really needed to do something. And so I decided I was going

00:08:39.820 --> 00:08:44.840
to survey the open source landscape again for math software and see what's out there and then switch.

00:08:44.840 --> 00:08:52.500
But when I looked around, it was really kind of frustrating back then. There were a number of

00:08:52.500 --> 00:08:59.280
programs that kind of competed with Magma, but were much more specialized. And despite Magma's language

00:08:59.280 --> 00:09:04.880
being fairly primitive compared to say Python, the other systems had languages that were much, much more

00:09:04.880 --> 00:09:11.180
primitive yet. So, I mean, it's kind of hard to emphasize how primitive they are. It's kind of like

00:09:11.180 --> 00:09:17.620
using, I don't know, assembly programming. I mean, things like different namespaces, that sort of thing is,

00:09:17.620 --> 00:09:23.740
is an advanced feature compared to what's available in some of those languages. So I couldn't really bring

00:09:23.740 --> 00:09:29.800
myself to go back to that. And also there's a huge amount of functionality that got implemented in Magma

00:09:29.800 --> 00:09:36.180
over about a decade. And it just wasn't implemented anywhere in open source, which was a serious problem

00:09:36.180 --> 00:09:43.020
as well. So there was just a massive lack of functionality. So what I decided naively first to

00:09:43.020 --> 00:09:49.760
do is just choose a language. And I spent about six months to a year evaluating options like OCaml and

00:09:49.760 --> 00:09:55.920
directly writing something myself in C++ and using Python. And at the end of the day, I chose Python

00:09:55.920 --> 00:10:01.440
because the language was most similar to Magma's. And so I thought it would be easier to get users over

00:10:01.440 --> 00:10:09.020
from Magma. And also the Python C API was kind of like what Magma had, but much cleaner as far as how

00:10:09.020 --> 00:10:15.380
Magma itself is implemented. And so one thing about Python is that if you want to write a function that you

00:10:15.380 --> 00:10:20.640
can use from the interpreter and is really fast, you can write it in C if you need to. And it's just as fast as if

00:10:20.640 --> 00:10:24.520
you wrote it in C. And that's kind of a basic requirement if you're going to write code that will be used for

00:10:24.520 --> 00:10:30.300
research, that you can write very, very fast code. So Python was good enough. And then I decided I would just sit down

00:10:30.300 --> 00:10:36.380
in Python C and me, and I would look at maybe code from other projects and look up algorithms and implement

00:10:36.380 --> 00:10:43.340
everything I needed. And this lasted about three hours. And I realized how insanely hard that would be to do.

00:10:43.540 --> 00:10:50.680
And I completely switched courses and decided that purely out of laziness, I would try to wrap existing

00:10:50.680 --> 00:10:59.540
code in whatever way I had to do so. So using P expect pseudo TTY type stuff, using C libraries,

00:10:59.540 --> 00:11:04.860
and we're adding C libraries to existing computer algebra systems, etc.

00:11:04.860 --> 00:11:09.600
So maybe not everyone knows expect. Actually, a lot of people don't know. What was it? They know

00:11:09.600 --> 00:11:15.480
C, of course, but what does P expect? So one way if you have a, say, Python program,

00:11:15.480 --> 00:11:21.960
and you'd like it to interact with some other kind of bizarre, let's just let's say there's a program

00:11:21.960 --> 00:11:26.500
called Symmetrica or something, just some one researcher wrote it has a command line interface,

00:11:26.500 --> 00:11:31.140
and it doesn't have any C library interface or anything. But you really want to call functions

00:11:31.140 --> 00:11:36.600
in there and run some code there and get the results. What P expect will do is let you basically

00:11:36.600 --> 00:11:43.080
simulate the terminal and use Python to programmatically feed code into the other program,

00:11:43.080 --> 00:11:48.880
look at what output it produces, and then parse that output and return it. So it abstracts things away

00:11:48.880 --> 00:11:54.040
and makes it look like you're calling some functions in a Python library. But really behind the scenes,

00:11:54.120 --> 00:12:00.320
things are really more or less being copy pasted into a terminal. It's nice because you can interface

00:12:00.320 --> 00:12:07.200
with a black, a closed source black box this way, if you need to. And the drawback is that it's brittle,

00:12:07.200 --> 00:12:13.200
and it's potentially slow. There's a lot of latency. Instead of, well, there's a several millisecond

00:12:13.200 --> 00:12:18.040
overhead to every single thing you do, which is painful. You really want the overhead to be a microsecond,

00:12:18.160 --> 00:12:23.980
not a milliseconds. So there's like a order of magnitude of 1000 latency, which can be really

00:12:23.980 --> 00:12:30.260
annoying. Interesting. So yeah, yeah. So you were, you were naive and hopeful and you just said,

00:12:30.260 --> 00:12:35.460
I'm going to go write this. And then you basically just said, all right, forget that. Let's try to find

00:12:35.460 --> 00:12:40.320
all the good building blocks that are already built and build upon them. And that's a very open source

00:12:40.320 --> 00:12:45.920
way of problem solving as anyway, right? Yep. So I think about it this way. Like when I worked with Magma,

00:12:46.080 --> 00:12:51.720
my team was all the other people, you know, working on that project. And when I switched to trying to do

00:12:51.720 --> 00:12:55.920
something open source, the team was all other people in the entire open source sort of world,

00:12:55.920 --> 00:13:00.400
everybody that contributed to open source. And definitely the easy way to go would be to

00:13:00.400 --> 00:13:05.680
choose the best libraries for number theory and commutative algebra and graph theory and so on and

00:13:05.680 --> 00:13:11.180
put them all together. And they weren't kind of built to be put together or to be called from Python,

00:13:11.180 --> 00:13:17.560
Python. But it, no matter how hard it would be, it's way easier to provide a library interface to

00:13:17.560 --> 00:13:22.240
one of those other systems that you can then use from Python very efficiently than to write one of

00:13:22.240 --> 00:13:28.000
those systems from scratch. Like each of those systems took decades and decades of work to write.

00:13:28.000 --> 00:13:29.820
So, I mean, total.

00:13:29.820 --> 00:13:34.940
Yeah. And to debug them and fine tune them and, you know, that kind of stuff's very hard to know,

00:13:34.940 --> 00:13:36.500
even if it's right some of the time.

00:13:36.500 --> 00:13:40.640
And a lot of the algorithms, you really kind of have to be in the throes of a PhD

00:13:40.640 --> 00:13:44.860
focused for years just to understand what the algorithms are and how they work. And

00:13:44.860 --> 00:13:49.300
like, there's just no way one person can replicate that despite wanting to.

00:13:50.300 --> 00:13:57.760
That's interesting. So in the end, you decided, all right, Magma is cool, but it's, it's got all

00:13:57.760 --> 00:14:01.220
these restrictions and I'm going to go put this thing together. And what you built was called

00:14:01.220 --> 00:14:02.400
SageMath, right?

00:14:02.400 --> 00:14:12.720
Yes. Yep. So I built SageMath, which is, well, basically what it is, is it's a Python library,

00:14:13.300 --> 00:14:20.640
but many of the dependencies are these tricky to compile C programs or Fortran programs or whatever,

00:14:20.640 --> 00:14:26.740
which were written by mathematicians only to run on Linux, maybe just for their research.

00:14:26.740 --> 00:14:30.640
And so in addition to just being a Python library, it's also a build system,

00:14:30.640 --> 00:14:37.540
kind of like Anaconda, but obviously a little bit before that. And it targets a different type of

00:14:37.540 --> 00:14:43.280
dependence, like different types of packages. It's a build system. It's a Python library,

00:14:43.280 --> 00:14:48.300
library. And then to make it more friendly for mathematicians, it has a customized IPython

00:14:48.300 --> 00:14:55.800
command line. And also around 2006, we wrote a web-based graphical interface, which is like the

00:14:55.800 --> 00:15:00.840
IPython notebook, but we wrote it a few years earlier. And it was before things like WebSockets

00:15:00.840 --> 00:15:04.260
and a lot of nice modern JavaScript functionality existed.

00:15:04.260 --> 00:15:09.020
Back in the dark days of JavaScript, when it was earning its bad reputation.

00:15:09.020 --> 00:15:13.680
Yep. It was, we started writing it right when I think Google Maps and Gmail appeared.

00:15:13.680 --> 00:15:19.580
And there was this thing called Ajax, which let you update a web page without refreshing.

00:15:19.580 --> 00:15:23.760
And so we had that little bit of functionality, but the thing we didn't get was a consistent

00:15:23.760 --> 00:15:29.860
or a persistent connection. So instead we had to do polling techniques and all kinds of tricks that

00:15:29.860 --> 00:15:30.280
were ugly.

00:15:30.280 --> 00:15:31.260
Yeah. Very interesting.

00:15:31.260 --> 00:15:35.460
In order to make it like, when you do a for loop in Python, you want to see the output as it appears.

00:15:35.460 --> 00:15:38.540
And in order to do that, we had to do a lot of hacky stuff.

00:15:38.540 --> 00:15:43.580
Yeah. So I think the way maybe to conceptualize it is this is an open source alternative to

00:15:43.580 --> 00:15:45.020
something like Mathematica.

00:15:45.020 --> 00:15:45.740
Exactly.

00:15:45.740 --> 00:15:52.480
Or MATLAB maybe, but it's, it leverages a lot of the good data science, scientific tooling

00:15:52.480 --> 00:15:55.120
of Python, like IPython notebooks, for example.

00:15:55.120 --> 00:16:02.120
Exactly. So initially I just wanted it to be good enough for my number theory research, number

00:16:02.120 --> 00:16:07.340
theory being my research area. But the second developer wasn't a number theorist. The second

00:16:07.340 --> 00:16:12.680
person I could get on board is did research in coding theory. And so he wanted a bunch of

00:16:12.680 --> 00:16:16.620
functionality that had little to do with number theories. And then he also wanted to teach

00:16:16.620 --> 00:16:21.200
undergraduate courses like calculus and differential equations. And so I started adding a lot of

00:16:21.200 --> 00:16:26.620
functionality related to those classes, just so that the range of applicability would get

00:16:26.620 --> 00:16:31.040
bigger and I could get a few more developers and things sort of growing, started growing

00:16:31.040 --> 00:16:36.360
that way. And so this, the system quickly went from being just for number theory to being much

00:16:36.360 --> 00:16:42.620
more general. And in order to kind of focus development and decide what it should be, we chose the motto

00:16:42.620 --> 00:16:49.740
or the mission statement to create a viable open source free alternative to Magma, Mathematica,

00:16:49.960 --> 00:16:55.420
Matlab and Maple. Our focus, none of the developers really have a focus on numerical computation.

00:16:55.420 --> 00:17:03.480
So we, in Sage itself, in the Sage library, focus more on algebraic aspects of things. So arbitrary

00:17:03.480 --> 00:17:10.060
precision arithmetic, working with very quickly with large integers and rational numbers, doing linear algebra,

00:17:10.060 --> 00:17:16.340
where you have no roundoff error, that sort of thing. And for the more numerical parts, the kind of viable

00:17:16.340 --> 00:17:20.300
alternative to Matlab, we just incorporate libraries like NumPy, SciPy,

00:17:20.300 --> 00:17:22.220
et cetera. Yeah.

00:17:22.220 --> 00:17:25.420
Which the Python community has done an amazing job of developing over the years.

00:17:25.420 --> 00:17:27.560
Right. And that's definitely gaining speed now, right?

00:17:27.560 --> 00:17:32.400
Yeah. It's absolutely incredible now. I mean, we wanted all along to be a viable alternative

00:17:32.400 --> 00:17:36.700
to Matlab. And I remember in 2006, trying to write statistics,

00:17:36.700 --> 00:17:42.580
functionality, and all this kind of stuff for Sage directly. And just being like, I don't want to do

00:17:42.580 --> 00:17:46.020
this at all, but it's part of what we're trying to do to get more users. So here I am doing it.

00:17:46.020 --> 00:17:52.380
And I'm so happy that the community has come along and just made Python absolutely first rate in

00:17:52.380 --> 00:17:56.460
statistics and numerical computing so that we can just incorporate that functionality.

00:17:56.460 --> 00:18:00.560
Yeah, that's really great. One thing I think before we get too far into the details would be

00:18:00.560 --> 00:18:06.420
interesting for the listeners is just the scale of this project, the number of developers, number of

00:18:06.420 --> 00:18:10.440
lines of code, the technologies involved. Could you just give them like a quick sense of that?

00:18:10.800 --> 00:18:18.440
Sure. So the project itself incorporates about 100 packages. We have done a lot of development at what

00:18:18.440 --> 00:18:27.560
we call Sage Days workshops. And those we often have about 10 to 15 per year. We've had, I think,

00:18:27.560 --> 00:18:33.960
80 Sage Days workshops so far. They're kind of inspired by the pypy workshops that happened about

00:18:33.960 --> 00:18:38.760
a couple of years ago. But basically, we come together for a week and do lots of development.

00:18:39.160 --> 00:18:43.480
The number of contributors to Sage is around 500. So those are people who have contributed

00:18:43.480 --> 00:18:49.480
directly to the Sage library. Of course, Sage itself incorporates all these other open source

00:18:49.480 --> 00:18:55.940
packages, which have their own contributor groups. The amount of source code, I don't know the exact

00:18:55.940 --> 00:19:02.320
number, but it's on the order of several hundred thousand lines of actual code. And the code is about

00:19:02.320 --> 00:19:11.120
maybe 60% Python and maybe 40% Cython code. So there's a very, very large amount of Cython code that we've

00:19:11.120 --> 00:19:19.940
written. And functionality wise, we do cover very wide range of areas of mathematics. So almost anytime

00:19:19.940 --> 00:19:25.720
somebody comes to use it, they find that there is something for the area of math that they're interested in.

00:19:25.720 --> 00:19:42.140
This episode is brought to you by Hired. Hired is a two sided curated marketplace that connects the

00:19:42.140 --> 00:19:47.440
world's knowledge workers to the best opportunities. Each offer you receive has salary and equity presented

00:19:47.440 --> 00:19:52.000
right up front, and you can view the offers to accept or reject them before you even talk to the company.

00:19:52.700 --> 00:19:57.140
Typically candidates receive five or more offers within the first week and there are no obligations

00:19:57.140 --> 00:20:02.180
ever. Sounds awesome, doesn't it? Well, did I mention the signing bonus? Everyone who accepts a job

00:20:02.180 --> 00:20:07.140
from Hired gets a thousand dollar signing bonus. And as Talk Python listeners, it gets way sweeter.

00:20:07.140 --> 00:20:12.860
Use the link Hired.com slash Talk Python To Me and Hired will double the signing bonus to $2,000.

00:20:12.860 --> 00:20:18.420
Opportunities knocking. Visit Hired.com slash Talk Python To Me and answer the call.

00:20:18.420 --> 00:20:30.540
That's awesome. That's a really large scale project. And I think it's a cool success story.

00:20:30.540 --> 00:20:38.260
So it's written in Python and Cython, which is kind of a flavor of Python. But you also chose Python as

00:20:38.260 --> 00:20:45.840
basically the programming language of the system itself, right? Like MATLAB has its .in files with its own

00:20:45.840 --> 00:20:50.320
language. Mathematica has their own language. But you sort of said, hey, Python is a good match for

00:20:50.320 --> 00:20:51.640
the mathematicians.

00:20:51.640 --> 00:21:00.580
Yes. So this is a decision that I made, I would say, purely out of laziness originally. As a CS undergrad,

00:21:00.580 --> 00:21:07.560
I had written an interpreter. I took a course in writing interpreters. And I tried to do that again

00:21:07.560 --> 00:21:13.180
for some of my number three research. And I also had just seen how hard it is to really develop a

00:21:13.180 --> 00:21:19.080
programming language. And I really didn't want to do it. And moreover, the MAGMA group, I had often made

00:21:19.080 --> 00:21:23.500
requests for them to improve their language. And they responded that though they could get grant funding

00:21:23.500 --> 00:21:29.720
for the mathematical algorithms, they had a huge amount of trouble getting any funding for the actual

00:21:29.720 --> 00:21:34.660
language because their funding sources were in mathematics. So I was kind of scared for a number of

00:21:34.660 --> 00:21:42.380
reasons off from writing my own language. And basically, I'm like, well, I mean, it just follows

00:21:42.380 --> 00:21:47.780
the same principle of reusing third party libraries and computer algebra systems to reuse a third party

00:21:47.780 --> 00:21:54.380
language as well. I decided to use Python. It was criticized a lot by math people, because like literally

00:21:54.380 --> 00:21:59.980
every other project like Sage that's ever happened up until that point used their made up their own

00:21:59.980 --> 00:22:03.980
language was kind of like the thing you had to do. How has that criticism changed over time?

00:22:03.980 --> 00:22:07.360
Do they still feel that way? Or has it become more accepted?

00:22:07.360 --> 00:22:14.840
Way more accepted. And it's now considered a huge advantage. And often when people when I hear people

00:22:14.840 --> 00:22:20.660
convincing other people to switch from Mathematica to Sage, at all levels, both at research and undergrad

00:22:20.660 --> 00:22:26.900
teaching, one of the biggest, maybe the strongest arguments is that Python, the language is just a better

00:22:26.900 --> 00:22:32.580
language. Because the syntax is easier for the students. And it's it prepares them for other

00:22:32.580 --> 00:22:38.720
possible employment opportunities and down the line. So that's pretty interesting. Because when

00:22:38.720 --> 00:22:46.340
I was studying math at university, I did study C++ and scheme and other things because I took some

00:22:46.340 --> 00:22:52.360
computer science classes. But my math education really taught me just the math,

00:22:52.900 --> 00:22:58.100
math lab language, whatever you call that. I'm sure there's a name for it. But you know,

00:22:58.100 --> 00:23:05.280
that that's a very limited skill set to take away if I go out into the job market, right? But if people

00:23:05.280 --> 00:23:11.060
as part of learning their their math and doing their research, their statistics, whatever, become

00:23:11.060 --> 00:23:18.020
semi-proficient in Python, just sort of silently in the background, that's a really cool side effect.

00:23:18.020 --> 00:23:25.380
Yeah. And I have had many PhD students who learned Python really, really well as a result of working

00:23:25.380 --> 00:23:32.040
with me. And they really do use it in their jobs today. Like one of them, Robert Miller, who wrote a

00:23:32.040 --> 00:23:37.340
huge amount of our graph theory functionality, now works as a data scientist at Google. And another one,

00:23:37.340 --> 00:23:42.400
Simon Spicer, also works as a data scientist, but at Facebook. And they use Python, both of them use

00:23:42.400 --> 00:23:43.800
Python really heavily in their jobs.

00:23:43.800 --> 00:23:45.620
That's cool. Do you know if they use SageMath there?

00:23:45.620 --> 00:23:50.960
I don't think either of them use SageMath for their jobs. But I do know that SageMath is used

00:23:50.960 --> 00:23:54.020
at Google by some people, but not necessarily my students.

00:23:54.020 --> 00:23:59.460
Okay, yeah, that's very cool. What would you say to people who are maybe just straight up using

00:23:59.460 --> 00:24:07.120
NumPy or Matplotlib today? Maybe they're using an IPython notebook, like, should they consider using

00:24:07.120 --> 00:24:08.820
SageMath? And what would it offer them?

00:24:08.820 --> 00:24:14.800
It depends on what you're doing. So SageMath does symbolic things, and it can be very efficient at

00:24:14.800 --> 00:24:19.780
doing them. Like you have a large matrix, and you want to do something with it, and you want to have

00:24:19.780 --> 00:24:25.300
no rounding errors at all. Or you want to do something with linear algebra over finite fields or coding

00:24:25.300 --> 00:24:31.980
theory. Basically, Sage provides a lot of functionality that's complementary to the numerical things that are

00:24:31.980 --> 00:24:40.660
offered by NumPy and SciPy. It overlaps some with SymPy, S-Y-M-P-Y, though it has a lot of functionality that isn't in

00:24:40.660 --> 00:24:48.760
SymPy. And in many cases, it can be a lot faster. So also, another remark is that Sage now uses Jupyter

00:24:48.760 --> 00:24:53.640
Notebooks as our default graphical user interface. So when you download and install Sage, you get Jupyter

00:24:53.640 --> 00:25:00.960
Notebooks. One big drawback, which I hope to address in the future, is that currently, by far, the easiest way to use

00:25:00.960 --> 00:25:07.420
Sage is to install our self-contained distribution. And it's completely separate, really, from PyPy,

00:25:07.420 --> 00:25:13.000
the Python packaging repository. And it's not something that you can just install in your own

00:25:13.000 --> 00:25:18.980
Python environment. Right. There's no pip install SageMath. Yeah. Not yet. Yeah. I really, really hope

00:25:18.980 --> 00:25:24.120
there will be in the future. But right now, that isn't the case. Right. And so that interferes with easy

00:25:24.120 --> 00:25:30.080
adoption by existing Python users. That's true. But you do have a pretty decent way of getting it. You can go

00:25:30.080 --> 00:25:38.880
like on the Mac, you can go download just a DMG, just a disk image. Or on Linux, you can get a tarball.

00:25:38.880 --> 00:25:42.820
And it's kind of all self-contained there. So it's not too hard to get started with, right?

00:25:42.820 --> 00:25:49.560
Yeah. A lot of our users just want to do math rather than deal with installation. And so we do put a huge

00:25:49.560 --> 00:25:57.160
amount of effort into making it easy to just install. So we have Windows, Linux, and OS X binaries ready to go.

00:25:57.160 --> 00:26:03.420
So the Windows one currently is a virtual machine that you run. And then it provides a server. And

00:26:03.420 --> 00:26:05.680
then you get a Jupyter notebook that you can use Sage through.

00:26:05.680 --> 00:26:12.400
I see. So maybe you run Internet Explorer, but then you're requesting back into like a Linux thing on a

00:26:12.400 --> 00:26:13.280
virtual box or something?

00:26:13.280 --> 00:26:17.660
Exactly. Yeah. That's how currently, that's our main supported environment in Windows right now.

00:26:17.660 --> 00:26:22.300
Okay. Yeah. That's an easier way to get some of those libraries to compile for Windows, right?

00:26:22.420 --> 00:26:27.340
Yeah. That is a seriously hard problem to get some of those libraries that were not built for Windows,

00:26:27.340 --> 00:26:30.400
the C libraries or Fortran to compile there, right?

00:26:30.400 --> 00:26:37.720
It's really, really hard. We've, we tried for years and are still trying to natively port Sage to Windows.

00:26:38.400 --> 00:26:41.780
And I don't know if or when it will ever succeed.

00:26:41.780 --> 00:26:43.140
Yeah. Yeah. Interesting.

00:26:43.140 --> 00:26:47.680
It's like a, I don't know, in the Sage project, there's a lot of these sort of tall mountains that are

00:26:47.680 --> 00:26:53.880
very difficult to climb and four or five people will try and fail. And then the sixth person will succeed.

00:26:53.880 --> 00:27:00.620
Like writing a really good implementation of working with what are called finite abelian groups was one

00:27:00.620 --> 00:27:04.940
thing where it just seemed like one person after the other tried and failed. And then eventually somebody got it.

00:27:05.400 --> 00:27:09.680
And I hope porting Sage to Windows will be a similar thing. Some combination of

00:27:09.680 --> 00:27:16.400
the right approach and Microsoft Windows getting more friendly to PostSix style programs.

00:27:16.400 --> 00:27:22.180
Yeah. Well, you know, did you, I don't know if you heard, you are in Seattle, right? So maybe you heard

00:27:22.180 --> 00:27:28.120
that Microsoft in this summer, they're shipping a new version of Windows 10 and it comes

00:27:28.120 --> 00:27:33.000
with the ability to run native Linux binaries on the command line.

00:27:33.000 --> 00:27:38.480
Yeah. So that's just awesome. And Microsoft is going in the right direction that we should

00:27:38.480 --> 00:27:43.160
have something that works natively by maybe using, well, using that. It sounds really likely

00:27:43.160 --> 00:27:43.500
actually.

00:27:43.500 --> 00:27:48.500
It's, it was, it's gotta be a huge step in the right direction for you guys. So I don't

00:27:48.500 --> 00:27:50.620
know if it'd fix it, but it's definitely not a negative.

00:27:50.620 --> 00:27:51.880
Yep. Absolutely.

00:27:51.880 --> 00:27:56.720
So one thing that's interesting, well, there's, there's a bunch of interesting things I want

00:27:56.720 --> 00:28:03.060
to ask you about this. Let's start with this one. So doing math is obviously computational,

00:28:03.060 --> 00:28:10.860
right? Computationally intensive and having more computational power is, is key on modern

00:28:10.860 --> 00:28:12.580
hardware. That means parallelism, right?

00:28:12.580 --> 00:28:16.080
Yep. It can.

00:28:16.080 --> 00:28:21.280
How does it leverage, like multi-core machines? Does it support like parallel computational

00:28:21.280 --> 00:28:23.160
parallelism and things like that in it?

00:28:23.160 --> 00:28:30.880
So one thing that surprises me a lot over the years, at least in pure mathematics, the

00:28:30.880 --> 00:28:35.940
sort of parallelism that we have to do is usually what's called embarrassingly parallel sometimes.

00:28:35.940 --> 00:28:41.720
So somehow it's a lot easier than what people do in numerical computing with, you know, earthquake

00:28:41.720 --> 00:28:46.900
simulation or whatever, where they have some big distributed computation and each step depends

00:28:46.900 --> 00:28:51.280
on previous steps and there's lots of data flying all over the place and you have to use MPI or

00:28:51.280 --> 00:28:58.180
something to do it. So the parallelization that typically comes up is you want to evaluate some

00:28:58.180 --> 00:29:04.020
function F, 10,000 values of N. And so you just do it pretty easily and there's no real

00:29:04.020 --> 00:29:11.920
dependencies between them. So basically using fork, just using stuff built around fork, you can do pretty

00:29:11.920 --> 00:29:17.520
good parallelization that works pretty well for us as I've found.

00:29:17.520 --> 00:29:23.820
Yeah. Okay. So in the embarrassingly parallel case, you just basically split it across processes

00:29:23.820 --> 00:29:27.720
or something like that and a problem is solved, right? They've, they got their own guild, but who

00:29:27.720 --> 00:29:28.760
cares? Cause it's theirs.

00:29:28.760 --> 00:29:34.700
And you also, if you use a database, so you have your, you can have a process startup query a database

00:29:34.700 --> 00:29:40.180
for some things that haven't been done, do them and put the results back in. So simple techniques

00:29:40.180 --> 00:29:46.400
like that have pretty kept, I don't know, the community pretty happy. Some of our parallelization

00:29:46.400 --> 00:29:51.920
issues aren't too ridiculously hard. There are, there are much more subtle, interesting, like low

00:29:51.920 --> 00:29:58.400
level parallelization techniques that go into Sage where there's some C library or C++ library,

00:29:58.400 --> 00:30:03.560
some Sage developer writes like David Harvey is a guy who wrote some super fast code for

00:30:03.560 --> 00:30:11.200
polynomial multiplication and it uses parallelization techniques. And so Sage just kind of, or really Sage

00:30:11.200 --> 00:30:17.060
via some, via Python just calls out to this library. The library happens to do things in parallel and

00:30:17.060 --> 00:30:21.860
then give back a result. And so there's lots of little places like that where we have libraries

00:30:21.860 --> 00:30:26.420
that just implicitly do things in parallel. They're like highly multi-threaded and you don't even know

00:30:26.420 --> 00:30:31.200
they're, they're doing it unless you, you know, explicitly look right. So there's that level.

00:30:31.200 --> 00:30:37.240
And then there's also the level of other, of forking. I wrote a decorator for Python called

00:30:37.240 --> 00:30:43.220
parallel, which is included in Sage. So you put app parallel before a function. And then if you call

00:30:43.220 --> 00:30:49.600
it with a list of inputs, it will, it'll fork the process, call the function with each of those inputs

00:30:49.600 --> 00:30:54.220
up to the number of processors you have, and then get the results and give them back to you as a generator.

00:30:54.680 --> 00:30:58.620
So there's some little things like that that are built into Sage and it takes care of some

00:30:58.620 --> 00:31:04.400
possibly tricky surprises that would happen behind the scenes involving sub processes and so on.

00:31:04.400 --> 00:31:09.460
That's really awesome. That's a very, Pythonic little statement you made there. I'm going to put a

00:31:09.460 --> 00:31:14.340
decorator on it. It's going to, you know, fork this off and return it as a generator. I mean, that's,

00:31:14.340 --> 00:31:15.200
that is really great.

00:31:15.200 --> 00:31:22.500
Yeah. And it works really well. We have code that like nested functions written in Cython that just

00:31:22.500 --> 00:31:26.560
happen to have an app parallel decorator on them and then they'll fork and regroup properly.

00:31:26.560 --> 00:31:31.940
And the code itself is just probably two pages of code, maybe three pages. It's not a lot of code.

00:31:31.940 --> 00:31:38.300
Yeah. It's just getting the right, concept or the Zen of the style to make it really,

00:31:38.300 --> 00:31:39.780
um, expressive or whatever. Right.

00:31:39.920 --> 00:31:44.320
Yep. there's a lot of, there's a ton of pieces of little things like that all over in Sage,

00:31:44.320 --> 00:31:50.240
where I would like to separate them out as Python libraries, like individual standalone Python

00:31:50.240 --> 00:31:56.660
libraries, and then have Sage pip install them as part of its kind of build process. So that would

00:31:56.660 --> 00:32:00.700
make them much more widely available to the community. And then when they're running the context of Sage,

00:32:00.700 --> 00:32:04.940
they would know to do the extra things that Sage needs and they wouldn't do those things.

00:32:04.940 --> 00:32:11.220
otherwise. We also have a pre-parser. So for mathematicians, just an example, if you type two

00:32:11.220 --> 00:32:18.040
slash three in Python two, which is what Sage uses, you get zero, which is floor division in Python three,

00:32:18.040 --> 00:32:24.840
you get 0.666666. And neither of those are what pure mathematician expects. Pure mathematician

00:32:24.840 --> 00:32:31.180
expects to get two thirds, which is like an exact rational number. So in Sage, we have a little pre-parser.

00:32:31.180 --> 00:32:35.740
So when you use Sage directly via its own command line, which is this modified IPython

00:32:35.740 --> 00:32:41.120
interactive command line, it will take each line of input and then do a little bit of parsing to it.

00:32:41.120 --> 00:32:47.180
for example, when you type two slash three, it replaces it by integer of two slash integer of three.

00:32:47.180 --> 00:32:51.900
And then that allows you to make your own custom integer type. And then there's a bunch of other

00:32:51.900 --> 00:32:57.320
things similar to that. would like, for example, when you use the carrot symbol, which in Python

00:32:57.320 --> 00:33:02.440
means exclusive or a lot of mathematicians are used to that meaning exponentiation because that's what

00:33:02.440 --> 00:33:03.260
it means in LaTeX.

00:33:03.260 --> 00:33:06.180
Right. Not as opposed to double star or something like this. Yeah.

00:33:06.180 --> 00:33:11.600
Yeah. It's really like, so in Sage, when you type the carrot symbol, it gets converted to double star

00:33:11.600 --> 00:33:17.400
before it gets sent to Python. So there's, you don't do it. Mathematicians almost never do exclusive

00:33:17.400 --> 00:33:23.560
or, but they do exponentiation constantly when typing in polynomials and all kinds of things.

00:33:23.560 --> 00:33:28.760
so it's this optional thing that makes the Sage interface more friendly to mathematicians. It gives

00:33:28.760 --> 00:33:34.500
us our own kind of new language, but in a very well-defined minimal way, which is just built on top of

00:33:34.500 --> 00:33:40.920
Python. And in most cases, the things that get pre-parsed would be invalid Python code. And it would be nice to

00:33:40.920 --> 00:33:45.560
connect us with Python packages. It would be nice if we could take this pre-parser and make it a standalone

00:33:45.560 --> 00:33:52.840
Python package, which Sage just happens to use. And maybe like we have various interesting functionality in there,

00:33:52.840 --> 00:34:00.140
like square brackets, one dot dot 10 gives you the list of numbers from one to 10. It's kind of like the notation you'd have in

00:34:00.140 --> 00:34:06.820
MATLAB or Maple instead of using the range function. And there was a Python PEP to implement it, but it didn't get

00:34:06.820 --> 00:34:12.940
accepted. But so many Sage people wanted it. Robert Bradshaw just implemented it anyways and added it to the pre-parser.

00:34:13.300 --> 00:34:18.900
So it would be kind of neat if this whole pre-parser were made more generally available and then Sage just happened to use it.

00:34:34.120 --> 00:34:39.860
Continuous delivery isn't just a buzzword. It's a shift in productivity that will help your whole team become more efficient.

00:34:39.860 --> 00:34:46.040
With SnapCI's continuous delivery tool, you can test, debug, and deploy your code quickly and reliably.

00:34:46.040 --> 00:34:51.920
Get your product in the hands of your users faster and deploy from just about anywhere at any time.

00:34:51.920 --> 00:34:57.140
And did you know that ThoughtWorks literally wrote the book on continuous integration and continuous delivery?

00:34:57.940 --> 00:35:02.300
Connect Snap to your GitHub repo and they'll build and run your first pipeline automagically.

00:35:02.300 --> 00:35:08.900
Thanks SnapCI for sponsoring this episode by trying them for free at snap.ci slash talkpython.

00:35:17.980 --> 00:35:21.840
Maybe it could even have different grammars for different areas.

00:35:21.840 --> 00:35:25.120
Like maybe geologists do something different for the mathematicians. Who knows?

00:35:25.120 --> 00:35:31.820
Yeah. And so maybe somebody is proposing some great matrix operations to include in Python eventually.

00:35:31.820 --> 00:35:35.060
And maybe they get added to Python 3, but they're not in Python 2.

00:35:35.060 --> 00:35:36.920
You could use the pre-parser and still have those.

00:35:36.920 --> 00:35:39.400
And everything just gets converted to straight Python.

00:35:39.400 --> 00:35:43.100
So you could convert everything and then stick it in a Python library if you need to.

00:35:43.100 --> 00:35:43.880
That's cool.

00:35:43.880 --> 00:35:50.720
You said that in your documentation you say you have a UI kit for adding user interfaces to calculations and the app.

00:35:50.720 --> 00:35:52.200
That sounds pretty cool.

00:35:52.200 --> 00:35:55.000
What's the UI technology there and how does that work?

00:35:55.000 --> 00:35:56.720
Do you remember?

00:35:56.720 --> 00:35:59.760
Yeah, I'm not quite sure what that refers to.

00:35:59.760 --> 00:36:00.900
Yeah, okay. No worries.

00:36:00.900 --> 00:36:01.980
Yeah, sorry.

00:36:01.980 --> 00:36:03.880
That was written long ago, right? Okay.

00:36:03.880 --> 00:36:04.940
And there's a lot of people.

00:36:04.940 --> 00:36:06.900
The other problem is there's 500 contributors.

00:36:06.900 --> 00:36:10.140
So I have very limited knowledge.

00:36:10.140 --> 00:36:10.900
Sure, no worries.

00:36:10.900 --> 00:36:13.380
I'll ask you another sort of math question.

00:36:13.580 --> 00:36:22.980
One of the things when you're writing scientific and especially mathematical papers for academics and so on is you use LaTeX.

00:36:22.980 --> 00:36:30.240
So you can very precisely express symbolic mathematics like integral signs and things like that.

00:36:30.240 --> 00:36:32.000
And this is built right into it, right?

00:36:32.420 --> 00:36:37.720
Yeah, so the connection between Sage and LaTeX is, of course, mathematicians all use LaTeX.

00:36:39.820 --> 00:36:41.940
So we have a Dunder method.

00:36:41.940 --> 00:36:48.860
Well, it's really just a single underscore method, underscore LaTeX underscore, and it's defined on most objects that you create in Sage.

00:36:49.700 --> 00:36:52.940
And it gives back the LaTeX representation of that object.

00:36:52.940 --> 00:36:58.100
It works a lot like the wrapper method in Python, but it's to give you a LaTeX representation rather than...

00:36:58.100 --> 00:36:59.140
Right, right. That's awesome.

00:36:59.260 --> 00:36:59.860
Yeah, so we have...

00:36:59.860 --> 00:37:02.100
And it kind of recursively goes down the stack.

00:37:02.100 --> 00:37:11.660
So if you make a matrix with entries that are rational functions over some other thing, then there's automatically a way to turn that entire matrix into a LaTeX representation.

00:37:12.660 --> 00:37:19.900
And that gets used in the graphical user interface fairly automatically if you want, like in Jupyter Notebooks or in Sage worksheets.

00:37:19.900 --> 00:37:34.360
Also, we have a LaTeX package called SageTec, which lets you write a LaTeX document and then use commands like backslash Sage right inside the LaTeX document.

00:37:34.360 --> 00:37:39.260
So you can write something like consider and then in dollar signs backslash Sage.

00:37:39.400 --> 00:37:45.540
And then in braces, you can put some expression and it will get evaluated using Sage whenever you LaTeX the document.

00:37:45.540 --> 00:37:46.720
And then the result's cached.

00:37:46.720 --> 00:37:51.820
And you can also put blocks of code and the output gets automatically put into your LaTeX document.

00:37:51.820 --> 00:37:56.560
So basically it makes it so your LaTeX document can have executable Python code.

00:37:56.560 --> 00:37:58.020
But it's really...

00:37:58.020 --> 00:38:00.240
I mean, there's a similar thing like this for just Python.

00:38:00.240 --> 00:38:04.460
But for Sage, it also gives functionality for graphics.

00:38:04.740 --> 00:38:12.080
And it knows that Sage objects can be... have a LaTeX representation and it uses that automatically when typesetting the results.

00:38:12.080 --> 00:38:13.320
Yeah, that's really cool.

00:38:13.320 --> 00:38:17.280
So it's something that was written at the first Sage days way back in 2006.

00:38:17.280 --> 00:38:18.660
Yeah, yeah, really nice.

00:38:18.660 --> 00:38:19.480
Long, long ago.

00:38:19.480 --> 00:38:20.160
So...

00:38:20.160 --> 00:38:21.480
And it's been developed ever since.

00:38:21.480 --> 00:38:26.460
So another part of this system that I think is really interesting is Cython.

00:38:27.020 --> 00:38:28.880
And Cython actually...

00:38:28.880 --> 00:38:30.060
This I had no idea about.

00:38:30.060 --> 00:38:31.260
I just want to talk to you about SageMath.

00:38:31.260 --> 00:38:34.240
But Cython actually came out of this project, right?

00:38:34.240 --> 00:38:35.980
Yes, in the following sense.

00:38:35.980 --> 00:38:48.600
So when I started Sage, I mentioned before that Python plus the Python C API was kind of like the killer combination that meant that I could implement what I wanted in Sage on top of Python.

00:38:48.880 --> 00:38:58.060
So I had all these little benchmark programs and I would try to implement them in other languages like OCaml, like these really fast functional compiled languages.

00:38:58.060 --> 00:39:01.880
And I would get something that was fast, but it wasn't quite as fast as I could write in C.

00:39:01.880 --> 00:39:09.720
And if you kind of look, basically overall C lets you write really fast code and Python lets you use C code to write new functions.

00:39:10.260 --> 00:39:14.240
But the Python C API is pretty challenging and potentially error prone.

00:39:14.240 --> 00:39:16.900
You have to do manual reference counting all over the place.

00:39:16.900 --> 00:39:18.440
And the different...

00:39:18.440 --> 00:39:22.400
The ways in which the Python C API functions work can take a while to learn.

00:39:22.400 --> 00:39:30.020
And I really envisioned a lot of people, including me when I'm tired or just really want to get work done, writing code.

00:39:30.020 --> 00:39:31.540
And I wanted to write a huge amount of code.

00:39:31.540 --> 00:39:35.800
And I didn't think it was really viable to write directly against the Python C API.

00:39:35.800 --> 00:39:38.300
I would mess up some reference counting and get seg faults.

00:39:38.300 --> 00:39:40.220
And that just wasn't what I wanted to do.

00:39:40.820 --> 00:39:46.700
And so I started planning to write some Python program that would generate code against the Python C API.

00:39:46.700 --> 00:39:51.060
And I got excited about the possibility of doing that.

00:39:51.060 --> 00:40:00.800
And then I started searching around and found a program called Pyrex, which is like the glassware, P-Y-R-E-X, by Greg Ewing, who is a Python contributor.

00:40:00.800 --> 00:40:05.740
And he wrote this amazing program where you could write code.

00:40:05.740 --> 00:40:09.740
It looked almost like Python, but it would get converted into C extensions.

00:40:09.740 --> 00:40:12.520
And those would get linked into Python.

00:40:12.520 --> 00:40:14.980
And so that was really amazing.

00:40:14.980 --> 00:40:16.680
But it lacked a lot of functionality.

00:40:16.680 --> 00:40:18.940
Like it didn't have list comprehensions.

00:40:18.940 --> 00:40:21.440
And there were just a lot of little things.

00:40:21.440 --> 00:40:22.900
You couldn't do nested functions.

00:40:23.600 --> 00:40:25.660
Also, he didn't use revision control or anything.

00:40:25.660 --> 00:40:29.400
And he just kind of made it a zip archive every once in a while.

00:40:29.400 --> 00:40:33.220
It seemed like he worked on it mainly during the Christmas break each year or something.

00:40:33.220 --> 00:40:34.620
Those were the early days.

00:40:34.620 --> 00:40:35.800
A lot ago, right?

00:40:36.200 --> 00:40:36.920
So, yeah.

00:40:36.920 --> 00:40:39.340
So this was like 2004, 2005.

00:40:39.340 --> 00:40:42.160
And it was an absolutely awesome project.

00:40:42.160 --> 00:40:44.820
But it kind of wasn't really going anywhere.

00:40:44.820 --> 00:40:49.520
And so I started adding functionality I needed to Pyrex.

00:40:49.520 --> 00:40:52.540
And that was...

00:40:52.540 --> 00:40:54.880
I mean, I don't really like writing compilers very much.

00:40:54.880 --> 00:40:55.640
It's not my thing.

00:40:55.640 --> 00:40:57.040
I'm not very good at it.

00:40:57.540 --> 00:41:01.380
But I had this PhD student, Robert Bradshaw, who I mentioned before, who now works at Google.

00:41:01.380 --> 00:41:08.020
And he started diving in and writing a lot of really tricky stuff and doing all these optimizations to Pyrex.

00:41:08.020 --> 00:41:10.800
And I thought that was pretty cool.

00:41:10.800 --> 00:41:16.180
And then another guy, Stefan Benel, who is the developer of LXML, which is a Python library,

00:41:16.180 --> 00:41:19.180
he was forking Pyrex to add all kinds of things as well.

00:41:19.180 --> 00:41:25.420
And then at the same time, I made up a project called SageX for making Sage faster.

00:41:25.540 --> 00:41:28.460
And it was just a combination of some of these Pyrex forks.

00:41:28.460 --> 00:41:30.200
The name was really bad, though.

00:41:30.200 --> 00:41:30.760
SageX.

00:41:30.760 --> 00:41:33.160
And we were just distributing it inside of Sage.

00:41:33.160 --> 00:41:34.460
So that was kind of stupid.

00:41:34.460 --> 00:41:40.780
And so after about a year of that, I looked at this book by Fogel called Producing OSS.

00:41:40.780 --> 00:41:43.300
It's on his website, producingoss.com.

00:41:43.300 --> 00:41:46.840
And I think it's inspired by the Subversion Project.

00:41:46.840 --> 00:41:48.180
It's a great book.

00:41:48.180 --> 00:41:49.740
And I started...

00:41:49.740 --> 00:41:51.080
You know, like when you read a book...

00:41:51.080 --> 00:41:55.520
To me, like when I read a book, I kind of as an exercise think about a lot of stuff while I'm reading the book.

00:41:55.520 --> 00:41:58.640
And so I started thinking about SageX and Pyrex.

00:41:58.640 --> 00:42:04.600
And then I was brainstorming for a name for this thing and kind of thinking,

00:42:04.600 --> 00:42:06.980
I should make this into a proper open source project.

00:42:06.980 --> 00:42:11.480
And then I came up with this name, Cython, which is like Python, but C.

00:42:11.920 --> 00:42:15.640
But I thought it was a better name than SageX, which is hard to say.

00:42:15.640 --> 00:42:18.140
And sort of doesn't have anything to do with Python or C.

00:42:18.140 --> 00:42:19.680
And so I Googled it.

00:42:19.680 --> 00:42:22.340
And there was only one hit, which I could find.

00:42:22.340 --> 00:42:27.640
And it was a picture of this punk rocker in England who called himself Cython flipping you off.

00:42:28.040 --> 00:42:30.000
And so I thought, I'm safe.

00:42:30.000 --> 00:42:34.200
You'll probably not lay claim to this, really.

00:42:34.200 --> 00:42:35.240
Exactly.

00:42:35.240 --> 00:42:36.220
So I thought, I'm safe.

00:42:36.220 --> 00:42:37.300
I can choose this as a name.

00:42:37.300 --> 00:42:38.660
And then I wrote to...

00:42:38.660 --> 00:42:42.220
Or I talked to my PhD student, Robert, and to Stefan Benel.

00:42:42.220 --> 00:42:48.140
And I'm like, so I'm going to start this project and make you the lead developer.

00:42:48.140 --> 00:42:49.520
And each of them said no.

00:42:49.520 --> 00:42:51.780
And so I was a little worried about that.

00:42:51.840 --> 00:42:57.960
So I made them both lead developers and kind of like stepped back from it, made the website, bought the domain name.

00:42:57.960 --> 00:43:04.560
And though they both sort of decided not to be the lead developer, they together did an amazing amount of work.

00:43:04.560 --> 00:43:06.900
And then other people started contributing.

00:43:06.900 --> 00:43:10.460
And I mean, it really has blown up a huge amount since then.

00:43:10.460 --> 00:43:17.560
So I did try to push their direction to be, make it so that Cython can compile all of Python.

00:43:17.640 --> 00:43:22.660
Like you could take the standard Python test suite and just build it and see how fast it is compared to Python.

00:43:22.660 --> 00:43:33.000
And the systems really got deep because part of the test cases for Cython is compile all of Sage, which is huge, and then run the Sage test suite.

00:43:33.000 --> 00:43:40.620
And also there are sort of things we need, like when you're running blocking C code, you want to be able to hit control C and have that interrupt the running code.

00:43:40.620 --> 00:43:49.060
And so in Sage, we put a lot of work into writing something that would let you interrupt blocking C code that was written using Cython.

00:43:49.060 --> 00:43:54.260
Martin Albrecht recently separated that out as a separate project that you can pip install.

00:43:54.260 --> 00:43:56.580
So you can use it in your own Cython code.

00:43:56.580 --> 00:43:57.820
Right. Okay. That's really cool.

00:43:57.820 --> 00:43:59.780
So that's kind of where Cython came from.

00:43:59.780 --> 00:44:03.300
And I think it's been steadily progressing over the years.

00:44:03.300 --> 00:44:10.960
Very often there are things that come along which kind of sound like they do something similar, but Cython is just so battle-tested.

00:44:10.960 --> 00:44:21.840
And no matter what, like if you want to write some fast code that you can use from Python and you're willing to understand the basics of C data types, you can use Cython and do it and get it done.

00:44:22.240 --> 00:44:32.380
And if you want to make some code that's usable from C or C++, like a C or C++ library available to Python with no overhead, then you can do that via Cython.

00:44:32.380 --> 00:44:41.540
So it's very different than SWIG, Standard Wrapper and Interface Generator, where SWIG will automatically take a C++ library and make it usable from Python.

00:44:41.940 --> 00:44:48.280
But there's some Python code between the C++ library and you, and that slows things down a lot.

00:44:48.280 --> 00:44:57.140
So with Cython, we do things like make it so you can use a third-party library that provides basic arithmetic addition and multiplication, say, in a finite field.

00:44:57.140 --> 00:44:59.420
And we can make that so it's very, very fast.

00:44:59.420 --> 00:45:03.460
So it just takes on the order of 100 nanoseconds to do additions and multiplications.

00:45:03.460 --> 00:45:08.500
So it really, really eliminates overhead and makes using very, very low-level C code possible.

00:45:08.500 --> 00:45:10.140
Yeah, that's really awesome.

00:45:10.420 --> 00:45:13.340
How applicable is that in general?

00:45:13.340 --> 00:45:15.900
Is this something you would only use on math?

00:45:15.900 --> 00:45:23.500
Or if you've got a web service backend and there's a section that needs to go faster, would Cython be something you might consider?

00:45:23.500 --> 00:45:29.360
I think it's really, really aimed towards very compute-heavy loads.

00:45:29.360 --> 00:45:33.760
So it doesn't help much if your problem is IO-bound.

00:45:33.760 --> 00:45:39.040
And then the new Python async stuff is probably way more useful, or something like Twisted.

00:45:39.040 --> 00:45:39.560
Yeah, absolutely.

00:45:39.860 --> 00:45:43.340
So it's really, really all about compute-heavy, non-asynchronous.

00:45:43.340 --> 00:45:50.780
You have a synchronous thing like a for loop where you have a doubly nested for loop that's doing some calculation in the inside.

00:45:50.780 --> 00:45:55.200
And you want to make that one part really, really fast, as fast as you could possibly write it in C.

00:45:55.200 --> 00:45:56.860
That's what Cython lets you do.

00:45:56.860 --> 00:45:57.820
Okay, very cool.

00:45:58.060 --> 00:46:01.100
And that's the sort of thing that comes up a lot in math programming.

00:46:01.100 --> 00:46:02.800
Yeah, of course it does.

00:46:02.800 --> 00:46:05.880
Matrix multiplies and all sorts of things, right?

00:46:05.880 --> 00:46:06.260
Yep.

00:46:06.260 --> 00:46:16.980
So the sort of next step that you might take this whole project is rather than having people download 800 megs of all those packages and run it locally,

00:46:16.980 --> 00:46:18.660
it's just fire up a web browser.

00:46:18.660 --> 00:46:21.700
And so you started cloud.sagemath.com, right?

00:46:21.700 --> 00:46:22.140
Yes.

00:46:22.140 --> 00:46:22.640
Yep.

00:46:22.640 --> 00:46:25.020
I started that in 2013.

00:46:25.920 --> 00:46:38.460
And my initial motivation was that I had been teaching courses for just repeatedly every year for about a decade to undergraduates on how to use open source math software for kind of math.

00:46:38.460 --> 00:46:44.560
So I get like 40 or 50 math or math CS stats econ undergrads.

00:46:44.560 --> 00:46:53.460
And the whole course is about how to, you know, program in Python, program in Cython, use lots of functionality from Sage, use NumPy, use LaTeX a little bit.

00:46:53.460 --> 00:46:57.700
And the installation challenges for the students were pretty bad.

00:46:57.700 --> 00:47:05.800
And so for quite a while, they would use, they would often just use the Sage notebook server we had running, but that could only handle maybe a dozen people at once.

00:47:05.800 --> 00:47:07.360
It really wasn't very scalable.

00:47:07.360 --> 00:47:10.920
And all it did was give you Sage.

00:47:10.920 --> 00:47:15.640
So you could type in Sage code and see the output, but it didn't have a terminal and it didn't have LaTeX.

00:47:15.640 --> 00:47:31.340
And so I decided to write something that was much more all-inclusive where you could teach a whole course about anything related to basically open source scientific software and do it all in one unified place where the students in about, you know, 15 seconds are up and running.

00:47:31.840 --> 00:47:33.720
So that was the motivation.

00:47:33.720 --> 00:47:37.140
And something I've refined over the last few years.

00:47:37.400 --> 00:47:43.860
I've taught using it a couple of times now and written some research papers and a book all within Sage Math Cloud.

00:47:43.860 --> 00:47:48.080
And there have been several hundred other people who have done courses using it now.

00:47:48.080 --> 00:47:49.480
Yeah, that's, that's really great.

00:47:49.680 --> 00:48:00.420
I can just imagine the first day of these sort of computational math classes where it's like, all right, so what we're going to do is we're all going to download this.

00:48:00.420 --> 00:48:02.000
Like my download canceled.

00:48:02.000 --> 00:48:03.640
Mine won't install.

00:48:03.640 --> 00:48:05.240
Mine installed, but it won't launch.

00:48:05.240 --> 00:48:06.300
You're just like, ah, why?

00:48:06.460 --> 00:48:09.060
This is not what this class is about, right?

00:48:09.060 --> 00:48:12.220
But you've got to plow through that if it's on the machines, right?

00:48:12.220 --> 00:48:13.720
So this, this is really cool.

00:48:13.720 --> 00:48:16.280
And, you know, it's a really slick web app that you guys have built.

00:48:16.280 --> 00:48:17.080
Thanks.

00:48:17.080 --> 00:48:18.000
Yeah.

00:48:18.000 --> 00:48:28.420
So I've, I've been working on an enormous amount for the last couple of years with some input from Jonathan Lee and Nicholas Rund, who are two UW undergraduates.

00:48:28.840 --> 00:48:34.800
And also Harold Schilley, who's been working on Sage since about 2007 and who lives in Vienna, Austria.

00:48:34.800 --> 00:48:45.000
So we've done, we've written this application and it has, I don't know, around about 4,000 users each day.

00:48:45.000 --> 00:48:48.580
And it'll often have about 400 active users at once.

00:48:48.580 --> 00:48:50.900
So it's a pretty heavily used.

00:48:50.900 --> 00:48:54.220
And the usage is heavy because people are really running code.

00:48:54.700 --> 00:49:01.340
And they're running lots of Jupyter notebooks and Sage worksheets and editing LaTeX documents and maybe running long-term calculations.

00:49:01.340 --> 00:49:06.800
It all runs on top of Google Compute Engine, but it's also entirely top to bottom open source.

00:49:06.800 --> 00:49:10.360
And some people download it and install it on their own computers.

00:49:10.360 --> 00:49:10.900
Okay.

00:49:10.900 --> 00:49:15.940
That's a really interesting component of it that you can get a local server version.

00:49:15.940 --> 00:49:16.440
Yep.

00:49:16.440 --> 00:49:24.440
And it provides, so what it gives you is real-time collaborative editing of terminals, Jupyter notebooks, LaTeX documents.

00:49:25.020 --> 00:49:29.960
It also has a course management system built in for assigning homework to students and collecting it.

00:49:29.960 --> 00:49:34.660
And everything's collaborative in that you can see other people editing, kind of like Google Docs.

00:49:34.660 --> 00:49:36.420
There's also chats and stuff.

00:49:36.420 --> 00:49:37.520
Yeah, that's fantastic.

00:49:37.520 --> 00:49:39.760
And you've got a lot of features there.

00:49:39.760 --> 00:49:51.000
Like, it's not just for, say, running Python code, but you can run C or Go, or there's the ability to open terminals, just Linux Bash or something like this, right?

00:49:51.000 --> 00:49:51.820
Yep, absolutely.

00:49:52.440 --> 00:49:59.680
So it's kind of like those online IDEs, but, you know, like cloud9.io or one of those.

00:49:59.680 --> 00:50:02.260
But our target audience isn't at all programmers.

00:50:02.260 --> 00:50:08.600
It's just people who, especially students who just want to get up and running quickly with open source math-related software.

00:50:09.220 --> 00:50:17.620
And we also have really good support for R and Julia and Octave and so on, especially because Jupyter notebooks have kernels for all these languages.

00:50:17.620 --> 00:50:18.520
Right.

00:50:18.520 --> 00:50:21.520
You just pass it right along to Jupyter and let it deal with it, right?

00:50:21.520 --> 00:50:22.200
Yep, exactly.

00:50:22.200 --> 00:50:22.680
Nice.

00:50:22.880 --> 00:50:31.360
So you've got a lot of cool stuff in your GitHub, which I'll put in the SageMath GitHub, and I'll put a link to that in the show notes.

00:50:31.360 --> 00:50:34.480
And one of my stuff on there was stuff to do with Docker.

00:50:34.480 --> 00:50:35.720
How does Docker fit into this?

00:50:36.020 --> 00:50:48.220
First, there is a SageMath Docker image that Eric Bray, who I think is a guy in Europe, in France, who I think has the distinction of being the first full-time person to work on Sage.

00:50:48.920 --> 00:50:51.860
So NSF grants for Sage have kind of dried up recently.

00:50:51.860 --> 00:50:57.660
But in Europe, they just got this huge $8 million grant called Open Dream Kit.

00:50:57.660 --> 00:51:02.260
It's across the European Union, and it supports open source math software, including Sage.

00:51:02.260 --> 00:51:05.720
So the Europeans are really, really supporting open source math software.

00:51:05.720 --> 00:51:09.800
And Eric created some really nice Docker images for running Sage.

00:51:09.800 --> 00:51:16.380
So you just do like Docker run dash something SageMath, and you're up and running with Sage.

00:51:16.380 --> 00:51:18.340
So it's yet another way of installing Sage.

00:51:18.820 --> 00:51:20.400
And there's a Jupyter version of it.

00:51:20.400 --> 00:51:21.700
So that's one thing.

00:51:21.700 --> 00:51:26.160
So SageMath Cloud doesn't currently exactly use Docker.

00:51:26.160 --> 00:51:29.740
We use Cgroups and a lot of the stuff that Docker is built on.

00:51:29.740 --> 00:51:35.980
But I think it will use Docker extensively in the next few months under the hood.

00:51:35.980 --> 00:51:40.300
You won't know the difference, but it will just make things run a little smoother and be more scalable.

00:51:40.300 --> 00:51:44.320
Yeah, and let the Docker folks manage that kind of stuff and not you, right?

00:51:44.320 --> 00:51:44.780
Yep.

00:51:44.780 --> 00:51:45.560
Yeah, exactly.

00:51:45.560 --> 00:51:46.280
Yeah, yeah.

00:51:46.280 --> 00:51:46.760
Very cool.

00:51:46.760 --> 00:51:47.280
All right.

00:51:47.320 --> 00:51:49.140
We're getting kind of to the end of the show.

00:51:49.140 --> 00:51:56.660
One thing I wanted to recommend for people is if this is all interesting to you guys, go to cloud.sagemath.com.

00:51:56.660 --> 00:51:58.360
You can create an account there and check it out.

00:51:58.360 --> 00:52:04.680
But there's also a video like right on the landing page there that gives the two-minute story of this.

00:52:04.680 --> 00:52:06.300
If you want to share it, that's cool.

00:52:06.300 --> 00:52:09.460
And it features you and a bunch of other people in there, which is cool.

00:52:09.540 --> 00:52:13.240
And you've got some pretty sweet skating in there.

00:52:13.240 --> 00:52:13.880
Yep.

00:52:13.880 --> 00:52:18.260
I own the biggest skateboard ramp in the Northwest and I skate it a lot.

00:52:18.260 --> 00:52:20.320
So I'm really into skating large half pipes.

00:52:20.320 --> 00:52:20.840
Wow.

00:52:20.840 --> 00:52:22.040
That's really cool.

00:52:22.040 --> 00:52:22.440
Is it?

00:52:22.440 --> 00:52:23.160
This is at your house?

00:52:23.160 --> 00:52:24.880
It's at a friend of mine's house, thankfully.

00:52:24.880 --> 00:52:26.460
It's not at my house.

00:52:26.460 --> 00:52:28.020
Nice.

00:52:28.020 --> 00:52:28.380
Nice.

00:52:28.380 --> 00:52:29.040
That's really cool.

00:52:29.200 --> 00:52:32.700
When I was growing up, my brother built a quarter pipe.

00:52:32.700 --> 00:52:35.260
So we periodically hurt ourselves.

00:52:35.260 --> 00:52:36.160
So I think that was cool.

00:52:36.160 --> 00:52:36.400
Yeah.

00:52:36.400 --> 00:52:38.720
I got into skateboarding with my brother.

00:52:38.720 --> 00:52:40.540
We skateboard together a lot still.

00:52:40.540 --> 00:52:41.020
Oh, yeah.

00:52:41.020 --> 00:52:41.500
That's great.

00:52:41.500 --> 00:52:41.940
That's great.

00:52:41.940 --> 00:52:43.400
All right.

00:52:43.400 --> 00:52:47.120
So I think it's probably a good time to wrap up our conversation.

00:52:47.120 --> 00:52:49.640
So let me ask you two questions I always ask my guests.

00:52:49.640 --> 00:52:56.200
First, even though you can't pip install SageMath, there's still a lot of packages that you guys

00:52:56.200 --> 00:52:56.940
must use.

00:52:56.940 --> 00:53:01.840
And so do you have a favorite PyPI package that is really helpful to you that maybe other

00:53:01.840 --> 00:53:02.580
people don't know about?

00:53:02.580 --> 00:53:03.620
Well, okay.

00:53:03.620 --> 00:53:04.480
Let's see.

00:53:04.480 --> 00:53:07.620
First, again, I really wish the answer was SageMath.

00:53:07.620 --> 00:53:09.260
I did.

00:53:09.260 --> 00:53:12.400
I posted my first ever package to PyPI.

00:53:12.400 --> 00:53:13.700
How do you say it?

00:53:13.700 --> 00:53:14.800
PyPI.

00:53:14.800 --> 00:53:22.600
Guido says that PyPI and some of the core developers say PyPI and PyPI conflicts with PyPI the runtime.

00:53:22.600 --> 00:53:25.040
So I'm with PyPI as well.

00:53:25.040 --> 00:53:25.400
Okay.

00:53:25.700 --> 00:53:30.020
So I posted to PyPI a PyGSL package.

00:53:30.020 --> 00:53:32.600
So I'll say that that's a brand new one that wasn't there before.

00:53:32.600 --> 00:53:38.020
I did it because a physicist who wanted to use it in their class on SageMath Cloud wanted

00:53:38.020 --> 00:53:38.360
this.

00:53:38.360 --> 00:53:43.600
GSL is the GNU scientific library, and they wanted these Cython bindings to the GNU scientific

00:53:43.600 --> 00:53:44.640
library to be available.

00:53:44.640 --> 00:53:48.560
And the only way to do it was to download some zip file off of SourceForge.

00:53:49.060 --> 00:53:50.480
And that sucks.

00:53:50.480 --> 00:53:53.600
So yeah, anything on SourceForge these days is a little suspect.

00:53:53.840 --> 00:54:00.960
So I set up a PyPI account and figured out how to...

00:54:00.960 --> 00:54:02.680
I took the zip file, then I pushed it.

00:54:02.680 --> 00:54:08.420
So I myself became the kind of manager of the PyGSL package on PyPI.

00:54:08.420 --> 00:54:09.800
Yeah, lovely.

00:54:09.800 --> 00:54:12.040
It took me about two to three minutes to learn how to do so.

00:54:12.040 --> 00:54:17.860
So my answer is that package or push your own package, especially some old thing on SourceForge

00:54:17.860 --> 00:54:20.540
that should be pip installable and make it pip installable.

00:54:20.740 --> 00:54:23.340
It's easy for anybody to make things pip installable.

00:54:23.340 --> 00:54:27.700
Yeah, it's surprisingly easy to register a package and upload it and so on.

00:54:27.700 --> 00:54:28.520
It's...

00:54:28.520 --> 00:54:33.820
You just more or less create an account and just use the built-in tools and the set of tools

00:54:33.820 --> 00:54:34.140
and stuff.

00:54:34.140 --> 00:54:34.820
Yeah, it's really nice.

00:54:34.820 --> 00:54:35.580
Yeah, absolutely.

00:54:35.580 --> 00:54:36.180
Awesome.

00:54:36.180 --> 00:54:39.760
And then what editor do you use when you write Python code?

00:54:39.760 --> 00:54:42.240
So I dogfood everything.

00:54:42.240 --> 00:54:48.840
So I do absolutely all of my development of SageMath Cloud and Sage from within SageMath Cloud.

00:54:49.560 --> 00:54:51.880
And the editor of SageMath Cloud is...

00:54:51.880 --> 00:54:58.020
It's built on top of Codemirror, which is a web, like a JavaScript-based code editor.

00:54:58.020 --> 00:55:03.280
So I added things like multiple panes so you can split the view and see two points in the

00:55:03.280 --> 00:55:04.000
document at once.

00:55:04.000 --> 00:55:08.940
And also because the editing is synchronized, you can just open multiple browser tabs to

00:55:08.940 --> 00:55:11.540
see multiple points in the same document at once.

00:55:11.540 --> 00:55:16.040
And then I also have various plugins for the kind of functionality I felt like I really needed,

00:55:16.040 --> 00:55:18.320
like deleting, trailing, white space, and so on.

00:55:18.860 --> 00:55:23.260
So my answer is Codemirror, which is probably not the most popular answer, but that's my

00:55:23.260 --> 00:55:23.460
answer.

00:55:23.460 --> 00:55:24.600
Oh, oh, one other thing.

00:55:24.600 --> 00:55:25.720
I think that's really cool.

00:55:25.720 --> 00:55:28.320
One other thing is in SageMath Cloud, there's a history.

00:55:28.320 --> 00:55:31.700
So whenever you edit, every keystroke almost is recorded.

00:55:32.300 --> 00:55:37.260
And there's a slider that lets you slide back and forth and see the past, all past versions

00:55:37.260 --> 00:55:37.920
of your document.

00:55:37.920 --> 00:55:42.460
And so like when I'm editing code, I'll be like, oh, I wanted to look at what it was like

00:55:42.460 --> 00:55:45.660
three minutes ago or 10 minutes ago and copy something from that.

00:55:45.660 --> 00:55:48.060
And you can very easily do that with a little slider.

00:55:48.220 --> 00:55:51.400
So you get kind of a whole third dimension of time when editing.

00:55:51.400 --> 00:55:53.020
So it does have some benefits.

00:55:53.020 --> 00:55:54.800
Yeah, that's a really nice feature.

00:55:54.800 --> 00:56:03.160
I feel like a system has reached some level of maturity and well-roundedness and goodness,

00:56:03.160 --> 00:56:06.360
basically, when it can create itself.

00:56:06.820 --> 00:56:14.980
You know, when you compile C with a C compiler, when you write like PyPy, you know, you run

00:56:14.980 --> 00:56:16.640
Python with Python, these types of things.

00:56:16.640 --> 00:56:17.440
It's pretty cool.

00:56:17.440 --> 00:56:19.620
So it's nice to hear you're doing that for your editor.

00:56:19.620 --> 00:56:20.780
Awesome.

00:56:20.780 --> 00:56:27.660
So before we say goodbye, what should people know about getting started with this?

00:56:27.660 --> 00:56:29.460
If they want to check it out, what should they do?

00:56:29.460 --> 00:56:35.300
So just type Sage or SageMath into Google and you'll get to the SageMath.org website.

00:56:35.940 --> 00:56:37.360
And that has all kinds of documentation.

00:56:37.360 --> 00:56:42.200
There's like probably 10 to 15,000 pages of documentation there, links to books and so on.

00:56:42.200 --> 00:56:48.260
And there's a big link to, which just says SageMath online.

00:56:48.260 --> 00:56:53.760
And if you click that, it takes you to the SageMath cloud site that we've been talking about.

00:56:53.760 --> 00:56:57.380
And there's also something called SageMath cell, which gives you a single,

00:56:57.380 --> 00:57:02.180
one single input box where you can type in a block of Sage code and see output.

00:57:02.180 --> 00:57:05.860
And you can also embed those blocks inside of your own static website.

00:57:05.860 --> 00:57:07.760
And there's an API for doing that.

00:57:07.760 --> 00:57:10.760
So go to the website SageMath.org.

00:57:10.760 --> 00:57:14.980
You can either download it or go to the cloud site and use it online.

00:57:14.980 --> 00:57:17.500
It's all 100% open source, top to bottom.

00:57:17.500 --> 00:57:19.760
William, this is quite an achievement.

00:57:19.760 --> 00:57:25.200
I really love looking inside of it because you solved a lot of cool problems and a lot of

00:57:25.200 --> 00:57:27.300
excellent technologies come out of it.

00:57:27.300 --> 00:57:28.220
So congratulations.

00:57:28.220 --> 00:57:29.100
Thank you.

00:57:29.100 --> 00:57:29.500
Yeah.

00:57:29.500 --> 00:57:30.580
It's been good to talk to you.

00:57:30.580 --> 00:57:31.000
Take care.

00:57:31.220 --> 00:57:31.360
Okay.

00:57:31.360 --> 00:57:31.840
Thanks a lot.

00:57:31.840 --> 00:57:32.780
Great talking to you.

00:57:32.780 --> 00:57:32.960
Yeah.

00:57:32.960 --> 00:57:33.120
Bye.

00:57:34.200 --> 00:57:37.040
This has been another episode of Talk Python To Me.

00:57:37.440 --> 00:57:39.000
Today's guest was William Stein.

00:57:39.000 --> 00:57:41.540
And this episode has been sponsored by Hired and SnapCI.

00:57:41.540 --> 00:57:43.340
Thank you guys for supporting the show.

00:57:43.340 --> 00:57:46.260
Hired wants to help you find your next big thing.

00:57:46.260 --> 00:57:50.980
Visit Hired.com slash Talk Python To Me to get five or more offers with salary and equity

00:57:50.980 --> 00:57:52.040
presented right up front.

00:57:52.040 --> 00:57:54.740
And a special listener signing bonus of $2,000.

00:57:54.740 --> 00:57:58.880
SnapCI is modern, continuous integration and delivery.

00:57:58.880 --> 00:58:01.520
Build, test, and deploy your code directly from GitHub.

00:58:01.680 --> 00:58:04.780
All in your browser with debugging, Docker, and parallels included.

00:58:04.780 --> 00:58:07.820
Try them for free at snap.ci slash Talk Python.

00:58:07.820 --> 00:58:10.420
Are you or a colleague trying to learn Python?

00:58:10.420 --> 00:58:15.140
Have you tried books and videos that left you bored by just covering topics point by point?

00:58:15.140 --> 00:58:20.600
Well, check out my online course, Python Jumpstart by Building 10 Apps at talkpython.fm slash

00:58:20.600 --> 00:58:23.140
course to experience a more engaging way to learn Python.

00:58:23.140 --> 00:58:30.240
You can find the links from this show at talkpython.fm/episodes slash show slash 59.

00:58:30.920 --> 00:58:32.640
Be sure to subscribe to the show.

00:58:32.640 --> 00:58:34.820
Open your favorite podcatcher and search for Python.

00:58:34.820 --> 00:58:36.080
We should be right at the top.

00:58:36.080 --> 00:58:41.860
You can also find the iTunes feed at /itunes, Google Play feed at /play, and

00:58:41.860 --> 00:58:45.400
direct RSS feed at /rss on talkpython.fm.

00:58:45.400 --> 00:58:50.420
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:58:50.420 --> 00:58:54.460
You can hear the entire song at talkpython.fm/music.

00:58:54.460 --> 00:58:56.340
This is your host, Michael Kennedy.

00:58:56.340 --> 00:58:57.620
Thanks so much for listening.

00:58:57.620 --> 00:58:58.800
I really appreciate it.

00:58:59.540 --> 00:59:00.980
Smix, let's get out of here.

00:59:00.980 --> 00:59:03.140
I'm dating with my voice.

00:59:03.140 --> 00:59:04.940
There's no norm that I can feel within.

00:59:04.940 --> 00:59:06.120
Haven't been sleeping.

00:59:06.120 --> 00:59:07.760
I've been using lots of rest.

00:59:07.760 --> 00:59:10.640
I'll pass the mic back to who rocked it best.

00:59:10.640 --> 00:59:16.980
I'm first, developers, developers, developers, developers, developers, developers, developers,

00:59:16.980 --> 00:59:22.640
developers, developers, developers, developers, developers, developers, developers, developers,

00:59:22.640 --> 00:59:22.880
you

