WEBVTT

00:00:00.001 --> 00:00:03.820
There have been a bunch of new Python web frameworks coming out in the past few years.

00:00:03.820 --> 00:00:08.340
Generally, these have been focused solely on Python 3 and have tried to leverage Python's

00:00:08.340 --> 00:00:09.680
new async and await features.

00:00:09.680 --> 00:00:13.260
However, these frameworks have come with their own new APIs.

00:00:13.260 --> 00:00:18.720
They may be amazing, but it's still something new to learn and a barrier to migrating over

00:00:18.720 --> 00:00:20.300
to them and between them.

00:00:20.300 --> 00:00:24.520
That's why when I learned about Cort from Philip Jones, I was excited.

00:00:24.520 --> 00:00:29.780
It's an async-enabled web framework that attempts to be 100% compatible with Flask,

00:00:29.780 --> 00:00:30.900
including the extensions.

00:00:30.900 --> 00:00:37.080
This is Talk Python to Me, episode 147, recorded January 18th, 2018.

00:00:37.080 --> 00:00:55.640
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the

00:00:55.640 --> 00:00:57.140
ecosystem, and the personalities.

00:00:57.700 --> 00:00:59.280
This is your host, Michael Kennedy.

00:00:59.280 --> 00:01:01.280
Follow me on Twitter, where I'm @mkennedy.

00:01:01.280 --> 00:01:05.160
Keep up with the show and listen to past episodes at talkpython.fm.

00:01:05.160 --> 00:01:07.700
And follow the show on Twitter via at Talk Python.

00:01:08.160 --> 00:01:11.560
This episode is brought to you by SmartKets and Rollbar.

00:01:11.560 --> 00:01:13.840
Be sure to check out what they're offering during their segments.

00:01:13.840 --> 00:01:15.160
It really helps support the show.

00:01:15.160 --> 00:01:18.360
It's that conference time of year, everyone.

00:01:18.360 --> 00:01:22.360
There's actually a bunch of interesting things happening around Python conferences.

00:01:22.360 --> 00:01:24.120
So let's do a quick update.

00:01:24.620 --> 00:01:26.120
First, we'll do this chronologically.

00:01:26.120 --> 00:01:31.920
First, Pi Cascades is happening in Vancouver, BC, January 22nd and 23rd.

00:01:31.920 --> 00:01:32.720
I'm going to be there.

00:01:32.720 --> 00:01:36.860
So if you are one of the lucky people to have actually gotten a ticket before they sold out,

00:01:36.860 --> 00:01:39.180
hope to see you there in Vancouver.

00:01:40.000 --> 00:01:42.880
Next, we have Pi Colombia in Medellin, Colombia.

00:01:42.880 --> 00:01:45.460
This is February 9th, 10th, and 11th.

00:01:45.460 --> 00:01:49.820
So if you're in South America or want to go to South America and would love to go to this conference,

00:01:49.820 --> 00:01:52.140
please check out the Pi Colombia conference.

00:01:52.140 --> 00:01:53.700
Those guys are doing cool stuff down there.

00:01:53.700 --> 00:01:56.560
Next up, PiCon Slovakia.

00:01:56.680 --> 00:01:59.440
This is March 9th to 11th in Bratislava.

00:01:59.440 --> 00:02:03.180
And I'm actually going to be speaking there and doing a workshop.

00:02:03.180 --> 00:02:07.500
If you're in Europe and you can make it to Bratislava in March, that would be awesome.

00:02:07.500 --> 00:02:10.080
Please come say hello or attend one of my talk show workshops.

00:02:10.080 --> 00:02:15.020
And finally, the big one, PiCon US in Cleveland, Ohio, May 10th.

00:02:15.020 --> 00:02:17.740
I personally just finalized all my travel plans.

00:02:17.740 --> 00:02:18.680
I hope to see you there.

00:02:18.680 --> 00:02:20.280
There's still tickets available.

00:02:20.280 --> 00:02:22.280
They're not yet sold out as far as I know.

00:02:22.280 --> 00:02:26.060
So hurry, hurry, because just like Vancouver, they will sell out.

00:02:26.220 --> 00:02:28.980
We're also going to have a booth with lots of cool giveaway stuff there.

00:02:28.980 --> 00:02:32.080
So please stop by our booth and say hello if you make it to PiCon US.

00:02:32.080 --> 00:02:34.180
All of these conferences are amazing.

00:02:34.180 --> 00:02:36.240
And I hope you can make at least one of them.

00:02:36.240 --> 00:02:37.860
Now let's get to the interview.

00:02:37.860 --> 00:02:39.800
Phil, welcome to Talk Python.

00:02:39.800 --> 00:02:40.260
Thank you.

00:02:40.260 --> 00:02:40.620
Hello.

00:02:40.620 --> 00:02:42.040
It's great to have you here.

00:02:42.040 --> 00:02:44.520
I'm a big fan of asynchronous programming.

00:02:44.520 --> 00:02:48.400
And I consider myself really a web developer at heart.

00:02:48.400 --> 00:02:53.860
And so this project that you are creating is really, really interesting to me.

00:02:54.440 --> 00:02:57.080
Port, kind of an asynchronous version of Flask.

00:02:57.080 --> 00:03:00.520
And we're going to get into all the details in that and really dig into it.

00:03:00.520 --> 00:03:02.380
But before we do, let's start with your story.

00:03:02.380 --> 00:03:03.800
How did you get into programming in Python?

00:03:03.800 --> 00:03:08.360
So I got into programming to really to make games when I was a teenager.

00:03:08.360 --> 00:03:13.240
The first one was specifically was to try and make my own version of Cannon Fodder, which

00:03:13.240 --> 00:03:15.240
I quite enjoy playing around my friend's house.

00:03:15.240 --> 00:03:16.960
So that's how I got into it.

00:03:16.960 --> 00:03:18.520
And it was VB originally for me.

00:03:18.520 --> 00:03:20.720
VB, like VB6 type of thing?

00:03:20.900 --> 00:03:22.200
Yeah, I think it must have been.

00:03:22.200 --> 00:03:22.520
Yeah.

00:03:22.520 --> 00:03:24.960
Or like the Microsoft Visual Basic, right?

00:03:24.960 --> 00:03:25.160
Yeah.

00:03:25.160 --> 00:03:26.320
Oh, yeah.

00:03:26.320 --> 00:03:27.020
Very interesting.

00:03:27.020 --> 00:03:28.320
That's a long ways from the web.

00:03:28.320 --> 00:03:29.840
Yeah, definitely.

00:03:29.840 --> 00:03:31.800
It is cool.

00:03:31.800 --> 00:03:34.660
So you started out in Visual Basic and created that.

00:03:34.660 --> 00:03:35.440
And that sounds really fun.

00:03:35.440 --> 00:03:36.660
Where'd you go from there?

00:03:36.720 --> 00:03:40.880
Originally figured of doing computer science at university, but I did physics instead.

00:03:40.880 --> 00:03:43.360
But over the time, I got more and more into coding.

00:03:43.360 --> 00:03:47.880
And by the time I did my PhD, that was quite heavy on the simulation parts.

00:03:47.880 --> 00:03:53.280
And later on in the postdoc, I switched, roughly speaking, from C++ to Python.

00:03:53.280 --> 00:03:55.800
So I'm reasonably new to Python.

00:03:55.800 --> 00:03:59.900
But that's the kind of overview of how I progressed in the languages.

00:03:59.900 --> 00:04:00.480
Oh, yeah.

00:04:00.480 --> 00:04:00.940
Really cool.

00:04:00.940 --> 00:04:02.480
What was your PhD focus?

00:04:02.680 --> 00:04:05.980
It was background rejection in neutrino experiments in Canada.

00:04:05.980 --> 00:04:09.040
And the simulation of the experiment itself.

00:04:09.040 --> 00:04:10.340
So a lot of physics simulation.

00:04:10.340 --> 00:04:10.820
Oh, yeah.

00:04:10.820 --> 00:04:11.260
That's cool.

00:04:11.260 --> 00:04:15.720
And of course, computation is really front and center in that kind of stuff, right?

00:04:15.720 --> 00:04:19.100
You can't really explain it anymore without the Monte Carlo simulation.

00:04:19.100 --> 00:04:20.180
It's too complex.

00:04:20.180 --> 00:04:20.740
Yeah.

00:04:20.740 --> 00:04:23.440
Monte Carlo simulations are really amazing.

00:04:23.440 --> 00:04:24.580
They seem like magic to me.

00:04:24.660 --> 00:04:25.900
Here's the thing that'll take a month.

00:04:25.900 --> 00:04:27.340
Oh, but we can do it in five minutes.

00:04:27.340 --> 00:04:28.300
Very cool.

00:04:28.300 --> 00:04:30.980
If you're willing to accept a little uncertainty, we can do it really quick.

00:04:30.980 --> 00:04:31.280
All right.

00:04:31.280 --> 00:04:31.600
That's cool.

00:04:31.600 --> 00:04:33.580
So what do you do day to day?

00:04:33.580 --> 00:04:35.500
Not still physics simulations, right?

00:04:35.500 --> 00:04:35.780
No.

00:04:35.780 --> 00:04:38.400
I left physics about three years ago now.

00:04:38.400 --> 00:04:40.720
I work for a company called Smartkits in London.

00:04:40.720 --> 00:04:44.680
And they're a betting exchange or event trading exchange.

00:04:44.680 --> 00:04:47.900
So ideally, we become like the prediction market.

00:04:47.900 --> 00:04:51.100
So you go to figure out who's going to win an election, for example.

00:04:51.100 --> 00:04:52.200
That's what we want to be.

00:04:52.200 --> 00:04:53.040
Oh, that's really cool.

00:04:53.040 --> 00:04:55.920
So probably a lot of website traffic.

00:04:55.920 --> 00:04:58.480
Do you have APIs and stuff people can consume?

00:04:58.480 --> 00:04:59.040
Exactly.

00:04:59.040 --> 00:05:03.280
So we build the website and the API to interact with the exchange to allow people to trade.

00:05:03.280 --> 00:05:06.180
So yeah, it's quite heavy on Python.

00:05:06.180 --> 00:05:08.160
There's some JavaScript and some Erlang as well.

00:05:08.160 --> 00:05:08.540
Erlang.

00:05:08.540 --> 00:05:08.860
Okay.

00:05:08.860 --> 00:05:09.420
Very cool.

00:05:09.420 --> 00:05:11.500
That sounds like a fun thing to do day to day.

00:05:11.500 --> 00:05:14.980
And it's not that far removed from this project we're going to talk about.

00:05:14.980 --> 00:05:21.160
So I kind of want to start the conversation and set the stage by just talking about

00:05:21.160 --> 00:05:23.420
asyncio in general.

00:05:23.420 --> 00:05:26.240
So this was introduced in what?

00:05:26.240 --> 00:05:27.440
Python 3.4, right?

00:05:27.440 --> 00:05:28.180
I think so.

00:05:28.180 --> 00:05:28.480
Yeah.

00:05:28.480 --> 00:05:32.880
I think it was the Tulip project before then, which you could use with Python 3, I think.

00:05:32.880 --> 00:05:36.120
So yeah, I think it came in the standard library in 3.4.

00:05:36.240 --> 00:05:36.480
All right.

00:05:36.480 --> 00:05:38.780
So what's the main idea behind Async IO?

00:05:38.780 --> 00:05:43.060
I think it's about trying to utilize the CPU as much as you can.

00:05:43.060 --> 00:05:47.620
So instead of just being idle while you're waiting for IO, you've switched to something

00:05:47.620 --> 00:05:47.940
else.

00:05:47.940 --> 00:05:49.520
You gain the concurrency that way.

00:05:49.520 --> 00:05:51.220
To me, that's what it's about.

00:05:51.320 --> 00:05:51.400
Yeah.

00:05:51.400 --> 00:05:58.780
I think one of the real interesting things is web requests are so often waiting on other

00:05:58.780 --> 00:05:59.220
things.

00:05:59.220 --> 00:06:05.320
Like at the web server level, at the web framework level, a request comes in and it says, hey,

00:06:05.320 --> 00:06:06.020
I'm this user.

00:06:06.020 --> 00:06:07.140
I care about this data.

00:06:07.140 --> 00:06:09.000
What's the very next thing you do?

00:06:09.000 --> 00:06:10.820
You either call a microservice.

00:06:11.200 --> 00:06:14.480
You maybe find it on disk or you go talk to a database.

00:06:14.480 --> 00:06:20.960
Regardless, that whole process is just going, and I'll just be here for when you need me

00:06:20.960 --> 00:06:24.100
waiting for you to get back to me on that data so I can give it to the user, right?

00:06:24.100 --> 00:06:24.880
Yeah, exactly.

00:06:24.880 --> 00:06:31.820
And so if you could somehow say, well, let's pause that until that bit of work has an answer

00:06:31.820 --> 00:06:40.080
back from the Async IO, from the IO conversation, right, to the database or whatever, and let some

00:06:40.080 --> 00:06:45.240
other part of code that's going to run, run, so it can then begin to wait, you know, a lot

00:06:45.240 --> 00:06:46.660
of hurry up and wait on the web server.

00:06:46.660 --> 00:06:52.540
And so the Async IO basically means if you're waiting on IO, that same thread can be processing,

00:06:52.540 --> 00:06:57.440
can release the GIL and be processing other things, which I think is especially important

00:06:57.440 --> 00:06:58.220
in the web world.

00:06:58.220 --> 00:07:00.220
I think it goes a bit further as well.

00:07:00.220 --> 00:07:06.020
Like if you compare it to say threading, which is another way to achieve the same thing in that

00:07:06.020 --> 00:07:09.680
it's obviously a coroutines are much more lightweight.

00:07:09.680 --> 00:07:15.280
So you can handle many more of these requests at any point in time than you can with threads.

00:07:15.280 --> 00:07:19.780
So that's the other part of it that makes it really useful for web servers.

00:07:19.780 --> 00:07:20.140
Yeah.

00:07:20.140 --> 00:07:22.240
The lightweight part is really, really interesting.

00:07:22.240 --> 00:07:26.620
I mean, anyone who's sort of worked with a generator, it's kind of, kind of like that.

00:07:27.300 --> 00:07:32.280
And threads themselves have all sorts of overhead that comes with them, creating a thread, destroying

00:07:32.280 --> 00:07:32.680
a thread.

00:07:32.680 --> 00:07:37.740
So maybe you put them into a thread pool, but threads themselves, they have context switches

00:07:37.740 --> 00:07:39.740
at the kernel CPU level.

00:07:39.740 --> 00:07:42.960
They may mess up the cache, right?

00:07:42.960 --> 00:07:44.720
The L1, L2 cache.

00:07:44.720 --> 00:07:48.920
And so then they kind of can wreck performance as you cycle between the threads.

00:07:48.920 --> 00:07:55.240
You know, the cost of a thread varies by operating system, but they can have like a meg of stack

00:07:55.240 --> 00:07:56.320
space allocated to them.

00:07:56.320 --> 00:07:59.260
There's all sorts of things that limit how many you can have.

00:07:59.260 --> 00:08:01.780
So you can have a 10, no problem.

00:08:01.780 --> 00:08:02.760
A hundred, no problem.

00:08:02.760 --> 00:08:06.980
A thousand starts to, you know, maybe push the actual memory limits of your computer.

00:08:06.980 --> 00:08:12.620
With these, the sort of asyncio stuff, you can have many thousands, which is, I think, really

00:08:12.620 --> 00:08:12.940
awesome.

00:08:12.940 --> 00:08:18.480
So maybe give us a quick comparison to this concept with like Eventlet or GeoVent.

00:08:18.480 --> 00:08:19.760
How are they similar or different?

00:08:19.760 --> 00:08:25.840
So I think Eventlet and GeoVent are the ones you typically use with Flask at the moment.

00:08:25.840 --> 00:08:31.340
And I think Eventlet is roughly started out as a fork of GeoVent.

00:08:31.340 --> 00:08:33.280
So they're similar in principle, those two.

00:08:33.280 --> 00:08:38.080
And they're all three, including AsyncIO, are very similar in principle.

00:08:38.080 --> 00:08:45.380
They're an event loop that runs tasks or greenlets or coroutines and allow yielding when there's

00:08:45.380 --> 00:08:45.660
IO.

00:08:45.660 --> 00:08:51.220
But I think the crucial difference and what AsyncIO, I think, does differently to all the

00:08:51.220 --> 00:08:54.900
choices I've seen so far is that it makes the yielding explicit.

00:08:54.900 --> 00:08:57.080
You have to write the await keyword.

00:08:57.080 --> 00:09:01.720
And that fits the Python philosophy a lot better.

00:09:01.720 --> 00:09:03.800
Obviously, explicit being better than implicit.

00:09:04.620 --> 00:09:10.260
And I think it makes it a lot clearer to the user because you now know when these changes

00:09:10.260 --> 00:09:10.740
are going to happen.

00:09:10.740 --> 00:09:15.760
And you get a feeling that you're actually writing these yields in your code rather than

00:09:15.760 --> 00:09:17.560
there's some magic in the background making it happen.

00:09:17.560 --> 00:09:17.820
Right.

00:09:17.820 --> 00:09:18.200
Exactly.

00:09:18.200 --> 00:09:19.100
That's very cool.

00:09:19.100 --> 00:09:23.940
So basically, anytime you're going to call one of these Async methods, you say await.

00:09:24.180 --> 00:09:31.660
And that signals to the runtime to say, now we're going to give up this execution and pause

00:09:31.660 --> 00:09:34.280
until this IO or this event completes.

00:09:34.280 --> 00:09:35.560
Go on.

00:09:35.560 --> 00:09:41.040
And you sort of really clearly know and call out where things are going to sort of pause,

00:09:41.040 --> 00:09:44.240
at least for that request, but also yield the execution.

00:09:44.240 --> 00:09:44.480
Right.

00:09:44.560 --> 00:09:49.620
I think it was probably a little clearer before they introduced the Async and await keywords

00:09:49.620 --> 00:09:55.180
because you'd write an explicit yield to actually yield and a yield front to just switch control

00:09:55.180 --> 00:09:56.500
to your next coroutine.

00:09:56.500 --> 00:10:01.940
Whereas just with the await keywords, you could await a coroutine or await something that does

00:10:01.940 --> 00:10:04.360
yield, but it's not quite clear as much.

00:10:04.360 --> 00:10:09.860
But still, you know that that line could possibly yield, which makes it a lot clearer.

00:10:09.860 --> 00:10:10.200
Yeah.

00:10:10.200 --> 00:10:10.380
Yeah.

00:10:10.380 --> 00:10:11.040
That's really cool.

00:10:11.360 --> 00:10:15.420
So one thing that you've talked about is this AsyncIO color problem.

00:10:15.420 --> 00:10:15.900
What's that?

00:10:15.900 --> 00:10:18.400
I can't remember who termed it as such.

00:10:18.400 --> 00:10:19.040
Yeah.

00:10:19.040 --> 00:10:25.560
I certainly copied their choice because you could imagine coloring certain colors red and the

00:10:25.560 --> 00:10:30.640
red functions call other red functions and other functions black and the same applies.

00:10:30.640 --> 00:10:35.460
And the red functions would be coroutines asynchronous functions and the black ones just use synchronous

00:10:35.460 --> 00:10:35.920
ones.

00:10:35.920 --> 00:10:38.300
So I think that's where the naming comes from.

00:10:38.300 --> 00:10:44.380
But the basic problem part of it is that the explicit design forces you to only be able

00:10:44.380 --> 00:10:48.400
to trigger coroutines asynchronous code from coroutines.

00:10:48.400 --> 00:10:54.580
So if you have a synchronous function, your standard Python function, it's quite hard to run a coroutine.

00:10:54.580 --> 00:10:54.880
Right.

00:10:54.940 --> 00:11:01.900
And that's one of the hearts of the problems of why so many popular web frameworks don't

00:11:01.900 --> 00:11:03.220
just enable async.

00:11:03.220 --> 00:11:04.060
Right.

00:11:04.060 --> 00:11:06.800
Because it comes in through this WSGI interface.

00:11:06.800 --> 00:11:12.260
It calls, you know, the one function that is in that API and it starts out synchronous.

00:11:12.720 --> 00:11:18.840
And so there's really no layer, no place where you can sort of inject that easily.

00:11:18.840 --> 00:11:19.160
Right.

00:11:19.160 --> 00:11:24.200
Not only is it viral in nature, as soon as you want to await something, you need to be in a

00:11:24.200 --> 00:11:26.920
asynchronous in a coroutine to do so.

00:11:26.920 --> 00:11:30.260
To also call that coroutine, you need to be in a coroutine again.

00:11:30.420 --> 00:11:34.960
So you go all the way up to the event loop that inevitably runs your coroutines.

00:11:34.960 --> 00:11:39.320
And WSGI, at least in its current form, doesn't have a concept of event loop.

00:11:39.320 --> 00:11:41.160
So it's not having that.

00:11:41.160 --> 00:11:47.380
It's also not going to do the IO necessarily in a way that's going to yield to any event loop

00:11:47.380 --> 00:11:47.800
for you.

00:11:47.920 --> 00:11:52.100
So even if you introduce it later on, you're not necessarily getting the full advantage

00:11:52.100 --> 00:11:54.180
of yielding on the IO.

00:11:54.180 --> 00:11:59.420
You basically have to block and wait to give the request back at some point, or you're going

00:11:59.420 --> 00:12:00.200
to get ahead of yourself.

00:12:00.200 --> 00:12:03.320
And that pretty much cancels out all the benefits that you had.

00:12:03.320 --> 00:12:09.600
So your project says, we're going to take this and we're going to start from this asynchronous

00:12:09.600 --> 00:12:10.780
level.

00:12:10.780 --> 00:12:16.360
One thing I do want to call out, and I can't quickly look up where it is, but there's this

00:12:16.360 --> 00:12:22.720
great article by Christian Medina that says, it's titled something like Controlling Async

00:12:22.720 --> 00:12:23.220
Creep.

00:12:23.220 --> 00:12:29.340
And he talks about this problem, this asyncio coloring problem, and different techniques

00:12:29.340 --> 00:12:32.700
you can have to sort of create boundaries or whatnot.

00:12:32.700 --> 00:12:34.900
Very, very interesting article around this idea.

00:12:34.900 --> 00:12:36.780
But let's stay focused on this.

00:12:36.780 --> 00:12:44.260
So maybe before we get into how people work with Flask, I feel like the Flask API is showing

00:12:44.260 --> 00:12:44.880
up everywhere.

00:12:45.500 --> 00:12:51.680
For example, I just recently did a show on Flask Ask, which is like a Flask API for writing,

00:12:51.680 --> 00:12:55.640
say, Echo Dot type voice interactions.

00:12:55.640 --> 00:13:02.000
And you just write it as a Flask app, and it just magically plugs into that whole framework

00:13:02.000 --> 00:13:03.400
from Amazon, which is really cool.

00:13:03.400 --> 00:13:05.400
So why do you think Flask is so popular?

00:13:05.400 --> 00:13:06.440
That does sound really cool.

00:13:07.240 --> 00:13:15.000
I think it's a very clear and concise API to use.

00:13:15.000 --> 00:13:21.120
I think if you're a very simple example that hello world with the decorator saying this

00:13:21.120 --> 00:13:25.980
is the root and this is the view function, I think you couldn't get an API clearer than

00:13:25.980 --> 00:13:27.440
that for a web framework.

00:13:27.440 --> 00:13:29.340
It's so concise and nice.

00:13:29.340 --> 00:13:35.920
And I think the design choices Flask has made as a whole just really kind of emphasize this

00:13:35.920 --> 00:13:36.920
usability.

00:13:36.920 --> 00:13:42.280
So it might be the request object being a global, for example, just because you're going

00:13:42.280 --> 00:13:44.220
to use it that way, it makes life so much easier.

00:13:44.220 --> 00:13:50.720
And so I think this and the familiarity of that API is what kicked it off.

00:13:50.720 --> 00:13:56.680
And then I think that enabled the really strong community around Flask that probably makes it

00:13:56.680 --> 00:13:57.800
really popular today.

00:13:57.800 --> 00:14:04.300
So the great blog posts you can find, especially effectively the large blog post I think everyone

00:14:04.300 --> 00:14:10.420
starts with from, I think, Michael Grinberg and the extensions on Miguel.

00:14:10.420 --> 00:14:11.360
Yeah, Miguel Grinberg.

00:14:11.360 --> 00:14:16.980
And he just, he's actually redoing that one for Python 3 and modern Flask and all that.

00:14:16.980 --> 00:14:20.220
So like he's halfway through redoing that, which is really exciting as well.

00:14:20.220 --> 00:14:21.740
Yeah, I'll be sure to link to that.

00:14:21.740 --> 00:14:22.520
I agree.

00:14:22.520 --> 00:14:26.980
I think there's also so many plugins you can get to sort of extend Flask, right?

00:14:26.980 --> 00:14:29.860
There's extensions for almost anything you could want to do.

00:14:29.860 --> 00:14:30.980
Let's talk about this for a second.

00:14:30.980 --> 00:14:36.460
What if I have a Flask app, standard Flask, not Quart or anything, frequency like that, and

00:14:36.460 --> 00:14:38.060
I want to do something asynchronous in it?

00:14:38.400 --> 00:14:43.140
Like, let's say I want to do WebSockets, which are basically permanent connections, right?

00:14:43.140 --> 00:14:48.080
That can't easily be done synchronously in sort of a request response style.

00:14:48.080 --> 00:14:49.820
So how would that go?

00:14:49.820 --> 00:14:50.480
Can you do it?

00:14:50.480 --> 00:14:50.900
Yeah.

00:14:51.020 --> 00:14:55.580
I think typically at the moment you'd use Gevent, at least the two popular ones, which

00:14:55.580 --> 00:15:00.700
is Flask Sockets, the popular extensions, and Flask Socket.io, I believe use Gevent under

00:15:00.700 --> 00:15:01.040
the HUD.

00:15:01.040 --> 00:15:05.140
And you do need the event loop really to make it possible.

00:15:05.140 --> 00:15:08.540
And with those, it's actually quite easy.

00:15:08.540 --> 00:15:11.120
I think you just add that extension.

00:15:11.280 --> 00:15:12.600
It takes care of the rest for you.

00:15:12.600 --> 00:15:19.220
And you can just decorate a function that you say is a WebSocket root and deal with the WebSocket

00:15:19.220 --> 00:15:19.660
directly.

00:15:19.660 --> 00:15:20.880
It's very easy.

00:15:20.880 --> 00:15:21.180
I see.

00:15:21.180 --> 00:15:27.480
So does it basically like hand it off to that processing to just run asynchronously on its

00:15:27.480 --> 00:15:27.660
own?

00:15:27.660 --> 00:15:32.500
Well, if we take the Flask Socket example, what that does is it'll wrap your Flask app

00:15:32.500 --> 00:15:37.780
in a Gevent whiskey server and introduce the WebSocket at that level.

00:15:37.780 --> 00:15:43.860
So a WebSocket request coming in would be handled before it gets to Flask, although it looks like

00:15:43.860 --> 00:15:45.920
it's going to Flask, but it would be handled beforehand.

00:15:45.920 --> 00:15:49.600
And then everything else would just go straight through to Flask with the whiskey interface.

00:15:49.600 --> 00:15:52.060
So yeah, it would work that way.

00:15:52.060 --> 00:15:52.360
Yeah.

00:15:52.360 --> 00:15:52.800
Nice.

00:15:52.800 --> 00:15:56.940
This portion of Talk Python is brought to you by SmartKits.

00:15:56.940 --> 00:16:00.140
And they're looking to hire someone to write some really awesome Python code.

00:16:00.140 --> 00:16:05.160
SmartKits operates a world-leading exchange for peer-to-peer trading on sports, politics,

00:16:05.160 --> 00:16:05.880
and current affairs.

00:16:05.880 --> 00:16:10.640
As a business, SmartKits is widely recognized as one of the fastest-growing tech companies

00:16:10.640 --> 00:16:14.800
in Europe and has won a roster of awards for its success over the past few years.

00:16:14.800 --> 00:16:20.040
Headquartered in London with a new tech hub in downtown LA, the company is pioneering a

00:16:20.040 --> 00:16:22.160
self-managed organizational structure.

00:16:22.160 --> 00:16:26.920
This breaks down the traditional pyramid of hierarchical silos into a more fluid and

00:16:26.920 --> 00:16:30.640
flat network of interlinked teams who are engineers of the driving force.

00:16:30.640 --> 00:16:31.940
They're no formal bosses.

00:16:31.940 --> 00:16:36.940
Staff are allowed to set their own salary, have unlimited holiday, and work where they like

00:16:36.940 --> 00:16:37.660
within the company.

00:16:37.660 --> 00:16:43.520
Over 60% of the staff are engineers who work on a modern tech stack predominantly based on

00:16:43.520 --> 00:16:45.960
Python, complemented with Erlang and JavaScript.

00:16:45.960 --> 00:16:52.140
SmartKits uses Python 3.6 throughout and deploys dockerized microservices multiple times a day.

00:16:52.140 --> 00:16:58.740
Apply to work at SmartKits by visiting talkpython.fm/SmartKits or just click the link in

00:16:58.740 --> 00:16:59.380
the episode notes.

00:16:59.380 --> 00:17:07.520
Suppose I want to have some Flask view method and it's going to say call a web service.

00:17:07.660 --> 00:17:10.300
It's going to talk to a Postgres database, for example.

00:17:10.300 --> 00:17:15.060
There are asynchronous ways to do those things, right?

00:17:15.060 --> 00:17:22.980
If I have AIO HTTP client, that's a really nice AsyncIO friendly way to call remote services.

00:17:22.980 --> 00:17:27.580
And I could use the Async Postgres driver there and call that.

00:17:28.180 --> 00:17:33.360
But with straight Flask, I can't put like Async on my methods, right?

00:17:33.360 --> 00:17:36.220
Or await in it and really get it to honor that, could I?

00:17:36.220 --> 00:17:37.560
I don't think so.

00:17:37.560 --> 00:17:43.380
There was an extension called Flask AO HTTP, which I think is no longer maintained.

00:17:43.380 --> 00:17:49.100
But that, I believe, used the WISCII interface that AO HTTP provided, which I think is also

00:17:49.100 --> 00:17:50.420
deprecated now, sadly.

00:17:50.420 --> 00:17:56.520
But that would allow you to fairly easily, I think, make your Flask view functions async.

00:17:56.720 --> 00:18:04.840
But it wasn't, I think it had some issues whereby the locals, the requests, gee, those request

00:18:04.840 --> 00:18:07.520
locals would get corrupted or could get corrupted.

00:18:07.520 --> 00:18:09.520
So I think that kind of ruled it out.

00:18:09.520 --> 00:18:12.020
Yeah, that doesn't sound amazing, right?

00:18:12.020 --> 00:18:13.600
No, no, you certainly don't want that.

00:18:13.600 --> 00:18:20.680
There was also a fork, a Flask I found that did make the view functions async.

00:18:20.680 --> 00:18:23.560
It was designed around async AO for 3.4.

00:18:24.060 --> 00:18:29.900
But I haven't quite tried to figure out how it worked or if it worked, but it hasn't been

00:18:29.900 --> 00:18:31.100
touched for about three years.

00:18:31.100 --> 00:18:33.260
So I don't think that's maintained either.

00:18:33.260 --> 00:18:33.580
Right.

00:18:33.580 --> 00:18:37.060
And so this maybe brings us to your project, Quart.

00:18:37.060 --> 00:18:37.620
All right.

00:18:37.620 --> 00:18:38.180
What is Quart?

00:18:38.180 --> 00:18:44.020
So Quart is a web micro framework, much like Flask, based on async AO and the Flask API.

00:18:44.860 --> 00:18:50.260
So the aim really is to provide the easiest stepping stone from someone who has a Flask

00:18:50.260 --> 00:18:56.080
app or Flask knowledge to use async in that app or in a new app with that knowledge, basically.

00:18:56.080 --> 00:19:00.200
So yeah, it's just a web framework, web micro framework.

00:19:00.200 --> 00:19:00.740
Nice.

00:19:00.740 --> 00:19:06.040
So you decided instead of, because there are other asyncio frameworks that have come

00:19:06.040 --> 00:19:09.840
around, Sanic, Chepronto, others that we can talk about later.

00:19:09.840 --> 00:19:15.040
But generally they said, we're going to come up with a new way to program the web and we're

00:19:15.040 --> 00:19:17.640
going to sort of do it around this asyncio thing.

00:19:17.640 --> 00:19:19.900
And you said, look, Flask is super popular.

00:19:20.160 --> 00:19:23.240
It has this API that people already know.

00:19:23.240 --> 00:19:28.460
People can go and take Miguel's tutorial and learn about it already.

00:19:28.460 --> 00:19:33.140
But you just want to have it work with asyncio, right?

00:19:33.140 --> 00:19:35.040
And so we're going to start from there, right?

00:19:35.040 --> 00:19:39.120
How much did you borrow from Flask and how much did you have to start from scratch here?

00:19:39.120 --> 00:19:45.980
I've tried to borrow the entire Flask API and quite a bit of the Verkser API, which is

00:19:45.980 --> 00:19:49.340
the part under Flask that powers most of the HTTP stuff.

00:19:49.780 --> 00:19:51.460
I've tried to borrow most of that as well.

00:19:51.460 --> 00:19:53.580
So yeah, a great deal, hopefully.

00:19:53.580 --> 00:19:59.500
What I'd really quite like is if you have a Flask app that doesn't use any extensions, you

00:19:59.500 --> 00:20:03.880
can just find, replace Flask with Quart and then add the async and await keywords and it

00:20:03.880 --> 00:20:04.400
just runs.

00:20:04.400 --> 00:20:05.940
That's what I'm kind of aiming for.

00:20:05.940 --> 00:20:06.480
That's great.

00:20:06.480 --> 00:20:08.040
And how close is it to that goal?

00:20:08.040 --> 00:20:09.700
I think it's quite close.

00:20:09.700 --> 00:20:12.300
I think it's really the details now.

00:20:12.300 --> 00:20:18.840
So for example, I need to work on the e-tag handling, how they're applied to static files

00:20:18.840 --> 00:20:19.660
and stuff like that.

00:20:19.660 --> 00:20:22.600
And subdomain handling in the routing system.

00:20:22.600 --> 00:20:27.000
I think those are real details that I think most of the use cases, it should be possible

00:20:27.000 --> 00:20:27.960
to just do that now.

00:20:27.960 --> 00:20:30.280
To just, as in, find, replace.

00:20:30.280 --> 00:20:31.020
Oh, that's awesome.

00:20:31.020 --> 00:20:35.460
You could go like grab Miguel's tutorial and just, I don't know, what's the verb of making

00:20:35.460 --> 00:20:36.220
it run on Quart?

00:20:36.220 --> 00:20:37.080
Quartify?

00:20:37.080 --> 00:20:39.740
Add Quart capabilities to it, right?

00:20:39.740 --> 00:20:40.340
That'd be cool.

00:20:40.340 --> 00:20:40.840
Very cool.

00:20:41.660 --> 00:20:47.480
I guess one of the first questions is why not just fork Flask and just tack on the little

00:20:47.480 --> 00:20:50.200
bits of asyncio handling that you need?

00:20:50.200 --> 00:20:51.440
That would be ideal.

00:20:51.440 --> 00:20:55.580
Well, but at the moment, at least, it's beyond what I'm able to do.

00:20:56.000 --> 00:21:00.660
And I think it goes back to the Whiskey interface, which really isn't asynchronous.

00:21:01.100 --> 00:21:06.940
So, again, like if you really want the event loop to be able to get the yield on the request

00:21:06.940 --> 00:21:09.780
IO and the response IO, you need to be controlling that part.

00:21:09.780 --> 00:21:17.300
And so I think you have to go start from Flask, go up to VerkSug, and then almost go up to the

00:21:17.300 --> 00:21:23.360
WSGI servers themselves and make them asynchronous to really, well, I think IO compatible to really

00:21:23.360 --> 00:21:24.680
make it possible.

00:21:24.680 --> 00:21:28.140
And, yeah, I could really make that work.

00:21:28.140 --> 00:21:30.600
It was quite hard.

00:21:30.600 --> 00:21:39.120
I know a lot of people have tried and they've talked about adding like a Whiskey 2 or various

00:21:39.120 --> 00:21:44.480
acronyms with A involving in there to basically asyncify that API.

00:21:44.480 --> 00:21:47.600
But there's really not a lot of flexibility in there.

00:21:47.600 --> 00:21:53.160
And the actual Whiskey API, which is what all the web frameworks use to plug into the

00:21:53.160 --> 00:21:54.500
various web servers, right?

00:21:54.500 --> 00:21:56.460
I want to run on MicroWSGI.

00:21:56.460 --> 00:21:58.860
I want to run on Genicorn or whatever.

00:21:58.860 --> 00:21:59.760
They all speak Whiskey.

00:21:59.760 --> 00:22:03.920
So you can just plug Pyramid, Flask, Django, whatever in there, right?

00:22:03.920 --> 00:22:07.680
One of them I was looking at is ASCII, which I think Django is pushing.

00:22:07.680 --> 00:22:13.960
So I think the idea there is you just push out the messages to a queue and then you have loads

00:22:13.960 --> 00:22:18.100
of things consuming it in an asynchronous fashion and then returning the results.

00:22:18.100 --> 00:22:22.020
I don't think it would quite work for Quart either, but they seem to want to.

00:22:22.020 --> 00:22:25.520
I think they're trying to suggest that as the next step for Whiskey.

00:22:25.520 --> 00:22:26.800
Like it becomes ASCII.

00:22:26.800 --> 00:22:27.460
Yeah, yeah.

00:22:27.460 --> 00:22:29.060
That's one of the acronyms I was thinking of.

00:22:29.060 --> 00:22:37.100
So how do you add on things like WebSocket support or HTTP2 pipelining where you can make

00:22:37.100 --> 00:22:43.160
a request and actually through that in single network request punch like three CSS, a JavaScript,

00:22:43.160 --> 00:22:46.860
an image, an HTML file response as one.

00:22:46.860 --> 00:22:48.120
Do you think they could make that work there?

00:22:48.120 --> 00:22:49.320
I think so.

00:22:49.320 --> 00:22:54.900
Yeah, because each request could just be a separate message on their queue and then something can

00:22:54.900 --> 00:22:57.560
consume and produce the output and send it back.

00:22:57.560 --> 00:22:59.340
So I'm sure it would work for them.

00:22:59.340 --> 00:23:04.940
Maybe you could somehow bundle up the multiple responses or something at the framework level

00:23:04.940 --> 00:23:06.580
and then send it over to the network.

00:23:06.580 --> 00:23:07.040
I don't know.

00:23:07.040 --> 00:23:11.560
It's yeah, it's going to it's going to be pretty interesting with all the HTTP2 stuff coming

00:23:11.560 --> 00:23:12.780
along and whatnot.

00:23:12.780 --> 00:23:13.540
Oh, definitely.

00:23:13.540 --> 00:23:17.840
I think HTTP2 is one of the most more exciting things I'm interested in.

00:23:17.840 --> 00:23:20.140
And I'm very pleased that Quart can do it.

00:23:20.140 --> 00:23:22.220
So it's very good to play with.

00:23:22.220 --> 00:23:22.740
It can.

00:23:22.740 --> 00:23:23.460
That's really cool.

00:23:23.460 --> 00:23:27.740
So how much of that is the framework and how much of that is, say, just the server it's

00:23:27.740 --> 00:23:28.200
running on?

00:23:28.200 --> 00:23:30.580
Say if you run on G Unicorn, right?

00:23:30.580 --> 00:23:35.800
How much is G Unicorn doing versus how much of is Quart actually doing to make the HTTP2

00:23:35.800 --> 00:23:36.200
supported?

00:23:36.200 --> 00:23:40.380
In a traditional sense, the WSGI server does all the HTTP passing and just passes through

00:23:40.380 --> 00:23:41.400
the environment.

00:23:41.400 --> 00:23:46.800
But for Quart, how it works with G Unicorn is we just use the socket.

00:23:46.800 --> 00:23:50.300
So G Unicorn doesn't actually do any HTTP passing.

00:23:50.300 --> 00:23:51.560
It all goes through to Quart.

00:23:51.900 --> 00:23:55.960
So all the HTTP2, the HTTP1, it's all taken care of in Quart.

00:23:55.960 --> 00:23:59.500
And we just pipe it back out through the socket that G Unicorn's provided.

00:23:59.500 --> 00:24:04.420
Give us a sense around the kind of performance differences that people could expect.

00:24:04.420 --> 00:24:10.920
If they, say, have a standard Flask app running on G Unicorn now, if they flip to using Quart

00:24:10.920 --> 00:24:13.720
also on G Unicorn, what do you think happens?

00:24:13.720 --> 00:24:17.680
I actually did a, I think you're going to link an article I did to look at this.

00:24:17.880 --> 00:24:24.780
And I looked at a kind of production use case where you have a simple CRUD app with a database

00:24:24.780 --> 00:24:25.540
in the background.

00:24:25.540 --> 00:24:27.840
I used G Unicorn with eventlet.

00:24:27.840 --> 00:24:34.080
So it was asynchronous, fairly similar type of work load pattern and the way it approaches

00:24:34.080 --> 00:24:34.840
the problem.

00:24:35.120 --> 00:24:36.780
And I compared it against Quart.

00:24:36.780 --> 00:24:41.960
And I think with Quart, I got something like a free time throughput speed up.

00:24:41.960 --> 00:24:47.900
So the latency or the request time itself didn't really make too much of a difference.

00:24:47.900 --> 00:24:50.840
But the amount of requests it could handle at once really increased.

00:24:50.840 --> 00:24:51.980
Yeah, that's really cool.

00:24:51.980 --> 00:24:57.000
And I would guess that you're probably were not working with like a super slow database

00:24:57.000 --> 00:25:00.360
or a tremendous amount of data in your simple test.

00:25:00.360 --> 00:25:07.320
But it seems to me like the worse the database performs, the more beneficial having this asynchronous

00:25:07.320 --> 00:25:11.680
thing could be to sort of free up the waiting.

00:25:11.680 --> 00:25:16.340
The waiting, the worse the waiting is, the more beneficial is to have async methods.

00:25:16.340 --> 00:25:21.420
Although that should apply to both sides of the test because eventlet would do the same

00:25:21.420 --> 00:25:22.660
in the flask sense.

00:25:22.660 --> 00:25:23.080
Right.

00:25:23.080 --> 00:25:23.620
OK, yeah.

00:25:23.620 --> 00:25:27.460
So if you're already switching to eventlet, then it would.

00:25:27.460 --> 00:25:34.480
Have you thought about this relative to a non-async flask, like just a standard flask, if you're

00:25:34.480 --> 00:25:35.160
not using eventlet?

00:25:35.160 --> 00:25:39.900
Yeah, it makes a huge difference then because your requests effectively become synchronous.

00:25:39.900 --> 00:25:41.200
You have to do one at a time.

00:25:41.200 --> 00:25:43.840
So unless I suppose you used threading.

00:25:43.840 --> 00:25:48.840
I haven't tried threading, but assuming you've got no asynchronous aspect at all, then it would

00:25:48.840 --> 00:25:52.020
make a very large difference because you would have to finish the one request before you could

00:25:52.020 --> 00:25:52.840
even start the next.

00:25:52.840 --> 00:25:53.580
That's for sure.

00:25:53.580 --> 00:25:54.520
How interesting.

00:25:54.520 --> 00:26:01.160
OK, so you talked about flask and I said one of the benefits of it is these flask extensions,

00:26:01.160 --> 00:26:01.600
right?

00:26:01.600 --> 00:26:03.420
There's a bunch of stuff you can plug in.

00:26:03.420 --> 00:26:06.220
Does Quart support flask extensions?

00:26:06.220 --> 00:26:10.240
Supports a good fraction of them, I think it's fair to say.

00:26:10.860 --> 00:26:15.460
So this goes back to that color problem we mentioned earlier, because, of course, all the

00:26:15.460 --> 00:26:16.680
extensions are synchronous.

00:26:16.680 --> 00:26:18.320
They have synchronous functions.

00:26:18.320 --> 00:26:23.440
And inevitably, they're going to try and call some code that's now asynchronous in Quart.

00:26:23.440 --> 00:26:25.600
And that's where it becomes a problem.

00:26:25.600 --> 00:26:29.080
So I can go in the details of how it gets around that.

00:26:29.080 --> 00:26:31.520
But that's why some of them work.

00:26:31.520 --> 00:26:33.100
Yeah, that'd be kind of interesting, right?

00:26:33.180 --> 00:26:37.840
Because people are going to pip install these extensions and generally not change the code.

00:26:37.840 --> 00:26:44.000
And until your framework is popular enough that people are creating sort of async equivalents

00:26:44.000 --> 00:26:48.260
of their extensions, you have to make these, you have to blend the colors, right?

00:26:48.260 --> 00:26:49.120
So how are you doing that?

00:26:49.120 --> 00:26:50.660
It's quite fun to look at.

00:26:50.660 --> 00:26:51.720
It took quite a bit of time.

00:26:51.720 --> 00:26:56.320
So if I go back to how you run a coroutine, you need to run it in the event loop.

00:26:56.720 --> 00:26:58.780
And if you're outside of the event loop, it's quite easy.

00:26:58.780 --> 00:27:02.160
You just either create or get an event loop and tell it to run a coroutine.

00:27:02.160 --> 00:27:03.680
And it's all very good.

00:27:03.680 --> 00:27:08.500
But if you're in a function that's been called by something within the event loop, you can't

00:27:08.500 --> 00:27:08.880
do that.

00:27:08.880 --> 00:27:14.200
The actual async arrow function run until complete, for example, will refuse to run because you're

00:27:14.200 --> 00:27:15.020
inside the event loop.

00:27:15.020 --> 00:27:20.320
And it turns out this was known back during the tulip days.

00:27:20.400 --> 00:27:26.780
And someone proposed a solution to this, which was to actually run the event loop again within

00:27:26.780 --> 00:27:29.260
the event loop to run this particular coroutine.

00:27:29.260 --> 00:27:35.160
And I think it was rejected because it just made things quite complicated and wasn't a particularly

00:27:35.160 --> 00:27:36.400
useful use case.

00:27:36.400 --> 00:27:41.140
But in this case where you've got legacy, well, you have synchronous code, trying to call

00:27:41.140 --> 00:27:43.400
asynchronous code is exactly what you need to do.

00:27:44.040 --> 00:27:49.500
So what Quart will do if you want to go down this route is monkey patch the event loop to

00:27:49.500 --> 00:27:56.080
add a method to run the event loop, if you like, manually for a coroutine that you specify.

00:27:56.080 --> 00:28:01.920
So it will suspend the event loop it's already in, run it itself, and then restore everything

00:28:01.920 --> 00:28:02.740
after it's complete.

00:28:02.740 --> 00:28:04.820
So it probably sounds a bit messy.

00:28:04.820 --> 00:28:07.720
So it probably is.

00:28:07.720 --> 00:28:12.980
It sounds like it could create this cascading chain of nested event loops going down and

00:28:12.980 --> 00:28:13.400
down and down.

00:28:13.400 --> 00:28:14.900
Yeah, probably so.

00:28:14.900 --> 00:28:21.660
But it does allow like these extensions with a synchronous call to another function to be

00:28:21.660 --> 00:28:24.880
able to call an asynchronous function without them being able to tell.

00:28:24.880 --> 00:28:28.520
There's just a layer in between that does this kind of mapping from sync to async.

00:28:28.520 --> 00:28:29.360
That's really cool.

00:28:29.360 --> 00:28:30.300
I'm very creative.

00:28:30.300 --> 00:28:33.120
So you said it works for most of them.

00:28:33.120 --> 00:28:34.580
When it fails, what happens?

00:28:34.580 --> 00:28:35.720
Like, why does it not work?

00:28:35.720 --> 00:28:36.540
Do you remember?

00:28:36.540 --> 00:28:41.020
So Flask has these request locals, like the request object or the G object.

00:28:41.020 --> 00:28:46.480
And when you try and do anything with them or access any attribute of them, it effectively

00:28:46.480 --> 00:28:52.880
proxies that action to an instance that's local to the thread or greenlit that you're on.

00:28:53.340 --> 00:28:54.360
And I hope that makes sense.

00:28:54.360 --> 00:28:56.080
It's proxying, basically.

00:28:56.080 --> 00:29:02.580
So what I can do in Quart is I can, during that proxy, also take it from a synchronous call to an

00:29:02.580 --> 00:29:03.420
asynchronous call.

00:29:03.420 --> 00:29:06.840
So that works really well for these local proxy objects.

00:29:07.380 --> 00:29:13.620
The problem is when an extension uses the Flask class itself, like the app, because I haven't

00:29:13.620 --> 00:29:18.980
figured out a way yet to effectively proxy the call and convert it from synchronous to asynchronous.

00:29:18.980 --> 00:29:23.380
So if the extension just uses these globals, it's good.

00:29:23.380 --> 00:29:25.760
If it uses the app, I need to be a bit more clever.

00:29:25.760 --> 00:29:29.420
Hopefully you get that puzzle figured out, because it'd be really cool to have that supported

00:29:29.420 --> 00:29:29.660
there.

00:29:29.660 --> 00:29:30.720
Very nice.

00:29:30.880 --> 00:29:33.820
So what template languages are supported?

00:29:33.820 --> 00:29:35.080
You have Jinja 2?

00:29:35.080 --> 00:29:38.620
It follows the Flask design in that respect and just does Jinja 2.

00:29:38.620 --> 00:29:42.780
But I'm sure like the, I think there's an extension called Flask Maco.

00:29:42.780 --> 00:29:43.600
It's quite popular.

00:29:43.600 --> 00:29:46.180
I think that may work as well.

00:29:46.180 --> 00:29:50.480
The question becomes whether that template in engine is asynchronous itself.

00:29:50.480 --> 00:29:53.420
So if it isn't, you just get a bit of a performance hit.

00:29:53.520 --> 00:29:53.720
Right.

00:29:53.720 --> 00:29:54.040
I see.

00:29:54.040 --> 00:29:59.120
So the Jinja 2 one supports asynchronous behaviors in directly?

00:29:59.120 --> 00:29:59.760
It does.

00:29:59.760 --> 00:30:03.340
It's actually, if you look at the code, it's kind of amazing how they do it.

00:30:03.340 --> 00:30:08.300
So if you're running Python 3.6 and you ask it to be asynchronous, it will patch itself to

00:30:08.300 --> 00:30:10.020
add the asynchronous methods.

00:30:10.020 --> 00:30:12.840
It's, yeah, it's really quite good to look at.

00:30:12.840 --> 00:30:14.060
Wow, that's quite awesome, actually.

00:30:14.060 --> 00:30:15.100
I didn't realize it did that.

00:30:15.100 --> 00:30:19.900
So I'm guessing you don't support Python 2 in this.

00:30:19.900 --> 00:30:20.900
Is it Python 3 only?

00:30:20.900 --> 00:30:21.460
It is.

00:30:21.460 --> 00:30:23.240
It's even more restrictive than that, actually.

00:30:23.240 --> 00:30:27.380
It's Python 3.6 only because I use asynchronous generators.

00:30:27.380 --> 00:30:32.660
One of the uses being if you want to stream a response, you want to yield data back whilst

00:30:32.660 --> 00:30:33.300
being asynchronous.

00:30:33.300 --> 00:30:37.980
So because of that, you can't use anything other than Python 3.6 where they were introduced.

00:30:37.980 --> 00:30:39.240
Yeah, that's really interesting.

00:30:39.240 --> 00:30:44.940
So I feel like a few years ago, the story was, well, people can't move to Python 3 because

00:30:44.940 --> 00:30:48.760
there's all this cool stuff that we're using that only supports Python 2.

00:30:48.760 --> 00:30:52.960
And now I think more and more we're ending up in a situation where it's

00:30:52.960 --> 00:30:54.680
there's all these amazing new things.

00:30:54.680 --> 00:30:58.940
But they're only accessible to you if you're using the latest versions of Python 3, which

00:30:58.940 --> 00:31:00.320
I think that's a good move.

00:31:00.320 --> 00:31:04.900
The other thing it does as well, which really constrains it to Python 3 or I've used is I

00:31:04.900 --> 00:31:09.300
type into everything, including the variables, which the syntax, well, the nicest syntax was

00:31:09.300 --> 00:31:10.760
only introduced in Python 3.6.

00:31:10.760 --> 00:31:13.120
So yeah, I quite like that as well.

00:31:13.200 --> 00:31:14.080
I really do as well.

00:31:14.080 --> 00:31:18.720
I find it makes the editors much smarter about the types of things you're actually working

00:31:18.720 --> 00:31:19.000
with.

00:31:19.000 --> 00:31:21.760
You can run tools and say, no, no, you're passing an answer.

00:31:21.760 --> 00:31:24.540
You're supposed to pass the whole object, not the ID of the object here.

00:31:24.540 --> 00:31:25.140
Things like that.

00:31:25.140 --> 00:31:25.480
It's great.

00:31:26.980 --> 00:31:30.060
This portion of Talk Python to Me has been brought to you by Rollbar.

00:31:30.060 --> 00:31:33.760
One of the frustrating things about being a developer is dealing with errors.

00:31:33.760 --> 00:31:39.680
Relying on users to report errors, digging through log files, trying to debug issues, or getting

00:31:39.680 --> 00:31:42.780
millions of alerts just flooding your inbox and ruining your day.

00:31:42.900 --> 00:31:47.720
With Rollbar's full stack error monitoring, you get the context, insight, and control you need

00:31:47.720 --> 00:31:49.520
to find and fix bugs faster.

00:31:49.520 --> 00:31:53.520
Adding Rollbar to your Python app is as easy as pip install Rollbar.

00:31:53.520 --> 00:31:57.740
You can start tracking production errors and deployments in eight minutes or less.

00:31:57.740 --> 00:32:01.920
Are you considering self-hosting tools for security or compliance reasons?

00:32:01.920 --> 00:32:05.500
Then you should really check out Rollbar's compliant SaaS option.

00:32:05.500 --> 00:32:10.660
Get advanced security features and meet compliance without the hassle of self-hosting, including

00:32:10.660 --> 00:32:14.880
HIPAA, ISO 27001, Privacy Shield, and more.

00:32:14.880 --> 00:32:16.260
They'd love to give you a demo.

00:32:16.260 --> 00:32:17.960
Give Rollbar a try today.

00:32:17.960 --> 00:32:21.660
Go to talkpython.fm/Rollbar and check them out.

00:32:21.660 --> 00:32:32.020
Yeah, so actually converting your Flask methods to Quart methods is quite easy, right?

00:32:32.020 --> 00:32:35.140
You just, you have your, let's say, like a review function.

00:32:35.140 --> 00:32:36.720
I think this is an example you have on your website.

00:32:36.720 --> 00:32:40.540
You can say def add review data equals request.getJSON.

00:32:40.540 --> 00:32:46.940
Or you can just say async def add review data equals await request.getJSON.

00:32:46.940 --> 00:32:50.560
And you just add the async and await keywords and off it goes, right?

00:32:50.560 --> 00:32:50.740
Yeah.

00:32:50.740 --> 00:32:57.200
So I think it wouldn't be that hard to convert a small to medium-sized Flask app to Quart.

00:32:57.200 --> 00:32:57.880
What do you think?

00:32:57.880 --> 00:32:59.740
How much effort and testing has to be done?

00:32:59.820 --> 00:33:00.480
I think you're right.

00:33:00.480 --> 00:33:03.500
I think small ones should be quite easy.

00:33:03.500 --> 00:33:08.920
What probably make it hard for people is that they're probably going to call something else,

00:33:08.920 --> 00:33:09.880
like you were saying earlier.

00:33:09.880 --> 00:33:14.620
If you're going to do a web request to a, or a PHP request to a microservice or something

00:33:14.620 --> 00:33:16.200
to a database or something like that.

00:33:16.640 --> 00:33:20.440
And those libraries are likely to be synchronous rather than async.

00:33:20.440 --> 00:33:24.600
And while this comes back to the color problem, you're going to have to switch from, say,

00:33:24.600 --> 00:33:32.680
psycopg to async PG or your py Redis to like AO Redis or requests to AO HTTP.

00:33:32.680 --> 00:33:37.400
And that's probably going to be more work because those APIs are suddenly different usually.

00:33:37.800 --> 00:33:40.280
I would think probably the Redis wouldn't be that hard.

00:33:40.280 --> 00:33:43.840
Probably the AIO HTTP client, not such a big deal.

00:33:43.840 --> 00:33:49.360
But I feel like when you get down to database stuff, that's where the complexity lives a lot

00:33:49.360 --> 00:33:49.720
of times.

00:33:49.720 --> 00:33:56.700
So maybe upgrading the database driver or package to be the async one is probably where it's

00:33:56.700 --> 00:33:57.240
most challenging.

00:33:57.240 --> 00:33:57.820
I don't know.

00:33:57.820 --> 00:33:58.860
Have you tried?

00:33:58.860 --> 00:33:59.740
Have you got some experience?

00:33:59.740 --> 00:34:02.880
Yeah, I've played along with myself.

00:34:03.180 --> 00:34:07.880
And yeah, it's because I typically use psycopg directly.

00:34:07.880 --> 00:34:10.540
I don't use SQLAlchemy on top of it usually.

00:34:10.540 --> 00:34:12.120
And that's not too bad.

00:34:12.120 --> 00:34:13.800
It's fairly easy to change.

00:34:13.800 --> 00:34:16.060
And it has a big bonus.

00:34:16.060 --> 00:34:17.440
Like there's an async PG.

00:34:17.440 --> 00:34:24.020
If you look at how MagicStack report the benchmarking for it looks much, much quicker, which is excellent.

00:34:24.020 --> 00:34:28.500
But yes, if you have a lot of ORM stuff, I think you're almost stuck.

00:34:28.500 --> 00:34:31.160
I'm not sure I've seen an ORM that's async yet.

00:34:31.160 --> 00:34:35.440
I know that SQLAlchemy hasn't done it.

00:34:35.440 --> 00:34:39.640
I feel like there is one out there.

00:34:39.640 --> 00:34:46.180
And I'm hesitant to say which one I'm guessing it is because if it's wrong, I'll try to put

00:34:46.180 --> 00:34:47.840
some notes in the show notes or something.

00:34:47.840 --> 00:34:50.480
I've seen one that I thought allowed it.

00:34:50.480 --> 00:34:52.600
But yeah, certainly SQLAlchemy doesn't.

00:34:52.600 --> 00:34:55.200
And that's unfortunate, right?

00:34:55.200 --> 00:35:00.780
So it kind of says, look, if you're going to do the async stuff, then you're kind of stuck.

00:35:00.780 --> 00:35:04.400
I guess there's a few things you could do.

00:35:04.400 --> 00:35:10.440
You could move your requests out, say like another thread that you wrap up and you await

00:35:10.440 --> 00:35:12.240
that thing's response or something.

00:35:12.240 --> 00:35:15.480
But it definitely makes it not easy, right?

00:35:15.480 --> 00:35:15.800
Yeah.

00:35:15.800 --> 00:35:19.080
So asyncio makes that bit reasonably easy.

00:35:19.080 --> 00:35:23.520
I think there's a function called running executor, which will do almost exactly what you just said.

00:35:23.520 --> 00:35:25.620
So yeah, that's probably what you'd have to do.

00:35:25.700 --> 00:35:25.880
Okay.

00:35:25.880 --> 00:35:29.180
So I found what I was looking for and it's actually not the ORM itself.

00:35:29.180 --> 00:35:29.800
It's an add-on.

00:35:29.800 --> 00:35:31.040
It's called P.

00:35:31.040 --> 00:35:36.260
So the ORM is PeeWee, which is a sort of a small ORM type of thing.

00:35:36.260 --> 00:35:36.840
Right.

00:35:36.840 --> 00:35:37.820
It's, it's pretty popular.

00:35:37.820 --> 00:35:44.540
It's got close to 5,000 stars, but there's PeeWee dash async, which is an asyncio interface

00:35:44.540 --> 00:35:45.120
for PeeWee.

00:35:45.120 --> 00:35:48.440
So that one, that one you can do it.

00:35:48.440 --> 00:35:55.260
So you can basically say await objects.create or things like that, where you basically do

00:35:55.260 --> 00:35:58.000
the queries and then you can await the response, which is kind of cool.

00:35:58.000 --> 00:35:58.640
Oh, that is cool.

00:35:58.640 --> 00:35:58.900
Yeah.

00:35:58.900 --> 00:35:59.780
I didn't come across that.

00:35:59.780 --> 00:36:00.200
Yeah.

00:36:00.200 --> 00:36:05.200
But it's unfortunate that it's not like the most popular one, like SQLAlchemy or say the

00:36:05.200 --> 00:36:07.420
Django one or something like this, right?

00:36:07.420 --> 00:36:09.060
Like it's, yeah.

00:36:09.180 --> 00:36:13.080
But if people are looking for it, like maybe you'd have to switch to PeeWee async if right

00:36:13.080 --> 00:36:14.640
now it's written in say SQLAlchemy.

00:36:14.640 --> 00:36:15.360
I don't know.

00:36:15.360 --> 00:36:16.440
So what do you think?

00:36:16.440 --> 00:36:17.820
I'm thinking about this database problem.

00:36:17.820 --> 00:36:25.900
Like, can you take a SQLAlchemy Flask app or a MongoDB Flask app and somehow shoehorn

00:36:25.900 --> 00:36:27.800
it in so you can still do these queries?

00:36:27.800 --> 00:36:32.320
You don't have to completely rewrite your data access layer, but make it async friendly.

00:36:32.320 --> 00:36:33.040
Easy?

00:36:33.040 --> 00:36:33.560
Not easy?

00:36:33.560 --> 00:36:36.280
I think it, in all honesty, it requires a bit of effort.

00:36:36.280 --> 00:36:36.760
Yes.

00:36:36.860 --> 00:36:40.060
You'd have to, you'd probably want to choose a different driver.

00:36:40.060 --> 00:36:42.120
So you need to spend some time looking into it.

00:36:42.120 --> 00:36:45.340
And then you'd probably have to rewrite a bit to actually make it work.

00:36:45.340 --> 00:36:47.860
So yeah, I don't think it's all that easy.

00:36:47.860 --> 00:36:49.160
It doesn't sound easy to me either.

00:36:49.160 --> 00:36:50.460
Although it may be worth it.

00:36:50.460 --> 00:36:55.280
It's definitely not going to be just a throw an async and a wait keyword here and there and

00:36:55.280 --> 00:36:56.060
just go with it, right?

00:36:56.060 --> 00:36:56.960
Indeed.

00:36:56.960 --> 00:36:58.020
I think it is.

00:36:58.020 --> 00:36:59.440
It does look to be worth it.

00:36:59.440 --> 00:37:05.240
If you, there's some articles by Magic Stack and the way they talk of the performance they

00:37:05.240 --> 00:37:06.900
can get through the async stuff.

00:37:06.900 --> 00:37:08.480
It looks really, really good.

00:37:08.480 --> 00:37:09.400
Really very fast.

00:37:09.400 --> 00:37:09.680
Yeah.

00:37:09.680 --> 00:37:13.280
I think it's really quite powerful, but it also probably depends, right?

00:37:13.280 --> 00:37:15.560
Like you guys, I suspect have a lot of traffic.

00:37:15.560 --> 00:37:24.060
If you do 10 requests a second on your server or one, maybe just leave it alone, right?

00:37:24.060 --> 00:37:27.200
Pay $5 more and get a bigger server and just be done with it.

00:37:27.200 --> 00:37:32.300
There's probably some threshold where below that it's not worth rewriting it until there's

00:37:32.300 --> 00:37:33.240
enough demand.

00:37:33.240 --> 00:37:34.020
What do you think?

00:37:34.020 --> 00:37:34.800
Certainly, yeah.

00:37:34.800 --> 00:37:42.080
It's, even for us, it's not necessarily worth it to wholesale replace our services with core.

00:37:42.080 --> 00:37:47.360
I think we're only really kind of experimenting with async O systems at the moment.

00:37:47.360 --> 00:37:47.980
Cool.

00:37:48.220 --> 00:37:53.980
So let's compare this a little bit with some of the other, what I consider the Python 3 async

00:37:53.980 --> 00:37:54.960
web frameworks.

00:37:54.960 --> 00:37:57.860
So we've got Sanic.

00:37:57.860 --> 00:37:59.540
We have Jepronto.

00:37:59.540 --> 00:38:01.820
AIo HTTP.

00:38:01.820 --> 00:38:07.260
Like, how do you see your work similar or different to these?

00:38:07.260 --> 00:38:10.520
There's kind of two approaches have been taken here.

00:38:10.520 --> 00:38:16.680
And most of the Python 3 async ones I've seen have been more the micro framework style than

00:38:16.680 --> 00:38:17.800
the Django style.

00:38:17.800 --> 00:38:24.320
I think there's the ones that are Flask-like, which are Sanic and Jepronto, I think.

00:38:24.320 --> 00:38:30.440
And then there's AIo HTTP that I think for very legitimate reasons by design doesn't want

00:38:30.440 --> 00:38:31.740
to go down the Flask approach.

00:38:31.740 --> 00:38:34.300
So I think that's basically the first choice.

00:38:34.300 --> 00:38:38.600
And then I think Quart fits in because it's not Flask-like.

00:38:38.600 --> 00:38:40.280
Hopefully, it is the Flask API.

00:38:40.280 --> 00:38:44.640
So I think that sets it aside and it's kind of the motivation for it.

00:38:45.180 --> 00:38:47.460
So then I think there's kind of that scale.

00:38:47.460 --> 00:38:50.820
And then there's the what is the aim of the project in that scale.

00:38:50.820 --> 00:38:56.200
So Sanic and Jepronto, I think, are all about speed as far as I can understand what they're

00:38:56.200 --> 00:38:56.600
aiming for.

00:38:56.600 --> 00:38:59.400
They're really about trying to get performance out of it.

00:38:59.400 --> 00:39:06.240
And I think AIo HTTP is meant to be kind of like an all-encompassing HTTP library, right?

00:39:06.240 --> 00:39:08.120
So it does the client side as well as the server.

00:39:08.580 --> 00:39:12.380
So I think there's these varying kind of aims for the projects.

00:39:12.380 --> 00:39:12.740
Right.

00:39:12.740 --> 00:39:17.040
And I think it is a massive advantage to say we're not going to create something Flask-like.

00:39:17.040 --> 00:39:22.520
We're going to create Flask effectively, but async-enabled natively.

00:39:22.520 --> 00:39:27.120
And one of the main benefits there is obviously people can migrate more easily to it.

00:39:27.120 --> 00:39:30.780
You already talked about the Flask extensions, all those kinds of things, right?

00:39:30.780 --> 00:39:33.520
To me, it's mostly about not having to learn something new.

00:39:33.820 --> 00:39:35.160
So I did play with Sanic.

00:39:35.160 --> 00:39:38.140
I quite like Sanic, but I didn't want to have to learn how Sanic did things.

00:39:38.140 --> 00:39:41.820
Yeah, exactly.

00:39:41.820 --> 00:39:46.480
And if you want to go on Stack Overflow and ask, how do I do this with my web framework X?

00:39:46.480 --> 00:39:49.500
You'll have way more answers if X equals Flask.

00:39:49.500 --> 00:39:49.960
It's true.

00:39:49.960 --> 00:39:50.360
Definitely.

00:39:50.360 --> 00:39:50.800
Yeah.

00:39:50.800 --> 00:39:53.460
Just the more tutorials, more courses, et cetera, et cetera.

00:39:53.460 --> 00:39:55.780
Although I suspect there's minor differences.

00:39:55.780 --> 00:39:59.680
The majority of it is kind of still the Flask API, the Flask story, right?

00:39:59.680 --> 00:40:04.080
Certainly, there is differences in the details and obviously async.

00:40:04.080 --> 00:40:04.280
Yeah.

00:40:04.280 --> 00:40:07.500
So what are the hangups people might get trying to switch to court?

00:40:07.500 --> 00:40:14.620
Are there things they have to be on the lookout for just due to the async nature or how careful

00:40:14.620 --> 00:40:15.200
they got to be?

00:40:15.200 --> 00:40:20.980
I think one of the most annoying parts is if you have a coroutine.

00:40:21.120 --> 00:40:24.840
Say you want the example you said where you await the request.getJSON.

00:40:24.840 --> 00:40:29.880
If you forget to write the await word, then the data, let me start again.

00:40:29.880 --> 00:40:35.220
If you have data equals request.getJSON in your Flask and you change it to Quartz, that line

00:40:35.220 --> 00:40:36.320
of code will still run.

00:40:36.320 --> 00:40:41.160
It's just that data would now hold a coroutine object instead of the data you're expecting.

00:40:41.160 --> 00:40:46.840
And that could probably catch you up quite easily because until you try and use it, you

00:40:46.840 --> 00:40:48.460
don't know that it's going to be something different.

00:40:48.860 --> 00:40:52.500
What do you mean status code doesn't exist anymore on this thing?

00:40:52.500 --> 00:40:54.520
Like, why did this start failing?

00:40:54.520 --> 00:40:55.860
Why are the attributes missing, right?

00:40:55.860 --> 00:40:56.980
Of course, because you didn't await it.

00:40:56.980 --> 00:40:58.180
Yeah.

00:40:58.180 --> 00:40:58.680
Interesting.

00:40:58.680 --> 00:41:01.280
So let's talk about the deployment story.

00:41:01.280 --> 00:41:03.480
You talk a lot about using G-Unicorn.

00:41:03.480 --> 00:41:08.740
Is it, you said you can basically run both Quartz and Flask apps on top of that in more or

00:41:08.740 --> 00:41:10.820
less the same way, but just different config settings, right?

00:41:10.940 --> 00:41:11.120
Yeah.

00:41:11.120 --> 00:41:15.060
You just change the worker and that should be enough.

00:41:15.060 --> 00:41:15.360
Nice.

00:41:15.360 --> 00:41:15.520
Yeah.

00:41:15.520 --> 00:41:22.560
So you say eventlet is the one to use for Flask and Quart-UVloop for Quart.

00:41:22.560 --> 00:41:24.200
UVloop's pretty interesting.

00:41:24.200 --> 00:41:25.400
Why don't you tell people about that?

00:41:25.400 --> 00:41:29.720
My understanding, which I think is wrong, is that the kind of history goes from libEvent

00:41:29.720 --> 00:41:34.320
to libEvent, which is what eventlet and gvent, I think, are based on, to libUV.

00:41:34.320 --> 00:41:37.780
And they're all improvements on the previous iteration.

00:41:38.740 --> 00:41:46.220
And UVloop is the kind of Python bindings to change the async loop policy to use UVloop

00:41:46.220 --> 00:41:47.420
instead of the default one.

00:41:47.420 --> 00:41:52.880
And the reason you'd want to do this is because it looks like, from all the stuff that's been

00:41:52.880 --> 00:41:55.900
published, that UVloop really does make things run a lot quicker.

00:41:55.900 --> 00:42:03.400
And if I understand it correctly, it's the same kind of base event loop that Node.js uses.

00:42:03.400 --> 00:42:07.800
So it's got some proven track record of being very good.

00:42:07.800 --> 00:42:13.700
So yeah, if you switch it to the UVloop worker, you can really get some performance boosts.

00:42:13.700 --> 00:42:17.280
I get the same impression reading around that UVloop definitely speeds that up.

00:42:17.280 --> 00:42:22.940
And it's cool that it's the same one that Node.js runs on because Node.js, for all of its flaws

00:42:22.940 --> 00:42:29.380
and challenges, is definitely good at handling lots of requests based on IO completion waiting

00:42:29.380 --> 00:42:30.160
behaviors, right?

00:42:30.160 --> 00:42:30.980
Yeah, definitely.

00:42:30.980 --> 00:42:35.780
I find it kind of amusing if I've understood the history right, is that UVloop is a rewrite

00:42:35.780 --> 00:42:40.420
of EV, LibEV, LibUV is a rewrite to work on Windows.

00:42:40.420 --> 00:42:42.520
At least that was the original motivation.

00:42:42.520 --> 00:42:46.500
But as I understand it, the UVloop kind of bindings doesn't work on Windows.

00:42:46.500 --> 00:42:49.180
So I find that kind of like sad irony.

00:42:49.180 --> 00:42:51.280
That is very ironic.

00:42:51.280 --> 00:42:54.720
It's turned its back on its origin.

00:42:54.720 --> 00:42:55.440
How interesting.

00:42:56.200 --> 00:43:02.920
So have you talked with Armin Roedeker, the guy who maintains Creative Flask, about what

00:43:02.920 --> 00:43:08.100
you've done, how it maybe could be contributed back to Flask, what those guys are up to, things

00:43:08.100 --> 00:43:08.460
like that?

00:43:08.460 --> 00:43:09.200
I haven't, no.

00:43:09.200 --> 00:43:12.240
I was actually hoping, because I think you've spoke to him on this program.

00:43:12.240 --> 00:43:15.380
I was going to ask if you could introduce me, which would be excellent.

00:43:15.380 --> 00:43:16.400
Yeah, I'd be happy to.

00:43:16.400 --> 00:43:16.740
Sure.

00:43:17.900 --> 00:43:22.960
Yeah, I don't really know what's going on in official Flask around all this stuff.

00:43:22.960 --> 00:43:25.480
So it seems like you've got a really nice head start.

00:43:25.480 --> 00:43:26.080
So that's cool.

00:43:26.080 --> 00:43:29.800
I don't know what's going on officially for Flask either, but it doesn't look like they're

00:43:29.800 --> 00:43:31.820
actively pursuing AsyncIO at the moment.

00:43:31.820 --> 00:43:37.660
It looks like they're pursuing the release one of Flask, as far as I can tell, which would

00:43:37.660 --> 00:43:38.220
be great as well.

00:43:38.220 --> 00:43:38.760
Yeah, it would be great.

00:43:38.760 --> 00:43:46.900
I suspect making major changes to Flask in terms of APIs and stuff is a slow, tedious,

00:43:46.900 --> 00:43:48.000
careful process.

00:43:48.000 --> 00:43:50.420
Same thing for Django and for Pyramid.

00:43:50.420 --> 00:43:54.120
These are well-established, long-living web frameworks.

00:43:54.120 --> 00:43:57.340
Compatibility is probably a top concern.

00:43:57.340 --> 00:44:02.420
And I think you probably have to make some difficult changes to introduce AsyncIO as well.

00:44:02.420 --> 00:44:07.340
So I guess my hope would be that Quart proves that this is desired and useful.

00:44:07.880 --> 00:44:13.420
And then there's more kind of desire to actually make some Flask changes and to be able to

00:44:13.420 --> 00:44:13.980
merge the two.

00:44:13.980 --> 00:44:17.060
Yeah, then you'll push a major, major pull request over to Flask.

00:44:17.060 --> 00:44:22.280
Well, it would have to be Flask and Virgisk, I think, if it's ever going to be possible.

00:44:22.280 --> 00:44:23.320
Yeah, yeah, for sure.

00:44:23.320 --> 00:44:25.420
Yeah, very cool.

00:44:25.420 --> 00:44:25.840
All right.

00:44:25.840 --> 00:44:29.820
So where are you going in terms of the future for Quart?

00:44:29.820 --> 00:44:30.480
What's next?

00:44:30.480 --> 00:44:35.300
I said earlier, there's details about the API that don't fully match at the moment, which

00:44:35.300 --> 00:44:37.440
obviously I need to get correct.

00:44:37.720 --> 00:44:42.320
So like little details about how e-tags are used and how static files are served, that

00:44:42.320 --> 00:44:42.820
kind of thing.

00:44:42.820 --> 00:44:49.660
After that, I want to kind of like really demonstrate the robustness of the HTTP2 handling and the

00:44:49.660 --> 00:44:50.460
WebSocket handling.

00:44:50.460 --> 00:44:56.020
So luckily, there's some compliance testing projects out there, which I can use for that.

00:44:56.020 --> 00:44:59.300
And then it's also about the development process.

00:44:59.300 --> 00:45:03.260
So Flask and Virgisk have this really nice kind of debug web page that tells you what's

00:45:03.260 --> 00:45:04.700
going wrong when you try and do something.

00:45:05.120 --> 00:45:06.760
I think Quart needs something like that as well.

00:45:06.760 --> 00:45:07.540
Sounds very cool.

00:45:07.540 --> 00:45:13.840
One of the areas of performance that we spoke about was with Async and Await and sort of

00:45:13.840 --> 00:45:15.560
the asynchronous view.

00:45:15.560 --> 00:45:18.000
We also talked about HTTP2.

00:45:18.000 --> 00:45:20.400
How do you see that affecting performance?

00:45:20.400 --> 00:45:25.800
Do you see like the ability to have HTTP2 also adding like another layer of speedups?

00:45:25.800 --> 00:45:29.540
I do see that it makes things quicker when I test it.

00:45:29.540 --> 00:45:34.700
I haven't published anything yet because I haven't really figured out what a kind of safe

00:45:34.700 --> 00:45:38.860
comparison benchmark is because the cost of opening connections is quite high.

00:45:38.860 --> 00:45:40.680
Maybe you should include that.

00:45:40.680 --> 00:45:46.820
But you could effectively pipeline your maybe 20 connections down one and get a big difference.

00:45:47.300 --> 00:45:49.320
But whether that's fair or not, I'm not sure.

00:45:49.320 --> 00:45:52.920
So I don't know how to talk about it in a fair way.

00:45:52.920 --> 00:45:56.720
It's really precarious to publish benchmarks.

00:45:56.720 --> 00:45:57.480
Yeah, definitely.

00:45:57.480 --> 00:46:01.360
No matter what you do, there's always someone that's going to show you how you're wrong.

00:46:02.920 --> 00:46:09.200
And usually what that means is you're wrong because I use it this way and you're measuring

00:46:09.200 --> 00:46:10.040
it that way.

00:46:10.040 --> 00:46:15.000
And if I used it the way I use it, it wouldn't give you the same results as the way that you

00:46:15.000 --> 00:46:15.420
use it.

00:46:15.420 --> 00:46:18.740
And so your results are misleading or whatever, right?

00:46:18.740 --> 00:46:22.840
And it's just really hard to get something truly representative of what people are doing

00:46:22.840 --> 00:46:24.460
when they're doing all these different things, I think.

00:46:24.460 --> 00:46:28.600
One thing I'd really like to do if I could convince my colleagues is change one of our edge

00:46:28.600 --> 00:46:30.280
servers to be HTTP2.

00:46:30.280 --> 00:46:34.060
And then you'd be able to see quite a big difference in real use cases.

00:46:34.060 --> 00:46:35.340
So that'd be excellent.

00:46:35.340 --> 00:46:37.260
Yeah, well, let us know when it's out.

00:46:37.260 --> 00:46:39.040
I'll definitely point people at it.

00:46:39.040 --> 00:46:39.560
That'd be awesome.

00:46:39.560 --> 00:46:40.140
It would be.

00:46:40.140 --> 00:46:40.620
Yeah, yeah.

00:46:40.620 --> 00:46:40.960
Very cool.

00:46:40.960 --> 00:46:46.400
So one thing I noticed is you have your project on GitLab and a lot of people have their projects

00:46:46.400 --> 00:46:47.080
on GitHub.

00:46:47.080 --> 00:46:49.000
And you've talked about this a little bit.

00:46:49.000 --> 00:46:51.180
So why GitLab over say GitHub?

00:46:51.180 --> 00:46:57.100
Initially, it looks a bit silly because GitHub is way more popular than GitLab.

00:46:57.100 --> 00:47:02.500
And projects tend to be judged by, I think, at least superficially to begin with, by the

00:47:02.500 --> 00:47:06.240
kind of stars and forks they have, which is always going to be low on GitLab.

00:47:06.240 --> 00:47:12.380
But for me, GitLab is open source, which sways a lot of it in my mind.

00:47:12.380 --> 00:47:16.500
It certainly made a difference to the company I worked for when we were starting up, like

00:47:16.500 --> 00:47:20.440
to have such a great open source project we could just use to begin with.

00:47:20.960 --> 00:47:24.860
And the other thing I kind of like is its CI system is really nicely integrated.

00:47:24.860 --> 00:47:27.000
And that works very well for Cort at the moment.

00:47:27.000 --> 00:47:28.240
So it's very easy.

00:47:28.240 --> 00:47:31.860
So Phil, if you want to work on Cort, what editor do you open up?

00:47:31.860 --> 00:47:35.180
I use Emacs, although I think I use Emacs really badly.

00:47:35.180 --> 00:47:37.980
I don't really add any plugins.

00:47:37.980 --> 00:47:39.800
I tend to use it just in the terminal.

00:47:39.800 --> 00:47:41.020
Very vanilla.

00:47:41.020 --> 00:47:44.020
I went through a stage of having it reasonably optimized.

00:47:44.360 --> 00:47:47.100
And I just reverted it all back to plain.

00:47:47.100 --> 00:47:49.960
So yeah, I don't put too much in my editor.

00:47:49.960 --> 00:47:50.700
I probably should.

00:47:50.700 --> 00:47:53.080
But yeah, I just open Emacs and go from there.

00:47:53.080 --> 00:47:53.700
All right, cool.

00:47:53.700 --> 00:47:58.540
And in addition to Cort, which is pip install Cort, right?

00:47:58.540 --> 00:48:03.020
What other notable high-PI packages are out there that you want to recommend?

00:48:03.020 --> 00:48:05.260
I think I'll recommend two that I use in Cort.

00:48:05.260 --> 00:48:11.020
I recommend Flacate, which has certainly caught loads of silly bugs and style issues.

00:48:11.800 --> 00:48:17.240
I think mostly I use it to take away any discussion or uncertainty about the style.

00:48:17.240 --> 00:48:24.060
And my-PI for the same reason of catching the bugs and to make sure the documentation is right.

00:48:24.060 --> 00:48:25.100
Yeah, my-PI is very cool.

00:48:25.100 --> 00:48:27.360
There's a lot of activity around my-PI right now.

00:48:27.360 --> 00:48:28.180
It's really nice.

00:48:28.180 --> 00:48:28.680
For sure.

00:48:28.680 --> 00:48:31.160
All right, so final call to action.

00:48:31.160 --> 00:48:32.660
People are interested in Cort.

00:48:32.660 --> 00:48:33.980
How do they get started?

00:48:33.980 --> 00:48:36.820
Are you looking for contributors to the project?

00:48:36.820 --> 00:48:37.820
Things like that?

00:48:37.820 --> 00:48:38.940
Absolutely, yes.

00:48:38.940 --> 00:48:40.680
It would be great if people could give it a go.

00:48:40.940 --> 00:48:44.480
Open issues or pull requests, merge requests of changes.

00:48:44.480 --> 00:48:45.760
That would be absolutely excellent.

00:48:45.760 --> 00:48:47.400
And hopefully it's easy.

00:48:47.400 --> 00:48:49.940
It's just pip install Cort and give it a go.

00:48:49.940 --> 00:48:51.460
Hopefully it's as easy as Flask.

00:48:51.460 --> 00:48:54.920
It's like basically five-line quick start.

00:48:54.920 --> 00:48:55.840
Yeah, that's really cool.

00:48:55.840 --> 00:49:01.780
And you have a video that's now on YouTube from one of the PyCons, which I'll link to.

00:49:01.780 --> 00:49:03.220
That's PyCon UK, right?

00:49:03.220 --> 00:49:03.640
2017?

00:49:03.640 --> 00:49:04.740
Yep, that's the one, yeah.

00:49:04.740 --> 00:49:09.120
All right, so if people want to watch your video presentation as well, I'll be sure to link to that.

00:49:09.320 --> 00:49:11.560
So yeah, it looks like a really cool project.

00:49:11.560 --> 00:49:14.480
Thanks for creating it and coming on the show to share it with everyone.

00:49:14.480 --> 00:49:15.300
Thank you for the insight.

00:49:15.300 --> 00:49:15.860
Of course.

00:49:15.860 --> 00:49:16.540
Talk to you later.

00:49:16.540 --> 00:49:17.280
Okay, bye.

00:49:18.280 --> 00:49:21.180
This has been another episode of Talk Python to Me.

00:49:21.180 --> 00:49:26.120
Today's guest was Philip Jones, and this episode has been brought to you by SmartKits and Rollbar.

00:49:26.120 --> 00:49:32.540
SmartKits is looking for talented Python developers to build amazing Python 3-based microservices.

00:49:32.540 --> 00:49:37.100
Apply at talkpython.fm/SmartKits and level up your career.

00:49:37.100 --> 00:49:40.380
Rollbar takes the pain out of errors.

00:49:40.820 --> 00:49:48.100
They give you the context and insight you need to quickly locate and fix errors that might have gone unnoticed until your users complain, of course.

00:49:48.100 --> 00:49:55.240
As Talk Python to Me listeners, track a ridiculous number of errors for free at rollbar.com slash Talk Python to Me.

00:49:56.060 --> 00:49:58.000
Are you or a colleague trying to learn Python?

00:49:58.000 --> 00:50:02.680
Have you tried books and videos that just left you bored by covering topics point by point?

00:50:02.680 --> 00:50:11.300
Well, check out my online course, Python Jumpstart, by building 10 apps at talkpython.fm/course to experience a more engaging way to learn Python.

00:50:11.840 --> 00:50:18.620
And if you're looking for something a little more advanced, try my WritePythonic code course at talkpython.fm/pythonic.

00:50:18.620 --> 00:50:21.340
Be sure to subscribe to the show.

00:50:21.340 --> 00:50:23.540
Open your favorite podcatcher and search for Python.

00:50:23.540 --> 00:50:24.780
We should be right at the top.

00:50:24.780 --> 00:50:34.080
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

00:50:34.080 --> 00:50:35.980
This is your host, Michael Kennedy.

00:50:35.980 --> 00:50:37.340
Thanks so much for listening.

00:50:37.340 --> 00:50:38.400
I really appreciate it.

00:50:38.400 --> 00:50:40.340
Now, get out there and write some Python code.

00:50:40.340 --> 00:51:10.320
I'll see you next time.

