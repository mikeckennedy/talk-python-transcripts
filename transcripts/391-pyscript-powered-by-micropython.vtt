WEBVTT

00:00:00.001 --> 00:00:04.480
No Python announcement of 2022 was met with more fanfare than PyScript.

00:00:04.480 --> 00:00:09.860
This project, announced at PyCon, allows you to write Python files and run them in your browser

00:00:09.860 --> 00:00:15.080
in place of JavaScript or even with interactions between Python and JavaScript.

00:00:15.080 --> 00:00:20.740
There's just one catch. The runtime download was a 9 megabyte WebAssembly file.

00:00:20.740 --> 00:00:22.980
That made its use quite limited.

00:00:22.980 --> 00:00:27.340
On this episode, we dive into some news that might change that calculus.

00:00:27.340 --> 00:00:34.080
The MicroPython and PyScript folks have been teaming up to get PyScript running in the browser on MicroPython.

00:00:34.080 --> 00:00:38.120
Yes, that's the embedded chip Python that you may have heard of.

00:00:38.120 --> 00:00:39.540
And here's the good news.

00:00:39.540 --> 00:00:44.980
MicroPython's WebAssembly is just 300k to download and loads at under 100 milliseconds.

00:00:44.980 --> 00:00:47.600
Now that could unlock some real possibilities.

00:00:47.600 --> 00:00:53.200
We have Brett Cannon, Nicholas Toleve, and Fabio Plager on the show to discuss.

00:00:53.480 --> 00:00:59.280
This is Talk Python to Me, episode 391, recorded November 21st, 2022.

00:00:59.280 --> 00:01:15.680
Welcome to Talk Python to Me, a weekly podcast on Python.

00:01:15.680 --> 00:01:17.420
This is your host, Michael Kennedy.

00:01:17.820 --> 00:01:22.480
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython,

00:01:22.480 --> 00:01:24.900
both on fosstodon.org.

00:01:24.900 --> 00:01:27.520
Be careful with impersonating accounts on other instances.

00:01:27.520 --> 00:01:28.480
There are many.

00:01:28.480 --> 00:01:33.540
Keep up with the show and listen to over seven years of past episodes at talkpython.fm.

00:01:34.200 --> 00:01:37.600
We've started streaming most of our episodes live on YouTube.

00:01:37.600 --> 00:01:43.280
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming

00:01:43.280 --> 00:01:45.140
shows and be part of that episode.

00:01:45.140 --> 00:01:51.080
This episode is brought to you by the Local Maximum Podcast over at LocalMaxRadio.com

00:01:51.080 --> 00:01:53.380
and AWS Insiders Podcast.

00:01:53.380 --> 00:01:55.600
AWS is changing fast.

00:01:55.600 --> 00:02:00.460
Listen in to keep up over at talkpython.fm/AWS Insiders.

00:02:01.440 --> 00:02:07.060
Transcripts for this episode are sponsored by Assembly AI, the API platform for state-of-the-art

00:02:07.060 --> 00:02:12.380
AI models that automatically transcribe and understand audio data at a large scale.

00:02:12.380 --> 00:02:16.100
To learn more, visit talkpython.fm/assemblyai.

00:02:16.100 --> 00:02:16.480
Hey, guys.

00:02:16.480 --> 00:02:18.100
Welcome back to Talk Python to Me.

00:02:18.100 --> 00:02:18.740
Thanks, Michael.

00:02:18.740 --> 00:02:19.100
Hey.

00:02:19.100 --> 00:02:19.680
Thank you, Michael.

00:02:19.680 --> 00:02:19.900
Yeah.

00:02:19.900 --> 00:02:22.580
Fabio, Nicholas, Brett, it's really good to have you all here.

00:02:22.580 --> 00:02:27.520
And I know you are all very excited about this topic.

00:02:27.520 --> 00:02:35.500
Brett, I believe the last pre-COVID PyCon, we did a live on the Expo floor show about WebAssembly.

00:02:35.500 --> 00:02:36.040
We did.

00:02:36.040 --> 00:02:36.600
Yeah.

00:02:36.600 --> 00:02:38.600
Fabio, we recently talked about PyScript.

00:02:38.600 --> 00:02:43.820
And Nicholas, you're right in there as well, working on WebAssembly, PyDyde, PyScript stuff

00:02:43.820 --> 00:02:44.180
as well.

00:02:44.180 --> 00:02:48.660
So I know a lot of people know all of you, but maybe let's just kick it off with a quick

00:02:48.660 --> 00:02:50.720
round of introductions and background.

00:02:50.720 --> 00:02:52.540
Not too deep since we've all done it before.

00:02:52.540 --> 00:02:53.760
Brett, let's go with you first.

00:02:53.900 --> 00:02:54.300
Okay.

00:02:54.300 --> 00:02:54.760
Keep it short.

00:02:54.760 --> 00:02:58.600
I am the dev manager in charge of the Python experience in VS Code.

00:02:58.600 --> 00:03:00.680
Been a core developer for 19 years.

00:03:00.680 --> 00:03:04.100
Been on the Python steering council since Guido's retirement.

00:03:04.100 --> 00:03:05.600
And I'll stop there.

00:03:05.600 --> 00:03:06.200
Yeah.

00:03:06.200 --> 00:03:06.940
Fabio.

00:03:06.940 --> 00:03:11.740
So I'm creator of PyScript, current maintainer with Nicholas.

00:03:11.740 --> 00:03:15.080
I've been working with Franaconda for eight years now.

00:03:15.080 --> 00:03:21.840
Right now, I'm tech lead for PyScript and been doing a lot of community stuff around Python

00:03:21.840 --> 00:03:23.080
for a long time as well.

00:03:23.480 --> 00:03:23.640
Yeah.

00:03:23.640 --> 00:03:24.060
Fantastic.

00:03:24.060 --> 00:03:26.960
PyScript was the big news out of PyCon last year.

00:03:26.960 --> 00:03:31.700
That, I think, cut a lot of people by surprise and people were very excited about that, including

00:03:31.700 --> 00:03:32.080
myself.

00:03:32.080 --> 00:03:32.420
Yeah.

00:03:32.420 --> 00:03:33.340
I'm very excited.

00:03:33.340 --> 00:03:36.480
And yeah, got a lot of attention for good and bad.

00:03:36.480 --> 00:03:36.800
Right?

00:03:36.800 --> 00:03:37.800
Yeah.

00:03:37.800 --> 00:03:38.120
Yeah.

00:03:38.120 --> 00:03:38.220
Yeah.

00:03:38.220 --> 00:03:40.940
I was going to get some more attention today.

00:03:40.940 --> 00:03:42.180
Yeah.

00:03:42.180 --> 00:03:42.700
Hopefully.

00:03:42.700 --> 00:03:44.140
Indeed.

00:03:44.140 --> 00:03:45.140
Nicholas.

00:03:45.140 --> 00:03:45.660
Welcome.

00:03:45.660 --> 00:03:46.160
Hi.

00:03:46.160 --> 00:03:47.160
So, yep.

00:03:47.160 --> 00:03:49.020
I'm a colleague of Fabio's.

00:03:49.020 --> 00:03:50.960
I'm a principal engineer on the PyScript team.

00:03:51.240 --> 00:03:56.520
Prior to joining Anaconda in the summer, I'd been a Pythonista for far too many years and

00:03:56.520 --> 00:03:57.460
I care to remember.

00:03:57.460 --> 00:03:59.460
Before that, I was a teacher.

00:03:59.460 --> 00:04:03.000
And before that, I was a classically trained musician.

00:04:03.000 --> 00:04:09.980
And that probably explains my interest in Python in education and the activities that I still

00:04:09.980 --> 00:04:11.360
do in that sphere.

00:04:11.360 --> 00:04:12.200
So that's me.

00:04:12.200 --> 00:04:12.820
That's fantastic.

00:04:12.820 --> 00:04:14.800
You were involved with the BBC Microbit, right?

00:04:15.620 --> 00:04:15.980
Yes.

00:04:15.980 --> 00:04:18.600
I was involved with the BBC Microbit.

00:04:18.600 --> 00:04:19.780
It's fun.

00:04:19.780 --> 00:04:20.080
Yeah.

00:04:20.080 --> 00:04:20.580
Absolutely.

00:04:20.580 --> 00:04:21.200
Yeah.

00:04:21.200 --> 00:04:21.800
That's awesome.

00:04:21.800 --> 00:04:22.960
And we talked about that before.

00:04:22.960 --> 00:04:23.320
Okay.

00:04:23.320 --> 00:04:23.640
Yeah.

00:04:23.640 --> 00:04:27.720
Well, let's talk about running Python in the browser.

00:04:27.720 --> 00:04:32.460
There have been some attempts before and those attempts are still, you know, used in different

00:04:32.460 --> 00:04:32.720
places.

00:04:32.720 --> 00:04:36.640
I'm thinking of like Brython and Sculpt and those types of things.

00:04:37.160 --> 00:04:42.900
Anyone who has seen the birth and death of JavaScript, that famous 15-minute talk, which

00:04:42.900 --> 00:04:48.740
has got to be one of the most hilarious and yet insightful, like educational foundations

00:04:48.740 --> 00:04:55.120
of the web and JavaScript and, you know, what became WebAssembly talks of all time is really

00:04:55.120 --> 00:04:55.420
great.

00:04:55.420 --> 00:04:57.720
And I think those kind of land in that realm.

00:04:57.720 --> 00:05:02.480
But since then, as we started, like, you know, WebAssembly has allowed us to bring

00:05:02.480 --> 00:05:08.940
real runtimes, mostly things based on C or REST, but older things based on C, into the browser

00:05:08.940 --> 00:05:09.880
and run there.

00:05:09.880 --> 00:05:15.660
So who wants to sort of introduce this whole idea of WebAssembly quickly for those who don't

00:05:15.660 --> 00:05:18.740
necessarily know and sort of set the stage so people see where we're coming from?

00:05:18.740 --> 00:05:19.060
All right.

00:05:19.060 --> 00:05:19.600
I'll take it.

00:05:19.600 --> 00:05:24.360
So you can kind of think of WebAssembly as almost portable CPU.

00:05:24.860 --> 00:05:30.460
It's technically an instruction set that basically is almost like assembly designed to just run

00:05:30.460 --> 00:05:30.940
anywhere.

00:05:30.940 --> 00:05:32.300
It's all abstracted.

00:05:32.300 --> 00:05:37.740
It's technically stack-based, much like CPython's interpreter, for those of you who want to know

00:05:37.740 --> 00:05:40.340
insider baseball knowledge or insider football.

00:05:40.340 --> 00:05:42.440
But that's basically it.

00:05:42.440 --> 00:05:48.460
WebAssembly is really just portable target to compile stuff for that more or less you make

00:05:48.460 --> 00:05:52.120
a runtime work for that target and it gets to run everywhere.

00:05:52.420 --> 00:05:57.820
There's more details we can get into in terms of WASM versus WASE and platform-specific

00:05:57.820 --> 00:05:58.160
stuff.

00:05:58.160 --> 00:06:03.420
But at the core base low-level thing underpinning all of our discussion today is WebAssembly,

00:06:03.420 --> 00:06:05.460
which is basically just a portable CPU target.

00:06:05.460 --> 00:06:05.740
Yeah.

00:06:05.740 --> 00:06:06.160
Okay.

00:06:06.160 --> 00:06:06.620
Excellent.

00:06:06.620 --> 00:06:11.980
And CPython, I guess as the name would very strongly indicate, although people might not

00:06:11.980 --> 00:06:14.700
know, is largely C at its core.

00:06:14.700 --> 00:06:16.440
It's not Python code.

00:06:16.440 --> 00:06:21.180
Some of the standard library is, but not, you know, at the heart, there's an insane

00:06:21.180 --> 00:06:24.440
switch statement while loop that is written in C.

00:06:24.440 --> 00:06:29.960
And so that, if we can get that into WebAssembly, then we can get Python, the runtime, into the

00:06:29.960 --> 00:06:30.200
browser.

00:06:30.200 --> 00:06:30.700
Correct.

00:06:30.700 --> 00:06:36.000
Technically, as long as you can compile whatever language you want to WebAssembly, that's how

00:06:36.000 --> 00:06:36.520
we get it in.

00:06:36.680 --> 00:06:42.800
And traditionally, the tool chains that have supported compiling data WebAssembly, either

00:06:42.800 --> 00:06:49.620
statically compiled languages that use something like Clang as a build tool chain, or which

00:06:49.620 --> 00:06:55.280
typically has fallen under C and C++, Rust, because once again, Rust is based off of Clang

00:06:55.280 --> 00:06:56.120
for their compiler.

00:06:56.440 --> 00:07:00.640
As long as your language could use a tool chain that already had the support to compile

00:07:00.640 --> 00:07:06.260
down to WebAssembly as a CPU architecture or target, you were able to get some WebAssembly.

00:07:06.260 --> 00:07:10.380
So in CPython's case, because it's implemented, the key parts are in C.

00:07:10.380 --> 00:07:14.300
That was able to be compiled down such that I can run some WebAssembly.

00:07:14.300 --> 00:07:16.520
Nicholas's work with MicroPython the same.

00:07:16.520 --> 00:07:19.300
MicroPython's written mostly, I believe, in C as well.

00:07:19.980 --> 00:07:25.740
And so basically, that allowed both projects to basically just use a specific compiler with

00:07:25.740 --> 00:07:31.920
specific flags to just say, instead of writing out X64 assembly for my EMB or Intel chip or

00:07:31.920 --> 00:07:36.300
your ARM chip on your Mac, write me out some WebAssembly instead.

00:07:36.300 --> 00:07:41.040
People's first impression when they hear this is like, oh my gosh, binary code executing the

00:07:41.040 --> 00:07:43.180
browser, run for your life, right?

00:07:43.180 --> 00:07:44.920
But it's really no different than JavaScript.

00:07:44.920 --> 00:07:48.880
It has the same permissions and liabilities and benefits of JavaScript.

00:07:49.100 --> 00:07:50.420
It's just a different execution model.

00:07:50.420 --> 00:07:50.660
Yeah.

00:07:50.660 --> 00:07:51.940
The same sound bolts as I was.

00:07:51.940 --> 00:07:53.240
That's the core.

00:07:53.240 --> 00:07:57.780
There are a lot of nuances that comes with how it is.

00:07:57.780 --> 00:07:59.440
It's taught, right?

00:07:59.440 --> 00:08:04.960
One, it's still in a very young phase, despite all the usage and acceleration.

00:08:04.960 --> 00:08:06.340
Everybody's excited about it.

00:08:06.340 --> 00:08:10.480
But as Brett said, it's mainly a portable CPU.

00:08:10.480 --> 00:08:16.360
And it doesn't really come with the rest of what you would expect from an operating system,

00:08:16.360 --> 00:08:19.600
and especially file system and things like this.

00:08:19.600 --> 00:08:24.780
So there's a lot of extra work that the larger community is trying to add now to figure things

00:08:24.780 --> 00:08:25.040
out.

00:08:25.040 --> 00:08:32.180
Now, and the other small detail that I wanted to add is, yes, it's basically just like JavaScript

00:08:32.180 --> 00:08:36.020
on the browser, with the exception that some APIs are not available.

00:08:36.020 --> 00:08:39.240
For instance, access to DOM and other things like this.

00:08:39.500 --> 00:08:44.640
Yeah, I was going to say, it's worth pointing out that what Fabio is saying about, it's not

00:08:44.640 --> 00:08:45.780
like having an operating system.

00:08:45.780 --> 00:08:46.900
There are projects.

00:08:46.900 --> 00:08:48.140
You know, Brett mentioned Waze.

00:08:48.140 --> 00:08:52.100
There's also nscript as well, which gives you abstractions of a file system and so on and

00:08:52.100 --> 00:08:52.520
so forth.

00:08:52.520 --> 00:08:57.640
Such that you could, and it's always important to be aware when a developer uses the word

00:08:57.640 --> 00:09:04.940
just, but one could just compile CPython to WASM and it will just work in the browser.

00:09:04.940 --> 00:09:13.220
But of course, to get that to happen, it takes a rather a lot of work and browser-based expertise

00:09:13.220 --> 00:09:18.900
to actually get you to, for instance, the Python prompt in a REPL, as it were.

00:09:19.060 --> 00:09:19.180
Right.

00:09:19.180 --> 00:09:24.000
Which is why, you know, wouldn't it be fun if there was some sort of project that got

00:09:24.000 --> 00:09:27.620
you to Python in the browser without having to do all of that boilerplate stuff?

00:09:27.620 --> 00:09:30.280
Yeah, I wonder if we could find one of those.

00:09:30.280 --> 00:09:30.660
Yeah.

00:09:30.660 --> 00:09:36.640
One of the things we spoke about before, Brett, was so much of what comes with Python, the

00:09:36.640 --> 00:09:42.200
batteries included, the standard library, assumes a slightly larger execution environment

00:09:42.200 --> 00:09:44.780
than front-end browser code, right?

00:09:44.780 --> 00:09:46.280
Like it assumes a file system.

00:09:46.280 --> 00:09:48.820
It assumes that you can probably open a network socket.

00:09:48.820 --> 00:09:50.080
These types of things, right?

00:09:50.080 --> 00:09:54.840
And so one of the challenges here is, well, if you can compile it down, that doesn't mean

00:09:54.840 --> 00:09:59.440
it's going to be permitted to just take some code and jam it in a web page and run it, right?

00:09:59.440 --> 00:09:59.860
Yeah.

00:09:59.860 --> 00:10:02.960
I mean, taking the CPU analogy, the next step, right?

00:10:02.960 --> 00:10:08.700
Like when you compile something down to a CPU for like X64, that's great.

00:10:08.700 --> 00:10:10.580
But how are you going to read a file system?

00:10:10.580 --> 00:10:12.840
That doesn't exist to the concept of a CPU.

00:10:12.840 --> 00:10:14.780
How do you make things show up on the screen?

00:10:14.780 --> 00:10:17.160
How do you do lots of other things, right?

00:10:17.200 --> 00:10:19.320
Like that's all implemented by your operating system, right?

00:10:19.320 --> 00:10:22.360
It's the next layer above your CPU in terms of abstraction.

00:10:22.360 --> 00:10:28.700
And WebAssembly only has the start of this concept in one area, which is Wazzy.

00:10:28.700 --> 00:10:32.620
And in another area, it kind of just leans hard into the browser space.

00:10:32.620 --> 00:10:34.400
And that's kind of what we call MScripten, right?

00:10:34.400 --> 00:10:39.620
So generally the way all this plugs together is if you look at it from a browser perspective,

00:10:39.620 --> 00:10:42.800
there's a tool called MScripten, E-MScripten.

00:10:42.800 --> 00:10:48.740
And it's basically a kind of compiler front end that uses client to compile stuff to WebAssembly

00:10:48.740 --> 00:10:55.240
and then has a bunch of shims into the browser to implement stuff like file access, as Nicholas pointed out,

00:10:55.240 --> 00:10:59.020
and all these other things you can get in a rich web environment.

00:10:59.020 --> 00:11:01.820
But it's provided by this project called MScripten.

00:11:01.820 --> 00:11:06.480
And it's not quite an OS, but it's not nothing either.

00:11:06.480 --> 00:11:08.420
It's this interesting kind of middle ground.

00:11:08.420 --> 00:11:10.100
And it's project specific.

00:11:10.100 --> 00:11:14.500
But then on the other side of all this, there's a project called Wazzy.

00:11:14.500 --> 00:11:20.940
And this is what when you think of WebAssembly, you start hearing people talking about this compared to containers or edge compute

00:11:20.940 --> 00:11:26.480
and all this kind of server scenarios where Wazzy acts like POSIX, right?

00:11:26.480 --> 00:11:30.400
So it's not actually an implementation of an OS almost, kind of like what MScripten does,

00:11:30.400 --> 00:11:36.800
but instead it's an actual abstraction over what you might expect an OS to provide you.

00:11:36.800 --> 00:11:40.300
So in Wazzy's case, for instance, it is an implement file access.

00:11:40.300 --> 00:11:45.000
It implements the function to call from WebAssembly that gives you the file access.

00:11:45.000 --> 00:11:47.360
So in that case, what you have is you have a runtime.

00:11:47.360 --> 00:11:52.260
And that runtime is actually what provides that level of OS that you need.

00:11:52.260 --> 00:11:57.180
So if you've ever heard of things like WasmTime or WasmEdge or Wasmr,

00:11:57.180 --> 00:12:01.520
all of these are actually Wazzy runtimes that basically load up your WebAssembly,

00:12:01.520 --> 00:12:07.800
inject into that code the functions that Wazzy specifies on how to read files

00:12:07.800 --> 00:12:11.340
or how to print to standard out or read standard in,

00:12:11.340 --> 00:12:13.900
and then allow them to run in an abstracted fashion.

00:12:14.740 --> 00:12:21.820
So it's almost half between MScripten and kind of an OS, but above WebAssembly.

00:12:21.820 --> 00:12:27.040
But as you can notice, it's a weird little split here because there's the web part and the server part,

00:12:27.040 --> 00:12:29.220
and this is where this whole discussion gets really interesting, right?

00:12:29.220 --> 00:12:32.380
Because it's now we're starting to have discussions about abstraction layers

00:12:32.380 --> 00:12:34.840
and which abstraction layers are provided where.

00:12:35.300 --> 00:12:45.960
And this is kind of where WebAssembly's youth, to put it one way, really shines through in terms of showing that it's all still very much actively being developed,

00:12:45.960 --> 00:12:51.080
which I'm sure Fabio and Nicholas have some very fun stories to tell you about with PyScript and trying to get this all working today.

00:12:51.820 --> 00:12:55.320
But this is where this whole OS concept kind of ties in, right?

00:12:55.320 --> 00:12:56.680
Where Wazzy's POSIX, right?

00:12:56.680 --> 00:12:59.140
Just kind of abstractions that someone has to provide.

00:12:59.140 --> 00:13:03.820
And then you have tools like Inscripten that try to kind of, specifically in the browser,

00:13:03.820 --> 00:13:09.840
just go ahead and just lean hard in the browser specs that the W3C has given us and the browsers hopefully implement,

00:13:10.100 --> 00:13:14.000
and just use those to implement those things that you would expect from an OS.

00:13:14.000 --> 00:13:20.780
So it is, as you said, an interesting problem where from CPython's perspective and most Python implementations, right?

00:13:20.780 --> 00:13:22.760
Historically, we've had a full operating system.

00:13:22.760 --> 00:13:25.920
MicroPython's going to be the exception, which Nicholas, I'm sure we'll talk about.

00:13:25.920 --> 00:13:32.740
But from a CPython perspective, PyPy, whatever, we're used to running on Windows, Linux, Mac, right?

00:13:32.740 --> 00:13:34.460
Like full operating systems.

00:13:34.460 --> 00:13:36.820
Like it jammed down into a tiny Raspberry Pi.

00:13:36.820 --> 00:13:38.660
That doesn't happen anymore because you can't buy them.

00:13:38.660 --> 00:13:39.680
They're unobtainable.

00:13:39.680 --> 00:13:44.920
But yeah, but I mean, the key point is like a full OS, right?

00:13:44.920 --> 00:13:48.020
Where we didn't have to concern ourselves about what was or was not available.

00:13:48.020 --> 00:13:49.640
But in a WebAssembly case, right?

00:13:49.640 --> 00:13:53.700
Like in the browser, if you use Inscripten, you only have available what Inscripten gives you.

00:13:53.700 --> 00:13:59.840
In the Wazzy case, you only have what's been standardized by Wazzy and that the runtime you choose to use has actually implemented.

00:13:59.840 --> 00:14:05.600
So we're in this interesting new kind of world where what you might expect from the standard library, for instance, in Python,

00:14:05.600 --> 00:14:09.080
that's always been there, like threads aren't necessarily there.

00:14:09.220 --> 00:14:17.280
So it actually goes back to an interesting perspective of what's Python the language versus the runtime of Python that you're using and what is provided by that.

00:14:17.280 --> 00:14:23.300
We're kind of going back in time in a way of kind of this clear separation of language versus implementation.

00:14:23.560 --> 00:14:29.160
And kind of what does that mean to us as a community and what's possible in this new space that is WebAssembly.

00:14:31.980 --> 00:14:36.180
This portion of Talk Python To Me is brought to you by the AWS Insiders podcast.

00:14:36.180 --> 00:14:44.320
When was the last time you ordered a physical server to host your functions as a service, your latest API, or your most recent web app?

00:14:44.320 --> 00:14:45.980
I remember the last time I did.

00:14:45.980 --> 00:14:48.000
That was around the year 2001.

00:14:48.000 --> 00:14:50.160
And yes, it was quite the odyssey.

00:14:50.160 --> 00:14:52.360
Of course, we don't do that anymore.

00:14:52.540 --> 00:14:57.800
We run our code in the cloud with near instant provisioning and unparalleled data centers.

00:14:57.800 --> 00:15:01.440
And the most popular cloud provider is AWS.

00:15:01.440 --> 00:15:08.720
But for all the ways that AWS has made our lives easier, it has also opened a massive box of choices.

00:15:08.720 --> 00:15:10.600
Should you choose platform as a service?

00:15:10.600 --> 00:15:12.660
Or maybe it's still VMs with IaaS.

00:15:12.660 --> 00:15:13.900
What about your database?

00:15:13.900 --> 00:15:17.540
Maybe you should choose a managed service like RDS with Postgres.

00:15:17.540 --> 00:15:19.640
Or is DynamoDB better?

00:15:19.640 --> 00:15:20.440
Maybe Aurora?

00:15:20.440 --> 00:15:21.240
No, wait.

00:15:21.240 --> 00:15:23.980
I hear good things about Amazon DocumentDB too.

00:15:23.980 --> 00:15:27.260
And that's where the AWS Insider podcast comes in.

00:15:27.260 --> 00:15:32.520
This podcast helps technology leaders stay ahead of Amazon's constant pace of change and innovation.

00:15:32.520 --> 00:15:37.220
Some relevant recent episodes include Storage Wars Database Edition.

00:15:38.060 --> 00:15:40.280
Macro Services or Macro Disaster.

00:15:40.280 --> 00:15:44.400
And exploring computer vision at the edge with AWS Panorama.

00:15:44.400 --> 00:15:49.300
They bring on guests to debate the options and the episodes are vibrant and fun.

00:15:49.300 --> 00:15:56.560
So if you want to have fun and make sense of AWS, head on over to talkpython.fm/AWS Insiders.

00:15:56.560 --> 00:16:01.160
Yes, I know you probably already have a podcast player and you can just search for it there.

00:16:01.160 --> 00:16:04.740
But please use the link so that they know you came from us.

00:16:04.740 --> 00:16:09.620
Thank you to the AWS Insider podcast for keeping this podcast going strong.

00:16:09.620 --> 00:16:15.400
It's very exciting and very fresh.

00:16:15.400 --> 00:16:18.020
Meaning that in a good and bad way, right?

00:16:18.340 --> 00:16:22.000
It reminds me a little bit of what happened with Node.js, right?

00:16:22.000 --> 00:16:27.760
People are like, look, we're writing all this advanced code and the browsers are getting really fast at running JavaScript.

00:16:27.760 --> 00:16:29.940
Like, no, no, they're not.

00:16:29.940 --> 00:16:31.100
Similar to Apple Silicon.

00:16:31.100 --> 00:16:33.960
You're like, yeah, you can't take a phone and make that your fastest computer.

00:16:33.960 --> 00:16:34.700
No, no.

00:16:34.700 --> 00:16:35.580
And then somebody does.

00:16:35.580 --> 00:16:36.180
You're like, wait a minute.

00:16:36.180 --> 00:16:37.080
Look at this thing go.

00:16:37.420 --> 00:16:41.420
Wow, you could have a server-side JavaScript, which I don't necessarily want to go touch.

00:16:41.420 --> 00:16:47.580
But it's a similar transition that we could have Python in multiple places, right?

00:16:47.580 --> 00:16:51.780
And it theoretically could run the WebAssembly version on the server as well for parity.

00:16:51.780 --> 00:16:53.360
Or I don't know if that makes any sense.

00:16:53.360 --> 00:16:56.740
But it's a similar transition in ways.

00:16:56.740 --> 00:16:58.900
Maybe in the reverse direction than JavaScript.

00:16:59.260 --> 00:17:01.260
Yeah, it actually has.

00:17:01.260 --> 00:17:04.900
It's hard to predict as you are living through things, right?

00:17:04.900 --> 00:17:21.800
But thinking about how Python became popular as most popular language without actually having a solid story for the most popular hardware today, which is tablets or mobile, like basically mobile phones and stuff.

00:17:21.960 --> 00:17:30.380
And also not having a great story for the most popular virtualization software, which is the browser.

00:17:30.380 --> 00:17:34.960
You know, imagining how Python will change with the WASM stories.

00:17:34.960 --> 00:17:40.720
I find it very interesting because it basically introduces a series of concepts that we are not used to.

00:17:40.720 --> 00:17:44.200
It's not just like run your environment there.

00:17:44.200 --> 00:17:47.980
There's a whole packaging part of the process that we need to think about.

00:17:47.980 --> 00:17:49.760
And how do we distribute that code?

00:17:49.760 --> 00:18:06.180
And that opens up for things that we haven't been used to around optimizing space and building effective bundles of your environment where we can tree shake stuff and all of those funny things.

00:18:06.180 --> 00:18:16.540
So I think for Python, it can be a very revolutionary moment where in five years from now, we're looking at a different ecosystem, hopefully bigger and better.

00:18:17.060 --> 00:18:25.880
It did something on us to sort of adapt and change and make the most of the opportunities to the WASM presenters.

00:18:25.880 --> 00:18:35.060
But as Brett and Fabio have said, it's a strange world in that it's not like I've got a libc and I know I'm going to be able to get to the file system and things like that.

00:18:35.060 --> 00:18:45.120
There are these kind of shims and slightly different abstractions that may make Python feel like it's, I was going to say, a duck out of water.

00:18:45.120 --> 00:18:46.180
Snake out of water?

00:18:46.180 --> 00:18:46.700
I don't know.

00:18:46.700 --> 00:18:47.340
You know what I mean?

00:18:47.340 --> 00:18:48.620
It's not in its natural habitat.

00:18:48.620 --> 00:18:49.440
Water moccasin.

00:18:49.960 --> 00:19:01.260
But I think I'm pretty confident and bullish about the Python community and our ability collectively to find a way forward with this.

00:19:01.260 --> 00:19:03.040
You know, we've got a beautiful language.

00:19:03.040 --> 00:19:04.200
Let's bring it to WASM.

00:19:04.200 --> 00:19:04.680
We do.

00:19:04.680 --> 00:19:06.620
And many people love it.

00:19:07.040 --> 00:19:11.220
And, you know, when people say, I love Python, they might mean the language.

00:19:11.220 --> 00:19:13.400
But usually I think that's only a part of it.

00:19:13.400 --> 00:19:13.600
Right.

00:19:13.600 --> 00:19:16.300
Often that's the ecosystem and this whole broad.

00:19:16.300 --> 00:19:16.760
Right.

00:19:16.760 --> 00:19:18.800
All the packages and all the people on the projects.

00:19:18.800 --> 00:19:23.980
And in that sense, like Python is very much empowered to make some really cool transitions there.

00:19:23.980 --> 00:19:26.980
We don't have to always kick it back to the core devs for all the work.

00:19:26.980 --> 00:19:30.200
Although, Brett, congratulations, I guess, on 3.11.

00:19:30.200 --> 00:19:30.860
Right.

00:19:30.860 --> 00:19:32.580
I mean, you guys, that's a big deal.

00:19:32.580 --> 00:19:36.100
I only, I did a small amount, but I thank you.

00:19:36.100 --> 00:19:38.080
It seems to have been taken very well.

00:19:38.080 --> 00:19:43.200
The community seems to have picked it up faster than usual, which has been really fantastic.

00:19:43.200 --> 00:19:48.320
Dependencies seem to have been ready for this and got wheels out early, which was great.

00:19:48.320 --> 00:19:49.920
Because it made transitioning a lot easier.

00:19:49.920 --> 00:19:54.960
So kudos and thanks to the community for putting in that effort to get stuff ready to go as of October.

00:19:54.960 --> 00:20:02.220
So that when things launched and we were able to do that .0 release, people were able to just install it, download packages, and have the wheels ready to go.

00:20:02.220 --> 00:20:03.440
And it went pretty smoothly.

00:20:03.440 --> 00:20:04.540
Yeah, that's awesome.

00:20:04.540 --> 00:20:07.500
Either of you, other guys, have any contributions to 3.11?

00:20:07.500 --> 00:20:08.420
Yeah.

00:20:08.420 --> 00:20:10.080
No, we are happy consumers.

00:20:10.080 --> 00:20:10.560
Yes.

00:20:10.560 --> 00:20:11.660
Exactly.

00:20:11.660 --> 00:20:12.340
Exactly.

00:20:12.340 --> 00:20:13.440
All right.

00:20:13.440 --> 00:20:18.140
One other concept, which I really want to quickly throw out there and just get your thoughts on.

00:20:18.140 --> 00:20:19.340
Don't want to go deep on this.

00:20:19.340 --> 00:20:27.100
But one of the things that seems to me like an interesting benefit for WebAssembly is the interoperability with other languages.

00:20:27.100 --> 00:20:28.660
Like WebAssembly can call WebAssembly.

00:20:28.660 --> 00:20:40.160
So if somebody could compile their Rust or their C# or their, you name it, over to WebAssembly, you might be able to consume libraries in a broader way than you can now in Python.

00:20:40.160 --> 00:20:41.220
What do you think about this?

00:20:41.220 --> 00:20:42.460
Yes, or is this just Dreamit?

00:20:42.460 --> 00:20:43.700
I think the answer is you could.

00:20:43.700 --> 00:20:51.500
But I also refer the honoured gentleman to my esteemed colleague, Brett, to the earlier answer about this being relatively immature space as well.

00:20:51.500 --> 00:20:55.600
I mean, to be honest with you, I used to be a .NET developer before I came to Python.

00:20:55.600 --> 00:21:06.520
And the fact that .NET has this notion of the CLR, the common language runtime, to which C#, C++, Visual Basic, F Sharp, I and Python, I don't know, whatever compiles to.

00:21:06.520 --> 00:21:11.340
It feels like it's a very similar space as you're implying, Michael, as to what.

00:21:11.580 --> 00:21:20.180
Yeah, though the Blazor actually is like incredibly near with what they're doing, which is I haven't done anything with it, but it looks quite impressive.

00:21:20.180 --> 00:21:22.480
There's a piece of tech we can quickly touch here.

00:21:22.480 --> 00:21:28.400
Is there something, and I think it's actually on the page you're looking at right now if you're watching the live stream, it's right below the fold.

00:21:28.400 --> 00:21:30.240
The important note, Wazzy is in transition.

00:21:30.240 --> 00:21:43.820
The transition part is there is work towards something called the component model, specifically in Wazzy, which is defined more or less what you're talking about, Michael, which honestly feels like Korba for the new millennia.

00:21:43.820 --> 00:21:49.480
To date myself, or at least date my PhD supervisor who did his PhD relating to Korba.

00:21:49.480 --> 00:21:50.420
You said Korba, right?

00:21:50.420 --> 00:21:52.780
I've not thought about that since like the year 2000.

00:21:52.780 --> 00:22:05.940
But the thing here is the component model is a spec being worked on that's meant to be able for you to specify at the WebAssembly level kind of the API that your WebAssembly code exports, right?

00:22:05.940 --> 00:22:09.600
I mean, for the Python audience, you can think of it as almost the CPython API, right?

00:22:09.600 --> 00:22:14.220
It's kind of like what does CPython export out, and then what can you use from your extension modules?

00:22:14.220 --> 00:22:16.940
It's a similar thing, except it's done at the WebAssembly level.

00:22:16.940 --> 00:22:20.980
So you can just say like, okay, this function will return a string.

00:22:21.240 --> 00:22:24.080
And then there's a definition of what a string is for WebAssembly.

00:22:24.080 --> 00:22:31.340
So that when you say, oh, internally, I might use UTF-16, but a string in the WebAssembly component model context is UTF-8.

00:22:31.340 --> 00:22:33.020
So you have to encode out to UTF-8.

00:22:33.020 --> 00:22:35.220
And the other side, you go, oh, hey, I'm going to call this function.

00:22:35.220 --> 00:22:36.300
Oh, it gives me a string.

00:22:36.300 --> 00:22:37.640
I know that's going to come as UTF-8.

00:22:37.640 --> 00:22:39.120
If you can keep using it that way, great.

00:22:39.120 --> 00:22:41.740
If you have to change it to UTF-32 or something, you can.

00:22:41.740 --> 00:22:48.420
But it's defining the seam of your WebAssembly module and what it looks like in terms of what it exposes to other people.

00:22:49.140 --> 00:22:55.760
So that's that big dream you mentioned of people writing stuff in other languages that we can just consume directly from WebAssembly.

00:22:55.760 --> 00:23:04.680
But there's obviously, as Nicholas pointed out, immature stuff in this community where we have to figure out how do we even expose that from the Python side, right?

00:23:04.680 --> 00:23:10.400
Like, I don't even know technologically what we would do to make that work in terms of pulling another WebAssembly module.

00:23:10.400 --> 00:23:12.600
Because honestly, it's basically like linking.

00:23:12.600 --> 00:23:14.900
But we don't have that concept of linking in Python.

00:23:14.900 --> 00:23:16.080
You just run an import statement.

00:23:16.080 --> 00:23:18.880
There's no header, no definition of what's on the other side.

00:23:18.880 --> 00:23:19.920
Exactly, right?

00:23:19.920 --> 00:23:21.960
And that's exactly what the component model does, right?

00:23:21.960 --> 00:23:23.200
It's an interesting position.

00:23:23.200 --> 00:23:29.400
Actually, credit to Peter Wang, who you can save the love slash hate toots to later on this analogy.

00:23:29.400 --> 00:23:34.340
But up to this point, right, a lot of the WebAssembly world has been these languages that are compiled, right?

00:23:34.340 --> 00:23:39.840
Like the C and C++ and the Rust stuff, like where you just pull in all your code, you compile it, and it all just kind of works.

00:23:39.900 --> 00:23:44.060
And it's very much set up in these worlds where, oh, yeah, it's statically compiled, whatever.

00:23:44.060 --> 00:23:45.940
As you said, header files, it kind of comes together.

00:23:45.940 --> 00:23:58.860
But we come from this world where people have poured all this time and energy to wrap all of this esoteric C, C++, Fortran even code, and give us this nice API in Python.

00:23:58.860 --> 00:24:07.940
But once again, Python doesn't operate like C and C++ and Rust and all these other statically compiled languages where we have these concept of these interfaces, and they just load it, plug it right in.

00:24:07.940 --> 00:24:13.440
And it just works like, no, we're going to import some Python code, and it's going to execute as part of import, right?

00:24:13.440 --> 00:24:19.240
Like, I don't know how many people know that, but literally the way import works is it calls exec on your code, right?

00:24:19.240 --> 00:24:27.960
Extension modules use some really crazy chips from glibc to pull in that data off that module, which we don't have in WebAssembly and stuff.

00:24:27.960 --> 00:24:30.880
So there's a potential disconnect here at the moment.

00:24:30.880 --> 00:24:37.660
And hopefully, as Fabio said, in five years' time, we can kind of work together to kind of work with the WebAssembly community to make this solve the problem.

00:24:37.660 --> 00:24:42.540
But as of right now, that component model is not designed for us, the Python community.

00:24:42.540 --> 00:24:44.920
It's designed more for the C, C++, Rust world.

00:24:44.920 --> 00:24:48.460
And we're probably going to have to work with them to try to figure out how to make that work with us.

00:24:48.520 --> 00:24:56.940
Because to be frank, we're bleeding edge in terms of a dynamic programming language with an interpreter as we are coming into this and not being a compiled language.

00:24:56.940 --> 00:25:00.860
And I think we're going to be, I don't want to say bringing the WebAssembly world kicking and screaming.

00:25:00.860 --> 00:25:03.840
I think they're just, we haven't fully introduced ourselves yet.

00:25:03.840 --> 00:25:07.620
And I think they're going to come to get to know us, and we're going to start bringing in some new stuff.

00:25:07.760 --> 00:25:11.620
So I don't think we're quite ready for this whole magic bringing in other WebAssembly stuff.

00:25:11.620 --> 00:25:13.260
But hopefully, we can work with them to make that happen.

00:25:13.260 --> 00:25:15.620
Because as of right now, it's not in the cards.

00:25:15.620 --> 00:25:16.120
Yeah.

00:25:16.120 --> 00:25:18.020
I'd like to make a comment on this one.

00:25:18.020 --> 00:25:29.440
Because it actually is a topic of, we have the running joke inside the PyScript team where Antonio Cooney and I always argue about everything.

00:25:29.440 --> 00:25:31.280
Or argue, discuss.

00:25:31.280 --> 00:25:34.240
And this is a big topic of discussion.

00:25:34.240 --> 00:25:37.300
Because Antonio is more lower level.

00:25:37.660 --> 00:25:38.780
And very smart.

00:25:38.780 --> 00:25:41.700
And I look at things more on the higher level side.

00:25:41.700 --> 00:25:50.880
And I often tell, I really want to see Python working alongside with R or other languages for data science.

00:25:50.880 --> 00:25:57.900
Or just, I would love my kids to be using Python to drive a gaming library in JavaScript on the browser or something like this.

00:25:57.900 --> 00:26:00.520
And it's like, it's never going to work the way you want to.

00:26:00.520 --> 00:26:06.400
Because you don't know how types are going to be translated into WASM for different languages.

00:26:06.680 --> 00:26:08.000
And yada, yada, yada, yada.

00:26:08.000 --> 00:26:11.680
But one bridge that we have right now is JavaScript.

00:26:12.320 --> 00:26:21.320
And having proxy objects in JavaScript that relates to Python on the browser or Rust or things can be a possibility, too.

00:26:21.320 --> 00:26:34.420
But in general, I think what I always end up saying to Antonio is like, we're kind of in creative mode right now or experimentation mode where we can try stuff.

00:26:34.640 --> 00:26:35.960
And maybe it's not the right way.

00:26:35.960 --> 00:26:42.040
And maybe it's not the right way, but it may work 90% of the time, which gets a lot of work done for a lot of people.

00:26:42.360 --> 00:26:51.400
So in the meantime, we'll figure out the correct way and how different languages will actually talk to each other or what it means for WASM.

00:26:51.400 --> 00:26:53.380
Anyway, I think it's interesting.

00:26:53.600 --> 00:27:03.880
This is such an interesting conversation on so many levels because, you know, Brett mentioned Corbett, which is like this thing from way back when, before I was ever a software engineer.

00:27:03.920 --> 00:27:04.520
Okay.

00:27:04.520 --> 00:27:08.380
And Fabio is talking about how, you know, he has a high level view.

00:27:08.380 --> 00:27:12.980
Antonio, you know, from PyPy has a very different perspective on this.

00:27:12.980 --> 00:27:23.040
And I would say that, and also Fabio's pragmatism as well about what we need to get something to work because then we can do cool stuff with Python in the browser.

00:27:23.040 --> 00:27:30.760
And basically what I'm saying is that you need both of those attitudes, the Antonio and the Fabio and bring them together because that's when interesting things happen.

00:27:30.760 --> 00:27:35.920
And I'm not saying it's interesting watching these two have an interesting discussion in our morning standups or whatever.

00:27:35.920 --> 00:27:41.440
But what I'm talking about is that that's the intellectually stimulating thing because you have two different perspectives.

00:27:41.440 --> 00:27:50.320
And if like Fabio and Antonio are, they're excellent engineers and they can see and empathize with what the other person is talking about and adjust their position.

00:27:50.320 --> 00:27:59.080
And then eventually we kind of zone in on various potential solutions, which kind of goes back to the Corbett thing, which is why I brought it up, is that, you know,

00:27:59.380 --> 00:28:08.400
I remember meeting an old gray beard programmer when I was a young whippersnapper and he was, I can't remember, something had been announced and I was like, oh, this is amazing.

00:28:08.400 --> 00:28:10.160
It's going to change the world in that way.

00:28:10.160 --> 00:28:10.920
Young programmers.

00:28:10.920 --> 00:28:15.180
And he was like, oh yeah, we were doing this in the seventies with punch cards or something like that.

00:28:15.180 --> 00:28:27.280
And so once again, that sort of, we have this cyclical nature in the history of programming where, you know, we're, we're coming back to these kinds of archetypal solutions implemented in different ways.

00:28:27.280 --> 00:28:36.100
And you can actually see perhaps that the whole was and wassy thing as yet another iteration of this, because we're rethinking what a computing platform is.

00:28:36.100 --> 00:28:43.360
It's this virtualized thing and it's taken us maybe 20 or 30 years to get to that new space after lots of different experiments.

00:28:43.360 --> 00:28:43.600
Right.

00:28:43.600 --> 00:28:50.460
We're still going to be flapping around like headless chickens, trying to figure out how to make the damn thing work because all of this stuff keeps moving on.

00:28:50.520 --> 00:28:52.000
And that's called progress folks.

00:28:52.000 --> 00:28:54.400
But you know, this is why it's so interesting.

00:28:54.400 --> 00:29:13.060
This is why I'm a software engineer is because I get to work with clever people on interesting problems that if we get it right, a bunch of 11 year olds in the school down the road from me are going to be able to build Python applications on a little device like this using PyScript.

00:29:13.060 --> 00:29:16.520
And you know, that is something to work for.

00:29:16.520 --> 00:29:17.680
Yeah, that's fantastic.

00:29:17.680 --> 00:29:19.580
And if you don't like the tools.

00:29:19.720 --> 00:29:22.280
And just for the podcast, a little device was the phone.

00:29:22.280 --> 00:29:22.800
Yes.

00:29:22.800 --> 00:29:23.940
Sorry, Fred.

00:29:23.940 --> 00:29:30.260
By the way, we're not we're not paying Nicholas for every pitch on PyScript.

00:29:30.260 --> 00:29:32.060
It's out of his heart.

00:29:32.060 --> 00:29:34.900
He does an amazing job.

00:29:34.900 --> 00:29:38.120
Let's talk about a little bit about MicroPython.

00:29:38.120 --> 00:29:40.420
You know, MicroPython is amazing.

00:29:40.420 --> 00:29:50.680
I recently sitting around my desk stuck Velcro to one of the hosts of my desk is one of these ESP feather 32s.

00:29:50.680 --> 00:29:51.580
32 feathers.

00:29:51.580 --> 00:29:52.540
I don't know how other.

00:29:52.540 --> 00:29:53.380
Yes.

00:29:53.380 --> 00:29:54.300
Those words.

00:29:54.300 --> 00:29:55.680
Thank you.

00:29:56.160 --> 00:30:01.860
device running Python connected to my Wi-Fi, syncing a bunch of stuff on the cloud and just had a little thing.

00:30:01.860 --> 00:30:03.940
It blinks every now and then to tell me everything's cool.

00:30:03.940 --> 00:30:05.080
It's it's doing its job.

00:30:05.080 --> 00:30:06.580
And it just these are amazing.

00:30:06.580 --> 00:30:14.560
And yeah, I mean, I know circuit Python is not identical to MicroPython, but they're very near and they've been brought closer together as well, which is great.

00:30:14.560 --> 00:30:20.900
So if we download the entire CPython runtime over WebAssembly, it's not totally small, right?

00:30:20.900 --> 00:30:22.020
It's about 11 megs.

00:30:22.020 --> 00:30:22.280
Yeah.

00:30:22.280 --> 00:30:24.300
Which we have fast computers.

00:30:24.300 --> 00:30:31.820
But on the other hand, you wouldn't put it on like a public site that's there to load quick and be fast for SEO and all these things.

00:30:31.820 --> 00:30:32.060
Right.

00:30:32.060 --> 00:30:39.100
This portion of Talk Python to Me is brought to you by the Local Maximum Podcast.

00:30:39.100 --> 00:30:44.280
It's an interesting and technical podcast that dives into trends in technology, stats and more.

00:30:44.720 --> 00:30:48.700
But rather than tell you about it, let's hear from Max and Aaron about their show.

00:30:48.700 --> 00:30:52.120
We are now on with Talk Python to Me.

00:30:52.120 --> 00:30:53.880
Let's say hi to all the Python fans.

00:30:53.880 --> 00:30:54.880
Hi, Python fans.

00:30:54.880 --> 00:30:56.000
I'm Max Sklar.

00:30:56.000 --> 00:31:00.600
I have actually done a lot with Python myself, so I am a fan of Talk Python.

00:31:00.600 --> 00:31:02.100
Do you know Python, Aaron?

00:31:02.100 --> 00:31:04.860
I took a course years ago, but I am a little rusty.

00:31:04.860 --> 00:31:09.020
We are here today to talk about our podcast, The Local Maximum.

00:31:09.020 --> 00:31:12.280
We've been on a roll lately with a new episode every week,

00:31:12.340 --> 00:31:14.440
and I wanted to share with you what we've been up to.

00:31:14.440 --> 00:31:18.920
Here on The Local Maximum, we tackle subjects in software and technology,

00:31:18.920 --> 00:31:24.500
topics as diverse as the philosophy of probability to Elon Musk's next move.

00:31:24.500 --> 00:31:28.740
For Talk Python listeners, I want to highlight a couple of recent episodes of The Local Maximum.

00:31:28.740 --> 00:31:35.040
In 248, for example, I found out about an open source library that maps the world into hexagons.

00:31:35.040 --> 00:31:36.100
And some pentagons.

00:31:36.100 --> 00:31:41.600
I had a discussion with an author about games and puzzles and another on a novel approach to doing the job search well.

00:31:41.600 --> 00:31:44.560
We discussed the ramifications of AI-generated art.

00:31:44.560 --> 00:31:49.100
Have we reached peak creativity, or is this just another Local Maximum?

00:31:49.200 --> 00:31:53.100
So check out The Local Maximum podcast available on your podcast app.

00:31:55.480 --> 00:31:57.740
But you do have this project called MicroPython.

00:31:57.740 --> 00:31:58.760
Maybe tell us a bit about that.

00:31:58.760 --> 00:31:59.540
That's smaller, right?

00:31:59.540 --> 00:31:59.960
Okay.

00:31:59.960 --> 00:32:05.220
So MicroPython is the wonderful creation of Damian George.

00:32:05.220 --> 00:32:09.080
Damian is a physicist by training.

00:32:09.080 --> 00:32:14.300
He once told me what his PhD thesis title was, and it's something like 11-dimensional.

00:32:14.300 --> 00:32:15.980
And then he lost me.

00:32:15.980 --> 00:32:24.960
But he was at Cambridge, and one of his hobbies or part of his background in his studies was working with robotics.

00:32:24.960 --> 00:32:30.980
And he was part of the Australia team that entered the Robo World Cup for Americans.

00:32:30.980 --> 00:32:32.440
That's soccer, as it were.

00:32:32.440 --> 00:32:38.180
Which is rather appropriate, given the fact that the World Cup for Human Beings is happening right now.

00:32:38.180 --> 00:32:44.320
But what he wants to do is write a scripting language so that they could very quickly update what was going on in these robots.

00:32:44.320 --> 00:32:44.720
Okay.

00:32:44.720 --> 00:32:58.120
And he learned a lot by doing that and then realized, well, actually, perhaps if I take the things that I've learned building this stuff to a proper scripting language, then that'd be a cool project.

00:32:58.120 --> 00:33:02.120
And so he looked around thinking, well, what are cool scripting languages?

00:33:02.120 --> 00:33:03.420
And arrived at Python.

00:33:03.420 --> 00:33:14.100
Created an early version of MicroPython, put it on Kickstarter, thinking that he could sell a few boards, make a little bit of money, and, you know, MicroPython would be there.

00:33:14.100 --> 00:33:25.240
Well, I think $100,000 plus later, and, you know, lots and lots of forders for boards later, MicroPython was, you know, has become this amazing success.

00:33:25.240 --> 00:33:26.500
And the whole point of my...

00:33:26.500 --> 00:33:28.340
Oh, no, I caught the car moment, right?

00:33:28.340 --> 00:33:30.520
The dog that caught the car, like, here we go.

00:33:31.660 --> 00:33:31.860
Yeah.

00:33:31.860 --> 00:33:31.900
Yeah.

00:33:31.900 --> 00:33:35.080
Well, it rather surprised Damien, to say the least.

00:33:35.080 --> 00:33:40.180
But now MicroPython is designed to run in highly constrained environments.

00:33:40.180 --> 00:33:47.180
So, for instance, I believe it can work with only 16K of RAM, for instance.

00:33:47.420 --> 00:33:55.020
Clearly, when you're running it on your board, actual Python is running on the flash memory rather than the RAM, which is something different.

00:33:55.020 --> 00:33:59.640
And Damien pulls an awful lot of tricks to actually make it work really efficiently.

00:33:59.640 --> 00:34:02.860
But because he's a physicist, he knows how to do experiments.

00:34:03.400 --> 00:34:05.300
And so that's what he does, literally.

00:34:05.300 --> 00:34:24.080
He tries to work out, how can I get this big fat snake that's just eaten an elephant and squash it down into this small space so that we can still have a full re-implementation of Python 3 on something that maybe has 16K of RAM, like, I don't know, a microbit.

00:34:24.180 --> 00:34:26.460
Unsurprising, I have a box of microbits on my.

00:34:26.460 --> 00:34:26.720
Oh, yeah.

00:34:26.720 --> 00:34:27.160
Beautiful.

00:34:27.160 --> 00:34:32.640
And CircuitPython is a friendly fork of MicroPython by the wonderful folk at Adafruit.

00:34:32.640 --> 00:34:44.740
So, you know, it's, I think it creates an interesting dynamic because MicroPython is perhaps the industry version, whereas CircuitPython provides a consistent API for all the Adafruit boards.

00:34:44.740 --> 00:34:46.240
It's aimed at education.

00:34:46.240 --> 00:34:50.020
They've got a whole bunch of sort of tutorials and support for that sort of stuff.

00:34:50.060 --> 00:34:56.640
And they're forever bringing out incredible new devices, as I'm sure we've all picked up at PyCon, you know, the Circuit Playground Express.

00:34:56.640 --> 00:34:57.140
Yeah, exactly.

00:34:57.140 --> 00:34:58.360
Great conference band.

00:34:58.360 --> 00:35:00.000
So that's MicroPython in a nutshell.

00:35:00.000 --> 00:35:02.580
So what's it doing on Wazen?

00:35:02.580 --> 00:35:09.120
Well, it's because 16 megabytes is rather a lot to try and download even today over a 4G network.

00:35:09.120 --> 00:35:18.580
And these devices, subtitles here, this is a phone I'm holding up, are underpowered compared to the rather beefy MacBook sort of using to talk to you now.

00:35:18.920 --> 00:35:26.580
And so the, one of the first things I did when I joined Anaconda was just see, well, what happened if you run it on a mobile phone?

00:35:26.580 --> 00:35:32.940
And it took 16 seconds to get to Hello World, which is not an optimal kind of solution.

00:35:32.940 --> 00:35:34.620
So what would work?

00:35:34.620 --> 00:35:44.940
And very quickly, you know, I came to playing around with MicroPython and MicroPython is, you know, under 100 milliseconds to start up and get you to Hello World.

00:35:45.120 --> 00:35:45.800
It's fast enough.

00:35:45.800 --> 00:35:47.940
And you've got, so here's the interesting thing.

00:35:47.940 --> 00:35:50.040
I'm interested to hear what Brett says here.

00:35:50.040 --> 00:35:52.700
It's a full re-implementation of Python 3.

00:35:52.700 --> 00:35:54.520
However, there are differences.

00:35:54.520 --> 00:36:01.700
And so we get to Brett's rather interesting angle of, well, what is Python in the abstract and in the actual detail of implementation?

00:36:01.700 --> 00:36:06.140
And we've kind of got this platonic Python, this ideal Python that doesn't actually exist.

00:36:06.140 --> 00:36:12.760
And then you have all of these implementations of which, of course, the C, the CPython version is the, is the touchstone.

00:36:12.960 --> 00:36:15.740
But MicroPython doesn't have all the APIs.

00:36:15.740 --> 00:36:17.740
It doesn't have the full standard library.

00:36:17.740 --> 00:36:22.460
And depending on the size of the device, it might not even support floating point numbers, for instance.

00:36:22.460 --> 00:36:23.920
But it's Python.

00:36:23.920 --> 00:36:25.100
It's the Python that we love.

00:36:25.100 --> 00:36:31.100
You've still got indentation in the white space that annoys the C developers or whatever, you know, so it's good enough for me.

00:36:31.480 --> 00:36:39.500
So we can compile this much, much, much smaller, more lightweight version to WebAssembly and do similar things.

00:36:39.500 --> 00:36:47.860
But instead of downloading a whole huge thing, maybe it's a light little thing that still lets us write Python and do front end stuff in interesting ways.

00:36:47.860 --> 00:36:48.120
Yeah.

00:36:48.120 --> 00:36:48.420
All right.

00:36:48.420 --> 00:37:00.280
When I talked about speaking back in 2019, I guess it was in Cleveland, we did touch on, well, if you're not going to be able to do all the Python things, how do you define like a standard Python?

00:37:00.600 --> 00:37:06.480
There's, you know, and way back in Greek philosophy and the platonic Python, if you will.

00:37:06.480 --> 00:37:08.080
Platonic idealist language.

00:37:08.080 --> 00:37:08.860
The essence.

00:37:08.860 --> 00:37:09.260
Yeah.

00:37:09.260 --> 00:37:10.720
I mean, you're a philosopher, you know.

00:37:10.720 --> 00:37:11.180
Oh, yeah.

00:37:11.180 --> 00:37:17.080
The essence, like the core that, like, this is the little bit we circle and say, oh, Python does this.

00:37:17.080 --> 00:37:21.420
Like, what is your thought on this micro invasion of Python in the front end?

00:37:21.420 --> 00:37:24.840
Well, I have to be very clear on my bias here.

00:37:24.960 --> 00:37:44.720
I'm somewhat notorious as having written the PEP that causes all accelerator modules written in C for CPython to have to have a Python equivalent specifically so that projects like MicroPython and PyPy weren't left behind from the standard library so that they could just work and not have to re-implement the C API for key things like the date time module.

00:37:44.840 --> 00:37:47.960
So I have a massive bias in this statement, to be very clear.

00:37:47.960 --> 00:37:53.480
So I am not representing necessarily the entire Python core development team or the steering council on this.

00:37:53.760 --> 00:37:59.920
But for me, it has always been a separate concept of what the language is and what the reference implementation is, right?

00:37:59.920 --> 00:38:05.940
Like, we may do development of the language using the CPython reference implementation.

00:38:05.940 --> 00:38:12.320
And I am very specifically using the term reference implementation as a way to help make the language evolve.

00:38:12.320 --> 00:38:15.100
But for me personally, they are two separate concepts.

00:38:15.100 --> 00:38:18.100
These happen to be developed simultaneously and by the same group.

00:38:18.360 --> 00:38:22.800
And it's mainly for convenience and just be able to work faster.

00:38:22.800 --> 00:38:25.280
But I do view them as separate things.

00:38:25.280 --> 00:38:26.600
And it does make sense, right?

00:38:26.600 --> 00:38:34.700
Like, there are people on the Python core team who are way more into the esoteric bits of the language spec and how the language functions.

00:38:34.700 --> 00:38:39.400
And some people just care about the eval loop that makes CPython run, right?

00:38:39.400 --> 00:38:41.160
The big switch statement you mentioned earlier, Michael.

00:38:41.600 --> 00:38:43.960
So for me, this is totally great.

00:38:43.960 --> 00:38:55.280
Like, we have versions of the language specified in the language spec, which, to be fair, is not a spec from a, like, ECMA or ISO level standard.

00:38:55.280 --> 00:38:59.220
But hopefully good enough for people to be able to follow to implement the language.

00:38:59.220 --> 00:39:02.660
And to me, that is really what people are targeting.

00:39:02.660 --> 00:39:05.600
I honestly, once again, major bias showing here.

00:39:05.840 --> 00:39:07.840
I don't consider the Styron library part of the language.

00:39:07.840 --> 00:39:17.240
The Styron library is a very key piece of functionality and a key convenience and potential differentiator for Python in some people's eyes.

00:39:17.240 --> 00:39:19.580
But I do not consider it part of the language.

00:39:19.580 --> 00:39:25.300
It is just something that we have developed over the years that has helped accelerate Python's growth.

00:39:25.460 --> 00:39:30.160
Because back in the day, batteries had to be included because, guess what?

00:39:30.160 --> 00:39:31.180
We didn't have PyPI.

00:39:31.180 --> 00:39:37.880
Like, Vaults of Parnassus had little animated GIFs of a website where you downloaded zip files and you unzipped your stuff.

00:39:37.880 --> 00:39:40.920
Everyone vendored everything because there was no installer.

00:39:40.920 --> 00:39:42.040
There was no pip, right?

00:39:42.040 --> 00:39:44.240
Like, showing my age in the Python community, right?

00:39:44.240 --> 00:39:46.920
Like, we had to do the batteries included thing.

00:39:46.920 --> 00:39:51.180
Did you un-UU encode it off of Usenet to get your package?

00:39:52.140 --> 00:39:53.200
No, no.

00:39:53.200 --> 00:40:02.180
I was not that far back into programming that, I mean, I used Usenet, don't get me wrong, but I was not coding at the time when Usenet was the way to Netfeed.

00:40:02.180 --> 00:40:05.120
But, I mean, it was kind of just like, it's wherever it ends up.

00:40:05.120 --> 00:40:07.660
You grab it and you put it in your project and you run with it, right?

00:40:07.660 --> 00:40:10.060
There wasn't a central location for these things.

00:40:10.060 --> 00:40:12.920
And so, to me, there's a very clear separation here.

00:40:12.920 --> 00:40:18.260
And I personally view the Styron library as a thing that represents the time of when it was created.

00:40:18.260 --> 00:40:21.040
But, to me, it has never been the language.

00:40:21.040 --> 00:40:25.920
The language is what's in the language guide and more or less what's built in.

00:40:25.920 --> 00:40:28.240
And that's kind of it.

00:40:28.240 --> 00:40:33.720
The import statement brings all this wonderful stuff in for you, but that's not the import statement's part of the language.

00:40:33.720 --> 00:40:41.860
But what you can import into it, unless it's like Dunder future, right, which is baked into the language definition, I don't consider that part of the language.

00:40:41.960 --> 00:40:51.900
And I've said this controversially once on the former website that we all used to hang out on before Mastodon, where I actually said, like, the REPL, for instance, is not part of the language either, technically.

00:40:51.900 --> 00:40:54.040
If you think about it, it's a wonderful tool.

00:40:54.040 --> 00:40:56.280
And don't get me wrong, it definitely makes Python more useful.

00:40:56.480 --> 00:40:59.560
But for me, personally, the REPL is not part of the language either.

00:40:59.560 --> 00:41:05.900
It's just something we all ship because it's so useful to use and Python enables that kind of development process.

00:41:06.640 --> 00:41:16.740
But so MicroPython saying it targets Python, I believe, technically 3.4 with extras means it is an implementation of Python for Python 3.4.

00:41:16.740 --> 00:41:17.600
And that's great.

00:41:17.600 --> 00:41:23.340
And whether it comes with everything that the standard library that CPython had for 3.4 is a positive, is a plus what it has.

00:41:23.340 --> 00:41:25.240
But to me, that's not the language.

00:41:25.240 --> 00:41:27.940
And to me, they're very clearly separate concepts.

00:41:27.940 --> 00:41:31.580
It's just people get very spoiled when they just download CPython.

00:41:31.580 --> 00:41:32.940
Well, my code doesn't work over here.

00:41:32.940 --> 00:41:35.660
It's like, well, you can view CPython almost as a platform.

00:41:35.660 --> 00:41:37.920
And this platform just doesn't have the same platform.

00:41:37.920 --> 00:41:39.660
The same language, just different platform.

00:41:39.660 --> 00:41:41.120
And to me, that's fine.

00:41:41.120 --> 00:41:42.540
That just is what it is.

00:41:42.540 --> 00:41:44.600
So it sounds like you're okay with the micro invasion.

00:41:44.600 --> 00:41:45.160
Oh, yeah.

00:41:45.160 --> 00:41:46.660
I care about the language, right?

00:41:46.660 --> 00:41:49.180
If CPython is the way you get it, fantastic.

00:41:49.180 --> 00:41:51.200
If you get some other way, that's also fantastic.

00:41:51.200 --> 00:41:52.780
I personally care about the language.

00:41:52.780 --> 00:41:57.680
And I mean, we all know the community that comes with the language more than the implementation.

00:41:57.680 --> 00:41:58.240
And the fashion.

00:41:58.240 --> 00:41:59.400
Don't forget the fashion.

00:41:59.400 --> 00:42:00.240
And the fashion, yes.

00:42:00.240 --> 00:42:01.080
No, go ahead.

00:42:01.080 --> 00:42:04.120
I was going to say, before we pressed record, that was a running joke.

00:42:04.120 --> 00:42:06.720
But bring us back to the serious conversation, Nicholas.

00:42:06.720 --> 00:42:07.920
Brett Sandals.

00:42:07.920 --> 00:42:16.020
So the more serious point I was going to make is that what Brett just said is actually easy to miss, but of vital importance.

00:42:16.120 --> 00:42:28.860
Which is if you're coding with, say, for example, MicroPython, you can't expect your code to work with CPython and vice versa because of the differences in the platform, the wider platform ecosystem that you might have.

00:42:28.860 --> 00:42:32.300
Mostly the behavior is the same, although there are some very subtle differences.

00:42:33.120 --> 00:42:33.560
Yeah.

00:42:33.560 --> 00:42:43.020
It's mostly the experiments I've been doing where I've been using Pyodide as the sort of the reference and MicroPython as the sort of the thing to compare.

00:42:43.020 --> 00:42:47.980
I can just slot one in and slot the other out and PyScript sits on top of it.

00:42:48.120 --> 00:42:51.000
And I can make things work as I want to.

00:42:51.000 --> 00:42:59.680
When I'm testing Python things, there's a whole conversation, which I think I can see coming down the tube right now about how do you interact with the DOM and things like that.

00:42:59.680 --> 00:43:01.240
We'll get to that when we get to it.

00:43:01.240 --> 00:43:02.720
But it's mostly the same.

00:43:02.920 --> 00:43:05.640
But folks should know that they are different.

00:43:05.640 --> 00:43:07.640
And well, there you go.

00:43:07.640 --> 00:43:08.880
I'm just flagging that.

00:43:08.880 --> 00:43:09.880
I need to flag that.

00:43:09.880 --> 00:43:10.660
Yeah, absolutely.

00:43:10.660 --> 00:43:11.180
All right.

00:43:11.180 --> 00:43:12.740
Quick question from the audience here.

00:43:12.740 --> 00:43:16.640
Glenn says, do you think more stuff needs to be removed from CPython?

00:43:16.640 --> 00:43:24.680
I mean, I know actually that was one of the things that the 3.11 release addressed was a bunch of modules were either removed or deprecated.

00:43:24.680 --> 00:43:28.620
I think, Brett, we spoke about that a year ago or something, maybe, if I remember.

00:43:28.620 --> 00:43:29.920
Yeah.

00:43:29.920 --> 00:43:32.800
Christian and I came on maybe, yeah, almost a year ago.

00:43:33.200 --> 00:43:36.660
Not to the day, but maybe to the month or October last year.

00:43:36.660 --> 00:43:40.520
We came on here and talked about us removing modules from the standard library.

00:43:40.520 --> 00:43:41.160
Yeah.

00:43:41.160 --> 00:43:46.000
To directly talk about this, once again, personally, not speaking on behalf of any other group.

00:43:46.000 --> 00:43:52.260
I think we, I've actually put myself back up for the Python steering council.

00:43:52.260 --> 00:44:01.780
And one of the things I put in my self-nomination is I want to have a discussion about what the standard library is, which evolves around how do we want to evolve it, maintain it?

00:44:02.080 --> 00:44:04.760
What would go in there today if we were to have guidelines?

00:44:04.760 --> 00:44:07.280
Because we actually don't have guidelines on what should go in.

00:44:07.500 --> 00:44:09.960
Historically, it's just been a core dev has gone, I want this in.

00:44:09.960 --> 00:44:12.340
And people just kind of, in general consensus, go, okay.

00:44:12.340 --> 00:44:14.440
Or honestly, I'm going to add this.

00:44:14.440 --> 00:44:19.860
And they sometimes have added it because five or some odd core devs all agreed to it and just kind of goes in.

00:44:19.860 --> 00:44:21.700
And they just didn't think to have a wider discussion.

00:44:21.700 --> 00:44:23.860
Like, not going to go down details on that one.

00:44:23.980 --> 00:44:27.700
Anyway, point is, it's not had any guidance to it.

00:44:27.700 --> 00:44:30.140
And it's a discussion I want to have.

00:44:30.140 --> 00:44:37.800
And I don't know if it's going to lead to a shrinkage of the standard library just because, once again, from a CPython perspective, there's compatibility to consider.

00:44:37.800 --> 00:44:38.200
Right?

00:44:38.200 --> 00:44:39.880
And we don't want to just rip stuff out.

00:44:39.880 --> 00:44:44.540
But it is possible we might start deprecating more stuff, right, beyond what the dev batteries were.

00:44:44.600 --> 00:44:46.480
Because the dev battery list was very conservative.

00:44:46.480 --> 00:44:52.380
Basically, if almost anyone brought up any objection to something, we left it, whether we thought it was reasonable or not.

00:44:52.380 --> 00:44:59.620
So I can very much see a future where we maybe have a list of like, yeah, this stuff's here, but don't really rely on it.

00:44:59.620 --> 00:45:02.560
And obviously, MicroPython probably doesn't already ship that stuff now anyway.

00:45:02.560 --> 00:45:09.120
But yeah, personally, I would love to see the standard library a bit smaller, if for any other reason that it just makes it easier to maintain.

00:45:09.120 --> 00:45:14.340
Because there used to be, before the dev battery PEP, more modules than there are countries in the world.

00:45:14.820 --> 00:45:15.980
So like, I think, 198.

00:45:15.980 --> 00:45:18.280
So there's a lot of stuff in there.

00:45:18.280 --> 00:45:19.580
And we can probably stand to shrink it.

00:45:19.580 --> 00:45:24.340
And once again, it kind of makes it a little easier for other projects to not get pushback from people.

00:45:24.340 --> 00:45:26.180
And like, well, where is this module?

00:45:26.180 --> 00:45:27.460
It's in CPython.

00:45:27.460 --> 00:45:29.020
It's like, well, we don't have it.

00:45:29.020 --> 00:45:30.060
Well, why not?

00:45:30.060 --> 00:45:35.800
It's like, if it's not there to begin with, it makes their lives a little easier to not have to try to support it and push back to people.

00:45:35.800 --> 00:45:38.740
It's like, it just doesn't make sense for us as a platform.

00:45:38.740 --> 00:45:39.080
Right.

00:45:39.080 --> 00:45:43.600
And as we talked about before, some of these things being included came from a different time, for sure.

00:45:43.600 --> 00:45:44.820
All right.

00:45:44.820 --> 00:45:47.280
Well, I remember when I got one gopher lib.

00:45:47.280 --> 00:45:49.200
So it's also worth noting.

00:45:49.200 --> 00:45:51.680
But Archie, we're going to keep, we're sticking with Archie.

00:45:51.680 --> 00:45:52.320
Sorry, go ahead.

00:45:52.320 --> 00:45:52.920
No, no.

00:45:52.920 --> 00:45:55.580
I was saying, those batteries have a cost.

00:45:55.760 --> 00:46:02.300
And every time you have to run limited devices like MicroPython or the browser, like you realize that.

00:46:02.300 --> 00:46:10.400
And then the question becomes, well, is that user base significant to the Python project to make a change on those?

00:46:10.400 --> 00:46:10.580
Right.

00:46:10.580 --> 00:46:13.880
Like, and that comes with conversation and evolution.

00:46:13.880 --> 00:46:15.400
So I think probably.

00:46:15.520 --> 00:46:16.860
It's always a trade-off.

00:46:16.860 --> 00:46:22.640
You say, let's remove TKinter because it's a GUI from the mid-90s and nobody uses it.

00:46:22.640 --> 00:46:33.780
And then everybody points out that the Turtle module mostly uses TKinter and teachers all over the world will scream, you know, and you've got a big problem.

00:46:33.780 --> 00:46:37.160
So it's a Gordonian knot.

00:46:37.160 --> 00:46:37.740
Sure is.

00:46:38.240 --> 00:46:43.000
All right, let's bring in the third major project here, which we've touched on a few times.

00:46:43.000 --> 00:46:45.200
But Fabio, tell us about PyScript.

00:46:45.200 --> 00:46:46.400
What a cool project.

00:46:46.400 --> 00:46:46.700
Cool.

00:46:46.700 --> 00:46:47.120
Thank you.

00:46:47.120 --> 00:46:47.540
Yes.

00:46:47.540 --> 00:46:52.820
Where does it fit in this Pyodine, WebAssembly, MicroPython world?

00:46:52.820 --> 00:46:54.140
What's the angle here?

00:46:54.140 --> 00:46:57.500
I think it fits as a glue.

00:46:57.500 --> 00:47:00.540
Well, pretty much like Python was glue for a lot of things.

00:47:00.540 --> 00:47:08.220
Like the concept of PyScript was really, you know, realizing that a lot of, most of the technology for Python to run the browser is there.

00:47:08.220 --> 00:47:10.580
And it's been there for years now.

00:47:10.580 --> 00:47:29.320
And what we're missing is the easiness to just use it without being, you know, without having to spend hours or days looking for how to import things or, you know, the JavaScript side of it, what it means on the browser, as a web dev to start using Python.

00:47:29.780 --> 00:47:32.960
So the idea was really like, like, can we call it?

00:47:32.960 --> 00:47:35.340
Because it's one thing to have WebAssembly.

00:47:35.340 --> 00:47:38.100
Sorry, it's one thing to have WebAssembly see Python.

00:47:38.100 --> 00:47:42.500
It's another to build meaningful things in the browser with that as a piece.

00:47:42.500 --> 00:47:42.800
Right.

00:47:42.800 --> 00:47:48.900
And so PyScript kind of gives you a framework to write Python code in the browser based on this WebAssembly.

00:47:48.900 --> 00:47:49.280
Right.

00:47:49.280 --> 00:47:49.680
Correct.

00:47:49.900 --> 00:47:50.820
It's not a framework.

00:47:50.820 --> 00:47:51.700
It's a platform.

00:47:51.700 --> 00:48:02.580
And we fully expect people to write Pythonic frameworks on the platform that is PyScript to do whatever funky stuff they want to do in the browser, their business.

00:48:02.580 --> 00:48:09.560
And, you know, I know that I trust the Python community will come up with something that we can't even begin to imagine now.

00:48:09.760 --> 00:48:16.300
But the thing to do is remember that PyScript is that sort of platform layer rather than a framework.

00:48:16.300 --> 00:48:29.920
But in that platform, what we're looking at is perhaps pluggable runtimes and a bare minimum of APIs and heuristics and ways of working such that you can start to build your frameworks on top of this and make the funky stuff.

00:48:29.920 --> 00:48:32.280
Michael, like you said, that's useful for folks.

00:48:32.280 --> 00:48:32.820
Well, OK.

00:48:32.960 --> 00:48:37.000
Well, so we might have Pyodide, which is a more full featured version.

00:48:37.000 --> 00:48:40.820
Might we have MicroPython for a fast, speedy version?

00:48:40.820 --> 00:48:41.640
Yeah.

00:48:41.640 --> 00:48:48.120
And there are other projects as well that are coming up and or other languages, too.

00:48:48.120 --> 00:48:48.540
Right.

00:48:48.540 --> 00:48:51.420
So that's definitely in the.

00:48:51.420 --> 00:48:52.560
But that'd be interesting.

00:48:52.560 --> 00:48:53.180
Exactly.

00:48:53.180 --> 00:48:55.260
There was a big announcement that got thrown in here.

00:48:55.260 --> 00:48:56.080
We'll go this way.

00:48:56.080 --> 00:49:00.940
We'll go with Simon Wilson, who was on the previous show about Mastodon, previous episode.

00:49:01.280 --> 00:49:10.080
And he has a toot, which, by the way, I don't know, Brett, you said toot as well earlier, but they just the button on there used to say toot until like last week.

00:49:10.080 --> 00:49:11.480
They just call it publish now.

00:49:11.480 --> 00:49:13.300
I think they're downplaying the toot, but it's going to live on.

00:49:13.300 --> 00:49:18.460
The toot said huge Python WebAssembly news tucked away in this post from Anaconda here.

00:49:18.740 --> 00:49:23.860
When you apply MicroPython to WASM in its default configuration, something new and exciting emerges.

00:49:23.860 --> 00:49:32.080
With a total size of 300 kilobytes, this new runtime builds instantly and starts executing MicroPython logic in less than 100 milliseconds.

00:49:32.080 --> 00:49:38.040
That means the cost of running MicroPython on the web is now equivalent to serving up a large hero image.

00:49:38.040 --> 00:49:39.320
This is awesome, you guys.

00:49:39.320 --> 00:49:40.320
Where are we going with this?

00:49:40.540 --> 00:49:44.780
Whenever you meet Damien, you buy him a beer is pretty much what I would suggest.

00:49:44.780 --> 00:49:46.640
Although not too many.

00:49:46.640 --> 00:49:48.600
Once in sober.

00:49:51.280 --> 00:49:52.500
Yeah, this is fantastic.

00:49:52.500 --> 00:49:56.360
Because if we do have a really small runtime, then all of a sudden you could.

00:49:56.360 --> 00:50:01.400
So when people saw PyScribe and Fabio, they're like, oh my gosh, could we replace JavaScript with Python?

00:50:01.400 --> 00:50:05.160
And the answer was sometimes, but not in general, right?

00:50:05.160 --> 00:50:05.500
Yeah.

00:50:05.500 --> 00:50:06.000
Yeah.

00:50:06.000 --> 00:50:06.420
Not practically.

00:50:06.420 --> 00:50:13.860
This is Paul Everett, who's been around the Python ecosystem for a lifetime and is really great.

00:50:13.860 --> 00:50:18.660
And we were talking about that and Python for web during PyCon.

00:50:18.660 --> 00:50:28.640
And he often comes up with this distinction between the app web versus the content web, where in terms of content web, you need things to load immediately.

00:50:29.060 --> 00:50:34.060
And you're mostly wanting to show content rather than a full-blown application.

00:50:34.060 --> 00:50:40.620
And I think he still thinks Python is not going to be a reality for the content web.

00:50:40.620 --> 00:50:44.400
I think this brings it really, really, really close.

00:50:44.400 --> 00:50:55.720
And you can have basically Python running for content, but also the amount of possibilities around education, around exploration in real time and stuff like this is tremendous.

00:50:56.560 --> 00:51:07.680
And if we can actually, as a community, gather and understand how we want to build layers on top of other things, I think we can come up with really interesting solutions.

00:51:07.680 --> 00:51:09.840
And let me explain.

00:51:09.840 --> 00:51:15.200
MicroPython, for instance, doesn't have a JavaScript interface, right?

00:51:15.200 --> 00:51:29.520
So if we could have a module, maybe it's the Pyodide one that we strip out or we develop a new one where we can explore that Python to JavaScript interface and make it available for all the interpreters.

00:51:29.520 --> 00:51:32.020
And it's just like a package and you can install it.

00:51:32.020 --> 00:51:38.900
We open up a new channel or the whole packaging story for Python on the browser.

00:51:39.020 --> 00:51:58.680
And if we can figure that out in a way that, you know, we can just install packages and doesn't matter the interpreter because it all end up like being WASM, then I think we can build a very strong ecosystem where if you need more complicated things, you run with your full CPython and WASM interpreter.

00:51:58.680 --> 00:52:01.020
Otherwise, you can just use MicroPython.

00:52:01.580 --> 00:52:06.100
But I think right now is the time where we start doing those things.

00:52:06.100 --> 00:52:12.120
Coming from the Anaconda world, there's one view of like, what does Python computation mean, right?

00:52:12.120 --> 00:52:17.220
Often that means kind of notebooks and data science and like scientific computing.

00:52:17.220 --> 00:52:27.760
And there's a big desire to sort of move that to the front end and just say, let people run that on their computers and they can do kind of like notebook things on the front end.

00:52:27.980 --> 00:52:34.200
But there's a whole other side of the web that says, I want to build Gmail, but not in JavaScript on the front end.

00:52:34.200 --> 00:52:43.520
But I want that interactivity or I want maps or I want, you know, most modern highlight dynamic single page app type of web apps.

00:52:43.520 --> 00:52:45.100
But I want to write that in Python.

00:52:45.540 --> 00:53:00.240
That to me feels like that's almost the dividing point of like, well, we want the Pyodide runtime where it's rich and we can just straight grab Matplotlib and run with it or Pandas versus I'm willing to give up a lot to not write JavaScript.

00:53:00.240 --> 00:53:01.320
You know what I mean?

00:53:01.320 --> 00:53:06.440
If I've got to only use a few packages and I could still write Python end to end, that makes me super happy.

00:53:06.840 --> 00:53:10.280
As you said, like we can augment the things that Python can do.

00:53:10.280 --> 00:53:25.960
Like if we all of a sudden have access to the browser APIs for geolocation or other things, then you can write very interesting applications that is just Python or, you know, even a mobile and stuff like this because WebAssembly can run on mobile as well.

00:53:25.960 --> 00:53:37.100
So, yeah, the competition between all the arguments framing PyScript versus JavaScript, I think they really missed the point where it is augmenting both ecosystems.

00:53:37.100 --> 00:53:42.220
Like right now, we now can use D3 in Python and vice versa.

00:53:42.220 --> 00:53:45.160
JavaScript developers can use NumPy or Pandas.

00:53:45.160 --> 00:53:46.920
It's a win-win, to be honest.

00:53:46.920 --> 00:53:47.540
Yeah.

00:53:47.540 --> 00:53:54.420
One of the things I think maybe people when they hear this don't necessarily know, and I forget which is maybe the best one to look at.

00:53:54.420 --> 00:54:01.940
But not only can you run Python code in the browser with PyScript, but you can hook JavaScript events and then you can change DOM elements.

00:54:01.940 --> 00:54:05.520
This was the JavaScript DOM interaction layer you were talking about before, right?

00:54:05.520 --> 00:54:05.900
Yeah.

00:54:05.900 --> 00:54:06.480
Yes.

00:54:06.480 --> 00:54:15.280
And actually to what Nicholas was saying about the difference between that we want to really sell the point that PyScript is a platform.

00:54:16.100 --> 00:54:26.200
We're currently working on plugins where we want developers to actually write Python code to add custom elements to the DOM as well, right?

00:54:26.200 --> 00:54:27.960
And not use any JavaScript.

00:54:27.960 --> 00:54:34.620
I hope we can get it in this next release, but for sure before the end of the year, we are allowing that.

00:54:34.620 --> 00:54:43.820
And it's going to be a huge improvement in how what people can do with PyScript and actually how can people extend the platform creating new frameworks.

00:54:43.820 --> 00:54:56.340
So are you envisioning or are you at least aiming for, if not fully envisioning, something like PyView or PyReact or like some of these traditional front end frameworks, but a Python equivalent?

00:54:56.340 --> 00:54:56.980
Nicholas?

00:54:57.180 --> 00:54:58.380
That's a loaded question.

00:54:58.380 --> 00:54:59.160
I think.

00:54:59.160 --> 00:55:00.780
A Pyangular?

00:55:00.780 --> 00:55:01.620
No, just kidding.

00:55:01.620 --> 00:55:02.400
Pangular.

00:55:02.400 --> 00:55:12.460
I think that it makes a great story if you're a journalist that Python's going to come up and eat JavaScript's lunch in the browser.

00:55:12.460 --> 00:55:13.940
That's a false dichotomy.

00:55:13.940 --> 00:55:17.400
That's a great way of getting clickbait and things.

00:55:17.880 --> 00:55:30.240
If you want to write, you know, app, web-based app stuff, and you're familiar with JavaScript and React, you know, just use the tools that empower you to write the stuff that you want.

00:55:30.240 --> 00:55:34.140
But for the quartet of us in this conversation, we're all Pythonistas.

00:55:34.140 --> 00:55:39.400
We all appreciate the aesthetic of that language and the way it works.

00:55:40.120 --> 00:55:55.560
And so I would go back to the difference between a platform and a framework point from earlier on, which is it's going to be fun to trust the community, our remarkable community, and see what interesting things, what itches that they scratch.

00:55:55.560 --> 00:56:03.960
So that they create fun stuff and feedback to us, ways in which we can improve the PyScript offering, because this is a story that's going to keep going.

00:56:03.960 --> 00:56:05.620
You know, software is never finished.

00:56:06.060 --> 00:56:16.400
But I think that one thing I hope, and if I'm honest with you, this is really why I joined Anaconda, was to help think about these things.

00:56:16.400 --> 00:56:22.220
Exactly the question that you've just asked, Michael, you know, what about all of these kind of things of building apps with Python in the browser?

00:56:22.220 --> 00:56:30.880
Well, what I found is that I need to dig a bit lower to do some more cool PyScript-y things, and then dig a bit lower to look at perhaps what the runtimes are doing and blah, blah.

00:56:30.880 --> 00:56:41.220
And here I am messing around with, with MicroPython now, but hopefully I want to sort of surface, as it were, and get back to what I thought I was going to be doing, which is thinking about these sorts of things.

00:56:41.220 --> 00:56:50.220
And what I really hope to do, or what I really hope to see from the Python community as well, is engagement in frameworks that will empower people.

00:56:50.220 --> 00:57:02.660
And I'm thinking of the educational sphere as well here, because let's face it, I don't know if you've ever faced 30 teenagers on a Friday afternoon and somebody's introduced you as Nicholas, a coder who's going to teach you about Python.

00:57:03.000 --> 00:57:05.040
There's nothing more intimidating than that.

00:57:05.040 --> 00:57:09.440
And let me tell you, print hello world doesn't cut the mustard.

00:57:09.440 --> 00:57:09.920
Okay.

00:57:09.920 --> 00:57:11.840
This is not exciting for them.

00:57:11.840 --> 00:57:14.320
But if we can make something.

00:57:14.320 --> 00:57:15.580
I want to build this thing.

00:57:15.580 --> 00:57:17.760
I saw an Unreal Engine 5 in Python.

00:57:17.760 --> 00:57:18.320
Exactly.

00:57:18.320 --> 00:57:19.280
Exactly.

00:57:19.280 --> 00:57:19.940
Exactly.

00:57:19.940 --> 00:57:25.240
But if we could make it so that they can do the equivalent of, you know, the MySpace.

00:57:25.240 --> 00:57:26.480
Hi, hi, Nan.

00:57:26.480 --> 00:57:27.420
I'm on the internet.

00:57:27.420 --> 00:57:36.860
You know, within two minutes, you've got a website, you know, you've got a very quick way of getting onto a mobile phone or tablet, which let's face it, for today's teenagers, that's their primary computing device.

00:57:36.860 --> 00:57:37.300
Yeah.

00:57:37.300 --> 00:57:39.800
And I've been in classrooms where, you know, kids can't type.

00:57:39.800 --> 00:57:41.380
It's not because they don't know what a keyboard is.

00:57:41.380 --> 00:57:44.380
They use a keyboard every day, but they just use their thumbs like this with it.

00:57:44.380 --> 00:57:45.980
And when you give them an actual mechanical keyboard.

00:57:45.980 --> 00:57:47.300
We're really bad.

00:57:47.300 --> 00:57:50.720
We are dinosaurs using these keyboards now, right?

00:57:50.720 --> 00:57:51.020
Okay.

00:57:51.020 --> 00:57:55.820
We're going to evolve massive thumbs or something, but it's that sort of a situation.

00:57:55.820 --> 00:57:56.180
Okay.

00:57:56.180 --> 00:58:05.320
We've got to be aware of what these platforms are that folks are using that may be outside of our kind of age group and usage and help them both do things with Python.

00:58:05.320 --> 00:58:08.840
You're touching on a very important part of the PyScript vision.

00:58:08.840 --> 00:58:15.320
And it's really not about the current Python community user base.

00:58:15.320 --> 00:58:22.080
Like it actually is how can we democratize programming and Python and everything.

00:58:22.080 --> 00:58:27.400
And so we really want to be thinking about who's not thinking about coding at all.

00:58:27.400 --> 00:58:32.580
Like people that would love to use programming language as a tool for them to do things.

00:58:32.580 --> 00:58:39.940
And they can't either because, you know, time or because it's too complicated to get Python working or all of that.

00:58:39.940 --> 00:58:41.280
That's a pluggable.

00:58:41.280 --> 00:58:46.220
And I'm going to quote Peter again, because we are talking and welcome back, Nicholas.

00:58:46.800 --> 00:59:02.400
Peter at some point mentioned something like, you know, system design with plugins from the beginning is kind of indication of the developers not really knowing what they're doing or not really knowing what it should do, which, you know, sometimes is a negative connotation.

00:59:02.400 --> 00:59:09.880
But for PyScript is definitely intentional because we want to we want the community to be able to create their own things.

00:59:09.880 --> 00:59:12.620
And we don't it's really greenfield.

00:59:12.620 --> 00:59:14.560
So I don't know what they're going to be doing.

00:59:14.560 --> 00:59:17.860
I want to allow them to do crazy things and surprises.

00:59:17.860 --> 00:59:27.580
You know, like two months last DjangoCon, Patrick came up with this experiment of running Django on either PyScript or Pyodide.

00:59:28.000 --> 00:59:29.620
And I my first question was, why?

00:59:29.620 --> 00:59:30.580
Right.

00:59:30.580 --> 00:59:32.660
But then who cares?

00:59:32.660 --> 00:59:35.860
Like it's the web is inside the web inside the web.

00:59:35.860 --> 00:59:36.920
Exactly.

00:59:36.920 --> 00:59:38.900
Like inception all the way down.

00:59:38.900 --> 00:59:41.000
So that's the whole point.

00:59:41.000 --> 00:59:46.540
I can we want to make it funny, accessible and a hacker, a hacker space, a safe hacker space.

00:59:46.540 --> 00:59:47.740
Yeah, it's such awesome.

00:59:47.740 --> 00:59:49.800
Congratulations to you guys on this.

00:59:49.800 --> 00:59:56.920
When will we see something that we outside that don't want to grab onto an in-flight open source project,

00:59:56.920 --> 00:59:59.620
but like a release equivalent of this?

00:59:59.620 --> 01:00:03.460
Is there some time frame, some thought about when that's out?

01:00:03.460 --> 01:00:06.040
Because this is the right time to drop from the call.

01:00:06.040 --> 01:00:13.120
OK, so I can tell I can certainly tell you what the state of play is right now.

01:00:13.120 --> 01:00:16.980
And you can extrapolate when you may see sort of things like microprice.

01:00:17.240 --> 01:00:22.080
Because PyScript, proper PyScript is undergoing active development.

01:00:22.080 --> 01:00:30.280
I didn't want to try and plug in new runtimes, new interpreters, whilst the sand underneath me was shifting, as it were.

01:00:30.280 --> 01:00:37.540
So I created a very small and simple test harness version of PyScript that I've called, surprisingly enough, micro PyScript.

01:00:37.700 --> 01:00:39.120
That is going to be thrown away.

01:00:39.120 --> 01:00:44.500
Its sole purpose was to allow me to just poke these things with a stick and see what happens.

01:00:44.500 --> 01:00:51.760
And I'm still using that to, for instance, figure out how we can do MicroPython DOM connectivity and interactions as well.

01:00:51.760 --> 01:00:58.080
That's literally what I've been doing all day today is reading articles I needed to do to make that happen.

01:00:58.240 --> 01:01:00.300
So, yeah, that's going to unlock so much.

01:01:00.300 --> 01:01:03.280
Once the DOM is in play, then all of a sudden it's on.

01:01:03.280 --> 01:01:04.460
Yeah, everything else is.

01:01:04.460 --> 01:01:05.300
Yes, exactly.

01:01:05.300 --> 01:01:05.840
Exactly.

01:01:05.840 --> 01:01:21.060
Once that's in place, what I imagine will happen is Nicholas is going to be spending a lot of time with the main code base and pairing with people who know it a lot better than I currently do, because it's been maybe a couple of months since I've last looked at it.

01:01:21.060 --> 01:01:23.000
And it's changed a lot since then.

01:01:23.000 --> 01:01:25.120
And we'll integrate that work.

01:01:25.120 --> 01:01:32.120
So I expect, and this is a finger in the air, and remember, the right answer is when it's ready.

01:01:32.120 --> 01:01:35.220
But I imagine it's going to be kind of springtime.

01:01:35.220 --> 01:01:36.380
Springtime.

01:01:36.380 --> 01:01:38.120
First, third of next.

01:01:38.120 --> 01:01:39.140
Would you say maybe in April?

01:01:39.140 --> 01:01:42.640
Like April 19th, 20, 21st?

01:01:42.640 --> 01:01:46.520
I'm not going to mention any dates because you're just going to hold me to it, aren't you?

01:01:46.520 --> 01:01:48.620
I'm not going to mention any dates.

01:01:48.620 --> 01:01:49.760
I'm just teasing you.

01:01:49.760 --> 01:01:50.800
I'm not holding you to that.

01:01:50.800 --> 01:01:55.180
I hear that, you know, conference wear is very real.

01:01:55.180 --> 01:01:56.960
So we can promise for PyCon.

01:01:56.960 --> 01:01:57.780
No problem.

01:01:57.780 --> 01:02:03.860
Yeah, I hear a good place to announce new JavaScript packages is Salt Lake City in April.

01:02:03.860 --> 01:02:09.240
So Brett, I'm going to give you the final word here maybe to like put one more thought into this before we wrap up our show.

01:02:09.520 --> 01:02:15.820
Nicholas talked about, and Fabio also talked about like how do we, you know, this could be an empowering thing for other people, right?

01:02:15.820 --> 01:02:21.360
Like if for kids in education and whatnot, if you look at a lot of education is Chromebooks.

01:02:21.360 --> 01:02:23.000
You know what runs great on Chromebooks?

01:02:23.000 --> 01:02:23.600
The web.

01:02:23.600 --> 01:02:25.820
Also VS Code in the browser.

01:02:26.060 --> 01:02:35.100
Like there's, is there some thought of like interesting pure web development environments, runtime environments, like end-to-end things that could be done?

01:02:35.100 --> 01:02:38.440
We actually announced that for VS Code in our last release.

01:02:38.440 --> 01:02:45.980
If you go read our release notes, we actually have an extension that will load up into VS Code.dev, which is an actual website, not the name of a product.

01:02:45.980 --> 01:02:47.400
You literally go to VS Code.dev.

01:02:47.400 --> 01:02:48.680
It'll load up VS Code in the browser.

01:02:48.680 --> 01:02:55.840
And there's a Python extension by my teammate Dirk that uses Wazzy and the CPython build where you have a REPL.

01:02:55.840 --> 01:03:00.180
You can run code from your workspace wherever it's loaded, right?

01:03:00.180 --> 01:03:01.420
It doesn't have to be on disk.

01:03:01.420 --> 01:03:02.600
It can come from GitHub.

01:03:02.600 --> 01:03:04.980
Anywhere VS Code can read files from.

01:03:04.980 --> 01:03:08.460
It can load and be seen by Python interpreter itself.

01:03:08.460 --> 01:03:09.940
So that's all working.

01:03:09.940 --> 01:03:13.220
And just this past week, it's not out yet, to be very clear.

01:03:13.220 --> 01:03:18.660
Dirk got debugging working using Wazzy and a very cool trick that everyone can see.

01:03:18.660 --> 01:03:19.960
It's very Unix-y.

01:03:19.960 --> 01:03:21.280
I don't want to spoil it.

01:03:21.280 --> 01:03:23.720
It's going to be open source, so it's not a trade secret or anything.

01:03:23.720 --> 01:03:26.420
But it's way easier to read about it than trying to explain it on a podcast.

01:03:26.420 --> 01:03:28.600
But we got debugging working as well.

01:03:28.600 --> 01:03:38.260
So we are trying to work towards a complete development story such that, once again, for beginners, for learners, for the education market,

01:03:38.260 --> 01:03:46.980
to at least have a baseline Python experience where you can write code, read code, read files, debug.

01:03:46.980 --> 01:03:55.780
Like, what you would want to have when you're facing down that classroom of 30 kids that Nicholas has shown is very scary to at least have something you can have them all just pull up.

01:03:55.780 --> 01:04:02.640
I do want to add two other things to this, though, is actually kind of call to actions for the community around all this.

01:04:02.640 --> 01:04:08.360
One is I don't think we've all started to think about the opportunities here beyond what we've talked about, right?

01:04:08.360 --> 01:04:10.680
There's more to this than just what we have in the browser.

01:04:10.680 --> 01:04:13.740
And it's one of these rising tides lifts all shifts.

01:04:13.740 --> 01:04:18.200
So it's not that I want to take away from what Pryscript's done and all this wonderful stuff in the browser.

01:04:18.200 --> 01:04:24.620
But I think if we can get more WebAssembly stuff kind of going, it helps cause everyone to try to look into this more, which will lead to more Pryscript engagement.

01:04:24.620 --> 01:04:35.720
So I think there's some use cases we haven't really tackled yet in the community where if you just stop and look about where's things really oriented towards JavaScript as a platform and go like, oh, you know what?

01:04:35.720 --> 01:04:37.080
We might build these Python here now.

01:04:37.080 --> 01:04:42.520
For instance, you could probably, and I haven't had time to test this, but I see zero reason why this couldn't work.

01:04:42.680 --> 01:04:45.320
You could probably start writing GitHub Actions in Python now.

01:04:45.320 --> 01:04:46.080
Because guess what?

01:04:46.080 --> 01:04:46.860
It runs on Node.

01:04:46.860 --> 01:04:48.340
And Node can run WebAssembly.

01:04:48.340 --> 01:04:59.980
So we could totally take either Nicholas's MicroPython build or we could take the CPython build and totally just have as part of a GitHub Action as the first step in the JavaScript, load Python.

01:04:59.980 --> 01:05:01.780
And then suddenly just say, call this function.

01:05:01.780 --> 01:05:04.560
And suddenly all your stuff's going through Python.

01:05:04.560 --> 01:05:05.220
Because guess what?

01:05:05.220 --> 01:05:09.960
At that point, GitHub Actions is all totally driven via standard out and some special formatting in it.

01:05:09.960 --> 01:05:11.460
So you could totally just do that.

01:05:11.560 --> 01:05:13.100
And I think Nicholas wants to interject with something.

01:05:13.100 --> 01:05:13.380
Yeah.

01:05:13.380 --> 01:05:21.420
It's worth pointing out that Damien, who has done a lot of work on getting MicroPython to work with WASN, clearly he knows the code base and things like that.

01:05:21.420 --> 01:05:30.680
MicroPython, if you look very carefully at the WebAssembly port, you'll notice that there are conditionals that check whether it's running in Node or in a browser.

01:05:30.960 --> 01:05:32.280
So go knock yourself out.

01:05:32.280 --> 01:05:32.840
Try that.

01:05:32.840 --> 01:05:33.740
I've not tried it.

01:05:33.740 --> 01:05:35.540
I've clearly been busy doing other things.

01:05:35.540 --> 01:05:38.380
But folks might want to have a go at using.

01:05:38.380 --> 01:05:41.080
I mean, I feel like we should award a prize or something.

01:05:41.080 --> 01:05:45.700
You win a thumbs up or something like that if you can get a GitHub Action running MicroPython.

01:05:46.500 --> 01:05:46.940
Yeah.

01:05:46.940 --> 01:05:48.420
I mean, that's fantastic, right?

01:05:48.480 --> 01:05:55.240
Like, I think there's opportunities here we just haven't even touched yet that the community can totally just lean into that we haven't had opportunity to be able to do before.

01:05:55.600 --> 01:06:04.060
The other thing I want to lean into here that we've talked about languages versus platforms and all this, the one key thing across all of this story is Python the language.

01:06:04.060 --> 01:06:08.440
So this is going to sound a little weird, but I want to push people to write more Python code.

01:06:08.440 --> 01:06:18.880
And the reason I phrase it this way is we've historically as a community done great about this, but we will reach for that Rust code or that C code or whatever to write that little bit a little faster.

01:06:18.960 --> 01:06:25.400
But when you do that, well, right now, Fabio and Nicholas shed a tear because that makes it that much harder to make that run in PyScript, right?

01:06:25.400 --> 01:06:28.180
And same for anyone else who wants to do this WebAssembly thing, right?

01:06:28.180 --> 01:06:32.480
Anytime you write anything in something other than Python, it's harder to get running, right?

01:06:32.480 --> 01:06:33.160
Somewhere else.

01:06:33.160 --> 01:06:36.000
Now, you mentioned the 3.11 release, Michael.

01:06:36.000 --> 01:06:48.360
My hope here is now that we've got that nice little performance boost there, that's going to motivate people who are primarily targeting CPython at the moment to write more code in Python and reach for the C code and the Rust code less.

01:06:48.780 --> 01:06:51.300
Because, once again, that stuff can get brought over today.

01:06:51.300 --> 01:06:54.060
There is nothing you have to do to make this work, right?

01:06:54.060 --> 01:06:57.700
Like, you can load pure Python wheels in PyScript.

01:06:57.700 --> 01:06:59.220
You can do that on WebAssembly, right?

01:06:59.220 --> 01:07:00.680
It just runs.

01:07:00.680 --> 01:07:11.000
So if we can kind of nudge the community back towards running more Python and leaning less on the accelerator code that we have historically written for these kind of platforms, or do both, right?

01:07:11.000 --> 01:07:16.100
Like, if you can at least prototype in Python and keep that running, and then write the accelerator code behind the scenes, right?

01:07:16.100 --> 01:07:19.340
Like, you can have multiple wheels, including a pure Python wheel, right?

01:07:19.340 --> 01:07:23.760
Like, coverage.py, we all know, does this exact thing so that it works no matter where you are.

01:07:23.760 --> 01:07:26.160
Same thing for this case, right?

01:07:26.220 --> 01:07:29.840
Like, if you can get the pure Python wheel out there, then it's going to be usable everywhere.

01:07:29.840 --> 01:07:43.280
And so that's kind of a baseline target I hope the community kind of leans into more than we have in the last few years, where, yeah, write your Python code even more than you may have before, because it's usable in more places.

01:07:43.280 --> 01:07:44.520
That's really great advice.

01:07:44.520 --> 01:07:46.260
And it's not done getting faster, right?

01:07:46.260 --> 01:07:49.620
The faster CPython team is still making a bunch of steps.

01:07:49.620 --> 01:07:55.860
So it's much faster now, but there's still, there's 3.11, 3.13, or 3.12, 3.13, the one that's going to be.

01:07:55.860 --> 01:07:56.400
Yeah, exactly.

01:07:56.400 --> 01:07:57.900
Like, it's going to keep going.

01:07:57.900 --> 01:08:00.720
I don't know how much faster 3.12 may or may not be.

01:08:00.720 --> 01:08:04.320
I think there's some plans for 3.12 that are really foundational.

01:08:04.320 --> 01:08:11.200
So the bump might not be quite as big as 3.11, but 3.13, if the foundation lays in 3.12, we'll hopefully get the bump.

01:08:11.700 --> 01:08:15.200
So, yeah, hopefully you'll keep getting those wins going forward, right?

01:08:15.200 --> 01:08:20.020
And I know Damien's still working on MicroPython to make it faster and smaller and better and all that stuff.

01:08:20.020 --> 01:08:21.820
So it's not just a CPython thing out of there.

01:08:21.820 --> 01:08:25.960
Like, the whole, everyone's always trying to make Python run better on all these platforms.

01:08:25.960 --> 01:08:31.160
So key thing, though, is the common bottom layer of all these platforms is actually Python itself.

01:08:31.160 --> 01:08:38.480
So if we can target that more as a community, we'll actually be able to get more use out of the code and for what people have produced in more places.

01:08:38.880 --> 01:08:41.860
And once again, help Nicholas when he faces down that class of 30.

01:08:41.860 --> 01:08:44.880
Yes, you can.

01:08:44.880 --> 01:08:46.020
You can create Call of Duty.

01:08:46.020 --> 01:08:46.420
Okay.

01:08:46.420 --> 01:08:47.120
Thank you, Brett.

01:08:47.120 --> 01:08:48.480
That's great thoughts.

01:08:48.480 --> 01:08:52.780
And it also points out I should pay more attention to those release notes when they come up in my VS Code.

01:08:52.780 --> 01:08:54.220
I'm like, oh, new one, out of the way.

01:08:54.220 --> 01:08:54.940
Maybe I'll read them.

01:08:54.940 --> 01:08:56.640
All right.

01:08:56.640 --> 01:08:59.140
You guys, thank you so much for all the work on this.

01:08:59.140 --> 01:09:00.820
This is super exciting.

01:09:01.180 --> 01:09:06.160
And yeah, I'm looking forward to hearing about it in spring or whenever it's ready.

01:09:06.160 --> 01:09:07.760
Brett, Fabio, Nicholas, thanks for being here.

01:09:07.760 --> 01:09:08.420
It's been great.

01:09:08.420 --> 01:09:09.140
Thanks, Michael.

01:09:09.140 --> 01:09:09.900
Thank you, Michael.

01:09:09.900 --> 01:09:10.960
That was great.

01:09:10.960 --> 01:09:11.640
Thank you, Michael.

01:09:13.380 --> 01:09:16.000
This has been another episode of Talk Python to Me.

01:09:16.000 --> 01:09:17.800
Thank you to our sponsors.

01:09:17.800 --> 01:09:19.420
Be sure to check out what they're offering.

01:09:19.420 --> 01:09:20.840
It really helps support the show.

01:09:20.840 --> 01:09:23.980
AWS is the lead cloud for developers.

01:09:23.980 --> 01:09:28.700
But with over 250 services, it's an overwhelming set of choices.

01:09:29.320 --> 01:09:32.280
That's where the AWS Insiders podcast comes in.

01:09:32.280 --> 01:09:35.800
Their job is to help you make sense of all those AWS options.

01:09:35.800 --> 01:09:40.600
Listen to an episode at talkpython.fm/AWS Insiders.

01:09:40.600 --> 01:09:42.980
Listen to the Local Maximum podcast.

01:09:42.980 --> 01:09:49.140
Learn about topics as diverse as the philosophy of probability and Elon Musk's next move.

01:09:49.140 --> 01:09:52.520
Just search for Local Maximum in your favorite podcast player.

01:09:52.520 --> 01:09:54.540
Want to level up your Python?

01:09:54.540 --> 01:09:58.580
We have one of the largest catalogs of Python video courses over at Talk Python.

01:09:59.040 --> 01:10:03.760
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:10:03.760 --> 01:10:06.440
And best of all, there's not a subscription in sight.

01:10:06.440 --> 01:10:09.340
Check it out for yourself at training.talkpython.fm.

01:10:09.340 --> 01:10:11.240
Be sure to subscribe to the show.

01:10:11.240 --> 01:10:14.020
Open your favorite podcast app and search for Python.

01:10:14.020 --> 01:10:15.320
We should be right at the top.

01:10:15.320 --> 01:10:20.480
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:10:20.480 --> 01:10:24.680
and the direct RSS feed at /rss on talkpython.fm.

01:10:24.680 --> 01:10:28.120
We're live streaming most of our recordings these days.

01:10:28.120 --> 01:10:31.540
If you want to be part of the show and have your comments featured on the air,

01:10:31.540 --> 01:10:35.960
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:10:35.960 --> 01:10:37.800
This is your host, Michael Kennedy.

01:10:37.800 --> 01:10:39.100
Thanks so much for listening.

01:10:39.100 --> 01:10:40.260
I really appreciate it.

01:10:40.260 --> 01:10:42.180
Now get out there and write some Python code.

01:10:42.180 --> 01:10:43.180
Thank you.

01:10:43.180 --> 01:11:13.160
Thank you.

