WEBVTT

00:00:00.001 --> 00:00:04.500
Monorepos are contrary to how many of us have been taught to use source control.

00:00:04.500 --> 00:00:09.160
To start a project or app, the first thing we do is create a Git repository for it.

00:00:09.160 --> 00:00:12.640
This leads to many focused and small repositories.

00:00:12.640 --> 00:00:18.860
A quick check on my GitHub account shows that I have 179 non-fork repositories.

00:00:18.860 --> 00:00:21.440
That's a lot, but I think many of us work that way.

00:00:21.440 --> 00:00:23.180
It's not like this with monorepos.

00:00:23.180 --> 00:00:28.760
With monorepos, you create one or a couple of repositories for your entire company.

00:00:28.760 --> 00:00:34.700
This might have hundreds or thousands of employees working on multiple projects within a single repository.

00:00:34.700 --> 00:00:39.560
Famously, Google, Meta, Microsoft, and Airbnb, amongst others,

00:00:39.560 --> 00:00:44.660
all employ very large monorepos with varying strategies for coordination.

00:00:44.660 --> 00:00:49.440
On this episode, we have David Vilyek here to give us his perspective on monorepos,

00:00:49.440 --> 00:00:54.980
as well as highlight an architectural pattern and set of tools for accomplishing this in Python.

00:00:55.320 --> 00:01:01.260
This is Talk Python To Me, episode 399, recorded January 13th, 2023.

00:01:14.140 --> 00:01:17.560
Welcome to Talk Python To Me, a weekly podcast on Python.

00:01:17.560 --> 00:01:19.300
This is your host, Michael Kennedy.

00:01:19.300 --> 00:01:26.780
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython, both on fosstodon.org.

00:01:26.780 --> 00:01:29.380
Be careful with impersonating accounts on other instances.

00:01:29.380 --> 00:01:30.340
There are many.

00:01:30.340 --> 00:01:35.400
Keep up with the show and listen to over seven years of past episodes at talkpython.fm.

00:01:36.000 --> 00:01:39.460
We've started streaming most of our episodes live on YouTube.

00:01:39.460 --> 00:01:46.980
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.

00:01:46.980 --> 00:01:51.180
This episode is brought to you by Microsoft for Startups Founders Hub.

00:01:51.180 --> 00:01:59.420
Get early stage support for your startup without the requirement to be VC-backed or verified at talkpython.fm/foundershub.

00:01:59.680 --> 00:02:01.980
It's also brought to you by Brilliant.org.

00:02:01.980 --> 00:02:09.880
Stay on top of technology and raise your value to employers or just learn something fun in STEM at Brilliant.org.

00:02:09.880 --> 00:02:14.820
Visit talkpython.fm/brilliant to get 20% off an annual premium subscription.

00:02:14.820 --> 00:02:17.500
David, welcome to Talk Python To Me.

00:02:17.500 --> 00:02:18.040
Thank you.

00:02:18.040 --> 00:02:21.060
I'm really excited to be on the podcast.

00:02:21.060 --> 00:02:23.460
I'm really excited to have you on the podcast.

00:02:23.460 --> 00:02:27.720
And we get to talk about a couple of interesting ideas.

00:02:27.720 --> 00:02:30.040
We get to talk about software architecture.

00:02:30.040 --> 00:02:33.380
People may know I'm a big fan of architecture.

00:02:33.380 --> 00:02:37.500
I think putting your software together bright makes all the difference.

00:02:37.500 --> 00:02:45.800
We're going to talk about some ideas that are new to me, this polyleth idea that you're an advocate and fan of and how it applies to Python.

00:02:45.800 --> 00:02:50.420
We're also going to focus a good portion of this conversation on monorepos.

00:02:50.420 --> 00:02:52.680
And what the heck are monorepos, right?

00:02:52.680 --> 00:02:53.940
Yeah.

00:02:53.940 --> 00:02:54.900
That'll be a lot of fun.

00:02:54.900 --> 00:02:56.320
And I'm really looking forward to it.

00:02:56.860 --> 00:02:59.400
But let's hear your story first.

00:02:59.400 --> 00:03:01.220
How did you get into programming and Python?

00:03:01.220 --> 00:03:01.680
Yeah.

00:03:01.680 --> 00:03:02.980
How did I get into programming?

00:03:02.980 --> 00:03:05.940
Well, so I guess it was when I was a kid.

00:03:05.940 --> 00:03:08.500
My dad bought me Commodore 64.

00:03:08.500 --> 00:03:11.180
It was like way back in the 1980s.

00:03:11.880 --> 00:03:24.460
So that's when I started learning basic programming language and how to write things that are code and not pure text.

00:03:24.460 --> 00:03:28.820
But then I went on a different path.

00:03:28.820 --> 00:03:34.140
I was working mostly with design and things like that.

00:03:34.140 --> 00:03:41.900
And the first thing I knew was a job in our business was a web designer.

00:03:41.900 --> 00:03:44.960
So that was what I wanted to be at first.

00:03:44.960 --> 00:03:51.320
So I started to learn JavaScript and copy and pasted some snippets of code and stuff like that.

00:03:51.320 --> 00:03:51.580
Yeah.

00:03:51.580 --> 00:03:52.540
And that's the era.

00:03:52.540 --> 00:03:58.140
I'm just guessing from the starting computer where you were sort of in time when this must have happened.

00:03:58.140 --> 00:04:02.860
And that was probably before all these crazy JavaScript front-end frameworks and all that.

00:04:02.860 --> 00:04:09.680
And it was more of how do you visually design this page with graphic and more art and more focused on that, right?

00:04:09.680 --> 00:04:09.980
Yeah.

00:04:09.980 --> 00:04:17.540
Before like jQuery and before like all these React and all of that good stuff that we have today.

00:04:17.540 --> 00:04:18.040
Sure.

00:04:18.040 --> 00:04:19.080
Yeah.

00:04:19.080 --> 00:04:23.180
And with Python, I think I started about 2015 with Python.

00:04:23.640 --> 00:04:37.740
I started with Python 2.7 and then learning all I think in that period, I also learned started to think in more like functional programming style, more like functional-ish.

00:04:37.740 --> 00:04:37.740
Yeah.

00:04:37.740 --> 00:04:40.680
And that's coming from Python actually.

00:04:40.680 --> 00:04:44.880
And I was very much into Node.js at that time too.

00:04:44.880 --> 00:04:50.420
So I think around 2015, and I've been like jumping back and forth between different languages.

00:04:50.920 --> 00:04:55.540
I'm a really huge fan of Clojure 2, which is like 100% functional.

00:04:55.540 --> 00:05:04.640
So I've been like visiting some different kinds of programming languages and styles and things like that.

00:05:04.640 --> 00:05:15.560
And now I'm back to full-time Python on my day job and almost full-time Python during nights because I really love to code on my spare time too.

00:05:15.560 --> 00:05:19.840
When I assume there is any chance to code.

00:05:19.840 --> 00:05:21.020
So I'll take that one.

00:05:21.020 --> 00:05:22.220
Yeah, absolutely.

00:05:22.220 --> 00:05:30.280
I mean, how much of open source is there's programmers and we have this project we've got to work on, but we really want to build this other thing and we're super passionate about it.

00:05:30.280 --> 00:05:33.200
We just end up building it and sharing it and it takes off, you know?

00:05:33.360 --> 00:05:35.680
And I think that's a very common story for sure.

00:05:35.680 --> 00:05:46.140
So before we move on, how has working in Python influenced something like Clojure or Clojure influenced your Python thinking?

00:05:46.140 --> 00:05:48.240
They're fairly different languages, right?

00:05:48.240 --> 00:05:48.640
Yeah.

00:05:48.640 --> 00:05:52.880
Functional being less stateful, which is a really big different way of programming.

00:05:52.880 --> 00:05:53.240
Yeah.

00:05:53.240 --> 00:06:04.820
Well, I think what I learned from Python was like the elegance and the importance of writing elegant and simplistic code.

00:06:04.820 --> 00:06:08.260
I was really impressed by the Zen of Python.

00:06:08.260 --> 00:06:14.260
You know, if you type import this in a shell, you get this nice list of how to write your code.

00:06:14.260 --> 00:06:16.160
I really liked that idea.

00:06:16.560 --> 00:06:22.640
So I guess that's where I started to think about keeping it simple, clean and short.

00:06:22.640 --> 00:06:22.940
Yeah.

00:06:22.940 --> 00:06:43.220
And with Clojure, it was like that's kind of a different, total different syntax, but also digging into a lot of functional aspects and how to think about state, how to separate the calculations from actions and data and things like that.

00:06:43.220 --> 00:06:53.600
And I think I've brought a lot of those ideas back to when I'm back at Python, how to separate different kinds of code that you write.

00:06:53.600 --> 00:06:54.520
Yeah, I can see that.

00:06:54.520 --> 00:07:00.380
I feel like Python is really interesting because you can choose to only focus on little parts of it.

00:07:00.380 --> 00:07:07.480
That's good for beginners because they only have to learn a little part, but it's also good for people who have particular styles that they like to work.

00:07:07.580 --> 00:07:21.880
If you want to write functional Python, you don't have to create any global variables or any classes or any, you can just, you can write it that way, but you could completely go really deep OO patterns and can do that in Python too if you want.

00:07:21.880 --> 00:07:22.120
Right.

00:07:22.120 --> 00:07:23.420
It's completely up to you.

00:07:23.420 --> 00:07:23.740
Yeah.

00:07:23.840 --> 00:07:25.500
And I like that kind of freedom.

00:07:25.500 --> 00:07:34.220
It's, you can't, you don't, you're not the force to do either this or that you, you can learn an experiment.

00:07:34.220 --> 00:07:41.420
And especially when you, if you use libraries, they are like designed in different ways too.

00:07:41.420 --> 00:07:46.040
So you can, you don't have to limit yourself to only use that kind of library or this kind of library.

00:07:46.040 --> 00:07:55.380
So I really like Python, the capabilities of Python when it comes to that, but it's not very strict in any kind of format.

00:07:55.560 --> 00:07:56.160
I like that too.

00:07:56.160 --> 00:08:00.420
And I think other languages are seeing that and adopting that as well.

00:08:00.420 --> 00:08:09.680
You know, you see Swift with their playgrounds and well, Swift in general and .NET with their, you know, maybe we don't need namespaces and classes and static main void for everything to get started.

00:08:09.680 --> 00:08:12.420
And they're adopting those types of things.

00:08:12.860 --> 00:08:20.820
You know, we're talking about this like, well, functional people might want to write this way and more OO oriented people that way, but that also could just be you in different situations.

00:08:20.820 --> 00:08:23.420
You know, right now, this is the right tool to solve it.

00:08:23.420 --> 00:08:30.960
And other times here's a different way to solve a different problem, but you can just stay in the same tools and the same editors and the same ecosystem.

00:08:30.960 --> 00:08:31.700
It's cool.

00:08:31.700 --> 00:08:32.320
Yeah, definitely.

00:08:32.320 --> 00:08:32.800
Yeah.

00:08:32.800 --> 00:08:33.240
All right.

00:08:33.240 --> 00:08:40.060
Well, let's start in on the first half of our, our main topic here is the mono repo.

00:08:41.060 --> 00:08:48.800
Now, yeah, it's really easy to confuse what a mono repo is with a mono lith versus same microservices.

00:08:48.800 --> 00:08:49.260
Yeah.

00:08:49.260 --> 00:08:51.020
Those are not really at all the same thing.

00:08:51.020 --> 00:08:56.700
In fact, they might actually be opposites in a sense, a mono repo and a mono lith to some degree.

00:08:56.700 --> 00:09:01.360
So maybe kick us off by telling us what is a mono repo here?

00:09:01.360 --> 00:09:09.960
A mono repo is, I don't think it's that complicated, but I actually also, before I started to dig into this thing more,

00:09:10.100 --> 00:09:18.440
I also had almost put like an equal sign between mono lift and mono repo because that's the way I have used the writing code.

00:09:18.440 --> 00:09:23.780
I was in the dot net and C# world a lot.

00:09:23.780 --> 00:09:28.880
And you like building your website and you have a data later and you have a domain layer and everything was in a repo.

00:09:28.880 --> 00:09:38.520
So I guess Microsoft was like a reaction to that to separate code into isolated environments.

00:09:38.520 --> 00:09:49.100
And you can have this nice and clean little code base and you have that does one thing and you have this other code base that does a different thing.

00:09:49.220 --> 00:09:58.100
So if instead of just having the user authentication bit completely just woven into the code, we can make a little API that we call over JSON that does the authentication.

00:09:58.100 --> 00:09:59.840
And then here's the one has the catalog.

00:09:59.840 --> 00:10:00.440
Yeah.

00:10:00.520 --> 00:10:11.860
And we could write just a little bit of code and, you know, the, I guess the benefit, right, is that whoever's working on the catalog bit, they theoretically can just stay focused on that little bit of code and not the entire system.

00:10:11.860 --> 00:10:12.160
Right.

00:10:12.160 --> 00:10:12.420
Yeah.

00:10:12.460 --> 00:10:14.260
With a microservice story.

00:10:14.260 --> 00:10:14.580
Yeah.

00:10:14.580 --> 00:10:31.260
A monorepo is, I think, from the way I see it, it's like, it's a Git or any version control repo that has basically all of your code in the same repo, same repository.

00:10:31.260 --> 00:10:39.300
And that doesn't necessarily mean that it's one program or one app that you are going to build or compile into.

00:10:39.300 --> 00:10:44.240
You can have several projects or artifacts in that repo.

00:10:44.240 --> 00:10:50.080
And I guess that's why it's called monorepo because you can have multiple things in it.

00:10:50.080 --> 00:10:57.920
So I guess that's the difference between a monolith where you have, where you actually build one app and deploy it to one place.

00:10:57.920 --> 00:10:59.660
Right, right.

00:10:59.660 --> 00:11:03.960
The monolith is the opposite of the microservice style.

00:11:04.100 --> 00:11:04.280
Yeah.

00:11:04.280 --> 00:11:18.340
Whereas the monorepo is just a way of organizing your code and sharing how do you propagate changes, look at dependencies across either libraries or, there are companies that take this really far.

00:11:18.340 --> 00:11:20.420
Crazy, crazy far.

00:11:20.540 --> 00:11:26.880
Like Google and Facebook, I believe, haven't worked on it, but I hear that they have one repo.

00:11:26.880 --> 00:11:28.020
Yeah.

00:11:28.020 --> 00:11:29.660
Or like all of it.

00:11:29.660 --> 00:11:30.820
What, one?

00:11:30.820 --> 00:11:31.380
Really?

00:11:31.380 --> 00:11:34.280
Just like, what's the checkout story look like on that?

00:11:34.280 --> 00:11:35.800
It's got to be a lot of code.

00:11:35.800 --> 00:11:36.240
Yeah.

00:11:36.240 --> 00:11:37.500
It's got to be a lot of code.

00:11:37.600 --> 00:11:53.600
I believe Google, I'm probably going to misassociate this, but I think Google uses Bazel and there's different tools that allow them that are kind of not just Git, but something that can handle that scale of code.

00:11:54.120 --> 00:12:03.540
So it really, when I think about organizing my code, it's either me or me and a couple of people working on the code and it's pretty contained.

00:12:03.540 --> 00:12:09.780
But when you start to think about hundreds or thousands of people across projects, it starts to get really wild, right?

00:12:09.780 --> 00:12:10.060
Yeah.

00:12:10.060 --> 00:12:13.620
That has to be a completely different story.

00:12:14.360 --> 00:12:19.640
We're really fun to see how they do, how they work in the teams.

00:12:19.640 --> 00:12:20.380
Yeah, absolutely.

00:12:20.380 --> 00:12:29.280
So maybe we could talk about some of the, you know, why, if you're not doing this, you know, why would you do that?

00:12:29.280 --> 00:12:38.180
Like it seems, you know, you highlighted that there's kind of these two trends that you saw out there in some of your articles.

00:12:38.180 --> 00:12:40.280
And we'll talk about the articles and link to them.

00:12:40.280 --> 00:12:52.300
You talked about seeing a trend of more people trending towards this monorepo and more people or other groups of people trending towards having more small repos.

00:12:52.300 --> 00:12:52.980
Yeah.

00:12:52.980 --> 00:13:01.780
For you take my little microservice example, the user access service might be its own repository separate from the catalog service.

00:13:01.780 --> 00:13:08.240
Whereas others might say, we're going to put all that together and all the utilities and that other data reporting project.

00:13:08.240 --> 00:13:11.900
And all of that goes into one giant repo, even though there's a big team on it, right?

00:13:11.900 --> 00:13:12.220
Yeah.

00:13:12.220 --> 00:13:28.900
Well, I think from my experience, what I've seen joining different teams and different companies that I've seen exactly that some quite recently, I joined a team at a company with several teams.

00:13:28.900 --> 00:13:34.680
And they actually migrated from a monorepo to several repositories.

00:13:34.680 --> 00:13:43.820
And it was part of their microservice journey, as they call it, because they had one repo with all their code.

00:13:44.620 --> 00:13:47.840
But that code base was so difficult to work with.

00:13:47.840 --> 00:14:02.860
So they kind of wanted to extract one app at a time into a separate repository just to be able to deploy that one and work with it in a reasonable way with tooling support and things like that.

00:14:02.860 --> 00:14:07.900
So before that, I was at a different company joining a different team.

00:14:07.900 --> 00:14:10.720
And we went the total opposite way.

00:14:10.720 --> 00:14:20.620
We had a couple of microservices that were quite easy to work with.

00:14:20.620 --> 00:14:29.320
But we identified issues or problems with it because maybe there's one service that has outdated dependencies.

00:14:29.320 --> 00:14:37.860
So the biggest problem was the actual code duplication because we had one service that we had developed one thing for.

00:14:37.860 --> 00:14:47.560
And we had another service that we needed code that was very much like the thing we had in that other service.

00:14:47.560 --> 00:14:53.420
So I guess the solution could be to extract that one into a library, but then you have three repositories.

00:14:53.420 --> 00:15:00.080
And I guess there's difficult to find that good balance between one or the other.

00:15:00.080 --> 00:15:00.820
I agree.

00:15:00.820 --> 00:15:05.320
And that extracting, I mean, that's certainly one of the possibilities.

00:15:05.320 --> 00:15:13.980
As you say, well, we're going to, you know what, we now have a third repository and we have the data access repository and package.

00:15:13.980 --> 00:15:22.420
And, you know, that's probably not the type of thing you publish to PyPI, but it's very likely something you would publish to some kind of internal dependency artifact.

00:15:23.400 --> 00:15:25.160
System that you would depend upon, right?

00:15:25.160 --> 00:15:39.220
But the problem is, if it's used in just these two places, it's, and it sounds like that sort of description, the kind of the team is probably working on both sides of those microservices and they understand the broader system.

00:15:39.220 --> 00:15:45.120
But as it grows and more people depend upon it, it's harder to understand this little standalone project.

00:15:45.120 --> 00:15:48.920
Who is using it and what ways are they completely?

00:15:48.920 --> 00:15:50.380
Can we make a change here?

00:15:50.380 --> 00:15:56.780
If we refactor this, who do we talk to about changing even just the signature of a function?

00:15:56.900 --> 00:16:11.820
How do we reach out to the other parts of code or other stakeholders and say, look, we need to change this function, but we got to, you know, we're changing the data model and you're going to have to figure out how to go along.

00:16:12.160 --> 00:16:26.100
On the other hand, if all of those projects were together in a giant mono repo, we have tooling that understands, well, what functions call this function or what thing imports this class or who's using it?

00:16:26.100 --> 00:16:27.580
Is it used at all?

00:16:27.580 --> 00:16:28.780
Actually, maybe you could delete it.

00:16:29.040 --> 00:16:31.160
You thought someone was using it and no one's using it, right?

00:16:31.160 --> 00:16:38.520
There's a lot of understanding of the broader integration if it's all there with you, right?

00:16:38.520 --> 00:16:39.040
Definitely.

00:16:39.040 --> 00:16:46.360
This portion of Talk Python to Me is brought to you by Microsoft for Startups Founders Hub.

00:16:46.360 --> 00:16:48.420
Starting a business is hard.

00:16:48.420 --> 00:16:53.360
By some estimates, over 90% of startups will go out of business in just their first year.

00:16:54.020 --> 00:17:02.840
With that in mind, Microsoft for Startups set out to understand what startups need to be successful and to create a digital platform to help them overcome those challenges.

00:17:02.840 --> 00:17:05.520
Microsoft for Startups Founders Hub was born.

00:17:05.520 --> 00:17:12.180
Founders Hub provides all founders at any stage with free resources to solve their startup challenges.

00:17:12.180 --> 00:17:20.780
The platform provides technology benefits, access to expert guidance and skilled resources, mentorship and networking connections, and much more.

00:17:21.380 --> 00:17:30.340
Unlike others in the industry, Microsoft for Startups Founders Hub doesn't require startups to be investor-backed or third-party validated to participate.

00:17:30.340 --> 00:17:33.060
Founders Hub is truly open to all.

00:17:33.060 --> 00:17:34.560
So what do you get if you join them?

00:17:34.560 --> 00:17:42.820
You speed up your development with free access to GitHub and Microsoft Cloud computing resources and the ability to unlock more credits over time.

00:17:42.820 --> 00:17:52.560
To help your startup innovate, Founders Hub is partnering with innovative companies like OpenAI, a global leader in AI research and development, to provide exclusive benefits and discounts.

00:17:52.560 --> 00:17:57.980
Through Microsoft for Startups Founders Hub, becoming a founder is no longer about who you know.

00:17:57.980 --> 00:18:11.520
You'll have access to their mentorship network, giving you a pool of hundreds of mentors across a range of disciplines and areas like idea validation, fundraising, management and coaching, sales and marketing, as well as specific technical stress points.

00:18:11.520 --> 00:18:16.780
You'll be able to book a one-on-one meeting with the mentors, many of whom are former founders themselves.

00:18:16.780 --> 00:18:21.880
Make your idea a reality today with the critical support you'll get from Founders Hub.

00:18:21.880 --> 00:18:27.840
To join the program, just visit talkpython.fm/foundershub, all one word, no links in your show notes.

00:18:27.840 --> 00:18:30.140
Thank you to Microsoft for supporting the show.

00:18:32.360 --> 00:18:33.640
Yeah, I totally agree.

00:18:33.640 --> 00:18:46.260
And our editors are so smart and they can find usages and if you have this function signature isn't really correct and stuff like that.

00:18:46.260 --> 00:18:55.040
And that's so much easier when you have your source code in a folder that is like right next to the one using it.

00:18:55.040 --> 00:19:00.780
So that's a huge benefit, like editor-wise to the developer experience, I guess.

00:19:00.780 --> 00:19:02.080
Yeah, absolutely.

00:19:02.460 --> 00:19:06.360
And I think one of, this is both a benefit and a challenge.

00:19:06.360 --> 00:19:10.600
You know, I'll maybe link to the Monorepo Wikipedia page and it says, here are some of the advantages.

00:19:10.600 --> 00:19:14.580
One of the number one advantage list is ease of code reuse.

00:19:15.020 --> 00:19:25.520
So it's possible, not necessarily suggested, but possible that you say, well, the data access functions and classes that we need on this side, we need some of them over here.

00:19:25.520 --> 00:19:33.340
But if you have the whole Monorepo, you could just say, well, import them in both projects and deploy, you know, a larger piece of code to your server.

00:19:33.340 --> 00:19:34.000
But who cares?

00:19:34.000 --> 00:19:36.960
The servers have a lot of storage and they'll be fine, right?

00:19:36.960 --> 00:19:47.680
The challenge, I think, is going to be the, you're going to end up with a tightly coupled architecture pretty badly if you just say, well, I see way over there, there's that file and that's the one I want.

00:19:47.680 --> 00:19:48.720
And we're just going to grab that.

00:19:48.720 --> 00:19:56.500
And, you know, it doesn't necessarily encourage good behavior, but it does make reusing code and understand how it's being used easy, right?

00:19:56.500 --> 00:19:56.800
Yeah.

00:19:56.800 --> 00:20:02.520
And also you have, you're like in the risk zone of actually building a Monoly again.

00:20:02.520 --> 00:20:03.220
Yeah, exactly.

00:20:04.700 --> 00:20:11.220
You're just part of the, part of the API points run there and part of the API points run there, but they're, they're effectively just one giant thing, right?

00:20:11.660 --> 00:20:33.700
So I guess what I think is that if you are using a Mono, if you want to have your code in a Mono repo, I guess you would need some sort of tooling or ideas about how to separate your code into separate artifacts that don't have the entire code base in its package.

00:20:33.700 --> 00:20:38.160
Only the code that is actually needed for this artifact.

00:20:38.160 --> 00:20:42.580
So, again, I guess that's, that's part of the challenge, having a Mono repo.

00:20:42.580 --> 00:20:43.560
I would say so.

00:20:43.560 --> 00:20:47.980
I've been thinking about this a little bit leading up to our conversation today.

00:20:48.240 --> 00:21:01.400
And certainly you can use packages in the, you know, we have this problem in Python or this challenge where packages mean different things, but it has the same word.

00:21:01.800 --> 00:21:11.660
So a package could be just a grouping of modules into a directory that has a Dunder init, or it could be something on PyPI that you ship and you deploy and you version on its own.

00:21:11.760 --> 00:21:18.060
And I mean, in just the on disk, the Dunder init sort of local grouping, right?

00:21:18.060 --> 00:21:34.240
So you could create these, these sort of groups within your Mono repo and say, we're going to import that, but have a little bit of a formal separation and say, look, we're not necessarily going to deploy it through some versioning story and let other people pull it in.

00:21:34.240 --> 00:21:37.780
Because then we lose track of who's using it and how they're using it.

00:21:37.780 --> 00:21:39.400
Are they on the right version?

00:21:39.400 --> 00:21:44.540
But we'll still maybe think of them as a Python package, in a sense.

00:21:44.540 --> 00:21:47.940
Do you have any experience with doing it one way or the other?

00:21:47.940 --> 00:21:48.840
Any preference?

00:21:48.840 --> 00:21:49.240
Yeah.

00:21:49.240 --> 00:22:02.900
What I was thinking of from the company that I joined that were migrating from their Mono repo, they had done a couple of attempts to do this code sharing thing.

00:22:02.900 --> 00:22:08.000
with the likes, I think it was like Git sub modules or, or similar things.

00:22:08.000 --> 00:22:17.400
But all of that ended up into in, it was became too complicated to, to understand what was going on.

00:22:17.400 --> 00:22:26.000
And, and I think even the editor support where it wasn't really, really perfect when you had like these kind of dynamic linking.

00:22:26.000 --> 00:22:31.520
So I guess that's, that's why they, they chose to, to abandon that idea.

00:22:31.520 --> 00:22:33.520
Yeah.

00:22:33.520 --> 00:22:34.520
Yeah.

00:22:34.520 --> 00:22:46.520
It sounds a little bit like with the sub modules that it was not a pure Mono repo, but kind of a, let's have different sections on, on our repository, but bring it together.

00:22:46.520 --> 00:22:49.520
Yeah.

00:22:49.520 --> 00:22:49.520
Yeah.

00:22:49.520 --> 00:22:49.520
Yeah.

00:22:49.520 --> 00:22:56.520
like, we're going to sort of put these files and it's, this is a sub module, that's a sub module and they're kind of separate.

00:22:56.520 --> 00:23:02.060
But then once they're all checked out and linked up, then our tool thinks of it as one giant thing.

00:23:02.060 --> 00:23:03.900
Like the Mono repo would be right.

00:23:03.900 --> 00:23:04.160
Yeah.

00:23:04.220 --> 00:23:07.540
So it's kind of a, an intermediate, I also thought about this as well.

00:23:07.540 --> 00:23:10.860
Like maybe, maybe you could put together the get tools like that.

00:23:10.860 --> 00:23:18.960
I do want to highlight a couple of get tools because maybe I'll, I'll take a quick bit of audience feedback real quick.

00:23:19.040 --> 00:23:25.360
But I do think that, you know, when it's five people, 10 people, you just check the thing out and it's going to be fine.

00:23:25.360 --> 00:23:39.980
But as it gets larger and larger, both over time and lines of code and number of people, it's, it's going to be a thing where it almost becomes unmanageable to just do a, a get clone URL and see what happens.

00:23:39.980 --> 00:23:40.260
Right.

00:23:40.260 --> 00:23:41.760
You can go grab, grab a coffee.

00:23:41.760 --> 00:23:44.540
And when it got back, it's not, it hasn't downloaded.

00:23:44.540 --> 00:23:49.080
We've probably seen that XKCD where there's people like fake sword fighting on a chair.

00:23:49.080 --> 00:23:49.960
It's like, get back to work.

00:23:49.960 --> 00:23:53.020
Like, you know, we're doing a get clone, leave us alone.

00:23:53.020 --> 00:23:54.120
Okay.

00:23:54.120 --> 00:23:54.380
Sure.

00:23:54.380 --> 00:23:54.700
Fine.

00:23:54.700 --> 00:23:55.300
Gotcha.

00:23:55.600 --> 00:23:56.360
It's going to be a while.

00:23:56.360 --> 00:23:59.780
Quick bit of audience feedback says model repos are okay.

00:23:59.780 --> 00:24:04.080
If you have a dedicated team that manages the advanced tooling required to deal with them.

00:24:04.080 --> 00:24:04.780
Yeah, absolutely.

00:24:04.780 --> 00:24:14.060
And I sort of related Lucas asks, they would use Bazel for your projects or rather have make files or similar in case of lints and builds.

00:24:14.060 --> 00:24:20.180
So yeah, there's the different tools that like Facebook and Google and those folks use.

00:24:20.180 --> 00:24:22.020
There's also pants.

00:24:22.020 --> 00:24:24.760
Benji Weinberger has talked a lot about it.

00:24:24.800 --> 00:24:25.640
I've had him on the show.

00:24:25.640 --> 00:24:26.440
I've had him on the show before.

00:24:26.440 --> 00:24:30.380
And pants is one of these tools that can kind of help pants build.

00:24:31.140 --> 00:24:32.480
But David, how about you?

00:24:32.480 --> 00:24:38.540
What were you all using in terms of more advanced tooling or was there anything special?

00:24:38.540 --> 00:24:45.380
Back then it was not really more advanced than actually make files to make things happen.

00:24:45.380 --> 00:24:55.260
But the other place, the team that I joined actually started to use this, I guess we're going to talk about it in the architecture called polyleth.

00:24:55.260 --> 00:24:57.100
And there's also tooling for that.

00:24:57.100 --> 00:24:58.100
Yeah.

00:24:58.100 --> 00:25:06.900
And there's also tooling for that kind of offers a solution to many of these headaches with having a monorepo.

00:25:06.900 --> 00:25:08.100
Yeah, absolutely.

00:25:08.100 --> 00:25:13.680
And back then it was because polyleth originates from closure.

00:25:13.680 --> 00:25:15.480
So we were actually writing closure code.

00:25:15.480 --> 00:25:23.120
And then for Python, I started to look around for a solution.

00:25:23.120 --> 00:25:26.200
I actually read a little bit about pants.

00:25:26.200 --> 00:25:30.200
So I think that can solve a lot of problems too.

00:25:30.200 --> 00:25:37.540
It seems like a really great tool with a lot of useful functionality.

00:25:37.540 --> 00:25:41.540
And then there's also poetry.

00:25:41.540 --> 00:25:52.960
I don't think that it's not really about monorepos, but you can, I believe that you can use pure poetry and have your dependencies,

00:25:52.960 --> 00:26:02.260
like the third party libraries, your own or the one at PyPy in sort of an, not the third party, but your own in an editable mode.

00:26:02.260 --> 00:26:05.980
So they will, as soon as you change something, it will be updated.

00:26:05.980 --> 00:26:19.520
So I guess there are some tools that can help you along the way, but I guess there's still a lot of frustration with having that smooth and really joyful monorepo experience that you would like to have.

00:26:19.520 --> 00:26:24.020
So that's what led me to, to, to start working on this project.

00:26:24.020 --> 00:26:37.200
I do think that Python, the way that its dependencies and its understanding of linking, you know, files together through directories and things like that makes it a little bit more challenging than other systems.

00:26:37.200 --> 00:26:46.740
Like if I was doing C++, I could open up Visual Studio Code and create a broader project and say, these three libraries are what I want to see as my project.

00:26:46.740 --> 00:26:48.480
And it doesn't really matter where they come from.

00:26:48.480 --> 00:26:53.260
You build it and they link together and there's sort of a build the Delta only type of thing.

00:26:53.260 --> 00:27:00.820
Whereas in Python, you kind of need to bring on a little bit more tooling to say, I know it looks like there's some giant Python thing here, but just these two pieces.

00:27:01.420 --> 00:27:11.400
That's what I want to think of as the thing, you know, what we're going to talk about with some of the stuff that you've done with poetry with polyleth and others certainly make that relevant.

00:27:11.400 --> 00:27:14.540
I do want to talk about the Git tools, but it's also interesting.

00:27:14.540 --> 00:27:20.040
This comment from David Poole, it says we use sub modules for legal licensing reasons.

00:27:20.340 --> 00:27:29.500
That is to have GPL code separate from our proprietary code rather than just dropping it in, which obviously has different implications.

00:27:29.500 --> 00:27:31.980
Oh, that was very interesting to learn about.

00:27:31.980 --> 00:27:32.280
Yeah.

00:27:32.280 --> 00:27:32.600
Yeah.

00:27:32.600 --> 00:27:36.540
I hadn't really thought about that either, but yes, you definitely want to think about it.

00:27:36.540 --> 00:27:38.800
So let's just talk Git for a moment.

00:27:38.800 --> 00:27:47.660
Now, one of the big challenges is if we're going to put this all into one giant GitHub repository, which I hinted at, it could get really large.

00:27:48.160 --> 00:27:54.340
Especially if you put binary files, like some of your build tooling or other assets, you might put it in there.

00:27:54.340 --> 00:27:56.500
And then that makes it extra tricky.

00:27:56.500 --> 00:27:59.700
The less something can diff, the more it kind of piles up quick.

00:27:59.700 --> 00:28:03.320
As I was thinking about this thing, I learned about a couple cool ideas.

00:28:03.320 --> 00:28:04.740
Let's talk about this one first.

00:28:04.740 --> 00:28:05.720
Partial clone.

00:28:05.720 --> 00:28:09.660
This is something that was totally new to me.

00:28:09.820 --> 00:28:14.960
So normally it's Git clone the URL to the Git repository.

00:28:14.960 --> 00:28:21.460
However, you can say things like filter, --filter equals blob.

00:28:21.460 --> 00:28:22.580
Have you seen this before, David?

00:28:22.580 --> 00:28:24.880
No, this is totally new to me.

00:28:24.880 --> 00:28:27.260
So, but it looks really interesting.

00:28:27.540 --> 00:28:33.160
Yeah, so what happens here is if you, the blob is like a binary file, right?

00:28:33.160 --> 00:28:39.080
And what you're saying when you say filter blob is it'll check out all of the Git history.

00:28:39.080 --> 00:28:43.740
And normally when you do a clone, you get, at least for the branch you're on, you get every

00:28:43.740 --> 00:28:44.640
version of the file.

00:28:44.640 --> 00:28:48.400
So you get clone, you disconnect from the network and you've got everything, right?

00:28:48.400 --> 00:28:49.780
Which is the beauty of Git.

00:28:50.000 --> 00:28:55.640
But if you've got a really huge repository, it also might be the drawback of Git.

00:28:55.640 --> 00:29:00.220
So you can filter out these blobs in the historical sense.

00:29:00.220 --> 00:29:06.240
And if you say this, what you see in your hard drive for the working directory is identical.

00:29:06.240 --> 00:29:12.800
But the .git folder with the history only has the working version, not all copies of the

00:29:12.800 --> 00:29:13.880
history of the blob.

00:29:13.880 --> 00:29:16.100
This has like a really huge effect.

00:29:16.100 --> 00:29:19.660
So I did this on Talk Python training, my courses website.

00:29:19.660 --> 00:29:26.620
And if I just say git clone, the repo, it pulled down 118,000 objects.

00:29:26.620 --> 00:29:32.380
It resolved 71,000 deltas and it updated 10,000 files and it was a gig on disk.

00:29:32.380 --> 00:29:38.300
If I just say filter, --filter equals blob colon none, it goes from 118,000 to 10,000

00:29:38.300 --> 00:29:39.600
downloads.

00:29:39.600 --> 00:29:42.900
It goes, it's less than half the size.

00:29:42.900 --> 00:29:49.620
And the resulting files on disks, those were the same, but the intermediate deltas were

00:29:49.620 --> 00:29:52.840
like 170th or 150th.

00:29:52.840 --> 00:29:54.980
Really a big difference.

00:29:54.980 --> 00:29:59.380
And this is, you know, it's a pretty old repo.

00:29:59.380 --> 00:30:00.200
It's got a lot of stuff.

00:30:00.200 --> 00:30:01.940
It's nothing compared to what a lot of people have.

00:30:01.940 --> 00:30:06.820
So one, there's one problem where like, okay, if I'm going to try to git clone a mono repo,

00:30:06.820 --> 00:30:08.620
there's just no way.

00:30:08.620 --> 00:30:09.120
Right?

00:30:09.260 --> 00:30:12.820
So adding this aspect here, I think actually would be really valuable.

00:30:12.820 --> 00:30:13.760
Yeah, definitely.

00:30:13.760 --> 00:30:20.240
because it's, I guess in the normal, the use case is that you want to work with the latest

00:30:20.240 --> 00:30:21.740
version of the source code.

00:30:21.740 --> 00:30:23.260
You want to develop something new.

00:30:23.260 --> 00:30:26.500
So I guess that's what you want on disk.

00:30:27.460 --> 00:30:28.760
It makes a lot of time.

00:30:28.760 --> 00:30:34.320
And what happens is if you say, well, actually we need to switch branches or we need to go

00:30:34.320 --> 00:30:36.180
back three months in time.

00:30:36.180 --> 00:30:39.560
It just goes back to the network and clones a little bit more.

00:30:39.560 --> 00:30:42.100
It's like an incremental clone as it needs it.

00:30:42.480 --> 00:30:46.600
So I think actually this, this would help a lot of people who don't know about it, working

00:30:46.600 --> 00:30:51.320
with mono repos that turn out to have a lot of files and a lot of historical, especially

00:30:51.320 --> 00:30:52.620
binaries that grow over time.

00:30:52.620 --> 00:30:52.960
Yeah.

00:30:52.960 --> 00:30:56.360
Because those are the ones that are huge, you know, it's not the text files usually that

00:30:56.360 --> 00:30:56.940
are the problem.

00:30:56.940 --> 00:30:58.240
So I have to bookmark this.

00:30:58.240 --> 00:31:00.120
Yeah, yeah, yeah.

00:31:00.120 --> 00:31:06.240
This portion of Talk Python to Me is brought to you by Brilliant.org.

00:31:06.240 --> 00:31:09.220
You are a curious person who loves to learn about technology.

00:31:09.220 --> 00:31:11.160
I know because you're listening to my show.

00:31:11.600 --> 00:31:15.900
That's why you would also be interested in this episode's sponsor, Brilliant.org.

00:31:15.900 --> 00:31:19.040
Brilliant.org is entertaining, engaging, and effective.

00:31:19.040 --> 00:31:23.980
If you're like me and feel that binging yet another sitcom series is kind of missing out

00:31:23.980 --> 00:31:28.400
on life, then how about spending 30 minutes a day getting better at programming or deepening

00:31:28.400 --> 00:31:33.060
your knowledge and foundations of topics you've always wanted to learn better, like chemistry

00:31:33.060 --> 00:31:34.800
or biology over on Brilliant.

00:31:34.800 --> 00:31:41.240
Brilliant has thousands of lessons from foundational and advanced math to data science, algorithms,

00:31:41.520 --> 00:31:44.260
neural networks, and more with new lessons added monthly.

00:31:44.260 --> 00:31:48.540
When you sign up for a free trial, they ask a couple of questions about what you're interested

00:31:48.540 --> 00:31:50.260
in as well as your background knowledge.

00:31:50.260 --> 00:31:53.960
Then you're presented with a cool learning path to get you started right where you should

00:31:53.960 --> 00:31:54.160
be.

00:31:54.160 --> 00:31:57.220
Personally, I'm going back to some science foundations.

00:31:57.220 --> 00:32:00.620
I love chemistry and physics, but haven't touched them for 20 years.

00:32:01.160 --> 00:32:07.320
So I'm looking forward to playing with PV equals NRT, you know, the ideal gas law, and all the

00:32:07.320 --> 00:32:08.640
other foundations of our world.

00:32:08.640 --> 00:32:14.160
With Brilliant, you'll get hands-on on a whole universe of concepts in math, science, computer

00:32:14.160 --> 00:32:18.140
science, and solve fun problems while growing your critical thinking skills.

00:32:18.280 --> 00:32:20.780
Of course, you could just visit brilliant.org directly.

00:32:20.780 --> 00:32:22.740
Its URL is right there in the name, isn't it?

00:32:22.740 --> 00:32:25.540
But please use our link because you'll get something extra.

00:32:25.540 --> 00:32:28.560
20% off an annual premium subscription.

00:32:28.560 --> 00:32:33.780
So sign up today at talkpython.fm/brilliant and start a seven-day free trial.

00:32:33.780 --> 00:32:36.080
That's talkpython.fm/brilliant.

00:32:36.080 --> 00:32:38.060
The link is in your podcast player show notes.

00:32:38.060 --> 00:32:40.480
Thank you to brilliant.org for supporting the show.

00:32:43.660 --> 00:32:47.580
Related to that, so quirky ads, wouldn't a shallow clone be more predictable?

00:32:47.580 --> 00:32:49.560
So this is also interesting.

00:32:49.560 --> 00:32:54.280
So shallow clones is a older way to do this in GitHub.

00:32:54.280 --> 00:33:01.200
The problem is with shallow clones, you don't get the full history and changelog.

00:33:01.200 --> 00:33:06.520
With these partial clones, you have all of the history, commit history and details.

00:33:06.520 --> 00:33:10.060
You just don't have the files and they're incrementally pulled in.

00:33:10.060 --> 00:33:11.580
So you could do a shallow clone.

00:33:11.580 --> 00:33:15.240
And then there's another one, what was it called?

00:33:15.240 --> 00:33:17.440
A sparse clone.

00:33:17.440 --> 00:33:24.140
So a sparse clone is another tool that you can bring in here for advanced Git usage, where

00:33:24.140 --> 00:33:29.800
you say, I know I've got this huge directory structure, but I just want to get these three

00:33:29.800 --> 00:33:33.560
directories or this subdirectory structure.

00:33:33.560 --> 00:33:37.360
And you clone only part of the files, right?

00:33:37.360 --> 00:33:41.740
So we were talking about how Python understands just like the whole thing as one giant project.

00:33:41.740 --> 00:33:43.900
And maybe even you check it out and try to open it.

00:33:43.900 --> 00:33:48.460
Your editor will just say they're indexing, indexing, and autocomplete won't really work

00:33:48.460 --> 00:33:50.460
and very well and go crazy.

00:33:50.460 --> 00:33:55.700
So you can just say, I want these three directories and I want them partially cloned.

00:33:55.700 --> 00:33:59.360
So they only have like the recent history and they're not so insane.

00:33:59.360 --> 00:34:05.520
And you can kind of combine these to get really focused views into a monorepo, which I thought

00:34:05.520 --> 00:34:06.400
was pretty interesting.

00:34:06.400 --> 00:34:07.100
Yeah.

00:34:07.340 --> 00:34:14.060
So anyway, when I think back to the story you told about how you guys were using submodules,

00:34:14.060 --> 00:34:20.240
I kind of feel like these partial clones plus sparse clones might be a better fit than trying

00:34:20.240 --> 00:34:22.660
to, you know, symlink things together.

00:34:22.660 --> 00:34:25.640
Because it really just is the same thing.

00:34:25.640 --> 00:34:26.840
If you want to clone the whole thing, you do.

00:34:26.840 --> 00:34:30.300
But then you can kind of just, as you clone it, filter out.

00:34:30.580 --> 00:34:34.360
And you can also, with those sparse clones, you can retroactively add in.

00:34:34.360 --> 00:34:35.700
You go, oh, I also need that directory.

00:34:35.700 --> 00:34:37.680
You can say like, get sparse ad.

00:34:37.680 --> 00:34:38.600
Oh, cool.

00:34:38.600 --> 00:34:40.660
This now needs to be this piece to come in as well.

00:34:40.660 --> 00:34:42.940
And there's some interesting ways to put these together.

00:34:42.940 --> 00:34:46.840
So I think these tools are going to be, for people who are working with monorepos, I think

00:34:46.840 --> 00:34:51.140
those advanced Git features that I called out might be really helpful.

00:34:51.140 --> 00:34:52.160
What do you think, David?

00:34:52.160 --> 00:34:53.260
Yeah, I totally agree.

00:34:53.260 --> 00:34:57.080
Especially when you have a monorepo that is a lot of code.

00:34:57.080 --> 00:35:03.560
So it seems like this is, you wouldn't live with, want to live without it, I guess.

00:35:03.560 --> 00:35:05.720
Because it's probably not helpful.

00:35:05.720 --> 00:35:06.940
Yeah, I think so too.

00:35:06.940 --> 00:35:10.540
So sparse checkout, I believe, is actually the first.

00:35:10.540 --> 00:35:10.780
Sparse checkout.

00:35:10.780 --> 00:35:11.120
Okay.

00:35:11.120 --> 00:35:13.680
I think sparse checkout is the term.

00:35:13.680 --> 00:35:14.820
I'll link to it as well.

00:35:14.820 --> 00:35:16.380
It's partial clone and sparse checkout.

00:35:16.380 --> 00:35:16.860
There we go.

00:35:16.860 --> 00:35:18.020
Nice.

00:35:18.020 --> 00:35:18.620
Okay.

00:35:18.620 --> 00:35:22.860
There's so many good features in Git that I guess most of us don't use.

00:35:22.860 --> 00:35:23.200
Yeah.

00:35:23.200 --> 00:35:24.320
I think so too.

00:35:24.320 --> 00:35:29.540
Like I've been doing Git for a really long time and this sparse checkout is completely

00:35:29.540 --> 00:35:30.580
new to me.

00:35:30.580 --> 00:35:34.360
I only learned about it because I was trying to research a little bit more of some like,

00:35:34.360 --> 00:35:38.460
well, how do you do actually manage with these monorepos as we are preparing for our chat

00:35:38.460 --> 00:35:38.780
today?

00:35:38.780 --> 00:35:45.000
So yeah, I think there's a lot of tools and flexibility that are not obvious or not apparent

00:35:45.000 --> 00:35:48.840
that people can use to make monorepos work really, really well.

00:35:49.360 --> 00:35:53.620
There's still a lot of interesting ways to structure your code and put it together and

00:35:53.620 --> 00:35:55.260
use it once you get it checked out.

00:35:55.260 --> 00:35:59.060
So maybe let's, what do you want to start?

00:35:59.060 --> 00:36:00.840
You want to start with a fresh take on monorepos?

00:36:00.840 --> 00:36:02.060
This is one of your articles.

00:36:02.060 --> 00:36:02.600
Yeah.

00:36:02.600 --> 00:36:02.920
Yeah.

00:36:02.920 --> 00:36:03.340
Why not?

00:36:03.340 --> 00:36:03.640
Yeah.

00:36:03.640 --> 00:36:03.860
Yeah.

00:36:03.860 --> 00:36:05.160
So tell us the story here.

00:36:05.160 --> 00:36:09.080
I wrote this article about a year ago, almost a year ago.

00:36:09.360 --> 00:36:15.960
Before that, I was trying to figure out how to work and have this nice developer experience

00:36:15.960 --> 00:36:17.280
in a monorepos.

00:36:17.280 --> 00:36:24.700
And coming from closure and having learned new things and have some new fresh ideas on how

00:36:24.700 --> 00:36:30.480
you can solve things, I wanted to give it a try in Python too.

00:36:31.300 --> 00:36:38.580
And also at the same time, I was actually doing work with microservices, but in several

00:36:38.580 --> 00:36:39.120
repos.

00:36:39.120 --> 00:36:45.220
And I kind of found myself, there was not a huge thing, but it was like a logger, sort

00:36:45.220 --> 00:36:47.840
of a logger module or a package.

00:36:48.020 --> 00:36:54.680
I knew that I had done it in the other microservice just a couple of weeks ago.

00:36:54.680 --> 00:36:56.420
So, okay, what should I do?

00:36:56.420 --> 00:36:57.600
Should I create a library?

00:36:57.600 --> 00:37:00.280
No, this is way too small to create a library.

00:37:00.280 --> 00:37:03.260
And it wasn't even open source.

00:37:03.260 --> 00:37:06.180
It's like a proprietary system.

00:37:06.180 --> 00:37:12.240
So when you would need a lot of private repo servers, things like that.

00:37:12.240 --> 00:37:14.320
So I just ended up in copying some code.

00:37:14.320 --> 00:37:17.640
And, you know, while people would go, of course, you should never do that.

00:37:17.640 --> 00:37:23.040
But sometimes it's just not complicated enough or important enough or big enough to justify

00:37:23.040 --> 00:37:26.280
all the change management and dependencies.

00:37:26.280 --> 00:37:27.600
And you know what?

00:37:27.600 --> 00:37:29.580
That file, it goes into this project.

00:37:29.580 --> 00:37:35.580
And usually it's fine until they get out of sync or there's some weird, you want to upgrade

00:37:35.580 --> 00:37:37.760
one and then, oh, where else is it, right?

00:37:37.760 --> 00:37:44.400
Or you discover a bug in that part and you forget about that you have copied it a couple of times

00:37:44.400 --> 00:37:45.300
and now with the other repo.

00:37:45.300 --> 00:37:47.800
So then you have a lot of work to do.

00:37:47.800 --> 00:37:56.180
There's probably a whole section of cybersecurity history and like breaches where they thought they fixed a problem in some system.

00:37:56.180 --> 00:37:56.460
Yeah.

00:37:56.500 --> 00:38:00.260
And it turns out someone else found a copy of it that wasn't fixed and broken.

00:38:00.260 --> 00:38:02.320
And yes, this is not ideal.

00:38:02.320 --> 00:38:10.200
I really wanted to give the polyleth in Python a try because I really enjoyed the way things are structured

00:38:10.200 --> 00:38:15.060
and a lot of these like headaches are solved there.

00:38:15.060 --> 00:38:17.400
Polyleth is really, really new to me.

00:38:17.400 --> 00:38:21.800
Maybe tell people about polyleth before we go on because I suspect a lot of people don't know about this.

00:38:21.800 --> 00:38:22.740
Yeah, maybe we should begin.

00:38:22.740 --> 00:38:23.760
Yeah, let's begin there.

00:38:23.760 --> 00:38:24.540
Then we'll come back to it.

00:38:24.540 --> 00:38:31.540
Well, polyleth, it's an architecture, but it's also a tool or something with a tooling support.

00:38:31.940 --> 00:38:37.880
And it's open source and it's developed by a fellow Swede, Joachim Tengstrand.

00:38:37.880 --> 00:38:43.680
And I was fortunate to actually work in the same team as him.

00:38:43.680 --> 00:38:46.740
So he was done introducing this.

00:38:46.740 --> 00:38:49.040
We decided to give it a try.

00:38:49.040 --> 00:38:50.340
He was new in our team.

00:38:51.340 --> 00:39:02.380
And I have to confess, I was a little bit skeptical at the beginning because skeptical of monorepos in general too, because based on previous bad experiences.

00:39:03.080 --> 00:39:12.860
So the polyleth is the main idea is that you have, when you write code, you're supposed to, you aim to write them in small parts.

00:39:12.860 --> 00:39:15.700
And that's what polyleth called components.

00:39:15.700 --> 00:39:21.100
And a component, polyleth uses the idea of Lego, but for code.

00:39:21.240 --> 00:39:28.620
So a component could be a piece, a Lego brick that you can reuse in several ways.

00:39:28.620 --> 00:39:41.180
And a component can be everything from a small tech, something that you normally would put in a utils folder, like functions that do maybe some parsing or something.

00:39:41.180 --> 00:39:44.700
But it can also be a combination of other components.

00:39:44.700 --> 00:39:46.740
They don't have to be of the same size.

00:39:46.740 --> 00:39:52.660
It's the idea of composability and reusability that is the important thing.

00:39:52.660 --> 00:39:57.760
So the big parts of polyleth are our components.

00:39:57.760 --> 00:40:00.280
And then we have something called bases.

00:40:00.280 --> 00:40:06.060
And that is also a component, but a kind of special kind of component.

00:40:06.060 --> 00:40:15.080
If you think about Lego, if you're going to build like a house, you often have a base plate where you put your Lego bricks on it.

00:40:15.080 --> 00:40:17.780
So a base is sort of that part.

00:40:17.780 --> 00:40:28.120
And in code, that could be like, if you have like a FastAPI app, maybe a base plate could be where you define the endpoints.

00:40:28.120 --> 00:40:33.600
Like you use the API decorator side or something like that.

00:40:33.600 --> 00:40:35.720
So that could be a base.

00:40:35.720 --> 00:40:42.240
And then the code that actually does something could be a combination of different components.

00:40:42.240 --> 00:40:44.260
Yeah, that's an interesting way to think of it.

00:40:44.260 --> 00:40:47.740
Whenever you talk about stuff, what are the things that's difficult as to understand?

00:40:47.740 --> 00:40:50.740
What is the scale or how are these different?

00:40:50.740 --> 00:41:04.200
So one way, well, our functions components, our modules components, our packages components, like, how do I identify that since it's not a formal language runtime term?

00:41:04.200 --> 00:41:32.720
Yeah. That's really, really good. Help me understand how I make these things in Python. Yeah. Yeah. That's really interesting. Because you can see a component. It's not a full blown feature, like maybe a library that you publish in on PyPy would be. It's smaller than that. And I guess it could be a single function. But it's probably one or more functions that kind of relates to it. Let's say that you...

00:41:32.720 --> 00:41:52.720
And what should I have prepared with an example, but let's say that you want to parse a CSV file or something, then you would probably separate the different things you want to do with that CSV file into functions already.

00:41:52.880 --> 00:42:02.800
And the component is where you kind of group the functions that kind of relate to each other or that make sense to have in a Python package.

00:42:02.800 --> 00:42:05.560
Then I mean a namespace with a dunder in it.

00:42:05.560 --> 00:42:07.220
So that could be a component.

00:42:07.220 --> 00:42:07.780
Yeah.

00:42:07.780 --> 00:42:11.160
Although it could be modeled in one of these sub packages.

00:42:11.160 --> 00:42:18.680
Those sub packages often have multiple jobs and roles and you're like, let's stay really focused on the one thing that it does, right?

00:42:18.680 --> 00:42:19.060
Yeah.

00:42:19.060 --> 00:42:23.280
And all of this lives in what Polylyph calls a workspace.

00:42:23.280 --> 00:42:35.040
And that is basically a repository with a configuration about how your repository looks like.

00:42:35.040 --> 00:42:39.560
So you have your components in namespace packages, basically.

00:42:39.560 --> 00:42:43.820
And you have your basis, the entry points of your apps.

00:42:43.960 --> 00:42:47.720
Then you have something called projects or a project.

00:42:47.720 --> 00:42:52.040
And that is the artifacts or artifacts that you want to build.

00:42:52.040 --> 00:42:58.780
So you can have only one project if you're going to build one thing, maybe a FastAPI service.

00:42:59.020 --> 00:43:03.240
But the benefit comes when you are about to build something new.

00:43:03.240 --> 00:43:14.080
Then you have your project infrastructure, like the project configuration and what it is defined in a folder called projects.

00:43:14.880 --> 00:43:19.720
And then with the code you use, you pick the code from the components and bases folder.

00:43:19.720 --> 00:43:23.260
So you will reuse the same source code.

00:43:23.260 --> 00:43:25.680
And then you package it into different artifacts.

00:43:26.160 --> 00:43:30.600
So it sounds a little bit like we've got this monorepo with all of this stuff.

00:43:30.600 --> 00:43:38.760
And the polylyph, its job is to say, well, we're going to look into these little parts of this monolith.

00:43:38.760 --> 00:43:40.580
And I need this part and this part and this part.

00:43:40.580 --> 00:43:47.800
And it's some tooling and some concepts to help you manage some artifact.

00:43:47.800 --> 00:43:54.680
We don't usually have exact build artifacts often if you're not shipping out separate packages.

00:43:54.680 --> 00:44:00.460
But maybe these three pieces here make up the FastAPI service that we're going to host over there.

00:44:00.460 --> 00:44:06.700
And maybe these two services make up the data science tools we're going to give to the data scientists for their notebooks.

00:44:06.700 --> 00:44:09.680
And there could be some overlap in those, right?

00:44:09.680 --> 00:44:10.480
Yeah, exactly.

00:44:10.480 --> 00:44:10.860
Yeah.

00:44:10.860 --> 00:44:11.160
Okay.

00:44:11.160 --> 00:44:20.800
And another good thing is with the workspace is that you don't really do much work in the project folder or something like that.

00:44:20.800 --> 00:44:29.800
Because the main idea is that you have a development environment that includes all your bases, all your components.

00:44:29.800 --> 00:44:39.380
So the good thing with that is that you can experiment and try out code without worrying about if you have imported the correct stuff.

00:44:39.540 --> 00:44:45.460
So you just, you have a top project folder containing all of your dependencies and packages.

00:44:45.460 --> 00:44:48.020
And then you can take it from there.

00:44:48.020 --> 00:44:58.700
Once you're ready to build a project, build something out of it, an app or whatever it is, then you can start constructing that project-specific configuration.

00:44:58.700 --> 00:45:00.820
You can choose where you want to start.

00:45:00.900 --> 00:45:04.000
But I usually start from the development workspace.

00:45:04.000 --> 00:45:08.560
And I really like a way of working called REPL-driven development.

00:45:08.560 --> 00:45:12.740
But I also learned from Closure, which is they try out things in the REPL, basically.

00:45:12.740 --> 00:45:13.160
Yeah.

00:45:13.160 --> 00:45:19.280
That's a really nice developer experience that you get from having the entire source code.

00:45:19.280 --> 00:45:23.540
You can try out things, combine components, and develop new features.

00:45:23.540 --> 00:45:23.860
Yeah.

00:45:23.860 --> 00:45:27.080
I'm doing more and more of that as well, this REPL-driven development.

00:45:27.460 --> 00:45:30.540
Or I'd say not necessarily development, but exploration.

00:45:30.540 --> 00:45:32.180
I kind of want to understand.

00:45:32.180 --> 00:45:33.440
I'm not really sure.

00:45:33.440 --> 00:45:35.080
Is this going to click together right?

00:45:35.080 --> 00:45:42.620
Or is this, rather than putting a lot of structure in place, because I'm not even sure I really want to stick with it, fire up a REPL.

00:45:42.620 --> 00:45:47.500
For those of you who don't know, if you just type Python, what you get, redevelop print loop, that's the REPL.

00:45:47.500 --> 00:45:55.040
I do it in PyCharm these days, because PyCharm has a Python console, but it gives you autocomplete and tab completion.

00:45:55.240 --> 00:46:00.960
Like, of the things that are in your project when you're playing in the REPL, but, you know, still, same idea.

00:46:00.960 --> 00:46:01.920
Yeah, that's really great.

00:46:01.920 --> 00:46:02.940
Yeah, yeah, absolutely.

00:46:02.940 --> 00:46:06.880
So are you guys using this on your projects right now?

00:46:06.880 --> 00:46:08.960
Or what do you do with it these days?

00:46:08.960 --> 00:46:11.440
Yeah, I'm fairly new to the team that I join.

00:46:11.440 --> 00:46:17.160
So I've introduced them to the ideas, but they have, like, already code and stuff in place.

00:46:17.160 --> 00:46:28.660
So my hopes are that we will give it, once we have something new to develop or include an existing microservice, maybe we could give this idea a try.

00:46:28.660 --> 00:46:31.220
So that's basically because I'm coming.

00:46:31.420 --> 00:46:37.960
Yeah, that's always the problem is, even if you yourself are not new, the ideas may be new to you, and you've done a bunch of previous work.

00:46:37.960 --> 00:46:40.640
Like, for me, I was showing you that repo before.

00:46:40.640 --> 00:46:50.100
I'm just, I'm thinking, there's a lot of cool stuff I could do about how I restructure this and reuse it and make it available, you know, sort of bring more of the mono repo stuff to some of the things I'm doing.

00:46:50.100 --> 00:46:59.800
I'm like, then I got to update the continuous deployment changes, and I've got to update where the web server, I'm just like, you know, it's just like, there's all this stuff that's there.

00:46:59.800 --> 00:47:06.680
And it's, you know, do you kind of pause what you're doing to try some new big organization of code here?

00:47:06.680 --> 00:47:07.800
That's how it goes, right?

00:47:07.800 --> 00:47:09.400
We still learned the polylet.

00:47:09.400 --> 00:47:11.680
That's where we actually used it in production.

00:47:11.680 --> 00:47:18.760
We had several kinds of different services and apps where we had everything in a polylet, not a repo.

00:47:18.760 --> 00:47:19.600
But that was Clojure.

00:47:19.740 --> 00:47:22.920
And Clojure is a compiled language, like C++ or C#.

00:47:22.920 --> 00:47:23.900
Is that right?

00:47:23.900 --> 00:47:26.580
Yeah, it's on top of the JVM.

00:47:26.580 --> 00:47:31.000
So that is compiled through that engine.

00:47:31.000 --> 00:47:43.540
Yeah, I do feel like things are just a little, the deliverable artifacts are slightly more obvious and easy to distinguish when you're talking about something that compiles.

00:47:43.540 --> 00:47:49.220
And like, here's the library that drops into the bin folder, and here's the executable binary that drops.

00:47:49.380 --> 00:47:53.440
You know, there's an output folder that has all the pieces that were selected.

00:47:53.440 --> 00:47:56.880
Whereas Python, you've got to be a little more careful how you put that together.

00:47:57.220 --> 00:48:03.280
So what I came up to was how can this idea be used in Python?

00:48:03.280 --> 00:48:09.660
And then that was actually what led me to poetry, which I think is a really nice tool.

00:48:09.660 --> 00:48:18.960
Well, because poetry, I think it's a lot of nice ways of handling projects and dependencies and structure and stuff like that.

00:48:18.960 --> 00:48:23.460
There were a couple of things missing to make this idea work.

00:48:23.460 --> 00:48:30.720
Because when you have a project configuration, you actually include components from a relative path.

00:48:30.720 --> 00:48:34.840
So you navigate up and navigate down to the actual component.

00:48:34.840 --> 00:48:42.620
And if you would just build a wheel or a source distribution from that, that wouldn't be a valid package.

00:48:42.620 --> 00:48:47.500
Because then you would need to ship the entire monorepo structure.

00:48:47.500 --> 00:48:49.360
And you don't want to do that.

00:48:49.900 --> 00:48:56.700
So what I did was I developed a plugin to poetry that actually allows for having relative includes.

00:48:57.340 --> 00:49:00.260
And that will build the code.

00:49:00.260 --> 00:49:05.880
That will build a wheel and a source distribution with the kind of correct path.

00:49:05.880 --> 00:49:13.180
So it takes all the package dependencies and puts them in the same folder, basically, before it does the wheel.

00:49:13.180 --> 00:49:16.900
And then you have a valid distribution that you can use.

00:49:16.900 --> 00:49:21.140
So it does a little bit of copying and stuff like that.

00:49:21.140 --> 00:49:21.740
All right.

00:49:21.800 --> 00:49:29.260
So the actual output here, it's a couple of wheels that we could say pip install into a virtual environment.

00:49:29.260 --> 00:49:30.400
And they work together.

00:49:30.400 --> 00:49:30.880
Is that right?

00:49:30.880 --> 00:49:31.180
Yeah.

00:49:31.180 --> 00:49:31.540
Okay.

00:49:31.540 --> 00:49:37.140
Try this idea with like services, like FastAPI services.

00:49:37.140 --> 00:49:47.520
Instead of including the source code like as a tree, installing it with pip from a wheel or a source distribution.

00:49:47.920 --> 00:49:53.220
Preferably be from a wheel if you don't have any like operating system specific stuff.

00:49:53.220 --> 00:49:55.220
So I think that works really.

00:49:55.220 --> 00:49:57.600
And it's the end result.

00:49:57.600 --> 00:50:03.280
If you do it in a Docker container, you can like have the full control of what's in there.

00:50:03.280 --> 00:50:03.760
Yeah.

00:50:03.760 --> 00:50:14.960
So in your Docker file that builds the Docker image, you can just say, you know, copy these three wheels over, pip install them into my Python environment I have over there.

00:50:14.960 --> 00:50:20.380
And it's just taken the, what do you call them, workspaces that you need over there.

00:50:20.380 --> 00:50:23.220
What is the terminology that you call the artifacts here?

00:50:23.220 --> 00:50:28.380
I mean, I know they're wheels and packages, but is there a polyleth term that matches over here?

00:50:28.380 --> 00:50:30.320
Oh, I don't think so.

00:50:30.320 --> 00:50:33.780
Maybe it's like a built artifact perhaps.

00:50:34.140 --> 00:50:35.140
Yeah.

00:50:35.140 --> 00:50:46.940
And it's probably the most simplistic scenario is that you have like an app, like an API endpoint or maybe a CLI app or even a library.

00:50:46.940 --> 00:50:53.220
And you probably want to install them in different places, maybe even on AWS Lambda.

00:50:53.220 --> 00:51:04.240
So you can have the control over the deployment in your CI saying that I want to deploy this Lambda here and I want to deploy this FastAPI over there.

00:51:04.240 --> 00:51:08.460
So, and with polyleth, you can build these wheels differently.

00:51:08.460 --> 00:51:08.900
Nice.

00:51:08.900 --> 00:51:09.340
Yeah.

00:51:09.340 --> 00:51:21.340
I feel like the, if you think of microservices and monolith, the AWS Lambda or any serverless functions as a service story is like the most extreme version of this.

00:51:21.340 --> 00:51:21.600
Yeah.

00:51:21.600 --> 00:51:23.320
Here's a single function that gets deployed.

00:51:23.320 --> 00:51:27.160
Here's a single function that gets deployed, like just one after another, right?

00:51:27.180 --> 00:51:29.040
It's kind of out of control.

00:51:29.040 --> 00:51:32.340
And you have all of them in separate repositories.

00:51:32.340 --> 00:51:33.300
Oh, please.

00:51:33.300 --> 00:51:33.580
No.

00:51:33.580 --> 00:51:34.160
Yes.

00:51:34.160 --> 00:51:35.800
That would be definitely tricky.

00:51:35.800 --> 00:51:39.120
I want to come back and talk more about this poetry plugin because it's really cool.

00:51:39.120 --> 00:51:41.660
But let's address this question from Lucas here.

00:51:41.660 --> 00:51:50.160
How would you approach versioning in a monorepo, like of these different services and of the different pieces?

00:51:50.160 --> 00:51:56.140
So if I'm going to have that FastAPI thing that builds over there, I'm going to have some other projects that are built

00:51:56.140 --> 00:52:00.220
with some overlap that are shared over to, say, my data science team.

00:52:00.220 --> 00:52:04.260
They're going to analyze data in some other way, but reuse some of the code.

00:52:04.260 --> 00:52:09.840
I've got some thoughts, but what are your thoughts on versioning, say, in the repository or how you deploy them?

00:52:09.840 --> 00:52:11.460
Yeah, that's a really good question.

00:52:11.460 --> 00:52:18.620
If I'm looking at it from a polyleth perspective, I would suggest a very simplistic solution.

00:52:18.800 --> 00:52:27.160
Let's say that you have your this project depends on something with this version and the other project is still on an earlier version.

00:52:27.360 --> 00:52:36.100
And I think that can be solved with the components itself because all source code is made up of all these components.

00:52:36.100 --> 00:52:45.720
So if you're going to build a new version of something and if that version uses a new third-party dependency or that is incompatible,

00:52:45.840 --> 00:52:50.500
I would suggest you to add it as a new separate component.

00:52:50.500 --> 00:52:57.100
So your new projects that will use that one will pick that component instead of the old.

00:52:57.100 --> 00:53:05.240
I think it's a good practice if these components have the same or as long as it's possible, the same API.

00:53:05.240 --> 00:53:10.140
So it should be easy to switch from the old to the new one.

00:53:10.140 --> 00:53:16.240
So that would be my solution to versioning, at least when using polyleth.

00:53:16.240 --> 00:53:22.360
If we look at not the monorepo style, but you build an artifact like a wheel from one repo

00:53:22.360 --> 00:53:30.080
and you put it up there and someone else depends upon that, maybe through an internal artifact management, private PYPI,

00:53:30.080 --> 00:53:34.800
you would pin your version in the requirements file for that other one, right?

00:53:34.800 --> 00:53:41.680
Because that repo is changing at a different rate and a different cadence than maybe the library that it depends upon.

00:53:41.680 --> 00:53:49.560
And that's really natural for us as Python people because we already have a great long list of things that are open source

00:53:49.560 --> 00:53:56.320
that we don't build that we depend on, right? FastAPI, Pydantic, and Starlette would be an example from what we've been talking, right?

00:53:56.320 --> 00:53:59.080
Those things you don't control and you depend on them.

00:53:59.080 --> 00:54:01.840
So you pin the versions and upgrade them as you see fit.

00:54:01.840 --> 00:54:08.980
But one of the advantages of the monorepo to me, as far as I see it at least, is the whole system,

00:54:08.980 --> 00:54:15.860
not just your part of the system, but the whole system is consistent all the time.

00:54:15.860 --> 00:54:20.100
The main branch or the production branch or whatever the shipping branch is.

00:54:20.100 --> 00:54:25.120
So I think you would maybe branch, do some of your work, merge that back in.

00:54:25.120 --> 00:54:29.380
And at that point, you could ship everything if you need to, right?

00:54:29.380 --> 00:54:29.640
Yeah.

00:54:29.640 --> 00:54:36.720
Because you're continuously keeping it together as a whole system, not like, well, that library built and that library built

00:54:36.720 --> 00:54:40.300
because they're separate repos, but you put them together and who knows what's going to happen.

00:54:40.460 --> 00:54:43.440
I think this is an advantage of the monorepo in a sense.

00:54:43.440 --> 00:54:44.040
Yeah, me too.

00:54:44.040 --> 00:54:44.760
Definitely.

00:54:44.760 --> 00:54:51.680
I think it makes it easier to notice about using some parts of the code.

00:54:51.680 --> 00:54:54.920
It's using a certain version of a dependency.

00:54:54.920 --> 00:55:00.060
You will learn about it quite quickly because if you would install it and try to run the code.

00:55:00.180 --> 00:55:04.720
it's easier to note, and hopefully it's easier to also update that code.

00:55:04.720 --> 00:55:09.140
But if you are in a situation where there's so much code that you need to refactor,

00:55:09.140 --> 00:55:16.240
maybe there's a breaking change that kind of has rethought the entire idea of that happens.

00:55:16.240 --> 00:55:22.780
Maybe you need to do some sort of separation and keep the oldest until you have the time to refactor that.

00:55:23.040 --> 00:55:28.880
I guess in most cases, it's pretty straightforward to update just everything in the monorepo.

00:55:28.880 --> 00:55:29.800
Right. Yeah, exactly.

00:55:29.800 --> 00:55:34.400
And if you've got some sort of continuous integration or some kind of automated check,

00:55:34.400 --> 00:55:39.500
you're going to find out pretty quickly this change you made has a consequence over there.

00:55:39.500 --> 00:55:45.440
And I think that's why people who are psyched about monorepos are excited about it.

00:55:45.900 --> 00:55:51.860
It also feels to me like if there was going to be a breaking change, it's going to happen either way.

00:55:51.860 --> 00:55:56.860
It's just, is it going to happen in small little pieces or is it going to happen in one terrible, huge,

00:55:56.860 --> 00:55:58.420
oh, you got the new one?

00:55:58.420 --> 00:56:00.400
Well, let me tell you, the new one's really different.

00:56:00.400 --> 00:56:01.380
It doesn't work anymore.

00:56:01.380 --> 00:56:02.080
Like, oh no.

00:56:02.080 --> 00:56:08.600
You know, just like you want to merge more often or you want to try to integrate things more often

00:56:08.600 --> 00:56:12.180
and not just wait some long period of time and go, now do they go together?

00:56:12.840 --> 00:56:16.040
Why are there a hundred or a thousand, you know, merge conflicts?

00:56:16.040 --> 00:56:16.960
I don't know, right?

00:56:16.960 --> 00:56:25.140
Like the more you do these little continuous checkbacks and integrations, it's just going to be so much easier.

00:56:25.140 --> 00:56:25.760
Oh yeah.

00:56:25.760 --> 00:56:26.800
Totally agree.

00:56:26.800 --> 00:56:27.160
Yeah.

00:56:27.160 --> 00:56:34.560
I mean, the only scenario where you don't have to go back and pay that penalty is where the other service

00:56:34.560 --> 00:56:39.120
that you're versioning against says, we're never going to go to the new version.

00:56:39.120 --> 00:56:43.600
And if this is internal code, it's unlikely that it's never going to go to the new version

00:56:43.600 --> 00:56:45.020
unless it becomes just dead.

00:56:45.020 --> 00:56:45.860
And then who cares?

00:56:45.860 --> 00:56:47.980
You're going to need to integrate them eventually.

00:56:47.980 --> 00:56:50.040
Just keep doing it continuously.

00:56:50.040 --> 00:56:52.960
So yeah, I'm starting to really come around to the idea of these things.

00:56:52.960 --> 00:56:53.320
Yeah.

00:56:53.320 --> 00:56:53.620
Yeah.

00:56:53.620 --> 00:56:58.320
So this polyleth plugin for poetry, it's super cool.

00:56:58.440 --> 00:57:04.560
So for example, here on your example, you say poetry, space poly, space info on the terminal,

00:57:04.560 --> 00:57:05.900
on the command prompt.

00:57:05.900 --> 00:57:10.940
And it'll say, hey, look, in here we have two projects made of two components and two bases,

00:57:10.940 --> 00:57:13.820
the Lambda project and the FastAPI project.

00:57:13.820 --> 00:57:17.400
And they're made up of these different elements.

00:57:17.880 --> 00:57:22.880
And it really shows what part of your code is depending on the other ones.

00:57:22.880 --> 00:57:24.640
It even gives you a pretty table.

00:57:24.640 --> 00:57:25.940
Is this made with rich?

00:57:25.940 --> 00:57:26.940
Yeah.

00:57:26.940 --> 00:57:27.360
Yeah, it's rich.

00:57:27.360 --> 00:57:28.640
I love that tool.

00:57:28.640 --> 00:57:29.780
It's so great.

00:57:29.780 --> 00:57:30.220
Yeah.

00:57:30.220 --> 00:57:32.440
It's been my new favorite tool.

00:57:32.440 --> 00:57:34.720
It's so good.

00:57:34.720 --> 00:57:35.000
Yeah.

00:57:35.000 --> 00:57:38.200
So it's a really nice looking UI that you put together here as well.

00:57:38.200 --> 00:57:38.500
Yeah.

00:57:38.500 --> 00:57:38.860
Thanks.

00:57:38.860 --> 00:57:41.060
I'm really happy to hear that.

00:57:41.060 --> 00:57:42.580
Well, how easy for people to...

00:57:42.580 --> 00:57:42.980
Yeah, go ahead.

00:57:42.980 --> 00:57:43.140
Sorry.

00:57:43.140 --> 00:57:44.100
Don't mean to just talk over you.

00:57:44.100 --> 00:57:51.260
Yeah, I just want to mention that what we see here is the tooling support for the polyleth thing in Python.

00:57:51.260 --> 00:57:53.980
And I decided to make it as a poetry plugin.

00:57:53.980 --> 00:57:59.200
I have some plans to break it out of poetry to make it separate.

00:57:59.200 --> 00:58:01.940
CNI 2, maybe I'll do that in the future.

00:58:01.940 --> 00:58:07.180
But I thought it was a good fit for poetry since I'm relying on a lot of poetry features.

00:58:07.180 --> 00:58:13.120
And the command there, polyinfo, is showing you an overview of your monoree.

00:58:13.120 --> 00:58:16.060
And this is my example project with...

00:58:16.060 --> 00:58:23.620
So it's not a lot of code, but the idea is that you will list all your components and bases.

00:58:23.620 --> 00:58:25.940
The command there for these are bricks.

00:58:25.940 --> 00:58:30.200
Then you get a sort of an overview of what's in that monoree.

00:58:30.200 --> 00:58:33.920
You can sort of get an idea of what's in there.

00:58:33.920 --> 00:58:35.920
What does this thing do?

00:58:35.960 --> 00:58:38.160
And then it's listed per project.

00:58:38.160 --> 00:58:42.840
So you can see which project is actually using which brick.

00:58:42.840 --> 00:58:47.100
Yeah, let me just give a little bit of visual information for people listening.

00:58:47.100 --> 00:58:54.960
So under the brick column, it says we have the logging, we have the messaging, we have the greet API, and we have the messages for Lambda.

00:58:54.960 --> 00:59:02.480
And then you've got, in different columns, the different projects that might be consuming them in little check marks or dashes to say using or not using it.

00:59:02.480 --> 00:59:07.520
It makes it really visually clear how your elements fit together, right?

00:59:07.520 --> 00:59:11.540
I'm continuing adding commands to this tooling.

00:59:11.540 --> 00:59:27.120
There is also, you can use this information, the information about the workspace and the individual project to, in your CI to determine if, let's say that you change the message component, you do something in it.

00:59:27.340 --> 00:59:34.400
And then you would want to have the projects that are affected built for that.

00:59:34.400 --> 00:59:44.380
So the tooling will help your CI to make decisions, should build this project or if it should skip building because nothing has changed.

00:59:44.380 --> 00:59:46.080
So that's part of the tooling to work.

00:59:46.080 --> 00:59:53.800
That's pretty interesting because we've had attempts and they've always been like an awesome 80% solution that never quite works.

00:59:53.800 --> 01:00:04.820
But really good solution, really good tool, ideas, I guess, to say, if you change this code, what actually needs to be tested again or what needs to be analyzed again?

01:00:04.820 --> 01:00:10.120
If this other part of your system doesn't depend on it, you don't need to run those tests, right?

01:00:10.120 --> 01:00:13.760
If just the file changes, that doesn't tell you anything.

01:00:13.760 --> 01:00:16.360
You need to look at things like code coverage.

01:00:16.360 --> 01:00:22.080
What part of the system was touched if this part, you know, by affected by this at all, right?

01:00:22.080 --> 01:00:24.320
Those are always really tricky.

01:00:24.320 --> 01:00:27.920
And how do you keep like a history of code coverage to know what to do?

01:00:27.920 --> 01:00:32.700
And all those attempts I've seen just kind of like, we tried, but we don't really do that.

01:00:32.700 --> 01:00:35.160
We'll just run the files that change, which is never enough.

01:00:35.160 --> 01:00:48.280
But this kind of is a natural way to express dependencies in that tree to say, okay, if we change the greet API, we see that the Lambda thing doesn't work with it.

01:00:48.280 --> 01:00:51.280
So we don't need to test anything to do with the Lambda stuff.

01:00:51.280 --> 01:00:54.000
We only need to test the FastAPI aspect, right?

01:00:54.000 --> 01:00:54.660
Yeah, exactly.

01:00:54.660 --> 01:00:55.940
Is that tooling in place now?

01:00:55.940 --> 01:00:57.060
Yeah, that's in place now.

01:00:57.060 --> 01:00:57.400
Okay.

01:00:57.400 --> 01:01:03.160
The poly info command, I think it was like the first command that I actually added.

01:01:03.160 --> 01:01:04.400
Then there's a...

01:01:04.400 --> 01:01:07.960
diff command and what did I add?

01:01:07.960 --> 01:01:12.900
Yeah, the latest addition to commands is a check command.

01:01:12.900 --> 01:01:15.720
Because since you are...

01:01:15.720 --> 01:01:21.720
I was talking about development experience that you're working at in a development project where you have everything.

01:01:22.280 --> 01:01:24.840
And then you might not touch the project that much.

01:01:24.840 --> 01:01:30.800
And that means that you could potentially forget to include dependencies.

01:01:30.800 --> 01:01:34.540
Because as of today, there's no automatic thing yet.

01:01:34.540 --> 01:01:36.720
I'm planning to add that later.

01:01:36.840 --> 01:01:41.500
But so far, you need to keep track of your dependencies and stuff like that.

01:01:41.540 --> 01:01:48.280
So I added a check command that actually does performance analysis on the source code.

01:01:48.280 --> 01:01:49.040
So if you...

01:01:49.040 --> 01:01:54.180
Let's say that one of the components uses the requests library or something like that.

01:01:54.180 --> 01:01:56.680
And you don't have it in your dependencies.

01:01:56.680 --> 01:02:00.940
Then you would be notified for that particular project.

01:02:00.940 --> 01:02:05.020
It's very likely that you would discover it anyway in your development environment.

01:02:05.020 --> 01:02:11.200
But this is an extra check to just make sure once you're about to build something,

01:02:11.200 --> 01:02:14.200
can I really build this specific project?

01:02:14.200 --> 01:02:20.580
So it's a few commands, but it will be more commands that are more and more useful, I guess.

01:02:20.720 --> 01:02:21.520
Yeah, it looks great.

01:02:21.520 --> 01:02:29.060
And you have some examples over in the Python polyleth examples repository that people can check out.

01:02:29.060 --> 01:02:29.300
Yeah.

01:02:29.300 --> 01:02:29.600
Yeah.

01:02:29.600 --> 01:02:34.440
So is the poetry plugin ready for people if they wanted to use it?

01:02:34.440 --> 01:02:35.040
I think so.

01:02:35.040 --> 01:02:44.440
I know I haven't seen any stats yet, but I have a couple of users that have contacted me through the GitHub repo and social media.

01:02:46.740 --> 01:02:50.900
Maybe some of them are just experimented with it and others have.

01:02:50.900 --> 01:02:55.420
I think they actually are working with it in their daily work.

01:02:55.420 --> 01:02:57.100
And I think it's useful.

01:02:57.100 --> 01:03:06.440
I have to remind myself to contact them regularly to just check out how it goes.

01:03:06.440 --> 01:03:14.220
And hopefully they will come to this repo and let me know if something doesn't work as intended.

01:03:14.220 --> 01:03:21.820
But it's a new tool and I probably need some more work on it, of course.

01:03:21.820 --> 01:03:22.460
Yeah.

01:03:22.460 --> 01:03:24.780
Well, a lot of people will hear about it now.

01:03:24.780 --> 01:03:27.120
They can come check it out and play with it.

01:03:27.120 --> 01:03:27.940
Oh, that would be great.

01:03:27.940 --> 01:03:28.620
Yeah.

01:03:28.620 --> 01:03:34.420
And I'm sure you're taking contributions and PRs and you wouldn't mind if people had some additions.

01:03:34.420 --> 01:03:34.420
Oh, yeah, definitely.

01:03:34.420 --> 01:03:35.060
Yeah.

01:03:35.060 --> 01:03:37.200
I would love to have that.

01:03:37.200 --> 01:03:38.740
Cool.

01:03:38.740 --> 01:03:40.780
So contributions are very welcome.

01:03:40.780 --> 01:03:41.140
Yeah.

01:03:41.220 --> 01:03:43.140
And you also have really nice examples here.

01:03:43.140 --> 01:03:47.040
Like you have two videos that show how it works.

01:03:47.040 --> 01:03:48.680
You know, 15 minute YouTube videos.

01:03:48.680 --> 01:03:51.560
You've got some pictures and, you know, well done on that.

01:03:51.560 --> 01:03:54.800
It makes it really easy for people to come and just see like, okay, is this interesting?

01:03:54.800 --> 01:03:55.800
Does it apply to me?

01:03:55.800 --> 01:03:57.780
So good work.

01:03:58.080 --> 01:04:01.100
I do want to make one really quick follow-up.

01:04:01.100 --> 01:04:11.180
Corky out there had mentioned that maybe shallow clones were a better, more predictable choice than the partial clones with the filter equals blob.

01:04:11.740 --> 01:04:24.740
In general, the people at GitHub are recommending not to use the shallow clones anymore, but to use instead these partial clones because it keeps the history and it can incrementally go back and pull the stuff in as needed.

01:04:25.300 --> 01:04:29.360
However, there is one time where you may really want those shallow clones.

01:04:29.360 --> 01:04:37.180
And the reason I'm thinking of this is you talked about builds and using this to make builds run faster and only focusing on the parts that have changed.

01:04:37.180 --> 01:04:42.760
If you have a CI, the CI doesn't care about the history of your GitHub project.

01:04:42.760 --> 01:04:45.240
It just wants the working files, right?

01:04:45.240 --> 01:04:52.980
So you can do a shallow clone and say, just get me only the files on the tip of this branch and then build it.

01:04:52.980 --> 01:05:00.220
And that could be dramatically faster than saying, give me all five years of history of every single file and reassociate that.

01:05:00.220 --> 01:05:13.880
So if you're thinking about CI, this shallow clone idea that I was dismissing a little bit is exactly a good choice, I think, because you don't care about version history if you're trying to see if the current version builds or not, right?

01:05:14.100 --> 01:05:16.560
So anyway, just a quick follow-up on that.

01:05:16.560 --> 01:05:19.900
All right, David, I think we're probably out of time.

01:05:19.900 --> 01:05:22.520
I definitely encourage people to go check out your poetry plugin.

01:05:22.520 --> 01:05:28.220
They can check out polylith at polylith.getbook.io.

01:05:28.220 --> 01:05:30.780
Of course, I'll link to it in the show notes.

01:05:30.780 --> 01:05:35.480
Now, before you get out of here, I've got the two final questions to ask you, of course.

01:05:35.480 --> 01:05:44.020
If you're going to write some code, if you're going to work on the poetry polylith plugin, whatever, what editor are you using these days?

01:05:44.020 --> 01:05:45.940
Well, these days I use Emacs.

01:05:45.940 --> 01:05:48.220
I really like the two final things.

01:05:48.220 --> 01:05:53.500
Before Emacs, I really liked PyCharm too.

01:05:53.500 --> 01:05:57.820
But then I decided to learn Emacs and I'm stuck.

01:05:57.820 --> 01:05:59.420
Okay.

01:05:59.420 --> 01:06:03.400
Every programming language, I'm going to code everything in Emacs.

01:06:03.400 --> 01:06:03.880
Nice.

01:06:03.880 --> 01:06:04.100
Yeah.

01:06:04.100 --> 01:06:08.160
Long, long ago, that was my very first editor for programming.

01:06:08.160 --> 01:06:09.380
Oh, cool.

01:06:09.380 --> 01:06:10.620
And then, yeah.

01:06:10.620 --> 01:06:15.040
It brings me back to working on Silicon Graphics mainframes, computers doing C++.

01:06:15.040 --> 01:06:17.920
So, notable PyPI package.

01:06:17.920 --> 01:06:20.060
Something we simply talked about.

01:06:20.060 --> 01:06:22.480
Something else that you want to just tell people about that you thought was awesome.

01:06:22.480 --> 01:06:23.880
Ran across recently.

01:06:24.040 --> 01:06:27.860
I have to say Rich because it's such an awesome tool.

01:06:27.860 --> 01:06:37.300
And when you're going to develop a CLI and want it to look nice, and yeah, Rich is a really, really good tool.

01:06:37.300 --> 01:06:40.960
There were a lot of visualization features and stuff like that.

01:06:41.080 --> 01:06:42.680
So, that's a fantastic tool.

01:06:42.680 --> 01:06:42.880
Yeah.

01:06:42.880 --> 01:06:43.580
Good recommendation.

01:06:43.580 --> 01:06:46.180
There's so much momentum behind Rich these days.

01:06:46.180 --> 01:06:53.540
And if you're making some CLI developer-oriented tool, just give it a little color.

01:06:53.540 --> 01:06:54.860
Give it a little structure.

01:06:54.860 --> 01:07:06.320
And something like Rich, even just a little bit of color or a little bit of distinguishing one line of text from the other makes such a big difference in being able to use it really quickly and easily.

01:07:06.320 --> 01:07:09.380
And Rich is probably the best way to do that by far, right?

01:07:09.540 --> 01:07:09.660
Yeah.

01:07:09.660 --> 01:07:16.520
You should check out my new latest command, PolyCheck, because it uses a rich feature that I'm really happy about.

01:07:16.520 --> 01:07:17.960
It's silly, but I'm really happy.

01:07:17.960 --> 01:07:20.780
It uses an emoji while you're waiting.

01:07:20.780 --> 01:07:21.580
Fantastic.

01:07:21.580 --> 01:07:22.160
Oh, yeah.

01:07:22.160 --> 01:07:23.420
I love emojis.

01:07:23.420 --> 01:07:26.180
I love emojis and CLIs as well.

01:07:26.180 --> 01:07:27.060
All right.

01:07:27.060 --> 01:07:28.500
Final call to action.

01:07:28.500 --> 01:07:34.480
People want to get started with monorepos, with polyleth, with some of these ideas we've talked about.

01:07:34.480 --> 01:07:34.980
What do you tell them?

01:07:34.980 --> 01:07:42.040
Head over to the polyleth git repo or the official polyleth docs and read about it and see.

01:07:42.040 --> 01:07:55.800
Also, if you're interested in monorepos in general, check out the other solutions that are out there, because there are a lot of different approaches with different kind of focuses that maybe fit your situation best.

01:07:55.960 --> 01:08:02.200
I'm, of course, pro polyleth because I, yeah, develop a tool and really like that.

01:08:02.200 --> 01:08:06.100
But there's probably tools that are better for a difference to situation.

01:08:06.100 --> 01:08:09.540
So just explore, I would say.

01:08:09.540 --> 01:08:10.160
Right, right.

01:08:10.340 --> 01:08:18.700
The tools that maybe Google chooses to manage its code base might be the wrong tools that you choose for yours because the scale is so different.

01:08:18.700 --> 01:08:19.540
Right.

01:08:19.540 --> 01:08:19.780
Yeah.

01:08:19.780 --> 01:08:22.440
You might add so much complexity that it's not relevant.

01:08:22.440 --> 01:08:27.780
You know, it makes it really hard, but you don't need that complexity because you've got five projects, not 5,000 projects.

01:08:27.780 --> 01:08:28.060
Right.

01:08:28.060 --> 01:08:29.240
So, yeah, absolutely.

01:08:29.240 --> 01:08:31.720
Look around is good advice.

01:08:31.720 --> 01:08:32.620
Okay, David.

01:08:32.620 --> 01:08:33.620
Thank you for being here.

01:08:33.620 --> 01:08:34.620
It's been a really fun chat.

01:08:34.620 --> 01:08:35.380
I learned a bunch.

01:08:35.380 --> 01:08:35.740
Yeah.

01:08:35.740 --> 01:08:36.240
Thank you.

01:08:36.240 --> 01:08:39.440
So we really have fun to be on the show.

01:08:39.680 --> 01:08:40.000
Thank you.

01:08:40.000 --> 01:08:40.280
Yeah.

01:08:40.280 --> 01:08:40.720
You bet.

01:08:40.720 --> 01:08:41.080
Bye-bye.

01:08:41.080 --> 01:08:41.320
Bye.

01:08:41.320 --> 01:08:45.520
This has been another episode of Talk Python to Me.

01:08:45.520 --> 01:08:47.320
Thank you to our sponsors.

01:08:47.320 --> 01:08:48.940
Be sure to check out what they're offering.

01:08:48.940 --> 01:08:50.360
It really helps support the show.

01:08:50.360 --> 01:08:52.420
Starting a business is hard.

01:08:52.420 --> 01:09:01.020
Microsoft for Startups Founders Hub provides all founders at any stage with free resources and connections to solve startup challenges.

01:09:01.020 --> 01:09:05.540
Apply for free today at talkpython.fm/founders hub.

01:09:06.300 --> 01:09:13.660
Stay on top of technology and raise your value to employers or just learn something fun in STEM at brilliant.org.

01:09:13.660 --> 01:09:19.860
Visit talkpython.fm/brilliant to get 20% off an annual premium subscription.

01:09:20.860 --> 01:09:22.140
Want to level up your Python?

01:09:22.140 --> 01:09:26.180
We have one of the largest catalogs of Python video courses over at Talk Python.

01:09:26.180 --> 01:09:31.380
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:09:31.380 --> 01:09:34.040
And best of all, there's not a subscription in sight.

01:09:34.040 --> 01:09:36.960
Check it out for yourself at training.talkpython.fm.

01:09:37.360 --> 01:09:41.620
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

01:09:41.620 --> 01:09:42.940
We should be right at the top.

01:09:42.940 --> 01:09:52.300
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

01:09:52.300 --> 01:09:55.740
We're live streaming most of our recordings these days.

01:09:55.740 --> 01:10:03.520
If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:10:04.240 --> 01:10:05.420
This is your host, Michael Kennedy.

01:10:05.420 --> 01:10:06.700
Thanks so much for listening.

01:10:06.700 --> 01:10:07.860
I really appreciate it.

01:10:07.860 --> 01:10:09.780
Now get out there and write some Python code.

01:10:09.780 --> 01:10:09.780
Thank you.

01:10:09.780 --> 01:10:10.320
Bye.

01:10:10.320 --> 01:10:10.700
Bye.

01:10:10.700 --> 01:10:11.700
Bye.

01:10:11.700 --> 01:10:12.700
Bye.

01:10:12.700 --> 01:10:13.700
Bye.

01:10:13.700 --> 01:10:14.700
Bye.

01:10:14.700 --> 01:10:15.700
Bye.

01:10:15.700 --> 01:10:16.700
Bye.

01:10:16.700 --> 01:10:17.700
Bye.

01:10:17.700 --> 01:10:18.700
Bye.

01:10:18.700 --> 01:10:19.700
Bye.

01:10:19.700 --> 01:10:20.700
Bye.

01:10:20.700 --> 01:10:21.700
Bye.

01:10:21.700 --> 01:10:22.700
Bye.

01:10:22.700 --> 01:10:23.700
Bye.

01:10:23.700 --> 01:10:24.700
Bye.

01:10:24.700 --> 01:10:25.700
Bye.

01:10:25.700 --> 01:10:26.700
Bye.

01:10:26.700 --> 01:10:27.200
you

01:10:27.200 --> 01:10:27.700
you

01:10:27.700 --> 01:10:28.200
you

01:10:28.200 --> 01:10:28.700
you

01:10:28.700 --> 01:10:30.700
Thank you.

