WEBVTT

00:00:00.001 --> 00:00:04.780
Every year, the Python core developers and a few other key players in the Python ecosystem

00:00:04.780 --> 00:00:08.500
meet to discuss the pressing issues and important advancements

00:00:08.500 --> 00:00:11.240
at an event called the Python Language Summit.

00:00:11.240 --> 00:00:14.480
While Python is a community known for its openness,

00:00:14.480 --> 00:00:19.460
this meeting is typically held behind closed doors, mostly for efficiency's sake.

00:00:19.460 --> 00:00:23.020
On this episode, we'll give you a look behind that door.

00:00:23.020 --> 00:00:26.980
We have Alex Waygood here on this episode to break it down for us

00:00:26.980 --> 00:00:29.740
and give us a report from inside the Python Language Summit.

00:00:30.700 --> 00:00:36.680
This is Talk Python To Me, episode 375, recorded June 29th, 2022.

00:00:36.680 --> 00:00:53.100
Welcome to Talk Python To Me, a weekly podcast on Python.

00:00:53.100 --> 00:00:54.820
This is your host, Michael Kennedy.

00:00:54.820 --> 00:00:58.240
Follow me on Twitter where I'm @mkennedy and keep up with the show

00:00:58.240 --> 00:01:01.020
and listen to past episodes at talkpython.fm

00:01:01.020 --> 00:01:04.120
and follow the show on Twitter via at Talk Python.

00:01:04.120 --> 00:01:07.720
We've started streaming most of our episodes live on YouTube.

00:01:07.720 --> 00:01:11.460
Subscribe to our YouTube channel over at talkpython.fm/youtube

00:01:11.460 --> 00:01:15.260
to get notified about upcoming shows and be part of that episode.

00:01:16.260 --> 00:01:19.360
This episode is sponsored by Reflect.run.

00:01:19.360 --> 00:01:24.980
If you can browse the web, you can use Reflect.run to create sophisticated tests for your web app.

00:01:24.980 --> 00:01:29.440
And it's brought to you by Microsoft for Startups, Founders Hub.

00:01:29.440 --> 00:01:34.060
Get early stage support for your startup and build what you've been dreaming about.

00:01:35.420 --> 00:01:38.860
Transcripts for this and all of our episodes are brought to you by Assembly AI.

00:01:38.860 --> 00:01:41.560
Do you need a great automatic speech-to-text API?

00:01:41.560 --> 00:01:44.080
Get human-level accuracy in just a few lines of code.

00:01:44.080 --> 00:01:46.840
Visit talkpython.fm/assemblyai.

00:01:46.840 --> 00:01:49.420
Alex, welcome to Talk Python To Me.

00:01:49.420 --> 00:01:50.000
Thank you.

00:01:50.000 --> 00:01:50.800
It's great to be on the show.

00:01:50.800 --> 00:01:52.060
Big fan of the podcast.

00:01:52.200 --> 00:01:55.880
There's so much going on with the Python Language Summit, especially this year.

00:01:55.880 --> 00:02:02.820
I think there's quite a renaissance of new ideas to sort of look at the foundations and the fundamentals of Python.

00:02:02.820 --> 00:02:06.380
And a lot of it has to do with speed in different aspects.

00:02:06.380 --> 00:02:10.500
Maybe that's through threading or through raw performance or reference counting garbage collection.

00:02:10.500 --> 00:02:18.640
And so we're going to dive into all those ideas and more by just talking about your coverage of the Python Language Summit 2022.

00:02:18.640 --> 00:02:20.340
It's going to be super fun.

00:02:20.340 --> 00:02:22.080
But before we get to that, let's get to your story.

00:02:22.080 --> 00:02:23.420
How did you get into programming in Python?

00:02:23.420 --> 00:02:25.300
And how did you get inside the Language Summit anyway?

00:02:25.300 --> 00:02:26.360
Oh, yeah, sure.

00:02:26.360 --> 00:02:30.740
So I started programming actually only around two years ago.

00:02:30.740 --> 00:02:34.980
But my first line of code during the pandemic started off as a hobby.

00:02:34.980 --> 00:02:36.720
Still actually is a hobby.

00:02:36.720 --> 00:02:39.080
Had to have something to do while staying indoors.

00:02:39.080 --> 00:02:39.620
Exactly.

00:02:39.620 --> 00:02:43.820
Yeah, so Python is my first language and I'm entirely self-taught.

00:02:43.820 --> 00:02:46.460
And yeah, once I started, couldn't stop.

00:02:46.460 --> 00:02:46.940
That's cool.

00:02:46.940 --> 00:02:49.180
What kind of things were you looking to build?

00:02:49.180 --> 00:02:52.780
Were you just looking to learn a language or did you have some idea of something you wanted to create?

00:02:52.900 --> 00:02:56.580
So I started, so I was doing a journalism master's at the time.

00:02:56.580 --> 00:03:01.140
And there's a sub-community of journal coders.

00:03:01.140 --> 00:03:08.780
So people who use programming languages to gather data, scrape the web to find stories, essentially.

00:03:08.780 --> 00:03:10.400
So I thought that sounded pretty cool.

00:03:10.400 --> 00:03:11.420
Yeah, that sounds very cool.

00:03:11.720 --> 00:03:15.120
Yeah, so I started learning Python to help with that.

00:03:15.120 --> 00:03:21.140
And then sort of started to realize I actually enjoyed Python quite a lot, just for its own sake.

00:03:21.140 --> 00:03:25.600
Started building, built a card game using Pygame.

00:03:25.600 --> 00:03:29.480
It was one of my first projects, which was a lot harder than I anticipated.

00:03:29.480 --> 00:03:30.920
All the first projects are.

00:03:30.920 --> 00:03:31.560
Oh, yeah.

00:03:31.560 --> 00:03:32.380
Yeah, definitely.

00:03:32.840 --> 00:03:35.560
And then built a bad website using Flask.

00:03:35.560 --> 00:03:39.020
And then eventually started contributing to open source.

00:03:39.020 --> 00:03:41.140
And that's about where I am now.

00:03:41.140 --> 00:03:41.540
Fantastic.

00:03:41.540 --> 00:03:42.460
Yeah, yeah.

00:03:42.460 --> 00:03:43.120
That's really cool.

00:03:43.120 --> 00:03:45.260
It's interesting that you bring up journalism.

00:03:45.260 --> 00:03:50.740
I had Carolyn Stransky on a little while ago, predated the pandemic.

00:03:50.740 --> 00:03:51.900
Is it?

00:03:51.900 --> 00:03:52.260
Did it?

00:03:52.260 --> 00:03:52.740
Yeah.

00:03:52.740 --> 00:03:53.640
Maybe not.

00:03:53.640 --> 00:03:55.160
I don't even know when the pandemic was.

00:03:55.160 --> 00:03:55.960
A couple of years ago.

00:03:56.460 --> 00:03:58.300
Anyway, we talked about Python.

00:03:58.300 --> 00:04:01.820
Looks like you just hit before the business started.

00:04:01.820 --> 00:04:04.620
Just before it really, really kicked it.

00:04:04.620 --> 00:04:05.140
Exactly.

00:04:05.140 --> 00:04:05.680
Yeah.

00:04:05.680 --> 00:04:08.400
We talked about Python and AI and journalism.

00:04:08.400 --> 00:04:17.600
And there's a ton of neat things that people are doing to sort of automate the act of gathering data and reporting on it, right?

00:04:17.600 --> 00:04:18.080
Yeah.

00:04:18.080 --> 00:04:19.360
No, it's a really cool space.

00:04:19.360 --> 00:04:22.200
Directly employed in journalism is my full-time job at the moment.

00:04:22.200 --> 00:04:26.080
But it's something I'd love to dip into again at some point.

00:04:26.260 --> 00:04:26.660
For sure.

00:04:26.660 --> 00:04:27.460
Yeah.

00:04:27.460 --> 00:04:38.880
Carolyn was talking about things like monitoring certain websites like the National Geography, whatever the foundation is there, that alerts people about earthquakes.

00:04:38.880 --> 00:04:42.580
And I would bring up details and sort of pre-fill.

00:04:42.580 --> 00:04:47.300
So like some folks in LA, like on the LA Times or something, would get an alert.

00:04:47.300 --> 00:04:47.860
There's an earthquake.

00:04:47.860 --> 00:04:48.880
Here's most of the details.

00:04:48.880 --> 00:04:53.160
Just put the details around it and hit publish, you know, within 10 minutes or whatever.

00:04:53.160 --> 00:04:54.480
That's pretty cool.

00:04:54.780 --> 00:04:56.580
A little beep and then go write your article now.

00:04:56.580 --> 00:05:09.680
One of my first projects I tried to do, again, biting off much more than I could chew, was there's a, in the UK, we have this body called Historic England, which catalogs England's old buildings and heritage assets.

00:05:10.180 --> 00:05:13.400
And I have this all online, but it's not like in an easily downloadable form.

00:05:13.400 --> 00:05:17.280
You know, you can't just like download the CSV of the National Heritage List.

00:05:17.280 --> 00:05:20.540
So I decided that I was going to try and scrape this from the website.

00:05:20.540 --> 00:05:24.200
Of course, the scraping is easy, but then the data cleaning is a nightmare.

00:05:25.280 --> 00:05:29.980
Because like there's no consistent format and some of it's from the 1950s and yeah, it's horrible.

00:05:29.980 --> 00:05:34.240
Well, it would have been cool if you could have gotten it right and shared it with everyone.

00:05:34.240 --> 00:05:40.200
I got, I got some way there, but yeah, it's way too, way too difficult for one man.

00:05:40.200 --> 00:05:42.480
Like just started learning a few months ago.

00:05:42.480 --> 00:05:43.020
Yeah.

00:05:43.020 --> 00:05:43.300
Yeah.

00:05:43.300 --> 00:05:43.340
Yeah.

00:05:43.340 --> 00:05:43.820
Of course.

00:05:44.340 --> 00:05:47.680
It's those kinds of projects that are really good for learning programming.

00:05:47.680 --> 00:05:48.520
You know, they're.

00:05:48.520 --> 00:05:48.860
Oh yeah.

00:05:48.860 --> 00:05:49.600
I learned a ton.

00:05:49.600 --> 00:05:50.460
Don't regret it at all.

00:05:50.460 --> 00:05:50.720
Yeah.

00:05:50.720 --> 00:05:52.300
You're like, here's my goal.

00:05:52.300 --> 00:05:56.020
And then you just start frantically searching for like, well, what are the steps I need?

00:05:56.020 --> 00:05:59.940
And then how do I make those steps happen in my programming language, Python in this case?

00:05:59.940 --> 00:06:04.260
And like, you might not normally care to figure out how do you parse a CSV file out of this,

00:06:04.260 --> 00:06:07.900
but you're going to have to do it now because you're trying to, you know, aggregate on, you know,

00:06:07.900 --> 00:06:09.740
add onto it, append onto it and so on.

00:06:09.740 --> 00:06:12.320
So yeah, those kinds of things are great, great projects.

00:06:12.320 --> 00:06:12.780
Cool.

00:06:12.780 --> 00:06:13.680
All right.

00:06:13.780 --> 00:06:18.360
Well, how'd you get into the Python language summit from a journalism anger, from the open

00:06:18.360 --> 00:06:18.940
source angle?

00:06:18.940 --> 00:06:20.400
What was, what's the story here?

00:06:20.400 --> 00:06:25.900
I was invited in the autumn, I think, to become a triage with CPython.

00:06:25.900 --> 00:06:32.120
So at that point I'd contributed a lot of docs, documentation fixes, just something I was pretty

00:06:32.120 --> 00:06:33.920
good at because of the journals and masters.

00:06:33.920 --> 00:06:36.140
You actually know how to write.

00:06:36.140 --> 00:06:37.220
So yeah, I do know.

00:06:37.220 --> 00:06:43.620
I'd also contributed code to a few modules at that point, a few small fixes to,

00:06:43.620 --> 00:06:46.240
I think, functools, enum.

00:06:46.240 --> 00:06:47.780
Yeah, a few standard lib modules.

00:06:47.780 --> 00:06:55.000
So I'd been invited by Ken Jin, who's one of the typing module maintainers to become a triage

00:06:55.000 --> 00:06:55.740
during the autumn.

00:06:55.740 --> 00:06:59.540
So that got me onto the CPython developers' Discord channel.

00:06:59.540 --> 00:07:05.800
And then in, I think it was February or March, there was a discussion there where a few cordels

00:07:05.800 --> 00:07:09.400
were asking who they were going to invite to become the blogger this year.

00:07:09.400 --> 00:07:11.100
You know, Alex does journalism.

00:07:11.100 --> 00:07:11.680
Yeah.

00:07:11.680 --> 00:07:14.880
I got this, I got this master's.

00:07:14.880 --> 00:07:16.700
I mean, could maybe I do it?

00:07:16.780 --> 00:07:19.180
And they said yes, which was very flattering.

00:07:19.180 --> 00:07:19.800
Yeah.

00:07:19.800 --> 00:07:20.380
Fantastic.

00:07:20.380 --> 00:07:21.520
And great of them.

00:07:22.240 --> 00:07:23.620
And I really, really appreciate it.

00:07:23.620 --> 00:07:28.380
So it's Ukash, Mayata, and Sentil this year who organized the Language Summit.

00:07:28.380 --> 00:07:32.100
So massive thanks to them for inviting me to be the blogger this year.

00:07:32.100 --> 00:07:33.060
I actually appreciate it.

00:07:33.060 --> 00:07:34.080
Yeah, that's great.

00:07:34.080 --> 00:07:38.480
You must have been also at PyCon then, I'm guessing, because if you're at the Language Summit,

00:07:38.480 --> 00:07:39.020
you're at PyCon.

00:07:39.400 --> 00:07:40.460
Yeah, what was your experience there?

00:07:40.460 --> 00:07:40.980
Was it a good time?

00:07:40.980 --> 00:07:42.020
Yeah, I had a blast.

00:07:42.020 --> 00:07:43.000
It was great.

00:07:43.000 --> 00:07:43.500
Yeah.

00:07:43.500 --> 00:07:47.540
It's awesome to meet all these people I've been, you know, doing up and sort of stuff

00:07:47.540 --> 00:07:49.460
with online for several months.

00:07:49.460 --> 00:07:50.080
Yeah.

00:07:50.080 --> 00:07:51.180
It was really cool.

00:07:51.180 --> 00:07:51.400
Cool.

00:07:51.400 --> 00:07:57.340
I really appreciate these conferences because there's people I work with or talk to in different

00:07:57.340 --> 00:08:01.480
ways through, you know, through GitHub, through Twitter, through the podcast.

00:08:01.480 --> 00:08:05.660
But you don't really get to see them in person because they're halfway around the world until

00:08:05.660 --> 00:08:08.540
you show up and have a beer together or hang out together.

00:08:08.720 --> 00:08:10.580
I think that was, I mean, the talks are fantastic.

00:08:10.580 --> 00:08:12.880
But yeah, that was definitely the best bit for me.

00:08:12.880 --> 00:08:15.160
Yeah, that's the same for me, actually.

00:08:15.160 --> 00:08:16.640
That's the thing that I dig the most.

00:08:16.640 --> 00:08:17.200
All right.

00:08:17.200 --> 00:08:18.480
Let's talk about the Language Summit.

00:08:18.480 --> 00:08:18.920
Sure.

00:08:18.920 --> 00:08:21.800
So maybe tell people really quickly, what is the Language Summit?

00:08:21.800 --> 00:08:22.400
Sure.

00:08:22.400 --> 00:08:25.500
The Language Summit is an event every year.

00:08:25.500 --> 00:08:29.400
It's just like a day or two days before PyCon itself starts.

00:08:29.400 --> 00:08:34.200
Most of PyCon is available to just like anybody who's interested in Python.

00:08:34.580 --> 00:08:39.640
The Language Summit is generally only available to like core developers and special guests.

00:08:39.640 --> 00:08:41.100
So it's a big exclusive.

00:08:41.100 --> 00:08:45.480
That's not because they want to be like secretive about what's happening in there.

00:08:45.480 --> 00:08:51.940
It's more so that it can just be a sort of frank conversation between trends, I think.

00:08:51.940 --> 00:08:52.740
Sort of.

00:08:52.740 --> 00:08:53.120
Yeah.

00:08:53.120 --> 00:08:53.580
Does that make sense?

00:08:53.580 --> 00:08:53.900
Yeah.

00:08:53.900 --> 00:08:58.260
I mean, it's where the business of planning out Python gets done, right?

00:08:58.260 --> 00:08:59.320
Yeah, exactly.

00:08:59.320 --> 00:08:59.840
Yeah.

00:08:59.840 --> 00:09:00.960
It's not the only place.

00:09:00.960 --> 00:09:04.980
We have our peps and we have other places where conversation happens.

00:09:04.980 --> 00:09:09.580
But it seems like one of the places where, you know, some of the ideas of the peps are discussed

00:09:09.580 --> 00:09:13.480
and there's a quick feedback loop amongst a lot of the core developers.

00:09:13.480 --> 00:09:14.420
Yeah, exactly.

00:09:14.420 --> 00:09:19.240
I think it's just, you know, get everybody together all in one small room, talk Python for the whole

00:09:19.240 --> 00:09:21.040
day and then see what comes out of it.

00:09:21.040 --> 00:09:21.580
Awesome.

00:09:21.580 --> 00:09:22.680
How many people show up there?

00:09:22.680 --> 00:09:25.120
How many core developers and other folks?

00:09:25.540 --> 00:09:27.240
Around 30 this year, I think.

00:09:27.240 --> 00:09:33.240
So mostly core developers, a few triagers and a few special guests.

00:09:33.240 --> 00:09:38.940
So Zach Hadfield-Dobbs, I think, from Hypothesis was there.

00:09:38.940 --> 00:09:40.480
Sam Colvin from Pydantic.

00:09:40.480 --> 00:09:45.760
So yeah, a few open source maintainers outside the Core Dev team as well.

00:09:45.760 --> 00:09:46.320
Right, right.

00:09:46.320 --> 00:09:46.680
Yeah.

00:09:46.680 --> 00:09:48.060
Yeah, Pydantic's interesting.

00:09:48.060 --> 00:09:49.720
Obviously a great library.

00:09:49.720 --> 00:09:55.620
It's interesting to me because it kind of, a lot of its meaningful functionality is in

00:09:55.620 --> 00:10:00.060
the way that it breaks with the tradition of Python, you know, in the same way, like type

00:10:00.060 --> 00:10:00.380
hints.

00:10:00.380 --> 00:10:04.680
Now all of a sudden don't just mean something, but like they are the core way in which that

00:10:04.680 --> 00:10:05.400
library works.

00:10:05.400 --> 00:10:09.640
Whereas like most of the time it's a suggestion or a hint as the name would suggest.

00:10:09.640 --> 00:10:09.980
Sure.

00:10:09.980 --> 00:10:10.600
Yeah, yeah.

00:10:10.600 --> 00:10:13.320
And in the way it's quite coercive as well.

00:10:13.320 --> 00:10:14.620
So you don't have to like, yeah.

00:10:14.620 --> 00:10:15.380
Yeah, for sure.

00:10:15.380 --> 00:10:19.320
It's, so he's a good guest to have because he's, he's both got a popular project and

00:10:19.320 --> 00:10:21.460
one that's kind of an outlier to some degree.

00:10:21.460 --> 00:10:21.820
Yeah.

00:10:21.820 --> 00:10:23.220
It's hugely popular, isn't it?

00:10:23.220 --> 00:10:24.100
Yeah, it sure is.

00:10:24.100 --> 00:10:30.740
We've got, you know, SQL model by Sebastian Ramirez, which is basically take Pydantic models

00:10:30.740 --> 00:10:36.760
on top of SQLAlchemy and you've got Beanie from Roman Wright and there's some other ones

00:10:36.760 --> 00:10:40.580
that are just like sort of using Pydantic as their, their layer, which is really cool.

00:10:41.120 --> 00:10:45.900
So obviously the reason we're chatting today is this year's summit was covered by Alex

00:10:45.900 --> 00:10:46.300
Waygood.

00:10:46.300 --> 00:10:47.040
That's awesome.

00:10:47.040 --> 00:10:47.520
That's me.

00:10:47.520 --> 00:10:47.860
Yeah.

00:10:47.860 --> 00:10:48.520
Yay.

00:10:48.520 --> 00:10:49.360
Nicely done.

00:10:49.360 --> 00:10:54.780
And so I, when I saw this article or series of articles, I guess you might say come out,

00:10:54.780 --> 00:10:59.680
I thought it was really fantastic because like I said, I think there's just so much that's

00:10:59.680 --> 00:11:01.400
exciting going on here.

00:11:01.400 --> 00:11:02.100
No, it's not.

00:11:02.100 --> 00:11:05.500
Well, we're going to change the language a little bit here or there, but there's, there's stuff

00:11:05.500 --> 00:11:06.620
that everyone's going to get.

00:11:06.620 --> 00:11:08.260
That's really huge stuff in that.

00:11:08.260 --> 00:11:08.680
Yeah.

00:11:08.680 --> 00:11:09.600
Yeah, absolutely.

00:11:10.220 --> 00:11:15.140
So I thought what we could do for our conversation is just go and order and just sort of chat

00:11:15.140 --> 00:11:15.460
through them.

00:11:15.460 --> 00:11:18.980
You can give me a sense of what it was like to be in the room.

00:11:18.980 --> 00:11:21.480
What are some of the main ideas of, of each of these?

00:11:21.480 --> 00:11:22.740
And we'll, we'll just chat about them.

00:11:22.740 --> 00:11:26.880
So the first one was a very exciting project by Sam Gross.

00:11:26.880 --> 00:11:27.260
Yes.

00:11:27.260 --> 00:11:29.040
Who I think works for Meta.

00:11:29.040 --> 00:11:29.500
Yeah.

00:11:29.500 --> 00:11:30.200
I think he does.

00:11:30.200 --> 00:11:30.440
Yeah.

00:11:30.440 --> 00:11:31.540
I think he does part of the Cinder stuff.

00:11:31.540 --> 00:11:31.720
Yeah.

00:11:31.720 --> 00:11:35.920
And this is Python without the GIL or, or no GIL.

00:11:35.920 --> 00:11:39.620
I don't think he's on the Cinder team, but, but yeah, he is working at Meta.

00:11:39.720 --> 00:11:39.880
Right.

00:11:39.880 --> 00:11:40.160
Okay.

00:11:40.160 --> 00:11:41.000
Cool.

00:11:41.000 --> 00:11:41.260
Yeah.

00:11:41.260 --> 00:11:42.320
There's other stuff from Cinder.

00:11:42.320 --> 00:11:43.040
We'll get to later.

00:11:43.040 --> 00:11:43.440
Yeah.

00:11:43.440 --> 00:11:48.000
But yeah, Python without the GIL or, you know, his, his no GIL story.

00:11:48.000 --> 00:11:53.940
There's been a, you know, from a historical perspective, we've had attempts to remove the

00:11:53.940 --> 00:11:57.960
gill or change the performance characteristics of the GIL and so on.

00:11:57.960 --> 00:12:02.580
And maybe let me just set the stage a little bit with this GIL or global interpreter lock

00:12:02.580 --> 00:12:03.260
for people listening.

00:12:03.260 --> 00:12:09.580
When I heard this, the global interpreter lock means you can only run one statement of Python

00:12:09.580 --> 00:12:12.500
at a time, even if it's happening in multiple threads.

00:12:12.500 --> 00:12:17.760
I thought, okay, well, this must be some odd constraint put on the language so that things

00:12:17.760 --> 00:12:19.820
like threading are easier for people.

00:12:19.980 --> 00:12:24.720
But as I learned more about it, the real purpose of the GIL has nothing to do with threading

00:12:24.720 --> 00:12:25.560
per se.

00:12:25.560 --> 00:12:27.060
It has to do with memory management.

00:12:27.060 --> 00:12:27.580
Yeah.

00:12:27.580 --> 00:12:27.980
Yeah.

00:12:27.980 --> 00:12:33.220
And so the way memory management happens in Python, at least in the primary first pass

00:12:33.220 --> 00:12:34.440
sense is it's reference counted.

00:12:34.600 --> 00:12:39.420
So everything, numbers, strings, classes, dictionaries, they all have a ref count.

00:12:39.420 --> 00:12:43.640
And if that ref count ever reaches zero, it gets deleted as long as there's no cycles.

00:12:43.640 --> 00:12:49.100
And the problem is if you're going to change that number on the object, normally you would

00:12:49.100 --> 00:12:50.480
have to do that in a thread safe way.

00:12:50.480 --> 00:12:51.080
You will lock it.

00:12:51.080 --> 00:12:55.300
But that turns out to slow single threaded Python down a lot when it's unneeded.

00:12:55.300 --> 00:13:00.160
And so the global interpreter lock is there to meant to basically allow for that reference

00:13:00.160 --> 00:13:03.540
counting to happen quickly in the single threaded case.

00:13:03.540 --> 00:13:05.760
And that made fantastic sense 30 years ago.

00:13:05.760 --> 00:13:12.180
Now that we're sitting here with our 16 and 32 core CPUs, all of a sudden, we might want

00:13:12.180 --> 00:13:14.300
to run more than one thread and get stuff done.

00:13:14.300 --> 00:13:14.900
You know what I mean?

00:13:14.900 --> 00:13:15.260
Yeah.

00:13:15.260 --> 00:13:16.600
That's the history of the GIL.

00:13:16.600 --> 00:13:21.220
And so there were other things like Larry Hastine.

00:13:21.220 --> 00:13:22.140
He was there, right?

00:13:22.140 --> 00:13:22.600
Yeah.

00:13:22.600 --> 00:13:23.020
Yeah.

00:13:23.020 --> 00:13:24.460
Just to interject for a second.

00:13:24.460 --> 00:13:29.320
It's really fun to see sort of how long a project has been to try to remove the GIL.

00:13:29.320 --> 00:13:35.580
You can go back 10 years ago and there's a talk by David Beasley on weird things going

00:13:35.580 --> 00:13:36.820
on with the GIL in 2010.

00:13:36.820 --> 00:13:43.760
And then I was writing this after the summit, looking through the archives, past language

00:13:43.760 --> 00:13:44.580
summit bloggers.

00:13:45.120 --> 00:13:49.480
I think there's like three successive years running where there's presentations about

00:13:49.480 --> 00:13:51.160
the latest project to remove the GIL.

00:13:51.160 --> 00:13:53.620
But like this time, it actually seems like it could happen.

00:13:53.620 --> 00:13:54.520
It's really cool.

00:13:54.520 --> 00:13:55.280
It could happen.

00:13:55.280 --> 00:13:56.480
Yeah, it certainly could.

00:13:56.480 --> 00:13:59.560
Sam Gross's work seems to be the most likely candidate.

00:14:00.180 --> 00:14:05.280
And all the other attempts, their challenges have been, yes, you might remove the GIL and you

00:14:05.280 --> 00:14:09.520
might make the parallel computing faster, but you're going to make single threaded Python

00:14:09.520 --> 00:14:13.420
so much slower that it's, we don't want to accept it, right?

00:14:13.420 --> 00:14:16.600
If you could say, well, you can use core, you can use all the cores on your machine, but

00:14:16.600 --> 00:14:18.080
now everything runs half as fast.

00:14:18.080 --> 00:14:20.700
That's not a huge benefit to a lot of people.

00:14:20.700 --> 00:14:21.040
Yeah.

00:14:21.040 --> 00:14:25.420
And especially because, because of the fact that the guild's been there for so long,

00:14:25.420 --> 00:14:28.500
the vast majority of Python code is with only one thread, right?

00:14:28.900 --> 00:14:33.900
So it's like, well, it could make your Python code faster, but only if you rewrote all of

00:14:33.900 --> 00:14:36.060
your code, which not many people want to do.

00:14:36.060 --> 00:14:36.320
True.

00:14:36.320 --> 00:14:42.640
The other major problem or challenge that is there is how does it work with the C extensions

00:14:42.640 --> 00:14:45.980
that are so important to making Python work well, right?

00:14:45.980 --> 00:14:48.620
NumPy and all those types of things, right?

00:14:48.620 --> 00:14:48.820
Yeah.

00:14:48.820 --> 00:14:54.400
So Larry Hastings was there and he worked on the Galectomy, which I think is still the

00:14:54.400 --> 00:14:55.740
best name of all these projects.

00:14:55.740 --> 00:14:56.800
The Galectomy.

00:14:56.800 --> 00:14:57.580
Yes, definitely.

00:14:58.460 --> 00:15:02.600
Yeah, but it sounds like he thinks that Sam's project is already farther than his.

00:15:03.460 --> 00:15:08.460
This portion of Talk Python To Me is brought to you by Reflect.run.

00:15:08.460 --> 00:15:12.700
Reflect is the fastest way to create end-to-end tests for your web app.

00:15:12.700 --> 00:15:16.280
Most of us have encountered flaky, unreliable tests over the years.

00:15:16.280 --> 00:15:20.440
For a lot of us, testing our code is painful, but it doesn't have to be.

00:15:20.440 --> 00:15:25.560
Reflect was created by developers who are tired of dealing with constant problems inherent in

00:15:25.560 --> 00:15:27.540
code-based testing tools for web apps.

00:15:27.540 --> 00:15:32.960
Reflect is an automated, no-code testing tool that enables you to shave countless hours off

00:15:32.960 --> 00:15:34.640
your end-to-end testing timeline.

00:15:34.960 --> 00:15:38.800
If you can browse the web, you can create sophisticated tests with Reflect.

00:15:39.300 --> 00:15:43.840
navigate to your site within Reflect's simulated browser and perform the actions you want to test.

00:15:43.840 --> 00:15:49.360
Reflect will auto-generate selectors and do the painstaking work of test creation and maintenance

00:15:49.360 --> 00:15:50.360
for you in minutes.

00:15:50.360 --> 00:15:56.080
Instead of creating and maintaining a separate code base for your tests, you can manage all of your tests within Reflect.

00:15:56.520 --> 00:16:05.040
Features include visual validation, efficient for debugging and eliminating weights, cross-browser testing, run tests across all modern browsers,

00:16:05.040 --> 00:16:10.380
including Safari, Chrome, Firefox, and Edge, and email and SMS validation.

00:16:10.380 --> 00:16:13.980
The best way to appreciate what Reflect can do for you is to see it in action.

00:16:14.400 --> 00:16:20.260
They put together a nice six-minute video you can watch at talkpython.fm/reflect dash video.

00:16:20.260 --> 00:16:21.560
That's reflect dash video.

00:16:21.560 --> 00:16:26.300
I encourage you to watch it and see how straightforward and composable their tool is to use.

00:16:26.300 --> 00:16:30.720
Once you're ready to try it out, sign up at talkpython.fm/reflect.

00:16:30.720 --> 00:16:35.960
And as a special offer for Talk Python listeners, you'll get a free t-shirt when you sign up through this link.

00:16:36.360 --> 00:16:40.420
That's talkpython.fm/reflect to see how easy web testing can be.

00:16:40.420 --> 00:16:41.820
The link's in your show notes.

00:16:41.820 --> 00:16:44.400
Thank you to reflect.run for supporting the show.

00:16:44.400 --> 00:16:48.840
Maybe tell us a bit about what Sam was proposing there.

00:16:48.840 --> 00:16:55.740
So yeah, Sam has got this fork of cPython where he has removed the GIL and it all works.

00:16:55.740 --> 00:16:59.820
I think, you know, there's still a few rough edges, but it all basically works essentially.

00:16:59.820 --> 00:17:02.180
So now he is looking to...

00:17:02.180 --> 00:17:03.880
So if you want to, you can try that right now.

00:17:03.880 --> 00:17:09.100
You can go and download Sam's blog, new gill, and most Python programs will run fine on it.

00:17:09.100 --> 00:17:10.220
That's it right there.

00:17:10.220 --> 00:17:10.420
Yeah.

00:17:10.420 --> 00:17:11.560
For those watching...

00:17:11.560 --> 00:17:12.760
Yeah, I'll put a link in the show notes.

00:17:12.760 --> 00:17:13.080
Yeah.

00:17:13.080 --> 00:17:19.720
People can check out the GitHub repo and it's just a fork of Python, of cPython, and then goes from there, right?

00:17:19.720 --> 00:17:19.900
Yeah.

00:17:19.900 --> 00:17:27.120
And now Sam is hoping to essentially create a separate mode of cPython that you can enable with a compiler flag,

00:17:27.120 --> 00:17:29.520
which would enable new GIL.

00:17:29.520 --> 00:17:33.240
So to get his changes merged into the cPython main branch, essentially.

00:17:33.780 --> 00:17:41.720
So that would mean you would have to build cPython separately in order to get a version of cPython when no GIL would work.

00:17:41.720 --> 00:17:46.280
So it wouldn't be like you'd be able to just open up the repo and go like, import no GIL.

00:17:46.280 --> 00:17:47.500
It wouldn't be quite that easy.

00:17:47.500 --> 00:17:48.060
Right, right.

00:17:48.060 --> 00:17:55.900
It is a bit of a hassle that it's literally a separate compilation step, a separate binary and so on.

00:17:56.120 --> 00:17:57.620
But maybe it could ship.

00:17:57.620 --> 00:18:03.600
Maybe the cPython distribution, if this really works out well, could be shipped with that.

00:18:03.600 --> 00:18:08.060
Like it could be a set of Python or Python 3 or whatever you type.

00:18:08.060 --> 00:18:11.180
It could be Python ng or something like that.

00:18:11.180 --> 00:18:13.180
You know, like some extra command you can run.

00:18:13.280 --> 00:18:21.200
But at least it would be nice at least if you didn't have to literally go find a different installer and try to avoid the name clashes of what Python means, you know?

00:18:21.200 --> 00:18:21.480
Yeah.

00:18:21.480 --> 00:18:22.240
Yeah, for sure.

00:18:22.600 --> 00:18:24.760
And this is a change from his original proposal.

00:18:24.760 --> 00:18:27.600
So his original proposal was for a runtime flag.

00:18:27.600 --> 00:18:30.080
So that would mean that you would be able to, I don't know.

00:18:30.080 --> 00:18:33.500
I don't know how exactly it would work, but do something like import no GIL.

00:18:33.500 --> 00:18:34.080
Yeah.

00:18:34.080 --> 00:18:41.980
And reading your write up here, it sounded like Sam has come to the conclusion that there's too many differences for a runtime flag to make sense.

00:18:41.980 --> 00:18:44.680
And it's got to be a compiled type of thing.

00:18:44.680 --> 00:18:45.100
Exactly.

00:18:45.100 --> 00:18:47.080
So yeah, that was his proposal.

00:18:47.080 --> 00:18:47.980
How was the reception?

00:18:47.980 --> 00:18:49.700
There were a lot of questions for Sam.

00:18:50.220 --> 00:18:58.080
So I think there were, I think like a few of the other proposal presentations finished under time later on in the summit.

00:18:58.080 --> 00:19:02.880
And then we went back and asked some more questions to Sam because we still have questions.

00:19:02.880 --> 00:19:03.400
Yeah.

00:19:03.400 --> 00:19:06.580
So I think everybody in the room definitely knew.

00:19:06.580 --> 00:19:07.900
So like it's crazy.

00:19:07.900 --> 00:19:17.800
If you look at the viewing figures for these blogs, like the blog on no GIL is off the charts in terms of how many people have clicked on it and read it.

00:19:17.800 --> 00:19:18.660
Interesting.

00:19:18.660 --> 00:19:19.120
Okay.

00:19:19.720 --> 00:19:26.860
So it's like, the last time I checked, it was like 40,000 people had read the no GIL article and the next highest was 5,000 people.

00:19:26.860 --> 00:19:27.200
Wow.

00:19:27.200 --> 00:19:32.520
There was a huge amount of interest in this feature and the people in the room knew that there was a huge amount of interest in this feature.

00:19:32.520 --> 00:19:36.760
So I think there's a lot of interest in making this work if it can be made to work.

00:19:36.760 --> 00:19:37.100
Sure.

00:19:37.100 --> 00:19:40.160
But there's just a lot of complications about how to get that.

00:19:40.160 --> 00:19:49.440
So there were a lot of people asking what exactly the plan is here because it's this huge project that Sam's been working on for months and months.

00:19:49.440 --> 00:19:52.060
And how do you merge that into cPython?

00:19:52.060 --> 00:19:58.020
You know, you obviously can't have one PR where you have tens of thousands of lines of code changed all it was.

00:19:58.520 --> 00:20:00.020
So how do you split that up?

00:20:00.020 --> 00:20:01.860
You know, how do you...

00:20:01.860 --> 00:20:07.220
I think Sam was looking for a kind of pre-approval before submitting a PEP.

00:20:07.220 --> 00:20:09.520
I think some people were reluctant to...

00:20:09.520 --> 00:20:09.520
Right, right.

00:20:09.520 --> 00:20:13.080
Just taking the temperature of the room to see if it was just...

00:20:13.080 --> 00:20:13.100
Yeah.

00:20:13.100 --> 00:20:14.860
If it was welcome or unwelcome, right?

00:20:15.000 --> 00:20:18.280
I think the general mood was sort of cautious, if that makes sense.

00:20:18.280 --> 00:20:18.600
Yeah.

00:20:18.600 --> 00:20:23.080
Like, yes, we'd need to set the plan before we give our stuff.

00:20:23.080 --> 00:20:23.240
Yeah.

00:20:23.240 --> 00:20:24.320
That was the kind of vibe I got.

00:20:24.320 --> 00:20:24.560
Okay.

00:20:24.560 --> 00:20:32.220
There was some feedback, like from Barry Warsaw and Itamar Osterker about the impact it might have on third-party libraries.

00:20:32.220 --> 00:20:41.680
I think Carol Willing also talked about that because especially these C layers or these native code layers are super common in the data science space, especially.

00:20:41.680 --> 00:20:44.200
So, yeah, some conversation about that, right?

00:20:44.400 --> 00:20:53.280
Yeah, I think there's a lot of concern about with some features new to the language, for example, with typing was added a few releases back.

00:20:53.280 --> 00:20:55.220
I'm very involved with the typing community.

00:20:55.220 --> 00:20:57.020
I'm a massive fan of typing.

00:20:57.020 --> 00:20:57.540
I am too.

00:20:57.540 --> 00:20:58.960
Fan, not involved.

00:20:58.960 --> 00:20:59.240
Sure.

00:20:59.240 --> 00:21:11.300
But, you know, it's kind of got a little bit of a bad name for itself in some ways because there's some people who go to maintainers and demand that typing to be added or whatever.

00:21:11.300 --> 00:21:11.580
Right.

00:21:11.580 --> 00:21:15.760
And that's not really felt on the maintainers because everybody's volunteer doing it for free.

00:21:15.760 --> 00:21:26.580
It is getting easier because one of the holdups used to be, well, my library is for Python 2 and 3 and I'm not going to maintain two versions and so on and so on.

00:21:26.580 --> 00:21:26.780
Right.

00:21:26.880 --> 00:21:29.500
So, the typing wouldn't work in Python 2.

00:21:29.500 --> 00:21:32.960
At least now we're generally past that holdup.

00:21:32.960 --> 00:21:36.600
But still, yeah, it's effort that the person might not want to put out there.

00:21:36.600 --> 00:21:37.780
I'm a TypeShed maintainer.

00:21:37.780 --> 00:21:38.140
Yeah.

00:21:38.140 --> 00:21:39.340
I'm very involved in typing.

00:21:39.340 --> 00:21:39.940
So, yeah.

00:21:39.940 --> 00:21:40.940
Tell people about TypeShed.

00:21:40.940 --> 00:21:41.780
TypeShed's pretty cool.

00:21:41.780 --> 00:21:42.380
Oh, sure.

00:21:42.380 --> 00:21:49.760
So, TypeShed is the repository of stubs for the standard library and also a bunch of third-party stubs.

00:21:50.660 --> 00:21:59.420
So, TypeShed is like the only version of the standard library that mypy knows or Pyright or PyType or any other type checker.

00:21:59.420 --> 00:22:04.320
They don't actually know what's going on in real standard library at all.

00:22:04.700 --> 00:22:08.320
They only know this bundle of stubs and TypeShed.

00:22:08.320 --> 00:22:09.380
They don't feel like I'm explaining it very well.

00:22:09.380 --> 00:22:09.380
Yeah.

00:22:09.380 --> 00:22:10.820
So, you know, I'll pull it to one for app pairs.

00:22:10.820 --> 00:22:13.880
And people, these are not PY files.

00:22:13.880 --> 00:22:15.420
These are PYI files.

00:22:15.420 --> 00:22:16.160
Yes.

00:22:16.160 --> 00:22:19.340
And if you look at them, the implementation is super straight.

00:22:19.340 --> 00:22:21.420
Information?

00:22:21.420 --> 00:22:22.260
I don't know.

00:22:22.260 --> 00:22:27.460
The implementation of all these is super interesting because all the functions are dot, dot, dot.

00:22:27.460 --> 00:22:29.600
And the default values are dot, dot, dot.

00:22:29.920 --> 00:22:40.580
But what you have is you have function name, variable name, type, return value, type, or class, field type, field type, field type, field type, right?

00:22:40.580 --> 00:22:40.880
Yeah.

00:22:40.880 --> 00:22:43.220
So, it's like a Python file would like...

00:22:43.220 --> 00:22:43.420
Yeah.

00:22:43.420 --> 00:22:49.320
I suspect some people don't even know that this is a thing you can do to improve the understanding of editors and stuff, right?

00:22:49.320 --> 00:22:49.800
In mypy.

00:22:49.800 --> 00:22:57.280
A static type checker will use this information to inform the, like, the errors that's flagging on your file if you use it to check a file.

00:22:57.760 --> 00:23:10.780
So, if you import appders in your Python project and you install types appders, then mypy will use the type in some type check to understand, ah, okay, this app does instance has an app name.

00:23:10.780 --> 00:23:11.640
Oh, interesting.

00:23:11.640 --> 00:23:13.420
To add the address of type checker.

00:23:13.420 --> 00:23:14.660
Do you know what the editors do?

00:23:14.660 --> 00:23:17.740
Like, does PyCharm already have this information?

00:23:17.740 --> 00:23:22.360
Does VS Code already have this information from other sources or behind the scenes?

00:23:22.360 --> 00:23:22.680
So, PyCharm...

00:23:22.680 --> 00:23:25.780
VS Code does use type checker completely.

00:23:26.660 --> 00:23:29.400
PyCharm, I think, mostly uses type checker now.

00:23:29.400 --> 00:23:30.360
It was kind of...

00:23:30.360 --> 00:23:31.600
They used to have their own way.

00:23:31.600 --> 00:23:32.000
Yeah.

00:23:32.000 --> 00:23:35.620
I think it was a bit of a journey for them to move to type checker.

00:23:35.620 --> 00:23:39.080
I'm not sure if they 100% do yet, but yeah.

00:23:39.080 --> 00:23:39.320
Okay.

00:23:39.320 --> 00:23:40.340
Yeah, very interesting.

00:23:40.340 --> 00:23:40.880
Let's see.

00:23:40.880 --> 00:23:46.880
We were talking about the CPython stuff and Mr. Hypermagnetic asked, will CPython ever become Rust Python?

00:23:47.420 --> 00:23:50.260
They also pointed out that type, hence, saves lives.

00:23:50.260 --> 00:23:51.160
Saves lives.

00:23:51.160 --> 00:23:51.580
It's great.

00:23:51.580 --> 00:23:53.200
But back to the first question.

00:23:53.200 --> 00:23:54.160
Did that come up?

00:23:54.160 --> 00:23:56.120
Did Rust ever come up?

00:23:56.120 --> 00:23:59.960
My first thought is that's a pretty far bridge, but did it come up?

00:23:59.960 --> 00:24:01.860
There is already Rust Python, I think.

00:24:01.860 --> 00:24:03.780
You can go and use that if you want.

00:24:03.780 --> 00:24:04.060
Sure.

00:24:04.160 --> 00:24:11.780
I think it's quite a long way from becoming the default, like default, you know, from becoming the leading version of the reference implementation of Python.

00:24:11.780 --> 00:24:12.080
Yeah.

00:24:12.080 --> 00:24:12.260
Okay.

00:24:12.280 --> 00:24:16.440
We can come back to that in a little bit because it'll circle its way back a little bit.

00:24:16.440 --> 00:24:16.700
Yeah.

00:24:16.700 --> 00:24:17.280
All right.

00:24:17.280 --> 00:24:20.160
We're halfway through the show and we've got one of our items done.

00:24:20.160 --> 00:24:20.520
Fantastic.

00:24:20.520 --> 00:24:20.960
Yes.

00:24:20.960 --> 00:24:21.620
Let's go to the next one.

00:24:21.620 --> 00:24:23.300
No, we'll pick up speed as we go.

00:24:23.300 --> 00:24:23.900
Yeah.

00:24:23.900 --> 00:24:32.220
This next one is a per interpreter gill, which actually has been a little bit around from PEP 684.

00:24:32.220 --> 00:24:35.180
And it's still in draft mode from Eric Snow.

00:24:35.180 --> 00:24:38.460
And so this also goes back to dealing with the GIL.

00:24:38.940 --> 00:24:44.220
And it tries to, instead of remove it, say, well, you know what the GIL does is it makes you have single threaded code.

00:24:44.220 --> 00:24:51.740
So what we're going to do is if you want to run a thread, you just start a new sub interpreter in the same process.

00:24:51.740 --> 00:24:57.340
And sure, it has a gill, but it's meaningless because there's only one thread per interpreter.

00:24:57.340 --> 00:25:00.680
And so it's a way to kind of sidestep that problem, right?

00:25:00.680 --> 00:25:01.000
Yeah.

00:25:01.000 --> 00:25:01.620
It's kind of funny.

00:25:01.620 --> 00:25:04.120
So the first talk is like, yeah, let's get rid of the GIL.

00:25:04.120 --> 00:25:07.400
And then Eric comes along and says, but what if we had lots of gill?

00:25:08.480 --> 00:25:09.840
The problem is the GIL is shared.

00:25:09.840 --> 00:25:10.280
Yeah.

00:25:10.280 --> 00:25:13.900
Although we got to rename it if there's a per interpreter GIL.

00:25:13.900 --> 00:25:14.320
Yeah.

00:25:14.320 --> 00:25:15.420
It's not globally, right?

00:25:15.420 --> 00:25:17.520
It should just be a per interpreter ill.

00:25:17.520 --> 00:25:20.860
The gill, the g part, the global doesn't make sense anymore.

00:25:20.860 --> 00:25:21.400
A pill?

00:25:21.400 --> 00:25:22.380
Yeah.

00:25:22.380 --> 00:25:23.220
A pill?

00:25:23.220 --> 00:25:23.520
Yeah.

00:25:23.520 --> 00:25:24.460
That sounds a little bad.

00:25:24.680 --> 00:25:36.380
But it's interesting to point out, you know, like you pointed out in your article here, that back in 1997, you know, posted something saying, massive changes for separate thread state management.

00:25:36.640 --> 00:25:43.480
All per thread globals are moved to a struct, which is manipulated separately, you know, basically trying to do the same thing.

00:25:44.160 --> 00:25:55.080
And it turns out, though, that through another picture that you've got laid out here, there's actually a lot of global state shared across threads and different things, right?

00:25:55.080 --> 00:25:55.740
That's the problem.

00:25:55.880 --> 00:25:57.480
I think if I understand it correctly.

00:25:57.480 --> 00:25:59.220
So, I mean, I'm angry mouth.

00:25:59.220 --> 00:26:00.140
It's wrong.

00:26:00.140 --> 00:26:03.200
I have had him on the show before, so I'll link to that episode as well.

00:26:03.200 --> 00:26:08.540
I think it is possible now to run multiple interpreters within the same process.

00:26:09.000 --> 00:26:11.600
But it just doesn't work very well, if I understand correctly.

00:26:11.600 --> 00:26:17.980
So, it's like, you know, running to all sorts of problems, which, web safety, and, yeah, various conditions.

00:26:17.980 --> 00:26:18.400
Okay.

00:26:18.400 --> 00:26:18.940
There we go.

00:26:18.940 --> 00:26:19.260
Interesting.

00:26:19.260 --> 00:26:22.860
Yeah, so it sounds like he's been working on this for a long time.

00:26:22.860 --> 00:26:25.860
I think you opened with a funny quote.

00:26:25.860 --> 00:26:27.740
Hopefully, the speaker began.

00:26:27.740 --> 00:26:30.560
This is the last time I give a talk on this subject.

00:26:30.560 --> 00:26:32.720
He's been working on it since 2014.

00:26:32.720 --> 00:26:33.300
Yeah.

00:26:33.300 --> 00:26:38.100
I think at the time he gave the talk, he was hoping to get it in for 3.11.

00:26:38.480 --> 00:26:39.480
But didn't quite make it.

00:26:39.480 --> 00:26:40.120
Yeah, exactly.

00:26:40.120 --> 00:26:42.220
So, maybe it'll be 3.12.

00:26:42.220 --> 00:26:44.460
Yeah, because 3.11 is already frozen.

00:26:44.460 --> 00:26:45.660
Yeah, and it's still in draft mode.

00:26:45.660 --> 00:26:46.600
Okay.

00:26:46.600 --> 00:26:47.740
So, that's a good one.

00:26:47.740 --> 00:26:49.120
People can check that out.

00:26:49.120 --> 00:26:57.980
There's a tension between many of these projects in that the optimizations one are making might be complicating the work the others are doing.

00:26:57.980 --> 00:26:58.400
Yeah.

00:26:58.400 --> 00:27:03.360
And that's also true for the next one here, which actually, I think, is the biggest news of Python 3.11.

00:27:03.360 --> 00:27:04.700
I completely agree.

00:27:04.700 --> 00:27:05.540
Performance improvements.

00:27:05.540 --> 00:27:06.040
Yeah.

00:27:06.040 --> 00:27:07.840
Performance improvements for 3.11.

00:27:07.960 --> 00:27:13.000
I feel like it's a shame that so many more people read the no-kill one than this one, actually, in a way.

00:27:13.000 --> 00:27:13.280
Yeah.

00:27:13.280 --> 00:27:15.800
But, you know, I've been watching a C-Python repo.

00:27:15.800 --> 00:27:17.920
I know how much work has been going into this.

00:27:17.920 --> 00:27:20.120
And I think it's really impressive.

00:27:20.120 --> 00:27:20.400
Yeah.

00:27:20.480 --> 00:27:20.920
Yeah.

00:27:20.920 --> 00:27:29.080
So, essentially, the top-line news from this is Python 3.11 is going to be about 25% faster than Python 3.10.

00:27:29.080 --> 00:27:35.220
And this is mainly a result of implementing a PEP by Mark Shannon.

00:27:35.220 --> 00:27:37.520
Not sure I can remember the number of the PEP.

00:27:37.520 --> 00:27:39.900
It's known as the Shannon plan.

00:27:39.900 --> 00:27:40.180
Yeah.

00:27:40.180 --> 00:27:48.060
I'm making Python five times faster over five years or something like that by doing, like, this 1.25x per year, which they did it this year.

00:27:48.060 --> 00:27:48.580
That's incredible.

00:27:48.580 --> 00:27:53.620
The main chunk of this is that there are loads of, like, small optimizations that have gone into this.

00:27:53.740 --> 00:27:58.460
But a lot of them have to do with implementing what's called a specializing adaptive interpreter.

00:27:58.460 --> 00:27:58.900
Okay.

00:27:58.900 --> 00:28:00.100
What does that mean?

00:28:00.100 --> 00:28:00.560
What is that?

00:28:00.560 --> 00:28:13.800
So, this is essentially an interpreter that monitors your program as it's running and spots if you've got, like, an inefficient bytecode that can do lots of different things.

00:28:14.260 --> 00:28:21.420
So, like, maybe it's an add bytecode that could plausibly, I'm almost settling in and get some details wrong here.

00:28:21.420 --> 00:28:25.680
But, you know, maybe it could add two lists together or add two ins together.

00:28:25.680 --> 00:28:28.700
You know, it's just like a generic add bytecode.

00:28:28.700 --> 00:28:33.380
And then the specializing adaptive interpreter will spot, oh, hang on.

00:28:33.380 --> 00:28:34.920
Okay, we're in a tight loop here.

00:28:34.920 --> 00:28:37.980
Only numbers are being, only ins are being added here.

00:28:37.980 --> 00:28:42.400
We can replace this bytecode with a more specialized one, which will do the same thing faster.

00:28:42.600 --> 00:28:49.140
Yeah, because there's probably a lot of checks and different types of bits of indirection to let it add strings and lists and so on.

00:28:49.140 --> 00:28:51.800
But if you know it's numbers, then just do the number thing without the checks.

00:28:51.800 --> 00:28:52.300
Exactly.

00:28:52.300 --> 00:28:53.880
So, that's known as quickening.

00:28:53.880 --> 00:29:02.340
So, like, as the program's running, specializing adaptive interpreter quickens your code and replaces the bytecode with a more specialized one.

00:29:02.340 --> 00:29:09.020
This portion of Talk Python To Me is brought to you by Microsoft for Startups Founders Hub.

00:29:09.020 --> 00:29:11.060
Starting a business is hard.

00:29:11.360 --> 00:29:16.000
By some estimates, over 90% of startups will go out of business in just their first year.

00:29:16.000 --> 00:29:25.480
With that in mind, Microsoft for Startups set out to understand what startups need to be successful and to create a digital platform to help them overcome those challenges.

00:29:25.480 --> 00:29:28.180
Microsoft for Startups Founders Hub was born.

00:29:28.180 --> 00:29:34.820
Founders Hub provides all founders at any stage with free resources to solve their startup challenges.

00:29:35.360 --> 00:29:43.440
The platform provides technology benefits, access to expert guidance and skilled resources, mentorship and networking connections, and much more.

00:29:43.440 --> 00:29:53.020
Unlike others in the industry, Microsoft for Startups Founders Hub doesn't require startups to be investor-backed or third-party validated to participate.

00:29:53.020 --> 00:29:55.720
Founders Hub is truly open to all.

00:29:56.000 --> 00:29:57.200
So, what do you get if you join them?

00:29:57.200 --> 00:30:05.500
You speed up your development with free access to GitHub and Microsoft Cloud computing resources and the ability to unlock more credits over time.

00:30:05.500 --> 00:30:15.200
To help your startup innovate, Founders Hub is partnering with innovative companies like OpenAI, a global leader in AI research and development, to provide exclusive benefits and discounts.

00:30:15.780 --> 00:30:20.620
Through Microsoft for Startups Founders Hub, becoming a founder is no longer about who you know.

00:30:20.620 --> 00:30:34.160
You'll have access to their mentorship network, giving you a pool of hundreds of mentors across a range of disciplines and areas like idea validation, fundraising, management and coaching, sales and marketing, as well as specific technical stress points.

00:30:34.160 --> 00:30:39.400
You'll be able to book a one-on-one meeting with the mentors, many of whom are former founders themselves.

00:30:39.400 --> 00:30:44.540
Make your idea a reality today with the critical support you'll get from Founders Hub.

00:30:44.640 --> 00:30:50.500
To join the program, just visit talkpython.fm/founders hub, all one word, no links in your show notes.

00:30:50.500 --> 00:30:52.820
Thank you to Microsoft for supporting the show.

00:30:52.820 --> 00:30:59.260
Have you heard of Grant Booker's specialist project?

00:30:59.260 --> 00:30:59.740
No.

00:30:59.740 --> 00:31:06.620
So, if you look that up on GitHub, it's a project that he published a few weeks ago, I think, and it's really cool.

00:31:06.620 --> 00:31:13.040
You can see, it's like visualizes the way Python 3.11 will quicken your code that it's running.

00:31:13.040 --> 00:31:15.880
So, I'll send you a pass and link.

00:31:15.880 --> 00:31:16.180
Yeah, yeah.

00:31:16.180 --> 00:31:16.520
Send your link.

00:31:16.520 --> 00:31:17.100
Yeah.

00:31:17.100 --> 00:31:22.540
Tomer points out that they've been following the faster CPython repository.

00:31:22.540 --> 00:31:24.660
And yeah, I'll link to that as well.

00:31:24.660 --> 00:31:26.100
You know, Mark Shannon and other stuff.

00:31:26.100 --> 00:31:30.900
The ideas for making CPython faster over time and different things.

00:31:30.900 --> 00:31:31.140
Yeah.

00:31:31.140 --> 00:31:32.180
So, yeah.

00:31:32.180 --> 00:31:32.460
Very cool.

00:31:32.460 --> 00:31:32.660
Yeah.

00:31:32.840 --> 00:31:35.120
So, that does like the ideas hub with all.

00:31:35.120 --> 00:31:35.840
Visualizing.

00:31:35.840 --> 00:31:38.140
It's specializing adaptive interpreter.

00:31:38.140 --> 00:31:38.880
Okay.

00:31:38.880 --> 00:31:39.560
Yeah.

00:31:39.560 --> 00:31:39.900
All right.

00:31:39.900 --> 00:31:40.560
Very interesting.

00:31:40.560 --> 00:31:42.360
So, this is the thing.

00:31:42.360 --> 00:31:44.520
Pip install specialist is a thing you can do.

00:31:44.520 --> 00:31:45.880
And then it'll what?

00:31:45.880 --> 00:31:50.000
It'll show you like a printout of the code where it's actually found improvements?

00:31:50.180 --> 00:31:50.500
Exactly.

00:31:50.500 --> 00:31:55.440
So, it'll show you where it's quickened your code and where it's been unable to quicken

00:31:55.440 --> 00:31:55.800
your code.

00:31:55.800 --> 00:32:01.900
So, I think the green bits here, specialist has, yeah, quickened those bits of code.

00:32:01.900 --> 00:32:04.260
But the other bits, it's been like, yeah, don't know what to do here.

00:32:04.260 --> 00:32:05.100
Got to leave it.

00:32:05.100 --> 00:32:05.400
I said it.

00:32:05.400 --> 00:32:06.060
Couldn't do anything.

00:32:06.060 --> 00:32:06.380
Yeah.

00:32:06.460 --> 00:32:06.660
Yeah.

00:32:06.660 --> 00:32:10.740
So, for people listening, if you just pull up the specialist GitHub repository, which

00:32:10.740 --> 00:32:15.260
I will put in the show notes, there's a bunch of pictures and colorized code showing you

00:32:15.260 --> 00:32:18.860
where Python 3.11 was able to make it faster and where it wasn't.

00:32:18.860 --> 00:32:19.800
This is super cool.

00:32:19.800 --> 00:32:21.120
I never heard of this.

00:32:21.120 --> 00:32:21.640
Yeah.

00:32:21.640 --> 00:32:28.220
And this is a project by Brant Booker, who's been one of the major collaborators on the

00:32:28.220 --> 00:32:29.380
FasterCPython project.

00:32:29.380 --> 00:32:29.700
Right.

00:32:29.700 --> 00:32:30.460
Coming from the top.

00:32:30.460 --> 00:32:30.700
Yeah.

00:32:30.700 --> 00:32:33.280
What also is neat is this is not just for 3.11.

00:32:33.280 --> 00:32:35.080
3.11 is the first step.

00:32:35.080 --> 00:32:36.320
They're like only halfway through.

00:32:36.400 --> 00:32:36.500
Yeah.

00:32:36.500 --> 00:32:37.480
3.12 is currently.

00:32:37.480 --> 00:32:39.340
It's pretty well funded, too, right?

00:32:39.340 --> 00:32:44.540
Like, Microsoft has, I think, a team of six people possibly working with Guido and Mark.

00:32:44.540 --> 00:32:45.700
Sounds about right.

00:32:45.700 --> 00:32:50.840
And then also Bloomberg has contributed some resources or some help.

00:32:50.840 --> 00:32:51.100
Yeah.

00:32:51.100 --> 00:32:51.360
Yeah.

00:32:51.360 --> 00:32:52.800
It's really got a lot of speed here.

00:32:52.800 --> 00:32:55.440
A lot of inertia behind it, I guess I should say.

00:32:55.440 --> 00:32:55.900
And speed.

00:32:55.900 --> 00:32:56.380
Absolutely.

00:32:56.380 --> 00:32:56.900
All right.

00:32:56.900 --> 00:32:59.080
This one, actually, I think this is the big news.

00:32:59.080 --> 00:33:03.260
I know that it probably didn't make the biggest splash of the headlines, but.

00:33:03.260 --> 00:33:05.840
I think it's going to, yeah, because this is going to make everybody's code

00:33:05.840 --> 00:33:06.480
faster.

00:33:06.480 --> 00:33:09.500
It's not like one small micro-optimization.

00:33:09.500 --> 00:33:10.960
It's across the board.

00:33:10.960 --> 00:33:11.240
Right.

00:33:11.240 --> 00:33:11.480
Yeah.

00:33:11.480 --> 00:33:16.640
The threading stuff is very exciting and interesting, but I'm going to go out on LM and say, I think

00:33:16.640 --> 00:33:20.540
a lot of people think they need it or they think they want it more than they actually

00:33:20.540 --> 00:33:21.520
need it.

00:33:21.780 --> 00:33:28.160
So, for example, if you're running a website with APIs and stuff, you know, G Unicorn or

00:33:28.160 --> 00:33:32.340
Microwave's Geek or whatever, they all spin out a bunch of worker processes and you can

00:33:32.340 --> 00:33:37.840
have several worker processes per core, meaning you're already like saturating every core of

00:33:37.840 --> 00:33:38.320
the CPU.

00:33:39.320 --> 00:33:43.800
You know, so in those scenarios, it's nice, but it doesn't help that much in terms of, you know,

00:33:43.800 --> 00:33:45.720
a lot of stuff that you don't really need the threading.

00:33:45.720 --> 00:33:50.520
On the data science side, you might, but at the same time, you often, you're doing the computation

00:33:50.520 --> 00:33:53.380
in C or you can use async and await if it's IO bound.

00:33:53.460 --> 00:33:55.940
There's a lot of ways where this problem is actually already solved.

00:33:55.940 --> 00:33:57.740
It just doesn't feel like it's solved.

00:33:57.740 --> 00:34:02.960
And so this one though, this fix it, this makes multi-threaded code faster, single-threaded

00:34:02.960 --> 00:34:03.480
code faster.

00:34:03.480 --> 00:34:05.720
It's just, it just makes all the code faster, which is great.

00:34:05.720 --> 00:34:07.680
This could be a given at a run for the money.

00:34:07.680 --> 00:34:13.720
You know, when the listener asked earlier about Rust being the reference implementation

00:34:13.720 --> 00:34:15.720
for CPython, well, what is it then?

00:34:15.720 --> 00:34:16.200
RPython?

00:34:16.200 --> 00:34:16.680
I don't know.

00:34:16.680 --> 00:34:18.700
Maybe CPython isn't the name for it anymore.

00:34:18.700 --> 00:34:20.340
The reference implementation for Python.

00:34:20.660 --> 00:34:25.420
This one here, Python in the browser, could put some pressure to move in that direction.

00:34:25.420 --> 00:34:25.920
Right?

00:34:25.920 --> 00:34:27.440
So this one has to do with WebAssembly.

00:34:27.440 --> 00:34:28.280
Tell us about this.

00:34:28.280 --> 00:34:33.160
For a while now, there's been a project called Pyodide, which has been like a third party project,

00:34:33.160 --> 00:34:39.380
which has been monkey patching, essentially, CPython to get a version of CPython running in

00:34:39.380 --> 00:34:39.680
the browser.

00:34:39.680 --> 00:34:47.000
Pyodide has been the basis for several cool projects, which are all sort of just starting to take off

00:34:47.000 --> 00:34:47.320
now.

00:34:47.320 --> 00:34:52.100
I feel like we've sort of reached this like critical point where it's all the finest of

00:34:52.100 --> 00:34:54.220
starting to fit together and make sense.

00:34:54.220 --> 00:35:01.820
And over the last two years, Christian Himes, co-developer and contributor Ethan Smith have

00:35:01.820 --> 00:35:08.560
been working to upstream loads of these changes that Pyodide has been making to CPython itself,

00:35:08.560 --> 00:35:14.060
which would mean that Pyodide doesn't need to monkey patch CPython nearly so much anymore.

00:35:14.060 --> 00:35:18.840
And so I think that's actually will just work in the browser, which would be huge.

00:35:18.840 --> 00:35:20.020
Yeah, that's fantastic.

00:35:20.020 --> 00:35:22.300
There were a bunch of changes made to make this possible.

00:35:22.300 --> 00:35:27.840
And I can't remember where in the article you said, but yeah, over 60 PRs.

00:35:27.840 --> 00:35:28.040
Yeah.

00:35:28.040 --> 00:35:28.360
Yeah.

00:35:28.360 --> 00:35:29.460
And a GitHub issue, right?

00:35:29.460 --> 00:35:29.940
That's one.

00:35:29.940 --> 00:35:31.980
We just like see the numbers.

00:35:31.980 --> 00:35:35.920
Consider supporting mscripten slash WebAssembly as a build target.

00:35:35.920 --> 00:35:36.600
And guess what?

00:35:36.600 --> 00:35:37.700
That's not a thing.

00:35:37.700 --> 00:35:45.240
Now you can actually go in and say --with inscripten target equals browser as to compile

00:35:45.240 --> 00:35:45.780
CPython.

00:35:45.780 --> 00:35:47.020
And that's a big deal.

00:35:47.020 --> 00:35:52.700
I think it's going to make it possible to use Python where you would have otherwise used

00:35:52.700 --> 00:35:53.180
JavaScript.

00:35:53.180 --> 00:35:53.940
For sure.

00:35:53.940 --> 00:35:59.520
So I think this is possibly one of the biggest gripes that anybody using Python for web development

00:35:59.520 --> 00:35:59.880
has.

00:35:59.880 --> 00:36:02.100
And then have to like use JavaScript.

00:36:02.800 --> 00:36:07.640
Yeah, people will say sometimes to me that I'm being mean or inconsiderate or something

00:36:07.640 --> 00:36:10.700
when I say that we might not want to write in JavaScript.

00:36:10.700 --> 00:36:12.220
You're like, why are you hating on JavaScript?

00:36:12.220 --> 00:36:17.900
I think the frustration that a lot of people feel in the software industry is not that they

00:36:17.900 --> 00:36:21.940
necessarily hate JavaScript, that JavaScript is the only option.

00:36:21.940 --> 00:36:26.720
Like there's almost nowhere else in programming where we go, there's one language and one runtime

00:36:26.720 --> 00:36:27.540
and that's it.

00:36:27.540 --> 00:36:29.380
That's all you get to use, period.

00:36:30.020 --> 00:36:30.260
Right.

00:36:30.260 --> 00:36:35.740
On the desktop, on embedded, on the web, like on, you know, server side web, like you

00:36:35.740 --> 00:36:38.880
can pick tens of languages at least.

00:36:38.880 --> 00:36:39.220
Right.

00:36:39.220 --> 00:36:41.700
And you pick the one that works well for you and the one you like.

00:36:41.700 --> 00:36:46.940
And except for in the browser, everyone is forced to do this one language, which is frustrating.

00:36:46.940 --> 00:36:52.840
And so as Python developers, where we like Python, it would be great if we could continue to use

00:36:52.840 --> 00:36:55.900
a language that we prefer for things like this.

00:36:55.900 --> 00:36:56.100
Right.

00:36:56.100 --> 00:36:56.380
Yeah.

00:36:56.380 --> 00:36:56.900
And now you can.

00:36:56.900 --> 00:36:57.540
And now you can.

00:36:58.000 --> 00:37:00.700
There's a few challenges with this.

00:37:00.700 --> 00:37:04.420
One is that the WebAssembly binaries are a bit large, not huge.

00:37:04.420 --> 00:37:08.000
They're not huge, but they're like five or 10 megs instead of 50k.

00:37:08.000 --> 00:37:10.300
So that's a bit of a challenge.

00:37:10.300 --> 00:37:13.440
But there's places where this is already highly valuable.

00:37:13.440 --> 00:37:19.480
So for example, if you're doing like an Electron JS app, you could write that largely in Python

00:37:19.480 --> 00:37:22.000
using this stuff already.

00:37:22.240 --> 00:37:25.380
And it doesn't matter because you already downloaded an entire copy of Chrome.

00:37:25.380 --> 00:37:27.280
What's another 10 megs?

00:37:27.280 --> 00:37:29.620
You know, is it 200 or 205?

00:37:29.620 --> 00:37:30.240
Like, I don't care.

00:37:30.240 --> 00:37:30.800
It's the same.

00:37:30.800 --> 00:37:31.100
Yeah.

00:37:31.100 --> 00:37:34.260
I think Simon and Willison might have done that a few weeks ago.

00:37:34.260 --> 00:37:35.040
Okay.

00:37:35.040 --> 00:37:38.240
I created an Electron JS app with PyScript?

00:37:38.240 --> 00:37:39.160
Yeah, I think so.

00:37:39.160 --> 00:37:39.860
I'll have to look into that.

00:37:39.860 --> 00:37:40.980
That sounds really fantastic.

00:37:40.980 --> 00:37:42.020
Let's see.

00:37:42.100 --> 00:37:48.500
So this is cool because PyIodide is great, but it's like this sort of project maintain

00:37:48.500 --> 00:37:49.740
alongside CPython.

00:37:49.740 --> 00:37:55.380
And this is saying the core developers and the team behind Python are allowing you to just

00:37:55.380 --> 00:37:58.820
compile a limited version directly, right?

00:37:58.820 --> 00:38:03.100
So PyIodide could say build on top of this one and not have to maintain their own copy.

00:38:03.100 --> 00:38:03.620
Exactly.

00:38:03.620 --> 00:38:03.960
Yeah.

00:38:03.960 --> 00:38:05.420
So we do need to be careful here.

00:38:05.420 --> 00:38:09.820
Like, it's mscripts in the WebAssembly are not fully supported by CPython yet.

00:38:10.160 --> 00:38:11.820
There was a lot of concern about that at the summit.

00:38:11.820 --> 00:38:17.260
Like, if we say it's supported now, then it's a big statement to put out there.

00:38:17.260 --> 00:38:19.440
So definitely not fully supported yet.

00:38:19.440 --> 00:38:19.660
Yeah.

00:38:19.660 --> 00:38:19.960
Okay.

00:38:19.960 --> 00:38:20.800
Good to point that out.

00:38:20.800 --> 00:38:25.500
And there's plenty of things that are not supported because they're probably not just

00:38:25.500 --> 00:38:26.980
haven't, they're not ready.

00:38:26.980 --> 00:38:29.260
Some things that will never, ever be supported.

00:38:29.260 --> 00:38:32.380
Like TK Enter support is probably never coming to the browser.

00:38:32.380 --> 00:38:33.440
Yeah.

00:38:33.440 --> 00:38:34.100
You know what I mean?

00:38:34.100 --> 00:38:39.440
Or other things that are not permitted by the browser's sandboxing rules and so on.

00:38:39.540 --> 00:38:44.740
Anything that can be run in the browser needs to be extremely security conscious because

00:38:44.740 --> 00:38:47.840
nobody expects to have arbitrary code execution on the browser.

00:38:47.840 --> 00:38:49.640
It sounds very, very suspicious.

00:38:49.640 --> 00:38:53.900
Like, you're going to let me run binary code in the browser, but it's subjected to exactly

00:38:53.900 --> 00:38:55.500
the same rules as JavaScript.

00:38:55.500 --> 00:38:58.500
And JavaScript gets JIT compiled to binary code and then run anyway.

00:38:58.500 --> 00:39:00.760
It just feels better that it's like, oh, here's a script.

00:39:00.760 --> 00:39:02.360
It's like, no, it's the same thing.

00:39:02.580 --> 00:39:03.460
So very cool.

00:39:03.460 --> 00:39:07.700
I do want to just point out, give a quick shout out to PyScript, which you also did in

00:39:07.700 --> 00:39:08.160
your article.

00:39:08.160 --> 00:39:09.740
This is super exciting.

00:39:09.740 --> 00:39:11.820
This takes it and makes it way, way more real.

00:39:11.820 --> 00:39:14.660
This is where you really do put Python in the browser.

00:39:14.880 --> 00:39:16.920
This is built on top of Pyroidite, I think.

00:39:16.920 --> 00:39:17.180
Yep.

00:39:17.180 --> 00:39:22.100
Just enables you to embed Python inside an HTML file.

00:39:22.100 --> 00:39:23.680
And it just works.

00:39:23.680 --> 00:39:24.160
Yes.

00:39:24.160 --> 00:39:25.200
Yeah, it works pretty well.

00:39:25.200 --> 00:39:29.280
Opening tag, py-script inside an HTML file.

00:39:29.280 --> 00:39:31.680
And don't need to download anything.

00:39:31.680 --> 00:39:32.080
Yeah.

00:39:32.080 --> 00:39:32.740
Pretty incredible.

00:39:32.980 --> 00:39:37.540
You can also say source equals app.py in your browser.

00:39:37.540 --> 00:39:41.580
And as long as that can be delivered as a static file, it'll pull that up and run.

00:39:41.580 --> 00:39:43.460
I just, quick follow up on this.

00:39:43.460 --> 00:39:44.940
No, this is a different one.

00:39:44.940 --> 00:39:46.060
I'll roll it.

00:39:46.060 --> 00:39:49.020
But I do want to point out that I actually, I don't know if people know this.

00:39:49.020 --> 00:39:51.640
I did a video called Python PyScript WebAssembly.

00:39:51.640 --> 00:39:55.980
And then I actually created an offline progressive web app with it.

00:39:55.980 --> 00:40:01.940
So once you've installed this app, it no longer has to download that larger binary.

00:40:02.400 --> 00:40:05.760
So if you look at the code, it's like super, super simple.

00:40:05.760 --> 00:40:07.360
You can get this cool little offline app.

00:40:07.360 --> 00:40:13.120
And it is like launch time, you know, down to one second, maybe one and a half seconds.

00:40:13.120 --> 00:40:18.400
And it's just so bizarre to write Python for like JavaScript events.

00:40:18.400 --> 00:40:23.100
So you can say like on click equals here's the Python function and all sorts of stuff.

00:40:23.100 --> 00:40:24.640
So people can check that out.

00:40:24.640 --> 00:40:25.600
I'll link that in the show notes.

00:40:25.600 --> 00:40:27.360
This is a really big deal.

00:40:27.360 --> 00:40:29.700
This WebAssembly stuff that's coming in.

00:40:29.700 --> 00:40:30.880
It's coming from these different angles.

00:40:30.960 --> 00:40:35.220
It's coming from Pyodide, from PyScript, from the core developers compiling to WebAssembly.

00:40:35.220 --> 00:40:38.080
All of those things are pretty fantastic.

00:40:38.080 --> 00:40:41.600
It's really cool to see so many people collaborate on the same thing at once.

00:40:41.600 --> 00:40:43.240
From seven different parts of the community.

00:40:43.240 --> 00:40:43.720
It's true.

00:40:43.720 --> 00:40:44.180
It's happening.

00:40:44.180 --> 00:40:45.860
There's two parts where that's happening, right?

00:40:45.860 --> 00:40:49.700
In this GIL thing and in the WebAssembly side of things, right?

00:40:49.700 --> 00:40:53.580
They're not necessarily coordinating, but they're all working on the same problem.

00:40:53.580 --> 00:40:55.820
And surely we'll get some good outcomes from that.

00:40:55.820 --> 00:40:56.700
All right.

00:40:56.700 --> 00:41:00.100
Let's talk about the Cinder one next.

00:41:00.100 --> 00:41:04.900
So this one does come also from Meta and more Instagram, I suppose, directly.

00:41:04.900 --> 00:41:07.220
But this comes from the Cinder project.

00:41:07.220 --> 00:41:09.820
And this has to do with some of the optimizations.

00:41:09.820 --> 00:41:11.000
You want to tell us about this one?

00:41:11.060 --> 00:41:14.360
These are essentially async specific optimizations.

00:41:14.360 --> 00:41:19.760
So Cinder, for those who don't know, is a performance-oriented fork of CPython.

00:41:20.180 --> 00:41:28.180
So the Instagram team essentially were like, we really love Python, but it's a bit too slow for our web servers if we're going to have the whole thing written in Python.

00:41:28.180 --> 00:41:30.540
So they forked it and implemented.

00:41:30.540 --> 00:41:35.000
There's a ton of different optimizations implemented in Cinder.

00:41:35.000 --> 00:41:35.880
Many changes.

00:41:35.880 --> 00:41:36.220
Yeah.

00:41:36.220 --> 00:41:37.260
There's a ton.

00:41:37.260 --> 00:41:41.720
If you check out the Cinder project, there's just a whole list of all these different things.

00:41:41.720 --> 00:41:42.940
Some of them have to do with JIT.

00:41:43.160 --> 00:41:49.200
Some of them have to do with immortal objects and some have to do with other things as well.

00:41:49.200 --> 00:41:49.360
Yeah.

00:41:49.360 --> 00:41:50.340
Async IO.

00:41:50.340 --> 00:41:51.300
Lazy imports.

00:41:51.300 --> 00:41:51.960
Yeah.

00:41:51.960 --> 00:41:53.440
Loads of stuff going on.

00:41:53.440 --> 00:41:53.860
Yeah.

00:41:53.860 --> 00:42:04.540
With all the attention recently on making Python faster, the Cinder team is hopeful that they will be able to get some of their optimizations merged into the main drive to Cpython.

00:42:04.540 --> 00:42:12.900
So this presentation was specifically about some of the async specific optimizations that they have been implementing in their fork.

00:42:12.900 --> 00:42:19.020
So essentially, the issue is to do with eagerly awaited coroutines.

00:42:19.020 --> 00:42:26.160
So if you have coroutine, then generally, if you have a coroutine function, you'll call that function.

00:42:26.160 --> 00:42:27.980
It will create this coroutine object.

00:42:27.980 --> 00:42:31.020
That coroutine object doesn't do much until you await it.

00:42:31.020 --> 00:42:33.360
And then eventually you get the result back.

00:42:33.360 --> 00:42:37.420
But that can be inefficient in some situations.

00:42:37.420 --> 00:42:46.540
Because if the task being done in the coroutine can just sort of finish immediately, then there's no reason to create that coroutine object.

00:42:46.540 --> 00:42:46.920
Right.

00:42:46.920 --> 00:42:50.720
And to schedule it and to do all the stuff on the loop and then wait for it.

00:42:50.720 --> 00:42:52.460
All of that is just overhead.

00:42:53.060 --> 00:43:03.220
What's done in the Cinder fork is they detect when a task can be immediately finished and don't bother correcting the coroutine object in that case.

00:43:03.220 --> 00:43:07.100
So let me see if I can come up with an example for people that might make it concrete.

00:43:07.100 --> 00:43:07.740
Kind of complicated.

00:43:07.740 --> 00:43:08.740
Yeah, no, it is.

00:43:08.740 --> 00:43:11.780
But I think once you get this feel for it, it's no problem.

00:43:11.780 --> 00:43:12.700
It's not that bad.

00:43:12.700 --> 00:43:14.640
Probably bad to implement, but not bad to understand.

00:43:15.060 --> 00:43:25.060
So imagine you have an async function that's going to call an API, but you might have an in-memory cache that says, have I already looked this up for this particular argument?

00:43:25.060 --> 00:43:25.460
Right.

00:43:25.460 --> 00:43:30.420
So your code could say, if this value is in the cache, just return that value.

00:43:30.420 --> 00:43:33.920
Otherwise, await HTTPX get da-da-da-da-da.

00:43:33.920 --> 00:43:34.580
Right.

00:43:34.580 --> 00:43:46.760
So that first case where you call something that's in the cache, by default in Python now, it's going to still schedule that on the loop and it's going to make it run on the loop and wait for all that to happen in this inefficient way.

00:43:46.760 --> 00:43:53.880
So the optimization is like run it as a regular function until you hit an await and then go through that process.

00:43:53.880 --> 00:43:54.720
Something like that, right?

00:43:54.720 --> 00:43:55.520
I think so.

00:43:55.520 --> 00:43:56.760
That's my understanding.

00:43:56.760 --> 00:43:59.040
And people can send me messages and let me know I got it wrong.

00:43:59.040 --> 00:44:00.800
But I think that's the basic idea.

00:44:00.800 --> 00:44:08.580
There's scenarios where, in my case, if it's in the cache, it doesn't ever really need to be treated as a async coroutine ever.

00:44:08.580 --> 00:44:10.660
You just get the value back like a regular function.

00:44:10.660 --> 00:44:12.860
But if it goes past that, then it does need to be one.

00:44:12.860 --> 00:44:14.180
And that's the distinction, I think.

00:44:14.180 --> 00:44:15.060
Okay, cool.

00:44:15.060 --> 00:44:19.880
So there's actually a lot of improvements and performance things coming from the Cinder project.

00:44:19.880 --> 00:44:23.380
There's this one, but there was also the lazy imports, right?

00:44:23.380 --> 00:44:25.780
PEP 690 and that one and so on.

00:44:25.780 --> 00:44:32.740
On discuss.python.org, there's been a, I think a discussion has reached to over 100 comments now on lazy imports.

00:44:32.740 --> 00:44:37.280
So if you have views, that is where to send them.

00:44:37.280 --> 00:44:37.720
Absolutely.

00:44:37.960 --> 00:44:45.400
That's a whole different proposal where you could, we should introduce an API to enable or disable lazy imports.

00:44:45.400 --> 00:44:47.560
So with lazy imports enabled.

00:44:47.560 --> 00:44:50.100
So at the moment, all imports in Python are eager.

00:44:50.100 --> 00:45:00.980
So if you type in import functools at the top of a file, it will execute the entire functools module and then put a reference to that module in your file for you.

00:45:01.180 --> 00:45:05.540
Whereas with lazy imports enabled, it would see the import functools statement.

00:45:05.540 --> 00:45:07.660
It'd be like, meh, not going to do anything with that.

00:45:07.660 --> 00:45:13.440
And then wouldn't actually import the module until the first time functools was referenced later on down the file.

00:45:13.440 --> 00:45:13.680
Right.

00:45:13.680 --> 00:45:16.740
Because the problem is there's a cost for doing an import.

00:45:16.740 --> 00:45:20.440
It's not like a hash include, which might be a compile time thing.

00:45:20.440 --> 00:45:22.860
There's an actual runtime cost for every import.

00:45:23.780 --> 00:45:27.540
So PEP 8 says all the imports go at the top to keep them orderly.

00:45:27.540 --> 00:45:34.960
But if there's many apps that might or might not use some import, depending on what part of it runs.

00:45:34.960 --> 00:45:35.400
Right.

00:45:35.400 --> 00:45:35.700
Yeah.

00:45:35.700 --> 00:45:40.540
And so if you could delay that, that expense only if you use it, that would be great.

00:45:40.540 --> 00:45:44.500
And this can have a major impact on startup time for Python CLI apps.

00:45:44.500 --> 00:45:44.900
Yeah.

00:45:44.900 --> 00:45:45.340
Especially.

00:45:45.340 --> 00:45:45.660
Yeah.

00:45:45.660 --> 00:45:45.880
Yeah.

00:45:45.880 --> 00:45:48.360
The one that we were talking about is this ASIC optimization.

00:45:48.560 --> 00:45:54.480
So that's the one that was actually covered, but it's just one of the things coming out of Cinder, which is cool.

00:45:54.480 --> 00:45:54.860
Yes.

00:45:54.860 --> 00:45:59.200
And then I think maybe this path forward for immortal objects.

00:45:59.200 --> 00:46:00.640
Is that also coming out of Cinder?

00:46:00.640 --> 00:46:01.920
Sounds like it.

00:46:01.920 --> 00:46:03.540
No, that's another one.

00:46:03.540 --> 00:46:04.860
Similar, but not the same.

00:46:04.860 --> 00:46:10.780
This is linked to the current up to Gil talk, essentially.

00:46:10.780 --> 00:46:11.220
Okay.

00:46:11.220 --> 00:46:17.480
This is one of those proposals that's kind of very much in the weeds of how Python is implemented.

00:46:17.960 --> 00:46:22.100
So it's a proposal to introduce what's known as immortal objects.

00:46:22.100 --> 00:46:26.840
So an immortal object is, well, an object that never dies.

00:46:26.840 --> 00:46:31.980
So generally in Python, as we were talking about earlier, objects have a reference count.

00:46:31.980 --> 00:46:36.660
And if that reference count reaches zero, then the garbage collector comes along eventually

00:46:36.660 --> 00:46:40.880
and deletes it, freeing out memory that was holding that object.

00:46:40.880 --> 00:46:45.900
So this path proposes introducing a class of objects where the reference count would never

00:46:45.900 --> 00:46:51.020
reach zero, meaning that the object would never be cleaned up by the garbage collector and would

00:46:51.020 --> 00:46:51.480
never die.

00:46:51.480 --> 00:46:53.420
So this would have the advantage.

00:46:53.420 --> 00:46:53.800
Yeah.

00:46:53.800 --> 00:46:58.380
Because why are you bothering to like check and check on these objects that you know will

00:46:58.380 --> 00:47:01.980
never, ever have any sort of reason to go away?

00:47:01.980 --> 00:47:02.220
Right.

00:47:02.220 --> 00:47:06.640
So like there's the non-singleton, for example, like it would be quite rare to have a program

00:47:06.640 --> 00:47:08.700
that doesn't use none at least once.

00:47:08.700 --> 00:47:11.780
Or the number five, which is pre-allocated, right?

00:47:11.780 --> 00:47:18.740
As well as the number 200, like the first, the last, the first negative five in the top 255

00:47:18.740 --> 00:47:19.360
or something like that.

00:47:19.360 --> 00:47:19.540
Yeah.

00:47:19.540 --> 00:47:25.440
But nonetheless, Python will like doggedly keep a reference count for these objects and

00:47:25.440 --> 00:47:27.560
like track where they are.

00:47:27.560 --> 00:47:28.000
Yeah.

00:47:28.000 --> 00:47:35.740
So for a lot of these, yeah, pre-allocated object numbers, in terms strings, the empty

00:47:35.740 --> 00:47:39.140
tubal, I think is also singleton, the non-singleton.

00:47:39.140 --> 00:47:43.080
These would all become immortal objects if this path accepted.

00:47:43.080 --> 00:47:48.580
And that would, I think in the short term, make Python a little bit slower, probably.

00:47:48.580 --> 00:47:52.700
So I think a naive implementation makes it slower by around 6%.

00:47:52.700 --> 00:47:58.160
But with mitigations, you can make it so that performance impacted is marginal.

00:47:58.160 --> 00:48:04.180
But then if you do implement immortal objects, there's, it makes things like a paratexta

00:48:04.180 --> 00:48:05.160
gill easier.

00:48:05.160 --> 00:48:07.940
It might also simplify no gill, I think.

00:48:07.940 --> 00:48:08.520
Yeah, probably.

00:48:08.520 --> 00:48:14.300
Because once you know something's immortal and probably also immutable, then you can share

00:48:14.300 --> 00:48:14.920
it all you want.

00:48:14.920 --> 00:48:15.360
Yeah.

00:48:15.360 --> 00:48:15.840
Exactly.

00:48:15.840 --> 00:48:16.260
Yeah.

00:48:16.260 --> 00:48:17.480
So you don't have to worry about.

00:48:17.480 --> 00:48:17.720
Yeah.

00:48:17.720 --> 00:48:17.880
Yeah.

00:48:17.880 --> 00:48:21.680
So some of that state that's really hard to create one per interpreter, you're just like,

00:48:21.680 --> 00:48:22.520
well, it doesn't change.

00:48:22.520 --> 00:48:23.720
So here it is.

00:48:23.720 --> 00:48:24.000
Yeah.

00:48:24.000 --> 00:48:24.880
You don't have to check it either.

00:48:24.880 --> 00:48:25.340
Yeah.

00:48:25.340 --> 00:48:25.740
Cool.

00:48:25.740 --> 00:48:29.200
It just kind of makes sense when you think about it in a way, I think.

00:48:29.200 --> 00:48:32.640
You know, like, why would you track the reference counts for all of these objects?

00:48:32.640 --> 00:48:33.180
Exactly.

00:48:33.180 --> 00:48:35.680
You know, like, true and false are never going to be gone.

00:48:35.680 --> 00:48:36.560
So just forget it.

00:48:36.560 --> 00:48:39.180
Just leak that memory or whatever, right?

00:48:39.180 --> 00:48:39.880
Yeah.

00:48:39.880 --> 00:48:40.220
Yeah.

00:48:40.260 --> 00:48:40.440
All right.

00:48:40.440 --> 00:48:40.780
Let's see.

00:48:40.780 --> 00:48:42.180
What else we got to cover here?

00:48:42.180 --> 00:48:44.980
Maybe the issues and PR backlog?

00:48:44.980 --> 00:48:45.740
Sure.

00:48:45.740 --> 00:48:47.520
It's one of the, I think that's the longest one.

00:48:47.520 --> 00:48:47.740
Okay.

00:48:47.740 --> 00:48:47.920
Yeah.

00:48:47.920 --> 00:48:52.780
This is a pretty interesting aspect because it has to do with the developer in residence

00:48:52.780 --> 00:48:57.940
and Lucas Lange and all the improvements that having somebody dedicated to that role has

00:48:57.940 --> 00:48:58.420
brought, right?

00:48:58.420 --> 00:49:01.860
There are a lot of open issues and open PRs on CPython.

00:49:01.860 --> 00:49:07.800
But this talk was actually kind of taking a step back and looking philosophically about

00:49:07.800 --> 00:49:10.940
it and sort of saying, well, what is an issue for?

00:49:10.940 --> 00:49:13.320
You know, why there's all these issues.

00:49:13.320 --> 00:49:17.100
Some of them haven't had activity on them for five years or whatever.

00:49:17.100 --> 00:49:19.300
Like, why is that issue still open?

00:49:19.300 --> 00:49:21.240
Like, what is that doing for us really?

00:49:21.960 --> 00:49:23.340
And also, I guess, really quick shout out.

00:49:23.340 --> 00:49:25.080
This is from Edreet Catrail.

00:49:25.080 --> 00:49:25.640
Yes.

00:49:25.640 --> 00:49:26.740
This talk.

00:49:26.740 --> 00:49:29.740
So I think it's like two perspectives, right?

00:49:29.740 --> 00:49:36.420
You see the person who, when they open their phone at the bottom, it has 26,214 unread messages.

00:49:36.420 --> 00:49:38.100
The first is inbox zero.

00:49:38.100 --> 00:49:44.160
Like, you know, it's like, well, if we can't close this issue and we can't deal with it within

00:49:44.160 --> 00:49:46.100
five years, it's just friction.

00:49:46.100 --> 00:49:50.120
That's one side of the argument, I suspect, is it's friction.

00:49:50.120 --> 00:49:51.540
The other people are like, well, this is history.

00:49:51.680 --> 00:49:51.800
Yeah.

00:49:51.800 --> 00:49:52.460
Historical friction.

00:49:52.460 --> 00:49:53.500
What do we do about it?

00:49:53.500 --> 00:49:59.960
Sahih Spachaka, one of the most prolific SuperIcon core developers who's contributed more to

00:49:59.960 --> 00:50:00.960
SuperIcon, like I'd say.

00:50:00.960 --> 00:50:05.260
You're sort of saying, well, you know, sometimes I do come back to issues after five years.

00:50:05.800 --> 00:50:06.360
I do.

00:50:06.360 --> 00:50:11.960
I am planning on working on it, but I'm working on a lot of things and have hundreds of local

00:50:11.960 --> 00:50:14.000
branches and I'm working on loads of things at once.

00:50:14.000 --> 00:50:17.600
And sometimes I forget about something for five years and then come back to it, which is

00:50:17.600 --> 00:50:18.520
totally fair.

00:50:18.520 --> 00:50:19.060
It is fair.

00:50:19.180 --> 00:50:23.400
But I don't think like one person isn't going to fix all of those issues.

00:50:23.400 --> 00:50:26.060
You know, when you've got, how many is it now?

00:50:26.060 --> 00:50:30.540
See, six, over 6,500 open issues on the CPython repo.

00:50:30.540 --> 00:50:30.960
Yeah.

00:50:30.960 --> 00:50:31.280
Yeah.

00:50:31.360 --> 00:50:33.240
I don't know how I actually fall on this.

00:50:33.240 --> 00:50:37.360
I mean, on one hand, I totally get that you want to keep it around.

00:50:37.360 --> 00:50:42.920
On the other, if it was something really important, it would probably resurface again anyway.

00:50:42.920 --> 00:50:43.780
You know what I mean?

00:50:43.780 --> 00:50:44.120
Like...

00:50:44.120 --> 00:50:44.960
No, I completely get that.

00:50:44.960 --> 00:50:49.620
I think at the moment, my personal opinion is we do have too many open issues at the moment.

00:50:49.620 --> 00:50:52.400
And a lot of them just aren't ever going to have...

00:50:52.400 --> 00:50:55.720
Either aren't going to get fixed or like, if they are going to get fixed, it's not because

00:50:55.720 --> 00:50:56.680
of the issue being open.

00:50:56.680 --> 00:51:00.380
Like somebody else will just come along and be like, I'm going to fix this now.

00:51:00.380 --> 00:51:01.280
It's on GitHub now.

00:51:01.280 --> 00:51:05.840
You could apply a tag to it like closed due to old age or something.

00:51:05.840 --> 00:51:06.200
Yeah.

00:51:06.200 --> 00:51:06.960
And then just close them.

00:51:06.960 --> 00:51:08.220
They can be reopened.

00:51:08.220 --> 00:51:11.200
People could go, well, I really want to see all the ones that were closed due to old age,

00:51:11.200 --> 00:51:12.760
plus the ones that are open.

00:51:12.900 --> 00:51:16.140
You know, just create a search that shows that view.

00:51:16.140 --> 00:51:21.960
Somebody's really bored and is like, I really want to fix some Tkintered feature requests

00:51:21.960 --> 00:51:22.900
20 years ago.

00:51:22.900 --> 00:51:25.620
We can scroll through those.

00:51:25.620 --> 00:51:27.540
Yeah.

00:51:27.540 --> 00:51:28.900
Yeah, for sure.

00:51:28.900 --> 00:51:29.180
Okay.

00:51:29.180 --> 00:51:33.900
It's an interesting conversation and discussion and what to think about, but it's not something

00:51:33.900 --> 00:51:35.880
that directly affects people.

00:51:35.880 --> 00:51:39.320
Like that's the perfect kind of thing that's like handled at this meeting, right?

00:51:39.320 --> 00:51:40.660
Because it's really about those folks.

00:51:40.660 --> 00:51:40.900
Yeah.

00:51:40.900 --> 00:51:41.140
Yeah.

00:51:41.140 --> 00:51:41.360
All right.

00:51:41.380 --> 00:51:43.780
The final one, the F string grammar.

00:51:43.780 --> 00:51:48.880
We got f-strings in Python 3.6 and it's one of the most popular languages added recently,

00:51:48.880 --> 00:51:49.680
language features.

00:51:49.680 --> 00:51:51.140
Everyone loves it.

00:51:51.140 --> 00:51:55.700
I've heard people upgrading to 3.6 and beyond or throwing away old versions just so they can

00:51:55.700 --> 00:51:57.020
write f-strings, which is great.

00:51:57.020 --> 00:52:01.980
But it turns out that the actual parser for f-strings is kind of insane.

00:52:01.980 --> 00:52:02.740
I had no idea.

00:52:02.740 --> 00:52:03.560
Tell us about that.

00:52:03.620 --> 00:52:05.500
I think it was how many lines of code is it?

00:52:05.500 --> 00:52:06.540
I think it wrote it in the article.

00:52:06.540 --> 00:52:14.620
1,400 lines of custom C parser code just for f-strings that's separate from the regular parser.

00:52:14.720 --> 00:52:19.560
This whole file is just manually handwritten C code to parse f-strings.

00:52:19.900 --> 00:52:22.780
And Pablo brought up this crazy slide on that.

00:52:22.780 --> 00:52:24.280
This talk is by Pablo.

00:52:24.280 --> 00:52:25.400
And the Salgado.

00:52:25.400 --> 00:52:32.300
He is a core developer, steering council member, and lead manager for Python 3.10 and 3.11.

00:52:32.300 --> 00:52:35.440
So this is his big project.

00:52:35.440 --> 00:52:42.820
So yeah, Pablo brought up this crazy slide showing the dance that the interpreter has to go to

00:52:42.820 --> 00:52:44.240
whenever it encounters an F string.

00:52:44.240 --> 00:52:46.300
It's like a passed.

00:52:46.300 --> 00:52:50.520
It sounds really tricky to figure out because you've got all the captured variables.

00:52:50.520 --> 00:52:52.300
You've got to figure out how to pass those over.

00:52:52.300 --> 00:52:54.520
Then it goes to the parser and it's like, oh, geez.

00:52:54.520 --> 00:52:54.860
Okay.

00:52:54.860 --> 00:52:55.240
Yeah.

00:52:55.240 --> 00:52:56.020
So what is the idea?

00:52:56.020 --> 00:52:58.240
The idea is to make this part of the regular parser?

00:52:58.240 --> 00:53:02.900
Just move this over to bring it into the peg parser and all those kinds of things.

00:53:02.900 --> 00:53:03.360
Okay.

00:53:03.360 --> 00:53:03.740
Yeah.

00:53:03.740 --> 00:53:08.360
So since Python 3.9, Python has had a generated parser.

00:53:08.360 --> 00:53:16.180
So you just write all the grammar rules down in this file according to a mini language for

00:53:16.180 --> 00:53:16.520
the grammar.

00:53:16.520 --> 00:53:23.600
And then the program will generate a very large C file to parsing Python according to those

00:53:23.600 --> 00:53:23.840
rules.

00:53:23.840 --> 00:53:26.740
So it's a much nicer way of doing things.

00:53:26.740 --> 00:53:28.480
It's much less error prone.

00:53:28.480 --> 00:53:32.360
Just generate all the C code instead of writing it all out.

00:53:32.360 --> 00:53:37.900
And so Pablo's big idea is, yeah, let's just move all this F string parsing into the grammar.

00:53:37.900 --> 00:53:39.900
Do it all at the same time as that.

00:53:39.900 --> 00:53:41.460
Be much cleaner.

00:53:41.460 --> 00:53:43.920
It's nicer to maintain.

00:53:43.920 --> 00:53:47.500
And it also has some exciting things for users.

00:53:48.020 --> 00:53:53.900
It will mean that the code team will be able to do some big work on improving error messages,

00:53:53.900 --> 00:53:55.100
for example, for f-strings.

00:53:55.100 --> 00:54:01.060
It's currently quite hard to do because if you touch one corner of this C file, it could have

00:54:01.060 --> 00:54:04.940
a chain reaction to the rest of it and cause you 10 bugs and nobody wants that.

00:54:04.940 --> 00:54:05.720
Yeah, that's great.

00:54:05.720 --> 00:54:09.900
That's one of the other areas of focus there has been lately on improving error messages.

00:54:09.900 --> 00:54:10.780
That's good.

00:54:10.900 --> 00:54:11.040
Yeah.

00:54:11.040 --> 00:54:14.120
310 had improvements just in general for error messages.

00:54:14.120 --> 00:54:14.520
Yeah.

00:54:14.520 --> 00:54:16.740
Maybe that also comes from the peg parser, right?

00:54:16.740 --> 00:54:17.640
Like maybe that's related.

00:54:17.640 --> 00:54:21.320
If like the peg parser already has better error messages and you can get this into the peg parser,

00:54:21.320 --> 00:54:23.980
it'll just bring along better error messages more easily.

00:54:24.160 --> 00:54:26.940
So the peg parser is smarter than the old parser has.

00:54:26.940 --> 00:54:32.520
So like the old parser couldn't like look back when it encountered the syntax error, essentially.

00:54:32.520 --> 00:54:37.600
So like if it encountered the syntax error, it would just kind of throw up its hands and die on you.

00:54:37.600 --> 00:54:43.520
Whereas the new parser is able to catch the syntax error and then kind of look around context

00:54:43.520 --> 00:54:47.520
and then give you a better message using that context, essentially.

00:54:47.520 --> 00:54:48.020
That's great.

00:54:48.020 --> 00:54:48.280
Yeah.

00:54:48.280 --> 00:54:48.940
Yeah, yeah, sure.

00:54:48.940 --> 00:54:50.260
I think that pretty much covers it.

00:54:50.360 --> 00:54:54.080
Anything else you want to mention to people about the Language Summit?

00:54:54.080 --> 00:54:57.780
You wrote it up pretty well, I think, but there's something else not in there.

00:54:57.780 --> 00:54:59.960
Pythons.blogspot.com.

00:54:59.960 --> 00:55:02.120
It's the address if you want to read that.

00:55:02.120 --> 00:55:02.580
Yeah, for sure.

00:55:02.580 --> 00:55:04.480
I'll put the article in the show notes.

00:55:04.480 --> 00:55:05.680
I think we've pretty much covered everything.

00:55:05.680 --> 00:55:06.760
We've covered a lot anyway.

00:55:06.760 --> 00:55:08.840
Yeah, we have covered a lot, Alex.

00:55:08.840 --> 00:55:09.260
That's great.

00:55:09.260 --> 00:55:09.940
All right.

00:55:09.940 --> 00:55:13.100
Well, thanks for all of this and all your work on the other things as well.

00:55:13.100 --> 00:55:15.740
Before we get out of here, let me ask you the final two questions.

00:55:15.740 --> 00:55:20.200
If you're going to write some Python code, be it 312 or something new or older,

00:55:20.200 --> 00:55:21.320
what editor are you using?

00:55:21.320 --> 00:55:24.260
I'm actually using Idle quite a lot these days.

00:55:24.260 --> 00:55:24.960
Yeah, right on.

00:55:24.960 --> 00:55:26.220
I've used Pyjarm for a while.

00:55:26.220 --> 00:55:27.960
I've tried out VS Code several times.

00:55:27.960 --> 00:55:29.340
I've never really got on with it.

00:55:29.340 --> 00:55:30.380
I'm not quite sure why.

00:55:30.380 --> 00:55:30.660
Yeah.

00:55:30.660 --> 00:55:35.860
I loved all the features Pyjarm had, but nowadays I'm just enjoying something that just starts

00:55:35.860 --> 00:55:36.480
up really quickly.

00:55:36.480 --> 00:55:37.600
And it's just really simple.

00:55:37.600 --> 00:55:38.400
Something simple.

00:55:38.400 --> 00:55:39.280
All right, cool.

00:55:39.280 --> 00:55:39.460
Yeah.

00:55:39.460 --> 00:55:44.060
And then notable PyPI package or library, something you want to give a shout out to?

00:55:44.060 --> 00:55:48.660
I mean, we kind of sort of did that in a meta sense with TypeScript or TypeShed, rather.

00:55:48.820 --> 00:55:51.140
Yeah, am I allowed to shout out my own package?

00:55:51.140 --> 00:55:52.920
You can shout out whatever you want.

00:55:52.920 --> 00:55:54.240
Absolutely.

00:55:54.240 --> 00:55:57.060
I'll just give another shout out to Specialist, I think.

00:55:57.060 --> 00:55:58.880
I think that's really cool.

00:55:58.880 --> 00:56:00.760
Yeah, Specialist is neat.

00:56:00.760 --> 00:56:02.440
I'm glad I learned about that today.

00:56:02.440 --> 00:56:02.800
That's cool.

00:56:02.800 --> 00:56:03.500
All right.

00:56:03.500 --> 00:56:06.720
Well, I can seem magnanimous by shouting out somebody else's project.

00:56:06.720 --> 00:56:08.060
There you go.

00:56:08.060 --> 00:56:08.960
All right.

00:56:08.960 --> 00:56:10.280
Well, thanks for doing the write-up.

00:56:10.280 --> 00:56:12.840
Thanks for taking good notes and sharing it with everyone.

00:56:12.840 --> 00:56:19.060
Because while it makes total sense that the Language Summit is this closed-door story where

00:56:19.060 --> 00:56:24.000
people can have open conversations and just keep it amongst the core developers, I know

00:56:24.000 --> 00:56:28.400
everyone in the community really appreciates having a sense of what's coming, where the focus

00:56:28.400 --> 00:56:30.680
is, what people are worried about, and so on.

00:56:30.720 --> 00:56:33.320
So thanks for getting that out in the light for us.

00:56:33.320 --> 00:56:34.040
Yeah, no worries.

00:56:34.040 --> 00:56:35.200
It was fun to do.

00:56:35.200 --> 00:56:35.560
Yeah.

00:56:35.560 --> 00:56:36.480
Really fun to have this conversation.

00:56:36.480 --> 00:56:37.180
Yeah, you bet.

00:56:37.180 --> 00:56:37.820
Thanks.

00:56:37.820 --> 00:56:38.160
Awesome.

00:56:38.160 --> 00:56:38.680
Thanks, man.

00:56:38.780 --> 00:56:42.440
This has been another episode of Talk Python To Me.

00:56:42.440 --> 00:56:44.260
Thank you to our sponsors.

00:56:44.260 --> 00:56:45.860
Be sure to check out what they're offering.

00:56:45.860 --> 00:56:47.280
It really helps support the show.

00:56:47.280 --> 00:56:52.100
If you can browse the web, you can create sophisticated tests with Reflect.

00:56:52.100 --> 00:56:56.900
Navigate to your site within Reflect's simulated browser and perform actions you want to test.

00:56:56.900 --> 00:57:00.620
Let Reflect handle the painstaking work of test creation and maintenance.

00:57:00.620 --> 00:57:04.660
Sign up and get a free t-shirt at talkpython.fm/reflect.

00:57:04.660 --> 00:57:06.920
Starting a business is hard.

00:57:07.420 --> 00:57:13.020
Microsoft for Startups Founders Hub provides all founders at any stage with free resources

00:57:13.020 --> 00:57:15.540
and connections to solve startup challenges.

00:57:15.540 --> 00:57:20.080
Apply for free today at talkpython.fm/foundershub.

00:57:20.080 --> 00:57:21.920
Want to level up your Python?

00:57:21.920 --> 00:57:26.060
We have one of the largest catalogs of Python video courses over at Talk Python.

00:57:26.060 --> 00:57:31.160
Our content ranges from true beginners to deeply advanced topics like memory and async.

00:57:31.160 --> 00:57:33.820
And best of all, there's not a subscription in sight.

00:57:33.820 --> 00:57:36.740
Check it out for yourself at training.talkpython.fm.

00:57:37.000 --> 00:57:38.620
Be sure to subscribe to the show.

00:57:38.620 --> 00:57:41.400
Open your favorite podcast app and search for Python.

00:57:41.400 --> 00:57:42.720
We should be right at the top.

00:57:42.720 --> 00:57:52.080
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

00:57:52.080 --> 00:57:55.500
We're live streaming most of our recordings these days.

00:57:55.500 --> 00:58:03.280
If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

00:58:03.840 --> 00:58:05.200
This is your host, Michael Kennedy.

00:58:05.200 --> 00:58:06.480
Thanks so much for listening.

00:58:06.480 --> 00:58:07.640
I really appreciate it.

00:58:07.640 --> 00:58:09.560
Now get out there and write some Python code.

00:58:09.560 --> 00:58:09.840
Thank you.

00:58:09.840 --> 00:58:29.380


00:58:29.380 --> 00:58:30.200
Thank you.

00:58:30.200 --> 00:59:00.180
Thank you.

