WEBVTT

00:00:00.001 --> 00:00:06.520
Ever since Python 3.5 was released, we've had a really powerful way to write I/O bound async code

00:00:06.520 --> 00:00:11.620
using the async and await keywords. On this episode, you'll meet Nathaniel Smith, who wrote

00:00:11.620 --> 00:00:16.380
the Trio async framework that significantly simplifies complex coordinating operations

00:00:16.380 --> 00:00:23.680
using async and await. This is Talk Python to Me, episode 167, recorded June 21st, 2018.

00:00:23.680 --> 00:00:42.460
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the

00:00:42.460 --> 00:00:47.080
ecosystem and the personalities. This is your host, Michael Kennedy. Follow me on Twitter

00:00:47.080 --> 00:00:52.000
where I'm @mkennedy. Keep up with the show and listen to past episodes at talkpython.fm

00:00:52.000 --> 00:00:58.680
and follow the show on Twitter via @talkpython. This episode is sponsored by Linode and Rollbar.

00:00:58.680 --> 00:01:01.680
Please check out what they're offering during their segments. It really helps support the

00:01:01.680 --> 00:01:05.960
show. Nathaniel, welcome to Talk Python.

00:01:05.960 --> 00:01:07.280
Hey, thanks for having me.

00:01:07.280 --> 00:01:10.760
It's great to have you here. I've wanted to have you on for a long time. I, you know,

00:01:10.760 --> 00:01:18.120
listeners of the show probably know that I'm a fan of async programming and parallel programming.

00:01:18.120 --> 00:01:23.800
It's definitely gotten some feedback and some attention, but I think it's super important

00:01:23.800 --> 00:01:27.960
for Python. And I think what you're doing is incredible. Some of the stuff you showed at

00:01:27.960 --> 00:01:33.000
PyCon this year was incredible. So I'm just, I'm really excited to talk about it. Yeah, it's

00:01:33.000 --> 00:01:36.800
going to be fun. Before we get to that though, let's get your story into programming and Python.

00:01:36.800 --> 00:01:41.480
So let's see. So for getting into programming, I mean, I guess I was fortunate in my choice of

00:01:41.480 --> 00:01:47.600
parents. I was sort of, you know, born into sort of a relatively affluent family. And my mother was

00:01:47.600 --> 00:01:52.480
also a professional programmer. So she mostly stopped, you know, switched to sort of part-time consulting

00:01:52.480 --> 00:01:58.320
consulting when the kids came along. So she could be a stay at home mom. So actually I first learned a

00:01:58.320 --> 00:02:05.920
program through in my elementary school, they did have this program, this teaching logo to us that my

00:02:05.920 --> 00:02:13.920
mom created this project at my elementary school. Wow. That's pretty awesome. Many moms volunteer at

00:02:13.920 --> 00:02:20.960
schools, but not any of them. Right. Learning programs. Yeah, no, you know, my mom is pretty

00:02:20.960 --> 00:02:26.880
incredible. She also loves podcasts. So I mean, I guess, hey, hi, mom. Maybe she'll listen to this.

00:02:26.880 --> 00:02:34.000
Yeah. I mean, she later went on to get a master's in education, and now teaches art and science and

00:02:34.000 --> 00:02:39.920
programming. Yeah. But so yeah, so I got started early and was fortunate enough to have my own computer

00:02:39.920 --> 00:02:43.360
starting around like age 10 and so on. So this was like in the days when I was like,

00:02:43.360 --> 00:02:50.320
it was DOS. Windows 3.1 was pretty exciting. Like 386, 46 type thing. Oh yeah. Yeah. Turbo button to

00:02:50.320 --> 00:02:55.120
like make it go faster. Yeah. Yeah. We don't have turbo buttons anymore. No, it just always goes fast.

00:02:55.120 --> 00:02:59.680
Isn't that weird, right? Yeah. Yeah. Isn't there a little button to make your laptop half the speed?

00:02:59.680 --> 00:03:07.200
Why would everyone want that? So, and then I, from there I installed Linux when I was like 13 on my

00:03:07.200 --> 00:03:12.560
computer messing around. I had no idea what I was doing. It was Slackware 96 because like, was the name of it?

00:03:12.800 --> 00:03:16.640
It was, it's like, you know, Windows 95 was the big thing then. So like, this was one better, right?

00:03:16.640 --> 00:03:17.520
96.

00:03:17.520 --> 00:03:23.760
Exactly. Yeah. Right. So yeah. So I've kind of been, you know, bumming around that kind of,

00:03:23.760 --> 00:03:28.560
you know, programming open source world for something years now. It took me a little longer to get into

00:03:28.560 --> 00:03:33.600
Python. I don't remember exactly when it probably, you know, five years later. So I know the first time

00:03:34.160 --> 00:03:37.440
people were talking about, you know, Python was this cool new thing. It's, you know, kind of like

00:03:37.440 --> 00:03:43.280
Perl, but so forth. first time I read the tutorial, I got to the point where it said that

00:03:43.280 --> 00:03:47.760
Lambda was syntactically limited to a single expression and just like rage quit. I was like,

00:03:47.760 --> 00:03:49.360
whatever, stupid language.

00:03:49.360 --> 00:03:52.080
Where are the curly braces? Come on.

00:03:52.080 --> 00:03:55.760
Yeah. Well, it wasn't, I mean, I guess also like, so like, but I had like sort of like logo,

00:03:55.760 --> 00:04:01.040
I learned scheme and things like that. So like, this was like obviously terrible. I'd later came

00:04:01.040 --> 00:04:05.680
back to it, got over that. And I, and under, you know, understand now why that makes sense in terms

00:04:05.680 --> 00:04:10.800
of the block structure and everything, but the statement expression distinction that Python has,

00:04:10.800 --> 00:04:16.240
but, it took me a little while, but yeah. So I, yeah, I guess I got into Python around

00:04:16.240 --> 00:04:22.160
like 2.2 or so. And it sort of gradually become, you know, just sort of my main language.

00:04:22.160 --> 00:04:27.680
In the meantime, I was also like, you know, I was getting a PhD, stuff like that. So using Python

00:04:27.680 --> 00:04:34.320
for both like hobby hacking stuff. And also like for my, in my work, you know, for data analysis,

00:04:34.320 --> 00:04:37.520
I wrote some various libraries there. What's your PhD in?

00:04:37.520 --> 00:04:38.480
Yeah. Cognitive science.

00:04:38.480 --> 00:04:39.920
Oh, right. Okay. Very awesome.

00:04:39.920 --> 00:04:44.800
Yeah. Yeah. So it was like studying how people understand language and brains understand language.

00:04:44.800 --> 00:04:49.440
Yeah. So yeah. So along the way, and then, yeah, getting embedded and all these different sort of,

00:04:49.440 --> 00:04:53.760
you know, entangled in all these different sort of open source projects, like NumPy and so on.

00:04:53.760 --> 00:04:57.040
Yeah. Yeah. That's really great. So what do you do these days?

00:04:57.040 --> 00:05:01.760
So I'm actually kind of in a bit of transition right now. So the last few years, I've been

00:05:01.760 --> 00:05:06.880
working at UC Berkeley at the Berkeley Institute for Data Science, which is a sort of new

00:05:07.520 --> 00:05:12.400
data science center. That's what started up on campus. And so in my position has been sort of

00:05:12.400 --> 00:05:19.280
this unique, one really where it's, been, I've been grant funded to sort of figure out how to,

00:05:19.280 --> 00:05:25.280
you know, make sure the Python, you know, continues to work well, works better for scientists. There's

00:05:25.280 --> 00:05:30.160
a, actually there's a blog post we can like put a link to there. I wrote just sort of talking about

00:05:30.160 --> 00:05:35.680
all this sort of stuff I've done there, but some highlights being like, I got, some grants for

00:05:35.680 --> 00:05:41.840
a NumPy development, $1.3 million over a few years, which is basically the first time NumPy

00:05:41.840 --> 00:05:48.080
has been funded. We'll have full-time people working on it. Did I made a color map people like,

00:05:48.080 --> 00:05:54.880
did some work on packaging? So like, many Linux sort of led that effort so we can have wheels on

00:05:54.880 --> 00:06:00.000
Linux now. That sounds like a really fun job. Like you get to actually make a difference in

00:06:00.000 --> 00:06:04.240
the open source space. Exactly. Yeah. I mean, it partly it's, it's sort of funny. Like this is what

00:06:04.240 --> 00:06:08.640
I talk about in the blog post, but like, you know, open source is just sort of like desperately underfunded.

00:06:08.640 --> 00:06:14.400
And like, it's amazing how well and effectively we can use the little bits of volunteer time and

00:06:14.400 --> 00:06:18.480
things that people manage or, you know, people have spending, you know, a few hours a week.

00:06:18.480 --> 00:06:24.480
But there's a lot of things that like larger projects that have huge impact that can't be

00:06:24.480 --> 00:06:28.480
done in that mode where you actually need to like sit down for a little while and think about it and,

00:06:28.480 --> 00:06:31.920
you know, understand the landscape, put some focused effort into something.

00:06:31.920 --> 00:06:38.560
Yeah. It's a difference on like what you take as your goal. If you have a month of uninterrupted full

00:06:38.560 --> 00:06:44.320
time, some project or a goal part of project versus I'm going to squeeze this in

00:06:44.960 --> 00:06:49.200
Saturday morning before the kids get up, right? These are the same types of things you attack.

00:06:49.200 --> 00:06:53.840
Exactly. Yeah. I mean, it's like a month of time is not that much in the grand scheme of things. One

00:06:53.840 --> 00:06:58.560
person, one month is like compared to, you know, the amount of labor that like, you know, Google has

00:06:58.560 --> 00:07:03.440
available. Yeah. But it's still, you know, enables all kinds of things that right now just

00:07:03.440 --> 00:07:07.440
aren't happening. And so there's actually lots of low hanging fruit because no, there is nobody

00:07:07.440 --> 00:07:13.200
almost who has that kind of time to worry about these sort of broad open source ecosystem kind of projects.

00:07:14.240 --> 00:07:19.120
There's just, there's all kinds of... We saw how much of a difference was made with the Mozilla

00:07:19.120 --> 00:07:21.120
grant, the Python package.

00:07:21.120 --> 00:07:22.160
Or the PyPI. Yes.

00:07:22.160 --> 00:07:27.200
Yeah. The PyPI, like that was like, hey, look, $170,000. Oh, actually this can happen. It's

00:07:27.200 --> 00:07:29.600
been dragging on for years. Now it's, you know, it's real.

00:07:29.600 --> 00:07:34.320
Yeah. Yeah. I mean, getting the team together to make that happen. Yeah. I had a little bit of

00:07:34.320 --> 00:07:39.280
involvement on that. I'm on the PSF's packaging working group. I didn't, I wasn't heavily involved

00:07:39.280 --> 00:07:43.360
in that. You know, I like made some introductions, gave some feedback on the grant and things.

00:07:43.360 --> 00:07:48.720
So it was, yeah, it's just super exciting to see that up close. Because yeah, it was very successful.

00:07:48.720 --> 00:07:49.760
And it wasn't...

00:07:49.760 --> 00:07:53.040
Like it really got a lot out of how much investment was put into it.

00:07:53.040 --> 00:07:58.960
Yeah. I mean, it was like, that had been dragging on for literally six years. The old PyPI was just

00:07:58.960 --> 00:08:02.480
totally unworkable. But, you know.

00:08:03.600 --> 00:08:08.480
It was like Kryptonon for people who wanted to contribute to open source. They looked at it and

00:08:08.480 --> 00:08:10.800
like, oh, no, no, I'm not touching that. That's...

00:08:10.800 --> 00:08:16.000
Yeah. I made one patch to the old PyPI. And it was just a trivial thing. It was just that we wanted it

00:08:16.000 --> 00:08:21.120
to start to say that, oh yeah, many Linux is now a legal thing for a wheel to have in its name.

00:08:21.120 --> 00:08:25.040
So it was just like, there's like a list of strings that allowed, I'm just adding one new string,

00:08:25.040 --> 00:08:30.720
right? That was the most terrifying patch I've ever made. PR I've ever made. Because it's like,

00:08:30.720 --> 00:08:37.280
if I have a typo, then PyPI dies, right? And there are no tests. There's nothing, right?

00:08:37.280 --> 00:08:40.240
The consequences of failure is so high.

00:08:40.240 --> 00:08:41.600
Yeah. Exactly.

00:08:41.600 --> 00:08:47.520
Yeah. The new PyPI is way, way better. You should all go and help make it contribute. Because now

00:08:47.520 --> 00:08:52.080
it's all set up. You can develop locally and there's a real test suite.

00:08:52.080 --> 00:08:58.160
Yeah. It's really nice. I had the people involved on the show a couple episodes back too. So it

00:08:58.160 --> 00:09:01.440
definitely got a chance to dig into that. Oh yeah. Right. That's right. Yeah. Yeah.

00:09:01.440 --> 00:09:04.720
So let's talk a little bit about async. Yeah.

00:09:04.720 --> 00:09:04.720
Yeah.

00:09:04.720 --> 00:09:09.600
Because I think that that's one of the sort of revitalized areas of Python last,

00:09:09.600 --> 00:09:16.640
since 3.4, 3.5, it really started coming along, right? So what, in 3.4, we got asyncio as a thing.

00:09:16.640 --> 00:09:22.560
And in 3.5, it really, I feel like it really got more accessible with async and await.

00:09:22.560 --> 00:09:26.480
Right. With the new syntax features to make it easier to use. Exactly. Yeah.

00:09:26.480 --> 00:09:31.360
Yeah. Yeah, exactly. Like the keep it, the foundation was built previously, but it was,

00:09:31.360 --> 00:09:37.280
it was still this sort of callback hell type of programming, right? Right.

00:09:37.280 --> 00:09:41.920
Right. We should maybe take a little bit of a step back and just, you know, let people know about

00:09:42.160 --> 00:09:46.720
the presentation you gave at PyCon, which introduces your project TRIA, which is what we're going to

00:09:46.720 --> 00:09:51.680
focus on. But in your talk, you sort of set the stage and said, look, there's these two

00:09:51.680 --> 00:09:58.960
philosophies or types of async programming that you might consider. So maybe, maybe you could touch on

00:09:58.960 --> 00:10:03.280
that a little. Well, so, I mean, I think the first thing to say is for those who aren't kind of already,

00:10:03.280 --> 00:10:08.560
you know, up on the jargon, async is sort of a subset of concurrent programming. And so concurrency,

00:10:08.560 --> 00:10:14.160
meaning writing programs that do two things at the same time, which is very handy. You know,

00:10:14.160 --> 00:10:18.080
it's something in our real life we do all the time, you know, you know, I'm working on one thing and my

00:10:18.080 --> 00:10:22.080
friends working on another thing at the same time. It's very natural. But writing a program that does

00:10:22.080 --> 00:10:27.680
that is a little bit trickier, especially, you know, in Python is kind of generally a sequential

00:10:27.680 --> 00:10:31.680
language, right? It makes it easy to do, I want to do this and then that and then the other thing.

00:10:31.680 --> 00:10:36.240
It doesn't directly have built into like the syntax, whatever ways to say, I want to do these

00:10:36.240 --> 00:10:39.520
two things at the same time. And then when they're both done, do these other things.

00:10:39.520 --> 00:10:43.920
So, so generally, there's this general question of like, how do you write concurrent programs in Python?

00:10:43.920 --> 00:10:48.960
And then I think what you were thinking of, there's kind of two philosophies of concurrency,

00:10:48.960 --> 00:10:56.000
which is one is the kind of preemptive concurrency that threads give you, where just everything

00:10:56.000 --> 00:11:00.240
just kind of runs all the time interleaved kind of in arbitrary ways.

00:11:00.240 --> 00:11:04.720
To be clear, this is in general threads, not Python threads, because we have this whole

00:11:04.720 --> 00:11:05.280
thing called the gil.

00:11:05.280 --> 00:11:09.920
From the programmer, from the user's point of view, the gil doesn't make, gil makes things

00:11:09.920 --> 00:11:14.800
slower, but it doesn't make it really change what it feels like to use it compared to threads in

00:11:14.800 --> 00:11:15.520
general. True.

00:11:15.520 --> 00:11:20.240
So in general in threads, you might have like two threads actually running at the same time,

00:11:20.240 --> 00:11:24.080
like on two different views. Because of Python, we have the global interpreter off the gil,

00:11:24.080 --> 00:11:28.480
multiple, then it means that mostly only one thread can actually run at a time.

00:11:28.480 --> 00:11:33.760
But because in Python interpreter controls that, it can decide at any moment to switch which thread

00:11:33.760 --> 00:11:38.800
is running. From your point of view, as writing code in Python, it might as well be running multiple

00:11:38.800 --> 00:11:42.240
things at the same time, basically, right? Because since it could switch at any moment,

00:11:42.240 --> 00:11:45.760
you kind of have to act like it's just constantly switching, right?

00:11:45.760 --> 00:11:50.480
And the reason this is kind of a challenge is because if you have a data structure, and you have two

00:11:50.480 --> 00:11:55.280
different threads or whatever, you know, you have two different concurrent pieces of code acting on

00:11:55.280 --> 00:11:59.040
the data structure at the same time, if they're not like, if you're not careful, you can make a big

00:11:59.040 --> 00:12:05.120
mess. So like, you know, one, you have the classic examples are things like, you know, your program is

00:12:05.120 --> 00:12:09.040
like managing like a bank. And so I'm going to withdraw money from this account, and then add it,

00:12:09.040 --> 00:12:14.720
put it in this account. But if you don't do that, like atomically, so like ice, you know, first one,

00:12:14.720 --> 00:12:19.920
one thread says, okay, does Alice have enough money? Yeah, great. Okay, I'll take that money out and put it

00:12:19.920 --> 00:12:24.640
into Bob's account. Another thread says, oh, does Alice have enough money for this transfer to Carl?

00:12:24.640 --> 00:12:28.480
And then if they're in a leave right, first both threads check and say, oh, yeah, Alice has plenty of money.

00:12:28.480 --> 00:12:33.280
And then both threads take money out of the account. And now Alice has spent the same money twice, actually.

00:12:33.280 --> 00:12:35.760
Yeah, great for Alice, but not so nice for the bank.

00:12:35.760 --> 00:12:40.160
So yeah, someone's gonna be trouble running writing that software.

00:12:40.160 --> 00:12:44.720
Yeah, right. So yeah, if you're writing that software, you need to sort of manage this.

00:12:44.720 --> 00:12:48.400
Yeah. So one of the things that kind of helped me this like click in my mind was

00:12:48.400 --> 00:12:54.480
thinking about how programs temporarily enter these invalid states.

00:12:54.480 --> 00:12:55.600
Right.

00:12:55.600 --> 00:12:59.520
What you're describing is basically that like at the beginning of that function,

00:12:59.520 --> 00:13:04.400
the bank is in a valid state. At the end of the function, everything is valid. But somewhere in

00:13:04.400 --> 00:13:09.920
between in order to accomplish that operations as a series of steps, it has to become invalid. And

00:13:09.920 --> 00:13:16.160
long as nobody observes it in this invalid state, it's all good. But when they do like, like you're

00:13:16.160 --> 00:13:21.040
describing halfway through, it's not okay anymore. It's kind of like transactions and databases,

00:13:21.040 --> 00:13:25.600
but in time. And yeah, they're pretty similar in some ways, I guess.

00:13:25.600 --> 00:13:31.280
Yeah. So yeah, exactly. So with threads, which the solution to this is you have to sort of explicitly,

00:13:31.280 --> 00:13:36.080
like, make sure you notice all those places where you're passing through that invalid state and do

00:13:36.080 --> 00:13:40.400
some kind of in like market somehow in your source code, like say, okay, I'm going to take a lock here.

00:13:40.400 --> 00:13:44.400
That's going to make sure that anyone else who tries to use this has to wait for me to be done

00:13:44.400 --> 00:13:48.080
and things get back to the valid state before they can look at it. Right?

00:13:48.080 --> 00:13:51.360
Yeah, exactly. Okay. But that's really error pro.

00:13:51.360 --> 00:13:53.440
And this is preemptive concurrency, right?

00:13:53.440 --> 00:13:55.760
Yeah, exactly. It's still talking about kind of how threads work, right?

00:13:55.760 --> 00:13:59.440
Yep. So you would have to like find all these places where you go through a temporarily

00:13:59.440 --> 00:14:05.440
invalid state and mark them in your source code. And if you forget one, then you have this nasty bug

00:14:05.440 --> 00:14:10.080
where Alice gets to suspend the money twice or all kinds of weird things can happen.

00:14:10.080 --> 00:14:12.880
And it usually has to do with timing. And so it's very,

00:14:12.880 --> 00:14:13.920
super hard to debug.

00:14:13.920 --> 00:14:17.120
Yeah. And it's like, yeah, it's like super subtle. Like, yeah,

00:14:17.120 --> 00:14:20.560
like it only happens one in a thousand times randomly. And it happens,

00:14:20.560 --> 00:14:23.440
it depends how much memory you have. And it's only happens in production and not on your tests.

00:14:23.440 --> 00:14:27.280
And just all kinds of, it's really, really, yeah, it's bad. Yeah.

00:14:27.280 --> 00:14:30.080
Yeah. I've heard them described as Heisen bugs. And I just love that term.

00:14:30.080 --> 00:14:32.960
Yes. Yes. Heisen bugs. Right. And it's just like,

00:14:32.960 --> 00:14:34.240
and so it means that when you're working with threads,

00:14:34.240 --> 00:14:37.280
you just have to be like constantly vigilant, right? Like every line of code,

00:14:37.280 --> 00:14:40.960
which we think, okay, is this the one that's going to introduce this terrible bug?

00:14:40.960 --> 00:14:44.240
So that's, that sucks, right? You don't want to live like that.

00:14:44.400 --> 00:14:51.840
So, yeah, right. You just have to be like constantly paranoid. So yeah. So the idea for

00:14:51.840 --> 00:14:56.080
async concurrency, because we kind of flip it around instead of saying that like, okay,

00:14:56.080 --> 00:15:01.280
we have to go through and find all the places in the source code where something dangerous is

00:15:01.280 --> 00:15:05.200
happening and mark those. You say, you know what, let's be conservative. Let's assume something

00:15:05.200 --> 00:15:09.840
dangerous could be happening anywhere. That's the default. So by default, only one thing is allowed to

00:15:09.840 --> 00:15:14.720
happen at a time. And then we'll mark in the source code, you know, okay, here's a place where

00:15:14.720 --> 00:15:19.360
I want to let other things happen. It's okay for, I'm not in the middle of, you know, just doing some

00:15:19.360 --> 00:15:24.160
delicate operation, you know, adjusting someone's bank account. This is a fine place for that to happen.

00:15:27.200 --> 00:15:31.760
This portion of talk Python to me is brought to you by Linode. Are you looking for bulletproof

00:15:31.760 --> 00:15:35.760
hosting that's fast, simple, and incredibly affordable? Look past that bookstore and check

00:15:35.760 --> 00:15:43.440
out Linode at talkpython.fm/linode. That's L I N O D E. Plans start at just $5 a month for a

00:15:43.440 --> 00:15:48.880
dedicated server with a gig of RAM. They have 10 data centers across the globe. So no matter where you are,

00:15:48.880 --> 00:15:54.560
there's a data center near you. Whether you want to run your Python web app, host a private get server

00:15:54.560 --> 00:16:01.520
or file server, you'll get native SSDs on all the machines, a newly upgraded 200 gigabit network,

00:16:01.520 --> 00:16:06.880
24 seven friendly support, even on holidays and a seven day money back guarantee. Do you need a little

00:16:06.880 --> 00:16:11.840
help with your infrastructure? They even offer professional services to help you get started

00:16:11.840 --> 00:16:17.760
with architecture, migrations, and more. Get a dedicated server for free for the next four months. Just visit

00:16:17.760 --> 00:16:20.080
talkpython.fm/linode.

00:16:20.080 --> 00:16:26.000
And you can still have bugs. You can still make mistakes and put that in the wrong place.

00:16:26.000 --> 00:16:31.360
Because now there's only like a finite number of places to check when something goes wrong, right?

00:16:31.360 --> 00:16:34.000
It's just much easier to reason about that kind of program.

00:16:34.000 --> 00:16:39.440
Right. And that could be done with just straight up asyncio. But with three, five and above,

00:16:39.440 --> 00:16:44.160
like basically the await keyword is the marker in your code for that.

00:16:44.160 --> 00:16:45.840
Exactly. Yeah.

00:16:45.840 --> 00:16:50.320
Yeah. Yeah. That's pretty beautiful. That's pretty beautiful. So I'm guessing,

00:16:50.320 --> 00:16:54.560
I'm guessing most people probably under understand like how to use async and await the keywords,

00:16:54.560 --> 00:17:01.200
but maybe just describe like what's, how to define like a super, super simple async method with the

00:17:01.200 --> 00:17:02.160
keyword, just to the people understand this.

00:17:02.160 --> 00:17:07.680
Yeah. Like you said, I'm going to be focusing on trio here and trio does kind of use only kind of a

00:17:07.680 --> 00:17:12.560
simple subset. There's some extra complexity needed for like backwards compatibility with async

00:17:12.560 --> 00:17:17.040
IOS sort of called that place thing. We can get, talk about that more later. But sort of for if,

00:17:17.040 --> 00:17:21.280
especially if you're just, you know, if you're using trio, async await is very simple actually.

00:17:21.280 --> 00:17:26.160
And so here's what you need to know is that there are two kinds of functions. There's the async ones,

00:17:26.160 --> 00:17:31.920
which are these, the special functions that might let other code run during them. And so you kind of

00:17:31.920 --> 00:17:35.600
need to be aware of what you call one of them that like, you know, the ground might shift under

00:17:35.600 --> 00:17:40.000
feet, data structures might change while it's happening. And there's the regular functions,

00:17:40.000 --> 00:17:45.360
like the synchronous functions where those always happen atomically. And so, and we're going to do is

00:17:45.360 --> 00:17:49.520
we're going to make all the regular Python functions you already know, those are going to be the synchronous

00:17:49.520 --> 00:17:53.760
ones. Because, you know, no one, you know, they're all written on the assumption that like, you know,

00:17:53.760 --> 00:17:58.240
Python's a sequential language, it does things sequentially. And so they, no one like thought about

00:17:58.240 --> 00:18:03.280
how to handle this async stuff when they were writing all these libraries that already exist.

00:18:03.280 --> 00:18:09.120
So those are going to be all atomic. And then we need a way to mark these special async functions.

00:18:09.120 --> 00:18:12.800
And we want to mark it at two places. So what we want to mark it when we define the function

00:18:12.800 --> 00:18:18.160
so that we, you know, as part of the API, is this an async function or not? And we want to mark it at

00:18:18.160 --> 00:18:22.080
the call sites. When you call one of these, when you're like reading through your code, you see, ah,

00:18:22.080 --> 00:18:26.320
this is a point where I'm calling an async function. This is a point where other code might run in the

00:18:26.320 --> 00:18:29.680
background, I need to make sure I'm not in the middle of some, you know, dangerous operation.

00:18:29.680 --> 00:18:30.240
Right?

00:18:30.240 --> 00:18:34.080
Right. Okay. So you've got like, maybe a call to a web service or something.

00:18:34.080 --> 00:18:39.680
Yeah, that might return like a future, which then you hook in a call.

00:18:39.680 --> 00:18:43.600
So there are no futures in Trio. That was one of the things I got rid of.

00:18:43.600 --> 00:18:48.880
Yes. Yeah, that's beautiful. Yeah. But you got to, you have to wait on the result, basically.

00:18:48.880 --> 00:18:49.040
Right?

00:18:49.040 --> 00:18:53.760
So yeah. I mean, so yeah, so the way, yeah, the way you think about it for Trio is just that,

00:18:54.400 --> 00:18:57.760
it's just like, there are these special functions and the way you call it is you type

00:18:57.760 --> 00:19:01.680
a weight and then the function call. It's like a new kind of syntax for calling a function.

00:19:01.680 --> 00:19:02.560
Right.

00:19:02.560 --> 00:19:05.920
And that's sort of all you need to know. There is, yeah, like you said, like there's the

00:19:05.920 --> 00:19:09.920
complexities around Python also supports a weighting on objects and having future objects,

00:19:09.920 --> 00:19:14.880
like the function to return and so on and so forth. But it's kind of unnecessary clutter is

00:19:14.880 --> 00:19:17.840
kind of how Trio's perspective on it. So we just don't do any of that.

00:19:17.840 --> 00:19:22.800
Yeah. I feel like the AsyncIO layer is like, let's get something kind of working,

00:19:22.800 --> 00:19:28.640
but it's not that delightful. And I feel like Trio really cleans it up. So there's a really great

00:19:28.640 --> 00:19:33.360
example that you gave in your talk about happy eyeballs, which is like a way to try to use

00:19:33.360 --> 00:19:39.360
basically DNS resolution to connect a socket to a server and some concurrency stuff around that,

00:19:39.360 --> 00:19:43.600
which is, I don't want to talk about that yet. Maybe we'll have some time to talk about it later. But

00:19:43.600 --> 00:19:49.520
basically there's a version in Twisted, which is how long was the one in Twisted? Hundreds?

00:19:49.520 --> 00:19:54.640
And so, yeah, well, yeah, there's two different versions of Twisted I talked about in the talk.

00:19:54.640 --> 00:20:00.160
One is the sort of the classic one that's in in master, which is like 120 lines long, I think,

00:20:00.160 --> 00:20:04.720
roughly. I mean, not that it's not super meaningful to talk about lines of code like this, but like

00:20:04.720 --> 00:20:07.120
just kind of give you a sense. Yeah. Yeah, exactly.

00:20:07.120 --> 00:20:12.880
A better sense of complicated is to reason about that is it has inside this method. It has another

00:20:12.880 --> 00:20:16.080
internal function. Inside that function, there's another function defined. And then inside that,

00:20:16.080 --> 00:20:20.720
there's a fourth level of internal functions. So like, yeah, that's bad.

00:20:20.720 --> 00:20:24.160
Because it's all these. Yeah. Yeah.

00:20:24.160 --> 00:20:30.240
Almost like it's full of all these go to's and in some weird sense. And then, and you basically say,

00:20:30.240 --> 00:20:34.800
now, if we apply the building blocks or the primitives of trio to it, oh, look, it's like 20 lines,

00:20:34.800 --> 00:20:38.960
and it's totally straightforward, which is really great. So I think, you know, let's talk about trio.

00:20:40.000 --> 00:20:45.600
Why don't you start by telling people what it is. Trio is a library for a sink concurrency in Python.

00:20:45.600 --> 00:20:52.560
It's like an alternative to libraries like a sink or twisted or so on, which NATO or threads,

00:20:52.560 --> 00:20:57.680
sort of all of them. And I think there's kind of, I think it was, there's kind of two pieces. So one

00:20:57.680 --> 00:21:03.440
is there's sort of the idea trio, the ideas are like a research project or something where I have,

00:21:03.440 --> 00:21:08.160
I sort of did some analysis of like, what is it about twisted and I think I own someone that makes

00:21:08.160 --> 00:21:13.440
it so difficult to use sometimes, or why are things like happy eyeballs so complicated?

00:21:13.440 --> 00:21:18.000
Where are some common errors sort of come from? It came up like, oh, that's actually I sort of,

00:21:18.000 --> 00:21:21.280
as I dug into it, I realized actually, there's, you know, a small number of things that kind of

00:21:21.280 --> 00:21:26.640
seem to cause a lot of the problems, and even ended up digging into some old literature from like the

00:21:26.640 --> 00:21:32.320
60s, about early programming language design. On Univac or what was that one on? That was like

00:21:32.320 --> 00:21:38.880
a really old computer. Oh, oh, Flowmatic. The, that language, which is, yeah, the Grace Hopper's

00:21:38.880 --> 00:21:42.720
language, the precursor to COBOL, which is a really interesting language. That's going way back. Yeah.

00:21:42.720 --> 00:21:47.600
Yeah. Yeah. And sort of talking about this transition, there was a lot of debates then about like,

00:21:47.600 --> 00:21:51.440
how do you structure your language, not even getting into the concurrency part, just like,

00:21:51.440 --> 00:21:56.560
how do you do a language at all that's like usable? And one of the big things that happened was

00:21:56.560 --> 00:22:02.320
this switch from using go to as the main control structure to having things like if statements and

00:22:02.320 --> 00:22:08.880
functions and for loops and so on. And I realized there's actually sort of an analogy there that's

00:22:08.880 --> 00:22:16.000
surprisingly like precise between a lot of that, a lot of these async libraries are actually still

00:22:16.000 --> 00:22:21.440
kind of in the go to stage, where sort of the basic primitives are in sort of a technical way,

00:22:21.440 --> 00:22:25.760
kind of analogous to a go to, and they cause similar kinds of problems. And then if you look at,

00:22:25.760 --> 00:22:29.920
okay, how did, you know, Dijkstra solve these problems back in the late sixties,

00:22:29.920 --> 00:22:34.480
we can take those and apply them to concurrency. And that leads to something called,

00:22:34.480 --> 00:22:38.960
I call it a nursery concept. Yeah. It's so interesting. And I had, yeah. And I had never

00:22:38.960 --> 00:22:44.800
thought about the relationship between go to and many of these programming, these threaded programming

00:22:44.800 --> 00:22:50.400
models, but you really hit it. Well, I think it's a super good analogy and it's really relevant.

00:22:50.400 --> 00:22:56.320
Because so what Dijkstra said was, look, you should be able to treat these building blocks as black boxes.

00:22:56.320 --> 00:23:01.360
Stuff goes in, stuff goes out. That's all. If you know kind of what it does, you don't need the details,

00:23:01.360 --> 00:23:05.600
right? I mean, this is like a huge part of abstraction and programming, like functions,

00:23:05.600 --> 00:23:09.760
classes, it's modules, et cetera. Right. Like, like even just think of like,

00:23:09.760 --> 00:23:17.200
like in Python, think of the print function, right? Like in actually it does all kinds of complicated

00:23:17.200 --> 00:23:22.400
stuff, right? It's got talking to the operating system interfaces to do IO and it's like buffer

00:23:22.400 --> 00:23:26.880
a thing and character second version and blah, blah, blah. But like, you don't have to care about

00:23:26.880 --> 00:23:30.240
that. You just type print hello world. And it, you know, it prints all the world.

00:23:30.240 --> 00:23:33.920
You can just treat that as like this little atomic unit. And that's great.

00:23:33.920 --> 00:23:36.960
That kind of. Yeah. It's such an important part of a building block of programming,

00:23:36.960 --> 00:23:41.920
but these threads mean that stuff can still be going. You're just like all over the place. Right.

00:23:41.920 --> 00:23:44.960
And it's very similar to the go-to's, which I thought that was a great analogy.

00:23:44.960 --> 00:23:48.960
Yeah. I mean, specifically the issue is, so like, let's say the analog of print,

00:23:48.960 --> 00:23:52.400
like in say twisted, you have this transport object. That's like your connection,

00:23:52.400 --> 00:23:55.760
like a network connection and you call it's right method. And this is like,

00:23:55.760 --> 00:23:59.920
I want to send this data to the remote site now. And that's like a function. You call it

00:23:59.920 --> 00:24:04.720
it returns. That's all fine. But what's sort of confusing is that when you call it,

00:24:04.720 --> 00:24:08.880
it returns, it hasn't actually finished yet. What it's actually done is sort of scheduled

00:24:08.880 --> 00:24:12.800
that right to happen in the background. And that makes it hard to reason about the flow.

00:24:12.800 --> 00:24:17.120
Cause it's like, Oh, the functions returned, but actually in a sense, it's like kind of still running.

00:24:17.120 --> 00:24:21.040
Right. And now if I want to write and then do something else that happens after that,

00:24:21.040 --> 00:24:26.080
that's hard to manage because I don't necessarily know when that's actually finished. I have to use some

00:24:26.080 --> 00:24:29.600
other API to like check and ask, okay, has it actually written yet?

00:24:29.600 --> 00:24:30.720
Yeah. And so yeah.

00:24:30.720 --> 00:24:34.160
Did it succeed? Did it not succeed? Then how do you deal with that? And then how do you get that

00:24:34.160 --> 00:24:37.920
back into your, yeah, your whole, it's yeah. It feels like almost like JavaScript.

00:24:37.920 --> 00:24:42.560
Well, I mean, JavaScript, you know, is also in this general family of like, yeah,

00:24:42.560 --> 00:24:48.400
it is as this async currency model that's sort of endemic to it. We use all over the place and it's

00:24:48.400 --> 00:24:52.000
all callback based and it's all, yeah, it has that same kind of go-to problem.

00:24:52.000 --> 00:24:58.000
Yeah, exactly. So let's talk about the architecture and then maybe like we can see about how that kind

00:24:58.000 --> 00:25:01.520
of brings us back into something that Dykstra might be proud of.

00:25:01.520 --> 00:25:05.760
Okay. Sure. Yeah. I guess I should also mention, so I don't know how,

00:25:07.120 --> 00:25:11.440
this is a discussion that really benefits from like diagrams, which is not something podcasts or

00:25:11.440 --> 00:25:18.560
there is also, I have a blog post called notes on structured concurrency or go statement considered

00:25:18.560 --> 00:25:23.040
harmful, which goes into this and sort of this set of ideas and much more detailed pictures and all

00:25:23.040 --> 00:25:27.680
that. But so yeah, so the basically the idea is that, I mean, so it's what I said, right? That like,

00:25:27.680 --> 00:25:32.320
when you call a function, it should be something you can treat as a black box. It does some stuff,

00:25:32.320 --> 00:25:36.640
it returns. That's kind of what Dykstra's point. I mean, that's the problem with go to is also that

00:25:36.640 --> 00:25:43.520
like, you know, the old go to world, you could call a function and maybe it returns, maybe it jumps

00:25:43.520 --> 00:25:47.360
somewhere else, maybe some other function and some other point of your code suddenly returns instead

00:25:47.360 --> 00:25:52.080
because the control go to just lets, you know, functions have a certain control flow they're supposed

00:25:52.080 --> 00:25:56.240
to have, right? Where you have your function and then you call something. So control jumps into that

00:25:56.240 --> 00:26:00.160
function. It executes that code and then it comes back again to your function. That's kind of this

00:26:00.160 --> 00:26:03.840
nice little structure. That's why it's, you could treat it as a black box because you know, oh, it'll

00:26:03.840 --> 00:26:08.640
do some stuff, but then it'll come back. Right. Go to isn't like that. It's just, it's just a one way

00:26:08.640 --> 00:26:13.920
you leap off somewhere else and then maybe you come back, you could jump back, it's something you do manually.

00:26:13.920 --> 00:26:19.040
Choose your own adventure book. You don't know when you're done, you don't know where to begin or

00:26:19.040 --> 00:26:23.040
you're just like, it's always a mess. It's always a surprise. Yeah. Yeah. I mean, it's choose your own

00:26:23.040 --> 00:26:26.320
adventure accepted. Then you're like, you know, actually I want to switch. I'm going to, it says

00:26:26.320 --> 00:26:32.480
I can go to page five or 10, but I'm going to 17. Let's see what happens. So yeah. So in that,

00:26:32.480 --> 00:26:36.880
and that breaks this function abstraction, right? So it means like you call a function and you know,

00:26:36.880 --> 00:26:41.360
hopefully like if it's like a nice, well-written library and people aren't like messing with you,

00:26:41.360 --> 00:26:46.560
it will come back normally. But there's no kind of guarantee of that in the language. Like if

00:26:46.560 --> 00:26:50.880
someone decided to be clever, they could, it could do something else. It could jump somewhere else.

00:26:50.880 --> 00:26:54.240
And then it becomes very hard to sort of reason about the overall structure of your program,

00:26:54.240 --> 00:26:59.040
if that's true. And it also breaks sort of higher level structures that people are using the program.

00:26:59.040 --> 00:27:04.000
But like, so, so think about exceptions, right? So it's very, a handy thing about exceptions is like,

00:27:04.000 --> 00:27:09.120
oh, something goes wrong. Then, you know, and I didn't think about how to deal with it locally,

00:27:09.120 --> 00:27:14.320
then the exception will propagate out in Python. And so until either someone catches it and knows how to

00:27:14.320 --> 00:27:18.880
deal with it, or the program crashes, you get a trace back and like, that's not great. But at least,

00:27:18.880 --> 00:27:22.640
you know, you didn't just like go blindly on doing the wrong thing. At least, you know,

00:27:22.640 --> 00:27:25.520
you get a trace back, you can try and figure out what's going, what happened, right?

00:27:25.520 --> 00:27:28.640
But not with, not with threading. Not if you care.

00:27:28.640 --> 00:27:32.080
Well, okay, well, we'll get there in a moment, right? But if you have go to,

00:27:32.080 --> 00:27:37.040
then it's where do you, when you raise an exception, it goes up the stack, right? It's like,

00:27:37.040 --> 00:27:40.640
okay, does this function want to handle it? Okay. How about it's caller? How about it's caller's

00:27:40.640 --> 00:27:45.360
caller? Right? Because you have this nice stack kind of, you know, you know who the caller is,

00:27:45.360 --> 00:27:50.160
you know who the caller's caller is. If you have go to, then control just bounces around sort of at

00:27:50.160 --> 00:27:54.480
random. So who wants to know about this exception? Like I don't have a well-defined sense of a caller

00:27:54.480 --> 00:27:59.200
even, right? It's just like these basic things we take for granted growing up and you know, this,

00:27:59.200 --> 00:28:03.120
you know, our ancestors struggled with and sort of fixed for us. And now we take for granted,

00:28:03.120 --> 00:28:06.400
right? But like these basic assumptions just aren't there in the language of go to.

00:28:06.400 --> 00:28:10.560
Yeah. With blocks have similar issues, right? So like a with block is supposed to like,

00:28:10.560 --> 00:28:14.640
you say with open file and then you know, okay, inside the block, the file's open,

00:28:14.640 --> 00:28:20.080
outside the block, the file's closed. That's nice. It's great. It makes it easy to manage resources.

00:28:20.080 --> 00:28:23.120
But if you have go to, you like, you jump into the middle of a block, you jump out of the middle of

00:28:23.120 --> 00:28:27.360
the block. Like what happens is the, where does the file open and close? Like how does that even,

00:28:27.360 --> 00:28:33.920
I don't even, it doesn't work, right? Exactly. Yeah. So yeah. And then,

00:28:33.920 --> 00:28:38.160
then if you look at like problems we're dealing with threads or things that are a struggle and like

00:28:38.160 --> 00:28:43.200
asyncio or twisted, but these are just kind of the things that are problematic, right? So you call

00:28:43.200 --> 00:28:46.640
a function, is it, you know, it's still running maybe when it returns, it makes it hard to like

00:28:46.640 --> 00:28:51.600
control sequencing, hard to treat things to black boxes. Like you don't know, like you need to like,

00:28:51.600 --> 00:28:57.200
go read the source code when you use some random, asyncio like based library to find out like,

00:28:57.200 --> 00:29:01.440
okay, I called this function, but did it actually do the thing then? Or is it scheduled something in

00:29:01.440 --> 00:29:05.280
the background? Like you have to go, does the error go to the caller or does it go to the callback?

00:29:05.280 --> 00:29:10.960
Right. Yeah. So if you spawn off this background thread or background task, as I think it calls it,

00:29:10.960 --> 00:29:17.200
and it crashes, there's an error. There's an unhandled exception with that. Well, you've lost,

00:29:17.200 --> 00:29:21.840
you don't have a nice sort of call stack that you've, you've spun up this new independent entity that's

00:29:21.840 --> 00:29:27.040
executing and it's now split apart from your original code. And so there's sort of like, where does that

00:29:27.040 --> 00:29:32.800
if there's an unhandled error, an exception, then what actually happens is that in threads and

00:29:32.800 --> 00:29:36.560
they sync IO and twist or whatever, is it, you know, maybe print something on standard, like,

00:29:36.560 --> 00:29:41.120
hey, I hope someone's looking, something went wrong. Then it throws away the exception and it carries on.

00:29:41.120 --> 00:29:43.760
And you know, hopefully... It does make your software more reliable,

00:29:43.760 --> 00:29:48.240
because there's way fewer crashes when you don't actually... Well, for some value of reliable,

00:29:48.240 --> 00:29:53.040
right? Yeah. Exactly. Nice. Okay. So what are the building blocks of Trio that like...

00:29:53.040 --> 00:29:59.680
Yeah, exactly. Yeah. Yeah. So the main thing that is, in Trio, we have this thing we call a nursery.

00:29:59.680 --> 00:30:04.320
And the idea, it's just a sort of a silly joke, right? About if you want to spawn a child task,

00:30:04.320 --> 00:30:08.800
then it's not okay for it just to be go off independently. Like it has, you have to like,

00:30:08.800 --> 00:30:13.040
put it somewhere and it'll be like taken care of. It's like a nursery is where children live.

00:30:13.040 --> 00:30:19.360
Okay. So concretely, what it is, is if you want to spawn a child task in Trio, you have to first

00:30:19.360 --> 00:30:24.640
have a nursery object. The way you get a nursery object is you write async with Trio.openNursery as

00:30:24.640 --> 00:30:29.680
nursery. So it's like this open, you have like a with block that opens a nursery and then you get this

00:30:29.680 --> 00:30:34.240
nursery object. And the object is tied to that with block. And so, and then once you have that,

00:30:34.240 --> 00:30:38.960
you can say nursery, there's a method on that nursery to spawn a task into it. And all the tasks you

00:30:38.960 --> 00:30:44.240
spawn to the nursery will run concurrently. But then the trick is that that with block,

00:30:44.240 --> 00:30:50.480
its lifetime in the parent is tied to the lifetime of the child tasks. So that you can't exit the

00:30:50.480 --> 00:30:53.840
with block while there's still children running. If you hit the end of the with block, then the

00:30:53.840 --> 00:30:58.960
parent just stops and waits for them. The stuff within the with block could be interwoven

00:30:58.960 --> 00:31:05.440
and like in certain ways, async and concurrent. But taken as a whole, the with block is like a black box.

00:31:05.440 --> 00:31:10.560
You start it, it runs, and then out comes the answer at the end, and everything's done,

00:31:10.560 --> 00:31:13.360
or it's gotten into its canceled state or whatever happens to it, right?

00:31:13.360 --> 00:31:18.560
Exactly. Exactly. Yeah. And so right. And that so that lets us do things like so right. So now,

00:31:18.560 --> 00:31:23.680
if you call a function in Trio, you know, well, okay, it might internally open a nursery and have

00:31:23.680 --> 00:31:28.240
some currency. But by the time it finishes, it's done, it hasn't left anything running. Or if you have,

00:31:28.240 --> 00:31:34.160
if something crashes, we have some child task, you know, has an exception that is no, it doesn't catch,

00:31:34.160 --> 00:31:37.680
then we say, okay, what do we do with this? Oh, well, wait, the parent is just sitting there waiting

00:31:37.680 --> 00:31:43.520
for the child. So that's what we do is the exception hops into the parent and continues executing. So

00:31:43.520 --> 00:31:48.960
in there, sorry, continues like propagating out. So Trio sort of follows the normal Python rule of,

00:31:48.960 --> 00:31:52.800
you know, you can catch an exception, but if you don't, then it will keep propagating until someone

00:31:52.800 --> 00:32:00.640
does. Right. So that nursery is a really important block block here. And I think, you know, it's,

00:32:00.640 --> 00:32:05.120
it's really cool to be able to start all these child tasks and they can even be sort of children

00:32:05.120 --> 00:32:09.120
of the children, right? Like you could pass the nursery and the child task could spawn more child

00:32:09.120 --> 00:32:12.480
tasks and whatever. And so it's all going to sort of be done at the end.

00:32:15.040 --> 00:32:19.600
This portion of talk Python to me has been brought to you by roll bar. One of the frustrating things

00:32:19.600 --> 00:32:25.040
about being a developer is dealing with errors, relying on users report errors, digging through

00:32:25.040 --> 00:32:30.400
log files, trying to debug issues, or getting millions of alerts, just flooding your inbox and ruining your

00:32:30.400 --> 00:32:35.760
day. With roll bars, full stack error monitoring, you get the context insight and control you need to

00:32:35.760 --> 00:32:42.240
find and fix bugs faster. Adding roll bar to your Python app is as easy as pip install roll bar. You can

00:32:42.240 --> 00:32:46.960
start tracking production errors and deployments in eight minutes or less. Are you considering

00:32:46.960 --> 00:32:51.760
self hosting tools for security or compliance reasons? Then you should really check out roll bars,

00:32:51.760 --> 00:32:57.440
compliance SAS option, get advanced security features and meet compliance without the hassle of self

00:32:57.440 --> 00:33:05.200
hosting, including HIPAA ISO 27001 privacy shield and more. They'd love to give you a demo. Give roll bar a

00:33:05.200 --> 00:33:09.520
try today. Go to talkpython.fm/roll bar and check them out.

00:33:09.920 --> 00:33:17.760
The other thing that's really important in this type of threading is to not block forever, to not wait

00:33:17.760 --> 00:33:19.440
on something forever, right?

00:33:19.440 --> 00:33:22.480
Oh yeah, so you're talking about timeouts and cancel scopes.

00:33:22.480 --> 00:33:24.080
Timeouts and cancel scopes and all that stuff.

00:33:24.080 --> 00:33:24.640
Yeah, yeah, yeah.

00:33:24.640 --> 00:33:29.600
Yeah, so this is a really basic problem. If you're doing anything, kind of network programming,

00:33:29.600 --> 00:33:36.080
for example, or any kind of thing, your programs talking to other programs, other resources,

00:33:36.080 --> 00:33:42.080
because sometimes those will just stop responding. So it's like, if you make an HTTP request,

00:33:42.080 --> 00:33:47.360
then maybe it'll succeed. Maybe it'll fail, you'll get a 404 or something like that.

00:33:48.000 --> 00:33:54.240
Or, but there's also a third possibility, which is that it just never finishes, right? Like the

00:33:54.240 --> 00:34:00.480
network disappeared and it just like sits there forever. And your program, yeah. And like, you kind

00:34:00.480 --> 00:34:04.240
of, and I mean, if it's just writing a little script or whatever, it's like that you're running

00:34:04.240 --> 00:34:06.960
at the command line, it's fine. You know, you have some point you'll get bored and hit control C,

00:34:06.960 --> 00:34:11.440
it's fine. But for sort of more complicated systems, you need to be robust against this.

00:34:11.440 --> 00:34:11.440
Yeah.

00:34:11.440 --> 00:34:13.360
Or unattended systems.

00:34:13.360 --> 00:34:13.360
Yeah.

00:34:13.360 --> 00:34:17.440
Like, well, we have 10 workers, but we're only getting this super low throughput. Why? Well,

00:34:17.440 --> 00:34:19.600
because eight of them are like just blocked forever.

00:34:19.600 --> 00:34:24.480
Yeah. You need to somehow, you know, detect this, be able to get out and say, okay, actually,

00:34:24.480 --> 00:34:29.440
let's stop doing that. Try something else, raise an error or something, but like, you know,

00:34:29.440 --> 00:34:34.240
not just sit there forever. So that means, yeah, there's just like, and this is just a problem

00:34:34.240 --> 00:34:40.160
that's just endemic, right? It's just every time you do any kind of networking or other kinds of IPC,

00:34:40.160 --> 00:34:43.520
you need to have this kind of timeout support. So that's one thing that makes it tricky.

00:34:43.520 --> 00:34:47.760
The other thing that makes timeouts tricky is that usually the place where you need to set

00:34:47.760 --> 00:34:52.960
the timeout is like buried way, way down deep inside the code. It's like, at some point your

00:34:52.960 --> 00:34:58.080
HTTP client, you know, is using some socket library and the socket library is like trying to send some

00:34:58.080 --> 00:35:02.960
bytes or read some bytes from the network, like a very, very low level operation. That's probably buried

00:35:02.960 --> 00:35:07.040
under like five levels of abstraction. But then where you want to set the timeout is like way out at the

00:35:07.040 --> 00:35:11.440
top where you say like, I just want to say, if this HTTP request isn't done in 10 seconds,

00:35:11.440 --> 00:35:16.080
then give up. So timeouts are this problem that's like, you need them everywhere and you need

00:35:16.080 --> 00:35:21.520
coordination across different layers of your system. So it's this really complicated problem that like

00:35:21.520 --> 00:35:28.640
covers, you really kind of need your timeout framework that's like used universally by everyone

00:35:28.640 --> 00:35:31.040
and kind of like coordinates, can coordinate across the system.

00:35:31.040 --> 00:35:37.840
And it can be super tricky. Like imagine you want to call like two web services and do a database

00:35:37.840 --> 00:35:43.920
transaction. And if one times out, you want them all to like roll. Yeah. Right. Which is like super,

00:35:43.920 --> 00:35:49.280
like how do you coordinate that? Like there's just, you know, like, yeah, almost impossible. Right. Unless,

00:35:49.280 --> 00:35:53.600
yeah. Unless you put it in trio. So yeah. So right. Yeah. So the traditional way to do this is like,

00:35:53.600 --> 00:35:58.880
you have a timeout framework sort of inside each library, like inside, you know, your HTTP client has a

00:35:58.880 --> 00:36:03.600
timeout argument that you pass or whatever, but that doesn't help with people just don't do that

00:36:03.600 --> 00:36:07.840
reliably. And yeah. And it doesn't solve these coordination problems. So in trio, you say like,

00:36:07.840 --> 00:36:12.640
no, this is something that we're just going to bake into the library, the IO library itself.

00:36:12.640 --> 00:36:18.960
So all libraries that work with trio, if you have an issue that in trio, it uses trio's timeout system.

00:36:18.960 --> 00:36:23.600
And so in this, this thing called cancel scope. So again, there's a lot more details on this in a

00:36:23.600 --> 00:36:28.080
blog post that I wrote called timeouts and cancellation for humans. We'll put the link up there.

00:36:28.720 --> 00:36:34.160
Podcast description, I guess. But in basically, yeah, it's, it's fairly simple to use. Basically,

00:36:34.160 --> 00:36:38.800
the way it works is you can just anywhere in your code, say, you know, with timeout,

00:36:38.800 --> 00:36:45.040
10 seconds, and then you put code inside that with block. And if it takes more than 10 seconds,

00:36:45.040 --> 00:36:51.440
then trio raises a special exception called canceled that just sort of, you know, unwinds out of there.

00:36:51.440 --> 00:36:55.680
And then that with block catches the exception. So, you know, it's a way of saying, okay,

00:36:55.680 --> 00:37:00.320
whatever's happening with block, stop doing that, and then carry on at that point.

00:37:00.320 --> 00:37:04.880
The other nice thing that's important about this, as compared to a lot of other systems we're doing,

00:37:04.880 --> 00:37:10.640
working with timeouts and this cancellation, is that we have the with block to limits, like you can say,

00:37:10.640 --> 00:37:17.040
this is the operation that I want to cancel, which is really important. So like asyncio doesn't work like this.

00:37:17.040 --> 00:37:21.680
So when I think IO, you can say, I want to cancel something, and that injects the special exception,

00:37:21.680 --> 00:37:25.600
but then there's nothing that keeps track of, you can't look at the exception, figure out, okay,

00:37:25.600 --> 00:37:34.480
did I want to cancel this specific network operation, or this HTTP request, or this like entire program,

00:37:34.480 --> 00:37:39.680
like, kind of, you don't keep track of that. When trio, because we said it's with block, we can say,

00:37:39.680 --> 00:37:44.960
okay, I know this is the actual set, this is the operation that I'm trying to cancel right now.

00:37:44.960 --> 00:37:46.320
And these can be nested.

00:37:46.320 --> 00:37:50.480
Yeah, it's awesome. And you, if you want to do like a timeout, you can create a with block that says,

00:37:50.480 --> 00:37:57.360
basically, do this to success or fail after 10 seconds. What is the syntax for that? It's like,

00:37:57.360 --> 00:37:58.720
async with, I forget.

00:37:58.720 --> 00:38:00.240
This one is just a regular with.

00:38:00.240 --> 00:38:00.560
Okay.

00:38:00.560 --> 00:38:06.320
Because, so async with is just like a regular with except that a regular with does, calls a method at

00:38:06.320 --> 00:38:10.560
the beginning and the end of the block. And async with does an await call of a method at the beginning

00:38:10.560 --> 00:38:14.640
of the block. And we talk about a weight being the special, you know, thing we call these special

00:38:14.640 --> 00:38:20.800
functions. Yeah. And so for, it happens that for tree for timeouts, for nurseries, you have to use

00:38:20.800 --> 00:38:24.960
an async with because at the end of the block, it might, the parent might have to wait for the

00:38:24.960 --> 00:38:30.160
children. And you want to let them run while it's waiting. Right. So it has to be an await there.

00:38:30.160 --> 00:38:34.240
So let's use async with for a timeout. You're just, you know, setting something at the beginning

00:38:34.240 --> 00:38:37.840
of the end, but there's, it doesn't, it doesn't have to actually like stop and wait for, let other

00:38:37.840 --> 00:38:42.080
things run there. It can be synchronous. That's just a little detail, but yeah. So it's, it's basically,

00:38:42.080 --> 00:38:46.880
so with block, what we, the main one, sort of this basic one is called move on after to kind

00:38:46.880 --> 00:38:51.360
of remind you that it's going to run the code. And then if the timeout happened, it doesn't

00:38:51.360 --> 00:38:55.680
raise an exception. Like it, you can stop and see, okay, did it, was it canceled or not? But like,

00:38:55.680 --> 00:39:00.640
it keeps executing after the block. So you can like, look at it, which is, this again has to do with,

00:39:00.640 --> 00:39:04.480
like, like the simplest case for a timeout is just like, okay, if the timeout expires,

00:39:04.480 --> 00:39:09.760
blow up everything, give up, raise an exception, right? But a lot of times you want to say, oh,

00:39:09.760 --> 00:39:16.640
well, did this thing get canceled? If so, do some fallback, do something else. So the core thing in

00:39:16.640 --> 00:39:20.560
Trio is, is not to raise an exception after that. It's like to provide some object you can look at to

00:39:20.560 --> 00:39:23.280
see what happened and then figure out how you want to deal with it.

00:39:23.280 --> 00:39:30.320
Yeah. The other thing that I thought you did well with these cancellation scopes is if there's an

00:39:30.320 --> 00:39:35.280
exception on one of the tasks and there's a bunch running in one of these width blocks, you can

00:39:35.280 --> 00:39:40.560
catch that and use that to cancel the other ones and just say, no, no, things are going wrong. We're

00:39:40.560 --> 00:39:46.000
out of here. Every, all threads are done. We're out of here. Yeah. So yeah. So the nurseries actually

00:39:46.000 --> 00:39:51.040
kind of need the cancel scopes because what, one of the things the nurseries do is this exception

00:39:51.040 --> 00:39:55.440
family thing, right? So if an exception happens in a child, it isn't caught, then it has to hop

00:39:55.440 --> 00:39:59.520
into the parent. So we have this kind of, I guess the way I think about it is normally you think of

00:39:59.520 --> 00:40:03.440
like your call stack. It's like this little chain of like, you know, A calls B calls C calls D,

00:40:03.440 --> 00:40:10.240
right? What nurseries do is they kind of make it that into like a tree. So like A calls B, B calls C and D

00:40:10.240 --> 00:40:15.680
and E sort of simultaneously. And then maybe D calls several things at the same time, right? So you have

00:40:15.680 --> 00:40:20.560
this kind of like this tree structure of your, for your call stack. And now some exception happens down

00:40:20.560 --> 00:40:24.560
inside one of those branches. Well, what do you do with exceptions? You unwind the stack,

00:40:24.560 --> 00:40:28.800
right? You go, you run any handlers inside that function. And then you go up to the parent,

00:40:28.800 --> 00:40:33.040
you kill that functions call and you move in there and run any handlers there and so on.

00:40:33.040 --> 00:40:36.240
But then we have this problem. If you're going up, unwinding the stack, and you hit one of these

00:40:36.240 --> 00:40:41.920
places where branch, the stack now branches, how do you sort of unwind past that point? Right?

00:40:41.920 --> 00:40:46.400
You don't want to like orphan the other children, like you just unwind the parent without

00:40:46.400 --> 00:40:49.920
stopping them because that's our whole thing in Trio, right? We say we're not going to let

00:40:49.920 --> 00:40:58.480
orphans run around unsupervised. That's a bad idea. Dijkstra doesn't like that. So what we do is,

00:40:58.480 --> 00:41:02.880
but we have to unwind the stack, right? So what we do is we use the cancellation at that point to go and

00:41:02.880 --> 00:41:07.840
we cancel all the other tasks that are inside that same nursery. So we sort of prune the tree,

00:41:08.240 --> 00:41:13.760
unwind those tasks back up to this point. And then we can keep unwinding from there with the original

00:41:13.760 --> 00:41:18.800
exception. Yeah, that's, that's really clever. I really like the way you put it all together.

00:41:18.800 --> 00:41:26.560
So there's also some other pieces, like some file system bits. I love the whole trick of saying

00:41:26.560 --> 00:41:32.240
like a wait sleep for a little bit of time, just go, I'm basically yielding this thread to let it do

00:41:32.240 --> 00:41:37.280
other work, but then just carry on as opposed to say like a time.sleep and things like that.

00:41:37.280 --> 00:41:39.840
So maybe tell us about the higher order of building blocks.

00:41:39.840 --> 00:41:43.520
Yeah. So I guess, yeah, so far we've sort of been talking about kind of the core ideas in Trio, which

00:41:43.520 --> 00:41:48.560
are, you know, not specific to Trio the project. In fact, there's so, I've had a, talking to a number

00:41:48.560 --> 00:41:52.720
of other language designers or other languages, like, oh, this is interesting. We're also struggling with

00:41:52.720 --> 00:41:57.520
these problems. But then, yeah, but Trio is also a specific project you can download. It has

00:41:57.520 --> 00:42:02.800
documentation and API and all that. And one of the things I try to do with that project is to make

00:42:02.800 --> 00:42:07.840
it sort of really sort of usable and accessible, kind of have this philosophy of like, the, you know,

00:42:07.840 --> 00:42:12.080
kind of the buck stops here for developer experience. Like if there's something that you're trying to,

00:42:12.080 --> 00:42:16.080
you're trying to write a program using Trio and there's something awkward or difficult or a problem

00:42:16.080 --> 00:42:22.480
you have, then it's up to us to solve that. And even maybe it's, it's so we, it's, we have the project

00:42:22.480 --> 00:42:27.600
itself. We also have things like that, like, you know, has the core, like networking and concurrency

00:42:27.600 --> 00:42:34.320
stuff. We also have testing helpers and we have a documentation, like a plugins for Sphinx to make

00:42:34.320 --> 00:42:40.160
it easier to document these things. And so there's something called pytest-Trio. How's that work with

00:42:40.160 --> 00:42:46.800
that? So the main thing that pytest-Trio gives you is that you can have, when you write a test, you can say,

00:42:46.800 --> 00:42:52.640
okay, I guess we need to give a little more information here. So Trio, there's sort of a

00:42:52.640 --> 00:42:57.600
stereotype pattern that all Trio programs for, where you have like an async def main or whatever you want

00:42:57.600 --> 00:43:02.320
to call it. That's like your top level async function. That's like, that's where you go into

00:43:02.320 --> 00:43:04.960
that Trio's magic async mode. If you use all the Trio stuff.

00:43:04.960 --> 00:43:08.160
Right. So maybe you start by saying trio.run main.

00:43:08.160 --> 00:43:12.720
Yeah. Yeah. So the thing about async functions, you can only call them from other async functions.

00:43:12.720 --> 00:43:17.600
So you have this problem. How do you call your first async function? And that's what trio.run.

00:43:17.600 --> 00:43:22.320
So you have this little bit of ceremony at the very top of every Trio program. And this is also the case

00:43:22.320 --> 00:43:27.120
for like asyncio and so on. But like, you say, I have to like switch into trio mode. And that's kind of

00:43:27.120 --> 00:43:31.760
annoying in a test suite to do that on every single test. So that's the most basic thing that pytest-Trio

00:43:31.760 --> 00:43:37.200
does for you is it makes it so you can write async def test, whatever, and it will take care of like

00:43:37.200 --> 00:43:42.400
setting up trio and turning it on there. But it also has some other handy stuff. So one thing

00:43:42.400 --> 00:43:47.440
is that it allows you to have async fixtures. And it does some sort of magic to like goes,

00:43:47.440 --> 00:43:50.880
it switches into trio mode, and then sets up your fixtures and then calls your test,

00:43:50.880 --> 00:43:54.640
and then tears down the fixtures. So it's sort of all within this async context.

00:43:54.640 --> 00:43:59.360
And it's also integrated with some of the testing helpers that are built into trio itself.

00:43:59.360 --> 00:44:03.520
So in particular, the one that's sort of the most, you know, gee whiz, awesome,

00:44:03.520 --> 00:44:10.240
is that trio has this ability to use a fake clock. So this is an issue when you're writing like

00:44:10.240 --> 00:44:15.520
networking programs. Like often you want to like have a test about, okay, what does happen if this

00:44:15.520 --> 00:44:20.960
HE request just hangs forever? Like do my timeouts work correctly? Stuff like that, right? But it's

00:44:20.960 --> 00:44:25.200
really annoying to run these tests because it's like, okay, and now I have to sit and wait for a

00:44:25.200 --> 00:44:29.360
minute for the timeout to fire and make sure something happens. And that happens every time you run your

00:44:29.360 --> 00:44:33.520
test. It just spends a minute sitting there doing nothing. And you're like, I really like, okay, but

00:44:34.320 --> 00:44:38.880
like, this is really boring. I want my test suite to finish already. And I need like 100 of these

00:44:38.880 --> 00:44:40.000
tests. And yeah.

00:44:40.000 --> 00:44:42.160
So killing my build time.

00:44:42.160 --> 00:44:48.240
Exactly. Yeah. Right. It's like really ruins your flow. So one thing I've done, actually,

00:44:48.240 --> 00:44:52.720
what I did is when writing trio itself, I said, okay, I really want trio's own test suite to run

00:44:52.720 --> 00:44:57.440
really quickly. I figured that'll force me to like come up with the tools that my users will need to

00:44:57.440 --> 00:44:58.720
make their test suite run quickly. Yeah.

00:44:58.720 --> 00:45:03.280
So if you just type pytest trio, you know, if you want to contribute to trio, we'd love to have

00:45:03.280 --> 00:45:07.840
you. We're very friendly and all that. If you type pytest trio, it runs in like five seconds.

00:45:07.840 --> 00:45:12.880
It has like 99 point something percent test coverage, which is like completely, it's very

00:45:12.880 --> 00:45:16.960
difficult to get there because trio is this really complicated sort of networking library. It's all

00:45:16.960 --> 00:45:21.200
this stuff that's usually hard to test. Part of that is that for all the timeout tests,

00:45:21.200 --> 00:45:26.560
we have this magic clock. And so the way it works is you say, okay, trio, I don't want you to use,

00:45:26.560 --> 00:45:31.920
I know it says like sleep 30 seconds or whatever. I don't want you to actually use sleep 30 real

00:45:31.920 --> 00:45:36.320
seconds. I only want you, I want you to sleep 30 virtual seconds. And so it's a special thing you

00:45:36.320 --> 00:45:41.920
sort of pass the tree at our run to say, every time you have timeouts, sleeping, anything inside this call,

00:45:41.920 --> 00:45:45.920
I want you to sort of use this virtual clock instead. And the way the virtual clock works,

00:45:45.920 --> 00:45:50.960
it starts out at time zero and it just stays there. And you can like advance it manually if you

00:45:50.960 --> 00:45:54.400
want or things like that. But normally what you do is you just use the automatic behavior,

00:45:54.400 --> 00:45:59.600
which is, it's just, it's, it's at time zero. And then it sort of watches what your program is

00:45:59.600 --> 00:46:04.080
doing. Anytime that your program sort of like finishes running everything and just stops and

00:46:04.080 --> 00:46:08.800
is waiting for stuff to happen, then it looks to see, okay, looks like the next thing that would

00:46:08.800 --> 00:46:13.760
wake up, there's like a sleep 10 and sleep 20. Okay. So in 10 seconds, that's the next one that'll wake

00:46:13.760 --> 00:46:17.840
up. I'm just going to jump the clock forward 10 seconds and then start running again. Right.

00:46:17.840 --> 00:46:21.360
So anytime it knows it's going to be waiting for a certain amount, it's like, all right,

00:46:21.360 --> 00:46:24.320
we'll just, we'll let the wait start and then we'll just go right past that.

00:46:24.320 --> 00:46:29.200
So it's basically, yeah, you just write your test the way you normally would with like for use timeouts

00:46:29.200 --> 00:46:34.400
regularly, test your real code, but sleeps, whatever is easiest. And then what's annoying about that

00:46:34.400 --> 00:46:39.840
normally is then your, your test takes like 30 seconds, a minute, whatever it is to run. Most of

00:46:39.840 --> 00:46:44.560
which the time is just sitting there doing nothing, waiting for time to pass. So if you flip the switch to

00:46:44.560 --> 00:46:48.480
use the special clock, then it does this exactly the same things, but it just skips over all those

00:46:48.480 --> 00:46:52.320
times when it's sitting doing nothing. And so suddenly your test runs in like a few milliseconds.

00:46:52.320 --> 00:46:57.440
Oh, that's awesome. Yeah. It's pretty awesome. And then it tests trio is hooked up to that.

00:46:57.440 --> 00:47:00.320
So you can just turn this on with just like flip a switch on any test.

00:47:00.320 --> 00:47:07.040
Oh, that's great. Yeah. So one of the things that makes me a little bit sad about Python's async

00:47:07.920 --> 00:47:16.240
loops and stuff is like the asyncio based apps and the trio based apps. Those are not exactly the same

00:47:16.240 --> 00:47:22.240
and they're not exactly compatible. It's not like the core you're using the same core. And so it just

00:47:22.240 --> 00:47:26.720
keeps running like the asyncio loop and the trio loop. These are not the same. They got to be like

00:47:26.720 --> 00:47:30.560
brought together with different APIs. Right. Yeah.

00:47:30.560 --> 00:47:35.680
But you seem to have, you do have some interoperability. So like trio can work with

00:47:35.680 --> 00:47:38.400
libraries that maybe assume asyncio is there or something, right?

00:47:38.400 --> 00:47:43.760
Trio itself is just like a totally different library than asyncio. I've looked at, you know,

00:47:43.760 --> 00:47:47.760
could I build it on top of asyncio? And there's sort of a number of reasons why that didn't sort of

00:47:47.760 --> 00:47:55.120
make sense. And yes, and there is this big problem because it's just because of technical things about

00:47:55.120 --> 00:48:00.480
how these async concurrency systems work. There has to be like one library ultimately that controls

00:48:00.480 --> 00:48:06.320
all the actual networking like asyncio or trio or whatever, or twisted or tornado or something.

00:48:06.320 --> 00:48:11.680
And that means to like, if you have a, like a say an HTTP client that's written to work on async

00:48:11.680 --> 00:48:16.480
IO, it will necessarily work on trio because it's using a different set of networking primitives underneath

00:48:16.480 --> 00:48:24.160
or vice versa. And this is sort of a, a larger sort of ecosystem problem, right? So there used to be,

00:48:24.160 --> 00:48:28.240
there's twisted and tornado and G event and they all, none of them could interoperate. You'd have to

00:48:28.240 --> 00:48:33.920
like pick which one they're using. And asyncio was sort of one of the reasons it exists is to try

00:48:33.920 --> 00:48:38.640
and solve that problem and become the standard one, but then twisted and tornado and everyone can use.

00:48:38.640 --> 00:48:43.920
And now they can all work on top of asyncio. And now all those libraries written for twisted and tornado,

00:48:43.920 --> 00:48:48.080
you can mix and match however you like. And then here comes trio and kind of ruins that

00:48:48.080 --> 00:48:53.200
by being here's this new thing you should use. So to try and kind of mitigate that,

00:48:53.200 --> 00:49:00.080
there is this library called a trio asyncio, which lets you use asyncio libraries on top of trio.

00:49:00.080 --> 00:49:06.160
The way it does this is kind of, it creates like a virtual asyncio loop that internally uses trios primitives

00:49:06.160 --> 00:49:11.680
under the cover. And it kind of lets you, you know, kind of cordon them off and kind of a little container,

00:49:11.680 --> 00:49:17.760
sort of all the weird stuff they sink IO can do. You can do that stuff, but, the kind of in a little box

00:49:17.760 --> 00:49:22.000
that won't like leak out to pollute the rest of your program, your trio program.

00:49:22.000 --> 00:49:27.040
I think this is really encouraging because that means if you maybe have already invested in AC IO and

00:49:27.040 --> 00:49:29.360
you've already got some code written on it, like you could still

00:49:29.360 --> 00:49:30.720
Yeah.

00:49:30.720 --> 00:49:34.880
Trio without going, I'm rewriting trio. And is that worth it? Is that a good idea?

00:49:34.880 --> 00:49:40.000
Yeah. Or again, it gives you sort of an incremental path. You can say like, well, okay, I can at least

00:49:40.000 --> 00:49:44.800
get it running on trio first of all, and then I can start porting one piece at a time and eventually

00:49:44.800 --> 00:49:46.240
end up all in trio. Hopefully.

00:49:46.240 --> 00:49:47.120
Exactly.

00:49:47.120 --> 00:49:47.200
Exactly.

00:49:47.200 --> 00:49:51.680
Now, the reason it's not, you can't just magically make this all work because

00:49:51.680 --> 00:49:56.160
trio and Cinco really have fundamentally different ideas about things. Now, obviously, I think trio's

00:49:56.160 --> 00:50:02.000
ideas are better. They're kind of the new thing that I try to fix all these problems, but it's not that

00:50:02.000 --> 00:50:06.400
it's the differences aren't just like in terms of the internal implementation. The differences are in

00:50:06.400 --> 00:50:09.280
terms of just like the fundamental concepts that are exposed.

00:50:09.280 --> 00:50:10.960
Right. Like the philosophy of it.

00:50:10.960 --> 00:50:14.240
Yeah. Right. It totally changes how you write the library on top.

00:50:14.240 --> 00:50:17.760
Right. So it's not something you can just sort of magically switch.

00:50:17.760 --> 00:50:22.800
But there's a little bit of an incremental aspect to it. So we're almost out of time.

00:50:22.800 --> 00:50:22.800
Right.

00:50:22.800 --> 00:50:27.600
Just really quickly, what's the future of trio? Like where is it going? What you got planned?

00:50:27.600 --> 00:50:29.120
And is it production ready?

00:50:29.120 --> 00:50:33.840
So yeah. So I should be clear. Yeah. Right now, the trio library itself is very solid,

00:50:33.840 --> 00:50:39.680
but there is not much of an ecosystem around it. So like there is not currently an HTTP client or

00:50:39.680 --> 00:50:43.920
an HTTP server that you can just use out of the box and it's like mature and all that

00:50:43.920 --> 00:50:47.520
for trio. There are some solutions for these kinds of issues. And I don't want to say too

00:50:47.520 --> 00:50:51.920
much because, you know, this will change quickly. We have a chat channel. If you go to our

00:50:51.920 --> 00:50:57.120
documentation or whatever, you can like find out what the latest news is about what you should use.

00:50:57.120 --> 00:51:01.680
But it's not something that, you know, is ready today to run big websites or something like that.

00:51:01.680 --> 00:51:02.000
Okay.

00:51:02.000 --> 00:51:05.760
Just because the libraries aren't there yet. If you'd like to help, you know, write those libraries and

00:51:05.760 --> 00:51:11.760
make it happen. I'd love to have you. We have a really solid contributing policy and things like

00:51:11.760 --> 00:51:17.280
that. You can check it out. The other thing that's happening is asyncio. So I also, I spent a lot of

00:51:17.280 --> 00:51:22.160
time. I am a core Python developer. I talked to Yuri Selvanov as the main asyncio developer and Guido

00:51:22.160 --> 00:51:27.280
about all this stuff. And so there is this, Yuri is quite keen on saying, oh, well, right. You know,

00:51:27.280 --> 00:51:32.800
trios ideas are better. We should add them all into I sync IO. This is quite complicated. There's a lot

00:51:32.800 --> 00:51:36.480
of, I mean, we could probably do a whole other podcast about all the trade offs there. And maybe

00:51:36.480 --> 00:51:38.400
we should, I don't know. It's pretty interesting. It is interesting.

00:51:38.400 --> 00:51:42.400
Maybe relevant. So that's something that's also happening is that Yuri is going to be trying to

00:51:42.400 --> 00:51:47.680
add nurseries and cancel scopes and things to I sync IO. So I think there's a lot going to be a lot of

00:51:47.680 --> 00:51:52.240
limitations. It's a lot of the value in trios of things people can't do. And I sync IO has already

00:51:52.240 --> 00:51:57.600
got like six layers of abstraction built in there or I don't know. It's not actually six. It's like

00:51:57.600 --> 00:52:02.560
four. And they're all totally doing all the things that trio says, these are, these are things that

00:52:02.560 --> 00:52:07.280
should never be done. It shouldn't be possible. So you can't, that's also, you could fix just adding

00:52:07.280 --> 00:52:11.600
a new layer on top, but you know, it's still better than nothing, right? Like, you know,

00:52:11.600 --> 00:52:15.200
I think it would continue to exist. So we do want to make it as good as possible.

00:52:15.200 --> 00:52:16.560
By these ideas. Yeah, absolutely.

00:52:16.560 --> 00:52:21.200
And ultimately we don't, I mean, maybe like no one knows for sure whether like the make a new thing

00:52:21.200 --> 00:52:25.120
plus a compatibility layer, like trio, the trio, the single thing I mentioned, is that going to be

00:52:25.120 --> 00:52:28.800
the best thing or is making asyncio better going to be the best thing? We'd, none of us know for

00:52:28.800 --> 00:52:32.640
sure. So we are trying both versions. I will sort of see.

00:52:32.640 --> 00:52:38.080
I'm super excited just to hear that that collaboration is happening. I think that's great. All right.

00:52:38.080 --> 00:52:42.960
I think that we're out of time for trio. It's super interesting project. I really love what you've

00:52:42.960 --> 00:52:46.160
done there. I think it's, I think it's brilliant. So, people should definitely check it out.

00:52:46.160 --> 00:52:47.120
Thanks a lot.

00:52:47.120 --> 00:52:50.720
Yeah, you're welcome. So quick two final questions. If you're going to write some Python code,

00:52:50.720 --> 00:52:51.840
what editor do you use?

00:52:51.840 --> 00:52:55.040
I use Emacs. I've been using it for 20 years. I'm stuck.

00:52:55.040 --> 00:53:00.560
It's great. It's not any, I don't know that it works for other people or not just because,

00:53:00.560 --> 00:53:01.360
yeah.

00:53:01.360 --> 00:53:06.160
Yeah, sure. I definitely, I started on Emacs as well. And notable pipe effect.

00:53:06.160 --> 00:53:07.840
Yeah. Well, trio, obviously.

00:53:07.840 --> 00:53:10.320
And, pytest.strio?

00:53:10.320 --> 00:53:15.760
Yeah. pytest trios, Sphinx controlled trio. There's, if you go to the, you know,

00:53:15.760 --> 00:53:21.760
github.com/python-trio to see all the different projects under the trio organization. And they're

00:53:21.760 --> 00:53:24.000
sort of trying to build up that ecosystem. Like I said, so.

00:53:24.000 --> 00:53:28.720
Yeah. Sounds cool. Yeah. So final call to action. People are excited. They want to try trio. Maybe

00:53:28.720 --> 00:53:30.480
they want to contribute to it. What do they do?

00:53:30.480 --> 00:53:36.400
Yeah. So check out, start with the documentation trio.readthedocs.io. That also will give you

00:53:36.400 --> 00:53:41.600
links to our chat is, sort of a place to hang out. it has our contributing docs. If you want

00:53:41.600 --> 00:53:47.680
to get involved like that, we give out commitments on your first pull request acceptance. So there's

00:53:47.680 --> 00:53:52.560
lots of people. Yeah, we, we want, you know, this is a project for everyone. I don't want to just be my,

00:53:52.560 --> 00:53:53.680
you know, personal little thing.

00:53:53.680 --> 00:53:55.680
Yeah, that sounds great. Awesome.

00:53:55.680 --> 00:53:56.160
Yeah.

00:53:56.160 --> 00:54:00.240
All right. Nathaniel, thank you for sharing your project and creating it. It's quite great. And,

00:54:00.240 --> 00:54:02.960
we may have to come back and dig into this a little bit more. This is fun.

00:54:02.960 --> 00:54:05.360
Yeah. Thanks for having me. Yeah. Yeah. Talk to you later.

00:54:05.360 --> 00:54:05.920
You too. Bye bye.

00:54:05.920 --> 00:54:13.200
This has been another episode of talk Python to me. Our guest on this episode was Nathaniel Smith,

00:54:13.200 --> 00:54:18.800
and it was brought to you by Linode and Rollbar. Linode is bulletproof hosting for whatever you're

00:54:18.800 --> 00:54:25.600
building with Python. Get four months free at talkpython.fm/linode. That's L I N O D E.

00:54:26.720 --> 00:54:32.640
Rollbar takes the pain out of errors. They give you the context insight you need to quickly locate and

00:54:32.640 --> 00:54:38.160
fix errors that might have gone unnoticed until your users complain. Of course, as talk Python to me,

00:54:38.160 --> 00:54:43.600
listeners track a ridiculous number of errors for free at rollbar.com/talkpython to me.

00:54:43.600 --> 00:54:49.040
Want to level up your Python? If you're just getting started, try my Python jumpstart by building 10

00:54:49.040 --> 00:54:54.720
apps or our brand new 100 days of code in Python. And if you're interested in more than one course,

00:54:54.720 --> 00:54:58.640
be sure to check out the everything bundle. It's like a subscription that never expires.

00:54:58.640 --> 00:55:04.560
Be sure to subscribe to the show. Open your favorite podcatcher and search for Python. We should be right at the top.

00:55:04.560 --> 00:55:13.520
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

00:55:13.520 --> 00:55:19.840
This is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code.

00:55:19.840 --> 00:55:40.800
I'll see you soon.

