WEBVTT

00:00:00.160 --> 00:00:04.440
Algorithms underpin almost everything we do in programming and in problem solving in general.

00:00:04.440 --> 00:00:09.180
Yet many of us have partial or incomplete knowledge of the most important and common ones.

00:00:09.180 --> 00:00:16.420
In this episode, you'll meet Adit Bhargava, the author of The Light and Playful Grokking Algorithms, an illustrated guidebook.

00:00:16.420 --> 00:00:21.140
If you struggle to understand and learn the key algorithms, this episode is for you.

00:00:21.140 --> 00:00:27.540
This is Talk Python To Me, episode 82, recorded October 24th, 2016.

00:00:27.540 --> 00:00:57.300
Welcome to Talk Python To Me, a weekly podcast on Python.

00:00:57.600 --> 00:01:00.340
The language, the libraries, the ecosystem, and the personalities.

00:01:00.340 --> 00:01:04.480
This is your host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy.

00:01:04.480 --> 00:01:08.360
Keep up with the show and listen to past episodes at talkpython.fm.

00:01:08.360 --> 00:01:10.960
And follow the show on Twitter via at Talk Python.

00:01:10.960 --> 00:01:15.120
This episode is brought to you by Capital One and Intel.

00:01:15.120 --> 00:01:19.720
Thank them both for sponsoring the show by checking out what they're offering during their segments.

00:01:19.720 --> 00:01:22.240
Adit, welcome to Talk Python.

00:01:22.240 --> 00:01:23.000
Thank you.

00:01:23.000 --> 00:01:28.580
I'm really enjoying your book that I started reading a little while ago, Grokking Algorithms

00:01:28.580 --> 00:01:29.100
with Python.

00:01:29.100 --> 00:01:31.660
And I think we're going to have a great time talking about it.

00:01:31.660 --> 00:01:33.500
But before we do, tell us your story.

00:01:33.500 --> 00:01:34.660
How did you get into programming in Python?

00:01:34.660 --> 00:01:38.420
Well, I think I have a slightly atypical route.

00:01:38.740 --> 00:01:43.760
Because I got into programming with this thing called Thing Maker.

00:01:43.760 --> 00:01:46.360
I don't know if anyone remembers this.

00:01:46.360 --> 00:01:53.180
It was, you know, back in the day, WWE had put it out, like the World Wrestling Entertainment

00:01:53.180 --> 00:01:54.160
guys.

00:01:54.160 --> 00:01:54.680
Okay.

00:01:55.460 --> 00:01:55.860
Yeah.

00:01:55.860 --> 00:02:00.440
And it was just a simple way to, like, make little games or, you know, make a website.

00:02:00.440 --> 00:02:03.540
And I started playing around with that.

00:02:03.540 --> 00:02:06.760
And then I thought, you know, I would love to make my own games.

00:02:06.760 --> 00:02:08.660
And then I started playing with Flash.

00:02:08.660 --> 00:02:11.620
So now you know how old the story is.

00:02:11.620 --> 00:02:12.600
Yep.

00:02:12.600 --> 00:02:14.920
Flash was probably new and exciting at the time.

00:02:14.920 --> 00:02:16.420
It was.

00:02:16.580 --> 00:02:18.960
And, like, it wasn't even owned by Adobe.

00:02:18.960 --> 00:02:20.260
It was owned by Macromedia.

00:02:20.260 --> 00:02:24.120
And Macromedia Director was a big thing.

00:02:24.120 --> 00:02:27.520
Anyway, so I, like, started, you know, started with ActionScript.

00:02:27.520 --> 00:02:29.880
And I sold a game.

00:02:29.880 --> 00:02:32.480
And that's when I thought, you know, I could do programming.

00:02:32.480 --> 00:02:33.420
This is really fun.

00:02:33.420 --> 00:02:34.000
Oh, yeah.

00:02:34.000 --> 00:02:34.440
That's cool.

00:02:34.440 --> 00:02:37.580
So that's a ways away from Python.

00:02:37.580 --> 00:02:39.020
How did you get over to the Python world?

00:02:39.020 --> 00:02:45.260
Eventually, I was, like, because I had learned C, C++, kind of the standard route that a lot

00:02:45.260 --> 00:02:45.880
of people take.

00:02:45.880 --> 00:02:54.280
And I just wanted to get back to those Flash days when, you know, I mean, to me, I would

00:02:54.280 --> 00:02:58.740
rather work with a simple language that can execute my ideas.

00:02:58.740 --> 00:03:01.360
And that's when I found Python.

00:03:01.360 --> 00:03:03.820
And it was so easy to use.

00:03:03.820 --> 00:03:09.000
You know, it's like you can think about something and type it out as you're thinking about it.

00:03:09.000 --> 00:03:09.680
Yeah, that's cool.

00:03:09.680 --> 00:03:11.340
It's like programming is fun again, right?

00:03:11.340 --> 00:03:12.600
Yeah.

00:03:12.600 --> 00:03:13.500
Exactly.

00:03:13.500 --> 00:03:15.860
It reminds me of that XKCD Python.

00:03:15.860 --> 00:03:17.060
All right.

00:03:17.060 --> 00:03:18.460
Well, that's excellent.

00:03:18.460 --> 00:03:21.420
Did you go to a university and do a computer science degree?

00:03:21.420 --> 00:03:25.080
I actually did my undergrad in graphic design.

00:03:25.080 --> 00:03:25.880
Okay.

00:03:26.100 --> 00:03:29.580
Because, you know, I mean, I love drawing.

00:03:29.580 --> 00:03:31.360
It's been a hobby for me for a long time.

00:03:31.360 --> 00:03:35.300
And then I worked as a designer for a while.

00:03:35.300 --> 00:03:40.920
But I realized that I would enjoy programming more as a job.

00:03:40.920 --> 00:03:45.140
So then I went to UChicago and got a master's in computer science.

00:03:45.140 --> 00:03:46.120
Okay, cool.

00:03:46.120 --> 00:03:47.680
Yeah, I guess that makes a lot of sense.

00:03:47.680 --> 00:03:51.820
Like the illustrated part of your book, which we're going to get to, which is very cool.

00:03:52.460 --> 00:03:54.680
You know, there's a lot of things you can learn.

00:03:54.680 --> 00:03:58.200
You can just self-teach yourself about programming.

00:03:58.200 --> 00:04:00.160
You know, there's a lot of good boot camps.

00:04:00.160 --> 00:04:01.820
There's a lot of good online classes.

00:04:01.820 --> 00:04:02.960
Things like that.

00:04:02.960 --> 00:04:12.400
But I do feel one of the shortcomings of that type of education really is around the proper use of data structures and algorithms.

00:04:12.740 --> 00:04:17.200
And not necessarily being able to write them, but knowing sort of the trade-offs, right?

00:04:17.200 --> 00:04:18.280
Yeah, exactly.

00:04:18.280 --> 00:04:19.960
You decided to solve that problem.

00:04:19.960 --> 00:04:26.860
And you took your graphic arts skills and applied them, not just your programming skills, but your graphic arts skills,

00:04:26.860 --> 00:04:31.460
and applied them to this problem with this book you wrote called Grokking Algorithms,

00:04:31.460 --> 00:04:34.900
an illustrated guide for programmers and other curious people.

00:04:34.900 --> 00:04:35.620
Yeah.

00:04:36.340 --> 00:04:39.080
So I read your book, a good portion of it.

00:04:39.080 --> 00:04:40.940
I find it delightful.

00:04:40.940 --> 00:04:43.280
I think it is really, really nice.

00:04:43.280 --> 00:04:48.340
You know, there's a lot of these concepts that if I remember reading algorithm-type books,

00:04:48.340 --> 00:04:51.740
and it's just, you know, you're about to fall asleep.

00:04:51.740 --> 00:04:55.720
It's just so dense and so hard to make it real, right?

00:04:55.720 --> 00:04:59.260
It's like, I don't know, it's just tough to grok them, I guess, right?

00:04:59.260 --> 00:05:05.760
And your book is filled with playful examples and fun pictures and things like that, right?

00:05:05.760 --> 00:05:07.300
What was inspiration for that?

00:05:07.300 --> 00:05:11.820
This whole thing started because I wrote a blog post on Haskell,

00:05:11.820 --> 00:05:18.820
and it's this blog post about monads, which is a tough concept for a lot of people to understand.

00:05:18.820 --> 00:05:24.560
The post got really popular, and still, you know, to this day, I see it being tweeted.

00:05:25.560 --> 00:05:30.480
That's when, you know, I was like, you know, using pictures can really make a big difference

00:05:30.480 --> 00:05:32.660
when you're trying to explain hard concepts.

00:05:32.660 --> 00:05:36.440
So that's where I started with the book.

00:05:36.440 --> 00:05:41.780
It was like, I would love to do, because I've always known I would love to do a book on algorithms.

00:05:41.780 --> 00:05:46.160
Like you said, there's all the ones that I've read so far are so hard to read,

00:05:46.160 --> 00:05:52.680
and I had a very good algorithms professor at Chicago, and she made things so easy.

00:05:53.180 --> 00:06:00.560
So, you know, that's when I thought it would be great to have a book that makes it as easy as she made it for me.

00:06:00.560 --> 00:06:03.980
And it just, you know, it just seemed like a good fit.

00:06:03.980 --> 00:06:09.120
You started your blog at audit.io, and I'll be sure to link to that, right?

00:06:09.120 --> 00:06:12.820
And you started doing these visual sort of explanation posts.

00:06:12.820 --> 00:06:13.360
Yeah.

00:06:13.360 --> 00:06:16.160
Did like, so this book is published by Manning, is that right?

00:06:16.160 --> 00:06:16.580
Yes.

00:06:16.840 --> 00:06:21.120
Yeah, so did Manning reach out to you and go, hey, this illustrated idea is really cool,

00:06:21.120 --> 00:06:26.140
or did you approach him and say, I'd like to do something more torturous to myself?

00:06:26.140 --> 00:06:27.200
No.

00:06:27.200 --> 00:06:29.080
They reached out to me.

00:06:29.080 --> 00:06:30.280
It was just the craziest.

00:06:30.280 --> 00:06:34.980
After that, I kind of joked, like, this is how I get success.

00:06:34.980 --> 00:06:38.120
I just sit back and wait for people to come to me.

00:06:38.340 --> 00:06:41.160
There's a lesson there, though, I think, and that's really cool to hear.

00:06:41.160 --> 00:06:49.480
I think there's a really important lesson there that you don't know what opportunities are out there or how they're going to come to you.

00:06:49.820 --> 00:06:56.020
But if you don't ever put yourself out there and you don't try to do things in public, they're absolutely not going to come, right?

00:06:56.020 --> 00:07:01.720
Like, there's so many opportunities have come to me from because of the podcast, but I never even imagined that they would.

00:07:01.720 --> 00:07:05.840
I wasn't looking for them, and I didn't do the podcast for them or anything like that.

00:07:05.840 --> 00:07:08.500
But just, like you said, being out there makes a big difference.

00:07:08.500 --> 00:07:09.200
I agree.

00:07:09.200 --> 00:07:12.520
And I put in so much work into those blog posts.

00:07:12.520 --> 00:07:16.160
Like, it used to take me weeks to write a single post.

00:07:16.160 --> 00:07:20.900
And it's kind of like just throwing a note in a bottle, right?

00:07:20.900 --> 00:07:25.480
Like, you don't know if anyone's even reading it or even cares.

00:07:25.480 --> 00:07:28.840
But somehow, you know, I mean, I enjoyed it.

00:07:28.840 --> 00:07:31.220
That's why I kept doing it, and things just worked out.

00:07:31.220 --> 00:07:38.560
So your book on algorithms is written in Python, and you could have chosen many languages, Java, JavaScript, and so on.

00:07:38.560 --> 00:07:39.540
Why Python?

00:07:39.540 --> 00:07:41.720
It's just the easiest language for me.

00:07:41.980 --> 00:07:43.140
It's the easiest to learn.

00:07:43.140 --> 00:07:48.920
I used to teach a course on Python, and it was just people picked it up so quickly.

00:07:48.920 --> 00:07:50.760
Yeah, I totally agree with that.

00:07:50.760 --> 00:07:57.040
You know, I was thinking earlier as you were talking about you want to get back to the ActionScript days and things that are easy.

00:07:57.040 --> 00:08:03.580
A lot of people know JavaScript, but I feel like JavaScript has, by way of its popularity, become hard again.

00:08:03.580 --> 00:08:10.020
You know, like all the Node.js dependencies, all the layers piled on top of it.

00:08:10.100 --> 00:08:14.340
Somehow, Python has managed to avoid that fate, which keeps it simple but powerful.

00:08:14.340 --> 00:08:14.980
I think it's great.

00:08:14.980 --> 00:08:17.280
I'm constantly confused by JavaScript.

00:08:17.280 --> 00:08:18.980
I think it's a...

00:08:18.980 --> 00:08:24.020
I love JavaScript because it has a lot of those functional parts that I really like.

00:08:24.020 --> 00:08:28.220
But yeah, the JavaScript community is moving so fast, it's hard to keep up.

00:08:28.220 --> 00:08:29.100
Yeah, for sure.

00:08:30.260 --> 00:08:39.960
So one thing that you said when you were talking in the preface of your book, you said that for everything that you describe, you like to lead with examples.

00:08:39.960 --> 00:08:41.020
Yes.

00:08:41.020 --> 00:08:43.920
Well, so this is part of my...

00:08:44.920 --> 00:08:49.860
I mean, I have this, you know, some ideas about like what it means to teach something well.

00:08:49.860 --> 00:08:55.460
And I think one big piece of that is you have to make things concrete.

00:08:55.460 --> 00:08:58.380
I'm reading this book on probability right now.

00:08:58.380 --> 00:09:05.200
And one thing that really frustrates me about this book is they'll start with a simple problem.

00:09:05.660 --> 00:09:11.980
So they'll say, you know, for example, one of the problems in the book is this classic random walk idea.

00:09:11.980 --> 00:09:15.520
So you have a man standing at the edge of a cliff.

00:09:15.520 --> 00:09:19.780
And there's a one-third chance that he'll step towards the cliff.

00:09:19.780 --> 00:09:23.400
And there's a two-third chance that he'll step away from the cliff.

00:09:23.400 --> 00:09:26.640
And he's drunk, so he doesn't know which direction he's going to step in.

00:09:27.160 --> 00:09:30.100
So, of course, if he takes a step towards the cliff, he's just going to fall off.

00:09:30.100 --> 00:09:32.280
But there's a two-third chance he'll step away.

00:09:32.280 --> 00:09:36.960
And, you know, again, there's a one-third chance that he'll step towards, two-thirds that he'll step away.

00:09:36.960 --> 00:09:42.740
So the question is, does he escape the cliff or does he eventually fall off?

00:09:42.740 --> 00:09:50.320
So a pretty good probability problem, you know, because it's simple to state and pretty hard to solve.

00:09:50.600 --> 00:09:55.860
But then I read their answer in the back and they're like, okay, let's generalize this problem.

00:09:55.860 --> 00:10:02.620
And let's say X is the probability of him stepping towards and Y is the probability of stepping away.

00:10:02.620 --> 00:10:05.400
And I was like, no, you have concrete numbers.

00:10:05.400 --> 00:10:10.300
Isn't it so much better to be able to visualize the problem as you're stepping through it?

00:10:10.300 --> 00:10:13.280
And the only way to do that is by having a concrete example.

00:10:13.280 --> 00:10:13.760
Yeah.

00:10:13.760 --> 00:10:14.600
Yeah, I agree.

00:10:14.600 --> 00:10:27.540
I feel like a lot of things, the concreteness of it and sort of the reason the whole thing came to be interesting in the first place gets, it kind of gets sterilized and all that stuff gets lost.

00:10:27.540 --> 00:10:30.120
And you're down to just the essence of the abstract problem.

00:10:30.120 --> 00:10:33.620
But then the joy of the problem is kind of gone in some ways, right?

00:10:33.620 --> 00:10:35.900
So I really like that you have examples.

00:10:35.900 --> 00:10:38.420
And these are like really playful examples.

00:10:38.420 --> 00:10:45.500
I think it's important to start with making things concrete and then you can get into the theory and the abstract and so on.

00:10:45.500 --> 00:10:46.060
Yeah.

00:10:46.060 --> 00:10:57.080
I think I also try to choose pretty real world examples so people can, you know, look at the problem and think about all the different ways they could use it in their work.

00:10:57.080 --> 00:10:57.640
Yeah.

00:10:57.640 --> 00:11:00.200
I really like the one about Maggie and the checkout counter.

00:11:00.200 --> 00:11:01.280
We'll get to that one.

00:11:01.280 --> 00:11:02.200
Thank you.

00:11:03.240 --> 00:11:12.000
So I have a pretty diverse listenership and people, a lot of people have, you know, PhDs in computer science, but a lot of people have come from different areas.

00:11:12.000 --> 00:11:16.760
So just real quickly, what, tell us, what's an algorithm for those of us who don't know?

00:11:16.760 --> 00:11:20.480
An algorithm is a set of instructions for accomplishing a task.

00:11:20.480 --> 00:11:24.140
So really any piece of code could be an algorithm, right?

00:11:24.140 --> 00:11:35.120
But there are certain pieces that are more interesting, maybe because they solve a hard problem really well, or maybe they can be used at a lot of different places.

00:11:35.120 --> 00:11:40.160
So that's really what we talk about when we say algorithms, you know.

00:11:40.160 --> 00:11:40.620
Yeah.

00:11:40.620 --> 00:11:40.820
Okay.

00:11:40.820 --> 00:11:41.680
I totally agree.

00:11:41.680 --> 00:11:44.240
I think it's the reusability is definitely an interesting part.

00:11:44.240 --> 00:11:51.660
Like the way you might log something to disk might be an algorithm, but it's not reusable in any way because it's exactly specific to a thing.

00:11:51.660 --> 00:11:53.860
So you wouldn't call it an algorithm per se, right?

00:11:54.160 --> 00:11:54.440
Yeah.

00:11:54.440 --> 00:11:55.220
Cool.

00:11:55.220 --> 00:11:56.040
All right.

00:11:56.040 --> 00:12:00.540
So in your book, you broke it down to, like you said, there's going to be two major things that you learned.

00:12:00.540 --> 00:12:05.660
One, you said you're going to learn about performance and the other, you're going to learn about solving problems.

00:12:05.660 --> 00:12:06.940
How's that work?

00:12:06.940 --> 00:12:11.940
The solving problems one is the really big one that I focused on.

00:12:11.940 --> 00:12:23.780
Back when I was starting out, I just used to run into walls sometimes where you like come across a problem and you just don't know how you're going to solve it because you've never solved a problem like that before.

00:12:23.780 --> 00:12:28.300
Or you don't really have a lot of tools in your tool belt.

00:12:28.300 --> 00:12:33.940
So you can't say like, oh, maybe I'll use a hash table for this and see if that works.

00:12:33.940 --> 00:12:38.260
Or maybe I should try to use some kind of a machine learning approach.

00:12:38.260 --> 00:12:43.480
If you, you know, there's this idea of you don't know what you don't know.

00:12:44.260 --> 00:12:47.660
And if you don't know that those tools exist, you're just stuck.

00:12:47.660 --> 00:12:48.780
You can't solve those problems.

00:12:48.780 --> 00:12:58.200
So this book is really about giving you all those tools like that should be able to solve most of the problems you encounter day to day.

00:12:58.200 --> 00:12:59.380
Yeah, that's really cool.

00:12:59.460 --> 00:13:10.440
And some of the examples you give are like, if you're making a video game, you could learn how to create an AI system that can find its way through pass or a recommendation system kind of like Amazon.

00:13:10.440 --> 00:13:18.900
So that you might like, or even things that knowing that there are problems that are basically not solvable in a quick way.

00:13:18.900 --> 00:13:21.020
Yeah, those NP complete problems.

00:13:21.020 --> 00:13:21.620
Yeah, yeah.

00:13:21.620 --> 00:13:23.600
That's a whole different interesting area.

00:13:23.600 --> 00:13:26.340
I think performance is also interesting.

00:13:26.520 --> 00:13:31.000
I mean, you talked about hash tables just a minute ago and dictionaries.

00:13:31.000 --> 00:13:42.540
Like, knowing that if I have this type of thing I need to do, it's 100 times faster using this data structure than that data structure and being able to express that.

00:13:42.540 --> 00:13:45.460
It helps you design how you solve a problem.

00:13:45.460 --> 00:13:50.500
If you're like, you know, if I can coerce it into this shape, it will be rocket fast.

00:13:50.500 --> 00:13:51.160
Absolutely.

00:13:51.600 --> 00:13:56.780
That's something, to me, that is really about the craft of engineering.

00:13:56.780 --> 00:14:02.140
One reason I love Python is you can write beautiful code with it.

00:14:02.140 --> 00:14:12.700
And I think thinking about performance is just another aspect of that craft where you like, you know, you want to write something that runs well, that's dependable.

00:14:13.080 --> 00:14:16.440
And that means it should run as fast as it can run.

00:14:16.440 --> 00:14:16.880
Yeah.

00:14:16.880 --> 00:14:25.080
Yeah, up to the point where it becomes, like, you can optimize something so much that it becomes write only.

00:14:25.080 --> 00:14:29.260
Like, you wrote it and it works, but you can't understand it and nobody else can certainly understand it, right?

00:14:29.260 --> 00:14:29.920
Oh, yeah.

00:14:29.920 --> 00:14:33.720
So there has to be this tradeoff of maintainability.

00:14:33.720 --> 00:14:41.340
But, yeah, knowing the data structure definitely is the right in algorithms and how that works in terms of performance is key.

00:14:41.340 --> 00:14:45.820
So the algorithms, your algorithm book is not, like, comprehensive.

00:14:45.820 --> 00:14:51.420
It's not like an encyclopedia of all known algorithms or anything like that, right?

00:14:51.420 --> 00:14:55.060
It's more a special list.

00:14:55.060 --> 00:15:00.480
You said the topics that you cover are all things you've used at work, which is pretty cool.

00:15:00.480 --> 00:15:01.220
Exactly.

00:15:01.220 --> 00:15:10.860
I think if you're looking for an encyclopedia, like, you could just read the Wikipedia articles or, like, one of those algorithms books that are, like, a thousand pages long.

00:15:10.860 --> 00:15:18.220
You know, I didn't want to, I didn't want my book to be, like, we printed out Wikipedia and bound it into a book format.

00:15:18.220 --> 00:15:18.700
Yeah.

00:15:18.700 --> 00:15:19.820
Thank you for not doing that.

00:15:21.160 --> 00:15:25.640
So we're going to talk in depth about some of the algorithms and stuff.

00:15:25.640 --> 00:15:30.300
But can you just give us, like, a quick flyover of what's covered and things like that?

00:15:30.300 --> 00:15:30.820
Sure.

00:15:30.820 --> 00:15:37.460
So the first part of the book is, like, foundational work that I'll be using in the rest of the book.

00:15:37.460 --> 00:15:47.960
So chapter one introduces you to a very basic algorithm and then talks about big O notation, which is something a lot of people get very confused by.

00:15:47.960 --> 00:15:49.520
But it's an important concept.

00:15:49.960 --> 00:15:53.060
And then chapters, chapter two is about memory.

00:15:53.060 --> 00:15:54.860
Chapter three is about recursion.

00:15:55.100 --> 00:15:59.680
So you can see I'm kind of building the foundation, like, the very basics.

00:15:59.680 --> 00:16:02.900
And then we get into the interesting stuff.

00:16:02.900 --> 00:16:12.820
So, like, chapter four, this is where I introduce one of those tools that I was talking about called divide and conquer, where, you know, you get a problem.

00:16:12.820 --> 00:16:14.620
I don't know how to solve this.

00:16:14.740 --> 00:16:18.540
Well, you could think, like, maybe I'll use divide and conquer and see if that works.

00:16:18.540 --> 00:16:25.480
Chapter five is hash tables, which is the most useful tool in my tool belt.

00:16:25.480 --> 00:16:26.640
I totally agree with you.

00:16:26.640 --> 00:16:27.960
Yeah, you had a good quote.

00:16:27.960 --> 00:16:31.440
You said, when I want to solve a problem, there are two planes of attack I start with.

00:16:31.440 --> 00:16:34.220
Like, can I make this hash table problem?

00:16:34.280 --> 00:16:36.120
Can I solve it with a graph, maybe?

00:16:36.120 --> 00:16:37.280
One of those two, right?

00:16:37.280 --> 00:16:37.580
Exactly.

00:16:37.580 --> 00:16:41.960
I feel like, I mean, this is kind of a secret tip.

00:16:42.380 --> 00:16:50.680
But when I get into an interview and someone gives me a problem, I immediately just think hash tables or graphs.

00:16:50.680 --> 00:16:54.680
And it works, like, 90% of the time, you know.

00:16:54.680 --> 00:16:55.000
Nice.

00:16:55.000 --> 00:16:57.420
So, yeah, obviously, I think graphs are really important.

00:16:57.420 --> 00:17:02.220
So chapter six and seven are graphs, another very useful tool.

00:17:02.220 --> 00:17:06.720
Chapter eight is another good tool, and it's so easy.

00:17:06.720 --> 00:17:17.580
Like, this might be the easiest chapter in the book, because chapter eight is really, like, do the dumbest thing you can think of, and it'll probably work.

00:17:17.580 --> 00:17:20.400
And that's what a greedy algorithm is.

00:17:20.400 --> 00:17:21.100
Yeah.

00:17:21.100 --> 00:17:22.720
Sometimes, you know, computers are fast.

00:17:22.720 --> 00:17:24.460
Sometimes the problems aren't that big.

00:17:24.460 --> 00:17:26.260
Just solve it simply, right?

00:17:26.260 --> 00:17:27.060
Exactly.

00:17:27.060 --> 00:17:36.020
Chapter nine is probably the one I'm most proud of and the one that people have complimented me the most on,

00:17:36.180 --> 00:17:42.520
because it's dynamic programming, and it is this really hard way to solve things.

00:17:42.520 --> 00:17:47.520
That's not the same as programming with a dynamic language versus static languages.

00:17:47.520 --> 00:17:48.480
It's something different, right?

00:17:48.480 --> 00:17:49.120
Yeah.

00:17:49.120 --> 00:17:59.440
It's all about creating this 2D array and splitting a problem up into sub-problems and then using those solutions for those sub-problems for the bigger problem.

00:17:59.440 --> 00:18:03.240
It kind of, I feel like it just blows people's minds.

00:18:03.240 --> 00:18:04.960
It's just so hard to use.

00:18:04.960 --> 00:18:13.840
I mean, I spent maybe three or four months on this chapter alone, and I think it's really well-written, and a lot of people have found it very useful.

00:18:15.020 --> 00:18:16.740
So that's chapter nine.

00:18:16.740 --> 00:18:28.300
And then chapter 10, I just wanted to put a little thing about machine learning in here, because key nearest neighbors is so easy to use, and it's so effective.

00:18:29.340 --> 00:18:35.060
And it was just, you know, you could read this chapter before bed, and you would know how to build a recommendations engine.

00:18:35.060 --> 00:18:35.960
Oh, that's great.

00:18:35.960 --> 00:18:36.720
That's really cool.

00:18:36.720 --> 00:18:36.920
Yeah.

00:18:37.400 --> 00:18:43.200
And then you finish out with saying, basically, now that you're inspired, you know the foundational algorithms.

00:18:43.200 --> 00:18:45.700
Here's a whole bunch more things you can go do, right?

00:18:45.700 --> 00:18:46.380
Yeah.

00:18:46.520 --> 00:19:01.920
And then there's 10 things in chapter 11 that I think are really neat, and they're just, oh, I wish I could have put all 10 of these in the book also, but I just gave a little tidbit about each one.

00:19:01.920 --> 00:19:02.340
Sure.

00:19:02.500 --> 00:19:06.120
That'll be the follow-on, the second version.

00:19:06.120 --> 00:19:06.420
Yeah.

00:19:06.420 --> 00:19:06.800
Yeah.

00:19:06.800 --> 00:19:19.140
So one thing that I liked about your book is you have little short exercises, like a couple minutes, two or three minutes at the end of each section, each chapter, that you can do to sort of test your thinking.

00:19:19.140 --> 00:19:20.640
And I found those to be really nice.

00:19:20.640 --> 00:19:21.320
Thank you.

00:19:21.320 --> 00:19:31.640
I've been reading this book called A Book of Abstract Algebra, and it's got a great model where all the chapters are like two pages followed by six pages of exercises.

00:19:32.340 --> 00:19:38.240
I found that those exercises helped me so much, so I figured, you know, I need to put more exercises in my book.

00:19:38.240 --> 00:19:40.400
So who did you have in mind?

00:19:40.400 --> 00:19:45.020
Like, if I have no programming or very little program experience, would this book be useful?

00:19:45.020 --> 00:19:47.620
If I had a computer science degree, would it still be useful?

00:19:47.620 --> 00:19:52.360
So it's been really popular with boot camp students so far.

00:19:52.360 --> 00:20:02.300
I have a few friends who went to boot camps, and, you know, I have a friend who's in a boot camp right now, and he kind of told other students in the camp,

00:20:02.300 --> 00:20:06.180
about it, and they all seem to like it.

00:20:06.180 --> 00:20:12.540
I think it's also useful for people who have a computer science degree.

00:20:13.500 --> 00:20:19.960
So I work at Etsy, and I kind of, you know, just sent an email out when the book came out saying, like, hey, I've published a book.

00:20:19.960 --> 00:20:21.180
You know, isn't that cool?

00:20:22.140 --> 00:20:30.760
And I've had people email me, like, really senior people, you know, people who are, like, two levels above me at Etsy.

00:20:30.760 --> 00:20:37.480
And they're like, wow, I, finally I have great examples to explain these concepts with.

00:20:37.480 --> 00:20:41.120
Because it's so hard to come up with a good example to explain something.

00:20:41.280 --> 00:20:41.800
Yeah, absolutely.

00:20:41.800 --> 00:20:42.980
It's one thing to know it.

00:20:42.980 --> 00:20:45.220
It's another to teach it to another person.

00:20:45.220 --> 00:20:49.380
And I think it is really, I think it's really accessible in that way.

00:20:49.380 --> 00:20:49.980
Thank you.

00:20:49.980 --> 00:20:52.840
It also doesn't require a lot of math, which I like.

00:20:52.840 --> 00:20:57.520
You know, you don't need calculus or linear algebra or anything.

00:20:57.520 --> 00:21:05.460
It's really, like, if you know the basics of algebra, like, if you know what a function is, you can read this book.

00:21:05.460 --> 00:21:06.000
Yeah.

00:21:06.000 --> 00:21:07.240
I like that you said that.

00:21:07.240 --> 00:21:12.580
You know, I was talking to a friend of mine about sort of what does it take to become a programmer?

00:21:12.580 --> 00:21:15.140
Like, how much math do you need to know?

00:21:15.140 --> 00:21:20.140
And I think there's an outside of the programming field, like, people who are not programmers,

00:21:20.140 --> 00:21:24.320
I feel like programming is very, very mathematical, right?

00:21:24.380 --> 00:21:29.080
Like, if you don't know how to do calculus and differential equations, you'll never be a good programmer.

00:21:29.080 --> 00:21:34.920
And to be honest, I find I do very little actual advanced math in anything that I do,

00:21:34.920 --> 00:21:38.040
except for when I was working for, like, a scientific visualization company.

00:21:38.040 --> 00:21:43.080
But outside of that context, like, it's more just knowing, like, critical thinking and problem solving.

00:21:43.080 --> 00:21:47.340
And so I think that they give people feel like they need to learn a lot of math.

00:21:47.340 --> 00:21:50.680
I mean, math is not a bad thing, but I don't think it's required.

00:21:50.680 --> 00:21:51.340
Do you?

00:21:51.340 --> 00:21:53.100
I don't think it's required either.

00:21:53.600 --> 00:22:02.640
I think, especially for something like this, where, like, algorithms are the first step to, like, long journey in computer science.

00:22:02.640 --> 00:22:06.780
And that first step should be as easy as possible.

00:22:06.780 --> 00:22:10.320
There shouldn't be, like, big hurdles to get to that first step.

00:22:10.320 --> 00:22:11.440
Yeah, totally agree.

00:22:11.440 --> 00:22:12.680
Totally agree.

00:22:12.680 --> 00:22:13.240
Okay, cool.

00:22:13.240 --> 00:22:18.220
So let's talk about some of the algorithms and some of the things that you covered in the book.

00:22:18.340 --> 00:22:28.020
The very first one that you covered was sort of different types of searching in sets and really leading towards binary search.

00:22:28.260 --> 00:22:28.820
Yeah.

00:22:28.820 --> 00:22:36.440
This is my favorite algorithms example because anyone can understand it.

00:22:36.440 --> 00:22:41.440
Like, you don't even need to know anything about computers.

00:22:42.720 --> 00:22:48.540
But because a lot of people, you know, when they heard I'm writing a book, they were like, tell me what is an algorithm.

00:22:48.540 --> 00:22:55.260
So I gave them this example where I was like, you know, think of a, I'm thinking of a number between 1 and 100.

00:22:56.060 --> 00:22:56.680
Take a guess.

00:22:56.680 --> 00:22:58.460
And they would say, you know, 55.

00:22:58.460 --> 00:23:02.260
And I'd say, well, that's too high.

00:23:02.260 --> 00:23:03.140
Take another guess.

00:23:03.140 --> 00:23:04.240
And they'd say 30.

00:23:04.240 --> 00:23:13.360
And that's interesting because people automatically divide the space in half when they guess, almost on instinct.

00:23:13.360 --> 00:23:19.260
Like, maybe they don't even understand what they're doing, but they're running binary search in their mind.

00:23:20.000 --> 00:23:21.620
You know, that's all binary search is.

00:23:21.620 --> 00:23:27.420
Divide the space in half every time to get to the results or to find the result as quickly as you can.

00:23:27.420 --> 00:23:28.900
Yeah, it's such a simple example.

00:23:28.900 --> 00:23:38.800
And yet I think it really dramatically points out the power of taking that, formalizing it just a little bit and making it really fast.

00:23:38.800 --> 00:23:55.040
Capital One has a special message for you.

00:23:55.040 --> 00:23:57.480
They need Python pros who love to work with data.

00:23:57.480 --> 00:24:03.200
Put your Python experience at work at Capital One and help them use data to make life better for millions of customers.

00:24:03.200 --> 00:24:08.040
Capital One is employing the latest tools and approaches to do data analytics and data science

00:24:08.040 --> 00:24:09.120
from the ground up.

00:24:09.120 --> 00:24:13.000
They're smart, creative professionals who love to explore new ways to interact with data.

00:24:13.000 --> 00:24:16.320
They're interested in figuring out novel, advanced Python techniques,

00:24:16.320 --> 00:24:20.440
and even more interested in finding more people who will help them do that.

00:24:20.440 --> 00:24:24.240
When you join their state-of-the-art Python community, you'll work with people you really like,

00:24:24.240 --> 00:24:26.600
people who might be listening to this podcast right now.

00:24:26.600 --> 00:24:28.940
Relentless innovation is their way of life.

00:24:28.940 --> 00:24:30.480
Make it yours at Capital One.

00:24:30.480 --> 00:24:35.740
Visit jobs.capitalone.com slash talkpython to learn more and apply today.

00:24:37.280 --> 00:24:41.900
You had a cool example.

00:24:41.900 --> 00:24:44.720
You said, you know, imagine that you play this.

00:24:44.720 --> 00:24:47.540
You have a couple of ways which you could do it.

00:24:47.540 --> 00:24:52.740
Like you could just say like, I've got a list of 100 things and you want to search for something in there.

00:24:52.740 --> 00:24:53.120
Right?

00:24:53.120 --> 00:24:54.560
Kind of like the example you just gave.

00:24:55.020 --> 00:25:00.080
One option is to look at the first one, check it next one.

00:25:00.080 --> 00:25:02.060
Just go through it in order, right?

00:25:02.060 --> 00:25:08.400
Another way is to apply this binary search thing, assuming that set is somehow ordered like an address book or something.

00:25:08.400 --> 00:25:13.600
And you said, well, for 100 items, if you go straight through it, you know, worst case, you'll have to go,

00:25:13.600 --> 00:25:14.800
you'll search until you get to the end.

00:25:14.800 --> 00:25:15.260
That's 100.

00:25:15.600 --> 00:25:20.760
But if you use the binary search because you half it and half it and half it, worst case scenario, you get seven.

00:25:20.760 --> 00:25:23.400
But then you said, well, let's think about it, four billion.

00:25:23.860 --> 00:25:24.000
Yeah.

00:25:24.000 --> 00:25:29.920
And it's so crazy because now the difference, you know, now it's really obvious.

00:25:29.920 --> 00:25:33.560
Like for searching through four billion items is too much.

00:25:33.560 --> 00:25:36.900
But with binary search, it's just 32.

00:25:36.900 --> 00:25:39.680
Maximum of 32 guesses, right?

00:25:39.680 --> 00:25:42.740
Even if it's I'm guessing between a number between zero and four billion.

00:25:42.740 --> 00:25:43.360
Yeah.

00:25:43.360 --> 00:25:45.780
Isn't that such a huge difference?

00:25:45.780 --> 00:25:46.360
Yeah.

00:25:46.360 --> 00:25:47.840
It's it's insane.

00:25:47.840 --> 00:25:50.020
I mean, it makes sense.

00:25:50.460 --> 00:25:55.700
But at the same time, you don't think such a simple idea is going to reduce it from four

00:25:55.700 --> 00:25:58.120
billion comparisons to 32 at worst case.

00:25:58.120 --> 00:25:58.740
Yeah.

00:25:58.740 --> 00:25:59.880
It's really amazing.

00:25:59.880 --> 00:26:00.260
Yeah.

00:26:00.260 --> 00:26:00.680
Yeah.

00:26:00.680 --> 00:26:06.780
So one of the things I think is hard for people who have not gone through a formal computer science

00:26:06.780 --> 00:26:09.660
background and just for everybody listening, I don't have a computer science degree, but

00:26:09.660 --> 00:26:11.060
I have a minor in computer science.

00:26:11.060 --> 00:26:12.080
So I've gone through some of it.

00:26:12.080 --> 00:26:13.960
So I guess I'm somewhere in the middle of this.

00:26:13.960 --> 00:26:18.220
But if you are self-taught, if you've gone to a boot camp or if you're just really new,

00:26:19.540 --> 00:26:24.160
people often talk about big O notation around performance of algorithms.

00:26:24.160 --> 00:26:27.680
And I think that that's kind of mysterious to people.

00:26:27.680 --> 00:26:32.500
And it also seems to be something that ends up on job interviews often.

00:26:32.500 --> 00:26:36.740
And so if you don't have that experience, you're like, I don't even know what big O is.

00:26:36.740 --> 00:26:40.880
Like, well, sorry, you're out or something, right?

00:26:40.880 --> 00:26:45.440
Like it can be a bigger problem than it maybe really deserves to be.

00:26:45.440 --> 00:26:48.680
But I think it's worth knowing big O notation for a couple reasons.

00:26:48.680 --> 00:26:49.080
Yeah.

00:26:49.080 --> 00:26:52.240
Dude, this was a really good way for you to introduce that concept, I thought.

00:26:52.240 --> 00:26:53.760
Like, pretty crazy, right?

00:26:53.760 --> 00:26:55.060
Yeah, exactly.

00:26:55.060 --> 00:26:59.120
And I won't, you know, get into the full explanation here.

00:26:59.300 --> 00:27:06.680
But I do want to say, I think every beginner engineer I meet has trouble with big O notation.

00:27:06.680 --> 00:27:14.380
So, you know, if some of your listeners are still new to engineering, just to say, like, that's not just you.

00:27:14.380 --> 00:27:15.320
Don't feel that.

00:27:15.320 --> 00:27:15.760
That's right.

00:27:15.900 --> 00:27:16.300
Yeah.

00:27:16.300 --> 00:27:20.600
But that's why I, you know, it's right up front in the book.

00:27:20.600 --> 00:27:24.020
And then I talk about it again in chapter four.

00:27:24.280 --> 00:27:29.940
So, I spend a lot of time trying to explain big O notation in this book.

00:27:29.940 --> 00:27:30.800
Yeah, absolutely.

00:27:31.900 --> 00:27:33.440
So, I think it's pretty interesting.

00:27:33.440 --> 00:27:38.020
You've got the linear search, which is what they call O of N.

00:27:38.480 --> 00:27:41.900
So, as if you have N items, you have to do N comparisons.

00:27:41.900 --> 00:27:44.240
If you have two N items, you have to do two N comparisons.

00:27:44.240 --> 00:27:45.440
It grows basically linearly.

00:27:45.440 --> 00:27:52.780
But this binary search one is log of N, which doesn't sound like that big of a difference.

00:27:52.780 --> 00:27:54.880
So, you realize it's 4 billion versus 32.

00:27:54.880 --> 00:27:55.980
You know?

00:27:55.980 --> 00:27:57.620
Which is pretty amazing.

00:27:57.620 --> 00:28:03.840
So, knowing this relative scale, that doesn't actually tell you how fast it is, does it?

00:28:03.840 --> 00:28:08.520
That just tells you, like, relatively how much slower does it get as you get more data.

00:28:08.520 --> 00:28:09.160
Exactly.

00:28:09.160 --> 00:28:12.480
Because everyone's computer, you know, calculates at a different speed.

00:28:12.480 --> 00:28:15.200
So, you can't put a time on it.

00:28:15.200 --> 00:28:15.560
Yeah.

00:28:15.560 --> 00:28:23.520
And that becomes interesting later when you find algorithms that are actually look worse in big O, but often they're not.

00:28:24.100 --> 00:28:29.580
And so, you talked about this idea of average time versus worst case time.

00:28:29.580 --> 00:28:32.220
I think that's also important to understand.

00:28:32.220 --> 00:28:33.020
Yeah.

00:28:33.020 --> 00:28:48.440
That's another really interesting one where, you know, if you can say that your algorithm is going to take a short time on average and a really long time, worst case, maybe that's fine.

00:28:48.440 --> 00:28:56.780
And, you know, if you're just a website or, you know, you have a basic consumer app and you're like, well, it'll run fast most of the time.

00:28:56.780 --> 00:28:57.500
So, that's fine.

00:28:57.500 --> 00:29:05.480
If you're NASA and you have to guarantee a certain time, then you really care about that worst case time also.

00:29:05.780 --> 00:29:05.840
Yeah.

00:29:05.840 --> 00:29:07.180
Any real-time system.

00:29:07.180 --> 00:29:22.440
So, if you were doing like a flight control system on a spaceship or if you're doing trading in some sort of high-speed trading system or I worked on a system that would actually analyze eye tracking data in real time.

00:29:22.780 --> 00:29:25.280
And it would get 250 samples per second.

00:29:25.280 --> 00:29:32.200
And if it couldn't process using some very advanced sort of wavelet decomposition algorithms and whatnot.

00:29:32.200 --> 00:29:35.420
If you couldn't process that in, you know, four milliseconds.

00:29:35.420 --> 00:29:39.200
Well, then it just couldn't keep up because that was how fast data was coming, right?

00:29:39.200 --> 00:29:44.120
I mean, there's these situations where worst case time maybe is super important.

00:29:44.120 --> 00:29:46.720
But a lot of times, like you said, average time I think is fine.

00:29:47.180 --> 00:29:54.400
So, give us some, like for some algorithms that we might know, give us a big O performance stats.

00:29:54.400 --> 00:29:55.220
Sure.

00:29:55.220 --> 00:30:06.280
So, binary search, we already talked about log N and searching, you know, linear search, looking at one item at a time is big O of N.

00:30:06.280 --> 00:30:10.380
And like we just talked about, that's a big difference, right?

00:30:10.380 --> 00:30:11.340
Log N versus N.

00:30:11.340 --> 00:30:17.520
So, again, if you think about that, a slow sorting algorithm is N squared.

00:30:17.520 --> 00:30:20.020
And my example is selection sort.

00:30:20.020 --> 00:30:23.640
A fast sorting algorithm is going to be N log N.

00:30:23.640 --> 00:30:27.180
So, again, you have that log N versus N difference.

00:30:27.180 --> 00:30:29.640
So, the fast sorting algorithm is much faster.

00:30:29.640 --> 00:30:30.060
Yeah.

00:30:30.060 --> 00:30:34.460
And after that, there's like N cubed algorithms.

00:30:34.460 --> 00:30:42.400
My extreme example is you can get big O of N factorial algorithms.

00:30:42.400 --> 00:30:51.460
And, you know, if people don't know what a factorial is, that's like 5 factorial would be 1 times 2 times 3 times 4 times 5.

00:30:51.460 --> 00:30:55.040
6 factorial would be 1, 2, 3, 4, 5, 6.

00:30:55.040 --> 00:30:57.640
Factorial grows really fast.

00:30:57.740 --> 00:31:04.480
If you have an N factorial algorithm, that just means you just can't use it most of the time.

00:31:04.480 --> 00:31:07.000
It only works on extremely small data sets, right?

00:31:07.000 --> 00:31:07.500
Yeah.

00:31:07.500 --> 00:31:07.900
Yeah.

00:31:07.900 --> 00:31:12.860
So, the example, probably the canonical example for that is the traveling salesperson problem.

00:31:12.860 --> 00:31:13.580
Yep.

00:31:13.580 --> 00:31:20.900
And this is one of those NP complete problems we have talked about where, you know, the problem is really simple.

00:31:20.900 --> 00:31:26.900
You're a traveling salesman and you have a list of cities that you want to travel to.

00:31:27.340 --> 00:31:31.760
And you want to figure out the shortest route that hits all of those cities.

00:31:31.760 --> 00:31:34.980
So, it just seems so simple.

00:31:34.980 --> 00:31:37.820
Like, you know, why couldn't you calculate that?

00:31:37.820 --> 00:31:38.880
And, of course, you can.

00:31:38.880 --> 00:31:44.340
It means that you have to come up with every permutation of cities, of the order of cities.

00:31:45.400 --> 00:31:50.700
Which, if you have 6 cities, it's 6 factorial permutations.

00:31:50.700 --> 00:31:56.120
If you have 100 cities, it's 100 factorial permutations.

00:31:56.120 --> 00:32:04.140
And just to give you an example of how crazy that is, 6 factorial is 720, which, you know, your computer can do.

00:32:05.000 --> 00:32:12.720
100 factorial is 9 followed by 157 zeros.

00:32:12.720 --> 00:32:13.460
Wow.

00:32:14.960 --> 00:32:15.360
Yeah.

00:32:15.360 --> 00:32:19.180
That means you're going to run out of time or you're going to run out of memory.

00:32:19.180 --> 00:32:20.260
One of those first.

00:32:20.260 --> 00:32:21.880
But you're probably going to run out of something, right?

00:32:21.880 --> 00:32:22.540
Yeah.

00:32:22.540 --> 00:32:26.640
I think the universe will end before you can make that.

00:32:26.640 --> 00:32:27.420
Absolutely.

00:32:28.720 --> 00:32:29.000
All right.

00:32:29.000 --> 00:32:33.240
So, the next thing that you talked about that I thought was cool was selection sort.

00:32:33.240 --> 00:32:44.000
And you took a moment to say, like, let's think about the two data structures that hold stuff in just like a list style.

00:32:44.000 --> 00:32:46.760
And that was linked lists and arrays.

00:32:46.760 --> 00:32:52.040
And I thought that was a really interesting tradeoff, knowing how you're going to use them and so on.

00:32:52.040 --> 00:32:54.440
So, tell us about that comparison you made.

00:32:54.440 --> 00:32:55.080
Sure.

00:32:55.480 --> 00:33:01.280
So, the example I use in the book is this idea of, you know, you're going to watch a movie.

00:33:01.280 --> 00:33:04.260
And let's say you're going there.

00:33:04.260 --> 00:33:05.680
There's eight of you.

00:33:05.680 --> 00:33:06.800
Eight people are going.

00:33:06.800 --> 00:33:08.280
And you're trying to find seats.

00:33:08.280 --> 00:33:14.740
So, maybe you can find eight seats all together and then you can all sit together.

00:33:14.740 --> 00:33:17.560
Maybe there's no set of eight seats together.

00:33:17.560 --> 00:33:20.120
So, you have to kind of sit all over the theater.

00:33:21.240 --> 00:33:27.100
And you know where each other, you know where your group is, but they're not all in one place.

00:33:27.100 --> 00:33:30.580
And that's this idea of linked lists versus arrays.

00:33:30.580 --> 00:33:33.740
Where arrays, you're all sitting together.

00:33:33.740 --> 00:33:37.400
Link lists, you're all sitting separately.

00:33:37.400 --> 00:33:40.620
You know, your data is together in memory or apart.

00:33:40.620 --> 00:33:43.200
So, with arrays, you basically have a contiguous block.

00:33:43.200 --> 00:33:44.800
Exactly.

00:33:44.800 --> 00:33:50.100
And with linked lists, each element knows how to find the next element.

00:33:50.100 --> 00:33:51.560
Sometimes you have doubly linked lists.

00:33:51.560 --> 00:33:53.880
So, you can start at the back and go forward or forwards and go backwards.

00:33:53.880 --> 00:33:59.840
But each element is more or less in charge of going to a new memory location to find the next or be in the end.

00:33:59.840 --> 00:34:00.660
Exactly.

00:34:00.660 --> 00:34:04.320
And if I could stretch this movie analogy a little bit.

00:34:04.320 --> 00:34:07.000
Let's say, you know, you have a bag of popcorn.

00:34:07.000 --> 00:34:09.420
And you're kind of passing it down the row.

00:34:10.380 --> 00:34:13.280
Really easy to do if you're all sitting together, right?

00:34:13.280 --> 00:34:17.660
Because you can just, you know, the next person is just to your right.

00:34:17.660 --> 00:34:19.740
And you just keep passing the bag to your right.

00:34:19.740 --> 00:34:23.060
And that's what arrays are.

00:34:23.060 --> 00:34:27.160
So, it's really easy to access the next element in an array.

00:34:27.720 --> 00:34:35.120
And it's easy to say, like, you know, I want to find the fifth item in my array.

00:34:35.120 --> 00:34:38.080
Because every once together, you can just do the math.

00:34:38.080 --> 00:34:40.640
Like, zero plus five equals five.

00:34:40.640 --> 00:34:45.180
Linked list, it's like, now you're passing this bag of popcorn around.

00:34:45.180 --> 00:34:47.360
You have to go to the next person in the movie theater.

00:34:47.360 --> 00:34:49.400
And then they have to go to the next person.

00:34:49.400 --> 00:34:51.160
It's a little more arduous.

00:34:51.800 --> 00:34:56.600
And if you want to find the fifth person, you can't just go directly to that person.

00:34:56.600 --> 00:34:58.060
You have to go to the first one.

00:34:58.060 --> 00:34:59.940
And the first one has to go to the second one.

00:34:59.940 --> 00:35:01.880
Second one has to go to the third one.

00:35:01.880 --> 00:35:04.880
So, you have to, like, follow these links down.

00:35:04.880 --> 00:35:06.260
Yeah, that makes perfect sense.

00:35:06.260 --> 00:35:11.880
So, I mostly, if I think of the data structures I use, I mostly use arrays.

00:35:11.880 --> 00:35:12.620
So, lists.

00:35:12.620 --> 00:35:14.680
And dictionaries.

00:35:14.680 --> 00:35:16.420
And then sometimes I want distinct stuff.

00:35:16.420 --> 00:35:16.880
So, sets.

00:35:16.960 --> 00:35:19.360
I don't find myself using linked lists so often.

00:35:19.360 --> 00:35:22.060
But they do have some interesting trade-offs.

00:35:22.060 --> 00:35:25.700
Like, when is an array good versus when is a linked list good?

00:35:25.700 --> 00:35:28.160
So, again, going back to this movie example.

00:35:28.160 --> 00:35:34.840
Sometimes you go to the theater and you just don't have eight seats together, right?

00:35:34.840 --> 00:35:41.020
Like, sometimes you just can't fit an array in memory because you don't have, you know,

00:35:41.020 --> 00:35:46.860
if your array, if the array you want to create is too big, you just don't have space for it.

00:35:46.860 --> 00:35:55.620
Or, what can be bad also is, let's say, eight of you sits down at the theater and you found

00:35:55.620 --> 00:35:59.600
eight seats, everything's great, and now another person shows up.

00:35:59.600 --> 00:36:00.840
So, now you have nine people.

00:36:00.840 --> 00:36:04.040
But there's no space for a ninth person.

00:36:04.560 --> 00:36:10.320
So, now you have to all get up and go around trying to find that ninth seat.

00:36:10.320 --> 00:36:16.160
So, you know, similarly, when you want to add elements to an array, let's say you allocated

00:36:16.160 --> 00:36:17.700
memory for 100 elements.

00:36:17.700 --> 00:36:21.960
And now you want to increase the size of your array to 200.

00:36:21.960 --> 00:36:27.260
Well, it's going to be a lot of work to move those, all those items to a different part of

00:36:27.260 --> 00:36:27.580
memory.

00:36:27.580 --> 00:36:31.420
You know, that's bad performance set.

00:36:31.700 --> 00:36:31.860
Right.

00:36:31.860 --> 00:36:32.520
If you have a linked list.

00:36:32.520 --> 00:36:35.220
Or if I want to insert one in the middle, something like that, right?

00:36:35.220 --> 00:36:35.860
Exactly.

00:36:35.860 --> 00:36:38.260
Like, it's hard to move all those items.

00:36:38.260 --> 00:36:42.780
But for the linked list, you can just put them somewhere and just change the links around.

00:36:42.780 --> 00:36:43.380
Yeah.

00:36:43.380 --> 00:36:47.000
So, you talked about the big O performance of both of those.

00:36:47.000 --> 00:36:51.880
And basically, inserts for lists are O1.

00:36:51.880 --> 00:36:54.180
So, constant, like super fast.

00:36:54.180 --> 00:36:59.880
But, like, random access is order in, which is not so great.

00:37:00.240 --> 00:37:03.380
But it's almost the reverse for arrays, right?

00:37:03.380 --> 00:37:06.720
Random access is just instant, more or less.

00:37:06.720 --> 00:37:10.620
But adding something grows as you have more items, right?

00:37:10.620 --> 00:37:12.500
Because you've got to copy and reallocate and all that.

00:37:12.500 --> 00:37:17.540
So, they're almost like counterpart, like opposites in some way from a performance tradeoff.

00:37:17.540 --> 00:37:18.160
Exactly.

00:37:18.780 --> 00:37:31.840
And that's kind of, you know, you hear all that and you start thinking, gosh, I wish I had something that was as good as arrays for reads and as good as link lists for inserts.

00:37:31.840 --> 00:37:36.400
And that's when you start getting into, like, the more complex data structures.

00:37:36.400 --> 00:37:36.620
Right.

00:37:36.620 --> 00:37:37.020
Absolutely.

00:37:37.980 --> 00:37:47.100
So, another thing that you covered that I recall, like, this has burnt a spot into my brain from when I learned it is recursion.

00:37:47.100 --> 00:37:53.500
And I just remember recursion, like, blowing my mind when I first thought of problem solving with recursion.

00:37:53.500 --> 00:37:54.500
Oh, my gosh.

00:37:54.500 --> 00:37:54.880
Yeah.

00:37:54.880 --> 00:38:05.020
This is another one that's so hard for people to start thinking about it because it's just, you know, a function calling itself.

00:38:05.020 --> 00:38:06.420
That just seems crazy.

00:38:07.000 --> 00:38:13.140
But that's why I have a lot of examples about recursion and I have a lot of exercises.

00:38:13.140 --> 00:38:21.500
And I kind of try to break it down so people understand the structure of a recursive solution.

00:38:21.500 --> 00:38:30.420
Even if you never plan to use recursion in a problem, there are plenty of algorithms that other people have created that use recursion.

00:38:30.420 --> 00:38:35.260
So, if you want to understand those algorithms, you need to know what recursion is.

00:38:35.260 --> 00:38:35.900
Yeah, absolutely.

00:38:36.040 --> 00:38:39.340
And there are times when you can solve a problem without recursion.

00:38:39.340 --> 00:38:47.280
But the data you're trying to understand is so perfectly lined up for recursion that the solution is just dead simple.

00:38:47.280 --> 00:38:50.120
If you realize that that's something in your toolbox, right?

00:38:50.120 --> 00:38:54.400
Like tree, like depth first sort of tree type processing and things like that.

00:38:54.400 --> 00:38:54.860
Exactly.

00:38:54.860 --> 00:38:55.240
Yeah.

00:38:55.240 --> 00:38:59.800
So, one thing that you had at the beginning was this example with boxes.

00:38:59.800 --> 00:39:05.980
And you have like a little box story in the attic for loops and recursions.

00:39:05.980 --> 00:39:06.460
Yeah.

00:39:06.460 --> 00:39:06.540
Yeah.

00:39:06.540 --> 00:39:17.160
So, this was a toy example where, you know, you're going to your grandma's attic and you're looking for this key and she has so many boxes.

00:39:17.160 --> 00:39:18.860
And it could be among these boxes.

00:39:19.720 --> 00:39:25.520
So, you open a box and then you see more boxes inside that box.

00:39:25.520 --> 00:39:30.740
So, now you can think about, you know, there's two ways you could find this key.

00:39:30.740 --> 00:39:34.580
You could kind of keep this list of boxes, right?

00:39:34.660 --> 00:39:40.360
So, like you open a box, you see more boxes and you just add them to your pile of boxes to check.

00:39:40.360 --> 00:39:50.860
And you, the algorithm you're running is you pick up a box from the pile, look for the key.

00:39:50.860 --> 00:39:53.440
If you see some boxes, you add it to the pile.

00:39:54.220 --> 00:39:59.160
And until you find the key, you just grab another box from the pile and check it for the key.

00:39:59.160 --> 00:40:02.640
And that's the while loop approach, right?

00:40:02.640 --> 00:40:09.360
Because while you don't have the key, go to the pile, pick up a box, search for the key.

00:40:09.860 --> 00:40:13.640
And the recursive approach would be open a box.

00:40:13.640 --> 00:40:16.400
If there's a key, you're done.

00:40:16.400 --> 00:40:19.520
If there's a box, open the box.

00:40:19.520 --> 00:40:21.440
If there's a key, you're done.

00:40:21.440 --> 00:40:23.860
If there's a box, open the box, you know.

00:40:23.860 --> 00:40:24.320
Yeah.

00:40:24.320 --> 00:40:30.540
It's got this beautiful, very simple quality to me where you can express it in two lanes.

00:40:30.540 --> 00:40:32.640
Like, if key, done.

00:40:32.640 --> 00:40:34.600
Else, keep going.

00:40:34.600 --> 00:40:36.440
Do it again.

00:40:36.440 --> 00:40:36.560
Do it again.

00:40:36.560 --> 00:40:38.940
Just open the box and see if there's a key in it.

00:40:39.020 --> 00:40:42.340
Yeah, it's got this very natural way of solving the problem, doesn't it?

00:40:42.340 --> 00:40:42.700
That's cool.

00:40:42.700 --> 00:40:43.020
Yeah.

00:40:43.020 --> 00:41:01.100
We all love Python for its tremendous productivity benefits.

00:41:01.100 --> 00:41:03.580
But getting the best performance takes some work.

00:41:03.580 --> 00:41:07.740
What if you could get out of the box, easy access to high-performance Python?

00:41:08.180 --> 00:41:11.380
Intel distribution for Python developers delivers just that.

00:41:11.380 --> 00:41:16.740
Get close to 100 times better performance for certain functions when using NumPy, SciPy,

00:41:16.740 --> 00:41:21.500
scikit-learn, linked with optimized native libraries like Intel Math Kernel Library,

00:41:21.500 --> 00:41:25.320
access-efficient multi-threading, and Python projects like Numba and Scithon.

00:41:25.500 --> 00:41:31.940
Try the Intel distribution for Python and experience performance today at talkpython.fm/Intel.

00:41:31.940 --> 00:41:39.480
And profile your Python and native C, C++ applications for performance hotspots with Intel VTune amplifier.

00:41:39.480 --> 00:41:41.880
With Intel, it's all about performance.

00:41:49.820 --> 00:41:53.140
I like how you've got some nice pictures and the pictures are even simpler.

00:41:53.140 --> 00:41:56.280
It just feels really great.

00:41:56.280 --> 00:42:04.000
The other thing that was interesting was in your first example, you talked about having this list of boxes.

00:42:04.000 --> 00:42:06.720
And you put the stuff in the list and you take the stuff out of the list.

00:42:07.220 --> 00:42:16.200
In the recursion example, you don't have anything that is the storage of where you are or what box you're working on or anything like that.

00:42:16.200 --> 00:42:18.400
Like, how do you keep track of the boxes?

00:42:18.900 --> 00:42:27.400
So that's a really interesting part of recursion, where you're kind of making the computer do the work for you, right?

00:42:27.400 --> 00:42:32.820
Because you call, let's say you call the look for key function.

00:42:32.820 --> 00:42:39.600
So you've called it once, and the computer has that, you know, that information noted.

00:42:39.600 --> 00:42:42.020
Like, okay, he's called look for key once.

00:42:42.820 --> 00:42:45.820
And then you call it again inside look for key.

00:42:45.820 --> 00:42:51.320
So the computer says, okay, that's the second call to the look for key function.

00:42:51.320 --> 00:42:55.100
And then you call it again, and it says, okay, that's the third call.

00:42:55.100 --> 00:42:58.280
So it's kind of keeping track of those calls for you.

00:42:58.280 --> 00:43:02.960
And those function calls is your array, basically.

00:43:03.380 --> 00:43:10.000
You're keeping track of all the boxes you have to check through that array of function calls.

00:43:10.000 --> 00:43:13.400
But the computer is doing it all for you behind the scenes.

00:43:13.400 --> 00:43:14.660
You don't even have to think about it.

00:43:14.660 --> 00:43:15.280
Yeah, absolutely.

00:43:15.280 --> 00:43:18.620
It's just, it's the way programs execute, right?

00:43:18.620 --> 00:43:20.880
And you're just taking advantage of that.

00:43:20.880 --> 00:43:21.920
It lines that up for you.

00:43:21.920 --> 00:43:22.920
That's cool.

00:43:22.920 --> 00:43:30.380
So this whole recursion thing is more or less, is very good at solving this kind of divide and conquer inductive problem.

00:43:30.480 --> 00:43:38.220
If you can talk about some kind of base case, and you can talk about, well, how do I take like one step away from there?

00:43:38.220 --> 00:43:39.920
You can probably apply recursion.

00:43:39.920 --> 00:43:40.420
Yep.

00:43:40.420 --> 00:43:47.200
I'm reading this book called How to Solve It, which is a famous math book about like solving hard problems.

00:43:47.200 --> 00:43:50.060
And I love one of the parts in this book.

00:43:50.060 --> 00:43:58.120
He says, if you come across a problem you can't solve, change it into a problem that you can solve and solve that problem instead.

00:43:59.240 --> 00:44:00.840
I mean, that's so easy.

00:44:00.840 --> 00:44:05.600
And that's the same thing with divide and conquer, where it's really hard to solve this problem.

00:44:05.600 --> 00:44:14.600
But I'm going to just take it down to the smallest component that I can solve and use the solution for that to solve this bigger problem.

00:44:14.600 --> 00:44:15.040
Yeah.

00:44:15.040 --> 00:44:19.660
It kind of gives you a foothold on climbing the solution or whatever.

00:44:19.660 --> 00:44:19.920
Yeah.

00:44:20.140 --> 00:44:24.660
So you have two examples of divide and conquer that you gave in this area.

00:44:24.660 --> 00:44:25.500
Yeah.

00:44:25.500 --> 00:44:31.180
And I'm going to talk about the quick sort one because it's so elegant.

00:44:31.180 --> 00:44:31.580
Yeah.

00:44:31.740 --> 00:44:33.840
It's a great example of divide and conquer.

00:44:33.840 --> 00:44:36.040
And again, such a simple idea.

00:44:36.040 --> 00:44:41.060
You have an array of elements that you want to sort, but you don't know how to sort an array.

00:44:41.060 --> 00:44:43.660
Well, what's an array you can sort?

00:44:43.660 --> 00:44:46.440
How about if the array had zero elements?

00:44:46.440 --> 00:44:47.900
That's pretty easy to sort.

00:44:47.900 --> 00:44:50.080
It's just there's nothing to sort.

00:44:50.080 --> 00:44:50.600
It's sorted.

00:44:50.600 --> 00:44:51.220
It's sorted.

00:44:52.080 --> 00:44:54.980
Similarly, if you have an array with one element, pretty easy.

00:44:54.980 --> 00:45:00.440
If you have an array with two elements, it's still, you know, you just check which one's bigger and put it at the end.

00:45:00.440 --> 00:45:03.220
So all of these are the easy examples.

00:45:03.220 --> 00:45:06.400
Now you get to an array with three elements.

00:45:06.400 --> 00:45:10.540
And quick sort says, just pick an element from the array.

00:45:10.540 --> 00:45:13.040
So it doesn't matter which one.

00:45:13.040 --> 00:45:14.740
So I'll just pick the first one.

00:45:14.740 --> 00:45:18.300
So let's say your array is 5, 3, 7.

00:45:18.760 --> 00:45:22.920
So I pick 5 as my, it's called the pivot element.

00:45:22.920 --> 00:45:28.220
And now I look at the rest of the elements in the array.

00:45:28.220 --> 00:45:29.440
So 3 and 7.

00:45:29.440 --> 00:45:32.340
And I know that 3 is less than 5.

00:45:32.340 --> 00:45:35.020
And I know that 7 is greater than 5.

00:45:35.020 --> 00:45:42.820
So now I have these two sub-arrays, right, of elements less than the pivot and elements greater than the pivot.

00:45:42.820 --> 00:45:48.580
And now I just call quick sort again on those two arrays separately.

00:45:49.400 --> 00:45:53.760
So I call quick sort of this array that only has the element 3.

00:45:53.760 --> 00:45:58.220
And we know how to solve, we know how to sort an array with one element.

00:45:58.220 --> 00:45:59.560
It's just 3.

00:45:59.560 --> 00:46:06.240
And then you have the pivot because that's the number greater, you know, we know that that's greater than 3.

00:46:06.480 --> 00:46:10.360
And then you call quick sort on the second array, which has the 7.

00:46:10.360 --> 00:46:13.480
And again, it's just one element, we know how to sort that.

00:46:13.480 --> 00:46:20.700
So you end up with these three sub-arrays, one with just a 3, one with just a 5, and one with just a 7.

00:46:20.700 --> 00:46:24.240
And you just smash them all together and you have a sorted array.

00:46:25.200 --> 00:46:33.120
So using just the knowledge of how to sort an array with 0, 1, or 2 elements, you started an array with 3 elements.

00:46:33.120 --> 00:46:36.820
And now that you can do that, you can sort an array with 4 or 5 elements.

00:46:36.820 --> 00:46:41.160
And you can kind of sort any array you want just by solving that small problem.

00:46:41.380 --> 00:46:44.180
Yeah, you just continue to break it down, even if you have a million, right?

00:46:44.180 --> 00:46:44.900
Exactly.

00:46:44.900 --> 00:46:45.400
Nice.

00:46:45.400 --> 00:46:47.840
Yeah, quick sort is lovely.

00:46:47.840 --> 00:46:50.520
And the history of quick sort is pretty interesting.

00:46:50.520 --> 00:46:57.100
So another thing, the next thing in your book that you talked about is one of my favorite data structures.

00:46:57.100 --> 00:47:00.800
I don't necessarily use it the most, but when I do use it, it's so awesome.

00:47:00.800 --> 00:47:02.560
And that's hash tables or dictionaries, right?

00:47:02.560 --> 00:47:03.360
Yeah.

00:47:03.360 --> 00:47:10.680
I mean, this is one of the reasons I love JavaScript is, you know, JavaScript objects are just hash tables.

00:47:11.140 --> 00:47:15.020
So hash tables are such a big part of JavaScript.

00:47:15.020 --> 00:47:20.560
And it's, I mean, like I said, I feel like almost any problem, I could just, you know,

00:47:20.560 --> 00:47:24.900
if I just want the quick and dirty solution, I can just do the hash table and call it done.

00:47:24.900 --> 00:47:25.320
Yeah.

00:47:25.320 --> 00:47:28.200
So you had a really nice example of a checkout person.

00:47:28.200 --> 00:47:29.120
Oh, yeah.

00:47:29.120 --> 00:47:30.020
The Maggie.

00:47:30.020 --> 00:47:31.040
The Maggie.

00:47:31.040 --> 00:47:31.380
Yes.

00:47:31.380 --> 00:47:32.020
You need a Maggie.

00:47:32.020 --> 00:47:33.120
How much is an avocado?

00:47:33.120 --> 00:47:33.920
It's $1.49.

00:47:33.920 --> 00:47:34.860
Thank you, Maggie.

00:47:34.860 --> 00:47:35.360
Yeah.

00:47:35.360 --> 00:47:40.900
Isn't, I mean, that's exactly what a hash table is, where you can either look up prices

00:47:40.900 --> 00:47:43.880
in this book and it kind of takes you some time.

00:47:43.880 --> 00:47:46.860
Or you just have a person there who has it all memorized.

00:47:46.860 --> 00:47:50.300
And I just say, you know, it's 67 cents.

00:47:50.300 --> 00:47:50.960
Thank you.

00:47:50.960 --> 00:47:53.040
Maggie is my wife's name.

00:47:53.040 --> 00:47:55.860
And I feel like she is so much smarter than I am.

00:47:56.280 --> 00:47:59.740
So I knew I needed to make her a character in this book.

00:47:59.740 --> 00:48:01.840
Oh, that's a nice touch.

00:48:01.840 --> 00:48:03.160
Yeah.

00:48:03.160 --> 00:48:03.360
Yeah.

00:48:03.360 --> 00:48:03.820
Very cool.

00:48:03.820 --> 00:48:04.120
Yeah.

00:48:04.160 --> 00:48:09.560
So if people want to get a sense of like how powerful hash tables or dictionaries are,

00:48:09.560 --> 00:48:16.520
I just last week wrote a search engine so people could search every single bit of content of

00:48:16.520 --> 00:48:17.860
all the podcast episodes.

00:48:17.860 --> 00:48:21.300
So if you go to talkpython.fm, there's like a little search thing in the top right.

00:48:22.620 --> 00:48:27.860
And you can click it and you can type in complex searches and it'll find basically anything that

00:48:27.860 --> 00:48:28.820
matches all those keywords.

00:48:28.820 --> 00:48:34.280
And the way it works is it goes through all the transcripts.

00:48:34.280 --> 00:48:36.940
It goes through all of the show notes.

00:48:36.940 --> 00:48:39.680
It goes through all the titles, all those various things and a few others.

00:48:40.040 --> 00:48:44.480
And it turns it into a bunch of keywords and turns that into a dictionary.

00:48:44.480 --> 00:48:51.120
And then for each keyword it finds, it figures out if there's a piece that matches, you know,

00:48:51.120 --> 00:48:53.480
what pieces match this keyword and it puts that in there.

00:48:53.480 --> 00:48:58.440
And if you go there, you know, it's like 80 hours of conversation plus some other stuff.

00:48:58.440 --> 00:49:03.780
And you can type in a keyword and hit enter and it runs in sub millisecond time, 100% in Python.

00:49:03.780 --> 00:49:07.920
You know, so you, yeah, you can search for like five,

00:49:07.920 --> 00:49:13.920
finding the things that contain these five words across 80 hours of conversation, 0.1 milliseconds.

00:49:13.920 --> 00:49:15.760
100% by all.

00:49:15.760 --> 00:49:15.840
Beautiful.

00:49:15.840 --> 00:49:20.980
I mean, that is like, think of if that was trying to, you know, regular expression, the text,

00:49:20.980 --> 00:49:24.960
or it was trying to like, you know, literally search it or whatever, right?

00:49:24.960 --> 00:49:25.920
Like it would be insane.

00:49:25.920 --> 00:49:27.440
You just, you're like, ah, this is too slow.

00:49:27.440 --> 00:49:32.140
But yeah, it's so like things like that are just so possible with dictionaries.

00:49:32.140 --> 00:49:33.060
They make me happy.

00:49:33.060 --> 00:49:34.100
Cool.

00:49:34.100 --> 00:49:36.800
So let's talk about some of the other algorithms.

00:49:37.140 --> 00:49:38.240
And we're kind of getting short on time.

00:49:38.240 --> 00:49:41.440
So maybe just sort of skip over and just touch on them a bit.

00:49:41.440 --> 00:49:41.980
Sure.

00:49:41.980 --> 00:49:50.860
Again, chapters five and six are super useful to me, you know, hash tables and graphs.

00:49:51.400 --> 00:49:58.660
And a graph is this really simple idea where you model a problem using nodes and edges.

00:49:58.660 --> 00:50:04.940
So my example is, you're trying to get from Twin Peaks to the Golden Gate Bridge.

00:50:04.940 --> 00:50:08.180
And this is how you can tell that I live in San Francisco.

00:50:08.180 --> 00:50:16.240
And you're trying to figure out what is the least number of bus transfers I have to do to get to from Twin Peaks to the Golden Gate Bridge.

00:50:16.500 --> 00:50:24.720
And so you can model that, you can model it using a graph where you have one node, which is the Golden Gate, which is Twin Peaks.

00:50:24.840 --> 00:50:33.460
And then you kind of puts out edges, which are all the different bus routes you can take to the next part, to the next transfer stop.

00:50:33.460 --> 00:50:43.600
And then that one puts out edges of all the buses you can take from that one to the next transfer stop and so on until you hit the Golden Gate Bridge.

00:50:43.840 --> 00:50:47.900
And it's a, this is a classic, it's called the shortest path problem.

00:50:47.900 --> 00:50:59.180
Another example would be, you're on Facebook and you're trying to find, you really want to talk to, I don't know, someone famous, Brad Pitt, for example.

00:50:59.180 --> 00:51:04.060
And so you're trying to figure out what is the shortest number of connections to Brad Pitt?

00:51:04.060 --> 00:51:06.280
Like, you know, what is the least number of people?

00:51:06.280 --> 00:51:08.900
Which one of your friends could introduce you indirectly?

00:51:08.900 --> 00:51:09.700
Something like this, right?

00:51:09.700 --> 00:51:10.220
Exactly.

00:51:10.220 --> 00:51:15.360
I mean, LinkedIn does this where they say, like, you're, you know, so many connections away from this person.

00:51:15.360 --> 00:51:17.260
And it's just graphs.

00:51:17.260 --> 00:51:18.100
It's a graph problem.

00:51:18.100 --> 00:51:18.600
Nice.

00:51:18.600 --> 00:51:19.400
Okay.

00:51:19.400 --> 00:51:23.560
And then you talk about greedy algorithms and your dynamic programming.

00:51:23.560 --> 00:51:24.460
Yep.

00:51:24.460 --> 00:51:26.980
And again, greedy algorithms are so simple.

00:51:26.980 --> 00:51:31.200
It's just do the simplest thing you can do.

00:51:31.200 --> 00:51:36.400
So, you know, my example is you are a thief.

00:51:36.400 --> 00:51:38.500
This is the classic knapsack problem.

00:51:38.840 --> 00:51:50.540
So, you're a thief in a department store and you have a knapsack and you're trying to figure out what items can I steal to get the maximum value, to steal the maximum value of items.

00:51:50.540 --> 00:51:55.000
And different items have different values, but there's only so much space in your knapsack.

00:51:55.980 --> 00:52:07.680
So, the greedy approach says, pick the most expensive item that will fit in your knapsack and put it in there and then steal the next most expensive item that will fit and keep going until you have filled your knapsack.

00:52:07.680 --> 00:52:15.800
And it doesn't give you a perfect solution, but it gives you a good enough solution where it's good enough for most cases.

00:52:15.800 --> 00:52:16.680
Yeah, this optimization problem.

00:52:16.680 --> 00:52:18.280
Interesting.

00:52:18.280 --> 00:52:18.700
Yeah.

00:52:18.940 --> 00:52:21.140
And then recommendations with K nearest neighbors.

00:52:21.140 --> 00:52:22.080
Oh, yes.

00:52:22.080 --> 00:52:25.220
Again, really simple concepts.

00:52:25.220 --> 00:52:30.320
My example is, let's say you are a Netflix user and Netflix is trying to recommend movies to you.

00:52:31.040 --> 00:52:35.020
And they know that you have, I love the Matrix, for example.

00:52:35.020 --> 00:52:39.540
So, they know that I've rated the Matrix five stars on Netflix and a bunch of other movies.

00:52:39.540 --> 00:52:46.760
So, they look for other users that have similar ratings on those movies.

00:52:46.760 --> 00:52:50.060
So, they might say, like, you rated the Matrix five stars.

00:52:50.780 --> 00:52:53.620
It looks like Keanu Reeves rated the Matrix five stars also.

00:52:53.620 --> 00:53:00.340
And then you rated, I don't know, 101 Dalmatians five stars.

00:53:00.340 --> 00:53:03.940
And Keanu Reeves rated 101 Dalmatians five stars also.

00:53:03.940 --> 00:53:08.480
So, it seems like the two of you have a common taste in movies.

00:53:08.480 --> 00:53:13.760
We're just going to look at what other movies Keanu likes that you haven't seen.

00:53:13.760 --> 00:53:18.180
And we'll just recommend them to you because you probably will like them also.

00:53:18.180 --> 00:53:18.880
Yeah, that's cool.

00:53:19.400 --> 00:53:21.260
That's a pretty simple recommendation engine.

00:53:21.260 --> 00:53:29.560
But I recall a few years ago that Netflix had, like, a challenge to the community to build the best recommendation engine.

00:53:29.560 --> 00:53:32.500
And they had, like, a million dollar prize or something big like that, right?

00:53:32.500 --> 00:53:33.340
Do you remember?

00:53:33.340 --> 00:53:34.220
Did you hear about this?

00:53:34.220 --> 00:53:35.240
Yeah, I did.

00:53:35.240 --> 00:53:39.560
And I think they used to use K-nearest neighbors.

00:53:39.560 --> 00:53:41.280
I'm not 100% sure.

00:53:41.280 --> 00:53:45.320
But I think they used K-nearest neighbors before that price came out.

00:53:45.320 --> 00:53:49.160
So, that's how, you know, it worked for them for so long.

00:53:49.820 --> 00:53:54.600
And I think the current version uses a modified version of K-nearest neighbors.

00:53:54.600 --> 00:53:58.820
Yeah, I don't see how you get around something like this being at least part of the solution, right?

00:53:58.820 --> 00:53:59.340
Yeah.

00:53:59.340 --> 00:53:59.780
Awesome.

00:54:00.100 --> 00:54:03.120
I think that's quite a good introduction to algorithms.

00:54:03.540 --> 00:54:16.080
You know, if you're out there listening and you didn't have a formal computer science education or, like me, you kind of paid attention and you forgot and these ideas were living in the edge of your memory, but you wouldn't mind a reminder.

00:54:16.220 --> 00:54:21.140
I think this is a really interesting way to learn it with this nice illustrations and simple stories.

00:54:21.780 --> 00:54:22.800
I really appreciate your book.

00:54:22.800 --> 00:54:24.820
I think we're probably out of time, so I have to leave it there.

00:54:24.820 --> 00:54:28.080
Let me ask you a couple of questions before I let you go, though.

00:54:28.080 --> 00:54:29.060
I always ask my guests.

00:54:29.060 --> 00:54:29.700
Sure.

00:54:29.700 --> 00:54:34.700
Yeah, there's now over 90,000 PyPI packages out there, distinct packages.

00:54:34.700 --> 00:54:38.620
I'm sure you've come across some that you found interesting that maybe not everybody knows of.

00:54:38.620 --> 00:54:41.120
Anything come to mind you want to recommend?

00:54:41.300 --> 00:54:41.920
Oh, my gosh.

00:54:41.920 --> 00:54:47.020
I'm sure everyone knows about the one I'm going to recommend, but it's called NumPy.

00:54:47.020 --> 00:54:47.460
Oh, yeah.

00:54:47.460 --> 00:54:55.400
And it's, you know, I'm starting to get more into machine learning and it's so useful.

00:54:55.400 --> 00:55:07.160
Yeah, I think the whole things like NumPy and SciPy and the whole data science story has really opened up a whole new avenue for Python to grow, right?

00:55:07.160 --> 00:55:08.860
It's not just a web development technology.

00:55:09.120 --> 00:55:12.980
It's also so much for science and it's amazing what people are doing with it.

00:55:12.980 --> 00:55:17.540
Editor, if you're going to write some Python code, what editor do you use?

00:55:17.540 --> 00:55:18.960
I have to go with Vim.

00:55:18.960 --> 00:55:20.660
All right, Vim, right on.

00:55:20.660 --> 00:55:23.460
Okay, so any final call to action?

00:55:23.460 --> 00:55:24.720
How do people find your book?

00:55:24.720 --> 00:55:25.360
Things like that.

00:55:25.360 --> 00:55:31.900
So if they just go to my website, it's audit.io, A-D-I-T dot I-O.

00:55:31.900 --> 00:55:36.420
There's a link to my book and there's blog posts there.

00:55:36.420 --> 00:55:42.060
Oh, you said that people can get the pictures and use them like for their classes if they're a teacher or something.

00:55:42.060 --> 00:55:45.740
Yes, that's something not a lot of people know.

00:55:45.940 --> 00:55:52.280
But all the images from the book are available for free online and high res.

00:55:52.280 --> 00:56:02.860
So if you're a teacher and you want more images related to algorithms, there's like 400 images from this book and they're all on my GitHub.

00:56:03.720 --> 00:56:07.580
So it's github.com/Egon Schiele.

00:56:07.580 --> 00:56:11.260
And maybe you can add a link so I don't have to spell that out.

00:56:11.260 --> 00:56:12.420
Yeah, I'll definitely link to that.

00:56:12.420 --> 00:56:12.800
No problem.

00:56:12.800 --> 00:56:13.540
That'll be in the show notes.

00:56:13.540 --> 00:56:14.420
All right.

00:56:14.420 --> 00:56:19.220
Well, it's been great to talk to you and I definitely recommend your book to people.

00:56:19.220 --> 00:56:21.020
I think it's very approachable.

00:56:21.020 --> 00:56:24.000
So if this kind of thing is interesting to you, check it out.

00:56:24.000 --> 00:56:24.940
Thank you so much.

00:56:24.940 --> 00:56:25.500
You're welcome.

00:56:25.500 --> 00:56:26.260
Thanks for being on the show.

00:56:26.260 --> 00:56:26.880
Talk to you later.

00:56:26.880 --> 00:56:27.400
Take care.

00:56:27.400 --> 00:56:31.540
This has been another episode of Talk Python to Me.

00:56:31.540 --> 00:56:34.300
Today's guest has been Adit Bhargava.

00:56:34.300 --> 00:56:37.600
And this episode has been sponsored by Capital One and Intel.

00:56:37.600 --> 00:56:39.500
Thank you both for supporting the show.

00:56:39.500 --> 00:56:43.000
Are you a data scientist or Python developer who loves data?

00:56:43.000 --> 00:56:48.640
If you're looking for a place to work on data science with truly big data that can affect millions of lives,

00:56:48.640 --> 00:56:57.060
then head on over to jobs.capitalone.com slash talkpython and check out the wide range of jobs that Capital One is trying to fill right now.

00:56:57.060 --> 00:57:03.600
The Intel distribution for Python delivers the high performance Intel C libraries built right into Python.

00:57:03.600 --> 00:57:09.620
Get close to 100 times better performance for certain functions when using NumPy, SciPy, and scikit-learn.

00:57:09.620 --> 00:57:12.900
Check them out at talkpython.fm/intel.

00:57:12.900 --> 00:57:15.820
Are you or a colleague trying to learn Python?

00:57:15.820 --> 00:57:20.460
Have you tried books and videos that just left you bored by covering topics point by point?

00:57:20.520 --> 00:57:29.080
Well, check out my online course Python Jumpstart by building 10 apps at talkpython.fm/course to experience a more engaging way to learn Python.

00:57:29.080 --> 00:57:36.400
And if you're looking for something a little more advanced, try my Write Pythonic Code course at talkpython.fm/pythonic.

00:57:37.020 --> 00:57:43.000
You can find the links from this episode at talkpython.fm/episodes slash show slash 82.

00:57:43.000 --> 00:57:45.180
Be sure to subscribe to the show.

00:57:45.180 --> 00:57:47.380
Open your favorite podcatcher and search for Python.

00:57:47.380 --> 00:57:48.620
We should be right at the top.

00:57:48.620 --> 00:57:54.020
You can also find the iTunes feed at /itunes, Google Play feed at /play,

00:57:54.020 --> 00:57:57.940
and direct RSS feed at /rss on talkpython.fm.

00:57:58.300 --> 00:58:03.020
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:58:03.020 --> 00:58:09.720
Corey just recently started selling his tracks on iTunes, so I recommend you check it out at talkpython.fm/music.

00:58:09.720 --> 00:58:15.060
You can browse his tracks he has for sale on iTunes and listen to the full-length version of the theme song.

00:58:15.060 --> 00:58:17.140
This is your host, Michael Kennedy.

00:58:17.140 --> 00:58:18.420
Thanks so much for listening.

00:58:18.420 --> 00:58:19.620
I really appreciate it.

00:58:19.620 --> 00:58:21.760
Smix, let's get out of here.

00:58:22.960 --> 00:58:26.040
Stating with my voice, there's no norm that I can feel within.

00:58:26.040 --> 00:58:28.860
Haven't been sleeping, I've been using lots of rest.

00:58:28.860 --> 00:58:31.740
I'll pass the mic back to who rocked it best.

00:58:31.740 --> 00:58:44.060
I'll pass the mic back to who rocked it best.

00:58:44.060 --> 00:59:14.040
Thank you.

