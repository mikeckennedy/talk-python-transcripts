WEBVTT

00:00:00.001 --> 00:00:04.940
What does it take to track detailed analytics and errors from literally thousands of web

00:00:04.940 --> 00:00:10.200
applications at once? Could you build such a system entirely in Python? Answer is yes.

00:00:10.200 --> 00:00:15.160
And we'll hear from Ron Cohen from Opbeat about how they do it for Django, Flask,

00:00:15.160 --> 00:00:21.000
and even Node.js apps. This is episode 43, recorded January 13th, 2016.

00:00:21.000 --> 00:00:50.300
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the

00:00:50.300 --> 00:00:54.920
ecosystem, and the personalities. This is your host, Michael Kennedy. Follow me on Twitter,

00:00:54.920 --> 00:00:59.820
where I'm @mkennedy. Keep up with the show and listen to past episodes at talkpython.fm,

00:00:59.820 --> 00:01:06.560
and follow the show on Twitter via at Talk Python. This episode is brought to you by Hired and SnapCI.

00:01:06.560 --> 00:01:12.320
Thank them for supporting the show on Twitter via at Hired underscore HQ and at SnapCI.

00:01:12.320 --> 00:01:18.000
Hey, everyone. Do you remember that t-shirt Kickstarter I did last summer to create a cool

00:01:18.000 --> 00:01:22.940
Talk Python To Me podcast t-shirt? It was super successful reaching its funding goal within

00:01:22.940 --> 00:01:28.700
just two hours. Well, the shirt is back. I've worked with our friends at pythongear.com to make

00:01:28.700 --> 00:01:36.480
the shirt available on demand for just $25. Visit talkpython.fm/shirt and get yourself one

00:01:36.480 --> 00:01:41.540
while they're hot. The proceeds support the show and the shirt helps spread the word about the podcast.

00:01:42.040 --> 00:01:47.100
Now let's get right to the conversation with Ron Cohen, the CTO and co-founder at OpBeat.

00:01:47.100 --> 00:01:49.100
Ron, welcome to the show.

00:01:49.100 --> 00:01:50.800
Thank you. Thank you so much, Michael.

00:01:51.200 --> 00:01:55.400
You're welcome. I'm a big fan of OpBeat, and I know you guys do a ton of stuff with Python.

00:01:55.400 --> 00:01:59.400
So it's going to be a really interesting conversation. And before we get into all that,

00:01:59.400 --> 00:02:03.060
though, as usual, how did you get started in programming in Python?

00:02:03.060 --> 00:02:09.860
I got started programming initially because one of my friends borrowed some books at the library.

00:02:09.860 --> 00:02:14.660
This is many, many years ago. And it was about the programming language,

00:02:14.820 --> 00:02:20.280
basic, as I'm sure a lot of people got started with basic. I immediately found it very intriguing to be

00:02:20.280 --> 00:02:25.740
able to tell a computer what to do and sort of interact with it. And my friend quickly lost interest,

00:02:25.740 --> 00:02:31.260
but I sort of kept going. And my dad was actually also programming and working as a programmer.

00:02:31.260 --> 00:02:38.280
So a lot of people think I got into programming because of him, but it turns out it actually was

00:02:38.280 --> 00:02:46.640
in spite of him also programming. And Python, the way I got started with Python was another buddy of mine

00:02:46.640 --> 00:02:51.080
who really thought I should take a look at this Django thing, this thing called Django.

00:02:51.080 --> 00:02:56.040
Because at the time I was working as a consultant doing web applications,

00:02:56.040 --> 00:03:03.680
and I had done web applications in Rails and PHP and all sorts of different languages and framework.

00:03:04.120 --> 00:03:08.100
But he really insisted that I try out Django. And then I had to learn Python to actually

00:03:08.100 --> 00:03:12.320
to work with Django. And I've pretty much stuck with it ever since.

00:03:12.320 --> 00:03:15.680
Oh, that's excellent. When was that? What time? What year?

00:03:15.680 --> 00:03:19.780
Oh, good question. I think it's like three or four years ago.

00:03:19.780 --> 00:03:25.160
Yeah, Django is excellent. Python is just such a fun programming language to work with.

00:03:25.160 --> 00:03:27.180
It's such a fun ecosystem. It's hard to not love it.

00:03:27.180 --> 00:03:33.020
Yeah, it really is. And so the thing I like about it is that it's so explicit.

00:03:33.020 --> 00:03:33.920
There's no surprises.

00:03:33.920 --> 00:03:37.980
Yeah, there's very few gotchas. You often hear about JavaScript gotchas

00:03:37.980 --> 00:03:41.300
and all the things you've got to be careful of. You don't typically hear about the Python gotchas.

00:03:41.300 --> 00:03:42.220
I love that.

00:03:42.220 --> 00:03:45.240
Yeah, JavaScript is interesting.

00:03:45.240 --> 00:03:48.240
Yes, it is. I'll ask you more about that later, actually.

00:03:48.240 --> 00:03:51.600
You like Python so much, you started a company called Opby, right?

00:03:51.600 --> 00:03:54.840
Yeah, yeah, exactly. So I helped start Opby with a friend.

00:03:54.840 --> 00:03:57.380
In the beginning, it was just me and him. He's called Rasmus.

00:03:57.380 --> 00:04:03.240
And we had been working as consultants building web applications for a while together.

00:04:03.240 --> 00:04:09.560
And every time we sort of built something, we found that we were also the people that ended up running it.

00:04:09.560 --> 00:04:11.780
So maintaining it and making sure that it actually worked.

00:04:12.020 --> 00:04:18.800
What we found there is that all the tools were sort of targeted people who were technical ops people.

00:04:18.800 --> 00:04:20.720
So ops people, basically.

00:04:20.720 --> 00:04:24.360
Developers just really think in a different way than ops people do.

00:04:24.360 --> 00:04:28.540
And they also need to know about different data.

00:04:29.700 --> 00:04:38.500
So we thought we'd build a product that helps developers operate their applications that they build that was targeted to developers directly.

00:04:38.500 --> 00:04:41.160
And that's how we sort of got started with Opby.

00:04:41.160 --> 00:04:42.920
At the time, I was really into Python.

00:04:42.920 --> 00:04:45.520
So, and I mean, I still am, obviously.

00:04:45.520 --> 00:04:49.080
So we started building in Django and Python.

00:04:49.080 --> 00:04:51.160
And today, it's pretty much all Python.

00:04:51.360 --> 00:04:52.040
That's awesome.

00:04:52.040 --> 00:04:59.020
So in sort of the whole back end of what you guys have going there, not just what plugs into the app, it's all Python, huh?

00:04:59.020 --> 00:05:00.340
Mostly Python, let's say.

00:05:00.340 --> 00:05:01.080
Yes.

00:05:01.080 --> 00:05:06.220
We started now doing, we started working on support for Node.

00:05:06.220 --> 00:05:11.120
So Node.js, because that's also a big opportunity for us.

00:05:11.120 --> 00:05:13.760
That's going to be really interesting to see how that goes.

00:05:13.760 --> 00:05:14.260
Yeah.

00:05:14.260 --> 00:05:18.660
I just saw today that you guys have a beta program that people can go sign up for.

00:05:18.660 --> 00:05:19.460
So that's cool.

00:05:19.460 --> 00:05:22.640
So let's talk about monitoring apps in general.

00:05:22.640 --> 00:05:28.760
You said there's sort of the infrastructure side of folks, and they have one set of things they want to know about.

00:05:28.760 --> 00:05:30.260
We've got the developers.

00:05:30.260 --> 00:05:39.480
And then also we've got this, you know, this growing sort of DevOps continuous delivery set of people that maybe have kind of a mix of those things.

00:05:39.480 --> 00:05:41.460
But what do people want to know about in their apps?

00:05:41.460 --> 00:05:46.000
Like what kinds of things can be tracked in applications like Opby, things like that?

00:05:46.000 --> 00:05:46.940
How does that all work?

00:05:46.940 --> 00:05:47.500
Right.

00:05:48.020 --> 00:05:49.500
So you're absolutely right.

00:05:49.500 --> 00:05:57.300
There are different sort of disciplines within this DevOps ideology or terminology or whatever you want to call it.

00:05:57.500 --> 00:06:09.400
So if we start with monitoring, that's really sort of focused on delivering actionable metrics for developers.

00:06:09.400 --> 00:06:14.060
And for us, that means that all the data that we give you, it has to sort of relate to your application.

00:06:14.820 --> 00:06:18.380
So it has to be something that you can use to improve the performance of your application.

00:06:18.380 --> 00:06:27.140
That means we don't deal with sort of the machines that your application runs on very much more sort of the code that you've written.

00:06:27.140 --> 00:06:35.520
And that's something we hear is really attractive to developers because that's sort of also their angle of attack, if you will.

00:06:36.260 --> 00:06:40.600
Basically, it all depends on the code and deals with the code.

00:06:40.600 --> 00:06:46.080
And things like response times for an application, that's, of course, really interesting.

00:06:46.740 --> 00:06:54.660
And then also sort of delivering it to developers in a way that they are used to think about stuff.

00:06:54.660 --> 00:07:06.020
So some tools deal with something called aptics, which isn't really a metric that people are very used to working with.

00:07:06.020 --> 00:07:12.620
It's probably something that ops people are more used to, or even just business people who need to deliver some kind of SLA.

00:07:12.620 --> 00:07:17.360
Developers are more familiar with averages and percentiles.

00:07:17.360 --> 00:07:22.760
So that's, for example, a choice we've picked instead of aptics.

00:07:22.760 --> 00:07:23.880
Then there's error logging.

00:07:23.880 --> 00:07:28.220
So there's a lot of ways that you can be logging errors.

00:07:28.220 --> 00:07:30.920
The most basic thing is write them to a file.

00:07:31.920 --> 00:07:36.840
A lot of people do that, and then they ship those lines in the file off to some service.

00:07:36.840 --> 00:07:42.200
And then they search through the lines of the files to see what kind of errors they had.

00:07:42.200 --> 00:07:47.580
And that's also, I feel like, something that caters to ops people more than developers.

00:07:47.580 --> 00:07:50.920
Developers are used to dealing with code.

00:07:50.920 --> 00:07:55.240
So when an error happens, they would really like to see a proper stack trace.

00:07:55.240 --> 00:08:00.640
They'd really like to get an email or get notified on a mobile phone that something is now broken.

00:08:01.320 --> 00:08:04.920
They don't want to just tail some log and sit there and watch it go by.

00:08:04.920 --> 00:08:08.760
They want detailed stuff that they can go back and actually track down the bug with.

00:08:08.760 --> 00:08:11.560
Not just knowing there's a problem, but all the details, right?

00:08:11.560 --> 00:08:14.740
Which maybe don't necessarily fit on a line in a log file.

00:08:14.740 --> 00:08:16.380
Exactly, exactly.

00:08:16.380 --> 00:08:23.920
And when you have the details sort of in a structured way, there's a lot of stuff you can do to make it more useful, more actionable.

00:08:23.920 --> 00:08:24.700
Yeah.

00:08:24.700 --> 00:08:25.580
Yeah.

00:08:25.680 --> 00:08:28.480
I guess you could say, like, what are the most common exception types?

00:08:28.480 --> 00:08:30.760
How many exceptions do we have per hour?

00:08:30.760 --> 00:08:31.760
Right?

00:08:31.760 --> 00:08:31.940
Yeah.

00:08:31.940 --> 00:08:34.500
Whose check-in has caused the most exception?

00:08:34.500 --> 00:08:35.700
Yeah.

00:08:35.700 --> 00:08:36.720
And we actually do that.

00:08:36.720 --> 00:08:39.360
Or we do something called automatic assignments.

00:08:39.360 --> 00:08:44.940
So, based on who checked in the code, we'll automatically assign that error to the person who checked in the code.

00:08:44.940 --> 00:08:46.180
That's awesome.

00:08:46.180 --> 00:08:47.340
Thanks.

00:08:47.340 --> 00:08:50.860
That's something you can only do if you have the data in a structured way.

00:08:50.860 --> 00:08:51.440
Yeah.

00:08:51.440 --> 00:08:52.860
Just one example.

00:08:53.820 --> 00:08:54.120
Yeah, yeah.

00:08:54.120 --> 00:08:58.100
I love the blame feature of source control.

00:08:58.100 --> 00:08:59.880
You can say, all right, this looks ridiculous.

00:08:59.880 --> 00:09:00.640
Who wrote this?

00:09:00.640 --> 00:09:03.380
And that's kind of the error equivalent of blame, right?

00:09:03.380 --> 00:09:04.580
Yeah.

00:09:04.580 --> 00:09:08.440
And it's, you know, it's not a good way to think about it, blame.

00:09:08.440 --> 00:09:17.100
But it's also not very effective for you to sit and work on something that someone else on your team knows much more about.

00:09:17.620 --> 00:09:21.080
Yeah, well, there's the negative way of looking at, like, blame, right?

00:09:21.080 --> 00:09:22.060
Whose fault is this?

00:09:22.060 --> 00:09:34.860
But then there's also the sort of the positive perspective of, like, whoever wrote that code and probably just checked it in, they're more likely to be able to quickly fix it, quickly go, oh, geez, yes, I understand.

00:09:34.860 --> 00:09:36.280
Let me do this, da-da-da-da-da, right?

00:09:36.280 --> 00:09:39.740
If you just give it to somebody out of the blue, go, here's a random problem with some app.

00:09:39.740 --> 00:09:41.520
You probably didn't write it, but fix it, right?

00:09:41.520 --> 00:09:43.300
That's much harder to get it fixed quickly.

00:09:43.300 --> 00:09:44.040
Yeah, absolutely.

00:09:44.040 --> 00:09:44.460
Absolutely.

00:09:44.460 --> 00:09:47.040
It's also about accountability in some sense.

00:09:47.260 --> 00:09:48.360
We can talk about it a little bit later.

00:09:48.360 --> 00:09:53.340
But in my experience, good developers, they like to be held accountable.

00:09:53.340 --> 00:09:55.800
So they like to know when they actually made a mistake.

00:09:55.800 --> 00:10:02.480
And this is sort of a way to complete the circle, if you will, after you write something.

00:10:02.480 --> 00:10:07.620
You will also be assigned to the errors that your code caused.

00:10:07.620 --> 00:10:13.820
Yeah, I think, especially when you're learning the program, when you're a fairly junior developer,

00:10:14.620 --> 00:10:23.160
the whole error handling, dealing with malformed data, unexpected things, and so on, that's much harder to get your head around.

00:10:23.160 --> 00:10:29.440
It's much easier, I think, to write the code so it's supposed to take this and it's supposed to do these things and it's done, right?

00:10:29.440 --> 00:10:31.840
Just like the happy path, if you will.

00:10:32.200 --> 00:10:36.480
But knowing to be aware of all these other errors, right?

00:10:36.480 --> 00:10:38.740
That's something that takes more experience, I think.

00:10:38.740 --> 00:10:43.140
And so if you can help catch those sooner and maybe learn those lessons sooner, that's also good.

00:10:43.140 --> 00:10:44.520
Yeah, absolutely.

00:10:44.520 --> 00:10:45.840
Nice.

00:10:45.920 --> 00:10:49.460
So you talked a little bit about performance and you talked about errors.

00:10:49.460 --> 00:10:52.040
You guys also talk about, like, deployment and workflow.

00:10:52.040 --> 00:10:52.900
What's the story of that?

00:10:52.900 --> 00:10:53.440
Right.

00:10:53.440 --> 00:11:06.780
Again, coming back to the DevOps paradigm, if you will, what we found is that developers now are more and more empowered to deploy their own code whenever they feel like it's finished.

00:11:06.780 --> 00:11:15.760
And whenever the CI tests pass, it's usually the case nowadays that developers actually have the power to deploy their code.

00:11:15.760 --> 00:11:17.340
Now, that's really cool.

00:11:17.340 --> 00:11:21.680
But it also means that it can get pretty difficult to figure out what was actually deployed at what time.

00:11:21.680 --> 00:11:31.680
Because you probably used to have an ops department that would make a little note in a changelog somewhere to sort of keep track of what was deployed.

00:11:31.680 --> 00:11:33.700
But developers don't really do that.

00:11:33.700 --> 00:11:40.700
So we help them do that by what we call release tracking, which is basically a list of releases.

00:11:40.700 --> 00:11:45.540
And each item in the list will contain the commits that went into a specific release.

00:11:45.540 --> 00:11:49.100
That makes it really easy for you to go back and see exactly what you deployed at what time.

00:11:49.100 --> 00:11:50.440
Yeah.

00:11:50.440 --> 00:11:55.620
So maybe you can link those back to a series of GitHub issues that have been closed or something like that, right?

00:11:55.620 --> 00:11:57.320
Yeah, exactly.

00:11:57.320 --> 00:12:01.140
Or errors that started happening after a specific release, etc.

00:12:01.140 --> 00:12:11.840
Yeah, it's another sort of case where the tools and the sort of workflows that you used to have don't really fit anymore.

00:12:11.840 --> 00:12:14.000
And that's why we did this release tracking.

00:12:14.500 --> 00:12:15.420
Yeah, that's really cool.

00:12:15.420 --> 00:12:25.900
I mean, it definitely ties together with continuous integration and continuous delivery and services that companies like SnapCI and those guys build, right?

00:12:25.900 --> 00:12:28.020
To sort of do the checking before it goes out.

00:12:28.020 --> 00:12:30.680
But you guys are kind of on the other end, right?

00:12:30.680 --> 00:12:37.080
Once it hits production, if something happens, you can sort of say, after this release, these errors started happening.

00:12:37.080 --> 00:12:37.480
Is that right?

00:12:38.280 --> 00:12:39.060
Yeah, yeah, exactly.

00:12:39.060 --> 00:12:45.480
And CI is obviously still a really important part of the modern workflow.

00:12:45.480 --> 00:12:49.020
And yeah, it's definitely not a replacement.

00:12:49.020 --> 00:12:50.220
Yeah, absolutely.

00:12:50.220 --> 00:12:57.640
But, you know, the thing is, there's the unit test you write and the scenarios you test for and look for.

00:12:57.640 --> 00:13:00.340
And then there's the real world, right?

00:13:00.340 --> 00:13:01.180
Yeah, absolutely.

00:13:01.180 --> 00:13:13.100
You know, no matter how good your CI system is or your tests are, chances are on some major application, there's something happening that's going to happen that you just didn't account for.

00:13:13.100 --> 00:13:17.700
Like, why are there browsers on my page that have no user agent?

00:13:17.700 --> 00:13:18.900
I didn't plan for this, right?

00:13:18.900 --> 00:13:20.340
You know, just weird stuff like that, right?

00:13:20.340 --> 00:13:33.000
This episode is brought to you by Hired.

00:13:33.000 --> 00:13:38.600
Hired is a two-sided, curated marketplace that connects the world's knowledge workers to the best opportunities.

00:13:38.600 --> 00:13:46.080
Each offer you receive has salary and equity presented right up front, and you can view the offers to accept or reject them before you even talk to the company.

00:13:46.900 --> 00:13:51.820
Typically, candidates receive five or more offers within the first week, and there are no obligations, ever.

00:13:51.820 --> 00:13:53.380
Sounds awesome, doesn't it?

00:13:53.380 --> 00:13:55.040
Well, did I mention the signing bonus?

00:13:55.040 --> 00:13:58.440
Everyone who accepts a job from Hired gets a $1,000 signing bonus.

00:13:58.440 --> 00:14:01.240
And as Talk Python listeners, it gets way sweeter.

00:14:01.240 --> 00:14:06.940
Use the link Hired.com slash Talk Python To Me, and Hired will double the signing bonus to $2,000.

00:14:06.940 --> 00:14:09.080
Opportunity's knocking.

00:14:09.080 --> 00:14:12.520
Visit Hired.com slash Talk Python To Me and answer the call.

00:14:12.520 --> 00:14:19.820
Yeah, absolutely.

00:14:19.820 --> 00:14:29.720
And it turns out that users are really creative in what they will enter into a form, and you basically have no chance to guess what all the different scenarios are going to be.

00:14:29.720 --> 00:14:30.820
Yeah, yeah, absolutely.

00:14:31.420 --> 00:14:34.400
So right now you guys support Django, and that's where you started.

00:14:34.400 --> 00:14:41.420
And recently you added Flask support, and you also are about to add node support, or you're beta testing it.

00:14:41.420 --> 00:14:42.960
What about other apps?

00:14:42.960 --> 00:14:47.120
Like a lot of the apps that I work on, the web apps, are pyramid apps.

00:14:47.120 --> 00:14:51.660
Is there a way to add tracking to apps that are not one of those three?

00:14:52.220 --> 00:14:53.100
Yes, there is, actually.

00:14:53.100 --> 00:15:07.080
And we've not been very good at documenting this, but the Upbeat module has a very simple API, and it comes down to calling begin transaction whenever you sort of start a new request or a background job starts.

00:15:07.080 --> 00:15:15.060
And then you call end transaction whenever you've sent back the response or your background task has finished.

00:15:15.740 --> 00:15:20.020
And the Upbeat module will automatically pick up all the information it needs in between those.

00:15:20.020 --> 00:15:23.340
That's performance metrics, performance monitoring.

00:15:23.340 --> 00:15:31.940
And error logging, usually there's a way to look into the framework's sort of unhandled exception signal or something like that.

00:15:31.940 --> 00:15:34.620
So it should definitely be doable.

00:15:34.620 --> 00:15:37.800
We just haven't really had the time to look at it yet.

00:15:37.800 --> 00:15:39.300
Okay, that's interesting.

00:15:39.300 --> 00:15:50.300
So if I was able to sort of trigger like a bit, like do a begin transaction and an end transaction, all the calls I'm making, say, to SQLAlchemy or out to other web services, those would get tracked?

00:15:50.300 --> 00:15:56.560
Actually, what you need to do is just call begin transaction whenever your request starts.

00:15:56.560 --> 00:16:00.720
And we already instrument most of the modules you use, I hope.

00:16:01.660 --> 00:16:03.920
So that data should automatically show up, actually.

00:16:03.920 --> 00:16:11.500
What you need, yeah, the only thing you need to do is call begin transaction when the request starts and then end transaction when the request ends, the web request, let's say.

00:16:11.500 --> 00:16:12.380
Oh, sweet.

00:16:12.380 --> 00:16:14.300
Well, I may have to go play with this after.

00:16:14.300 --> 00:16:14.820
Cool.

00:16:14.820 --> 00:16:16.020
Let me know how it goes.

00:16:16.020 --> 00:16:17.100
Yeah, very cool.

00:16:17.100 --> 00:16:22.740
So what's the craziest sort of monitoring example you've seen?

00:16:22.740 --> 00:16:31.080
Like there's got to be some company or some piece of software that's just done something way crazier than you've expected.

00:16:32.020 --> 00:16:33.140
That's a really good question.

00:16:33.140 --> 00:16:39.800
Well, I can tell you the first time your main database server just drops off the face of the net.

00:16:39.800 --> 00:16:43.920
It's a very unpleasant experience.

00:16:43.920 --> 00:16:46.580
But that was a bit of a rough night.

00:16:46.580 --> 00:16:52.020
We had to fail over to the replica database and the site was down while we did it.

00:16:52.020 --> 00:16:54.060
So we did it pretty quickly.

00:16:54.060 --> 00:16:58.180
I would say it was like 15 minutes, but it was still not a very nice experience.

00:16:59.260 --> 00:17:00.020
Yeah, I guess so.

00:17:00.020 --> 00:17:06.660
Because, I mean, you guys are running real-time data collection from many potentially popular apps.

00:17:06.660 --> 00:17:11.200
And so you're sort of, you guys must have a lot of load, a lot of requests, huh?

00:17:11.200 --> 00:17:12.380
Yeah, yeah.

00:17:12.380 --> 00:17:15.100
We have quite a lot of load, quite a lot of requests.

00:17:15.100 --> 00:17:20.760
If we're down, then people will get us a little notification in their log whenever they try to send something to us.

00:17:20.760 --> 00:17:23.760
And that's really not cool, right?

00:17:23.840 --> 00:17:26.600
You want your monitoring service to be up all the time.

00:17:26.600 --> 00:17:28.280
Otherwise, it's sort of useless.

00:17:28.280 --> 00:17:33.060
So we spent a lot of time trying to make sure that we can't go down.

00:17:33.060 --> 00:17:41.100
And so what we recently did was we changed it so that we should still be able to receive data, even if the main database server is down.

00:17:41.100 --> 00:17:44.280
So that data is just going to keep being accepted by us.

00:17:44.280 --> 00:17:48.360
And then whenever the server is back up, it'll start processing the data.

00:17:48.360 --> 00:17:51.340
What infrastructure are you guys running on?

00:17:51.340 --> 00:17:54.000
Is it like Amazon Web Services or something else?

00:17:54.000 --> 00:17:54.200
Yeah.

00:17:54.200 --> 00:17:56.060
Yeah, so it's all Amazon Web Services.

00:17:56.060 --> 00:17:58.320
We've set it up ourselves.

00:17:58.320 --> 00:17:59.680
So it runs on EC2.

00:18:00.320 --> 00:18:04.320
We don't use too many of the sort of Amazon services on top of it.

00:18:04.320 --> 00:18:07.540
We use a bit of S3, but mostly EC2.

00:18:07.540 --> 00:18:09.800
Yeah, EC2, S3.

00:18:09.800 --> 00:18:10.860
Those are the main ones, right?

00:18:10.860 --> 00:18:11.940
Yeah, exactly.

00:18:11.940 --> 00:18:18.780
You talked about performance and collecting data, even if it can't necessarily be processed.

00:18:18.780 --> 00:18:26.160
And one of the really nice ways to do that is to add some sort of queue, asynchronous queuing mechanism to the whole process, right?

00:18:26.160 --> 00:18:27.180
Yeah, exactly.

00:18:27.180 --> 00:18:28.860
And we do that a lot.

00:18:29.160 --> 00:18:32.820
So whenever some data comes in, it immediately gets put into a queue.

00:18:32.820 --> 00:18:36.680
We use RabbitMQ, which is a very, very powerful software.

00:18:36.680 --> 00:18:42.340
That gives us a lot of freedom in scaling out, handling failures, et cetera.

00:18:42.340 --> 00:18:51.980
Right, because it's much easier to keep a queue alive than maybe a complex database where the schema could change and it can no longer insert into it or something like this, right?

00:18:51.980 --> 00:18:53.100
Yeah, exactly.

00:18:54.060 --> 00:18:57.720
Maybe talk me through what pieces are involved.

00:18:57.720 --> 00:19:07.340
What does it look like from some web app external to you guys sending some piece of data until it actually gets totally stored in some database?

00:19:07.340 --> 00:19:08.060
Right.

00:19:08.280 --> 00:19:14.640
So we have a separate service called the intake, which is responsible for basically accepting data and put it into a queue.

00:19:15.000 --> 00:19:22.240
It's also what does authentication and authorization of the data.

00:19:22.240 --> 00:19:26.580
So whenever data comes in, we need to make sure that it has the right tokens, et cetera.

00:19:26.580 --> 00:19:29.760
We also rate limit you there.

00:19:29.940 --> 00:19:34.540
So if you send us a lot of data, we will rate limit you right there.

00:19:34.540 --> 00:19:39.740
We need to validate that the structure of the data is actually correct.

00:19:39.740 --> 00:19:41.500
So we also do that.

00:19:41.500 --> 00:19:42.580
And then we put it into a queue.

00:19:43.220 --> 00:19:50.600
So that service is very sort of simple in the sense that it just needs to accept the data and put it into a queue.

00:19:50.600 --> 00:19:56.180
And that makes it easier for us to scale up when we have a lot of data coming in.

00:19:56.180 --> 00:19:58.220
Yeah, but it's almost stateless, right?

00:19:58.220 --> 00:20:02.300
Other than knowing the authorization part, it's like entirely stateless, right?

00:20:02.860 --> 00:20:04.040
Yeah, exactly, exactly.

00:20:04.040 --> 00:20:09.660
So a lot of the, you know, we can cache the authentication stuff really heavily.

00:20:09.660 --> 00:20:17.960
And it's also a very resilient interface of failures because it's read-only from the database, like the authentication stuff.

00:20:17.960 --> 00:20:21.260
It just needs to be able to put data into a queue.

00:20:21.260 --> 00:20:22.360
Yeah, excellent.

00:20:22.360 --> 00:20:25.980
So then there's something else that gets the data back out and really does the processing, right?

00:20:25.980 --> 00:20:26.860
Right.

00:20:26.860 --> 00:20:29.660
So we have a separate service that pulls the data out and then processes it.

00:20:29.660 --> 00:20:36.400
And that's also very convenient for us because it means that we can scale that out very easily.

00:20:36.400 --> 00:20:39.980
We have more freedom in sort of, let's say, we need to do some maintenance.

00:20:39.980 --> 00:20:44.060
We can stop that for a short period of time and then keep going.

00:20:44.060 --> 00:20:47.520
And things will just be in the queue for waiting for us to process them.

00:20:47.520 --> 00:20:50.480
Yeah, I think queues are somewhat underused.

00:20:50.480 --> 00:20:58.800
They're so easy to use, and yet they provide so much architectural flexibility and response time flexibility and so on.

00:20:58.800 --> 00:21:07.240
And even as you say, sort of like a deployment infrastructure management perspective, like long as you don't read things offline until the queues can't take anymore, then you're kind of golden, right?

00:21:07.240 --> 00:21:08.320
Yeah, yeah.

00:21:08.320 --> 00:21:11.500
We do have some requirements for processing time.

00:21:11.500 --> 00:21:19.040
So we can't leave stuff around forever, but it does give us a lot of flexibility in switching out things while everything is running.

00:21:19.320 --> 00:21:20.000
So that's great.

00:21:20.000 --> 00:21:28.920
And I agree on the point that queues are undervalued and also probably not that well understood in the best majority of developers.

00:21:28.920 --> 00:21:31.640
There's also some, as you mentioned, architectural benefits.

00:21:31.640 --> 00:21:36.900
It sort of forces you to decouple a lot of systems, which is always a good thing.

00:21:37.440 --> 00:21:51.740
Yeah, you know, there's a lot of talk about microservices and building more smaller pieces of software and putting a queue in between those two pieces makes it real easy rather than having a monolithic thing that does all the intake, all the processing, all the reporting, and on and on and on, right?

00:21:52.360 --> 00:21:52.920
Yeah, absolutely.

00:21:52.920 --> 00:22:00.840
And there's also a pattern emerging where people use the queue as a sort of bus to talk between the services.

00:22:00.840 --> 00:22:14.520
So it basically becomes a sort of communication medium instead of, for example, using HTTP, people will put a request in the queue and then expect a response on some other queue.

00:22:14.760 --> 00:22:25.280
And that's also quite useful because it gives you some additional architectural advantages when it comes to timeouts and things like these.

00:22:25.280 --> 00:22:26.380
Yeah, that's really cool.

00:22:26.380 --> 00:22:28.580
All right, so I have a big question for you.

00:22:28.580 --> 00:22:29.220
Hit me.

00:22:29.220 --> 00:22:30.900
Python 2 or Python 3?

00:22:30.900 --> 00:22:33.440
Python 3 for the sake of progress.

00:22:33.440 --> 00:22:35.040
Oh, beautiful, beautiful.

00:22:35.040 --> 00:22:40.780
I know a lot of people are on Python 2, but any chance we can get to kind of move forward, we should take that chance, right?

00:22:40.780 --> 00:22:42.300
Yeah, I agree.

00:22:42.800 --> 00:22:49.040
It's a bit of a cost that we have to pay now, sort of upfront, but it's the right thing to do, in my opinion.

00:22:49.040 --> 00:22:50.300
Yeah, excellent.

00:22:50.300 --> 00:22:50.700
I agree.

00:22:50.700 --> 00:23:01.340
A lot of the systems that people are writing that are kind of in the realm of what you guys are doing, they're maybe choosing languages like Go and Rust.

00:23:01.340 --> 00:23:07.440
Do you know sort of what the advantages of those are, like what the disadvantages are?

00:23:07.440 --> 00:23:08.560
Have you guys considered those?

00:23:08.760 --> 00:23:14.000
Not that I'm necessarily encouraging you to do so, but I know a lot of people are thinking about that.

00:23:14.000 --> 00:23:14.400
Yeah.

00:23:14.400 --> 00:23:20.160
So I've written some Go and a little bit of Rust, and I think they're really interesting.

00:23:20.880 --> 00:23:29.460
I think what still is very clear to me is that Python helps me get things done very quickly and with very little code in a very robust way.

00:23:29.460 --> 00:23:36.240
If we start with Go, for example, I think Go is mostly interesting in the way that concurrency works in Go.

00:23:36.440 --> 00:23:43.780
I think the main reason why you would write something in Go instead of Python is the concurrency primitives that exist in Go.

00:23:43.780 --> 00:23:48.720
So Python has a really sad concurrency story, in my opinion.

00:23:48.720 --> 00:23:52.700
And usually, like if you do Django, it's not a big problem.

00:23:53.120 --> 00:24:03.880
But as soon as you have to write a service that talks to the outside world and you want to talk to many different web services at the same time or something like that, then that becomes kind of difficult in Python.

00:24:03.880 --> 00:24:06.620
And it basically comes down to the event loop, in my opinion.

00:24:06.620 --> 00:24:12.620
Go is sort of built on top of an event loop that is seamless to you when you program.

00:24:13.360 --> 00:24:31.480
Getting an event loop into Python usually involves some kind of monkey patching, for example, with g event or some really sort of strange, at least if you're coming from the Python world, some strange modifications that you must make to your application to get this kind of event loop concurrency.

00:24:31.480 --> 00:24:35.020
And then there's Rust, which I think is also super interesting.

00:24:35.020 --> 00:24:38.040
It has a much more interesting type system than Go.

00:24:38.040 --> 00:24:41.480
But at the same time, the Rust feels more like a replacement for C++.

00:24:42.480 --> 00:24:50.040
So some of the things that you will typically use Python for, it also makes sense to use Go for.

00:24:50.040 --> 00:24:52.860
But I would say Rust is in a different category.

00:24:52.860 --> 00:24:54.580
And I feel like a lot of people are comparing.

00:24:54.580 --> 00:24:59.100
So there was recently a lot of people talking about if they should use Go or Rust.

00:24:59.100 --> 00:25:02.580
But in my opinion, they are applicable to different use cases.

00:25:02.580 --> 00:25:04.460
So Rust is more low level.

00:25:04.460 --> 00:25:07.320
You have to deal with memory management yourself.

00:25:07.320 --> 00:25:08.480
And that's important.

00:25:08.900 --> 00:25:14.200
But it's sort of other sorts of applications that you write in Rust than it is Go and Python.

00:25:14.200 --> 00:25:18.940
I see it almost more as a replacement for things like, I would have done this in C.

00:25:18.940 --> 00:25:20.680
So now I'll do it in one of these languages.

00:25:20.680 --> 00:25:24.140
But that could just be my lack of experience with them, right?

00:25:24.140 --> 00:25:25.360
No, I think you're right.

00:25:25.360 --> 00:25:26.780
Especially when it comes to Rust.

00:25:26.780 --> 00:25:28.800
I think Go is somewhere in between.

00:25:28.800 --> 00:25:30.520
It's aesthetically typed.

00:25:30.520 --> 00:25:35.100
It feels a lot more high level, I would say, than C or Rust.

00:25:54.320 --> 00:26:00.120
SnapCI for sponsoring this episode by trying them for free at snap.ci.

00:26:00.120 --> 00:26:05.160
simply do a get push and they auto detect and run all the necessary tests through their multi-stage

00:26:05.160 --> 00:26:10.600
pipelines. Something fails, you can even debug it directly in the browser. With a one-click

00:26:10.600 --> 00:26:15.940
deployment that you can do from your desk or from 30,000 feet in the air, Snap offers flexibility

00:26:15.940 --> 00:26:21.860
and ease of mind. Imagine all the time you'll save. Thanks SnapCI for sponsoring this episode

00:26:21.860 --> 00:26:25.720
by trying them for free at snap.ci slash talkpython.

00:26:25.720 --> 00:26:41.120
So let's talk about shipping software a little bit more. Yes. You said you had some recommendations

00:26:41.120 --> 00:26:45.760
for sort of how to make your team a high-performance shipping machine. What's the story there?

00:26:45.760 --> 00:26:55.380
Right. My role here at Upbeat has transitioned from coding every day to more and more trying to get my

00:26:55.380 --> 00:27:01.780
team to be efficient managing, if you will. And along that path, different things sort of became

00:27:01.780 --> 00:27:08.440
clear. Yeah, there's some different things that you should be aware of, I think, when you are managing

00:27:08.440 --> 00:27:14.600
a team of developers or even if you're just a single developer building applications, especially for

00:27:14.600 --> 00:27:19.180
the web. That's sort of what we've been focusing on, building applications that live on the internet.

00:27:19.180 --> 00:27:23.840
That's really interesting. You know, I think a lot of people who are working by themselves

00:27:25.040 --> 00:27:30.620
don't necessarily adopt some of the sort of what you would think of as best practices and tooling that

00:27:30.620 --> 00:27:36.420
maybe teams would automatically adopt. Things like continuous integration, things like, you know,

00:27:36.420 --> 00:27:42.260
sometimes even source control. But, you know, things like application monitoring and so on.

00:27:42.260 --> 00:27:47.620
So you think even if there's one person working on a project, maybe you should put this stuff in place?

00:27:47.760 --> 00:27:52.480
Yeah, absolutely. Absolutely. Especially like things like CI. I think you should definitely

00:27:52.480 --> 00:27:55.340
have CI even if you're just a one person team.

00:27:55.340 --> 00:28:00.860
So if I have like my files on the hard drive and I just zip them up periodically and put a date on it,

00:28:00.860 --> 00:28:01.940
that's probably not enough?

00:28:01.940 --> 00:28:05.840
I've seen that by the way.

00:28:05.840 --> 00:28:08.080
I've seen that before.

00:28:08.340 --> 00:28:12.520
No, really, that's not. Okay. Well, let's talk about first source control.

00:28:12.520 --> 00:28:14.220
Yeah. Oh, that's horrible.

00:28:14.220 --> 00:28:16.820
It's been a few years, but still.

00:28:16.820 --> 00:28:18.060
Right.

00:28:18.060 --> 00:28:22.940
So maybe you could make it concrete. Like, what do you guys do to ship software like

00:28:22.940 --> 00:28:26.240
at Opby to sort of push out new versions and so on?

00:28:26.240 --> 00:28:26.980
Yeah. Good question.

00:28:26.980 --> 00:28:32.780
So one of the things we really focus on is getting things shipped early in the sense that

00:28:32.780 --> 00:28:38.180
whenever there's something that is an improvement to what we have today, we'll generally try to ship it.

00:28:38.180 --> 00:28:45.140
And what typically happens when you are sitting and programming and working on some feature is that

00:28:45.140 --> 00:28:50.640
you sort of got started on this feature and it's going well, but your feature relies on something else.

00:28:50.640 --> 00:28:57.100
depends on some other code and you sort of take a peek into that code and it feels really sort of,

00:28:57.100 --> 00:29:04.520
it has some of those bad code smells that we as developers are familiar with and are sort of trained to recognize.

00:29:04.520 --> 00:29:11.780
So you consider whether you should just quickly refactor that other thing that your feature is going to depend on.

00:29:11.780 --> 00:29:17.580
What usually ends up happening is that you end up actually spending time both working on your feature

00:29:17.580 --> 00:29:20.260
and refactoring that other thing that you found.

00:29:20.260 --> 00:29:26.080
And then that thing relies on some third thing and you think, oh, well, I made it.

00:29:26.080 --> 00:29:28.100
I might as well just refactor that thing too.

00:29:28.100 --> 00:29:31.260
And then it ends up being a huge release when you finally get it shipped.

00:29:31.260 --> 00:29:34.880
And that's sort of a big red flag for us.

00:29:34.880 --> 00:29:36.960
Big releases are a problem.

00:29:36.960 --> 00:29:38.700
They're a problem for multiple reasons.

00:29:38.700 --> 00:29:42.340
First of all, they are much more cumbersome to review.

00:29:42.660 --> 00:29:45.020
So everything we do gets peer reviewed.

00:29:45.020 --> 00:29:47.640
And if you have a big release, that just takes much more time.

00:29:47.640 --> 00:29:53.800
And it's much harder to get an overview over the impact of this particular release when it's huge.

00:29:53.800 --> 00:29:59.180
And it also takes much more time before your stuff actually comes out to the users.

00:29:59.180 --> 00:30:03.640
The sad thing about that is that we know as developers that, you know,

00:30:03.640 --> 00:30:10.800
you can think of a lot of scenarios on how you have some idea about how your users are going to use a specific feature.

00:30:10.800 --> 00:30:14.360
And you obviously think that the feature is really valuable to them.

00:30:14.360 --> 00:30:18.080
But it turns out that our assumptions are often wrong about this kind of stuff.

00:30:18.320 --> 00:30:25.080
So getting new features into the hands of users is really important because then you will learn how they are actually going to use it.

00:30:25.080 --> 00:30:29.680
It's really hard to predict what people will find valuable, what they won't.

00:30:29.680 --> 00:30:30.280
Yeah, exactly.

00:30:30.280 --> 00:30:32.120
Like you said, how they're going to use it.

00:30:32.120 --> 00:30:36.100
Speed is an advantage in the software business, right?

00:30:36.100 --> 00:30:36.820
Yeah.

00:30:36.820 --> 00:30:40.800
Small releases actually give you a lot of speed, in my opinion.

00:30:41.320 --> 00:30:44.420
There's also the things like when something breaks.

00:30:44.420 --> 00:30:53.120
If you have just released a huge change, it's really difficult to figure out what part of that change actually made things break.

00:30:53.120 --> 00:31:00.120
But if you're releasing small releases all the time, it's much, much easier to go back and see exactly what caused a specific problem.

00:31:00.120 --> 00:31:04.000
So we're huge proponents of small incremental releases at Upbeat.

00:31:04.000 --> 00:31:07.660
And it's something to reiterate on, sort of talk about often.

00:31:08.440 --> 00:31:21.820
The other side of that story is if everything you are releasing is a small little feature or a small piece and something goes wrong, it's pretty painless to just say, whoops, we're just going to roll it back to the way it was before.

00:31:21.820 --> 00:31:22.840
Yeah, yeah, exactly.

00:31:22.840 --> 00:31:29.700
But if you've had to do some massive database migration to like roll out a huge new thing and then you're kind of stuck, right?

00:31:29.700 --> 00:31:34.440
Not only is it speed going forward, it also enables you to go, oh, no, roll it back, roll it back.

00:31:34.440 --> 00:31:35.820
Hopefully nobody saw that.

00:31:35.820 --> 00:31:36.880
Yeah.

00:31:37.620 --> 00:31:45.180
Another thing that is really useful when you're building applications is to make sure you try to break down silos.

00:31:45.180 --> 00:31:52.580
For us, that means that getting something shipped is a sort of cross-discipline process.

00:31:52.580 --> 00:32:00.720
We have a product designer that works with a visual designer that works with a developer and finally with marketing.

00:32:00.720 --> 00:32:05.400
And that means everybody is sort of aligned on shipping this feature.

00:32:06.000 --> 00:32:17.640
Of course, there's a lot of talk about DevOps, which one of the points there is that your operations people should be aligned or should have the same goals as developers.

00:32:17.640 --> 00:32:23.700
And that makes for a much better process and a much nicer product in the end.

00:32:23.700 --> 00:32:24.700
That's really interesting.

00:32:24.700 --> 00:32:24.740
That's really interesting.

00:32:24.740 --> 00:32:30.980
So, you know, I used to, I feel like teams used to be structured horizontally, like here's the data guys.

00:32:30.980 --> 00:32:33.700
Here's the middle tier service guys.

00:32:33.700 --> 00:32:35.420
Here's the front end people, right?

00:32:35.420 --> 00:32:35.860
Yeah.

00:32:36.540 --> 00:32:38.900
That doesn't seem like a great workflow.

00:32:38.900 --> 00:32:44.900
So you're saying a vertical slice through that is a much better way to group people and features and work, right?

00:32:45.440 --> 00:32:45.940
Yeah, exactly.

00:32:45.940 --> 00:33:02.640
And even including the marketing people and designers and product designers in that slice so that you have like a wide range of capabilities on a specific team or aligned together to ship a feature.

00:33:02.640 --> 00:33:14.100
My point was that, you know, people talk about DevOps, but really we should be talking about collaboration between all the sort of different roles or disciplines that are involved in shipping a feature.

00:33:14.100 --> 00:33:20.080
So DevOps, the collaboration between ops and developers is just the very start.

00:33:20.080 --> 00:33:25.120
You should have marketing and product design, et cetera, in there as well.

00:33:25.120 --> 00:33:25.480
Yeah.

00:33:25.480 --> 00:33:29.020
So you're proposing like a DevOps mark prod team.

00:33:29.020 --> 00:33:32.240
So it's going to be a new password.

00:33:32.240 --> 00:33:34.780
But I think you're right.

00:33:34.780 --> 00:33:35.960
That makes a lot of sense.

00:33:35.960 --> 00:33:43.680
And it's really easy as software people to forget once you write the software, unless you have a very established business,

00:33:43.680 --> 00:33:45.000
or you're writing internal software.

00:33:45.000 --> 00:33:46.140
That's only part of it, right?

00:33:46.140 --> 00:33:49.680
You've got to have a marketing effort and a product development.

00:33:49.680 --> 00:33:52.980
Like you said, it's a whole team effort and software is only part of it.

00:33:52.980 --> 00:33:54.080
Yeah, exactly.

00:33:54.080 --> 00:34:02.860
Another thing that's important for us when we ship code is that the person who wrote the code is also the person who actually presses the button to get that code into production.

00:34:03.300 --> 00:34:09.980
That's something we've insisted on from the very beginning, because that means that if something breaks, that developer who wrote the code will be around to fix it.

00:34:09.980 --> 00:34:10.960
So he didn't go home.

00:34:10.960 --> 00:34:16.060
And the developer who actually presses the button knows exactly what code is going to go out.

00:34:16.060 --> 00:34:18.340
And it's basically about accountability.

00:34:18.820 --> 00:34:28.640
So you want to make sure that the developers that you're working with and that you also understand that if you've built something, so you've written some code, you're the person who ships it.

00:34:28.640 --> 00:34:30.680
And then if it breaks, you're the person who fixes it.

00:34:30.680 --> 00:34:35.000
That's something we've really sort of been adamant about from the very beginning.

00:34:35.000 --> 00:34:36.300
And it seems to work very well.

00:34:36.560 --> 00:34:37.600
Yeah, I think that's great advice.

00:34:37.600 --> 00:34:46.800
You know, there's always on teams people who embrace things like continuous integration that you just have seen more, and there's people who embrace it, let's say, less.

00:34:46.800 --> 00:34:56.680
But making everyone be actively part of the shipping puts the accountability on them, which means maybe they'll rely on the process a little more.

00:34:56.680 --> 00:34:59.440
Maybe they will run those tests before they send it out, right?

00:34:59.440 --> 00:35:00.120
Something like this.

00:35:00.120 --> 00:35:01.080
Exactly, exactly.

00:35:01.080 --> 00:35:03.980
Let me ask you a few more questions.

00:35:03.980 --> 00:35:05.800
We'll kind of get into the end of the show here.

00:35:05.800 --> 00:35:08.460
What's your favorite editor?

00:35:08.460 --> 00:35:10.340
If you're going to write some Python code, what do you open up?

00:35:10.340 --> 00:35:14.000
These days, it's actually mostly PyCharm.

00:35:14.000 --> 00:35:19.780
I found it to be really useful, and it has a lot of interesting features.

00:35:19.780 --> 00:35:22.680
It helps me find the stuff that I need very easily.

00:35:22.680 --> 00:35:29.480
It's a bit heavy, but I still feel like the JetBrains people have spent a lot of time making it fast.

00:35:29.480 --> 00:35:32.080
So I'm pretty happy with PyCharm.

00:35:32.080 --> 00:35:33.200
Yeah, that's cool.

00:35:33.200 --> 00:35:35.020
Like I've said a bunch of times on the show,

00:35:35.020 --> 00:35:36.260
that's the one I use as well.

00:35:36.260 --> 00:35:38.180
And like you said, it's a bit heavy.

00:35:38.180 --> 00:35:42.900
But if you're willing to wait five seconds, the whole next few hours are a lot nicer.

00:35:42.900 --> 00:35:46.420
So that's worth five seconds in my opinion.

00:35:46.420 --> 00:35:46.940
That's awesome.

00:35:46.940 --> 00:35:47.720
I agree.

00:35:47.960 --> 00:35:52.840
And there's thousands and thousands of packages out there that you can use in Python.

00:35:52.840 --> 00:35:56.660
What are some of the ones that maybe not everyone knows about that you're like, oh, this thing is awesome.

00:35:56.660 --> 00:35:58.080
You should know about X.

00:35:58.800 --> 00:35:59.680
Oh, good question.

00:35:59.680 --> 00:36:02.120
Of course, I'm going to have to say the upbeat module.

00:36:02.120 --> 00:36:13.440
But apart from that, some of the modules we've used that are really useful are, for example, something called dog opt, which is a way to...

00:36:13.440 --> 00:36:16.320
It basically helps you write command line applications.

00:36:16.320 --> 00:36:18.380
And it helps you parse command line arguments.

00:36:18.380 --> 00:36:21.820
And the way it works is opposite of how all the other ones work.

00:36:21.820 --> 00:36:25.940
So in here, you actually write your usage document.

00:36:26.180 --> 00:36:29.540
So the stuff that comes out when you do dash H.

00:36:29.540 --> 00:36:30.960
And then it'll parse that.

00:36:30.960 --> 00:36:34.980
And from that, it'll know how to parse the arguments to the application.

00:36:34.980 --> 00:36:37.740
So that's really useful, in my opinion.

00:36:37.740 --> 00:36:44.560
The modules that come with Python, opt-parse, and arg-parse are really not very good, in my opinion.

00:36:44.560 --> 00:36:46.620
Yeah, that's a really cool package.

00:36:46.620 --> 00:36:48.460
I've heard of that one before.

00:36:48.460 --> 00:36:56.120
And what surprised me was that there's actually a specification for the way that you write that help documentation that's, like, well-structured.

00:36:56.120 --> 00:37:00.280
And so this thing just looks at that and builds the actual command line for you, right?

00:37:00.280 --> 00:37:00.820
Oh, yeah.

00:37:00.820 --> 00:37:01.400
Exactly.

00:37:01.400 --> 00:37:02.940
Man, that's really awesome.

00:37:02.940 --> 00:37:03.920
Yeah.

00:37:03.920 --> 00:37:09.500
I think some other things that we're using is requests is always a good module.

00:37:09.500 --> 00:37:10.280
Yeah.

00:37:10.280 --> 00:37:12.660
I'm sure most people know that.

00:37:12.660 --> 00:37:13.960
Request is amazing.

00:37:13.960 --> 00:37:15.440
You can't get away without requests, right?

00:37:15.440 --> 00:37:15.940
Right.

00:37:15.940 --> 00:37:16.660
Exactly.

00:37:16.660 --> 00:37:18.240
All right, Ron.

00:37:18.240 --> 00:37:20.380
So how about a final call to action?

00:37:20.380 --> 00:37:22.320
How do people get started with Upbeat?

00:37:22.320 --> 00:37:23.420
What should they do?

00:37:23.420 --> 00:37:25.620
It's really easy to get started with Upbeat.

00:37:25.620 --> 00:37:33.580
You go to Upbeat.com and you sign up, create your first Django application or Flask application, and the instructions are right there.

00:37:33.580 --> 00:37:35.340
It takes, like, five minutes to set up, probably.

00:37:35.340 --> 00:37:36.380
And it's free to get started.

00:37:36.380 --> 00:37:38.400
Everyone can go and check it out.

00:37:38.400 --> 00:37:41.720
Please let us know if you run into any issues or get any feedback.

00:37:41.720 --> 00:37:43.520
We're always trying to improve it.

00:37:43.520 --> 00:37:46.540
So, yeah, looking forward to hearing the feedback.

00:37:46.540 --> 00:37:47.840
All right, very cool.

00:37:48.020 --> 00:37:50.180
Thanks for the look inside of what you guys are doing there.

00:37:50.180 --> 00:37:52.160
There's a lot of cool stuff happening at Upbeat.

00:37:52.360 --> 00:37:53.420
Thanks for having me, Michael.

00:37:53.420 --> 00:37:54.540
Yeah, you bet.

00:37:54.540 --> 00:37:55.940
Thanks for the advice on shipping software.

00:37:55.940 --> 00:37:56.540
That's great.

00:37:56.540 --> 00:37:57.160
Talk to you later.

00:37:57.160 --> 00:37:57.360
Bye.

00:37:57.360 --> 00:37:57.380
Bye.

00:37:57.380 --> 00:37:57.400
Bye.

00:37:58.140 --> 00:37:58.660
Bye.

00:37:58.660 --> 00:38:01.280
This has been another episode of Talk Python To Me.

00:38:01.280 --> 00:38:05.820
Today's guest was Ron Cohen, and this episode has been sponsored by Hired and SnapCI.

00:38:05.820 --> 00:38:07.800
Thank you guys for supporting the show.

00:38:07.800 --> 00:38:10.460
Hired wants to help you find your next big thing.

00:38:10.460 --> 00:38:15.620
Visit Hired.com slash Talk Python To Me to get five or more offers with salary and equity

00:38:15.620 --> 00:38:19.620
presented right up front and a special listener signing bonus of $2,000.

00:38:19.620 --> 00:38:24.060
SnapCI is modern, continuous integration and delivery.

00:38:24.440 --> 00:38:29.160
Build, test, and deploy your code directly from GitHub, all in your browser with debugging,

00:38:29.160 --> 00:38:31.120
Docker, and parallelism included.

00:38:31.120 --> 00:38:34.980
Try them for free at snap.ci slash Talk Python.

00:38:34.980 --> 00:38:41.900
You can find the links from today's show at talkpython.fm/episodes slash show slash 43.

00:38:41.900 --> 00:38:44.260
Be sure to subscribe to the show.

00:38:44.260 --> 00:38:46.700
Open your favorite podcatcher and search for Python.

00:38:46.700 --> 00:38:47.900
We should be right at the top.

00:38:47.900 --> 00:38:52.200
You can also find the iTunes and direct RSS feeds in the footer of the website.

00:38:52.820 --> 00:38:57.340
And don't forget to check out the podcast t-shirt at talkpython.fm/shirt.

00:38:57.340 --> 00:39:02.700
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:39:02.700 --> 00:39:05.080
You can hear the entire song on our website.

00:39:05.080 --> 00:39:06.960
This is your host, Michael Kennedy.

00:39:06.960 --> 00:39:09.480
As always, thank you so much for listening.

00:39:09.480 --> 00:39:11.420
Smix, take us out of here.

00:39:11.760 --> 00:39:32.980
Stay tuned.

