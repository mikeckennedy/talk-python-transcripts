WEBVTT

00:00:00.001 --> 00:00:01.500
Time is a simple thing, right?

00:00:01.500 --> 00:00:04.240
And working with it in Python is great.

00:00:04.240 --> 00:00:07.140
You just import date time and, somewhat oddly,

00:00:07.140 --> 00:00:09.520
use the date time class from that module.

00:00:09.520 --> 00:00:13.100
Oh, except there are times with time zones

00:00:13.100 --> 00:00:14.580
and times without time zones.

00:00:14.580 --> 00:00:16.580
And why is there a total seconds,

00:00:16.580 --> 00:00:18.860
but no total minutes, total hours,

00:00:18.860 --> 00:00:20.420
or total days on time delta?

00:00:20.420 --> 00:00:23.580
How about computing the number of weeks in a time span?

00:00:23.580 --> 00:00:25.520
What if you wanted to iterate

00:00:25.520 --> 00:00:27.940
over the next 21 workdays, skipping weekends?

00:00:28.660 --> 00:00:31.380
All right, we'd better talk about time in Python.

00:00:31.380 --> 00:00:33.480
Good thing Paul Gansel is here.

00:00:33.480 --> 00:00:37.260
He's a core developer who controls time in CPython.

00:00:37.260 --> 00:00:40.360
This is Talk Python To Me, episode 271,

00:00:40.360 --> 00:00:42.700
recorded June 18th, 2020.

00:00:42.700 --> 00:00:57.140
Welcome to Talk Python To Me,

00:00:57.240 --> 00:00:58.880
a weekly podcast on Python,

00:00:58.880 --> 00:01:00.900
the language, the libraries, the ecosystem,

00:01:00.900 --> 00:01:01.940
and the personalities.

00:01:01.940 --> 00:01:03.860
This is your host, Michael Kennedy.

00:01:03.860 --> 00:01:06.000
Follow me on Twitter where I'm @mkennedy.

00:01:06.000 --> 00:01:08.360
Keep up with the show and listen to past episodes

00:01:08.360 --> 00:01:09.760
at talkpython.fm.

00:01:09.760 --> 00:01:12.180
And follow the show on Twitter via at Talk Python.

00:01:12.180 --> 00:01:15.020
This episode is brought to you by Brilliant.org

00:01:15.020 --> 00:01:18.780
and us with our online courses over at Talk Python Training.

00:01:19.460 --> 00:01:20.940
Speaking of Talk Python Training,

00:01:20.940 --> 00:01:23.160
have you been thinking about taking one of our courses?

00:01:23.160 --> 00:01:30.640
We're participating in the latest Humble Bundle deal for Python developers along with a bunch of other great educators and tool developers.

00:01:30.840 --> 00:01:40.920
Until July 22nd, you can get $1,400 worth of Python goodies, including three of our popular courses for just $25.

00:01:41.460 --> 00:01:43.200
Yeah, Humble Bundles are crazy.

00:01:43.200 --> 00:01:47.440
That's $25 for our three courses and all those other things combined.

00:01:47.440 --> 00:01:51.160
Just visit talkpython.fm/humble2020.

00:01:51.160 --> 00:01:58.440
That's talkpython.fm/humble2020 altogether before July 22nd to take advantage of this offer.

00:01:58.800 --> 00:02:00.300
Now, let's get to that interview.

00:02:00.300 --> 00:02:02.220
Paul, welcome to Talk Python To Me.

00:02:02.220 --> 00:02:02.920
Glad to be here.

00:02:02.920 --> 00:02:03.940
Yeah, it's great to have you here.

00:02:03.940 --> 00:02:08.160
Really excited to talk about the meaning of time and all of that.

00:02:08.160 --> 00:02:10.620
Time is really tricky, actually.

00:02:10.620 --> 00:02:15.360
Time is one of those things that seems really obvious and simple until it's not.

00:02:15.360 --> 00:02:17.560
And then until you start working with it and you're like,

00:02:17.560 --> 00:02:20.900
oh, actually that code's running on the server and that server we forgot,

00:02:20.900 --> 00:02:23.140
you know, we didn't set the time zone to actually where it is.

00:02:23.140 --> 00:02:24.140
So maybe it's UTC.

00:02:24.140 --> 00:02:28.080
Maybe it's where the server's located or where our office is.

00:02:28.080 --> 00:02:31.240
And all of a sudden you find yourself juggling all these things.

00:02:31.240 --> 00:02:35.640
And especially if you're building anything that has to do with calendars or stuff like that,

00:02:35.640 --> 00:02:37.300
that's going to be a real adventure.

00:02:37.300 --> 00:02:41.720
Yeah, well, I will say that I did not set out to become like the date time guy,

00:02:41.720 --> 00:02:46.320
but I think that kind of complexity, like the natural complexity of the subject has,

00:02:46.320 --> 00:02:50.360
it's either drawn me in or what's the word for when something gets you stuck,

00:02:50.360 --> 00:02:53.380
like in a Kragmire or like a Venus flytrap or something.

00:02:53.380 --> 00:02:57.600
It's enticed you in and now it's got you trapped in its world.

00:02:57.600 --> 00:02:59.880
Yeah, it certainly seems like a one-way function,

00:02:59.880 --> 00:03:02.520
like something barbed where you can move in one direction,

00:03:02.520 --> 00:03:03.600
but not in the other direction.

00:03:03.600 --> 00:03:04.400
Yeah, for sure.

00:03:04.400 --> 00:03:06.340
Well, you know, it's really great that you're working on it.

00:03:06.340 --> 00:03:10.680
And just for the listeners, so you're a Python core developer working on basically

00:03:10.680 --> 00:03:13.840
times, date times, time spans, that kind of stuff in Python.

00:03:14.040 --> 00:03:16.900
Yeah, I think I originally got into it with working on DateUtil.

00:03:16.900 --> 00:03:21.260
So I've been maintaining that for about, oh God, now it's like six years.

00:03:21.260 --> 00:03:24.400
And, you know, DateUtil has a lot of little minor extensions.

00:03:25.040 --> 00:03:31.080
And then when PEP495 came around, the core developers showed up in DateUtil and said,

00:03:31.080 --> 00:03:36.100
hey, we kind of used your library as a prototype for how this could work.

00:03:36.100 --> 00:03:39.440
So maybe you want to actually implement PEP495.

00:03:39.920 --> 00:03:40.760
And then I did that.

00:03:40.760 --> 00:03:43.500
And then I had a relationship with the core developers.

00:03:43.500 --> 00:03:47.100
And then I just kind of stuck around and started doing more stuff.

00:03:47.100 --> 00:03:51.320
And eventually it's one of those things like you never set out to do it.

00:03:51.400 --> 00:03:55.140
And I don't even have a job that's particularly date time heavy.

00:03:55.140 --> 00:03:59.880
It's just like, if you start monitoring the issue tracker for something like DateUtil or

00:03:59.880 --> 00:04:05.720
even CPython, and then specifically just focusing on any one thing, like you'll just learn a stupidly

00:04:05.720 --> 00:04:08.740
large amount about edge cases and how everything works.

00:04:08.740 --> 00:04:09.800
I can see how that happens.

00:04:09.800 --> 00:04:11.720
And it's definitely one of those things that pulls you in.

00:04:11.720 --> 00:04:15.680
Before we dive too much into all that, though, let's start with your story.

00:04:15.680 --> 00:04:16.900
How'd you get into programming in Python?

00:04:16.900 --> 00:04:20.680
I knew this question was coming and I was sort of dreading trying to answer it because

00:04:20.680 --> 00:04:24.540
I feel like every time someone asks me how I started programming, I give them a slightly

00:04:24.540 --> 00:04:28.020
different answer because I've had quite a bit of false starts.

00:04:28.020 --> 00:04:33.320
Like I had when I was a kid, they taught us basic and I sort of remembered enough of that.

00:04:33.320 --> 00:04:35.280
And then so I didn't go to high school.

00:04:35.280 --> 00:04:41.360
But when I was sort of in place of high school, going to like a homeschooling center every once

00:04:41.360 --> 00:04:45.360
in a while, I guess I shouldn't say every once in a while, I was regularly going to a

00:04:45.360 --> 00:04:46.040
homeschooling center.

00:04:46.040 --> 00:04:48.220
You know, I started learning C++.

00:04:48.840 --> 00:04:53.000
And then weirdly, my friend became close friends with someone who was what they call

00:04:53.000 --> 00:04:57.780
the wizard on a moo, which is a mud, but object oriented.

00:04:57.780 --> 00:05:01.380
And mud stands for multi-user dungeon, I think.

00:05:01.380 --> 00:05:05.640
You know, I don't know if the young people listening these days will know what a mud was,

00:05:05.640 --> 00:05:09.000
but man, muds were super fun back in the early days.

00:05:09.000 --> 00:05:09.300
Yeah.

00:05:09.300 --> 00:05:12.960
See if you can describe a mud to people listening who have never played it.

00:05:13.020 --> 00:05:13.140
Yeah.

00:05:13.140 --> 00:05:18.120
So a mud is a text-based game that you would connect to via like Telnet or something.

00:05:18.120 --> 00:05:22.260
It's kind of like Zork or some sort of, if you don't know what a mud is, you probably don't

00:05:22.260 --> 00:05:23.080
know what Zork is either.

00:05:23.080 --> 00:05:27.940
But you know, like it's a text-based game where you describe, it'll say, you know, like, oh,

00:05:27.940 --> 00:05:31.420
you're in a room, you can go north or south and you'll go north, you know, you'll pick

00:05:31.420 --> 00:05:32.420
up an object or something.

00:05:32.420 --> 00:05:37.340
So it's like kind of a fantasy game or a Dungeons and Dragons type thing where it's all text-based.

00:05:37.340 --> 00:05:39.060
And then you can also talk to other people there.

00:05:39.060 --> 00:05:39.260
Yeah.

00:05:39.260 --> 00:05:42.700
And there's usually, potentially hundreds of people all running around.

00:05:42.700 --> 00:05:46.260
They might be in these rooms and you can have battles, you can go on quests.

00:05:46.260 --> 00:05:50.780
One of the hallmarks, I think, is it's not super obvious what you can do.

00:05:50.780 --> 00:05:52.460
It's not like, well, here are my five commands.

00:05:52.460 --> 00:05:57.340
Like you kind of have to interrogate the game with words to figure out like, oh, there's actually

00:05:57.340 --> 00:05:58.780
a rock and I could move the rock.

00:05:58.780 --> 00:05:59.320
I didn't know that.

00:05:59.320 --> 00:06:00.720
But now I, you know, that kind of stuff.

00:06:00.720 --> 00:06:06.020
What I liked about it was it was, you know, as great as graphics are on games these days,

00:06:06.020 --> 00:06:08.260
it really just leveraged your imagination.

00:06:08.260 --> 00:06:10.240
And yet there were other people there and stuff.

00:06:10.240 --> 00:06:11.140
I thought it was pretty cool.

00:06:11.140 --> 00:06:11.440
Yeah.

00:06:11.440 --> 00:06:17.320
Well, so I actually got into that stuff like after the heyday of MUDs, like when there was

00:06:17.320 --> 00:06:19.040
like not that many people in there.

00:06:19.040 --> 00:06:24.660
It was just my friend had this, like was running, it was basically a chat server that you could

00:06:24.660 --> 00:06:26.320
just build whatever room you wanted.

00:06:26.320 --> 00:06:28.840
And then like you could just directly program stuff.

00:06:28.840 --> 00:06:35.460
And it was interesting because when you would actually play MUD games in say the early 2000s

00:06:35.460 --> 00:06:39.520
or something, a decent fraction of the people or like a much higher fraction of the people

00:06:39.520 --> 00:06:44.120
than you would think, than you would meet in your daily life were blind because that was

00:06:44.120 --> 00:06:45.880
like the game was all textual.

00:06:45.880 --> 00:06:50.080
And so it was one of those things where, you know, you're not really going to appreciate

00:06:50.080 --> 00:06:55.040
World of Warcraft or something, but you could go on a MUD or something and then it'll describe,

00:06:55.040 --> 00:06:58.020
it just describes everything in the room and all that kind of stuff.

00:06:58.020 --> 00:07:04.040
So it was really interesting to see when like a decent fraction of the users are, you know,

00:07:04.040 --> 00:07:06.340
just interacting with computers in a completely different way.

00:07:06.340 --> 00:07:07.920
You see some interesting stuff.

00:07:07.920 --> 00:07:11.080
If I think about this too much, I'm going to stop being the daytime guy and I'm going to

00:07:11.080 --> 00:07:13.020
just take up a second career as the accessibility guy.

00:07:13.020 --> 00:07:13.260
Yeah.

00:07:13.260 --> 00:07:13.880
Yeah.

00:07:13.880 --> 00:07:14.100
Yeah.

00:07:14.100 --> 00:07:14.480
For sure.

00:07:14.480 --> 00:07:15.460
Well, it is super interesting.

00:07:15.460 --> 00:07:19.180
I hadn't really put that together, but of course, because it's pure text, you can have

00:07:19.180 --> 00:07:19.760
a screen reader.

00:07:20.300 --> 00:07:23.900
And like, once you have the screen reader, it's pretty much on par with everyone else's

00:07:23.900 --> 00:07:24.460
experience.

00:07:24.460 --> 00:07:25.500
That's super cool.

00:07:25.500 --> 00:07:27.060
A cool bit of nostalgia there.

00:07:27.060 --> 00:07:31.020
So you got into this Moo somehow that led you into programming.

00:07:31.020 --> 00:07:31.380
Yeah.

00:07:31.380 --> 00:07:32.940
So it was a programmable Moo.

00:07:32.940 --> 00:07:35.600
So that was like, you could do object-oriented programming.

00:07:35.600 --> 00:07:39.160
So I was just doing a little Moo scripting stuff.

00:07:39.160 --> 00:07:41.600
And then later I took up Tickle TK.

00:07:41.600 --> 00:07:46.640
I had this job that I had these very long shifts and nothing to do.

00:07:46.640 --> 00:07:49.000
It was just kind of sitting around doing nothing.

00:07:49.160 --> 00:07:50.180
And I could play on the computer.

00:07:50.180 --> 00:07:53.680
So I bought a laptop and just programmed a notepad clone.

00:07:53.680 --> 00:07:57.920
Then I went off to grad school, did a lot of MATLAB and some C programming.

00:07:57.920 --> 00:08:03.720
And then at some point I was on some forum somewhere trying to make a point about something.

00:08:03.720 --> 00:08:08.100
And I made a chart in MATLAB and I posted it.

00:08:08.100 --> 00:08:13.260
And MATLAB has like terrible anti-aliasing, or at least it did at the time.

00:08:13.260 --> 00:08:15.220
And someone was like, oh, what is this alias nonsense?

00:08:15.220 --> 00:08:17.600
Like you should use MATplotlib instead.

00:08:18.020 --> 00:08:22.200
So, and my friend had told me the one, the same one who had the Moo.

00:08:22.200 --> 00:08:27.060
He had told me about this programming language called Python that was like interesting and,

00:08:27.060 --> 00:08:29.960
you know, like natural language text or something.

00:08:29.960 --> 00:08:30.840
Fewer curly braces.

00:08:30.840 --> 00:08:31.300
Yeah.

00:08:31.300 --> 00:08:33.520
So I just like, I was like, all right, I'll give it a try.

00:08:33.520 --> 00:08:35.980
And then I really, really liked MATplotlib.

00:08:36.100 --> 00:08:41.260
I rewrote my whole thesis or I guess I just wrote my whole thesis, made all my charts in

00:08:41.260 --> 00:08:42.140
in MATplotlib.

00:08:42.140 --> 00:08:47.580
And then when I went and graduated and got a job, there was this one day when all the MATLAB

00:08:47.580 --> 00:08:52.220
licenses were taken on the, like you had a certain number of site licenses.

00:08:52.220 --> 00:08:55.700
And if you ran multiple processes, it would take up two licenses.

00:08:56.240 --> 00:08:58.120
And I just couldn't do any work that day.

00:08:58.120 --> 00:09:00.240
So I was like, how about this?

00:09:00.240 --> 00:09:03.880
I'll just rewrite all of our MATLAB scripts in Python.

00:09:03.880 --> 00:09:06.440
And so then at work, I got to use Python.

00:09:06.780 --> 00:09:11.680
And then, you know, I started doing open source and I don't think I've used MATLAB since I

00:09:11.680 --> 00:09:12.300
left that job.

00:09:12.300 --> 00:09:18.740
Isn't it interesting how these draconian licensing systems, like these licensed servers and other

00:09:18.740 --> 00:09:24.000
super intense things that are like just there to punish you, even if you follow the rules,

00:09:24.000 --> 00:09:31.120
you know, it's just, it's like in their world, the worst possible scenario is that in some edge

00:09:31.120 --> 00:09:36.600
case, some user gets to run 11 copies instead of 10 when they only paid for 10.

00:09:37.080 --> 00:09:41.980
Whereas, you know, they've lost all the goodwill and they've actually pushed you to just, you

00:09:41.980 --> 00:09:45.280
know what, we're just going to go do something that doesn't work like this at all.

00:09:45.280 --> 00:09:47.060
Those are really interesting situations.

00:09:47.060 --> 00:09:52.660
That's one of the reasons I really like open culture is it just cuts down on friction so much.

00:09:52.660 --> 00:09:56.960
Like there are just so many times when it's like, oh, if I get this image from Unsplash instead

00:09:56.960 --> 00:10:00.540
of iStockphoto or whatever, it's just, I don't have to think about it.

00:10:00.540 --> 00:10:01.840
I can use it however.

00:10:01.840 --> 00:10:05.560
And that's why I tend to create a lot of open artifacts.

00:10:05.740 --> 00:10:07.860
You know, I, my blog is all CC zero.

00:10:07.860 --> 00:10:11.900
I'm just really trying to cut down on the friction of letting people use my work.

00:10:11.900 --> 00:10:18.300
But, you know, I understand like my business model for myself is to sell my labor day to

00:10:18.300 --> 00:10:19.720
day to big companies.

00:10:19.720 --> 00:10:24.920
I understand how it would, you know, if you are a company, you may want to sell software.

00:10:24.920 --> 00:10:26.680
I also totally love that.

00:10:26.680 --> 00:10:30.780
I have to rent, you know, so many things via cloud services.

00:10:30.780 --> 00:10:35.020
And I think part of that is because it's so easy to get around licensing restrictions.

00:10:35.020 --> 00:10:36.740
So I don't know.

00:10:36.740 --> 00:10:42.340
I'm of two minds, but I think wherever I can, just cutting down friction by using free and

00:10:42.340 --> 00:10:45.640
open source licenses is, is just, just makes everyone happy.

00:10:45.640 --> 00:10:46.000
Yeah.

00:10:46.000 --> 00:10:46.460
Yeah.

00:10:46.900 --> 00:10:53.020
Well, I mean, there could always, always be some sort of grace slack area, right?

00:10:53.020 --> 00:10:57.660
Like, okay, you have 10 licenses, but we're not going to cut it off until you have 15 processes

00:10:57.660 --> 00:10:57.860
right.

00:10:57.860 --> 00:10:58.120
Yeah.

00:10:58.200 --> 00:11:01.120
There's just like, when it's such a hard and fast rule, I don't know.

00:11:01.120 --> 00:11:02.560
It just cuts me the wrong way.

00:11:02.560 --> 00:11:03.400
All right.

00:11:03.400 --> 00:11:08.460
So you talked about some of the stuff that you've done at work and you talked to, gave me the

00:11:08.460 --> 00:11:12.200
sense that you're kind of just doing some consulting and helping out various companies on various

00:11:12.200 --> 00:11:12.560
projects.

00:11:12.560 --> 00:11:13.980
But what do you do day to day?

00:11:13.980 --> 00:11:14.660
Oh, sorry.

00:11:14.660 --> 00:11:14.960
Yeah.

00:11:14.960 --> 00:11:16.380
No, I don't do consulting.

00:11:16.380 --> 00:11:17.260
I work for Google.

00:11:17.260 --> 00:11:23.220
So I, I, I'm more of a, less of a philanderer and more of a serial monogamist.

00:11:23.220 --> 00:11:24.440
So I gotcha.

00:11:24.540 --> 00:11:24.700
Yeah.

00:11:24.700 --> 00:11:29.540
I worked for Bloomberg for about four years and now I work for Google and our team is

00:11:29.540 --> 00:11:31.480
called a Corp Eng machine learning.

00:11:31.480 --> 00:11:36.880
So Corp Eng is our internal infrastructure team that, that handles things like facilities

00:11:36.880 --> 00:11:39.120
and like tickets.

00:11:39.120 --> 00:11:44.260
Like if you, if you open tickets with people like HR, things like that, those are all within

00:11:44.260 --> 00:11:50.080
Corp Eng and we build machine learning models for other people in Corp Eng for, to, to provide

00:11:50.080 --> 00:11:52.220
them insights or to make their job easier, that kind of thing.

00:11:52.220 --> 00:11:56.160
So this is like the Google scale of automate the boring stuff to help you do your work

00:11:56.160 --> 00:11:56.560
a little better.

00:11:56.560 --> 00:11:57.320
Yeah, definitely.

00:11:57.320 --> 00:12:01.020
So, you know, my day to day work is playing around in Jupyter Notebook.

00:12:01.020 --> 00:12:01.600
Well, okay.

00:12:01.600 --> 00:12:07.260
Everything in Google is like its own proprietary thing or even like when it's not proprietary,

00:12:07.260 --> 00:12:08.160
it's still its own thing.

00:12:08.160 --> 00:12:10.800
So like, we usually use collabs.

00:12:10.800 --> 00:12:15.620
Unfortunately, you know, I like to rag on people being like having their own proprietary versions

00:12:15.620 --> 00:12:16.080
of stuff.

00:12:16.080 --> 00:12:20.520
But like every time I try and do that with Google, like they have like stupidly good

00:12:20.520 --> 00:12:20.940
reasons.

00:12:20.940 --> 00:12:26.080
It just makes it so much less fun to make fun of our proprietary technologies when, when

00:12:26.080 --> 00:12:31.740
it's like, oh, well, they do have native integration with like Google Docs and, and, Google drive.

00:12:31.740 --> 00:12:34.480
So yeah, I guess it does make sense to use it.

00:12:34.640 --> 00:12:34.800
Yeah.

00:12:34.800 --> 00:12:35.220
Yeah.

00:12:35.220 --> 00:12:35.480
Yeah.

00:12:35.480 --> 00:12:35.680
Sure.

00:12:35.680 --> 00:12:41.620
I mean, there is in the tech space and the developer space, certainly the not built here.

00:12:41.620 --> 00:12:45.840
So we've got to build our own sort of obsession where people could take that too far.

00:12:45.840 --> 00:12:47.460
And it's just a, just a drag.

00:12:47.460 --> 00:12:51.200
Like we don't need to build our own like booking system.

00:12:51.200 --> 00:12:55.060
We can just get a, get a calendar system somewhere else and things like that.

00:12:55.060 --> 00:12:59.160
But when it's large enough scale and it has like built in advantages, sure.

00:12:59.160 --> 00:12:59.820
It makes sense.

00:12:59.820 --> 00:13:00.100
Yeah.

00:13:00.100 --> 00:13:03.680
I mean, I just wish that my colleagues were less competent because then I can make fun of

00:13:03.680 --> 00:13:07.880
them, but you know, now I just have to respect them.

00:13:07.880 --> 00:13:10.160
Oh, what kind of a work environment is that?

00:13:10.160 --> 00:13:11.860
Pretty good one.

00:13:11.860 --> 00:13:17.040
This portion of Talk Python To Me is brought to you by Brilliant.org.

00:13:17.040 --> 00:13:21.880
Brilliant has digestible courses in topics from the basics of scientific thinking all the

00:13:21.880 --> 00:13:24.700
way up to high end science, like quantum computing.

00:13:25.300 --> 00:13:29.960
And while quantum computing may sound complicated, Brilliant makes complex learning uncomplicated

00:13:29.960 --> 00:13:30.500
and fun.

00:13:30.500 --> 00:13:34.440
It's super easy to get started and they've got so many science and math courses to choose

00:13:34.440 --> 00:13:34.640
from.

00:13:34.640 --> 00:13:39.280
I recently used Brilliant to get into rocket science for an upcoming episode and it was a

00:13:39.280 --> 00:13:39.660
blast.

00:13:39.660 --> 00:13:44.520
The interactive courses are presented in a clean and accessible way and you could go from knowing

00:13:44.520 --> 00:13:47.060
nothing about a topic to having a deep understanding.

00:13:47.060 --> 00:13:51.600
Put your spare time to good use and hugely improve your critical thinking skills.

00:13:52.040 --> 00:13:55.040
Go to talkpython.fm/brilliant and sign up for free.

00:13:55.040 --> 00:13:59.620
The first 200 people that use that link get 20% off the premium subscription.

00:13:59.620 --> 00:14:04.900
That's talkpython.fm/brilliant or just click the link in the show notes.

00:14:07.720 --> 00:14:08.360
All right.

00:14:08.360 --> 00:14:09.600
Let's talk about time.

00:14:09.600 --> 00:14:14.540
Every programming language has to deal with dates and times and they all have their own

00:14:14.540 --> 00:14:15.980
way of doing it.

00:14:15.980 --> 00:14:18.880
And I would say Python's is pretty solid, right?

00:14:18.880 --> 00:14:21.300
It's got a pretty good system there.

00:14:21.300 --> 00:14:25.760
So there's a couple of interesting things, I guess, about time.

00:14:25.760 --> 00:14:29.360
One is it only goes back so far in computer time, right?

00:14:29.580 --> 00:14:33.040
Some of if you if you're talking in ticks or things like that.

00:14:33.040 --> 00:14:33.660
So I don't know.

00:14:33.660 --> 00:14:38.460
What do you think about the daytime story in Python now that you're down in it?

00:14:38.460 --> 00:14:39.440
I'm actually a big fan.

00:14:39.440 --> 00:14:46.120
I may not have a great breadth of experience outside of Python, but I think, you know, the

00:14:46.120 --> 00:14:51.400
more I've learned about Python daytime, the more I understand the choices that were made.

00:14:51.400 --> 00:14:56.460
Like one of the biggest issues with daytimes is that you often see people like, oh, I can't

00:14:56.460 --> 00:14:59.580
believe daytimes are so terrible in Python because of X, Y, Z.

00:14:59.580 --> 00:15:03.800
Like, why isn't why isn't every daytime UTC by default?

00:15:03.800 --> 00:15:09.520
Like, why is it some other naive thing or or like, why do I have to attach a different time

00:15:09.520 --> 00:15:10.940
zone to this or that?

00:15:10.940 --> 00:15:16.880
And the issue is that there are multiple camps of people who have equally strong.

00:15:16.880 --> 00:15:21.340
It should just be this way opinions, but in opposite directions.

00:15:21.340 --> 00:15:25.920
So most of the people think UTC is the natural thing to do.

00:15:25.920 --> 00:15:30.500
But I think those same people may not realize that when you're working with dates in the

00:15:30.500 --> 00:15:35.660
future or you're working with civil times in general, UTC is actually a very bad choice

00:15:35.660 --> 00:15:40.240
because generally speaking, UTC is good for.

00:15:40.240 --> 00:15:45.480
So I say UTC is good and UTC is actually like the best that we have.

00:15:45.480 --> 00:15:51.240
I don't love that UTC has leap seconds in it because it takes some nice monotonic constant

00:15:51.240 --> 00:15:57.000
that you can, you know, that you can use as a reference and turns it into this weird thing

00:15:57.000 --> 00:16:01.980
with its own edge cases where sometimes there are 60 and sometimes there are 61 seconds in

00:16:01.980 --> 00:16:02.260
a minute.

00:16:02.260 --> 00:16:02.900
Very annoying.

00:16:02.900 --> 00:16:03.340
Really?

00:16:03.340 --> 00:16:04.420
I had no idea.

00:16:04.420 --> 00:16:05.040
Yeah.

00:16:05.240 --> 00:16:08.440
every fourth minute has an extra second or something.

00:16:08.440 --> 00:16:10.620
It can happen as many as two times per year.

00:16:10.620 --> 00:16:15.980
And sometimes they, I think they'll either skip the 59th second or they'll add one second.

00:16:15.980 --> 00:16:18.740
I think it's only ever that they've added one second.

00:16:18.740 --> 00:16:21.720
It's for the purposes of leap seconds.

00:16:21.720 --> 00:16:27.160
Leap seconds are, I think, useful for some things like astro navigation or something, but

00:16:27.160 --> 00:16:29.400
they're incredibly important for astronomers.

00:16:29.760 --> 00:16:36.020
I have no idea why they're built into the foundations of civil time of regular human does not need

00:16:36.020 --> 00:16:39.780
to know to the second when the sun is going to be overhead in Greenwich.

00:16:39.780 --> 00:16:40.420
Right, right.

00:16:40.420 --> 00:16:45.700
You know, maybe it makes more sense to have like an astro time that takes those like peculiarities

00:16:45.700 --> 00:16:46.480
into account, right?

00:16:46.480 --> 00:16:50.980
Astronomy has its own whole big long set of ways of doing timekeeping.

00:16:50.980 --> 00:16:53.940
Like they have sidereal times and solar time.

00:16:53.940 --> 00:16:59.000
And, and I think they usually use the Julian calendar going backwards.

00:16:59.000 --> 00:17:03.360
I don't really understand exactly why they do all that stuff, but if you really want to

00:17:03.360 --> 00:17:08.780
dig into like weird timekeeping practices, astronomers are astronomers and weirdly astrologers.

00:17:08.780 --> 00:17:16.600
Like something you, you may not know is that a decent amount of the like historical corrections.

00:17:16.740 --> 00:17:20.600
And actually I think the original basis of a lot of the data in the time zone database

00:17:20.600 --> 00:17:27.240
that everyone uses came from astrologers who were like deeply concerned with exactly what

00:17:27.240 --> 00:17:29.020
second you were born at.

00:17:29.020 --> 00:17:38.480
So like if you birth certificate says like three, 15 and 14 seconds in Yugoslavia in 1981, they

00:17:38.480 --> 00:17:46.180
have to dig up the, like the old Soviet era Yugoslavian timekeeping records to find out what that

00:17:46.180 --> 00:17:51.900
meant in UTC time so that they could find out whether Jupyter was in the house of Aquarius

00:17:51.900 --> 00:17:54.440
or some, some crazy thing like that.

00:17:54.440 --> 00:17:55.560
That is crazy.

00:17:55.560 --> 00:17:56.280
I had no idea.

00:17:56.280 --> 00:18:00.300
If you don't cut me off on these things, I will just go on as many tangents, like a weird

00:18:00.300 --> 00:18:00.600
fact.

00:18:00.600 --> 00:18:03.020
Tell me how they're still involved and then I want to dig into something else.

00:18:03.020 --> 00:18:05.240
Oh, well, they just, it's still important for them.

00:18:05.240 --> 00:18:11.480
So you'll still see corrections where they're very concerned with like times before 1970 because

00:18:11.480 --> 00:18:13.160
the record keeping is a little shoddier.

00:18:13.460 --> 00:18:18.900
And so the time zone database, you know, basically they say anything after 1970, we try and keep

00:18:18.900 --> 00:18:21.420
it as accurate as possible before its best effort.

00:18:21.420 --> 00:18:28.500
So you'll still see people making sure they're like, oh, well the, like exactly how did the

00:18:28.500 --> 00:18:30.800
clocks move on the ground at this time?

00:18:30.980 --> 00:18:36.640
It's like the people who are on the time zone mailing list are basically a bunch of Unix

00:18:36.640 --> 00:18:43.020
people, the historians who are digging through, looking at historical stuff and astrologers who

00:18:43.020 --> 00:18:46.200
are just weirdly concerned with exactly the minute you were born.

00:18:46.200 --> 00:18:46.700
How interesting.

00:18:46.700 --> 00:18:47.400
I had no idea.

00:18:47.400 --> 00:18:48.300
All right.

00:18:48.300 --> 00:18:55.060
So what I, what I want to dig into is this idea of naive time versus aware times.

00:18:55.060 --> 00:18:55.420
Sure.

00:18:55.500 --> 00:18:56.620
You can do interesting math.

00:18:56.620 --> 00:19:01.200
Like you can subtract two date times, but I don't think you can subtract like a naive

00:19:01.200 --> 00:19:02.900
time from an aware time and stuff like that.

00:19:02.900 --> 00:19:04.160
Like you can't combine these things.

00:19:04.160 --> 00:19:05.020
Can you not?

00:19:05.020 --> 00:19:05.620
I don't remember.

00:19:05.620 --> 00:19:07.380
I feel like I've seen an error from that before.

00:19:07.380 --> 00:19:08.220
That is true.

00:19:08.360 --> 00:19:13.520
So it's changed a little bit between Python two and Python three, but not to the point

00:19:13.520 --> 00:19:15.620
where arithmetic is allowed between them.

00:19:15.620 --> 00:19:22.480
So in Python two, there was this idea that a naive time was essentially just a representation

00:19:22.480 --> 00:19:25.660
of a time as it would show up on a calendar.

00:19:25.660 --> 00:19:28.940
So it's divorced from any notion of real time.

00:19:28.940 --> 00:19:33.780
It's an abstract, perfect daytime that just is the proleptic Gregorian calendar.

00:19:34.340 --> 00:19:37.880
And an aware time represents a specific timestamp.

00:19:37.880 --> 00:19:42.480
So you can take something that's in UTC and you can turn it into local time in New York

00:19:42.480 --> 00:19:45.680
or in Shanghai or any, anything like that.

00:19:45.680 --> 00:19:47.960
You can get durations between things.

00:19:47.960 --> 00:19:49.920
So that was the distinction.

00:19:49.920 --> 00:19:55.400
And, you know, the idea was that it's kind of like a naive daytime was a daytime without

00:19:55.400 --> 00:19:58.340
a unit and aware daytime is putting units on it.

00:19:58.340 --> 00:20:00.280
So the number five is just a number.

00:20:00.280 --> 00:20:05.020
Five feet is equivalent to one and a quarter meters or something like that.

00:20:05.020 --> 00:20:05.280
Right.

00:20:05.280 --> 00:20:05.740
Yes.

00:20:05.740 --> 00:20:06.920
1.6 or something.

00:20:06.920 --> 00:20:13.120
In Python three, it changed a little bit for reasons that are complicated and like probably

00:20:13.120 --> 00:20:14.920
not worth getting into.

00:20:14.920 --> 00:20:22.360
It's very complicated to create a time zone, like a TZ info that represents local time and

00:20:22.360 --> 00:20:24.600
maintains all the semantics that you would hope.

00:20:24.740 --> 00:20:30.860
If during an entire process where the local time might change over the course of the process.

00:20:30.860 --> 00:20:37.920
And so one of the things that happened in Python three is that now instead of naive times being

00:20:37.920 --> 00:20:40.720
unit list, they just represent local time.

00:20:40.720 --> 00:20:44.000
So they still act mostly the same way.

00:20:44.120 --> 00:20:50.320
But if you do something like you call dot timestamp on them, they will give you, they'll convert

00:20:50.320 --> 00:20:55.120
it to UTC and give you the number of seconds since 1970, January 1st in UTC.

00:20:55.120 --> 00:20:59.860
You can also do like as time zone and you can just directly, you can pass that a time zone.

00:20:59.860 --> 00:21:00.460
It'll convert.

00:21:00.460 --> 00:21:05.960
It'll assume that the daytime represents local time and then convert it into the time zone you

00:21:05.960 --> 00:21:06.340
care about.

00:21:06.340 --> 00:21:13.040
So at this point, local times are, or naive times represent local time, which is why UTC

00:21:13.040 --> 00:21:16.780
now and UTC from timestamp are not functions you should use these days.

00:21:16.780 --> 00:21:17.080
Okay.

00:21:17.080 --> 00:21:22.580
Because they basically, they generate a naive timestamp without attaching UTC offset or like

00:21:22.580 --> 00:21:26.980
without attaching the UTC object to it, but they do it as if that represents UTC.

00:21:26.980 --> 00:21:32.000
So if you do UTC now and then dot timestamp, it'll give you a timestamp representing a different

00:21:32.000 --> 00:21:32.720
time than now.

00:21:33.040 --> 00:21:38.380
Like I'm in a minus eight, so it would subtract eight hours from it or something like that

00:21:38.380 --> 00:21:39.540
or add eight hours rather.

00:21:39.540 --> 00:21:42.780
It'll plus or minus eight hours, but it'll change it in some direction.

00:21:42.780 --> 00:21:43.900
That's not just leave it alone.

00:21:43.900 --> 00:21:45.380
It was UTC now.

00:21:45.380 --> 00:21:47.720
So it just, it is that time, right?

00:21:47.720 --> 00:21:48.340
Yeah, exactly.

00:21:48.340 --> 00:21:48.820
Okay.

00:21:48.820 --> 00:21:49.600
Interesting.

00:21:49.600 --> 00:21:50.140
Yeah.

00:21:50.140 --> 00:21:55.020
I always feel like daytime seems so straightforward until you get into here and then it's just

00:21:55.020 --> 00:21:56.880
like fraught with education.

00:21:56.880 --> 00:21:57.400
Like, wait a minute.

00:21:57.400 --> 00:21:57.680
What?

00:21:57.680 --> 00:21:59.640
I didn't know I couldn't use UTC now.

00:21:59.640 --> 00:22:00.540
Why is it still there?

00:22:00.540 --> 00:22:00.900
Right.

00:22:00.900 --> 00:22:01.920
Without at least a warning.

00:22:01.920 --> 00:22:05.680
It's even worse than you might think too, because the semantics of like subtraction

00:22:05.680 --> 00:22:07.940
are made even more complicated.

00:22:07.940 --> 00:22:12.500
And like the people who designed this library, like they weren't just like idiots.

00:22:12.500 --> 00:22:16.260
They actually were like really thinking things through.

00:22:16.260 --> 00:22:19.140
And so most of the time you won't even notice this kind of thing.

00:22:19.140 --> 00:22:22.580
But when you learn about it, it's a bit like makes your head explode.

00:22:22.580 --> 00:22:29.500
So there's subtract, like subtraction works differently when you do it between the same

00:22:29.500 --> 00:22:31.620
time zone and a different time zone.

00:22:31.620 --> 00:22:35.800
So if you have two dates and they're both in New York time, right?

00:22:35.800 --> 00:22:36.980
America slash New York.

00:22:36.980 --> 00:22:41.100
What it'll do is subtract them just based on the calendar.

00:22:41.220 --> 00:22:44.780
It won't give you the amount, the total amount of time elapsed between those.

00:22:44.780 --> 00:22:50.120
Even if like, so if it's like the day before daylight saving time transition and the day after

00:22:50.120 --> 00:22:55.640
23 hours have elapsed between one o'clock and one o'clock the following day, it'll give

00:22:55.640 --> 00:22:57.400
you 24 hours between those two.

00:22:57.400 --> 00:22:58.840
If they're both in New York.

00:22:58.840 --> 00:22:59.100
Okay.

00:22:59.300 --> 00:23:01.640
Because that's how it works in the other direction.

00:23:01.640 --> 00:23:07.120
If you add 24 hours to something, it'll just shift over the calendar by one day.

00:23:07.120 --> 00:23:12.320
And I think the idea was that they wanted it to be the way it works in the other direction

00:23:12.320 --> 00:23:16.580
is you add one day and then it'll create something that's one calendar day in the future.

00:23:16.580 --> 00:23:21.340
And then it'll attach the same time zone object to the new daytime.

00:23:21.340 --> 00:23:25.140
So if you then subtract it back, you'll get, you'll still get one day.

00:23:25.320 --> 00:23:30.960
The problem is that like, you can't just sort of shift around on the calendar when you're

00:23:30.960 --> 00:23:34.980
trying to do operations between two daytimes, like one in Chicago and one in New York.

00:23:34.980 --> 00:23:40.640
And the relevant, like the most reasonable thing to do is to just get the total amount of elapsed

00:23:40.640 --> 00:23:40.920
time.

00:23:40.920 --> 00:23:43.840
You just convert them both to UTC and say how much time has passed.

00:23:43.840 --> 00:23:44.100
Right.

00:23:44.100 --> 00:23:49.680
The thing is that, the way they decide between inter zone and different zone, like same

00:23:49.680 --> 00:23:53.480
zone and different zone is whether the objects are the exact same object.

00:23:53.480 --> 00:23:58.400
So if you construct a new time zone object, if your time zone provider allows you to create

00:23:58.400 --> 00:24:02.880
a new time zone object representing the exact same zone, it won't check if they're equal.

00:24:02.880 --> 00:24:04.400
It'll just check if they're the same object.

00:24:04.400 --> 00:24:09.440
This is not really a problem with PyTZ because PyTZ doesn't use normal daytime mechanisms.

00:24:09.440 --> 00:24:14.140
And like basically literally everything you do will generate a new time zone object.

00:24:14.140 --> 00:24:16.080
So everything is an inter zone comparison.

00:24:16.080 --> 00:24:16.460
Yeah.

00:24:16.580 --> 00:24:21.860
And with date util and with the new zone info module, I've implemented a cache.

00:24:21.860 --> 00:24:24.760
So basically all of these zones are singletons anyway.

00:24:24.760 --> 00:24:31.460
So nowadays it's basically like if you use the same INA key, you'll get same zone semantics.

00:24:31.460 --> 00:24:34.220
And otherwise you'll get different zone semantics.

00:24:34.220 --> 00:24:36.040
It's more complicated than you would think.

00:24:36.240 --> 00:24:41.400
And it's really just all down to these overloaded concepts that are just everywhere in daytimes.

00:24:41.400 --> 00:24:46.600
Like the idea of adding a duration is horribly ambiguous, right?

00:24:46.600 --> 00:24:48.380
If you consider adding a month, right?

00:24:48.380 --> 00:24:49.000
What does that mean?

00:24:49.000 --> 00:24:50.100
Does that mean 30 days?

00:24:50.100 --> 00:24:50.880
Does it mean 31?

00:24:50.880 --> 00:24:54.800
Does it mean give me the next, the same day, the next month?

00:24:54.800 --> 00:24:57.000
What if it's January 31st?

00:24:57.000 --> 00:24:58.940
Do you go to the end of February?

00:24:58.940 --> 00:25:00.100
Do you go to the beginning of March?

00:25:00.300 --> 00:25:03.920
So for two days, if you add one month, does it all go to the same day?

00:25:03.920 --> 00:25:09.860
Like, you know, do you just do one month, mod, however many days the difference is?

00:25:09.860 --> 00:25:11.440
Like there's so many different options.

00:25:11.440 --> 00:25:15.380
You know, you kind of have to pick one, but it's very frequently the case that

00:25:15.380 --> 00:25:21.180
different users will have different, very strong expectations that it will do one thing or the other.

00:25:21.180 --> 00:25:25.480
And for something so low level, like the datetime module, which is, you know,

00:25:25.480 --> 00:25:28.020
essentially something like a standard, right?

00:25:28.040 --> 00:25:31.420
It's trying to be basically a data type, an interchange type.

00:25:31.420 --> 00:25:37.620
You just have to make choices that are hopefully going to be useful for the most,

00:25:37.620 --> 00:25:38.740
the greatest number of people.

00:25:38.740 --> 00:25:39.020
Yeah.

00:25:39.020 --> 00:25:42.460
Well, it makes a lot of sense, but man, there are more and more edge cases.

00:25:42.460 --> 00:25:44.800
The more we talk, I'm like, yeah, that's, that's tricky.

00:25:44.800 --> 00:25:49.820
And you know, you think about, so if I was in Indiana, for example, like certain places

00:25:49.820 --> 00:25:54.860
in the United States have different rules about following things like daylight savings, right?

00:25:54.860 --> 00:26:01.780
So Arizona, Indiana, a couple others, but I pick on Indiana because they've got a county

00:26:01.780 --> 00:26:03.340
by county system.

00:26:03.340 --> 00:26:07.260
So depending on which county you live in, like you're actually, let me just read this a bit

00:26:07.260 --> 00:26:09.260
from Wikipedia just so people know what I'm talking about.

00:26:09.260 --> 00:26:14.620
It says, most portions of the state that were in the Eastern time zone do not observe

00:26:14.620 --> 00:26:15.900
DTS daylight savings.

00:26:16.000 --> 00:26:20.440
However, Floyd Clark and Harrison counties, which are near Louisville, Kentucky and Ohio

00:26:20.440 --> 00:26:26.240
and Dearborn counties, which are near Cincinnati and Ohio unofficially observe it because they're

00:26:26.240 --> 00:26:28.500
proximity to these cities, which do observe it.

00:26:28.500 --> 00:26:35.100
So if I've, if I have like two day times, one in that county or not in that county, right?

00:26:35.100 --> 00:26:40.040
It's in different time zones in different parts of the year based on like region.

00:26:40.160 --> 00:26:41.660
Like what do you even do there?

00:26:41.660 --> 00:26:46.520
Well, in the time zone database, the INA time zone database is also sometimes called the

00:26:46.520 --> 00:26:47.240
Olsen database.

00:26:47.240 --> 00:26:52.960
What they have is that, I mean, it's one of the reasons why names like us slash Eastern

00:26:52.960 --> 00:26:55.180
and us slash Pacific are actually deprecated.

00:26:55.180 --> 00:27:02.160
The way those keys work is that they usually go with a region slash the largest city in the

00:27:02.160 --> 00:27:07.140
region that has continuously had used the same rules since 1970.

00:27:07.760 --> 00:27:12.780
So America slash New York is the same one that you use in New York as in Boston.

00:27:12.780 --> 00:27:13.300
Yeah.

00:27:13.300 --> 00:27:14.800
Or in Virginia, anything like that.

00:27:14.800 --> 00:27:20.720
If Massachusetts switches over to being part of a Atlantic standard time, then there will

00:27:20.720 --> 00:27:26.220
be a new zone created called like America slash Boston and it'll cover Massachusetts going

00:27:26.220 --> 00:27:28.320
back all the way to 1970 in Indiana.

00:27:28.320 --> 00:27:29.880
They have their own like sub key.

00:27:29.880 --> 00:27:35.120
So they have like America slash Indiana slash Indianapolis and then like five different states

00:27:35.120 --> 00:27:35.500
there.

00:27:35.620 --> 00:27:38.360
I think Mountain Time has a couple things like that as well.

00:27:38.360 --> 00:27:41.880
Like Denver and Phoenix are separately, are handled separately.

00:27:41.880 --> 00:27:42.280
I see.

00:27:42.280 --> 00:27:47.220
So you have to be very precise about your, like your time zone info passed over, but then it'll

00:27:47.220 --> 00:27:48.140
actually take care of that.

00:27:48.140 --> 00:27:48.420
Yeah.

00:27:48.420 --> 00:27:51.260
It definitely handles that in terms of historical times.

00:27:51.260 --> 00:27:55.800
Like this gets to an issue that it's another one of these overloaded concepts, which is like

00:27:55.800 --> 00:27:59.760
when we talk about a date time for some people, like if you're looking at server logs, people

00:27:59.760 --> 00:28:02.560
are like, why would you not just use UTC all the time?

00:28:03.060 --> 00:28:08.860
It's unambiguous, but those people are not implementing say a scheduling service, right?

00:28:08.860 --> 00:28:13.620
Where, you know, like you and I scheduled to meet at a specific time to record this podcast.

00:28:13.620 --> 00:28:14.080
Right.

00:28:14.080 --> 00:28:19.540
If someone had changed daylight saving time, like if between the point where I scheduled it

00:28:19.540 --> 00:28:24.600
and today, the United States said, we're in so many crises right now that we're just going

00:28:24.600 --> 00:28:27.060
to like switch off daylight saving time.

00:28:27.500 --> 00:28:30.920
I don't know why politicians love messing with time at the last minute, but they absolutely

00:28:30.920 --> 00:28:31.300
do.

00:28:31.300 --> 00:28:37.160
If someone had done that, then we would still want to meet at four o'clock because relative

00:28:37.160 --> 00:28:41.840
to my work schedule and your work schedule and everyone's school schedules, that's still

00:28:41.840 --> 00:28:42.940
the right time for us to meet.

00:28:42.940 --> 00:28:46.780
But the mapping between four o'clock and UTC will have changed.

00:28:46.780 --> 00:28:52.420
So what that means is like, if we had recorded that as saying, okay, this is going to be as a

00:28:52.420 --> 00:28:55.820
daytime guy, I should always be embarrassed by this, but I can never do any daylight saving

00:28:55.820 --> 00:28:57.000
time calculations in my head.

00:28:57.000 --> 00:28:59.240
Hey, we have computers for this stuff.

00:28:59.240 --> 00:28:59.500
Come on.

00:28:59.500 --> 00:28:59.780
Yeah.

00:28:59.780 --> 00:29:03.260
It's like eight o'clock UTC is when this recording is going to happen.

00:29:03.260 --> 00:29:06.900
If all of a sudden the mapping between four o'clock and eight o'clock changes, you and I

00:29:06.900 --> 00:29:11.320
will be very unhappy that they stored it in UTC and then converted it before showing it to

00:29:11.320 --> 00:29:11.560
people.

00:29:11.560 --> 00:29:16.240
So when you're dealing with the distinction I usually make is timestamps versus civil times.

00:29:16.240 --> 00:29:22.760
So a civil time is like when you actually care what the clock on the wall says, then

00:29:22.760 --> 00:29:26.900
you should use a civil time, which is you store exactly what the clock on the wall says.

00:29:26.900 --> 00:29:30.840
And then the time zone you stored it in America, New York, something like that.

00:29:30.840 --> 00:29:31.060
Right.

00:29:31.060 --> 00:29:36.040
This is to get back to this point about what you do, like how you store it right now.

00:29:36.040 --> 00:29:40.600
There's no way to solve exactly that problem, or there's not a great way to solve exactly

00:29:40.600 --> 00:29:41.140
that problem.

00:29:41.740 --> 00:29:47.020
Because what you really care about is like a little hard to pin down because, you know,

00:29:47.020 --> 00:29:49.640
I'm in New York, you're in Portland, right?

00:29:49.640 --> 00:29:49.940
Yeah.

00:29:49.940 --> 00:29:57.000
So, you know, if one of us changes our time zone, if our relative time zones change, New

00:29:57.000 --> 00:29:59.820
York changes its time zone offset, but Portland doesn't.

00:29:59.820 --> 00:30:04.420
Which, you know, the meetings with two people, which one controls, which one matters, you

00:30:04.420 --> 00:30:06.400
know, or like, I said, it's American.

00:30:06.400 --> 00:30:11.920
Do you reorient it based on like the current understanding of time in New York and then break

00:30:11.920 --> 00:30:14.620
Portland or do you stick with Portland and now you're out of sync?

00:30:14.620 --> 00:30:19.540
I think the best you can do is you pick an INA zone and you just store it that way.

00:30:19.540 --> 00:30:21.620
Usually that won't be a major problem.

00:30:21.820 --> 00:30:26.640
If you're like super belt and suspenders, like storing a user's location, you say like,

00:30:26.640 --> 00:30:29.720
where is this meeting or like, where's the rules that you care about?

00:30:29.720 --> 00:30:35.540
And then you'd have to find a library that maps locations to time zones as a function of

00:30:35.540 --> 00:30:35.900
time.

00:30:35.900 --> 00:30:38.560
And then just make sure that that library is kept up to date.

00:30:38.560 --> 00:30:40.940
That should sort of sort you out.

00:30:40.940 --> 00:30:47.900
But I think the best you can do is to monitor the time zone mailing list and, you know, just

00:30:47.900 --> 00:30:51.020
be aware if you see anything that's going to affect you.

00:30:51.280 --> 00:30:51.440
Yeah.

00:30:51.440 --> 00:30:51.920
Yeah.

00:30:51.920 --> 00:30:54.940
Well, there's definitely a lot of little edge cases and that's pretty interesting.

00:30:54.940 --> 00:31:00.540
So another thing that's interesting in the whole time space of Python, and I think it's

00:31:00.540 --> 00:31:02.880
done pretty well, is time deltas, right?

00:31:02.880 --> 00:31:07.000
And the fact that I can have two daytimes and I just subtract them and that gives me a time

00:31:07.000 --> 00:31:11.860
delta object, or I can have a daytime and then add or subtract the time delta and that generate

00:31:11.860 --> 00:31:13.660
a new daytime that's offset by that.

00:31:13.660 --> 00:31:16.960
What's weird about time deltas that I should be learning about?

00:31:16.960 --> 00:31:18.360
Because they seem pretty straightforward.

00:31:18.720 --> 00:31:22.760
I would like to see them do a little bit more help for people, but this is already pretty

00:31:22.760 --> 00:31:22.960
good.

00:31:22.960 --> 00:31:28.540
The biggest thing semantically is an issue that I already alluded to, which is that they're

00:31:28.540 --> 00:31:32.420
a little overloaded in that sometimes they represent an elapsed amount of time.

00:31:32.420 --> 00:31:37.780
And most of the time, and usually they're interpreted when you like apply them to something, they're

00:31:37.780 --> 00:31:40.960
usually interpreted as a calendrical delta.

00:31:41.160 --> 00:31:46.420
So it's like, it'll give you, you know, if you add one hour to something, if you add one

00:31:46.420 --> 00:31:52.400
hour to like 1.30 right before a standard time to daylight saving time transition, what you'll

00:31:52.400 --> 00:31:56.600
get is some non-existent time that is right in the middle.

00:31:56.600 --> 00:31:59.200
Like, you know, it's like a 2.30 that never happened.

00:31:59.400 --> 00:32:05.620
Or you add one hour, like one minute to right before that you'll get, or you add one hour

00:32:05.620 --> 00:32:10.760
and one minute in such a way that it spans that you'll get something that is nominally

00:32:10.760 --> 00:32:12.340
one hour and one minute away.

00:32:12.340 --> 00:32:15.420
But in fact, two minutes have elapsed, something like that.

00:32:15.420 --> 00:32:15.700
Right.

00:32:15.700 --> 00:32:16.040
Okay.

00:32:16.040 --> 00:32:17.900
So that surprises people.

00:32:17.900 --> 00:32:22.980
I think it tends to surprise people more on certain scales, like for very short time scales,

00:32:22.980 --> 00:32:25.000
one minute, two minutes, something like that.

00:32:25.240 --> 00:32:29.520
You're like, why isn't this working exactly as I expect when it's like one day, you're

00:32:29.520 --> 00:32:32.920
usually trying to just get the same time the next day, something like that.

00:32:32.920 --> 00:32:35.300
I don't know that there's a great solution to that.

00:32:35.300 --> 00:32:39.420
One thing that I would kind of like to do, and I don't know that there's any way to do it

00:32:39.420 --> 00:32:45.660
without breaking backwards compatibility is to separate out the concept of like a calendrical

00:32:45.660 --> 00:32:50.440
delta and an absolute delta, which is like, give me this elapsed period of time.

00:32:50.680 --> 00:32:54.160
You can certainly add a type that represents elapsed times.

00:32:54.160 --> 00:32:59.380
And then when you add it to a daytime, it converts the daytime to UTC, does the addition

00:32:59.380 --> 00:33:00.660
and then converts back.

00:33:00.660 --> 00:33:07.380
But the issue there is that what you'd really want is you'd really want the results of those

00:33:07.380 --> 00:33:13.940
interzone subtractions to return those elapsed time, you know, elapsed time time deltas, because

00:33:13.940 --> 00:33:15.220
that's actually what's happening.

00:33:15.220 --> 00:33:17.460
You know, you're actually getting an elapsed time time delta.

00:33:17.560 --> 00:33:22.340
So if you take something that's like something in America Chicago minus something in America

00:33:22.340 --> 00:33:25.080
New York, you'll get the absolute exact time.

00:33:25.080 --> 00:33:29.520
And then if you add that to America New York and then convert the result back to America

00:33:29.520 --> 00:33:33.820
Chicago, you might get a different value than the value that you started with.

00:33:33.820 --> 00:33:38.320
So like that property is something that you would expect to be true.

00:33:38.320 --> 00:33:38.660
Right.

00:33:38.660 --> 00:33:44.140
That item potency of like, if I change it this way and then I change it back or that sort of

00:33:44.140 --> 00:33:48.520
additive identity or whatever you call it there that like I make this change and I undo that

00:33:48.520 --> 00:33:48.920
change.

00:33:48.920 --> 00:33:52.100
It would be weird if it's like not back to where it started and stuff.

00:33:52.100 --> 00:33:52.280
Right.

00:33:52.280 --> 00:33:52.540
Yeah.

00:33:52.540 --> 00:33:58.120
So, I mean, in that very particular edge case, it is a little bit lossy and I would really

00:33:58.120 --> 00:33:59.720
like it if there were a bit that I could add.

00:34:00.020 --> 00:34:07.060
And maybe you could like maybe everyone who is seeing this behavior is expecting the that

00:34:07.060 --> 00:34:09.040
like reversible transformation.

00:34:09.040 --> 00:34:13.120
And basically, we would just be fixing a bug for every single person.

00:34:13.120 --> 00:34:18.060
But there may be people like you always hate to punish people who figured out the right thing

00:34:18.060 --> 00:34:19.460
to do and then did it.

00:34:19.460 --> 00:34:22.340
And then you just like change what the right thing to do is out from under them.

00:34:22.340 --> 00:34:22.640
Yeah.

00:34:22.840 --> 00:34:27.160
Once you've kind of put it in place, then it's really hard to change it.

00:34:27.160 --> 00:34:27.280
Right.

00:34:27.280 --> 00:34:27.960
I mean, you're kind of stuck.

00:34:27.960 --> 00:34:28.180
Yeah.

00:34:28.180 --> 00:34:29.740
I mean, that's the story of my life.

00:34:29.740 --> 00:34:34.760
But you make slow and steady changes and you break things only when you absolutely have

00:34:34.760 --> 00:34:35.000
to.

00:34:35.000 --> 00:34:39.340
And hopefully you get a reputation for not breaking things just willy nilly.

00:34:39.340 --> 00:34:43.520
And people take you seriously when you say, hey, we really want to break all your stuff

00:34:43.520 --> 00:34:44.120
today.

00:34:44.120 --> 00:34:44.500
Yeah.

00:34:44.720 --> 00:34:49.920
Well, I think that that's actually one of the reasons that Python is going so strong.

00:34:49.920 --> 00:34:50.400
Right.

00:34:50.400 --> 00:34:52.940
You know, JavaScript is going strong as well.

00:34:52.940 --> 00:34:58.580
But the challenge with JavaScript is like I spent all the time learning Angular and then

00:34:58.580 --> 00:35:02.100
they threw away Angular 1 and they rewrote the API and they switched it to TypeScript.

00:35:02.100 --> 00:35:03.060
So I got to start over.

00:35:03.060 --> 00:35:06.400
Or, you know, like pick your framework du jour.

00:35:06.400 --> 00:35:10.720
Like the stability of those things or the life cycle of those things is so short.

00:35:11.040 --> 00:35:15.200
And, you know, the fact that you don't have to keep changing because your dependencies or

00:35:15.200 --> 00:35:15.840
whatever changed.

00:35:15.840 --> 00:35:18.700
That's like dependency being Python potentially.

00:35:18.700 --> 00:35:20.940
That's a really good feature, I think.

00:35:20.940 --> 00:35:21.180
Yeah.

00:35:21.180 --> 00:35:27.200
I think sometimes also things have a short, tend to have a short shelf life in some situations

00:35:27.200 --> 00:35:30.840
because people want to break a whole bunch of stuff.

00:35:30.840 --> 00:35:36.320
And I guess I'm just glad that we have maintainers around who are willing to kind of put in the

00:35:36.320 --> 00:35:41.020
work for the long haul to make it so that, you know, hey, this thing is still

00:35:41.020 --> 00:35:44.740
supported and you don't have to migrate to a new framework every 30 minutes.

00:35:44.740 --> 00:35:45.080
Yeah.

00:35:45.080 --> 00:35:49.620
So one thing about daytimes that I want to ask, sorry, time deltas that I want to ask you

00:35:49.620 --> 00:35:55.700
about because it drives me crazy is I find myself doing math way more than I think I should with

00:35:55.700 --> 00:35:56.680
time deltas.

00:35:56.680 --> 00:36:02.160
For example, if I have a time delta and I want to know how many days that that time delta

00:36:02.160 --> 00:36:04.980
represents, that's a math problem for me, right?

00:36:05.100 --> 00:36:13.980
It has a day's operation, a day's property or field, but it gives me unusual answers in some sense and not a

00:36:13.980 --> 00:36:15.660
fraction of days, right?

00:36:15.660 --> 00:36:21.240
So if I have something that's 30 seconds, I would like it to be whatever that is, like one one hundredth of a day.

00:36:21.540 --> 00:36:24.540
Or I would like to be able to ask, how many hours are there?

00:36:24.540 --> 00:36:25.580
How many weeks?

00:36:25.580 --> 00:36:26.600
You can do that.

00:36:26.600 --> 00:36:27.440
Months and stuff starts to get hard.

00:36:27.440 --> 00:36:28.120
Okay.

00:36:28.120 --> 00:36:29.180
How do I do it?

00:36:29.180 --> 00:36:31.840
Because all I know about is total seconds, for example.

00:36:31.840 --> 00:36:35.980
And then there's seconds and then there's microseconds and there's days.

00:36:35.980 --> 00:36:43.260
Those accessors, like the days, seconds, microseconds thing, those are actually, time delta is essentially

00:36:43.260 --> 00:36:49.480
supposed to be like a struct type object that just like holds a time delta, you know, and it has three

00:36:49.480 --> 00:36:54.460
canonical components, which is days, microseconds, days, seconds and microseconds.

00:36:54.460 --> 00:36:59.560
I understand that it's confusing that those accessors are like not the total number of days.

00:36:59.560 --> 00:37:02.440
The way you're actually supposed to, this was added in Python 3.

00:37:02.440 --> 00:37:06.620
The way you're supposed to get this information is time deltas can just be divided by other

00:37:06.620 --> 00:37:07.180
time deltas.

00:37:07.180 --> 00:37:11.740
So if you just have like a time delta and you want to know how many days there are, you just

00:37:11.740 --> 00:37:13.580
divide it by time delta days equals one.

00:37:13.580 --> 00:37:14.240
Oh, interesting.

00:37:14.240 --> 00:37:20.880
So instead of going total seconds divided by 60, divided by 60, divided by 24, I would say

00:37:20.880 --> 00:37:23.740
dt divided by time delta days equals one.

00:37:23.740 --> 00:37:24.000
Yeah.

00:37:24.000 --> 00:37:27.760
And you can just have any arbitrary value as the denominator there.

00:37:27.760 --> 00:37:32.420
So it's actually, this is one of those situations where it's like not super discoverable,

00:37:32.420 --> 00:37:33.740
but it's incredibly elegant.

00:37:33.740 --> 00:37:34.060
Yeah.

00:37:34.060 --> 00:37:39.200
And like you can, the fact that time, that total seconds even exists is a problem.

00:37:39.200 --> 00:37:44.340
Well, it's not a problem, but it highlights this fact that it's not super discoverable because

00:37:44.340 --> 00:37:50.600
the, when they added total seconds, they had already added the ability to divide by, they

00:37:50.600 --> 00:37:54.800
had already solved this problem by adding the, by defining a dunder div.

00:37:54.800 --> 00:37:55.100
Yeah.

00:37:55.200 --> 00:37:59.320
And one core developer didn't know about that and added total seconds.

00:37:59.320 --> 00:38:03.720
And then the guy who was, you know, maintaining daytime showed up after it was all merged and

00:38:03.720 --> 00:38:05.740
stuff and was like, oh, I wish I had seen this before.

00:38:05.740 --> 00:38:07.280
I would have said, please don't add this.

00:38:07.280 --> 00:38:07.500
Yeah.

00:38:07.500 --> 00:38:10.460
So, you know, every once in a while we get people who show up and they're like, can we

00:38:10.460 --> 00:38:12.360
get total microseconds and total whatever?

00:38:12.360 --> 00:38:17.720
And it's like, we don't want to make 40 different, you know, things that say quarters and months

00:38:17.720 --> 00:38:19.000
and years and things like that.

00:38:19.000 --> 00:38:24.120
Like just, you just have to divide it by a time delta and it works super well, especially

00:38:24.120 --> 00:38:28.880
now that increasingly you are, people are working in Python three only code bases.

00:38:28.880 --> 00:38:33.980
If you have a two, three compatible code base, you generally do have to like do total seconds

00:38:33.980 --> 00:38:37.640
and then divide that by total seconds of whatever your time delta is.

00:38:37.640 --> 00:38:37.900
Gotcha.

00:38:37.900 --> 00:38:38.720
Okay.

00:38:38.720 --> 00:38:39.420
Interesting.

00:38:39.420 --> 00:38:39.680
Yeah.

00:38:39.680 --> 00:38:44.640
Cause I was hoping there would be a total minutes, total hours, total days, and it could

00:38:44.640 --> 00:38:47.400
just do that math that I talked about just in line.

00:38:47.400 --> 00:38:47.660
Right.

00:38:47.660 --> 00:38:51.940
And like, just so I don't have, so I could be more expressive and not do like a long series

00:38:51.940 --> 00:38:52.560
of divisions.

00:38:52.560 --> 00:38:53.860
You certainly can do that.

00:38:53.860 --> 00:38:59.900
Like, I can understand why you would want that, I suppose, but then, you know, you only

00:38:59.900 --> 00:39:03.320
have the enumerated units that, that are in there.

00:39:03.320 --> 00:39:07.060
And it also sort of hides the fact that you can just do regular division.

00:39:07.060 --> 00:39:13.960
I mean, you don't have a dozens method on, on integers to find out how many times 12 evenly

00:39:13.960 --> 00:39:14.640
divides in it.

00:39:14.640 --> 00:39:16.480
You know, it's a fair point.

00:39:16.580 --> 00:39:19.440
I think that's the discoverability that is the challenge, right?

00:39:19.440 --> 00:39:23.680
To know that you can actually do the division and it'll, cause now you say it like, sure,

00:39:23.680 --> 00:39:27.520
it makes total sense to say, I want to know how many whole weeks are in there.

00:39:27.520 --> 00:39:29.980
So I would say time delta days equals seven and then divide it.

00:39:29.980 --> 00:39:31.240
And that would give me a great answer.

00:39:31.240 --> 00:39:31.480
Right.

00:39:31.480 --> 00:39:33.080
And I can pick my units to be whatever.

00:39:33.080 --> 00:39:35.020
You can also do weeks equals one.

00:39:35.020 --> 00:39:35.300
Yeah.

00:39:35.300 --> 00:39:35.900
Yeah.

00:39:35.900 --> 00:39:36.020
Yeah.

00:39:36.020 --> 00:39:36.580
Weeks equals one.

00:39:36.580 --> 00:39:36.780
Sure.

00:39:36.780 --> 00:39:41.260
So there's a lot of flexibility there, but yeah, it's just, I don't see a lot of examples

00:39:41.260 --> 00:39:45.180
using that, you know, when you look around at code stuff.

00:39:45.180 --> 00:39:47.040
That's partly because people don't see it.

00:39:47.040 --> 00:39:51.520
And partly because anything that a lot of the code that we look at now, especially open source

00:39:51.520 --> 00:39:55.420
code has been two, three compatible for like the past five or 10 years or something.

00:39:55.420 --> 00:39:58.500
And that idiom is not available in Python two.

00:39:58.760 --> 00:40:02.380
So Python three, when you're Python three only, you know, it's kind of like you're starting

00:40:02.380 --> 00:40:03.420
to see f-strings everywhere.

00:40:03.420 --> 00:40:07.080
Hopefully all the cool kids now are just dividing their time deltas.

00:40:07.080 --> 00:40:10.220
Well, they will be now, now that they hear about it on the podcast.

00:40:10.220 --> 00:40:10.540
Yeah.

00:40:10.540 --> 00:40:16.360
I thought you were going to say the thing about how the rapper and the stir, like the

00:40:16.360 --> 00:40:19.580
string cast of time deltas is just absolute trash.

00:40:19.580 --> 00:40:21.580
Like I really wish I could fix that.

00:40:21.580 --> 00:40:27.320
I think it's going to be difficult to do so, but it's like, if you print a time delta that

00:40:27.320 --> 00:40:33.820
is negative one hour, it tells you one day minus 23 hours or tells it to you in seconds.

00:40:33.820 --> 00:40:34.180
Yeah.

00:40:34.180 --> 00:40:35.640
The internal reputation is weird.

00:40:35.640 --> 00:40:38.800
Like so for, I do that for one that is one second long.

00:40:38.800 --> 00:40:43.240
It's negative one day, 23 hours, 59 minutes and 59 seconds.

00:40:43.240 --> 00:40:45.900
If it has like a negative one second or something in it.

00:40:45.900 --> 00:40:46.060
Yeah.

00:40:46.060 --> 00:40:49.260
It's, you know, it computes to the same, but it's not very human.

00:40:49.260 --> 00:40:49.720
Yeah.

00:40:49.720 --> 00:40:52.200
I would probably do it a different way.

00:40:52.200 --> 00:40:56.360
I would probably do it as like negative and then abs, like an absolute value.

00:40:56.360 --> 00:41:00.940
I think they're worried about some ambiguity there, but I don't think anyone ever wants

00:41:00.940 --> 00:41:01.820
what we got.

00:41:01.820 --> 00:41:02.580
So yeah.

00:41:02.580 --> 00:41:08.740
You've given like 99.99% of people something they don't want to avoid a tiny bit of possible

00:41:08.740 --> 00:41:09.180
ambiguity.

00:41:09.180 --> 00:41:09.620
It's right.

00:41:09.620 --> 00:41:09.980
Yeah.

00:41:09.980 --> 00:41:11.020
What are you going to do?

00:41:11.020 --> 00:41:15.640
Well, so let's talk a little bit about some of the peps here.

00:41:15.640 --> 00:41:19.400
So you've got pep495 and that one, is that one already done?

00:41:19.400 --> 00:41:20.680
That one's already done.

00:41:20.680 --> 00:41:21.120
Yeah.

00:41:21.120 --> 00:41:27.380
So pep495 was implemented for Python 3.6 and that adds the fold attribute.

00:41:27.380 --> 00:41:33.820
The background of this is that prior to Python 3.6 time zone support was not super great.

00:41:34.060 --> 00:41:39.800
Basically, whenever you have an offset change that where the offset decreases, that means

00:41:39.800 --> 00:41:43.820
that you are jumping back by an hour or by any amount.

00:41:43.820 --> 00:41:45.520
And that creates an ambiguity, right?

00:41:45.520 --> 00:41:49.060
So it's two o'clock and then you jump back one hour.

00:41:49.060 --> 00:41:50.240
Hopefully it's two o'clock.

00:41:50.480 --> 00:41:56.560
I actually found one place in, I think in Argentina in 1992, their daylight saving time

00:41:56.560 --> 00:42:00.300
transition happened at midnight on February 29th.

00:42:00.300 --> 00:42:03.180
Cause it wasn't bad enough to do it at midnight with that ambiguity.

00:42:03.180 --> 00:42:04.800
They also had to do it during leap day.

00:42:04.800 --> 00:42:07.480
So my goodness.

00:42:07.480 --> 00:42:07.820
Yeah.

00:42:07.820 --> 00:42:11.740
So it's like, anyway, so you do something like that, right?

00:42:11.740 --> 00:42:18.760
And so instead of it being February 29th or March 1st, it's now February 29th and at

00:42:18.760 --> 00:42:20.400
11 PM a second time.

00:42:20.400 --> 00:42:25.880
So the way time zone handling works in daytime is, is, is actually quite elegant.

00:42:25.880 --> 00:42:32.400
The idea is that you attach because a time zone represents a set of rules for like taking

00:42:32.400 --> 00:42:39.420
the current for mapping between absolute times, like time and UTC and local time.

00:42:39.420 --> 00:42:41.740
Like what time does it say on the clock?

00:42:41.740 --> 00:42:47.480
So I think the original design intent was that you would have a TZ info and the TZ info has

00:42:47.480 --> 00:42:52.140
these functions that you can call that give you information about the time zone as a function

00:42:52.140 --> 00:42:53.280
of the daytime.

00:42:53.280 --> 00:42:54.640
So it's super great.

00:42:54.640 --> 00:42:59.960
You just write this function that maps your daytime to UTC and you're done.

00:42:59.960 --> 00:43:04.220
Except that the daytime portion is sometimes ambiguous, right?

00:43:04.220 --> 00:43:11.660
So if it's 1992 and it's 1130 in Argentina on February 29th, there are two different offsets.

00:43:11.660 --> 00:43:14.600
There's two different sets of information that you could apply there.

00:43:14.600 --> 00:43:19.180
And there's no function that you can write that just takes the naive portion of that daytime

00:43:19.180 --> 00:43:22.440
and gives you the correct offset because it's ambiguous.

00:43:22.880 --> 00:43:29.000
So the way PyTZ solved this problem was that they added this localized concept where what

00:43:29.000 --> 00:43:33.780
they do is they, you create a time zone and then instead of just like attaching it directly,

00:43:33.780 --> 00:43:35.460
you have to call localize on it.

00:43:35.460 --> 00:43:40.500
And what PyTZ will do is it'll just attach a dedicated fixed time zone offset.

00:43:40.500 --> 00:43:45.540
So it has a little switch in there where you can say, do I want to be on the daylight saving

00:43:45.540 --> 00:43:47.040
time side or the other side?

00:43:47.140 --> 00:43:52.140
This is a major source of bugs because people will just do what the docs say and attach PyTZ

00:43:52.140 --> 00:43:57.280
time zones directly to the TZ info instead of letting PyTZ do it itself.

00:43:57.280 --> 00:44:02.680
And also it kind of circumvents a lot of the other logic in there about a lot of assumptions

00:44:02.680 --> 00:44:06.880
about like you're just supposed to have this one set of rules, not a fixed set of offsets.

00:44:06.880 --> 00:44:11.940
And then it's also a bit of a problem because they specifically use DST, but there are situations

00:44:11.940 --> 00:44:15.500
where you have transitions that are not due to daylight saving time.

00:44:15.500 --> 00:44:18.600
Like someone just switches their base offset or something.

00:44:18.600 --> 00:44:21.440
So that's where PEP495 came in.

00:44:21.440 --> 00:44:25.340
They, what they did was they said, we're just going to take the naive portion of the date

00:44:25.340 --> 00:44:28.860
time and we're going to add an additional component to it called fold.

00:44:28.860 --> 00:44:31.200
And I can take two values, zero or one.

00:44:31.200 --> 00:44:36.440
The zero represents the first, the offset that happened before the transition.

00:44:36.440 --> 00:44:39.520
And then after the transition, you put fold equals one.

00:44:39.520 --> 00:44:40.700
It's very elegant.

00:44:40.700 --> 00:44:45.780
It allows you to write time zones that just take the naive portion of the daytime and then

00:44:45.780 --> 00:44:48.940
just flip a switch if it's ambiguous based on the fold.

00:44:48.940 --> 00:44:49.300
Okay.

00:44:49.300 --> 00:44:49.760
Yeah.

00:44:49.760 --> 00:44:50.540
That's, that's cool.

00:44:50.540 --> 00:44:51.140
Yeah.

00:44:51.140 --> 00:44:52.740
Just catching these little edge cases.

00:44:52.740 --> 00:44:56.280
And then PEP615 you're working on as well.

00:44:56.280 --> 00:44:57.620
And this one's in 3.9.

00:44:57.620 --> 00:45:01.260
So I guess in a sense it's accepted because 3.9's in its beta world.

00:45:01.440 --> 00:45:01.760
Yeah.

00:45:01.760 --> 00:45:04.060
It was accepted and we merged it.

00:45:04.060 --> 00:45:06.440
So it's going to be, you can get it in the betas now.

00:45:06.440 --> 00:45:07.580
You can actually get it.

00:45:07.580 --> 00:45:13.300
I have a backport of it implemented back all the way to Python 3.6.

00:45:13.300 --> 00:45:14.480
It works in PyPy.

00:45:14.480 --> 00:45:19.620
I've tried to make it, you know, my goal here is basically that I would really, really like

00:45:19.620 --> 00:45:21.800
it if people could stop using PyTZ.

00:45:22.080 --> 00:45:25.620
I think the maintainer of PyTZ would also agree with me on that.

00:45:25.620 --> 00:45:29.880
It's basically PyTZ was sort of a hack around this issue.

00:45:29.880 --> 00:45:31.720
They did a really great job on it.

00:45:31.720 --> 00:45:36.520
Like, I think, I don't know that there's a better way to have done that, but well, you

00:45:36.520 --> 00:45:40.820
know, other than just coming up with this fold idea yourself and that has its own problems.

00:45:40.820 --> 00:45:46.760
In DateUtil, I also have a backport of PEP495 that works in 2.7.

00:45:47.360 --> 00:45:53.180
So even if you have a Python 2.7 implementation with some combination of the zone info module,

00:45:53.180 --> 00:46:00.040
which was added in PEP615 and DateUtil, you can actually get proper PEP495 support all

00:46:00.040 --> 00:46:02.300
the way back to Python 2.7.

00:46:02.300 --> 00:46:07.080
And yeah, you know, there's a bunch of reasons why you should use zone info.

00:46:07.080 --> 00:46:12.780
One is obviously, you know, I think it's enough of a selling point to just say, you don't have

00:46:12.780 --> 00:46:14.340
to do this localized, normalized stuff.

00:46:14.500 --> 00:46:18.680
Like you can just use time zones like they were meant to use and it'll just work.

00:46:18.680 --> 00:46:26.200
But there's also the fact that PyTZ doesn't have any support for the version 2.tzif files.

00:46:26.200 --> 00:46:32.100
So the INA, the compiled versions of the INA time zone, they're all version 2 or 3 now,

00:46:32.100 --> 00:46:33.400
like since 2005.

00:46:33.400 --> 00:46:39.460
And version 2 and 3 is when they switched from using 4 byte integers to 8 byte.

00:46:39.680 --> 00:46:44.760
So each time zone now starts with version 1 file, like the entire version 1 file.

00:46:44.760 --> 00:46:47.120
And then after that, they have the version 2 file.

00:46:47.120 --> 00:46:51.920
So all the stuff that supports version 1 files only still works with your version 2 and 3 files.

00:46:51.920 --> 00:46:55.700
But version 2 and 3 files will go past 2038.

00:46:55.700 --> 00:47:01.420
And they, instead of just like stopping at some point, they also have like a general rule.

00:47:01.660 --> 00:47:05.980
So they'll say like, here's the rule for transitions after 2038.

00:47:05.980 --> 00:47:06.340
Right.

00:47:06.340 --> 00:47:08.980
We don't have data for this, but here's how it has been.

00:47:08.980 --> 00:47:10.440
So just keep computing it like this.

00:47:10.440 --> 00:47:10.660
Yeah.

00:47:10.660 --> 00:47:16.400
I mean, the further into the future and actually the further into the past, like the distant past,

00:47:16.400 --> 00:47:21.380
like just like what was the time is significantly less meaningful question to ask.

00:47:21.620 --> 00:47:33.580
So right now, you know, what time zone, like what is the UTC for New York in 2040 is not a terribly like gazing into a crystal ball, right?

00:47:33.580 --> 00:47:34.240
It's right.

00:47:34.240 --> 00:47:35.220
You can have a guess.

00:47:35.220 --> 00:47:39.960
It's probably a better guess than randomly choosing, but it's not going to be accurate.

00:47:39.960 --> 00:47:47.760
Like it's not, it might be a bit of an XY problem if you're asking that question, but you know, it's still like, at least it'll do what you expect.

00:47:47.760 --> 00:47:55.640
But as time goes on in the next 10 years, in the next 15 years, we're getting a lot closer to 2038.

00:47:55.640 --> 00:47:57.980
You're going to need that kind of support.

00:47:57.980 --> 00:47:58.260
Right.

00:47:58.260 --> 00:48:00.460
So PyTZ doesn't have support for that.

00:48:00.460 --> 00:48:02.720
It doesn't have support for sub-minute offsets.

00:48:03.040 --> 00:48:12.360
Another thing that ZoneInfo does and DateUtil does, but PyTZ does not do, is that they will hit your system time zone information first.

00:48:12.360 --> 00:48:14.540
So there's a way to configure it.

00:48:14.540 --> 00:48:16.680
They have their own access to time zone.

00:48:16.680 --> 00:48:23.860
They have their own time zone data in a sense that you can get if your system time zone data, if your system doesn't provide time zones.

00:48:23.860 --> 00:48:28.240
And there are mechanisms for specifying where you want to get the time zone data from.

00:48:28.240 --> 00:48:32.500
But with PyTZ, it ships the time zone data with it.

00:48:32.500 --> 00:48:35.860
So you have to keep your PyTZ up to date just to get the data updates.

00:48:35.860 --> 00:48:43.620
There's a way to change that where I think you like set an environment variable and tell it where your system time zones are.

00:48:43.620 --> 00:48:47.460
And it will use that instead of its own thing.

00:48:47.460 --> 00:48:49.480
But you have to know where your stuff is.

00:48:49.480 --> 00:48:52.800
Whereas with ZoneInfo, it's built in.

00:48:52.800 --> 00:48:54.800
So it'll find it in the most common places.

00:48:54.800 --> 00:49:01.960
And then there's a mechanism for the person who distributes Python to you to tell the compiler where it's going to be.

00:49:01.960 --> 00:49:07.240
So if you use some system Python, it'll always hit your system time zone, which is very helpful.

00:49:07.240 --> 00:49:10.360
So, you know, there's all those reasons to not use PyTZ.

00:49:10.360 --> 00:49:11.060
Yeah.

00:49:11.060 --> 00:49:13.960
There's still reasons why you might be worried about switching over.

00:49:14.120 --> 00:49:25.440
Like, for example, since PyTZ has its own weird interface, you know, there's going to be a lot of your users possibly who've taken your TZ info and they've called localize or normalize on some date time.

00:49:25.680 --> 00:49:29.220
And if you change over from PyTZ, it's going to break all of them.

00:49:29.220 --> 00:49:32.120
But I am aware of this kind of thing.

00:49:32.120 --> 00:49:46.920
So I've also created a library called PyTZ deprecation shim, which is just a thin wrapper around ZoneInfo, except that it supports the PyTZ interface as close to the semantics that PyTZ has as possible.

00:49:47.440 --> 00:49:51.420
And then it just raises a warning if anyone's doing anything PyTZ specific.

00:49:51.420 --> 00:49:55.220
So it just works like a regular 495 thing.

00:49:55.220 --> 00:49:58.180
It works in 2.7 and 3.6 onwards.

00:49:58.720 --> 00:50:02.840
And if anyone's, like, using localize or normalize or whatever, it'll raise a warning.

00:50:02.840 --> 00:50:10.600
So you can basically say, oh, for the next two years, I'm going to depend on PyTZ deprecation shim, and then I'm going to drop it in favor of ZoneInfo.

00:50:10.600 --> 00:50:14.300
And hopefully everyone has not been ignoring all my warnings.

00:50:14.300 --> 00:50:16.160
Yeah, that's good.

00:50:16.160 --> 00:50:17.880
It's really nice to have that warning there.

00:50:17.880 --> 00:50:20.140
So it gives you some time to deal with it.

00:50:20.140 --> 00:50:25.840
All right, Paul, we talked about a lot of different things, a lot of interesting edge cases and scenarios.

00:50:26.380 --> 00:50:34.060
Maybe give us the main takeaways, like, if you could give people listening some advice on the please do and please don't with time in Python, what would you say?

00:50:34.060 --> 00:50:38.100
Yeah, so for don'ts, I actually have a couple of blog articles about this.

00:50:38.100 --> 00:50:44.460
Like, one of the things I see the most often is people using UTC now thinking like, oh, I want something in UTC.

00:50:44.460 --> 00:50:49.520
But UTC now and UTC from timestamp are not something you should be using in modern Python.

00:50:49.520 --> 00:50:51.280
I would like to remove them.

00:50:51.460 --> 00:50:55.440
But there are, like, occasionally these situations where they're useful.

00:50:55.440 --> 00:51:07.000
Like, if you're immediately trying to, if you're just using UTC now to, and then dumping it right into ISO format, and you don't want the, like, the UTC offset in there.

00:51:07.000 --> 00:51:07.280
Right.

00:51:07.280 --> 00:51:09.240
It's not a super great way to do that.

00:51:09.240 --> 00:51:11.120
I might just bite the bullet and deprecate those.

00:51:11.340 --> 00:51:15.680
And then maybe, you know, have a wrapper function for it in dateutil.

00:51:15.680 --> 00:51:19.140
But for the most part, you don't want to use UTC now.

00:51:19.140 --> 00:51:27.900
You should use just daytime.now and then pass it the daytime.timezone.utc object, which is just a UTC singleton that's in a standard library.

00:51:27.900 --> 00:51:30.300
Also, I don't think you should use PyTZ.

00:51:30.300 --> 00:51:35.180
I think you should take all your PyTZ code and migrate it over to zone info or dateutil.

00:51:35.560 --> 00:51:38.240
And start getting on the PEP495 bandwagon.

00:51:38.240 --> 00:51:41.000
And I've got a little migration guide for that.

00:51:41.000 --> 00:51:41.260
Nice.

00:51:41.260 --> 00:51:43.160
We can put the links to those in the show notes.

00:51:43.160 --> 00:51:50.000
Now, I just want to do, maybe acknowledge a couple of libraries that are on the outside of CPython, but still pretty helpful.

00:51:50.000 --> 00:51:53.100
And the first one actually is Python-DateUtil.

00:51:53.100 --> 00:51:54.020
That one's yours, right?

00:51:54.020 --> 00:51:54.500
Yeah.

00:51:54.500 --> 00:51:57.860
So I didn't write that, but I've been maintaining it for about six years.

00:51:58.100 --> 00:51:59.460
That's got some interesting stuff.

00:51:59.460 --> 00:52:06.860
Even after PEP615, the timezone module does still have some useful timezones in it.

00:52:06.860 --> 00:52:09.660
Like it has, well, you know, I say useful.

00:52:09.660 --> 00:52:16.060
What I mean is like available, like different types of timezones that are not in the standard library.

00:52:16.060 --> 00:52:17.940
So like there's this TZiCal.

00:52:18.600 --> 00:52:24.040
If you have timezones in this iCalendar RFC format, dateutil will handle that.

00:52:24.040 --> 00:52:26.980
And you can also like use like these POSIX strings.

00:52:26.980 --> 00:52:35.540
Like if you ever see like EST5 EDT and then like a, there's a POSIX standard for expressing recurring DST transitions.

00:52:35.540 --> 00:52:39.480
So it has that and some Windows specific stuff as well.

00:52:39.640 --> 00:52:42.920
You know what I use it for that I really like is its parse.

00:52:42.920 --> 00:52:48.980
Its parsing is really good because it seems like it generally just handles time strings, which is great.

00:52:48.980 --> 00:52:49.220
Yeah.

00:52:49.220 --> 00:52:54.100
The parser is the part that I like the least, but that's mainly, I mean, because I have to maintain it.

00:52:54.100 --> 00:52:56.800
And it's got so many rules that it's super easy to break.

00:52:56.800 --> 00:53:01.980
So anytime someone shows me something where it's broken, it's like, I'm really afraid to change anything.

00:53:01.980 --> 00:53:06.720
Because if I do, it'll break someone else's use case that they've been using it for like 10 years.

00:53:06.720 --> 00:53:08.900
It's also like pretty slow.

00:53:09.440 --> 00:53:21.200
So it's super useful if you have something that you know is a date time and it's in a pretty standard format and you just want it to like chew at it until it finds something that looks like a date time.

00:53:21.200 --> 00:53:24.060
But it could be chewing for like 200 microseconds.

00:53:24.060 --> 00:53:34.520
If you have something that's in ISO 8601 format, dateutil also has ISO parse, which will handle anything that's in a valid ISO 8601 format.

00:53:35.060 --> 00:53:42.180
And then date time, I think the first thing I added to CPython was from ISO format, which is like the inverse of ISO format.

00:53:42.180 --> 00:53:43.100
Okay.

00:53:43.100 --> 00:53:43.720
That's cool.

00:53:43.720 --> 00:53:44.740
That's on date time.

00:53:44.740 --> 00:53:45.920
It's got our rule.

00:53:45.920 --> 00:53:49.820
Dateutil also has our rule for recurrence rules, which are very useful.

00:53:50.060 --> 00:53:55.680
It has relative delta if you want to do time deltas, but include years and months and things like that.

00:53:55.680 --> 00:53:59.280
And the best one I saved for last is Easter.

00:53:59.280 --> 00:54:01.000
It just tells you when Easter is.

00:54:01.000 --> 00:54:04.500
You give it a year and it's like, this is when Easter is.

00:54:04.680 --> 00:54:05.040
Oh, that's cool.

00:54:05.040 --> 00:54:05.580
Yeah.

00:54:05.580 --> 00:54:13.280
There's a couple of different holidays and stuff that are all sorts of all over the place that are tricky, like Hanukkah and stuff.

00:54:13.280 --> 00:54:19.460
So the two others that come to mind, and I'm sure there's like 10 additional libraries that people are out there, let's see.

00:54:19.460 --> 00:54:22.780
But this one, I just don't have them off the top of my head.

00:54:22.780 --> 00:54:24.140
One is called Arrow.

00:54:24.140 --> 00:54:26.000
Are you familiar at all with Arrow?

00:54:26.000 --> 00:54:26.600
Yeah.

00:54:26.600 --> 00:54:26.860
Yeah.

00:54:27.040 --> 00:54:29.260
I've contributed to Arrow a couple of times.

00:54:29.260 --> 00:54:29.640
Yeah.

00:54:29.640 --> 00:54:30.520
It's pretty cool.

00:54:30.520 --> 00:54:36.340
Some of the things, I guess, that stand out to me, like, that got my attention the most is that it has humanized.

00:54:36.340 --> 00:54:38.080
So you can have a time and you say .humanize.

00:54:38.080 --> 00:54:39.200
It'll say an hour ago.

00:54:39.200 --> 00:54:40.580
And you say humanize.

00:54:40.580 --> 00:54:41.020
An hour.

00:54:41.020 --> 00:54:43.620
The locale is Korean or something.

00:54:43.620 --> 00:54:47.200
And then you get the Korean statement of an hour ago and so on.

00:54:47.200 --> 00:54:48.080
And that's pretty easy.

00:54:48.080 --> 00:54:48.860
Pretty nice.

00:54:48.860 --> 00:54:49.200
Yeah.

00:54:49.200 --> 00:54:56.400
I mean, so for stuff like Arrow and Pendulum and Maya and DeLorean and all these things, I've never found a huge amount of use for them.

00:54:56.620 --> 00:55:01.500
But I'm not, like, a huge, like, I don't actually, like, I don't know that I have the exact use cases.

00:55:01.500 --> 00:55:06.480
I tend to write libraries and taking on big dependencies is not the easiest thing for me.

00:55:06.480 --> 00:55:10.120
But I do know that people kind of swear by these libraries.

00:55:10.120 --> 00:55:10.960
They really like them.

00:55:10.960 --> 00:55:13.540
So I think that there's certainly something to them.

00:55:13.540 --> 00:55:21.980
The biggest problem I have with them is that they tend to be, they tend to try and advertise themselves as, like, drop-in replacements for date time.

00:55:21.980 --> 00:55:24.680
And so they then subclass date time and time delta.

00:55:25.260 --> 00:55:32.320
Stuff like Pendulum advertises itself as a drop-in replacement, but then it breaks all the stuff that I want to break, you know.

00:55:32.320 --> 00:55:34.660
So it's not actually a drop-in replacement.

00:55:34.660 --> 00:55:36.740
You can't even construct it the same way.

00:55:36.740 --> 00:55:39.580
And they tend to be slow as well.

00:55:39.580 --> 00:55:44.480
I mean, this is partially because they're not written in C or not mostly written in C.

00:55:44.480 --> 00:55:52.980
But, you know, to do simple time delta arithmetic in Pendulum is, like, 10 times slower than doing the same thing in C.

00:55:52.980 --> 00:55:58.000
But, you know, if you're not handling a huge number of date times, it's probably fine.

00:55:58.000 --> 00:56:01.600
But, of course, you know, we don't have human eyes and things like that in the core.

00:56:01.860 --> 00:56:03.920
I think that those are very useful things.

00:56:03.920 --> 00:56:16.860
I would tend, like, I would love to see a library that is kind of like Pendulum or Arrow, but instead of it being methods on a date time subclass, it's, like, just free functions, you know, utility functions.

00:56:16.860 --> 00:56:17.080
Right.

00:56:17.080 --> 00:56:18.920
You could pass it, built-in items.

00:56:18.920 --> 00:56:19.220
Yeah.

00:56:19.220 --> 00:56:19.840
Yeah.

00:56:19.920 --> 00:56:22.240
I mean, I think that would be faster in a lot of ways.

00:56:22.240 --> 00:56:23.980
Sometimes people don't care about fast.

00:56:23.980 --> 00:56:24.300
Yeah.

00:56:24.300 --> 00:56:24.760
Yeah.

00:56:24.760 --> 00:56:29.480
Well, if you're building a library, especially if you're building CPython itself, it's a different level of concern.

00:56:29.480 --> 00:56:30.020
Yeah.

00:56:30.020 --> 00:56:36.680
If I'm rendering a web page and I've got 10 items and I want, like, the human expression of how long ago they were, I probably don't care.

00:56:36.680 --> 00:56:37.940
Plus, you can benchmark.

00:56:37.940 --> 00:56:38.540
Yeah.

00:56:38.540 --> 00:56:41.720
Like, I can sort of, you can benchmark and see where the bottlenecks are.

00:56:41.720 --> 00:56:53.780
I can't benchmark everything on PyPI and everyone's proprietary code bases and find out, like, you know, do some sort of optimization and find that it's, this is not the bottleneck anywhere that this code is being used.

00:56:53.780 --> 00:56:54.680
Right.

00:56:54.680 --> 00:56:55.440
Exactly.

00:56:55.440 --> 00:56:56.540
It's a different scenario.

00:56:56.540 --> 00:57:02.320
And, yeah, I do find that just using bare date times is useful for interop.

00:57:02.320 --> 00:57:12.680
But if you're mostly working in your own stuff, like, you're just passing it around, doing stuff with it, they do have some, like, you know, people do like it, you know, they really do like the interfaces.

00:57:12.680 --> 00:57:17.920
They like that the time delta things that they give you have total minutes and that they have human errors.

00:57:17.920 --> 00:57:18.400
Right, right.

00:57:18.400 --> 00:57:20.300
Yeah, they got, like, weeks and hours and stuff.

00:57:20.300 --> 00:57:28.300
The thing that stands out as most unique about Pendulum is they have a duration period thing that is aware.

00:57:29.140 --> 00:57:37.120
So I could have a date time span, the subtraction between two date times, the equivalent of a time delta.

00:57:37.120 --> 00:57:42.000
And then you can say in weekdays and then for each thing in the period.

00:57:42.000 --> 00:57:45.740
And it'll give you day one, day two, skip the weekend, day three.

00:57:45.740 --> 00:57:49.900
So, you know, Thursday, Friday, Monday, Tuesday, as a thing you can go.

00:57:49.900 --> 00:57:56.340
So if you're like, well, there's, it's this long, I need to know how many weekdays there are or how many weeks or something in this span.

00:57:56.340 --> 00:57:58.240
That's an interesting concept.

00:57:58.520 --> 00:58:07.380
Like in detail, we have this R rule, which is based on a data type described in RFC 5545 called the recurrence rule.

00:58:07.380 --> 00:58:11.280
And it is super, like, it's a little more complicated than that.

00:58:11.280 --> 00:58:15.160
You know, again, this is why I think these sorts of things could be done as free functions.

00:58:15.160 --> 00:58:16.160
It's very interesting.

00:58:16.160 --> 00:58:21.720
And like, it's a little too complicated for the average person to just sort of jump right into it.

00:58:21.720 --> 00:58:26.320
But you can express all kinds of stuff like that and say, like, how many Tuesdays are there?

00:58:26.320 --> 00:58:32.780
Like one of the talks I give on date you till, I think I say, like, how many times did like the guy who played Mr.

00:58:32.780 --> 00:58:37.640
Miyagi, Pat Morita, like how many times did his birthday fall on a Tuesday during the Vietnam War?

00:58:37.640 --> 00:58:40.840
You know, and I have like a simple R rule that is like standardized.

00:58:41.040 --> 00:58:43.240
You can cast it to a string and pop it into Google Calendar.

00:58:43.240 --> 00:58:45.620
And I can just easily do that with an R rule.

00:58:45.620 --> 00:58:49.960
I say easily, but that's after maintaining an R rule library for use, right?

00:58:49.960 --> 00:58:51.340
Like a random person.

00:58:51.340 --> 00:58:51.360
Right, right.

00:58:51.360 --> 00:58:51.960
But it does it.

00:58:51.960 --> 00:58:52.240
I don't know.

00:58:52.340 --> 00:58:54.460
It's like saying you can find that with a regular expression.

00:58:54.460 --> 00:58:54.800
Yeah.

00:58:54.800 --> 00:58:55.740
Right.

00:58:55.740 --> 00:58:56.040
Yeah.

00:58:56.040 --> 00:58:56.600
Yeah.

00:58:56.600 --> 00:58:58.260
You can easily do that with a regular expression.

00:58:58.260 --> 00:59:00.480
You can easily do that with a regular expression.

00:59:00.480 --> 00:59:03.640
I will struggle with that regular expression, but it's fine.

00:59:03.640 --> 00:59:04.680
But it's powerful.

00:59:04.680 --> 00:59:05.040
It's cool.

00:59:05.040 --> 00:59:05.600
All right.

00:59:05.600 --> 00:59:08.360
Well, I think that's probably it for all the time we have.

00:59:08.360 --> 00:59:12.020
We've run out of time talking about time, but there's been a lot to talk about.

00:59:12.020 --> 00:59:12.600
It's very interesting.

00:59:12.600 --> 00:59:12.900
Thanks.

00:59:12.900 --> 00:59:16.280
So before you go, though, let me ask you the final two questions.

00:59:16.280 --> 00:59:18.860
If you're going to write some Python code, what editor do you use?

00:59:18.860 --> 00:59:23.400
I usually just dictate that to my secretary and just kidding.

00:59:23.400 --> 00:59:23.740
That sounds good.

00:59:23.740 --> 00:59:25.160
I usually use Vim.

00:59:25.160 --> 00:59:26.760
I don't feel strongly about it, though.

00:59:26.760 --> 00:59:31.800
So if anyone wants to, well, don't try and convince me about it, but also don't see that

00:59:31.800 --> 00:59:33.460
it as an attack on your Emacs using Waze.

00:59:33.460 --> 00:59:35.040
Like I just picked one at random.

00:59:35.040 --> 00:59:35.680
Sure.

00:59:35.680 --> 00:59:36.280
Sounds good.

00:59:36.280 --> 00:59:38.380
And then notable PyPI package.

00:59:38.380 --> 00:59:42.400
There's one that's really fun, but please don't like if you install it, do it in a virtual

00:59:42.400 --> 00:59:43.200
environment or something.

00:59:43.200 --> 00:59:44.740
It's called a break my Python.

00:59:45.060 --> 00:59:49.220
You pip install it, and then it just makes it so that your Python is broken.

00:59:49.220 --> 00:59:52.580
Like you can't, you don't have to import it to have your Python be broken.

00:59:52.580 --> 00:59:54.680
You just do pip install break my Python.

00:59:54.680 --> 00:59:57.420
And if you type Python, it won't work anymore.

00:59:57.420 --> 00:59:58.400
It'll just break it.

00:59:58.400 --> 01:00:01.740
That's break dash my dash Python.

01:00:01.740 --> 01:00:02.480
All right.

01:00:02.480 --> 01:00:03.940
So that's kind of an anti-recommendation.

01:00:03.940 --> 01:00:04.440
That's interesting.

01:00:04.440 --> 01:00:04.900
Very cool.

01:00:04.900 --> 01:00:05.940
Funny.

01:00:05.940 --> 01:00:10.360
If you want a real recommendation of something that's like fun and useful to use is I actually

01:00:10.360 --> 01:00:11.340
do like pipX.

01:00:11.340 --> 01:00:11.920
Oh, yeah.

01:00:11.920 --> 01:00:12.900
PipX is cool.

01:00:12.900 --> 01:00:13.720
I love pipX.

01:00:13.720 --> 01:00:13.900
Yeah.

01:00:13.900 --> 01:00:19.720
At this point, my main Python installation, well, my main Python installation stuff is

01:00:19.720 --> 01:00:22.860
like super layered with all kinds of indirection.

01:00:22.860 --> 01:00:27.160
So like everything is all pip and or not pip and pyenv environments.

01:00:27.160 --> 01:00:30.440
So like I have 10 different pythons installed.

01:00:30.440 --> 01:00:33.440
But even within those, I never pip install anything directly.

01:00:33.440 --> 01:00:40.120
It's either like working in a virtual environment or if it's tools like talks or virtual env or

01:00:40.120 --> 01:00:42.120
something like PEP 517.

01:00:42.120 --> 01:00:43.800
Well, actually, that one doesn't really work.

01:00:43.800 --> 01:00:47.780
Like glances or PT Python or any of those types of tools.

01:00:47.780 --> 01:00:48.460
pytest.

01:00:48.460 --> 01:00:49.260
mypy.

01:00:49.260 --> 01:00:49.640
Yep.

01:00:49.640 --> 01:00:49.920
Yep.

01:00:49.920 --> 01:00:50.580
PyLint.

01:00:50.580 --> 01:00:51.560
All that stuff.

01:00:51.560 --> 01:00:53.800
You just do pipX install whatever.

01:00:53.800 --> 01:00:55.520
You do it like you're going to pip install it.

01:00:55.600 --> 01:01:00.220
But what it does is it will install each one of these tools into their own virtual environments

01:01:00.220 --> 01:01:05.140
and then just put on your path the entry points that they expose.

01:01:05.140 --> 01:01:08.260
So you do pipX install mypy.

01:01:08.420 --> 01:01:13.360
And then if you try to like if you open your Python and try and import some mypy like thing,

01:01:13.360 --> 01:01:14.040
it won't be there.

01:01:14.040 --> 01:01:17.560
But if you just type mypy, it'll work as if by magic.

01:01:17.560 --> 01:01:23.160
And this avoids the whole situation of like different tools stepping on each other's dependencies

01:01:23.160 --> 01:01:24.860
or needing to update all that stuff.

01:01:24.860 --> 01:01:25.720
It's really great.

01:01:25.720 --> 01:01:26.580
Yeah, I really like it.

01:01:26.580 --> 01:01:31.860
To me, it feels like homebrew for Python utilities and applications, right?

01:01:31.860 --> 01:01:34.740
Like on my Mac, I can brew install MongoDB.

01:01:34.740 --> 01:01:39.040
I can brew install FFmpeg, all these things that I might need.

01:01:39.040 --> 01:01:41.140
And they'll be installed separately and maintained.

01:01:41.140 --> 01:01:42.440
And you know when there's updates.

01:01:42.440 --> 01:01:46.320
PipX is that for things that are tools based on Python that you would pip install them.

01:01:46.320 --> 01:01:46.940
It's really nice.

01:01:46.940 --> 01:01:50.840
Yeah, I mean, except brew also kind of maybe has that same problem, right?

01:01:50.840 --> 01:01:53.840
Where because it's like a system package manager.

01:01:53.840 --> 01:01:55.280
I mean, they handle it for you.

01:01:55.280 --> 01:01:56.000
Yeah, it's a little more.

01:01:56.000 --> 01:01:57.700
Yeah, it's less isolated.

01:01:57.700 --> 01:01:58.360
Yeah, I agree.

01:01:58.360 --> 01:01:58.760
Yeah.

01:01:58.760 --> 01:01:59.040
Yeah.

01:01:59.040 --> 01:02:01.460
I mean, as long as you're not using your brew Python, right?

01:02:01.500 --> 01:02:05.460
Like if you don't open up Python that you brew installed.

01:02:05.460 --> 01:02:05.900
Exactly.

01:02:05.900 --> 01:02:06.260
Cool.

01:02:06.260 --> 01:02:06.780
All right.

01:02:06.780 --> 01:02:08.400
Well, PipX is a fun recommendation.

01:02:08.400 --> 01:02:11.320
And Breakmypython is a good joke as well.

01:02:11.320 --> 01:02:11.740
All right.

01:02:11.740 --> 01:02:14.020
I'm looking forward to dig into that to see how it actually breaks your Python.

01:02:14.020 --> 01:02:14.700
All right.

01:02:14.700 --> 01:02:16.100
Well, thank you for being here.

01:02:16.100 --> 01:02:17.040
Final call to action.

01:02:17.040 --> 01:02:20.160
People want to get their time zones and time in order.

01:02:20.160 --> 01:02:23.420
I mean, obviously, the recommendations you had, the do's and don'ts stand.

01:02:23.420 --> 01:02:24.840
We'll put a link to those.

01:02:24.840 --> 01:02:26.080
Anything else you want to leave people with?

01:02:26.080 --> 01:02:27.000
I think it's pretty good.

01:02:27.000 --> 01:02:31.680
Like I think I'm very interested in getting people to migrate over to Zone Info.

01:02:31.680 --> 01:02:36.060
So especially right now when there's not a huge number of people knocking at my door

01:02:36.060 --> 01:02:37.820
to ask about that.

01:02:37.820 --> 01:02:42.520
But feel free to, you know, open some issues on there or send me an email or at me on Twitter

01:02:42.520 --> 01:02:42.960
or something.

01:02:42.960 --> 01:02:48.680
And yeah, like get out there and, you know, maybe like tweet or Instagram or TikTok or whatever

01:02:48.680 --> 01:02:52.420
the kids do these days to all your friends about how great PEP615 is.

01:02:52.420 --> 01:02:56.900
And hopefully we can get the word out that you don't have to use PyTZ anymore.

01:02:56.900 --> 01:02:57.600
Yeah, absolutely.

01:02:57.600 --> 01:03:01.220
Well, thanks for working on all this stuff and handling all these edge cases for people.

01:03:01.220 --> 01:03:04.200
That way we can mostly ignore them except for when we can't.

01:03:04.200 --> 01:03:04.360
Yeah.

01:03:04.360 --> 01:03:05.080
Yeah.

01:03:05.080 --> 01:03:05.340
Thanks.

01:03:05.340 --> 01:03:05.780
See you later.

01:03:05.780 --> 01:03:06.080
All right.

01:03:06.080 --> 01:03:06.180
Bye.

01:03:06.180 --> 01:03:10.140
This has been another episode of Talk Python To Me.

01:03:10.320 --> 01:03:14.720
Our guest on this episode was Paul Gansel and it's been brought to you by Brilliant.org

01:03:14.720 --> 01:03:16.960
and us over at Talk Python Training.

01:03:16.960 --> 01:03:21.500
Brilliant.org encourages you to level up your analytical skills and knowledge.

01:03:21.500 --> 01:03:27.540
Visit talkpython.fm/brilliant and get Brilliant Premium to learn something new every day.

01:03:27.540 --> 01:03:29.960
Want to level up your Python?

01:03:29.960 --> 01:03:34.820
If you're just getting started, try my Python Jumpstart by Building 10 Apps course.

01:03:34.820 --> 01:03:39.900
Or if you're looking for something more advanced, check out our new Async course that digs into

01:03:39.900 --> 01:03:42.960
all the different types of async programming you can do in Python.

01:03:42.960 --> 01:03:46.920
And of course, if you're interested in more than one of these, be sure to check out our

01:03:46.920 --> 01:03:47.640
Everything Bundle.

01:03:47.640 --> 01:03:49.520
It's like a subscription that never expires.

01:03:49.520 --> 01:03:51.680
Be sure to subscribe to the show.

01:03:51.680 --> 01:03:54.160
Open your favorite podcatcher and search for Python.

01:03:54.160 --> 01:03:55.300
We should be right at the top.

01:03:55.300 --> 01:04:00.140
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:04:00.140 --> 01:04:04.300
and the direct RSS feed at /rss on talkpython.fm.

01:04:04.300 --> 01:04:06.380
This is your host, Michael Kennedy.

01:04:06.380 --> 01:04:07.880
Thanks so much for listening.

01:04:07.880 --> 01:04:08.920
I really appreciate it.

01:04:09.180 --> 01:04:10.700
Now get out there and write some Python code.

01:04:10.700 --> 01:04:11.700
Bye.

01:04:11.700 --> 01:04:31.700
Thank you.

01:04:31.700 --> 01:05:01.680
Thank you.

