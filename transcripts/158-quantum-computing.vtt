WEBVTT

00:00:00.001 --> 00:00:04.320
You've surely heard of quantum computing and quantum computers. They're based on the often

00:00:04.320 --> 00:00:08.360
non-intuitive nature of very small particles described by quantum mechanics.

00:00:08.360 --> 00:00:13.640
So how do they work and what will they mean for us as a society and as developers? Luckily,

00:00:13.640 --> 00:00:18.220
I have Hannah Sim, a PhD student from Harvard working on quantum algorithms,

00:00:18.220 --> 00:00:23.900
here to give us the full story. This is Talk Python To Me, episode 158, recorded April 17,

00:00:23.900 --> 00:00:25.020
2018.

00:00:25.020 --> 00:00:43.520
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries,

00:00:43.520 --> 00:00:48.320
the ecosystem, and the personalities. This is your host, Michael Kennedy. Follow me on Twitter,

00:00:48.320 --> 00:00:53.240
where I'm @mkennedy. Keep up with the show and listen to past episodes at talkpython.fm,

00:00:53.440 --> 00:00:59.480
and follow the show on Twitter via at talkpython. This episode is brought to you by Linode and

00:00:59.480 --> 00:01:03.720
ActiveState. Check out what they're offering during their segments. It really helps support the show.

00:01:03.720 --> 00:01:05.380
Hannah, welcome to Talk Python.

00:01:05.380 --> 00:01:06.960
Hi, thanks for having me, Michael.

00:01:06.960 --> 00:01:10.840
Yeah, it's really great to have you here. I'm super excited about the topic that we're going to cover,

00:01:10.840 --> 00:01:16.000
quantum computers and a little bit of quantum mechanics even. So that's going to be so fun.

00:01:16.000 --> 00:01:20.320
But before we get into those topics, let's start with your story. How'd you get into programming in

00:01:20.320 --> 00:01:25.520
Python? During my first year of college, I was really trying to decide. I knew I was interested

00:01:25.520 --> 00:01:30.600
in chemistry, but I was, I guess, trying to decide what type of research or lab I wanted to join.

00:01:30.600 --> 00:01:38.440
And I recall really liking the idea of integrating chemistry with computation. And this comes from the

00:01:38.440 --> 00:01:44.300
fact that by using computational chemistry, you can essentially probe what's happening inside a test

00:01:44.300 --> 00:01:49.300
tube or a beaker in lab and really understanding what's happening down at the molecular level.

00:01:49.300 --> 00:01:55.620
Yeah, there's so much that seems almost unknown in chemistry. I mean, we have really, really clear

00:01:55.620 --> 00:02:02.260
models for what it looks like if I throw a ball across the room. But understanding how, say, electrons

00:02:02.260 --> 00:02:07.060
actually interact and stuff, that starts to get a little tricky, right? So these computational

00:02:07.060 --> 00:02:09.160
approximations and stuff become important.

00:02:09.160 --> 00:02:14.480
Exactly. And I guess the project that I was working on in undergrad was using classical molecular

00:02:14.480 --> 00:02:19.340
dynamics. Just because these quantum mechanical calculations are so expensive, we need to make

00:02:19.340 --> 00:02:26.340
these classical approximations. And I use these types of simulations specifically to study protein DNA

00:02:26.340 --> 00:02:27.040
interactions.

00:02:27.040 --> 00:02:32.500
Wow. So you went like really into the hard problems, right? It wasn't like, you know, how does the electron

00:02:32.500 --> 00:02:37.140
move around benzene? But like, let's go for DNA and proteins and stuff like that, right?

00:02:37.140 --> 00:02:42.980
Yeah, I guess they're both very hard problems. It's just coming from it at a different point

00:02:42.980 --> 00:02:43.720
of view, I guess.

00:02:43.720 --> 00:02:44.280
Yeah, yeah.

00:02:44.280 --> 00:02:50.960
Yeah. And I guess at this point, I hadn't taken any formal computing or programming courses. But I just

00:02:50.960 --> 00:02:56.080
kind of more or less taught myself programming in Python just by playing around and scripting and

00:02:56.080 --> 00:02:57.340
using Stack Overflow.

00:02:57.340 --> 00:03:02.120
Yeah, it doesn't matter what skill level you're at, whether you're just getting started or you're

00:03:02.120 --> 00:03:05.500
a complete professional, Stack Overflow will be involved in the process.

00:03:05.500 --> 00:03:07.020
Oh, definitely. Definitely.

00:03:07.020 --> 00:03:11.340
That's really cool. So I'd like to ask you a little bit about this learning to program at this stage,

00:03:11.340 --> 00:03:16.680
because a lot of folks, especially sort of in government and stuff, they'll say, well, we need

00:03:16.680 --> 00:03:22.140
to teach people programming, because programming is an important skill. And I feel like a lot of these

00:03:22.140 --> 00:03:27.560
initiatives are trying to just create more programmers. But you know, here you've come and

00:03:27.560 --> 00:03:31.840
you've learned programming just to solve just basically to be a better chemist, right?

00:03:31.840 --> 00:03:33.000
Exactly. Yeah.

00:03:33.000 --> 00:03:38.140
Yeah, I think it's I think this is a really interesting use case just to kind of highlight or like experience

00:03:38.140 --> 00:03:42.700
the highlight because so many people think, well, we're going to make a bunch of programmers. And I

00:03:42.700 --> 00:03:47.600
think actually, what we need is to make super powered people that do other stuff and superpower them

00:03:47.600 --> 00:03:48.220
with programming.

00:03:48.440 --> 00:03:54.220
Yeah. And especially these days, there are so many available kind of learning platforms you can use

00:03:54.220 --> 00:04:00.280
online. But I realized that there's a real difference between just understanding how,

00:04:00.280 --> 00:04:06.140
say, like Python syntax works versus kind of knowing the art of modeling and programming.

00:04:06.140 --> 00:04:10.180
For sure. You know, programming, especially in Python, because you can get started pretty quickly,

00:04:10.180 --> 00:04:15.380
right, is one of these things that like, you feel like you're starting to you kind of learned it in

00:04:15.380 --> 00:04:19.100
a week or two. But then, you know, 10 years later, you're still learning something every day.

00:04:19.100 --> 00:04:20.260
Exactly. Yeah.

00:04:20.260 --> 00:04:23.040
Nice. So now you're in grad school, right?

00:04:23.040 --> 00:04:29.800
Yes. I'm a second year grad student at Harvard with Professor Alana Spurguzik.

00:04:29.800 --> 00:04:31.360
Nice. And what are you studying there?

00:04:31.360 --> 00:04:37.380
So right now, I'm doing a PhD in chemical physics. But I guess part of our research group really

00:04:37.380 --> 00:04:43.100
focuses on developing new quantum classical algorithms for implementing on current or near

00:04:43.100 --> 00:04:46.940
term quantum computers, which I'll, of course, talk about a little more later.

00:04:46.940 --> 00:04:52.100
Yeah, quantum or near term quantum computers. I think this is super, super interesting. How many

00:04:52.100 --> 00:04:53.660
people work in your research group?

00:04:53.660 --> 00:04:59.840
So we're a pretty big group, I'd say around 30 people, but around a third of those people work on

00:04:59.840 --> 00:05:01.080
quantum algorithms.

00:05:01.080 --> 00:05:05.360
Yeah. So I guess, day to day, what kind of stuff are you doing? Are you like,

00:05:05.360 --> 00:05:11.220
writing algorithms? Are you trying to create hardware? What are you doing? Scrambling to

00:05:11.220 --> 00:05:12.220
finish qualifying exams?

00:05:12.220 --> 00:05:14.200
I've already gotten past that, luckily.

00:05:14.200 --> 00:05:16.460
Good for you. That's a big step.

00:05:16.460 --> 00:05:22.020
But yeah, like you said, we're either as a group kind of trying to come up with the next new quantum

00:05:22.020 --> 00:05:27.020
algorithm. But like I said before, because we're working with current or near term quantum

00:05:27.020 --> 00:05:32.520
processors, we really, there are some constraints that we need to consider, such as how qubits

00:05:32.520 --> 00:05:38.680
will respond to the noise and just the limitations and the number of these quantum bits or their

00:05:38.680 --> 00:05:44.360
limited connectivities on the actual device and seeing how that will affect the types of algorithms

00:05:44.360 --> 00:05:45.940
that we can come up with.

00:05:45.940 --> 00:05:50.700
Yeah, that's really interesting because it's not just the bit is on or off. It can be many things.

00:05:50.700 --> 00:05:50.980
Yeah.

00:05:51.140 --> 00:05:51.580
Exactly.

00:05:51.580 --> 00:05:56.180
Yeah. I'm really looking forward to digging into the quantum computing aspects because

00:05:56.180 --> 00:06:03.300
it's still sort of a little bit beyond my understanding. But I think an important foundational

00:06:03.300 --> 00:06:07.600
item maybe we should cover because, you know, most people listening are programmers, data scientists,

00:06:07.600 --> 00:06:12.300
or maybe biologists or astrophysicists. But, you know, none of those groups necessarily

00:06:12.300 --> 00:06:17.840
study quantum mechanics per se. Everybody's heard of quantum mechanics because,

00:06:18.320 --> 00:06:22.520
you know, just pop culture. But, you know, maybe we could just talk real briefly about,

00:06:22.520 --> 00:06:26.880
like, what is quantum mechanics as an area of physics?

00:06:26.880 --> 00:06:32.240
To be very honest, it's like quantum mechanics is something that no one will ever fully understand,

00:06:32.240 --> 00:06:39.520
just going in. I guess to put it broadly, you can think of it as a physical theory that describes

00:06:39.520 --> 00:06:44.400
what happens in nature at the atomic or subatomic scale. Like you mentioned before,

00:06:44.820 --> 00:06:51.700
just how electrons kind of move around and interact. That's really captured by quantum mechanics.

00:06:51.700 --> 00:06:58.000
And to kind of contrast this with classical mechanics, where you can essentially, again,

00:06:58.000 --> 00:07:03.000
you've already mentioned this example, but we can really predict where, say, something like a tennis

00:07:03.000 --> 00:07:09.040
ball will be at some time T. But in quantum mechanics, we're really gaining an intuition of the

00:07:09.040 --> 00:07:13.380
probability of finding a quantum particle at these various locations.

00:07:13.380 --> 00:07:19.120
Yeah. So it's way more statistical driven than it is just measurement, right?

00:07:19.120 --> 00:07:19.960
Right, right.

00:07:19.960 --> 00:07:27.960
So when do we reach, like, where do I find quantum mechanics? So obviously, planets don't behave

00:07:27.960 --> 00:07:34.480
quantumly. People don't behave quantumly. My little Apple ear pod thing, probably still too large,

00:07:34.480 --> 00:07:39.780
right? A grain of sand, smaller? How small does it get? Like, where do you go? Like,

00:07:39.780 --> 00:07:43.940
okay, we have to start thinking about like, forget, or start to at least factor in these quantum

00:07:43.940 --> 00:07:48.020
mechanical principles rather than just say, like, Newton type stuff.

00:07:48.020 --> 00:07:52.300
You're right in that all of these things that you've mentioned are classical particles, but we do

00:07:52.300 --> 00:07:58.520
kind of use quantum mechanics everywhere. For example, if you look at kind of break down the

00:07:58.520 --> 00:08:04.840
percentage of where computing, I guess, including times and efforts spent on supercomputers go,

00:08:04.840 --> 00:08:09.880
So there are really a lot of significant chunk of them goes into performing these chemistry

00:08:09.880 --> 00:08:15.800
calculations or some type of modeling of physical systems. And of course, all of these calculations are

00:08:15.800 --> 00:08:22.880
really important for drug discovery, materials design and other industrial processes. But to really

00:08:22.880 --> 00:08:29.100
capture accurate results for these types of calculations, you need to have a good understanding of

00:08:29.100 --> 00:08:34.440
what's happening at the atomic or molecular level. And this is where quantum mechanics is,

00:08:34.440 --> 00:08:39.640
I guess, at this scale, you really can't capture these behaviors and properties without considering

00:08:39.640 --> 00:08:43.620
quantum mechanics, right? That's where the classical stuff actually starts to fall down.

00:08:43.620 --> 00:08:48.860
How interesting. I don't want to go through all the aspects of quantum mechanics, because this is a

00:08:48.860 --> 00:08:56.440
programming podcast, not a science one. But what parts or aspects of quantum mechanics are relevant for,

00:08:56.440 --> 00:09:00.760
say, quantum computers, right? Like we have Heisenberg's uncertainty principle,

00:09:00.760 --> 00:09:05.460
we all know about Schrodinger's cat, like, what kind of stuff do we kind of, what are the essential

00:09:05.460 --> 00:09:09.780
things we need to know, just as the foundation of thinking about quantum computers?

00:09:09.780 --> 00:09:16.000
To kind of put a spin on that question, this can be really captured by kind of looking at the difference

00:09:16.000 --> 00:09:22.240
between quantum computing and classical computing, because we do directly apply laws of quantum mechanics

00:09:22.240 --> 00:09:29.680
mechanics at the level of the basic unit of computation, essentially how we consider this quantum bit or

00:09:29.680 --> 00:09:30.020
qubit.

00:09:30.020 --> 00:09:37.660
Right. In traditional programming, we have bits, and they can be on or off zero or one. What's a qubit?

00:09:37.660 --> 00:09:43.460
Right. So quantum bit, it's a little bit more complicated, just in terms of how they can be

00:09:43.460 --> 00:09:50.220
represented, and how different processes are effectively operations can influence the state of that qubit.

00:09:50.220 --> 00:09:58.120
So I guess what I can say is, we as quantum computer scientists can observe and work with directly in

00:09:58.120 --> 00:10:04.420
quantum computing are actually samples of probability distributions of finding each qubit in the zero or

00:10:04.420 --> 00:10:11.540
one state. Often people say that this is like being able to access the zero and one state at the same

00:10:11.540 --> 00:10:16.220
time. But I think there's just subtle differences between these two explanations.

00:10:16.220 --> 00:10:24.940
Okay. So instead of being zero or one, it's almost like it can be anywhere in between those two

00:10:24.940 --> 00:10:28.500
possibilities in sort of a statistical model.

00:10:28.500 --> 00:10:34.820
Exactly. There's some probability that you'll find this qubit in the zero or one state. Yes.

00:10:34.820 --> 00:10:41.660
That's pretty interesting. Now, with traditional computers, they're super small too, right? I mean,

00:10:41.660 --> 00:10:48.600
like the dyes these days for like the modern Intel processors and other ones, they're like at the 14

00:10:48.600 --> 00:10:53.120
nanometer range. And it's been a long time since I've studied chemistry, but I'm feeling like

00:10:53.120 --> 00:10:59.600
a couple of nanometers, that's like the diameter of an atom, right? That's pretty small, isn't it?

00:10:59.600 --> 00:11:00.360
Right, right.

00:11:00.360 --> 00:11:08.540
So do traditional CPUs like the one in my MacBook now, do they have to think about quantum computing

00:11:08.540 --> 00:11:10.820
when building those types of devices?

00:11:10.820 --> 00:11:16.880
They are definitely approaching this quantum realm, if you will, according to this Moore's law. And I

00:11:16.880 --> 00:11:22.700
think this is actually one of the big motivations behind quantum computing, where, as you said, as the

00:11:22.700 --> 00:11:29.400
size of each transistor is getting really smaller and smaller, it will just approach a size in which we

00:11:29.400 --> 00:11:36.520
can really no longer ignore the effects of quantum mechanics. And this is why some people are like,

00:11:36.520 --> 00:11:42.080
oh, we might need a different paradigm of computing. And this is where quantum computing may step in.

00:11:42.080 --> 00:11:47.860
Right. So as we get our general CPUs smaller and smaller and more focused, right, like,

00:11:47.860 --> 00:11:54.440
we're getting to the point where we just can't pack in more stuff without effectively entering the

00:11:54.440 --> 00:11:56.360
quantum realm. Am I understanding that correctly?

00:11:56.560 --> 00:11:56.860
Yes.

00:11:56.860 --> 00:12:01.460
Okay. I guess if we're talking about quantum computers at the lowest, lowest level,

00:12:01.460 --> 00:12:09.100
we already talked about how you have qubits versus regular bits, and how we have the statistical

00:12:09.100 --> 00:12:14.700
difference, which I'm not really, I understand what you're saying, but I don't understand how to do

00:12:14.700 --> 00:12:21.440
computation with it. So maybe give us a sense of like, what does it mean to try to implement like

00:12:21.440 --> 00:12:25.260
algorithms or computation, like down at that level? Like, how do these things really work?

00:12:25.260 --> 00:12:32.480
So the model of computation that I work with every day is the gate based quantum computation. And this

00:12:32.480 --> 00:12:39.200
is quite analogous to the, I guess, the classical circuit model, where you essentially have, you select

00:12:39.200 --> 00:12:45.440
a number of qubits to work on. And then you kind of propagate the circuit through time by applying

00:12:45.440 --> 00:12:50.600
different types of operations on it. But this time, instead of these logic classical gates,

00:12:50.600 --> 00:12:57.300
like and and or, we're now applying these quantum gates that kind of obey these mathematics of quantum

00:12:57.300 --> 00:12:57.820
mechanics.

00:12:57.820 --> 00:13:01.540
What kind of gates do you get there? Like, and and or, that makes a lot of sense to me.

00:13:01.540 --> 00:13:04.980
What does, give us some examples of the quantum gate?

00:13:04.980 --> 00:13:12.520
Say that we start at the zero state in a quantum computer. So if you apply, say, Hadamard gate,

00:13:12.520 --> 00:13:14.480
let's see, how do I, how do I?

00:13:14.480 --> 00:13:17.240
How do you explain this over audio?

00:13:17.240 --> 00:13:22.760
Right. So the effect of a Hadamard gate, you can think of it as turning this, just the zero state

00:13:22.760 --> 00:13:30.860
into this even superposition of zero and one state. So this effectively means that it's equally likely

00:13:30.860 --> 00:13:36.440
to find this qubit at the end of this application of the Hadamard gate in the zero and one state.

00:13:36.440 --> 00:13:41.320
There's a 50% chance of finding it in the zero or one state.

00:13:41.320 --> 00:13:46.420
This is pretty wild. I guess one of the things that I always hear when I hear about quantum computing

00:13:46.420 --> 00:13:53.960
is it's like it can compute sort of inherently can compute many possibilities at once.

00:13:53.960 --> 00:13:58.620
And regular computers, they don't do that, right? They just like go right down their path. And I mean,

00:13:58.620 --> 00:14:04.440
obviously they'll do like weird things, like try to guess the rest of the computation based on,

00:14:04.440 --> 00:14:07.800
you know, while they're waiting for some other part of the system, but that's not really the same

00:14:07.800 --> 00:14:14.420
thing, right? That's just doing extra work quickly in order. So where does that sort of factor in or

00:14:14.420 --> 00:14:17.200
where does that come from? Or is even that the right way to think of it?

00:14:17.200 --> 00:14:22.300
Yeah, I think there is actually some common misconceptions about quantum computing in that

00:14:22.300 --> 00:14:28.180
people think that it's, it's somewhat like parallel computing in some sense, right? Just being able

00:14:28.180 --> 00:14:36.360
to access all possible states at the same time. But I wouldn't say that that's entirely accurate.

00:14:36.420 --> 00:14:42.820
It's just that, again, like I said, because we're kind of working with this evolution of this probability

00:14:42.820 --> 00:14:49.900
distribution, in some sense, you're not just working with a discrete state, but you're able to kind of

00:14:49.900 --> 00:14:56.040
affect a, you're effectively working with this distribution instead of a single state.

00:14:58.040 --> 00:15:03.120
This portion of Talk Python To Me is brought to you by Linode. Are you looking for bulletproof hosting

00:15:03.120 --> 00:15:07.640
that's fast, simple, and incredibly affordable? Look past that bookstore and check out Linode at

00:15:07.640 --> 00:15:15.260
 talkpython.fm/Linode. That's L-I-N-O-D-E. Plans start at just $5 a month for a dedicated server

00:15:15.260 --> 00:15:19.900
with a gig of RAM. They have 10 data centers across the globe. So no matter where you are,

00:15:19.900 --> 00:15:25.560
there's a data center near you. Whether you want to run your Python web app, host a private get server,

00:15:25.560 --> 00:15:32.240
or file server, you'll get native SSDs on all the machines, a newly upgraded 200 gigabit network,

00:15:32.240 --> 00:15:37.800
24-7 friendly support, even on holidays, and a seven-day money-back guarantee. Do you need a

00:15:37.800 --> 00:15:42.820
little help with your infrastructure? They even offer professional services to help you get started

00:15:42.820 --> 00:15:48.200
with architecture, migrations, and more. Get a dedicated server for free for the next four months.

00:15:48.200 --> 00:15:55.280
Just visit talkpython.fm/Linode. When I see quantum computing applied right now,

00:15:55.420 --> 00:16:01.480
there's two areas that I hear it applied quite a bit, at least as much as it is applied. One of those

00:16:01.480 --> 00:16:08.520
seems to do around solving science problems. You're a computational chemist person, and you're

00:16:08.520 --> 00:16:14.260
studying this, right? That's very much in that space. And the other one I hear it all the time

00:16:14.260 --> 00:16:21.040
is cryptography. And if people get quantum computers working, cryptography is broken. We all suggest,

00:16:21.040 --> 00:16:26.520
you know, go get a cabin or something like that and live in the woods. So what kind of problems would

00:16:26.520 --> 00:16:30.480
you say are like especially well suited for being addressed by quantum computers?

00:16:30.480 --> 00:16:35.900
First of all, I think this is a very good question, because I think it's worth noting that quantum

00:16:35.900 --> 00:16:41.980
computers will not be able to solve every problem exponentially faster than classical computers can.

00:16:41.980 --> 00:16:48.560
So like you said, there are some kind of types of problems that quantum computers will be good at or

00:16:48.560 --> 00:16:54.500
are well suited for. And that includes this factoring problem, which has applications in cryptography,

00:16:54.500 --> 00:17:01.580
like you mentioned, quantum chemistry and Hamiltonian simulation. Others include combinatorial optimization

00:17:01.580 --> 00:17:09.180
and possibly machine learning, with the intuition that maybe quantum computers can be used to

00:17:09.180 --> 00:17:14.940
effectively capture complex patterns and data. That's really interesting. So that's definitely one

00:17:14.940 --> 00:17:21.380
of the areas that I didn't just mention, but it certainly is on my radar is like quantum computers could be

00:17:21.380 --> 00:17:26.500
a game changer for machine learning. Let's take them in order though. Let's, let's talk about the,

00:17:26.500 --> 00:17:32.100
the sort of straight computational stuff. Like I want to model a bridge really, really well, or I want to

00:17:32.100 --> 00:17:38.180
try to understand, you know, this sort of scientific problem better. And instead of doing approximations,

00:17:38.180 --> 00:17:43.700
like maybe even weather, right? Maybe like climate science, maybe we can get like a truly accurate

00:17:43.700 --> 00:17:49.540
forecast for like a hundred days or something like that with quantum computers. How does quantum computing help

00:17:49.540 --> 00:17:52.260
like complex computation like that?

00:17:52.260 --> 00:17:59.380
The problem that you came up with such as bridges, I'm a little less clear on how quantum computers can directly help

00:17:59.380 --> 00:18:00.900
near term at least.

00:18:00.900 --> 00:18:03.700
I'm just throwing stuff out there. I don't really know computers that well.

00:18:03.700 --> 00:18:12.020
So well, maybe going back to problems in chemistry, right? There's this idea that because you can think of molecules

00:18:12.020 --> 00:18:19.380
essentially as a system of quantum particles, there's a better map that you can use in order to kind of map

00:18:19.380 --> 00:18:25.300
this problem onto the quantum computer where maybe each qubit represents some, some type of a orbital.

00:18:25.300 --> 00:18:30.180
And in that case, by kind of evolving this quantum state on your quantum computer,

00:18:30.180 --> 00:18:34.500
you're effectively modeling this molecule. And by doing so,

00:18:34.500 --> 00:18:39.860
the medium is like inherently more suited to modeling stuff that behaves like it does.

00:18:39.860 --> 00:18:45.780
Yeah. But I guess this is still very much a, it's a rapidly developing field, but there's so many

00:18:45.780 --> 00:18:51.940
open questions like how do you map quantum system to a more general problem? And that's very much an

00:18:51.940 --> 00:18:53.220
active area of research.

00:18:53.220 --> 00:19:00.100
So with machine learning, right, machine learning is going through dramatic changes. And I think one of

00:19:00.100 --> 00:19:07.460
the areas where it's gotten super, super advanced is the different types of computation already being

00:19:07.460 --> 00:19:12.020
applied to machine learning. So what I mean is, for a long time, the stuff was done just on

00:19:12.020 --> 00:19:20.180
general purpose CPUs. And then it was moved over to GPUs where you could do way more work and have a

00:19:20.180 --> 00:19:25.860
better model. And then now it's finding its way over to things like tensor processing units and stuff like

00:19:25.860 --> 00:19:32.900
that coming out of Google. So do you see that that maybe keeps going into the quantum realm with some

00:19:32.900 --> 00:19:33.460
of the stuff?

00:19:33.460 --> 00:19:40.580
Adding on to the name, I guess, now you can think about QPUs, right? And as I mentioned earlier,

00:19:40.580 --> 00:19:46.740
this kind of quantum circuit model, I think right now, one thing people are thinking about is using a

00:19:46.740 --> 00:19:53.620
quantum circuit as some type of, let's say, a quantum neural network where you're training these parameters

00:19:53.620 --> 00:20:00.340
on these quantum gates in order to, I guess, represent some type of model that can describe

00:20:00.340 --> 00:20:07.460
some data. But I guess there's a lot of work being done on quantum machine learning, but it's,

00:20:07.460 --> 00:20:13.460
again, still pretty early in its stages. So I think we're trying to really kind of figure out as a

00:20:13.460 --> 00:20:19.380
community what quantum machine learning means even. Does this mean that we're working with

00:20:19.380 --> 00:20:24.100
a classical data or quantum data or maybe both? There are lots of open questions.

00:20:24.100 --> 00:20:27.540
Well, I think part of the problem is we don't understand how normal learning,

00:20:27.540 --> 00:20:34.180
human or animal learning works all the way, right? And so our models are just like pokes in the dark,

00:20:34.180 --> 00:20:37.860
right? Like we are not like, well, this is how it works in people and brains. So here's how we're

00:20:37.860 --> 00:20:40.580
doing computers. It's like, well, we don't know that either. So let's try this.

00:20:40.580 --> 00:20:45.700
Yeah. And add quantum to that equation and add two things that we don't fully understand.

00:20:45.700 --> 00:20:47.620
And we don't know.

00:20:47.620 --> 00:20:51.860
I feel like computers are going that way in general, the computers and software,

00:20:51.860 --> 00:20:57.780
even before we talked about quantum computers, is that software is getting further to a place where

00:20:57.780 --> 00:21:04.100
it kind of defines itself and it builds itself up and it can do things that we don't necessarily,

00:21:04.100 --> 00:21:09.220
we can't ask it for a justification of why it did that thing. It just, we gave it some examples and

00:21:09.220 --> 00:21:14.500
now it does things that seem mostly right. And quantum computing seems like it's just going to take us

00:21:14.500 --> 00:21:20.740
farther down that realm of like, well, it works. Why? I don't know, but it really, it works really well.

00:21:20.740 --> 00:21:23.220
Yeah. No, definitely. Definitely.

00:21:23.220 --> 00:21:26.660
Yeah. So do you think what it means to be a programmer is going to be different in 30 years?

00:21:26.660 --> 00:21:33.380
Right. Even thinking about what a quantum software engineer means currently, I'm still trying to

00:21:33.380 --> 00:21:38.500
kind of figure that out because I feel like that's the type of profession or career I want in the

00:21:38.500 --> 00:21:43.460
future. But what do you have to kind of do to prepare for this position? Right. How do you prepare

00:21:43.460 --> 00:21:46.740
for a position that's not fully defined yet? Exactly. Yeah.

00:21:46.740 --> 00:21:51.220
I would say you're way in a better place than most people though right now. Quantum computing research

00:21:51.220 --> 00:21:56.500
lab at Harvard is definitely like one of the places I would think might help you on that path.

00:21:56.500 --> 00:21:57.860
I hope so. I hope so.

00:21:57.860 --> 00:22:06.500
That's pretty cool. So I know what it means to build reliable software in the traditional

00:22:06.500 --> 00:22:13.220
sense of computing, right? Like, cause it's with the exception of parallel, like true parallel

00:22:13.620 --> 00:22:18.260
execution, which throws its own things in there, which by the way, I think it's interesting that

00:22:18.260 --> 00:22:24.180
the bugs created in parallel programs, traditional form often get called Heisen bugs,

00:22:24.180 --> 00:22:30.340
which are, are borrowed from the whole quantum mechanics world, right? Like, you know, you observe

00:22:30.340 --> 00:22:34.500
it, it changed the timing of the race condition and the race conditions gone, but you stop observing

00:22:34.500 --> 00:22:39.540
and it comes back, things like that. I know with the exception of like the race conditions,

00:22:39.540 --> 00:22:45.700
what for standard programming, what it looks like to build reliable software, unless the underlying

00:22:45.700 --> 00:22:53.300
hardware is broken. Basically, once you get it working, it stays working. Like what's the story

00:22:53.300 --> 00:23:00.580
with quantum programs? Like it sounds like if it's statistical based that it's mostly okay, or is it,

00:23:00.580 --> 00:23:05.140
can we get to a place where it is fully deterministic in the same sense that we have now?

00:23:05.140 --> 00:23:11.620
I think the power of quantum computing comes from the fact that it's not deterministic. I mean,

00:23:11.620 --> 00:23:19.060
this is a real challenge that, we need to kind of find ways to efficiently sample from these

00:23:19.060 --> 00:23:20.900
distributions of possible states.

00:23:20.900 --> 00:23:26.900
So like in networks and stuff, we have like error checks and ways to sort of retry if something goes

00:23:26.900 --> 00:23:31.860
wrong. Could we have something like that in computer and quantum computing where it's like, well,

00:23:32.820 --> 00:23:36.980
while we ran this, we also ran like a, some sort of a checksum type thing and that failed.

00:23:36.980 --> 00:23:39.300
So we're just going to rerun that computation at this step.

00:23:39.300 --> 00:23:45.380
I have to say, I'm not too familiar with this area, but I think there is some methods for,

00:23:45.380 --> 00:23:50.980
I think we call it a post-processing where, like you mentioned before, if you get an outcome that

00:23:50.980 --> 00:23:56.820
you know is wrong, then you kind of ignore that run and then keep going through these or propagating

00:23:56.820 --> 00:24:02.900
these quantum circuits until you get to an outcome that you know is right or is reliable.

00:24:02.900 --> 00:24:08.500
Yeah. I just wonder if there's a way to like weave in like a known computation that it has to come

00:24:08.500 --> 00:24:13.220
out with the same answer. And then you also get the thing you're actually trying to compute. And if

00:24:13.220 --> 00:24:17.300
they're either going to be both broken or both. Okay. I don't know. Like I've not done any quantum

00:24:17.300 --> 00:24:21.060
programs. I don't really know. I'm just trying to imagine how like you build reliable stuff out of this.

00:24:21.060 --> 00:24:26.580
Yeah. And that's still very much a challenge just because quantum bits or qubits themselves are

00:24:26.580 --> 00:24:33.300
still quite sensitive to noise. So it's hard to really check if the fault is coming from your

00:24:33.300 --> 00:24:38.260
program or from the noise on the qubits. Yeah. And all these things are pretty experimental,

00:24:38.260 --> 00:24:43.460
right? Like I haven't been to Best Buy for a while, but I didn't see any quantum computers. Like I saw,

00:24:43.460 --> 00:24:47.860
they have a little Apple section and they have a bunch of Windows machines. I haven't seen any Linux

00:24:47.860 --> 00:24:53.220
stuff over there, but you can go buy regular computers, but you can't go get quantum computers.

00:24:53.220 --> 00:24:58.740
And so would you say that quantum computers exist today or they're just research projects that are

00:24:58.740 --> 00:25:02.980
like poking at this concept of it? Like how far down this quantum computer path are we?

00:25:02.980 --> 00:25:09.540
So I would say that definitely, yes, quantum computers exist today. And there are different

00:25:09.540 --> 00:25:15.060
types of architectures that implement this. That being said, it's not like, like you said,

00:25:15.060 --> 00:25:20.180
you can walk into a store and buy a quantum computer. And because of this, what's really

00:25:20.180 --> 00:25:25.860
happening is that a lot of academic institutions and companies, they basically have these large

00:25:25.860 --> 00:25:31.700
refrigeration units that are cooled down to very, very low temperatures. And this is where the qubits

00:25:31.700 --> 00:25:38.500
reside. And because like I said before, that qubits are very delicate and sensitive to noise. There are

00:25:38.500 --> 00:25:44.180
lots of scientists and engineers kind of trying to every day working to maintain these qubits.

00:25:44.180 --> 00:25:50.660
But in order to make these quantum computers work and at the same time have them accessible to the

00:25:50.660 --> 00:25:55.780
public so that they can try programming on these quantum computers. I think one way that they figured

00:25:55.780 --> 00:26:00.660
this out is to have it through the cloud where anyone around the world can just kind of submit

00:26:00.660 --> 00:26:01.940
these quantum program jobs.

00:26:01.940 --> 00:26:10.260
Right. Yeah. People have said that sort of cloud computing is a little bit like jumping back to the

00:26:10.260 --> 00:26:16.500
whole, like, you know, fire up a terminal dial into some big mainframe type of experience,

00:26:16.500 --> 00:26:21.140
right? For a long time computing sort of moved to the desktop. And now in some sense,

00:26:21.140 --> 00:26:28.020
it's kind of moved back to like the new modern mainframe. So you can take advantage of just all the scale of the

00:26:28.020 --> 00:26:33.140
data centers. And it seems like that's the perfectly reasonable solution, at least in the early days

00:26:33.140 --> 00:26:39.300
for these quantum computers is like they'll live in some special place underground away from other

00:26:39.300 --> 00:26:45.940
interference, like really, really cold. And then we can like schedule jobs on them kind of like AWS Lambda

00:26:45.940 --> 00:26:46.660
or something, right?

00:26:46.660 --> 00:26:54.660
Yeah, I actually submitted some jobs on Rigetti computing's 90 qubit chip last weekend. And it was

00:26:54.660 --> 00:27:00.500
very exciting. That's a theory. Yeah, that's super cool. All right. So you said computer quantum computers exist.

00:27:00.500 --> 00:27:08.100
And can you give us some examples? So there's Rigetti. I heard IBM has something I've early days. I heard D wave.

00:27:08.100 --> 00:27:15.060
I think I saw like a Nova show on D wave or something a long time ago. Maybe give us a rundown of some of these systems.

00:27:15.060 --> 00:27:22.900
Like you said, Rigetti computing has their qubit processor, IBM, Google, Microsoft, but also a lot of academic institutions

00:27:22.900 --> 00:27:31.940
have their own chips. And right, the D wave. The D wave is actually also how I first found out about this idea of quantum computing.

00:27:31.940 --> 00:27:42.260
Because I think D wave was one of the first mainstream machines that were covered by media in order to really discuss this new technology called quantum computing.

00:27:42.500 --> 00:27:48.340
Right. There was this concept of quantum computing, but then to actually see this thing, which is pretty interesting.

00:27:48.340 --> 00:27:57.740
And it only had just like two bits or something like it was really, really not a massive computing system, but it was working right in the early days.

00:27:57.740 --> 00:27:58.020
Right.

00:27:58.020 --> 00:28:03.860
That's pretty awesome. Then there's the IBM 50, right?

00:28:04.260 --> 00:28:05.860
So what's the story of that one?

00:28:05.860 --> 00:28:29.060
So I believe they have a 50 qubit superconducting chip. I haven't actually had any experience programming on it, but I can say in general for IBM and these other major companies, often what they'll have are these quantum processors, but also their own kind of in-house quantum programming packages that they come with.

00:28:29.860 --> 00:28:36.680
Any user can kind of play around with creating these quantum circuits and try running them on these qubit chips.

00:28:36.680 --> 00:28:43.940
That's a pretty interesting question. Like if you have this entirely different way of thinking about programming and modeling, right?

00:28:43.940 --> 00:28:52.500
Like when I sit down to program in Python, like it's all about if this, if not that, while that, you know what I mean?

00:28:52.500 --> 00:28:57.660
Like it's all based on the and or gates. And so the programming languages are going to be really different.

00:28:57.660 --> 00:29:00.660
But before I ask you about that, I want to actually ask you one other thing.

00:29:00.660 --> 00:29:05.880
So you said there's the Regetti 19 qubit system, the IBM 50 qubit system.

00:29:05.880 --> 00:29:12.460
I have a 64 bit Intel core seven or whatever.

00:29:12.460 --> 00:29:20.340
How do I relate? Like, how can I relate the number 16 or 50 to what I know in terms of like regular CPUs?

00:29:20.340 --> 00:29:22.240
Is there a relationship? What is it?

00:29:22.440 --> 00:29:36.800
This is a good question. I have to say in classical computers at this point, you know, the common user like myself, when I program, I really don't have to worry at the level of if the bit is undergoing some noise process.

00:29:36.800 --> 00:29:44.300
And if there's any like bit flips that I'm worrying about, there are these like error correction codes and these redundancy checks that are in place.

00:29:44.520 --> 00:29:51.420
But for quantum computers, I think we're still at the stage where we can't kind of ignore these effects.

00:29:51.420 --> 00:29:58.860
So when we say these 19 qubit chips, 50 qubit chips, these qubits are actually physical qubits that haven't been.

00:29:58.860 --> 00:30:05.440
So we don't have enough qubits in order to fully kind of implement these quantum error correction codes,

00:30:05.440 --> 00:30:14.200
such that when we run these quantum programs, we know with great probability that our program will run reliably, so to say.

00:30:14.200 --> 00:30:20.000
There will be a lot of noise that undergo and the computation or the result that we get at the end.

00:30:20.000 --> 00:30:25.420
We don't know if there has been some like various bit flips and other noises that happened.

00:30:25.780 --> 00:30:29.880
I guess right now it's a little too early for like a direct comparison.

00:30:29.880 --> 00:30:30.420
Sure.

00:30:30.420 --> 00:30:37.320
But it sounds like maybe they're not as fully leveraged as say the systems that we have.

00:30:37.320 --> 00:30:38.740
Something to that effect, maybe.

00:30:38.740 --> 00:30:43.380
This portion of Talk Python To Me is brought to you by ActiveState.

00:30:43.380 --> 00:30:49.360
ActiveState gives you a faster way to build and secure open source runtimes from your first line of code through to production.

00:30:49.360 --> 00:30:53.560
Every second you spend building your Python distro or trying to secure your Python programs

00:30:53.560 --> 00:30:56.100
is less time spent doing the work you love.

00:30:56.100 --> 00:30:58.700
You've got better things to do than trying to resolve dependencies

00:30:58.700 --> 00:31:02.340
or making sure that you tick off all security boxes when you ship to production.

00:31:02.340 --> 00:31:06.840
Standardize on your Python builds so you can have less friction in the development cycle

00:31:06.840 --> 00:31:08.700
and you can deliver apps faster.

00:31:08.700 --> 00:31:13.180
You can also get a unique server-side way to verify your Python applications at runtime.

00:31:13.180 --> 00:31:16.600
Bake security right into your code without impacting performance.

00:31:16.600 --> 00:31:19.940
Go faster, spend more time doing the work you love,

00:31:19.940 --> 00:31:21.980
and comply with your enterprise security needs.

00:31:22.280 --> 00:31:27.640
Try ActiveState and see why it was chosen by IBM, Microsoft, NSA, Siemens, PepsiCo, and more.

00:31:27.640 --> 00:31:31.720
Join millions of developers who trust ActiveState to build their open source language distros.

00:31:31.720 --> 00:31:35.860
Visit talkpython.fm/ActiveState for a special offer.

00:31:35.860 --> 00:31:38.300
That's talkpython.fm/ActiveState.

00:31:40.040 --> 00:31:41.880
We have this new programming model.

00:31:41.880 --> 00:31:43.200
How do we program it?

00:31:43.200 --> 00:31:50.060
Like I mentioned before, I think this is a great time to really get into quantum programming or quantum computing

00:31:50.060 --> 00:31:56.260
because you have actually several choices of packages that you can use to program on a quantum device.

00:31:56.260 --> 00:32:01.700
Some of them include IBM's Quantum Experience where they have some drag-and-drop interface

00:32:01.700 --> 00:32:04.880
in order to try to create your own quantum program.

00:32:04.880 --> 00:32:08.860
Wow. Is it almost like Scratch or something like that?

00:32:08.860 --> 00:32:10.380
Yeah, you could think of it like that.

00:32:10.380 --> 00:32:13.360
I played around with it a little bit and it's quite fun.

00:32:13.360 --> 00:32:18.960
Besides that, they have their, I guess, non-drag-and-drop software package called Qiskit.

00:32:18.960 --> 00:32:19.240
Okay.

00:32:19.380 --> 00:32:22.440
I think Rigetti Computing has Forrest.

00:32:22.440 --> 00:32:26.800
Their platform is called Forrest, but their programming language is called Quill.

00:32:26.800 --> 00:32:29.380
I think Microsoft has Qsharp.

00:32:29.380 --> 00:32:33.440
And Google actually has a package called OpenFermion,

00:32:33.440 --> 00:32:37.100
which is a package that can be used to develop quantum algorithms

00:32:37.100 --> 00:32:40.860
specifically for fermionic or essentially molecular systems.

00:32:40.860 --> 00:32:43.380
So that's, of course, one of my favorites.

00:32:43.380 --> 00:32:44.200
Yeah, of course.

00:32:44.200 --> 00:32:49.460
Those all sound really interesting, but none of them sound very familiar, right?

00:32:49.460 --> 00:32:54.160
Like the only one that I've really looked through the programming model of

00:32:54.160 --> 00:32:56.940
was the Qsharp one from Microsoft.

00:32:56.940 --> 00:33:01.320
And that's because it actually has interesting Python tie-ins.

00:33:01.320 --> 00:33:05.500
But most of these that you mentioned actually have some way to interact with them from Python, right?

00:33:05.500 --> 00:33:06.000
Yes.

00:33:06.000 --> 00:33:07.660
Yeah. So tell us about that relationship.

00:33:07.660 --> 00:33:12.020
I guess I've mostly played around with Rigetti Computing's PyQuil,

00:33:12.020 --> 00:33:16.080
where you essentially, right now, a Python program,

00:33:16.080 --> 00:33:19.440
you'd have these Python functions for these quantum gates.

00:33:19.440 --> 00:33:22.640
And what you're doing is kind of initiating a quantum circuit

00:33:22.640 --> 00:33:25.980
by inputting the number of qubits you want in a circuit.

00:33:25.980 --> 00:33:31.120
And then you can basically place different gates in different parts of the circuit

00:33:31.120 --> 00:33:34.080
in order to perform the computation you want

00:33:34.080 --> 00:33:37.240
or alternatively produce a quantum state that you want.

00:33:37.240 --> 00:33:41.640
And they have these different backends where one backend could be a simulator

00:33:41.640 --> 00:33:45.000
where you can kind of look at how the wave function

00:33:45.000 --> 00:33:48.920
or the quantum state is evolving as you propagate your circuit.

00:33:48.920 --> 00:33:52.980
But then another backend is when you directly now communicate

00:33:52.980 --> 00:33:55.160
with the actual quantum computers,

00:33:55.160 --> 00:33:58.140
maybe for Rigetti in Berkeley or something,

00:33:58.140 --> 00:34:01.220
where after you write this quantum program in Python,

00:34:01.220 --> 00:34:04.880
you can just directly send it to the machine to run.

00:34:04.880 --> 00:34:06.460
That's pretty awesome.

00:34:06.820 --> 00:34:08.960
You mentioned the simulators, right?

00:34:08.960 --> 00:34:11.260
There's only a handful of these computers.

00:34:11.260 --> 00:34:12.060
What do they cost?

00:34:12.060 --> 00:34:14.940
If I wanted to, I don't even know if it's possible,

00:34:14.940 --> 00:34:17.180
but if I wanted to go buy, say, the D-Wave,

00:34:17.180 --> 00:34:19.880
I'm a real big enthusiast,

00:34:19.880 --> 00:34:22.420
and I want to put into my garage the IBM 50,

00:34:22.420 --> 00:34:25.380
what would that cost?

00:34:25.520 --> 00:34:27.580
It depends on what your job is.

00:34:27.580 --> 00:34:29.600
Because you're going to need a lot of money.

00:34:29.600 --> 00:34:30.080
Yeah.

00:34:30.080 --> 00:34:33.160
Luckily, I think in the US, at least,

00:34:33.160 --> 00:34:37.140
there's this real initiative to kind of get quantum computing going

00:34:37.140 --> 00:34:39.900
and have it more accessible to the public.

00:34:39.900 --> 00:34:44.120
So I wouldn't be surprised if a lot of these kind of national labs

00:34:44.120 --> 00:34:46.040
start investing in quantum computing

00:34:46.040 --> 00:34:48.540
and even purchasing these machines.

00:34:48.540 --> 00:34:49.060
Sure.

00:34:49.440 --> 00:34:52.660
So a long time ago, IBM had their mainframes,

00:34:52.660 --> 00:34:55.560
and Bill Gates and crew came along and said,

00:34:55.560 --> 00:34:57.320
no, we're going to have a computer on every desk.

00:34:57.320 --> 00:34:59.300
Things like that effect.

00:34:59.300 --> 00:35:01.520
And there's some quote, I think it was from the IBM people,

00:35:01.520 --> 00:35:03.520
like, how many computers do there need to be in the world?

00:35:03.520 --> 00:35:04.960
Like nine, maybe 10?

00:35:04.960 --> 00:35:05.620
I don't know.

00:35:05.900 --> 00:35:06.220
Right.

00:35:06.220 --> 00:35:11.660
And it's probably like that way now for these quantum computers, right?

00:35:11.660 --> 00:35:13.880
There's like one or two of each of the ones you've named.

00:35:13.880 --> 00:35:14.460
I don't know.

00:35:14.460 --> 00:35:15.280
Not too many.

00:35:15.280 --> 00:35:17.240
But I feel like this time,

00:35:17.240 --> 00:35:19.980
because of all the infrastructure needed to say,

00:35:19.980 --> 00:35:21.020
keep it cool,

00:35:21.020 --> 00:35:25.900
keep it away from interference with other sorts of radiations and interactions,

00:35:25.900 --> 00:35:29.360
like it might actually stay in the cloud only.

00:35:29.360 --> 00:35:32.940
Do you think that we'll ever have quantum computers,

00:35:32.940 --> 00:35:35.540
like just in laptop form?

00:35:35.680 --> 00:35:38.960
Or is this something we're always going to connect to over services?

00:35:38.960 --> 00:35:40.500
I mean, of course, right?

00:35:40.500 --> 00:35:43.080
Having your personal quantum computer is the dream.

00:35:43.080 --> 00:35:43.980
But like you said,

00:35:43.980 --> 00:35:50.880
there's still quite a way to go before we can really find ways to consider these noises

00:35:50.880 --> 00:35:55.540
and maybe avoid these necessities for cold conditions.

00:35:55.540 --> 00:35:57.500
Right now it's super cold.

00:35:57.500 --> 00:35:58.680
Like how cold does it have to be?

00:35:58.680 --> 00:36:00.920
Like you don't want to touch it cold, right?

00:36:00.920 --> 00:36:02.540
Yeah, like millikelvin.

00:36:02.540 --> 00:36:03.520
Millikelvin.

00:36:03.520 --> 00:36:05.360
Yes, close to absolute zero,

00:36:05.460 --> 00:36:06.820
which is, yeah.

00:36:06.820 --> 00:36:08.100
But that being said,

00:36:08.100 --> 00:36:09.820
I mean, even with classical computing,

00:36:09.820 --> 00:36:12.800
you know, when you mentioned this IBM quote,

00:36:12.800 --> 00:36:13.660
at that point,

00:36:13.660 --> 00:36:15.740
I'm sure there were a lot of skeptics

00:36:15.740 --> 00:36:17.160
and people who were like,

00:36:17.160 --> 00:36:19.480
oh, I don't know if that's going to be achievable.

00:36:19.480 --> 00:36:21.580
But hey, like today,

00:36:21.580 --> 00:36:22.760
we did achieve that.

00:36:23.280 --> 00:36:24.740
So maybe for quantum computers,

00:36:24.740 --> 00:36:32.500
new technologies will kind of come in and new research scientists will find ways in order to make quantum computing more accessible.

00:36:32.500 --> 00:36:32.980
Right.

00:36:32.980 --> 00:36:40.600
Maybe some material science problem is solved that requires only liquid nitrogen level cold,

00:36:40.700 --> 00:36:41.940
not millikelvin cold.

00:36:41.940 --> 00:36:42.700
Exactly.

00:36:42.700 --> 00:36:43.380
Interesting.

00:36:44.060 --> 00:36:44.280
Yeah.

00:36:44.280 --> 00:36:46.120
And we also have simulators, right?

00:36:46.200 --> 00:36:48.680
So not everybody has access to these machines.

00:36:48.680 --> 00:36:51.000
But I know that at least the Qsharp one,

00:36:51.000 --> 00:36:52.860
because I looked through their documentation,

00:36:52.860 --> 00:37:00.840
they have like a literal simulator that you can go and write your programs from Python or Qsharp or Jupyter or whatever,

00:37:00.840 --> 00:37:02.760
however you want to do on that thing.

00:37:02.840 --> 00:37:06.460
Like you can go write your programs and simulate it.

00:37:06.460 --> 00:37:07.860
Is that pretty common these days?

00:37:07.860 --> 00:37:08.180
Yeah.

00:37:08.180 --> 00:37:12.200
So I've been actually working with Regetti's PyQuil simulator,

00:37:12.200 --> 00:37:14.800
and I think a lot of them work pretty similarly.

00:37:14.800 --> 00:37:19.480
And this type of tool or framework is really important for theorists.

00:37:19.480 --> 00:37:25.300
And just because we're kind of looking to develop algorithms for near term computers,

00:37:25.300 --> 00:37:26.280
but at the same time,

00:37:26.280 --> 00:37:27.660
we want to do something useful.

00:37:27.660 --> 00:37:29.260
So in some sense,

00:37:29.260 --> 00:37:32.380
we want to assume these like error corrected qubits.

00:37:32.380 --> 00:37:32.820
Yeah.

00:37:33.060 --> 00:37:34.860
So how accurate is this, right?

00:37:34.860 --> 00:37:36.280
Like it is a simulator,

00:37:36.280 --> 00:37:41.820
and you're simulating things that we have a hard time fully contemplating.

00:37:41.820 --> 00:37:44.940
Like if I write some program and get it working on the simulator,

00:37:44.940 --> 00:37:47.000
how close is that to working?

00:37:47.000 --> 00:37:47.660
Like how,

00:37:47.660 --> 00:37:49.620
what's the difference in say performance,

00:37:49.620 --> 00:37:50.600
things like that?

00:37:50.600 --> 00:37:51.480
At this point,

00:37:51.480 --> 00:37:56.900
it would be great if the simulator that you're using has some way of creating noise

00:37:56.900 --> 00:37:59.000
or accounting for noise in your simulation.

00:37:59.940 --> 00:38:03.240
And assuming that you have a good enough noise model,

00:38:03.240 --> 00:38:08.120
I think the result that you get should be pretty comparable to experimental results.

00:38:08.120 --> 00:38:08.560
Okay.

00:38:08.560 --> 00:38:09.360
That's encouraging.

00:38:09.360 --> 00:38:10.640
What about performance?

00:38:10.640 --> 00:38:13.060
It depends on what you're doing maybe, right?

00:38:13.060 --> 00:38:13.760
Right, right.

00:38:13.820 --> 00:38:14.680
Because right now,

00:38:14.680 --> 00:38:16.000
like I mentioned before,

00:38:16.000 --> 00:38:17.720
these like experimental setups,

00:38:17.720 --> 00:38:18.160
you know,

00:38:18.160 --> 00:38:23.920
there has to be a group of engineers and scientists that are trying to really optimize these operations

00:38:23.920 --> 00:38:28.820
in order to kind of perform a calculation using the actual quantum device.

00:38:29.280 --> 00:38:34.920
So when we talk about maybe runtime or some type of performance measure like that,

00:38:34.920 --> 00:38:37.960
it's hard to compare really directly right now.

00:38:37.960 --> 00:38:43.660
But I guess at least simulations take way shorter and takes less manpower.

00:38:43.660 --> 00:38:47.820
I say it's similar to how other fields in computational science works,

00:38:47.820 --> 00:38:54.240
where theory and experiments kind of go hand in hand and help each other kind of advance.

00:38:54.380 --> 00:39:01.520
Yeah, I definitely think it's cool that these simulators exist because there's not that much access to even,

00:39:01.520 --> 00:39:01.980
you know,

00:39:01.980 --> 00:39:03.820
these limited quantum computers we have.

00:39:03.820 --> 00:39:07.800
So definitely lets people do research and explore and test.

00:39:07.800 --> 00:39:08.440
Mm-hmm.

00:39:08.440 --> 00:39:08.840
Nice.

00:39:08.920 --> 00:39:14.960
Okay, so let me ask you some sort of slightly higher philosophical questions about quantum computing.

00:39:14.960 --> 00:39:17.980
What are the things to really get excited about?

00:39:17.980 --> 00:39:19.780
Like what's going to be invented?

00:39:19.780 --> 00:39:24.500
What is going to be possible that is not possible now because of quantum computing?

00:39:24.500 --> 00:39:26.360
What do you see on the horizon?

00:39:26.360 --> 00:39:30.700
We've already kind of discussed the possible applications of quantum computing.

00:39:31.020 --> 00:39:37.800
But I think just looking at the field itself, even now, I think research or development,

00:39:37.800 --> 00:39:40.680
they're all moving very fast in quantum computing.

00:39:40.680 --> 00:39:45.720
But at the same time, I'd say this is a good time for people to get into quantum computing

00:39:45.720 --> 00:39:49.360
because there's just so many open questions that you can ask.

00:39:49.620 --> 00:39:54.720
And quantum computing is one of those fields where people from various backgrounds,

00:39:54.720 --> 00:39:59.160
such as math, physics, chemistry, engineering, and computer science,

00:39:59.160 --> 00:40:02.940
they can really all get involved and significantly contribute.

00:40:02.940 --> 00:40:04.000
Yeah, that's really cool.

00:40:04.000 --> 00:40:11.140
I feel like so much of what is sort of sold as a college degree of computer science

00:40:11.140 --> 00:40:14.360
is much more just software engineering.

00:40:14.360 --> 00:40:18.100
And the actual science part of it is not so much there.

00:40:18.660 --> 00:40:23.540
But this seems like a place where computer science still is like very much the experiment,

00:40:23.540 --> 00:40:28.740
explore, hypothesis, and test stage rather than we just go through like,

00:40:28.740 --> 00:40:32.060
you know, we're using unit testing in Scrum and we're going to do that.

00:40:32.060 --> 00:40:34.560
And here's how we, you know, factor our database and whatnot.

00:40:34.560 --> 00:40:35.100
Right.

00:40:35.100 --> 00:40:36.300
No, it seems pretty cool.

00:40:36.300 --> 00:40:39.020
So what about energy, right?

00:40:39.020 --> 00:40:45.520
Like energy consumption by data centers is actually really huge because we never see them, right?

00:40:45.520 --> 00:40:49.520
There are these giant places in just a few spots on the globe, right?

00:40:49.520 --> 00:40:55.000
I think the closest data center to me is Prinnville, Oregon, which is out by, and this literally,

00:40:55.000 --> 00:41:00.460
the reason it is there is it's by one of the dams in the, I believe the Columbia River,

00:41:00.460 --> 00:41:04.180
so that it has like close access to lots of power.

00:41:04.640 --> 00:41:05.040
Right.

00:41:05.040 --> 00:41:05.080
Right.

00:41:05.080 --> 00:41:10.000
And so the traditional CPUs take a ton of power to exist and do their work.

00:41:10.000 --> 00:41:13.560
How does that work in the quantum computing world?

00:41:13.560 --> 00:41:18.400
Like if we got a really well working quantum computer, would it use less energy?

00:41:18.400 --> 00:41:19.080
Would it use more?

00:41:19.080 --> 00:41:19.800
What do you think?

00:41:19.960 --> 00:41:24.840
I think as a theorist, I have much less of an intuition for these types of questions.

00:41:24.840 --> 00:41:29.800
But given that, I actually talked to one of my colleagues who is an experimentalist, and

00:41:29.800 --> 00:41:35.040
he mentioned that at least for certain types of qubit architectures, such as superconducting

00:41:35.040 --> 00:41:39.200
qubits, they do expect less power consumption per qubit.

00:41:39.200 --> 00:41:39.500
Okay.

00:41:39.500 --> 00:41:40.400
That's pretty encouraging.

00:41:40.400 --> 00:41:41.600
Compared to the classical.

00:41:41.820 --> 00:41:42.000
Yeah.

00:41:42.000 --> 00:41:48.120
And I don't know the numbers, but I know that some problems are solved immensely faster

00:41:48.120 --> 00:41:49.080
by quantum computers.

00:41:49.080 --> 00:41:54.580
So, you know, maybe it even takes more energy, but it could solve it a thousand times faster.

00:41:54.580 --> 00:41:57.720
So in the long run, maybe it's, you know, way, way more efficient.

00:41:57.720 --> 00:42:00.600
So there's interesting trade-offs on that angle too, I would suspect.

00:42:00.600 --> 00:42:01.340
That's true.

00:42:01.340 --> 00:42:06.180
Because I guess that's where you're like, in classical computing, you probably won't ever

00:42:06.180 --> 00:42:10.440
find it or get to the answer within the time of the universe.

00:42:10.680 --> 00:42:12.920
But for quantum computing, maybe it'll be possible.

00:42:12.920 --> 00:42:14.300
Right, right.

00:42:14.300 --> 00:42:17.340
But I feel like, you know, that's awesome and that's probably going to happen.

00:42:17.340 --> 00:42:21.320
But at the same time, like, we'll just ask more complicated questions and we'll ask them

00:42:21.320 --> 00:42:21.760
more often.

00:42:21.760 --> 00:42:28.820
So it'll open up what we can do more with the various watts we got around, but it probably

00:42:28.820 --> 00:42:30.640
won't make any significant difference, I guess.

00:42:30.640 --> 00:42:31.680
It's pretty cool though.

00:42:31.680 --> 00:42:33.980
So it's all pretty exciting.

00:42:33.980 --> 00:42:36.800
Like, are there things that we should be concerned of?

00:42:36.800 --> 00:42:41.460
You know, I mentioned like cryptography, getting in a cabin, checking out a society sort of

00:42:41.460 --> 00:42:41.720
thing.

00:42:41.720 --> 00:42:48.160
What should, I guess, we be careful of or just like, what would maybe be not a great consequence?

00:42:48.160 --> 00:42:52.240
Regarding this like loss of privacy, perhaps that people fear.

00:42:52.360 --> 00:42:58.540
I think quantum computing will actually help with that fear in some sense because of these

00:42:58.540 --> 00:43:05.260
proposals for different types of quantum key distribution protocols or just in general, how

00:43:05.260 --> 00:43:07.280
quantum computing will help cryptography.

00:43:07.280 --> 00:43:13.720
Even in some of the standard encryption conversations these days, I hear people talking about like

00:43:13.720 --> 00:43:21.040
quantum safe algorithms that are sort of resistant to being cracked by quantum computing techniques

00:43:21.040 --> 00:43:25.760
that are different than say, just depending upon exchanging primary key, primary numbers,

00:43:25.760 --> 00:43:27.000
primes.

00:43:27.000 --> 00:43:29.400
But do you have any experience with these?

00:43:29.400 --> 00:43:30.680
Do you know what that's about?

00:43:30.680 --> 00:43:35.240
I've definitely heard of them, but I don't think I have enough expertise to say anything.

00:43:35.420 --> 00:43:35.740
Sure.

00:43:35.740 --> 00:43:38.820
I'm just trying to understand like, what is that, you know, what does that algorithm look

00:43:38.820 --> 00:43:39.020
like?

00:43:39.020 --> 00:43:41.180
How, like, how do you implement something like that?

00:43:41.180 --> 00:43:45.380
That is just, I don't know, a problem that would be not so easily solved by quantum computing

00:43:45.380 --> 00:43:46.500
and pretty, pretty interesting.

00:43:46.500 --> 00:43:48.680
But just going back to if we should.

00:43:48.680 --> 00:43:49.740
Should we be worried, right?

00:43:49.740 --> 00:43:55.220
Like, it sounds like maybe there'll be this like rough patch while we transition algorithms,

00:43:55.220 --> 00:44:00.200
but maybe in the long term, quantum computing doesn't necessarily mean bad stuff for encryption

00:44:00.200 --> 00:44:00.740
and privacy.

00:44:01.040 --> 00:44:01.280
Yeah.

00:44:01.280 --> 00:44:06.540
And I just want to say, like, as with all technologies, I think we always need to be

00:44:06.540 --> 00:44:09.760
wary of where and how this new technology will be used.

00:44:09.760 --> 00:44:16.840
But I think given that quantum computing is still very much early in its stages, and we're

00:44:16.840 --> 00:44:22.720
trying to figure out how to really fully leverage its strengths and capabilities to do practical

00:44:22.720 --> 00:44:23.200
tasks.

00:44:23.580 --> 00:44:27.540
So I think those will be relevant questions, but just not right now.

00:44:27.540 --> 00:44:27.880
Right.

00:44:27.880 --> 00:44:29.980
We're a little too early for that.

00:44:29.980 --> 00:44:30.320
Yeah.

00:44:30.320 --> 00:44:30.600
Yeah.

00:44:30.600 --> 00:44:34.900
Probably what will happen is we'll come up with these amazing quantum computers and people

00:44:34.900 --> 00:44:39.300
will just use them to like animate GIFs, like with their head stuck on a cat or, you know,

00:44:39.300 --> 00:44:42.200
something kind of like now.

00:44:42.200 --> 00:44:42.560
Yeah.

00:44:42.560 --> 00:44:43.280
All right.

00:44:43.280 --> 00:44:45.820
So maybe we'll just leave it there for the quantum computers.

00:44:45.820 --> 00:44:47.280
That's really interesting.

00:44:47.280 --> 00:44:50.780
I have a slightly better understanding than I did before.

00:44:50.900 --> 00:44:52.700
Thank you for sharing all that.

00:44:52.700 --> 00:44:57.680
And of course, I'll put all the links to like the various computers and APIs and stuff in

00:44:57.680 --> 00:44:58.120
the show notes.

00:44:58.120 --> 00:45:01.680
So let me ask you the two final questions I ask at the end of the show.

00:45:01.680 --> 00:45:02.000
Always.

00:45:02.000 --> 00:45:06.960
If you're going to write some code, maybe some Python code to talk to a Rigotti server or

00:45:06.960 --> 00:45:08.840
something like that, what editor do you use?

00:45:08.840 --> 00:45:15.040
So I go back and forth between Sublime and Vim just because my dad was a software engineer

00:45:15.040 --> 00:45:17.120
and he exposed me to Vim.

00:45:17.120 --> 00:45:19.460
That's Vim from an early age.

00:45:19.460 --> 00:45:19.760
Awesome.

00:45:19.760 --> 00:45:20.620
All right.

00:45:20.620 --> 00:45:22.360
How about a notable PyPI package?

00:45:22.360 --> 00:45:25.740
Like many of these amazing things you've been talking about, you can literally pip install

00:45:25.740 --> 00:45:26.200
them, right?

00:45:26.200 --> 00:45:26.760
Yes.

00:45:26.760 --> 00:45:27.180
Yes.

00:45:27.180 --> 00:45:32.420
So I've already mentioned these two before, but of course, being a chemist, I really enjoy

00:45:32.420 --> 00:45:38.900
using OpenVermion for basically implementing quantum chemistry algorithms for quantum computers,

00:45:38.900 --> 00:45:43.360
as well as PyQuil, which I've mentioned earlier by Rigetti Computing.

00:45:43.360 --> 00:45:49.420
Not only is it really well tested and documented, but it has a really great Slack community where you

00:45:49.420 --> 00:45:54.380
can just post questions about the syntax as well as general questions about quantum computing.

00:45:54.380 --> 00:45:55.280
Oh, very cool.

00:45:55.560 --> 00:46:00.100
It's really nice to have these Slack communities or Gitter channels or whatever popping up

00:46:00.100 --> 00:46:04.660
that you can actually get in touch really easily with people doing similar things in all specials.

00:46:04.660 --> 00:46:05.220
Definitely.

00:46:05.220 --> 00:46:05.960
Yeah.

00:46:05.960 --> 00:46:06.200
Cool.

00:46:06.200 --> 00:46:07.280
All right.

00:46:07.280 --> 00:46:11.040
So it's not too early for people to get started with quantum computing.

00:46:11.040 --> 00:46:15.500
Now you say you think it's a good time to get started, build some experience and like

00:46:15.500 --> 00:46:17.340
play with some simulator, something like that.

00:46:17.340 --> 00:46:18.100
Yes, definitely.

00:46:18.100 --> 00:46:19.400
I encourage it highly.

00:46:19.400 --> 00:46:20.260
All right.

00:46:20.260 --> 00:46:20.660
Awesome.

00:46:20.660 --> 00:46:22.960
Well, Hannah, thank you so much for being on TalkByThan.

00:46:23.120 --> 00:46:24.000
Thank you, Michael.

00:46:24.000 --> 00:46:24.700
Bye.

00:46:24.700 --> 00:46:28.740
This has been another episode of Talk Python To Me.

00:46:28.740 --> 00:46:34.200
Today's guest was Hannah Sim, and this episode has been brought to you by Linode and ActiveState.

00:46:34.200 --> 00:46:38.140
Linode is bulletproof hosting for whatever you're building with Python.

00:46:38.140 --> 00:46:42.480
Get four months free at talkpython.fm/Linode.

00:46:42.520 --> 00:46:44.280
That's L-I-N-O-D-E.

00:46:44.280 --> 00:46:50.020
ActiveState gives you a faster way to build and secure open source runtimes.

00:46:50.020 --> 00:46:57.040
From your first line of code through to production, check it out at talkpython.fm/ActiveState.

00:46:57.040 --> 00:46:58.740
Want to level up your Python?

00:46:58.740 --> 00:47:03.920
If you're just getting started, try my Python jumpstart by building 10 apps or our brand new

00:47:03.920 --> 00:47:05.780
100 days of code in Python.

00:47:05.780 --> 00:47:09.580
And if you're interested in more than one course, be sure to check out the Everything Bundle.

00:47:09.580 --> 00:47:11.840
It's like a subscription that never expires.

00:47:11.840 --> 00:47:14.040
Be sure to subscribe to the show.

00:47:14.040 --> 00:47:16.220
Open your favorite podcatcher and search for Python.

00:47:16.220 --> 00:47:17.480
We should be right at the top.

00:47:17.480 --> 00:47:23.580
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct

00:47:23.580 --> 00:47:26.780
RSS feed at /rss on talkpython.fm.

00:47:26.780 --> 00:47:28.660
This is your host, Michael Kennedy.

00:47:28.660 --> 00:47:30.020
Thanks so much for listening.

00:47:30.020 --> 00:47:31.100
I really appreciate it.

00:47:31.420 --> 00:47:33.040
Now get out there and write some Python code.

00:47:33.040 --> 00:47:53.600
I'll see you next time.

