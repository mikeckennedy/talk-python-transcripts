WEBVTT

00:00:00.001 --> 00:00:03.220
Think about how you learn most technical or detail-oriented subjects.

00:00:03.220 --> 00:00:08.240
You start at the bottom, lowest level, and you create building blocks and work your way into the thing

00:00:08.240 --> 00:00:11.060
that eventually you get to that you actually care about.

00:00:11.060 --> 00:00:15.040
This happens in engineering. This happens in math. This even happens in programming.

00:00:15.040 --> 00:00:23.700
Our guest this week, Dr. Allen Downey, believes that computation and programming can help us turn this inside-out way of teaching right-side-out again.

00:00:23.700 --> 00:00:29.640
Join Alan and me as we discuss programming as a way of thinking and physical modeling and engineering in Python.

00:00:29.640 --> 00:00:35.240
This is Talk Python To Me, episode 119, recorded May 30th, 2017.

00:00:58.340 --> 00:01:05.860
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:01:05.860 --> 00:01:10.000
This is your host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy.

00:01:10.000 --> 00:01:16.460
Keep up with the show and listen to past episodes at talkpython.fm, and follow the show on Twitter via at Talk Python.

00:01:17.140 --> 00:01:20.480
This episode is brought to you by Linode and Rollbar.

00:01:20.480 --> 00:01:25.660
That's right. Welcome to Linode, who has joined Talk Python To Me as a major sponsor.

00:01:25.660 --> 00:01:30.620
Be sure to check out what both of them are offering during their segments. It really helps support the show.

00:01:30.620 --> 00:01:35.120
Hey, everyone. I have a quick announcement before we get to our conversation.

00:01:35.580 --> 00:01:42.460
I'm super excited to announce the availability of my next course, and this is one I've been wanting to write for a long time.

00:01:42.460 --> 00:01:45.100
It's MongoDB for Python developers.

00:01:45.100 --> 00:01:50.340
This is one of the most practical and real-world courses on document databases in MongoDB.

00:01:50.340 --> 00:01:55.060
You'll learn the native query syntax PyMongo and the ODM Mongo engine.

00:01:55.060 --> 00:01:58.340
We'll also cover performance tuning and production deployments.

00:01:58.600 --> 00:02:02.820
Get the MongoDB course right now at training.talkpython.fm.

00:02:02.820 --> 00:02:05.700
Alan, welcome to Talk Python.

00:02:05.700 --> 00:02:07.720
Thank you. It's a pleasure to be here.

00:02:07.720 --> 00:02:09.380
It's an honor to have you on the show.

00:02:09.380 --> 00:02:15.040
I'm really excited to bring this engineering aspect of Python to all the listeners.

00:02:15.040 --> 00:02:16.020
It'll be really fun, I think.

00:02:16.020 --> 00:02:16.560
I hope so.

00:02:16.560 --> 00:02:20.720
Indeed, indeed. It's really cool to see the different ways that people are using programming in Python

00:02:20.720 --> 00:02:30.320
and certainly to see how it's slowly eating away at the big commercial monolithic type things like MATLAB and Mathematica and so on.

00:02:30.320 --> 00:02:31.240
Right, right.

00:02:31.240 --> 00:02:32.020
Yeah, very fun.

00:02:32.020 --> 00:02:35.140
We're going to dig into that for sure, but let's start at the beginning.

00:02:35.140 --> 00:02:35.800
What's your story?

00:02:35.800 --> 00:02:37.240
How did you get into programming in Python?

00:02:37.240 --> 00:02:41.160
I got to Python in, I think, the year 2000.

00:02:41.160 --> 00:02:45.400
I have a great story, which is I actually was working in Java.

00:02:45.400 --> 00:02:48.440
I was teaching at Colby College up in Waterville, Maine.

00:02:48.440 --> 00:02:50.480
I was unhappy with the books.

00:02:50.480 --> 00:02:58.120
I was using, so I started writing a free open source textbook, and I wrote it in Java because that's the language I was teaching in.

00:02:58.120 --> 00:02:59.920
I didn't know Python at the time.

00:02:59.920 --> 00:03:01.620
I'm not sure I had even heard of Python.

00:03:01.620 --> 00:03:06.780
But there was a snake thing, and there was some kind of movie that British make that's kind of funny.

00:03:06.780 --> 00:03:08.300
And then, right, exactly.

00:03:08.300 --> 00:03:09.380
Exactly.

00:03:09.380 --> 00:03:18.680
But I put my Java book out under a free license, and Jeff Elkner, who was teaching high school in Virginia at the time, kind of took me up on the offer.

00:03:18.680 --> 00:03:20.180
I said, you know, you can take this book.

00:03:20.180 --> 00:03:21.100
You can modify it.

00:03:21.100 --> 00:03:22.200
You can do anything you want.

00:03:22.200 --> 00:03:26.940
And he translated it from Java into Python and sent it back to me.

00:03:27.420 --> 00:03:30.760
So I actually learned Python by reading my own book.

00:03:30.760 --> 00:03:31.200
Wow.

00:03:31.200 --> 00:03:34.480
Most people don't learn Python by reading their own book.

00:03:34.480 --> 00:03:35.760
That's a really crazy story.

00:03:35.760 --> 00:03:36.920
That's amazing.

00:03:36.920 --> 00:03:40.360
It's a strange experience because it sounded like me.

00:03:40.360 --> 00:03:44.340
It's my writing style, but it's telling me things I don't know.

00:03:44.340 --> 00:03:44.680
Oh, no.

00:03:44.680 --> 00:03:45.360
That is weird.

00:03:45.840 --> 00:03:51.100
It's like in movies where the future you comes back from the future and tells you things that you don't know.

00:03:51.100 --> 00:03:52.080
It's just like that.

00:03:52.080 --> 00:03:52.400
Yeah.

00:03:52.400 --> 00:03:53.180
Oh, my gosh.

00:03:53.180 --> 00:03:54.500
That's really, really interesting.

00:03:54.500 --> 00:04:00.780
It was a pretty unique thing to do back in the year 2000 to release books kind of open source, right?

00:04:00.780 --> 00:04:05.860
Like now it's pretty standard that many books have some online open source component to it.

00:04:05.860 --> 00:04:07.320
But that was not common then, was it?

00:04:07.420 --> 00:04:08.600
I don't think so.

00:04:08.600 --> 00:04:10.640
And I had no idea what I was doing.

00:04:10.640 --> 00:04:16.080
In fact, the first version, because I was writing in LaTeX, and LaTeX is almost a programming language,

00:04:16.080 --> 00:04:22.620
I released it under the GNU general public license because I thought of it as being source code.

00:04:22.620 --> 00:04:24.460
So that was the first license I used.

00:04:24.460 --> 00:04:28.260
This was before the Creative Commons licenses didn't exist yet.

00:04:28.260 --> 00:04:33.500
I switched at one point to the GNU free documentation license because that made more sense.

00:04:33.500 --> 00:04:36.260
And now I'm mostly using Creative Commons licenses.

00:04:36.620 --> 00:04:37.580
Okay, which Creative Commons?

00:04:37.580 --> 00:04:39.400
Because there's a bunch of variations, right?

00:04:39.400 --> 00:04:41.420
Yeah, different ones for different books.

00:04:41.420 --> 00:04:47.900
Part of it, most of mine are, I don't have the non-commercial clause on most of them.

00:04:47.900 --> 00:04:53.800
But for the ones that I'm publishing with O'Reilly, that's kind of the compromise that we've settled in on,

00:04:53.800 --> 00:04:58.140
which is that the versions that are on my webpage have the non-commercial clause.

00:04:58.140 --> 00:04:58.500
Right.

00:04:58.500 --> 00:05:01.200
And then O'Reilly has the exclusive commercial license.

00:05:01.200 --> 00:05:02.500
That seems like a pretty fair deal.

00:05:02.500 --> 00:05:03.620
I think it's not bad.

00:05:03.620 --> 00:05:08.360
What I've done a couple of times, when people have made a substantially modified version,

00:05:08.360 --> 00:05:11.440
I can give them another license.

00:05:11.440 --> 00:05:15.620
I can grant it to them under a license that does not have the non-commercial clause.

00:05:15.620 --> 00:05:19.500
So if someone makes a really small change, then that's still covered.

00:05:19.500 --> 00:05:21.920
But if they make a bigger change, then I've got some flexibility.

00:05:21.920 --> 00:05:22.300
Right.

00:05:22.300 --> 00:05:22.620
Okay.

00:05:22.620 --> 00:05:23.640
Yeah, very interesting.

00:05:24.140 --> 00:05:27.040
I think this way of learning Python is quite amazing.

00:05:27.040 --> 00:05:32.320
And, you know, it's probably not entirely new, given how many people there are in the world, but it's got to be pretty rare.

00:05:32.320 --> 00:05:34.720
So tell me, what was your experience?

00:05:34.720 --> 00:05:37.980
What was the impression of the language as you learned it?

00:05:37.980 --> 00:05:40.420
Were you like, why did they take away all the curly braces?

00:05:40.420 --> 00:05:41.220
This is so weird.

00:05:41.220 --> 00:05:43.260
Or were you like, oh, this is actually kind of amazing.

00:05:43.260 --> 00:05:44.040
What was your thought?

00:05:44.180 --> 00:05:45.920
Oh, no, I was hooked immediately.

00:05:45.920 --> 00:05:47.620
Again, I was coming from Java.

00:05:47.620 --> 00:05:57.760
And so I knew the frustration of teaching Java, which is all the stuff that you have to explain on the first day, just to write hello world.

00:05:57.760 --> 00:06:02.040
There's public, static, void, main, string, bracket, bracket, and all that.

00:06:02.040 --> 00:06:05.440
And in Python, of course, it's print hello world.

00:06:05.960 --> 00:06:06.440
Exactly.

00:06:06.440 --> 00:06:07.200
It's amazing.

00:06:07.200 --> 00:06:12.180
I feel like people that work in those languages like Java, and I consider myself among them.

00:06:12.180 --> 00:06:16.060
I did for a long time C++ development and some C# development.

00:06:16.060 --> 00:06:24.520
And they're highly structured with symbol type languages, not structured in format, but structured with many, many symbols around it.

00:06:24.520 --> 00:06:26.420
And you just feel like those are required.

00:06:26.420 --> 00:06:27.800
Those are the right way to do it.

00:06:27.800 --> 00:06:35.100
Everything must have curly braces and extra parentheses and whatnot until you realize that it doesn't have to be there.

00:06:35.100 --> 00:06:38.760
You can actually have a nice, clean language that's just equally expressive.

00:06:38.760 --> 00:06:42.420
And it's really liberating when you get there finally, I think.

00:06:42.420 --> 00:06:44.900
Right, because you end up having to do the indentation anyway.

00:06:44.900 --> 00:06:45.600
Yeah, exactly.

00:06:45.600 --> 00:06:49.360
So at that point, if you have to indent, you might as well take away the squiggly braces.

00:06:49.360 --> 00:06:50.500
Exactly.

00:06:50.500 --> 00:06:51.340
Fully embrace it.

00:06:51.340 --> 00:06:52.020
Fully embrace it.

00:06:52.020 --> 00:06:52.820
Great.

00:06:52.820 --> 00:06:56.580
So you said you wrote the book when you were teaching in Maine.

00:06:56.580 --> 00:06:59.020
And now you're still teaching at a university, right?

00:06:59.020 --> 00:07:00.660
But you're doing it a little farther south?

00:07:00.660 --> 00:07:01.220
Yes.

00:07:01.220 --> 00:07:03.880
I'm at Olin College, which is just outside of Boston.

00:07:04.240 --> 00:07:05.920
And it's an engineering school.

00:07:05.920 --> 00:07:07.640
So it's a little bit of a different environment.

00:07:07.640 --> 00:07:12.160
I used to do computer science in the context of a liberal arts education.

00:07:12.160 --> 00:07:16.460
And now I'm doing computing in the context of an engineering education.

00:07:16.460 --> 00:07:19.900
So is it a little more exploratory?

00:07:19.900 --> 00:07:28.360
Let's try to model these things and less learn how to write operating systems, learn how to create web apps or things like this.

00:07:28.360 --> 00:07:29.080
How's the difference?

00:07:29.300 --> 00:07:29.540
Right.

00:07:29.540 --> 00:07:29.920
Yeah.

00:07:29.920 --> 00:07:43.460
Part of it is that maybe less emphasis on theory, less emphasis on getting very deep into how things work, and more on using what's there and using it to solve the problems that you're trying to solve.

00:07:44.020 --> 00:07:45.800
Sometimes it's about engineering.

00:07:45.800 --> 00:07:48.680
Sometimes you are modeling physical systems.

00:07:48.900 --> 00:07:57.040
Other times it's developing software systems, but maybe more like software engineering and less like computer science.

00:07:57.040 --> 00:07:57.460
Right.

00:07:57.460 --> 00:08:03.860
People may disagree with me, but just coming from my background where I just minored in computer science, I didn't go all in.

00:08:04.240 --> 00:08:18.000
I feel like computer science and programming and software development kind of are the same thing, but the true computer science part of it is much more theoretical than what a lot of people do day to day, even though they might call themselves CS folks.

00:08:18.820 --> 00:08:24.540
And so I think you guys might have this more explicit here in your program, right?

00:08:24.540 --> 00:08:25.840
Yeah, I think that's right.

00:08:25.840 --> 00:08:30.200
I mean, computer science as a field is kind of a historical accident.

00:08:30.200 --> 00:08:36.600
It came out of math departments, and then it combined with some parts of engineering.

00:08:37.040 --> 00:08:39.220
I mean, there are pieces there that are mathematics.

00:08:39.220 --> 00:08:41.620
They are just, that's, they're discrete mathematics.

00:08:41.620 --> 00:08:46.460
There are parts that are the engineering of working with software.

00:08:46.460 --> 00:08:53.160
And then there are parts that are applications, you know, using computation in science and engineering and other fields.

00:08:53.160 --> 00:08:59.060
Those are three kind of different things that don't necessarily belong together in one department.

00:08:59.060 --> 00:08:59.500
Yeah.

00:08:59.500 --> 00:09:03.360
I suspect that in 50 years, they won't be one department anymore.

00:09:03.360 --> 00:09:03.720
Yeah.

00:09:04.080 --> 00:09:04.480
Okay.

00:09:04.480 --> 00:09:08.360
So in 50 years, would you imagine there might be an artificial intelligence department?

00:09:08.360 --> 00:09:09.320
Oh, interesting.

00:09:09.320 --> 00:09:10.200
I don't know.

00:09:10.200 --> 00:09:10.760
That might.

00:09:10.760 --> 00:09:13.840
Or data science where that AI is a big section of it or something?

00:09:13.840 --> 00:09:14.280
Yeah.

00:09:14.280 --> 00:09:18.540
Data science might make more sense as a field.

00:09:18.540 --> 00:09:20.060
I don't know.

00:09:20.060 --> 00:09:22.260
I can't even begin to think about what this will look like.

00:09:22.260 --> 00:09:23.960
It's hard to predict that far out, isn't it?

00:09:23.960 --> 00:09:24.260
Yeah.

00:09:24.260 --> 00:09:24.680
Sure.

00:09:24.680 --> 00:09:25.760
All right.

00:09:25.760 --> 00:09:29.040
So you teach a number of classes there, which is really cool.

00:09:29.040 --> 00:09:38.020
We'll dig into some of the learnings and takeaways from those around sort of fixing engineering education through programming.

00:09:38.020 --> 00:09:40.120
But let's start a little bit farther back.

00:09:40.120 --> 00:09:45.680
You wrote a really cool article called Programming as a Way of Thinking in Scientific American, right?

00:09:45.680 --> 00:09:46.200
Yes.

00:09:46.200 --> 00:09:47.080
It was on their blog.

00:09:47.080 --> 00:09:47.300
Yeah.

00:09:47.420 --> 00:09:47.560
Yeah.

00:09:47.560 --> 00:09:50.820
That's an honor, right, to be on Scientific American, a pretty cool place.

00:09:50.820 --> 00:09:53.760
So I recommend people check that out.

00:09:53.760 --> 00:09:54.560
I'll put a link to it.

00:09:54.560 --> 00:09:56.420
But could you maybe give us the synopsis?

00:09:56.420 --> 00:09:57.100
Sure.

00:09:57.300 --> 00:09:58.460
I mean, it's the idea.

00:09:58.460 --> 00:10:09.480
And it's not just Python, but other modern programming languages are now so expressive that I think we can move away from programming as translation.

00:10:09.480 --> 00:10:17.840
It used to be that you had to write everything out using mathematics and then translate it into executable code.

00:10:17.840 --> 00:10:22.300
And you see things like, you know, the name of, you know, Fortran is formula translation.

00:10:22.300 --> 00:10:24.560
That's what programming was.

00:10:24.560 --> 00:10:25.460
It's right in the name.

00:10:25.760 --> 00:10:28.560
I remember, yeah, I remember learning Fortran.

00:10:28.560 --> 00:10:31.740
I actually did a little bit of engineering work in college as well.

00:10:31.740 --> 00:10:35.800
And they told me, Fortran's the most important language you'll ever learn.

00:10:35.800 --> 00:10:37.620
Wait, see where that went.

00:10:37.620 --> 00:10:45.060
But I remember that, you know, when they would teach programming to some degree it was, and you make this flow chart, and then you translate it into the language.

00:10:45.060 --> 00:10:49.540
And that just seems so in the way these days, right?

00:10:49.540 --> 00:10:50.720
Why would you ever do this?

00:10:50.720 --> 00:10:53.180
It just, you write it out in the language, right?

00:10:53.180 --> 00:10:54.040
Right, right.

00:10:54.120 --> 00:11:01.160
And you see this now in the history of pseudocode, which is if you look at early pseudocode, it looks like mathematics notation.

00:11:01.160 --> 00:11:05.400
And then gradually it starts to look more and more like Python.

00:11:05.400 --> 00:11:08.840
Until you get to the point where it is Python.

00:11:08.840 --> 00:11:15.260
That you realize that the pseudocode is more readable if you just write it in Python.

00:11:15.260 --> 00:11:17.520
And furthermore, it's executable.

00:11:17.520 --> 00:11:20.300
And of course, being executable is huge.

00:11:20.800 --> 00:11:25.860
Not only because that's, you know, the purpose of code, but also now it's debuggable.

00:11:25.860 --> 00:11:28.840
So now you're taking these ideas that are in your head.

00:11:28.840 --> 00:11:33.760
You're expressing them directly in code without going through all these translation steps.

00:11:34.000 --> 00:11:41.340
And now while you're debugging that code, you are debugging your understanding of the ideas that you're expressing.

00:11:41.340 --> 00:11:42.680
You're debugging your own brain.

00:11:42.680 --> 00:11:42.980
Yeah.

00:11:42.980 --> 00:11:44.620
It's really, it really is amazing.

00:11:44.860 --> 00:11:55.140
And the fact that you can push a button and get the answer means some of these conceptual debates about things are often instantly solved.

00:11:55.140 --> 00:11:56.080
Right.

00:11:56.120 --> 00:11:58.420
I think of a lot of mathematical proofs.

00:11:58.420 --> 00:12:03.220
Like I'm thinking of particularly one in topology where I sat there for days working on this problem.

00:12:03.220 --> 00:12:06.340
And you can work out the proof and you can write it down.

00:12:06.340 --> 00:12:09.980
And it seems very much like programming, very much logical step, step, step, do this.

00:12:09.980 --> 00:12:13.440
You come to a conclusion, but you're never really sure.

00:12:13.440 --> 00:12:14.800
You're not a hundred percent sure.

00:12:14.800 --> 00:12:15.460
Right.

00:12:15.460 --> 00:12:25.520
Whereas if you can do this with a program, the cool thing is you can push a button or hit the inner key and see, you know, do I actually have this right?

00:12:25.520 --> 00:12:25.880
Right.

00:12:25.880 --> 00:12:28.060
There's this great story about Paul Erdős.

00:12:28.060 --> 00:12:29.380
And I don't know if you've heard this.

00:12:29.380 --> 00:12:38.640
This is the Monty Hall problem, which is this notorious problem in probability that almost everybody gets it wrong when they first hear this problem.

00:12:38.640 --> 00:12:43.380
And even once somebody tells you what the right answer is, most people don't believe it.

00:12:43.380 --> 00:12:45.440
It's just so counterintuitive.

00:12:45.440 --> 00:12:52.640
So Paul Erdős, when a friend of his told him this problem, this is one of the greatest mathematical minds of the 20th century.

00:12:52.640 --> 00:12:53.960
Yeah, he was truly amazing.

00:12:54.140 --> 00:12:56.760
And he lived in the world of mathematics.

00:12:56.760 --> 00:12:59.860
Unlike so many people, he didn't even really have possessions.

00:12:59.860 --> 00:13:02.400
He just went from department to department, right?

00:13:02.400 --> 00:13:04.940
Oh, I mean, he's a great story in his own right.

00:13:04.940 --> 00:13:09.200
But this particular problem just, it did not click with him.

00:13:09.200 --> 00:13:15.320
He refused to believe what is actually the correct answer until his friend showed him a computer simulation.

00:13:16.320 --> 00:13:21.760
And exactly as you said, the power of writing code and seeing it happen is what it took.

00:13:21.760 --> 00:13:25.380
There was no amount of mathematical proof that was going to be as persuasive.

00:13:25.380 --> 00:13:27.100
Yeah, that's really, really amazing.

00:13:27.100 --> 00:13:32.420
And so one of the things that really resonated with me from this program is a way of thinking.

00:13:32.580 --> 00:13:40.740
And I think anybody who presents ideas to other people, maybe you're working at a company, you're leading your team, you want to tell them about something.

00:13:40.740 --> 00:13:50.520
If you're a public speaker or if you're a teacher or whatever is traditionally, I feel like we've taught things in the reverse order, in the wrong order.

00:13:50.520 --> 00:13:54.980
Like, what I'm going to do is I'm going to spend three weeks teaching you a billion little details.

00:13:54.980 --> 00:13:59.860
And then in a month, you'll see that what you've actually learned is kind of cool and we'll see what we can do with it.

00:13:59.860 --> 00:14:00.780
Right.

00:14:00.780 --> 00:14:01.960
Right.

00:14:01.960 --> 00:14:03.100
That's such a problem, isn't it?

00:14:03.100 --> 00:14:03.580
Yes.

00:14:03.580 --> 00:14:04.080
Yes.

00:14:04.080 --> 00:14:11.520
And this is now, this is a major theme of these textbooks that I'm working on, which is exactly as you said, put the fun stuff first.

00:14:11.520 --> 00:14:13.240
Show me that it works.

00:14:13.240 --> 00:14:14.700
Show me why it's useful.

00:14:14.700 --> 00:14:16.420
What can I do with it?

00:14:16.420 --> 00:14:17.840
And now I'm interested.

00:14:18.020 --> 00:14:22.300
Now I want to know how it works and we can start going top down.

00:14:22.300 --> 00:14:25.980
We don't have to start with all the details and work our way up.

00:14:25.980 --> 00:14:26.200
Right.

00:14:26.200 --> 00:14:34.920
And what's interesting, basically what makes this really possible is we can execute the ideas and understand them from the outside in.

00:14:34.920 --> 00:14:35.320
Right.

00:14:35.320 --> 00:14:41.340
Like if you're going to teach math, like you can't solve a fast Fourier transform unless you literally like learn all the steps.

00:14:41.340 --> 00:14:41.620
Right.

00:14:41.620 --> 00:14:47.920
But if you're doing programming, you could grab like a simulation library or you want to teach threading.

00:14:47.980 --> 00:14:52.260
You could just use the simple async and await stuff and just start from the outer shell.

00:14:52.260 --> 00:14:53.020
Like how does this look?

00:14:53.020 --> 00:14:53.760
How do we use it?

00:14:53.760 --> 00:14:55.040
What's amazing about it?

00:14:55.040 --> 00:15:00.280
And then now let's dig in one layer and then another layer and another layer, like basically in reverse.

00:15:00.280 --> 00:15:00.580
Right.

00:15:00.580 --> 00:15:00.980
Right.

00:15:01.320 --> 00:15:08.060
And in fact, your Fourier transform example, that's exactly what I do in Think DSP, which is chapter one.

00:15:08.060 --> 00:15:10.380
I'm using Python and I'm using SciPy.

00:15:10.380 --> 00:15:12.480
It's all in Jupyter Notebooks.

00:15:12.700 --> 00:15:18.920
So right away, you can grab, download a sound, download an MP3 or make your own recording.

00:15:18.920 --> 00:15:20.820
Look at the Fourier transform.

00:15:20.820 --> 00:15:31.240
Look at what that spectrum looks like and understand what the Fourier transform does, how you're breaking a sound up and expressing it as a sum of frequency components.

00:15:31.900 --> 00:15:36.640
At the end of chapter one, you understand 90% of what you need to understand.

00:15:36.640 --> 00:15:40.500
And then the last 10% is how the Fourier transform actually works.

00:15:40.500 --> 00:15:40.900
Right.

00:15:40.900 --> 00:15:41.380
Yeah.

00:15:41.380 --> 00:15:45.320
I remember learning that stuff and it was always just like, wow, this is so in serious integration.

00:15:45.320 --> 00:15:46.240
What is going on here?

00:15:46.240 --> 00:15:54.380
But you don't actually see like amazing signals being extracted from some noisy environment or, you know, some signal or something.

00:15:54.380 --> 00:15:54.620
Yeah.

00:15:54.620 --> 00:15:55.400
That's really cool.

00:15:55.400 --> 00:15:55.760
Right.

00:15:55.760 --> 00:15:56.040
Right.

00:15:56.040 --> 00:15:58.140
You can start with auto-tune and work your way down.

00:15:58.140 --> 00:15:58.980
Exactly.

00:15:58.980 --> 00:16:09.480
One of the quotes you ended that article with that I wanted to share with everyone I thought was pretty cool is was basically that modern programming languages are quantitatively different from their predecessors.

00:16:09.480 --> 00:16:12.420
And we're only beginning to realize the implications of that difference.

00:16:12.420 --> 00:16:13.740
You want to add a little to that?

00:16:13.740 --> 00:16:16.100
That's a pretty amazing, pretty awesome thought, I think.

00:16:16.100 --> 00:16:18.320
I agree with people are just beginning to realize.

00:16:18.320 --> 00:16:19.000
Yes.

00:16:19.000 --> 00:16:32.480
So if we do translation, if we start out thinking in natural languages and then we express it in mathematics and then we have to translate it into code, we're limited to the set of things that we can express in all three languages.

00:16:32.480 --> 00:16:35.720
And we lose something at each step of the translation.

00:16:36.560 --> 00:16:45.740
So my conjecture is if we don't have to do the translation, if we work directly in code, potentially we will start writing things that look very different.

00:16:45.740 --> 00:16:51.600
We will start writing things that we would never have come to if we approach them mathematically.

00:16:51.600 --> 00:16:58.100
But I don't think we know yet what that's going to look like because that's not how we've been trained to think.

00:16:58.460 --> 00:17:07.780
I think it'll have to be the next generation who start out in Python, who start out using programming languages for exploration.

00:17:07.780 --> 00:17:12.180
And we'll see what they do that ends up being different from what we do.

00:17:12.180 --> 00:17:12.920
That's for sure.

00:17:12.920 --> 00:17:17.540
You know, I talk to people about how they got into programming or what was exciting to them all the time.

00:17:17.600 --> 00:17:26.320
And a lot of times it's, well, I first, you know, wrote my simple basic program and it did something on the screen, like echoed my name a hundred times.

00:17:26.320 --> 00:17:30.340
Or I made this turtle draw a square or something.

00:17:30.340 --> 00:17:35.580
I can easily see a world in 10 or 15 years where people start answering that question.

00:17:35.580 --> 00:17:40.680
Like the first thing I did was, well, I pulled up this Jupyter notebook and I typed in these things.

00:17:40.680 --> 00:17:44.020
And then I understood something totally different than before, right?

00:17:44.020 --> 00:17:44.800
Yes.

00:17:44.800 --> 00:17:45.780
Yes.

00:17:45.780 --> 00:17:52.220
Or if they're going through grade school and every class that they take involves an element of computation.

00:17:52.220 --> 00:17:55.360
I mean, right now there's kind of obvious stuff.

00:17:55.360 --> 00:18:00.420
Like when, if people are doing trigonometry, then maybe they'll do some computing along the way.

00:18:00.420 --> 00:18:06.520
But they're probably not doing things like analysis of word frequencies when they study a text.

00:18:06.520 --> 00:18:07.780
But you could do that.

00:18:07.780 --> 00:18:21.800
You could have students in middle school take a couple of different authors and look at the distribution of sentence lengths or the number of different words that people use in different types of articles or different authors.

00:18:21.800 --> 00:18:23.880
They could do that kind of analysis.

00:18:23.880 --> 00:18:24.480
Yeah.

00:18:24.480 --> 00:18:25.180
That's really interesting.

00:18:25.180 --> 00:18:35.340
I can imagine a world where the study of literature somewhat involves sentiment analysis on the text using machine learning or something like that, right?

00:18:35.340 --> 00:18:35.620
Right.

00:18:35.940 --> 00:18:41.040
And where that's not something that's unusual, but it's just, look, we've got computation as a tool.

00:18:41.040 --> 00:18:43.500
We're going to apply it to everything that we study.

00:18:43.500 --> 00:18:48.060
This portion of Talk Python To Me is brought to you by Linode.

00:18:48.060 --> 00:18:52.100
Are you looking for bulletproof hosting that is fast, simple, and incredibly affordable?

00:18:52.100 --> 00:18:57.280
Look past that bookstore and check out Linode at talkpython.fm/Linode.

00:18:57.280 --> 00:18:59.280
That's L-I-N-O-D-E.

00:18:59.280 --> 00:19:03.220
Plans start at just $5 a month for a dedicated server with a gig of RAM.

00:19:03.220 --> 00:19:05.800
They have 10 data centers across the globe.

00:19:05.800 --> 00:19:08.420
So no matter where you are, there's a data center near you.

00:19:08.420 --> 00:19:22.820
Whether you want to run your Python web app, host a private Git server, or even a file server, you'll get native SSDs on all the machines, a 40 gigabit network, 24-7 friendly support, even on holidays, and a seven-day money-back guarantee.

00:19:23.320 --> 00:19:26.160
Want a dedicated server for free for the next four months?

00:19:26.160 --> 00:19:31.640
Use the coupon code python17 at talkpython.fm/Linode.

00:19:31.640 --> 00:19:37.880
There's this big push for all kids around the world sort of learning to code.

00:19:37.880 --> 00:19:43.520
And I think what we're touching on definitely highlights some of the amazing reasons why that is.

00:19:44.260 --> 00:19:49.820
I don't feel like we need more programmers per se, although there's going to be a need for more programmers.

00:19:49.820 --> 00:19:55.840
I think we need more people with these skills that can, like you say, apply a little bit of computation to everything.

00:19:55.840 --> 00:19:59.160
Whatever it is they're doing, bring a little computation to it, right?

00:19:59.340 --> 00:19:59.700
I agree.

00:19:59.700 --> 00:20:02.640
I'm not trying to make everybody be a software engineer.

00:20:02.640 --> 00:20:05.060
We don't need that, and they don't want that.

00:20:05.060 --> 00:20:11.660
But I do think if people have basic programming skills, that becomes a pedagogic wedge.

00:20:11.660 --> 00:20:15.520
You use that as a lever to learn everything else.

00:20:15.520 --> 00:20:16.980
I don't know if it's a wedge or a lever.

00:20:16.980 --> 00:20:18.280
I might be mixing my metaphors.

00:20:18.280 --> 00:20:20.700
But it gives you a tool for learning.

00:20:20.700 --> 00:20:21.460
Yeah, for sure.

00:20:21.460 --> 00:20:28.460
And you have a pretty interesting place to apply that, or at least see that in action, at an engineering school where most people probably aren't programmers.

00:20:28.760 --> 00:20:30.680
But they really kind of need some computation, right?

00:20:30.680 --> 00:20:30.920
Right.

00:20:30.920 --> 00:20:36.560
We have a range of students, both when they come in, not everybody has programmed when they get here.

00:20:36.560 --> 00:20:39.820
So we are the first contact for many of them.

00:20:39.820 --> 00:20:42.780
And then when they leave, not everybody's going to do software.

00:20:42.780 --> 00:20:45.520
We have some who love it, and that's going to be their career.

00:20:45.520 --> 00:20:53.400
And others, especially, not to stereotype, but the folks doing mechanical engineering are not necessarily the ones who love software.

00:20:53.400 --> 00:20:58.180
But the chances are they're going to do something with software at some point in their careers.

00:20:58.180 --> 00:21:04.800
Yeah, if even it's just to write some Python script to automate something that actually is the application they're modeling with, right?

00:21:04.800 --> 00:21:05.100
Right.

00:21:05.100 --> 00:21:07.240
At the very least, they can automate the boring stuff.

00:21:07.240 --> 00:21:08.280
Exactly.

00:21:08.280 --> 00:21:08.760
All right.

00:21:08.760 --> 00:21:13.200
So maybe that's a good place to segue into your physical modeling stuff.

00:21:13.200 --> 00:21:16.620
So let's talk about physical modeling in Python.

00:21:16.620 --> 00:21:18.480
You're doing a course there.

00:21:18.480 --> 00:21:22.040
You've got some cool libraries and stuff that you're working with.

00:21:22.120 --> 00:21:25.360
You said you're basically trying to fix engineering education.

00:21:25.360 --> 00:21:26.380
Maybe we could start with that.

00:21:26.380 --> 00:21:27.600
That's the Olin mission.

00:21:27.600 --> 00:21:33.860
So Olin College was founded because the founders thought that engineering education is broken.

00:21:33.860 --> 00:21:34.680
Why is it broken?

00:21:34.680 --> 00:21:35.480
A couple of ways.

00:21:35.480 --> 00:21:39.980
You know, one of them is that it's divorced from the people that we're designing for.

00:21:40.460 --> 00:21:45.760
So engineers, I use this analogy that it's as if the engineer is sitting in a box.

00:21:45.760 --> 00:21:49.900
Somebody comes and slides a well-formulated problem under the door.

00:21:50.280 --> 00:21:59.260
And you have no idea where it came from, but you craft a beautiful engineering solution and you slide it under another door with no idea where it's going.

00:21:59.260 --> 00:22:00.860
And that doesn't work.

00:22:00.860 --> 00:22:04.320
Engineers have to understand the people they're designing for.

00:22:04.320 --> 00:22:06.740
They have to identify opportunities.

00:22:06.740 --> 00:22:13.280
They have to formulate those beautiful problems and figure out, first of all, is there an engineering solution?

00:22:13.280 --> 00:22:14.520
Because not always.

00:22:14.520 --> 00:22:16.140
Is there going to be one?

00:22:16.940 --> 00:22:19.960
And then if there is, great, let's do the engineering.

00:22:19.960 --> 00:22:21.520
Let's craft a beautiful solution.

00:22:21.520 --> 00:22:27.180
But now there's a ton of work to get that idea out of the lab and make it real in the world.

00:22:27.180 --> 00:22:36.980
So engineering education has to hit all three parts of that, designing for people and then crafting an engineering solution and then getting it out into the world.

00:22:36.980 --> 00:22:40.420
Yeah, that sounds like a really nice way to structure everything.

00:22:40.420 --> 00:22:43.980
You also talked about the science and math death march.

00:22:43.980 --> 00:22:44.820
What is this?

00:22:45.580 --> 00:22:49.660
Well, that's the other big problem with engineering education is that there's not enough engineering.

00:22:49.660 --> 00:22:58.700
Students don't see anything that really looks like engineering, that looks like the practice of engineering, at least for the first two years.

00:22:58.700 --> 00:23:02.840
Very often they're doing math and science and other prerequisites.

00:23:02.840 --> 00:23:09.380
And they treat engineering as if it's the reward that you get for surviving past all those hurdles.

00:23:09.380 --> 00:23:15.300
But even then it tends to be, even in the second and third and fourth years, it tends to be very theoretical.

00:23:15.300 --> 00:23:24.660
So students often graduate with a lot of ability to solve the problems that are in the textbook, but very little ability to do real engineering.

00:23:25.080 --> 00:23:26.740
Yeah, that was my experience in college.

00:23:26.740 --> 00:23:38.300
So I feel like taking programming and simulations and letting you sort of start before you fully understand all the way down is a way you could maybe move the engineering up.

00:23:38.300 --> 00:23:38.740
Yeah.

00:23:38.740 --> 00:23:42.720
So this is the course that I'm working on right now is called Modeling and Simulation.

00:23:42.720 --> 00:23:45.960
And this is part of the first semester at Olin.

00:23:45.960 --> 00:23:48.740
We have three classes that go in parallel.

00:23:48.740 --> 00:23:52.840
Modeling and Simulation is about doing physical modeling.

00:23:53.040 --> 00:23:55.120
So you've got a physical system.

00:23:55.120 --> 00:23:59.820
You make a model of what are the important parts that you have to include?

00:23:59.820 --> 00:24:01.980
What are the things that you can leave out and simplify?

00:24:01.980 --> 00:24:10.800
And then do either mathematical analysis or computational simulation to use that model to either predict something.

00:24:10.800 --> 00:24:12.940
You know, what will this system do in the future?

00:24:12.940 --> 00:24:16.120
Explain why the system behaves the way it does.

00:24:16.320 --> 00:24:19.140
Or to design something to do some kind of optimization.

00:24:19.140 --> 00:24:19.500
Okay.

00:24:19.500 --> 00:24:22.500
And this is like, welcome to the university.

00:24:22.500 --> 00:24:23.720
Here's your dorm.

00:24:23.720 --> 00:24:25.000
Here's where you get textbooks.

00:24:25.000 --> 00:24:26.600
We'll see you on Monday in this class.

00:24:26.600 --> 00:24:27.300
Like that early?

00:24:27.300 --> 00:24:29.300
That is, yes, that's exactly right.

00:24:29.300 --> 00:24:32.100
And it's, we do some programming.

00:24:32.420 --> 00:24:37.620
So of the first year classes, this is the one that has the most software in it.

00:24:37.620 --> 00:24:41.020
And, but again, I mentioned most people are coming in, they haven't programmed before.

00:24:41.020 --> 00:24:49.860
So we are simultaneously learning a little bit of programming, but with the immediate goal of modeling physical systems.

00:24:49.860 --> 00:24:51.840
That carves it down.

00:24:51.840 --> 00:24:57.740
We can teach a very small subset of the language because it's not general purpose programming yet.

00:24:57.740 --> 00:25:00.020
It's really application focused.

00:25:00.360 --> 00:25:06.100
It's not a full multi-tier web application with a database back in the scale.

00:25:06.100 --> 00:25:07.200
No, no, no.

00:25:07.200 --> 00:25:11.860
Just, we're going to run this math problem against this data and go, right?

00:25:11.860 --> 00:25:12.440
Exactly.

00:25:12.440 --> 00:25:12.980
Right.

00:25:12.980 --> 00:25:20.260
So, you know, some of the first examples are just four loops where you're updating a variable that just measures, you know, the quantity of something.

00:25:20.260 --> 00:25:22.820
We're doing a bike sharing example.

00:25:22.820 --> 00:25:29.800
Probably one of the first examples is, you know, you've got three different stations and your customers are moving bikes from one station to another.

00:25:29.800 --> 00:25:34.980
And we're going to simulate that process and figure out, is there going to be an equilibrium?

00:25:34.980 --> 00:25:36.980
Or are we going to run out of bikes?

00:25:36.980 --> 00:25:39.140
Do we have to move the bikes around?

00:25:39.860 --> 00:25:45.120
So, with a very simple model, I mean, we're talking about three variables and addition and subtraction.

00:25:45.120 --> 00:25:47.440
But we can get some interesting questions.

00:25:47.440 --> 00:25:48.680
We can see equilibrium.

00:25:48.680 --> 00:25:50.140
We can see non-equilibrium.

00:25:50.140 --> 00:25:52.280
We can evaluate different strategies.

00:25:52.280 --> 00:25:55.520
Like, should I move the same number of bikes every day?

00:25:55.520 --> 00:25:59.020
Or should I measure something and make decisions dynamically?

00:25:59.020 --> 00:26:00.120
All kinds of things.

00:26:00.120 --> 00:26:00.500
Yeah.

00:26:00.500 --> 00:26:02.920
And that definitely ties back to the real world.

00:26:02.920 --> 00:26:19.000
I just heard today, I think it was today, maybe a few days ago, that Uber is running some program where or feature where it's cheaper to get cars where there's too many cars if your destination is in a place where they need to basically move a car to effectively.

00:26:19.000 --> 00:26:20.500
Ah, yes.

00:26:20.500 --> 00:26:24.040
So, here it is, just on a much larger scale, right?

00:26:24.040 --> 00:26:24.420
Right.

00:26:24.420 --> 00:26:26.240
So, almost the opposite of surge pricing.

00:26:26.240 --> 00:26:29.380
It'll be a discount if you happen to be going where we want you to go.

00:26:29.380 --> 00:26:32.260
Yeah, I think that's what, yeah, they called it like a power zone or something.

00:26:32.260 --> 00:26:33.060
I think it was Uber.

00:26:33.060 --> 00:26:34.560
It could have been Lyft, but I'm pretty sure it's Uber.

00:26:34.560 --> 00:26:35.440
Ah, interesting.

00:26:35.440 --> 00:26:35.760
Yeah.

00:26:35.760 --> 00:26:41.100
So, okay, you come in and you have them do these models and they can do it computationally.

00:26:41.100 --> 00:26:42.120
Do they do that in Python?

00:26:42.120 --> 00:26:46.400
Until this coming year, everything has been MATLAB, which has worked okay.

00:26:46.400 --> 00:26:49.400
It's got some nice tools built in.

00:26:49.780 --> 00:26:55.020
So, there are things like there's an ODE solver, there's a root finder, there's an optimization tool.

00:26:55.020 --> 00:26:56.360
And those are great.

00:26:56.360 --> 00:26:58.120
Again, thinking about going top down.

00:26:58.120 --> 00:27:01.080
We can use those tools before we understand how they work.

00:27:01.080 --> 00:27:02.680
So, that's been good.

00:27:02.680 --> 00:27:05.100
But we're switching to Python starting this fall.

00:27:05.100 --> 00:27:05.940
Oh, that's exciting.

00:27:05.940 --> 00:27:11.640
So, you guys are getting ready over the summer and then it's going to launch in Python for the next set of students, huh?

00:27:11.640 --> 00:27:12.200
Yes.

00:27:12.200 --> 00:27:19.280
So, this is my big project this summer is rewriting a lot of the materials that we have, switching over from MATLAB to Python.

00:27:19.420 --> 00:27:19.900
Okay, excellent.

00:27:19.900 --> 00:27:23.060
And this time, you're going to be writing the Python, not someone sending it back to you.

00:27:23.060 --> 00:27:24.580
Exactly.

00:27:24.580 --> 00:27:26.480
Oh, that sounds really great.

00:27:26.480 --> 00:27:28.640
Do you think that this would be, I'm sure it would be possible.

00:27:28.640 --> 00:27:33.820
Would this be a likely thing without IPython notebooks and Jupyter and all that kind of stuff?

00:27:33.820 --> 00:27:34.800
It certainly could.

00:27:34.920 --> 00:27:36.220
I think it would be less good.

00:27:36.220 --> 00:27:42.000
I think one of the nice things about Jupyter is the students can just check out a notebook.

00:27:42.800 --> 00:27:51.460
And there's a nice pedagogic process there where the first time through, they can just read the code and execute it and see what it does.

00:27:52.120 --> 00:28:00.960
And maybe on the second pass, they're just making small changes, like try and experiment, change a parameter, put a couple of extra statements here or there.

00:28:01.280 --> 00:28:02.780
And I think you're modifying code.

00:28:02.780 --> 00:28:09.840
You can learn a lot from doing that before they get to the third step, which is really, okay, now you're going to create code from scratch.

00:28:09.840 --> 00:28:10.180
Sure.

00:28:10.180 --> 00:28:12.000
I think that's nice to start that way.

00:28:12.360 --> 00:28:15.820
Especially this is almost like their first programming course, at least for some of them.

00:28:15.820 --> 00:28:21.180
So they come in and say, well, what if we moved three bikes a day instead of just two?

00:28:21.180 --> 00:28:23.300
How does that change the equilibrium and play with it?

00:28:23.300 --> 00:28:24.140
And you have the nice pictures.

00:28:24.140 --> 00:28:25.120
Yeah, it's pretty cool.

00:28:25.120 --> 00:28:28.580
And there's a lot of room for the students who are just learning to program.

00:28:28.580 --> 00:28:34.300
We're going to have kind of the lower bound that says, okay, we want to make sure that everybody gets to this level.

00:28:34.300 --> 00:28:40.400
At the same time, people who are coming in with experience or people who just pick it up quickly, they can go crazy.

00:28:40.400 --> 00:28:41.980
I mean, there's a ton that they can go and do.

00:28:42.180 --> 00:28:42.720
Yeah, cool.

00:28:42.720 --> 00:28:46.400
So what are some of the libraries you're planning on using for this?

00:28:46.400 --> 00:28:48.160
So a lot of it is SciPy.

00:28:48.160 --> 00:28:50.720
I mentioned some of the tools in MATLAB.

00:28:50.720 --> 00:28:55.160
We need an ODE solver, and there's a good one in SciPy.

00:28:55.160 --> 00:28:57.940
A root finder, optimization tools.

00:28:57.940 --> 00:29:00.780
That's basically it, and that's coming straight out of SciPy.

00:29:00.780 --> 00:29:04.920
And then the other library that I'm looking at is called Pint.

00:29:04.920 --> 00:29:08.280
And this does units, units and dimensions.

00:29:09.220 --> 00:29:13.740
This, I think, if this works, will be really good.

00:29:13.740 --> 00:29:16.020
Because we're doing physical modeling.

00:29:16.020 --> 00:29:18.840
And in physical modeling, everything is a quantity.

00:29:18.840 --> 00:29:24.560
If you tell me that the answer is five, my question is going to be, five what?

00:29:24.560 --> 00:29:26.060
Five meters?

00:29:26.060 --> 00:29:26.920
Five seconds?

00:29:27.240 --> 00:29:28.260
Tell me the units.

00:29:28.260 --> 00:29:29.080
Tell me the dimensions.

00:29:29.080 --> 00:29:37.120
So one opportunity here is to do computation where every quantity has its units attached

00:29:37.120 --> 00:29:39.580
to it, and they carry through the computation.

00:29:39.580 --> 00:29:45.180
So if you try to add two things, it's going to check to see if they have the same units.

00:29:45.180 --> 00:29:47.200
And if they don't, it's going to give you an error.

00:29:47.460 --> 00:29:48.660
You can't add joules and kilograms.

00:29:48.660 --> 00:29:49.260
What are you doing?

00:29:49.260 --> 00:29:49.920
Exactly.

00:29:49.920 --> 00:29:50.880
Exactly.

00:29:50.880 --> 00:29:57.000
And if you look at the number of real scientific and engineering projects that have run into

00:29:57.000 --> 00:30:03.280
problems because the units got messed up, including, I think it was at the Mars climate probe that

00:30:03.280 --> 00:30:08.300
was destroyed because they had, I think, both feet and meters.

00:30:08.300 --> 00:30:10.700
And that was the end of that.

00:30:10.700 --> 00:30:10.980
Yeah.

00:30:10.980 --> 00:30:12.060
That's really unfortunate.

00:30:12.060 --> 00:30:20.760
We in the U.S. probably have a little bit of blame to take for keeping the feet, the imperial units

00:30:20.760 --> 00:30:21.440
still around.

00:30:21.440 --> 00:30:22.340
Oh, yeah.

00:30:22.340 --> 00:30:24.040
The rest of the world has tried to move on.

00:30:24.040 --> 00:30:24.640
And we're like, nope.

00:30:24.640 --> 00:30:25.860
We love our feet.

00:30:25.860 --> 00:30:28.400
Still measuring things in drams per fortnight.

00:30:28.400 --> 00:30:29.420
Exactly.

00:30:29.420 --> 00:30:33.700
But even so, you still have centimeters versus meter.

00:30:33.700 --> 00:30:37.920
I mean, there's certainly room for this error, even in the unit system, the metric system,

00:30:37.920 --> 00:30:38.340
rather.

00:30:38.340 --> 00:30:42.260
You'd mentioned Pite earlier when we were getting things set up, and I'd forgotten.

00:30:42.260 --> 00:30:43.560
I did check this out.

00:30:43.560 --> 00:30:44.500
This is really cool.

00:30:44.500 --> 00:30:50.580
So you can, say, create one of these Pite-type things, and you can say, like, three times meters

00:30:50.580 --> 00:30:55.020
plus four times centimeters, and it will, you know, make that 3.04 meters, right?

00:30:55.020 --> 00:30:55.560
Things like that.

00:30:55.560 --> 00:30:57.220
It really makes it obvious and easy.

00:30:57.220 --> 00:30:57.720
Yes.

00:30:57.720 --> 00:30:58.360
Yep.

00:30:58.460 --> 00:31:03.740
So it'll do error checking, or if you multiply two things together, the result will have the

00:31:03.740 --> 00:31:06.280
right units, and it'll reduce units.

00:31:06.280 --> 00:31:10.520
So if you express something as some crazy combination, it'll say, oh, that's Jules.

00:31:10.520 --> 00:31:10.900
Yeah.

00:31:10.900 --> 00:31:12.200
Really?

00:31:12.200 --> 00:31:14.040
Yeah, Jules is a crazy unit.

00:31:14.040 --> 00:31:21.080
So I think this highlights one of the things where, say, MATLAB or one of these package systems,

00:31:21.080 --> 00:31:24.780
it's kind of nice in that it's self-contained and whatnot, but I don't think MATLAB has this

00:31:24.780 --> 00:31:26.780
concept of this Pint library.

00:31:26.780 --> 00:31:30.900
And if it has the Pint, there's, you know, a thousand other Python such libraries that

00:31:30.900 --> 00:31:34.580
are really cool to bring in to just sort of make it more expressive, right?

00:31:34.580 --> 00:31:35.000
Right.

00:31:35.000 --> 00:31:40.760
And it also, when you're comparing languages, there's theoretically, all languages are equivalent

00:31:40.760 --> 00:31:43.540
in the sense that they can compute all computable functions.

00:31:43.540 --> 00:31:45.800
But there are pragmatic things.

00:31:46.060 --> 00:31:51.660
There are, you know, some things are hard or easy, but there's also culture, which is around

00:31:51.660 --> 00:31:52.700
MATLAB culture.

00:31:52.700 --> 00:31:59.620
People tend to write fairly simple programs that are mostly script-like in the sense that

00:31:59.620 --> 00:32:01.760
you're just combining existing features.

00:32:01.960 --> 00:32:07.440
You're not often writing functions or functions that use other functions.

00:32:07.440 --> 00:32:09.080
You're not writing objects.

00:32:09.080 --> 00:32:12.160
You're not building up layers of abstraction.

00:32:12.160 --> 00:32:12.640
Right.

00:32:12.640 --> 00:32:16.020
You're not building reusable concepts.

00:32:16.020 --> 00:32:21.880
You're taking other people's reusable concepts and making it like a final product, right?

00:32:22.400 --> 00:32:25.740
Maybe not a well-factored one, but something that like, this is done when this runs.

00:32:25.740 --> 00:32:30.140
I'm not going to like open source this in a way that other people can easily build on, probably.

00:32:30.140 --> 00:32:31.780
I think that's often true.

00:32:31.780 --> 00:32:33.600
And not because it's impossible.

00:32:33.840 --> 00:32:39.180
I mean, I think there is object-oriented MATLAB out there, but it's not commonly used.

00:32:39.180 --> 00:32:46.320
When you come to the Python cultural ecosystem, it's more of a software engineering world.

00:32:46.320 --> 00:32:51.100
There's more abstraction, more functional decomposition, more object-oriented programming.

00:32:51.100 --> 00:32:57.660
So at the risk of starting a programming language war, the overall level of software engineering

00:32:57.660 --> 00:32:58.780
tends to be higher.

00:32:58.780 --> 00:33:01.560
So the tools you're working with are more abstract.

00:33:02.360 --> 00:33:10.040
And then from my point of view as an instructor, now I can build abstraction to put between

00:33:10.040 --> 00:33:12.460
the students and the tools that they're using.

00:33:12.460 --> 00:33:17.380
So what I'm planning to do, I'm making a library that's called modsim.py.

00:33:17.380 --> 00:33:22.180
Most of what the students do, at least when they're getting started, is they're going to

00:33:22.180 --> 00:33:23.820
use things from my library.

00:33:23.820 --> 00:33:26.080
So I can put wrappers around things.

00:33:26.080 --> 00:33:28.740
I can hide the details that they don't need to know about yet.

00:33:29.400 --> 00:33:34.160
If I see them making the same errors over and over, I can generate really good error messages.

00:33:34.160 --> 00:33:36.320
I can do argument checking.

00:33:36.320 --> 00:33:40.600
I can just help them get over what I know the rough spots are going to be.

00:33:40.700 --> 00:33:42.480
I think that's a great, great point.

00:33:42.480 --> 00:33:49.380
I've had a couple of people who were teaching classes and then they've had students teaching

00:33:49.380 --> 00:33:54.920
classes that were somehow computational and using Python said, why do I need to learn Python?

00:33:54.920 --> 00:33:59.320
Can't I just learn MATLAB or Mathematica and just go on?

00:33:59.320 --> 00:34:02.700
Like I've asked Jake Venderplass what he thought about this, like what he would respond.

00:34:02.700 --> 00:34:06.540
What would you tell a student who comes and says, I don't really want to learn Python or

00:34:06.540 --> 00:34:06.900
programming.

00:34:07.040 --> 00:34:10.100
Can we just use MATLAB for this example or this class?

00:34:10.100 --> 00:34:10.880
Well, you could.

00:34:10.880 --> 00:34:14.600
And I'm not trying to say I'm not a total zealot.

00:34:14.600 --> 00:34:18.060
And we've been teaching MATLAB for this class since 2009.

00:34:18.060 --> 00:34:19.100
It's not impossible.

00:34:19.100 --> 00:34:19.860
It's not terrible.

00:34:19.860 --> 00:34:25.100
I think it's an okay first language, but I think Python is better.

00:34:25.100 --> 00:34:26.560
I think it's a better first language.

00:34:26.560 --> 00:34:29.300
Just I think the rough spots are smoother.

00:34:29.300 --> 00:34:31.080
It's easier to get started.

00:34:31.080 --> 00:34:37.140
And it's a general purpose programming language, which means that all of the effort that you

00:34:37.140 --> 00:34:43.260
put into learning it will pay off not just for this class, but for any other class that

00:34:43.260 --> 00:34:43.760
you're taking.

00:34:43.760 --> 00:34:46.780
So you get a little bit more reward from that investment.

00:34:46.780 --> 00:34:47.100
Yeah.

00:34:47.100 --> 00:34:48.420
I think that's, that's really interesting.

00:34:48.420 --> 00:34:53.060
And I think Jake Vanderplass maybe even touched on this on his keynote at PyCon last week

00:34:53.060 --> 00:35:00.380
and that not everybody who goes through an engineering program or astronomy program or whatever is

00:35:00.380 --> 00:35:04.060
going to be just an astronomer or just an engineer on the other side.

00:35:04.280 --> 00:35:08.600
And so learning something like Python gives you a super marketable and flexible skill.

00:35:08.600 --> 00:35:13.560
Learning something very focused in that discipline makes it less, right?

00:35:13.560 --> 00:35:18.400
So it's also, also good job diversification possibilities, I guess.

00:35:18.400 --> 00:35:19.520
Yeah, I think that's right.

00:35:19.520 --> 00:35:21.240
I'm teaching at an engineering college.

00:35:21.240 --> 00:35:25.980
So in some sense we are focused, but not all of our students are going to be engineers.

00:35:25.980 --> 00:35:32.180
One of the things that we say is that engineering education is great preparation for a lot of things,

00:35:32.180 --> 00:35:33.140
not just engineering.

00:35:33.140 --> 00:35:33.580
Sure.

00:35:34.100 --> 00:35:38.360
And you could go work at somewhere like Autodesk and work on AutoCAD, for example, right?

00:35:38.360 --> 00:35:44.160
Or something like some company that makes software for engineers, but you could end up only using

00:35:44.160 --> 00:35:46.560
a little of engineering and a lot more programming skills, right?

00:35:46.560 --> 00:35:46.860
Sure.

00:35:46.860 --> 00:35:47.280
Yeah.

00:35:47.280 --> 00:35:49.740
Hey everyone, Michael here.

00:35:49.740 --> 00:35:53.080
Let me take just a moment and thank one of our sponsors who makes this show possible.

00:35:53.080 --> 00:35:56.220
This portion of Talk Python To Me has been brought to you by Rollbar.

00:35:56.220 --> 00:35:59.720
One of the frustrating things about being a developer is dealing with errors.

00:35:59.720 --> 00:36:04.040
Relying on users to report errors, digging through log files, trying to debug them,

00:36:04.040 --> 00:36:07.320
or a million alerts just flooding your inbox and ruining your day.

00:36:07.320 --> 00:36:12.260
With Rollbar's full stack error monitoring, you get the context, insight, and control you

00:36:12.260 --> 00:36:14.320
need to find and fix bugs faster.

00:36:14.320 --> 00:36:19.120
Adding the Rollbar Python SDK is just as easy as pip install Rollbar.

00:36:19.120 --> 00:36:22.880
You can start tracking production errors and deployments in eight minutes or less.

00:36:22.880 --> 00:36:27.560
Rollbar works with all the major languages and frameworks, including the Python ones like

00:36:27.560 --> 00:36:32.380
Django, Flask, Pyramid, as well as Ruby, .NET, Node, iOS, and Android.

00:36:32.380 --> 00:36:35.060
You can integrate Rollbar into your existing workflow.

00:36:35.060 --> 00:36:39.280
Send error alerts to Slack or HipChat or automatically create new JIRA issues,

00:36:39.280 --> 00:36:41.020
pivotal tracker issues, and a lot more.

00:36:41.020 --> 00:36:43.480
They have a special offer for Talk Python To Me listeners.

00:36:43.760 --> 00:36:46.100
Visit talkpython.fm/Rollbar.

00:36:46.100 --> 00:36:49.040
Sign up and get the bootstrap plan free for 90 days.

00:36:49.040 --> 00:36:51.440
That's 100,000 errors tracked for free.

00:36:51.440 --> 00:36:55.300
But, you know, just between you and me, I hope you don't encounter that many errors.

00:36:55.300 --> 00:36:57.200
Give Rollbar a try today.

00:36:57.200 --> 00:37:00.000
Just go to talkpython.fm/Rollbar.

00:37:00.920 --> 00:37:03.080
You talked at the beginning about your book.

00:37:03.080 --> 00:37:04.180
What was the title?

00:37:04.180 --> 00:37:04.960
Did you say the title?

00:37:04.960 --> 00:37:05.660
Thinking?

00:37:05.660 --> 00:37:06.860
Think Python, right?

00:37:06.860 --> 00:37:07.680
Think Python.

00:37:07.680 --> 00:37:08.440
Yes.

00:37:08.440 --> 00:37:09.020
Right.

00:37:09.020 --> 00:37:10.960
So that's a really great book.

00:37:10.960 --> 00:37:15.840
And it's almost like Computer Science 101 getting started with programming, right?

00:37:15.840 --> 00:37:16.600
It is.

00:37:16.600 --> 00:37:19.320
It's meant for people who have never programmed before.

00:37:19.320 --> 00:37:22.420
So it really starts from X equals five.

00:37:22.420 --> 00:37:23.340
This is a variable.

00:37:23.340 --> 00:37:24.280
This is a value.

00:37:24.280 --> 00:37:28.620
But it's meant to be mostly language agnostic.

00:37:29.200 --> 00:37:33.640
So the principles are the same across lots of different programming languages.

00:37:33.640 --> 00:37:36.900
Certainly the family of imperative programming languages.

00:37:36.900 --> 00:37:42.540
In fact, there are now, there are translations of the book in, you know, Java and Python.

00:37:42.540 --> 00:37:45.960
And actually the most recent one is Perl 6.

00:37:45.960 --> 00:37:50.140
The book, Think Perl 6, just comes out, just came out this week.

00:37:50.140 --> 00:37:51.080
Oh, that's pretty cool.

00:37:51.080 --> 00:37:52.560
Yeah, very nice.

00:37:52.560 --> 00:37:52.840
Okay.

00:37:52.840 --> 00:37:54.760
So what other books have you written?

00:37:54.760 --> 00:37:58.620
I know you talked about your digital signal processing one, right?

00:37:58.620 --> 00:37:59.000
Right.

00:37:59.120 --> 00:38:00.260
So that's ThinkDSP.

00:38:00.260 --> 00:38:07.040
And then the two, the data science books are ThinkStats, which is mostly about exploratory

00:38:07.040 --> 00:38:07.940
data analysis.

00:38:07.940 --> 00:38:12.120
And then ThinkBase, which is specifically about doing Bayesian statistics.

00:38:12.120 --> 00:38:12.640
All right.

00:38:12.640 --> 00:38:15.740
Are those open source in the same sense that ThinkPython was?

00:38:15.740 --> 00:38:16.220
Yes.

00:38:16.220 --> 00:38:17.200
Yeah, they all are.

00:38:17.200 --> 00:38:21.520
So those are all, my webpage is greenteepress.com.

00:38:21.520 --> 00:38:23.500
Or if you just Google my name.

00:38:23.500 --> 00:38:26.660
Yeah, I'll link to all the, I'll be sure to link to them as well in the show notes.

00:38:26.660 --> 00:38:27.040
Great.

00:38:27.300 --> 00:38:28.960
And so, yeah, all the books are there.

00:38:28.960 --> 00:38:33.120
As I said, not all under exactly the same licenses, but they're under free licenses.

00:38:33.120 --> 00:38:37.720
And then Think Complexity is the other one, which is about complexity science.

00:38:38.280 --> 00:38:41.080
I'm working on the second edition of that one now.

00:38:41.080 --> 00:38:42.520
So that's a work in progress.

00:38:42.520 --> 00:38:43.440
That sounds interesting.

00:38:43.440 --> 00:38:45.980
Give us a sense of what complexity science is.

00:38:45.980 --> 00:38:48.240
It's kind of an odd set of topics.

00:38:48.240 --> 00:38:55.580
One way to think about it is it's the physics of complex systems, systems where you have components

00:38:55.580 --> 00:38:56.860
that interact with each other.

00:38:56.940 --> 00:38:59.720
Like a three-body problem and gravity, something like that?

00:38:59.720 --> 00:39:00.160
Yeah.

00:39:00.160 --> 00:39:02.460
So that would be an example of a system that gets chaotic.

00:39:02.460 --> 00:39:06.840
And among continuous mathematics, those are interesting systems too.

00:39:07.540 --> 00:39:13.040
And then in discrete math world, there are things like grids and cellular automata.

00:39:13.200 --> 00:39:19.960
So things like Conway's Game of Life and Stephen Wolfram's work in CA's cellular automata.

00:39:19.960 --> 00:39:22.480
And then also graph models.

00:39:22.480 --> 00:39:28.520
So things like small world networks and scale-free networks and agent-based models, one of the

00:39:28.520 --> 00:39:29.180
big topics.

00:39:29.180 --> 00:39:32.560
So boids, things moving around in three dimensions.

00:39:33.440 --> 00:39:39.640
Or there are some economic models like sugarscape and Schelling's model of segregation.

00:39:39.640 --> 00:39:41.240
So those are some of the topics.

00:39:41.240 --> 00:39:41.580
Yeah.

00:39:41.580 --> 00:39:42.920
Oh, that sounds really interesting.

00:39:42.920 --> 00:39:45.680
I just need an excuse to study them, but it sounds cool.

00:39:45.680 --> 00:39:47.960
It's great stuff and they're fun.

00:39:47.960 --> 00:39:53.380
They tend to have a lot of leverage, like a small amount of computation for a lot of very

00:39:53.380 --> 00:39:54.420
interesting results.

00:39:54.420 --> 00:40:00.020
And there are philosophical implications to almost all of it.

00:40:00.020 --> 00:40:06.380
So almost every chapter ends with, here's some reading that you might want to do from

00:40:06.380 --> 00:40:11.820
the philosophy of science, because we've just come face-to-face with instrumentalism and

00:40:11.820 --> 00:40:14.760
reductionism and all kinds of other isms.

00:40:14.760 --> 00:40:15.560
Yeah, cool.

00:40:15.560 --> 00:40:20.840
It seems to me if there are parents out there listening who have to help their kid with a

00:40:20.840 --> 00:40:25.320
science fair presentation, you could probably take something pretty interesting from there

00:40:25.320 --> 00:40:28.640
and put a little simulation on it and make that a science fair presentation.

00:40:28.640 --> 00:40:29.320
It's pretty good.

00:40:29.320 --> 00:40:34.400
It's not as good as the volcano with the baking soda, but Game of Life is pretty good.

00:40:34.400 --> 00:40:35.060
Yeah, for sure.

00:40:35.060 --> 00:40:39.940
So another one that you are working on is called ThinkOS, right?

00:40:39.940 --> 00:40:40.360
Yes.

00:40:40.360 --> 00:40:41.640
That one looks interesting.

00:40:41.640 --> 00:40:46.780
And this takes people who you sort of assume the reader knows Python and says, all right,

00:40:46.780 --> 00:40:48.380
let's write an operating system and see.

00:40:48.380 --> 00:40:49.920
Yes.

00:40:50.240 --> 00:40:55.420
So this is filling a gap that I think has opened up in the computer science curriculum,

00:40:55.420 --> 00:41:02.480
because it used to be that the intro classes were often in C or Java or languages that are

00:41:02.480 --> 00:41:08.520
similar, so that when people get to the operating systems class, they already know a low-level

00:41:08.520 --> 00:41:09.120
language.

00:41:09.360 --> 00:41:12.740
And now they're ready to find out how to implement an operating system.

00:41:12.740 --> 00:41:13.020
Yeah.

00:41:13.020 --> 00:41:15.080
I think you're right that this is changing.

00:41:15.080 --> 00:41:19.800
And it's for the better in the large scale that people are starting with higher-level languages.

00:41:19.980 --> 00:41:25.740
I think even with Java, if you learn Java and you stay in a managed language or you learn

00:41:25.740 --> 00:41:34.280
Python, which is more common these days, understanding malloc and all these sorts of low, low, low-level

00:41:34.280 --> 00:41:35.940
things is pretty new, right?

00:41:35.940 --> 00:41:36.400
Right.

00:41:36.640 --> 00:41:37.600
And that's a good example.

00:41:37.600 --> 00:41:40.640
I think memory management is one of the gaps.

00:41:40.640 --> 00:41:48.080
So now when students get into a second or a third computer science class, now maybe they need to learn C,

00:41:48.080 --> 00:41:50.340
but they need to learn memory management.

00:41:50.340 --> 00:41:53.820
They need to learn a lot about that kind of system level.

00:41:53.820 --> 00:41:57.080
What do the operating system calls look like?

00:41:57.080 --> 00:41:58.000
What are those APIs?

00:41:58.000 --> 00:42:06.580
So ThinkOS is an attempt to fill in some of that space with, on the one hand, we're going to

00:42:06.580 --> 00:42:10.820
learn system level programming in C. And on the other hand, we're going to learn about

00:42:10.820 --> 00:42:17.060
operating systems. But what we're going to learn is the stuff that you need to know in order to be

00:42:17.060 --> 00:42:19.100
a good application level programmer.

00:42:19.100 --> 00:42:24.140
Right. I think you need to know C to be a good professional programmer. I don't think you need to

00:42:24.140 --> 00:42:30.600
do it all the time, but I think knowing really what happens down at that level, really what does

00:42:30.600 --> 00:42:36.480
it mean for pointers to do their thing? What does it mean for memory management and so on? And have

00:42:36.520 --> 00:42:42.180
that experience is pretty important, even if you spend 99.9% of your time in Python or something.

00:42:42.180 --> 00:42:49.940
Yeah, I think I agree. Although I tend to be skeptical about people telling me what everybody

00:42:49.940 --> 00:42:50.760
needs to know.

00:42:50.760 --> 00:42:52.720
Yes, of course, of course.

00:42:52.720 --> 00:42:57.160
But I think you're right. At the very least, one of the things that you're going to have

00:42:57.160 --> 00:43:01.020
is a mental model of what's happening while your program is executing.

00:43:01.340 --> 00:43:06.140
Right. Yeah. And I'm not necessarily, I said C, but I'm more thinking like just a language that

00:43:06.140 --> 00:43:12.500
you need to have a concept of like how the thing actually runs. That's more what I'm trying to say.

00:43:12.500 --> 00:43:14.920
And I think C is probably where most people get that model.

00:43:14.920 --> 00:43:20.580
Yeah, I agree. And maybe it used to be assembly language. So we're still moving up. But I think

00:43:20.580 --> 00:43:27.380
you're right. And you're going to have a performance model as well of what's fast and what's slow. So

00:43:27.380 --> 00:43:32.860
when you start writing at the application level, if you are surprised, if things are slower than you

00:43:32.860 --> 00:43:37.220
expected, maybe you can debug that because you know what's going on one level down.

00:43:37.220 --> 00:43:41.300
Right. Enough tools to go and explore that and go, oh, I see why this is happening rather than,

00:43:41.300 --> 00:43:45.200
that's weird. Didn't know that would be slow. I just guess that's just won't do that anymore.

00:43:47.360 --> 00:43:51.980
Interesting. Okay. So I think that is a really cool book. So if you come in from Python and you

00:43:51.980 --> 00:43:58.340
want to like get some, some experience and see sort of tailor, tailor made to take you from that one

00:43:58.340 --> 00:44:02.620
step to the next, that's cool. And certainly understanding operating systems is good as well.

00:44:02.620 --> 00:44:10.100
So let's see, where, where are you going with courses in this whole area? What do you have other

00:44:10.100 --> 00:44:15.200
courses that you're teaching? Do you have other areas you're trying to explore this? Like let's use

00:44:15.200 --> 00:44:19.500
computation to help people understand stuff in the right order, not the reverse order.

00:44:19.500 --> 00:44:25.100
Right. I've got a bunch of projects that I work on in parallel. So I mentioned complexity. That's,

00:44:25.100 --> 00:44:31.100
that's the immediate project. Sort of medium to long-term, I'm still thinking about linear algebra.

00:44:31.100 --> 00:44:37.580
I think there's a big opportunity there for people to really understand that in a way that lets them

00:44:37.580 --> 00:44:41.680
do things with it. I think a lot of people who've studied linear algebra,

00:44:41.680 --> 00:44:48.840
they walk away with the vague notion that they can prove things about matrices, but not necessarily a

00:44:48.840 --> 00:44:57.600
lot of skills for really using the entities of, of linear algebra to do work, to solve problems by

00:44:57.600 --> 00:45:02.840
expressing them in that vocabulary. Right. I could tell you if a matrix is singular, I could do various

00:45:02.840 --> 00:45:07.800
other things to it, but I can't apply. There's like no useful skill I take away from this. Right.

00:45:07.800 --> 00:45:12.620
Basically is a way a lot of people end up experiencing it. I suspect. Yep. That's another

00:45:12.620 --> 00:45:17.420
place where doing things computationally can flip the order. You can go top down starting with

00:45:17.420 --> 00:45:22.660
applications and gradually understanding how they work. All right. Well, that all sounds really fun.

00:45:22.660 --> 00:45:29.500
Do you think that we should be trying to get this computational stuff in middle school or like,

00:45:29.500 --> 00:45:36.620
like 10, 12, 13 year old kids, like maybe a little bit less math, a little bit more programming or

00:45:36.620 --> 00:45:41.340
something, or how do you think we could take this in and make it more? So it's not something they

00:45:41.340 --> 00:45:45.160
experience when they get to college, but sort of everyone gets a chance to see it.

00:45:45.160 --> 00:45:49.840
Oh yeah. No, I think everybody should see it. And earlier than that, I think you can do it in

00:45:49.840 --> 00:45:56.400
elementary school for some definition of do it. What I'm talking about is using computational tools in

00:45:56.400 --> 00:46:02.520
the context of whatever it is that you're studying at a level that's appropriate for where the kids

00:46:02.520 --> 00:46:11.660
are. It can't be another class. You can't go and study English for an hour and then math for an hour

00:46:11.660 --> 00:46:18.280
and then computing for an hour. I think the computing just has to be embedded everywhere. Just in the same

00:46:18.280 --> 00:46:22.060
way that we use paper and pencil as a tool, we should be using computation as a tool,

00:46:22.060 --> 00:46:30.500
but not just using applications that other people wrote. There should be a gradual process of

00:46:30.500 --> 00:46:38.100
programming for some definition of programming for basic things, languages like Scratch that are

00:46:38.100 --> 00:46:44.200
block-based where you're just organizing computational elements, gradually working up to general purpose

00:46:44.200 --> 00:46:49.100
programming languages. Yeah, I totally agree. I think, I think it'd be great to see that.

00:46:49.100 --> 00:46:54.520
And I suspect we will see that over time, but who knows when it really kick in at that level.

00:46:54.520 --> 00:46:58.120
That's a pretty big battleship to turn the curriculum up for children.

00:46:58.120 --> 00:46:59.440
Oh yeah, no question.

00:46:59.440 --> 00:47:03.660
All right. Well, Alan, we're getting sort of near the end of the show. So let me ask you the

00:47:03.660 --> 00:47:09.080
two questions I always ask everyone. One, first, if you're going to write some Python code,

00:47:09.080 --> 00:47:10.320
what editor do you open up?

00:47:10.540 --> 00:47:16.500
I do most of my programming in Emacs. And then more recently I'm writing more and more of it in

00:47:16.500 --> 00:47:21.820
Jupyter notebooks while I'm exploring. And then at some point I end up taking that code out of the

00:47:21.820 --> 00:47:27.320
notebooks and putting it into modules and then either Emacs or other IDs.

00:47:27.320 --> 00:47:34.000
Sure. All right. Excellent. And most notable or favorite PyPI package? We're over a hundred thousand

00:47:34.000 --> 00:47:35.040
by quite a ways now.

00:47:35.040 --> 00:47:41.220
Right. I guess pandas is probably the thing I'm spending my most of my time working with. I love

00:47:41.220 --> 00:47:49.080
it. I did a lot of statistics using my own tools for a while. And I ended up just writing a whole lot

00:47:49.080 --> 00:47:54.940
of pointless code that I never should have written because 90% of what I was doing would have been a

00:47:54.940 --> 00:47:58.420
one line pandas method. Yes.

00:47:58.740 --> 00:48:03.120
And then the other package I mentioned is pint that I'm very interested in. Again, for doing

00:48:03.120 --> 00:48:05.680
computation with quantities that have units.

00:48:05.680 --> 00:48:10.480
Pint is really simple. Pandas is something that's very powerful, but definitely takes some study and

00:48:10.480 --> 00:48:16.460
to really leverage it. But it's great as well. All right. So for the educators, for the students,

00:48:16.460 --> 00:48:20.300
or even professional programmers listening, what's the final call to action? How can they

00:48:20.300 --> 00:48:22.200
take these ideas and do more with them?

00:48:22.200 --> 00:48:25.880
Well, so the physical modeling project, as I said, I'm working on that this summer.

00:48:26.120 --> 00:48:31.480
We're going to be developing that course. And I'm really interested to hear from people who are doing

00:48:31.480 --> 00:48:37.840
physical modeling of lots of different kinds. In particular, we're probably going to start with

00:48:37.840 --> 00:48:44.280
population models and other discrete things where you've got either animals that are breeding,

00:48:44.280 --> 00:48:50.860
or I mentioned bicycles moving from place to place. So discrete things moving in discrete spaces.

00:48:51.300 --> 00:48:56.700
And then probably some first order systems like thermodynamics and chemical kinetics,

00:48:56.700 --> 00:49:04.400
maybe some pharmacokinetics. So just looking for examples that are interesting because the

00:49:04.400 --> 00:49:12.940
applications matter. So real world problems that have consequences. And really examples where

00:49:12.940 --> 00:49:19.360
you have a simple model that does a lot of work for you, that you can take a complex physical system

00:49:19.360 --> 00:49:24.260
and describe it with a model that is just the right amount of simple.

00:49:24.260 --> 00:49:29.100
Right. The interesting problems that are not so complex, they're too daunting, right?

00:49:29.100 --> 00:49:33.520
Right, right. And really do something with it that you're either making predictions that are

00:49:33.520 --> 00:49:39.680
real predictions that people care about, or explaining something that's genuinely an open question,

00:49:39.680 --> 00:49:46.140
or doing design where you can actually optimize something by modeling it, finding an optimum,

00:49:46.140 --> 00:49:49.640
and then building that product or whatever the system is.

00:49:49.640 --> 00:49:52.620
Yeah, that's really cool. You said you're going to be working on a thing called modsim.py

00:49:52.620 --> 00:49:58.360
for this class. Is that going to show up on GitHub? And could people come give you feedback and stuff

00:49:58.360 --> 00:49:58.600
on it?

00:49:58.600 --> 00:50:04.100
Yeah, I'll probably start the GitHub repository soon. In fact, I might already have, we'll have a link to that.

00:50:04.100 --> 00:50:08.400
Yeah, there's a little bit of time shifting. So whenever you get it done, even if it comes out after

00:50:08.400 --> 00:50:12.520
the podcast, send it to me and I'll put it in the show notes. People can then go and check it out.

00:50:13.120 --> 00:50:15.620
All right, Alan, thank you for being on the show. It's really great to chat with you.

00:50:15.620 --> 00:50:17.420
Thank you very much. It's been a lot of fun.

00:50:17.420 --> 00:50:18.280
Yep, you bet. Bye.

00:50:19.920 --> 00:50:26.260
This has been another episode of Talk Python To Me. Today's guest has been Allen Downey. And this

00:50:26.260 --> 00:50:32.580
episode has been brought to you by Linode and Rollbar. Linode is bulletproof hosting for whatever

00:50:32.580 --> 00:50:39.140
you're building with Python. Get your four months free at talkpython.fm/Linode. Just use the

00:50:39.140 --> 00:50:46.260
code Python17. Rollbar takes the pain out of errors. They give you the context and insight you need to

00:50:46.260 --> 00:50:51.180
quickly locate and fix errors that might have gone unnoticed until your users complain, of course.

00:50:51.180 --> 00:50:57.440
As Talk Python To Me listeners, track a ridiculous number of errors for free at rollbar.com slash

00:50:57.440 --> 00:51:02.880
talkpythontome. Are you or a colleague trying to learn Python? Have you tried books and videos that

00:51:02.880 --> 00:51:07.600
just left you bored by covering topics point by point? Well, check out my online course Python

00:51:07.600 --> 00:51:13.700
jumpstart by building 10 apps at talkpython.fm/course to experience a more engaging way to learn

00:51:13.700 --> 00:51:19.160
Python. And if you're looking for something a little more advanced, try my Write Pythonic code course at

00:51:19.160 --> 00:51:25.280
 talkpython.fm/pythonic. Be sure to subscribe to the show. Open your favorite podcatcher and search

00:51:25.280 --> 00:51:31.500
for Python. We should be right at the top. You can also find the iTunes feed at /itunes, Google Play feed

00:51:31.500 --> 00:51:38.580
at /play and direct RSS feed at /rss on talkpython.fm. Our theme music is Developers,

00:51:38.580 --> 00:51:43.760
Developers, Developers by Corey Smith, who goes by Smix. Corey just recently started selling his tracks

00:51:43.760 --> 00:51:49.940
on iTunes. So I recommend you check it out at talkpython.fm/music. You can browse his tracks

00:51:49.940 --> 00:51:55.000
he has for sale on iTunes and listen to the full length version of the theme song. This is your host,

00:51:55.100 --> 00:52:00.200
Michael Kennedy. Thanks so much for listening. I really appreciate it. Smix, let's get out of here.

00:52:00.200 --> 00:52:21.200
Outro Music.

00:52:21.200 --> 00:52:21.700
you

00:52:21.700 --> 00:52:22.200
Bye.

00:52:22.200 --> 00:52:22.360
you

