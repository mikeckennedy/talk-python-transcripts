WEBVTT

00:00:00.001 --> 00:00:05.340
What would a modern Python project look like? Maybe it would use poetry rather than pip directly for

00:00:05.340 --> 00:00:10.120
its package management. Perhaps its test automation would be controlled by Nox.

00:00:10.120 --> 00:00:15.740
You might automate its release notes with release drafter. The list goes on and on,

00:00:15.740 --> 00:00:21.620
and that list is the topic of this episode. Join me and Claudio Jolovitz as we discuss

00:00:21.620 --> 00:00:28.220
his hypermodern Python project and template. This is Talk Python to Me, episode 362,

00:00:28.220 --> 00:00:30.740
recorded April 6th, 2022.

00:00:30.740 --> 00:00:48.480
Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:48.480 --> 00:00:53.120
Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes

00:00:53.120 --> 00:00:57.800
at talkpython.fm and follow the show on Twitter via at talkpython.

00:00:57.800 --> 00:01:03.180
We've started streaming most of our episodes live on YouTube. Subscribe to our YouTube channel over

00:01:03.180 --> 00:01:08.920
at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.

00:01:08.920 --> 00:01:14.380
This episode is sponsored by Microsoft for Startups Founders Hub. Check them out at

00:01:14.380 --> 00:01:20.360
 talkpython.fm/founders hub to get early support for your startup. And it's brought to you by

00:01:20.360 --> 00:01:26.900
Compiler from Red Hat. Listen to an episode of their podcast as they demystify the tech industry.

00:01:26.900 --> 00:01:33.340
over at talkpython.fm/compiler. Transcripts for this and all of our episodes are brought to

00:01:33.340 --> 00:01:38.680
you by Assembly AI. Do you need a great automatic speech to text API? Get human level accuracy in

00:01:38.680 --> 00:01:42.480
just a few lines of code. Visit talkpython.fm/assemblyai.

00:01:42.480 --> 00:01:45.040
Claudio, welcome to Talk Python to Me.

00:01:45.040 --> 00:01:46.220
So happy to be here.

00:01:46.220 --> 00:01:51.640
I'm so happy to have you here. It's great to be talking to you. And this is one of those episodes

00:01:51.640 --> 00:01:56.500
that's going to be so fun because what it's going to turn out to be, I'm pretty sure, is diving into

00:01:56.500 --> 00:02:01.120
a ton of little tools. And I can tell you, just doing a little bit of research and putting together

00:02:01.120 --> 00:02:05.260
some show notes for this, like, oh, there's that thing. And oh, look, this too. Oh, I didn't know

00:02:05.260 --> 00:02:13.200
about this. So you've assembled this conglomeration of tools and techniques that you're putting under the

00:02:13.200 --> 00:02:18.300
hyper modern banner. And I think it's going to be a lot of fun to talk about. So yeah, we're going to have a

00:02:18.300 --> 00:02:23.160
good time. Looking forward. Indeed, same. Now, before we get into that, let's talk about your

00:02:23.160 --> 00:02:27.640
story. How'd you get into programming and overhear to Python? I think one day my dad, that must have

00:02:27.640 --> 00:02:33.860
been in the 80s, came back with and said, I bought a computer and I was really excited. I imagined,

00:02:33.860 --> 00:02:39.380
you know, there's going to be a room filled with all these machines and ran down the corridor and

00:02:39.380 --> 00:02:44.700
turned out to be like some kind of keyboard as it seemed to me. So there was a Commodore 64.

00:02:45.320 --> 00:02:51.180
And initially we just, you know, played all those great 8-bit games. And eventually I started

00:02:51.180 --> 00:02:56.860
programming a little bit in basic. And I think that's kind of when I really found out how much

00:02:56.860 --> 00:03:03.380
fun this is. And, you know, then I think I was interested in a lot of other non-computer things

00:03:03.380 --> 00:03:07.320
for a long while. I went to uni, I studied law.

00:03:07.320 --> 00:03:09.080
As most programmers do, of course.

00:03:09.080 --> 00:03:16.820
And, but somehow this, the interest in formal systems always stayed with me and law, especially

00:03:16.820 --> 00:03:23.180
continental law, German law is very much like a little bit like a calculus tracing back to ancient

00:03:23.180 --> 00:03:32.380
Rome. And I got interested in logic. And there's a small research community working on applying AI and

00:03:32.380 --> 00:03:37.480
logics to legal theory. And that was really my gateway drug to, to get back into programming

00:03:37.480 --> 00:03:43.620
really logics. I think I programmed this like a little flashcard system to help me prepare for the,

00:03:43.620 --> 00:03:51.660
for the law exams. And yeah, eventually I decided I want to get really deep into this. And I started

00:03:51.660 --> 00:03:56.980
studying computer science and pretty much never, never went back to law after that. So I have a law

00:03:56.980 --> 00:03:59.320
degree, but yeah, working as a software engineer.

00:03:59.320 --> 00:04:03.800
It's interesting. I hadn't really thought about it with law. I have a friend who's a lawyer and

00:04:03.800 --> 00:04:09.720
in software. So I know it's, it's, it happens for sure, but thinking about the way you have to

00:04:09.720 --> 00:04:15.300
mentally sort of solve the problems and the constraints of like legal contracts and laws

00:04:15.300 --> 00:04:19.660
and stuff and how they apply. That's actually kind of a similar skill to thinking through solving a

00:04:19.660 --> 00:04:24.160
computer programming problem with APIs and what the computer can do and stuff. Right.

00:04:24.160 --> 00:04:29.920
And it's such a human way of thinking. So it's, it's really interesting from an AI point of view,

00:04:29.920 --> 00:04:35.360
because it's not the kind of really clear logical deductions that you have, but there's a lot of

00:04:35.360 --> 00:04:39.680
everyday knowledge that you need to have and the feasible rules. Yeah.

00:04:39.680 --> 00:04:41.040
So it's quite exciting.

00:04:41.040 --> 00:04:45.440
Yeah. Very neat. Now, what kind of a code and what kind of stuff are you doing these days?

00:04:45.440 --> 00:04:53.840
I've been working mostly on a, on cybersecurity. So I'm working for a company almost 14 years,

00:04:53.840 --> 00:05:01.360
that's doing cybersecurity as a service. So we're working mostly on C++ services or high performance,

00:05:01.360 --> 00:05:09.520
data intensive services. We're using Python mostly for, to automate the build system, testing and releases,

00:05:09.520 --> 00:05:15.760
processes, but also for prototyping. So algorithms, that's like really handy before you implement it in

00:05:15.760 --> 00:05:17.440
a high performance way.

00:05:17.440 --> 00:05:22.160
Yeah. I think Python is used frequently for that. Like let's prototype this. And then if

00:05:22.160 --> 00:05:27.360
once we completely decide it works right, then we're going to write it in C++ or Rust. That's

00:05:27.360 --> 00:05:30.560
not the most common use of Python, but it certainly is one that people have said, oh,

00:05:30.560 --> 00:05:34.560
this is really good because you can prototype so quickly. Sometimes people just decide,

00:05:34.560 --> 00:05:39.360
and also this will just work fine for what we're doing. It's actually, it's plenty fast. Or they

00:05:39.360 --> 00:05:43.200
decide, you know, maybe not, right? Maybe they need C++, but it's still a cool use case.

00:05:43.200 --> 00:05:43.520
Yeah.

00:05:43.520 --> 00:05:50.800
Now let's kick off our conversation with some thoughts from a former guest, Mahmoud Hashemi. He had a

00:05:50.800 --> 00:05:57.280
really interesting way of sort of presenting Python to people who are not deep in the Python language and

00:05:57.280 --> 00:06:02.000
said, basically, it's actually, when people say Python is great for prototyping, for example,

00:06:02.000 --> 00:06:07.200
well, they might be talking about one of three things or some combination of there. It could be

00:06:07.200 --> 00:06:11.600
when people say, oh, Python is good for this, or Python is like that. They might be talking about the

00:06:11.600 --> 00:06:16.640
language, or they might be talking about the standard library, or more and more these days,

00:06:16.640 --> 00:06:21.840
they're talking about the third party ecosystem with, I don't even know how many libraries, but I

00:06:21.840 --> 00:06:28.560
gotta look this up because it changes so fast. Right now at the time of recording, 368,000 libraries. So when

00:06:28.560 --> 00:06:34.960
people mention Python, they often mean one or more of those different things. And we're going to talk about

00:06:34.960 --> 00:06:40.960
hyper modern Python. So I think we should frame it a little bit in the sense of like, well, you know, what is

00:06:40.960 --> 00:06:46.880
modern about the language? Or what is kind of modern about the standard library? And obviously, the ecosystem

00:06:46.880 --> 00:06:51.680
where a lot of it's, it's happening. So from your point of view, what is modern Python?

00:06:51.680 --> 00:06:53.360
Before we get to hyper modern?

00:06:53.360 --> 00:07:01.280
Yeah, yeah, we definitely, we can talk about the language, the standard library, the ecosystem.

00:07:01.280 --> 00:07:06.240
I'd also add the community. I think that's something that really defines Python.

00:07:06.240 --> 00:07:07.120
Yeah, I agree.

00:07:07.120 --> 00:07:14.400
Yeah. And all that tooling that evolved in the ecosystem. So about the language, what really,

00:07:14.400 --> 00:07:20.560
because my, you know, my story is, I think I got into Python. Python was it like Python 2.3?

00:07:20.560 --> 00:07:25.360
So you've been through the journey, you've been through the great split and the rejoining.

00:07:25.360 --> 00:07:31.840
I pretty much missed a lot of the pain of the Python 2.3 transition. I've been busy with C++ and then

00:07:31.840 --> 00:07:37.600
came back to Python. And for me, it was just the enthusiasm of rediscovering all the great,

00:07:37.600 --> 00:07:43.520
like how expressive Python had become. One of the things that really get me excited about modern Python

00:07:43.520 --> 00:07:51.360
is type annotations. I just find them so helpful to structure programs, to make APIs clear,

00:07:51.360 --> 00:07:56.160
to help me think about my code and to keep it maintainable and readable. So I use them

00:07:56.160 --> 00:08:03.600
pretty much always. And I always run my Pi in strict mode. Even I'd even use it in small scripts.

00:08:03.600 --> 00:08:09.520
And it's, of course, very helpful in large systems. Absolutely. I don't know that I've,

00:08:09.520 --> 00:08:15.600
in fact, I'm, I'm pretty sure I've never gone end to end and taken a large system and completely made it

00:08:15.600 --> 00:08:21.280
100% my Pi checked, you know? Yeah. For me, I'm with you. I absolutely love

00:08:21.280 --> 00:08:28.000
the types. And I use them a lot to sort of drive the, the tooling intelligence. For example, like if

00:08:28.000 --> 00:08:32.880
you've got a data access layer, you could, you could talk about what is exchanged at the boundary there

00:08:32.880 --> 00:08:38.320
so that your editors are all of a sudden super smart about autocomplete. And, you know, I was just doing

00:08:38.320 --> 00:08:46.480
a massive overhaul to the course, Python courses website and change, change, like it was 110 commits

00:08:46.480 --> 00:08:51.120
in this PR. It was like ridiculous. But before I checked them all in, I went through and I said, okay,

00:08:51.520 --> 00:08:56.720
look for all the type warnings, look for anything that might've become like out of sync along the way.

00:08:56.720 --> 00:09:02.560
And I, I caught like one or two things before I accepted the, or merged the PR back in. So it's

00:09:02.560 --> 00:09:05.840
just, yeah, I absolutely think that's one of the most important additions.

00:09:05.840 --> 00:09:10.880
And they also, it's so nice how you can leverage them at runtime as well. It's not only that they

00:09:10.880 --> 00:09:16.960
allow you to check your code in a, in, in a way that doesn't require hitting every, every code path,

00:09:16.960 --> 00:09:21.360
but you can build a data validation on top of it. And so many more.

00:09:21.360 --> 00:09:26.640
Yeah, absolutely. I mean, look at libraries like Pydantic and FastAPI that are making interesting

00:09:26.640 --> 00:09:28.320
runtime use out of it.

00:09:28.320 --> 00:09:28.320
Absolutely.

00:09:28.320 --> 00:09:34.000
And speaking of modern Python, like there's the, there was that proposed change to make

00:09:34.000 --> 00:09:40.400
typing more efficient where it wouldn't actually import the things until really needed it. Or I

00:09:40.400 --> 00:09:44.960
can't remember the exact PEP, but it was a way to sort of delay type information imports until you're

00:09:44.960 --> 00:09:49.920
doing something like my PY and the Pydantic people and fast, you know, Sebastian and FastAPI. I was like,

00:09:49.920 --> 00:09:54.400
wait, wait, wait, wait, wait, wait, we need this. Like, this is how our thing works. If you take away the

00:09:54.400 --> 00:09:56.480
actual meaning other than for verification.

00:09:56.480 --> 00:10:03.760
Yeah. I think the stringification of the, of the types that makes it really hard for these use cases. And, and

00:10:03.760 --> 00:10:10.240
there's this other approach where they, where they basically lazily evaluate the, the types, I think, to avoid this

00:10:10.240 --> 00:10:16.400
string problem. Yeah. I don't know if they've, I think it's still an open question of how to, how to proceed this. They, they, they,

00:10:16.400 --> 00:10:22.960
we should have gotten the string types already and then decided to take some more time to,

00:10:22.960 --> 00:10:27.680
to find a good solution for everybody. Yeah. I think that was, was sort of delayed. I can't

00:10:27.680 --> 00:10:31.360
remember the total outcome, but I think it was like, we needed to think about this more and make sure all

00:10:31.360 --> 00:10:37.600
the use cases are covered. Right. Yeah. Cool. Okay. Well, that's the language. One thing that we could

00:10:37.600 --> 00:10:44.080
talk about real quick, that's pretty timely is this PEP. I just had Brett Cannon and Christian on

00:10:44.080 --> 00:10:51.120
to talk about PEP 594, removing dead batteries from the standard library, which, you know,

00:10:51.120 --> 00:10:57.200
it's pretty interesting. The idea is a lot of these libraries had been added. These core modules have

00:10:57.200 --> 00:11:03.200
been added to the standard library in like 1992. And they've, they might not still be relevant.

00:11:03.200 --> 00:11:08.480
For example, CGI is not the most common way to do web apps anymore. We've got micro whiskey and

00:11:08.480 --> 00:11:13.760
the unicorn and all those things. Right. So does that still make sense to maintain them? Yeah.

00:11:13.760 --> 00:11:19.920
I think that the set of libraries to remove them was pretty non-controversial because they're just

00:11:19.920 --> 00:11:27.600
very, very old, obsolete, and also basically unmaintained. CPython is, has, I think like 90

00:11:27.600 --> 00:11:35.040
core developers and they, they have like 1,600 open PRs right now. So it's very hard to maintain a huge

00:11:35.040 --> 00:11:43.840
standard library with so little human resources. Yeah. So I think that was, yeah, pretty a good step.

00:11:43.840 --> 00:11:50.560
What I really find interesting is, is the vision behind it. Like where, where, where should the, the standard library go?

00:11:51.040 --> 00:11:57.600
How, what are the criteria in the future to, to include libraries? For example, we, I think usually,

00:11:57.600 --> 00:12:04.800
recently we got a Tomlip into the, standard library. Right. Yeah. To join JSON and CSV and XML and all

00:12:04.800 --> 00:12:11.200
those. Yeah. It's, it's, it started as a, as a PyPI library called Tomli and it's been adopted

00:12:11.200 --> 00:12:16.640
quickly by a lot of the tools out there. And now it's part of the, or it will be a part of the standard

00:12:16.640 --> 00:12:23.440
library. So this is, for example, this is something that is important to solve a, a bootstrapping

00:12:23.440 --> 00:12:30.400
problem in the, the packaging ecosystem, because we have PyProject Toml now, and how is pip going to

00:12:30.400 --> 00:12:35.360
pass the PyProject Toml file? For example, how are the other tools going to, to pass it? So it's,

00:12:35.360 --> 00:12:40.800
it's very advantageous to have it in the standard lib, but we probably don't want to have passes for

00:12:40.800 --> 00:12:46.880
every file format out there. I agree. So in fact, a lot of the ones that were removed

00:12:46.880 --> 00:12:53.440
in PEP 594 are actually having to do with file formats. So you've got like AIFC, which is an audio

00:12:53.440 --> 00:12:59.520
format. You have audio op, is it like the sun AU format? There's a bunch of, bunch of things like

00:12:59.520 --> 00:13:04.000
that. Right. So yeah. I don't want to dive too much into that because we've done a whole show on it,

00:13:04.000 --> 00:13:09.200
but I do think it's interesting to think about this as a modern, like the first step in a modernization

00:13:09.200 --> 00:13:13.760
of the standard library. Right. Yeah. And then where it really blows open. And I think an

00:13:13.760 --> 00:13:18.960
interesting inter, inter exchange sort of cross influence here is, as I already mentioned, the

00:13:18.960 --> 00:13:25.040
368,000 external packages that are building on a lot of the new language features that I think are,

00:13:25.040 --> 00:13:31.040
are super cool. And how much, you know, looking back, if that world existed already, how much smaller

00:13:31.040 --> 00:13:35.280
would the standard library be? Right? Like, would your lib ever have to be in there? Well, we got requests.

00:13:35.280 --> 00:13:38.800
I don't know. Maybe not. It could make a lot of sense for it actually to be there, like this

00:13:38.800 --> 00:13:42.880
bootstrapping problem you talked about, but maybe it doesn't, right? Like, I think different choices

00:13:42.880 --> 00:13:48.720
would be made, but yeah. What are your thoughts on the sort of ecosystem from the PYPI perspective?

00:13:48.720 --> 00:13:55.280
Mm-hmm. So if we look at the, at the 30, the third party libraries, I think for me, modern Python is a

00:13:55.280 --> 00:14:01.920
lot about expressive, expressive types, like Adhors for me is like the best example really to how to write

00:14:01.920 --> 00:14:09.680
well-structured code using Adhors just got a new API, which is really, really nice. And I can definitely

00:14:09.680 --> 00:14:18.400
recommend having a look at it. So it's become very easy to define immutable value objects, essentially,

00:14:18.400 --> 00:14:23.120
that will allow you to basically structure your domain logic in a really expressive way.

00:14:23.120 --> 00:14:26.320
Yeah, no, I was going to say that it did get a new API recently. I forgot that it,

00:14:26.320 --> 00:14:31.600
it kind of inspired data classes and then it sort of turned the tables on it a bit, right? And sort of

00:14:31.600 --> 00:14:34.320
rethought about how some of its stuff was offered as well, right?

00:14:34.320 --> 00:14:40.080
I love that we have data classes in the standard library because it's like a mini Adhors that you

00:14:40.080 --> 00:14:44.960
always have at your disposal, even when you don't want to take on third-party dependencies,

00:14:44.960 --> 00:14:50.960
but it's definitely always worth looking at Adhors. It's very fast and has a lot of features and it

00:14:50.960 --> 00:14:56.000
doesn't have this problem that you can only really update it once per year.

00:14:56.000 --> 00:15:01.040
Yeah. And that's a super interesting point. You know, they considered putting requests in the standard

00:15:01.040 --> 00:15:05.760
library for a while and requests is under the, I can't remember the exact organization,

00:15:05.760 --> 00:15:11.680
but it's under an official PSF. Maybe it is, I think it is just the PSF organization now on GitHub,

00:15:11.680 --> 00:15:16.720
right? It's sort of officially Python in a sense, but they decided not to put it into the standard

00:15:16.720 --> 00:15:20.960
library, not because it didn't fit or it wasn't good enough, but because it would actually slow down

00:15:20.960 --> 00:15:24.880
the development of requests and constrain it too much. And that's sort of similar here as well,

00:15:24.880 --> 00:15:29.600
right? Adders can come out every day with new stuff and data classes yearly, right?

00:15:29.600 --> 00:15:36.320
This portion of Talk Python to Me is brought to you by Microsoft for Startups Founders Hub.

00:15:36.320 --> 00:15:42.720
Starting a business is hard. By some estimates, over 90% of startups will go out of business in just their

00:15:42.720 --> 00:15:48.080
first year. With that in mind, Microsoft for Startups set out to understand what startups need

00:15:48.080 --> 00:15:53.760
to be successful and to create a digital platform to help them overcome those challenges. Microsoft for

00:15:53.760 --> 00:16:00.480
Startups Founders Hub was born. Founders Hub provides all founders at any stage with free resources to

00:16:00.480 --> 00:16:06.880
solve their startup challenges. The platform provides technology benefits, access to expert guidance and

00:16:06.880 --> 00:16:12.800
skilled resources, mentorship and networking connections, and much more. Unlike others in the industry,

00:16:12.800 --> 00:16:18.960
Microsoft for Startups Founders Hub doesn't require startups to be investor backed or third-party

00:16:18.960 --> 00:16:24.800
validated to participate. Founders Hub is truly open to all. So what do you get if you join them?

00:16:24.800 --> 00:16:29.760
You speed up your development with free access to GitHub and Microsoft Cloud computing resources

00:16:29.760 --> 00:16:35.120
and the ability to unlock more credits over time. To help your startup innovate, Founders Hub is

00:16:35.120 --> 00:16:40.160
partnering with innovative companies like OpenAI, a global leader in AI research and development,

00:16:40.160 --> 00:16:45.440
to provide exclusive benefits and discounts. Through Microsoft for Startups Founders Hub,

00:16:45.440 --> 00:16:49.920
becoming a founder is no longer about who you know. You'll have access to their mentorship network,

00:16:49.920 --> 00:16:56.160
giving you a pool of hundreds of mentors across a range of disciplines and areas like idea validation,

00:16:56.160 --> 00:17:01.200
fundraising, management and coaching, sales and marketing, as well as specific technical stress

00:17:01.200 --> 00:17:06.320
points. You'll be able to book a one-on-one meeting with the mentors, many of whom are former founders

00:17:06.320 --> 00:17:11.920
themselves. Make your idea a reality today with the critical support you'll get from Founders Hub.

00:17:11.920 --> 00:17:17.840
To join the program, just visit talkpython.fm/foundershub, all one word, no links in your show notes.

00:17:17.840 --> 00:17:20.080
Thank you to Microsoft for supporting the show.

00:17:20.080 --> 00:17:27.840
I think that's an interesting aspect of like sort of modern Python as well, right? This ability to just

00:17:27.840 --> 00:17:32.640
continually deliver new features and adapt it as needed.

00:17:32.640 --> 00:17:39.840
I also really love C-Adder because you mentioned Pydantic before. What I really like about C-Adder, it has kind of a similar,

00:17:39.840 --> 00:17:48.240
so you can serialize and deserialize data classes and adders. The difference between Pydantic and C-Adders is that

00:17:48.240 --> 00:17:57.360
Pydantic uses inheritance to give you this functionality, whereas with C-Adders, you just have your pure Python classes

00:17:57.360 --> 00:18:04.720
without any, they don't need to inherit from anything. You just have, you decouple serialization logic from

00:18:04.720 --> 00:18:10.720
your domain logic. And I think that brings a lot of advantages in structuring software.

00:18:10.720 --> 00:18:14.080
This is the right one I have on the screen here, this C-A-T-T-R-S.

00:18:14.080 --> 00:18:14.800
Right. Yeah.

00:18:14.800 --> 00:18:15.360
Yeah.

00:18:15.360 --> 00:18:22.400
Yeah. Interesting. So you can do things like put a frozen decorator onto just a regular Python class and

00:18:22.400 --> 00:18:27.360
hey, it's frozen. You can create an instance of it and you can say unstructure and you get a dictionary,

00:18:27.360 --> 00:18:31.440
you can structure it back until it would type, it parses it back, which is quite neat.

00:18:31.440 --> 00:18:31.760
Yeah.

00:18:31.760 --> 00:18:34.080
This one's new to me. Like I said, we're going to go through a lot of those,

00:18:34.080 --> 00:18:38.400
a lot of those different things. Anything else you want to like give a quick shout out to

00:18:38.400 --> 00:18:43.760
into the broader ecosystem before, like we'll dig into your hypermodern ones that you're using as well.

00:18:43.760 --> 00:18:50.080
If you haven't seen Rich and HTTPX, those are definitely some to check out. And HTTPX,

00:18:50.080 --> 00:18:56.880
basically we talked about requests. HTTPX has a very similar interface, but gives you both async and

00:18:56.880 --> 00:18:58.720
sync operations. Yeah.

00:18:58.720 --> 00:19:00.400
That's definitely a wonderful project.

00:19:00.400 --> 00:19:06.880
I use HTTPX a lot and it's really nice because it's so familiar if you know requests, but if you happen

00:19:06.880 --> 00:19:12.400
to find yourself doing cool async stuff, you're not stuck not doing async for one of the most

00:19:12.400 --> 00:19:18.160
important parts, which is calling services, right? So you can await doing a get or a post or whatever.

00:19:18.160 --> 00:19:23.520
Yeah, it's really nice. I'm not 100% switched to it instead of requests, but it's definitely one of

00:19:23.520 --> 00:19:29.280
my go-tos as well. Cool. All right. Well, so that's sort of some thoughts on modern Python and where things

00:19:29.280 --> 00:19:37.120
are going. Then you created this series, which is almost like a little mini course on how should you,

00:19:37.120 --> 00:19:42.400
from your perspective, how should you structure and build modern Python projects and what tools should you

00:19:42.400 --> 00:19:50.080
bring in? Not just should you use HTTPX over requests, but should you use Knox for testing and things like that?

00:19:50.080 --> 00:19:50.640
Yes, right.

00:19:50.640 --> 00:19:52.160
You might say yes for Knox.

00:19:52.160 --> 00:20:00.240
Given that you work on it, right? So you did this article, this six-part series article on it, which I'll definitely link to.

00:20:00.240 --> 00:20:06.080
But then also you created a cookie cutter template that'll allow people to jump into it.

00:20:06.080 --> 00:20:11.280
I find this to be really helpful. I do this sometimes with my classes. You're like, "Well, here's the thing we built at the end,

00:20:11.280 --> 00:20:19.280
but if you just want to create your own version of it, here's a cookie cutter to actually just create it with your settings and your values,

00:20:19.280 --> 00:20:25.200
so you don't have to go through rebuilding it from scratch." And cookie cutter has been really influential in that sense, don't you think?

00:20:25.200 --> 00:20:34.480
Absolutely. When I wrote the articles, there was example code on GitHub and I saw people forking the repository and I was like, "Oh, no.

00:20:34.480 --> 00:20:44.720
They're all going to end up with this example code that displays Wikipedia articles and you can so am I going to keep all the dependencies up to date?

00:20:44.720 --> 00:20:53.840
And how do I even do that?" And I was like, "No, I have to find a better way." And cookie cutter was definitely a good way to set up a project template.

00:20:54.400 --> 00:21:07.360
And also something that was much easier for me to keep up to date. So there's after two years, definitely quite a bit of drift between the article series, which is from January 2020,

00:21:07.360 --> 00:21:10.400
and the cookie cutter as it is today.

00:21:10.400 --> 00:21:10.720
Yeah.

00:21:10.720 --> 00:21:11.120
Yeah.

00:21:11.120 --> 00:21:11.440
Yeah.

00:21:11.440 --> 00:21:19.040
It's hard to keep an article or a video or a talk or whatever as a living thing that evolves as we gain more experience and stuff.

00:21:19.040 --> 00:21:21.040
But the cookie cutter template, that's like software.

00:21:21.040 --> 00:21:21.360
Yeah.

00:21:21.360 --> 00:21:21.760
Plastic.

00:21:21.760 --> 00:21:23.600
You can make it open source and have

00:21:23.600 --> 00:21:31.120
contributors that do some work for you, which is really, I'm extremely grateful for all the contributions I got there.

00:21:31.120 --> 00:21:32.000
Yeah, that's great.

00:21:32.000 --> 00:21:33.760
I see a bunch of contributors there.

00:21:33.760 --> 00:21:37.680
Now, first, let's start with the, just the term, hypermodern Python.

00:21:37.680 --> 00:21:39.360
What's the story with the naming here?

00:21:39.360 --> 00:21:44.400
I actually brought you, now this is only for those that have a camera in front of them, that this is,

00:21:44.400 --> 00:21:45.760
this is hypermodern Python.

00:21:45.760 --> 00:21:47.840
So this is not Python.

00:21:47.840 --> 00:21:51.760
This is a hypermodern chess game written in 1925.

00:21:51.760 --> 00:21:52.320
Oh, interesting.

00:21:52.320 --> 00:21:56.000
So this is where the name hypermodern really comes from.

00:21:56.000 --> 00:21:58.800
It was meant a little bit tongue in cheek.

00:21:58.800 --> 00:22:06.160
And also, I was very conscious that how's Python going to look like two years after I've written this article series.

00:22:06.320 --> 00:22:06.480
Yeah.

00:22:06.480 --> 00:22:08.480
The ecosystem evolves so quickly.

00:22:08.480 --> 00:22:14.240
I decided to stick all these images in the blog that are basically past versions of the future.

00:22:14.240 --> 00:22:16.480
It's a thing called retrofuturism.

00:22:16.480 --> 00:22:28.640
So they're basically all like images from the 1920s and so on about how people in the future may be going to fly to the opera using planes that look like little birds.

00:22:28.640 --> 00:22:29.040
Yeah.

00:22:29.040 --> 00:22:32.240
It's sort of a steampunk mechanical bird.

00:22:32.240 --> 00:22:34.160
People are cruising along in here.

00:22:34.160 --> 00:22:36.080
It's, yeah, it's a, it's a cool picture.

00:22:36.080 --> 00:22:36.800
It's a cool idea.

00:22:36.800 --> 00:22:38.320
So what is hypermodern?

00:22:38.320 --> 00:22:44.400
I think basically it's just whatever I was excited about and didn't know about beforehand.

00:22:44.400 --> 00:22:52.960
I had used some tools, like more of the standard tools, like setup tools and pip-tools and talks.

00:22:52.960 --> 00:22:59.680
And coming back to Python, I thought, wow, let's just check out all the things that have happened.

00:22:59.680 --> 00:23:04.720
And let's see how maybe that might solve a few of the problems that I had.

00:23:04.720 --> 00:23:05.040
Nice.

00:23:05.040 --> 00:23:05.280
Okay.

00:23:05.280 --> 00:23:10.640
So then you put together the article, which is, you know, it's a serious article.

00:23:10.640 --> 00:23:12.560
It's not just a couple of paragraphs, right?

00:23:12.560 --> 00:23:14.400
It's, it's quite a bit of writing.

00:23:14.400 --> 00:23:14.960
Six articles.

00:23:14.960 --> 00:23:15.280
Yeah.

00:23:15.280 --> 00:23:16.080
Six articles.

00:23:16.080 --> 00:23:18.400
And my little, or maybe it was your website.

00:23:18.400 --> 00:23:21.680
It's like 11 minutes reading for this part, that kind of, kind of thing.

00:23:21.680 --> 00:23:24.000
So it goes into pretty good detail with examples.

00:23:24.000 --> 00:23:28.400
And then you captured it in this cookie cutter because you said that to put it into practice,

00:23:28.400 --> 00:23:29.520
that's a pretty good way.

00:23:29.520 --> 00:23:32.080
Now using cookie cutter is super easy.

00:23:32.080 --> 00:23:36.080
You know, I'm sure people have, are familiar with this, but cookie cutter, give it the name.

00:23:36.080 --> 00:23:37.920
It asks a bunch of questions, right?

00:23:37.920 --> 00:23:38.560
Right.

00:23:38.560 --> 00:23:44.000
I think maybe the right way to explore this would be to talk about the features and the

00:23:44.000 --> 00:23:47.040
steps of the cutter that it does, right?

00:23:47.040 --> 00:23:52.480
There's on the page for the cookie cutter GitHub repo, there's a big section that says features.

00:23:52.480 --> 00:23:57.440
And that sort of talks about the different aspects and angles dimensions you decided to

00:23:57.440 --> 00:23:59.120
bring in and the tooling there.

00:23:59.120 --> 00:24:02.480
So how about we just go through these and sort of dive into them?

00:24:02.480 --> 00:24:05.440
I think, I think people are going to discover some cool tools here.

00:24:05.440 --> 00:24:11.200
So first of all, if you're going to build something meaningful, you've got to get some libraries off

00:24:11.200 --> 00:24:11.760
PyPI.

00:24:11.760 --> 00:24:17.280
Like there's very few projects that have no dependencies that are rich these days and not just rich the

00:24:17.280 --> 00:24:19.040
package, but you know, feature rich.

00:24:19.040 --> 00:24:21.040
Let's talk about the first one here.

00:24:21.040 --> 00:24:21.040
Okay.

00:24:21.040 --> 00:24:22.560
Take us through it.

00:24:22.560 --> 00:24:23.120
Yeah.

00:24:23.120 --> 00:24:28.720
So poetry really solved the problem for me because it's basically the one tool approach.

00:24:28.720 --> 00:24:32.720
You have one tool that does everything for you.

00:24:32.720 --> 00:24:38.480
It will allow you to define metadata for your package, build the package for you so you can

00:24:38.480 --> 00:24:40.000
publish it on PyPI.

00:24:40.000 --> 00:24:45.600
It can manage environments for you, install all the dependencies of your project and your project

00:24:45.600 --> 00:24:46.160
itself.

00:24:46.160 --> 00:24:49.040
And it can also manage the dependencies itself.

00:24:49.040 --> 00:24:56.720
So it has a resolution mechanism and it has a log file, which is for me, a really important

00:24:56.720 --> 00:25:03.600
feature because not only is it good for deploying services in a, in a reproducible and deterministic

00:25:03.600 --> 00:25:10.560
way, but it's also for running the checks on your code and making sure that the checks run exactly

00:25:10.560 --> 00:25:17.360
the same locally on your machine and CI with on and on the machines of your collaborators.

00:25:17.360 --> 00:25:17.680
Yeah.

00:25:17.680 --> 00:25:23.040
They're not as familiar with the poetry lock file as I should be, but basically it's like

00:25:23.040 --> 00:25:26.000
hitting your versions in a requirements.txt.

00:25:26.000 --> 00:25:26.640
Right.

00:25:26.640 --> 00:25:26.720
Right.

00:25:26.720 --> 00:25:29.920
But so often people just write, you know, here's my requirements.

00:25:29.920 --> 00:25:35.440
I have requests or HCPX and I have FastAPI and I have SQLAlchemy or SQL model.

00:25:35.440 --> 00:25:40.720
And you just type those out and you pip install -r and you're good to go until you want

00:25:40.720 --> 00:25:44.960
to go back to an old version that might have a bug that that's the one in production.

00:25:44.960 --> 00:25:49.200
But the bug might be because it has the old library of whatever.

00:25:49.200 --> 00:25:49.520
Right.

00:25:49.520 --> 00:25:50.480
And you don't know.

00:25:50.480 --> 00:25:50.640
Right.

00:25:50.640 --> 00:25:52.480
So you want to be able to pin those versions.

00:25:52.480 --> 00:25:57.040
And then does the lock file also put the hashes in so they can't be fiddled with?

00:25:57.040 --> 00:25:57.520
It does.

00:25:57.520 --> 00:25:57.760
Yeah.

00:25:57.760 --> 00:25:58.240
Yeah.

00:25:58.240 --> 00:26:04.240
So it has the hashes and it gives you all the, basically the, all the indirect dependencies

00:26:04.240 --> 00:26:05.040
as well.

00:26:05.040 --> 00:26:08.320
So much like pip compile would do from the tools.

00:26:08.320 --> 00:26:08.720
Yeah.

00:26:08.720 --> 00:26:11.920
So, and that is tremendously useful.

00:26:11.920 --> 00:26:13.280
Yeah, it absolutely is.

00:26:13.280 --> 00:26:16.240
I'm a big fan of the pip-tools and pip compile.

00:26:16.240 --> 00:26:18.240
We'll get to that later when we talk.

00:26:18.240 --> 00:26:18.560
Yeah.

00:26:18.560 --> 00:26:18.800
Yeah.

00:26:18.800 --> 00:26:18.880
Yeah.

00:26:18.880 --> 00:26:22.400
When we get to, there's a section, a whole section in the cookie cutter about it.

00:26:22.400 --> 00:26:22.720
All right.

00:26:22.720 --> 00:26:25.440
So it starts by setting up with poetry, right?

00:26:25.440 --> 00:26:26.320
Absolutely.

00:26:26.320 --> 00:26:26.800
Yeah.

00:26:26.800 --> 00:26:34.080
I called poetry though, the one tool approach, and there has been a lot of work in the packaging

00:26:34.080 --> 00:26:40.880
community to introduce standards, packaging standards that make it easier for the tools to

00:26:40.880 --> 00:26:41.600
interoperate.

00:26:42.800 --> 00:26:49.280
And I think this is actually a very good way to approach things in an ecosystem like

00:26:49.280 --> 00:26:55.920
Python's to, to make it possible that you can define your package metadata for one tool,

00:26:55.920 --> 00:27:02.880
like flit, and then use poetry to build the package or PDM and so many others.

00:27:02.880 --> 00:27:09.920
And there has been a lot of great work that has made the packaging ecosystem more diverse.

00:27:09.920 --> 00:27:10.240
Yeah.

00:27:10.240 --> 00:27:10.640
Yeah.

00:27:10.640 --> 00:27:15.120
There was some separation of the architectures of certain responsibilities, right?

00:27:15.120 --> 00:27:15.440
Yes.

00:27:15.440 --> 00:27:15.840
Yeah.

00:27:15.840 --> 00:27:19.360
So there's perhaps six to one, which defined the metadata.

00:27:19.360 --> 00:27:24.960
There was also an attempt to, to standardize log files, which I think would be great, but

00:27:24.960 --> 00:27:27.440
that I've unfortunately has been rejected for now.

00:27:27.440 --> 00:27:33.680
So I'm hoping that there will be more attempts in the future, but so as great as it is to work

00:27:33.680 --> 00:27:39.680
with poetry, I definitely hope for the ecosystem to become even more diverse and more standardized,

00:27:39.680 --> 00:27:44.560
to really give us more flexibility and interoperability.

00:27:44.560 --> 00:27:44.880
Yeah.

00:27:44.880 --> 00:27:45.680
Yeah, that is great.

00:27:45.680 --> 00:27:49.600
Definitely seems like a lot of options are coming out around that these days.

00:27:49.600 --> 00:27:53.680
And then the next one here is test automation with Knox.

00:27:53.680 --> 00:27:55.600
What's your relationship with Knox, by the way?

00:27:55.600 --> 00:27:59.120
Are you the maintainer or are you just a contributor or where's this?

00:27:59.120 --> 00:28:00.320
I'm co-maintaining Knox.

00:28:00.320 --> 00:28:00.640
Okay.

00:28:00.640 --> 00:28:04.720
It was written by, by Thea Flowers and it has a large maintainer team.

00:28:04.720 --> 00:28:10.400
At the time that I wrote the article series, I was just a fan of Knox and I started contributing

00:28:10.400 --> 00:28:13.040
to it and I kind of ended up co-maintaining it.

00:28:13.920 --> 00:28:16.080
Whoops, I'm contributing more than anyone else.

00:28:16.080 --> 00:28:17.760
Does that make me more involved?

00:28:17.760 --> 00:28:18.080
All right.

00:28:18.080 --> 00:28:18.160
Yeah.

00:28:18.160 --> 00:28:20.640
So tell us what the role of Knox plays in this.

00:28:20.640 --> 00:28:21.920
So Knox is a great tool.

00:28:21.920 --> 00:28:23.520
It's not just test automation.

00:28:23.520 --> 00:28:28.560
It's really, it lets you automate basically all the developer tasks you have.

00:28:28.560 --> 00:28:30.720
So this might be tests.

00:28:30.720 --> 00:28:30.720
Okay.

00:28:30.720 --> 00:28:37.600
It might be the other checks you have like linting, or it could be building your documentation or

00:28:37.600 --> 00:28:39.120
building wheels.

00:28:39.120 --> 00:28:45.680
If that's complicated in, in any way you can just, the great thing about Knox is that it uses

00:28:45.680 --> 00:28:52.800
Python to let you define your, the tasks rather than basically having something like a make file

00:28:52.800 --> 00:28:57.920
where you use the shell or in talks, you, you have an any file where you enter your commands,

00:28:57.920 --> 00:28:58.320
right?

00:28:58.320 --> 00:28:59.200
At least talks three.

00:28:59.200 --> 00:29:02.320
I think talks for is also going to add Python configuration.

00:29:02.320 --> 00:29:06.320
So Knox, it's really, so it's really inspired by talks.

00:29:06.960 --> 00:29:13.040
I think so if you know talks, talks allows you to run tests on multiple versions of Python.

00:29:13.040 --> 00:29:13.280
Yeah.

00:29:13.280 --> 00:29:15.280
And it's been around for much longer.

00:29:15.280 --> 00:29:16.880
It's very mature tool.

00:29:16.880 --> 00:29:18.560
Knox is inspired by that.

00:29:18.560 --> 00:29:24.800
It also lets you have this matrix of Python versions or even other things.

00:29:24.800 --> 00:29:32.000
So you can similar to a pytest, you can parameterize your session functions and pass in,

00:29:32.000 --> 00:29:37.120
say like a specific dependency that you want to test against in different versions.

00:29:37.120 --> 00:29:45.520
So Knox is, is, is really useful if you want to have a single entry point into your, your project

00:29:45.520 --> 00:29:50.800
maintenance, running all the tasks that you have and running them the same locally and on CI.

00:29:50.800 --> 00:29:51.600
Yeah, this looks great.

00:29:51.600 --> 00:29:57.120
I hadn't really explored this, this Knox file thing where you have these different tasks,

00:29:57.120 --> 00:29:59.920
like a task, you know, task basically being a function.

00:29:59.920 --> 00:30:04.800
Like, so you say like tests or lint, and you can just put a session decorator on it and just

00:30:04.800 --> 00:30:09.920
say session dot install pytest, session dot run pytest or session install flake 8 and run it with

00:30:09.920 --> 00:30:10.720
the parameters.

00:30:10.720 --> 00:30:15.200
It's really nice and clean and it's, it's way better than a shell script.

00:30:15.200 --> 00:30:16.880
I think it keeps you in Python, right?

00:30:16.880 --> 00:30:17.280
Right.

00:30:17.280 --> 00:30:19.200
Which is probably where you want to be on Python project.

00:30:19.200 --> 00:30:20.960
And it runs on all the platforms.

00:30:20.960 --> 00:30:24.640
So at some point I use make files to automate these things.

00:30:24.640 --> 00:30:29.680
So the non-tox related things, I guess, don't work very well on windows.

00:30:29.680 --> 00:30:31.920
So you don't have this problem.

00:30:31.920 --> 00:30:33.200
Yeah, that's for sure.

00:30:33.200 --> 00:30:33.760
Cool.

00:30:33.760 --> 00:30:38.720
And then we kind of saw an example of that there, but linting with pre-commit and flake 8.

00:30:38.720 --> 00:30:39.040
Right.

00:30:39.040 --> 00:30:40.560
So it's about these two libraries.

00:30:40.560 --> 00:30:41.600
I love pre-commit.

00:30:41.600 --> 00:30:47.120
I actually, it wasn't in the first draft of the, of the article series.

00:30:47.120 --> 00:30:50.320
I got some reviewers who commented on that.

00:30:50.320 --> 00:30:56.160
I think Oni Fanchmitt from the pytest project and, and Hinnik Schlawak both mentioned that,

00:30:56.160 --> 00:30:57.760
you know, you have to cover pre-commit.

00:30:57.760 --> 00:30:59.600
And I was really skeptical.

00:30:59.600 --> 00:31:05.680
I had made bad experiences with these kinds of pre-commit hooks that run.

00:31:05.680 --> 00:31:13.040
So you make a git commit and then it doesn't work because you had some wrong white space in it.

00:31:13.360 --> 00:31:15.920
And I thought my, I want my commits to be really snappy.

00:31:15.920 --> 00:31:17.840
I'll, I just use Knox for that.

00:31:17.840 --> 00:31:22.240
But after hearing these comments, I thought I'm going to give it a try, you know, like it's a new

00:31:22.240 --> 00:31:24.880
tool, maybe it solves these problems much better.

00:31:24.880 --> 00:31:25.760
And it really does.

00:31:25.760 --> 00:31:28.800
I would really recommend anybody to give a pre-commit a try.

00:31:28.800 --> 00:31:37.360
Basically you drop a YAML config in your project that defines the hooks that you want to run.

00:31:38.000 --> 00:31:45.440
So this might be a hook that formats your code using black or that, that lints your code using

00:31:45.440 --> 00:31:47.360
flake eight or so much more there.

00:31:47.360 --> 00:31:50.480
There's an abundance of pre-commit hooks out there.

00:31:50.480 --> 00:31:50.960
Oh wow.

00:31:50.960 --> 00:31:51.120
Yeah.

00:31:51.120 --> 00:31:56.320
There's, there's probably 20 pages in the list of pre-commit hooks that are at the top.

00:31:56.320 --> 00:31:59.760
You click on supported hooks and pre-commit.com.

00:31:59.760 --> 00:32:00.160
Right.

00:32:00.160 --> 00:32:05.520
Pre-commit it's, so it's a git hook manager, but it's not just a git hook manager.

00:32:05.520 --> 00:32:10.960
It's also a, a linter framework and a multi-linter multi-language linter framework.

00:32:10.960 --> 00:32:16.720
So you can have your hooks written in, you know, Ruby, C++, you name it.

00:32:16.720 --> 00:32:25.280
And it's very easy to use them in a Python project or basically any, any language project.

00:32:25.280 --> 00:32:26.800
It works using git.

00:32:26.800 --> 00:32:35.280
So basically installs the tools from their git repository and you can run them as part of your

00:32:35.280 --> 00:32:43.680
git commits or all the other hook points that git offers, but you can also run it just in CI on your

00:32:43.680 --> 00:32:45.200
entire code base.

00:32:45.200 --> 00:32:50.320
And that's really what I, what I love about it is that it has this fail early philosophy.

00:32:50.320 --> 00:32:56.720
So you really get very early feedback, but it also works to, as a gatekeeper for your default

00:32:56.720 --> 00:33:02.720
branch and make sure that the, all the commits that go into your main branch are well-formed.

00:33:02.720 --> 00:33:03.680
This is interesting.

00:33:03.680 --> 00:33:08.160
I did have creator of pre-commit on the show quite a while ago.

00:33:08.160 --> 00:33:11.840
I talked about it, but I hadn't, I think maybe some of these are new or I hadn't really appreciated

00:33:11.840 --> 00:33:12.400
them before.

00:33:12.400 --> 00:33:18.240
Like one that's really cool here is check JSON as a pre-commit and it checks JSON files for

00:33:18.240 --> 00:33:19.120
parsable syntax.

00:33:19.120 --> 00:33:24.160
So basically as part of your commits, it says, well, here's, I'm guessing here's a changed

00:33:24.160 --> 00:33:24.960
JSON file.

00:33:24.960 --> 00:33:30.400
Is this, you know, can it just basically be loaded with, you know, JSON.loadf or load, give it a

00:33:30.400 --> 00:33:30.640
file.

00:33:30.640 --> 00:33:35.440
Right. And another one is, yes, you're supposed to have unit tests, but you might not have unit

00:33:35.440 --> 00:33:36.240
tests for everything.

00:33:36.240 --> 00:33:39.360
So check AST just means like, can Python parse the files?

00:33:39.360 --> 00:33:41.920
That's the word of like the compile, right?

00:33:41.920 --> 00:33:43.600
In a sense.

00:33:43.600 --> 00:33:43.760
Yeah.

00:33:43.760 --> 00:33:46.560
I mean, those are just like the first couple out of this 20 pages.

00:33:46.560 --> 00:33:50.560
So I'm, I need to come back to this and check Toml was another sort of similar to the check

00:33:50.560 --> 00:33:53.040
JSON, check YAML, check up XML and so on.

00:33:53.040 --> 00:33:53.360
Yes.

00:33:53.360 --> 00:33:59.840
There's a, this repository called pre-commit hooks, and that has lots of very small hooks that

00:33:59.840 --> 00:34:01.040
are tremendously useful.

00:34:01.040 --> 00:34:07.280
And then you have larger tools that also offer integration with pre-commit like flake eight,

00:34:07.280 --> 00:34:07.680
for example.

00:34:07.680 --> 00:34:15.520
This portion of Talk Python To Me is brought to you by the compiler podcast from Red Hat.

00:34:15.520 --> 00:34:21.520
Just like you, I'm a big fan of podcasts, and I'm happy to share a new one from a highly

00:34:21.520 --> 00:34:26.560
respected and open source company compiler and original podcast from Red Hat.

00:34:27.200 --> 00:34:31.120
With more and more of us working from home, it's important to keep our human connection

00:34:31.120 --> 00:34:31.920
with technology.

00:34:31.920 --> 00:34:34.320
With compiler, you'll do just that.

00:34:34.320 --> 00:34:38.960
The compiler podcast unravels industry topics, trends, and things you've always wanted to know

00:34:38.960 --> 00:34:42.000
about tech through interviews with people who know it best.

00:34:42.000 --> 00:34:58.400
I was a guest on Red Hat's previous podcast, Command Line Heroes, and compiler follows along in that

00:34:58.400 --> 00:35:01.600
excellent and polished style we came to expect from that show.

00:35:01.600 --> 00:35:05.440
I just listened to episode 12 of compiler, how should we handle failure?

00:35:05.440 --> 00:35:11.440
I really valued their conversation about making space for developers to fail so that they can learn

00:35:11.440 --> 00:35:15.440
and grow without fear of making mistakes or taking down the production website.

00:35:15.440 --> 00:35:18.240
It's a conversation we can all relate to, I'm sure.

00:35:18.240 --> 00:35:23.120
Listen to an episode of compiler by visiting talkpython.fm/compiler.

00:35:23.120 --> 00:35:25.200
The link is in your podcast player's show notes.

00:35:25.200 --> 00:35:31.040
You can listen to compiler on Apple Podcasts, Overcast, Spotify, Pocket Cast, or anywhere you listen to your

00:35:31.040 --> 00:35:31.600
podcasts.

00:35:31.600 --> 00:35:35.920
And yes, of course, you could subscribe by just searching for it in your podcast player,

00:35:35.920 --> 00:35:42.160
But do so by following talkpython.fm/compiler so that they know that you came from Talk Python To Me.

00:35:42.160 --> 00:35:47.360
My thanks to the compiler podcast for keeping this podcast going strong.

00:35:47.360 --> 00:35:51.920
On to continuous integration.

00:35:51.920 --> 00:35:58.720
I feel like GitHub Actions has really sort of taken hold in the Python space as a way a lot of people are doing stuff there.

00:35:58.720 --> 00:36:04.560
Absolutely. It feels like there was some kind of mass exodus from Travis CI to GitHub Actions.

00:36:04.560 --> 00:36:13.520
It's so flexible and it goes way beyond just running tests and like the normal, what you'd normally

00:36:13.520 --> 00:36:21.120
think of as CI. So you can automate a lot of your developer workflows centered around the collaboration with others.

00:36:21.120 --> 00:36:26.080
Nice. The type of stuff I work on doesn't super lend itself well to GitHub Actions.

00:36:26.080 --> 00:36:29.840
It does. It probably does somewhat, but it's not something I use that much.

00:36:29.840 --> 00:36:38.800
But it seems like if you had a package that had maybe complicated builds or something like that, you could even use it to build your wheels and stuff like that, right?

00:36:38.800 --> 00:36:46.000
Sure. Yeah. I mean, my the way I like to use it is to have most of the logic in Knox,

00:36:46.000 --> 00:36:51.760
because that means I can always just test it locally and see if everything, you know, debug it easily.

00:36:51.760 --> 00:36:59.920
And then I try to keep the GitHub Actions workflows pretty lightweight and just let them invoke Knox.

00:36:59.920 --> 00:37:04.880
I usually have a matrix with that contains the Knox sessions.

00:37:04.880 --> 00:37:13.840
So this might be the testing or running pre-commit or to lint the code or to build the documentations.

00:37:13.840 --> 00:37:19.360
If that that's all valid, then the matrix has the Python versions that I want to test on.

00:37:19.360 --> 00:37:20.320
Yeah.

00:37:20.320 --> 00:37:29.600
If I'm working on a library, it's important to support not just the latest Python version, but probably Python 3.6 onwards, maybe even the upcoming Python version.

00:37:29.600 --> 00:37:40.720
And then obviously platforms. So always, if you're, unless you're only working on one platform, try to have at least Linux and Windows, and then maybe, maybe macOS as well.

00:37:40.720 --> 00:37:49.280
Yeah. Yeah. Yeah. This is neat. You know, people talk about, well, we can't really test this on Windows because I don't have a Windows machine or vice versa. Can't test it on Mac or so easy.

00:37:49.280 --> 00:37:52.080
Yeah. So this here's your three platforms right here. Right.

00:37:52.080 --> 00:38:02.880
I'm not saying it's easy to debug it. If something goes wrong and you're only working on macOS or Linux, you probably at some point want to have a virtual machine with the running windows.

00:38:02.880 --> 00:38:10.560
If you don't have a physical Windows machine, but it's also not hard to get one these days, too. But otherwise, you know, it's very easy.

00:38:10.560 --> 00:38:12.480
To integrate Windows in your CI.

00:38:12.480 --> 00:38:16.480
Yeah, very cool. And then the next one has to do with documentation here.

00:38:16.480 --> 00:38:17.520
Right there.

00:38:17.520 --> 00:38:22.640
Sphinx, Mist, and Read the Docs. And one of the themes. So yeah, pretty.

00:38:22.640 --> 00:38:40.240
When I wrote the articles, it was just Sphinx and Read the Docs. Mist hadn't happened yet. So, well, Mist, maybe let's start with Sphinx, because I guess many people will already be familiar with it. It's a Python documentation generator. It's also used for Python's own.

00:38:40.400 --> 00:38:46.320
So for example, the library docs. It's been around for a long time.

00:38:46.320 --> 00:38:54.240
It's a very expressive language to write technical documentation.

00:38:54.240 --> 00:39:02.160
Sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too, sometimes too expressive. It's not the lightweight language that we know Markdown to be.

00:39:02.160 --> 00:39:03.080
Right.

00:39:03.080 --> 00:39:28.340
And Markdown has really conquered the world. And when I wrote the documentation chapter, I think I linked to an article by Eric Holcher from Read the Docs, comparing the two formats. And that was before, before Mist happened. And he said, you know, there's use restructured text. It's just so much more expressive. And it lets you have cross references. And all of these things has the powerful directives.

00:39:28.340 --> 00:39:49.980
Anyway, now we have Mist. And Mist allows you to do essentially the same thing in Markdown. There's an extension syntax, and you can have directives, you can have cross references. And it's a lot of fun to write documentation in Mist. So this was a recent addition to the project template to support Markdown documentation.

00:39:50.200 --> 00:40:07.940
And for those who don't know, I also I did have a show recently with the Mist folks, about Sphinx and Mist and so on. And there I learned that one of the things that's cool is you can inline restructured text. So if you get to a section, you're like, this is just Markdown. I want to do this. Do a little tiny bit of restructured text instead of living in it.

00:40:07.940 --> 00:40:09.940
You actually need to do that.

00:40:09.940 --> 00:40:21.720
You actually need to do that still for your generated API documentation. So Sphinx has this extension called AutoDoc that will take all the doc strings in your code and transform that into API documentation.

00:40:22.360 --> 00:40:42.760
And that still doesn't have a replacement. What you do is you write your doc strings, you know, using restructured text, maybe using Google style doc strings or NumPy style doc strings. And then you use the AutoDoc directive to basically quote it in line in your Markdown documentation.

00:40:42.760 --> 00:40:54.400
So that's a little bit of restructured text there. I think I'm working on filling this gap somewhere going on and I'm really looking forward to that feature coming because then everything will be just marked down.

00:40:54.400 --> 00:41:07.940
Yeah, that'd be great for sure. I do want to give a quick shout out to Paul Everett's course that he wrote over at Doc Python on Sphinx. And listen, if you're interested, check out this free course that he put together for us over there. So that's worth checking out. Now I'll put a link in the show notes.

00:41:08.380 --> 00:41:28.880
Now, if you're building a Python package that goes on PyPI, like not everything people build with Python goes on PyPI or even should be structured in the shape of a package potentially. But a lot of them are right. A lot of libraries are. So you talk about automating uploads to PyPI and test PyPI. Want to talk about the story there?

00:41:28.880 --> 00:41:50.940
Yeah. So PyPI, the Python package index there actually has a sibling called test PyPI, which is just a separate instance. It's very useful to upload your wheels and sdiscs to test PyPI before you actually do a release because you can check them and see if everything is the way you expect it to be.

00:41:50.940 --> 00:41:51.220
Yeah.

00:41:51.220 --> 00:41:51.220
Yeah.

00:41:51.220 --> 00:42:12.280
And basically install the package end to end. And in CI, what I like to do is I have the switch where if it's an actual release, I upload to PyPI. But in all the other cases, I just upload to test PyPI. So every commit that goes into the main branch is going to be built and uploaded to test PyPI.

00:42:12.280 --> 00:42:19.280
You can't change what you put into PyPI. You can add new versions that replace it, but you can't change a version really.

00:42:19.280 --> 00:42:32.620
The best you can do is yank the release. It's still going to be there for those who have pinned the version, but otherwise it'll be invisible to those who just want to get the latest release. But yeah, there's no replacing.

00:42:32.620 --> 00:42:41.020
Yeah. So it's a nice reminder and automation to set up to remember there's test PyPI and automatically sort of have your project know and use it.

00:42:41.280 --> 00:42:49.540
All right. Here's another one. I want to talk about stuff I was learning. This one is definitely new to me. And this is cool. Automate release notes with release drafter.

00:42:49.540 --> 00:42:51.420
What's about release drafter? This is cool.

00:42:51.420 --> 00:43:10.280
So release drafter takes the titles of your merged PRs and it creates a draft release. So the release in this sense is the GitHub release. That is something that you can see on the right hand side of the GitHub repo page.

00:43:10.280 --> 00:43:24.040
You have this releases link and that basically gets you to either a list of tags or you can describe the changes. So it's essentially release notes on GitHub.

00:43:24.040 --> 00:43:49.240
So I think the release drafter is really handy for that. Now actually you can, so GitHub releases have an auto generate button. So some of this functionality you will actually get even without using the release drafter action.

00:43:49.240 --> 00:44:03.460
So I think the release drafter action is somewhat more flexible, what it gives you and basically means you're going to have to add a GitHub actions workflow for it and the configuration file.

00:44:03.880 --> 00:44:15.500
So you can provide a template for your release notes and some, you know, replacement marker that a placeholder that where all the PR titles go.

00:44:15.500 --> 00:44:22.540
I think it's cool. And it even has a draft, like you, you can see the draft release notes as well.

00:44:22.540 --> 00:44:23.180
Yeah.

00:44:23.320 --> 00:44:32.320
You can see it. And then you have a button to publish the draft release. And if you don't have a tag yet, that's also going to add a git tag to your repository.

00:44:32.320 --> 00:44:38.680
So that's a really lightweight approach to the release notes question.

00:44:39.020 --> 00:44:51.620
So I see that it has a what's changed, but I also saw in the release drafter had like bug fixes and stuff. Is there a way to teach it? Like these PRs are related to bugs and these are additions and stuff like that?

00:44:51.620 --> 00:45:00.140
Yes. You can do that using labels on your PRs. So if it's a bug fix and you have a label, you know, then you can put it under a separate section.

00:45:00.140 --> 00:45:07.240
Well, so basically just drive it with GitHub labels. Cool. All right. We got a lot to go through here. So maybe these next two are pretty quick here. Actually, the next three here.

00:45:07.580 --> 00:45:19.280
You talked about this sort of article and the cookie cutter drifting quite a bit apart because so many things have changed. One thing that seems to be pretty stable is like since black came out, people are all about just black.

00:45:19.280 --> 00:45:24.380
It hasn't seemed to gone out of style at all. I think that's pretty, pretty stable one, right?

00:45:24.380 --> 00:45:35.540
It really makes a huge difference for productivity. And I feel if I'm contributing to somebody else's project, it makes things so much easier to know that there's a consistent style.

00:45:35.760 --> 00:45:55.400
I don't need to be afraid to destroy somebody's, you know, well-crafted, handcrafted, formatted code. I can just run black. And it's also great, really helps readability. It's basically the style becomes invisible. So I love black. And black now, better status in January. So we now have like...

00:45:55.400 --> 00:45:55.940
Official black.

00:45:55.940 --> 00:45:56.780
Finally.

00:45:56.780 --> 00:46:01.180
Well known as hash 000000. There's no more debate.

00:46:01.180 --> 00:46:04.960
So yeah, I'm definitely, definitely a big fan of black.

00:46:04.960 --> 00:46:11.320
Indeed. I also give a shout out to Predeer as well. And then sort of related, you have import sorting with iSort.

00:46:11.320 --> 00:46:18.060
I've been using reorder Python imports for a long time, which is also a tool by Anthony Sotile, who wrote Precommit.

00:46:18.060 --> 00:46:27.420
Yes. I wanted to give Anthony a shout out, but I wasn't 100% sure that I had the name just right in my memory. So I didn't want to like misattribute it. But yeah, he also did Precommit, which I had him on the show for.

00:46:27.420 --> 00:46:42.120
Right. So these days, I actually like to use iSort, which is what everybody uses. It's since iSort 5, it's become much nicer to use. It uses the AST more. It has no trouble figuring out what your third party dependencies are.

00:46:42.980 --> 00:46:49.340
And it has an option. It has these profiles to make it really easy to be compatible with black style.

00:46:49.340 --> 00:47:02.820
And what I like to do is I like to put each import on a single line, which is actually what reorder Python imports does as well. And it greatly reduces the chance of merge conflicts.

00:47:03.260 --> 00:47:16.760
Oh, right. Okay. Yeah, of course. Cool. A quick question, stepping back to the release drafter. Michael out in the audience says his biggest hurdle is for doing regular and good release for doing regular and good releases are change logs.

00:47:16.760 --> 00:47:23.940
How does release drafter sort of fit into that? Basically, if you structure everything as a PR, it'll capture it?

00:47:23.940 --> 00:47:37.280
Yes. So release drafter only drafts the GitHub release for you. If you want to have, say, a page in your Sphinx documentation, you're going to need to pull that out. There's actually a...

00:47:37.280 --> 00:47:50.720
I'm sorry. That's his GitHub handle. I'm sure we should put a link later, but there's a tool that will pull the GitHub release and insert it into your Sphinx documentation. So you can do that.

00:47:50.940 --> 00:48:16.780
And there's also TownCryer, which really should be mentioned, and Scriv, which was written by Ned Batchelder. Those are tools that allow you to add release notes to your PRs as snippets or fragments. And that scales very well if you have an open source project with many contributors. So yeah, it's still figuring out the best way to maybe integrate all of these in some way.

00:48:16.780 --> 00:48:33.600
Sure. You can overdo it for sure. All right. I think a quick, just a quick shout out. Speaking of Ned Batchelder, we have pytest, Coverage.py, and CodeCov all in there is neat. And then CLI interface with Click. That's an interesting one, a popular one as well.

00:48:33.720 --> 00:48:42.080
Absolutely. So that's from the Palace project. So the same family of projects like Flask. There's also a nice wrapper for Click called Typer.

00:48:42.080 --> 00:48:42.520
Yes.

00:48:42.520 --> 00:48:44.580
It's written by the FastAPI author.

00:48:44.580 --> 00:48:49.640
Yeah. When I saw that using Click, I'm like, hmm, you're such a fan of types. Maybe Typer is also relevant here.

00:48:49.640 --> 00:49:05.980
Actually, I just had another look at Typer and I think I do like it after all. I actually really like it. Initially, I was like, well, it's actually not so. I kind of like how Click gives you these decorators and separates your option help texts from the actual function.

00:49:06.320 --> 00:49:17.140
But it is true that Typer really reduces duplication because you don't have to repeat the types of your options. They're just type annotations of your parameters. So that's really neat.

00:49:17.140 --> 00:49:25.380
Nice. Continuing with the typing story, we've got two things here. A static type checking with mypy. I suspect a lot of people who are really into typing know about this.

00:49:25.380 --> 00:49:35.380
Like the CLI, you run against your code and it'll make sure everything hangs together. If this function is calling that function with that variable, and you said that variable is one of the things that make sure that all is going to fit together.

00:49:35.380 --> 00:49:42.280
And if you get that working, then you might be open to having something like mypyC for optimizations and so on, which is also interesting.

00:49:42.280 --> 00:49:46.520
But one that maybe people haven't heard about is runtime type checking with Typeguard.

00:49:46.520 --> 00:49:54.100
Right. I think it's really one of the most undervalued projects out there in the typing space. Typeguard is so useful.

00:49:54.100 --> 00:49:59.720
When I first heard about it, I was like, why would you want to runtime type check your code?

00:49:59.720 --> 00:50:02.580
If you have a static type checker, you know why?

00:50:02.580 --> 00:50:05.020
Then you need to hit all the code paths.

00:50:05.020 --> 00:50:11.840
Static type checking is great because it can just basically deduce the type correctness.

00:50:11.840 --> 00:50:21.340
Typeguard is really useful if you're, for example, if you're interfacing with third-party libraries who may or may not have type annotations.

00:50:21.540 --> 00:50:22.540
If they do, great.

00:50:22.540 --> 00:50:25.360
But you know, how much do you trust them?

00:50:25.360 --> 00:50:25.680
Right.

00:50:25.680 --> 00:50:26.100
Yeah.

00:50:26.100 --> 00:50:30.140
Just because it says it, nothing enforces that where it said it returns an int.

00:50:30.140 --> 00:50:31.120
It could return none.

00:50:31.120 --> 00:50:31.480
Yeah.

00:50:31.480 --> 00:50:33.120
And it should have said optional int, but it didn't.

00:50:33.120 --> 00:50:37.760
Your code can absolutely have type correctness as far as mypyC is concerned.

00:50:37.960 --> 00:50:47.760
But that might be just because there are some any types or it's just kind of a loosey type because there's no way to be stricter about the actual types.

00:50:47.760 --> 00:50:48.920
And Typeguard will check that.

00:50:48.920 --> 00:50:53.180
So the way I like to use Typeguard is as a pytest plugin.

00:50:53.180 --> 00:50:56.040
So you're basically running your test suite.

00:50:56.040 --> 00:51:02.420
And if you have complete code coverage, that should give you a good chance to catch any type.

00:51:02.420 --> 00:51:03.000
Oh, interesting.

00:51:03.000 --> 00:51:07.560
So you can turn it on while your tests are running and it will runtime check everything.

00:51:07.560 --> 00:51:10.340
But then in production, not turn it on?

00:51:10.340 --> 00:51:10.820
Exactly.

00:51:10.820 --> 00:51:13.000
You basically specify it.

00:51:13.000 --> 00:51:17.020
So you install it next to pytest and then you pass an option.

00:51:17.020 --> 00:51:21.720
I think it's Typeguard packages and pass the name of your package.

00:51:21.720 --> 00:51:31.980
And then Typeguard is going to wrap every function in your code and check the parameter types and the return type.

00:51:31.980 --> 00:51:33.020
So that's really useful.

00:51:33.020 --> 00:51:33.920
It's also a library.

00:51:33.920 --> 00:51:38.520
So if you want to explicitly check in production, you can also use Typeguard for that.

00:51:38.520 --> 00:51:38.800
Nice.

00:51:38.800 --> 00:51:43.640
Yeah, it's got the type checked decorator, which probably you can just put that on stuff you want to make sure it's checked.

00:51:43.640 --> 00:51:43.980
Exactly.

00:51:43.980 --> 00:51:44.500
Okay.

00:51:44.500 --> 00:51:45.820
Well, that's a good one to learn.

00:51:45.820 --> 00:51:48.240
Another one is you create your project.

00:51:48.240 --> 00:51:50.320
You start building it.

00:51:50.320 --> 00:51:53.500
Two years later, you know, some feature is added.

00:51:53.500 --> 00:51:56.740
Some other language feature might be not the way to do things.

00:51:56.740 --> 00:52:01.100
So you talk about automated Python syntax upgrades with PyUp upgrade.

00:52:01.100 --> 00:52:01.580
Yeah.

00:52:01.580 --> 00:52:04.460
That's another Anthony Sotile tool.

00:52:04.460 --> 00:52:07.800
So it's also, you can run it from pre-commit.

00:52:08.340 --> 00:52:22.940
It's going to essentially pass the AST of your, so the abstract syntax tree of your code and look for things that have better ways to express them in your versions of Python.

00:52:22.940 --> 00:52:31.400
So basically what you say, you drop Python 3.6 and automatically you get unions like the pipe.

00:52:31.400 --> 00:52:32.240
Right, right.

00:52:32.240 --> 00:52:35.600
Like int pipe none versus optional bracket int.

00:52:35.600 --> 00:52:36.800
Something like that, right?

00:52:36.800 --> 00:52:37.160
Yeah.

00:52:37.160 --> 00:52:38.140
These kinds of things.

00:52:38.140 --> 00:52:39.160
Or yeah.

00:52:39.160 --> 00:52:42.400
Giving you nice set comprehensions.

00:52:42.400 --> 00:52:42.920
Yeah.

00:52:42.920 --> 00:52:45.020
Kind of like calls to the set built in.

00:52:45.020 --> 00:52:46.000
Those of these.

00:52:46.000 --> 00:52:52.180
And it's very nice if you're supporting multiple Python versions and you've been waiting to use this feature.

00:52:52.180 --> 00:52:58.500
And now finally you can drop the last Python version that didn't support it and you get this for free.

00:52:58.500 --> 00:52:59.440
I just run.

00:52:59.440 --> 00:53:00.520
Yeah, that is interesting.

00:53:00.520 --> 00:53:02.320
I hadn't really thought about that.

00:53:02.320 --> 00:53:12.800
You know, some of these are not language features in the sense that people are thinking, oh, well now I can use async and await, which would take like a real important, significant change.

00:53:12.800 --> 00:53:25.360
But it's just like, oh, you, you know, now you're able to, because of PEP 289, pass a generator directly to the min function or max or sum rather than a list comprehension, which then gets processed, right?

00:53:25.360 --> 00:53:27.480
And that would just be more efficient across the board.

00:53:27.480 --> 00:53:29.640
And so that just happens automatically, right?

00:53:29.640 --> 00:53:30.040
Cool.

00:53:30.040 --> 00:53:30.460
Yeah.

00:53:30.460 --> 00:53:30.960
Very neat one.

00:53:30.960 --> 00:53:31.320
All right.

00:53:31.320 --> 00:53:31.840
Next.

00:53:31.840 --> 00:53:33.580
Security audits.

00:53:33.580 --> 00:53:34.620
There's Bandit.

00:53:34.620 --> 00:53:47.100
Bandit is a tool that looks at your Python code and figures out if there are any things that may or may not give you a security vulnerability or any kind of security issue.

00:53:47.100 --> 00:53:53.940
It flags some things like just importing a subprocess and you can no QA it.

00:53:54.880 --> 00:54:03.380
I still find that useful because it just gives me a moment to think about all the implications of spawning other processes from our Python code.

00:54:03.380 --> 00:54:08.480
And, but it, it has a lot of checks in your, in your Python code base.

00:54:08.480 --> 00:54:12.800
So it's, it's very nice to use it to guard yourself against some.

00:54:12.800 --> 00:54:13.460
Right.

00:54:13.460 --> 00:54:18.740
Like it'll detect things like YAML dot load should be YAML dot safe load.

00:54:18.940 --> 00:54:21.020
And I bet there's something there about pickling.

00:54:21.020 --> 00:54:22.900
Yeah, for sure.

00:54:22.900 --> 00:54:23.820
It's caught of me.

00:54:23.820 --> 00:54:24.340
Could be.

00:54:24.340 --> 00:54:25.160
All right.

00:54:25.160 --> 00:54:26.820
Yeah, exactly.

00:54:26.820 --> 00:54:28.260
Safety is the other one.

00:54:28.260 --> 00:54:28.600
Yeah.

00:54:28.600 --> 00:54:30.620
That basically just checks your dependencies.

00:54:30.620 --> 00:54:39.300
So there's a, there's a curated database of security vulnerabilities and it's going to see if you have any dependency in a version that was vulnerable.

00:54:39.300 --> 00:54:40.420
Nice.

00:54:40.880 --> 00:54:49.080
And just stepping back to some moment, Nick Ma points out that hyper is amazing when it comes to the documentation in the --help option.

00:54:49.080 --> 00:54:49.620
Yeah.

00:54:49.620 --> 00:54:50.020
Pretty cool.

00:54:50.020 --> 00:54:51.060
Let's see.

00:54:51.060 --> 00:54:52.960
Going back to, yeah.

00:54:52.960 --> 00:54:55.960
Checking the documentation with xdoc test.

00:54:55.960 --> 00:55:01.280
So xdoc test is essentially a rewrite of a standard library or utility.

00:55:01.280 --> 00:55:02.300
It's called doc test.

00:55:02.300 --> 00:55:04.080
And what does it do?

00:55:04.260 --> 00:55:11.660
So suppose you have a doc string with an example code that shows how you, how you're supposed to use a library or a function.

00:55:11.660 --> 00:55:20.040
And you commonly write these with a, the Python interpreter prompt to give you like, what, what does the user type import my package?

00:55:20.040 --> 00:55:26.040
And underneath you have the output of whatever, you know, functions you call it and so on.

00:55:26.640 --> 00:55:34.200
So doc test runs these examples and sees if they produce the expected output, they don't throw a raise exceptions and so on.

00:55:34.200 --> 00:55:41.020
xdoc test is a rewrite that uses the AST more than regular expressions, which is nice.

00:55:41.020 --> 00:55:42.340
And it's also a bit more flexible.

00:55:42.340 --> 00:55:47.420
So has a few nice features compared to doc test.

00:55:47.420 --> 00:55:47.700
Right.

00:55:47.700 --> 00:55:47.920
Cool.

00:55:47.920 --> 00:55:53.440
So if you have an example in your documentation, here's a way to automatically make sure it's all good.

00:55:53.780 --> 00:55:56.440
Also another audience question, follow up here.

00:55:56.440 --> 00:56:06.660
Vasil asks, what do you think about services like Sink, S-N-Y-K, S-N-Y-K, S-N-Y-K, to check dependencies, like for security, right?

00:56:06.660 --> 00:56:12.320
So you depend on Flask, Flask depends on it's dangerous, it's dangerous.

00:56:12.320 --> 00:56:13.220
Who knows?

00:56:13.220 --> 00:56:16.060
Theoretically could have some issue like that kind of check.

00:56:16.060 --> 00:56:16.880
I'm thinking he's asking.

00:56:16.880 --> 00:56:17.960
I haven't used S-N-Y-K yet.

00:56:17.960 --> 00:56:21.040
So I'm only familiar with, with safety.

00:56:21.040 --> 00:56:21.860
Nice.

00:56:21.860 --> 00:56:22.140
Okay.

00:56:22.140 --> 00:56:22.640
Cool.

00:56:22.940 --> 00:56:24.020
Getting close to the end.

00:56:24.020 --> 00:56:26.380
Then I have a question about all of these taken as a whole.

00:56:26.380 --> 00:56:27.020
All right.

00:56:27.020 --> 00:56:31.420
Generating API documentation with Autodoc and Napoleon.

00:56:31.420 --> 00:56:31.820
Right.

00:56:31.820 --> 00:56:33.380
So we talked about this before.

00:56:33.380 --> 00:56:36.780
This takes, it takes your doc strings and generates API documentation.

00:56:36.780 --> 00:56:37.120
Right.

00:56:37.120 --> 00:56:41.800
And this is not a RESTful API, like Swagger, OpenAPI.

00:56:41.800 --> 00:56:45.640
This is, this is like my Python libraries function documentation, right?

00:56:45.640 --> 00:56:46.100
Exactly.

00:56:46.100 --> 00:56:46.380
Yeah.

00:56:46.380 --> 00:56:51.500
That's so the reference for your, the functions in your, in your package.

00:56:51.500 --> 00:56:51.900
Got it.

00:56:52.100 --> 00:56:52.720
Right.

00:56:52.720 --> 00:56:52.820
Right.

00:56:52.820 --> 00:56:53.020
Right.

00:56:53.020 --> 00:56:53.120
Right.

00:56:53.120 --> 00:57:00.180
And Napoleon is a tool that will add support for doc strings that are written Google style,

00:57:00.180 --> 00:57:02.960
for example, or some other conventions for doc strings.

00:57:02.960 --> 00:57:06.800
So Google style is pretty lightweight, which I'm a fan of that as well.

00:57:06.800 --> 00:57:07.360
Yeah.

00:57:07.360 --> 00:57:07.400
Yeah.

00:57:07.400 --> 00:57:07.700
Yeah.

00:57:07.700 --> 00:57:10.020
Declaring your arguments and, and returns.

00:57:10.020 --> 00:57:10.380
Okay.

00:57:10.380 --> 00:57:10.840
Nice.

00:57:10.840 --> 00:57:14.360
Generate command line reference with Sphinx click.

00:57:14.500 --> 00:57:18.700
So I'm guessing if you're using click might be relevant.

00:57:18.700 --> 00:57:19.100
Right.

00:57:19.100 --> 00:57:26.260
So you already have all your option help texts and, you know, command descriptions in, in click.

00:57:26.260 --> 00:57:29.320
So why not just use them to generate the documentation.

00:57:29.320 --> 00:57:32.160
And that's basically what Sphinx click does.

00:57:32.160 --> 00:57:39.220
So it takes, so you, when you build your documentation and you use things like auto doc or Sphinx click,

00:57:39.220 --> 00:57:41.260
you have to remember to install your own package.

00:57:41.260 --> 00:57:47.780
And then these tools can just import it and read the, read all the documentation that you have inline in your code,

00:57:47.780 --> 00:57:50.060
including click option up text.

00:57:50.060 --> 00:57:50.320
Yeah.

00:57:50.320 --> 00:57:50.740
Very cool.

00:57:50.740 --> 00:57:51.360
All right.

00:57:51.360 --> 00:57:54.000
You've done all the work documented it.

00:57:54.000 --> 00:57:54.720
You've tested it.

00:57:54.720 --> 00:57:55.420
It's good to go.

00:57:55.420 --> 00:57:56.840
How are you going to release it?

00:57:56.840 --> 00:57:57.640
Put it on GitHub.

00:57:57.640 --> 00:58:00.920
And the last one is managed project labels with GitHub labeler.

00:58:00.920 --> 00:58:10.420
So the, the idea of labeler is that you, instead of going through the web interface and then typing in all the,

00:58:10.420 --> 00:58:18.940
color codes and hacks and so on, you, you can just use, a file that you put in your repository to manage all your,

00:58:18.940 --> 00:58:21.220
all your labels for your PRs and for your issues.

00:58:21.220 --> 00:58:26.200
So that's really helpful and makes it really easy if you're collaborating with other people.

00:58:26.200 --> 00:58:26.600
Nice.

00:58:26.600 --> 00:58:27.160
Yeah.

00:58:27.160 --> 00:58:27.580
That's great.

00:58:27.580 --> 00:58:28.140
Okay.

00:58:28.140 --> 00:58:30.100
Well, that's your cookie cutter.

00:58:30.100 --> 00:58:36.200
And in one fail swoop, in one single CLI cookie cutter command, you get all of these.

00:58:36.200 --> 00:58:39.740
So when this runs, I should have just run it and played with it.

00:58:39.780 --> 00:58:46.220
But does it give you an option to say, you know, don't install my pie or does it just kind of give it all to you?

00:58:46.220 --> 00:58:50.440
What's the, I know cookie cutter has a lot of conditional behaviors and stuff.

00:58:50.440 --> 00:58:52.880
Like what's the experience of using this to create a project?

00:58:52.880 --> 00:58:56.200
I have personally resisted putting in too many options.

00:58:56.200 --> 00:59:03.240
It's kind of, I try to find, to kind of show one way that works and also keep it maintainable.

00:59:03.240 --> 00:59:07.240
So I don't have a lot of, I don't want the combinatorial explosion.

00:59:07.240 --> 00:59:10.120
There's a little bit of options that it gives you.

00:59:10.120 --> 00:59:19.160
So you can choose the license, for example, and cookie cutter allows you to hide or show parts of your file tree, depending on what the user chose.

00:59:19.160 --> 00:59:32.780
But basically it's not meant to be the, all the different packaging tools, all the different ways like talks, knocks, the different CIs that there was a conscious decision to basically say, okay, here's one way to do it.

00:59:32.940 --> 00:59:36.280
And I can really curate it and make sure that it all works.

00:59:36.280 --> 00:59:36.560
Sure.

00:59:36.560 --> 00:59:40.340
Keep it opinionated and straightforward and whatnot, right?

00:59:40.340 --> 00:59:48.260
I suppose if people really wanted to use talks instead of knocks and they wanted to use typer instead of click, they could fork the repo, create their own template, right?

00:59:48.260 --> 00:59:49.280
And roll with that.

00:59:49.280 --> 00:59:49.500
Yeah.

00:59:49.500 --> 00:59:49.740
Cool.

00:59:49.740 --> 00:59:50.380
All right.

00:59:50.380 --> 00:59:51.960
Well, very interesting.

00:59:51.960 --> 00:59:58.960
One more quick audience question here from Michael says, can labeler, as in GitHub labeler, export existing settings?

00:59:58.960 --> 01:00:01.660
It'd be great to unify labels across repos.

01:00:01.660 --> 01:00:02.320
Any idea?

01:00:02.320 --> 01:00:02.800
Right.

01:00:02.800 --> 01:00:06.620
I think there is a separate tool to do that.

01:00:06.620 --> 01:00:13.340
So I don't think that GitHub labeler does it, but I remember that that was actually a community contribution.

01:00:13.340 --> 01:00:23.580
And I remember that the contributor who added this feature first went and exported the existing configuration from whatever we had in the repository.

01:00:23.580 --> 01:00:24.080
Okay.

01:00:24.080 --> 01:00:24.640
Yeah, cool.

01:00:24.640 --> 01:00:25.040
So.

01:00:25.040 --> 01:00:25.880
Yeah, very nice.

01:00:25.880 --> 01:00:26.500
All right.

01:00:26.500 --> 01:00:30.160
Well, we are just tiny bit out of time here.

01:00:30.160 --> 01:00:37.240
So unfortunately, even though there's a bunch of other stuff I wanted to cover, I don't think we're going to be able to because we cover so many cool things.

01:00:37.240 --> 01:00:41.300
You know, I did want to just give a quick shout out to your music.

01:00:41.300 --> 01:00:48.580
And in addition to being a lawyer and a software developer and open source person, you also do like compositional stuff.

01:00:48.580 --> 01:00:49.100
Right.

01:00:49.100 --> 01:00:51.260
So you've got on your website, you've got a whole section.

01:00:51.260 --> 01:00:52.500
How many videos here?

01:00:52.580 --> 01:00:56.760
Like 10 different music videos that you've put together that are pretty neat.

01:00:56.760 --> 01:00:58.100
You want to just give a quick shout out to that?

01:00:58.100 --> 01:00:58.420
Yeah.

01:00:58.420 --> 01:01:06.660
So I spent, I think, 10 years working both as a software engineer and a touring and recording musician.

01:01:06.660 --> 01:01:08.580
Also as an arranger.

01:01:08.580 --> 01:01:10.240
So I arranged some string quartets.

01:01:11.120 --> 01:01:17.420
So I did arrangements for Naima Hussaini, who's a German indie singer.

01:01:17.420 --> 01:01:19.220
Definitely check her.

01:01:19.220 --> 01:01:20.380
Jack E.

01:01:20.380 --> 01:01:27.520
I've been on tour with her already across all of Europe and wonderful reggae inspired singer.

01:01:27.520 --> 01:01:29.460
And there are so many more.

01:01:29.460 --> 01:01:30.500
Yeah.

01:01:30.500 --> 01:01:32.640
It's, yeah.

01:01:32.800 --> 01:01:36.200
I'm very grateful for the musicians I've been able to play with.

01:01:36.200 --> 01:01:37.020
Yeah.

01:01:37.020 --> 01:01:37.760
That's fantastic.

01:01:37.760 --> 01:01:39.240
I listened to a bunch of them.

01:01:39.240 --> 01:01:43.660
My favorite is Immer Alles Kustisch im Deutschen Theater.

01:01:43.660 --> 01:01:45.900
That's the one with Naima Hussaini.

01:01:45.900 --> 01:01:47.460
That was a really good one.

01:01:47.460 --> 01:01:48.140
They're all good.

01:01:48.140 --> 01:01:49.700
But that one was really excellent.

01:01:49.700 --> 01:01:54.100
And then Michael also thinks that we should have a whole podcast about your compositional tools.

01:01:54.100 --> 01:01:56.260
Do you use Python for any of this stuff?

01:01:56.260 --> 01:01:57.900
Or is it kind of a separate world?

01:01:57.900 --> 01:02:00.660
Sadly, it's pretty much a separate word.

01:02:00.780 --> 01:02:02.780
I've been using Ableton a lot.

01:02:02.780 --> 01:02:07.220
And we didn't really get into automating all of this with Python yet.

01:02:07.220 --> 01:02:08.560
Not yet.

01:02:08.560 --> 01:02:09.200
Not yet.

01:02:09.200 --> 01:02:09.500
Also.

01:02:09.500 --> 01:02:12.440
I think Lucas Lange does this kind of stuff, though.

01:02:12.440 --> 01:02:13.360
Yeah.

01:02:13.360 --> 01:02:13.640
Cool.

01:02:13.640 --> 01:02:14.460
It can be done.

01:02:14.460 --> 01:02:14.760
Yeah.

01:02:14.760 --> 01:02:15.940
People should check out Fox.

01:02:15.940 --> 01:02:17.320
Are you familiar with Fox.

01:02:17.320 --> 01:02:22.500
And that whole programming with composition, building up music with Python?

01:02:22.500 --> 01:02:23.100
Have you seen this?

01:02:23.100 --> 01:02:23.460
I know.

01:02:23.460 --> 01:02:25.060
Oh, my gosh.

01:02:25.060 --> 01:02:26.380
I've got to check this out.

01:02:26.380 --> 01:02:27.760
Every time I search for it, Fox.

01:02:27.760 --> 01:02:28.840
I think it's Fox.

01:02:28.840 --> 01:02:29.380
Python.

01:02:29.380 --> 01:02:30.640
I think that's what it is.

01:02:30.900 --> 01:02:31.840
Check out the videos.

01:02:31.840 --> 01:02:35.400
There's some neat live coding music with Fox.

01:02:35.400 --> 01:02:35.960
And Python.

01:02:35.960 --> 01:02:40.100
Every time I just randomly pick one of these videos, it's not really necessarily the best one.

01:02:40.100 --> 01:02:43.880
But there's some really neat ones of sort of like adding instruments in with Python.

01:02:43.880 --> 01:02:44.460
It's cool.

01:02:44.460 --> 01:02:45.600
People should check that out.

01:02:45.600 --> 01:02:46.100
Yeah.

01:02:46.100 --> 01:02:46.700
All right.

01:02:46.740 --> 01:02:49.140
Well, we are out of time.

01:02:49.140 --> 01:02:50.200
Really quickly.

01:02:50.200 --> 01:02:51.820
Final two questions.

01:02:51.820 --> 01:02:53.420
You're going to write some Python code.

01:02:53.420 --> 01:02:54.740
What editor are you using these days?

01:02:54.740 --> 01:02:55.800
I use Space Max.

01:02:55.800 --> 01:03:00.000
I've been using Emacs for a long time and use it with VI bindings now.

01:03:00.000 --> 01:03:00.780
I like it.

01:03:00.780 --> 01:03:01.160
Right on.

01:03:01.360 --> 01:03:06.340
And I'm almost hesitant to ask you for a notable PyPI package because we covered so many.

01:03:06.340 --> 01:03:08.600
But maybe just like, you know, what one stands out to you?

01:03:08.600 --> 01:03:10.900
Like you want to just give a shout out to either one we covered or...

01:03:10.900 --> 01:03:14.080
I just named TypeGuard because it really deserves...

01:03:14.080 --> 01:03:14.160
Okay.

01:03:14.160 --> 01:03:18.360
TypeGuard 3 is going to come out hopefully soon, bringing new features.

01:03:18.360 --> 01:03:19.260
Cool.

01:03:19.260 --> 01:03:19.980
All right.

01:03:19.980 --> 01:03:21.000
Well, final call to action.

01:03:21.000 --> 01:03:22.260
People want to get started.

01:03:22.260 --> 01:03:25.700
This hypermodern project idea that you've created, what do they do?

01:03:25.700 --> 01:03:29.240
So just go to the cookie cutter hypermodern Python repo.

01:03:29.240 --> 01:03:32.940
Check out the contributor guide and the code of conduct.

01:03:32.940 --> 01:03:35.080
And we love contributors.

01:03:35.080 --> 01:03:36.060
So...

01:03:36.060 --> 01:03:36.280
Hold on.

01:03:36.280 --> 01:03:39.420
How relevant is going back and reading the article?

01:03:39.640 --> 01:03:42.600
Has it drifted too far or is it enough to get like some of the zen?

01:03:42.600 --> 01:03:44.760
Or if you've listened to this, are you kind of good to go?

01:03:44.760 --> 01:03:47.980
I think the article series is still fun to read.

01:03:47.980 --> 01:03:53.960
I think these days what I would recommend is that you don't just take the example code.

01:03:53.960 --> 01:04:00.440
Maybe just generate a default project from the cookie cutter and then take a look at that as well.

01:04:00.440 --> 01:04:03.200
Because some things have changed in the two years.

01:04:03.200 --> 01:04:06.820
But the article series kind of gives you the motivation for everything.

01:04:07.260 --> 01:04:14.820
And it's probably also more fun to read than the user guide for the project template, which is also there and very detailed.

01:04:14.820 --> 01:04:15.460
But yeah.

01:04:15.460 --> 01:04:15.720
Yeah.

01:04:15.720 --> 01:04:16.160
Fantastic.

01:04:16.160 --> 01:04:16.580
All right.

01:04:16.580 --> 01:04:18.240
Well, thank you so much for being on the show.

01:04:18.240 --> 01:04:19.860
And congrats on the cool project.

01:04:19.860 --> 01:04:20.840
Thank you very much.

01:04:20.840 --> 01:04:21.460
You bet.

01:04:21.460 --> 01:04:21.860
Bye.

01:04:21.860 --> 01:04:22.240
Bye-bye.

01:04:22.540 --> 01:04:23.700
Bye-bye.

01:04:23.700 --> 01:04:26.000
This has been another episode of Talk Python to Me.

01:04:26.000 --> 01:04:27.820
Thank you to our sponsors.

01:04:27.820 --> 01:04:29.420
Be sure to check out what they're offering.

01:04:29.420 --> 01:04:30.840
It really helps support the show.

01:04:30.840 --> 01:04:33.240
Starting a business is hard.

01:04:33.240 --> 01:04:41.840
Microsoft for Startups, Founders Hub, provides all founders at any stage with free resources and connections to solve startup challenges.

01:04:41.840 --> 01:04:46.360
Apply for free today at talkpython.fm/foundershub.

01:04:46.880 --> 01:04:50.940
Listen to an episode of Compiler, an original podcast from Red Hat.

01:04:50.940 --> 01:04:58.400
Compiler unravels industry topics, trends, and things you've always wanted to know about tech through interviews with the people who know it best.

01:04:58.400 --> 01:05:02.520
Subscribe today by following talkpython.fm/compiler.

01:05:02.520 --> 01:05:04.240
Want to level up your Python?

01:05:04.240 --> 01:05:08.280
We have one of the largest catalogs of Python video courses over at Talk Python.

01:05:08.720 --> 01:05:13.460
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:05:13.460 --> 01:05:16.120
And best of all, there's not a subscription in sight.

01:05:16.120 --> 01:05:19.040
Check it out for yourself at training.talkpython.fm.

01:05:19.040 --> 01:05:23.720
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

01:05:23.720 --> 01:05:25.020
We should be right at the top.

01:05:25.020 --> 01:05:34.380
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

01:05:34.380 --> 01:05:37.820
We're live streaming most of our recordings these days.

01:05:38.180 --> 01:05:45.600
If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:05:45.600 --> 01:05:47.500
This is your host, Michael Kennedy.

01:05:47.500 --> 01:05:48.780
Thanks so much for listening.

01:05:48.780 --> 01:05:49.940
I really appreciate it.

01:05:49.940 --> 01:05:51.860
Now get out there and write some Python code.

01:06:07.640 --> 01:06:12.400
I'll see you next time.

01:06:12.400 --> 01:06:42.380
Thank you.

