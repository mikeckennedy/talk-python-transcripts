00:00:00 If you could have any API you wanted to access data from Python, what would it look like? What would make it pythonic? This week you'll hear about pony ORM pony is a Python ORM with beautiful query syntax that lets you write your database queries using Python generators and lambdas. Join me in a conversation with one of pone orams founders, Alexi, melosh kovitch. This is talk Python to me, Episode 87, recorded November 3 2016.

00:00:30 Ember developer, in many senses of the word because I make these applications balls and use these words to make this music constructed. You think when I'm coding another software design, in both cases, it's about design patterns, anyone can get the job done. It's the execution that matters. I have many interests.

00:00:50 Welcome to talk Python to me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities. This is your host, Michael Kennedy, follow me on Twitter, where I'm at m Kennedy. Keep up with the show and listen to past episodes at talk python.fm and follow the show on Twitter via at talk Python. This episode has been sponsored by robar and gocd. Thank them both for supporting the podcast by checking out what they're offering during their segments. Lexie Welcome to talk Python.

00:01:20 I Michael. Thank you guys. Good

00:01:21 to have you here. Thanks for coming. I'm super excited to talk about your ORM. And that you built this, what I'm saying might be the most pythonic ORM yet, which because of the really cool query syntax that use and a couple of other highly pythonic techniques, and I'm very impressed with it. But before we get into the details of pony ORM, let's talk about your story. How did you get into programming and Python?

00:01:46 Well, I was always interested in programming. Actually, when I was a teenager, I had a synthetic spectrum computer, playing computer games and start to program basic. And actually, it was the reason for me to get a master's degree in Computer Science later when I was programming while studying in the university. But what I really liked was computer networks. So after graduating, I started to work as a network engineer in an IT department of an airline company. And at that time, it was 2001 and 2002, airline agencies had to use dedicated leased lines for connecting to Erlang database system. And I figure that using internet for that would be like 100%, cheaper, and like got the crazy idea of developing a client server solution, which works or internet. So I developed a prototype. And it consisted of an app written in delfy and Linux server. And then I presented it to the airline management team. And they were impressed and offered me to form a development team. So from that point in time I started Yeah, I continued to developer

00:03:02 Yeah, that's think of the times back when you had to have a leased line or back when you had BBs you had to dial up to get online. Like it's just such a different world, right. But that's really cool that you held that company like emerged out of that world,

00:03:17 right. So now you cannot imagine that not using it. Yeah, so and then, several years later, I started to work. For another company. It was a FinTech startup. It was a New York based company. And they outsourced the development to St. Petersburg, Russia. And this is the city where I'm originally from. And I was developing the back end in C++ and Java. And when the business took off, they decided to form a team and development team in New York. And they invited me for this role. So I moved to New York, and formed the development team there and was building software for some years there. And during that time, actually, my friend Alexander Kozlowski, he studied together in the university. And he was really, really interested in databases. And he was actually a senior lecturer. So he taught people databases, and he feel that most people actually don't get relational algebra, you know, and there should be a better way to build software. And he suggested an idea to build web framework. And I love that Yeah, because working for financial company, I saw that this very fast environment and I actually missed a tool like Delphia rabbit application development tool. And I thought that if I would have one, I would use one This car, we started to work on pornea. And it was a weekend project actually initially developed the whole framework issue. And it was a templating engine it was routing it was, or RAM. And then we found that probably we shouldn't do all those things, because it's too much. Yeah, by the time SQL SQLAlchemy appeared, actually, we started the same here 2006, it was the first year when we started to work together. And actually, by that time, Alexander origa, tried to build a mapper. He tried in C++ in delfy. And Python was a choice, which he came to understanding that it should be a dynamic language.

00:05:50 Yeah, I'm sure it was much harder in C++ to pull something like this off, especially with the really rich language level query syntax, like, I'm not really sure how that works in C++,

00:06:01 right? And then we start to work together on this. And he told that it was a sequel object, such a mapper, and in one of email, at least, he suggested that why not to use generator syntax for writing queries. And I love the idea too, because it was natural syntax for queries. It is completely natural syntax, like I think of generator expressions. And list comprehensions is kind of like in memory database operations just working on on your objects, obviously not indexed or anything like that.

00:06:38 So if you're going to do that in your Python code, but somehow project that down into the database, that's perfect, I think.

00:06:44 Yeah, exactly. And what you liked as well that it is so natural for someone who just starts working with Python, that you don't need to actually learn another language such as SQL.

00:06:58 Yeah, I think you probably could get away with just being able to read but not write SQL with Python. Yeah. Yeah. Or SQLAlchemy, or some of the other ORM. Right. Like, if you can understand the debug output. You may be okay. Notice, it depends on how complex this was against. But that's, that's a cool goal anyway,

00:07:18 exactly. I worked with people who actually can program different languages, but it's hard for them to understand SQL pretty well. And that's why we decided that if we could provide such a tool, it will be very helpful. And I could see how it can speed up making prototypes. And you know, when you build the prototype, you never know if it will be an application later and how to evolve.

00:07:48 Yeah, absolutely. That mean, I wonder how many applications are in production in the world that were just supposed to be prototypes? I bet it's a really high percentage.

00:07:58 Yeah, you need to have a tool, which allows you to start quickly. And then when you actually evolve this with this application roles. You want it to allow you to build this as as complex as you want.

00:08:13 Well, yeah. And also the ability to recreate the project quickly, rather than manage some huge data access later, with some kind of REM that's really nice and clean. Like pony Oreo is a really good thing to have. So you can say, No, no, this is a prototype, we're going to start again, but it only takes like this morning, and then we'll have it back to where it is. But proper, something like that, right. That's cool

00:08:38 app that created using a simple to can reach a point where the further development is too difficult or even impossible. And then reach this borderline of complexity. It's often not time, actually to start from scratch.

00:08:54 Yeah, it's usually you're already down that path, and it's too late. How interesting. Okay, so let's talk about pony ORM. A bit. So pony, orem is a data access layer. It's an ORM object relational mapper. How would you describe it? If somebody asked you what is pony Oreo?

00:09:11 Well, it is an advanced object relational mapper. And it provides a

00:09:18 very easy interface. And even a newbie can start working with this. That is one thing I was struck with when I was working with it is I was almost thinking like, Well, how do I connect back this object to the entities like where do I create the entity based classroom? And all in how do I you know, why don't I have to call add to insert objects and why don't I have to call commit to commit them? And all of those answers are because you're using some really interesting pythonic concepts. That sort of simplify a couple of the steps that you might have found in other rmws.

00:09:56 Right, and pony. It's a small horse, right? This is smart and powerful. So you believe that these features we put into our mapper? I think so too.

00:10:09 I think it's really, it is really nice. And I'm looking forward to using it properly on some projects now that I know a little bit more about it. So I want to ask you what's pythonic about it, but I think maybe the way to, to uncover the various pythonic elements is to actually work through an example. But before we get to that, let's let me ask you this other question. So there's these two styles or two design patterns for that typically are in play at ORM s. And that's whether or not the ORM acts as an active record, where you sort of work with individual elements. So like Ruby on Rails, or I think the Django ORM is like this. Or it's a unit of work, which is like SQLAlchemy, where you create a bunch of objects and make some changes, inserts, updates, deletes, and so on. And when you're finally ready, you commit that unit of work, and it applies all of those, which style is pony?

00:11:05 Yeah, absolutely. There are two basic patterns. And with Active Record, you have an object, which represents a line in the database. And the thing is that if you select the same object twice, using active record, you will have two instances of the same object in the memory. And it is a huge problem, because now you have two objects, which are actually the same. And when you start to change one object, and then change another one, you can have lost updates. And another thing that you need to always remember to call safe on each object.

00:11:47 Yeah, exactly. And you don't really do that with unit work, you just kind of work with your data. And when you're ready, you commit, right,

00:11:54 every time you read a record from the database, we first check in the identity map, if there is such a record already loaded into the memory. And this allows us to return an object from the cache or from the memory instead of querying the database.

00:12:15 Yeah, so that's cool in that it gives you better performance because you're not round tripping to the database, as often. But it's also maybe even more important that it means if you somehow get the same object twice, it's still the same object in memory. Right,

00:12:29 exactly. So it also asked to avoid excessive database calls. And the same time, we always work with the same copy of the object. And another option that it provides us with easy to manage transactions, so we can see when the scope of a function or a context manager was left. And at this point, we can commit all the changes to the database, it is very convenient.

00:12:58 And it's very convenient. I love your use of context managers in this project. So maybe that's a good place to jump into talking about the code. And we have to be a little careful on an audio format talking about code, but maybe we could just kind of roughly walk through some of the steps involved. And we could talk about the pythonic concepts as we get to them. Okay. So obviously, yeah, so obviously, to get started, you have to import pony, right? So there's a number of things in there that you got to work with. So pip install pony, and port pony and so on. And then you create a database. So a database is just an object, right? But this database has a couple of features that go on to be super important, like, on that object, you have a base class, and all of your entities have to derive from it right?

00:13:51 Exactly. So when you create a database, at this point, it is just an object. And later, when you create entities, you inherit it from DB dot entity, which is an attribute and it is an abstract class, which tells that it is an entity which is connected to this database. And hidden such patterns. Actually, you can create several databases, you can simultaneously work with more than one database,

00:14:20 right? Maybe you have like a core database that has your important stuff and then an analytics database for tracking how people use your app something like that, right?

00:14:29 Yeah, it's very often use this way

00:14:31 Yeah. And then you create like you said, you create this class that derives from DB dot entity. What does it look like to define the columns,

00:14:39 the mean difference of fornia from other members, that we work in terms of entities. So in sequel alchemy, you work with installations, and here with the higher the level of abstraction, and work in terms of entities Joseph objects, and we don't create columns, we create attributes of the object. Because this way, we figure that it is easier for a human being to think in terms of objects, not relations.

00:15:13 Yeah. And probably Python as well, right? We're used to working with hierarchical collections of objects, anyway.

00:15:19 Yeah, yeah. And then you create attributes. And we provide a very concise way of declaring such entities. Because from the first day of development, we actually had three goals, we wanted, this model would be easy to use, it means having pythonic API, it will be very performant. So high performance is the goal. And the third is safety and reliability. So we would like to avoid SQL injections and make it reliable.

00:15:52 Yeah, you do some really nice stuff to avoid SQL injection attacks. And I'll talk about those later as well.

00:15:58 Yeah. So when you declare entities, it is, as short as possible, you just write the attribute name, and then the type of the attribute. So it could be a required attribute or optional. Another two options is you can have a primary key or a relationship to another entity. And then in creating the attribute, you specify the type, or the attribute, and some additional options, like unique or, or the generator, when you want to have a sequence, greeting a new object. Sometimes you want the ID to be automatically generated, right? Of course, you have default values as well for like created dates and things like that. Right? Right. So we have API reference. And there are about like, probably 15, options that you can specify for attribute. And you asked about columns, you can also specify the name of the column, if you would like to give a specific name to the database column, or if you have a database already created. And you would like to map this entities to the existing tables. So you can specify the table name, and the column name and declaring the entity

00:17:19 Yeah, that's, that's excellent. So let me try to give people a really quick example here. So you've had on your GitHub, you've got a nice example called a store. And you've relationships between like customers and products and stuff in a shopping cart, and so on. So you obviously have a customer class, and a product class and so on, but just to like talk about the simplicity. So for a cart item, the whole thing is you have a cart item class, it derives from DB dot entity, it has a quantity, which is a required column, which is an integer. And then you have a customer, which is a required customer object, just literally privacy, the class name, not even in quotes, just actually the Python class object, and product required of product. So here's a object that has two relationships back to customer and product. And it's like the simplest thing you can imagine, right? Right.

00:18:16 In order to make this even simpler, you can take a look at the diagram, our entity relationship diagram editor, which represent this, this database schema, so you can visually see this,

00:18:30 right? So for people who are the same if they want to find it, and they want to go on the show notes, it's editor dot pony, O r m.com, slash user slash pony slash e capital S store? Of course, I'll link to that. Yeah, that's, that's really cool. You guys have this wonderful online designer that shows you the relationships that lets you model and rearrange them even get the what would be the generated SQL, the generated Python classes, and so on it, definitely I want to come back and talk about this online editor, because it's, it looks really special. So yeah, so very cool. We create these entities, and the relationships are really super simple to set up. So that's wonderful. And then another thing that you chose to do when your API is make the ID something that is optional,

00:19:16 right? Oftentimes, you don't have a natural primary key. And in this case, you just create attributes, attributes that you want to have an entity. And if you don't declare a primary key, when you add it automatically, and it will be integer type, view the sequence in the auto incrementing

00:19:39 primary key. Exactly, yeah. Yeah, that's perfect. So then you go through the standard stuff, you bind to a database connection and a database type what types of databases are supported?

00:19:50 So currently, we support four major databases which SQL lite for this, my SQL and Oracle Currently, we are working on agent, MySQL, Microsoft SQL Server. So we get the users who asked us about it. And we actually added this type of the database. But the thing is that recently, we added a JSON type support. So you can work view the database, JSON type, and make queries to those Jason types. And this part, we didn't add to Microsoft server yet. But after we will add the JSON support, I think we will include it into the release and view support five databases. Oh, that sounds great. I mean, that's those are basically the major ones like what

00:20:43 are there any that people are asking for that? are asking for commonly that, that are missing only a Microsoft SQL Server? Or was something we were asking about? Yeah, it seems to me like those five rounded out, tell me more about this JSON thing. Is this something that is JSON stored in like Postgres, or sequel lite, or is it something else?

00:21:04 Right, so we use the native database JSON type, so it does Jason D binary, Jason for Postgres, and for my SQL, for Oracle, it is,

00:21:16 I believe, at this club. And for SQL lite, normally, this stored as text by default, but you always can install a module, just called Jason one. And this way, your queries to SQL lite will be faster. Okay, so there's a module that I can extend, I see that I can extend sequel lite so that it can understand the internals of that JSON document. So I could possibly query by some attribute deep down inside it. But recently,

00:21:46 we have added the native JSON data type support. And this way, we can actually combine NoSQL database via the relational database. So it's like having best of two worlds. In a relational database, you can declare an attribute of Jason type. And in this attribute, you can keep the data structure, which can right

00:22:12 yeah, this is really cool. So basically, you have regular columns, but you can also have hierarchical columns that are stored as JSON, more or less. That's right. Yeah, it does very much seem like here's a MongoDB type thing going on as part of that table. Exactly. And you can

00:22:32 actually do queries to the internals of this JSON structure, which is described in our documentation.

00:22:41 Yeah, that's cool. Can you add indexes to the internals of that data structure? I think not yet. It's down to the whether the databases support it, I'm sure, but

00:22:51 probably for the database support that you can actually adjust the native Jason type for the database. If the database supports index, you can add an index. Right? Okay, that makes sense. So it's really a question of,

00:23:05 does MySQL support indexes on embedded JSON types? Which I actually don't know the answer to? So that's cool, though, we can

00:23:12 go use this feature in production already. Nice.

00:23:17 Yes, speaking of production, can you speak of some of the notable deployments? apone? RM d? I mean, I know like the vast majority have no visibility into but

00:23:25 yeah, some of them asked us not share their details, because they have PR departments that we need to approve with. And for those who we can share, I put this demonios to our side.

00:23:41 Oh, yeah. Excellent. See the bottom, here's a whole bunch of testimonials, and people can come check them out. I'm sure not everybody has permission to divulge whether they're there to speak on behalf of their company. But that's very cool.

00:23:53 So when I was working on the new version of the site, I sent this request to all our users. And actually those people wait for the license because we usually hit pornea, at least under the dual license. So it was a GPL. And it was commercial license. And then we figure that agpl, he doesn't really work view the community, people don't like agpl at all. And although we were selling licenses, we decided that we probably need to change our model. And we just need to release pony under Apache two license and think about the possibility to monetize our editor because it really can be a tool which allows people to develop applications faster. And we use the same model as GitHub. So if you would like to share your data schema with everybody make it public. You can use it for free and if you would like to keep it private The the schema, then you asked to pay some money.

00:25:03 Yeah, I think that's a great model. And we'll definitely talk about it. That's it. editor top pony orm.com. Yeah, it's it's very cool.

00:25:24 This portion of talk Python to me has been brought to you by robar. One of the frustrating things about being a developer is dealing with errors, relying on users to report errors, digging through log files, trying to debug issues, or a million dollars just flooding your inbox and ruining your day. With role bars full stack air monitoring, you'll get the context insights and control that you need to find and fix bugs faster. It's easy to install, you can start tracking production errors and deployments in eight minutes, or even less. rhobar works with all the major languages and frameworks, including the Python one such as Django flask pyramid, as well as Ruby, JavaScript, node, iOS and Android. You can integrate robar into your existing workflow, send error alerts to slack or HipChat, or even automatically create issues in JIRA, Pivotal Tracker and a whole bunch more. roll bars put together a special offer for talk Python to me listeners, visit robot.com slash talk Python to me sign up and get the bootstrap plan free for 90 days. That's 300,000 errors tracked all for free. But hey, just between you and me, I really hope you don't encounter that many errors. I love to buy developers at awesome companies like Heroku, Twilio, kayak instacart, Zendesk, twitch and more. give rhobar a try today, go to robar.com slash talk Python to me.

00:26:46 Let's focus for a moment on what I think are you really getting to the pythonic concepts and what we talked about so far with the way you work with ponies. It's very nice, but it's not super unique. And it's just like a nicer version of what I feel like the other ones are doing. But then you get to things like working with context managers and decorators and all sorts of really nice stuff. Tell us how do we like insert data? Or how do I get like a database connection and commit it and go through like that whole

00:27:17 set of steps there? Well, when you bind entities to the database, the next step, you need to generate mapping. And this way, we just connect objects in the program entities to the database tables. And then you can start working in the database. You can select entity objects, or create new objects and all that all that interconnection should be done within the database session, because it is a transaction.

00:27:51 Right? Right, this whole unit of work thing, right? Yeah,

00:27:53 you need to fork Exactly. So you need to either agree the function and decorate it with DB session, or you need to use the context manager and work with the database. within this context manager, yeah, so

00:28:09 let's focus on that for a sec, because I think that's great. So if I want to make a bunch of crud, operations, inserts, updates, deletes, and so on, one way to do that is write a function that changes the data and creates objects, it updates existing ones. And all I have to do is put a decorator right at dB session on that method. And it will, it'll handle both the the you the positive outcome and the negative outcome. So like, if, if that method runs to completion without errors, without exceptions, it will commit the transaction. But if for some reason, there's an exception in there, it will roll back the transaction just by virtue having the decorator right

00:28:49 things are gonna. So when you wrap your code, which works with the entities DB session, it actually does the following. When you start working with a database, it doesn't start a transaction from the first moment, because if this just read, you don't need actually, to open a transaction, you can read from the database without opening it. And when you start to change, then your transaction is created. And then when you leave this scope, if no exception happened, then automatically it will commit the changes to the database. If an exception happened, then it will be rolled back. And you can specify parameters to this decorator. For example, if you would like to retry several times, you can do that specifying parameters to the decorator. That might be helpful when you have more than one process, working with the same table with the same row. And point here's a concept of optimistic chicken So this way we avoid a situation when you can lose updates. When you save something in the database, it actually adds and checks that the attribute values keep the same. Because when you work with the objects on your tracks, which objects you read and which objects you write, so if you, for example, your code, read in attribute, and then do something and save this object into the database, when you will make sure that attributes that you read, keep the same, because if it doesn't it mean that some other process, change the database. And it can be saved in the database.

00:30:46 Yeah, this is very common in the sort of disconnected unit of work styles of rmws. But I really liked this model. I mean, the alternative is pessimistic concurrency, which is to say lock the database, nobody can do a thing, until we're done with this whole part, right, and everybody get get in line. And I'm going to do a bunch of changes. And then you can go make your queries or other operations on the database and not seeing consistent data. And that's great. But it also kills concurrency and all sorts of things. With this model, the opposite optimistic concurrency, it's like, well, probably nobody changed us record also. So it'll just do all the work. And then it will say, more or less something to the effect of update person with ID this where the name is the old name, set the name to the new name, something like that. Right.

00:31:35 So the goal of panya is provide consistent API and ability to work with a database, even for people who don't know much about transactions and most of these service, we would like pony provide such an easy way to work with that data reliably.

00:31:56 Yeah, and I think the retrying thing is really interesting, a really interesting addition there. Sometimes you don't want to make an entire method, basically a transaction in a sense. So you can use another Python at concept of context managers, right? So you can just say, with DB session, do you work in that little suite? And then when you're out of there, it follows the same rules, no exceptions commit exception? rollback, right,

00:32:19 right. At the same time, this concept of optimistic chicken, it wasn't by default, important. But

00:32:27 if you need to lock a database, do for update query, you can do that too. There is a method for entity has a method for update. And a query has such a method for update. So that this way, you can log the database if you if you need, right. Okay, very cool. So the next thing, once you have data in the database, of course, you want to write a query. And this is why this is what caught my attention opponent in the first place is the way that I would like, say, do a query on like, a bunch of people will insert into the database if the person class would be to write a generator, that would do the in memory query. So you'd say something like select p for P and person if P dot age is greater than 20? Like that's literally what you write? Yeah,

00:33:14 yeah, you run this generator, and pass it as an argument to the selector function. And what point does it gets the bytecode, or the generator D compiles it in order to extract the abstract syntax tree. And then it translates this abstract syntax tree into SQL, and made the presentation on the Europe item in 2014. And this available on YouTube, where I explained the whole process, how we actually do this translation, because before, a lot of people actually ask him if this translation is fast enough, and I should tell that the the whole thing works really fast. And the thing is that you need to translate each generator only once. In the whole program, you need to translate the generator bytecode only once, and then it will be cached. And the result of the translation to SQL will be cached as well. And after that, we just have the SQL query where we just put the parameters and send it to the database.

00:34:30 That is really awesome. I'm definitely gonna link to your 2014 talk. You could also do like projection. So like in a generator expression, I could say P dot name, comma p dot age for the data, you support basically doing projections at the database level in the same manner. Right,

00:34:47 right. So you basically you don't even need to think in terms of tables. You just work with objects. And you can select the whole object or you can see Select a specific attribute, or you can can even do aggregation. So you select a topple, for example, you select the P dot name. And then for example, if we have some, let me give you this example, for example, you work with a customer. And this customer has some orders, which has the attribute, total amount. So you can do aggregation and return from this query in a topple where you have the customer name and then aggregated amount of his or her orders. That's really cool.

00:35:41 Do you have some good examples of that on your dock? Yeah. Okay, I'll be sure to link to him. Yeah, send me the link. And finally, if for some reason, this syntax doesn't work for you, you just like, you know, I just need to write a SQL query and just have something happen, you can do that as well. And so you could just go to your entity which represents a table and just say select by SQL, and give it some kind of SQL statement,

00:36:05 you can write row SQL and but what is more interesting is that you can insert a row parts of SQL query into a generator, you know, if you have such a function, or SQL, and for example, there is a function in the database, which is not supported in Python, for example, then you can insert this piece of raw SQL into declarative query written in the form of a generator,

00:36:37 that is really awesome. And also like how you automatically capture the in your SQL text, local variables, as as name. So like, if I had x defined locally, in my SQL statement, I could say dollar x, and you would translate that to a parameter, right? Yeah. And one second, let me send you the link for raw SQL. Oh, yeah, that's really amazing. So you can just say raw SQL as part of either a lambda or a generator expression, and it just, it can execute on the database. Right, exactly. So if you insert this part of rose SQL, into the translated query, and one thing that's interesting is you have both lambda expressions in generator expressions, right? When do I use and I can pass those as the SELECT clause. So when do I use it, which,

00:37:28 if you would like to get an object as the result, you can use lambda or generator. So they will actually be translated into the same SQL query. But if you would like to aggregate the aggregation or return just a couple of attribute names, then in this case, you use a generator, because it allows you to put an expression in the beginning of the generator, right, and it will be returned to us. Nice to have such toggles, for example, yeah,

00:38:03 I really love that aspect of Tony. That's super cool. So let's talk about parameters. Because it's super important for the safety of your app that you don't write, just straight up raw SQL with concatenated strings, right? Like if anybody has a doubt, just Google little Bobby tables. So the parameters here are really great. Like, tell us tell us about that. A pony allows you to avoid SQL injections. Absolutely. Because all the parameters that we pass into the SQL query, they are passed as database parameters. So this way, there's no way to get a SQL injection. And also pony allows you to pass not only parameters, but expressions as well. So you can find that part described in the documentation. When you pass the parameter, you can specify the whole expression inside the generator query. And that's really great that you can pass expressions as well. I think there's always trade offs when you use something, some kind of ORM versus just writing raw SQL entirely. I personally, the safety from SQL injection attacks, the fact that you might forget to use a parameter somewhere, almost alone makes it worth using rmws. Not to mention all the cool benefits of everything else. So yeah, I think it's really great that you have all these levels of safety, especially for web apps. So let's talk about the team how you talked about your co founder just a bit, but maybe mention him again, and how many people are working on the project. Now

00:39:37 Currently, we have four people. So Alexander Kozlowski is my co founder. And we started the work with him together. And at some point, I decided to leave my job and concentrate on poorni full time.

00:39:53 Congratulations on that. That's awesome.

00:39:55 Yeah, thank you. Although we found another project later. So currently The we work on pony. We have four people, we have two more developers. So one of them works on the back end and another on front end. So his role is to, to help us build our editor. We have big plans on that. And currently we actually, yeah, we work on the editor as well. Nice.

00:40:24 Yeah. So tell us, where were you going? what features are you adding?

00:40:28 Currently, you can use the editor in order to create entity relationship diagram and then get either a Python classes or SQL CREATE TABLE statements. And this is actually used a lot by users who actually don't know anything about pony. And when I ran them that, do you use pony? Why not? You just start the the tab with the Python classes. They actually often the the know a thing about pony. And when they discover this possibility, they love this feature and start using pony as well.

00:41:08 Yeah, that's great. Yeah, so let's talk about your editor a little bit. So I really, like I said, edited out pony or calm. And the idea is, it's basically a database diagram development tool, right? So you can see your tables, you can see the relationships, and so on, which all that is all that is really cool. And I can like add a new, a new entity. And it gives you a whole nice designer shows you a bunch of stuff that maybe you didn't realize was something that you could model, like the volatility of attributes or things like this. But then once you get your model built together, you can actually go and say, Show me the Python code, or Yeah, show me the Python code or show me the sequel light code, that it would actually the the DDL table generation code for the various databases and things like that, right?

00:41:56 How do you just create this, and another option is to have a history of all the changes. But what we have other people asking for, is to provide a tool, which allows them to do the whole cycle of development. So when they can create a diagram, and then get the Python code and work on the project, and when they need to change something, they can just change it in the editor. And they get their migration applied to the database. And keep those the local, the changes in the editor.

00:42:31 Nice. Yeah. Okay. So that's, that's really neat that, that brings us to migrations a little bit, what's the story of migration. So

00:42:38 this point is the the feature which is most asked, and at this point, we are working on migrations, and we develop the prototype, and it works. Great. But what would like to add in the ability to write comments inside the migration file the same way, as in Django. So when you just write operations, like add attribute or add relationship, I believe that it will be released within the following month. But it is not that fast. The development of my migrations took longer than we initially suggested. Yeah, it seems like it might take a while. That's a non trivial thing. That's right. But we are very close to the release. At this point. Nice.

00:43:31 Yeah. What are you doing after you get the migrations done

00:43:33 sometime ago, we started to work on a project, which is called to find out to be real. So it is a Miami based company. And the goal is to provide Wikipedia for more than art. I formed a team for this project. And from the day one, we started to use pony, it was actually our goal to find a company where we can use pony in order to build the backend and see how we can make it better. And when we were working on this project, we found that when we need to build a front end, we actually need to have the same models at the front end. And we thought why not to just provide a way to have the same, the same identity map the same models at the front end, and this way was point js, this way pony JS appear. So pony js is a dawn to pony which is not released yet. Why I will tell a little bit later. And this way, you can get the objects which are extracted in the backend, you can have the same graph of connected objects and the front end and work with them in JavaScript die. So

00:44:52 I could just basically expose my models from my back end as some kind of service that honey JS can Consume, and then they're like replicated over or how's that work?

00:45:03 When you extract that objects from the database, then you call the to JSON method. And it returns a set of objects which will be sent to the front end. And the front end, we have a library pointing js, which puts it into an identity map, and allows you to work with objects the same way you do it on the back end. So you can traverse attributes, you can traverse relationships, you can create new objects and send them back to the backend. That's cool. And for allowing this for making this work, we created a layer of emissions in security. So it is also a declarative language, which allows you to tell which operations are allowed to create, delete, update, or modify. But when we were when we were working on this project, we found that Facebook released graph QL. And we thought that probably does the same thing that we are working on. And we decided actually to to try graph QL. And by this time, we had one more team member and joined to our company. And he developed a graph qL server server. And now we have actually three ways to work with the front end. And after we release migrations, we believe that integration with the front end issue will be our major focus.

00:46:40 Yeah, you have your back end stuff pretty much dialed in. So extending, that seems like a great idea.

00:47:01 This portion of talk Python to me is brought to you by go CD from thoughtworks. Go CD is the on premise, open source Continuous Delivery server. With go CDs, comprehensive pipeline and model, you can model complex workflows for multiple teams with ease, and go see these Value Stream Map lets you track changes from commit to deployment at a glance, go see these real power is in the visibility it provides over your end to end workflow, you get complete control of and visibility into your deployments across multiple teams say goodbye to release a panic and hello to consistent predictable deliveries. Commercial support and enterprise add ons, including disaster recovery are available. To learn more about go CD visit, talkpython.fm/ go CD for free download, let's talkpython.fm/ geo CD, check them out, it helps support the show.

00:48:00 So your docs are in Python two, I want to encourage you to write them in Python three and tell the story. So when people were looking at the adoption of Python three, maybe a year ago or something like this, and I think around that time Django switched its documentation to Python three, they didn't do anything else. They just said look, pipe up three years, this is the way to do it in Python three, and it also supports Python two, and the usage of Python three on pi pi went up significantly, like some number of percent total. Because of that, so the but my real question is, does it support Python? Three, as well as Python two? What's the story around on the various versions?

00:48:41 Yes, it does. Nice.

00:48:43 Yeah. So all the stuff that I've done with it works totally fine. I was playing with it in Python three. So that's great. So I'm really fascinated by people working on successful open source projects that have businesses around them. And so can you talk just really briefly about your project and the editor and the business model around it?

00:49:05 We think that this editor could be helpful for startup companies and for companies who wish to develop new projects, those people who you were talking to, who would like to use pony in their projects, we found that what they like in pony is simplicity. And that pony allows them to save resources. So they can start fast. They don't need a dedicated back end engineer sometimes. And they just can easily return to the project, which was developed like a year ago, and do some changes without actually looking through the manuals, because the query language is really, really simple. And it allows us to maintain projects with less with less resources.

00:49:58 We think that For such people for such companies, having an editor would help them to build prototypes, and work on applications even faster, especially if they will be able to work on the same data schema together. And this is one of the features we would like to add to our editor. So the idea is that it is software as a service. And if you would like to create a diagram and share it with everyone, it is free. And if you would like to keep it is as follows closed source diagram, then there is some price for this. And it depends on how many diagrams you would like to capture. You know, one thing I think is really interesting about this, you talk about people getting started more quickly and helping new companies and or new applications get up to speed, you have an explorer section here. So I can drop in and find things like you've got a corporate directory already modeled, and you've got a ecommerce store model than a university model and things like that. So if I know that there's something in your explore areas, some of these are created by you guys, but many of them are by others. And I'm like, Well, how exactly would I model this? Let me just look and see what other people have done. Right? I could go and like, just start from there, right? And Copy that.

00:51:24 Yeah, exactly. And maybe at some point, we will, we will add an ability to deploy the schema to cloud database and write logic, right there.

00:51:37 Yeah, that's pretty interesting. Is there a way to take and like, reverse the thing? So I've got the diagram, which generates my Python, could I like, take my code that I've been working on for six months after starting with one of these and like through the Python in and get the diagram out?

00:51:55 Probably we should add that. But this point, the most people are asking about a reflection tool for the database. So when you can just get the local the database, CREATE TABLE statements, and create a diagram based on that. Yeah, that makes sense. Which, I guess is probably the most important one is you want to be exactly like your database and give me the Python classes to make that happen. Right, right. So someone would like to work using pony with a database, and they just don't want to create. Those classes are bankrupt.

00:52:29 Yeah. If you've got 1000 tables, you probably don't want to spend time trying to model them again, just push the button and have that pop out. Right. That's cool. All right. Well, we're getting near the end of the show. This has been really interesting. I'm really fascinated, especially with the pythonic style of pony. So thanks for telling us all about it and given us the backstory. It's great.

00:52:48 Thank you, Michael.

00:52:50 Yeah, you bet. So before I let you go, though, I have a couple of questions for you. There's over 90,000 packages on pi pi these days. And you probably come across some that not everybody knows about what when would you like to recommend to audience?

00:53:03 Well, I love flask.

00:53:05 flask is definitely nice and great for building apps, especially for building API's, I think,

00:53:10 but we use the in our projects, and it is simple. And you can develop very fast using flask. So that's why I like I flask. Great

00:53:19 recommendation. And if you're gonna write some Python code, what editor do you open up by Shawn? Nice. Yeah, a lot of the PI charm teams based in St. Petersburg, along with you. So do you know some of the geyser?

00:53:31 Yeah, I do. Actually, we met with them. And we were asking them to add support for pony. And we agree that when enough people will be asking about it, they will start working on.

00:53:45 Alright, well, maybe this show will give them a little nudge. Yeah, that's cool. Any final call to actions for everyone? Like how do they get started pony in your project?

00:53:52 Please go to patreon.com and read the documentation. Try pony and give us feedback. We have a telegram group where people can discuss pony features and ask questions or Stack Overflow. And please give us some feedback so that we can make one even better.

00:54:13 Alright, Alexi, thank you so much for being on the show. It's been fun to talk to you.

00:54:16 Thank you, Michael splitter.

00:54:17 Yep. Bye. This has been another episode of talk Python to me. Today's guest has been Alexi melosh kovitch and this episode has been sponsored by robar and gocd. Thank you both for supporting the show. rhobar takes the pain out of errors. They give you the context inside you need to quickly locate and fix errors that might have gone unnoticed until your users complain of course, fans talk Python to me listeners track a ridiculous number of errors for free@robar.com slash talk Python to me. Go CD is the on premise open source Continuous Delivery server will improve your deployment workflow but keep your code and builds in house. Check out go CD at talkpython.fm/ je OCD and take control over your process. Or you are a colleague trying to learn Python. Have you tried books and videos that just left you bored by covering topics point by point? Well check out my online course Python jumpstart by building 10 apps at talkpython.fm/ course to experience a more engaging way to learn Python. And if you're looking for something a little more advanced, try my write pythonic code course at talkpython.fm/ pythonic. Be sure to subscribe to the show, open your favorite pod catcher and search for Python we should be right at the top. You can also find the iTunes feed at /itunes, Google Play feed at /play indirect RSS feed at /rss on talk python.fm. Our theme music is developers developers developers by Cory Smith Goes by some mix. Corey just recently started filling his tracks on iTunes. So I recommend you check it out at talk Python dot f m slash music. You can browse his tracks he is for sale on iTunes and listen to the full length version of the theme song. This is your host Michael Kennedy. Thanks so much for listening. I really appreciate it. Let's mix. Let's get out of here.

00:56:06 Speaking with my boys

00:56:09 having been sleeping I've been using lots of rest

