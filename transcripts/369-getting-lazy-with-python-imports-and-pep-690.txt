00:00:00 Python is undergoing a performance renaissance.

00:00:02 We already have Python 3.11 20-40% faster than even Python 3.10.

00:00:07 On this episode, we'll dive into a new proposal to make Python even more efficient using lazy

00:00:13 imports laid out in PEP 690.

00:00:15 We have all three folks involved on the episode, Carl Meyer, Hermann Bravo, and Barry Warsaw.

00:00:20 Are you ready to get into making Python faster still?

00:00:23 Let's dive in.

00:00:24 Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:42 This is your host, Michael Kennedy.

00:00:43 Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past

00:00:47 episodes at talkpython.fm and follow the show on Twitter via at Talk Python.

00:00:53 We've started streaming most of our episodes live on YouTube.

00:00:56 Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming

00:01:02 shows and be part of that episode.

00:01:04 This episode is brought to you by Sentry and us over at Talk Python Training.

00:01:08 Please check out what we're both offering during our segments.

00:01:11 It really helps support the show.

00:01:13 Transcripts for this and all of our episodes are brought to you by Assembly AI.

00:01:17 Do you need a great automatic speech-to-text API?

00:01:20 Get human-level accuracy in just a few lines of code.

00:01:22 Visit talkpython.fm/assembly AI.

00:01:25 Hello, Barry, Erman, Carl.

00:01:27 Welcome to the show.

00:01:28 Hey, hello.

00:01:29 It's wonderful to have you all here.

00:01:30 I'm very excited about the work that you're all doing around Python performance.

00:01:37 We're going to focus on imports and this PEP that you three proposed today, but it's really

00:01:43 just the tip of the iceberg in terms of a bunch of cool stuff that's going on.

00:01:47 So I'm very excited to dive into that with the three of you.

00:01:49 Now, before we get to it, though, let's just do a quick round of introductions.

00:01:53 Barry, you've been on the show before talking about 1994 Python stuff and other things.

00:02:00 So maybe just a quick introduction for yourself.

00:02:02 Yeah.

00:02:03 Barry Warsaw.

00:02:04 So I'm still here hanging around, I guess.

00:02:07 You know, I should mention, you know, as we get into this PEP, though, I'm really just

00:02:12 the sponsor.

00:02:13 You know, I got to hand a lot of thanks to Jeff Hermann and Carl for doing all the work

00:02:18 on it.

00:02:19 You know, most PEPs these days, you know, require a core developer to sponsor.

00:02:24 I'm just super interested in the topic.

00:02:26 I think it's a super clever approach.

00:02:28 And so I think it'll help specific needs that I have at work.

00:02:33 And so I was really eager to sponsor it.

00:02:37 Yeah.

00:02:38 Fantastic.

00:02:39 Yeah.

00:02:39 All right.

00:02:40 Very cool.

00:02:41 Hermann, how about you?

00:02:42 I'm just working at Mana with Carl and I wrote the initial approach for Licey eports.

00:02:48 And well, here I am.

00:02:49 Right on.

00:02:50 Carl, quick introduction.

00:02:51 I've been around the Python community for a while.

00:02:55 I think the first maybe semi-notable thing that I did was write the first version of PIP

00:03:01 uninstalled back in 2009.

00:03:02 And that led to being a maintainer of pip and virtualen for a while.

00:03:07 And I worked on the Django core team for a while.

00:03:10 And so, yeah, I've been doing Python things for a long time.

00:03:13 And I've been working at Meta.

00:03:14 Those are a lot of big projects there.

00:03:16 Yeah.

00:03:17 They're projects that I was using.

00:03:18 And so I was interested in working on them.

00:03:20 And same goes for Python itself.

00:03:22 Yeah, absolutely.

00:03:23 And sorry, I kind of cut you off there.

00:03:24 You said working at Meta since 2016.

00:03:26 Is that what you said?

00:03:26 Yeah.

00:03:27 I've been working at Meta since 2016.

00:03:29 Working mostly on how Meta uses Python, how Instagram uses Python.

00:03:34 Yeah.

00:03:34 There have been some really cool looks inside what's going on, especially at Instagram.

00:03:39 there with some of the typing talks that Lucas gave, as well as sort of suspending the garbage

00:03:45 collector for other various things.

00:03:47 And a lot.

00:03:47 Was that you guys?

00:03:48 I think it was, right?

00:03:49 Yeah.

00:03:49 We had a whole.

00:03:50 A lot of neat stuff.

00:03:51 A whole saga.

00:03:52 We turned off the garbage collector, turned back on the garbage collector.

00:03:55 There's been multiple blog posts along the way explaining why we've done each of those

00:03:59 silly sounding things.

00:04:00 Sure.

00:04:02 I mean, they seem insane.

00:04:03 Well, a lot of the projects that a lot of the stuff that's coming out of here has to

00:04:07 do with the Cinder project.

00:04:08 Right.

00:04:08 Yeah.

00:04:09 And maybe, I don't know who's best to give the introduction for Cinder, but Cinder's a really

00:04:14 cool project about, you know, taking a whole bunch of optimizations and specializations you

00:04:20 all have done and sharing that back with the community a little bit, right?

00:04:23 Yeah.

00:04:24 So we started Cinder in, I think, 2017 or 2018.

00:04:27 There was actually two projects kind of started simultaneously.

00:04:31 We realized around that time that the trajectory for Instagram's kind of server footprint was

00:04:37 not really sustainable just in terms of how much server CPU time we were spending running

00:04:41 Python code.

00:04:42 And so we kicked off two projects.

00:04:44 One was called, it's now called Sky Bison.

00:04:47 It was like a ground up rewritten Python interpreter, you know, using all the modern dynamic language

00:04:53 VM ideas, like a moving garbage collector and all these different things.

00:04:57 We weren't the first people to try that.

00:04:59 And we also weren't the first people to fail.

00:05:02 And that project was wound down last year, just weren't able to get the performance, particularly

00:05:07 trying to emulate compatibility with the C API and all the C extensions, which is the same

00:05:12 reason many prior rewrite efforts didn't go very far.

00:05:16 So at the same time as we kicked off Sky Bison, we had sort of kicked off what we thought was

00:05:21 a short-term project of just like, what can we squeeze out of CPython?

00:05:24 Where can we get a little more performance out of it?

00:05:27 And that turned into Cinder and then ended up kind of becoming our primary approach to

00:05:31 Python performance.

00:05:32 Isn't it always the story that the C interop stuff is the big sticking point here?

00:05:38 I mean, Barry, you must have seen a whole bunch of examples from a core-to-of perspective on

00:05:43 that, right?

00:05:43 If we could just change the gill, but the C API defense, but if we could just, but, you

00:05:49 know.

00:05:49 Yeah.

00:05:49 Yeah.

00:05:49 Yeah.

00:05:50 Yeah.

00:05:50 Yeah.

00:05:50 I mean, it's both, you know, Python's, you know, advantage, you know, pros and cons,

00:05:54 right?

00:05:54 Like the approachability and the usability of the C API has led directly to the incredible

00:06:02 ecosystem of extension modules.

00:06:04 Right.

00:06:05 But those also are also the hindrance for moving, you know, ahead in a revolutionary way

00:06:10 with the interpreter, I think.

00:06:13 Right.

00:06:13 You kind of got to live within the box with the walls that are put up by those constraints.

00:06:17 But I do think it's super important.

00:06:19 You know, a lot of people would maybe just think, well, let's just get rid of it.

00:06:21 Like, let's just try to move beyond it.

00:06:23 But when you hear people say that Python is slow or it has these other problems, so often

00:06:28 what you'll see is, well, and what I did was I did a for loop in Python and did some math

00:06:33 and that was slow.

00:06:34 It's like, well, but if a thing is slow, so often that gets rewritten in C and then all

00:06:38 of a sudden it's faster than, I don't know, what Java or whatever else it is they're trying,

00:06:42 you know, node, but they're trying to compare it to.

00:06:44 And so there's this kind of crazy switch that gets flipped for like really high performance

00:06:49 and then, you know, maybe acceptable most of the time performance.

00:06:53 And it's this interop with C that is the thing that's the escape hatch.

00:06:58 At LinkedIn, we don't, you know, we don't have the same kind of workloads that they have at

00:07:02 Meta, but, you know, we've done analysis.

00:07:06 One of the reasons why I was particularly interested in this project is because we write a lot of

00:07:10 our CLIs in Python.

00:07:12 And so, you know, we've had proponents of other languages say, you know, complain, hey, Python's

00:07:17 really slow.

00:07:18 So I write a CLI in Python and then it takes a long time to start up.

00:07:22 But if you actually do the analysis, what you find is that people are not writing a lot of

00:07:28 the internal libraries that those CLIs import do things like they go hit the network and they

00:07:32 go try to do the service and create really expensive resources at module scope time.

00:07:37 Right.

00:07:38 So like those are the types of analysis that you really need to do to say, is it really Python

00:07:42 or is it the way we use Python?

00:07:44 You know, for us, it's a little of both for sure, but often it's sort of the way Python is being used

00:07:49 in a non-idiomatic or not in the highest performance way.

00:07:53 Right.

00:07:53 It's a little bit of rewrite of some internal code can get you a long way.

00:07:57 It sure can.

00:07:57 Also, I want to just give a quick shout out back on episode 347.

00:08:01 I talked with Dino VLAN like all about the Cinder project.

00:08:04 So if you want to check that out, they can definitely go find that.

00:08:06 But there's a lot of cool things that were taken out of Cinder and are being proposed.

00:08:12 And I guess that sort of brings us to our main topic for today is imports and this PEP 690

00:08:19 that you all have proposed, which I am also excited for.

00:08:22 I think imports are one of those things that are a little bit mysterious to people because

00:08:28 they have conceptions coming from other languages, especially compiled languages that are very

00:08:32 different than what the reality is.

00:08:35 So I do want to talk a whole bunch about what you're offering here, what you're proposing

00:08:39 here in this lazy imports PEP.

00:08:42 But before we do, let's maybe just set the stage with what happens when I write import requests

00:08:49 or I write import FastAPI or even something built in like import collections.

00:08:55 Who wants to take this one?

00:08:57 Tell people what really happens when the import statement runs or is there.

00:09:00 There was a time where the import system for Python was written in C.

00:09:05 And it was even more mysterious, I think, at that point.

00:09:07 And I don't remember when it was, but Brett Cannon rewrote the import system into Python.

00:09:13 And then about that time, I sort of went through sort of line by line and tried to understand.

00:09:20 I mean, because right, like imports are probably one of the oldest features of Python, right?

00:09:25 They've been around so long and there's so many corner cases, right?

00:09:29 It's a very complex system and has lots of features, lots of hooks, lots of places where

00:09:34 you can hook in your own behavior and really understanding how all of that fits together.

00:09:39 I think I probably took a couple of months to sort of walk through the entire system line

00:09:45 by line and document.

00:09:46 Unfortunately, now, if you go to the language reference guide, I think it goes into all the

00:09:51 gory detail about how imports work.

00:09:54 Everything from namespace packages to, you know, concrete packages and all the file system

00:09:59 hooks and meta path hooks and, you know, blah, blah, blah, blah, blah, right?

00:10:04 Yeah, definitely a lot going on.

00:10:06 I think the key thing, though, that you are hinting at there is this is a runtime type of behavior,

00:10:12 right?

00:10:13 This is a runtime experience.

00:10:14 Carl, you're shaking your head.

00:10:16 What do you want to add to this?

00:10:17 What Barry was saying here?

00:10:19 Well, yeah, I mean, I think what a lot of people don't consciously realize initially

00:10:23 about imports is that it's just executing some more code, right?

00:10:26 So it's like, you can almost think of imports in Python as like syntax sugar for a function

00:10:31 call where the body of the function is the module level code of some module and the return

00:10:36 value is the module object that you end up getting back from the import.

00:10:40 But what it really is, is just causing some more code to be executed where the result is

00:10:45 a module object that has stuff on it that you can use.

00:10:48 So, and one of the consequences of that is that literally anything can happen when you

00:10:54 import a module.

00:10:55 I mean, like Barry was saying, you know, it could go off and talk to the internet.

00:10:59 I think people have even written stuff that like automatically goes and finds modules on

00:11:03 the internet and downloads them just in time to import them.

00:11:06 But like, but yeah, that's the key point is that you don't have install.

00:11:09 Let's fix that for you.

00:11:13 Yeah.

00:11:13 It could be arbitrarily slow.

00:11:15 It could fail.

00:11:15 It could do anything.

00:11:16 Yeah.

00:11:17 Yeah.

00:11:17 You know, if people have a conception of an import statement being like a using statement

00:11:22 in C# or an include statement in C++, that's not, that's kind of effectively the same intent,

00:11:30 but the behavior is massively different, right?

00:11:33 In C++, it says, here's some symbols that should also be used for compilation.

00:11:37 In Python, it's literally saying, let's just execute this file top to bottom.

00:11:42 And usually execution means define a function, define a function, define a local variable,

00:11:46 define a class.

00:11:46 But it could mean run some random thing, search the file system, all sorts of stuff.

00:11:52 And it leads to things like this, the if dunder name equal dunder main, right?

00:11:59 Yeah.

00:11:59 This is a big confusion that people run into.

00:12:03 Why is this weird thing in Python?

00:12:05 Why do they recommend it, right?

00:12:07 And it's just because like when you do an import statement, it just runs top to bottom.

00:12:11 And if you put behavior in there, well, that behavior happens, right?

00:12:14 So here's your way to sort of skip that.

00:12:16 Just as a sidebar, you all have been involved for a long time.

00:12:19 Like, should Python have had a deaf main sort of entry point thing like so many languages have?

00:12:26 I'm not saying it should or shouldn't.

00:12:28 I just want to hear your thoughts on this.

00:12:30 I think this is just one of those, you know, quirky things about the, not even really even about the language.

00:12:35 It's just a quirky thing about the Python, you know, the way you use Python.

00:12:39 And to me, it's like one of those things, you learn it and then you just use it.

00:12:44 But actually, I think I tend to use this much, much less now, now that we have things like packages and entry points and things like that.

00:12:52 To me, you know, I almost am defining a main function.

00:12:55 And then in my package metadata, I say, well, there's my entry point.

00:12:59 And the packaging system just does it magically.

00:13:02 So this is kind of a convenience.

00:13:04 And I don't think you really actually run into it as often nowadays as you probably did,

00:13:10 you know, years ago.

00:13:11 Sure.

00:13:11 All my apps that are supposed to be run directly like that, they all have a def main somewhere.

00:13:16 And then this just calls the main with this symbol here.

00:13:19 Right.

00:13:20 Right.

00:13:20 Yeah.

00:13:20 Herman, what do you think?

00:13:21 Yeah.

00:13:21 I totally agree.

00:13:22 And it's probably not something that we should be using as much right now.

00:13:27 Yeah.

00:13:27 Sure.

00:13:27 Of course, the really interesting thing here, right?

00:13:29 Is that it's Dunderne.

00:13:31 Right.

00:13:32 Like that's a deeper concept about Python that you should really understand is that modules

00:13:38 are objects and they have this attribute called Dunder name.

00:13:42 And that Dunder name, that attribute is set to some string.

00:13:46 And when you call a, when you not import a file, but call a file using the Python executable,

00:13:54 that file gets done, you know, this string Dunder main assigned to that attribute.

00:13:59 Right.

00:14:00 So.

00:14:00 Yeah.

00:14:00 Yeah.

00:14:01 Kind of like understanding a little deeper about how Python works is really important,

00:14:06 I think, to get, to be able to use it effectively.

00:14:08 It is.

00:14:08 And you hinted on being more idiomatic to get better performance.

00:14:12 And I totally agree with you.

00:14:13 All right.

00:14:14 So now knowing kind of what it means to do an import, let's talk about your pep.

00:14:19 Who wants to introduce the PEP here?

00:14:20 Herman, you're number one author here.

00:14:23 So how about you go for it?

00:14:24 Yeah, sure.

00:14:25 Well, we all started long before the pep.

00:14:28 In 2020 is when I joined Meta.

00:14:32 It was just one month before the pandemic hit.

00:14:35 And so I started working in Instagram code base at the time.

00:14:40 But there have been a lot of problems cause a problem is there with the reload speeds in the development server and Instagram.

00:14:46 And also another, a ton of other common like too, as well.

00:14:51 So what I did is I worked in Instagram code base for a couple of years, trying to fight and touch the startup performance problems that we were in the country all the time.

00:15:01 And when you get into code bases, the size of Instagram is, they had a whole bunch of problems that become apparent.

00:15:09 One of those is...

00:15:11 Yeah, most people don't work at the scale in terms of lines of code or number of servers or anything like that.

00:15:16 You're definitely pushing the outer envelope there.

00:15:18 Yeah, there are thousands and thousands of modules working here.

00:15:22 So one of the problems that start to become a parent is startup speed.

00:15:28 The other problem is that refactoring modules becomes really, really hard.

00:15:33 So if you try to modify something to get it working better, it suddenly starts getting, you suddenly start getting an import cycles.

00:15:42 And all that means when you just live around imports or try to split modules.

00:15:46 So it gets really tricky and hard.

00:15:49 It's complicated.

00:15:50 So the start speed, when you run a module that imports other modules, and these modules start to run, then those in turn import more than modules.

00:16:00 And this goes on and on.

00:16:02 So all transitive dependencies are involved.

00:16:04 Right, right.

00:16:05 If you just import one thing, it seems minor.

00:16:08 But then that could import two things.

00:16:10 And those two things could import four things.

00:16:12 And then it just, if you're talking thousands of modules, it can explode.

00:16:16 And PEP8 says, import goes at the top.

00:16:19 First thing, right?

00:16:20 It's like, just to get started before you can even figure out what your code is going to do.

00:16:24 You wouldn't do all the imports, which is the transitive closure of every import, basically, right?

00:16:28 Exactly.

00:16:29 So it just ends up loading every single module.

00:16:32 Nobody is going to be used immediately or it's never going to be used at all.

00:16:37 So this was an ever ending battle with the Instagram server.

00:16:42 And as soon as I realized that I was doing repetitive work, that was very complex and produced a little, very fragile changes.

00:16:51 And that was really hard to maintain.

00:16:53 And at the end, it didn't really yield the improvements that we needed.

00:16:57 So I thought, unless I set sail to write less imports, that's when we started implementing that.

00:17:04 Well, the PEP is when we tried to show to the world what we did and the results that we were having.

00:17:12 When we get to the U.S. Python 2020 in Salt Lake City.

00:17:16 I was planning to discuss this at the Language Summit.

00:17:19 But at the end, Carl ended up giving a really good overview there, explaining what it was.

00:17:25 I don't know.

00:17:26 Carl, can you add?

00:17:27 Yeah, we were, I think, Herman proposed a talk for the Language Summit at this last PyCon 2022 in Salt Lake City for the Language Summit.

00:17:35 And there just wasn't space in the schedule.

00:17:37 So the Language Summit organizers had to pick some things to leave out.

00:17:40 And so they didn't squeeze in lazy imports.

00:17:44 But then at the Language Summit, a couple of different people brought up lazy imports that they had heard that we had done this and wanted to know more about it.

00:17:51 And there was a lightning talks slot at the end of the Language Summit.

00:17:54 So in the middle of the afternoon, sitting there at the Language Summit, I just put together about 10 slides on what lazy imports is and how it works.

00:18:01 And I gave a quick lightning talk.

00:18:03 And on the way back to my seat from giving the lightning talk, Guido leaned over and said, just write the PEP already.

00:18:10 So a little bit of positive encouragement and a nudge.

00:18:15 Yeah, that's encouragement.

00:18:16 So then Herman was at the sprints.

00:18:18 And so the two of us sat down together at the sprints on the first day and said, all right, let's write a PEP.

00:18:21 So we put together PEP 690.

00:18:23 And he said, hey, oh, Barry's walking by.

00:18:25 Grab him.

00:18:27 Well, yeah, this is something that's been on my radar at LinkedIn for quite a while, like I said, because we have tons of CLIs right from Python.

00:18:35 And I think the thing that, like, this is not the first attempt at lazy imports.

00:18:39 Like, you know, there's been lots of different approaches.

00:18:42 But I think what really kind of struck, certainly what struck me, and I suspect what struck Guido was the really clever implementation of this particular approach to it.

00:18:52 I don't know who came up with that, but whoever did it was like really a stroke of genius.

00:18:56 Because it really gives you the transparency that I think you need to make this a success.

00:19:05 This is a portion of Talk Python To Me is brought to you by Sentry.

00:19:07 How would you like to remove a little stress from your life?

00:19:10 Do you worry that users may be encountering errors, slowdowns, or crashes with your app right now?

00:19:16 Would you even know it until they sent you that support email?

00:19:19 How much better would it be to have the error or performance details immediately sent to you, including the call stack and values of local variables and the active user recorded in the report?

00:19:30 With Sentry, this is not only possible, it's simple.

00:19:33 In fact, we use Sentry on all the Talk Python web properties.

00:19:37 We've actually fixed a bug triggered by a user and had the upgrade ready to roll out as we got the support email.

00:19:43 That was a great email to write back.

00:19:45 Hey, we already saw your error and have already rolled out the fix.

00:19:49 Imagine their surprise.

00:19:50 Surprise and delight your users.

00:19:53 Create your Sentry account at talkpython.fm/Sentry.

00:19:56 And if you sign up with the code Talk Python, all one word, it's good for two free months of Sentry's business plan, which will give you up to 20 times as many monthly events as well as other features.

00:20:08 Create better software, delight your users, and support the podcast.

00:20:12 Visit talkpython.fm/Sentry and use the coupon code Talk Python.

00:20:20 Maybe Carl or Hermann can talk about that a little bit.

00:20:23 Yeah, well, let's first define just like what is the PEP proposing?

00:20:26 So we've described traditionally what it means when you say import thing.

00:20:31 It executes all the Python.

00:20:33 And if there's some inline behaviors, that runs those behaviors.

00:20:36 And that all happens at the top.

00:20:37 Like, how is this different?

00:20:38 What change is this proposing to the CPython runtime?

00:20:42 Yeah, I mean, the basic idea is just that when you hit an import statement, they say import foo.

00:20:47 Instead of immediately at that point going off and finding the foo module, the source code and executing the entire module top to bottom and doing all that work.

00:20:56 And then, of course, all the transitive imports from that and et cetera, et cetera.

00:20:59 That all we do when we hit import foo is we basically remember, all right, we have this name foo.

00:21:06 It refers to a module somewhere.

00:21:08 We're going to put off the work of figuring out what that module is and actually executing it.

00:21:13 And we're just going to remember that whenever foo is used, that means we need to go find out what it is and actually execute it.

00:21:19 So then that name foo will just kind of sit there in the global namespace of whichever module imported it.

00:21:25 And oftentimes foo won't even be used or referenced anywhere in the module body of the module that imported it.

00:21:31 So we can go through the whole way importing that module and foo just continues to sit there as kind of this deferred pending import.

00:21:38 And then later at runtime, maybe somebody calls a function from our module.

00:21:42 And within that function, we have like we have a call to foo.bar or something like that, a reference to some attribute of the module.

00:21:49 And at that moment, the first time we actually at runtime run into a reference to the name foo, that's the moment when we'll suddenly say, OK, hold everything.

00:21:59 We need to go off, figure out what foo is, import it.

00:22:01 And now we actually have the proper foo module.

00:22:04 And now we can go ahead and figure out what foo.bar is and move on.

00:22:07 So that's kind of the essence of PEP690 is to try to do that.

00:22:10 Defer imports until the moment when they're first referenced, but try to do it transparently.

00:22:15 So that is as much as possible, apart from side effects of the import itself, you really can't tell the difference in your code that the import was delayed.

00:22:25 Right. The runtime behavior might be a little bit different, ideally faster and using less memory, which would be great.

00:22:31 But other than that, your code shouldn't, but maybe italics shouldn't know the difference.

00:22:38 Right. If you're doing coding styles and good patterns, basically not creating side effects during imports, you shouldn't be able to tell the difference.

00:22:47 Right. And so if you've got, say, a function that uses JSON parsing, but that only periodically gets called and under some pass.

00:22:55 Right. Like you could avoid import JSON effectively unless you need that bit of functionality.

00:23:00 And for larger projects that can really cascade. Right.

00:23:03 Right. That's the whole idea. So if you think of like a command line program that maybe has like 10 subcommands. Right.

00:23:10 And each of those subcommands might do something fairly different and they might have very different dependencies.

00:23:16 So on any given time that you run that command line program, if you're only using one subcommand, you don't actually need any of the dependencies of the other nine subcommands.

00:23:24 So with lazy imports, you can avoid, you can basically pay for what you use every time you run a program and only pay for what you use.

00:23:31 Yeah. I really like the idea. And the transparent aspect of it is, and what Barry was fond of, is that we write code the way we traditionally wrote.

00:23:40 We write import requests or import JSON or whatever at the top. And it's up to a special dictionary that replaces a standard dictionary that holds the globals.

00:23:51 It says when you access one of these things, if it's not yet materialized and really imported, go do that and then hand it off.

00:23:57 Otherwise, just hand off the module. Right. Something like that.

00:24:01 Yeah. I think you put it really well.

00:24:02 Thanks.

00:24:03 It's actually a standard dictionary for the module, but it's just a specialized lookup function, essentially.

00:24:09 Got it.

00:24:09 Right. So when that deferred object gets installed into the module's dictionary, and this is, I think it's really key because at the point at which that the dictionary lookup function finds this deferred object, that's when the object is resolved.

00:24:24 And what that means is that at the Python level, and even if you're an extension writer accessing the module's dictionary, you never see those deferred objects.

00:24:35 So they're completely hidden both from the C extension author and Python developer.

00:24:41 It's just completely bad. And that's where the transparency really shines.

00:24:45 That's where, yeah, because if you're going to force a new programming model onto people, all of a sudden they're going to not like it.

00:24:51 And we saw how easy that was to go from two to three. Right. So let's not try that again.

00:24:58 Oh, it was so easy. I got this before we get further into this. It's worth pointing out that this is in draft status, right?

00:25:04 It was created out a month and a week ago. So it's not super old. It's in draft. If it appears, it'll be in 312, probably. What's the status of the PEP? It's basically proposed and under discussion?

00:25:17 Yeah. It's currently discussed. Yeah.

00:25:19 I think I went and looked recently and saw that in the, in discuss.python.org in the PEPs category. I think the PEP 690 thread has more posts than any other thread there.

00:25:30 So it's been.

00:25:31 Okay. That's exciting.

00:25:32 It's been thoroughly discussed. But at this point, I think to some extent, the discussion is on hold while we work on getting an implementation against the Python main branch.

00:25:42 Cause our implementation in Cinder, Cinder is unfortunately still based on Python 3.8. We're currently working on upgrading it to 3.10, but there's some changes in the underlying dictionary and other things between 3.8 and now 3.12 alpha.

00:25:56 So the implementation needs some, some reworking and we need to get that available for people to look at and play with to really move to the next stage in discussion.

00:26:05 Yeah. Just a side note. So with projects like Cinder and stuff, it's based on 3.8, which is great. There's a lot of good features.

00:26:11 I mean, basically three, six and beyond you get f-strings, you get async and away, you get a lot of amazing stuff there, but the shift from 10 to 11, there's a big performance boost.

00:26:21 It's sort of coming along there. Are you guys looking to sort of bring all of this stuff into 11 as sort of a stable point or what's the story there?

00:26:30 For Cinder in general?

00:26:31 Yeah.

00:26:32 Yeah.

00:26:32 Yeah. So I mean, we're currently upgrading to 3.10 just to go two versions at a time instead of kind of leap three versions in one bound.

00:26:42 And also because as you said, there's a lot of changes between 3.10 and 3.11. So we want to kind of isolate those and get 3.10 stable first and get it in production for Instagram and everything.

00:26:52 So that's our current target. And then once that's done, we'll probably look at 3.12 next.

00:26:57 Sure.

00:26:57 We do want to bring Cinder up to date. And also we're really looking at trying to upstream a lot of the things that are in Cinder so that more people can benefit from them.

00:27:07 And to reduce the amount of work we have to do to be constantly rebasing all of our stuff on newer versions of Python.

00:27:12 So our goal, hopefully, is that lazy imports.

00:27:14 Sure. Everything that you get accepted is just one fewer thing you have to maintain. You can kick it to Barry. Let Barry do it.

00:27:20 That's right.

00:27:21 Well, I mean, we hope to continue to help maintain these things upstream too.

00:27:26 Yes, of course. Yeah, of course. But if you can make it part of the broader community thing, it's no longer your team. It's the community's benefit.

00:27:33 Okay. Let's talk a little bit about some of the different forms of imports and how they affect this.

00:27:39 Because out in the audience, Hybrid Robotics asks, when you do from library import function, does this really save memory?

00:27:46 I think that maybe sets the stage for talking about when there's different styles of imports we can do.

00:27:52 Obviously, we can just do import library. We can do from library import function or import star, all these different things.

00:27:59 And there's rules in the PEP about how that controls the laziness or the alternative.

00:28:04 I guess the current default way is called eager loading or eager imports, right?

00:28:08 I think it's really good that Hybrid Robotics brought up this question of from library import function, because that's actually a key way that PEP 690 is different from the existing ways of doing lazy imports.

00:28:18 So there are existing things out there. There's a lazy import loader in the standard library.

00:28:23 And there's something called demand import on the package index that came out of Mercurial.

00:28:27 And all of these things take the approach of having a custom module object.

00:28:31 Right.

00:28:32 That when you do a get attribute on it, it has a dunder get adder or dunder get attribute implementation that waits for an attribute access and then goes out and does the import.

00:28:41 And that works for import foo, but it doesn't make from foo import bar lazy because from foo import bar gets the foo module and then you immediately access the bar attribute on it.

00:28:53 And so if you're using this lazy module object style, then effectively it's just eager because you get the attribute off it right away and that makes the import happen.

00:29:01 And the difference with PEP 690 is that with from foo import bar, we just stick a lazy object into the namespace of the importing module under the name bar instead of under the name foo.

00:29:13 But it's still a lazy object and the import still won't happen until something later actually uses the name bar.

00:29:20 So even in the case of from foo import bar, we're still able to make it lazy and it still will save memory at least until or unless you actually use the imported thing.

00:29:30 Yeah, that's a great summary.

00:29:31 I would like to point out maybe just not entirely sure where they're coming from here.

00:29:36 So today, if you write from library import function versus just import library or from library import star, you're not really saving any memory.

00:29:44 It basically is doing the same thing, right?

00:29:45 The module object is created.

00:29:46 It's imported.

00:29:47 All the stuff is done.

00:29:48 It's just what symbols are defined for you, right?

00:29:52 It's more of a syntax thing than it is a memory thing right now.

00:29:55 Yeah, that's correct.

00:29:56 Yeah.

00:29:57 But in the thing you're proposing, this will still be the lazy version, which is great.

00:30:01 Yes.

00:30:02 Yeah.

00:30:02 So there's different ways in which we do import.

00:30:06 Sometimes people even do imports inside of try blocks.

00:30:10 So like try to import this thing.

00:30:11 And if it's not there, maybe try to shim it in or report that this module is a dependency or other things.

00:30:18 And it's literally the import statement that is supposed to succeed or fail that communicates back whether or not that was okay.

00:30:25 Right.

00:30:25 And with this lazy version, you're going to change.

00:30:28 It's not going to fail within that try block because within the try block, it's going to create a deferred lazy thing.

00:30:35 And that'll always work, right?

00:30:36 It actually could also fail in certain circumstances.

00:30:39 But for the most part, it should just work.

00:30:42 If you have an import inside a try block or inside a class or inside a function, all those imports are eager imports.

00:30:49 Right.

00:30:49 Exactly.

00:30:50 So what I was getting at is that you were actually specifying that if there's an import within a try except or within a width block, you're actually not letting that be lazy.

00:31:00 You're making them be eager, right?

00:31:01 That's right.

00:31:02 Yeah, exactly.

00:31:02 Although imports inside this important thing are also lazy.

00:31:07 So if any of those fail and you are expecting those to fail, it could not throw an exception there in that reason, in that case.

00:31:16 Okay.

00:31:16 And then also from thing import star has to be eager.

00:31:21 Why does that one have to be eager?

00:31:22 Yeah, because we don't have the clean names that are being imported.

00:31:26 So there's no way to add these lazy objects to these names.

00:31:32 So we need to just import everything and see what are the names that are being imported.

00:31:37 That's the main reason for it.

00:31:38 Yeah.

00:31:39 Right.

00:31:39 Because when you say star, you don't know what to put into the module's symbol table, right?

00:31:44 So you've got to actually do the import to figure out the star.

00:31:49 That's pretty interesting.

00:31:50 All right.

00:31:50 So there's some interesting examples you have in the PEP that people can check out about.

00:31:54 Here's sort of a fake slow module that just does time.sleep, but it effectively shows that it could be slow.

00:32:03 And you can run it like do an import and it'll run instantly basically because it's not actually, if you're not accessing that module really at that point, it's pretty much instant.

00:32:12 I guess one thing to point out here, and this is, I don't know how I feel about this, but maybe we could talk about it a bit.

00:32:19 The proposal is that this is not the default behavior for Python indefinitely into the future, that you have to pass a dash L flag to the interpreter or set an environment variable or something along those lines.

00:32:33 You want to talk about why make it opt in instead of maybe opt out?

00:32:37 I wish it was a default.

00:32:38 That's what I wish to.

00:32:40 But the thing, the reality is that there are a lot of applications and modules that are using or relying on import side effects.

00:32:49 So we can just expect those to be lazy or compatible anytime soon.

00:32:55 So you're saying there's a lot of bad code out there.

00:32:56 Is that what you're saying?

00:32:57 No.

00:32:58 No, I'm just teasing.

00:32:59 But if it has side effects, right, if it's like, oh, because you imported this, we've initialized the database connection.

00:33:05 There's actually some really good discussion on the discourse thread.

00:33:09 I feel like this is actually an important aspect of the PEP because one of the things that was sort of pointed out in this discussion is that I both author libraries and I author applications, right?

00:33:23 As a library author, I can't really reason about whether I can sort of say, yeah, maybe my library is unsafe for lazy, but I can never really say, you know, assert that my module is safe for laziness and be certain that in all the way that all my downstream consumers are going to use my library, right?

00:33:45 That it's always going to be safe for lazy imports.

00:34:15 So by using it, I'm a little uncertain about the environment variable, but I feel pretty strongly like the flag, the dash, capital flag.

00:34:24 Yeah.

00:34:24 It's the responsibility of the person running it, sort of.

00:34:27 It's the leap.

00:34:28 Yeah.

00:34:28 It's the top of the tree.

00:34:32 Yeah.

00:34:33 Yeah.

00:34:33 To give an example of what Barry's talking about is like, I mean, for better or worse, some level of import side effects are just kind of built into Python.

00:34:41 Like if you have a module that subclasses a class from another module, you may think that you have a module with no import side effects, but actually importing your module adds something to the Dunder subclasses of the module you inherited from.

00:34:55 And so even code that apparently looks very clean and clear of import side effects does technically have some side effects on import.

00:35:05 And the real question is, is anybody actually looking at Dunder subclasses on the parent module?

00:35:09 And, you know, there's a lot of common library patterns like decorators that when you decorate a function, they register that function to that class and some registry and some other module.

00:35:20 So then suddenly again, you have an import side effect.

00:35:22 Like Flask or something.

00:35:22 Yeah.

00:35:23 Right.

00:35:23 Yep.

00:35:23 Exactly.

00:35:24 So you really have to, it really has to be the person writing the application and testing the application.

00:35:29 You says, I'm going to try lazy imports.

00:35:32 I'm going to see if things work.

00:35:33 I know how my dependencies are used.

00:35:35 If it works well and all my tests pass, then I can consider just turning this on at that level.

00:35:40 Sure.

00:35:41 Okay.

00:35:41 Interesting.

00:35:42 Taking Barry's idea that it's the application owner who should sort of make this decision.

00:35:48 What about having some code artifact that allows you to signal that as well?

00:35:53 Right.

00:35:53 So as I run it, I can control whether or not this happens.

00:35:57 But what if I just the very first line of my app.py or whatever it is, I just say import lazy or something like that.

00:36:05 And then every subsequent thing from there on behaves that way.

00:36:08 That way, if I distribute my app to someone else, I don't have to convince them or teach them about dash L.

00:36:15 I can just say, no, just double click this thing or run this.

00:36:18 And it'll just, it'll go in a consistent way.

00:36:21 As long as you don't have like PTH files that are getting in the way, you know, before your main gets called.

00:36:27 Go ahead, Carl.

00:36:29 Sorry.

00:36:29 Yeah, no, I was just going to say there was a lot of discussion about that in the thread.

00:36:33 And there actually is a draft of a heavily revised version of the PEP.

00:36:38 For Barry's review, actually.

00:36:39 So Barry, you can.

00:36:40 Barry, let me throw that up for you.

00:36:42 We can go through it.

00:36:43 Yeah.

00:36:45 One of the changes that is made in that draft is both removing the environment variable because people were concerned about the risk that if somebody just got the idea that, oh, lazy imports makes everything faster, they might try to just set the environment variable in their shell.

00:37:00 And then all of the Python programs they run will try to run with lazy imports and might break.

00:37:05 And then they're reporting bugs.

00:37:06 And that's not a great experience.

00:37:08 So we want it to be really limited to an application that's tested with lazy imports.

00:37:11 So the latest draft of the PEP removes the environment variable and actually adds exactly what you're talking about, a programmatic way to enable lazy imports for your application in code.

00:37:21 What is the code way?

00:37:23 Well, I mean, it's just a proposal in my draft PR to the PEP text right now.

00:37:27 So we'll see what Barry says about it.

00:37:29 Sure.

00:37:29 It could well change.

00:37:31 I just rubber stamped it.

00:37:33 So the reason I ask is there's sometimes certain things you've got to do to, like, tweak the path or something to get imports to work right if you're running from some weird location or something.

00:37:44 Think of, like, alembic migrations and stuff like that.

00:37:48 But in a lot of the editors and the linter's, they'll whine at you and say, no, no, no, these imports that go below that modification to the path statement, they go above it.

00:37:58 Like, no, the whole point of the thing above it is so the things below it don't fail.

00:38:01 Right.

00:38:02 Is there, like, whatever it is, I just want to put in a little hint.

00:38:06 Like, if you could make the editors not complain that the stuff below it should go above it because the stuff below it is controlled by the stuff above it.

00:38:14 You know what I mean?

00:38:14 Yeah, the current proposal, I don't think, I mean, I suppose if it becomes merged, the linters and such could special case it.

00:38:21 I think hopefully that's not too huge of an issue because the idea is, I mean, you potentially have a large application and this would occur, like, in one main module, right?

00:38:29 You would just put like that.

00:38:30 Call this function.

00:38:31 Right.

00:38:31 You put the hash, ignore, and then you're good to go.

00:38:33 Right.

00:38:34 Got it.

00:38:34 Okay, cool.

00:38:35 Let's go talk about some benefits here.

00:38:37 So, in terms of performance, so it says it's already been demonstrated for startup time improvements of 70% and memory reduction of real-world CLIs by 40%.

00:38:50 Those are not joking around.

00:38:51 This is not, like, playing at the edges of performance changes.

00:38:54 This is significant.

00:38:55 So, are those numbers from what you're doing with Instagram or other tools that you tested it on or something like that?

00:39:02 These are numbers from Instagram, Instagram server, and also I love command line tools that we use inside Meta.

00:39:09 So, yeah, these are real numbers.

00:39:11 It's about 70%.

00:39:14 Sometimes we've seen 50% improvement in startup speed.

00:39:17 Memory is also up to 40%.

00:39:20 We've seen 20%.

00:39:21 Right.

00:39:22 These are upper bounds, of course.

00:39:23 Sure.

00:39:24 But what I think is good about that is it's not, you know, sometimes people say, well, let's see how fast Python is.

00:39:29 I'm going to do a wild true loop and see how many times I can increment a number and compare that to doing that and see, like, okay, nobody does this and they don't really care about how fast.

00:39:39 Like, how do real apps behave?

00:39:40 How do real?

00:39:41 And so, this is you taking the stuff that you all work with day to day and trying to make it faster and getting significant benefits from it.

00:39:48 Not weird little edge case benchmarks.

00:39:50 Yeah, I think an important thing to note there that Hermann mentioned is that this isn't just one code base.

00:39:54 So, you know, we've seen this as repeatable scale of improvement across a variety of different tools.

00:40:00 In fact, recently, we've started to see we have a lot of data science people and researchers who use a lot of Jupyter notebooks.

00:40:08 And they've started to really quickly pick up Jupyter notebooks kernels based on Cinder with lazy imports enabled because they're seeing similar startup time and memory use numbers for their Jupyter notebooks.

00:40:20 So, like, across a fairly wide range of use cases and types of programs, we are seeing these kinds of numbers as consistently repeatable.

00:40:27 Yeah, that's interesting to the data science side.

00:40:29 A lot of those libraries are pretty large.

00:40:31 And so, I suspect that that's probably pretty valuable.

00:40:34 So, one of the things you all talk about is that this proposal also will eliminate, what would you call it, like, false import cycles?

00:40:42 I don't know.

00:40:43 Do you want to talk about this cycle benefit that we might get here?

00:40:47 Yeah.

00:40:47 Throw it out to all of you.

00:40:48 Whoever wants to grab it.

00:40:49 I didn't.

00:40:49 Can try to say something about the import cycles.

00:40:51 When you have imports at the top of the module, and you're not using these imports, and some of the imports that you are declaring there are importing something on the end to us.

00:41:02 At some point, it's importing the first module.

00:41:06 Then you have a cycle, right?

00:41:07 So, if one of these imports is not actually being used, and it's being deferred to a use case where it's only resolved inside a function,

00:41:18 further down, which is not being immediately called, then we won't have these cycles.

00:41:24 And then a lot of times when we have this kind of imports that are declared on the top of the modules, because

00:41:32 But it hates this that is recommended to have all imports in the top of the module.

00:41:37 And so people just start putting imports there because it's cleaner and looks better, but

00:41:43 it needs to stop provoking these, causing these import cycles.

00:41:48 Nice.

00:41:49 So hopefully this will solve some of those issues.

00:41:52 I know when I first got into Python, I didn't understand why there wasn't a better way out

00:41:57 of like sharing code in a bi-directional way.

00:42:01 It was really, it took a lot of thinking like, okay, how can I structure my code into different

00:42:06 files that don't feel like it's all just went in one file and yet allow me to reference it?

00:42:12 Like, for example, if I've got one class and it works with another and it has a function

00:42:17 that returns one type of it, but the other one might have a field, which is one of those.

00:42:20 And you want to do a type declaration of saying which one is which, or you need to create the

00:42:24 call initializer of one or something.

00:42:26 Those kinds of bi-directional relationships are hard to model.

00:42:30 And it sounds like this doesn't really address or fix or change those in any significant

00:42:34 way.

00:42:35 But the other ones just about the timing can go away, right?

00:42:38 The only import cycles that lazy imports don't fix are the ones where basically it would be

00:42:44 a cycle, even if you had it in the same module, like where you're literally using names in a

00:42:50 bi-directional way at module level.

00:42:53 And so there's no way you could order them even within one module and have it work.

00:42:57 And so essentially forward references, those kinds of cycles, the lazy imports doesn't fix.

00:43:00 But really any other kind of cycle or anywhere in the cycle, one of the uses is inside a function.

00:43:06 All of those are taken care of.

00:43:08 And so even for the type annotation ones, if you use from future import annotations, PEP 563,

00:43:15 or another proposal, PEP 649, anything that makes the type annotations also lazily evaluated,

00:43:21 so they aren't eagerly evaluated at import time, then all of a sudden your cycles went with that

00:43:26 plus lazy imports.

00:43:27 Then all the cycle problems with type annotations also just disappear.

00:43:31 I was just going to say, I think one of the interesting things that I think it was Carl

00:43:34 pointed out when we were talking about this is that if you've got the converse is right,

00:43:38 if you've got an application or something that's using these lazy imports, and then you turn

00:43:43 them off, you might be hit with a bunch of cycles that were sort of, you know, hidden from

00:43:50 you because of the lazy feature, right?

00:43:51 So you have to be a little bit careful about engaging with lazy imports and then turning them

00:43:57 off.

00:43:57 Right.

00:43:58 Getting everything eager.

00:43:59 So it's just one of those things to watch out for.

00:44:01 Oh, interesting.

00:44:01 Yeah.

00:44:02 If you're doing it by running it with the run flag, you could be effectively hiding a runtime

00:44:07 error that someone else would hit if they ran it without.

00:44:10 Yeah.

00:44:10 Right.

00:44:10 Kind of back to my like, could the code define this instead of a runtime flag?

00:44:14 So it's like absolutely consistent.

00:44:16 Yeah.

00:44:16 Let's talk about debuggability a little bit.

00:44:19 So normally when you have an exception, if I import thing and there's a problem importing that

00:44:24 thing, I'll get an exception on the line that the import did.

00:44:27 But with this lazy thing, it'll be the import error will occur where the first attempt to

00:44:33 touch it happens.

00:44:35 Right.

00:44:36 But you all do some work to figure out and sort of report back.

00:44:39 the error came from where the original import statement was, right?

00:44:42 Yes.

00:44:43 The error should be reported where the import is being declared so that it's easier to do

00:44:47 But this can also produce import error and send anywhere.

00:44:51 So the other thing that we are thinking about adding to this implementation is to have an error wrapper around the real error that is being thrown.

00:45:02 So we can easily know that it's just an import error coming from a lazy import.

00:45:08 Yeah.

00:45:08 It could theoretically, I guess, get caught in a situation where people would have not expected it.

00:45:14 Right.

00:45:14 It could have a overly aggressive try accept block.

00:45:18 There's like, well, there's only two types of exceptions that come out of here possibly ever.

00:45:22 And either of them, I'm going to handle it in this case.

00:45:25 Well, now here's a third.

00:45:26 Surprise.

00:45:27 Yeah.

00:45:27 Okay.

00:45:28 But at least from sort of figuring out where the error came from, I guess you guys, what do you call it?

00:45:33 Deferred exceptions is what you actually called that, right?

00:45:36 Right.

00:45:36 So there's a couple of code examples in here.

00:45:39 And I'm going to kind of flip through here and check it out.

00:45:42 You also have some code APIs.

00:45:43 I talked about my wish for some code thing to declare laziness, I guess, is the way to put it.

00:45:48 But different things happen.

00:45:50 Like if you do the import within a try block, that forces them to be eager.

00:45:54 But you also have defined this eager imports context manager, sort of.

00:45:59 That will force the imports to be eager, right?

00:46:02 And I say sort of because it's not actually the eager imports thing.

00:46:05 It's the width block.

00:46:06 Whatever you put in there, if you do an import in it, is what's going to trigger it, right?

00:46:10 Yeah.

00:46:10 It doesn't matter.

00:46:11 Yeah.

00:46:11 And then the third way is you can import set eager imports and actually pass like namespace names in there.

00:46:19 Because one of the problems is I'm going to import a thing that's a package whose code I don't control.

00:46:25 And I need it to, for one particular thing, eagerly import that, right?

00:46:29 So you kind of have to force it down the line where it's out of the chain of control there.

00:46:33 So you can sort of set like, I want to do FastAPI dot whatever, like exceptions or whatever's in there.

00:46:40 I want to make sure that that eager loads, even though I don't control FastAPI, right?

00:46:45 So you want to talk about some of these code tricks that you have here?

00:46:48 Yeah.

00:46:48 Or tools, I guess is a better word.

00:46:50 Yeah.

00:46:50 Let's say the eager imports is just for opting out certain modules.

00:46:54 Application owners should be the ones adding the incompatible libraries here if they find or figure out that they aren't playing well with lazy imports.

00:47:04 Yeah.

00:47:04 So if I write a library and I see that my sub module cannot deal with being lazy, I could put this in my code to avoid, no matter what people set for the runtime flag, I could avoid that problem for my library, right?

00:47:17 Yeah, exactly.

00:47:18 So you can always try first and if you're the application owner and you know exactly what you need to do this application for, to work, you can try it in modules.

00:47:28 And a lot of the libraries just work out of the box.

00:47:31 So you don't need to do anything.

00:47:33 There are some, some libraries that don't work.

00:47:36 And if you can make those work in some other way, you can then add these as eager imports.

00:47:42 What's the, I don't know if it's a lazy imports in those libraries.

00:47:46 Yeah.

00:47:46 Yeah.

00:47:47 These are really interesting to see here.

00:47:49 Like you can even pass a callback that will be handed a module name and it can, it can decide.

00:47:55 You could say, I don't want to just say all the names that are of the sub module, but just anything that matches this pattern.

00:48:01 Let's just tell it.

00:48:03 We want to eagerly import that.

00:48:05 Yeah.

00:48:05 Yeah.

00:48:05 Yeah.

00:48:05 Yeah.

00:48:06 It looks nice.

00:48:06 I like it.

00:48:07 There's a, another question from audience back to a code question and explicit opt-in is a hybrid robotics.

00:48:15 Also asked.

00:48:15 I really liked the idea of import lazy or lazy import library or something like that to be explicit about it.

00:48:21 And you all actually specifically addressed whether or not there should be some syntax code that makes this happen instead of changing the default one.

00:48:29 Right.

00:48:30 What's the thoughts there?

00:48:31 I think generally we're not opposed to the idea of syntax for lazy imports.

00:48:37 The kinds of like memory and startup time wins that we've seen really depend on very broad application of lazy imports with just very narrowly targeted opt-outs.

00:48:49 That's what you need in order to really get to a situation where you're actually paying for what you use in a robust way where you're not in a situation where you just accidentally add one import in one place.

00:48:59 And all of a sudden all your gains just disappear like that.

00:49:02 If it's really across the code base, then it's very robust startup time and memory wins where you add one import.

00:49:08 And while you might pay for a little more, but you're not going to suddenly start paying 100% of the cost again.

00:49:13 It feels like adding new syntax is a much bigger hurdle in terms of the steering council and having to change the Python grammar and all of that.

00:49:22 And when the syntax, the per import syntax isn't really even useful in gaining the wins that are the primary motivation for the PEP, then it doesn't feel like a good trade-off to add that to the PEP.

00:49:36 Sure.

00:49:36 Yeah.

00:49:36 I think I agree with that.

00:49:37 That seems pretty reasonable to me.

00:49:38 What about the reverse?

00:49:40 What about if you, instead of doing something like this, where you say, I'm going to force these to be, I'm going to run some code to make these modules eager.

00:49:48 What if as a library author, I could write eager import my thing or something along those lines.

00:49:55 Now, I really don't want to see more syntax in Python.

00:49:57 There was a huge battle over whether a colon goes by an equal sign.

00:50:01 So I'm not necessarily suggesting that we should do this.

00:50:04 I would say there's nothing necessarily wrong with that.

00:50:07 It's more just that adding new syntax is a higher bar and maybe we should get some experience.

00:50:11 When the same thing is easily possible with existing syntax, like a context manager, we may as well get some experience with the future in a less invasive way before we go adding syntax.

00:50:21 Right.

00:50:21 If you see so many people using it and benefiting from it, then you could consider it.

00:50:26 I mean, one example of that is like 3.4 to 3.5 when there was asyncio introduced and then there was async and await introduced on top of that.

00:50:34 Right.

00:50:34 Even things like property, right?

00:50:36 Like the property decorator was, you know, a feature that was available for the decorator syntax was added.

00:50:43 So it's a tried and true strategy for Python.

00:50:47 Let's get experience with the feature and then we can make adjustments and syntax to make it prettier, you know, down the road.

00:50:53 Yeah, that's a good path.

00:50:56 Awesome.

00:50:56 All right.

00:50:57 Well, really, really good work on this, you guys.

00:51:00 This is exciting.

00:51:02 I would like to see the status change from draft to something further.

00:51:06 I guess I have to go do something after this chat.

00:51:11 Perhaps so.

00:51:12 Perhaps.

00:51:12 Awesome.

00:51:13 But now people know about the conversation much more broadly and maybe we'll get some more, even more comments on the discourse thread there.

00:51:21 Let's maybe wrap that up because I think we're about out of time.

00:51:24 But before I let you all out of here, you've got the two questions to quickly answer since there's three of you.

00:51:29 Barry, if you're going to write some code, what editor are you using these days?

00:51:32 It's always going to be Emacs for me.

00:51:34 I know.

00:51:35 You know, it's funny because Brett works at Microsoft.

00:51:38 And so, you know, LinkedIn and Microsoft, we share.

00:51:40 He has something to do with some editor.

00:51:41 I think people, a few people may have heard of him or something.

00:51:43 Yeah.

00:51:45 And I keep telling Brett, I want to, I want to, you know, if I was starting today, I would probably, yes, Emacs is just kind of deeply in my bones.

00:51:53 Got it.

00:51:54 German, how about you?

00:51:55 I used to use Sublime Text, even though it didn't have AutoComplete.

00:52:01 So I added some AutoComplete from porting, Komodo IDE Editor, AutoComplete to Sublime Text.

00:52:10 But now that it's in meta, I'm using VS Code.

00:52:12 And also being when I'm in the terminal.

00:52:15 Right on.

00:52:16 Carl?

00:52:16 Yeah, I used to be an Emacs user.

00:52:18 I mentioned that's how Barry and I very first connected back at PyCon 2008.

00:52:22 But I have switched to VS Code.

00:52:25 There's a lot of integrations with VS Code in terms of meta infrastructure and maintaining all that stuff myself for Emacs just became more of a hassle than I wanted to pay.

00:52:35 So I've switched to two jobs.

00:52:36 One was enough.

00:52:37 Right.

00:52:38 All right.

00:52:40 And then notable PyPI package, something that you think is pretty cool you just want to give a shout out to, popular or not.

00:52:46 Go in reverse order.

00:52:47 Carl, how about you?

00:52:48 Well, I guess I'll give a shout out to something that I use in all of my projects, which is, I guess, depending on the project, either Pyre or mypy.

00:52:55 I'm a big fan of type checking my Python codes.

00:52:58 Yeah, fantastic.

00:52:58 German?

00:52:59 Yeah, well, Pyre is pretty good.

00:53:01 Oh, I don't know.

00:53:02 And microsort, which sorts your imports at the top of the file.

00:53:07 So it's really useful.

00:53:09 If there's an import syntax that makes all the other ones lazy, all these tools are going to have to learn about, well, this one doesn't go before the other.

00:53:16 Or you could give it something like A, A, A, A, A, A, A, lazy.

00:53:19 I guess.

00:53:23 All right, Barry, how about you?

00:53:27 Notable package?

00:53:28 For me, it's a PDM, which is a package manager and sort of a build backend.

00:53:33 I went through an exercise a couple of months ago where I just was finally wanting to get rid of all my setup.pies and setup.cfgs and just fully embrace pyproject.tomil and see how far it could go.

00:53:45 And I was actually pretty happy with being able to get rid of both of those legacy packaging files.

00:53:52 So I tried a bunch of the different package managers and I really liked PDM.

00:53:56 So I kind of, you know, settled on that one for my personal stuff.

00:53:59 Yeah, fantastic.

00:54:00 All right.

00:54:01 Well, final call to action.

00:54:02 People want to maybe have their thoughts heard on this.

00:54:05 What do they do?

00:54:05 I guess the discourse thread.

00:54:07 Yeah.

00:54:07 Discussed up.

00:54:08 Python.org.

00:54:09 Look for the PEPS category and look for PEPS 690.

00:54:12 Yeah.

00:54:12 Cool.

00:54:12 You can love it or not love it or stuff like that.

00:54:15 There's sort of ways to give just a heart feedback as well.

00:54:19 So cool.

00:54:20 The other thing you can do is pressure the sponsor of the PEPS to stop being so lazy.

00:54:24 And that's something.

00:54:26 I would find it incorrect if you were not lazy on this particular one.

00:54:30 I mean, you got to just swim in that waterfall and see how it feels before you can really make a decision.

00:54:38 Right, right, right, right, right, right, right.

00:54:39 Awesome.

00:54:41 All right.

00:54:41 Well, gentlemen, thank you for being here.

00:54:43 It's been great having you all on the show.

00:54:45 Thanks.

00:54:45 You're welcome.

00:54:45 Thanks so much, Michael.

00:54:46 Thanks for inviting us.

00:54:48 Appreciate it.

00:54:48 Yeah, you bet.

00:54:49 Bye.

00:54:49 Bye.

00:54:49 Bye.

00:54:49 This has been another episode of Talk Python to Me.

00:54:53 Thank you to our sponsors.

00:54:55 Be sure to check out what they're offering.

00:54:57 It really helps support the show.

00:54:58 Take some stress out of your life.

00:55:00 Get notified immediately about errors and performance issues in your web or mobile applications with Sentry.

00:55:06 Just visit talkpython.fm/Sentry and get started for free.

00:55:11 And be sure to use the promo code TALKPYTHON, all one word.

00:55:15 Want to level up your Python?

00:55:17 We have one of the largest catalogs of Python video courses over at Talk Python.

00:55:21 Our content ranges from true beginners to deeply advanced topics like memory and async.

00:55:26 And best of all, there's not a subscription in sight.

00:55:28 Check it out for yourself at training.talkpython.fm.

00:55:31 Be sure to subscribe to the show.

00:55:33 Open your favorite podcast app and search for Python.

00:55:36 We should be right at the top.

00:55:38 You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

00:55:48 We're live streaming most of our recordings these days.

00:55:50 If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

00:55:58 This is your host, Michael Kennedy.

00:56:00 Thanks so much for listening.

00:56:01 I really appreciate it.

00:56:02 Now get out there and write some Python code.

00:56:04 I really appreciate it.

