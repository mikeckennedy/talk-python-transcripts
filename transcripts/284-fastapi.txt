00:00:00 As Python 3 has eclipsed the old constraints of Python 2 and the web frameworks that adopted them,

00:00:04 we've seen a big jump in the new frameworks appearing on the scene, taking full advantage of things like type hints, async it away, and more.

00:00:11 No framework has done this more successfully than FastAPI recently.

00:00:15 That's why we're here with the creator of FastAPI, Sebastian Ramirez, to dive into this exciting new Python web framework.

00:00:21 This is Talk Python to Me, episode 284, recorded July 23rd, 2020.

00:00:27 Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:00:46 This is your host, Michael Kennedy.

00:00:48 Follow me on Twitter, where I'm @mkennedy.

00:00:50 Keep up with the show and listen to past episodes at talkpython.fm, and follow the show on Twitter via at Talk Python.

00:00:57 This episode is brought to you by Linode and us.

00:01:00 Python's async and parallel programming support is highly underrated.

00:01:05 Have you shied away from the amazing new async and await keywords because you've heard it's way too complicated or that it's just not worth the effort?

00:01:13 With the right workloads, a hundred times speed up is totally possible with minor changes to your code.

00:01:19 But you do need to understand the internals.

00:01:21 And that's why our course, Async Techniques and Examples in Python, show you how to write async code successfully as well as how it works.

00:01:29 Get started with async and await today with our course at talkpython.fm/async.

00:01:35 Sebastian, welcome to Talk Python to Me.

00:01:38 Thank you very much.

00:01:39 Thank you for the invitation.

00:01:40 It's a great pleasure to be here.

00:01:42 Well, thanks for building a cool web API.

00:01:45 You're welcome, I guess.

00:01:47 Yeah, it's going to be fun to talk about it, actually.

00:01:49 I think, you know, it's been really interesting.

00:01:51 There were a lot of web frameworks that came out in 2005, 2008 timeframe.

00:01:58 Then I feel like it kind of stabilized for a long time.

00:02:01 And then I'm not sure exactly what it was, but I think that the async and await stuff coming along

00:02:07 sort of pushed the creation of a bunch of new frameworks.

00:02:10 And all of a sudden there was another framework every other week.

00:02:13 It was crazy.

00:02:14 And yours was kind of in that second wave or whatever wave that was.

00:02:17 And yeah, it looks like it's getting a lot of traction.

00:02:20 So that's awesome.

00:02:21 Yeah, thank you very much.

00:02:22 Yeah, I actually feel pretty much the same.

00:02:24 I feel like there were like a couple of waves of frameworks and then a second one.

00:02:29 And I was actually avoiding building a framework for a long time.

00:02:33 Yeah.

00:02:33 Yeah, I can imagine.

00:02:35 I definitely want to ask you about that.

00:02:37 But let's start with your story.

00:02:38 How'd you get into programming in Python?

00:02:40 So I'm not sure if I got to do some Python when I was little.

00:02:44 But when I really got into it was in, I think, when I was 20 something, I was studying a bunch of courses online.

00:02:52 And one of them was, I was doing a bunch of courses, actually doing everything in JavaScript on the browser,

00:02:58 because Node.js was just starting to be something.

00:03:01 And one of them required Python for doing artificial intelligence and stuff.

00:03:06 And I ended up like, yeah, let's just try.

00:03:08 Let's see if I can do it.

00:03:10 And I ended up just like learning the basics of Python for the course.

00:03:15 And it was super intense, but I ended up loving it.

00:03:18 And yeah, I just went on with Python for everything.

00:03:21 Oh, that's great.

00:03:21 You know, Python is one of those things that learning Python is really interesting,

00:03:26 because it's both super approachable, but kind of never ending.

00:03:29 Like, I think one of the guests I had on not too long ago, I told a joke, talked about a t-shirt that was kind of a joke that said,

00:03:38 I learned Python.

00:03:39 It was a great afternoon or something like that, you know?

00:03:41 Yeah.

00:03:43 Which, in one hand, like, you can learn the syntax and you can make things happen

00:03:46 or follow along in a simple example.

00:03:48 But, you know, I'm still learning Python all the time, right?

00:03:52 Like, learning about your framework, I learned a bunch of stuff that I needed to figure out,

00:03:56 because it depends what you call Python.

00:03:59 Do you call Python, is that the language?

00:04:01 Or when you learn Python, are you also talking about learning the standard library?

00:04:04 Or if you really want to blow it up, then like the stuff on PyPI, right?

00:04:09 Like, you know, there's these different levels.

00:04:10 And you hear people say, oh, I learned Python really quick.

00:04:13 Or I've been learning Python for a long time and I'm still working on it.

00:04:16 Those people are probably not talking about the same thing, right?

00:04:18 Yeah, absolutely.

00:04:19 And then you get into numerical computation and processing stuff on GPUs.

00:04:24 And it's like a whole different story additional to everything else.

00:04:29 Yeah, absolutely.

00:04:29 Yeah.

00:04:30 Oh, for sure.

00:04:31 For sure.

00:04:31 Yeah.

00:04:32 And I only bring that up because I know there's a lot of people who are like

00:04:34 learning Python and getting started.

00:04:36 And they're probably a lot of times they're like, I'm still working on it after a year.

00:04:39 You know what I mean?

00:04:40 And I just, it's really interesting that people say the same thing.

00:04:43 And there's like these layers that they're talking about.

00:04:46 Cool.

00:04:46 So you got into programming or Python dragged into the data science side of the world.

00:04:52 That's cool.

00:04:53 And what are you up to these days?

00:04:55 So right now I'm working for Explosion in Berlin, Germany.

00:04:58 Explosion are the creators of Spacey, the natural language processing package for doing things

00:05:03 like machine learning over text.

00:05:06 The Prodigy, the package for doing data annotation using active learning.

00:05:11 So to annotate machine learning.

00:05:12 So to annotate machine learning datasets.

00:05:13 And think the deep learning library for doing, well, deep learning using ideas from functional programming, type annotations, and all these things in a way that is compatible with other tools like PyTorch, TensorFlow, etc.

00:05:27 This is the company I'm working for.

00:05:28 I'm working on the team that is building Prodigy Teams.

00:05:32 So the version of Prodigy for Teams to have like multiple people in the same company interacting with each other, coordinated and doing all that is like the cloud version.

00:05:44 But the important thing is that it runs on the client's cloud, on the specific company's cloud.

00:05:52 So data is like stored and all the privacy stuff can be like safe and all the stuff.

00:05:58 Yeah.

00:05:58 So that's what I'm doing like mainly in Explosion from time to time.

00:06:03 I also help put some extra things from the other projects.

00:06:06 And as part like of, I have the privilege that part of my work is maintaining my open source tools and projects because we use them internally and because Explosion is very cool, I guess.

00:06:17 Yeah.

00:06:17 But yeah, like I get to spend like, I don't know, a fifth of all my working time just dedicated to this open source tool.

00:06:24 So yeah, that's mainly my day to day flow.

00:06:26 I know that sounds really fun.

00:06:28 And yeah, Explosion AI seems like a cool company.

00:06:30 You know, we just had Ines on Python Bytes on episode 191.

00:06:33 So a little while ago when this ships, but you know, in calendar time, not long ago.

00:06:37 Yeah.

00:06:38 I'm guessing that you are probably using a lot of working a lot on the API side of that product, right?

00:06:45 Exactly.

00:06:46 Yeah.

00:06:46 Yeah.

00:06:47 Mainly on that side.

00:06:48 Cool.

00:06:48 Well, speaking of APIs, let's start there.

00:06:51 Obviously, it's all about consuming APIs these days.

00:06:54 APIs are everywhere.

00:06:55 You go to Zapier and they're like, we integrate with, you know, however many thousand different

00:07:00 API endpoints that you might want to work with.

00:07:02 And it's, it's all pretty crazy.

00:07:04 But of course, creating APIs is super important.

00:07:08 So focusing on that side, how have you seen the evolution of API frameworks coming on?

00:07:14 Because the early days that I spoke of, it was like things were web frameworks.

00:07:19 And then if you wanted, you could somehow manage to put a web API in it.

00:07:23 Yeah, absolutely.

00:07:25 Exactly.

00:07:25 I think that's the key difference.

00:07:27 I think that's exactly the key difference.

00:07:29 Yeah.

00:07:29 Because.

00:07:30 Yeah.

00:07:31 So for example, this framework is basically, I don't know what you call it.

00:07:35 I would think it was something like API first.

00:07:37 I mean, obviously it's in the name, but there's a bunch of them like that these days that are

00:07:41 coming out where it's the building blocks talk in terms of APIs, not in terms of web templates

00:07:46 and whatnot.

00:07:48 Yeah, exactly.

00:07:49 So like, I guess for a very long time, the more established frameworks in Python specifically

00:07:54 have been Flask and Django.

00:07:56 And for APIs, it will be in Django, it will be Django REST framework.

00:08:00 In Flask, there are a bunch of plugins that can be combined together to make something that

00:08:05 works very well.

00:08:07 The same as with Django REST framework.

00:08:08 But the thing is that, as you were saying, these frameworks were made mainly to handle templates

00:08:14 in the backend.

00:08:15 So the extra plugins and the extra functionality was added on top around the ways that the framework

00:08:22 was able to do things.

00:08:24 So, and as you were saying, like there was this bunch of extra frameworks that came afterwards,

00:08:31 like several, even at the same time, sort of.

00:08:34 And then all the async wave came with a bunch of other frameworks.

00:08:39 Past API ended up later in that last wave, I guess.

00:08:44 But it was mainly from the learnings of all these previous frameworks.

00:08:48 I was using a bunch of those frameworks for a long time.

00:08:51 A bunch of plugins, a bunch of combinations, trying one thing, trying the other.

00:08:55 I had like something that was kind of stable, but it's still very difficult to maintain and

00:08:59 quite fragile.

00:09:00 Yeah, you said that you didn't really want to build FastAPI, but finally you decided,

00:09:05 all right, I need the thing I want to exist.

00:09:07 So here we go.

00:09:08 Yeah.

00:09:09 I felt like the meme of, hey, I built another JavaScript framework.

00:09:12 This happens like every week or so.

00:09:14 And I was trying really hard to avoid that.

00:09:17 And I was trying like, no, I just find the thing that I'm looking for and find the thing

00:09:22 that will do the functionality that I need.

00:09:24 Yeah.

00:09:25 And at some point when I was like, yeah, I'm not finding the right thing.

00:09:30 I found it.

00:09:31 And it was API Star was the name.

00:09:34 Right.

00:09:34 API Star was a framework built by Tom Christie, a great guy, the same creator of Django REST

00:09:41 framework.

00:09:41 Yeah, exactly.

00:09:42 A successor Django REST framework, but from scratch.

00:09:45 Exactly, exactly.

00:09:46 And that was API Star.

00:09:47 And API Star was trying to be compatible with Woosgi and Asgi.

00:09:51 So like the canonical standard specification or interface for web frameworks, which is what

00:09:58 Flask and Django are based on.

00:09:59 And at the same time with Asgi, which was the new standard that was also born at Django for

00:10:06 doing web sockets and all these asynchronous things.

00:10:09 Right.

00:10:09 It's probably maybe worth just pointing out to the people listening who are not deep in

00:10:13 the web hosting side, like Woosgi is this common API that all the different web frameworks,

00:10:19 Flask, Django, and so on, can talk to or implement.

00:10:24 And then all the web servers like uWSGI, G-Unicorn, and so on, know how to talk to anything

00:10:29 that does Woosgi.

00:10:30 And that's how you can run all the different frameworks on these various web servers.

00:10:34 But none of those were capable of supporting async programming, which is super important

00:10:39 for scalability on the server side, because just the way that thing was written is incompatible

00:10:45 with that.

00:10:45 And so there's another standard, I think, yeah, maybe Tom was even partially involved in like

00:10:51 defining the standard, I'm not sure, but called ASGI for async gateway interface.

00:10:56 And that's the ASGI that you're talking about, right?

00:10:58 So API Star was trying to do both of those things.

00:11:01 Yeah, exactly.

00:11:02 And complementing on what you were saying, like these specifications of how to interact

00:11:07 with the server and the framework are actually like quite simple.

00:11:11 It's mainly kind of one page.

00:11:13 And it just says like, there has to be a function that is going to be called with these parameters.

00:11:19 And it's basically that.

00:11:20 But then defining what is the shape of that function, what are the parameters that it's going

00:11:24 to receive, all that is like the main point of interaction between a server like Unicorn and

00:11:30 a framework like Flask.

00:11:32 So this new standard ASGI is the one that adds support for async and await and all these things.

00:11:41 And API Star was trying to have support for both things while being an API first framework

00:11:47 and having like a bunch of extra features that Tom Christie added.

00:11:51 And it was great.

00:11:53 I was just trying to add some authentication ideas to be able to integrate them with the

00:11:59 API first things.

00:12:00 And at that point, Tom Christie was also building Starlet, which is the micro framework slash toolkit

00:12:07 for building APIs in ASGI, in this new building APIs.

00:12:11 No, sorry.

00:12:12 For building like web applications or for doing web stuff using this new standard.

00:12:16 So it's like the bare bones thing is kind of in the middle of Flask and a lower level tool.

00:12:22 It will do like kind of the same things.

00:12:23 And because he was focusing on that, he had to deprecate most of the API Star components,

00:12:30 like the server components, and made it just like a system and a set of tools to validate

00:12:36 schemas for APIs.

00:12:38 Right.

00:12:38 And at that point, I just had found the perfect tool and then it had to be deprecated.

00:12:43 So I guess that was the cue.

00:12:45 That was the point where I said like, okay, let's try this.

00:12:48 And at the same, you know, that is a little bit unfortunate, but at the same time, you now

00:12:53 have Starlet.

00:12:54 So you don't have to write that layer.

00:12:56 You can work a little bit higher level.

00:12:58 So, well, let me just put my take on an API for building APIs, a meta API.

00:13:04 They're on top of Starlet, right?

00:13:06 Exactly.

00:13:06 Yeah.

00:13:07 So Starlette is like one of the fastest or I guess the fastest framework for Python currently,

00:13:15 like as measured by independent benchmarks.

00:13:17 Right.

00:13:17 Tech Empower is one of these people.

00:13:20 Yeah, exactly.

00:13:20 They measure not just, you're not saying that for Python frameworks, right?

00:13:24 That's like a general statement for many of the web.

00:13:27 They test all the different web frameworks, Python, Ruby, .NET, Java, and so on.

00:13:30 Yeah, exactly.

00:13:31 And a bunch of languages.

00:13:33 And with a bunch of combinations of databases and stuff.

00:13:35 So they have a great job.

00:13:37 And they do like testing rounds on physical servers.

00:13:41 So it's like a very, very robust and well-made general benchmark.

00:13:46 So it's quite nice because lets you like see more clearly what are the things and the advantages

00:13:52 and disadvantages.

00:13:52 Of course, benchmarks are always somehow biased in one way or another and difficult to handle

00:13:59 and to interpret.

00:14:01 At least like it's a very common ground, I think, these ones.

00:14:05 Right.

00:14:06 So then Starlette was this new tool and it was built by Tom Christie, the same creator

00:14:11 of Django REST framework, the same creator of the thing that I thought was the perfect

00:14:14 match that I was looking for.

00:14:16 So it was like a very, very solid option to build something on top.

00:14:20 Yeah.

00:14:20 I remember API Starlette being really nice.

00:14:22 I was sad to see that it got semi-deprecated as well.

00:14:25 Yeah.

00:14:25 Yeah.

00:14:26 I know.

00:14:27 But I mean, if we have FastAPI, because I think that FastAPI is actually better.

00:14:31 So it sounds to me like you're pretty happy with your job at Explosion AI, but you did have

00:14:37 this, you did run across this interesting job ad asking and you sent out a tweet and oh my

00:14:44 goodness, did that tweet take off.

00:14:45 So it said that it was looking for somebody to work in FastAPI and it suggested that they

00:14:52 have at least four years of experience with it.

00:14:54 Right.

00:14:54 Tell us about this.

00:14:56 Yeah, exactly.

00:14:57 It's fun because I thought like, huh, this is kind of a funny story.

00:15:04 And actually I have seen several job posts requiring similar things like for FastAPI specifically

00:15:10 requiring several years of FastAPI and FastAPI has one year and a half of existence.

00:15:14 And I saw the job post and I was like, it's kind of fun, but not fun enough.

00:15:20 But one day I was like, yeah, let's just tweet it.

00:15:22 It's not really that fun, but whatever.

00:15:25 So the tweet was, I saw a job post from four plus years of experience with FastAPI and

00:15:32 I couldn't apply because I only have 1.5 years since I created that thing.

00:15:36 I'm like, yeah, well, maybe it's time to reevaluate that years of experience is equal to the skill

00:15:43 level.

00:15:43 It was actually, I wrote it and I was like, it's not that fun.

00:15:48 And I asked my wife and she said like, yeah, well, whatever, just post it.

00:15:51 Yeah, exactly.

00:15:53 Someone might find it fun.

00:15:54 And then like two hours later, it was like 2000 likes or something like that.

00:15:59 And it started growing like crazy.

00:16:01 You probably almost had to like turn off notifications on your phone at that point.

00:16:05 If it's just ding, ding, ding, ding, retweet, retweet, like retweet.

00:16:08 Yeah, exactly.

00:16:11 Like I tried to open the Twitter app in my phone.

00:16:14 And for two days, it was just crashing immediately.

00:16:16 It wouldn't even open.

00:16:18 And I didn't even know, like, how is this thing?

00:16:21 This is so weird.

00:16:23 And if you see my Twitter account, you can see like the tweets before that or after that.

00:16:28 Right, right, right, right.

00:16:29 30 likes, 50 likes.

00:16:31 Yeah, you really struck a nerve.

00:16:33 Yeah.

00:16:33 You really found like this idea of like, oh yeah.

00:16:36 I guess so.

00:16:37 We all hate this idea and it's all the time, right?

00:16:40 Pretty funny.

00:16:41 Yeah.

00:16:42 Yeah.

00:16:42 This portion of Talk Python to Me is brought to you by Linode.

00:16:47 Whether you're working on a personal project or managing your enterprise's infrastructure,

00:16:51 Linode has the pricing, support, and scale that you need to take your project to the next level.

00:16:56 With 11 data centers worldwide, including their newest data center in Sydney, Australia,

00:17:01 enterprise-grade hardware, S3-compatible storage, and the next-generation network,

00:17:07 Linode delivers the performance that you expect at a price that you don't.

00:17:11 Get started on Linode today with a $20 credit and you get access to native SSD storage,

00:17:16 a 40 gigabit network, industry-leading processors, their revamped cloud manager at cloud.linode.com,

00:17:22 root access to your server, along with their newest API and a Python CLI.

00:17:27 Just visit talkpython.fm/Linode when creating a new Linode account and you'll automatically

00:17:33 get $20 credit for your next project.

00:17:35 Oh, and one last thing.

00:17:36 They're hiring.

00:17:37 Go to linode.com slash careers to find out more.

00:17:40 Let them know that we sent you.

00:17:41 Created about a year and a half ago.

00:17:45 Let's talk about some of the core features because I really, really like the way that you put this

00:17:50 together.

00:17:51 It brings together two or three of my really favorite things about some of the language stuff.

00:17:56 Type Annotations.

00:17:57 It makes those like first class citizens in a, the right way to put it, a non-artificial way.

00:18:04 Because I've seen people on other frameworks use Type Annotations, but the types are meant to talk to the

00:18:10 framework, but they're not actually the types you end up with.

00:18:12 You know, like think SQLAlchemy.

00:18:14 Like you would say that by default, the type is a column type.

00:18:17 But really what you mean is it's an integer.

00:18:19 So, I mean, that's not SQLAlchemy doesn't do that, but there's some web frameworks that kind of have

00:18:23 that similar take.

00:18:24 So Type Annotations, the async and await stuff on the server.

00:18:27 And then also this, this ability to have like a model that defines what you expect to be coming

00:18:33 in and the ability to not have to do that juggling yourself.

00:18:37 Yeah.

00:18:38 Yeah.

00:18:38 Yeah.

00:18:38 Exactly.

00:18:39 I think you, you already defined it better than me, but yeah, that was the idea.

00:18:43 I wanted like coming from what I had seen on API star and with the idea that you could maybe

00:18:51 add some extra information about the parameters that go into a function in the same declaration

00:18:56 of those parameters.

00:18:57 Then I wanted to extend that a bit.

00:18:59 And that's when I found Pydantic, which is a library for doing data manipulation, which is

00:19:03 awesome independently of if you use FastAPI or not.

00:19:07 It's great by itself.

00:19:09 And the way it works is that it's pretty much the same as with data classes, but it adds the

00:19:15 additional data validation and data serialization.

00:19:19 So if you type something that is declared with a type of an integer and you try to parse something

00:19:24 that is not an integer, it will try to transform that into an integer and try to serialize that

00:19:30 and convert that to the actual integer that you're declaring to receive.

00:19:33 So for example, if you say that parameter in a, in a URL should be an integer, let's say the user ID,

00:19:40 a Pydantic can take that and transform it into the, an actual integer so that the, the code internally

00:19:46 receives an actual integer.

00:19:48 Right.

00:19:48 So FastAPI uses all these ideas from Pydantic and the internal tools to integrate that with the framework itself based all on top of Starlet.

00:19:58 And as you say, I was trying to hit exactly that point of being able to use the type annotations in the standard way to use the standard type annotations.

00:20:08 For example, to use, if I wanted to have a string to declare it as a string, not having to import some specific strange class that was declared by FastAPI or something,

00:20:18 but just using the standard string as a type annotation and they get all the type support in the editor,

00:20:25 like auto completion and type checks and all these things, having them by default working as it will be with any code base that is type annotated.

00:20:32 So like all those features and on top of that, having the data validation,

00:20:37 so that data is valid at the point that your code starts to run.

00:20:42 You don't have to do all that validation by hand and data serialization.

00:20:46 So for example, like with Pydantic, you can create, say, a user class and say it has an ID colon int and a name,

00:20:54 which has a default value.

00:20:55 And then another thing like a date time, which has an optional of, say, date time and so on.

00:21:01 And if I'm reading it right, the ID that doesn't have any default value,

00:21:05 but is also not an optional ID is a required field.

00:21:08 Probably the name that has a default value.

00:21:10 Exactly.

00:21:11 Is optional and would take that default value.

00:21:14 And the optional one that's explicit also would have an optional and so on.

00:21:17 So like if there's a concrete type, it's both required and converted to that.

00:21:21 If there's a default value, it is that type, but it's also, it's not required and so on.

00:21:26 So there's a lot of nice nuance with almost nothing but like this field is this type and either is optional or not.

00:21:33 Right?

00:21:33 Yeah, exactly.

00:21:34 And the idea is to like use the same, the same way that standard Python works.

00:21:40 So like the same way that you declared that a function parameter is required, it should still be required, which is like by not declaring a default value, then it is required.

00:21:49 So it's interpreted that way.

00:21:51 So the idea is that it just like hooks the standard intuition and uses that to provide all the extra features.

00:21:59 So it should be just like very intuitive to work with and just work well by default.

00:22:03 That's kind of the...

00:22:05 It's beautiful.

00:22:06 And then also because of the way that it's put together, it leverages all the stuff that tells the editors what to do.

00:22:13 So if you get your value and you say, you know, dot, it knows what type that is and what to autocomplete right there.

00:22:19 Exactly.

00:22:20 Exactly.

00:22:20 And because you can also have like very deeply nested and complex data structures.

00:22:25 Like you can say that your API is going to receive a list of orders of food.

00:22:31 And each one of these food items is going to have a name, but can also have a list of ingredients, which each of them is going to be a string.

00:22:38 So it's like a very nested and complex to even to explain a complex data structure.

00:22:44 But then being able to have autocompletion, even for the deeply nested little bits inside of the editor and type checks and all that.

00:22:52 Like for me, that's like, wow, this is so cool.

00:22:56 It's so cool.

00:22:57 And like, it's the fidantic that I use.

00:22:59 Yeah.

00:23:00 You know why it's so cool is because that's the part of programming that just sucks.

00:23:04 Like you just, it's not fun to go, just go like, okay, does it have this?

00:23:07 Does it have this?

00:23:08 Is it this the type?

00:23:09 I tried to convert it.

00:23:10 No, it crashed.

00:23:10 Okay.

00:23:11 There's not much value in that, but you have to be very careful and specific.

00:23:16 And just, if that could just go away like this and something else handles it, it's beautiful.

00:23:21 Yeah.

00:23:23 And also I think it's like, at least in my experience, it has been one of those pieces of code and logic that is in many cases neglected, at least in the beginning.

00:23:33 Like when you say, okay, let's build an API.

00:23:35 Then you just add Flask and yeah, it works.

00:23:38 But then you're not taking into account all the corner cases and all the invalid data problems and all those things.

00:23:44 And it's very easy to miss that and to not realize that you have to validate all that stuff.

00:23:50 So having something that kind of enforces you to do it and does it by default, that's, I guess, like the main benefit.

00:23:56 Right.

00:23:56 And so when that fails validation, what happens?

00:24:00 Does the client get a 400 bad request with some kind of message about how it failed?

00:24:04 Yeah, exactly.

00:24:05 So when you declare, so let's say you create a class, a user class that inherits from this thing from Pydantic.

00:24:12 And you say like, I'm going to receive a food that has a name and has some ingredients.

00:24:17 And you declare the parameter inside of the function with using standard type annotations using the food colon.

00:24:24 This is of an instance of this class food.

00:24:26 So you have like standard Python type annotations and your code will be executed.

00:24:32 Like the code inside of the function that will handle that request is going to be executed only after the data is validated.

00:24:40 That's fantastic.

00:24:41 So if someone sends, yeah, I think that's pretty cool because it saves like, I don't know, 20, 50 lines of code inside of each one of those functions that is just done automatically.

00:24:52 So when data is invalid and it gets to the server, data is going to be validated and all the errors are going to be like checked and the client is going to receive.

00:25:04 It's a 422 error.

00:25:06 Yeah, it's a 400 range error.

00:25:08 422 is the unprocessable entity.

00:25:11 And it's going to tell the client exactly where is the error.

00:25:15 So it's not only saying there's an invalid data in your request.

00:25:20 It's saying exactly inside of this point deep in your deeply nested data structure, like one of those ingredients in the food items that you sent in your orders.

00:25:32 One of those ingredients is not really a string.

00:25:35 So exactly there is a problem.

00:25:36 Wow.

00:25:37 Yeah, that's awesome.

00:25:38 I love it.

00:25:39 And you said it, but I'm not sure if it totally sunk in.

00:25:43 All you have to do to make this happen is you create an API endpoint and then you say it takes a class, an instance of a class.

00:25:51 So like it takes a food colon food and that's it.

00:25:55 You don't have to like get from some dictionary and like copy it over or like FastAPI will look at that and say, oh, it's the thing that I have to supply this function or call it is this.

00:26:05 So I'm going to take the posted JSON data.

00:26:07 I'm going to run it through Pydantic, make sure everything works.

00:26:10 And in that case, I'm going to deliver to them to start off a fully validated one of these things, pre-populated strings converted to integers as they need to be and all that.

00:26:19 Right?

00:26:19 Yeah, exactly.

00:26:20 Exactly.

00:26:21 And if you're not going to do that, then you just won't receive it and the client will receive an error automatically.

00:26:37 So it's just works by default.

00:26:39 That's super cool.

00:26:40 I guess the other point around one of these core features here that we're talking about, this isn't the thing necessarily that like made me go, yes, this is awesome.

00:26:48 But it's nice is that it's API first.

00:26:50 So if I was in, say, Flask, I would say at app.route, give it the URL.

00:26:57 And then optionally, I could decide to filter down the HTTP verbs I could accept.

00:27:02 I could say, is it methods equals get comma head or something like that, right?

00:27:07 Those could be the things.

00:27:08 Yeah.

00:27:08 But with your API, it's app.get URL or app.post.

00:27:13 And so you speak in terms of, I want to handle this verb and this URL here, which is a very API way of thinking about the world.

00:27:21 Yeah, exactly.

00:27:21 And the idea with that was that in many cases, it's very easy to end up having a bunch of logic to handle get and post in the same function.

00:27:32 And then all that logic is actually like very cumbersome to untangle because it's handling different ideas and different cases.

00:27:40 It might share some code, but it's mostly different ideas in most of the cases.

00:27:45 Yeah, I've seen it too.

00:27:46 And it's such a bad idea.

00:27:47 It's like, why would you say if method equals get, here's part of my method, else if it's post, do this.

00:27:55 Just make that two methods and just set the method, the verb to be the two things.

00:28:00 In which case, like what you've got here, it just leads you more naturally down that path of this is the one that does the get.

00:28:05 This is the one that does the post.

00:28:06 And it kind of, there's this cool concept of designing APIs or ways of consuming stuff that I like,

00:28:12 like helping users fall into the pit of success.

00:28:15 Like if you don't know what you're doing, you kind of bumble your way around.

00:28:19 You're going to land into the place you should land.

00:28:22 You got to fight to get out of that place to like do it wrong.

00:28:25 You know what I mean?

00:28:26 I hope so.

00:28:28 I really hope so.

00:28:28 And this helps people fall into the pit of success.

00:28:31 And it's also that I waddled around into the neighboring places that didn't work very well.

00:28:39 Yeah.

00:28:40 And then like learning from these things, learning from all these best practices from different APIs, from different tools, from different plugins.

00:28:47 It's like all that learning is what I try to put together with FastAPI.

00:28:51 Yeah, well, well done, I think.

00:28:53 So because all these things we talked about are the stuff that you've put together, but because in terms of defining the API, but because it's based on top of Starlet, Starlette itself has a bunch of cool features as well, right?

00:29:06 Yeah, exactly.

00:29:07 Starlette is, well, to start, FastAPI is actually kind of a thin, sort of thin layer on top of Starlet, adding the pydantic parts and combining it all together based on the standards, based on the open API, JSON schema, or two, all these standards from the web that you just like get by default when using, when creating a FastAPI application.

00:29:28 But Starlette is the thing that is actually doing all the web handling.

00:29:33 It's the thing that it provides all the performance.

00:29:35 And Starlette has support for, so FastAPI also has support for web circuits.

00:29:41 There's easy GraphQL integration.

00:29:43 You can have templates the same as you would with Flask or with many other frameworks.

00:29:49 So you can actually build a web application based on templates in the like same way as you will do with all their established frameworks.

00:30:00 It's just that that's not where it shines.

00:30:02 But yeah, like you can have all these different things by default just because it's based on Starlet.

00:30:08 So if I wanted to rewrite my website, most of which is in Pyramid, some of which is in Flask, I could do it with FastAPI?

00:30:16 Yeah.

00:30:16 Actually, I imagine you will have like a bunch of Jinja 2 templates or something like that.

00:30:21 Then you can just preserve the same templates and you just reuse them and pass them to FastAPI.

00:30:27 It's just that there's not that huge benefit from that because like the logic will end up being very similar and FastAPI won't provide a lot on top of what other frameworks made with templates will do.

00:30:40 But yeah, you can actually do it fairly easily.

00:30:42 Yeah.

00:30:43 Okay.

00:30:43 Yeah.

00:30:44 I mean, we do have a bunch of APIs for like our mobile apps and stuff and it'd be nice to write those differently.

00:30:49 Yeah.

00:30:49 Yeah, absolutely.

00:30:50 Yeah.

00:30:51 Cool.

00:30:51 So there's a bunch of features you get from Starlette and because this is a layer on top of that, you basically get all the features of Starlette Plus.

00:30:59 We mentioned ASGI a couple of times.

00:31:02 Yeah.

00:31:02 And so I'm guessing I could do an async def view method or API endpoint.

00:31:08 Yeah.

00:31:09 So Starlette is based on this standard ASGI.

00:31:12 So you actually can get like all the things that are compatible with ASGI and there's a bunch of tools and additional like middleware and things that you can integrate directly because it's based on one of these common standards.

00:31:27 Like it's an open standard that everyone can implement.

00:31:29 So you can add, I don't know, Sentry, you can add the Data Dog, you can add Elasticsearch, like the logging functionality.

00:31:39 You can add like a bunch of things right there that are not necessarily even made for FastAPI or for Starlet, just because they adopt the same standard.

00:31:48 You can get like all that as well.

00:31:50 Okay.

00:31:51 Super cool.

00:31:51 And do you support async methods?

00:31:53 Oh yeah, of course.

00:31:55 So FastAPI is actually like mainly, well, and actually Starlette is mainly an async framework.

00:32:01 So you will use async def for your functions.

00:32:05 If you want to have like all the performance and you know how to use async and await.

00:32:09 Async and await are like provide a bunch of performance and performance in concurrent scenarios, a bunch of performance benefits.

00:32:19 But they have like their own ideas that you need to be aware of to be able to use them properly.

00:32:25 So you need to be able to use tools that are compatible with async and await.

00:32:30 So if you are using async and await, then you can take all the benefit from that.

00:32:35 But with the Starlette and FastAPI, you can also use standard function definitions.

00:32:40 And then it will do like the smart thing and will run those standard function definitions underneath in a thread pool.

00:32:48 So the technical details is that it won't block the event loop.

00:32:52 But the thing is that it won't degrade performance or it won't do something that actually ends up like hurting the whole application.

00:33:00 So if you are not sure or if you are doing, I don't know, machine learning stuff, then you can just use a standard function definition with just def whatever.

00:33:10 But when you want to or when you need to have some of these async ideas, for example, when you need to handle WebSockets, then you can use async def functions.

00:33:19 Oh, that's really nice.

00:33:20 So you don't have to adopt the async APIs in order to work with it, but you can if you want to.

00:33:26 Yeah, exactly.

00:33:27 And for example, you can if you have a bunch of SQLAlchemy models with a Flask application or something else, then you can just reuse exactly the same SQLAlchemy models and reuse even the same database.

00:33:37 So you can actually have both applications running at the same time and then just use a standard code as you would with normal def functions.

00:33:45 Very nice.

00:33:46 I think most people probably don't need that, right?

00:33:49 Like most of the time, APIs are fast enough and they're just fine and whatnot.

00:33:53 But when you do need them, it's really awesome that that capability is there to say the answer is not I have to go rewrite this in Node.js or in Go.

00:34:02 It is I just need to use a different thing, HTTP client that I'm consuming my API with like HTTPX or something that supports async.

00:34:10 Or I need to use a slightly different ORM library that supports async await, right?

00:34:15 Like a small adjustment rather than a throw it all away and start over.

00:34:20 Exactly, exactly.

00:34:20 And in fact, you can combine those in the same application.

00:34:24 So you can have like a bunch of standard function definitions for most of the application.

00:34:28 And then you need one that needs to have like all the maximum possible performance.

00:34:33 You can have like, I don't know, maybe literal SQL statements connected to an async postgres driver or something.

00:34:42 And then do that only for that specific endpoint that needs to have like all the maximum performance.

00:34:48 And then the rest, you can just do the standard code.

00:34:51 Right.

00:34:51 And in FastAPI, there's a dependency injection system that can be used to handle data positions and a bunch of things, but also to do things like authentication, authorization, getting, for example, getting the current user from a request, things like that.

00:35:04 And it's all gets integrated into the automatic user interface that is generated.

00:35:09 But the cool thing is that you can actually combine async and normal function definitions for these dependencies that can depend on one another.

00:35:17 So you can have different async and normal function definitions even for the same route that you're handling, even for the same endpoint.

00:35:26 Oh, wow.

00:35:27 Okay.

00:35:28 That's pretty awesome.

00:35:29 Talk Python to Me is partially supported by our training courses.

00:35:34 How does your team keep their Python skills sharp?

00:35:37 How do you make sure new hires get started fast and learn the Pythonic way?

00:35:41 If the answer is a series of boring videos that don't inspire or a subscription service you pay way too much for and use way too little, listen up.

00:35:50 At Talk Python Training, we have enterprise tiers for all of our courses.

00:35:54 Get just the one course you need for your team with full reporting and monitoring.

00:35:59 Or ditch that unused subscription for our course bundles, which include all the courses and you pay about the same price as a subscription once.

00:36:06 For details, visit training. talkpython.fm/business or just email sales at talkpython.fm.

00:36:15 One thing I think would be fun to do is maybe compare this to Flask at an API level.

00:36:20 And there's a cool article.

00:36:22 I don't know.

00:36:22 Have you seen it?

00:36:23 This article called FastAPI for Flask users?

00:36:25 Yeah, yeah, yeah.

00:36:27 It got a lot of attention.

00:36:28 And it was actually very on point with most of the things like how they are different.

00:36:32 Yeah.

00:36:33 And the advantages and stuff.

00:36:34 Yeah.

00:36:35 So this is an article by Amit Chantari.

00:36:37 I'll link to it.

00:36:39 But basically, he goes through and says, all right, you know Flask.

00:36:41 Here's what you would do if you were to convert your app or rewrite it or just learn FastAPI.

00:36:46 And I think a lot of people out there know the API for Flask.

00:36:49 So I think it'll be a quick comparison.

00:36:51 So the first one that we talked about a little bit is that this is API first, not page first or URL destination first.

00:36:59 So instead of app.route, you have app.get, app.post, and so on.

00:37:04 And pass the URL, of course.

00:37:05 That's what we talked about.

00:37:06 I think one that touches on some of the stuff, some of the advantages are you've got app.route.

00:37:12 And then you can specify a variable in there.

00:37:15 And in Flask, it's nice as well that you can say this variable is an integer or it is float or something.

00:37:22 And it'll look at that and it'll require it to be an integer.

00:37:25 And it will cast it to an integer and then pass it to you, right?

00:37:28 Yeah.

00:37:28 But in your framework, you just say there's a variable.

00:37:30 And in the function, you say it's an integer, which I think is better.

00:37:34 I mean, it's sort of equivalent, but it's better because the tooling, mypy, PyCharm, VS Code,

00:37:40 they all know that it's an integer.

00:37:41 Whereas the Flask version, it just happens to be.

00:37:44 Yeah.

00:37:44 So the thing is that Flask was made in the Python 2.something versions.

00:37:50 So it's a great syntax and some great ideas that used the available options that were there at the time.

00:37:59 But then the thing is that you end up having to learn this extra syntax of where to put,

00:38:04 like what is the type and what is the variable and what is the symbol that you have to put on the size.

00:38:10 There's like a little extra syntax that is specific to Flask that you have to learn.

00:38:15 The idea here was to use the same concepts that are like now part of Python itself.

00:38:21 So for example, to declare a variable, you don't use, how do you call them?

00:38:24 Like angular braces or like less than and more than?

00:38:28 Yeah, exactly.

00:38:29 Yeah, yeah.

00:38:29 Angle brackets.

00:38:30 Yeah.

00:38:30 Yeah.

00:38:31 You use call the braces, which is the same one that you use for f-strings.

00:38:34 So it should be relatively familiar.

00:38:37 Yeah.

00:38:37 And then to declare the type is just like in the function, which you will probably want to declare the type in the function either way,

00:38:44 even if you were using Flask instead of FastAPI, just to get like all the type support from the editor and from tools.

00:38:50 So.

00:38:50 Exactly.

00:38:51 That's what I do.

00:38:52 But you've got to have it in two places, right?

00:38:54 You got to have it in the route definition and in the function parameter.

00:38:58 And they could get out of sync, which is annoying.

00:39:00 I mean, this is not a huge bash on Flask type of thing.

00:39:03 Like you said, it just predated the concept of type annotation.

00:39:06 Yeah.

00:39:07 And actually like a lot of the things in FastAPI were learned from Flask

00:39:12 and from a bunch of additional plugins that were compatible with Flask, including Marshmallow and WebArgs and Flask API spec that were great tools.

00:39:22 And those were my favorite tools like up until I built FastAPI to be able to have like

00:39:26 that functionality that they provided, but like taking the advantage of the new type of notations.

00:39:33 But yeah, it's like FastAPI wouldn't exist if it was not for the learnings provided by all these previous tools.

00:39:40 Yeah, for sure.

00:39:41 Another one, query strings and maybe more general, right?

00:39:45 Like if I understand it right, FastAPI will take the data from all the places it is provided to your endpoint, right?

00:39:54 So obviously if you post a JSON document or a form, it'll take it from there and put it into your argument,

00:40:00 but also from the query string, from the headers, from the cookies and so on, right?

00:40:04 Yeah. So basically the way that you declare that you, let's say in many traditional frameworks,

00:40:10 you receive a request, a request object, or you import in some way, you have some type of request object.

00:40:18 And from the request object, you extract data, you get JSON data, you get query parameters,

00:40:24 you get path parameters, cookies, whatever.

00:40:27 But you start with a request that is the same for all your functions.

00:40:31 In FastAPI, you can actually get the request and get the data by yourself directly if you want to do so.

00:40:37 So it's actually also available.

00:40:39 But the main point of interaction and the main point of extracting the data is not getting a request object,

00:40:46 but declaring the parameters in the function.

00:40:49 And those parameters will be extracted, validated, and everything from the request.

00:40:54 And also documented, because when you create an application with FastAPI,

00:40:57 you get automatic API documentation in a web user interface that you can explore and use interactive.

00:41:03 So like the main point of information extraction is in those parameters in the function.

00:41:09 Yeah. And what happens if it's missing, right?

00:41:11 Like a query string is something that may or may not be there.

00:41:14 Yeah. For example, let's say that you have a query string that you call like,

00:41:19 Yeah, well, Q because it's you are doing some query search or something.

00:41:24 If you declare...

00:41:25 Right, right. So you'd have like endpoint question mark Q equals some value you want to search for.

00:41:30 Yeah, exactly. Exactly.

00:41:31 Then you declare the function and you add a parameter that is called Q.

00:41:35 Because the parameter is called Q, the FastAPI will look for a parameter in the query that is also called Q.

00:41:44 Then you declare a type for that parameter.

00:41:47 Let's say it's a string because we want text string.

00:41:49 So FastAPI will make sure that it's a string.

00:41:52 Well, given it's a URL, it will always be a string.

00:41:54 But you could say like it's a boolean and FastAPI will make sure that it's a boolean.

00:41:57 Right.

00:41:58 But then you can also say, hey, this thing is optional.

00:42:00 So by default, this will be none.

00:42:04 So that means FastAPI, like in the Python world with like independent of FastAPI, when you declare a function that has a default value, then that parameter automatically is not required.

00:42:16 So FastAPI will use that same logic and make the parameter not required because it has a default value.

00:42:22 You could use that, for example, to say like, I want to get, I don't know, the users and I want to limit the amount of users that I want to receive by 200 and I want to skip the first thing or something like that.

00:42:34 You could have default values for those query parameters and say like that the default value is to skip zero because you want to get all the users from the first one.

00:42:42 And the limit is by default 10.

00:42:45 Right.

00:42:45 But then you will get those values in your code, but the user provides them in the query parameters, then FastAPI will read that from those query parameters.

00:42:53 So you actually use the same ideas that you use in normal functions to declare when something is required or not.

00:43:01 Like this is the basic case.

00:43:03 There's an additional case where you want to do additional data validation of those specific query parameters on those specific data that you're receiving.

00:43:11 For example, you want to make sure that the query is not longer than 100 characters or something like that.

00:43:17 You can do additional validation for that with another technique.

00:43:20 But in the basic case, it's just like the same way you use for standard functions.

00:43:26 Right.

00:43:27 Like if you wanted more validation, you could have a search parameters, Pydantic type, could have a field queue, and then you could put the Pydantic requirements and restrictions there.

00:43:36 Right.

00:43:37 Right.

00:43:37 Yeah.

00:43:37 And actually, like FastAPI will, if you declare a parameter that has a simple type like a string or a boolean or something like that, FastAPI will try to read it from the query.

00:43:46 But if you want to read it from, let's say, from a cookie, then you can import another utility from FastAPI and make the default value of that parameter.

00:43:56 That thing that you imported, which is a function, and you just call it, and that tells FastAPI, hey, I want this thing to be retrieved from the cookie, not from the query that will be the default.

00:44:07 Right, right.

00:44:07 That's a really interesting angle as well.

00:44:09 So because my stuff is in Pyramid, and a lot of it predates or is like right on the verge of predating the type annotations as well, certainly the framework is it gets this request and like you've got to go.

00:44:21 Yeah.

00:44:21 What's really annoying about when you're giving the request is it's not just like here's the data.

00:44:24 It's like, no, no, no.

00:44:25 There's a JSON body thing you've got to go check.

00:44:27 There's a form you've got to check.

00:44:31 There's the query string you've got to check.

00:44:33 There's the headers.

00:44:33 There's all these different dictionaries you've got to go check, right?

00:44:36 So what I've done so far is I've just I've set up some sort of lower level infrastructure that like, we'll just take that and merge it all into one giant dictionary and go, here's the data you've been provided.

00:44:47 You can ask for it.

00:44:49 You know, the form has or the URL has higher priority than the form, which has higher priority than like, you know, query string and all those kinds of things.

00:44:56 Right.

00:44:56 Yeah.

00:44:56 But yeah, this is nicer.

00:44:58 I'm glad you like it.

00:45:02 Yeah, for sure.

00:45:03 But yeah, it's actually it's one of those things that everyone ends up having a taste.

00:45:07 And sometimes people come like, hey, why are you doing it this way and not that way that I prefer?

00:45:12 And it's like, well, yeah, like I had to make some decisions and have some defaults.

00:45:17 But you can actually customize it to have whatever you actually want.

00:45:21 One of the things I think the API is a lot like Flask.

00:45:24 And I think Flask is a very popular framework.

00:45:27 But what's even more popular is the basic API of Flask.

00:45:30 Like you look at Sanic and it's kind of Flask like you look at Responder.

00:45:34 It's kind of Flask like, you know what I mean?

00:45:36 Like, yeah, this idea of I create an app and then I do app dot route or something to the equivalent.

00:45:40 It's just super popular.

00:45:42 Right.

00:45:42 One of the drawbacks of that API and maybe the cute little demos of like, look, you can in like 10 lines of code, write your web server.

00:45:51 And it's all great.

00:45:51 It can send people a little bit down the wrong path of like, well, now I've got this app object and I need to use it as the decorator on my stuff.

00:45:59 So I guess every single one of my API or view methods just goes into like the main app dot PY file.

00:46:06 Right.

00:46:06 And, you know, I think a lot of the tutorials and stuff lead people down the wrong way by just saying, well, this is just you just use app.

00:46:13 Right.

00:46:14 You just use that.

00:46:14 And in a real app, you would be hurting if you put that.

00:46:18 I mean, there's hundreds of API and for web endpoints in my apps.

00:46:24 And you want to put those into different modules.

00:46:27 Right.

00:46:28 Like, oh, here's where I deal with like, see your food example.

00:46:30 Here's how I deal with the recipes.

00:46:32 Here's how I go and get like a particular thing for the food.

00:46:35 Here's how I get like my preferences.

00:46:38 Like those are not all the same place.

00:46:39 Right.

00:46:39 Yeah.

00:46:40 So if Flask has blueprints, what does FastAPI have for the ability to factor your code into what I would call real applications?

00:46:50 So FastAPI has this additional tool, very similar to blueprints.

00:46:54 Actually, if you search for blueprint, Flask blueprints in FastAPI, you get immediately to the docs on how to do that.

00:47:01 There's this additional class comparable to the FastAPI class that you use to create an app that is called API router.

00:47:08 So you can create independent routers that are all in their specific modules, which work pretty much the same as the main app object that you will use.

00:47:18 But then you just have like, I don't know, router.get and the URL that you want.

00:47:23 And then you can import all those routers in your main application and include them in the main application.

00:47:28 And you can actually include them adding a prefix for the path.

00:47:31 So you can have like, let's say, one module, one Python file for users.

00:47:36 And then you have just router.get slash without even having to declare slash users slash.

00:47:42 You just say router.get slash.

00:47:44 And then it will provide you all the users.

00:47:46 But then at the time that you include that in the main application, you say everything that comes from this module should go with the prefix slash users slash.

00:47:56 Yeah, that's fantastic.

00:47:57 Because that's usually the thing that tells you how you want to break up your endpoints and group them, right?

00:48:04 Like, here's all the stuff that slash admin.

00:48:06 Here's all the stuff that is slash users and so on.

00:48:09 And you just enforce it right that way as well.

00:48:11 That's great.

00:48:12 Yeah, exactly.

00:48:13 Exactly.

00:48:13 So it's actually quite simple to do.

00:48:15 And you can like structure the application in a very simple way.

00:48:19 It's actually part of the main documentation.

00:48:21 Documentation is structured in a way that is a user guide and at the same time kind of reference.

00:48:26 But it's made in a way that you can go one point after the other and get like a full system with all the basic stuff.

00:48:35 And there's another section with all the extra advanced stuff.

00:48:39 But then you can get like learning all the bits and pieces and get to one of these things where you have an application built in with separate modules that all work together.

00:48:50 Yeah.

00:48:50 Yeah, cool.

00:48:51 Another thing that is common around APIs is not very common around websites, but is quite common around APIs is you need to document what are the endpoints?

00:49:02 What are the expected values?

00:49:04 Like your JSON documents look like this.

00:49:06 This is required.

00:49:07 It's an integer.

00:49:08 This is optional.

00:49:09 It's a date time and so on.

00:49:10 What's the story for that here?

00:49:12 So I guess I suffer from that maintaining corporate wikis that always got obsolete and the front end team came fighting like, hey, this thing doesn't work.

00:49:21 Like, no, it was updated a week ago.

00:49:23 So when you create an application with FastAPI, FastAPI itself is all built around open standards.

00:49:31 So when you create an application with FastAPI, you get an API that is based on standards and you get an open API schema.

00:49:39 So the standard is called open API.

00:49:40 And you get a schema, which is just a very big JSON that the clarion describes everything in your API.

00:49:47 All the paths, all the parameters, everything.

00:49:50 This is a big JSON that you actually kind of never look at because this JSON is read by a user interface that you can see through the web browser that documents all your API and that you can explore and actually interact with it live.

00:50:05 So you get automatic interactive documentation in your web browser included by default when you create an application.

00:50:13 And you can use it.

00:50:14 It's fun because sometimes people ask me, like, who is the user of that user interface?

00:50:19 And like, when you start this, like, you assume like no one is going to use it.

00:50:23 And maybe no, maybe it's just like for the final client or, but then you end up the final client ends up using it.

00:50:29 The front end team that you have to communicate.

00:50:31 And then you yourself end up using it to see like, hey, is this thing working or not?

00:50:36 So you actually end up using it a lot.

00:50:38 Exactly.

00:50:38 Or what does the system think?

00:50:41 I told it I want, right?

00:50:43 Does it, does it think this is optional or not optional?

00:50:46 I want it to be optional.

00:50:47 What does it say?

00:50:47 Yeah, exactly.

00:50:49 Exactly.

00:50:49 The thing is that because you don't have to maintain any documentation outside, or you don't have to include like additional configurations or schema inside of the, I don't know, the doc strings or things like that.

00:51:02 It's all generated automatically.

00:51:03 You don't have to do any effort to get that.

00:51:06 Like just by writing your standard code, you get that kind of for free.

00:51:10 So that's really helpful when developing and when using.

00:51:14 Yeah, for sure.

00:51:15 If I were to put a doc string that just was like a summary of what happens, would that show up in the documentation?

00:51:21 Yeah, exactly.

00:51:22 The doc string will end up in the documentation, in the interactive documentation, and you can actually use markdown and it will be rendered as a markdown.

00:51:30 Oh, sweet.

00:51:32 So yeah, it works.

00:51:33 As it should.

00:51:34 Awesome.

00:51:34 Awesome.

00:51:34 Yeah.

00:51:35 Yeah.

00:51:35 That works pretty well.

00:51:37 Well, and you also have like the utilities to document each of the things that you declare.

00:51:41 Like if you declare one of these classes that we were mentioning, you can have documentation for that specific class, which will be like a JSON payload.

00:51:50 It could have its own description.

00:51:52 Like each one of the fields could have its own description.

00:51:56 Like you can say name, this refers to the name of the food that you are requesting or whatever.

00:52:00 And it will be all there in the code and it gets all rendered in the documentation.

00:52:05 That's super cool.

00:52:06 So two final things I want to talk about.

00:52:09 One, I was going through the documentation and I saw that there were some optional dependencies, which is pretty interesting.

00:52:16 Yeah.

00:52:16 And so, for example, it says some are used by Pydantic, some are used by Starlet, some are used more directly.

00:52:22 But for example, I could optionally use micro JSON, U-J-S-O-N, but the mu, right?

00:52:30 The Greek micro, which is a faster implementation of JSON parsing.

00:52:34 And I guess if I just do pip install FastAPI, it just installs what it requires.

00:52:39 But maybe it uses just the built-in JSON parser, right?

00:52:43 Yeah, exactly.

00:52:44 By default, it will use the default JSON parser, which is like more standard and handles like all the cases in a more standard quote unquote way.

00:52:53 But if you need to have like the maximum performance, you can also install U-J-S-O-N and the TelFastAPI.

00:52:59 Like, hey, I want you to use not the standard JSON responses.

00:53:06 This U-J-S-O-N library to serialize all the data.

00:53:10 And actually, there in the documentation, I think in the main point where I say like, these are the optional dependencies.

00:53:15 There's only U-J-S-O-N is the only one mentioned.

00:53:17 But you can also use OR-J-S-O-N, which is equivalent to U-J-S-O-N, but is written in Rust.

00:53:24 And in some benchmarks is faster than U-J-S-O-N, you actually get like different ways to optimize whatever you want to do.

00:53:33 And to optimize like independently for each one of the things and each one of the endpoints that you need to have.

00:53:40 Interesting.

00:53:41 Yeah.

00:53:41 And you also, Starlette has an optional AIO files dependency, which will give you async and await capabilities for working with files.

00:53:50 And that plugs into like file response and static file responses and stuff like that.

00:53:54 Yeah, exactly.

00:53:55 So it's actually that Starlette is really, really lean.

00:53:59 Like the main code is very small and it's actually beautiful.

00:54:03 It's really enjoyable to read.

00:54:06 And it just plugs into different components and different parts for different things.

00:54:11 So when you use Starlette alone or FastAPI alone, for example, it won't include any ORM.

00:54:17 It won't include Jinja by default because you don't necessarily have to use templates.

00:54:23 But if you need templates, then you just import Jinja and use the templates functionality internally.

00:54:28 So it's made in a way that doesn't require all the possible dependencies, but you can install them and then just use them internally.

00:54:35 That also allows you to have like very minimal applications that are not bloated with different packages and dependencies and things.

00:54:43 Right.

00:54:43 But at the same time, you can grow very large to solve the use cases that you need to deal with.

00:54:49 Yeah, that's cool.

00:54:50 It's like a micro framework philosophy adopted there.

00:54:53 Yeah, exactly.

00:54:54 Exactly.

00:54:54 Exactly.

00:54:54 Last one is about hosting.

00:54:56 So I saw that it ships with UVicorn, which is like the ASGI Python server equivalent of G Unicorn, but based on uv loop.

00:55:07 Is that right?

00:55:07 Exactly.

00:55:08 That's exactly correct.

00:55:09 So UVicorn.

00:55:11 And uv loop is a high performance async and await, like event loop, basically written in C or something like that.

00:55:17 Yeah, and uv loop is the thing that has been providing all this high performance for all these high performance frameworks.

00:55:23 Like starting with Sanic, the main idea they had was let's run everything using this additional optional loop that is going to do all the asynchronous stuff.

00:55:35 And that's what provides all the huge performance.

00:55:37 So Starlette and FastAPI are frameworks, which is one of the sides of like the whole process.

00:55:45 Like when we were talking about this specification, this ASGI or ASGI specification, on one side you have the framework and on the other side you have the server.

00:55:53 UVicorn will stand on the server side.

00:55:55 You can use UVicorn, but you can also use another one called Hypercorn, or you can use the one that is created by the same guys from Django, which is called Daphne.

00:56:06 And you can use, for example, you can have UVicorn, which like starts a process using this uv loop server.

00:56:14 But you can also have Unicorn, the standard you will use for Flask, running a worker of UVicorn, like and running several workers.

00:56:24 So you can have several processes that all have like this massive high concurrency serving your application, all handled by the same unicorn as you will normally do.

00:56:35 Which is probably what you want to do in a production, right?

00:56:38 You very often have five or 10 worker processes that are controlled by G-Unicorn or Microwisgee, and then they clone themselves for the, to get the parallelism that you really would expect.

00:56:49 Yeah, exactly. And that's precisely what I do with the official Docker image for FastAPI.

00:56:54 It just does that. It has Unicorn, it runs UVicorn, and then it runs your application, and it spawns the amount of processes depending on the amount of processes available to the node that is running that Docker container.

00:57:08 So you can just like create the Docker file, the basic Docker file, copy your app, and it just like, by default, is fine-tuned to work pretty well.

00:57:16 Yeah.

00:57:16 If you use Docker.

00:57:17 So yeah, like that will probably be like the main combination you will have.

00:57:21 Unicorn with UbiCorn running your application.

00:57:23 Cool. What if I do it wrong and I host it under straight G-Unicorn or I host it under Microwisgee, both of which I don't think support ASGI, not to my knowledge anyway.

00:57:35 What if I host it in something that is just a WSGI server, not a ASGI server? What happens?

00:57:41 It just won't work.

00:57:43 It doesn't work at all? Okay.

00:57:44 It probably just won't work. Yeah. Like if you have a server that only, like a server provider, like a software as a service provider that only supports WSGI.

00:57:52 But actually most of the servers nowadays support ASGI. So you can actually use these frameworks very easily with most of these software as a service platforms.

00:58:02 Or if you use something like, I don't know, Google Cloud Run or any of these systems, there's actually a plugin, like an additional package that allows you to build FastAPI applications and run them as, what is the name?

00:58:17 These function services like Lambdas, these serverless things.

00:58:21 Right, right, right.

00:58:22 So you don't have to have a server running all the time. You can also like use these same tools, same ideas and run them in one of these function providers.

00:58:31 Oh, that's interesting. Yeah. Yeah, yeah. Cool. All right. Well, very cool project. Thanks for doing a deep dive into it.

00:58:37 Because I definitely think this is one of the shining examples of these new flowers and this next generation set of web frameworks that we talked about. So good job.

00:58:45 Thank you very much for the invitation. It's been really great.

00:58:48 Yeah, absolutely. Now, before we get out of here, though, I got to ask you the final two questions.

00:58:52 Sure.

00:58:53 If you're going to work on FastAPI, what editor do you use these days?

00:58:58 So I'm currently using Visual Studio Code, and they recently launched the new plugin for Python, which is called PyLens.

00:59:06 And it's really, really good. Yeah, that's my main editor currently.

00:59:11 Nice. And PyLens is a new language. Basically, it's the new Python plugin or built atop the other one, but it has a much better intelligence and visualization or understanding of like your whole project and like the help strings and the type information and all that kind of stuff. Right.

00:59:27 So it's kind of levels up the autocomplete and the tooltips and whatnot.

00:59:30 Exactly, because I was a complete and some of these things were pretty good with the previous plugin in Visual Studio Code.

00:59:37 But this one uses another tool. It's actually all written in TypeScript.

00:59:41 But the thing is that it provides very good autocompletion type checks, and it has like a detection of dead code.

00:59:48 For example, if there's something, some region in your code that will never be executed, if you're checking like if false or something like that, it will detect that this section will never be executed.

00:59:58 It also has a support, like it detects types very, very well.

01:00:03 There are some advanced ways that you can declare type annotations and that many or at least the previous version of this editor and some other editors were not able to catch it very well.

01:00:14 For example, when you use path leave paths, the new plugin get them very well, even when you do like sophisticated operations, including strings and things like that.

01:00:23 So it actually works pretty, pretty well.

01:00:24 Very cool.

01:00:25 Yeah. And I said that's quite new.

01:00:27 And then notable PyPI package.

01:00:29 Obviously, there's pip install FastAPI.

01:00:31 But, you know, some package you've come across lately that you're like, oh, you should definitely know about this.

01:00:36 So I sort, which is actually a command line package is one of the packages to do linting and recently got a new release that I sort is for doing automatic sorting of the imports in a file.

01:00:49 Yeah.

01:00:50 So you're going to, I can be very sloppy in my code and just import anywhere I'm writing the code right on top of the function.

01:00:58 I just import it and then I make it sort all the imports.

01:01:01 So it's very nice and keeps the code very tidy.

01:01:05 So that combined with black and other tools, it's great.

01:01:08 But I think iSort deserves a lot more attention than it's getting right now.

01:01:12 Very cool.

01:01:13 Yeah, that's a nice one.

01:01:14 All right.

01:01:14 Final call to action.

01:01:15 People are interested in FastAPI.

01:01:17 They want to get started.

01:01:18 You know, how can they bring this into their maybe existing API apps or create new APIs with it?

01:01:23 What do you tell them?

01:01:24 So I think the first thing is that I guess many people are like, hey, this seems kind of cool.

01:01:30 I'm not sure if I'm into it, but maybe the first thing will be just to read the main page of the documentation and try the examples there.

01:01:38 It's like, I don't know, it will take about 10, 15 minutes or something.

01:01:42 And that's enough to know if you like it or not.

01:01:44 That will be the main thing.

01:01:45 Like just the main page is enough to know if you like the thing or not.

01:01:49 If you don't like it then you won't like it later.

01:01:52 And then the other thing is that some people, including me, get very excited about new frameworks and new tools and jump right ahead to refactor everything with the new shiny tool that we found or something.

01:02:06 I have to tear it all down and rebuild it with this.

01:02:08 Absolutely.

01:02:08 Yeah.

01:02:09 Yeah.

01:02:09 Yeah.

01:02:09 Yeah.

01:02:10 We rebuilt it from scratch.

01:02:12 Yeah.

01:02:13 And it's normally not a very good idea because you have some tool that is already tested and it is already working.

01:02:20 And if this new thing is not really providing a very huge benefit to the thing that is already there working, it's probably not the best idea.

01:02:29 What many teams do and what I actually have done in many occasions is to add a layer of FastAPI on top of the current application, be it like, I don't know, Django REST framework, Flask or whatever.

01:02:42 And then add the new features in this FastAPI application.

01:02:45 And whenever I have to refactor something from the old application, then I just move it to FastAPI.

01:02:51 So and then I just refactor it.

01:02:52 But the thing is that FastAPI doesn't have like any compromise with database, with the specific tools that you use for security or for session management or for anything.

01:03:02 It's actually compatible with all the other tools and it's compatible with the database that you're already having and with the applications that you're already having.

01:03:09 So you can perfectly have both running at the same time and then just separate, let's say, by the path that they are hunting.

01:03:16 So everything that goes to API slash version one goes to Flask and API slash version two goes to the new FastAPI application.

01:03:23 I think that's a very good strategy that should work for many people when they want to add stuff.

01:03:28 Cool. And the mechanics of that might be in Nginx.

01:03:31 Instead of just saying pass everything to this URL, you can say pass everything to slash V1 slash to here, to this port or this socket and then the other one over there and kind of behind the scenes.

01:03:41 But at the front end, nobody knows.

01:03:43 Yeah, exactly.

01:03:44 You will do that with Nginx or Traffic.

01:03:46 I really like Traffic and I use it for a bunch of things.

01:03:48 It's also like has like automatic support for HTTPS certificates with Let's Encrypt.

01:03:54 And it just keeps them, makes sure that it's renewing them.

01:03:58 So like it's a very nice system.

01:04:00 And you can very easily say like, yeah, everything that goes to that specific path goes to one side and it'll be all the other.

01:04:06 Nginx, there's also like HAProxy.

01:04:08 And there's a bunch of others that can do the job.

01:04:11 And it's actually not that difficult to set up.

01:04:14 And it will probably save you like a lot of headaches with deadlines that are not fulfilled.

01:04:18 Right.

01:04:19 And if you don't like it, you just switch it back.

01:04:20 Yeah, exactly.

01:04:21 Exactly.

01:04:22 Yeah.

01:04:22 Cool.

01:04:23 Nevertheless, I have seen a bunch of teams that have been migrating the whole thing to FastAPI.

01:04:28 Unfortunately, they have been happy about it.

01:04:30 But yeah, I wouldn't suggest that as the main approach.

01:04:33 Sure.

01:04:34 Cool.

01:04:34 I guess it depends on the size of the project as well.

01:04:37 Yeah, of course.

01:04:37 Of course.

01:04:38 Yeah, for sure.

01:04:39 This has been another episode of Talk Python to Me.

01:04:43 Our guest on this episode was Sebastian Ramirez.

01:04:45 And it's been brought to you by Linode and Talk Python Training.

01:04:48 Start your next Python project on Linode's state-of-the-art cloud service.

01:04:53 Just visit talkpython.fm/Linode, L-I-N-O-D-E.

01:04:58 You'll automatically get a $20 credit when you create a new account.

01:05:01 Want to level up your Python?

01:05:03 If you're just getting started, try my Python Jumpstart by Building 10 Apps course.

01:05:08 Or if you're looking for something more advanced, check out our new Async course.

01:05:12 That digs into all the different types of async programming you can do in Python.

01:05:16 And of course, if you're interested in more than one of these, be sure to check out our

01:05:20 Everything Bundle.

01:05:21 It's like a subscription that never expires.

01:05:23 Be sure to subscribe to the show.

01:05:25 Open your favorite podcatcher and search for Python.

01:05:27 We should be right at the top.

01:05:28 You can also find the iTunes feed at /itunes.

01:05:32 The Google Play feed at /play.

01:05:33 And the direct RSS feed at /rss on talkpython.fm.

01:05:37 This is your host, Michael Kennedy.

01:05:39 Thanks so much for listening.

01:05:41 I really appreciate it.

01:05:42 Now get out there and write some Python code.

01:05:44 Thank you.

01:05:44 Thank you.

01:05:45 Thank you.

01:06:04 Thank you.

