00:00:00 Algorithms underpin almost everything we do in programming and in problem solving in general.

00:00:04 Yet many of us have partial or incomplete knowledge of the most important and common ones.

00:00:09 In this episode, you'll meet Adit Bhargava, the author of The Light and Playful Grokking Algorithms, an illustrated guidebook.

00:00:16 If you struggle to understand and learn the key algorithms, this episode is for you.

00:00:21 This is Talk Python To Me, episode 82, recorded October 24th, 2016.

00:00:27 Welcome to Talk Python To Me, a weekly podcast on Python.

00:00:57 The language, the libraries, the ecosystem, and the personalities.

00:01:00 This is your host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy.

00:01:04 Keep up with the show and listen to past episodes at talkpython.fm.

00:01:08 And follow the show on Twitter via at Talk Python.

00:01:10 This episode is brought to you by Capital One and Intel.

00:01:15 Thank them both for sponsoring the show by checking out what they're offering during their segments.

00:01:19 Adit, welcome to Talk Python.

00:01:22 Thank you.

00:01:23 I'm really enjoying your book that I started reading a little while ago, Grokking Algorithms

00:01:28 with Python.

00:01:29 And I think we're going to have a great time talking about it.

00:01:31 But before we do, tell us your story.

00:01:33 How did you get into programming in Python?

00:01:34 Well, I think I have a slightly atypical route.

00:01:38 Because I got into programming with this thing called Thing Maker.

00:01:43 I don't know if anyone remembers this.

00:01:46 It was, you know, back in the day, WWE had put it out, like the World Wrestling Entertainment

00:01:53 guys.

00:01:54 Okay.

00:01:55 Yeah.

00:01:55 And it was just a simple way to, like, make little games or, you know, make a website.

00:02:00 And I started playing around with that.

00:02:03 And then I thought, you know, I would love to make my own games.

00:02:06 And then I started playing with Flash.

00:02:08 So now you know how old the story is.

00:02:11 Yep.

00:02:12 Flash was probably new and exciting at the time.

00:02:14 It was.

00:02:16 And, like, it wasn't even owned by Adobe.

00:02:18 It was owned by Macromedia.

00:02:20 And Macromedia Director was a big thing.

00:02:24 Anyway, so I, like, started, you know, started with ActionScript.

00:02:27 And I sold a game.

00:02:29 And that's when I thought, you know, I could do programming.

00:02:32 This is really fun.

00:02:33 Oh, yeah.

00:02:34 That's cool.

00:02:34 So that's a ways away from Python.

00:02:37 How did you get over to the Python world?

00:02:39 Eventually, I was, like, because I had learned C, C++, kind of the standard route that a lot

00:02:45 of people take.

00:02:45 And I just wanted to get back to those Flash days when, you know, I mean, to me, I would

00:02:54 rather work with a simple language that can execute my ideas.

00:02:58 And that's when I found Python.

00:03:01 And it was so easy to use.

00:03:03 You know, it's like you can think about something and type it out as you're thinking about it.

00:03:09 Yeah, that's cool.

00:03:09 It's like programming is fun again, right?

00:03:11 Yeah.

00:03:12 Exactly.

00:03:13 It reminds me of that XKCD Python.

00:03:15 All right.

00:03:17 Well, that's excellent.

00:03:18 Did you go to a university and do a computer science degree?

00:03:21 I actually did my undergrad in graphic design.

00:03:25 Okay.

00:03:26 Because, you know, I mean, I love drawing.

00:03:29 It's been a hobby for me for a long time.

00:03:31 And then I worked as a designer for a while.

00:03:35 But I realized that I would enjoy programming more as a job.

00:03:40 So then I went to UChicago and got a master's in computer science.

00:03:45 Okay, cool.

00:03:46 Yeah, I guess that makes a lot of sense.

00:03:47 Like the illustrated part of your book, which we're going to get to, which is very cool.

00:03:52 You know, there's a lot of things you can learn.

00:03:54 You can just self-teach yourself about programming.

00:03:58 You know, there's a lot of good boot camps.

00:04:00 There's a lot of good online classes.

00:04:01 Things like that.

00:04:02 But I do feel one of the shortcomings of that type of education really is around the proper use of data structures and algorithms.

00:04:12 And not necessarily being able to write them, but knowing sort of the trade-offs, right?

00:04:17 Yeah, exactly.

00:04:18 You decided to solve that problem.

00:04:19 And you took your graphic arts skills and applied them, not just your programming skills, but your graphic arts skills,

00:04:26 and applied them to this problem with this book you wrote called Grokking Algorithms,

00:04:31 an illustrated guide for programmers and other curious people.

00:04:34 Yeah.

00:04:36 So I read your book, a good portion of it.

00:04:39 I find it delightful.

00:04:40 I think it is really, really nice.

00:04:43 You know, there's a lot of these concepts that if I remember reading algorithm-type books,

00:04:48 and it's just, you know, you're about to fall asleep.

00:04:51 It's just so dense and so hard to make it real, right?

00:04:55 It's like, I don't know, it's just tough to grok them, I guess, right?

00:04:59 And your book is filled with playful examples and fun pictures and things like that, right?

00:05:05 What was inspiration for that?

00:05:07 This whole thing started because I wrote a blog post on Haskell, and it's this blog post about monads, which is a tough concept for a lot of people to understand.

00:05:18 The post got really popular, and still, you know, to this day, I see it being tweeted.

00:05:25 That's when, you know, I was like, you know, using pictures can really make a big difference

00:05:30 when you're trying to explain hard concepts.

00:05:32 So that's where I started with the book.

00:05:36 It was like, I would love to do, because I've always known I would love to do a book on algorithms.

00:05:41 Like you said, there's all the ones that I've read so far are so hard to read,

00:05:46 and I had a very good algorithms professor at Chicago, and she made things so easy.

00:05:53 So, you know, that's when I thought it would be great to have a book that makes it as easy as she made it for me.

00:06:00 And it just, you know, it just seemed like a good fit.

00:06:03 You started your blog at audit.io, and I'll be sure to link to that, right?

00:06:09 And you started doing these visual sort of explanation posts.

00:06:12 Yeah.

00:06:13 Did like, so this book is published by Manning, is that right?

00:06:16 Yes.

00:06:16 Yeah, so did Manning reach out to you and go, hey, this illustrated idea is really cool,

00:06:21 or did you approach him and say, I'd like to do something more torturous to myself?

00:06:26 No.

00:06:27 They reached out to me.

00:06:29 It was just the craziest.

00:06:30 After that, I kind of joked, like, this is how I get success.

00:06:34 I just sit back and wait for people to come to me.

00:06:38 There's a lesson there, though, I think, and that's really cool to hear.

00:06:41 I think there's a really important lesson there that you don't know what opportunities are out there or how they're going to come to you.

00:06:49 But if you don't ever put yourself out there and you don't try to do things in public, they're absolutely not going to come, right?

00:06:56 Like, there's so many opportunities have come to me from because of the podcast, but I never even imagined that they would.

00:07:01 I wasn't looking for them, and I didn't do the podcast for them or anything like that.

00:07:05 But just, like you said, being out there makes a big difference.

00:07:08 I agree.

00:07:09 And I put in so much work into those blog posts.

00:07:12 Like, it used to take me weeks to write a single post.

00:07:16 And it's kind of like just throwing a note in a bottle, right?

00:07:20 Like, you don't know if anyone's even reading it or even cares.

00:07:25 But somehow, you know, I mean, I enjoyed it.

00:07:28 That's why I kept doing it, and things just worked out.

00:07:31 So your book on algorithms is written in Python, and you could have chosen many languages, Java, JavaScript, and so on.

00:07:38 Why Python?

00:07:39 It's just the easiest language for me.

00:07:41 It's the easiest to learn.

00:07:43 I used to teach a course on Python, and it was just people picked it up so quickly.

00:07:48 Yeah, I totally agree with that.

00:07:50 You know, I was thinking earlier as you were talking about you want to get back to the ActionScript days and things that are easy.

00:07:57 A lot of people know JavaScript, but I feel like JavaScript has, by way of its popularity, become hard again.

00:08:03 You know, like all the Node.js dependencies, all the layers piled on top of it.

00:08:10 Somehow, Python has managed to avoid that fate, which keeps it simple but powerful.

00:08:14 I think it's great.

00:08:14 I'm constantly confused by JavaScript.

00:08:17 I think it's a...

00:08:18 I love JavaScript because it has a lot of those functional parts that I really like.

00:08:24 But yeah, the JavaScript community is moving so fast, it's hard to keep up.

00:08:28 Yeah, for sure.

00:08:30 So one thing that you said when you were talking in the preface of your book, you said that for everything that you describe, you like to lead with examples.

00:08:39 Yes.

00:08:41 Well, so this is part of my...

00:08:44 I mean, I have this, you know, some ideas about like what it means to teach something well.

00:08:49 And I think one big piece of that is you have to make things concrete.

00:08:55 I'm reading this book on probability right now.

00:08:58 And one thing that really frustrates me about this book is they'll start with a simple problem.

00:09:05 So they'll say, you know, for example, one of the problems in the book is this classic random walk idea.

00:09:11 So you have a man standing at the edge of a cliff.

00:09:15 And there's a one-third chance that he'll step towards the cliff.

00:09:19 And there's a two-third chance that he'll step away from the cliff.

00:09:23 And he's drunk, so he doesn't know which direction he's going to step in.

00:09:27 So, of course, if he takes a step towards the cliff, he's just going to fall off.

00:09:30 But there's a two-third chance he'll step away.

00:09:32 And, you know, again, there's a one-third chance that he'll step towards, two-thirds that he'll step away.

00:09:36 So the question is, does he escape the cliff or does he eventually fall off?

00:09:42 So a pretty good probability problem, you know, because it's simple to state and pretty hard to solve.

00:09:50 But then I read their answer in the back and they're like, okay, let's generalize this problem.

00:09:55 And let's say X is the probability of him stepping towards and Y is the probability of stepping away.

00:10:02 And I was like, no, you have concrete numbers.

00:10:05 Isn't it so much better to be able to visualize the problem as you're stepping through it?

00:10:10 And the only way to do that is by having a concrete example.

00:10:13 Yeah.

00:10:13 Yeah, I agree.

00:10:14 I feel like a lot of things, the concreteness of it and sort of the reason the whole thing came to be interesting in the first place gets, it kind of gets sterilized and all that stuff gets lost.

00:10:27 And you're down to just the essence of the abstract problem.

00:10:30 But then the joy of the problem is kind of gone in some ways, right?

00:10:33 So I really like that you have examples.

00:10:35 And these are like really playful examples.

00:10:38 I think it's important to start with making things concrete and then you can get into the theory and the abstract and so on.

00:10:45 Yeah.

00:10:46 I think I also try to choose pretty real world examples so people can, you know, look at the problem and think about all the different ways they could use it in their work.

00:10:57 Yeah.

00:10:57 I really like the one about Maggie and the checkout counter.

00:11:00 We'll get to that one.

00:11:01 Thank you.

00:11:03 So I have a pretty diverse listenership and people, a lot of people have, you know, PhDs in computer science, but a lot of people have come from different areas.

00:11:12 So just real quickly, what, tell us, what's an algorithm for those of us who don't know?

00:11:16 An algorithm is a set of instructions for accomplishing a task.

00:11:20 So really any piece of code could be an algorithm, right?

00:11:24 But there are certain pieces that are more interesting, maybe because they solve a hard problem really well, or maybe they can be used at a lot of different places.

00:11:35 So that's really what we talk about when we say algorithms, you know.

00:11:40 Yeah.

00:11:40 Okay.

00:11:40 I totally agree.

00:11:41 I think it's the reusability is definitely an interesting part.

00:11:44 Like the way you might log something to disk might be an algorithm, but it's not reusable in any way because it's exactly specific to a thing.

00:11:51 So you wouldn't call it an algorithm per se, right?

00:11:54 Yeah.

00:11:54 Cool.

00:11:55 All right.

00:11:56 So in your book, you broke it down to, like you said, there's going to be two major things that you learned.

00:12:00 One, you said you're going to learn about performance and the other, you're going to learn about solving problems.

00:12:05 How's that work?

00:12:06 The solving problems one is the really big one that I focused on.

00:12:11 Back when I was starting out, I just used to run into walls sometimes where you like come across a problem and you just don't know how you're going to solve it because you've never solved a problem like that before.

00:12:23 Or you don't really have a lot of tools in your tool belt.

00:12:28 So you can't say like, oh, maybe I'll use a hash table for this and see if that works.

00:12:33 Or maybe I should try to use some kind of a machine learning approach.

00:12:38 If you, you know, there's this idea of you don't know what you don't know.

00:12:44 And if you don't know that those tools exist, you're just stuck.

00:12:47 You can't solve those problems.

00:12:48 So this book is really about giving you all those tools like that should be able to solve most of the problems you encounter day to day.

00:12:58 Yeah, that's really cool.

00:12:59 And some of the examples you give are like, if you're making a video game, you could learn how to create an AI system that can find its way through pass or a recommendation system kind of like Amazon.

00:13:10 So that you might like, or even things that knowing that there are problems that are basically not solvable in a quick way.

00:13:18 Yeah, those NP complete problems.

00:13:21 Yeah, yeah.

00:13:21 That's a whole different interesting area.

00:13:23 I think performance is also interesting.

00:13:26 I mean, you talked about hash tables just a minute ago and dictionaries.

00:13:31 Like, knowing that if I have this type of thing I need to do, it's 100 times faster using this data structure than that data structure and being able to express that.

00:13:42 It helps you design how you solve a problem.

00:13:45 If you're like, you know, if I can coerce it into this shape, it will be rocket fast.

00:13:50 Absolutely.

00:13:51 That's something, to me, that is really about the craft of engineering.

00:13:56 One reason I love Python is you can write beautiful code with it.

00:14:02 And I think thinking about performance is just another aspect of that craft where you like, you know, you want to write something that runs well, that's dependable.

00:14:13 And that means it should run as fast as it can run.

00:14:16 Yeah.

00:14:16 Yeah, up to the point where it becomes, like, you can optimize something so much that it becomes write only.

00:14:25 Like, you wrote it and it works, but you can't understand it and nobody else can certainly understand it, right?

00:14:29 Oh, yeah.

00:14:29 So there has to be this tradeoff of maintainability.

00:14:33 But, yeah, knowing the data structure definitely is the right in algorithms and how that works in terms of performance is key.

00:14:41 So the algorithms, your algorithm book is not, like, comprehensive.

00:14:45 It's not like an encyclopedia of all known algorithms or anything like that, right?

00:14:51 It's more a special list.

00:14:55 You said the topics that you cover are all things you've used at work, which is pretty cool.

00:15:00 Exactly.

00:15:01 I think if you're looking for an encyclopedia, like, you could just read the Wikipedia articles or, like, one of those algorithms books that are, like, a thousand pages long.

00:15:10 You know, I didn't want to, I didn't want my book to be, like, we printed out Wikipedia and bound it into a book format.

00:15:18 Yeah.

00:15:18 Thank you for not doing that.

00:15:21 So we're going to talk in depth about some of the algorithms and stuff.

00:15:25 But can you just give us, like, a quick flyover of what's covered and things like that?

00:15:30 Sure.

00:15:30 So the first part of the book is, like, foundational work that I'll be using in the rest of the book.

00:15:37 So chapter one introduces you to a very basic algorithm and then talks about big O notation, which is something a lot of people get very confused by.

00:15:47 But it's an important concept.

00:15:49 And then chapters, chapter two is about memory.

00:15:53 Chapter three is about recursion.

00:15:55 So you can see I'm kind of building the foundation, like, the very basics.

00:15:59 And then we get into the interesting stuff.

00:16:02 So, like, chapter four, this is where I introduce one of those tools that I was talking about called divide and conquer, where, you know, you get a problem.

00:16:12 I don't know how to solve this.

00:16:14 Well, you could think, like, maybe I'll use divide and conquer and see if that works.

00:16:18 Chapter five is hash tables, which is the most useful tool in my tool belt.

00:16:25 I totally agree with you.

00:16:26 Yeah, you had a good quote.

00:16:27 You said, when I want to solve a problem, there are two planes of attack I start with.

00:16:31 Like, can I make this hash table problem?

00:16:34 Can I solve it with a graph, maybe?

00:16:36 One of those two, right?

00:16:37 Exactly.

00:16:37 I feel like, I mean, this is kind of a secret tip.

00:16:42 But when I get into an interview and someone gives me a problem, I immediately just think hash tables or graphs.

00:16:50 And it works, like, 90% of the time, you know.

00:16:54 Nice.

00:16:55 So, yeah, obviously, I think graphs are really important.

00:16:57 So chapter six and seven are graphs, another very useful tool.

00:17:02 Chapter eight is another good tool, and it's so easy.

00:17:06 Like, this might be the easiest chapter in the book, because chapter eight is really, like, do the dumbest thing you can think of, and it'll probably work.

00:17:17 And that's what a greedy algorithm is.

00:17:20 Yeah.

00:17:21 Sometimes, you know, computers are fast.

00:17:22 Sometimes the problems aren't that big.

00:17:24 Just solve it simply, right?

00:17:26 Exactly.

00:17:27 Chapter nine is probably the one I'm most proud of and the one that people have complimented me the most on,

00:17:36 because it's dynamic programming, and it is this really hard way to solve things.

00:17:42 That's not the same as programming with a dynamic language versus static languages.

00:17:47 It's something different, right?

00:17:48 Yeah.

00:17:49 It's all about creating this 2D array and splitting a problem up into sub-problems and then using those solutions for those sub-problems for the bigger problem.

00:17:59 It kind of, I feel like it just blows people's minds.

00:18:03 It's just so hard to use.

00:18:04 I mean, I spent maybe three or four months on this chapter alone, and I think it's really well-written, and a lot of people have found it very useful.

00:18:15 So that's chapter nine.

00:18:16 And then chapter 10, I just wanted to put a little thing about machine learning in here, because key nearest neighbors is so easy to use, and it's so effective.

00:18:29 And it was just, you know, you could read this chapter before bed, and you would know how to build a recommendations engine.

00:18:35 Oh, that's great.

00:18:35 That's really cool.

00:18:36 Yeah.

00:18:37 And then you finish out with saying, basically, now that you're inspired, you know the foundational algorithms.

00:18:43 Here's a whole bunch more things you can go do, right?

00:18:45 Yeah.

00:18:46 And then there's 10 things in chapter 11 that I think are really neat, and they're just, oh, I wish I could have put all 10 of these in the book also, but I just gave a little tidbit about each one.

00:19:01 Sure.

00:19:02 That'll be the follow-on, the second version.

00:19:06 Yeah.

00:19:06 Yeah.

00:19:06 So one thing that I liked about your book is you have little short exercises, like a couple minutes, two or three minutes at the end of each section, each chapter, that you can do to sort of test your thinking.

00:19:19 And I found those to be really nice.

00:19:20 Thank you.

00:19:21 I've been reading this book called A Book of Abstract Algebra, and it's got a great model where all the chapters are like two pages followed by six pages of exercises.

00:19:32 I found that those exercises helped me so much, so I figured, you know, I need to put more exercises in my book.

00:19:38 So who did you have in mind?

00:19:40 Like, if I have no programming or very little program experience, would this book be useful?

00:19:45 If I had a computer science degree, would it still be useful?

00:19:47 So it's been really popular with boot camp students so far.

00:19:52 I have a few friends who went to boot camps, and, you know, I have a friend who's in a boot camp right now, and he kind of told other students in the camp,

00:20:02 about it, and they all seem to like it.

00:20:06 I think it's also useful for people who have a computer science degree.

00:20:13 So I work at Etsy, and I kind of, you know, just sent an email out when the book came out saying, like, hey, I've published a book.

00:20:19 You know, isn't that cool?

00:20:22 And I've had people email me, like, really senior people, you know, people who are, like, two levels above me at Etsy.

00:20:30 And they're like, wow, I, finally I have great examples to explain these concepts with.

00:20:37 Because it's so hard to come up with a good example to explain something.

00:20:41 Yeah, absolutely.

00:20:41 It's one thing to know it.

00:20:42 It's another to teach it to another person.

00:20:45 And I think it is really, I think it's really accessible in that way.

00:20:49 Thank you.

00:20:49 It also doesn't require a lot of math, which I like.

00:20:52 You know, you don't need calculus or linear algebra or anything.

00:20:57 It's really, like, if you know the basics of algebra, like, if you know what a function is, you can read this book.

00:21:05 Yeah.

00:21:06 I like that you said that.

00:21:07 You know, I was talking to a friend of mine about sort of what does it take to become a programmer?

00:21:12 Like, how much math do you need to know?

00:21:15 And I think there's an outside of the programming field, like, people who are not programmers,

00:21:20 I feel like programming is very, very mathematical, right?

00:21:24 Like, if you don't know how to do calculus and differential equations, you'll never be a good programmer.

00:21:29 And to be honest, I find I do very little actual advanced math in anything that I do,

00:21:34 except for when I was working for, like, a scientific visualization company.

00:21:38 But outside of that context, like, it's more just knowing, like, critical thinking and problem solving.

00:21:43 And so I think that they give people feel like they need to learn a lot of math.

00:21:47 I mean, math is not a bad thing, but I don't think it's required.

00:21:50 Do you?

00:21:51 I don't think it's required either.

00:21:53 I think, especially for something like this, where, like, algorithms are the first step to, like, long journey in computer science.

00:22:02 And that first step should be as easy as possible.

00:22:06 There shouldn't be, like, big hurdles to get to that first step.

00:22:10 Yeah, totally agree.

00:22:11 Totally agree.

00:22:12 Okay, cool.

00:22:13 So let's talk about some of the algorithms and some of the things that you covered in the book.

00:22:18 The very first one that you covered was sort of different types of searching in sets and really leading towards binary search.

00:22:28 Yeah.

00:22:28 This is my favorite algorithms example because anyone can understand it.

00:22:36 Like, you don't even need to know anything about computers.

00:22:42 But because a lot of people, you know, when they heard I'm writing a book, they were like, tell me what is an algorithm.

00:22:48 So I gave them this example where I was like, you know, think of a, I'm thinking of a number between 1 and 100.

00:22:56 Take a guess.

00:22:56 And they would say, you know, 55.

00:22:58 And I'd say, well, that's too high.

00:23:02 Take another guess.

00:23:03 And they'd say 30.

00:23:04 And that's interesting because people automatically divide the space in half when they guess, almost on instinct.

00:23:13 Like, maybe they don't even understand what they're doing, but they're running binary search in their mind.

00:23:20 You know, that's all binary search is.

00:23:21 Divide the space in half every time to get to the results or to find the result as quickly as you can.

00:23:27 Yeah, it's such a simple example.

00:23:28 And yet I think it really dramatically points out the power of taking that, formalizing it just a little bit and making it really fast.

00:23:38 Capital One has a special message for you.

00:23:55 They need Python pros who love to work with data.

00:23:57 Put your Python experience at work at Capital One and help them use data to make life better for millions of customers.

00:24:03 Capital One is employing the latest tools and approaches to do data analytics and data science

00:24:08 from the ground up.

00:24:09 They're smart, creative professionals who love to explore new ways to interact with data.

00:24:13 They're interested in figuring out novel, advanced Python techniques, and even more interested in finding more people who will help them do that.

00:24:20 When you join their state-of-the-art Python community, you'll work with people you really like,

00:24:24 people who might be listening to this podcast right now.

00:24:26 Relentless innovation is their way of life.

00:24:28 Make it yours at Capital One.

00:24:30 Visit jobs.capitalone.com slash talkpython to learn more and apply today.

00:24:37 You had a cool example.

00:24:41 You said, you know, imagine that you play this.

00:24:44 You have a couple of ways which you could do it.

00:24:47 Like you could just say like, I've got a list of 100 things and you want to search for something in there.

00:24:52 Right?

00:24:53 Kind of like the example you just gave.

00:24:55 One option is to look at the first one, check it next one.

00:25:00 Just go through it in order, right?

00:25:02 Another way is to apply this binary search thing, assuming that set is somehow ordered like an address book or something.

00:25:08 And you said, well, for 100 items, if you go straight through it, you know, worst case, you'll have to go,

00:25:13 you'll search until you get to the end.

00:25:14 That's 100.

00:25:15 But if you use the binary search because you half it and half it and half it, worst case scenario, you get seven.

00:25:20 But then you said, well, let's think about it, four billion.

00:25:23 Yeah.

00:25:24 And it's so crazy because now the difference, you know, now it's really obvious.

00:25:29 Like for searching through four billion items is too much.

00:25:33 But with binary search, it's just 32.

00:25:36 Maximum of 32 guesses, right?

00:25:39 Even if it's I'm guessing between a number between zero and four billion.

00:25:42 Yeah.

00:25:43 Isn't that such a huge difference?

00:25:45 Yeah.

00:25:46 It's it's insane.

00:25:47 I mean, it makes sense.

00:25:50 But at the same time, you don't think such a simple idea is going to reduce it from four

00:25:55 billion comparisons to 32 at worst case.

00:25:58 Yeah.

00:25:58 It's really amazing.

00:25:59 Yeah.

00:26:00 Yeah.

00:26:00 So one of the things I think is hard for people who have not gone through a formal computer science

00:26:06 background and just for everybody listening, I don't have a computer science degree, but

00:26:09 I have a minor in computer science.

00:26:11 So I've gone through some of it.

00:26:12 So I guess I'm somewhere in the middle of this.

00:26:13 But if you are self-taught, if you've gone to a boot camp or if you're just really new,

00:26:19 people often talk about big O notation around performance of algorithms.

00:26:24 And I think that that's kind of mysterious to people.

00:26:27 And it also seems to be something that ends up on job interviews often.

00:26:32 And so if you don't have that experience, you're like, I don't even know what big O is.

00:26:36 Like, well, sorry, you're out or something, right?

00:26:40 Like it can be a bigger problem than it maybe really deserves to be.

00:26:45 But I think it's worth knowing big O notation for a couple reasons.

00:26:48 Yeah.

00:26:49 Dude, this was a really good way for you to introduce that concept, I thought.

00:26:52 Like, pretty crazy, right?

00:26:53 Yeah, exactly.

00:26:55 And I won't, you know, get into the full explanation here.

00:26:59 But I do want to say, I think every beginner engineer I meet has trouble with big O notation.

00:27:06 So, you know, if some of your listeners are still new to engineering, just to say, like, that's not just you.

00:27:14 Don't feel that.

00:27:15 That's right.

00:27:15 Yeah.

00:27:16 But that's why I, you know, it's right up front in the book.

00:27:20 And then I talk about it again in chapter four.

00:27:24 So, I spend a lot of time trying to explain big O notation in this book.

00:27:29 Yeah, absolutely.

00:27:31 So, I think it's pretty interesting.

00:27:33 You've got the linear search, which is what they call O of N.

00:27:38 So, as if you have N items, you have to do N comparisons.

00:27:41 If you have two N items, you have to do two N comparisons.

00:27:44 It grows basically linearly.

00:27:45 But this binary search one is log of N, which doesn't sound like that big of a difference.

00:27:52 So, you realize it's 4 billion versus 32.

00:27:54 You know?

00:27:55 Which is pretty amazing.

00:27:57 So, knowing this relative scale, that doesn't actually tell you how fast it is, does it?

00:28:03 That just tells you, like, relatively how much slower does it get as you get more data.

00:28:08 Exactly.

00:28:09 Because everyone's computer, you know, calculates at a different speed.

00:28:12 So, you can't put a time on it.

00:28:15 Yeah.

00:28:15 And that becomes interesting later when you find algorithms that are actually look worse in big O, but often they're not.

00:28:24 And so, you talked about this idea of average time versus worst case time.

00:28:29 I think that's also important to understand.

00:28:32 Yeah.

00:28:33 That's another really interesting one where, you know, if you can say that your algorithm is going to take a short time on average and a really long time, worst case, maybe that's fine.

00:28:48 And, you know, if you're just a website or, you know, you have a basic consumer app and you're like, well, it'll run fast most of the time.

00:28:56 So, that's fine.

00:28:57 If you're NASA and you have to guarantee a certain time, then you really care about that worst case time also.

00:29:05 Yeah.

00:29:05 Any real-time system.

00:29:07 So, if you were doing like a flight control system on a spaceship or if you're doing trading in some sort of high-speed trading system or I worked on a system that would actually analyze eye tracking data in real time.

00:29:22 And it would get 250 samples per second.

00:29:25 And if it couldn't process using some very advanced sort of wavelet decomposition algorithms and whatnot.

00:29:32 If you couldn't process that in, you know, four milliseconds.

00:29:35 Well, then it just couldn't keep up because that was how fast data was coming, right?

00:29:39 I mean, there's these situations where worst case time maybe is super important.

00:29:44 But a lot of times, like you said, average time I think is fine.

00:29:47 So, give us some, like for some algorithms that we might know, give us a big O performance stats.

00:29:54 Sure.

00:29:55 So, binary search, we already talked about log N and searching, you know, linear search, looking at one item at a time is big O of N.

00:30:06 And like we just talked about, that's a big difference, right?

00:30:10 Log N versus N.

00:30:11 So, again, if you think about that, a slow sorting algorithm is N squared.

00:30:17 And my example is selection sort.

00:30:20 A fast sorting algorithm is going to be N log N.

00:30:23 So, again, you have that log N versus N difference.

00:30:27 So, the fast sorting algorithm is much faster.

00:30:29 Yeah.

00:30:30 And after that, there's like N cubed algorithms.

00:30:34 My extreme example is you can get big O of N factorial algorithms.

00:30:42 And, you know, if people don't know what a factorial is, that's like 5 factorial would be 1 times 2 times 3 times 4 times 5.

00:30:51 6 factorial would be 1, 2, 3, 4, 5, 6.

00:30:55 Factorial grows really fast.

00:30:57 If you have an N factorial algorithm, that just means you just can't use it most of the time.

00:31:04 It only works on extremely small data sets, right?

00:31:07 Yeah.

00:31:07 Yeah.

00:31:07 So, the example, probably the canonical example for that is the traveling salesperson problem.

00:31:12 Yep.

00:31:13 And this is one of those NP complete problems we have talked about where, you know, the problem is really simple.

00:31:20 You're a traveling salesman and you have a list of cities that you want to travel to.

00:31:27 And you want to figure out the shortest route that hits all of those cities.

00:31:31 So, it just seems so simple.

00:31:34 Like, you know, why couldn't you calculate that?

00:31:37 And, of course, you can.

00:31:38 It means that you have to come up with every permutation of cities, of the order of cities.

00:31:45 Which, if you have 6 cities, it's 6 factorial permutations.

00:31:50 If you have 100 cities, it's 100 factorial permutations.

00:31:56 And just to give you an example of how crazy that is, 6 factorial is 720, which, you know, your computer can do.

00:32:05 100 factorial is 9 followed by 157 zeros.

00:32:12 Wow.

00:32:14 Yeah.

00:32:15 That means you're going to run out of time or you're going to run out of memory.

00:32:19 One of those first.

00:32:20 But you're probably going to run out of something, right?

00:32:21 Yeah.

00:32:22 I think the universe will end before you can make that.

00:32:26 Absolutely.

00:32:28 All right.

00:32:29 So, the next thing that you talked about that I thought was cool was selection sort.

00:32:33 And you took a moment to say, like, let's think about the two data structures that hold stuff in just like a list style.

00:32:44 And that was linked lists and arrays.

00:32:46 And I thought that was a really interesting tradeoff, knowing how you're going to use them and so on.

00:32:52 So, tell us about that comparison you made.

00:32:54 Sure.

00:32:55 So, the example I use in the book is this idea of, you know, you're going to watch a movie.

00:33:01 And let's say you're going there.

00:33:04 There's eight of you.

00:33:05 Eight people are going.

00:33:06 And you're trying to find seats.

00:33:08 So, maybe you can find eight seats all together and then you can all sit together.

00:33:14 Maybe there's no set of eight seats together.

00:33:17 So, you have to kind of sit all over the theater.

00:33:21 And you know where each other, you know where your group is, but they're not all in one place.

00:33:27 And that's this idea of linked lists versus arrays.

00:33:30 Where arrays, you're all sitting together.

00:33:33 Link lists, you're all sitting separately.

00:33:37 You know, your data is together in memory or apart.

00:33:40 So, with arrays, you basically have a contiguous block.

00:33:43 Exactly.

00:33:44 And with linked lists, each element knows how to find the next element.

00:33:50 Sometimes you have doubly linked lists.

00:33:51 So, you can start at the back and go forward or forwards and go backwards.

00:33:53 But each element is more or less in charge of going to a new memory location to find the next or be in the end.

00:33:59 Exactly.

00:34:00 And if I could stretch this movie analogy a little bit.

00:34:04 Let's say, you know, you have a bag of popcorn.

00:34:07 And you're kind of passing it down the row.

00:34:10 Really easy to do if you're all sitting together, right?

00:34:13 Because you can just, you know, the next person is just to your right.

00:34:17 And you just keep passing the bag to your right.

00:34:19 And that's what arrays are.

00:34:23 So, it's really easy to access the next element in an array.

00:34:27 And it's easy to say, like, you know, I want to find the fifth item in my array.

00:34:35 Because every once together, you can just do the math.

00:34:38 Like, zero plus five equals five.

00:34:40 Linked list, it's like, now you're passing this bag of popcorn around.

00:34:45 You have to go to the next person in the movie theater.

00:34:47 And then they have to go to the next person.

00:34:49 It's a little more arduous.

00:34:51 And if you want to find the fifth person, you can't just go directly to that person.

00:34:56 You have to go to the first one.

00:34:58 And the first one has to go to the second one.

00:34:59 Second one has to go to the third one.

00:35:01 So, you have to, like, follow these links down.

00:35:04 Yeah, that makes perfect sense.

00:35:06 So, I mostly, if I think of the data structures I use, I mostly use arrays.

00:35:11 So, lists.

00:35:12 And dictionaries.

00:35:14 And then sometimes I want distinct stuff.

00:35:16 So, sets.

00:35:16 I don't find myself using linked lists so often.

00:35:19 But they do have some interesting trade-offs.

00:35:22 Like, when is an array good versus when is a linked list good?

00:35:25 So, again, going back to this movie example.

00:35:28 Sometimes you go to the theater and you just don't have eight seats together, right?

00:35:34 Like, sometimes you just can't fit an array in memory because you don't have, you know,

00:35:41 if your array, if the array you want to create is too big, you just don't have space for it.

00:35:46 Or, what can be bad also is, let's say, eight of you sits down at the theater and you found

00:35:55 eight seats, everything's great, and now another person shows up.

00:35:59 So, now you have nine people.

00:36:00 But there's no space for a ninth person.

00:36:04 So, now you have to all get up and go around trying to find that ninth seat.

00:36:10 So, you know, similarly, when you want to add elements to an array, let's say you allocated

00:36:16 memory for 100 elements.

00:36:17 And now you want to increase the size of your array to 200.

00:36:21 Well, it's going to be a lot of work to move those, all those items to a different part of

00:36:27 memory.

00:36:27 You know, that's bad performance set.

00:36:31 Right.

00:36:31 If you have a linked list.

00:36:32 Or if I want to insert one in the middle, something like that, right?

00:36:35 Exactly.

00:36:35 Like, it's hard to move all those items.

00:36:38 But for the linked list, you can just put them somewhere and just change the links around.

00:36:42 Yeah.

00:36:43 So, you talked about the big O performance of both of those.

00:36:47 And basically, inserts for lists are O1.

00:36:51 So, constant, like super fast.

00:36:54 But, like, random access is order in, which is not so great.

00:37:00 But it's almost the reverse for arrays, right?

00:37:03 Random access is just instant, more or less.

00:37:06 But adding something grows as you have more items, right?

00:37:10 Because you've got to copy and reallocate and all that.

00:37:12 So, they're almost like counterpart, like opposites in some way from a performance tradeoff.

00:37:17 Exactly.

00:37:18 And that's kind of, you know, you hear all that and you start thinking, gosh, I wish I had something that was as good as arrays for reads and as good as link lists for inserts.

00:37:31 And that's when you start getting into, like, the more complex data structures.

00:37:36 Right.

00:37:36 Absolutely.

00:37:37 So, another thing that you covered that I recall, like, this has burnt a spot into my brain from when I learned it is recursion.

00:37:47 And I just remember recursion, like, blowing my mind when I first thought of problem solving with recursion.

00:37:53 Oh, my gosh.

00:37:54 Yeah.

00:37:54 This is another one that's so hard for people to start thinking about it because it's just, you know, a function calling itself.

00:38:05 That just seems crazy.

00:38:07 But that's why I have a lot of examples about recursion and I have a lot of exercises.

00:38:13 And I kind of try to break it down so people understand the structure of a recursive solution.

00:38:21 Even if you never plan to use recursion in a problem, there are plenty of algorithms that other people have created that use recursion.

00:38:30 So, if you want to understand those algorithms, you need to know what recursion is.

00:38:35 Yeah, absolutely.

00:38:36 And there are times when you can solve a problem without recursion.

00:38:39 But the data you're trying to understand is so perfectly lined up for recursion that the solution is just dead simple.

00:38:47 If you realize that that's something in your toolbox, right?

00:38:50 Like tree, like depth first sort of tree type processing and things like that.

00:38:54 Exactly.

00:38:54 Yeah.

00:38:55 So, one thing that you had at the beginning was this example with boxes.

00:38:59 And you have like a little box story in the attic for loops and recursions.

00:39:05 Yeah.

00:39:06 Yeah.

00:39:06 So, this was a toy example where, you know, you're going to your grandma's attic and you're looking for this key and she has so many boxes.

00:39:17 And it could be among these boxes.

00:39:19 So, you open a box and then you see more boxes inside that box.

00:39:25 So, now you can think about, you know, there's two ways you could find this key.

00:39:30 You could kind of keep this list of boxes, right?

00:39:34 So, like you open a box, you see more boxes and you just add them to your pile of boxes to check.

00:39:40 And you, the algorithm you're running is you pick up a box from the pile, look for the key.

00:39:50 If you see some boxes, you add it to the pile.

00:39:54 And until you find the key, you just grab another box from the pile and check it for the key.

00:39:59 And that's the while loop approach, right?

00:40:02 Because while you don't have the key, go to the pile, pick up a box, search for the key.

00:40:09 And the recursive approach would be open a box.

00:40:13 If there's a key, you're done.

00:40:16 If there's a box, open the box.

00:40:19 If there's a key, you're done.

00:40:21 If there's a box, open the box, you know.

00:40:23 Yeah.

00:40:24 It's got this beautiful, very simple quality to me where you can express it in two lanes.

00:40:30 Like, if key, done.

00:40:32 Else, keep going.

00:40:34 Do it again.

00:40:36 Do it again.

00:40:36 Just open the box and see if there's a key in it.

00:40:39 Yeah, it's got this very natural way of solving the problem, doesn't it?

00:40:42 That's cool.

00:40:42 Yeah.

00:40:43 We all love Python for its tremendous productivity benefits.

00:41:01 But getting the best performance takes some work.

00:41:03 What if you could get out of the box, easy access to high-performance Python?

00:41:08 Intel distribution for Python developers delivers just that.

00:41:11 Get close to 100 times better performance for certain functions when using NumPy, SciPy,

00:41:16 scikit-learn, linked with optimized native libraries like Intel Math Kernel Library,

00:41:21 access-efficient multi-threading, and Python projects like Numba and Scithon.

00:41:25 Try the Intel distribution for Python and experience performance today at talkpython.fm/Intel.

00:41:31 And profile your Python and native C, C++ applications for performance hotspots with Intel VTune amplifier.

00:41:39 With Intel, it's all about performance.

00:41:49 I like how you've got some nice pictures and the pictures are even simpler.

00:41:53 It just feels really great.

00:41:56 The other thing that was interesting was in your first example, you talked about having this list of boxes.

00:42:04 And you put the stuff in the list and you take the stuff out of the list.

00:42:07 In the recursion example, you don't have anything that is the storage of where you are or what box you're working on or anything like that.

00:42:16 Like, how do you keep track of the boxes?

00:42:18 So that's a really interesting part of recursion, where you're kind of making the computer do the work for you, right?

00:42:27 Because you call, let's say you call the look for key function.

00:42:32 So you've called it once, and the computer has that, you know, that information noted.

00:42:39 Like, okay, he's called look for key once.

00:42:42 And then you call it again inside look for key.

00:42:45 So the computer says, okay, that's the second call to the look for key function.

00:42:51 And then you call it again, and it says, okay, that's the third call.

00:42:55 So it's kind of keeping track of those calls for you.

00:42:58 And those function calls is your array, basically.

00:43:03 You're keeping track of all the boxes you have to check through that array of function calls.

00:43:10 But the computer is doing it all for you behind the scenes.

00:43:13 You don't even have to think about it.

00:43:14 Yeah, absolutely.

00:43:15 It's just, it's the way programs execute, right?

00:43:18 And you're just taking advantage of that.

00:43:20 It lines that up for you.

00:43:21 That's cool.

00:43:22 So this whole recursion thing is more or less, is very good at solving this kind of divide and conquer inductive problem.

00:43:30 If you can talk about some kind of base case, and you can talk about, well, how do I take like one step away from there?

00:43:38 You can probably apply recursion.

00:43:39 Yep.

00:43:40 I'm reading this book called How to Solve It, which is a famous math book about like solving hard problems.

00:43:47 And I love one of the parts in this book.

00:43:50 He says, if you come across a problem you can't solve, change it into a problem that you can solve and solve that problem instead.

00:43:59 I mean, that's so easy.

00:44:00 And that's the same thing with divide and conquer, where it's really hard to solve this problem.

00:44:05 But I'm going to just take it down to the smallest component that I can solve and use the solution for that to solve this bigger problem.

00:44:14 Yeah.

00:44:15 It kind of gives you a foothold on climbing the solution or whatever.

00:44:19 Yeah.

00:44:20 So you have two examples of divide and conquer that you gave in this area.

00:44:24 Yeah.

00:44:25 And I'm going to talk about the quick sort one because it's so elegant.

00:44:31 Yeah.

00:44:31 It's a great example of divide and conquer.

00:44:33 And again, such a simple idea.

00:44:36 You have an array of elements that you want to sort, but you don't know how to sort an array.

00:44:41 Well, what's an array you can sort?

00:44:43 How about if the array had zero elements?

00:44:46 That's pretty easy to sort.

00:44:47 It's just there's nothing to sort.

00:44:50 It's sorted.

00:44:50 It's sorted.

00:44:52 Similarly, if you have an array with one element, pretty easy.

00:44:54 If you have an array with two elements, it's still, you know, you just check which one's bigger and put it at the end.

00:45:00 So all of these are the easy examples.

00:45:03 Now you get to an array with three elements.

00:45:06 And quick sort says, just pick an element from the array.

00:45:10 So it doesn't matter which one.

00:45:13 So I'll just pick the first one.

00:45:14 So let's say your array is 5, 3, 7.

00:45:18 So I pick 5 as my, it's called the pivot element.

00:45:22 And now I look at the rest of the elements in the array.

00:45:28 So 3 and 7.

00:45:29 And I know that 3 is less than 5.

00:45:32 And I know that 7 is greater than 5.

00:45:35 So now I have these two sub-arrays, right, of elements less than the pivot and elements greater than the pivot.

00:45:42 And now I just call quick sort again on those two arrays separately.

00:45:49 So I call quick sort of this array that only has the element 3.

00:45:53 And we know how to solve, we know how to sort an array with one element.

00:45:58 It's just 3.

00:45:59 And then you have the pivot because that's the number greater, you know, we know that that's greater than 3.

00:46:06 And then you call quick sort on the second array, which has the 7.

00:46:10 And again, it's just one element, we know how to sort that.

00:46:13 So you end up with these three sub-arrays, one with just a 3, one with just a 5, and one with just a 7.

00:46:20 And you just smash them all together and you have a sorted array.

00:46:25 So using just the knowledge of how to sort an array with 0, 1, or 2 elements, you started an array with 3 elements.

00:46:33 And now that you can do that, you can sort an array with 4 or 5 elements.

00:46:36 And you can kind of sort any array you want just by solving that small problem.

00:46:41 Yeah, you just continue to break it down, even if you have a million, right?

00:46:44 Exactly.

00:46:44 Nice.

00:46:45 Yeah, quick sort is lovely.

00:46:47 And the history of quick sort is pretty interesting.

00:46:50 So another thing, the next thing in your book that you talked about is one of my favorite data structures.

00:46:57 I don't necessarily use it the most, but when I do use it, it's so awesome.

00:47:00 And that's hash tables or dictionaries, right?

00:47:02 Yeah.

00:47:03 I mean, this is one of the reasons I love JavaScript is, you know, JavaScript objects are just hash tables.

00:47:11 So hash tables are such a big part of JavaScript.

00:47:15 And it's, I mean, like I said, I feel like almost any problem, I could just, you know,

00:47:20 if I just want the quick and dirty solution, I can just do the hash table and call it done.

00:47:24 Yeah.

00:47:25 So you had a really nice example of a checkout person.

00:47:28 Oh, yeah.

00:47:29 The Maggie.

00:47:30 The Maggie.

00:47:31 Yes.

00:47:31 You need a Maggie.

00:47:32 How much is an avocado?

00:47:33 It's $1.49.

00:47:33 Thank you, Maggie.

00:47:34 Yeah.

00:47:35 Isn't, I mean, that's exactly what a hash table is, where you can either look up prices

00:47:40 in this book and it kind of takes you some time.

00:47:43 Or you just have a person there who has it all memorized.

00:47:46 And I just say, you know, it's 67 cents.

00:47:50 Thank you.

00:47:50 Maggie is my wife's name.

00:47:53 And I feel like she is so much smarter than I am.

00:47:56 So I knew I needed to make her a character in this book.

00:47:59 Oh, that's a nice touch.

00:48:01 Yeah.

00:48:03 Yeah.

00:48:03 Very cool.

00:48:03 Yeah.

00:48:04 So if people want to get a sense of like how powerful hash tables or dictionaries are,

00:48:09 I just last week wrote a search engine so people could search every single bit of content of

00:48:16 all the podcast episodes.

00:48:17 So if you go to talkpython.fm, there's like a little search thing in the top right.

00:48:22 And you can click it and you can type in complex searches and it'll find basically anything that

00:48:27 matches all those keywords.

00:48:28 And the way it works is it goes through all the transcripts.

00:48:34 It goes through all of the show notes.

00:48:36 It goes through all the titles, all those various things and a few others.

00:48:40 And it turns it into a bunch of keywords and turns that into a dictionary.

00:48:44 And then for each keyword it finds, it figures out if there's a piece that matches, you know,

00:48:51 what pieces match this keyword and it puts that in there.

00:48:53 And if you go there, you know, it's like 80 hours of conversation plus some other stuff.

00:48:58 And you can type in a keyword and hit enter and it runs in sub millisecond time, 100% in Python.

00:49:03 You know, so you, yeah, you can search for like five, finding the things that contain these five words across 80 hours of conversation, 0.1 milliseconds.

00:49:13 100% by all.

00:49:15 Beautiful.

00:49:15 I mean, that is like, think of if that was trying to, you know, regular expression, the text,

00:49:20 or it was trying to like, you know, literally search it or whatever, right?

00:49:24 Like it would be insane.

00:49:25 You just, you're like, ah, this is too slow.

00:49:27 But yeah, it's so like things like that are just so possible with dictionaries.

00:49:32 They make me happy.

00:49:33 Cool.

00:49:34 So let's talk about some of the other algorithms.

00:49:37 And we're kind of getting short on time.

00:49:38 So maybe just sort of skip over and just touch on them a bit.

00:49:41 Sure.

00:49:41 Again, chapters five and six are super useful to me, you know, hash tables and graphs.

00:49:51 And a graph is this really simple idea where you model a problem using nodes and edges.

00:49:58 So my example is, you're trying to get from Twin Peaks to the Golden Gate Bridge.

00:50:04 And this is how you can tell that I live in San Francisco.

00:50:08 And you're trying to figure out what is the least number of bus transfers I have to do to get to from Twin Peaks to the Golden Gate Bridge.

00:50:16 And so you can model that, you can model it using a graph where you have one node, which is the Golden Gate, which is Twin Peaks.

00:50:24 And then you kind of puts out edges, which are all the different bus routes you can take to the next part, to the next transfer stop.

00:50:33 And then that one puts out edges of all the buses you can take from that one to the next transfer stop and so on until you hit the Golden Gate Bridge.

00:50:43 And it's a, this is a classic, it's called the shortest path problem.

00:50:47 Another example would be, you're on Facebook and you're trying to find, you really want to talk to, I don't know, someone famous, Brad Pitt, for example.

00:50:59 And so you're trying to figure out what is the shortest number of connections to Brad Pitt?

00:51:04 Like, you know, what is the least number of people?

00:51:06 Which one of your friends could introduce you indirectly?

00:51:08 Something like this, right?

00:51:09 Exactly.

00:51:10 I mean, LinkedIn does this where they say, like, you're, you know, so many connections away from this person.

00:51:15 And it's just graphs.

00:51:17 It's a graph problem.

00:51:18 Nice.

00:51:18 Okay.

00:51:19 And then you talk about greedy algorithms and your dynamic programming.

00:51:23 Yep.

00:51:24 And again, greedy algorithms are so simple.

00:51:26 It's just do the simplest thing you can do.

00:51:31 So, you know, my example is you are a thief.

00:51:36 This is the classic knapsack problem.

00:51:38 So, you're a thief in a department store and you have a knapsack and you're trying to figure out what items can I steal to get the maximum value, to steal the maximum value of items.

00:51:50 And different items have different values, but there's only so much space in your knapsack.

00:51:55 So, the greedy approach says, pick the most expensive item that will fit in your knapsack and put it in there and then steal the next most expensive item that will fit and keep going until you have filled your knapsack.

00:52:07 And it doesn't give you a perfect solution, but it gives you a good enough solution where it's good enough for most cases.

00:52:15 Yeah, this optimization problem.

00:52:16 Interesting.

00:52:18 Yeah.

00:52:18 And then recommendations with K nearest neighbors.

00:52:21 Oh, yes.

00:52:22 Again, really simple concepts.

00:52:25 My example is, let's say you are a Netflix user and Netflix is trying to recommend movies to you.

00:52:31 And they know that you have, I love the Matrix, for example.

00:52:35 So, they know that I've rated the Matrix five stars on Netflix and a bunch of other movies.

00:52:39 So, they look for other users that have similar ratings on those movies.

00:52:46 So, they might say, like, you rated the Matrix five stars.

00:52:50 It looks like Keanu Reeves rated the Matrix five stars also.

00:52:53 And then you rated, I don't know, 101 Dalmatians five stars.

00:53:00 And Keanu Reeves rated 101 Dalmatians five stars also.

00:53:03 So, it seems like the two of you have a common taste in movies.

00:53:08 We're just going to look at what other movies Keanu likes that you haven't seen.

00:53:13 And we'll just recommend them to you because you probably will like them also.

00:53:18 Yeah, that's cool.

00:53:19 That's a pretty simple recommendation engine.

00:53:21 But I recall a few years ago that Netflix had, like, a challenge to the community to build the best recommendation engine.

00:53:29 And they had, like, a million dollar prize or something big like that, right?

00:53:32 Do you remember?

00:53:33 Did you hear about this?

00:53:34 Yeah, I did.

00:53:35 And I think they used to use K-nearest neighbors.

00:53:39 I'm not 100% sure.

00:53:41 But I think they used K-nearest neighbors before that price came out.

00:53:45 So, that's how, you know, it worked for them for so long.

00:53:49 And I think the current version uses a modified version of K-nearest neighbors.

00:53:54 Yeah, I don't see how you get around something like this being at least part of the solution, right?

00:53:58 Yeah.

00:53:59 Awesome.

00:54:00 I think that's quite a good introduction to algorithms.

00:54:03 You know, if you're out there listening and you didn't have a formal computer science education or, like me, you kind of paid attention and you forgot and these ideas were living in the edge of your memory, but you wouldn't mind a reminder.

00:54:16 I think this is a really interesting way to learn it with this nice illustrations and simple stories.

00:54:21 I really appreciate your book.

00:54:22 I think we're probably out of time, so I have to leave it there.

00:54:24 Let me ask you a couple of questions before I let you go, though.

00:54:28 I always ask my guests.

00:54:29 Sure.

00:54:29 Yeah, there's now over 90,000 PyPI packages out there, distinct packages.

00:54:34 I'm sure you've come across some that you found interesting that maybe not everybody knows of.

00:54:38 Anything come to mind you want to recommend?

00:54:41 Oh, my gosh.

00:54:41 I'm sure everyone knows about the one I'm going to recommend, but it's called NumPy.

00:54:47 Oh, yeah.

00:54:47 And it's, you know, I'm starting to get more into machine learning and it's so useful.

00:54:55 Yeah, I think the whole things like NumPy and SciPy and the whole data science story has really opened up a whole new avenue for Python to grow, right?

00:55:07 It's not just a web development technology.

00:55:09 It's also so much for science and it's amazing what people are doing with it.

00:55:12 Editor, if you're going to write some Python code, what editor do you use?

00:55:17 I have to go with Vim.

00:55:18 All right, Vim, right on.

00:55:20 Okay, so any final call to action?

00:55:23 How do people find your book?

00:55:24 Things like that.

00:55:25 So if they just go to my website, it's audit.io, A-D-I-T dot I-O.

00:55:31 There's a link to my book and there's blog posts there.

00:55:36 Oh, you said that people can get the pictures and use them like for their classes if they're a teacher or something.

00:55:42 Yes, that's something not a lot of people know.

00:55:45 But all the images from the book are available for free online and high res.

00:55:52 So if you're a teacher and you want more images related to algorithms, there's like 400 images from this book and they're all on my GitHub.

00:56:03 So it's github.com/Egon Schiele.

00:56:07 And maybe you can add a link so I don't have to spell that out.

00:56:11 Yeah, I'll definitely link to that.

00:56:12 No problem.

00:56:12 That'll be in the show notes.

00:56:13 All right.

00:56:14 Well, it's been great to talk to you and I definitely recommend your book to people.

00:56:19 I think it's very approachable.

00:56:21 So if this kind of thing is interesting to you, check it out.

00:56:24 Thank you so much.

00:56:24 You're welcome.

00:56:25 Thanks for being on the show.

00:56:26 Talk to you later.

00:56:26 Take care.

00:56:27 This has been another episode of Talk Python to Me.

00:56:31 Today's guest has been Adit Bhargava.

00:56:34 And this episode has been sponsored by Capital One and Intel.

00:56:37 Thank you both for supporting the show.

00:56:39 Are you a data scientist or Python developer who loves data?

00:56:43 If you're looking for a place to work on data science with truly big data that can affect millions of lives,

00:56:48 then head on over to jobs.capitalone.com slash talkpython and check out the wide range of jobs that Capital One is trying to fill right now.

00:56:57 The Intel distribution for Python delivers the high performance Intel C libraries built right into Python.

00:57:03 Get close to 100 times better performance for certain functions when using NumPy, SciPy, and scikit-learn.

00:57:09 Check them out at talkpython.fm/intel.

00:57:12 Are you or a colleague trying to learn Python?

00:57:15 Have you tried books and videos that just left you bored by covering topics point by point?

00:57:20 Well, check out my online course Python Jumpstart by building 10 apps at talkpython.fm/course to experience a more engaging way to learn Python.

00:57:29 And if you're looking for something a little more advanced, try my Write Pythonic Code course at talkpython.fm/pythonic.

00:57:37 You can find the links from this episode at talkpython.fm/episodes slash show slash 82.

00:57:43 Be sure to subscribe to the show.

00:57:45 Open your favorite podcatcher and search for Python.

00:57:47 We should be right at the top.

00:57:48 You can also find the iTunes feed at /itunes, Google Play feed at /play,

00:57:54 and direct RSS feed at /rss on talkpython.fm.

00:57:58 Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:58:03 Corey just recently started selling his tracks on iTunes, so I recommend you check it out at talkpython.fm/music.

00:58:09 You can browse his tracks he has for sale on iTunes and listen to the full-length version of the theme song.

00:58:15 This is your host, Michael Kennedy.

00:58:17 Thanks so much for listening.

00:58:18 I really appreciate it.

00:58:19 Smix, let's get out of here.

00:58:22 Stating with my voice, there's no norm that I can feel within.

00:58:26 Haven't been sleeping, I've been using lots of rest.

00:58:28 I'll pass the mic back to who rocked it best.

00:58:31 I'll pass the mic back to who rocked it best.

00:58:44 Thank you.

