WEBVTT

00:00:00.001 --> 00:00:05.560
Welcome to a very special episode. This is the 100th episode of Talk Python to Me.

00:00:05.560 --> 00:00:10.400
It's the perfect chance to take a moment and look at where we've come from and where we're going.

00:00:10.400 --> 00:00:15.820
Not just with regard to this podcast, but for Python in general. And who better to do this with

00:00:15.820 --> 00:00:21.200
than Python's inventor himself, Guido Van Rossum. In this episode, we discuss how Guido got into

00:00:21.200 --> 00:00:27.600
programming, where Python came from and why, and Python's bright future with Python 3. This is

00:00:27.600 --> 00:00:32.360
Talk Python to Me, episode 100, recorded January 18th, 2017.

00:00:55.200 --> 00:01:01.980
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the ecosystem,

00:01:01.980 --> 00:01:06.740
and the personalities. This is your host, Michael Kennedy. Follow me on Twitter, where I'm at,

00:01:06.740 --> 00:01:11.980
mkennedy. Keep up with the show and listen to past episodes at talkpython.fm. And follow the

00:01:11.980 --> 00:01:18.720
show on Twitter via at Talk Python. This episode is brought to you by Rollbar and Hired. Thank them

00:01:18.720 --> 00:01:26.440
both for supporting the show. Check them out at Rollbar and at Hired underscore HQ on Twitter and

00:01:26.440 --> 00:01:33.320
tell them thank you. Hey, everyone. I just want to take a moment and reflect on this milestone of 100

00:01:33.320 --> 00:01:39.580
episodes and say a big thank you to everyone out there who's listening. The reason this podcast is

00:01:39.580 --> 00:01:44.800
successful, the reason I've kept doing it, is because so many of you tell me that you appreciate what I'm

00:01:44.800 --> 00:01:49.040
doing, that you enjoy all the guests that I have on the show. So I want to say thank you because

00:01:49.040 --> 00:01:55.180
without you, obviously, I would not have 100 episodes. I get to live basically my dream job.

00:01:55.180 --> 00:02:00.460
I talk to all these brilliant people in the tech industry and I get to share it with you and get

00:02:00.460 --> 00:02:06.060
all the great feedback that so many of you give me. So thanks. And we really have a special guest

00:02:06.060 --> 00:02:13.040
guest this episode with Guido and a look at Python over the years, the past, present and future. And I

00:02:13.040 --> 00:02:16.920
really hope you enjoy that. If you're out there thinking, hey, I really love the show and I'd like

00:02:16.920 --> 00:02:22.080
to support it. There's a couple of things you can do that are really easy. One, if you give us a review

00:02:22.080 --> 00:02:27.840
on iTunes, that actually makes a big difference how we rank within iTunes. So that's kind of like Google

00:02:27.840 --> 00:02:33.220
rank for podcasts. That would be great. If you want to do more than that, one of the really great ways to

00:02:33.220 --> 00:02:38.680
support me and what I'm doing would actually be to buy one of my classes or recommend my training

00:02:38.680 --> 00:02:44.800
content to your employer or your team at work. If you're into that, check that out at training.talkpython.fm.

00:02:44.800 --> 00:02:50.380
And there's even a little Patreon link if you just want to give a dollar or two a week. So thank you

00:02:50.380 --> 00:02:56.720
everybody for making this possible. Thank you for helping me reach 100 episodes and been great to share

00:02:56.720 --> 00:03:02.160
them with you. And I hope you've really enjoyed them yourself. All right. With all that said, here's Guido.

00:03:03.160 --> 00:03:07.960
Guido, welcome to Talk Python. Glad to be here, Michael. I'm honored that you're coming on my

00:03:07.960 --> 00:03:13.040
100th show to celebrate this special episode. And I know everyone in the community is really going to

00:03:13.040 --> 00:03:19.520
appreciate this look at the history and the present and future of Python with you. Well, let's have it.

00:03:19.520 --> 00:03:24.240
All right. Absolutely. So we're going to dig into a whole bunch of things about Python. But before we

00:03:24.240 --> 00:03:27.060
get there, let's start with your story. How'd you get into programming in the first place?

00:03:27.060 --> 00:03:33.840
Well, that was a long time ago. In high school, I did not know what a computer was. I believe I had

00:03:33.840 --> 00:03:40.520
not even ever heard of the word. I was an electronics hobbyist, though. And I got started, I think,

00:03:40.520 --> 00:03:47.980
around the age of 10, building very simple analog circuits, things like a little radio receiver that

00:03:47.980 --> 00:03:55.440
made from a kit. And I gradually discovered simple digital electronics and integrated circuits were

00:03:55.440 --> 00:04:01.480
becoming available to hobbyists like me, even with my very small amount of pocket money.

00:04:02.320 --> 00:04:07.800
And that's where I was when I graduated from high school. Then I went to university to study

00:04:07.800 --> 00:04:13.820
mathematics, the University of Amsterdam. And it was like a completely different world. They had a

00:04:13.820 --> 00:04:18.740
mainframe in the basement, and there were programming classes. And the languages that I remember were

00:04:18.740 --> 00:04:25.660
Algal 60 and Pascal. And I was basically instantly hooked, even though the first year I remember the

00:04:25.660 --> 00:04:29.660
only way I could input programs to the computer was through punch cards.

00:04:30.000 --> 00:04:35.140
Yeah. If you start programming, basically via hardware, and then you have this machine that

00:04:35.140 --> 00:04:39.900
you can just feed anything, the whole world opens up, right? Even if it's punch cards, it's like it can

00:04:39.900 --> 00:04:41.840
do anything I ask it to do almost, right?

00:04:41.840 --> 00:04:46.900
I was so happy that I didn't have to sort of solder stuff together anymore.

00:04:46.900 --> 00:04:48.340
That's right.

00:04:48.340 --> 00:04:50.700
Because that was always my weak point.

00:04:50.700 --> 00:04:56.940
Oh, it's such a difference. So you got started really in the early days, and when the term hacker

00:04:56.940 --> 00:04:58.620
meant something entirely different, right?

00:04:58.760 --> 00:05:03.700
I don't think I knew the word hacker. That was like decades later that people

00:05:03.700 --> 00:05:05.720
told me I had been a hacker.

00:05:05.720 --> 00:05:11.540
Oh, I didn't know. How interesting. Okay, excellent. And then you got into,

00:05:11.540 --> 00:05:16.380
you started working on programming languages. How'd you go from playing with mainframes and

00:05:16.380 --> 00:05:19.080
punch cards to working on things like ABC and stuff?

00:05:19.080 --> 00:05:24.620
Well, I guess I developed an interest in learning different programming languages. That probably

00:05:24.620 --> 00:05:30.660
started out when my first year there were two different languages being taught, I think,

00:05:30.660 --> 00:05:38.300
Algol and Pascal. And then I hung out with a bunch of physics students and their favorite language was

00:05:38.300 --> 00:05:45.200
Fortran. So right from the start, there was this discussion about Algol, no Fortran, no Algol,

00:05:45.200 --> 00:05:52.760
Pascal. And somehow that interested me. I always stayed on the Algol and Pascal side, actually.

00:05:52.760 --> 00:05:57.880
I was told that when I was in college that Fortran was the most important language I'd ever learned in

00:05:57.880 --> 00:06:02.420
my career and I should just focus on that. And I was pleading to take some C and C++. I'm like,

00:06:02.420 --> 00:06:07.200
can I do where the, nope, Fortran is where you got to start. You can do those as an elective afterwards.

00:06:07.200 --> 00:06:15.140
Oh gosh, yeah. Well, it wasn't, in our university, it was more like a split between the math department and the physics department.

00:06:15.140 --> 00:06:25.320
The natural sciences were using Fortran because they were sort of processing measurements and math people were more interested in sort of pure computer science.

00:06:25.320 --> 00:06:26.540
Yeah, very interesting. Yeah.

00:06:26.540 --> 00:06:35.620
The professors actually sort of crossed that bridge. So later, I actually, I encountered the author of ABC,

00:06:35.620 --> 00:06:45.240
Lombard Meartens. I encountered him in my personal life, sort of an extracurricular activity where I was helping some volunteer group doing programming.

00:06:45.240 --> 00:06:50.440
And he was also helping that same group. He was something higher in the organization.

00:06:50.440 --> 00:06:59.520
And he realized that I was a good programmer and had interest in programming languages and their design and implementation and had some,

00:06:59.520 --> 00:07:06.220
some interesting skills there. And when I was about to graduate, he just offered me a job.

00:07:06.360 --> 00:07:07.540
And that was that.

00:07:07.540 --> 00:07:15.880
That's fantastic, right? You're probably thinking, how am I going to find a job? What am I going to apply? What am I going to do? Oh, it just landed in my lab. How wonderful.

00:07:15.880 --> 00:07:25.040
And then I learned really what the job of a language designer and implementer is. And I didn't get to design any part of ABC.

00:07:25.040 --> 00:07:34.200
I got to discuss it with Lambert and other team members endlessly. But basically, the design was already complete when I joined the team.

00:07:34.620 --> 00:07:42.000
And all they needed was someone who would implement it. But by fighting every aspect of the language that I didn't understand,

00:07:42.000 --> 00:07:51.340
I prompted Lambert and others to explain what their reasoning process in the language design phase was.

00:07:51.340 --> 00:07:55.740
And that helped me learn how to be a language designer.

00:07:55.740 --> 00:07:59.540
Yeah, I'm sure it did, because they designed it more or less in the abstract, right?

00:07:59.540 --> 00:08:06.420
And they said, all right, now it's time for a rubber to hit the road. And you'd actually make this thing work that we've specced out, right?

00:08:06.420 --> 00:08:07.800
Yeah, much like that.

00:08:07.800 --> 00:08:12.580
Yeah. And how much of that experience do you feel like made it possible for you to actually create Python?

00:08:12.580 --> 00:08:18.840
Like, to me, thinking of I'm going to create a language, I'm going to create the CPython implementation and the standard library and all that.

00:08:18.840 --> 00:08:20.700
It's very daunting and a very big challenge.

00:08:20.840 --> 00:08:26.380
But do you feel like you kind of got a first round practice at it, doing this thing at ABC?

00:08:26.380 --> 00:08:34.540
Absolutely. Without having been on the ABC team for four years, I would never have been able to do that.

00:08:34.540 --> 00:08:37.660
I wouldn't have felt comfortable. I wouldn't have known how to.

00:08:38.500 --> 00:08:43.600
I wouldn't have known enough about language implementations.

00:08:43.600 --> 00:08:58.860
I mean, Python really is sort of the next version of ABC with all the things that were great about ABC retained and all the things I thought were not so successful in ABC removed.

00:08:58.860 --> 00:09:02.620
And a very small number of my own ideas replacing them.

00:09:02.620 --> 00:09:10.460
I see. So Python was sort of your, let me do this now knowing what I know, let me make a better version of something similar to this.

00:09:10.460 --> 00:09:14.600
Correct. Yeah, that's exactly what I was really thinking.

00:09:14.600 --> 00:09:20.420
And I sort of, I managed to present it to management in a slightly more objective fashion.

00:09:20.420 --> 00:09:23.180
How do you pitch it?

00:09:23.180 --> 00:09:30.260
Well, part of it was that management was not very closely involved in my day-to-day activities.

00:09:30.420 --> 00:09:32.800
There was a certain amount of software that had to be written.

00:09:32.800 --> 00:09:41.940
And however it was written was great, as long as we had sort of the running applications to prove it at the end.

00:09:41.940 --> 00:09:51.480
I was more or less at liberty to invent a different strategy for sort of eventually building that software faster.

00:09:51.480 --> 00:09:54.020
That's fantastic. And that's some of the origins of Python.

00:09:54.020 --> 00:09:56.840
What happened to ABC? It's not around.

00:09:56.840 --> 00:10:00.100
And Python is one of the most popular programming languages in the world.

00:10:00.100 --> 00:10:02.320
Like, why did those things take different paths?

00:10:02.320 --> 00:10:06.760
I've written about this in my old Python history blogs a few times.

00:10:06.760 --> 00:10:15.780
The ABC project actually four years into it, at least for me four years into it, was canceled by upper management at CWI.

00:10:16.120 --> 00:10:24.220
The reason being that there was no observable sort of user uptake.

00:10:24.220 --> 00:10:28.420
There were very few people interested in the language.

00:10:28.420 --> 00:10:32.240
There were even fewer people who are actually using it.

00:10:32.240 --> 00:10:36.340
And the team just couldn't move that needle.

00:10:36.340 --> 00:10:41.180
And part of that was that this was well before the Internet.

00:10:41.180 --> 00:10:43.700
And there was a little bit of Usenet.

00:10:43.700 --> 00:10:50.960
But it was difficult to distribute a language implementation and get people to use it.

00:10:50.960 --> 00:10:52.060
Right. There's no GitHub.

00:10:52.060 --> 00:10:54.700
There's not even SourceForge, right?

00:10:54.700 --> 00:10:55.920
There's no web.

00:10:55.920 --> 00:10:59.800
There's so many of the pieces that make these work.

00:11:00.060 --> 00:11:01.420
It's worse than that, even.

00:11:01.420 --> 00:11:07.540
There was no electronic way to distribute the source code at all when we got started.

00:11:07.720 --> 00:11:17.140
I remember taking a long vacation to the United States with a nine-track computer tape in my luggage.

00:11:17.140 --> 00:11:22.500
And taking that tape to two or three different places in the U.S.

00:11:22.500 --> 00:11:30.540
where there were people interested in using ABC so that they could load that tape onto their computer and get the sources.

00:11:31.180 --> 00:11:35.700
Because the amount of source code was larger than you could possibly send as an email.

00:11:35.700 --> 00:11:40.700
And I think attachments hadn't been invented yet or were still limited in size.

00:11:40.700 --> 00:11:43.020
Yeah, you have to, like, base 64 and code it.

00:11:43.020 --> 00:11:44.560
Just put it as text or something, right?

00:11:44.560 --> 00:11:47.820
I'm going to send you a thousand emails numbered 1, 2, 3, 4.

00:11:47.820 --> 00:11:49.400
Yeah.

00:11:49.400 --> 00:11:53.840
Even the first Python distribution had to suffer through some of that.

00:11:53.840 --> 00:12:03.760
But by then, in 91, it was about 20 compressed maximum-sized messages to some Usenet source code group.

00:12:03.760 --> 00:12:05.980
Yeah, Usenet was just starting to become popular.

00:12:05.980 --> 00:12:08.960
And the internet was starting to be a thing.

00:12:08.960 --> 00:12:12.260
But web browsers didn't really come out until, like, 93, 94.

00:12:12.260 --> 00:12:14.120
So it was quite early days in 91.

00:12:14.120 --> 00:12:16.700
Mm-hmm.

00:12:16.700 --> 00:12:19.740
Talk Python to Me is partially supported by our training courses.

00:12:19.740 --> 00:12:22.720
How does your team keep their Python skills sharp?

00:12:23.080 --> 00:12:26.860
How do you make sure new hires get started fast and learn the Pythonic way?

00:12:26.860 --> 00:12:30.980
If the answer is a series of boring videos that don't inspire,

00:12:30.980 --> 00:12:35.840
or a subscription service you pay way too much for and use way too little, listen up.

00:12:35.840 --> 00:12:39.760
At Talk Python Training, we have enterprise tiers for all of our courses.

00:12:39.760 --> 00:12:44.320
Get just the one course you need for your team with full reporting and monitoring.

00:12:44.320 --> 00:12:47.420
Or ditch that unused subscription for our course bundles,

00:12:47.420 --> 00:12:50.960
which include all the courses and you pay about the same price as a subscription.

00:12:50.960 --> 00:12:52.040
Once.

00:12:52.320 --> 00:12:59.340
For details, visit training. talkpython.fm/business or just email sales at talkpython.fm.

00:12:59.340 --> 00:13:03.820
Did you envision Python being open source from the beginning?

00:13:03.820 --> 00:13:05.840
What was your thinking around that?

00:13:06.100 --> 00:13:07.220
I would say yes.

00:13:07.220 --> 00:13:13.500
ABC actually, in the sense that the concept even existed, was meant to be open source.

00:13:13.500 --> 00:13:17.060
We were not interested in selling it.

00:13:17.060 --> 00:13:19.800
We were just interested in promoting the language.

00:13:19.800 --> 00:13:26.740
If the words open source had existed in the early 80s, we would have said ABC is open source.

00:13:27.120 --> 00:13:32.820
As it was, I don't think we had even realized that there was some kind of need of a license.

00:13:32.820 --> 00:13:33.300
Right.

00:13:33.300 --> 00:13:33.840
That's amazing.

00:13:33.840 --> 00:13:36.400
Just the nomenclature didn't even exist to describe.

00:13:36.400 --> 00:13:36.860
Yeah.

00:13:36.860 --> 00:13:38.620
You had to use words in a description.

00:13:38.620 --> 00:13:40.040
This is a thing we're giving away.

00:13:40.040 --> 00:13:41.080
You don't have to...

00:13:41.080 --> 00:13:41.640
So on, right?

00:13:41.720 --> 00:13:47.460
By the time I started on Python, there were a few models that were pretty solid.

00:13:47.460 --> 00:13:55.140
I remember, I think the big model that I just copied almost literally was the MIT license

00:13:55.140 --> 00:13:58.160
that went on X Windows.

00:13:58.160 --> 00:14:00.420
Now, you're not supposed to call it X Windows.

00:14:00.420 --> 00:14:01.360
It was X11.

00:14:02.160 --> 00:14:09.100
But that was a big, essentially open source piece of free software that was very sort of

00:14:09.100 --> 00:14:16.960
intentionally open source because the authors wanted to unify windowing software across different

00:14:16.960 --> 00:14:18.360
hardware platforms.

00:14:18.360 --> 00:14:19.840
There were all these different flavors.

00:14:19.840 --> 00:14:22.700
How do you write apps that run on all of them and things like that?

00:14:22.700 --> 00:14:23.620
That was a big problem, huh?

00:14:23.620 --> 00:14:24.360
Exactly.

00:14:24.360 --> 00:14:24.960
Okay.

00:14:24.960 --> 00:14:31.580
So how do you think having Python open source has helped or maybe even hindered Python over

00:14:31.580 --> 00:14:32.080
the years?

00:14:32.080 --> 00:14:33.340
Oh, it's only helped.

00:14:33.340 --> 00:14:40.100
I mean, if it hadn't been open source, people would not have been interested in picking it

00:14:40.100 --> 00:14:46.920
up because it's one thing to download an application that's not free software, that's not open source

00:14:46.920 --> 00:14:49.940
and use it to process some of your data.

00:14:49.940 --> 00:14:58.520
But it's quite different to start writing your own software using a language that hasn't proven

00:14:58.520 --> 00:14:59.340
itself yet.

00:14:59.340 --> 00:14:59.920
Right.

00:15:00.720 --> 00:15:05.620
So if maybe you're willing to pay for one of the top three most, the tooling and whatnot

00:15:05.620 --> 00:15:09.920
for the top three most popular languages, because you know that's kind of where a lot of the

00:15:09.920 --> 00:15:10.740
momentum is.

00:15:10.740 --> 00:15:17.500
But in order to break into that space, being open and free really allowed you to wedge yourself

00:15:17.500 --> 00:15:18.060
in there, right?

00:15:18.140 --> 00:15:24.760
And it was also the model that some languages that I felt I was competing with most directly,

00:15:24.760 --> 00:15:28.640
like Perl and Tickle TK, those were also open source.

00:15:28.880 --> 00:15:29.980
I do not recall any names.

00:15:29.980 --> 00:15:35.460
I do not recall any names, but I recall there were several similar level scripting languages

00:15:35.460 --> 00:15:42.640
being designed and distributed at the time that were not open source and very intentionally

00:15:42.640 --> 00:15:47.400
so, where there was someone who had a brilliant idea for making a better scripting language.

00:15:47.400 --> 00:15:52.980
And for all intents and purposes, their language probably was better than what was available.

00:15:52.980 --> 00:15:59.380
But their model for funding their work was sell copies of the interpreter.

00:16:00.140 --> 00:16:02.360
And that just never worked.

00:16:02.360 --> 00:16:02.720
Yeah.

00:16:02.720 --> 00:16:07.280
In those early days, it was still not entirely clear what business models would work for the

00:16:07.280 --> 00:16:09.100
developer community and what wouldn't.

00:16:09.100 --> 00:16:10.340
People were really experimenting.

00:16:10.340 --> 00:16:14.040
And I'm sure some things were lost because bad choices were made.

00:16:14.040 --> 00:16:17.800
But I'm really glad Python is still going strong.

00:16:17.800 --> 00:16:25.400
Did you ever imagine back in 1991 that open source and Python would be where they are today?

00:16:25.400 --> 00:16:30.880
I, in general, suffer from a terrible lack of imagination and vision.

00:16:30.880 --> 00:16:38.720
So at no point in Python's history have I ever adequately predicted where Python would be

00:16:38.720 --> 00:16:40.420
five years from there.

00:16:40.420 --> 00:16:44.780
So no, I had never thought that this would happen this particular way.

00:16:44.780 --> 00:16:46.720
To me as well, it's just amazing.

00:16:46.720 --> 00:16:51.860
Just even over the last five years, the way things have changed is so amazing.

00:16:51.860 --> 00:16:53.460
GitHub has come into existence.

00:16:54.020 --> 00:17:00.760
We're seeing companies that used to be fiercely proprietary become much more embracing of

00:17:00.760 --> 00:17:01.360
open source.

00:17:01.360 --> 00:17:07.640
I recently saw the CEO of the Linux Foundation or the head of the Linux Foundation standing

00:17:07.640 --> 00:17:12.400
next to Satya Nadella at a Microsoft conference saying they love each other.

00:17:12.400 --> 00:17:12.620
Yeah.

00:17:12.620 --> 00:17:16.300
This is a different place than we were a while ago.

00:17:16.300 --> 00:17:18.080
I think it's great for everyone, though.

00:17:18.080 --> 00:17:20.520
I think it's a very, very positive path forward.

00:17:20.520 --> 00:17:23.800
I'm very happy with how this all has turned out.

00:17:23.800 --> 00:17:28.700
I'm hopeful that a lot of technology will continue to be open source.

00:17:28.700 --> 00:17:29.720
Yeah, I think it will.

00:17:29.720 --> 00:17:35.260
And I think it's great to see companies taking open source and building business models alongside

00:17:35.260 --> 00:17:36.540
of it that are sustainable.

00:17:36.540 --> 00:17:43.140
Companies like Continuum or Scraping Web or these guys that have a great popular open source

00:17:43.140 --> 00:17:49.540
project and somehow they're adding value on top of it, but they're not abandoning open source.

00:17:49.540 --> 00:17:54.680
Without open source, you have to do all the work yourself as the company that owns it.

00:17:55.220 --> 00:18:03.360
And now, maybe if you're a large company like Google or IBM or Microsoft or Apple, you don't mind because you have tons of developers.

00:18:03.360 --> 00:18:18.680
But for anyone who is smaller, the value of a community is so tremendous because you sort of, you will still be able to make money on a variety of consulting and support projects.

00:18:19.040 --> 00:18:23.480
So that's how open source developers support themselves generally.

00:18:23.480 --> 00:18:24.760
I'm actually an exception.

00:18:24.760 --> 00:18:29.740
I'm just employed by some large software developer that uses a lot of Python.

00:18:29.740 --> 00:18:32.040
That's been my personal model.

00:18:32.040 --> 00:18:35.820
But yeah, companies like Continuum or Canonical.

00:18:35.820 --> 00:18:36.640
Canonical.

00:18:36.640 --> 00:18:51.340
Everything they produce is open source, but they make a lot of money through handholding of customers who don't want to sort of hire their own software developers.

00:18:51.340 --> 00:18:56.620
That's a model that works for many types of open source software.

00:18:56.620 --> 00:19:02.120
I think it's great to see people being successful in that model and experimenting with other ones as well.

00:19:02.120 --> 00:19:05.320
Let's talk a little bit about language design and trade-offs.

00:19:05.320 --> 00:19:05.920
Sure.

00:19:05.920 --> 00:19:12.060
Python has been growing in popularity pretty dramatically over the last 5, 10 years.

00:19:12.060 --> 00:19:14.620
It had been around for 15 years before.

00:19:14.620 --> 00:19:20.700
And it seems like not only is it still relevant and popular, but that popularity and relevance is growing.

00:19:20.860 --> 00:19:33.540
And I think part of that is expanding into different areas, like the adoption of Python in the data science space, I think, has brought many new people to the Python ecosystem where Python is their primary language now.

00:19:33.540 --> 00:19:38.160
How do you trade off sort of serving these different environments or these different ecosystems?

00:19:38.160 --> 00:19:43.860
Somebody wants in a language as a data scientist might be very different than what somebody wants as a web developer.

00:19:43.860 --> 00:19:51.960
On the language design side, I don't usually take applications into account that much.

00:19:51.960 --> 00:20:03.740
I've seen some language designs where people proudly announced, well, in our language, a URL is a standard data structure that is built into the compiler.

00:20:03.740 --> 00:20:06.260
They say that as if that's a good thing.

00:20:06.260 --> 00:20:09.580
And all it buys you is that you can leave out some string quotes.

00:20:09.580 --> 00:20:11.740
And internally, it usually is still a string.

00:20:11.740 --> 00:20:12.600
Right, exactly.

00:20:12.840 --> 00:20:13.580
It's a gimmick.

00:20:13.580 --> 00:20:18.460
And Python has always presented itself as a general purpose language.

00:20:18.460 --> 00:20:20.360
And you can do many things in Python.

00:20:20.360 --> 00:20:28.880
And I didn't design Python for web development, obviously, because the language is older than the concept of web development.

00:20:28.880 --> 00:20:32.400
And ditto for data science.

00:20:32.400 --> 00:20:48.420
And for web development, it turns out enough people from different backgrounds are interested in doing simple web development using Python that we ended up with a bunch of stuff in the standard library.

00:20:48.620 --> 00:20:57.940
But still, often the most successful APIs for even for web development are actually third-party packages.

00:20:58.400 --> 00:21:02.920
And what the standard library provides is more low-level than that.

00:21:03.020 --> 00:21:07.200
Like the standard library has to provide things like sockets.

00:21:07.640 --> 00:21:18.880
And in fact, one funny story is that I think in the first year that Python existed, before we made it open source, actually, I was teaching myself how sockets worked.

00:21:19.380 --> 00:21:25.280
Because sockets were sort of a new thing in our environment at that point.

00:21:25.280 --> 00:21:27.600
We had a bunch of Unix machines.

00:21:27.600 --> 00:21:32.540
And I had never really known how the networking on those machines worked before.

00:21:32.920 --> 00:21:37.660
And then some colleagues started writing little C programs that used sockets.

00:21:37.660 --> 00:21:38.860
And it was so cool.

00:21:38.860 --> 00:21:42.300
And the programs always crashed because they didn't do the right error checking.

00:21:42.300 --> 00:21:45.380
And I wanted to know what those sockets were about.

00:21:45.380 --> 00:21:53.360
And my way of teaching myself was, oh, I'll write a Python extension that wraps the socket API.

00:21:53.360 --> 00:22:00.920
And so I just read the man pages and say, okay, well, there is like the socket call and the bind call and the listen call.

00:22:01.540 --> 00:22:08.660
And I wrapped each of those in as low-level an extension as possible with proper error checking.

00:22:08.660 --> 00:22:12.620
Because Python has always had this philosophy, if something goes wrong, you get an exception.

00:22:12.620 --> 00:22:26.180
And then I started combining those calls in sort of random combinations and figuring out what errors I would get when and what forms of simple programs actually worked.

00:22:26.180 --> 00:22:30.420
And that's how Python socket module came into existence.

00:22:30.760 --> 00:22:38.060
And later, once the worldwide web started being promoted, I joined a variety of mailing lists around that.

00:22:38.440 --> 00:22:42.800
And started writing my own little web servers and started writing my own little web servers and clients.

00:22:42.800 --> 00:22:45.420
And eventually that turned into URL app.

00:22:45.420 --> 00:22:55.840
But what people actually use for web stuff is third-party frameworks like Twisted or for web serving, pure web serving.

00:22:55.840 --> 00:22:58.220
It's like Django or Flask.

00:22:58.220 --> 00:23:00.900
For web clients, it's requests.

00:23:02.000 --> 00:23:08.560
And so the standard library doesn't even contribute that much beyond the sort of the low-level sockets.

00:23:08.560 --> 00:23:09.120
Sure.

00:23:09.120 --> 00:23:15.900
So I totally agree that it's the packages that have absolutely made Python successful.

00:23:15.900 --> 00:23:23.240
I mean, just looking on PyPI.org right now, we've got 96,000 plus packages.

00:23:23.680 --> 00:23:30.620
And that's really a testament to how amazing the whole ecosystem and community is, right?

00:23:30.620 --> 00:23:37.700
How do you decide when something should be in the standard library or something should be an external package?

00:23:37.700 --> 00:23:39.900
And have these ever moved in or out?

00:23:40.440 --> 00:23:45.460
Yeah, I have to admit that the standard library is still fairly uneven.

00:23:45.460 --> 00:23:54.620
Because long ago, say 15 years ago, I had much less of a filter about what things would be good standard library modules.

00:23:54.620 --> 00:23:58.980
I had very strong backwards compatibility requirements.

00:23:58.980 --> 00:24:06.500
Like once a module is in the standard library, it can sort of grow, but it can't just change in an incompatible way.

00:24:06.500 --> 00:24:10.380
Or at least that's a major project with deprecations and all that.

00:24:10.380 --> 00:24:16.160
But I didn't have much of a bar for including stuff in the standard library.

00:24:16.160 --> 00:24:24.420
And that started out with various hobby projects that I wrote myself and played with for two months in 1991 or so.

00:24:24.420 --> 00:24:29.180
That were still in the Python 2 standard library around 2010.

00:24:29.180 --> 00:24:34.920
Many of those things finally got ripped out for Python 3.

00:24:34.920 --> 00:24:36.880
But of course, Python 2 is still there.

00:24:37.500 --> 00:24:41.800
More recently, sort of, as Python matured and became more popular.

00:24:41.800 --> 00:24:45.780
And from my perspective, it's just sort of been steady exponential growth.

00:24:45.780 --> 00:24:52.440
So I can't tell you whether it was 5 or 10 or 20 years ago that Python suddenly started becoming popular.

00:24:52.440 --> 00:25:04.700
So the current rules for inclusion in the standard library is a combination of something that is useful for multiple application areas.

00:25:04.700 --> 00:25:11.940
A new API for web development will not make it into the standard library just because that's one area.

00:25:12.180 --> 00:25:16.840
It has to be something that's useful for a wide variety of applications.

00:25:16.840 --> 00:25:19.000
It doesn't necessarily have to be all applications.

00:25:19.000 --> 00:25:24.940
But something like, well, sockets are obviously something that is useful across the board.

00:25:24.940 --> 00:25:25.320
Right.

00:25:25.320 --> 00:25:32.060
Many things in the standard library that really belong there also have to do with sort of the language itself.

00:25:32.060 --> 00:25:39.140
Like introspection tools, partial functions, those kind of things are good standard library things.

00:25:39.140 --> 00:25:40.240
The disk module.

00:25:40.240 --> 00:25:41.540
For example, yeah.

00:25:41.540 --> 00:25:41.980
Yeah.

00:25:41.980 --> 00:25:52.300
Things that are bad for inclusion in the standard library is usually almost any piece of code that is under active development.

00:25:52.560 --> 00:25:59.440
Because Python only issues a sort of feature release every 18 months or more.

00:25:59.440 --> 00:26:05.080
And that's just a really slow pace and you can't even get people to upgrade quickly.

00:26:05.080 --> 00:26:11.640
So if someone has a new idea for, let's take an example.

00:26:11.640 --> 00:26:19.660
We have async.io, which is in the standard library, but it doesn't have a built-in web framework.

00:26:19.660 --> 00:26:23.840
Well, why is there no async.io based web framework in the standard library?

00:26:23.840 --> 00:26:36.440
Because the async.io based web framework that exists is under very active development and constantly changes and not always incompatible ways.

00:26:36.440 --> 00:26:46.940
And so people would just be much worse off being stuck with whatever was the async.io based web framework around Python 3.5.

00:26:46.940 --> 00:26:50.440
You would actually hinder it by putting it in Python, right?

00:26:50.440 --> 00:26:51.280
Exactly.

00:26:51.280 --> 00:26:55.800
You would force it to freeze its API so that could never change in a breaking way.

00:26:55.800 --> 00:26:59.340
And it couldn't release more than every 18 months.

00:26:59.340 --> 00:27:05.260
And probably some third-party package would come along, mimic that, but iterate faster and be better anyway.

00:27:05.260 --> 00:27:05.800
Yeah.

00:27:05.800 --> 00:27:06.300
Okay.

00:27:06.300 --> 00:27:06.300
Okay.

00:27:06.300 --> 00:27:23.560
This portion of Talk Python to me has been brought to you by Rollbar.

00:27:23.880 --> 00:27:27.080
One of the frustrating things about being a developer is dealing with errors.

00:27:27.080 --> 00:27:27.660
Ah.

00:27:27.660 --> 00:27:35.260
Relying on users to report errors, digging through log files trying to debug issues, or a million alerts just flooding your inbox and ruining your day.

00:27:35.260 --> 00:27:42.480
With Rollbar's full-stack error monitoring, you'll get the context, insights, and control that you need to find and fix bugs faster.

00:27:43.020 --> 00:27:44.200
It's easy to install.

00:27:44.200 --> 00:27:48.440
You can start tracking production errors and deployments in eight minutes or even less.

00:27:48.440 --> 00:27:57.800
Rollbar works with all the major languages and frameworks, including the Python ones, such as Django, Flask, Pyramid, as well as Ruby, JavaScript, Node, iOS, and Android.

00:27:58.480 --> 00:28:07.020
You can integrate Rollbar into your existing workflow, send error alerts to Slack or HipChat, or even automatically create issues in Jira, Pivotal Tracker, and a whole bunch more.

00:28:07.020 --> 00:28:10.400
Rollbar has put together a special offer for Talk Python to me listeners.

00:28:10.400 --> 00:28:16.080
Visit rollbar.com slash Talk Python to me, sign up, and get the bootstrap plan free for 90 days.

00:28:16.080 --> 00:28:19.120
That's 300,000 errors tracked all for free.

00:28:19.120 --> 00:28:22.840
But hey, just between you and me, I really hope you don't encounter that many errors.

00:28:23.420 --> 00:28:28.840
Loved by developers at awesome companies like Heroku, Twilio, Kayak, Instacart, Zendesk, Twitch, and more.

00:28:28.840 --> 00:28:30.460
Give Rollbar a try today.

00:28:30.460 --> 00:28:33.060
Go to rollbar.com slash Talk Python to me.

00:28:33.060 --> 00:28:48.000
Has anything been brought in to Python that was originally external that you can think of?

00:28:48.000 --> 00:28:52.320
I don't have specific examples in mind, but it's definitely happened.

00:28:52.540 --> 00:28:55.260
That definitely occasionally happens.

00:28:55.260 --> 00:29:05.260
It's usually more of a threat where we say, if someone comes with an idea and they say, this functionality should really be in the standard library.

00:29:05.260 --> 00:29:09.840
And nowadays, we usually say, well, that looks more like an application.

00:29:09.840 --> 00:29:12.180
And how do we know that it's actually useful?

00:29:12.680 --> 00:29:23.320
Prove us that the design you have in mind works by first releasing it as a third-party package on PyPI and show us how popular that is.

00:29:23.320 --> 00:29:26.520
And then there are also maintenance requirements.

00:29:26.520 --> 00:29:35.300
We would require that a contributor commit to several years of keeping that code up to date and fixing bugs and stuff.

00:29:35.300 --> 00:29:35.760
Sure.

00:29:36.080 --> 00:29:45.520
And we've had things that actually were kicked out of the standard library because they were too much of a maintenance burden for the core development team.

00:29:45.520 --> 00:29:52.220
I think the last time that happened might have been BSDDB or BerkeleyDB, which was a very large package.

00:29:52.420 --> 00:29:57.340
It's currently much happier as a third-party package than it ever was in the standard library.

00:29:57.340 --> 00:30:00.760
Yeah, I'm sure it can, like we said, grow much faster and so on.

00:30:00.760 --> 00:30:01.900
There are databases in there.

00:30:01.900 --> 00:30:03.600
For example, SQLite ships with Python.

00:30:03.600 --> 00:30:18.420
SQLite is one of those things that is so popular and so versatile and so useful for so many different application domains that that was definitely the right decision to include that.

00:30:18.540 --> 00:30:21.540
Also, SQLite itself is incredibly stable.

00:30:21.540 --> 00:30:22.760
Yeah, that's one of the things.

00:30:22.760 --> 00:30:24.500
It's not changing much these days.

00:30:24.500 --> 00:30:25.320
It's very reliable.

00:30:25.320 --> 00:30:26.180
That's great.

00:30:26.180 --> 00:30:26.600
Yeah.

00:30:26.600 --> 00:30:35.380
So speaking of contributors and having people commit to a certain amount of support over time if something's going to come into the standard library,

00:30:35.380 --> 00:30:41.080
how do you ensure that the core development community invites and retains the best contributors?

00:30:41.080 --> 00:30:48.200
You know, I have a lot of respect for the core developers, but how do you make sure that ecosystem is healthy and vibrant?

00:30:48.420 --> 00:30:51.080
I don't think we're doing that very consciously.

00:30:51.080 --> 00:31:03.860
We have a nominal mentorship program in place, but it's mostly used to get people thinking about contributing to open source projects in general.

00:31:04.300 --> 00:31:09.020
I don't think that's where we get most of our new core developers.

00:31:09.020 --> 00:31:26.020
In practice, new core developers almost always happen because somebody has an itch to scratch and they happen to be a really good programmer or at least sort of made a serious study of Python and start contributing.

00:31:26.680 --> 00:31:38.240
And the people who review their code, and sometimes that's just one or two core devs who sort of mentor that one person, find that their contributions are of high value.

00:31:38.340 --> 00:31:54.780
And then at some point, the mentor or one of the mentors proposes, hey, Python dev, core developers, what do you think of giving person X commit bit so that they can commit their own code after it's been reviewed?

00:31:55.000 --> 00:31:55.660
Yeah.

00:31:55.660 --> 00:32:12.020
There's often real discussion about the sort of potential new contributors maturity, not just in terms of their pure programming chops and how well they know CPython or Python or whatever their area of contribution is.

00:32:12.160 --> 00:32:16.020
But also, do they have the right character?

00:32:16.020 --> 00:32:21.980
Are they likely to sort of not commit something when the reviewer says that it's not ready?

00:32:21.980 --> 00:32:22.420
Yeah.

00:32:22.420 --> 00:32:26.880
I suspect one aspect of that is there's a lot of people that come into programming.

00:32:26.880 --> 00:32:37.260
They see a shiny new thing, you know, something with Node.js or some other technology that seems like it's just going to take over the industry and then it doesn't necessarily.

00:32:37.480 --> 00:32:45.420
So there's probably a level of maturity of experiencing tech evolution over the long term so that you can bring that to the language, right?

00:32:45.420 --> 00:32:47.440
That would be too high a bar.

00:32:47.440 --> 00:32:54.780
You can't say people can only start contributing once they've gone through one technology boom and bust cycle.

00:32:54.780 --> 00:33:02.000
You need them to have a certain character that is okay with the pace of things and the thoroughness.

00:33:02.000 --> 00:33:07.000
And you definitely want them to have a very good attention to detail.

00:33:07.380 --> 00:33:07.460
Sure.

00:33:07.460 --> 00:33:19.700
I guess you definitely want a different level of attention to detail and being meticulous when you're working on the internals of CPython rather than if you're working on some package that's used by a thousand people a month.

00:33:19.700 --> 00:33:20.380
Right?

00:33:20.380 --> 00:33:22.360
These have different requirements for that kind of stuff.

00:33:22.360 --> 00:33:27.900
So you've been a champion of diversity in the whole Python ecosystem.

00:33:27.900 --> 00:33:37.420
And I just wanted to point that out and say thank you because I think it's really making the Python space better in some tangible ways than other environments.

00:33:37.740 --> 00:33:44.160
Just by way of a story, I went to a conference in London last year and I took my 16-year-old daughter.

00:33:44.160 --> 00:33:45.960
And this was not a Python conference.

00:33:45.960 --> 00:33:47.080
It was decidedly not.

00:33:47.080 --> 00:33:49.660
But I was speaking on Python to these folks.

00:33:49.660 --> 00:33:50.780
Say, hey, you should also learn Python.

00:33:50.780 --> 00:33:51.300
This is cool.

00:33:51.660 --> 00:33:53.160
And I brought my daughter.

00:33:53.160 --> 00:33:54.120
We went to the speaker dinner.

00:33:54.120 --> 00:33:57.100
And there was 28 or 29 speakers there.

00:33:57.100 --> 00:33:58.980
And I think one or two women.

00:33:58.980 --> 00:34:02.560
And my daughter looked at me after a while and goes, where are all the women?

00:34:03.220 --> 00:34:06.560
And I said, you know, this is a sad part of the tech industry.

00:34:06.560 --> 00:34:08.980
And when I go to Python conferences, I don't feel that way.

00:34:08.980 --> 00:34:10.440
And, you know, I just think that's great.

00:34:10.440 --> 00:34:15.720
I've personally always been a feminist, although never a radical one.

00:34:15.720 --> 00:34:20.600
Encouraging women has been a pretty natural thing for me.

00:34:20.600 --> 00:34:25.640
I think there was a specific series of events.

00:34:25.640 --> 00:34:28.140
I'm not entirely sure when it was.

00:34:28.200 --> 00:34:33.020
But I remember that there was some upset maybe around a decade ago at OSCOM.

00:34:33.020 --> 00:34:48.060
Some people started pointing out that the open source community was, despite all its sort of pride in, well, we care about results, rough consensus and working code and all that.

00:34:48.060 --> 00:34:50.160
There was not a very diverse community.

00:34:50.620 --> 00:34:58.520
And the number of women that someone counted at OSCOM, I believe, was well below even the already low industry level.

00:34:58.520 --> 00:35:01.260
Somehow that was a wake-up call for me.

00:35:01.260 --> 00:35:05.240
There had always been a few active women in the Python community.

00:35:05.240 --> 00:35:10.280
And I had never really counted how many there were or if it was always the same, two or three.

00:35:10.520 --> 00:35:25.620
But because of that discussion at OSCOM that I did not participate or even witness in person, but that's through various blogs and peripheral vision came to my attention, I thought, hmm, what's the situation in Python community?

00:35:25.620 --> 00:35:27.940
Actually, we're not doing great.

00:35:28.480 --> 00:35:39.520
So I sort of made a mental note of, well, maybe we ought to think of how to increase the participation, the diversity in the Python community.

00:35:39.520 --> 00:35:54.640
And I think that the main consequence of that was that when there were actually women who came to the Python community or were already part of the Python community and said, we would like to do something for women.

00:35:54.640 --> 00:35:57.220
We would like this community to be more welcoming.

00:35:57.220 --> 00:35:59.380
I thought, that's a great idea.

00:35:59.380 --> 00:36:00.420
Let's do that.

00:36:00.420 --> 00:36:11.660
Rather than responding in a way that some other tech communities have responded by feeling threatened or, oh, we don't have to do anything.

00:36:11.660 --> 00:36:14.880
If you're a good coder, you're a good coder, and then you're welcome.

00:36:14.880 --> 00:36:19.580
And if you're not a good coder, you're not welcome, regardless of whether you're a man or a woman.

00:36:19.580 --> 00:36:26.720
That's actually a fair amount of bullshit in that attitude because those people don't realize how much bias there is.

00:36:26.720 --> 00:36:42.460
So I've always been very open to the PSF and PyCon and various groups to try and reverse that bias by giving sort of diversity funding to PyCon attendees, for example.

00:36:42.460 --> 00:36:46.260
I think I should call out specifically Jessica McKellar.

00:36:46.260 --> 00:36:47.300
Yeah, I was going to bring her up.

00:36:47.300 --> 00:36:53.020
Who has been a champion of this for a long time, has given some fabulous keynotes about this.

00:36:53.760 --> 00:36:59.620
And all I had to do was be supportive there, I felt, which came naturally.

00:36:59.620 --> 00:37:08.460
I remember in real world politics, since I was a voting age, I've always made a point of voting for a woman whenever I could.

00:37:08.460 --> 00:37:12.020
I think the progress that's been made is really fabulous.

00:37:12.020 --> 00:37:14.580
And you're right that Jessica deserves a lot of credit for that.

00:37:14.580 --> 00:37:16.060
She's been fabulous at it.

00:37:16.060 --> 00:37:21.380
We're in a much better place than we were before with regard to that.

00:37:21.460 --> 00:37:23.240
Although I still think there's more work to do.

00:37:23.240 --> 00:37:23.900
Absolutely.

00:37:23.900 --> 00:37:25.740
I'm super happy to see the direction.

00:37:25.740 --> 00:37:27.280
There's always more work to do.

00:37:27.280 --> 00:37:29.760
And diversity is not just about women either.

00:37:29.760 --> 00:37:30.620
Absolutely.

00:37:30.620 --> 00:37:31.400
Let's remember that.

00:37:31.400 --> 00:37:31.740
Yep.

00:37:31.740 --> 00:37:32.060
Yep.

00:37:32.060 --> 00:37:32.500
Absolutely.

00:37:32.500 --> 00:37:33.080
Yeah.

00:37:33.080 --> 00:37:36.080
It was just the top of my mind because my daughter was so struck.

00:37:36.080 --> 00:37:40.660
I took her to this tech conference thinking, oh, I'd really like to show her how cool the tech scene is and stuff.

00:37:40.660 --> 00:37:47.280
And she did come away with that, but she also came away with a little bit of the feeling like maybe this is not for women, which made me a little bit.

00:37:47.280 --> 00:37:49.300
I just felt bad about it, right?

00:37:49.300 --> 00:37:50.520
Oh, that's terrible.

00:37:50.520 --> 00:37:51.140
Yeah.

00:37:51.140 --> 00:37:51.840
Yeah, it is.

00:37:51.840 --> 00:37:52.140
It is.

00:37:52.820 --> 00:37:53.340
All right.

00:37:53.340 --> 00:37:55.000
So let's shift gears a little bit.

00:37:55.000 --> 00:38:11.200
And, you know, one of the things that there's a lot of talk about right now and I think is turning a corner in a very positive way, but has definitely been a hot topic lately and over the last few years is Python 3 and the migration towards Python 3.

00:38:11.400 --> 00:38:12.220
Ha, yes.

00:38:12.220 --> 00:38:23.220
I love your attitude when I see you speak at conferences and do keynotes and there's a great 2.8 sign with like a slash through it just saying, look, we're moving forward.

00:38:23.220 --> 00:38:24.900
We're not going back, you guys.

00:38:24.900 --> 00:38:27.080
How do you feel we're doing on that?

00:38:27.080 --> 00:38:35.300
That certainly has been a much harder, more arduous journey than anybody had really anticipated.

00:38:35.300 --> 00:38:38.720
I think right now we're well over the hump.

00:38:38.720 --> 00:38:40.320
The destination is in sight.

00:38:40.620 --> 00:38:49.860
It's clearly better on the other side, but the mountain range was much bigger and colder, whatever, scarier than we had anticipated.

00:38:49.860 --> 00:39:01.820
And I think that honestly, the mistake that all of us in the Python core and actually the whole Python community, the mistake we made was underestimating Python's popularity.

00:39:02.440 --> 00:39:25.340
We sort of thought of Python as this sort of relatively small language with a relatively small number of dedicated followers who would all jump at the occasion of making their code more readable and converting to this new version of the language that was so clearly better in many ways.

00:39:25.680 --> 00:39:34.920
And what we just underestimated how much code people had written in Python 2 and really old versions of Python 2 and that.

00:39:34.920 --> 00:39:54.060
How much documentation there was that would have to be updated, not just the standard library and the core Python documentation and the reference manual, but all the hundreds of Python books and websites and answer sites and stack overflow questions and this and that.

00:39:54.160 --> 00:40:05.620
And we just initially, when we first started talking about Python 3 and actually the first time that the term came up was around the year 2000.

00:40:05.860 --> 00:40:09.740
It then took seven or eight years before we did anything about that.

00:40:09.740 --> 00:40:22.220
But initially, from our perspective and certainly from my perspective, but that everyone who participated in Python 3 had sort of had the same experience.

00:40:22.220 --> 00:40:26.000
Everybody was excited about this change.

00:40:26.000 --> 00:40:28.060
We're going to fix the language.

00:40:28.060 --> 00:40:29.480
There are all these Python words.

00:40:29.480 --> 00:40:36.440
Andrew Cushling, who was an important early core developer, had very influential posts about Python words.

00:40:36.440 --> 00:40:45.480
And he enumerated maybe a dozen of sort of key issues with the language that we were hoping we could somehow improve.

00:40:45.480 --> 00:40:49.440
And one example was in 2000, we introduced Unicode.

00:40:49.440 --> 00:40:53.740
And we introduced it in a way that would be incredibly backwards compatible.

00:40:53.740 --> 00:41:10.460
And by the time, three or four years later, when that design had completely been settled, we started finding out that applications actually became more brittle because they didn't expect the Unicode to pop up in places where it happened.

00:41:10.460 --> 00:41:15.120
And that was one of the things that we wanted to fix in Python 3.

00:41:15.640 --> 00:41:29.820
But we had no idea that there were people with millions of lines of Python code that was all interrelated and written by people who were no longer with that team or that company or that project.

00:41:29.820 --> 00:41:32.720
And what it would take.

00:41:32.820 --> 00:41:52.400
I mean, had we known we could have taken a different tack, we could have made Python 3 somehow, we could have changed a few features in Python 3 to allow somehow Python 2 and Python 3 code to coexist in the same virtual machine.

00:41:52.400 --> 00:41:52.820
Sure.

00:41:52.820 --> 00:41:56.760
Somehow make it just seriously deprecated, but not gone.

00:41:56.760 --> 00:41:57.600
Things like that.

00:41:57.600 --> 00:41:58.440
Some of the features, right?

00:41:58.580 --> 00:41:58.800
Yeah.

00:41:58.800 --> 00:42:03.960
And had we really wanted that, we could have done that.

00:42:03.960 --> 00:42:20.640
But we underestimated the difficulty it would be for the average Python user to convert their code because we thought, well, someone has a few scripts here and a few scripts there and maybe a thousand line library that they're using.

00:42:20.640 --> 00:42:24.000
But in fact, all the numbers were 10 or 100 times larger.

00:42:24.000 --> 00:42:25.760
Making it so much harder to switch.

00:42:25.760 --> 00:42:26.580
Right.

00:42:26.880 --> 00:42:27.160
Yeah.

00:42:27.160 --> 00:42:27.200
Yeah.

00:42:27.200 --> 00:42:34.500
And once we realized that this was not an ideal situation, there wasn't any chance of sort of backing out.

00:42:34.500 --> 00:42:39.340
And there was also no chance of suddenly accelerating the conversion process.

00:42:39.340 --> 00:42:54.880
So we've done the best we felt we could do, which included actually backporting many things to Python 2.7 in terms of libraries that were available and backporting even more things on PyPI.

00:42:54.880 --> 00:43:01.180
Like you can use the enum 3.4 package, I think, in Python 2.7.

00:43:01.180 --> 00:43:03.340
Then you can use enums in Python 2.

00:43:03.340 --> 00:43:12.900
But we also wanted to give the community and the users a sort of a clear message about the future of Python.

00:43:12.900 --> 00:43:16.820
And that's where the sort of no 2.8 banner came from.

00:43:17.180 --> 00:43:22.440
You can always say, well, maybe we should have done this differently, but I'm not sure that it would have necessarily been different.

00:43:22.440 --> 00:43:32.600
You could have said, well, we're going to leave our leave basically some 2.7 or Python 2 in Python 3 and just put new features and clean up around it.

00:43:32.640 --> 00:43:37.000
But then you still have all this old code that still is written in the 2.7 style.

00:43:37.000 --> 00:43:41.780
And the fact that people adopt the three features, you know, maybe they wouldn't.

00:43:41.780 --> 00:43:48.400
And it would have been more of a hindrance rather than just going, all right, we're just going to have to make this break and just jump the gap to get there.

00:43:48.400 --> 00:43:49.640
It's a complex problem.

00:43:49.640 --> 00:43:51.100
There's no perfect solution.

00:43:51.100 --> 00:43:55.260
And you also can't just stop evolving the language.

00:43:55.260 --> 00:43:55.940
Absolutely.

00:43:55.940 --> 00:44:00.020
I feel like Python 3 is going so fast and doing so much.

00:44:00.020 --> 00:44:01.760
It's really positive.

00:44:01.760 --> 00:44:02.340
Thank you.

00:44:02.340 --> 00:44:03.120
Yeah, you're welcome.

00:44:03.120 --> 00:44:16.640
A term that I started using, I got this from Matthias, I'm forgetting his last name, I'm sorry, from some of the Jupyter projects, is referring to Python 3 as Python and Python 2 as legacy Python.

00:44:16.640 --> 00:44:20.080
And I think that's an interesting way to think about it.

00:44:20.080 --> 00:44:29.380
You can try to change the language in the hope that people will subliminally be sort of influenced.

00:44:29.380 --> 00:44:31.580
I don't know how effective that is.

00:44:31.580 --> 00:44:42.580
I think the highway administration or whatever it's called have attempted to remove the word accident from our language and replace it with crash.

00:44:43.160 --> 00:44:46.000
That's wishful thinking in my view.

00:44:46.000 --> 00:44:53.220
And I think it's pretty consistently just say Python 2 and Python 3 whenever the distinction is important.

00:44:53.220 --> 00:44:58.320
You know, to round out this part of the discussion, I definitely feel like we've crossed the boundary.

00:44:58.320 --> 00:44:58.860
Absolutely.

00:44:59.140 --> 00:44:59.780
It's gained momentum.

00:44:59.780 --> 00:45:04.320
I see more and more projects that say either we're Python 3 first or Python 3 only.

00:45:04.320 --> 00:45:06.500
And if people want to backport it, that's fine.

00:45:06.500 --> 00:45:08.120
And this is the right path.

00:45:08.340 --> 00:45:18.480
The really good news is that basically all important libraries work as well with Python 3 as they do with Python 2 or better.

00:45:18.480 --> 00:45:27.900
Which means that the early problem with Python 3 adoption was that, well, if you had a thousand lines of pure Python code, that was very easy to port.

00:45:28.160 --> 00:45:36.700
But if you had a thousand lines of Python 2 that depended on seven different packages, you had to wait for those packages to be ported.

00:45:36.700 --> 00:45:38.900
That has taken a long time.

00:45:38.900 --> 00:45:43.740
And that was, I think, one of the issues that we underestimated.

00:45:43.860 --> 00:45:47.060
But that problem has now pretty much been solved completely.

00:45:47.060 --> 00:45:52.220
NumPy, Django, Flask, everything you can think of works with Python 3.

00:45:52.220 --> 00:45:53.940
Even DateUtil.

00:45:53.940 --> 00:46:01.260
If you want to start writing application code from scratch, there's nothing to stop you from using Python 3.

00:46:01.260 --> 00:46:02.280
Yeah, and that's really great.

00:46:02.280 --> 00:46:05.180
I do feel like that was maybe the single biggest barrier.

00:46:05.180 --> 00:46:17.660
Because even if people had the intention of switching to Python 3, but they depended upon these libraries and they just couldn't run, well, they're like, well, you're going to throw their hands up and say, well, I can't convert all these libraries.

00:46:17.660 --> 00:46:18.420
I got work to do.

00:46:18.420 --> 00:46:18.720
Yeah.

00:46:18.720 --> 00:46:19.080
Yeah.

00:46:19.080 --> 00:46:22.380
So let's do one more Python 3 topic here.

00:46:22.380 --> 00:46:25.580
Let's touch on a little bit of your favorite Python 3 features.

00:46:25.580 --> 00:46:35.020
The two that I've been, I think, most directly involved in were AsyncIO until two years ago.

00:46:35.020 --> 00:46:42.520
Since then, AsyncIO has matured to the point where I don't have to be involved all that much directly.

00:46:42.520 --> 00:46:51.400
Although I carefully encouraged and reviewed the development towards Async and the wait, which has been absolutely marvelous.

00:46:51.840 --> 00:47:05.160
The other favorite of mine is function annotations and what we now have in Python 3.6, the variable annotations, PEP 5.26, and the whole type checking area.

00:47:05.160 --> 00:47:08.900
That's sort of, I think those are my favorite features.

00:47:08.900 --> 00:47:22.340
One other thing that I'm personally very happy with is the proper distinction between bytes and text in Python 3, as opposed to the messy way of dealing with that in Python 2.

00:47:22.340 --> 00:47:22.760
Sure.

00:47:22.760 --> 00:47:26.100
That absolutely solves that whole, it's Unicode, it's not Unicode.

00:47:26.100 --> 00:47:26.640
What is it?

00:47:26.640 --> 00:47:26.920
Yeah.

00:47:26.920 --> 00:47:27.260
Yeah.

00:47:27.260 --> 00:47:31.060
Unfortunately, that has also been a major porting barrier.

00:47:31.060 --> 00:47:31.460
Yeah.

00:47:31.460 --> 00:47:35.760
I've heard that several times, especially people working on web frameworks or things that touch the network.

00:47:35.760 --> 00:47:50.580
The whole generation of Python 2 programmers grew up basically between 2000 and 2010 or so, who knew all the ins and outs of the compatibility and incompatibility between Unicode and bytes.

00:47:50.580 --> 00:48:08.020
And sometimes it interoperates with Unicode and sometimes it doesn't.

00:48:08.020 --> 00:48:17.200
But people got used to the ambiguity and actually exploited it in their APIs, which made their APIs difficult to port forward to Python 3.

00:48:17.200 --> 00:48:31.780
This portion of Talk Python is brought to you by Hired.

00:48:31.780 --> 00:48:34.820
Hired is the platform for top Python developer jobs.

00:48:34.820 --> 00:48:39.620
Create your profile and instantly get access to 3,500 companies who will work to compete with you.

00:48:39.940 --> 00:48:42.480
Take it from one of Hired's users who recently got a job and said,

00:48:42.480 --> 00:48:47.780
I had my first offer on Thursday after going live on Monday and I ended up getting eight offers in total.

00:48:47.780 --> 00:48:51.240
I've worked with recruiters in the past, but they've always been pretty hit and miss.

00:48:51.240 --> 00:48:54.080
I tried LinkedIn, but I found Hired to be the best.

00:48:54.080 --> 00:48:56.180
I really like knowing the salary up front.

00:48:56.180 --> 00:48:58.540
Privacy was also a huge seller for me.

00:48:58.540 --> 00:49:00.220
Sounds awesome, doesn't it?

00:49:00.220 --> 00:49:02.220
Well, wait until you hear about the sign-in bonus.

00:49:02.680 --> 00:49:05.660
Everyone who accepts a job from Hired gets $1,000 signing bonus.

00:49:05.660 --> 00:49:08.300
And as Talk Python listeners, it gets way sweeter.

00:49:08.300 --> 00:49:13.560
Use the link Hired.com slash Talk Python to me and Hired will double the signing bonus to $2,000.

00:49:13.560 --> 00:49:15.340
Opportunity's knocking.

00:49:15.340 --> 00:49:19.100
Visit Hired.com slash Talk Python to me and answer the door.

00:49:25.560 --> 00:49:31.220
So does it surprise you that new things are still happening in the CPython internals?

00:49:31.220 --> 00:49:35.960
Like dictionary got a major reworking in 3.6, things like that?

00:49:35.960 --> 00:49:37.600
It doesn't really surprise me.

00:49:37.600 --> 00:49:43.460
Dictionaries in particular are such an incredibly fundamental part of Python.

00:49:43.460 --> 00:49:49.440
It's used everywhere internally and it's used everywhere in applications.

00:49:50.440 --> 00:49:56.900
That it's totally par for the course that every, at least once every decade, maybe twice,

00:49:56.900 --> 00:49:59.880
some major innovation happens in that area.

00:49:59.880 --> 00:50:06.180
I remember when I first started Python, there was like, well, dictionaries were obviously something

00:50:06.180 --> 00:50:06.720
I needed.

00:50:06.720 --> 00:50:13.040
And in reaction to ABC, which used B trees, or at least some kind of, some form of balance

00:50:13.040 --> 00:50:17.500
trees, which I thought was very tedious and I had worked on that code forever in ABC and

00:50:17.500 --> 00:50:18.480
it was always buggy.

00:50:18.480 --> 00:50:21.980
So I thought, well, for Python, I'll do a hash table.

00:50:21.980 --> 00:50:22.980
That's a new thing.

00:50:22.980 --> 00:50:26.040
And I just sort of looked it up in Knuth volume three.

00:50:26.040 --> 00:50:28.200
What's the basic hashing algorithm?

00:50:28.200 --> 00:50:29.580
How do you hash a string?

00:50:29.580 --> 00:50:31.640
What, how do you implement a hash table?

00:50:31.640 --> 00:50:34.500
Well, open hashing or linked lists.

00:50:34.500 --> 00:50:38.460
And I made my decisions and implemented it.

00:50:38.460 --> 00:50:42.140
And then I had to move on to other things, module objects, functions.

00:50:42.140 --> 00:50:44.260
You'd write the whole thing, basically.

00:50:44.260 --> 00:50:47.940
I had to build a whole language, long integers, exceptions.

00:50:48.120 --> 00:50:49.000
Bytecode.

00:50:49.000 --> 00:50:56.420
So the first innovation, I think, happened when someone with an actual mathematical schooling

00:50:56.420 --> 00:51:01.920
in that area realized that I had copied an old algorithm from Knuth that was no longer

00:51:01.920 --> 00:51:02.860
state of the art.

00:51:02.860 --> 00:51:08.220
And there was something like, I think I, Knuth had discovered that it was good if you had

00:51:08.220 --> 00:51:12.180
hash table sizes that were primes or something, relative primes.

00:51:12.960 --> 00:51:19.780
And it turned out with changes in processor architecture, powers of two were suddenly better.

00:51:19.780 --> 00:51:20.340
Interesting.

00:51:20.340 --> 00:51:20.640
Yeah.

00:51:20.640 --> 00:51:22.060
I've always heard primes as well.

00:51:22.060 --> 00:51:23.200
So that's still in my mind.

00:51:23.200 --> 00:51:23.420
Yeah.

00:51:23.420 --> 00:51:25.980
That's no longer the state of the art.

00:51:26.120 --> 00:51:34.420
I mean, the caches in CPUs and the whole sort of L1, L2, L3 memory architecture has affected

00:51:34.420 --> 00:51:37.700
language implementations dramatically.

00:51:37.700 --> 00:51:41.400
And I don't even know all the ins and outs of that area.

00:51:41.560 --> 00:51:45.540
Unfortunately, we have other core developers who keep up with that and do that for me.

00:51:45.540 --> 00:51:46.260
Yeah, that's great.

00:51:46.260 --> 00:51:46.700
That's great.

00:51:46.700 --> 00:51:48.680
I'm sure we could dig into all sorts of those things.

00:51:48.680 --> 00:51:53.000
And there's so many other questions that I'd like to ask you.

00:51:53.000 --> 00:51:55.540
I want to be respectful of your time and not go too long.

00:51:55.620 --> 00:51:58.020
So let me ask you one final Python question.

00:51:58.020 --> 00:52:00.460
What do you see coming in Python 3.7?

00:52:00.460 --> 00:52:02.420
And what would you like to see there?

00:52:02.420 --> 00:52:07.000
Well, I mentioned earlier that I'm not the greatest visionary.

00:52:07.000 --> 00:52:10.900
Also, 3.6 only came out a month ago.

00:52:10.900 --> 00:52:17.080
Unlike some other languages, there's no secret cabal of people who are already planning what

00:52:17.080 --> 00:52:19.280
the language looks like five years from now.

00:52:19.980 --> 00:52:26.120
I'm sure somewhere there's a C++ committee that's anxiously designing C++ 19 or 20 or

00:52:26.120 --> 00:52:28.060
whatever the next version is going to be.

00:52:28.060 --> 00:52:30.740
Well, that's not how we do things in Python.

00:52:30.740 --> 00:52:39.520
And we just over time during the alpha stage of the next feature version, we tend to just

00:52:39.520 --> 00:52:47.700
collect ideas and peps and proposals and often a real life experience with the previous major

00:52:47.700 --> 00:52:52.980
version or the previous feature version, I should say, directs an evolution.

00:52:52.980 --> 00:53:01.700
For example, we added async.io in Python 3.4, which led Yuri Selvanov to come up with the

00:53:01.700 --> 00:53:06.940
idea of async, def and await and introduce that in 3.5.

00:53:06.940 --> 00:53:09.320
That's great because that really cleans up that API.

00:53:09.320 --> 00:53:11.860
That is an incredible improvement.

00:53:11.860 --> 00:53:18.980
And that is not something we could ever have done if we hadn't had the clunky version of

00:53:18.980 --> 00:53:23.420
async.io with yield from in Python 3.4.

00:53:23.420 --> 00:53:25.860
Because the generators actually are...

00:53:25.860 --> 00:53:27.320
I love the story of generators.

00:53:27.320 --> 00:53:34.240
I can talk for hours about that because it has been such a rich source of language improvements

00:53:34.240 --> 00:53:44.560
from the very early for loop to iterators and generators and coroutines and yield from and

00:53:44.560 --> 00:53:50.160
then async await and sort of small improvements to that in 3.6 even.

00:53:50.160 --> 00:53:53.260
That's been a very gratifying thing.

00:53:53.260 --> 00:53:55.500
But I don't know what's going to happen there next.

00:53:55.500 --> 00:53:56.600
Yeah, sure.

00:53:56.720 --> 00:54:02.860
I expect that static typing, optional static typing, what we're doing with mypy, that's

00:54:02.860 --> 00:54:04.740
my current project at Dropbox actually.

00:54:04.740 --> 00:54:09.740
I expect that will also make strides forward.

00:54:09.740 --> 00:54:13.780
But I don't know what those strides are going to be yet.

00:54:13.780 --> 00:54:18.620
Yeah, so it really highlights that the language is a journey and a living thing, right?

00:54:18.620 --> 00:54:21.300
You take a step and you look around.

00:54:21.860 --> 00:54:28.160
You see the landscape that you just ventured into from a different vantage point and you

00:54:28.160 --> 00:54:33.840
can pick a different destination or you can plan your next step or day trip or whatever

00:54:33.840 --> 00:54:36.280
metaphor you want to use.

00:54:36.280 --> 00:54:43.660
You can plan your next evolution based on where you are and what you see.

00:54:44.000 --> 00:54:51.040
And sometimes that just comes like, whoa, we see all these people using this feature that

00:54:51.040 --> 00:54:55.980
we just introduced two versions ago in a completely novel and interesting way.

00:54:55.980 --> 00:55:02.820
And now we suddenly realize, oh, there is a better syntax or a better API that's sort of

00:55:02.820 --> 00:55:04.260
waiting to come out.

00:55:04.260 --> 00:55:05.680
And that's very exciting.

00:55:05.880 --> 00:55:12.140
But I don't have sort of very specific plans for 3.7 yet, let alone beyond.

00:55:12.140 --> 00:55:19.700
The only thing that's sort of possibly way beyond would be the gillectomy, the removal of the

00:55:19.700 --> 00:55:20.020
gill.

00:55:20.020 --> 00:55:23.900
But that is also not at all certain.

00:55:23.900 --> 00:55:26.440
And it's a very complicated story.

00:55:26.440 --> 00:55:28.960
You could talk about the gillectomy for quite a while.

00:55:28.960 --> 00:55:32.780
And it's definitely an interesting area of focus.

00:55:33.480 --> 00:55:38.300
So does this sort of, you take one step, you climb one mountain, you see a new horizon of

00:55:38.300 --> 00:55:38.740
possibilities.

00:55:38.740 --> 00:55:44.060
Is that one of the things that keeps you interested in working on Python and maintaining and overseeing

00:55:44.060 --> 00:55:44.920
the language over time?

00:55:44.920 --> 00:55:50.100
The excitement of actually climbing a mountain and then seeing a whole new valley that you

00:55:50.100 --> 00:55:53.140
didn't know existed certainly motivates me.

00:55:53.140 --> 00:55:54.260
Yeah, that's excellent.

00:55:54.260 --> 00:55:56.000
So I guess we'll leave it there.

00:55:56.000 --> 00:55:59.220
Let me ask you two questions before we get out of here.

00:55:59.220 --> 00:56:03.000
First, if you're going to write some Python code, what editor do you open?

00:56:03.380 --> 00:56:03.700
Emacs.

00:56:03.700 --> 00:56:05.860
Well, actually, I don't open it.

00:56:05.860 --> 00:56:06.680
It's already open.

00:56:06.680 --> 00:56:08.120
It just stays open.

00:56:08.120 --> 00:56:10.980
Well, my shell also mostly runs in Emacs.

00:56:10.980 --> 00:56:11.440
Yeah.

00:56:11.440 --> 00:56:12.120
Oh, fantastic.

00:56:12.120 --> 00:56:12.560
Okay.

00:56:12.560 --> 00:56:17.880
I know you don't like to play favorites, but if there's a notable PyPI package that you really

00:56:17.880 --> 00:56:20.860
want to highlight that maybe people don't know about, but you'd like to say, hey, you guys

00:56:20.860 --> 00:56:23.620
really should check this out because it's a cool example of something.

00:56:23.620 --> 00:56:24.780
What comes to mind?

00:56:25.040 --> 00:56:31.400
Actually, the one thing I want to highlight here is mypy, which is a static type checker

00:56:31.400 --> 00:56:37.620
for Python that I didn't write, although I have now been contributing to it for well over

00:56:37.620 --> 00:56:37.980
a year.

00:56:38.420 --> 00:56:41.840
But it's still mostly Yuka Lettosolo's creation.

00:56:41.840 --> 00:56:44.580
And we're using this at Dropbox.

00:56:44.580 --> 00:56:51.760
And we have over 400,000 lines of annotated code in a code base that totals over 4 million

00:56:51.760 --> 00:56:52.480
lines of code.

00:56:52.600 --> 00:56:59.120
So we have a ways to go, but we also have more than 500 developers who are interacting

00:56:59.120 --> 00:57:08.120
with this tool and who, by and large, are very happy with how adding type annotations makes

00:57:08.120 --> 00:57:13.960
the code more understandable and more readable and sort of makes them more confident when they

00:57:13.960 --> 00:57:16.360
want to undertake refactorings and things like that.

00:57:17.160 --> 00:57:24.980
And mypy, the specific reason I want to highlight mypy as a PyPI package is that until a week

00:57:24.980 --> 00:57:31.980
ago, if you tried pip install mypy, you would get some completely unrelated package that is

00:57:31.980 --> 00:57:35.460
named mypy that has not been maintained for five years.

00:57:35.460 --> 00:57:41.540
And we finally convinced the leadership of PyPI to give us that project name.

00:57:41.540 --> 00:57:44.040
And now you can say pip install mypy.

00:57:44.040 --> 00:57:46.300
Actually, you have to do pip 3 install mypy.

00:57:46.560 --> 00:57:48.980
And it will actually do what you expect it to do.

00:57:48.980 --> 00:57:50.900
Okay, well, that sounds really excellent.

00:57:50.900 --> 00:57:55.560
It's great to see you guys using the type annotations and things like that at Dropbox.

00:57:55.560 --> 00:58:00.600
Guido, we have a final chance for you to give a call to action to the community.

00:58:00.600 --> 00:58:02.320
What would you like people to do?

00:58:02.320 --> 00:58:03.440
What's on your mind?

00:58:03.440 --> 00:58:07.880
Well, I really do want people to give mypy a try.

00:58:07.880 --> 00:58:10.200
That static type checker is pretty amazing.

00:58:10.200 --> 00:58:16.300
And I need to point out that there are still a lot of misunderstandings about what it can do

00:58:16.300 --> 00:58:17.420
and what it cannot do.

00:58:17.420 --> 00:58:23.860
Static types are completely orthogonal or almost completely orthogonal to unit testing, for example.

00:58:23.860 --> 00:58:26.840
It doesn't mean you have to write fewer tests.

00:58:26.840 --> 00:58:31.420
Occasionally, there are a few trivial tests you don't need to write because the static checker

00:58:31.420 --> 00:58:34.340
catches the same issues better.

00:58:34.340 --> 00:58:39.660
But by and large, a type checker just catches a very different category of errors than unit tests.

00:58:39.740 --> 00:58:41.620
So they complement each other nicely.

00:58:41.620 --> 00:58:44.100
And together, they give you more confidence.

00:58:44.100 --> 00:58:50.340
One of the misunderstandings about mypy has also been that when we started PEP 484, that

00:58:50.340 --> 00:58:53.400
the sort of the introduction of type checking was Python 3 only.

00:58:53.580 --> 00:58:55.480
But we've actually amended that.

00:58:55.480 --> 00:59:00.580
And for the past year, we've been using mypy successfully with Python 2 code base.

00:59:00.580 --> 00:59:01.120
Okay.

00:59:01.120 --> 00:59:07.040
So you can search PEP 484 for Python 2 support.

00:59:07.040 --> 00:59:09.440
And it's completely there.

00:59:09.440 --> 00:59:13.060
And mypy does as well on Python 2 as it does on Python 3.

00:59:13.060 --> 00:59:14.140
Oh, that's really nice.

00:59:14.140 --> 00:59:20.200
Yeah, the other misunderstanding about mypy or static typing in Python is that people have

00:59:20.200 --> 00:59:24.760
predicted that they will turn your Python code into Java, which is obviously nonsense.

00:59:24.760 --> 00:59:28.460
There's no interfaces all over the place.

00:59:28.460 --> 00:59:29.000
Yeah.

00:59:29.000 --> 00:59:35.400
So I think actually moving that type annotations to Python 2 is really important because it provides

00:59:35.400 --> 00:59:38.460
some foundation for when you do want to upgrade to Python 3.

00:59:38.460 --> 00:59:39.020
Correct.

00:59:39.020 --> 00:59:44.480
My secret plan at Dropbox is actually that once we have a large enough fraction of the

00:59:44.480 --> 00:59:51.120
code base annotated, we can start converting into Python 3 in a semi-automated fashion in

00:59:51.120 --> 00:59:55.040
a way that would not be possible without those annotations.

00:59:55.040 --> 00:59:58.220
We're not there yet, but that's my secret plan.

00:59:58.220 --> 00:59:59.220
That's fantastic.

00:59:59.220 --> 00:59:59.980
All right.

00:59:59.980 --> 01:00:02.380
Well, I want to say thank you again for the conversation.

01:00:02.380 --> 01:00:07.260
I really enjoyed talking with you and I'm sure everyone out there learned a lot.

01:00:07.260 --> 01:00:08.760
So thanks so much for being on the show.

01:00:08.760 --> 01:00:09.520
My pleasure.

01:00:09.520 --> 01:00:10.040
Yeah.

01:00:10.040 --> 01:00:10.780
Hope it's a good one.

01:00:10.780 --> 01:00:11.660
It's going to be a great one.

01:00:11.660 --> 01:00:12.000
Bye.

01:00:12.000 --> 01:00:12.440
Bye.

01:00:12.440 --> 01:00:16.460
This has been another episode of Talk Python to Me.

01:00:16.460 --> 01:00:21.020
Today's guest has been Guido Van Rossum and this episode has been sponsored by Rollbar

01:00:21.020 --> 01:00:21.700
and Hired.

01:00:21.700 --> 01:00:23.640
Thank you both for sponsoring the show.

01:00:23.640 --> 01:00:27.060
I want to say thank you again to Guido as well.

01:00:27.060 --> 01:00:29.100
It was really an honor to have him on the show.

01:00:29.100 --> 01:00:32.420
I know he's a very busy guy and there are tons of demands on his time.

01:00:32.420 --> 01:00:34.400
So thank you, Guido, for being on the show.

01:00:34.400 --> 01:00:37.260
I know everyone really enjoyed hearing your perspective.

01:00:38.220 --> 01:00:40.280
Rollbar takes the pain out of errors.

01:00:40.280 --> 01:00:45.040
They give you the context and insight you need to quickly locate and fix errors that

01:00:45.040 --> 01:00:47.980
might have gone unnoticed until your users complain, of course.

01:00:47.980 --> 01:00:52.800
As Talk Python to Me listeners, track a ridiculous number of errors for free at

01:00:52.800 --> 01:00:55.140
rollbar.com slash Talk Python to Me.

01:00:55.140 --> 01:00:58.380
Hired wants to help you find your next big thing.

01:00:58.380 --> 01:01:03.120
Visit Hired.com slash Talk Python to Me to get five or more offers with salary and equity

01:01:03.120 --> 01:01:06.880
presented right up front and a special listener signing bonus of $2,000.

01:01:06.880 --> 01:01:10.020
Are you or a colleague trying to learn Python?

01:01:10.020 --> 01:01:14.720
Have you tried books and videos that just left you bored by covering topics point by point?

01:01:14.720 --> 01:01:20.720
Well, check out my online course, Python Jumpstart, by building 10 apps at talkpython.fm/course

01:01:20.720 --> 01:01:23.320
to experience a more engaging way to learn Python.

01:01:23.940 --> 01:01:28.120
And if you're looking for something a little more advanced, try my WritePythonic code course

01:01:28.120 --> 01:01:30.660
at talkpython.fm/Pythonic.

01:01:30.660 --> 01:01:33.140
Be sure to subscribe to the show.

01:01:33.140 --> 01:01:35.340
Open your favorite podcatcher and search for Python.

01:01:35.340 --> 01:01:36.580
We should be right at the top.

01:01:36.960 --> 01:01:42.680
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct

01:01:42.680 --> 01:01:45.880
RSS feed at /rss on talkpython.fm.

01:01:45.880 --> 01:01:50.980
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

01:01:50.980 --> 01:01:55.680
Corey just recently started selling his tracks on iTunes, so I recommend you check it out at

01:01:55.680 --> 01:01:57.660
Talk Python.fm slash music.

01:01:57.660 --> 01:02:02.100
You can browse his tracks he has for sale on iTunes and listen to the full-length version

01:02:02.100 --> 01:02:03.020
of the theme song.

01:02:03.020 --> 01:02:05.100
This is your host, Michael Kennedy.

01:02:05.500 --> 01:02:06.380
Thanks so much for listening.

01:02:06.380 --> 01:02:07.580
I really appreciate it.

01:02:07.580 --> 01:02:09.720
Smix, let's get out of here.

01:02:09.720 --> 01:02:11.720
Thanks for listening.

01:02:11.720 --> 01:02:16.840
my voice, there's no norm that I can feel within, haven't been sleeping, I've been using lots of rest,

01:02:16.840 --> 01:02:19.660
I'll pass the mic back to who rocked it best.

01:02:19.660 --> 01:02:26.660
I'll see you next time.

01:02:26.660 --> 01:02:31.980
Developers, developers, developers, developers, developers, developers, developers, developers, developers, developers.

01:02:31.980 --> 01:02:32.000
Thank you.

01:02:32.000 --> 01:03:01.980
Thank you.

