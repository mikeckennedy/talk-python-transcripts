WEBVTT

00:00:00.001 --> 00:00:05.120
SQLAlchemy is the most widely used ORM, Object Relational Mapper, for Python developers.

00:00:05.120 --> 00:00:10.640
It's been around since February 2006, but we might just be in for the most significant

00:00:10.640 --> 00:00:13.620
release since the first one, SQLAlchemy 2.0.

00:00:13.620 --> 00:00:18.960
This version adds async and await support, new context manager-friendly features everywhere,

00:00:18.960 --> 00:00:21.300
and a unified query syntax.

00:00:21.300 --> 00:00:25.480
Mike Bayer is back to give us a glimpse of what's coming and why Python's database story

00:00:25.480 --> 00:00:26.640
is just getting stronger.

00:00:27.020 --> 00:00:32.340
This is Talk Python To Me, episode 344, recorded November 10th, 2021.

00:00:32.340 --> 00:00:48.700
Welcome to Talk Python To Me, a weekly podcast on Python.

00:00:48.700 --> 00:00:50.440
This is your host, Michael Kennedy.

00:00:50.440 --> 00:00:54.640
Follow me on Twitter, where I'm @mkennedy, and keep up with the show and listen to past

00:00:54.640 --> 00:00:56.640
episodes at talkpython.fm.

00:00:56.940 --> 00:00:59.640
And follow the show on Twitter via at Talk Python.

00:00:59.640 --> 00:01:03.300
We've started streaming most of our episodes live on YouTube.

00:01:03.300 --> 00:01:09.040
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming

00:01:09.040 --> 00:01:10.880
shows and be part of that episode.

00:01:10.880 --> 00:01:15.060
Mike, welcome back to Talk Python To Me.

00:01:15.060 --> 00:01:16.180
It's been a little while.

00:01:16.180 --> 00:01:17.120
Hi, how are you doing?

00:01:17.120 --> 00:01:18.280
Hey, I'm doing really well.

00:01:18.280 --> 00:01:25.960
When we last spoke, we did speak about SQLAlchemy, of course, but it was in April of 2015.

00:01:26.360 --> 00:01:27.280
That's been a while.

00:01:27.280 --> 00:01:29.280
So was that live version 1.1?

00:01:29.280 --> 00:01:31.100
Something like that.

00:01:31.100 --> 00:01:31.940
Yeah, yeah, yeah.

00:01:31.940 --> 00:01:35.180
And that was episode five of the podcast that's been going for six years.

00:01:35.180 --> 00:01:37.180
So really early days.

00:01:37.180 --> 00:01:39.160
I appreciate you helping me kick off the show.

00:01:39.160 --> 00:01:40.700
And can you believe it's still going?

00:01:40.700 --> 00:01:41.340
That's crazy, huh?

00:01:41.340 --> 00:01:41.600
Yeah.

00:01:41.600 --> 00:01:42.380
Doing great.

00:01:42.380 --> 00:01:45.740
I'm glad Python's popular enough that it can have its own podcast.

00:01:45.740 --> 00:01:46.900
I'm pretty psyched about that.

00:01:46.900 --> 00:01:48.520
I'm super psyched about that as well.

00:01:48.520 --> 00:01:51.700
Maybe let's sort of start with that, actually.

00:01:51.700 --> 00:01:54.400
Back then, Python was already popular, right?

00:01:54.400 --> 00:01:59.340
2015, we'd already sort of hit that hockey stick growth curve that started around 2012.

00:01:59.820 --> 00:02:06.260
But even so, does Python's popularity and growth and appeal surprise you these days?

00:02:06.260 --> 00:02:07.960
No, it doesn't surprise me.

00:02:07.960 --> 00:02:10.820
I'm pleased that it's growing in popularity.

00:02:11.100 --> 00:02:15.520
I think the first thing that I saw about Python when I first got into it in the early 2000s

00:02:15.520 --> 00:02:16.880
was it's really clear.

00:02:16.880 --> 00:02:20.800
It's really unambiguous compared to everything else that I've used.

00:02:20.800 --> 00:02:26.160
And I always wanted to be involved in a language that a quote-unquote regular people can get

00:02:26.160 --> 00:02:30.300
involved with and people at a low level, high level can do things with it.

00:02:30.300 --> 00:02:34.620
I didn't want to be focusing on a computer language that would only be very high level

00:02:34.620 --> 00:02:38.160
math whizzes because I'm not a math person at all.

00:02:38.160 --> 00:02:39.840
That's why I don't really do Haskell.

00:02:40.300 --> 00:02:44.900
I wanted there to be because I worked in different jobs and I always would be, not always, but

00:02:44.900 --> 00:02:48.700
often someone that was writing all the frameworks and the architectures and then all the other

00:02:48.700 --> 00:02:50.620
people were using my frameworks.

00:02:50.620 --> 00:02:54.080
But a lot of those people were not at the level that I was.

00:02:54.080 --> 00:02:57.000
And I wanted to make sure that the stuff that I did was approachable.

00:02:57.000 --> 00:02:58.280
Python's very approachable.

00:02:58.280 --> 00:03:04.020
And the fact that now that the academic world and the media news world is getting very data

00:03:04.020 --> 00:03:06.260
oriented, surprise, they're all using Python.

00:03:06.260 --> 00:03:07.480
Yeah, yeah.

00:03:07.480 --> 00:03:08.180
Surprise, surprise.

00:03:08.180 --> 00:03:08.760
Yeah.

00:03:08.760 --> 00:03:10.800
I missed exactly what I would have expected.

00:03:10.800 --> 00:03:13.900
And of course, it might not have gone that way, but it was a pretty good bet.

00:03:13.900 --> 00:03:20.800
So it's cool that there's a data science profession now and Python is at the center of it.

00:03:20.800 --> 00:03:21.740
So I think that's really great.

00:03:22.300 --> 00:03:24.440
It makes a lot of sense that it's at the center of it.

00:03:24.440 --> 00:03:27.300
I do think it has this special appeal to people.

00:03:27.300 --> 00:03:29.600
And I think it's made up of a couple of parts.

00:03:29.600 --> 00:03:33.740
One is it's, you can be very effective with a partial understanding of Python.

00:03:33.740 --> 00:03:37.340
Like you could not even understand what a class is and you could still do meaningful stuff,

00:03:37.340 --> 00:03:37.520
right?

00:03:37.520 --> 00:03:39.420
Which a lot of languages don't have that feature.

00:03:39.420 --> 00:03:40.940
It has the packages, right?

00:03:40.940 --> 00:03:42.680
All the, I haven't even checked.

00:03:42.680 --> 00:03:43.840
Let me check it out.

00:03:43.900 --> 00:03:46.640
How many packages are on PyPI these days?

00:03:46.640 --> 00:03:48.360
338,000.

00:03:48.360 --> 00:03:54.080
That's a few things to just grab and, you know, build with like Lego block style, some of which

00:03:54.080 --> 00:03:55.340
you've contributed to up there.

00:03:55.340 --> 00:03:56.340
So that's pretty awesome.

00:03:56.340 --> 00:03:57.300
Some of the popular ones.

00:03:57.300 --> 00:03:57.860
Yeah.

00:03:57.940 --> 00:03:59.380
I think it's, I think it's fantastic.

00:03:59.380 --> 00:04:02.760
So good to see people continuing to embrace it.

00:04:02.760 --> 00:04:06.700
And you mentioned making it more accessible, right?

00:04:06.700 --> 00:04:08.680
Like there's different things of accessibility.

00:04:08.680 --> 00:04:12.620
There's, well, I can write four loops and do a list comprehension.

00:04:12.620 --> 00:04:14.000
And that's pretty easy to understand.

00:04:14.000 --> 00:04:19.480
There's another, like, I need to talk to a Postgres cluster and make it do things, right?

00:04:19.480 --> 00:04:21.300
It doesn't matter how simple Python is.

00:04:21.300 --> 00:04:27.400
When you talk to external systems, you to some degree take on the complexity of that external

00:04:27.400 --> 00:04:27.840
system.

00:04:27.840 --> 00:04:28.260
Right.

00:04:28.260 --> 00:04:36.680
And I do think ORMs and in the NoSQL world, ODMs, if you will, really democratize that as

00:04:36.680 --> 00:04:36.940
well.

00:04:36.940 --> 00:04:41.480
You can write the code in the language you already know, and it does the database stuff,

00:04:41.480 --> 00:04:48.840
including the slight mismatch of language features in SQL, like at parameter name versus

00:04:48.840 --> 00:04:51.940
question mark type of variations, right?

00:04:51.940 --> 00:04:52.460
Yeah.

00:04:52.460 --> 00:04:56.860
What's interesting, that particular variation is not even necessary.

00:04:57.060 --> 00:05:01.380
That's a quirk of the Python DB API that they decided to have different parameter styles.

00:05:01.380 --> 00:05:04.400
So yeah, we wanted to make it so you wouldn't have to worry about that.

00:05:04.400 --> 00:05:04.800
Yes.

00:05:04.800 --> 00:05:10.120
As far as democratizing, you know, SQLAlchemy was always aiming to democratize as much as

00:05:10.120 --> 00:05:13.760
it could to make things that are trivial and you shouldn't have to worry about like question

00:05:13.760 --> 00:05:15.200
merge versus colon name.

00:05:15.200 --> 00:05:16.840
You don't have to worry about that stuff.

00:05:16.900 --> 00:05:20.840
But at the same time, I always came from all these different database shops where we had

00:05:20.840 --> 00:05:22.720
to use every feature possible.

00:05:22.720 --> 00:05:23.220
Yeah.

00:05:23.220 --> 00:05:27.040
And it's always about exposing the database, the SQL.

00:05:27.040 --> 00:05:30.700
And SQLAlchemy remains pretty different than most tools.

00:05:30.700 --> 00:05:35.280
Any tool I've seen in Python, more or less, and probably tools in other languages that is

00:05:35.280 --> 00:05:37.780
not trying to create this abstracted way.

00:05:37.780 --> 00:05:41.740
You can't really know that there's some vaguely relational object store thing.

00:05:42.180 --> 00:05:47.600
We really want you to be in SQL and you just happen to be able to write it in terms of Python

00:05:47.600 --> 00:05:49.960
constructs where you can also write SQL strings.

00:05:49.960 --> 00:05:55.040
And we're going to try to get that to have as much flexibility as possible.

00:05:55.040 --> 00:06:00.880
There's a couple of interesting philosophies around SQLAlchemy or philosophies of SQLAlchemy

00:06:00.880 --> 00:06:02.200
that you've imbued upon it.

00:06:02.200 --> 00:06:05.120
And one of them is not to hide the database, right?

00:06:05.120 --> 00:06:09.340
Because you often end up in this leak abstraction where it's like, oh, you can just forget there's

00:06:09.340 --> 00:06:09.900
no database.

00:06:09.900 --> 00:06:11.520
Oh, wait, is it too slow?

00:06:11.520 --> 00:06:14.820
Well, now you're into some weird world where it's not a great fit, right?

00:06:14.820 --> 00:06:20.080
So maybe we could talk a bit about the philosophies a bit before we get into what's new and where

00:06:20.080 --> 00:06:20.640
things are going.

00:06:20.640 --> 00:06:21.100
Yeah.

00:06:21.100 --> 00:06:25.580
The basic philosophy has always been, and I think some years into it, I read some articles

00:06:25.580 --> 00:06:26.780
that gave me some better terminology.

00:06:26.780 --> 00:06:30.940
One of automation of working with a SQL database.

00:06:30.940 --> 00:06:34.300
Like if you're going to write an application that talks to a database and you're going to

00:06:34.300 --> 00:06:38.400
have 20 tables and say you're not using any ORM, you're just going to write

00:06:38.400 --> 00:06:39.520
where you get the rush SQL.

00:06:39.520 --> 00:06:44.300
You're going to find yourself writing the same insert statement, typing it out over and

00:06:44.300 --> 00:06:44.780
over again.

00:06:44.780 --> 00:06:47.320
Like I know that my table has 10 columns.

00:06:47.320 --> 00:06:48.640
I'm going to type this insert statement.

00:06:48.640 --> 00:06:49.840
That's what we call boilerplate.

00:06:49.840 --> 00:06:53.760
Any program that anyone writes using nothing at all, they're going to write some function

00:06:53.760 --> 00:06:56.120
to generate that insert statement, right?

00:06:56.120 --> 00:06:59.840
Like people usually talk about select statements as like the ones they want to have more control

00:06:59.840 --> 00:07:00.000
over.

00:07:00.000 --> 00:07:01.400
But there's just the boring ones.

00:07:01.400 --> 00:07:03.520
There's updates, inserts, and deletes, which are really boring.

00:07:03.960 --> 00:07:06.560
There's all the DDL for creating tables and stuff.

00:07:06.560 --> 00:07:08.220
That's very redundant.

00:07:08.220 --> 00:07:12.580
Nobody needs to, you know, if you want to learn how to do that stuff, you should learn how to

00:07:12.580 --> 00:07:12.880
do that stuff.

00:07:12.880 --> 00:07:16.920
But if you have a hundred classes, you don't want to type in a hundred create table statements.

00:07:16.920 --> 00:07:17.980
You don't want to have to do that.

00:07:17.980 --> 00:07:18.740
It should be automated.

00:07:19.260 --> 00:07:23.780
So the idea is that when you're working in this automated environment, you still know

00:07:23.780 --> 00:07:28.620
everything that's what a create table statement is, what an insert is, you know what crud somewhat

00:07:28.620 --> 00:07:29.040
is.

00:07:29.040 --> 00:07:34.260
SQL, you would know it ideally, not to say, but ideally you would know how to write this

00:07:34.260 --> 00:07:35.920
whole program without using anything.

00:07:35.920 --> 00:07:37.500
Like you would know how to use raw SQL.

00:07:37.500 --> 00:07:37.740
Right.

00:07:37.740 --> 00:07:42.600
I would say a, probably a good rule of thumb for I've studied enough SQL.

00:07:42.600 --> 00:07:49.080
I feel like I'm, I'm not hiding too much from myself by using an ORM would be if you could

00:07:49.080 --> 00:07:51.920
get the ORM to print out its statement.

00:07:51.920 --> 00:07:57.340
So in SQLAlchemy on the engine, if you set echo equals true, for example, and you know what

00:07:57.340 --> 00:08:02.540
it does when you read the statements, you're like, okay, I'm not sure I would have exactly

00:08:02.540 --> 00:08:05.100
seen to write the join that way, but okay, that makes sense.

00:08:05.160 --> 00:08:08.380
I see why it's doing, I see what this update statement, these parameters mean.

00:08:08.380 --> 00:08:08.660
Okay.

00:08:08.660 --> 00:08:11.020
Like now let's just, let's be productive.

00:08:11.020 --> 00:08:11.320
Right.

00:08:11.320 --> 00:08:12.760
What do you think about it as a rule of thumb?

00:08:12.760 --> 00:08:18.360
Echo equals true was when I first wrote SQLAlchemy, whenever I did for the first two weeks,

00:08:18.360 --> 00:08:20.020
echo equals true was right there.

00:08:20.020 --> 00:08:23.960
That was like the very first thing, like you will see the SQL.

00:08:23.960 --> 00:08:27.920
Cause I had come from using, I think I'd probably use Hibernate for a while for Java.

00:08:27.920 --> 00:08:33.500
Now it's 20 years later or 25, Hibernate I'm sure is very different, but at that time,

00:08:33.880 --> 00:08:36.500
I didn't know how to see what the heck it was sending to the database.

00:08:36.500 --> 00:08:37.600
I had no idea.

00:08:37.600 --> 00:08:40.500
I'm sure there was a way to do it, but it wasn't like obvious.

00:08:40.500 --> 00:08:43.960
It was like, you have to set up lockers and this and that and Java, this and Java, that.

00:08:43.960 --> 00:08:48.520
And the idea with Hibernate and other, it was like, you shouldn't have to know that.

00:08:48.520 --> 00:08:49.520
We do the SQL for you.

00:08:49.520 --> 00:08:50.620
Why should you know that?

00:08:50.620 --> 00:08:51.880
And yeah.

00:08:51.880 --> 00:08:52.520
Yeah.

00:08:52.520 --> 00:08:54.960
Use us correctly and we'll solve the problem.

00:08:54.960 --> 00:08:55.280
Right.

00:08:55.280 --> 00:09:00.000
I want to really one-to-one thing where you're writing this Python select dot where dot

00:09:00.000 --> 00:09:00.280
whatever.

00:09:00.280 --> 00:09:05.620
And it's like what you can one-to-one, if I had more videography skills and also a lot of

00:09:05.620 --> 00:09:10.580
time, I'd write like, I'd make some kind of cartoon that shows boom where this, how the,

00:09:10.580 --> 00:09:11.840
how it lines up at the statement.

00:09:11.840 --> 00:09:12.700
Absolutely.

00:09:12.840 --> 00:09:15.340
It was a, it's meant to not, it's not meant to hide anything.

00:09:15.340 --> 00:09:16.160
It's meant to automate.

00:09:16.160 --> 00:09:21.340
So if you had, it was just this term, the idea of a soda bottle company, like a soda company,

00:09:21.340 --> 00:09:23.280
like you're selling soda, which not, soda's not good for you.

00:09:23.280 --> 00:09:27.440
But if you had to bottle 4,000 bottles of soda, you would use a machine to do it.

00:09:27.440 --> 00:09:31.540
It's not to say that you don't know how to pour soda into a bottle yourself, but you

00:09:31.540 --> 00:09:32.560
need to scale it up.

00:09:32.560 --> 00:09:33.560
Yeah.

00:09:33.560 --> 00:09:37.820
It's about scaling up something that is very repetitive to be typing by hand.

00:09:37.820 --> 00:09:40.460
And be consistent and repetitive and whatnot.

00:09:40.460 --> 00:09:41.240
Absolutely.

00:09:41.240 --> 00:09:41.900
Absolutely.

00:09:42.220 --> 00:09:42.440
Yep.

00:09:42.440 --> 00:09:44.140
A couple of comments from the audience real quick.

00:09:44.140 --> 00:09:44.960
I just want to throw out there.

00:09:44.960 --> 00:09:47.940
D Varazo says, hello from.

00:09:47.940 --> 00:09:48.280
Danielle.

00:09:48.280 --> 00:09:49.100
Yeah.

00:09:49.100 --> 00:09:49.320
Yeah.

00:09:49.320 --> 00:09:50.260
From Psycho PG.

00:09:50.260 --> 00:09:51.860
Thank you for your kind wrapping.

00:09:51.860 --> 00:09:55.540
And Jay Lee is just cheerleading for Python, which is awesome.

00:09:55.540 --> 00:09:55.740
Yay for PyTox.

00:09:55.740 --> 00:09:57.220
Awesome.

00:09:57.220 --> 00:09:58.160
Hello, everyone out there.

00:09:58.160 --> 00:10:02.400
So yeah, I think this is really a powerful thing to think about.

00:10:02.400 --> 00:10:03.960
Just the reproducibility.

00:10:03.960 --> 00:10:11.280
And also in terms of linking into the tooling, I think one thing people often miss about the

00:10:11.280 --> 00:10:11.720
advantages.

00:10:11.720 --> 00:10:14.500
Because sometimes you'll hear people say, you should never use an RM.

00:10:14.500 --> 00:10:16.180
It's hiding too much from you.

00:10:16.180 --> 00:10:16.640
Yeah.

00:10:16.640 --> 00:10:17.060
Yeah.

00:10:17.060 --> 00:10:17.280
Yeah.

00:10:17.280 --> 00:10:17.700
Sure.

00:10:17.700 --> 00:10:18.200
Yeah.

00:10:18.200 --> 00:10:18.440
Sure.

00:10:18.440 --> 00:10:18.700
Go.

00:10:18.700 --> 00:10:20.100
I'm going to go do something.

00:10:20.100 --> 00:10:21.740
You keep working on your strings.

00:10:22.740 --> 00:10:29.420
So one of the things I can see that sometimes can easily get missed is refactoring tools.

00:10:29.420 --> 00:10:30.020
Yeah.

00:10:30.020 --> 00:10:30.360
Error checking.

00:10:30.360 --> 00:10:30.700
Right.

00:10:30.700 --> 00:10:35.900
If you write some kind of select statement on a class and you want to change that field

00:10:35.900 --> 00:10:39.100
or that column, you change the field, which obviously maps over to the column.

00:10:39.100 --> 00:10:40.960
But that also changes your entire code.

00:10:40.960 --> 00:10:46.340
If you're using a proper editor that understands refactoring, like VS Code or PyCharm or something

00:10:46.340 --> 00:10:46.860
like that, right?

00:10:46.860 --> 00:10:47.120
Yeah.

00:10:47.120 --> 00:10:51.500
A big thing with the refactoring and one of the things that we had to adapt to as it came

00:10:51.500 --> 00:10:55.020
was PEP44, which is, I call it mypy, but it's not.

00:10:55.020 --> 00:10:57.800
mypy is a tool that checks Python annotations.

00:10:57.800 --> 00:10:59.800
And we call it the mypy thing.

00:10:59.800 --> 00:11:05.360
It's really PEP44, which is that new thing where they're trying to have a kind of a layer

00:11:05.360 --> 00:11:13.640
of typing, like a strongly typed, static typed, sorry, statically typed layer on top of your

00:11:13.640 --> 00:11:14.240
Python script.

00:11:14.240 --> 00:11:19.320
So if you're a library of Python, you have to work with the system now because people expect

00:11:19.320 --> 00:11:26.240
it and the IDEs, I use VS Code now with, so that I keep forgetting the name of the engine,

00:11:26.240 --> 00:11:27.080
but that's.

00:11:27.080 --> 00:11:27.380
PyLance.

00:11:27.380 --> 00:11:27.920
You know what it is?

00:11:27.920 --> 00:11:28.780
Yeah, PyLance.

00:11:28.780 --> 00:11:30.500
I can never remember that name, PyLance.

00:11:30.500 --> 00:11:31.280
PyLance.

00:11:31.280 --> 00:11:32.080
Think of a Lance.

00:11:32.080 --> 00:11:33.040
PyLance.

00:11:33.040 --> 00:11:35.560
PyLance uses the annotations a lot.

00:11:35.560 --> 00:11:39.040
And I actually am seeing where it works and where it doesn't work.

00:11:39.040 --> 00:11:44.160
And I think the refactoring tools are greatly improved by the fact that there is this concept

00:11:44.160 --> 00:11:45.580
of static type annotations.

00:11:45.580 --> 00:11:48.080
I think there's a lot of shortcomings in PEP44.

00:11:48.340 --> 00:11:50.900
There's a lot of things that's like, eh, it's not great.

00:11:50.900 --> 00:11:55.220
I'm not 100% optimistic on it, but I definitely, it's way better than nothing.

00:11:55.220 --> 00:12:00.120
And there's some, also some features that are coming that are in PEPs that have not been

00:12:00.120 --> 00:12:00.880
implemented.

00:12:00.880 --> 00:12:05.980
This thing called variadic types that would allow us to actually be able to type your result

00:12:05.980 --> 00:12:06.760
set coming back.

00:12:06.760 --> 00:12:09.720
If you give it a select, we'll know the types in your result row.

00:12:09.940 --> 00:12:10.160
I see.

00:12:10.160 --> 00:12:13.140
Is that something like a generic or template type?

00:12:13.140 --> 00:12:16.420
It's a generic that works like the tuple type.

00:12:16.760 --> 00:12:20.260
Because you might notice in PEP44, you can't make your own tuple type.

00:12:20.260 --> 00:12:24.340
The typing that's applied to tuple is actually, if you look at the mypy source, it's hard coded.

00:12:24.340 --> 00:12:27.840
If equals tuple, then all these new special things.

00:12:27.840 --> 00:12:29.380
So things like that, they need to fix.

00:12:30.380 --> 00:12:32.340
Yeah, because rows from a database are essentially tuples.

00:12:32.340 --> 00:12:34.120
So that's how we want to type them.

00:12:34.120 --> 00:12:34.940
I do have a question.

00:12:34.940 --> 00:12:40.700
Since we're talking about the typing, I pulled up this super simple example here off of the

00:12:40.700 --> 00:12:41.980
SQLAlchemy documentation.

00:12:41.980 --> 00:12:42.760
It doesn't really matter.

00:12:42.760 --> 00:12:46.740
It's just a class that drives from declare to base, has a table name, and then it has the

00:12:46.740 --> 00:12:49.020
stuff that people probably know from many ORMs.

00:12:49.020 --> 00:12:50.380
These descriptors, right?

00:12:50.380 --> 00:12:55.360
So ID equals a column, which is of type integer, primary key equals true, name equals column, which

00:12:55.360 --> 00:12:56.420
is a string and so on.

00:12:56.420 --> 00:12:59.020
I'm going to tell you what I've been doing with this stuff lately.

00:12:59.020 --> 00:13:03.280
And you tell me whether this is a good idea or a bad idea or whatever.

00:13:03.280 --> 00:13:06.920
So what I've been doing is I've been writing this code as like this name one.

00:13:06.920 --> 00:13:11.260
I would say name colon string equals column string.

00:13:11.260 --> 00:13:16.540
So the Python code believes it's the type that's backed by the database, the column type.

00:13:16.540 --> 00:13:22.820
So name is a string, ID colon, and even though it's really set to a descriptor of column integer

00:13:22.820 --> 00:13:24.040
primary key equals true.

00:13:24.040 --> 00:13:25.240
Have you seen this?

00:13:25.240 --> 00:13:25.920
Is this a good idea?

00:13:25.920 --> 00:13:26.840
Should I be doing this?

00:13:26.840 --> 00:13:27.280
Yes.

00:13:27.400 --> 00:13:29.680
I have done a lot of work on this concept.

00:13:29.680 --> 00:13:36.940
And what you're doing is not incorrect, but there's a lot of complexities to it that require

00:13:36.940 --> 00:13:38.560
a little more going on.

00:13:38.560 --> 00:13:38.760
Right.

00:13:38.760 --> 00:13:40.580
And to be clear, I'm not doing this for mypy.

00:13:40.580 --> 00:13:44.380
I'm doing this just so my editor is more approachable to me on autocomplete.

00:13:44.380 --> 00:13:44.600
Yes.

00:13:44.600 --> 00:13:46.260
For the editor, I don't have the link handy.

00:13:46.260 --> 00:13:47.580
I'd have to go searching on my computer.

00:13:47.740 --> 00:13:54.520
So first of all, we do have a mypy plugin where you are able to use annotations like name colon

00:13:54.520 --> 00:13:59.460
string, and it will automatically work them into the correct kind of thing to be recognized

00:13:59.460 --> 00:14:00.680
also at the query level.

00:14:00.900 --> 00:14:03.120
It doesn't work with PyLance.

00:14:03.120 --> 00:14:08.120
And I have a new approach that I worked out with some other people for PyLance type stuff

00:14:08.120 --> 00:14:11.360
where we won't need a plugin, where you won't be able to make...

00:14:11.360 --> 00:14:12.820
We're not totally sure how we want to do it.

00:14:12.820 --> 00:14:14.960
The point is that you would say name colon.

00:14:14.960 --> 00:14:16.800
You wouldn't say stir.

00:14:17.040 --> 00:14:21.440
You would use this other construct called mapping or maps rather and maps.

00:14:21.440 --> 00:14:22.980
And then the map type is stir.

00:14:22.980 --> 00:14:28.720
The reason you do that is because if you use the user class in a query, not as an instance,

00:14:28.720 --> 00:14:31.360
it also has behaviors at the class level.

00:14:31.360 --> 00:14:31.900
Right.

00:14:31.900 --> 00:14:34.780
Like .desk for a descending source.

00:14:34.780 --> 00:14:35.100
Yeah.

00:14:35.100 --> 00:14:35.940
Like that kind of stuff.

00:14:35.940 --> 00:14:36.620
Something like that, right?

00:14:36.620 --> 00:14:37.260
Right.

00:14:37.260 --> 00:14:42.260
So I'm trying to work out the best way to do this where you're not typing the same...

00:14:42.260 --> 00:14:45.080
You're not repeating yourself because right now it's a little bit squirrely.

00:14:45.220 --> 00:14:48.520
The class works completely in PyLance.

00:14:48.520 --> 00:14:52.760
Everything that's expected both at the class level and at the instance level will work out.

00:14:52.760 --> 00:14:58.300
It probably requires that when you do the declarative class, you would use a slightly different API.

00:14:58.300 --> 00:15:04.400
The current proposal is instead of using uppercase column, it's this new thing called m.column.

00:15:04.400 --> 00:15:06.240
We can always change the names and how it looks.

00:15:06.240 --> 00:15:11.660
One of the flaws with that declarative model you see there is that when I came up with that

00:15:11.660 --> 00:15:17.920
declarative idea many years ago, those column objects are not Python descriptor compatible at all.

00:15:17.920 --> 00:15:20.580
They actually get replaced when you map the class.

00:15:20.580 --> 00:15:21.260
It's totally...

00:15:21.260 --> 00:15:21.300
Okay.

00:15:21.300 --> 00:15:22.240
...like a seal.

00:15:22.240 --> 00:15:23.660
It's not that clean.

00:15:24.320 --> 00:15:31.560
So I have ideas to make declarative cleaner and do more of what it's supposed to do without breaking the rules.

00:15:31.560 --> 00:15:40.120
That's the thing about Python is that as the years have gone by, everyone, even newcomers, were all much more into not into being clean about code and being more verbose.

00:15:40.120 --> 00:15:43.500
And typing is more verbose and asyncio is more verbose.

00:15:43.500 --> 00:15:47.860
When we were doing Python in 06, 07, everything was like, done.

00:15:47.860 --> 00:15:49.300
Just magic object.

00:15:49.300 --> 00:15:49.620
Boom.

00:15:49.620 --> 00:15:50.260
Magic object.

00:15:50.260 --> 00:15:52.700
Nobody wanted to type anything, which was bad.

00:15:52.960 --> 00:15:54.620
But we did totally because it was scripting language.

00:15:54.620 --> 00:15:58.340
But nowadays, people are way more tolerant of more verbosity, more clarity.

00:15:58.340 --> 00:16:02.720
And I'm trying to keep SQLAlchemy and my team, we're trying to keep it going along with that.

00:16:02.720 --> 00:16:08.980
So the PEP 44 thing, the AsyncIO stuff, that's my knowledge dump for the typing thing.

00:16:08.980 --> 00:16:10.160
That's fantastic.

00:16:10.160 --> 00:16:11.260
That's a great insight.

00:16:11.260 --> 00:16:12.540
It's a work in progress.

00:16:12.800 --> 00:16:21.060
Do you think that people are more willing to accept a little more structure in the code now because the tooling is more there to help you write it?

00:16:21.060 --> 00:16:23.800
Like I write my maybe C tab.

00:16:23.800 --> 00:16:26.080
I don't write column of whatever, right?

00:16:26.080 --> 00:16:26.420
Right.

00:16:26.420 --> 00:16:32.980
Maybe it's the tooling because nowadays people use Python data classes and they want to use Python.

00:16:32.980 --> 00:16:35.260
We have some support for Python data classes now.

00:16:35.260 --> 00:16:40.000
And the syntaxes that they want me to implement, which we've done, are pretty verbose.

00:16:40.220 --> 00:16:43.500
Because they want to have a data class where you have all your data class fields.

00:16:43.500 --> 00:16:46.020
And then within the field, they want to have the mapping information.

00:16:46.020 --> 00:16:47.420
And people are like, this is awesome.

00:16:47.420 --> 00:16:48.980
And I'm like, great.

00:16:48.980 --> 00:16:52.300
Because it's actually more verbose than I would prefer.

00:16:52.300 --> 00:16:54.460
But people are way more tolerant of that.

00:16:54.460 --> 00:16:56.340
So yeah, I guess their IDEs are spitting things down.

00:16:56.340 --> 00:16:58.940
Or just people, the values are different now.

00:16:58.940 --> 00:16:59.740
Kids these days.

00:16:59.740 --> 00:17:05.480
This portion of Talk Python To Me is brought to you by TopTal.

00:17:05.480 --> 00:17:09.640
Are you looking to hire a developer to work on your latest project?

00:17:10.040 --> 00:17:13.840
Do you need some help with rounding out that app you just can't seem to get finished?

00:17:13.840 --> 00:17:17.120
Maybe you're even looking to do a little consulting work of your own.

00:17:17.120 --> 00:17:18.940
You should give TopTal a try.

00:17:18.940 --> 00:17:25.380
You may know that we have mobile apps for our courses over at Talk Python on iOS and Android.

00:17:25.380 --> 00:17:31.220
I actually used TopTal to hire a solid developer at a fair rate to help create those mobile apps.

00:17:31.220 --> 00:17:34.620
It was a great experience and I can totally recommend working with them.

00:17:35.180 --> 00:17:40.100
I met with a specialist who helped figure out my goals and technical skills that were required for the project.

00:17:40.100 --> 00:17:43.360
Then they did all the work to find just the right person.

00:17:43.360 --> 00:17:45.980
I had short interviews with two folks.

00:17:45.980 --> 00:17:50.120
I hired the second one and we released our apps just two months later.

00:17:50.720 --> 00:17:58.400
If you'd like to do something similar, please visit talkpython.fm/TopTal and click that hire top talent button.

00:17:58.400 --> 00:18:00.320
It really helps support the show.

00:18:03.320 --> 00:18:11.740
Is the goal with the data classes to try to have a more pure entity model that doesn't have column information and key index information?

00:18:11.740 --> 00:18:14.840
There's some other layer that puts those together?

00:18:14.840 --> 00:18:16.840
I haven't really played with that aspect.

00:18:16.840 --> 00:18:17.660
Data classes.

00:18:17.660 --> 00:18:21.080
I haven't really had the Kool-Aid with the data classes yet.

00:18:21.160 --> 00:18:31.840
I think the idea is that it's this very clean data encapsulating object that has kind of prefab constructors and Reaper and validation.

00:18:31.840 --> 00:18:33.340
It does have that kind of stuff.

00:18:33.340 --> 00:18:33.720
That's right.

00:18:33.720 --> 00:18:34.300
Comparison.

00:18:34.300 --> 00:18:34.720
Yeah.

00:18:34.720 --> 00:18:37.320
I might be thinking that Pydantic takes a little further.

00:18:37.320 --> 00:18:41.580
Some murky stuff between data classes, Pydantic and SQLAlchemy.

00:18:41.580 --> 00:18:41.800
Yeah.

00:18:41.800 --> 00:18:43.460
They blend together in my mind a little as well.

00:18:43.460 --> 00:18:44.160
It's all weird.

00:18:44.160 --> 00:18:44.440
Yeah.

00:18:44.440 --> 00:18:47.860
And there's a new product called SQL Model that seems to be pretty popular in that regard.

00:18:47.860 --> 00:18:48.280
Yeah.

00:18:48.280 --> 00:18:49.540
Built on SQLAlchemy.

00:18:49.540 --> 00:18:50.200
Yeah.

00:18:50.560 --> 00:18:50.760
Yeah.

00:18:50.760 --> 00:18:51.660
Which is great.

00:18:51.660 --> 00:18:52.740
It's totally awesome.

00:18:52.740 --> 00:18:59.000
It's actually a more opinionated overlay of the ORM, which is also using Pydantic.

00:18:59.000 --> 00:18:59.820
So that's good.

00:18:59.820 --> 00:19:00.600
Yeah.

00:19:00.600 --> 00:19:05.360
The thing you've got on the screen there is another way of, yeah, that's called a...

00:19:05.360 --> 00:19:05.700
Yeah.

00:19:05.700 --> 00:19:11.740
So it's a data class, but it also has the mapper registry.mapped on it, which is interesting.

00:19:11.740 --> 00:19:17.200
It has some of its table metadata has not just the table name, but all the column information as well.

00:19:17.200 --> 00:19:18.560
It's interesting.

00:19:18.700 --> 00:19:24.440
It does have the same type declaration that I was trying to impose upon the traditional SQLAlchemy models.

00:19:24.440 --> 00:19:24.800
Yeah.

00:19:24.800 --> 00:19:26.960
That's one form of the data class model.

00:19:26.960 --> 00:19:30.580
If you scroll down, the more inline embedded one is there.

00:19:30.580 --> 00:19:31.960
Let me see if that's what it is.

00:19:31.960 --> 00:19:32.460
Yeah.

00:19:32.460 --> 00:19:35.860
That's the one that's even crazier, which the data class fields.

00:19:36.080 --> 00:19:40.340
So you're fully a data class as far as what your IDE sees.

00:19:40.340 --> 00:19:43.320
But then you have the SQLAlchemy mapping stuff inside.

00:19:43.320 --> 00:19:44.340
So all of this is...

00:19:44.340 --> 00:19:48.960
Well, time will tell which approach becomes the popular one.

00:19:48.960 --> 00:19:49.400
Yeah.

00:19:49.400 --> 00:19:50.620
Or people just use SQL model.

00:19:50.620 --> 00:19:55.720
Because the people that like data classes tend to be using SQL model at Pydantic anyway.

00:19:55.720 --> 00:19:56.160
Right.

00:19:56.160 --> 00:19:56.840
Maybe they'll just...

00:19:56.840 --> 00:19:57.300
They'll be there.

00:19:57.300 --> 00:19:57.920
I don't really know.

00:19:57.920 --> 00:19:57.940
Yeah.

00:19:57.940 --> 00:20:02.940
I'm going to talk to Sebastian Ramirez maybe in December or January about SQL model.

00:20:02.940 --> 00:20:03.520
Yeah.

00:20:03.520 --> 00:20:10.900
SQL model is interesting because it basically takes Pydantic models and SQLAlchemy and merges

00:20:10.900 --> 00:20:11.520
them together.

00:20:11.520 --> 00:20:15.840
And Sebastian has a good feel for what a nice API looks like.

00:20:15.900 --> 00:20:17.820
So I'm optimistic for this.

00:20:17.820 --> 00:20:20.520
I haven't done anything with it, but it does look pretty neat.

00:20:20.520 --> 00:20:23.600
What he had to do was he had to modify Pydantic's base class.

00:20:23.600 --> 00:20:29.600
Because when I first looked, man, maybe like in this last past year about how Pydantic do

00:20:29.600 --> 00:20:33.400
SQLAlchemy without having two separate models, I was like, okay, this base class has got a

00:20:33.400 --> 00:20:36.320
whole thing, a lot of things going on that don't work with Python descriptors.

00:20:36.320 --> 00:20:37.160
So it'd have to change.

00:20:37.160 --> 00:20:39.440
And I think Sebastian did that, basically.

00:20:39.440 --> 00:20:39.920
Okay.

00:20:39.920 --> 00:20:42.580
Went in and changed how the init works so that it's compatible.

00:20:42.580 --> 00:20:43.360
Yeah.

00:20:43.360 --> 00:20:44.240
More power to him.

00:20:44.240 --> 00:20:45.260
Yeah, more power to him.

00:20:45.260 --> 00:20:45.540
Awesome.

00:20:45.720 --> 00:20:47.200
I have enough to work on.

00:20:47.200 --> 00:20:47.600
I can't.

00:20:47.600 --> 00:20:50.360
This is like too much for me to also work on Pydantic.

00:20:50.360 --> 00:20:52.000
So I'm glad someone else did it.

00:20:52.000 --> 00:20:52.540
Yeah, absolutely.

00:20:52.540 --> 00:20:53.040
Absolutely.

00:20:53.040 --> 00:20:55.500
One more philosophy thing.

00:20:55.500 --> 00:20:56.180
That is not it.

00:20:56.180 --> 00:20:56.720
This is the one.

00:20:56.720 --> 00:21:01.700
One more philosophy thing that I want to ask about or let you just speak to, because this

00:21:01.700 --> 00:21:04.700
is a key element of how SQLAlchemy works.

00:21:04.700 --> 00:21:06.820
There's other ORMs that work this way.

00:21:06.820 --> 00:21:10.640
And then there's also this one, I think it's called Django.

00:21:10.640 --> 00:21:12.780
People might have used the Django ORM before.

00:21:12.780 --> 00:21:13.380
No.

00:21:13.820 --> 00:21:18.520
That one is more of a traditional Ruby on Rails active record where I have a thing and I call

00:21:18.520 --> 00:21:19.120
save on it.

00:21:19.120 --> 00:21:19.400
Sure.

00:21:19.400 --> 00:21:23.820
You went with this thing called unit of work, which is a little more transactional.

00:21:23.820 --> 00:21:26.520
Like I'm going to do a bunch of stuff and then all together it happens.

00:21:26.520 --> 00:21:26.720
Yeah.

00:21:26.720 --> 00:21:28.980
Maybe just speak to that real quick before we talk about it to you.

00:21:28.980 --> 00:21:33.240
When I was going to do SQLAlchemy, the main thing that I had worked on a lot at work

00:21:33.240 --> 00:21:34.880
was a lot of fancy selects.

00:21:34.880 --> 00:21:39.600
I hadn't done much work with the persistence side, but I read this book by Martin Fowler

00:21:39.600 --> 00:21:41.060
called Patterns and Enterprise Architecture.

00:21:41.060 --> 00:21:41.600
I read it as well.

00:21:41.600 --> 00:21:43.420
It was quite an interesting book back then.

00:21:43.420 --> 00:21:43.620
Yeah.

00:21:43.620 --> 00:21:47.640
And I had actually never, even though I had used Hibernate, I had never heard of unit of

00:21:47.640 --> 00:21:47.880
work.

00:21:47.880 --> 00:21:50.260
And I was like, wow, that looks cool.

00:21:50.260 --> 00:21:51.440
I'm going to write that.

00:21:52.260 --> 00:21:56.800
Because one of the philosophies was like, insert update deletes are really boring.

00:21:56.800 --> 00:21:59.340
And even saying update.save is really boring.

00:21:59.340 --> 00:22:03.400
You're going to, because I, we worked, I was working on a content management system for Major

00:22:03.400 --> 00:22:03.980
League Baseball.

00:22:03.980 --> 00:22:09.080
And when you work with CMS, you have a lot of tree-based hierarchical structures with lots

00:22:09.080 --> 00:22:10.300
of self-referential stuff.

00:22:10.300 --> 00:22:14.580
When you persist self-referential structures in the database with auto-incommented primary

00:22:14.580 --> 00:22:18.620
keys, you've got to get one row, get the primary key back, put it there, put it in there.

00:22:18.620 --> 00:22:20.580
Everything's got to be done in a very specific order.

00:22:20.580 --> 00:22:20.820
Yeah.

00:22:20.820 --> 00:22:21.160
Yeah.

00:22:21.260 --> 00:22:25.060
Like I tried to call save on this, but that didn't work because I needed to call save first

00:22:25.060 --> 00:22:25.440
there.

00:22:25.440 --> 00:22:27.060
And it's like, ah, this is crazy, right?

00:22:27.060 --> 00:22:28.660
So it's like, why would I want to do, why?

00:22:28.660 --> 00:22:29.820
I shouldn't have to do that either.

00:22:29.820 --> 00:22:32.980
I should just have this thing that like, here's everything in a transaction, just push it.

00:22:32.980 --> 00:22:36.020
And it, you know, took a very long time to get it right.

00:22:36.020 --> 00:22:41.340
It has a couple of little chinks in the armor, a couple of cases that you might have to drop

00:22:41.340 --> 00:22:46.420
it to call it flush explicitly, but we never get bugs with the unit of work stuff.

00:22:46.420 --> 00:22:50.320
If you look at unitofwork.py, it hasn't changed in years.

00:22:50.320 --> 00:22:51.320
Yeah.

00:22:51.320 --> 00:22:52.620
It took a long time in the beginning.

00:22:52.620 --> 00:22:56.360
And then I wrote it a few times and we thought it was really bad early on.

00:22:56.360 --> 00:22:58.100
It was very hard to get it right.

00:22:58.100 --> 00:22:58.600
Yeah.

00:22:58.600 --> 00:22:59.800
A lot of edge cases, right?

00:22:59.800 --> 00:23:00.480
I can imagine.

00:23:00.480 --> 00:23:04.360
People can do any sequence of things and then you have to make it right.

00:23:04.360 --> 00:23:04.580
Yeah.

00:23:04.580 --> 00:23:08.800
Mostly that we support these joint table inheritance models were very hard for me to get my head

00:23:08.800 --> 00:23:09.740
around how to persist that.

00:23:09.740 --> 00:23:13.520
And then just took a long, it just took a long time because it grew organically.

00:23:13.520 --> 00:23:14.120
You know, you're coding.

00:23:14.120 --> 00:23:14.760
You're not, you're doing.

00:23:14.760 --> 00:23:16.500
I'm glad you wrote that instead of me.

00:23:16.500 --> 00:23:17.180
So thank you.

00:23:17.180 --> 00:23:17.560
Yeah.

00:23:17.900 --> 00:23:18.180
Yeah.

00:23:18.180 --> 00:23:19.180
I wouldn't be able to do it today.

00:23:19.180 --> 00:23:21.660
You got to be deep in it, right?

00:23:21.660 --> 00:23:22.300
Yeah.

00:23:22.300 --> 00:23:24.060
Comment from Brandon Brenner.

00:23:24.060 --> 00:23:24.520
Hey, Brandon.

00:23:24.520 --> 00:23:28.200
Because I use SQL model in a demo project and it was so easy to use.

00:23:28.200 --> 00:23:28.720
Very nice.

00:23:29.220 --> 00:23:29.520
All right.

00:23:29.520 --> 00:23:38.140
So I think probably the big news over here is 2.0 or as you like to put it at your recent

00:23:38.140 --> 00:23:39.580
talk, the 1.4 inning.

00:23:39.580 --> 00:23:41.600
The 1.4 inning.

00:23:41.600 --> 00:23:44.580
Very early stages are on the site.

00:23:44.580 --> 00:23:49.420
In the library tab is a development thing where development docs are.

00:23:49.420 --> 00:23:49.760
Nice.

00:23:49.760 --> 00:23:52.160
And the current release is a 1.4 or whatever.

00:23:52.160 --> 00:23:52.480
1.4.

00:23:52.480 --> 00:23:55.640
It has a lot of these features in there already, right?

00:23:55.640 --> 00:23:56.360
Yes.

00:23:56.360 --> 00:24:02.260
All of the, just about everything in SQL 2.0 internally is available in 1.4.

00:24:02.260 --> 00:24:07.640
We did the whole of the internals first and added all the stuff so that 1.4 could be a

00:24:07.640 --> 00:24:12.420
transitional release so that all this, all the behind the scenes would be getting tested

00:24:12.420 --> 00:24:15.040
and people use the new APIs and transition over.

00:24:15.040 --> 00:24:17.800
Is 2.0 going to drop some of the older APIs hard?

00:24:17.800 --> 00:24:18.580
Many.

00:24:18.580 --> 00:24:18.980
Yeah.

00:24:18.980 --> 00:24:19.460
Yeah.

00:24:19.460 --> 00:24:19.600
Okay.

00:24:19.600 --> 00:24:20.220
Yeah.

00:24:20.220 --> 00:24:26.240
So people who have looked, 1.4 has this big migration thing where if you're

00:24:26.240 --> 00:24:30.740
on 1.3, which is pretty common, you can go to 1.4 pretty easily without much problems.

00:24:30.740 --> 00:24:31.540
But right.

00:24:31.540 --> 00:24:38.980
When you're on this thing, we have this whole thing that is inspired by the Python 2.3 process

00:24:38.980 --> 00:24:44.060
and at the same time tries to not make some of the, what I thought were mistakes of the

00:24:44.060 --> 00:24:45.100
Python 2.3 process.

00:24:45.100 --> 00:24:51.860
So what this is based on is that 1.4 has a environment variable you can turn on in your

00:24:51.860 --> 00:24:52.560
console or whatever.

00:24:52.560 --> 00:24:55.380
A called SQL can be worn 2.0, something like that.

00:24:55.380 --> 00:24:58.340
And when you turn that on, you're in now, you're in now in warnings mode.

00:24:58.340 --> 00:25:03.540
You will get all kinds of warnings about all kinds of APIs that either have changed or are

00:25:03.540 --> 00:25:05.180
going away or use this one or that one.

00:25:05.180 --> 00:25:06.400
So a lot has happened.

00:25:06.740 --> 00:25:10.860
But at the same time, the reason that's maybe not as scary as you might think is that all

00:25:10.860 --> 00:25:14.460
the APIs that are being deprecated are APIs that I've already taken out of the docs years

00:25:14.460 --> 00:25:14.800
ago.

00:25:14.800 --> 00:25:19.440
Like the APIs that I've been telling people for years, don't do that anymore.

00:25:19.440 --> 00:25:20.340
We don't, we're not going to do that.

00:25:20.340 --> 00:25:24.460
So it's a lot of old stuff that is not what we've featured in the docs.

00:25:24.460 --> 00:25:28.200
Like basically the things we're taking on 2.0 are things that have annoyed me for years.

00:25:28.200 --> 00:25:31.760
And there's a few changes in 2.0 that are a little more boom.

00:25:31.760 --> 00:25:37.460
Like we changed how the engine is auto begin instead of auto commit, but it's 2.0 is basically

00:25:37.460 --> 00:25:38.840
going to be, I think, better.

00:25:38.840 --> 00:25:43.940
It's in line with this whole notion of people are, are appreciate more explicitness when things

00:25:43.940 --> 00:25:44.340
are clear.

00:25:44.340 --> 00:25:50.080
So 2.0 is going to remove a lot of implicit stuff, a lot of five ways to do the same thing

00:25:50.080 --> 00:25:50.720
patterns.

00:25:50.720 --> 00:25:54.940
It's going to narrow you down into one or two possible patterns for things.

00:25:54.940 --> 00:25:55.120
Yeah.

00:25:55.120 --> 00:25:56.700
That hasn't been a thing with SQLAlchemy, right?

00:25:56.700 --> 00:25:59.080
There's a lot of ways to accomplish stuff.

00:25:59.080 --> 00:25:59.260
Yeah.

00:25:59.260 --> 00:25:59.900
Yeah.

00:25:59.900 --> 00:26:00.940
Because I came from Perl.

00:26:00.940 --> 00:26:01.560
I can't, I'm sorry.

00:26:01.560 --> 00:26:03.400
I was doing Perl.

00:26:03.400 --> 00:26:06.280
It's still the case that there's more than one way to do that.

00:26:06.280 --> 00:26:07.860
You can't really get away from that totally.

00:26:07.860 --> 00:26:13.820
Well, there's often there's the, I want the super simple, easy way, just call an ORM method

00:26:13.820 --> 00:26:18.240
and then, oh, we got to rewrite the select statement to use the store procedure type.

00:26:18.240 --> 00:26:22.560
There's usually a backdoor type of thing in a database world that has to happen at some

00:26:22.560 --> 00:26:22.980
point, right?

00:26:22.980 --> 00:26:23.300
Yeah.

00:26:23.300 --> 00:26:25.560
Store procedure is a pretty dramatic example.

00:26:26.060 --> 00:26:29.800
But yeah, these days the way is that when you write your code, it's going to be clear

00:26:29.800 --> 00:26:34.220
where the SQL is being executed, where the IO happens.

00:26:34.220 --> 00:26:39.840
In many ways, it actually was inspired by AsyncIO, where I had been tweeting a lot with people

00:26:39.840 --> 00:26:42.580
into AsyncIO, which I was a little skeptical of it.

00:26:42.580 --> 00:26:46.720
At the same time, what people appreciate about it is that it can show, you're very aware of

00:26:46.720 --> 00:26:50.220
where the actual message to the database is happening.

00:26:50.680 --> 00:26:51.960
This is where the message gets sent down.

00:26:51.960 --> 00:26:52.920
Here's where it comes back.

00:26:52.920 --> 00:26:54.940
When you say await, now.

00:26:54.940 --> 00:26:55.400
Yeah.

00:26:55.400 --> 00:26:56.040
Now it's happening.

00:26:56.040 --> 00:27:00.420
Now, I think that's a little heavy handed, but at the same time, I appreciated that notion.

00:27:00.420 --> 00:27:03.960
So with 2.0, I tried to work with that idea that we want to make it very clear.

00:27:03.960 --> 00:27:06.140
Here's where you're making a SQL save it.

00:27:06.140 --> 00:27:07.160
Here's where it's executing.

00:27:07.160 --> 00:27:08.660
Here's where the results are.

00:27:08.660 --> 00:27:11.860
And then also, here's where the transaction is.

00:27:11.860 --> 00:27:15.600
Those are actually the biggest changes that you're going to know that you're in a transaction.

00:27:15.600 --> 00:27:17.600
You're going to know when your transaction ended.

00:27:17.600 --> 00:27:20.420
You're going to know if you committed it or if it just rolled back.

00:27:20.420 --> 00:27:20.500
Yeah.

00:27:20.500 --> 00:27:21.640
And you'll know.

00:27:21.640 --> 00:27:25.140
And the code is going to be a little more verbose than SQL Alchemist here at .1.

00:27:25.140 --> 00:27:27.340
But people are already writing code that way.

00:27:27.340 --> 00:27:30.040
Because now that I've seen many years of people writing code, you know.

00:27:30.040 --> 00:27:31.760
They're like, I really want to know when this happens.

00:27:31.760 --> 00:27:33.340
So I'm going to be super explicit about it.

00:27:33.340 --> 00:27:39.260
People don't want, they don't want excess bells and switches that don't seem to have any purpose.

00:27:39.260 --> 00:27:47.140
But if your code is clear, basically being able to read the code and the intent is as clear as you can get it.

00:27:47.140 --> 00:27:48.840
Without, this just does that.

00:27:48.840 --> 00:27:49.800
We just know it does that.

00:27:50.240 --> 00:27:52.080
That's where I'm trying to go.

00:27:52.080 --> 00:27:58.580
And I'm somewhat freed by the fact that I know people are more tolerant of step A, step B, step C.

00:27:58.580 --> 00:27:58.700
Sure.

00:27:58.700 --> 00:28:00.300
A little less magic, yeah.

00:28:00.300 --> 00:28:00.600
Yeah.

00:28:00.600 --> 00:28:01.420
People are okay with it.

00:28:01.420 --> 00:28:03.980
Now, they weren't okay with that tiptoe 12 years ago.

00:28:03.980 --> 00:28:05.020
People are like, that's too much typing.

00:28:05.020 --> 00:28:05.680
Sure.

00:28:05.680 --> 00:28:06.360
So it's good.

00:28:06.360 --> 00:28:11.420
I want to talk about this migration thing, like what a person does to go from a 1.3 application onward.

00:28:11.420 --> 00:28:13.980
But I think that's getting a little bit ahead of ourselves.

00:28:14.700 --> 00:28:20.000
What about we talk a little bit about, you know, what is, what are the major features coming in 2.0?

00:28:20.000 --> 00:28:23.920
First of all, obviously, we're finally to Python 3 only.

00:28:23.920 --> 00:28:24.780
Yeah.

00:28:24.780 --> 00:28:25.280
What is it?

00:28:25.280 --> 00:28:26.040
3.6?

00:28:26.040 --> 00:28:27.800
That you're, has a minimum version?

00:28:27.800 --> 00:28:28.620
We're going to make it 3.7.

00:28:28.620 --> 00:28:28.900
3.7.

00:28:28.900 --> 00:28:29.180
Okay.

00:28:29.180 --> 00:28:30.020
3.7.

00:28:30.020 --> 00:28:30.200
Yeah.

00:28:30.200 --> 00:28:31.100
3.6 is EOL.

00:28:31.100 --> 00:28:31.560
So.

00:28:31.560 --> 00:28:32.140
Yeah.

00:28:32.140 --> 00:28:33.020
In a case of a month or two.

00:28:33.020 --> 00:28:33.340
Yeah.

00:28:33.340 --> 00:28:33.520
Yeah.

00:28:33.520 --> 00:28:34.260
No point to do that.

00:28:34.260 --> 00:28:34.880
Yeah.

00:28:34.880 --> 00:28:39.300
Just today, or I didn't merge it yet, but like we're ready to merge this gigantic Garrett

00:28:39.300 --> 00:28:43.500
review that's going to take all the Unicode conversion crap out.

00:28:43.500 --> 00:28:45.500
That was all Python 2.

00:28:45.500 --> 00:28:52.460
Python 3 having native Unicode is tremendous for us because all the DB APIs do the Unicode now.

00:28:52.920 --> 00:28:53.920
It was the new API.

00:28:53.920 --> 00:29:00.600
So yeah, we, we have this new school caching system that I've talked about a bunch in the,

00:29:00.600 --> 00:29:01.820
some of the talks I did recently.

00:29:01.820 --> 00:29:02.240
Yeah.

00:29:02.240 --> 00:29:03.220
Tell us about that a little bit.

00:29:03.220 --> 00:29:03.820
Yeah.

00:29:03.820 --> 00:29:04.480
That's in 1.4.

00:29:04.480 --> 00:29:10.140
Is that like compiling the SQL statements and then like caching those results or what are

00:29:10.140 --> 00:29:10.720
we talking about here?

00:29:10.720 --> 00:29:15.700
It caches the, so when you run a SQLAlchemy statement, we have to take your Python code and

00:29:15.700 --> 00:29:18.000
make a string out of it, which is the string we sent to the database.

00:29:18.000 --> 00:29:21.940
We also have to look at that thing and figure out what kinds of results are we going to get

00:29:21.940 --> 00:29:22.220
back?

00:29:22.580 --> 00:29:25.000
Are we going to get strings and dates, injures and floats?

00:29:25.000 --> 00:29:29.080
And then for those strings and states and floats and whatever, do we have to do any processing

00:29:29.080 --> 00:29:29.820
on the rows?

00:29:29.820 --> 00:29:33.700
We want to have that all set up because if you get 10,000 rows back, you want to make all

00:29:33.700 --> 00:29:34.680
those decisions up front.

00:29:34.680 --> 00:29:39.060
So that when you run 10,000 times, everything is as fast as possible.

00:29:39.060 --> 00:29:40.460
Everything is already figured out.

00:29:40.460 --> 00:29:44.620
When you do the ORM, that whole process becomes like way more complicated.

00:29:44.620 --> 00:29:47.840
There's way more going on as eager loaders and there's more fancy kinds of types.

00:29:47.840 --> 00:29:50.900
We might be taking columns and putting them into an object.

00:29:51.120 --> 00:29:54.100
All of that stuff is time consuming.

00:29:54.420 --> 00:29:59.960
And it all now in 1.4 lives behind what I call the cache wall, which means when the

00:29:59.960 --> 00:30:04.260
caching is working, which it seems to work, it's only going to do that stuff once for a

00:30:04.260 --> 00:30:05.780
statement that's been cached.

00:30:05.780 --> 00:30:09.480
So when we run your statement, we're going to do a process that's still a little pricey,

00:30:09.480 --> 00:30:12.060
which is to get a cache key from what you typed.

00:30:12.320 --> 00:30:15.660
You've got to determine some sort of unique hash type of thing out of it.

00:30:15.660 --> 00:30:18.160
It's a unique, it's actually a gigantic tuple right now.

00:30:18.160 --> 00:30:20.120
And maybe it'll be a hash in some other release.

00:30:20.120 --> 00:30:22.340
But for now, it's a giant tuple because Python's pretty good at that.

00:30:22.340 --> 00:30:24.460
It's cheaper than running, than doing the whole compilation.

00:30:24.460 --> 00:30:28.340
And then we get the whole compilation from a cache if it's there.

00:30:28.500 --> 00:30:29.860
And it's LRU cache.

00:30:29.860 --> 00:30:30.940
So if it's not, we make it.

00:30:30.940 --> 00:30:35.560
And it allows us to put more bells and whistles into the compiler.

00:30:35.560 --> 00:30:40.620
We have this thing where it will now detect if your statement will produce Cartesian product,

00:30:40.620 --> 00:30:43.380
meaning you have joins between tables that are not linked together.

00:30:43.600 --> 00:30:48.600
And we have all kinds of other fun things the ORM can do that take a little more time to compile.

00:30:48.600 --> 00:30:49.820
But now they're behind a cache.

00:30:49.820 --> 00:30:53.260
So the performance is not really impacted too much.

00:30:53.260 --> 00:30:55.180
And so that's exciting stuff.

00:30:55.180 --> 00:31:00.820
And we're going to be looking at 2.0 to start using Cython to speed this up even more.

00:31:00.820 --> 00:31:01.720
Oh, fantastic.

00:31:01.720 --> 00:31:06.220
Yeah, it has C-Extensions that we wrote as C code years ago.

00:31:06.220 --> 00:31:12.320
We're going to migrate those to Cython so that we can more quickly add new Cythonized code

00:31:12.320 --> 00:31:15.980
for different sections to speed up to how those cache keys get built.

00:31:15.980 --> 00:31:19.580
Yeah, it's one thing to say we're going to write some big chunk in a C layer.

00:31:19.580 --> 00:31:21.900
It's another to say just that loop.

00:31:21.900 --> 00:31:24.280
Could that loop be C, right?

00:31:24.280 --> 00:31:27.180
And with Cython, you can kind of just do that, right?

00:31:27.180 --> 00:31:27.720
You can do that.

00:31:27.720 --> 00:31:32.960
You could do it quicker and without having to worry about all the memory reference counters.

00:31:32.960 --> 00:31:35.580
C code in Python is pretty tedious.

00:31:35.580 --> 00:31:38.140
I'm not really a spectacular C programmer anyway.

00:31:38.140 --> 00:31:40.540
Well, and also a lot of people who might want to come contribute

00:31:40.540 --> 00:31:42.260
are probably not C developers.

00:31:42.260 --> 00:31:43.660
They're Python developers first.

00:31:43.660 --> 00:31:44.080
Yeah.

00:31:44.080 --> 00:31:45.960
Yeah, Cython is pretty cool.

00:31:45.960 --> 00:31:47.340
Cython is pretty cool.

00:31:47.340 --> 00:31:49.320
Because you can really, if you just do Python, you can do it.

00:31:49.320 --> 00:31:51.200
It's just like a strict Python.

00:31:51.200 --> 00:31:51.760
Yeah.

00:31:51.760 --> 00:31:52.120
It's pretty neat.

00:31:52.120 --> 00:31:52.800
Yeah, it is.

00:31:52.800 --> 00:31:56.440
And we found that some of the Cythonized versions of the functions

00:31:56.440 --> 00:31:58.160
are actually faster than RC code.

00:31:58.160 --> 00:31:58.760
Really?

00:31:58.760 --> 00:31:59.260
Which seems strange.

00:31:59.460 --> 00:32:00.640
That's pretty strange.

00:32:00.640 --> 00:32:01.200
Yeah, faster.

00:32:01.200 --> 00:32:05.560
Because Cython, the people that did Cython optimized the crap out of it.

00:32:05.560 --> 00:32:11.420
They know all these very esoteric Python C API things that, like literally, we have RC code

00:32:11.420 --> 00:32:12.200
is not a lot of codes.

00:32:12.200 --> 00:32:13.420
That's like a few hundred lines.

00:32:13.420 --> 00:32:16.900
We'll call it a tuple get item or whatever it's called.

00:32:16.900 --> 00:32:19.800
Cython has some, if we do this, then it's faster.

00:32:19.800 --> 00:32:20.740
And it actually is.

00:32:21.300 --> 00:32:26.040
I can't give you detail on, because I don't know, but like we did benching and Cython

00:32:26.040 --> 00:32:27.780
was actually faster than RC code.

00:32:27.780 --> 00:32:27.900
Yeah.

00:32:27.900 --> 00:32:33.080
I remember way, way back when hearing, you know, people used to say, well, if you want

00:32:33.080 --> 00:32:34.840
it to be fast, you have to write an assembler.

00:32:34.840 --> 00:32:38.720
And then you can use C if you're not, if it's not going to be that fast, you can just use C,

00:32:38.720 --> 00:32:39.000
right?

00:32:39.000 --> 00:32:40.280
That's a different kind of fast.

00:32:40.280 --> 00:32:40.460
Right.

00:32:40.460 --> 00:32:41.200
Well, what I was.

00:32:41.200 --> 00:32:41.660
To be clear.

00:32:41.660 --> 00:32:46.860
What turned, of course, but to be, well, the interesting thing to me was there was this

00:32:46.860 --> 00:32:50.940
switch when the compilers got good enough that you probably were slower writing

00:32:50.940 --> 00:32:52.300
assembly for most people.

00:32:52.300 --> 00:32:52.600
Right.

00:32:52.600 --> 00:32:56.000
And I feel like the thing you're describing here is kind of like that transformation like

00:32:56.000 --> 00:32:56.280
this.

00:32:56.280 --> 00:33:01.240
The compiler understands the whole system better than if you were to try to do it yourself

00:33:01.240 --> 00:33:02.100
at the same level.

00:33:02.100 --> 00:33:02.600
They found.

00:33:02.600 --> 00:33:02.820
Yeah.

00:33:02.820 --> 00:33:03.400
They've apparently.

00:33:03.400 --> 00:33:04.120
Yeah.

00:33:04.120 --> 00:33:08.440
I don't know the specifics, but in some cases they've had figured out ways to make it even

00:33:08.440 --> 00:33:08.700
faster.

00:33:08.700 --> 00:33:10.180
So there's no reason to not use Cython.

00:33:10.180 --> 00:33:10.580
Yeah.

00:33:10.580 --> 00:33:12.780
You think of what people are doing with Cython, right?

00:33:12.780 --> 00:33:17.020
Like they're running on supercomputers doing huge calculations that take.

00:33:17.020 --> 00:33:20.920
So they have a strong motivation to make it a little bit faster here and there.

00:33:20.920 --> 00:33:21.180
Right.

00:33:21.180 --> 00:33:21.540
Yeah.

00:33:21.540 --> 00:33:22.980
Look, here's the thing about Python.

00:33:22.980 --> 00:33:24.640
Python is a high level scripting language.

00:33:24.640 --> 00:33:26.060
It's interpreted always.

00:33:26.060 --> 00:33:28.140
So it's already not.

00:33:28.140 --> 00:33:33.820
I don't want to say that, but if you're really writing high frequency training software, you

00:33:33.820 --> 00:33:36.720
probably want to use something like Rust or something.

00:33:36.720 --> 00:33:38.560
Python's not really that.

00:33:38.560 --> 00:33:44.460
It's a lot of things, but it's not high frequency training speed demon type that it's just it's

00:33:44.460 --> 00:33:44.740
right.

00:33:44.740 --> 00:33:45.740
You can make it do that.

00:33:45.740 --> 00:33:51.080
But once you start wanting it to be sub millisecond, you might want to start.

00:33:51.080 --> 00:33:52.760
But other than that, you're probably fine.

00:33:52.760 --> 00:33:52.940
Yeah.

00:33:52.940 --> 00:33:53.580
Yeah.

00:33:53.580 --> 00:33:54.700
It's not going to.

00:33:54.700 --> 00:33:55.380
I might be wrong.

00:33:55.380 --> 00:33:58.660
It's not going to control the rockets five, but I guess maybe it does.

00:33:58.660 --> 00:33:59.040
I don't know.

00:33:59.040 --> 00:33:59.580
Yeah.

00:33:59.580 --> 00:34:00.540
It's have to be that.

00:34:00.540 --> 00:34:02.780
It's so useful for so much stuff that.

00:34:02.780 --> 00:34:03.400
Yeah, absolutely.

00:34:03.400 --> 00:34:04.420
Okay.

00:34:04.480 --> 00:34:05.640
So that's really cool.

00:34:05.640 --> 00:34:10.160
So you're thinking about switching some of your C code over to Cython, which is really

00:34:10.160 --> 00:34:10.600
interesting.

00:34:10.600 --> 00:34:13.100
And I didn't didn't see that one coming.

00:34:13.100 --> 00:34:13.640
That's awesome.

00:34:13.640 --> 00:34:15.080
The cache layer is cool.

00:34:15.080 --> 00:34:21.040
So that way, if I call a function and in that function, I do a query statement in the ORM.

00:34:21.040 --> 00:34:22.860
The first time that's expensive.

00:34:22.860 --> 00:34:25.420
The second time it's not free, but less expensive.

00:34:25.420 --> 00:34:25.720
Right.

00:34:25.720 --> 00:34:26.300
Cheap ish.

00:34:26.300 --> 00:34:27.200
Much less expensive.

00:34:27.200 --> 00:34:27.840
Much less.

00:34:27.840 --> 00:34:28.040
Okay.

00:34:28.040 --> 00:34:28.660
Yeah.

00:34:28.660 --> 00:34:29.200
Yeah.

00:34:29.200 --> 00:34:30.860
We haven't sped up yet.

00:34:30.860 --> 00:34:35.860
And I've been speaking this for many years is when you fetch rows from the ORM to create

00:34:35.860 --> 00:34:40.140
the Python objects that are your classes, that's still more expensive than we'd like

00:34:40.140 --> 00:34:40.480
it to be.

00:34:40.480 --> 00:34:40.780
Yeah.

00:34:40.780 --> 00:34:44.100
That's super expensive in terms in ORMs and ODMs.

00:34:44.100 --> 00:34:49.160
If you select 10,000 rows out of a database, it's probably the serialization or deserialization.

00:34:49.160 --> 00:34:50.200
That's the cost, right?

00:34:50.200 --> 00:34:50.920
Completely.

00:34:50.920 --> 00:34:51.540
Okay.

00:34:51.540 --> 00:34:54.480
And we've made, I've made the loading way.

00:34:54.480 --> 00:34:59.520
I spent years and years making it way faster by doing that whole thing where we pre-calculate

00:34:59.520 --> 00:35:00.360
everything up front.

00:35:00.360 --> 00:35:04.680
Like every, every like loader, we're not going to like every time you get a row, it's

00:35:04.680 --> 00:35:05.480
like zip, zip, zip, zip, zip.

00:35:05.480 --> 00:35:06.680
We have these little callables set up.

00:35:06.680 --> 00:35:11.180
But still just to make the object, just to make a new class in Python is expensive.

00:35:11.180 --> 00:35:12.040
It's pricey.

00:35:12.040 --> 00:35:13.600
So still a brick of progress.

00:35:13.600 --> 00:35:16.060
But yeah, the caching will not speed that up.

00:35:16.060 --> 00:35:18.280
It'll speed up the overhead per query.

00:35:18.280 --> 00:35:21.400
Which is still like every, every area you can speed it up is great.

00:35:21.400 --> 00:35:26.360
Danielle out there says, Cython is also a great choice to forget about ref count and

00:35:26.360 --> 00:35:27.600
Psycho PG2.

00:35:27.600 --> 00:35:30.080
It took a while to find all the smaller leaks.

00:35:30.300 --> 00:35:30.440
Yeah.

00:35:30.440 --> 00:35:31.260
Ref counts are tough.

00:35:31.260 --> 00:35:33.080
Ref counts are tough.

00:35:33.080 --> 00:35:33.280
Yeah.

00:35:33.280 --> 00:35:36.780
I'm pretty proud of myself that I did figure them out to some degree.

00:35:36.780 --> 00:35:41.780
They're not as hard as Malik and Free, but the ref, it's an esoteric set of rules to

00:35:41.780 --> 00:35:42.080
ref counts.

00:35:42.080 --> 00:35:43.800
While we're down in the internals, let me ask you this.

00:35:43.800 --> 00:35:46.340
If you've thought about this or experimented with this, any.

00:35:46.760 --> 00:35:55.120
One thing as I dug into Python's memory model that I found to be really interesting is when

00:35:55.120 --> 00:36:00.820
you create, you know, you have GC, the GC module, you can say GC get thresholds or set thresholds.

00:36:00.820 --> 00:36:04.980
And the thresholds tell you what will trigger a garbage collection, not reference counting,

00:36:04.980 --> 00:36:07.220
but a cycle detection type of thing.

00:36:07.220 --> 00:36:07.420
Right.

00:36:07.420 --> 00:36:07.860
Yeah.

00:36:07.860 --> 00:36:12.560
The defaults, at least last I'd looked, I haven't looked in 3.10, but in 3.9, it was

00:36:12.560 --> 00:36:17.100
700, 10, 10, which means 700 allocations.

00:36:17.600 --> 00:36:22.520
And then for every 10 Gen 0 collections, there's a Gen 1 and every 10 Gen 1, there's a Gen 2

00:36:22.520 --> 00:36:23.000
collection.

00:36:23.000 --> 00:36:31.160
That 700 means if you allocate more, 700 more classes or dictionaries or tuples or whatever

00:36:31.160 --> 00:36:34.040
than have been freed, a GC will run.

00:36:34.040 --> 00:36:34.620
Yeah.

00:36:34.620 --> 00:36:39.840
So if you select 10,000 rows out of a database, how many GCs are running?

00:36:39.840 --> 00:36:41.820
I mean, that's a lot, right?

00:36:41.820 --> 00:36:43.160
That's like 14 GCs.

00:36:43.160 --> 00:36:46.820
If you're taking the 10,000 rows of putting them in a gigantic list, then it's not GCing much

00:36:46.820 --> 00:36:48.620
at all because you're putting it all in a gigantic buffer.

00:36:48.620 --> 00:36:51.420
You're going to have the size of your process growth.

00:36:51.420 --> 00:36:55.200
But the, I mean, you're not freeing any, but the, and you're not ref count freeing any either,

00:36:55.200 --> 00:36:57.980
but you're, you're allocating 700 more.

00:36:57.980 --> 00:36:58.620
Yeah.

00:36:58.620 --> 00:37:02.600
I think that triggers, I think that might trigger 14 GCs, unless I'm understanding it wrong.

00:37:02.600 --> 00:37:05.800
You would know, I don't know anything about, I wouldn't know.

00:37:05.800 --> 00:37:07.980
I know, all I know about GC is that it's going to happen.

00:37:07.980 --> 00:37:08.120
Yeah.

00:37:08.120 --> 00:37:13.240
I mean, the reference counting stuff is super straightforward, but the GC side, so I've always thought

00:37:13.240 --> 00:37:15.600
about this around the database.

00:37:15.600 --> 00:37:19.400
Even if you're just getting dictionaries, not ORM classes back.

00:37:19.400 --> 00:37:19.720
Yeah.

00:37:19.720 --> 00:37:23.400
If you're selecting a whole bunch of stuff, not only are you doing that serialization layer,

00:37:23.400 --> 00:37:27.620
you're also incurring a bunch of GC because it's trying to preemptively run around and look

00:37:27.620 --> 00:37:28.960
for cycles that might've been forming.

00:37:29.160 --> 00:37:32.660
One thing you can do is make the code so that you don't have as many cycles.

00:37:32.660 --> 00:37:33.920
And we actually do that.

00:37:33.920 --> 00:37:36.820
We've had people post issues related to this.

00:37:36.820 --> 00:37:38.660
So I said, I don't know much about GC.

00:37:38.660 --> 00:37:42.380
I do know that if you can reduce reference cycles, you will have less of these asynchronous

00:37:42.380 --> 00:37:43.400
GC runs happening.

00:37:43.400 --> 00:37:48.260
So we had someone specifically came to me with a whole lot of use cases where he showed when

00:37:48.260 --> 00:37:50.540
you run this little code, like all these GCs would happen.

00:37:50.540 --> 00:37:53.540
And we went in there and got rid of a lot of cycles.

00:37:53.800 --> 00:37:59.280
So we actually have a test suite in test slash AA profiling test man usage called cycle test,

00:37:59.280 --> 00:37:59.820
something like that.

00:37:59.820 --> 00:38:00.200
Okay.

00:38:00.200 --> 00:38:04.800
And they're all these little whiz bangs that run, make a session and close it, do this,

00:38:04.800 --> 00:38:05.640
then that, do this and that.

00:38:05.640 --> 00:38:09.400
And then it will runs it in a harness that actually counting what GC is doing.

00:38:09.400 --> 00:38:12.700
And it's asserting that there's only five GC calls and not 20.

00:38:12.700 --> 00:38:12.880
Right.

00:38:12.880 --> 00:38:13.080
Yeah.

00:38:13.080 --> 00:38:13.680
That's fantastic.

00:38:13.680 --> 00:38:15.180
We have a lot of that happening.

00:38:15.180 --> 00:38:15.600
Yeah.

00:38:15.600 --> 00:38:15.860
Interesting.

00:38:15.860 --> 00:38:16.120
Yeah.

00:38:16.120 --> 00:38:18.080
It's cool that you're, you're thinking about it.

00:38:18.080 --> 00:38:20.280
I mean, on one hand, this is an external thing.

00:38:20.280 --> 00:38:23.900
So you can control your data structures, but you can't totally control what people set

00:38:23.900 --> 00:38:24.660
their GC to do.

00:38:24.660 --> 00:38:28.440
But anyway, it's just something that I always think about when, when you're creating lots

00:38:28.440 --> 00:38:32.220
of these ORM things, because a lot of the signals to the GC are like, oh, I got to get

00:38:32.220 --> 00:38:32.460
busy.

00:38:32.460 --> 00:38:37.040
But yeah, you're not even like, that's a single call to SQLAlchemy and I'm just waiting.

00:38:37.040 --> 00:38:39.100
There's nothing else I can do to get out of the way.

00:38:39.100 --> 00:38:39.580
You know what I mean?

00:38:39.580 --> 00:38:42.020
We've just been around for so many years and people have come to us.

00:38:42.020 --> 00:38:47.360
So we have all kinds of man usage and C profile stuff at our test suite to make sure this

00:38:47.360 --> 00:38:50.560
does the call care of Stoke Grove here to make sure we don't do too many GCs.

00:38:50.560 --> 00:38:52.440
We try to work on that as much as we can.

00:38:52.440 --> 00:39:00.060
We have a new course over at Talk Python, HTMX plus Flask, modern Python web apps hold the

00:39:00.060 --> 00:39:00.400
JavaScript.

00:39:00.400 --> 00:39:04.600
HTMX is one of the hottest properties in web development today.

00:39:04.600 --> 00:39:05.580
And for good reason.

00:39:05.580 --> 00:39:10.680
You might even remember all the stuff we talked about with Carson Gross back on episode 321.

00:39:10.680 --> 00:39:15.760
HTMX, along with the libraries and techniques we introduced in our new course, will have you

00:39:15.760 --> 00:39:18.180
writing the best Python web apps you've ever written?

00:39:18.180 --> 00:39:21.740
Clean, fast, and interactive, all without that front-end overhead.

00:39:21.740 --> 00:39:26.500
If you're a Python web developer that has wanted to build more dynamic, interactive apps, but

00:39:26.500 --> 00:39:31.740
don't want to or can't write a significant portion of your app in rich front-end JavaScript frameworks,

00:39:31.740 --> 00:39:34.340
you'll absolutely love HTMX.

00:39:34.340 --> 00:39:40.340
Check it out over at talkpython.fm/HTMX or just click the link in your podcast player show notes.

00:39:41.960 --> 00:39:46.800
I would say one of the things that makes me more excited than most of the other stuff here

00:39:46.800 --> 00:39:50.200
is probably the async support that you have going on.

00:39:50.200 --> 00:39:52.500
You want to talk a bit about that?

00:39:52.500 --> 00:39:52.780
Yeah.

00:39:52.780 --> 00:39:58.980
So when I was doing 2.0, I thought I wanted to be compatible with how async.io works because

00:39:58.980 --> 00:40:01.820
I figured I would eventually do an async.io API for it.

00:40:01.820 --> 00:40:05.400
But then I suddenly had this idea, why don't we just do the async.io thing?

00:40:05.920 --> 00:40:09.360
And we do it doing this, we use this library called Greenlit.

00:40:09.360 --> 00:40:14.140
The way the async.io works is that SQLAlchemy has async blocking API.

00:40:14.140 --> 00:40:14.700
Yeah.

00:40:14.700 --> 00:40:17.860
We call dbapi execute, it blocks, it comes back.

00:40:17.860 --> 00:40:22.400
Usually the way you want to make that kind of thing work in an async non-blocking context

00:40:22.400 --> 00:40:25.040
is you have to throw all the stuff into a thread pool.

00:40:25.040 --> 00:40:26.440
You probably don't want to be in the wiki.

00:40:26.440 --> 00:40:28.620
This is more old stuff.

00:40:28.620 --> 00:40:29.020
Okay.

00:40:29.020 --> 00:40:29.440
Whoops.

00:40:29.440 --> 00:40:29.880
Yeah.

00:40:29.880 --> 00:40:30.920
Like that one.

00:40:30.920 --> 00:40:33.080
Click an async ORM at the top.

00:40:33.080 --> 00:40:33.880
There we go.

00:40:34.000 --> 00:40:35.060
This is the one I was looking for.

00:40:35.060 --> 00:40:35.920
That's the most basic.

00:40:35.920 --> 00:40:37.500
This is the one I wanted to show people.

00:40:37.500 --> 00:40:37.800
Yes.

00:40:37.800 --> 00:40:40.980
Not the session one, but the ORM.

00:40:40.980 --> 00:40:41.120
Yeah.

00:40:41.120 --> 00:40:41.920
This is ORM.

00:40:41.920 --> 00:40:47.180
So what's important here is that the notion that we, 2.0 style has the thing where there's

00:40:47.180 --> 00:40:49.040
a very specific place that execute happens.

00:40:49.040 --> 00:40:56.120
Because with the query object that SQLAlchemy session.query, you could say query.all, query.one,

00:40:56.120 --> 00:40:56.680
query.first.

00:40:56.680 --> 00:40:59.720
I didn't want to have all this await this, await that, await everything.

00:40:59.720 --> 00:41:03.080
With the new API, it's just, which is really the old API.

00:41:03.480 --> 00:41:04.920
It's await execute.

00:41:04.920 --> 00:41:07.600
And then you get your result back and then the result is buffered.

00:41:07.600 --> 00:41:13.580
And the way this works that changed the whole asyncio equation for SQLAlchemy is that this

00:41:13.580 --> 00:41:14.680
is not a rewrite of anything.

00:41:14.680 --> 00:41:18.920
This is a layer on top of the completely blocking API stuff.

00:41:18.920 --> 00:41:20.080
And it does not use threads.

00:41:20.080 --> 00:41:21.240
It uses Greenlit.

00:41:21.240 --> 00:41:21.980
Right.

00:41:22.140 --> 00:41:27.440
When I went to look at what Greenlit actually does, Greenlit is compared to a thread, but

00:41:27.440 --> 00:41:28.380
it's like a thread.

00:41:28.380 --> 00:41:31.580
But when you see what it is, it doesn't really feel like a thread because it's like, it's

00:41:31.580 --> 00:41:34.460
a little thing with code that you can context switch somewhere else.

00:41:34.460 --> 00:41:37.120
More like, it's more like generators than it is like threads.

00:41:37.120 --> 00:41:39.000
Like the weirdness of generators skipping around.

00:41:39.000 --> 00:41:39.200
Yeah.

00:41:39.200 --> 00:41:39.940
Exactly.

00:41:39.940 --> 00:41:45.680
So the way Python asyncio has that await keyword, the await is your context switch in asyncio.

00:41:45.680 --> 00:41:50.000
Now, I wanted the internals of SQLAlchemy to work in this context switching way, but to

00:41:50.000 --> 00:41:51.000
integrate with await.

00:41:51.180 --> 00:41:57.260
So we basically made a Greenlit wrapper that emulates await without actually using await.

00:41:57.260 --> 00:42:03.340
So you're able to take SQLAlchemy's blocking internals, which ultimately go out to, when

00:42:03.340 --> 00:42:08.060
you use SQLAlchemy asyncio, if you're going to use a DB API, actually it's not DB, it's

00:42:08.060 --> 00:42:11.320
a database driver, that is also asyncio.

00:42:11.320 --> 00:42:13.180
Currently, here goes the goal.

00:42:13.180 --> 00:42:19.260
Async PG, AO SQLite, there's async my, and also there's one, oh, I can't remember the name

00:42:19.260 --> 00:42:19.480
of it.

00:42:19.580 --> 00:42:23.780
Wait, I can't remember the name, trying to get Danielle to, Psycho PG3.

00:42:23.780 --> 00:42:26.100
I was teasing Danielle because he's on there.

00:42:26.100 --> 00:42:31.280
There's going to be a Psycho PG3 that we're also going to support that does asyncio for

00:42:31.280 --> 00:42:31.700
Postgres.

00:42:31.700 --> 00:42:38.140
So you have asyncio driver, SQLAlchemy then adapts, it's the await calls into the synchronous

00:42:38.140 --> 00:42:40.080
thing using the Greenlit thing.

00:42:40.080 --> 00:42:45.340
And then on the outside, where you see on the screen there, is you have asyncio stuff.

00:42:45.340 --> 00:42:49.560
And when I actually talked to some of the people that were involved with asyncio in Python,

00:42:49.560 --> 00:42:51.780
they explained to me, you could do it the other way too.

00:42:51.780 --> 00:42:57.600
You can have a synchronous API that calls into an async middle that goes back out to a

00:42:57.600 --> 00:42:58.060
sync API.

00:42:58.060 --> 00:42:59.300
And that's actually easier to do.

00:42:59.300 --> 00:43:02.640
But since SQLAlchemy was already written in sync blocking style, we kept it that way.

00:43:02.640 --> 00:43:02.820
Right.

00:43:02.820 --> 00:43:07.900
It's a lot easier to wrap an async shell on something that's 15 years old and polished.

00:43:08.640 --> 00:43:08.960
Right.

00:43:08.960 --> 00:43:11.220
Then to say, we're going to do the inside all over again.

00:43:11.220 --> 00:43:11.580
Yeah.

00:43:11.580 --> 00:43:11.920
Yeah.

00:43:11.920 --> 00:43:16.780
And the thing with async is that there were some SQLAlchemy based things on GitHub and

00:43:16.780 --> 00:43:20.860
whatever that were basically taking our engine and connection, rewriting them as totally brand

00:43:20.860 --> 00:43:21.700
new asyncio things.

00:43:21.700 --> 00:43:21.760
Yeah.

00:43:21.760 --> 00:43:24.760
And I always thought that's not, you can't maintain that.

00:43:24.760 --> 00:43:29.500
It's protecting our code, taking about 30% of what it actually does and putting it up.

00:43:29.500 --> 00:43:31.700
And I was like, that can't work.

00:43:31.700 --> 00:43:32.800
There's got to be a way to get green.

00:43:33.100 --> 00:43:36.440
Cause I had used G events and event lit a lot.

00:43:36.440 --> 00:43:38.520
And I'm like, okay, I know if I'm going to do this.

00:43:38.520 --> 00:43:40.840
I know it can context switch without using any way.

00:43:40.840 --> 00:43:41.620
I know it can do it.

00:43:41.620 --> 00:43:44.260
I just had to go in agreement and read the docs.

00:43:44.260 --> 00:43:44.860
And I did that.

00:43:44.860 --> 00:43:45.480
Yeah.

00:43:45.480 --> 00:43:46.120
That's really cool.

00:43:46.120 --> 00:43:51.060
I'm super excited to see this because it opens up using SQLAlchemy with some of the other

00:43:51.060 --> 00:43:52.820
frameworks that really leverage it.

00:43:52.820 --> 00:43:56.000
For example, FastAPI, but there's plenty of others as well.

00:43:56.000 --> 00:43:56.240
Right.

00:43:56.240 --> 00:43:56.580
Yeah.

00:43:56.580 --> 00:44:02.580
Another cool thing about asyncio was that when I did the SQLAlchemy 1.4, which introduces

00:44:02.580 --> 00:44:07.100
this new query ORM interface, but keeps the old one, which is not going to go away.

00:44:07.100 --> 00:44:09.220
Cause there's just too much code in the old query interface.

00:44:09.220 --> 00:44:12.260
But for asyncio, it's totally brand new greenfield development.

00:44:12.260 --> 00:44:16.200
So I said with async, you've got to use our new API that automatically got a lot of people

00:44:16.200 --> 00:44:20.340
to be testing the new way of working and got us to get people.

00:44:20.340 --> 00:44:25.200
Cause the one thing that makes libraries really good is when a lot of people use them and finds

00:44:25.200 --> 00:44:29.020
problems with them and add use cases and the library becomes mature.

00:44:29.580 --> 00:44:33.960
So the asyncio thing has been enormously helpful to bring a lot of people to SQLAlchemy

00:44:33.960 --> 00:44:35.280
who would not have been there.

00:44:35.280 --> 00:44:37.940
A lot of people who were probably going to leave SQLAlchemy stayed.

00:44:37.940 --> 00:44:38.640
Yeah.

00:44:38.640 --> 00:44:40.260
And people using the new 2.0 thing.

00:44:40.260 --> 00:44:42.180
SQL model probably wouldn't have been based on SQLAlchemy.

00:44:42.180 --> 00:44:42.560
Not at all.

00:44:42.560 --> 00:44:43.900
Yeah.

00:44:43.900 --> 00:44:45.160
Yeah, exactly.

00:44:45.160 --> 00:44:48.820
Because obviously, Sebastian needs that to integrate with FastAPI.

00:44:48.820 --> 00:44:50.900
And the async is a core element there.

00:44:50.900 --> 00:44:55.500
Audience, Daniel says, I wonder if other drivers are moving to expose native async interfaces

00:44:55.500 --> 00:44:55.900
themselves.

00:44:56.140 --> 00:44:57.260
Time to go back to DBC.

00:44:57.260 --> 00:44:58.220
DBC, yeah.

00:44:58.220 --> 00:45:00.280
That's the database special interest group.

00:45:00.280 --> 00:45:01.680
Sure.

00:45:01.680 --> 00:45:03.360
Daniel can go there.

00:45:03.360 --> 00:45:07.980
I've not had much success when I go to the SAC, suggest things.

00:45:07.980 --> 00:45:08.100
Yeah.

00:45:08.100 --> 00:45:13.760
Let me talk about this async API a little bit for folks who are probably familiar with SQL

00:45:13.760 --> 00:45:15.340
Alchemy's traditional API.

00:45:15.520 --> 00:45:19.260
because there's a couple of things that stand out to me here.

00:45:19.260 --> 00:45:22.120
One is, let's start simple here.

00:45:22.120 --> 00:45:28.440
One is you have this concept of creating a select statement and then executing the statement

00:45:28.440 --> 00:45:32.800
as opposed to like a query of a dot filter.

00:45:32.800 --> 00:45:37.240
So there's this sort of this statement model that you build up.

00:45:37.240 --> 00:45:37.380
Yeah.

00:45:37.380 --> 00:45:38.720
You want to speak about that?

00:45:38.720 --> 00:45:44.180
The original, the SQLAlchemy with query really is 95% the same statement model.

00:45:44.180 --> 00:45:49.540
It's just the statement has the fetcher, the getter, the result fetching method stuck on

00:45:49.540 --> 00:45:49.680
it.

00:45:49.680 --> 00:45:54.860
And when we, when query came out, that was a historical thing.

00:45:54.860 --> 00:45:58.280
The original idea of SQLAlchemy was that there was only going to be the select object.

00:45:58.280 --> 00:46:02.380
And then you would use select object in with the session to get results.

00:46:02.560 --> 00:46:05.840
And then it wasn't really very done very well.

00:46:05.840 --> 00:46:06.820
It wasn't very flexible.

00:46:06.820 --> 00:46:10.860
So people were coming to me with, why don't we use generative builder thing?

00:46:10.860 --> 00:46:12.400
And that's what happened.

00:46:12.400 --> 00:46:15.300
Cause I wasn't really, I was kind of, I was a little bit rudderless in those days.

00:46:15.300 --> 00:46:21.180
So we had query and it took me quite a long time to realize, wait a second, query is basically

00:46:21.180 --> 00:46:24.440
once query got much more fancy, it started as very simplistic, well, I could query for one

00:46:24.440 --> 00:46:25.760
object and do this and that.

00:46:25.760 --> 00:46:29.660
As I had to keep adding to it, it became clear that I was rebuilding select.

00:46:29.660 --> 00:46:30.640
They met in the middle.

00:46:31.340 --> 00:46:31.740
Yeah.

00:46:31.740 --> 00:46:35.420
Then like, I'm just rebuilding select in exactly the same, but slightly different way.

00:46:35.420 --> 00:46:37.560
And that bothered me for years.

00:46:37.560 --> 00:46:45.420
So with 2.0, I finally took that on and did a really long, difficult refactoring to take

00:46:45.420 --> 00:46:50.660
all of the guts of ORM query and put it into a different module called context that you don't

00:46:50.660 --> 00:46:51.080
deal with.

00:46:51.080 --> 00:46:57.860
And when you get the select object you see there, that indicates the exact same intent as query

00:46:57.860 --> 00:46:59.420
a options filter.

00:46:59.620 --> 00:47:04.780
And they both go to the same backend that does all the ORM figure it out stuff.

00:47:04.780 --> 00:47:04.940
Right.

00:47:04.940 --> 00:47:08.980
That's a little more elaborate to come up with the sequel that will be sent to the database.

00:47:08.980 --> 00:47:11.260
One of the biggest refactoring was I've ever done.

00:47:11.260 --> 00:47:14.780
And it was quite stressful when it seemed like I'm sitting dead ends is, oh, this is not going

00:47:14.780 --> 00:47:15.060
to work.

00:47:15.060 --> 00:47:15.340
Yeah.

00:47:15.340 --> 00:47:16.120
I can imagine.

00:47:16.120 --> 00:47:16.980
It was tough, but.

00:47:16.980 --> 00:47:17.320
Yeah.

00:47:17.320 --> 00:47:17.680
This is cool.

00:47:17.680 --> 00:47:17.840
Yeah.

00:47:18.100 --> 00:47:23.800
So basically the query of class dot that style is going away, right?

00:47:23.800 --> 00:47:27.580
It's never going to go away because there's so much code in that style that it's basically

00:47:27.580 --> 00:47:30.180
not, when you go to the website, it's not going to be in the tutorial.

00:47:30.180 --> 00:47:32.120
It's going to, it'll be in reference docs.

00:47:32.120 --> 00:47:34.160
So people that deal with that code could deal with it.

00:47:34.160 --> 00:47:38.180
It'd be in some sort of middle ground where it's not fully deprecated, but it's not promoted

00:47:38.180 --> 00:47:38.560
either.

00:47:38.560 --> 00:47:38.860
Huh?

00:47:38.860 --> 00:47:39.620
It's called legacy.

00:47:39.620 --> 00:47:42.200
We've had different systems that stayed legacy for many years.

00:47:42.200 --> 00:47:42.560
Makes sense.

00:47:42.560 --> 00:47:43.340
It's very.

00:47:43.340 --> 00:47:45.260
There's so much code written that way.

00:47:45.340 --> 00:47:45.980
I totally agree.

00:47:45.980 --> 00:47:46.260
Yeah.

00:47:46.260 --> 00:47:47.420
I probably would never take it out.

00:47:47.420 --> 00:47:52.680
So, but what I did do is when I do that, I try to make that code written such that it's

00:47:52.680 --> 00:47:53.580
all by itself.

00:47:53.580 --> 00:47:58.280
And it basically what query does now is it makes that select inside and sends it off.

00:47:58.280 --> 00:48:00.160
So it's what you call eating your own dog food.

00:48:00.160 --> 00:48:05.240
It means that the alternate API uses the real API internally.

00:48:05.240 --> 00:48:06.580
So you're testing it either way.

00:48:06.580 --> 00:48:06.920
Right.

00:48:06.920 --> 00:48:11.300
Going back to our patterns talk, it's like an adapter for the select pattern.

00:48:11.300 --> 00:48:11.560
Yeah.

00:48:11.560 --> 00:48:11.920
Okay.

00:48:11.920 --> 00:48:12.360
API.

00:48:12.360 --> 00:48:12.860
Yeah.

00:48:12.860 --> 00:48:14.660
Two other things that stand out here.

00:48:14.800 --> 00:48:19.620
One is you create a session maker traditionally, and you create a session by calling it.

00:48:19.620 --> 00:48:22.400
Here you have an async session maker, right?

00:48:22.400 --> 00:48:23.140
To create them.

00:48:23.140 --> 00:48:24.480
That's one of the differences.

00:48:24.480 --> 00:48:26.140
That's not super different.

00:48:26.140 --> 00:48:32.380
But the other one that is interesting to me is now these things are context managers, which

00:48:32.380 --> 00:48:38.260
when I used to work with SQLAlchemy, traditional ones, I would create a class called a session

00:48:38.260 --> 00:48:41.700
context just so I could do this in a with statement.

00:48:41.700 --> 00:48:44.780
And here, obviously it's an async with statement, but that's just the async.

00:48:44.780 --> 00:48:46.120
It's in the async aspect of it.

00:48:46.120 --> 00:48:47.520
It's in the async aspect too.

00:48:47.520 --> 00:48:47.660
Yeah.

00:48:47.660 --> 00:48:53.780
I should mention that when SQLAlchemy in 2006, we were in Python 2.3, there were not context

00:48:53.780 --> 00:48:54.080
managers.

00:48:54.080 --> 00:48:55.740
They didn't come out until Python 2.5.

00:48:55.740 --> 00:48:55.760
Right.

00:48:55.760 --> 00:48:58.260
So you can't integrate with them if they don't exist in your API, right?

00:48:58.380 --> 00:48:59.460
So I didn't.

00:48:59.460 --> 00:49:00.960
So nothing was based on that.

00:49:00.960 --> 00:49:06.860
SQL me 1.4 and 2.0, as much as possible, completely support the context manager model.

00:49:06.860 --> 00:49:12.360
And the docs and the tutorials, if you look at the new 1.4 tutorial that's on the site, it's

00:49:12.360 --> 00:49:13.360
all about context managers.

00:49:13.360 --> 00:49:17.680
And all the try, accepts, and ready your own thing should go away.

00:49:17.680 --> 00:49:19.020
You should use context managers now.

00:49:19.020 --> 00:49:23.660
And what you see there with the async pattern, I've made it so that if you're using all the

00:49:23.660 --> 00:49:30.020
new APIs, the context manager pattern with the engine and connection in core is mirrored to

00:49:30.020 --> 00:49:32.900
the context manager pattern with the session and the session maker.

00:49:32.900 --> 00:49:33.200
Nice.

00:49:33.500 --> 00:49:36.020
And then it's also mirrored in the asyncio API.

00:49:36.020 --> 00:49:37.120
So there's four different APIs.

00:49:37.120 --> 00:49:39.600
There's core and ORM, sync and async.

00:49:39.600 --> 00:49:45.120
And they all should have, as much as they can, the same, this means cone.

00:49:45.120 --> 00:49:45.740
Yeah.

00:49:45.740 --> 00:49:50.000
They have the same, as much as possible, they share the same context manager patterns.

00:49:50.000 --> 00:49:54.640
And we want you to use context managers for everything now, for any kind of blocking.

00:49:54.640 --> 00:49:59.480
And that's also how we can improve the transactional model so that you're really working the transaction

00:49:59.480 --> 00:50:00.680
all the time with the core.

00:50:01.520 --> 00:50:04.040
Because it's not a burden because you have context managers.

00:50:04.040 --> 00:50:04.760
Things I see here.

00:50:04.760 --> 00:50:08.480
I want to ask you about two bits of code and then take another question from the audience.

00:50:08.480 --> 00:50:13.220
So you have a with session.begin and you do some inserts.

00:50:13.220 --> 00:50:15.900
And then you don't say session.commit.

00:50:15.900 --> 00:50:20.820
So the way this works, I'm presuming, tell me if I understand this right, is if it makes

00:50:20.820 --> 00:50:23.560
it through the with block without an error, it commits.

00:50:23.560 --> 00:50:28.060
If it makes it through the with block with an exception, it just doesn't commit and effectively

00:50:28.060 --> 00:50:28.620
rolls it back.

00:50:28.620 --> 00:50:29.940
That's what it does.

00:50:29.940 --> 00:50:30.380
It does a rollback.

00:50:30.380 --> 00:50:30.600
Yeah.

00:50:31.080 --> 00:50:31.620
That's correct.

00:50:31.620 --> 00:50:31.820
Yeah.

00:50:31.820 --> 00:50:35.500
And we've had the begin context manager for a long time.

00:50:35.500 --> 00:50:38.080
It's just, it wasn't totally consistent everywhere.

00:50:38.080 --> 00:50:40.120
But it's always, we've had that for a long time.

00:50:40.120 --> 00:50:40.960
Yeah.

00:50:40.960 --> 00:50:45.920
But now I've made sure that all the opening and closing of a resource and the begin commit

00:50:45.920 --> 00:50:47.800
of a resource are consistent.

00:50:47.800 --> 00:50:53.380
And also there's always a way that you can open the resource and begin commit in one line.

00:50:53.380 --> 00:50:56.480
Also the session maker has a begin on it now.

00:50:56.480 --> 00:50:56.840
Super.

00:50:56.840 --> 00:50:57.620
And you could do that.

00:50:57.720 --> 00:51:02.400
The other thing I'm super familiar with execute, but then you also have stream, which looks

00:51:02.400 --> 00:51:02.980
real similar.

00:51:02.980 --> 00:51:04.340
What's the difference there?

00:51:04.340 --> 00:51:06.360
Stream is asyncio only right now.

00:51:06.360 --> 00:51:11.980
Stream is because it's important in many cases to get a result that's doing async streaming.

00:51:11.980 --> 00:51:15.220
And when you're doing async streaming with a, you've got to have the await keyword.

00:51:15.360 --> 00:51:19.620
So you can see the result object returned from session.stream is called an async result.

00:51:19.620 --> 00:51:26.740
And all of the methods have the async annotation on them so that you see it's async for a in result.scalers.

00:51:26.740 --> 00:51:27.020
Oh, I see.

00:51:27.020 --> 00:51:31.500
So the things you interact with, the subsequent functions are themselves all async as well.

00:51:31.500 --> 00:51:32.040
Okay.

00:51:32.040 --> 00:51:32.480
Yeah.

00:51:32.480 --> 00:51:32.740
That's cool.

00:51:32.840 --> 00:51:32.960
Yes.

00:51:32.960 --> 00:51:36.860
And what that will do is that will try to use a server-side cursor.

00:51:36.860 --> 00:51:37.080
Yeah.

00:51:37.080 --> 00:51:37.340
Yeah.

00:51:37.340 --> 00:51:37.960
That's what I imagine.

00:51:37.960 --> 00:51:38.420
That's cool.

00:51:38.420 --> 00:51:39.140
You actually are.

00:51:39.140 --> 00:51:43.320
Instead of trying to pull it all into memory, if you got a thousand rows back, you could start

00:51:43.320 --> 00:51:45.420
pulling them more generator-like, right?

00:51:45.420 --> 00:51:48.960
When you use a server-side cursor, you actually are genuinely not pulling everything into memory

00:51:48.960 --> 00:51:49.280
first.

00:51:49.280 --> 00:51:52.380
When you use the buffered result, you're getting everything into memory.

00:51:52.380 --> 00:51:52.640
Yeah.

00:51:52.640 --> 00:51:53.980
Which is normally okay.

00:51:53.980 --> 00:51:54.180
Yeah.

00:51:54.180 --> 00:51:55.320
Most of the time it's fine.

00:51:55.580 --> 00:51:58.300
But if you want a whole bunch, oh, you're flowing it on.

00:51:58.300 --> 00:51:58.800
Yeah.

00:51:58.800 --> 00:52:00.520
Anyway, a lot of cool stuff there.

00:52:00.520 --> 00:52:02.140
We'll get short on time.

00:52:02.140 --> 00:52:06.560
Mr. Hypermagnetic out there asked, does SQLAlchemy support paginated results?

00:52:06.560 --> 00:52:10.980
But that also leads us towards a little area I want to focus on just a couple of things as

00:52:10.980 --> 00:52:11.180
well.

00:52:11.180 --> 00:52:13.060
So yeah, maybe address that first.

00:52:13.060 --> 00:52:18.020
Paginated results is one of those things that seems simple, but it's more of a quagmire

00:52:18.020 --> 00:52:19.080
than you might expect.

00:52:19.080 --> 00:52:21.140
There's different ways to do paginated results.

00:52:21.140 --> 00:52:25.200
The way we all did it years ago was we used these functions that seem called limit and offset.

00:52:25.200 --> 00:52:29.580
offset where limit will give you like 10 rows at a time and offset will start your result

00:52:29.580 --> 00:52:30.180
set in the middle.

00:52:30.180 --> 00:52:34.560
Once we work with bigger database, we all realize that offset is terrible because offset will

00:52:34.560 --> 00:52:37.080
actually get the whole result set and scroll through it.

00:52:37.080 --> 00:52:38.900
It does it on the server side, but it's still very slow.

00:52:38.900 --> 00:52:42.660
So nowadays when you do pagination, you want to have some kind of approach where the query

00:52:42.660 --> 00:52:49.860
you're doing is looking at some data in the data, some row, the data, some column in

00:52:49.860 --> 00:52:50.480
the data you're querying.

00:52:50.480 --> 00:52:55.560
So if you're paginating by date, page 10 would be where date is greater than this date

00:52:55.560 --> 00:52:57.880
that from the previous page you just got.

00:52:57.880 --> 00:52:58.880
That's one way.

00:52:58.880 --> 00:53:02.700
Another way is to write SQL query that do this thing called window functions, where you can

00:53:02.700 --> 00:53:05.760
figure out all the date or this whatever thing ahead of time.

00:53:05.760 --> 00:53:10.920
Pagination implies, on that approach, implies that you have, or actually of any approach,

00:53:10.920 --> 00:53:13.080
implies that you have an order by something.

00:53:13.420 --> 00:53:18.340
So it's hard to make pagination be like this, like this result here, result.scalars to say

00:53:18.340 --> 00:53:19.120
.paginate.

00:53:19.120 --> 00:53:24.420
That's not really, you can make a very crappy version that does that, but it's not really,

00:53:24.420 --> 00:53:25.920
it wouldn't really work that way.

00:53:25.920 --> 00:53:33.380
There is, I should say there is a method in the result called partitions that will give

00:53:33.380 --> 00:53:35.320
you chunks of a result at a time.

00:53:35.500 --> 00:53:39.340
It's not quite the same as pagination because pagination is stateless, it's usually for web

00:53:39.340 --> 00:53:43.140
applications where you're going to get a certain page of a result and then show them a web page

00:53:43.140 --> 00:53:44.680
and then your whole SQL is over.

00:53:44.680 --> 00:53:45.240
Right.

00:53:45.240 --> 00:53:46.780
And then you're going to come back to that SQL later.

00:53:46.780 --> 00:53:52.380
So we have features built in for partitioning of a single result set so that you get chunks

00:53:52.380 --> 00:53:53.860
of that time, which is helpful.

00:53:53.860 --> 00:53:59.120
Pagination is something you need to go look, there's some, I think maybe SQL Utils probably

00:53:59.120 --> 00:54:01.040
has some helper functions for that.

00:54:01.040 --> 00:54:04.660
We have some recipes in that wiki page that I told you to leave.

00:54:04.660 --> 00:54:07.120
There's actually some recipes for pagination there.

00:54:07.120 --> 00:54:09.400
I don't think pagination is like a turnkey.

00:54:09.400 --> 00:54:14.840
It's got to be customized and people will write pagination frameworks and they're complicated

00:54:14.840 --> 00:54:15.800
and they're hard to do.

00:54:15.800 --> 00:54:21.740
So we leave those as an exercise for the community too, but we do have some recipes for that.

00:54:21.740 --> 00:54:22.620
That's a great answer.

00:54:22.620 --> 00:54:23.540
Okay.

00:54:23.540 --> 00:54:29.480
Now for the last thing, I wanted to talk really quickly about this list from Dahlia called

00:54:29.480 --> 00:54:30.800
Awesome SQLAlchemy.

00:54:30.800 --> 00:54:34.580
It's one of these awesome lists that covers all these SQLAlchemy things like data structures

00:54:34.580 --> 00:54:35.240
and types.

00:54:35.240 --> 00:54:40.140
And I'm just throwing this at you and neither of us have a ton of experience with a lot of

00:54:40.140 --> 00:54:42.660
these things, but I thought it'd be fun to just kind of go through them.

00:54:42.660 --> 00:54:47.180
Some of the nice or interesting things that I've ran across here.

00:54:47.180 --> 00:54:49.200
So it's a way to kind of wrap this up like some extras.

00:54:49.200 --> 00:54:49.680
All right.

00:54:49.680 --> 00:54:56.640
So one of them is SQLAlchemy Continuum, a versioning extension for SQLAlchemy.

00:54:56.640 --> 00:54:57.420
I know what this is.

00:54:57.420 --> 00:54:57.600
Yeah.

00:54:57.600 --> 00:54:58.120
Yeah.

00:54:58.520 --> 00:55:04.280
So it's probably based on one of the recipes that we have in the source distribution.

00:55:04.280 --> 00:55:05.740
Version A, yeah.

00:55:05.740 --> 00:55:08.620
It says the first line of SQLAlchemy already has a versioning extension.

00:55:08.620 --> 00:55:09.980
The extension is very limited.

00:55:09.980 --> 00:55:10.960
That's correct.

00:55:10.960 --> 00:55:12.960
Everything he wrote there and everything they wrote there is correct.

00:55:13.420 --> 00:55:18.080
I have some jobs in the banking industry where I was doing SQLAlchemy and we had some need

00:55:18.080 --> 00:55:19.600
to version rows.

00:55:19.600 --> 00:55:24.360
I need to know exactly audit this and when has it changed and how do I go back?

00:55:24.360 --> 00:55:25.300
All that kind of stuff.

00:55:25.300 --> 00:55:25.520
Right.

00:55:25.520 --> 00:55:25.820
Yeah.

00:55:25.820 --> 00:55:26.660
There's different models.

00:55:26.660 --> 00:55:30.780
You can either take the rows as you get them and put them in an aircraft table, or you can

00:55:30.780 --> 00:55:33.420
do this thing where you never update or delete a row.

00:55:33.520 --> 00:55:36.880
You just insert a new row and you've got a temporal version scheme.

00:55:36.880 --> 00:55:41.060
I have some recipes to do that in the example section because I did them at a job and I believe

00:55:41.060 --> 00:55:42.540
Continuum builds upon those.

00:55:42.540 --> 00:55:43.100
Fantastic.

00:55:43.100 --> 00:55:45.840
To make a more robust, supported thing.

00:55:45.840 --> 00:55:46.800
I don't know.

00:55:46.800 --> 00:55:48.020
I've heard of Liquibase.

00:55:48.020 --> 00:55:49.980
I don't know.

00:55:49.980 --> 00:55:51.180
Yeah.

00:55:51.180 --> 00:55:52.740
I forgot where Liquibase is.

00:55:52.740 --> 00:55:54.800
I'm not a Java person either.

00:55:54.800 --> 00:55:55.220
Yeah.

00:55:55.220 --> 00:55:55.760
But yeah.

00:55:55.760 --> 00:55:56.040
Okay.

00:55:56.040 --> 00:55:56.800
Maybe.

00:55:56.800 --> 00:55:57.880
It might be like that.

00:55:57.880 --> 00:56:01.920
Here's another one that I ran across from that SQLAlchemy awesome list is SQLAlchemy

00:56:01.920 --> 00:56:03.260
enum 3.4.

00:56:03.260 --> 00:56:05.040
I'm guessing because it came from Python 3.4.

00:56:05.040 --> 00:56:07.860
This package provides SQLAlchemy type to store.

00:56:07.860 --> 00:56:10.600
I use a standard enum.enums.

00:56:10.600 --> 00:56:14.720
Because a lot of times what happens is those things get turned into like numbers or other

00:56:14.720 --> 00:56:15.620
weird things.

00:56:15.620 --> 00:56:18.260
And here they get a little more type information, right?

00:56:18.260 --> 00:56:18.920
Yeah.

00:56:18.920 --> 00:56:18.960
Yeah.

00:56:18.960 --> 00:56:23.960
This might be obsolete because we do support regular Python enums in our enum type.

00:56:23.960 --> 00:56:24.400
Yeah.

00:56:24.400 --> 00:56:24.840
We did it first.

00:56:24.840 --> 00:56:27.160
This is looking like it's, well, seven months ago.

00:56:27.160 --> 00:56:27.860
I don't know.

00:56:27.860 --> 00:56:31.640
If someone's using this, they could stay because there are some enum features.

00:56:31.640 --> 00:56:34.680
I've been notified that we don't do exactly the way.

00:56:34.680 --> 00:56:37.680
There's some extra features that I forgot what they were, but there are some things that

00:56:37.680 --> 00:56:39.080
enums do that we don't support.

00:56:39.080 --> 00:56:40.360
Maybe it adds that on, yeah.

00:56:40.360 --> 00:56:41.620
So maybe this probably does that better.

00:56:41.620 --> 00:56:41.940
Yeah.

00:56:41.940 --> 00:56:44.140
Enums are really a pain in the butt.

00:56:44.140 --> 00:56:44.500
Yeah.

00:56:44.500 --> 00:56:45.280
I know.

00:56:45.280 --> 00:56:45.780
The data types.

00:56:45.780 --> 00:56:46.180
I know.

00:56:46.180 --> 00:56:47.180
All right.

00:56:47.180 --> 00:56:49.380
The Python side's good, but the database side is.

00:56:49.380 --> 00:56:50.160
Yeah.

00:56:50.160 --> 00:56:50.980
Yeah.

00:56:50.980 --> 00:56:51.940
It's always some sort of hack.

00:56:51.940 --> 00:56:52.080
Yeah.

00:56:52.080 --> 00:56:53.020
Alembic.

00:56:53.020 --> 00:56:57.800
I mean, that's pretty well known to people, but that's obviously important because you've

00:56:57.800 --> 00:57:01.620
got to keep your database and your models pretty closely in sync, right?

00:57:01.620 --> 00:57:01.840
Yeah.

00:57:01.840 --> 00:57:03.060
So we maintain Alembic.

00:57:03.060 --> 00:57:09.000
I wrote Alembic years ago as SQLAlchemy Migrate was not really holding up to what we were

00:57:09.000 --> 00:57:09.380
doing.

00:57:09.380 --> 00:57:12.680
SQLAlchemy Migrate is part of OpenStack now.

00:57:12.680 --> 00:57:14.940
And I actually have maintained that a little bit as well.

00:57:14.940 --> 00:57:20.680
But Alembic was meant to be more of a bare bones, a straightforward, not too fancy tool.

00:57:20.680 --> 00:57:22.320
It has become fancier.

00:57:22.320 --> 00:57:26.060
And people that use it and get what it's about like it a lot.

00:57:26.060 --> 00:57:29.420
It's never going to be as cool as South for Django.

00:57:29.420 --> 00:57:32.080
Maybe an Alembic 3.

00:57:32.080 --> 00:57:34.640
But that could happen.

00:57:35.300 --> 00:57:38.060
It's not as automated as everybody would like.

00:57:38.060 --> 00:57:43.060
It has a system that it will look at your models and look at the database and what we

00:57:43.060 --> 00:57:44.900
call auto-generate your migrations.

00:57:44.900 --> 00:57:48.560
But we don't guarantee those migrations are completely perfect.

00:57:48.560 --> 00:57:53.080
You've got to go and look at them and fix them, which I still think it just did 95% of

00:57:53.080 --> 00:57:55.080
the typing for you, of the work for you.

00:57:55.080 --> 00:57:56.200
That's what it was meant to do.

00:57:56.200 --> 00:58:01.820
Yeah, I think also it's helpful because it works in that realm of that's the area of

00:58:01.820 --> 00:58:04.540
SQL I know less well, the DDL and that drop.

00:58:04.540 --> 00:58:09.060
You know, how do I drop a table or a column and then re-add it under a different name without

00:58:09.060 --> 00:58:09.620
losing data?

00:58:09.620 --> 00:58:10.920
Like all that kind of stuff can be tricky.

00:58:10.920 --> 00:58:15.360
Yeah, and a DDL is where a lot of the database vendor specific stuff is exposed.

00:58:15.360 --> 00:58:15.720
Yeah.

00:58:15.720 --> 00:58:18.500
Like all these crazy keywords and data types.

00:58:18.500 --> 00:58:21.500
And it's less declarative and more imperative.

00:58:21.500 --> 00:58:26.020
And so for Alembic, we just provide a model to create your migrations and it's been working

00:58:26.020 --> 00:58:26.560
pretty well.

00:58:26.560 --> 00:58:31.520
It's got a lot of features now, but it's again, a tool where if you don't know what DDL is,

00:58:31.520 --> 00:58:34.480
you're going to have a bad time with Alembics.

00:58:34.480 --> 00:58:35.360
Yeah, sure.

00:58:35.360 --> 00:58:39.820
You should learn what database migrations look like in the alter table, alter column, and

00:58:39.820 --> 00:58:41.240
know what that means.

00:58:41.240 --> 00:58:42.940
And then Alembic will be pretty smooth.

00:58:42.940 --> 00:58:44.060
And there actually are extensions for Alembic.

00:58:44.060 --> 00:58:45.500
I saw it wasn't on that list.

00:58:45.500 --> 00:58:47.320
There's an extension called Alembic Utils.

00:58:47.320 --> 00:58:47.740
Oh, nice.

00:58:47.740 --> 00:58:52.260
Which are extensions for Alembic for Postgres that also build upon some recipes that are

00:58:52.260 --> 00:58:52.980
in these docs here.

00:58:52.980 --> 00:58:55.000
And I recommend looking at that too.

00:58:55.000 --> 00:58:55.300
All right.

00:58:55.300 --> 00:58:57.000
There's a couple we can go quick on.

00:58:57.000 --> 00:59:00.800
There's one for talking to Amazon Redshift as a provider.

00:59:00.800 --> 00:59:01.740
That's pretty cool.

00:59:01.740 --> 00:59:04.740
There's Form Alchemy, which...

00:59:04.740 --> 00:59:05.480
Is this still maintained?

00:59:05.480 --> 00:59:06.700
This is an old one.

00:59:06.700 --> 00:59:08.700
Form Alchemy is 12 years old.

00:59:08.700 --> 00:59:09.240
All right.

00:59:09.240 --> 00:59:09.780
This is what it is.

00:59:09.780 --> 00:59:10.360
It's old.

00:59:10.360 --> 00:59:12.480
Maybe it still works, but let's leave that one alone.

00:59:12.480 --> 00:59:13.400
It probably still works.

00:59:13.400 --> 00:59:13.600
Yeah, probably.

00:59:13.600 --> 00:59:14.600
It looks like it's had...

00:59:14.600 --> 00:59:16.040
HTML hasn't changed since then.

00:59:16.040 --> 00:59:17.420
Just style some CSS on it.

00:59:17.720 --> 00:59:18.060
All right.

00:59:18.060 --> 00:59:22.000
GeoAlchemy is pretty popular for people doing geospatial work.

00:59:22.000 --> 00:59:22.260
Yep.

00:59:22.260 --> 00:59:23.460
So there's GeoAlchemy.

00:59:23.460 --> 00:59:24.420
There's GeoAlchemy 2.

00:59:24.420 --> 00:59:26.380
I'm not sure of the relationship.

00:59:26.380 --> 00:59:27.580
Which one is which?

00:59:27.580 --> 00:59:28.740
Who works on which one?

00:59:28.740 --> 00:59:31.480
GeoAlchemy seems like it might have...

00:59:31.480 --> 00:59:32.020
It might not...

00:59:32.020 --> 00:59:33.000
I'm not sure how much it's maintained.

00:59:33.000 --> 00:59:33.700
I think it's maintained.

00:59:33.700 --> 00:59:36.380
I would like it to be much more well-maintained.

00:59:36.380 --> 00:59:37.240
I think it supports...

00:59:37.240 --> 00:59:43.560
It's pretty Postgres-centric, but there are geo things for SQL Server and Oracle and MySQL.

00:59:43.560 --> 00:59:45.740
I would like to see that stuff supported as well.

00:59:45.740 --> 00:59:47.700
GeoAlchemy, I don't hear much about.

00:59:47.700 --> 00:59:49.440
But I think it's a good project.

00:59:49.440 --> 00:59:51.200
One for some growth, perhaps.

00:59:51.200 --> 00:59:52.340
SQL tab.

00:59:52.340 --> 00:59:57.380
SQL profiling and introspection for applications using SQLAlchemy.

00:59:57.380 --> 00:59:58.020
Wow.

00:59:58.020 --> 00:59:58.420
Have you seen this?

00:59:58.420 --> 00:59:58.840
Cool.

00:59:58.840 --> 01:00:00.260
I have not seen this either.

01:00:00.260 --> 01:00:00.940
What is it doing?

01:00:01.200 --> 01:00:06.900
So when you do a request, I think what it's doing, it stores what the page did.

01:00:06.900 --> 01:00:08.580
So it says here there's 12 queries.

01:00:08.580 --> 01:00:10.700
It spent like 20 milliseconds.

01:00:11.380 --> 01:00:15.920
And then you click on each one and it'll show you the select statements and like the actual SQL.

01:00:16.160 --> 01:00:17.960
So it's probably profiling from the client side.

01:00:17.960 --> 01:00:18.380
Yeah.

01:00:18.380 --> 01:00:19.140
Yeah, yeah, yeah.

01:00:19.140 --> 01:00:19.520
I think so.

01:00:19.520 --> 01:00:20.200
As far as the database.

01:00:20.200 --> 01:00:20.760
Yeah, yeah.

01:00:20.760 --> 01:00:21.700
That's nice.

01:00:21.700 --> 01:00:22.780
If you're just timing it, yeah.

01:00:22.780 --> 01:00:23.720
That's cool.

01:00:23.720 --> 01:00:25.080
I wonder if it does things like explain.

01:00:25.080 --> 01:00:29.540
I don't totally know, but it looks like it has a whiskey integration, which is cool.

01:00:29.980 --> 01:00:32.400
This is another one related sort of that helps.

01:00:32.400 --> 01:00:34.140
It's called N plus one.

01:00:34.140 --> 01:00:35.640
Oh, yeah.

01:00:35.640 --> 01:00:37.280
N plus one is the.

01:00:37.280 --> 01:00:37.840
That's cool.

01:00:37.840 --> 01:00:44.520
Yeah, it's a problem that many ORMs run into when people don't realize they're doing lazy loading and they don't do a join.

01:00:44.520 --> 01:00:46.600
And it can be super indirect.

01:00:46.600 --> 01:00:50.940
Like here I got a query of a list and I sent the list off to the HTML template.

01:00:50.940 --> 01:00:54.860
And the HTML template did a loop and talked about some property on the thing.

01:00:54.860 --> 01:00:58.060
And then there's a bunch of more database queries or something crazy, right?

01:00:58.060 --> 01:00:58.340
Yeah.

01:00:58.860 --> 01:01:01.460
Interesting that it seems to work for multiple lower ends.

01:01:01.460 --> 01:01:03.020
Yeah, SQLAlchemy, PeeWee, and Django.

01:01:03.020 --> 01:01:08.040
So I guess it's streaming and maybe just taps into the APIs of all those different tools.

01:01:08.040 --> 01:01:09.400
Yeah, probably someone's added a layer for each.

01:01:09.400 --> 01:01:13.460
Yeah, I guess you could do it in a kind of a distant way heuristically.

01:01:13.460 --> 01:01:18.700
If you want to see the same query to the same table over and over again, maybe that's what it's looking for.

01:01:18.700 --> 01:01:19.300
Yeah, perhaps.

01:01:19.300 --> 01:01:23.220
Where it could do that without necessarily looking at SQLAlchemy and saying lazy logo called.

01:01:23.220 --> 01:01:25.580
If it just looks at the SQL, there's probably ways to do it.

01:01:25.580 --> 01:01:27.880
But that's an intricate problem.

01:01:27.980 --> 01:01:29.500
But that seems like a really useful tool.

01:01:29.500 --> 01:01:30.000
Yeah, it does.

01:01:30.000 --> 01:01:32.800
And also I saw in there, we'll just close it out with this.

01:01:32.800 --> 01:01:38.440
I saw in there, they mentioned the Pyramid debug toolbar, the Flask debug toolbar, and the Django debug toolbar.

01:01:38.440 --> 01:01:39.600
And I can't speak to Django.

01:01:39.600 --> 01:01:41.540
I don't think I've even run the Flask one.

01:01:41.540 --> 01:01:47.020
But the Pyramid one has a, like, you can open it up and say, what were the SQLAlchemy queries of this page?

01:01:47.420 --> 01:01:49.140
And actually see how many queries.

01:01:49.140 --> 01:01:52.220
And if you're on a page and it says, look, there's 51 queries.

01:01:52.220 --> 01:01:53.300
You're like, I thought I did one.

01:01:53.300 --> 01:01:53.880
What just happened?

01:01:53.880 --> 01:01:54.880
How did I get 51?

01:01:54.880 --> 01:01:58.120
Like, well, you got 50 elements and an N plus one.

01:01:58.120 --> 01:01:59.620
Debugtubo, I haven't really worked with it.

01:01:59.620 --> 01:02:02.160
But yeah, we have a lot of people dealing with it.

01:02:02.160 --> 01:02:02.880
Yeah, yeah.

01:02:02.880 --> 01:02:04.360
We have to fix issues with it.

01:02:04.360 --> 01:02:06.440
I don't actually write any web applications anymore.

01:02:06.440 --> 01:02:07.460
I just do this.

01:02:07.460 --> 01:02:08.720
So I don't get to do that.

01:02:08.720 --> 01:02:09.760
I don't get to see that stuff.

01:02:09.760 --> 01:02:10.300
Oh, really cool.

01:02:10.380 --> 01:02:12.160
I also don't use them very much anymore either.

01:02:12.160 --> 01:02:15.460
I find that I don't need that support as much as I did in the early days.

01:02:15.460 --> 01:02:17.940
But I do remember them being quite valuable early on.

01:02:17.940 --> 01:02:19.080
All right, Mike.

01:02:19.080 --> 01:02:20.900
Well, there's more stuff we could go into.

01:02:20.900 --> 01:02:23.400
But what a cool conversation.

01:02:23.400 --> 01:02:27.620
And thank you so much for releasing the 2.0 stuff, for adding the async support.

01:02:27.620 --> 01:02:29.800
It really opens up a lot more use cases.

01:02:29.800 --> 01:02:31.960
I think that are going to be interesting for people.

01:02:31.960 --> 01:02:33.140
So, yeah, it's fantastic.

01:02:33.140 --> 01:02:33.860
Yeah, my pleasure.

01:02:33.860 --> 01:02:35.440
The async worked out really well.

01:02:35.440 --> 01:02:36.240
I'm really happy about that.

01:02:36.240 --> 01:02:38.580
Now, before you get out of here, let me ask you the final two questions.

01:02:38.860 --> 01:02:40.480
You kind of alluded to this already.

01:02:40.480 --> 01:02:43.380
If you're going to write some code, what Python editor do you use?

01:02:43.380 --> 01:02:45.440
I'm on VS Code right now.

01:02:45.440 --> 01:02:47.920
I was on Sublime for a long time.

01:02:47.920 --> 01:02:49.620
Years ago, I used TextMate.

01:02:49.620 --> 01:02:52.640
I do use VI and Vim a lot.

01:02:52.640 --> 01:02:55.780
But if I have lots of windows open, right now it's VS Code.

01:02:55.780 --> 01:02:56.100
Fantastic.

01:02:56.100 --> 01:02:59.260
And then notable IPI package.

01:02:59.260 --> 01:03:00.160
Anything come to mind?

01:03:00.160 --> 01:03:01.680
I mean, we kind of threw out a whole bunch.

01:03:01.680 --> 01:03:02.100
Probably not.

01:03:02.100 --> 01:03:03.120
Did I put anything?

01:03:03.120 --> 01:03:04.360
I'm going to click to that.

01:03:04.360 --> 01:03:04.960
I didn't put anything down.

01:03:04.960 --> 01:03:08.840
How about your favorite out of the list that I threw up there?

01:03:08.840 --> 01:03:12.000
Tell me, like, out of the awesome ones, which one stood out the most to you?

01:03:12.000 --> 01:03:13.560
Oh, that N plus one thing looks really interesting.

01:03:13.560 --> 01:03:13.860
All right.

01:03:13.860 --> 01:03:14.140
Awesome.

01:03:14.140 --> 01:03:16.480
So N plus one with the plus spelled out.

01:03:16.480 --> 01:03:17.700
And the one also spelled out.

01:03:17.700 --> 01:03:18.320
Yeah.

01:03:18.320 --> 01:03:18.700
That's cool.

01:03:18.700 --> 01:03:19.280
Yeah.

01:03:19.280 --> 01:03:19.760
Yeah.

01:03:19.760 --> 01:03:20.100
Very good.

01:03:20.100 --> 01:03:20.520
All right.

01:03:20.520 --> 01:03:21.440
Well, final call to action.

01:03:21.440 --> 01:03:25.480
People have a bunch of SQLAlchemy code that they've written, but it's probably for the

01:03:25.480 --> 01:03:26.000
older style.

01:03:26.000 --> 01:03:27.660
It's probably not async and so on.

01:03:27.660 --> 01:03:28.600
What do you tell them?

01:03:28.600 --> 01:03:28.900
Yeah.

01:03:29.340 --> 01:03:32.960
We have a brand new tutorial on the current website.

01:03:32.960 --> 01:03:34.680
If you go to just docs.seqlalchemy.org.

01:03:34.760 --> 01:03:40.980
On the left side, it'll have this 1.4 slash 2.0 tutorial that kind of represents SQLAlchemy

01:03:40.980 --> 01:03:44.420
all over again using all the newest concepts.

01:03:44.420 --> 01:03:48.720
I would look at that and just get to know it and also point out problems.

01:03:48.720 --> 01:03:49.660
Yeah.

01:03:49.660 --> 01:03:50.560
This is a new tutorial.

01:03:50.560 --> 01:03:52.540
So this supersedes the old tutorials.

01:03:52.640 --> 01:03:55.200
And it's going to talk about core and ORM at the same time.

01:03:55.200 --> 01:03:58.440
This is a complete brand new rewrite from the ground up.

01:03:58.440 --> 01:03:59.820
It took many weeks to do it.

01:03:59.820 --> 01:04:01.620
And then there's also the migration guide.

01:04:01.620 --> 01:04:05.080
But if you go through this tutorial, you'll really see what the new way of working is supposed

01:04:05.080 --> 01:04:08.040
to look like and what the idea is what's supposed to be.

01:04:08.040 --> 01:04:12.000
If you look at the, if you read the tutorial and assume you don't have any SQLAlchemy code,

01:04:12.000 --> 01:04:14.360
assume you're just learning it from scratch, see what it's like.

01:04:14.360 --> 01:04:15.520
See, wow, wow, this is different.

01:04:15.520 --> 01:04:18.200
Or you might see, oh, I never knew that was like that.

01:04:18.200 --> 01:04:24.300
Because it really tries to represent the library from the first principles, so to speak,

01:04:24.300 --> 01:04:26.900
up to ORM stuff.

01:04:26.900 --> 01:04:27.240
All right.

01:04:27.240 --> 01:04:29.500
Well, I'm excited about all these new features.

01:04:29.500 --> 01:04:32.620
Even the embracing of context managers everywhere.

01:04:32.620 --> 01:04:33.660
It looks great to me.

01:04:33.660 --> 01:04:35.120
So yeah, thanks for being here.

01:04:35.120 --> 01:04:36.500
And thanks for sharing this with everyone.

01:04:36.500 --> 01:04:37.300
Yeah, my pleasure.

01:04:37.300 --> 01:04:37.600
Bye.

01:04:37.600 --> 01:04:41.780
This has been another episode of Talk Python To Me.

01:04:41.780 --> 01:04:43.600
Thank you to our sponsors.

01:04:43.600 --> 01:04:45.200
Be sure to check out what they're offering.

01:04:45.200 --> 01:04:46.620
It really helps support the show.

01:04:47.160 --> 01:04:51.300
With TopTal, you get quality talent without the whole hiring process.

01:04:51.300 --> 01:04:55.080
Start 80% closer to success by working with TopTal.

01:04:55.080 --> 01:04:59.620
Just visit talkpython.fm/toptal to get started.

01:04:59.620 --> 01:05:02.640
Do you need a great automatic speech-to-text API?

01:05:02.640 --> 01:05:05.160
Get human-level accuracy in just a few lines of code.

01:05:05.160 --> 01:05:07.900
Visit talkpython.fm/assemblyai.

01:05:07.900 --> 01:05:09.800
Want to level up your Python?

01:05:09.800 --> 01:05:13.860
We have one of the largest catalogs of Python video courses over at Talk Python.

01:05:13.860 --> 01:05:19.020
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:05:19.020 --> 01:05:21.700
And best of all, there's not a subscription in sight.

01:05:21.700 --> 01:05:24.600
Check it out for yourself at training.talkpython.fm.

01:05:24.600 --> 01:05:26.500
Be sure to subscribe to the show.

01:05:26.500 --> 01:05:29.280
Open your favorite podcast app and search for Python.

01:05:29.280 --> 01:05:30.580
We should be right at the top.

01:05:31.040 --> 01:05:36.380
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the

01:05:36.380 --> 01:05:39.960
direct RSS feed at /rss on talkpython.fm.

01:05:39.960 --> 01:05:43.380
We're live streaming most of our recordings these days.

01:05:43.380 --> 01:05:47.500
If you want to be part of the show and have your comments featured on the air, be sure to

01:05:47.500 --> 01:05:51.160
subscribe to our YouTube channel at talkpython.fm/youtube.

01:05:51.720 --> 01:05:53.060
This is your host, Michael Kennedy.

01:05:53.060 --> 01:05:54.360
Thanks so much for listening.

01:05:54.360 --> 01:05:55.520
I really appreciate it.

01:05:55.520 --> 01:05:57.420
Now get out there and write some Python code.

01:05:57.420 --> 01:05:58.420
Bye.

01:05:58.420 --> 01:05:59.420
Bye.

01:05:59.420 --> 01:06:00.420
Bye.

01:06:00.420 --> 01:06:01.420
Bye.

01:06:01.420 --> 01:06:02.420
Bye.

01:06:02.420 --> 01:06:03.420
Bye.

01:06:03.420 --> 01:06:04.420
Bye.

01:06:04.420 --> 01:06:05.420
Bye.

01:06:05.420 --> 01:06:06.420
Bye.

01:06:06.420 --> 01:06:07.420
Bye.

01:06:07.420 --> 01:06:08.420
Bye.

01:06:08.420 --> 01:06:09.420
Bye.

01:06:09.420 --> 01:06:10.420
Bye.

01:06:10.420 --> 01:06:11.420
Bye.

01:06:11.420 --> 01:06:12.420
Bye.

01:06:12.420 --> 01:06:13.420
Bye.

01:06:13.420 --> 01:06:14.420
Bye.

01:06:14.420 --> 01:06:14.920
you

01:06:14.920 --> 01:06:15.420
you

01:06:15.420 --> 01:06:17.420
Thank you.

01:06:17.420 --> 01:06:47.400
Thank you.

