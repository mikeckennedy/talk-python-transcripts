WEBVTT

00:00:00.001 --> 00:00:02.900
What advice would you give someone just getting into Python?

00:00:02.900 --> 00:00:07.780
What did you learn over time through hard work and a few tears that would have really helped you?

00:00:07.780 --> 00:00:12.340
It's a fun game to play, and we have Jason McDonald on the podcast to give us his take.

00:00:12.340 --> 00:00:17.800
This is Talk Python to Me, episode 411, recorded March 2nd, 2023.

00:00:17.800 --> 00:00:34.260
Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:34.260 --> 00:00:36.000
This is your host, Michael Kennedy.

00:00:36.000 --> 00:00:43.480
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython, both on fosstodon.org.

00:00:43.480 --> 00:00:46.100
Be careful with impersonating accounts on other instances.

00:00:46.100 --> 00:00:47.060
There are many.

00:00:47.520 --> 00:00:52.120
Keep up with the show and listen to over seven years of past episodes at talkpython.fm.

00:00:52.120 --> 00:00:56.160
We've started streaming most of our episodes live on YouTube.

00:00:56.160 --> 00:01:03.660
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.

00:01:03.660 --> 00:01:08.820
This episode is brought to you by Sentry and us over at Talk Python Training.

00:01:08.820 --> 00:01:11.580
Please check out what we're both offering during our segments.

00:01:11.580 --> 00:01:13.500
It really helps support the show.

00:01:13.500 --> 00:01:16.080
Jason, welcome to Talk Python to Me.

00:01:16.080 --> 00:01:17.140
Thank you for having me.

00:01:17.240 --> 00:01:19.540
Yeah, it's great to have you here on the show.

00:01:19.540 --> 00:01:25.620
I'm looking forward to talking about a bunch of things I wish people taught you about Python sooner.

00:01:25.620 --> 00:01:29.300
I think there are many, many things that fall into that category.

00:01:29.300 --> 00:01:37.080
And part of that, I guess it's true with all languages, but I think it's maybe a little extra true in Python because getting started is so easy.

00:01:37.080 --> 00:01:44.540
But getting really good at it takes a lifetime sort of thing, you know, and so there's like this big mismatch of how accessible it feels.

00:01:44.540 --> 00:01:47.020
But then what you can get out of it if you go further.

00:01:47.020 --> 00:01:47.260
Right.

00:01:47.260 --> 00:01:49.780
So I think that we'll touch on that going further part, maybe.

00:01:49.780 --> 00:01:50.260
Absolutely.

00:01:50.560 --> 00:01:51.220
Yeah, for sure.

00:01:51.220 --> 00:01:55.200
Now, before we get into all those things, let's start with your story.

00:01:55.200 --> 00:01:56.440
How did you get into programming in Python?

00:01:56.440 --> 00:02:00.120
Well, I got into programming by a route that I don't recommend to anybody.

00:02:00.660 --> 00:02:05.560
I fell down a staircase, hit my head on the banister and ended all hopes of ever becoming a doctor.

00:02:05.560 --> 00:02:13.580
Oh, so went from 4.0 straight A student, college level reading in high school to family pre-game material.

00:02:13.580 --> 00:02:19.240
Two extra years to climb back up where I was academically a bit longer after that for other things.

00:02:19.660 --> 00:02:28.260
But somewhere along the way, I discovered that I had a natural inclination towards an attack for coding and got into that because I wanted to make games.

00:02:28.260 --> 00:02:29.580
I wanted to make educational games.

00:02:29.580 --> 00:02:30.740
They had been part of my recovery.

00:02:30.740 --> 00:02:31.980
So I'm like, I want to make games.

00:02:31.980 --> 00:02:33.500
So I learned how to code.

00:02:33.500 --> 00:02:41.820
And so I taught myself BB.net and then felt very constrained by the .NET ecosystem and broke out into Python.

00:02:41.820 --> 00:02:46.980
Found my home, stayed put until I wound up going into a bunch of other languages.

00:02:46.980 --> 00:02:49.400
I used Flash for quite some time.

00:02:49.520 --> 00:02:50.280
I used C++.

00:02:50.280 --> 00:02:55.200
I'm not coming out in whatever, Sandy, but Python is definitely near to dear to my heart.

00:02:55.200 --> 00:02:55.900
Yeah, absolutely.

00:02:55.900 --> 00:03:00.360
Well, if you started out in BB.net, I think it's a little less true these days.

00:03:00.360 --> 00:03:05.260
But in the earlier days, that was a really different ecosystem than Python, right?

00:03:05.260 --> 00:03:09.240
There was like, well, what is the framework for this thing that Microsoft recommends?

00:03:09.240 --> 00:03:10.380
Like, how do I do the web?

00:03:10.380 --> 00:03:12.400
I do ASP.net because that's what they provide me.

00:03:12.400 --> 00:03:13.160
How do I do database?

00:03:13.160 --> 00:03:15.080
I do this because that's what they provide me.

00:03:15.080 --> 00:03:18.420
And you come into Python, you're like, wait, there's a thousand different ways to do this.

00:03:18.480 --> 00:03:21.040
And I have to pick and decide and I can mix and match.

00:03:21.040 --> 00:03:23.000
And it's both amazing and like.

00:03:23.000 --> 00:03:23.620
Terrifying.

00:03:23.620 --> 00:03:24.680
Yeah, it's terrifying.

00:03:24.680 --> 00:03:26.500
Like, what do I make the wrong choice?

00:03:26.500 --> 00:03:27.960
I've how do I decide?

00:03:27.960 --> 00:03:29.260
I have no basis, right?

00:03:29.260 --> 00:03:29.980
I'm both new.

00:03:29.980 --> 00:03:31.360
So I have no basis for deciding.

00:03:31.600 --> 00:03:33.840
But I also, I've got to decide to get started.

00:03:33.840 --> 00:03:34.820
So where do we go, right?

00:03:34.820 --> 00:03:35.960
Like, it's a different world.

00:03:35.960 --> 00:03:43.380
It is where I first started running into trouble with the paradox that I wound up addressing in my book on back of that.

00:03:43.380 --> 00:03:50.360
But the paradox that a lot of people find themselves in is like, I know all this stuff, but I don't know enough to do this thing.

00:03:50.420 --> 00:03:56.040
And so you wind up with this weird little gap in a lot of training material because you have like the absolute basic elementary.

00:03:56.040 --> 00:03:58.680
And the examples there are almost insultingly simplistic.

00:03:58.940 --> 00:04:04.700
And it's like, oh, you just have to type this stuff into this file and you run the file and look at that.

00:04:04.700 --> 00:04:05.500
You have a hello world.

00:04:05.500 --> 00:04:06.260
Aren't you smart?

00:04:06.260 --> 00:04:09.960
And then you go all the way to the extreme and it's something like super complicated.

00:04:09.960 --> 00:04:10.860
You don't understand any of it.

00:04:10.860 --> 00:04:13.240
And nobody sat and wrote down.

00:04:13.240 --> 00:04:18.720
Here's how you structure your multi-Python project in a way that's going to, at least when I started, that wasn't documented anywhere.

00:04:18.720 --> 00:04:20.480
Like no one had ever written it down.

00:04:20.480 --> 00:04:22.140
So it's just like, what do I do now?

00:04:22.140 --> 00:04:23.200
Yeah, it's really tricky.

00:04:23.200 --> 00:04:28.800
A lot of the tutorials and stuff are like, you just put all the stuff into one file and then it's magic.

00:04:29.040 --> 00:04:30.500
But you should never, ever do that.

00:04:30.500 --> 00:04:36.500
Well, maybe in simple cases, but in realistic apps, like no realistic app belongs in one file.

00:04:36.500 --> 00:04:39.600
Just like you wouldn't have one function or just like no functions, right?

00:04:39.600 --> 00:04:40.700
You're like, not really.

00:04:40.700 --> 00:04:41.740
That's not how you do it.

00:04:41.740 --> 00:04:50.700
But so there is this, even when you're sort of hunting through tutorials, there is this mismatch of the simple way to show it, the simplest way to show it.

00:04:50.700 --> 00:04:52.300
And then like maybe how you should.

00:04:52.300 --> 00:04:52.800
Yeah.

00:04:52.800 --> 00:04:53.920
Yeah, exactly.

00:04:53.920 --> 00:04:58.760
It's the example I've given is that there's two types of book slash article slash tutorial.

00:04:58.760 --> 00:04:59.340
out there.

00:04:59.340 --> 00:05:01.760
There's here's basics of variables, voice and curls.

00:05:01.760 --> 00:05:11.600
And then the next level after that is here's how to program a natural language recognition, OCR, AI, machine learning on a Raspberry Pi, your grandmother's base or running on a potato battery.

00:05:11.600 --> 00:05:13.240
And there's nothing in between.

00:05:13.240 --> 00:05:14.220
Yeah.

00:05:14.220 --> 00:05:16.840
Yeah, that's true.

00:05:16.840 --> 00:05:18.100
It does make it quite challenging.

00:05:18.100 --> 00:05:18.760
All right.

00:05:18.760 --> 00:05:19.280
How about now?

00:05:19.280 --> 00:05:19.760
What are you up to?

00:05:20.180 --> 00:05:20.900
These days?

00:05:20.900 --> 00:05:21.740
Oh, gosh.

00:05:21.740 --> 00:05:28.720
I'm actually kind of veering these days more into actually more into kind of the facilitation business analyst side of things more.

00:05:28.720 --> 00:05:32.460
Interestingly, the last last couple of years, that's become a point of particular interest.

00:05:32.460 --> 00:05:39.320
But, you know, in terms of coding, I'm working on I'm working on some interesting projects that, you know, at work building, you know, an API for an internal project.

00:05:39.560 --> 00:05:45.260
And that's been that's been fun getting to get my hands dirty with FastAPI and SQLAlchemy.

00:05:45.260 --> 00:05:47.840
And that's been that's been fairly enjoyable.

00:05:47.840 --> 00:05:50.880
So that's been the majority of my programming bandwidth lately.

00:05:50.880 --> 00:05:51.740
But it's fun.

00:05:51.740 --> 00:05:55.920
It's it's the sort of project you hope you're going to get at work because it's an interesting topic.

00:05:55.920 --> 00:05:58.560
You have enough love leeway.

00:05:59.280 --> 00:06:05.440
That's where we have enough leeway to do things right and do things to some degree your way if you can justify it well enough.

00:06:05.440 --> 00:06:07.140
And, you know, other tech lead on it.

00:06:07.140 --> 00:06:14.080
So I'm able to make sure, like, you know, we're making good decisions early and paying down technical debt and building something that's really, really cool.

00:06:14.080 --> 00:06:15.640
So it's it's a fun project.

00:06:15.640 --> 00:06:16.300
I'm enjoying it.

00:06:16.300 --> 00:06:16.440
Yeah.

00:06:16.440 --> 00:06:20.080
Those kind of projects, they're they're fun, but they're also important.

00:06:20.080 --> 00:06:20.620
Right.

00:06:20.620 --> 00:06:31.800
Like if your work, if you work, if you work at a place where they say, you know, you need to use 10 year old technology and there's no opportunity to try new things like FastAPI and other others.

00:06:31.800 --> 00:06:39.500
What you end up with is a whole bunch of people who that work there who don't want to learn any new technologies and don't are not deeply passionate about programming.

00:06:39.500 --> 00:06:42.240
And it's kind of the self-fulfilling prophecy.

00:06:42.240 --> 00:06:45.380
And I think it's cool that the place you're working at allows that.

00:06:45.380 --> 00:06:45.560
Right.

00:06:45.580 --> 00:06:54.580
Because I think it's it's one of the signs of a healthy tech, not necessarily a startup or whatever, but all these companies have like small software teams within it.

00:06:54.580 --> 00:06:58.400
It's a sign of a healthy small software team, even if it's just building internal software.

00:06:58.400 --> 00:06:59.120
Oh, definitely.

00:06:59.120 --> 00:06:59.520
Yeah.

00:06:59.520 --> 00:07:01.400
And, you know, and there's a place for older technologies.

00:07:01.400 --> 00:07:04.480
Well, it's good to be well-versed in both and be able to move between it.

00:07:04.480 --> 00:07:13.560
But I mean, yeah, if you're if you're just stuck in the past, then you either, like you said, get a lot of people that are afraid of change or are really wanting that change.

00:07:13.660 --> 00:07:15.360
They're dissatisfied with the fact that you can't get it.

00:07:15.360 --> 00:07:20.900
But on the other hand, if you just if you're only new technology, you'll just spontaneously combust because you can't.

00:07:20.900 --> 00:07:28.980
You know, there's just there's so much constant invention and reinvention and research and unexpected bugs and blockers and whatever.

00:07:28.980 --> 00:07:33.920
It's like sometimes the nice thing about a 10 year old library is that there's less bugs because it's years old.

00:07:33.920 --> 00:07:36.960
Or you can find documentation about issues or whatever.

00:07:36.960 --> 00:07:38.720
You know, they have a term.

00:07:38.720 --> 00:07:46.860
It's like a term in the software industry about this constant churn that's like going too quick and especially not appreciating stuff that's been around.

00:07:46.860 --> 00:07:47.480
It's called JavaScript.

00:07:47.480 --> 00:07:51.040
You're not wrong.

00:07:51.040 --> 00:07:53.680
JavaScript is the embodiment of shiny object syndrome.

00:07:53.680 --> 00:07:54.460
It is.

00:07:54.540 --> 00:08:00.840
I mean, I'm not bashing on JavaScript per se, but the life cycle of some of these frameworks is just so brief.

00:08:00.840 --> 00:08:01.780
You know, it's nuts.

00:08:01.780 --> 00:08:04.680
Everybody wanted to use Dino for about 10 minutes.

00:08:04.680 --> 00:08:05.540
I remember that.

00:08:05.540 --> 00:08:07.880
There was a thousand articles a minute on Dino.

00:08:07.880 --> 00:08:10.660
And now it's now we've moved on to other things.

00:08:10.660 --> 00:08:17.020
And it's funny because you get a new technology like, OK, the topic of the minute, ChatGPT.

00:08:17.020 --> 00:08:19.260
And everybody on LinkedIn is an expert in ChatGPT.

00:08:19.260 --> 00:08:20.280
You know, have you noticed that?

00:08:20.280 --> 00:08:22.000
Every other post is about ChatGPT.

00:08:22.000 --> 00:08:26.040
And it's like, well, it's interesting, but it's just a bit early.

00:08:26.040 --> 00:08:28.240
And the early adopters have a lot of egg.

00:08:28.240 --> 00:08:30.820
They're still trying to wash off their face in the last six fans.

00:08:30.820 --> 00:08:33.420
So it's like, let's see what happens.

00:08:33.420 --> 00:08:36.040
But chances are, this is just an early hiccup.

00:08:36.040 --> 00:08:37.040
Yeah, for sure.

00:08:37.040 --> 00:08:39.880
So you mentioned FastAPI and SQLAlchemy.

00:08:39.880 --> 00:08:42.840
And Yasser out there says SQLAlchemy is the best library.

00:08:42.840 --> 00:08:44.340
SQLAlchemy is pretty great.

00:08:44.340 --> 00:08:50.020
And it's cool to see Mike Bayer and crew updated to 2.0 and add async and await to it and stuff.

00:08:50.020 --> 00:08:55.540
But there's also, especially when you're in Pydantic world, say with FastAPI,

00:08:55.540 --> 00:09:01.380
there's a SQL model also from Sebastian Ramirez that says,

00:09:01.380 --> 00:09:05.840
hey, we are already doing Pydantic for the API or front-end exchange.

00:09:06.020 --> 00:09:07.980
Like, what about making that your database?

00:09:07.980 --> 00:09:10.500
Did you all evaluate or consider a SQL model?

00:09:10.500 --> 00:09:11.120
I did.

00:09:11.120 --> 00:09:13.440
It's one of those things like, this would be great.

00:09:13.440 --> 00:09:15.560
And I think we can move towards that later.

00:09:15.560 --> 00:09:19.840
But sometimes when you're paying down technical debt, you have to make a distinction between,

00:09:19.840 --> 00:09:24.580
do I want to make the monthly payment as it were more than a monthly payment?

00:09:24.580 --> 00:09:27.400
Or do I want to try and pay it all off in one thing?

00:09:27.660 --> 00:09:38.320
And sometimes when you're having to budget that time, you know, for us, it made the most sense to migrate from the 1.0 that we were working with earlier on to using, you know, SQLAlchemy 2.

00:09:38.320 --> 00:09:41.900
And so there was a relatively smaller set of changes that we needed to make.

00:09:41.900 --> 00:09:42.100
I see.

00:09:42.100 --> 00:09:49.780
Moving to something like a SQL model would be great, but it would also require us to rewrite some major things.

00:09:49.780 --> 00:09:53.220
And so that's one of those things is like, well, this might be a good option.

00:09:53.220 --> 00:09:58.180
I mean, it looks really cool, but let's defer that for right now so that we can actually get some stuff done.

00:09:58.240 --> 00:09:59.580
It's a constant balancing act.

00:09:59.580 --> 00:10:02.000
Like, do we pay down technical debt or build new features?

00:10:02.000 --> 00:10:02.960
And the answer is yes.

00:10:02.960 --> 00:10:06.620
You have to do both, but you have to keep it in balance.

00:10:06.620 --> 00:10:09.180
Pay down the credit card, but also make sure you're buying your groceries, you know?

00:10:09.180 --> 00:10:10.420
Yeah, absolutely.

00:10:10.420 --> 00:10:14.080
I feel like if you wanted to go that way, the change is pretty straightforward.

00:10:14.080 --> 00:10:18.460
But if you already have it all set up in the other way, again, it's like, eh, what is the value?

00:10:18.460 --> 00:10:27.960
Just one thing that kind of timely as of a couple days ago, let's see, as of two days ago, the Pydantic folks, Samuel Colvin and Terrence Dorsey,

00:10:27.960 --> 00:10:32.980
posted, hey, we're excited to announce the first alpha of Pydantic v2.

00:10:32.980 --> 00:10:36.460
And I had Samuel on like a year ago to talk about what they were doing there.

00:10:36.460 --> 00:10:36.880
Wow.

00:10:36.880 --> 00:10:44.780
But the big news is, the headline news in here is, they rewrote much of the core of Pydantic in Rust.

00:10:44.780 --> 00:10:48.700
And now Pydantic version 2 is 5 to 50 times faster.

00:10:48.700 --> 00:10:49.700
Nice.

00:10:49.700 --> 00:10:50.640
That's cool, right?

00:10:50.640 --> 00:10:51.780
That's gorgeous.

00:10:51.780 --> 00:10:52.660
Thank you.

00:10:52.660 --> 00:10:54.300
This has just put more work on my plate.

00:10:54.300 --> 00:10:54.920
That's okay.

00:10:54.920 --> 00:10:57.560
This will be good.

00:10:57.700 --> 00:10:58.840
I'll have to bring this up at work.

00:10:58.840 --> 00:11:00.300
It's like, hey, we should look at this later.

00:11:00.300 --> 00:11:00.700
Yeah.

00:11:00.700 --> 00:11:06.720
I mean, I don't think that there's any, I don't think anything will, obviously nothing will change for your SQLAlchemy side.

00:11:06.720 --> 00:11:10.400
But even for FastAPI, I'm sure that this is going to get rolled in in a smooth way.

00:11:10.400 --> 00:11:21.460
But it does mean that all that data exchange should just go way, way faster, which for basically no effort on users of things like FastAPI and SQL Model and Beanie and all those.

00:11:21.460 --> 00:11:22.460
So that's cool news.

00:11:22.460 --> 00:11:23.280
Yeah, definitely.

00:11:23.280 --> 00:11:24.240
That is neat.

00:11:24.300 --> 00:11:30.460
Other than the fact that if you do a lot of work directly in Pydantic models, there might be a few small breaking changes.

00:11:30.460 --> 00:11:33.420
But let's talk about our things.

00:11:33.420 --> 00:11:36.560
The things we wish someone had explained to us sooner.

00:11:36.560 --> 00:11:37.060
Yes.

00:11:37.060 --> 00:11:38.860
And I guess we can start with this.

00:11:38.860 --> 00:11:40.380
Like these things were motivated.

00:11:40.380 --> 00:11:42.400
We'll come back and talk a bit more about this at the end.

00:11:42.400 --> 00:11:43.200
But they were motivated.

00:11:43.200 --> 00:11:44.820
This whole conversation was motivated.

00:11:44.820 --> 00:11:48.240
This big, long book that you wrote here, Dead Simple Python.

00:11:48.480 --> 00:11:50.380
Give people the elevator pitch and then we'll get to all things.

00:11:50.380 --> 00:11:50.780
Yeah, exactly.

00:11:50.780 --> 00:11:53.180
So Dead Simple Python is the book I wish I had.

00:11:53.180 --> 00:11:55.960
And yeah, it's, I get teased a lot.

00:11:55.960 --> 00:11:57.580
It's like dead simple and it's that thick.

00:11:57.580 --> 00:12:01.880
But it's dead simple in the same way that Python is obvious.

00:12:01.880 --> 00:12:03.640
It's obvious retrospective.

00:12:03.640 --> 00:12:04.780
Things are dead simple.

00:12:04.780 --> 00:12:07.240
Once you understand it, you look back and go, oh, okay.

00:12:07.240 --> 00:12:07.720
That clicked.

00:12:07.720 --> 00:12:08.580
That just makes sense.

00:12:08.580 --> 00:12:10.320
A lot of things in Python are like that.

00:12:10.320 --> 00:12:10.960
You look into it.

00:12:10.960 --> 00:12:12.320
It's like, that looks really complicated.

00:12:12.320 --> 00:12:14.680
How is this ASIC supposed to work?

00:12:14.680 --> 00:12:16.660
And then you look back and go, oh, that's all?

00:12:16.660 --> 00:12:17.080
Okay.

00:12:17.080 --> 00:12:17.900
No, that's.

00:12:17.900 --> 00:12:18.260
Yeah, yeah, exactly.

00:12:18.260 --> 00:12:19.380
Why was I afraid?

00:12:19.380 --> 00:12:21.980
Why did I put learning, put off learning this for six months?

00:12:21.980 --> 00:12:22.620
Exactly.

00:12:22.620 --> 00:12:28.080
It's, you know, things look more intimidating than they are in practice.

00:12:28.080 --> 00:12:34.880
But basically this is the book for those persons who already know another programming language,

00:12:34.880 --> 00:12:37.620
or maybe they've even been working with Python for a while.

00:12:37.620 --> 00:12:39.160
Like they're familiar with the basics.

00:12:39.160 --> 00:12:44.820
They do not want to have their hand held through the, you know, this is what a variable is.

00:12:44.820 --> 00:12:45.900
And this is what a function is.

00:12:45.900 --> 00:12:50.120
They've been through this probably more times than they want to admit to.

00:12:50.120 --> 00:12:56.160
And they want to get into what's different about Python and how to use Python as Python.

00:12:56.160 --> 00:13:00.560
I think that's kind of the core of the book is there's a big difference between Python code

00:13:00.560 --> 00:13:06.680
that works and Python code that makes the most of the language and its patterns, what we would

00:13:06.680 --> 00:13:08.140
refer to as Pythonic code.

00:13:08.140 --> 00:13:12.840
And there's a big difference between the two because it's very tempting to come in and write Python as

00:13:12.840 --> 00:13:19.040
BB dot that in my case, because that's where I started or write Python as C or write Python as Java or write Python as Ruby.

00:13:19.040 --> 00:13:25.700
And we wind up holding ourselves back and having really convoluted and hard to maintain code because we don't understand the patterns.

00:13:25.860 --> 00:13:30.160
So the approach I took with the book is let me explain why we do things this way.

00:13:30.160 --> 00:13:36.960
Let's go all the way down into the internals and how this actually works under the hood.

00:13:37.060 --> 00:13:46.780
So by the time you get to the forward with statements, you know, the meta class or whatever, you're like, oh, I understand what this is, why it's there, how it's used and when not to use it.

00:13:46.780 --> 00:13:48.540
Yeah, that's a great service.

00:13:48.700 --> 00:13:58.600
So you're saying if I created a class called like user factory and it implemented I user factory and then I would use dependency injection.

00:13:58.600 --> 00:13:59.520
I might be doing that wrong.

00:13:59.800 --> 00:14:01.520
You might be writing C# and Python.

00:14:01.520 --> 00:14:03.020
Yeah, indeed.

00:14:03.020 --> 00:14:03.800
Yeah, indeed.

00:14:03.800 --> 00:14:08.800
This portion of Talk Python to Me is brought to you by Sentry.

00:14:08.800 --> 00:14:15.520
Is your Python application fast or does it sometimes suffer from slowdowns and unexpected latency?

00:14:15.520 --> 00:14:18.120
Does this usually only happen in production?

00:14:18.120 --> 00:14:21.320
It's really tough to track down the problems at that point, isn't it?

00:14:21.320 --> 00:14:28.160
If you've looked at APM application performance monitoring products before, they may have felt out of place for software teams.

00:14:28.420 --> 00:14:36.060
Many of them are more focused on legacy problems made for ops and infrastructure teams to keep their infrastructure and services up and running.

00:14:36.060 --> 00:14:40.220
Sentry has just launched their new APM service.

00:14:40.220 --> 00:14:47.160
And Sentry's approach to application monitoring is focused on being actionable, affordable and actually built for developers.

00:14:47.160 --> 00:14:53.100
Whether it's a slow running query or latent payment endpoint that's at risk of timing out and causing sales to tank,

00:14:53.100 --> 00:14:57.040
Sentry removes the complexity and does the analysis for you,

00:14:57.500 --> 00:15:00.980
surfacing the most critical performance issues so you can address them immediately.

00:15:00.980 --> 00:15:08.420
Most legacy APM tools focus on an ingest everything approach, resulting in high storage costs, noisy environments,

00:15:08.420 --> 00:15:13.340
and an enormous amount of telemetry data most developers will never need to analyze.

00:15:13.340 --> 00:15:18.580
Sentry has taken a different approach, building the most affordable APM solution in the market.

00:15:19.260 --> 00:15:25.360
They've removed the noise and extract the maximum value out of your performance data while passing the savings directly onto you,

00:15:25.360 --> 00:15:29.180
especially for Talk Python listeners who use the code Talk Python.

00:15:29.180 --> 00:15:36.840
So get started at talkpython.fm/sentry and be sure to use their code Talk Python all lowercase

00:15:36.840 --> 00:15:39.360
so you let them know that you heard about them from us.

00:15:39.900 --> 00:15:43.780
My thanks to Sentry for keeping this podcast going strong.

00:15:45.540 --> 00:15:47.860
So I like the idea of it.

00:15:47.860 --> 00:15:48.740
Let's talk.

00:15:48.740 --> 00:15:50.800
Let's go through the topics.

00:15:50.800 --> 00:15:52.280
We both contributed a little bit.

00:15:52.280 --> 00:15:54.460
Mostly, I'll throw in a few if we got extra time.

00:15:54.460 --> 00:15:55.040
Yeah, yeah.

00:15:55.060 --> 00:16:01.080
So the first one has to do with this, I guess, like really early stage writing code, like how do I create variables?

00:16:01.080 --> 00:16:05.000
What are the deals with types and variables, but also types and objects?

00:16:05.000 --> 00:16:05.960
Tell us about that.

00:16:05.960 --> 00:16:06.920
Yeah, exactly.

00:16:06.920 --> 00:16:08.500
How names and values actually work.

00:16:08.500 --> 00:16:13.280
And this is something that I had to learn early, but I didn't fully understand.

00:16:13.280 --> 00:16:23.940
So when I first logged into the Python IRC room back when I learned this language, you know, back in the Cretaceous period, I logged in and I, you know, I'm coming from a strongly typed background.

00:16:23.940 --> 00:16:27.120
So I'm saying, okay, so how do I declare a data type on a variable?

00:16:27.120 --> 00:16:28.440
Because I'm used to VB.

00:16:28.440 --> 00:16:31.740
I'm like, yeah, dim in the name of the variable, the type equals whatever.

00:16:31.740 --> 00:16:32.960
How do I declare a type?

00:16:32.960 --> 00:16:34.320
It was before type hints existed.

00:16:34.320 --> 00:16:37.160
And one of the guys in the room goes, you're a data type.

00:16:37.160 --> 00:16:38.560
And I'm like, sorry, what?

00:16:38.800 --> 00:16:44.600
And he goes on to explain, well, it doesn't quite work this way in Python, but I didn't realize just how different it was.

00:16:44.600 --> 00:16:48.680
So because I just sort of had this vague, like, oh, you just have the name equals the value.

00:16:48.680 --> 00:16:49.100
Cool.

00:16:49.100 --> 00:16:50.880
Type still seems kind of important.

00:16:50.880 --> 00:16:52.700
Maybe I should start doing Hungarian notation.

00:16:52.700 --> 00:16:53.640
Don't do that.

00:16:53.640 --> 00:16:54.220
By the way.

00:16:54.220 --> 00:16:56.580
S Z username.

00:16:56.580 --> 00:16:57.140
No.

00:16:57.140 --> 00:16:58.000
Exactly.

00:16:58.000 --> 00:16:59.260
Exactly.

00:16:59.260 --> 00:17:00.880
Int age or whatever.

00:17:00.880 --> 00:17:01.300
Yeah.

00:17:01.300 --> 00:17:03.620
And I thought I was being super clever and I wasn't.

00:17:03.620 --> 00:17:07.280
But eventually someone explained to me, I think it was actually Ned Batchelder.

00:17:07.280 --> 00:17:08.580
Someone gave me the link to Ned Batchel.

00:17:08.580 --> 00:17:14.680
And Batchelder's talk on this is that Python's variables work very differently than other languages.

00:17:14.680 --> 00:17:18.360
So much so that some smart elics like to say, well, Python doesn't really have variables.

00:17:18.360 --> 00:17:19.180
Yes, it does.

00:17:19.180 --> 00:17:21.120
But they're variables in a different sense.

00:17:21.120 --> 00:17:25.680
You have names, which are just like they're like labels and you can call it whatever you want.

00:17:25.680 --> 00:17:27.600
But a name has a scope.

00:17:27.600 --> 00:17:32.220
You know, so the name exists in the context of your whole program or in the context of your function or whatever.

00:17:32.220 --> 00:17:34.160
And a name can be bound to whatever you want.

00:17:34.500 --> 00:17:41.060
Imagine drawing, you know, basically having this label on a corkboard, thing like a conspiracy theorist corkboard.

00:17:41.060 --> 00:17:48.080
You know, you have the tack in a label and you put a little string around it and you tie that string to this other thing over here.

00:17:48.080 --> 00:17:49.480
And that's your value.

00:17:49.480 --> 00:17:50.860
Your value has a tie.

00:17:50.860 --> 00:17:51.660
It has.

00:17:51.660 --> 00:17:53.460
It is one thing.

00:17:53.460 --> 00:17:56.740
It's a Boolean or it is an integer or it is a string or it is a list.

00:17:56.740 --> 00:17:57.740
We've all seen the error.

00:17:57.740 --> 00:18:01.380
You cannot combine integer and string with plus operation.

00:18:01.380 --> 00:18:02.800
Like they know what they are, right?

00:18:02.800 --> 00:18:03.260
Exactly.

00:18:03.260 --> 00:18:04.760
Those values know what they are.

00:18:04.760 --> 00:18:08.140
And that's something that throws people off coming from JavaScript where everything's weakly typed.

00:18:08.140 --> 00:18:09.520
It'll just try to coerce them together.

00:18:09.520 --> 00:18:11.480
Python says, hey, these two values are different.

00:18:11.480 --> 00:18:12.900
I'm not going to try to figure this out.

00:18:12.900 --> 00:18:14.580
That's because it's working with the values.

00:18:14.580 --> 00:18:17.340
The values have type, but the values don't have scope.

00:18:17.420 --> 00:18:25.160
And this is where people get thrown off because if you say, you know, let's say I'm going to use the example here.

00:18:25.160 --> 00:18:26.040
X equals spam.

00:18:26.040 --> 00:18:31.600
If you were to say Z equals X, you're binding Z to the same value as X.

00:18:31.600 --> 00:18:34.660
And then if you decide to change Z, that works.

00:18:34.660 --> 00:18:35.380
X is unchanged.

00:18:35.380 --> 00:18:36.120
Z is changed.

00:18:36.120 --> 00:18:37.420
You might think, oh, cool.

00:18:37.420 --> 00:18:37.720
Okay.

00:18:37.720 --> 00:18:39.380
This is just, it just made a copy.

00:18:39.380 --> 00:18:40.520
Not exactly.

00:18:40.520 --> 00:18:44.160
Because we have this whole thing about mutable and immutable types.

00:18:44.160 --> 00:18:46.120
Some things can't be changed.

00:18:46.280 --> 00:18:48.420
Boolean, an integer, a string, a tuple.

00:18:48.420 --> 00:18:49.700
They're not changed.

00:18:49.700 --> 00:18:51.740
The value is never modified in memory.

00:18:51.740 --> 00:18:53.900
A new thing is made instead.

00:18:53.900 --> 00:18:57.400
But then some, some, and by some, I mean most.

00:18:57.400 --> 00:18:58.540
Sorry about my clock.

00:18:58.540 --> 00:19:05.240
Most types in Python, like lists and dictionaries and the objects that you're creating with your fancy little classes are mutable.

00:19:05.240 --> 00:19:14.660
So if you create a list or a dictionary and you bind that to two different names, you modify, you add a value to that list.

00:19:14.780 --> 00:19:19.280
It doesn't matter which of the names you use, you're modifying the value in memory, in place.

00:19:19.280 --> 00:19:22.180
And now that is accessible from either of those names.

00:19:22.180 --> 00:19:22.460
Yeah.

00:19:22.460 --> 00:19:26.820
And that can be confusing, especially when you start to understand that functions don't pass by value.

00:19:26.820 --> 00:19:27.960
They don't pass by reference.

00:19:27.960 --> 00:19:31.900
They just bind the value to the name of that argument.

00:19:31.900 --> 00:19:34.360
Pass by assignment is what we usually call it.

00:19:34.420 --> 00:19:38.560
So you're just having one more handle, one more alias pointing to that value in memory.

00:19:38.560 --> 00:19:42.740
So if you change on that argument, you're just changing your spot number.

00:19:42.740 --> 00:19:49.620
Many languages have values that are like local and copied types of values.

00:19:49.620 --> 00:19:56.300
So you mentioned VB.net, which like the integer and float numbers and things like that.

00:19:56.300 --> 00:19:58.480
If you assign one, it's a copy of a thing.

00:19:58.480 --> 00:20:02.520
Whereas Python, literally everything is a pointer, right?

00:20:02.520 --> 00:20:07.060
This corkboard conspiracy theory thing, right?

00:20:07.060 --> 00:20:09.680
There's no concept of, oh, I created this on the stack.

00:20:09.680 --> 00:20:11.100
And when the function returns, it's gone.

00:20:11.320 --> 00:20:17.920
It's everything is a, you know, even like a, just an integer is a pi long star down in the runtime.

00:20:17.920 --> 00:20:18.380
Right.

00:20:18.380 --> 00:20:24.100
That's a bit of a mental thing people got to get used to just like how much, because when

00:20:24.100 --> 00:20:29.260
you come from a language like C++ or something, pointers and these reference type type of ideas

00:20:29.260 --> 00:20:31.120
are like right in your face, right?

00:20:31.120 --> 00:20:36.480
Like you see this, like I just said, pi long star, like the star means it points at things

00:20:36.480 --> 00:20:37.460
without the star.

00:20:37.460 --> 00:20:38.460
It's on the stack, right?

00:20:38.460 --> 00:20:40.960
It's a, you are way down in those details.

00:20:41.140 --> 00:20:43.760
Whereas in Python, you never see pointers.

00:20:43.760 --> 00:20:46.700
Like you could imagine, like there's no such, like we don't even have pointers in Python.

00:20:46.700 --> 00:20:47.100
Right.

00:20:47.100 --> 00:20:52.980
But the irony is like literally everything is basically managed in that on the heap reference

00:20:52.980 --> 00:20:54.540
type style of work.

00:20:54.540 --> 00:20:56.660
So that's certainly something I wish I knew.

00:20:56.660 --> 00:20:57.340
Yeah.

00:20:57.340 --> 00:21:01.220
And, and of course, then people come from C++ and say like, oh, cool, that's easy.

00:21:01.220 --> 00:21:02.060
So it's all pointers.

00:21:02.060 --> 00:21:07.740
Well, once again, Python being Python, not quite because it's actually technically called a

00:21:07.740 --> 00:21:08.720
reference, not a pointer.

00:21:08.720 --> 00:21:15.560
And that's important because a Python reference or a Python value has two things.

00:21:15.560 --> 00:21:19.020
It has, yes, it does have a pointer, at least we're talking about CPython, but it also has

00:21:19.020 --> 00:21:21.120
a reference counter, which is a self and integer.

00:21:21.120 --> 00:21:22.560
And that's adding overhead.

00:21:22.680 --> 00:21:28.080
So if you ever do actually go down and look at the sizes of things, you will notice that

00:21:28.080 --> 00:21:31.780
your base value has this additional overhead.

00:21:31.780 --> 00:21:32.200
Yeah.

00:21:32.980 --> 00:21:33.920
two numbers.

00:21:33.920 --> 00:21:38.280
One of them is your pointer and the other one is your, the other one is your, your reference

00:21:38.280 --> 00:21:40.940
counter because it has a reference counter garbage collection.

00:21:40.940 --> 00:21:41.220
Yeah.

00:21:41.220 --> 00:21:41.980
Often a lot more.

00:21:41.980 --> 00:21:48.580
I think trying to, I guess I could check, but either an integer or a single character.

00:21:48.580 --> 00:21:50.980
I can't remember which is 28 bytes.

00:21:50.980 --> 00:21:51.460
Right.

00:21:51.460 --> 00:21:56.560
And that's in C, the single character would be one or two bytes and the integer would be

00:21:56.560 --> 00:21:57.760
two, four or eight.

00:21:57.760 --> 00:21:58.160
Right.

00:21:58.160 --> 00:22:02.100
And so there's just a big difference in the way you got a sort of like the implications

00:22:02.100 --> 00:22:02.520
of that.

00:22:02.520 --> 00:22:07.780
So related to that, kind of moving on to the next, before we move on, the other thing that

00:22:07.780 --> 00:22:13.800
you mentioned, and I think it's also a really big deal in this area is the scope of a variable.

00:22:13.800 --> 00:22:19.980
And so in some languages, you have very fine grained control of the lifetime of a variable

00:22:19.980 --> 00:22:21.260
by where you declare it.

00:22:21.260 --> 00:22:29.000
So for example, if you declare a variable in a C++ or VB.net or whatever in a if block,

00:22:29.000 --> 00:22:31.260
when you leave the if block, the thing goes away.

00:22:31.260 --> 00:22:36.260
Like if there's curly braces around it in a lot of languages, like that is the lifetime of

00:22:36.260 --> 00:22:42.440
the variable innermost bracket of curly braces, like outside of a loop, the thing goes away

00:22:42.440 --> 00:22:43.140
in Python.

00:22:43.140 --> 00:22:44.000
We don't have that.

00:22:44.000 --> 00:22:48.820
And that's a, you know, kind of the variable persists and lives after afterwards.

00:22:48.820 --> 00:22:49.200
Right.

00:22:49.200 --> 00:22:50.440
Which is interesting.

00:22:50.440 --> 00:22:50.900
Yeah.

00:22:51.020 --> 00:22:51.420
difference.

00:22:51.420 --> 00:22:51.740
Yeah.

00:22:51.740 --> 00:22:55.580
Because the garbage collection is something you're never supposed to have to deal with.

00:22:55.580 --> 00:23:00.320
So even if you call delete on something, it's not necessarily guaranteed to be cleaned up.

00:23:00.320 --> 00:23:05.200
And when you expect it, like the language is going to handle things when it, when it sees

00:23:05.200 --> 00:23:06.480
fit for whatever reason.

00:23:06.480 --> 00:23:11.520
So yeah, there's only to my knowledge, there's only three, there's only actually three scopes

00:23:11.520 --> 00:23:12.160
in Python.

00:23:12.160 --> 00:23:13.540
There's global level.

00:23:13.540 --> 00:23:20.540
There's module level and there's, I don't even, that gets a little pedantic and then you

00:23:20.540 --> 00:23:23.580
have function level classes are not their own skull.

00:23:23.580 --> 00:23:28.080
Classes actually do not, a class exists in the global level.

00:23:28.080 --> 00:23:32.120
And whenever you have an attribute sitting on a class or sitting on an instance is actually

00:23:32.120 --> 00:23:34.700
in a dictionary, unless using slots.

00:23:34.700 --> 00:23:35.500
I'm not going into that.

00:23:35.500 --> 00:23:41.340
Actually sitting in a dictionary that is a part of that object in memory.

00:23:41.340 --> 00:23:41.580
Yep.

00:23:41.580 --> 00:23:43.340
It's special, but it works out.

00:23:43.340 --> 00:23:44.880
It's just something you got to kind of get used to.

00:23:45.000 --> 00:23:45.280
Definitely.

00:23:45.280 --> 00:23:45.820
All right.

00:23:45.820 --> 00:23:46.700
Next one.

00:23:46.700 --> 00:23:47.380
Ducks.

00:23:47.380 --> 00:23:47.800
Quank.

00:23:47.800 --> 00:23:49.300
Duck typing.

00:23:49.300 --> 00:23:49.680
Yeah.

00:23:49.680 --> 00:23:52.320
And, and it's, this is where I went.

00:23:52.320 --> 00:23:53.040
Oh, haywire.

00:23:53.040 --> 00:23:56.540
When I, when I was doing that, that Hungarian notation, I mentioned it.

00:23:56.540 --> 00:23:57.920
I'm thinking, I'm being so clever.

00:23:57.920 --> 00:24:01.720
I'm just putting the, the name of the, or the type in the name.

00:24:01.720 --> 00:24:02.360
And then I know it.

00:24:02.600 --> 00:24:05.520
But unfortunately you're coming from a stronger type language.

00:24:05.520 --> 00:24:10.680
You're actually, it's easy to underestimate just how much strong typing can actually hold

00:24:10.680 --> 00:24:14.740
us back in some cases, because we started thinking about what a thing is rather than

00:24:14.740 --> 00:24:15.280
what it can do.

00:24:15.280 --> 00:24:16.300
And we see this in Java.

00:24:16.300 --> 00:24:19.600
Like you have to have these complex inheritance patterns because you want to be able to say,

00:24:19.600 --> 00:24:23.340
well, this thing is, it is this matches this interface.

00:24:23.340 --> 00:24:25.440
You know, it, it does this particular thing.

00:24:25.440 --> 00:24:29.000
Python's take is I really don't care what it is.

00:24:29.180 --> 00:24:34.780
As long as I can interact with it, according to a particular kind of set of assumptions,

00:24:34.780 --> 00:24:37.660
then I don't care what it's really doing under God.

00:24:37.660 --> 00:24:41.940
And this can be really beneficial because it allows you to create new things that act like

00:24:41.940 --> 00:24:45.320
integers, even though they're not integers or new things that act like Booleans that aren't

00:24:45.320 --> 00:24:47.340
Booleans, new things that act like strings that aren't strings.

00:24:47.340 --> 00:24:48.360
Python doesn't care.

00:24:48.360 --> 00:24:57.180
It's just interfacing with those objects on the basis of how it can use them and what certain

00:24:57.180 --> 00:24:58.100
things are going to return.

00:24:58.240 --> 00:24:59.480
That's all it cares about.

00:24:59.480 --> 00:25:03.600
So the concept of the duck typing being, it doesn't care whether it's a duck or a picture

00:25:03.600 --> 00:25:05.740
of a duck or a statue of a duck or a moose in a duck suit.

00:25:05.740 --> 00:25:08.760
As long as it can interact with it in the way it needs, it's good.

00:25:08.760 --> 00:25:09.220
Yeah.

00:25:09.220 --> 00:25:10.180
And that's very free.

00:25:10.180 --> 00:25:12.380
And talks like a duck and quacks like a duck.

00:25:12.380 --> 00:25:13.560
And it's probably a duck.

00:25:13.560 --> 00:25:14.400
Yeah, exactly.

00:25:14.400 --> 00:25:18.160
And it's very freeing once you get that because you don't have to muck about with all this weird

00:25:18.160 --> 00:25:19.240
inheritance anymore.

00:25:19.240 --> 00:25:22.120
It's like, well, it, it does what I need.

00:25:22.120 --> 00:25:23.220
And that's the important part.

00:25:23.300 --> 00:25:27.320
There is certainly less inheritance and less complex hierarchies in Python.

00:25:27.320 --> 00:25:31.440
Not, not that there's not an important place for object-oriented programming and classes.

00:25:31.440 --> 00:25:33.460
They're just often simpler.

00:25:33.820 --> 00:25:35.220
A lot more straightforward, definitely.

00:25:35.220 --> 00:25:41.620
And it frees us up to then the saying I coined a couple of years ago during a conference talk was,

00:25:41.620 --> 00:25:44.680
was that you need to define objects by their constituent data.

00:25:44.680 --> 00:25:50.360
So when you're writing a class or you're designing an object, you're thinking about what is it storing?

00:25:50.360 --> 00:25:57.640
Like what, what sort of state, if you think in a functional way, or what sort of data am I really putting in here?

00:25:57.640 --> 00:26:01.200
And you can design based off of that.

00:26:01.200 --> 00:26:03.800
And then you can think about, well, how do I want it?

00:26:03.800 --> 00:26:07.460
How does the system need to interact with that data?

00:26:07.660 --> 00:26:11.740
But you don't really have to sit there and think about encapsulating behavior because that's not really the point.

00:26:11.740 --> 00:26:16.120
The point is you can think about, like with the example I use is, we always see the example of,

00:26:16.120 --> 00:26:19.960
I'm going to create a class called cat and a class called dog and they inherit from animal.

00:26:19.960 --> 00:26:26.140
And that's actually a really lousy example we need to stop using because that's starting from the concept of behavior.

00:26:26.140 --> 00:26:28.640
Well, it barks, it meows, it eats, whatever.

00:26:29.200 --> 00:26:35.780
And in real systems, what we think about is I have a, you know, someone designing a game.

00:26:35.780 --> 00:26:36.500
I have a monster.

00:26:36.500 --> 00:26:37.180
Okay.

00:26:37.180 --> 00:26:38.460
What is a monster?

00:26:38.460 --> 00:26:40.640
Well, it's, it's a bad guy.

00:26:40.640 --> 00:26:42.060
No, no, no, no, not what it does.

00:26:42.060 --> 00:26:42.940
What is it?

00:26:42.940 --> 00:26:49.720
Well, it's, that's a collection of statistics about the character, you know, like the, how, how much strength it has and how much health it has.

00:26:49.720 --> 00:26:50.320
Okay.

00:26:50.320 --> 00:26:52.220
That is not a monster.

00:26:52.220 --> 00:26:53.760
That's an, that's an entity.

00:26:53.760 --> 00:26:58.280
That's a, you know, that you don't have to put what it's doing into the, into that code.

00:26:58.280 --> 00:27:01.060
It is this collection of information.

00:27:01.060 --> 00:27:12.260
And when you start, when you shift your thinking to a data first mindset about object oriented, then you find that you can actually use it with functional paradigms that are sometimes a lot easier to reason about.

00:27:12.260 --> 00:27:12.580
Yeah.

00:27:12.580 --> 00:27:14.960
The, the grouping together of data is an important part.

00:27:14.960 --> 00:27:22.080
I would say the most extreme example of duck typing in Python, maybe a couple of areas.

00:27:22.080 --> 00:27:28.320
And they all seem to involve, revolve around the, the magic methods or the Python data types, like the Dunder methods.

00:27:28.320 --> 00:27:28.580
Right.

00:27:28.580 --> 00:27:29.040
I love those.

00:27:29.040 --> 00:27:29.420
I could.

00:27:29.420 --> 00:27:30.380
Yeah, I know.

00:27:30.380 --> 00:27:39.420
So I could have a function, which I could call, or I could have a class that implements Dunder call is a callable, but it's actually an instance of an object.

00:27:40.140 --> 00:27:40.540
Right.

00:27:40.540 --> 00:27:43.660
And, but as far as Python is concerned, it doesn't matter.

00:27:43.660 --> 00:27:46.560
It can call it and pass parameters to the thing it called.

00:27:46.560 --> 00:27:47.120
Right.

00:27:47.120 --> 00:27:50.420
And there's no real type that disambiguates those two things.

00:27:50.420 --> 00:27:51.500
Like one is a function type.

00:27:51.500 --> 00:27:54.680
One is a, you know, a class with a particular method on it.

00:27:54.680 --> 00:27:55.040
Right.

00:27:55.080 --> 00:27:56.640
But they work just fine.

00:27:56.640 --> 00:27:58.560
And that's a pretty extreme example.

00:27:58.560 --> 00:28:07.140
You know, another one would be, I have a list I can iterate, or I have something that implements the iterator pattern through the Dunder methods.

00:28:07.140 --> 00:28:07.420
Right.

00:28:07.420 --> 00:28:09.200
Like the Dunder iter and so on.

00:28:09.200 --> 00:28:09.580
Right.

00:28:09.580 --> 00:28:10.080
Well, yeah.

00:28:10.080 --> 00:28:15.460
One of the classes I, one of the examples of the book I gave was like a, a cafe queue.

00:28:15.460 --> 00:28:17.460
So a queue of customers in a line.

00:28:17.460 --> 00:28:22.340
And yeah, I wrote it as inevitable, but there was all this additional stuff in there.

00:28:22.340 --> 00:28:23.780
It wasn't just a basic list.

00:28:23.780 --> 00:28:25.000
There was more to it than that.

00:28:25.000 --> 00:28:28.880
And, but because I implemented as an iterable, I didn't care.

00:28:28.880 --> 00:28:30.520
I could use it like I could use a list.

00:28:30.520 --> 00:28:30.800
Yeah.

00:28:30.800 --> 00:28:41.220
But it was able to do this additional work with data behind the scenes that made it just easier to use the, to reason about this line of customers.

00:28:41.220 --> 00:28:46.640
And then you get generator methods with the yield keyword and yield from, and like all sorts of stuff.

00:28:46.640 --> 00:28:52.460
You, you get pie test fixtures that allow you to set up and tear down without actually writing.

00:28:53.280 --> 00:28:55.520
Try finally blocks and all these things.

00:28:55.520 --> 00:28:57.080
A lot, a lot of interesting places.

00:28:57.080 --> 00:29:05.300
While I was thinking about this conversation and this topic in particular, I ran across an article called static duck typing in Python with protocols.

00:29:05.300 --> 00:29:08.100
How's that to like crash two ideas together?

00:29:08.160 --> 00:29:09.160
Yeah.

00:29:09.160 --> 00:29:16.320
It's well, when we look at data types, it's like the way Python even does its data types is yeah.

00:29:16.320 --> 00:29:24.680
You can say that you want to say, okay, this is a list and you can type it as a list, but you could also just actually type it as an iterable.

00:29:24.680 --> 00:29:27.800
And basically tell Python what you care about.

00:29:27.800 --> 00:29:30.020
Do you really care that it's a list?

00:29:30.020 --> 00:29:31.300
Probably not.

00:29:31.300 --> 00:29:31.760
Yeah.

00:29:31.760 --> 00:29:36.060
Do you care that it's an iterable that you can, that you can work with similar to a list?

00:29:36.060 --> 00:29:37.600
They're like, how are you going to use it?

00:29:37.600 --> 00:29:38.580
That's what you ask yourself.

00:29:38.580 --> 00:29:40.840
Then you base your annotations around that.

00:29:40.920 --> 00:29:47.160
And so you can say, well, I care measurement like I want it to, I want it to be usable as a measurement.

00:29:47.160 --> 00:29:48.960
I don't really care what it is.

00:29:48.960 --> 00:29:51.020
It doesn't need to be this particular type of class.

00:29:51.020 --> 00:29:57.120
And so that's moving from like we're talking about moving from Java thinking into Python thinking is, well, it's not what it is.

00:29:57.120 --> 00:29:58.140
It's what it does.

00:29:58.140 --> 00:29:58.580
Yeah.

00:29:58.580 --> 00:30:04.140
A lot of the types people put down are like, I need to treat it like some duck typing situation.

00:30:04.140 --> 00:30:07.800
So it needs to have these attributes about it.

00:30:08.240 --> 00:30:13.040
Let's try to put that aspect of it into the formal static typing rather than earlier.

00:30:13.040 --> 00:30:13.500
Yeah.

00:30:13.500 --> 00:30:14.120
Okay.

00:30:14.120 --> 00:30:18.360
Maybe a quick audience question or a bit of feedback here before we move on to the next one.

00:30:18.360 --> 00:30:19.160
It's relevant.

00:30:19.160 --> 00:30:28.040
Nick says, early in my Python journey, I wish I had gotten better understanding of all the intricacies, differences, and use cases for various data structures like set versus list.

00:30:28.040 --> 00:30:28.520
Right.

00:30:28.520 --> 00:30:29.100
Yeah.

00:30:29.100 --> 00:30:30.220
Versus dictionary.

00:30:30.220 --> 00:30:37.720
And those are certainly, even if you've done programming before, maybe that environment language didn't deeply embrace these data structures.

00:30:37.920 --> 00:30:40.980
So certainly those are table stakes for being good at Python.

00:30:40.980 --> 00:30:41.580
Absolutely.

00:30:41.580 --> 00:30:45.740
Use cases hits the nail on the head because it's like, what's the difference between them?

00:30:45.740 --> 00:30:46.840
Well, you know, it's a collection.

00:30:46.840 --> 00:30:48.640
And so maybe that's all you care about.

00:30:49.400 --> 00:30:54.820
But I find myself using all of them in different cases because it's like, all right, I never need to add or remove things from it.

00:30:54.820 --> 00:30:55.760
I'd probably a tuple.

00:30:55.760 --> 00:30:59.720
Or I need to, or I need to be able to hash it, use it as an immutable.

00:30:59.720 --> 00:31:00.300
That's a tuple.

00:31:00.300 --> 00:31:03.380
Or I need to be able to see what's in group A and not group B.

00:31:03.380 --> 00:31:04.060
That's set.

00:31:04.060 --> 00:31:05.420
Or I care about the order.

00:31:05.420 --> 00:31:06.160
That's a list.

00:31:06.360 --> 00:31:08.360
Or I want to be able to associate two things.

00:31:08.360 --> 00:31:08.920
That's a dictionary.

00:31:08.920 --> 00:31:12.160
So knowing your different data structures is helpful.

00:31:12.160 --> 00:31:19.460
And, you know, it's tricky because Python's data structures aren't really all that unique, but they have different names than maybe are used to whatever languages.

00:31:19.980 --> 00:31:22.000
You know, you come across lists and what is that?

00:31:22.000 --> 00:31:24.980
Well, it's a C++ vector or a JavaScript array.

00:31:24.980 --> 00:31:30.520
You know, it's like it's, it's, which is where it's helpful to come back to Python kind of with a fresh mind.

00:31:30.520 --> 00:31:32.000
It's like, what is this?

00:31:32.000 --> 00:31:36.460
Not assuming that things have the same names, but being prepared to get a different vocabulary.

00:31:36.460 --> 00:31:43.640
This portion of Talk Python to Me is brought to you by us over at Talk Python Training with our courses.

00:31:43.640 --> 00:31:47.660
And I want to tell you about a brand new one that I'm super excited about.

00:31:47.960 --> 00:31:50.940
Python web apps that fly with CDNs.

00:31:50.940 --> 00:31:54.880
If you have a Python web app, you want it to go super fast.

00:31:54.880 --> 00:31:58.840
Static resources turn out to be a huge portion of that equation.

00:31:58.840 --> 00:32:05.540
Leveraging a CDN could save you up to 75% of your server load and make your app way faster for users.

00:32:05.540 --> 00:32:09.620
And this course is a step-by-step guide on how to do it.

00:32:09.620 --> 00:32:14.240
And using a CDN to make your Python apps faster is way easier than you think.

00:32:14.600 --> 00:32:19.340
So if you've got a Python web app and you would like to have it scaled out globally,

00:32:19.340 --> 00:32:26.080
if you'd like to have your users have a much better experience and maybe even save some money on server hosting and bandwidth,

00:32:26.080 --> 00:32:30.060
check out this course over at talkpython.fm/courses.

00:32:30.060 --> 00:32:31.540
It'll be right up there at the top.

00:32:31.780 --> 00:32:34.000
And of course, the link will be in your show notes.

00:32:34.000 --> 00:32:36.280
Thank you to everyone who's taken one of our courses.

00:32:36.280 --> 00:32:37.980
It really helps support the podcast.

00:32:37.980 --> 00:32:39.360
Now back to the show.

00:32:43.120 --> 00:32:45.280
Iteration, iterables, iterators, living.

00:32:45.280 --> 00:32:46.300
Yes.

00:32:46.300 --> 00:32:55.400
I was working in some code last year and I came across something that just, I was, I cringed and then I laughed out loud because this was written.

00:32:55.400 --> 00:33:01.500
So this code was written by who I best guess university data scientists.

00:33:01.940 --> 00:33:05.780
So, you know, to their favor, this is not a software engineer.

00:33:05.780 --> 00:33:10.020
What they had written and they could tell it had been refactored a few times, but I am not kidding.

00:33:10.020 --> 00:33:13.240
They had said, all right, so I have this thing that it's iterable.

00:33:13.240 --> 00:33:15.500
It was already something that we could use in a loop.

00:33:15.500 --> 00:33:17.120
And we'll come back to what that is for anyone who's curious.

00:33:17.120 --> 00:33:18.360
But we had this iterable.

00:33:18.720 --> 00:33:20.640
I'm going to convert that into a list.

00:33:20.640 --> 00:33:25.660
By the way, we're talking about, in this case, tens of thousands of items in that list.

00:33:25.660 --> 00:33:26.940
I'm going to convert that into a list.

00:33:26.940 --> 00:33:33.560
Then on the next line, they say for index, comma, value in enumerate.

00:33:33.560 --> 00:33:36.100
Enumerate's a thing that lets you get the indexes as well.

00:33:36.100 --> 00:33:37.840
Enumerate that list.

00:33:37.840 --> 00:33:46.320
And then it says, you know, and then it accessed the value again inside the loop by going to the original list and accessing using the index.

00:33:46.680 --> 00:33:50.360
And I just sat there and I kind of half laugh, half cry.

00:33:50.360 --> 00:33:52.500
It's just like there is so much.

00:33:52.500 --> 00:33:54.260
This is so convoluted.

00:33:54.260 --> 00:34:00.300
And all I had to do was take all that logic out and just say for item in original iterable.

00:34:00.300 --> 00:34:02.200
And then item was the thing.

00:34:02.200 --> 00:34:06.340
But what had happened was that they didn't understand what was really happening in a for loop.

00:34:06.340 --> 00:34:08.660
They were still thinking C or C++.

00:34:08.660 --> 00:34:13.200
And the thing is that Python has these two magic methods called iter and next.

00:34:13.420 --> 00:34:19.400
Itter just says, give me the thing I can use that has the next operator that knows where it is in the list.

00:34:19.400 --> 00:34:20.460
I'm going to leave it at that.

00:34:20.460 --> 00:34:22.160
And the next just says, give me the next item.

00:34:22.160 --> 00:34:22.400
Yeah.

00:34:22.400 --> 00:34:23.320
That's all it is.

00:34:23.320 --> 00:34:24.360
Just give me the next item.

00:34:24.360 --> 00:34:28.640
All a for loop ever does is it grabs that, is it calls that next.

00:34:28.640 --> 00:34:29.840
It's like, give me the next thing.

00:34:29.840 --> 00:34:30.220
All right, good.

00:34:30.220 --> 00:34:30.500
I'm done.

00:34:30.500 --> 00:34:31.080
Give me the next thing.

00:34:31.080 --> 00:34:31.620
Give me the next thing.

00:34:31.620 --> 00:34:32.200
Give me the next thing.

00:34:32.200 --> 00:34:38.240
You can write entire classes that behave like this, even generate the value at that moment.

00:34:38.240 --> 00:34:40.480
It's called lazy iteration.

00:34:40.480 --> 00:34:47.440
You can actually generate the next value when it's wanted, not a moment sooner, which means you only ever have one value in memory sometimes.

00:34:47.440 --> 00:34:47.900
Yeah.

00:34:48.000 --> 00:34:49.580
And then you can just put that in the for loop.

00:34:49.580 --> 00:34:57.820
You come up with any arbitrary name for when you access it for each thing in iterable, name a thing, whatever you want, and then use it directly in your code.

00:34:58.180 --> 00:35:03.040
And I wish someone had told me that a lot sooner, discovered that about three years into my journey.

00:35:03.040 --> 00:35:06.020
I'm like, oh my gosh, I've been making lists of everything and I've been doing it.

00:35:06.020 --> 00:35:07.020
It's like, what a waste.

00:35:07.020 --> 00:35:07.380
Yeah.

00:35:07.380 --> 00:35:12.920
And, you know, the yield keyword, obviously, is a super easy way to do that lazy iteration that you talk about.

00:35:12.920 --> 00:35:16.600
But it also is really important for things like databases, right?

00:35:16.600 --> 00:35:16.880
Yeah.

00:35:16.880 --> 00:35:18.200
If you talk SQLAlchemy, right?

00:35:18.200 --> 00:35:19.000
I'm going to do a query.

00:35:19.000 --> 00:35:25.200
I could call the all method and turn it into an in-memory list, or I could, if I don't need that, I could just loop over it, right?

00:35:25.240 --> 00:35:29.280
And kind of read it cursor style, potentially stop talking to the database halfway through.

00:35:29.280 --> 00:35:29.760
Exactly.

00:35:29.760 --> 00:35:31.780
If I want to need it, I don't need the rest of the data.

00:35:31.780 --> 00:35:32.300
Exactly.

00:35:32.300 --> 00:35:32.880
Yeah, exactly.

00:35:32.880 --> 00:35:33.780
Yeah, interesting.

00:35:33.780 --> 00:35:34.400
Cool.

00:35:34.400 --> 00:35:41.080
Yeah, I think iteration is quite, it's settled because there's only two types of loops in Python.

00:35:41.080 --> 00:35:43.780
And usually we're using the for loops.

00:35:43.780 --> 00:35:47.800
But the variations, there's just so many of them, right?

00:35:47.800 --> 00:35:50.340
You can have your for loop that just goes over a thing.

00:35:50.340 --> 00:35:52.080
But what if you need the index like you described?

00:35:52.080 --> 00:35:53.280
Not for this improper use.

00:35:53.340 --> 00:35:55.200
But sometimes you actually still do need the index.

00:35:55.200 --> 00:35:59.020
So you could do enumerate of that thing and get a tuple.

00:35:59.020 --> 00:36:04.960
But you could take it to another level, do tuple unpacking and say like index comma value in enumerate of things.

00:36:04.960 --> 00:36:05.480
Right.

00:36:05.480 --> 00:36:06.260
And you get it back.

00:36:06.260 --> 00:36:08.280
And you can unpack a dictionary too.

00:36:08.280 --> 00:36:10.280
You can unpack a tuple with that in the dictionary.

00:36:10.280 --> 00:36:13.760
There's this whole library and it built into Python called iter tools.

00:36:14.020 --> 00:36:19.720
And if you ever have, you know, 10 minutes over coffee, just pull up the documentation for iter tools and just kind of scroll through.

00:36:19.720 --> 00:36:21.040
There's some neat stuff.

00:36:21.040 --> 00:36:25.820
Like you can, you can like find every possible combination of three different lists.

00:36:25.920 --> 00:36:27.180
I just give it three different lists.

00:36:27.180 --> 00:36:28.660
And this is one that will take all three of them.

00:36:28.660 --> 00:36:31.440
Just give you every single possible combination of it.

00:36:31.440 --> 00:36:32.260
I actually use it in the book.

00:36:32.540 --> 00:36:35.240
And it's just, there's all these neat things you can do with iterables.

00:36:35.240 --> 00:36:36.680
Some of them don't even have to stop.

00:36:36.680 --> 00:36:42.000
There are infinite iterables where you can just say, I want to get this sequence repeating infinitely.

00:36:42.000 --> 00:36:42.740
One, two, three.

00:36:42.740 --> 00:36:43.160
One, two, three.

00:36:43.160 --> 00:36:43.600
One, two, three.

00:36:43.600 --> 00:36:44.000
One, two, three.

00:36:44.000 --> 00:36:44.420
One, two, three.

00:36:44.420 --> 00:36:44.800
One, two, three.

00:36:44.800 --> 00:36:46.080
And two lines of code.

00:36:46.080 --> 00:36:47.440
And you can have that repeating forever.

00:36:47.940 --> 00:36:53.660
And if you're using an old fashioned while loop or an old fashioned C++ style for loop, that would be multiple lines of code.

00:36:53.660 --> 00:36:56.300
Like, you know, you have to keep track of the state and all that stuff.

00:36:56.300 --> 00:36:56.520
Yeah.

00:36:56.520 --> 00:36:57.460
I think it's two lines.

00:36:57.460 --> 00:36:57.800
Yeah.

00:36:57.800 --> 00:36:58.260
It's amazing.

00:36:58.260 --> 00:36:59.000
Yeah.

00:36:59.000 --> 00:37:02.520
So there's, there's a lot of depth, even though it seems so simple when you first look at it there.

00:37:02.520 --> 00:37:04.980
Closely related to that are comprehensions.

00:37:04.980 --> 00:37:05.540
Yeah.

00:37:05.540 --> 00:37:07.180
Like a list comprehension, right?

00:37:07.180 --> 00:37:15.200
People often see a list comprehension or a set comprehension and go, especially a list comprehension, they're like, oh, that's the same thing as a for loop.

00:37:15.200 --> 00:37:17.760
Where I create, before the for loop, I create a list.

00:37:17.760 --> 00:37:19.800
And then in the for loop, I add the thing to the list.

00:37:19.800 --> 00:37:20.860
And these are the same.

00:37:20.860 --> 00:37:24.240
May have the same outcome, but they're not actually the same thing.

00:37:24.240 --> 00:37:26.980
Like the runtime performance is not the same.

00:37:26.980 --> 00:37:30.500
The bytecode implementation of those two things is not the same.

00:37:30.500 --> 00:37:35.900
This is like a nonstop debate I have on YouTube whenever I put a video and mention something about list comprehension.

00:37:35.900 --> 00:37:37.200
They're like, that's just a for loop.

00:37:37.200 --> 00:37:38.960
It's not actually just a for loop.

00:37:38.960 --> 00:37:41.560
It's like a kind of accomplishing the same thing.

00:37:41.560 --> 00:37:59.200
But we now have for potentially 312, Carl Meyer put out a PEP 709 called inlined list comprehensions, which are supposed to take some of the mostly invisible behind the scene implementation and make comprehensions two times faster.

00:37:59.200 --> 00:38:05.880
I believe they're already faster than this looping story I talked about, but this would make them faster still, which is pretty cool.

00:38:06.340 --> 00:38:06.780
Wow.

00:38:06.780 --> 00:38:09.020
How does this how does this syntax work?

00:38:09.020 --> 00:38:09.800
I'm curious.

00:38:09.800 --> 00:38:11.960
It's just like it's just an internal change.

00:38:11.960 --> 00:38:12.540
Okay.

00:38:12.540 --> 00:38:14.600
So the syntax is unchanged.

00:38:14.600 --> 00:38:15.240
Yeah.

00:38:15.240 --> 00:38:17.800
So the way here's the magic of list comprehensions.

00:38:17.800 --> 00:38:20.180
That's funky that people maybe aren't aware of is it.

00:38:20.180 --> 00:38:26.220
It used to actually create a list comprehension object that implemented the loop in a function.

00:38:26.300 --> 00:38:32.620
And then it called that function as if you'd like nested a function to create the isolation of the list comprehension.

00:38:32.620 --> 00:38:34.280
So that created a stack frame.

00:38:34.280 --> 00:38:35.800
I created an object.

00:38:35.800 --> 00:38:40.180
Then it did function in direction and all those things made it slower than it needs to be.

00:38:40.180 --> 00:38:52.900
So now they create a new load fast and clear byte code operation that like stores the state of the function, then does the list comprehension and then pops it back off the stack to unwind it.

00:38:52.900 --> 00:38:55.000
So anyway, comprehensions are interesting.

00:38:55.000 --> 00:38:57.080
I just wanted to this is like kind of a brand new thing.

00:38:57.080 --> 00:38:57.640
That's cool.

00:38:57.640 --> 00:38:59.020
That's coming along.

00:38:59.020 --> 00:39:00.580
That might be interesting for people.

00:39:00.580 --> 00:39:05.180
Well, I think it's worth mentioning then that what a list comprehension really is.

00:39:05.180 --> 00:39:09.200
So like if I unpack it because people think, oh, people use that term very loosely.

00:39:09.200 --> 00:39:10.960
A lot of times they want the list comprehension.

00:39:11.120 --> 00:39:12.840
But what is a list comprehension?

00:39:12.840 --> 00:39:23.560
And if I unpack that, what it really is, is it is a generator expression that is being unpacked into a list.

00:39:23.560 --> 00:39:25.180
So what's a generator expression?

00:39:25.180 --> 00:39:27.000
Generator expression is a type of generator.

00:39:27.000 --> 00:39:27.940
What's a generator?

00:39:27.940 --> 00:39:34.340
A generator is a function or type of function that is itself iterable.

00:39:34.340 --> 00:39:36.440
So that's where this is.

00:39:36.440 --> 00:39:43.700
That's where this is critical is that a generator you can you can write a generator that what when call it that it has.

00:39:43.700 --> 00:39:45.520
You mentioned that earlier, this yield keyword.

00:39:45.740 --> 00:39:49.240
And so you can do whatever you want in this function.

00:39:49.240 --> 00:39:51.580
You can write it however much logic you want.

00:39:51.580 --> 00:39:55.280
Every time you hit the yield statement, it will return that value.

00:39:55.280 --> 00:39:56.940
And then it's going to wait for the next call.

00:39:56.940 --> 00:40:01.080
Then the next iteration of that, like the next call to next on that generator.

00:40:01.080 --> 00:40:03.460
And then it's going to run through again until it hits a yield.

00:40:03.460 --> 00:40:06.340
And then it's going to stop, turn that value and wait again.

00:40:06.340 --> 00:40:08.500
And you can do some incredible things with these.

00:40:08.500 --> 00:40:12.940
But once you understand the generator, which are incredibly powerful tools,

00:40:13.600 --> 00:40:17.800
then you can write a generator expression, which is I discovered later.

00:40:17.800 --> 00:40:21.360
A generator expression is to a generator as a lambda is to a function.

00:40:21.360 --> 00:40:23.400
It's an anonymous generator.

00:40:23.400 --> 00:40:24.420
That's all it is.

00:40:24.420 --> 00:40:29.220
A lambda is just a very small inline anonymous function.

00:40:29.220 --> 00:40:30.420
Has the logic.

00:40:30.420 --> 00:40:32.180
It can take in some values, return some values.

00:40:32.180 --> 00:40:33.940
It's a lot simpler, a lot shorter.

00:40:33.940 --> 00:40:35.560
And you do it right in place.

00:40:35.560 --> 00:40:38.600
So you're not having to go off somewhere and write a different function and come back.

00:40:38.600 --> 00:40:42.400
That's why we have anonymous functions is so that we can just do it like,

00:40:42.400 --> 00:40:47.780
like you see there at the bottom, reduce and just some rules right there instead of writing a separate function.

00:40:47.780 --> 00:40:49.460
Generate expression, same sort of thing.

00:40:49.460 --> 00:40:51.620
We're doing writing some generator logic.

00:40:51.620 --> 00:40:52.760
It's shorter.

00:40:52.760 --> 00:40:56.140
It's creating a generator, but it's just a lot smaller.

00:40:56.140 --> 00:40:59.740
And if you just wrap it in in parentheses, you can use it as a generator.

00:40:59.860 --> 00:41:08.020
But when you change those parentheses to be square brackets, what happens is you're running that generator and then you're loading all the values into the list.

00:41:08.020 --> 00:41:10.840
You do it in in curly braces.

00:41:10.840 --> 00:41:12.040
You're creating a set.

00:41:12.040 --> 00:41:18.340
Or if you're if you're doing the same thing, but you are the return value in each step is a key value pair.

00:41:18.340 --> 00:41:19.380
Then you're going to create a dictionary.

00:41:19.380 --> 00:41:23.260
But all you're really doing is unpacking that generator into a data structure.

00:41:23.400 --> 00:41:32.140
So sometimes you want to think when you're mucking about with these, do you really want the data structure when you're done or do you just want to go over the values?

00:41:32.140 --> 00:41:34.040
Maybe you just write a generator expression.

00:41:34.040 --> 00:41:34.260
Yeah.

00:41:34.260 --> 00:41:35.540
The difference is super subtle.

00:41:35.540 --> 00:41:39.620
Like, do you have square brackets or do you have parentheses around the expression?

00:41:39.620 --> 00:41:44.600
But the effect or consequence of that is very significant at runtime, right?

00:41:44.600 --> 00:41:49.540
It's kind of like that example you talked about putting everything in a list and looping over it or just looping over it.

00:41:49.540 --> 00:41:49.740
Right.

00:41:49.740 --> 00:41:50.860
Exactly.

00:41:50.860 --> 00:41:55.860
And because these are these are these one liners and we as coders tend to get a text of these one liners.

00:41:55.860 --> 00:41:58.080
It's like, oh, look at all the cool things I could do.

00:41:58.080 --> 00:41:59.420
I have a couple of examples in the book.

00:41:59.420 --> 00:42:05.480
Some real list comprehensions I've come across or some colleagues of mine have come across where it's like it's multiple lines.

00:42:05.480 --> 00:42:08.080
And that's a bad list comprehension.

00:42:08.080 --> 00:42:09.740
That's a bad generator expression.

00:42:09.740 --> 00:42:12.620
Just like you don't want to have a multi-line lambda at that point.

00:42:12.620 --> 00:42:13.780
Write a function.

00:42:13.780 --> 00:42:18.840
Generator expressions and lambdas are supposed to be these really small, short, in place bits of logic.

00:42:18.840 --> 00:42:22.140
And if it's getting complicated, write the full size thing.

00:42:22.140 --> 00:42:23.580
It's a lot easier to debug.

00:42:23.580 --> 00:42:26.940
If nothing else is usually to debug, but it's also a lot easier to read.

00:42:26.940 --> 00:42:27.480
It is.

00:42:27.480 --> 00:42:28.200
It is.

00:42:28.560 --> 00:42:31.120
Just why we're kind of ranching on these things.

00:42:31.120 --> 00:42:40.020
Like, I wish there was a way to specify a sort in these list comprehensions, generate expressions, and maybe not the generators because that gets tricky.

00:42:40.020 --> 00:42:44.900
But so often I find myself I'm doing a list comprehension and then I got to turn around and sort it.

00:42:44.900 --> 00:42:47.460
Like if it could just just add that in there, that would make me happy.

00:42:47.460 --> 00:42:48.040
All right.

00:42:48.040 --> 00:42:48.860
Moving on.

00:42:48.860 --> 00:42:50.200
Packaging.

00:42:50.200 --> 00:42:51.340
Yes.

00:42:51.340 --> 00:42:54.180
Deciding on packaging and all that right up front.

00:42:54.180 --> 00:42:58.460
Actually, before we get to that, I guess the other one that you threw in here is virtual environments.

00:42:58.880 --> 00:42:59.040
Indeed.

00:42:59.040 --> 00:42:59.360
Yeah.

00:42:59.360 --> 00:43:00.580
Virtual environments.

00:43:00.580 --> 00:43:01.380
Use them.

00:43:01.380 --> 00:43:02.080
They're the only.

00:43:02.080 --> 00:43:04.860
I avoided them for years because I thought, oh, these are scary.

00:43:04.860 --> 00:43:06.100
I don't understand them.

00:43:06.100 --> 00:43:07.340
They're not scary.

00:43:07.340 --> 00:43:08.180
I'm actually going to.

00:43:08.180 --> 00:43:09.480
I'm actually going to hijack something.

00:43:09.480 --> 00:43:14.280
I learned from one of my guests on my own podcast recently is what containers actually are.

00:43:14.280 --> 00:43:15.940
By the way, Docker containers.

00:43:15.940 --> 00:43:17.120
This is where this is relevant.

00:43:17.120 --> 00:43:19.040
You know what a Docker container actually is?

00:43:19.040 --> 00:43:20.800
Is it's the folder on your operating system?

00:43:20.980 --> 00:43:22.640
And it's just changing the route.

00:43:22.640 --> 00:43:24.900
So when you're working inside of it, it's changing the route.

00:43:24.900 --> 00:43:27.080
There's a bunch of magic logic around that.

00:43:27.080 --> 00:43:27.920
But that's all it is.

00:43:27.920 --> 00:43:32.840
It's like it's pretending that that folder is the route and it's running things accordingly.

00:43:32.840 --> 00:43:35.280
That's all a virtual environment really is doing either.

00:43:35.280 --> 00:43:37.720
So there's not a lot of difference between.

00:43:37.720 --> 00:43:39.920
It lies to Python about the path.

00:43:39.920 --> 00:43:40.300
Yeah.

00:43:40.300 --> 00:43:43.340
There's not a lot of difference between the virtual environment and the Docker image.

00:43:43.340 --> 00:43:45.600
Like they're the same fundamental concept.

00:43:45.600 --> 00:43:49.380
So all you're doing is you're creating this little spot on your, this little folder.

00:43:49.380 --> 00:43:51.840
And you're saying, these are my Python packages.

00:43:51.840 --> 00:43:55.620
And unless you tell it otherwise, don't go looking anywhere else.

00:43:55.620 --> 00:43:56.680
These are the ones I want to use.

00:43:56.680 --> 00:43:59.380
And they're super easy to create.

00:43:59.380 --> 00:44:01.100
It's like one line to create a virtual environment.

00:44:01.100 --> 00:44:06.920
And it lets you maintain exactly the packages you want for that particular situation.

00:44:06.920 --> 00:44:07.540
And it's great.

00:44:07.540 --> 00:44:08.620
It is.

00:44:08.620 --> 00:44:08.920
Yeah.

00:44:08.920 --> 00:44:11.160
It's once you get used to it, it's great.

00:44:11.160 --> 00:44:13.680
I remember it being frustrating at the beginning.

00:44:13.680 --> 00:44:15.820
You're like, ah, I don't remember exactly.

00:44:15.820 --> 00:44:17.000
How do I create the environment?

00:44:17.000 --> 00:44:17.980
How do I activate it?

00:44:17.980 --> 00:44:18.640
How do I know?

00:44:18.640 --> 00:44:19.880
Do I really need this?

00:44:19.880 --> 00:44:25.060
And yeah, I don't, I don't start any projects without having them as just straight up using

00:44:25.060 --> 00:44:25.540
them right away.

00:44:25.540 --> 00:44:26.360
It's like, absolutely.

00:44:26.360 --> 00:44:26.760
Yeah.

00:44:26.760 --> 00:44:30.200
I probably have created them for projects that don't even have external dependencies because I was just

00:44:30.200 --> 00:44:31.180
like on autopilot.

00:44:31.180 --> 00:44:32.600
Like, oh, actually I didn't need that, but whatever.

00:44:32.600 --> 00:44:33.240
It's still good to have.

00:44:33.240 --> 00:44:33.940
Yeah.

00:44:33.940 --> 00:44:36.840
I would absolutely control which Python version you're using.

00:44:36.840 --> 00:44:38.880
And then you can install whatever packages you want.

00:44:38.880 --> 00:44:42.300
And you don't not worry about messing up your system or user scope packages.

00:44:42.300 --> 00:44:46.360
And I had a coworker recently say, I dream of the day when I can actually remember how to

00:44:46.360 --> 00:44:48.640
activate this, but it's actually really easy.

00:44:48.640 --> 00:44:53.760
So once you, so assuming you know the name of the folder, so you can pick the name of the

00:44:53.760 --> 00:44:55.360
folder you use for your virtual environment.

00:44:55.360 --> 00:44:57.760
Traditionally, it's called like them, V-E-N-B.

00:44:57.760 --> 00:44:59.880
And it's, here's the thing to remember.

00:44:59.880 --> 00:45:02.160
You don't actually have to activate your virtual environment.

00:45:02.160 --> 00:45:03.540
Put that out of your mind for a moment.

00:45:03.540 --> 00:45:06.700
You can run things directly in the virtual environment.

00:45:06.700 --> 00:45:10.780
So in Unix systems like Linux and Mac, there's a bin folder.

00:45:11.340 --> 00:45:16.860
Vim slash bin slash, and then whatever Python, whatever Python executable you want to run.

00:45:16.860 --> 00:45:17.460
It could be Python.

00:45:17.460 --> 00:45:18.080
It could be pip.

00:45:18.080 --> 00:45:19.180
It could be your own package.

00:45:19.180 --> 00:45:22.420
You can actually just navigate into that bin folder.

00:45:22.420 --> 00:45:25.720
And so I can say Vim, bin, pip, and I've got the pip.

00:45:25.720 --> 00:45:29.360
And that knows to only work within its virtual environment.

00:45:29.360 --> 00:45:30.880
It's not going to break out of that container.

00:45:30.880 --> 00:45:33.960
Once you understand that, here's where they activate script is.

00:45:33.960 --> 00:45:35.060
Vim, bin, activate.

00:45:35.060 --> 00:45:36.760
It lives in the bin file.

00:45:37.220 --> 00:45:42.580
And if you're on Windows, the only thing you're changing is you're going from bin to capital S scripts.

00:45:42.580 --> 00:45:49.540
And then the things have an ending of like either .bat or .ps1, depending on what show you're using.

00:45:49.540 --> 00:45:52.240
But that's the structure of a virtual environment.

00:45:52.240 --> 00:45:54.120
And once you understand that, they're a little overscuried.

00:45:54.120 --> 00:46:02.620
Yeah, my RC file for my user profile on my Mac is just full of here's the Python executable in some virtual environment.

00:46:02.620 --> 00:46:06.940
And here's the script and commands to send to it for like little aliases and stuff.

00:46:06.940 --> 00:46:08.980
And like none of those activate the virtual environments.

00:46:08.980 --> 00:46:12.400
They just run the Python in the virtual environment to make all the magic happen.

00:46:12.400 --> 00:46:20.540
Another thing I would recommend is people think about creating aliases that make virtual environments happier and easier to use.

00:46:20.540 --> 00:46:23.340
So, for example, and you could do this in PowerShell on Windows.

00:46:23.340 --> 00:46:26.620
You can obviously do it in your RC files on Mac and Linux.

00:46:26.620 --> 00:46:32.400
So, for example, I have vnv, which is for venv, but I don't want it to accidentally change the directory.

00:46:32.400 --> 00:46:33.760
And if you haven't, like whatever.

00:46:33.760 --> 00:46:36.820
Like I just have a short version, so I know it's something slightly different.

00:46:36.820 --> 00:46:38.420
But it'll go run the virtual environment.

00:46:38.420 --> 00:46:45.320
And it'll always remember to add --prompt equals dot, which will make the virtual environment not just be called venv,

00:46:45.320 --> 00:46:48.420
but it'll be called the name of the project that it's in.

00:46:48.420 --> 00:46:54.780
So, for example, if it's in like talk Python, like the virtual environment, when I activate it, we'll say it's the virtual environment talk Python.

00:46:54.780 --> 00:46:55.260
Right.

00:46:55.260 --> 00:46:56.900
And then it activates it.

00:46:56.900 --> 00:47:05.820
And then I think I think this is almost a bug in Python that most of the time I would say like 49 weeks out of the year.

00:47:05.820 --> 00:47:09.960
When I create a virtual environment, the first thing I hear is warning your pip is out of date.

00:47:10.200 --> 00:47:13.020
You know, like, OK, well, I'm starting a new project.

00:47:13.020 --> 00:47:14.200
How about we start with a new one?

00:47:14.200 --> 00:47:15.600
Let's just go with that right now.

00:47:15.600 --> 00:47:15.880
Right.

00:47:15.880 --> 00:47:19.860
And so my just that is I always want the new one.

00:47:19.860 --> 00:47:22.380
I don't ever want the old one because this is brand new.

00:47:22.380 --> 00:47:23.420
So I want the new one.

00:47:23.420 --> 00:47:24.860
Why don't we fix that?

00:47:24.860 --> 00:47:30.180
So my alias then says pip install dash you pip setup tools, wheels, pip-tools, et cetera.

00:47:30.180 --> 00:47:31.540
And just ditches that output.

00:47:31.620 --> 00:47:32.660
So like, yeah, right.

00:47:32.660 --> 00:47:39.540
Immediately, like I have when I create a virtual environment, it's immediately active and it's immediately named the project and it's immediately up to date.

00:47:39.540 --> 00:47:41.620
So I don't see those silly warnings, at least for a while.

00:47:41.620 --> 00:47:44.040
And all I got to remember is type V and V.

00:47:44.040 --> 00:47:44.380
Boom.

00:47:44.380 --> 00:47:45.040
And that's it.

00:47:45.040 --> 00:47:45.180
Right.

00:47:45.180 --> 00:47:47.880
So if you get into this, if you do a few little steps.

00:47:47.880 --> 00:47:48.360
I do this too.

00:47:48.360 --> 00:47:48.980
Yeah.

00:47:48.980 --> 00:47:49.320
Yeah.

00:47:49.320 --> 00:47:49.520
Yeah.

00:47:49.520 --> 00:47:50.340
I imagine you did.

00:47:50.340 --> 00:47:59.780
And so it's I just strongly encourage people to somehow either do this in PowerShell or do this in their terminal setup because like that big, long thing to type, that's a hassle.

00:48:00.260 --> 00:48:02.020
Three letters is not a hassle.

00:48:02.020 --> 00:48:03.080
And they just makes it.

00:48:03.080 --> 00:48:06.520
There's something about lowering the friction that makes it really nice.

00:48:06.520 --> 00:48:08.880
And there's tools you can also install that do it.

00:48:08.880 --> 00:48:14.320
But like I recommend just writing your own aliases too, because everyone's got a sub of a different workflow instead of perfect anyway.

00:48:14.320 --> 00:48:16.020
That's why Vim has so many options.

00:48:16.020 --> 00:48:24.460
So writing this yourself, it's super easy and it teaches you a bit about how it's working so that you're not surprised at the results.

00:48:24.460 --> 00:48:25.260
Yeah.

00:48:25.260 --> 00:48:25.840
Yeah.

00:48:25.840 --> 00:48:26.480
Indeed.

00:48:26.480 --> 00:48:27.000
Okay.

00:48:27.000 --> 00:48:27.980
Now packaging.

00:48:27.980 --> 00:48:29.060
Yes.

00:48:29.360 --> 00:48:35.460
And I'm going to keep this one super short because it's a deep, deep, deep, deep, deep, deep, deep rabbit hole.

00:48:35.460 --> 00:48:37.280
Figure out your packaging day one.

00:48:37.280 --> 00:48:42.380
Like you get, I will figure out packaging before I even figure out what I'm, you know, how I'm building stuff.

00:48:42.460 --> 00:48:48.340
I am just going to set up a basic hello world and then I'm going to get the packaging working.

00:48:48.920 --> 00:48:51.380
Because I actually, and I learned this the hard way.

00:48:51.380 --> 00:48:52.540
I built a project once.

00:48:52.540 --> 00:48:54.100
It took me one month.

00:48:54.100 --> 00:48:55.580
I was very happy with it.

00:48:55.580 --> 00:48:56.260
It was gorgeous.

00:48:56.260 --> 00:48:56.880
It was a game.

00:48:56.880 --> 00:48:58.540
You can actually find it online now.

00:48:58.540 --> 00:49:00.280
I was very happy with myself.

00:49:00.280 --> 00:49:02.760
And then I spent the next two years trying to package the dark bag.

00:49:02.760 --> 00:49:08.040
Turned out it was impossible to package because of certain assumptions that one of the libraries I was using made.

00:49:08.320 --> 00:49:12.560
Had I actually tried to package it from the beginning, I could have saved myself a heck of a lot of time and just use a different library.

00:49:12.560 --> 00:49:12.860
Yeah.

00:49:13.180 --> 00:49:16.040
So you figure it out from day one.

00:49:16.040 --> 00:49:23.360
And then the benefit you get to this is that then you are constantly, especially if you're doing out of place testing, which I strongly recommend.

00:49:23.360 --> 00:49:24.560
Run your tests.

00:49:24.560 --> 00:49:26.560
Your tests should not be in your source folder.

00:49:26.560 --> 00:49:27.900
Put them separate.

00:49:27.900 --> 00:49:34.020
That's going to force you to actually install your package into a virtual environment and then run the test against that package.

00:49:34.020 --> 00:49:35.640
It is not as scary as it sounds.

00:49:35.640 --> 00:49:41.240
I have a whole, by the way, if you go to my website, code mouse92.com, I've got a whole talk on this called Escape in the Gargo Cult.

00:49:41.560 --> 00:49:43.800
And I explain how these patterns work.

00:49:43.800 --> 00:49:48.560
But when you do it that way, that means from day one and ever onward, you are testing your packaging.

00:49:48.560 --> 00:49:53.640
You're testing your assumptions about the working directories and all that.

00:49:53.640 --> 00:49:58.400
And you are testing it in the same way that it's going to be used on someone else's computer.

00:49:58.400 --> 00:50:07.700
So you never again have to have the thing of, well, it works on my machine because you are, all of your tests are depending on actually installing your package.

00:50:08.240 --> 00:50:14.480
So if something breaks, you bring in a dependency that just doesn't work with your packaging scheme, you know, right away.

00:50:14.480 --> 00:50:15.920
And you can make a decision about it.

00:50:15.920 --> 00:50:16.780
Yeah, that's good advice.

00:50:16.780 --> 00:50:18.780
There's a lot of depth to the packaging thing.

00:50:18.780 --> 00:50:19.940
I had a whole panel on it.

00:50:19.940 --> 00:50:21.520
We're in Talk Python not long ago.

00:50:21.520 --> 00:50:22.940
Definitely a lot there.

00:50:22.940 --> 00:50:23.460
Oh, yeah.

00:50:23.460 --> 00:50:24.340
Deep rabbit hole.

00:50:24.340 --> 00:50:24.980
But you know what?

00:50:24.980 --> 00:50:25.820
Don't copy it.

00:50:25.820 --> 00:50:27.100
Don't don't copy pasta.

00:50:27.100 --> 00:50:27.960
Don't copy paste.

00:50:27.960 --> 00:50:30.280
Find out what the things you're using are doing because.

00:50:31.240 --> 00:50:33.740
All right.

00:50:33.740 --> 00:50:34.940
Last one.

00:50:34.940 --> 00:50:35.400
Yeah.

00:50:35.400 --> 00:50:35.800
Currency.

00:50:35.800 --> 00:50:36.500
Currency.

00:50:36.500 --> 00:50:37.140
Yes.

00:50:37.140 --> 00:50:42.940
Which for years I heard concurrency, asynchrony, threading, parallelism, multiprocessing.

00:50:42.940 --> 00:50:46.140
I heard those all used as as synonyms for one another.

00:50:46.140 --> 00:50:50.320
They're not completely different things.

00:50:50.320 --> 00:50:55.620
So and actually I have to thank the Go language for that for for teaching me this.

00:50:55.620 --> 00:50:57.600
Thank you, Rob Pike, for his talk.

00:50:57.600 --> 00:51:00.240
Concurrency and parallelism are not the same thing.

00:51:00.240 --> 00:51:01.840
But here's the thing to understand.

00:51:01.840 --> 00:51:03.160
Concurrency is doing.

00:51:03.160 --> 00:51:04.940
You're switching between tasks.

00:51:04.940 --> 00:51:07.420
You're checking your phone and you're talking to your friend.

00:51:07.420 --> 00:51:08.820
Are you doing both at once?

00:51:08.820 --> 00:51:13.060
No, you're not reading stuff on Twitter and listening to what your friend says.

00:51:13.060 --> 00:51:16.640
You're actually switching between the two contexts rapidly.

00:51:16.640 --> 00:51:18.160
You're not really multitasking.

00:51:18.160 --> 00:51:21.900
You're just changing your focus fast enough that no one ever notices the difference.

00:51:21.900 --> 00:51:23.160
That's concurrency.

00:51:23.160 --> 00:51:28.780
So you have one CPU or potentially potentially multiple or involved in this where people get

00:51:28.780 --> 00:51:29.240
confused.

00:51:29.240 --> 00:51:32.600
Python's nice because you're locked to one CPU for concurrency.

00:51:32.600 --> 00:51:35.160
So it's I'm gonna work on this.

00:51:35.160 --> 00:51:35.780
Then I'll work on this.

00:51:35.780 --> 00:51:36.340
Then I'll work on this.

00:51:36.340 --> 00:51:37.040
Then I'll work on this.

00:51:37.040 --> 00:51:38.260
It doesn't make your code faster.

00:51:38.260 --> 00:51:39.860
It'll never make your code faster.

00:51:39.860 --> 00:51:42.620
Just like multitasking will not make you get your work day faster.

00:51:42.620 --> 00:51:44.840
What it's going to do is it's going to slow you down.

00:51:44.840 --> 00:51:48.140
But it doesn't look like it.

00:51:48.140 --> 00:51:52.560
In some cases, it'll make your code look faster because while you're waiting on the user to

00:51:52.560 --> 00:51:55.700
type in their answer, this example I use in the book, while you're waiting on the user

00:51:55.700 --> 00:51:59.260
to type in their answer to a question, you're doing some math in the background.

00:51:59.260 --> 00:52:00.380
You're IO blocked.

00:52:00.380 --> 00:52:02.600
You're waiting on something over which you have no control.

00:52:02.600 --> 00:52:04.520
You can do some other work while you wait.

00:52:04.520 --> 00:52:05.700
That's concurrency.

00:52:05.700 --> 00:52:10.180
And you can do that with a synchrony where Python's handling that multitasking, or you can do

00:52:10.180 --> 00:52:13.620
it with threading where the operating system is handling that multitasking.

00:52:13.840 --> 00:52:19.180
That's different than parallelism, which is where you're actually using different CPU cores and you're

00:52:19.180 --> 00:52:24.600
doing two things at the same time because you have two different CPUs, two different cores

00:52:24.600 --> 00:52:26.720
working in parallel.

00:52:26.720 --> 00:52:28.580
And they're not depending on one another.

00:52:28.580 --> 00:52:29.480
They're not waiting.

00:52:29.480 --> 00:52:32.040
So you're doing multiple tasks at once.

00:52:32.260 --> 00:52:33.620
Both of them have overhead.

00:52:33.620 --> 00:52:35.840
Near one is a silver bullet for performance.

00:52:35.840 --> 00:52:37.600
You're really going to have to think a lot about it.

00:52:37.600 --> 00:52:39.980
But I actually like the GIL for this reason.

00:52:39.980 --> 00:52:45.600
Global interpreter lock, the much aligned thing that stops us from getting free multiprocess,

00:52:45.600 --> 00:52:48.920
free parallelism, free multiprocessing with every thread.

00:52:48.920 --> 00:52:53.740
Because this forces us to actually stop and think, which thing do I need?

00:52:53.740 --> 00:52:56.420
Do I need concurrency or do I need parallelism?

00:52:56.600 --> 00:53:01.820
Because you can get both in Python, but the GIL makes sure that you have to make a decision.

00:53:01.820 --> 00:53:05.680
Because if you want multiprocessing, you're going to have to create different processes,

00:53:05.680 --> 00:53:07.500
spin them off, manage them separately.

00:53:07.500 --> 00:53:12.060
There's more overhead, but you're going to have to address all of those things of how do

00:53:12.060 --> 00:53:14.560
we share resources, which is a really snarly topic.

00:53:14.560 --> 00:53:17.780
And Python doesn't let you pretend that that's not going to be an issue.

00:53:17.780 --> 00:53:19.640
It makes you think about that.

00:53:19.640 --> 00:53:20.880
It does make you think about it.

00:53:20.880 --> 00:53:26.580
While you can't get more done, you can't make an individual thing go faster by using concurrency

00:53:26.580 --> 00:53:26.940
on it.

00:53:26.940 --> 00:53:31.660
You can start a bunch of things that run outside of your control and outside of your program

00:53:31.660 --> 00:53:33.060
and then get them back, right?

00:53:33.060 --> 00:53:38.100
Like I could issue a web request, a three API endpoints, all of them, and then start gathering

00:53:38.100 --> 00:53:39.980
up the answers as the first one comes back, right?

00:53:39.980 --> 00:53:45.580
Like you have to think about, I think the main thing to think about here is where am I waiting

00:53:45.580 --> 00:53:50.200
on something else when you're looking for the async and await type of benefits?

00:53:50.200 --> 00:53:51.920
Like am I waiting on a thing?

00:53:51.920 --> 00:53:53.940
Could I be doing something while I'm waiting?

00:53:54.140 --> 00:53:58.120
Async and await amount makes it super easy to do stuff while you're waiting.

00:53:58.120 --> 00:54:01.440
But your program itself is still constrained by the GIL.

00:54:01.440 --> 00:54:06.460
And often with async and await, there's not even a second thread involved, right?

00:54:06.720 --> 00:54:09.440
It's just slicing up, time slicing up the current thread.

00:54:09.440 --> 00:54:09.680
Yeah.

00:54:09.680 --> 00:54:12.880
Which I mean, technically is all that's going on with the threads anyway.

00:54:12.880 --> 00:54:16.380
Like when you have multiple threads, the operating system is now just doing the slicing up.

00:54:16.380 --> 00:54:18.260
You're still constrained to one process.

00:54:18.260 --> 00:54:21.860
Then you need a separate process if you want to do multiple things.

00:54:22.080 --> 00:54:22.140
Yeah.

00:54:22.140 --> 00:54:23.600
But like my machine has 10 cores.

00:54:23.600 --> 00:54:25.960
It will go across the cores according to the OS.

00:54:25.960 --> 00:54:30.140
But the effect in Python because of the GIL means it doesn't actually make any difference.

00:54:30.140 --> 00:54:31.240
It's still the same, right?

00:54:31.240 --> 00:54:31.640
Right.

00:54:31.640 --> 00:54:33.320
But if you get multi-processing them for sure.

00:54:33.320 --> 00:54:34.840
So yeah, super, super interesting.

00:54:34.840 --> 00:54:38.920
I think one of the things people tell, I think people say two things.

00:54:38.920 --> 00:54:42.220
One, asynchronous programming is so hard you should never try it.

00:54:42.460 --> 00:54:43.280
I hear that all the time.

00:54:43.280 --> 00:54:44.760
It's so complicated.

00:54:44.760 --> 00:54:45.500
It's so hard.

00:54:45.500 --> 00:54:46.820
You're going to end up with race conditions.

00:54:46.820 --> 00:54:47.940
Just don't try it.

00:54:47.940 --> 00:54:50.240
Mere mortals don't dare.

00:54:50.240 --> 00:54:51.080
They only regret.

00:54:51.080 --> 00:55:00.540
Maybe if you're doing like signaled events in C++ across, you know, hardware notification.

00:55:00.540 --> 00:55:03.400
Like there are scenarios that are super, super tricky.

00:55:03.400 --> 00:55:06.560
Using async and await generally don't fall into that.

00:55:06.560 --> 00:55:09.920
Like you write regular code without changing the structure.

00:55:10.060 --> 00:55:12.660
You don't have to have callbacks and signals and locks.

00:55:12.660 --> 00:55:15.800
You just write regular code where you have the async stuff you put away.

00:55:15.800 --> 00:55:17.160
It's kind of the end of the story.

00:55:17.160 --> 00:55:20.960
And it's not necessarily as simple as straight up regular programming, but it's, you know,

00:55:20.960 --> 00:55:22.020
it's like 10% more.

00:55:22.020 --> 00:55:23.300
It's not 10x more.

00:55:23.300 --> 00:55:23.700
Yeah.

00:55:23.700 --> 00:55:27.860
I think a lot of people for some, I don't understand why, but a lot of people, I think

00:55:27.860 --> 00:55:31.860
they want to feel like I've conquered this dragon.

00:55:31.860 --> 00:55:36.600
And if I'm going to tell other people how to do it or what to do, the first thing I'm

00:55:36.600 --> 00:55:39.460
going to tell them is how hard it is and how daunting it is.

00:55:39.540 --> 00:55:41.760
And like, yet I've conquered it and now I will help you.

00:55:41.760 --> 00:55:41.940
Right.

00:55:41.940 --> 00:55:43.500
That doesn't do people a favor.

00:55:43.500 --> 00:55:43.660
Right.

00:55:43.660 --> 00:55:45.120
They want to feel good about themselves.

00:55:45.120 --> 00:55:45.700
Yeah.

00:55:45.700 --> 00:55:46.860
I guess so.

00:55:46.860 --> 00:55:51.840
But I feel like threading and parallelism lands deeply in that space where people are like,

00:55:51.840 --> 00:55:53.360
oh, it's super hard.

00:55:53.360 --> 00:55:55.460
And it's not, it really isn't.

00:55:55.460 --> 00:55:59.460
But where it's hard is you, you have to be prepared to really think about why do I need

00:55:59.460 --> 00:55:59.620
it?

00:55:59.620 --> 00:56:05.000
And if I can briefly say, I have two entire chapters in this book on that topic.

00:56:05.000 --> 00:56:05.320
Yeah.

00:56:05.320 --> 00:56:05.820
Cool.

00:56:05.940 --> 00:56:09.400
And I pick one example and it has nothing to do with waiting for a webpage to download

00:56:09.400 --> 00:56:12.060
because that is both overused and something that most of us don't need.

00:56:12.060 --> 00:56:14.000
And I apply synchrony.

00:56:14.000 --> 00:56:14.780
I apply threading.

00:56:14.780 --> 00:56:16.320
I apply parallelism.

00:56:16.700 --> 00:56:22.640
And you actually see all those little concerns of how do you handle deadlocking, live locking?

00:56:22.640 --> 00:56:24.640
How do you handle starvation?

00:56:24.640 --> 00:56:26.940
How do you handle the producer consumer problem?

00:56:26.940 --> 00:56:31.520
How do you handle the fact that, huh, I just added 15 multi, multi processing workers.

00:56:31.520 --> 00:56:33.360
And now this thing is like way slower.

00:56:33.360 --> 00:56:33.840
Why?

00:56:33.840 --> 00:56:35.520
I go into all of that.

00:56:35.520 --> 00:56:40.040
And I think that's one thing I wanted to say is when I was writing this book, that was the

00:56:40.040 --> 00:56:44.680
thing that was my chief delight was coming up with examples for all of the topics from the,

00:56:44.680 --> 00:56:48.940
from the simplest, all the way to the most complicated, where I did not hold back on the

00:56:48.940 --> 00:56:49.780
relevant complexity.

00:56:49.780 --> 00:56:54.320
My list comprehensions were the starliest list comprehensions you're ever going to find in

00:56:54.320 --> 00:56:54.800
this tutorial.

00:56:54.800 --> 00:56:57.680
You know, my, you know, I have, I go into recursion.

00:56:57.680 --> 00:57:01.220
I go into, yes, I go into meta classes, whichever one's afraid of.

00:57:01.220 --> 00:57:02.480
I go into all of these things.

00:57:02.480 --> 00:57:06.160
I dig into them, but the complexity is always relevant.

00:57:06.160 --> 00:57:09.700
So you're only going to get the complexity from the topic and you're going to understand

00:57:09.700 --> 00:57:11.900
where all these bits and pieces interplay.

00:57:11.900 --> 00:57:17.680
But the, in the, the complexity coming in the old, from other irrelevant topics, I try to

00:57:17.680 --> 00:57:18.280
keep to a minimum.

00:57:18.280 --> 00:57:23.600
So you can really focus on understanding, not just the happy path of coding, not just the

00:57:23.600 --> 00:57:25.720
happy path of like, okay, well you can async this.

00:57:25.720 --> 00:57:26.960
Look how easy that was.

00:57:26.960 --> 00:57:30.180
Well, it's not easy, but it's also not painfully hard.

00:57:30.180 --> 00:57:35.020
You just have to be prepared to think through those different factors.

00:57:35.020 --> 00:57:39.920
And so I focused a lot of time on really helping you learn how to think through those factors

00:57:39.920 --> 00:57:41.360
as it relates to your code.

00:57:41.360 --> 00:57:41.720
Excellent.

00:57:41.720 --> 00:57:43.600
It sounds like a bit of the Einstein philosophy.

00:57:43.600 --> 00:57:45.580
Simple as possible, but not simpler.

00:57:45.580 --> 00:57:45.920
Right.

00:57:45.920 --> 00:57:46.400
Exactly.

00:57:46.400 --> 00:57:46.780
Yeah.

00:57:46.780 --> 00:57:47.000
Cool.

00:57:47.000 --> 00:57:49.020
I, you know, last thoughts on the async stuff.

00:57:49.080 --> 00:57:53.760
Like I think a sprinkling of async and await makes massive difference for a lot of scenarios.

00:57:53.760 --> 00:57:54.840
And that's pretty straightforward.

00:57:54.840 --> 00:57:59.300
If you're going to try to write trio or some full on framework that deeply coordinates and

00:57:59.300 --> 00:57:59.920
understands it.

00:57:59.920 --> 00:58:02.140
Like, yeah, that's super, super hard.

00:58:02.140 --> 00:58:07.420
Again, some of the signaling stories I talked about with like C code, that's super hard, but

00:58:07.420 --> 00:58:09.220
this stuff people, it's pretty approachable.

00:58:09.220 --> 00:58:10.880
So don't, don't forget to check it out.

00:58:10.880 --> 00:58:11.440
All right.

00:58:11.440 --> 00:58:14.800
Well, I think that's it for our things.

00:58:14.800 --> 00:58:19.180
We wish we knew if we had more time, we could wish upon more things, but that's pretty much

00:58:19.180 --> 00:58:20.360
definitely covers it.

00:58:20.360 --> 00:58:20.780
Doesn't it?

00:58:20.780 --> 00:58:21.880
Yeah, I think so.

00:58:21.880 --> 00:58:22.220
Nice.

00:58:22.540 --> 00:58:22.840
All right.

00:58:22.840 --> 00:58:25.040
Well, before you get out of here, let me ask you the final two questions.

00:58:25.040 --> 00:58:28.560
If you're going to write some code, what editor to use?

00:58:28.560 --> 00:58:29.000
Yeah.

00:58:29.000 --> 00:58:31.180
You know, for the longest time I was a VS Code guy.

00:58:31.180 --> 00:58:36.080
I still love it, but I broke down and I bought PyCharm Professional and I love that because

00:58:36.080 --> 00:58:41.780
I do a lot of refactoring and PyCharm saves my butt so much when it comes to refactoring

00:58:41.780 --> 00:58:43.120
that I fell in love with it.

00:58:43.120 --> 00:58:44.940
And I can't imagine working without it now.

00:58:44.940 --> 00:58:45.820
I hear you.

00:58:45.820 --> 00:58:46.520
So I'm spoiled.

00:58:48.940 --> 00:58:53.320
It does surprise me how people, not just a PyCharm comment, but in general, there's

00:58:53.320 --> 00:58:57.260
a lot of people who are like, oh, I don't really want to get like a new computer or I don't

00:58:57.260 --> 00:58:59.540
really want to pay 20 bucks for this thing.

00:58:59.540 --> 00:59:04.620
That would save you thousands of dollars worth of time as you go for it.

00:59:04.620 --> 00:59:06.600
You know, like, so I'm glad.

00:59:06.600 --> 00:59:07.880
Large on your tools.

00:59:07.880 --> 00:59:08.420
Yeah.

00:59:08.420 --> 00:59:10.260
As far as your budget will allow you.

00:59:10.260 --> 00:59:12.500
And I've been on both ends of that spectrum.

00:59:12.500 --> 00:59:15.920
And as your budget allows you, large on your tools because they're what you're going to

00:59:15.920 --> 00:59:18.040
be spending most of the day using anyway.

00:59:18.040 --> 00:59:21.040
And the last thing you want is something you're going to be getting splinters on.

00:59:21.040 --> 00:59:22.360
So indeed.

00:59:22.360 --> 00:59:26.560
And then notable PyPI package, something you're like, oh, this thing's awesome.

00:59:26.560 --> 00:59:28.660
I just ran across X, Y, Z.

00:59:28.660 --> 00:59:30.200
I guess I have two.

00:59:30.200 --> 00:59:34.460
One would be, I think my favorite, and this has certainly gotten plenty of press, but I

00:59:34.460 --> 00:59:34.720
love it.

00:59:34.720 --> 00:59:36.300
It's the hypothesis testing library.

00:59:36.300 --> 00:59:37.700
I love hypothesis.

00:59:37.700 --> 00:59:39.900
Hypothesis is fantastic.

00:59:39.900 --> 00:59:41.840
It will revolutionize the way you write tests.

00:59:41.840 --> 00:59:44.520
It's not as scary as the documentation makes it look.

00:59:44.520 --> 00:59:47.000
If you click on what you can generate and how, start there.

00:59:47.000 --> 00:59:49.540
I go through the quick start guide and then go right to this.

00:59:49.540 --> 00:59:52.240
And it's so cool because you just write these strategies.

00:59:52.240 --> 00:59:56.520
I'm like, okay, this is what my data is kind of sort of supposed to look like.

00:59:56.520 --> 00:59:59.700
And then your test is going to try and break your code.

00:59:59.700 --> 01:00:01.040
I love hypothesis.

01:00:01.040 --> 01:00:04.820
It's going to throw all sorts of garbage at you until it finds a way to break your code.

01:00:04.820 --> 01:00:07.800
And then it's going to go, hey, here's the simplest thing I could find that blew up

01:00:07.800 --> 01:00:08.240
your code.

01:00:08.240 --> 01:00:08.840
Fix it.

01:00:08.840 --> 01:00:09.380
Lovely.

01:00:09.380 --> 01:00:09.700
Nice.

01:00:09.800 --> 01:00:10.460
So much fun.

01:00:10.460 --> 01:00:14.660
The other favorite package I have is one of my own actually branch detective.

01:00:15.260 --> 01:00:17.280
I built this at two jobs ago.

01:00:17.280 --> 01:00:23.020
And basically we had the problem where we had these diverging branches where we had no

01:00:23.020 --> 01:00:24.740
choice, choice, but to completely diverge them.

01:00:24.740 --> 01:00:26.620
And we were cherry picking back and forth.

01:00:26.620 --> 01:00:30.100
And there was always this, which commits are in this one that aren't in this one.

01:00:30.100 --> 01:00:33.660
When you're doing cherry picking, your hashes are complete garbage.

01:00:33.900 --> 01:00:37.400
So I built this tool that allows you to see what's in one branch.

01:00:37.400 --> 01:00:40.200
It's not in another branch, any branch arbitrarily.

01:00:40.200 --> 01:00:42.620
You can specify day range.

01:00:42.620 --> 01:00:43.880
It knows how to handle cherry picks.

01:00:43.880 --> 01:00:46.560
It knows how to handle merge revisions or filter them out.

01:00:46.560 --> 01:00:51.140
And you can even pass to the dash M flag and just get this nice markdown.

01:00:51.140 --> 01:00:53.740
If you're using conventional commits, we'll just spit out this markdown.

01:00:53.740 --> 01:00:57.600
Then you can then copy and paste into your PR and say, hey, here's, here's all.

01:00:57.600 --> 01:01:00.540
Here's the summaries of the 26 commits I'm putting in here.

01:01:00.680 --> 01:01:06.680
So I use this every single day and I've improved it for every project I'm on so far.

01:01:06.680 --> 01:01:09.120
And I, I just, I love it.

01:01:09.120 --> 01:01:09.600
It's my favorite.

01:01:09.600 --> 01:01:10.920
One of my favorite things I've ever built.

01:01:10.920 --> 01:01:13.420
So you kind of wrote set for Git, right?

01:01:13.420 --> 01:01:14.680
Like you can say, what's in the set?

01:01:14.680 --> 01:01:15.620
Subtract that set.

01:01:15.620 --> 01:01:16.560
Show me those things.

01:01:16.560 --> 01:01:16.800
Yeah.

01:01:16.800 --> 01:01:18.060
Speaking of data structures.

01:01:18.060 --> 01:01:18.600
Exactly.

01:01:18.600 --> 01:01:19.960
Like what's here that's not there.

01:01:19.960 --> 01:01:20.320
Yes.

01:01:20.320 --> 01:01:20.660
Yeah.

01:01:20.660 --> 01:01:21.060
Cool.

01:01:21.060 --> 01:01:21.900
All right, Jason.

01:01:21.900 --> 01:01:23.380
Well, thanks for being here.

01:01:23.380 --> 01:01:24.620
Final call to action.

01:01:24.620 --> 01:01:26.520
People will get their Python better.

01:01:26.520 --> 01:01:27.060
What do you tell them?

01:01:27.060 --> 01:01:27.980
Yes.

01:01:27.980 --> 01:01:33.560
So dead simple Python is available from wherever you buy books, but especially if you go to

01:01:33.560 --> 01:01:38.080
nostarch.com, you can get this comes in ebook or in physical book form.

01:01:38.080 --> 01:01:39.380
And Hey, you know what?

01:01:39.380 --> 01:01:43.220
I wrote it and I refer to it every single day because this is the book I wish I had had.

01:01:43.220 --> 01:01:49.100
And my favorite little feature of this is that I have a thing in the back with every single

01:01:49.100 --> 01:01:50.300
command for the debugger.

01:01:50.300 --> 01:01:55.120
Also, every single dunder method is also documented in here, which even the Python docs didn't

01:01:55.120 --> 01:01:55.460
do that.

01:01:55.460 --> 01:02:00.460
This is the entire core language bar nothing explained for the existing coder.

01:02:00.460 --> 01:02:01.800
So check this out.

01:02:01.800 --> 01:02:02.520
Awesome.

01:02:02.520 --> 01:02:05.700
Well, thanks for taking the time for being here and enjoy the chat.

01:02:05.700 --> 01:02:06.740
Thank you so much.

01:02:06.740 --> 01:02:07.360
It's been a pleasure.

01:02:07.360 --> 01:02:08.080
You bet.

01:02:08.080 --> 01:02:08.680
See you later.

01:02:09.620 --> 01:02:12.280
This has been another episode of Talk Python to Me.

01:02:12.280 --> 01:02:14.100
Thank you to our sponsors.

01:02:14.100 --> 01:02:15.700
Be sure to check out what they're offering.

01:02:15.700 --> 01:02:17.120
It really helps support the show.

01:02:17.120 --> 01:02:19.360
Take some stress out of your life.

01:02:19.360 --> 01:02:24.840
Get notified immediately about errors and performance issues in your web or mobile applications with

01:02:24.840 --> 01:02:25.160
Sentry.

01:02:25.160 --> 01:02:30.140
Just visit talkpython.fm/sentry and get started for free.

01:02:30.140 --> 01:02:33.740
And be sure to use the promo code talkpython, all one word.

01:02:33.740 --> 01:02:35.200
Want to level up your Python?

01:02:35.620 --> 01:02:39.240
We have one of the largest catalogs of Python video courses over at Talk Python.

01:02:39.240 --> 01:02:44.420
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:02:44.420 --> 01:02:47.080
And best of all, there's not a subscription in sight.

01:02:47.080 --> 01:02:50.000
Check it out for yourself at training.talkpython.fm.

01:02:50.000 --> 01:02:51.900
Be sure to subscribe to the show.

01:02:51.900 --> 01:02:54.680
Open your favorite podcast app and search for Python.

01:02:54.680 --> 01:02:55.980
We should be right at the top.

01:02:55.980 --> 01:03:01.160
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:03:01.160 --> 01:03:05.360
and the direct RSS feed at /rss on talkpython.fm.

01:03:05.360 --> 01:03:08.780
We're live streaming most of our recordings these days.

01:03:08.780 --> 01:03:12.200
If you want to be part of the show and have your comments featured on the air,

01:03:12.200 --> 01:03:16.620
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:03:16.620 --> 01:03:18.460
This is your host, Michael Kennedy.

01:03:18.460 --> 01:03:19.760
Thanks so much for listening.

01:03:19.760 --> 01:03:20.920
I really appreciate it.

01:03:20.920 --> 01:03:22.820
Now get out there and write some Python code.

01:03:22.820 --> 01:03:44.280
I'll see you next time.

