00:00:00 Python 3 .8 is coming soon. It's scheduled for release at the end of October 2019, and you can

00:00:05 already download test versions today. Given that Python ships on an 18 -month cycle, it's time to

00:00:10 talk about what's coming for us Python developers in the fall. On this episode, I meet up with Lucas

00:00:14 Lenga and Anthony Shaw to chat about the highlights of this upcoming version of Python.

00:00:19 Also, quick show note, we recorded this on location in Cleveland at PyCon 2019. There may be a small

00:00:25 amount of background noise, but I think you'll barely notice. This is Talk Python to Me,

00:00:29 Episode 214, recorded May 5th, 2019.

00:00:46 Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the

00:00:51 ecosystem, and the personalities.

00:00:53 This is your host, Michael Kennedy.

00:00:54 Follow me on Twitter, where I'm @mkennedy.

00:00:56 Keep up with the show and listen to past episodes at talkpython .fm and follow the show on Twitter

00:01:01 via at Talk Python.

00:01:03 This episode is brought to you by Microsoft.

00:01:06 Be sure to check out what they're offering during their segments.

00:01:08 It really helps support the show.

00:01:10 Lucas, Anthony, welcome back to Talk Python, both of you guys.

00:01:13 Hello.

00:01:13 Hi, Michael.

00:01:14 Good to be back.

00:01:15 Yeah, it's great to have you back.

00:01:16 We are not recording over Skype far distances, but in fact, we're right here at PyCon.

00:01:22 And who knows how the audio for this is going to come out, but hopefully it'll sound good

00:01:26 enough, but it's great to be here on site in Cleveland with both of you. It's a

00:01:29 unique experience to actually see you doing the recording.

00:01:32 Yeah, it's really good to be here in Cleveland.

00:01:34 The sun has finally come out today after the third day of PyCon.

00:01:38 The fog was pretty incredibly epic and that was pretty special. And yeah, Lucas,

00:01:42 the latency on this video call is incredible, man. It's so, it's lifelike.

00:01:46 Yeah. So this video call is like 3D. It's amazing.

00:01:49 Yeah, it's amazing. So thank you both for being here. We're going to talk about Python 3 .8 and

00:01:54 maybe looking a little bit beyond that, some of the peps that are out there and all the cool stuff

00:01:58 there. But, you know, let's just start with PyCon. Like, how's your experience this year? It felt a

00:02:02 little different to me. I'll say why in a minute, but you go first. I'm Kashlanga. I've been co -chairing

00:02:07 the Language Summit this year with Mariata, and this is an absolutely new experience for me. So

00:02:12 that was interesting, actually herding all the cats at the right time to the right spots,

00:02:17 you know, pre -selecting talks, actually making sure that everybody has the opportunity to speak,

00:02:22 making sure that everybody is engaged.

00:02:25 That was new.

00:02:25 So I was very happy to have it over with after that day.

00:02:30 I've heard it went pretty well.

00:02:31 So I was happy about this.

00:02:33 The rest of PyCon was also rather intense so far for me.

00:02:37 I've had a talk about Black and then an extended Q &A that I just performed during the poster

00:02:43 session on Sunday morning.

00:02:44 That's really awesome.

00:02:45 I feel like Black is one of these things that has just taken off.

00:02:49 I often ask people what module they recommend or package.

00:02:52 or what is like special that they've seen.

00:02:55 And it's way more than any other single answer is black.

00:02:58 That's awesome.

00:02:59 Congratulations.

00:02:59 Yeah, thank you.

00:03:01 I'm very happy about it.

00:03:01 In fact, I think there was at least five talks that mentioned, you know,

00:03:06 using black as a good thing in them.

00:03:08 So it seems like, you know, we've solved an issue that people had.

00:03:12 We've solved a problem that people had.

00:03:13 Yeah, we've had these linters and they've tell us what you're doing wrong.

00:03:16 And we're just like, can't you just fix it?

00:03:18 Like, I don't want to be told what's wrong.

00:03:20 I just want it to be better.

00:03:21 Yeah, well, the difference between Black and other autoformatters, of which we have a few in the Python community,

00:03:27 is that Black was kind of brave, obnoxious enough to tell you that it's going to just be done in one way.

00:03:34 It's not really configurable.

00:03:36 But that kind of changes it to a workflow tool where if you decide to use the tool,

00:03:40 now the question of autoformatting sort of disappears.

00:03:43 The question of how to format your code is no longer a problem when you're developing your own projects.

00:03:49 Yeah, and if you're on a team, you don't have to have this debate anymore of how we do stuff, right?

00:03:53 You just run black and that's how you do it.

00:03:55 Absolutely.

00:03:55 Awesome.

00:03:56 Okay.

00:03:56 Anthony, how's your PyCon going?

00:03:58 Like, what do you notice this year that's special?

00:03:59 Yeah, this is the first PyCon I've actually given a talk.

00:04:03 So that was definitely a milestone for me.

00:04:04 Yeah, what was the talk?

00:04:05 It was on code complexity.

00:04:07 And I talked about Wiley, which is a project I've been working on.

00:04:10 And then the principles of code complexity and why complexity is bad.

00:04:13 So how awesome cyclomatic complexity is?

00:04:16 I actually talk about how it's inevitable, the more users you have to have more cyclomatic complexity.

00:04:21 people ask me how the talk went and my response so far has been i don't remember because i was so

00:04:27 nervous that it was just a sort of adrenaline fueled dream so that was um yeah really cool and

00:04:32 then yesterday there was mentored sprints that's new right which is a new thing this year and that's

00:04:39 probably the highlight actually for pycon so far is actually just being in there and mentoring people

00:04:44 and to contribute to the different projects and working with someone who ended up being able to

00:04:49 send a pull request through to CPython by the end of the day.

00:04:53 And I think it was their first one, which is awesome.

00:04:55 Yeah, that's super cool.

00:04:56 That's got to help adoption and contributions, right?

00:05:00 Because even me personally, I think about, okay, well, I'd love to do something,

00:05:04 but I really don't even know how to get started, how to build it, what the right rules or expectations are.

00:05:10 Like, it's a lot of work.

00:05:12 And if somebody can sit down who's done that or is at least knowledgeable about that

00:05:15 and walks you through it, like the second time onward is much more likely

00:05:19 to be smooth yeah and it was a proper amount of time allocated as well it was i think it's just

00:05:23 over four hours on the second day in the afternoon so it's good enough time to actually sit and work

00:05:29 on a proper a proper issue um or a proper feature and actually work through it from start to finish

00:05:34 yeah you actually got a pr in place not just started or whatever yeah exactly so yeah that's

00:05:39 awesome to me it felt like when i walked into the expo hall that the booths were a little bit bigger

00:05:45 there were a little bit more people. It just seemed like a little bit, I don't know, there are a little more people, a little more energy, even than last year. And last

00:05:52 year was amazing. I don't know. Did you have this feeling?

00:05:53 Yeah, I was particularly impressed with the portrait of Guido at the Capital One booth,

00:05:59 which you've got to see online if you haven't seen a picture of it already. Yeah, their booth was really artistic. It was pretty cool. Nice.

00:06:05 All right. So it's great to be here at PyCon, but let's talk about the future. Let's start with the

00:06:12 idea of when is Python 3 .8 going to be out? How precisely didn't we know that? And Lucas,

00:06:18 maybe just say a little bit about like, you're mostly in control of this at the moment, right?

00:06:23 Like the release schedule and management and whatnot, right?

00:06:25 Currently, I'm serving as the release manager of Python 3 .8. And I wrote the schedule for where

00:06:32 things are going to go. Traditionally, Python has been released every 18 months, which puts Python

00:06:36 3 .8 at the end of this year. Like, you know, and in particular, like, you know, give or take,

00:06:42 it should be the end of October. The reason why I'm not saying a particular date, even though it

00:06:47 is in the PEP, is that those things tend to be a bit fluid. Like in the past three alphas that I

00:06:53 released, like we've been a day early or a day late pretty much every time. Yeah, would you

00:06:58 be willing to like hold up a release if there's some important feature that's two days away? In fact,

00:07:03 like this time, there was a small issue, well, but small in size, but big in significance that

00:07:10 I held up Alpha 4 that I had a bit of time for early in the week, which kind of makes me late for my own schedule now.

00:07:18 And I have to release Alpha 4 tomorrow at the start of sprints.

00:07:22 But those things are more important to get right than to get on time.

00:07:26 And this is something.

00:07:28 Yeah, especially when it's 18 months.

00:07:29 If you were shipping monthly updates, like whatever, just ship what you got, right?

00:07:32 But if it's 18 months, that couple of days, that means a big, big deal, right?

00:07:37 This is exactly the point.

00:07:38 We try to make the consecutive releases, even on the alpha level, consecutively better and not introduce a breakage that is going to be later reverted since every release, including alphas, is being tested by our users.

00:07:52 And we're happy to see actually alpha releases being increasingly used by the community to test their own libraries and applications.

00:08:00 That used to be our problem, that it was only after the beta releases.

00:08:04 And in fact, RCs very often were the first releases that users would see.

00:08:09 Nowadays, with like PyPI working better, with CI options being out there for pretty much everybody,

00:08:17 we see more adoption of alpha releases, which is great.

00:08:20 But that is also a bigger responsibility on the alpha releases because you are no longer free to just make a breaking change and then later revert it.

00:08:27 Well, it's alpha anyway.

00:08:28 Well, no, it isn't.

00:08:29 Didn't you see what it was?

00:08:30 It said alpha.

00:08:30 Yes, now we would need to have feature toggles that look at the alpha version to see whether a particular bug exists or not.

00:08:37 And we don't want that.

00:08:39 This might be a slightly political question, but have the releases of Python recently become more stable?

00:08:47 It feels to me that people have almost zero trepidation or worry about just adopting 3 .7 when they had 3 .6 or 3 .6 when they had 3 .5 these days.

00:08:58 And it seemed like there was more concern about what's going to break when I go to the next, you know, semi -major version.

00:09:03 Has that changed or is that like perception?

00:09:05 For a number of years, the only version that people used was 2 .7.

00:09:09 And that was for a long time.

00:09:11 So it created this false perception that like Python is infallible, that every particular update of it like never introduces issues that were not there before.

00:09:21 Because they were just minor fixes.

00:09:22 Exactly.

00:09:24 That was good.

00:09:25 You know, at the same time, a blessing and a curse.

00:09:28 since every particular version of Python, like including Python 2 .4 to Python 2 .5,

00:09:34 Python 2 .5 to Python 2 .6, did introduce internal changes that made large projects actually complex to migrate.

00:09:44 The biggest example from the Python 2 world where it was when Python 2 .5 was released.

00:09:50 Zope at the time created such a problem for itself that it took them enough time

00:09:56 that they migrated to Python 2 .6 directly.

00:09:59 So the previous version worked on Python 2 .4, whereas the next one directly on Python 2 .6,

00:10:06 they did not migrate in time for 2 .5.

00:10:06 Right, it took so long to migrate.

00:10:08 They're like, let's just aim for the next one, huh?

00:10:09 So this is all just like a long, long introduction to just let you know that in Python 3,

00:10:16 there are also changes.

00:10:18 Many of those changes are deliberate, right?

00:10:20 We are changing how the internal memory representation of objects looks like.

00:10:24 We are introducing and removing bytecodes.

00:10:28 We can change how modules get initialized.

00:10:31 You know, there's multiple things that might break real applications, but breaking them in ways where it is impossible for us

00:10:40 to guarantee eternal compatibility with those things.

00:10:43 Sure, but this greater adoption of alpha versions and testing and CI probably doesn't hurt, right?

00:10:48 Some kind of crashers, right?

00:10:50 Downright bugs and whatnot.

00:10:52 That I feel like we are doing a better job these days with.

00:10:57 Also just because Python 3 finally gets enough adoption that those versions get vetted much better.

00:11:04 Right, absolutely.

00:11:05 When I started contributing, we were just working on Python 3 .2.

00:11:09 So for a number of years, almost none of the things I worked on were actually very heavily used in the industry.

00:11:15 Nowadays, the situation is different.

00:11:18 So fortunately, the time between a change and actually having real users report on it is way shorter, which makes the QLT just better.

00:11:27 Yeah, that's awesome.

00:11:28 Anthony, let me ask you what your perception of that's like.

00:11:31 You work for a pretty major company that probably has stability in mind and stuff.

00:11:35 What's your perspective and what are you seeing at Dimension Data and places like that?

00:11:39 It's definitely become easier for people to install newer versions of Python, which is really helping.

00:11:44 So in terms of, I guess, moving towards things running as microservices on Docker, for example,

00:11:50 there's this, it's not a single system running a specific version that's got to support all

00:11:55 these different applications.

00:11:55 Right, it's not cross your fingers or upgrading the server.

00:11:58 Yeah, we're not running on the mainframe anymore.

00:12:00 So I think that that's really helping in terms of there's more automation for systems deployment

00:12:06 and there's a lot more tooling being used to automate like the building of new environments.

00:12:12 there's this kind of idea of immutable infrastructure now where you basically create

00:12:17 infrastructure in the cloud and you build it on a specific version.

00:12:20 You don't change it, right, ever.

00:12:22 Yeah.

00:12:22 So I think that has actually made it easier to move to newer versions because you can

00:12:28 just spin up new infrastructure with the new version, test how it works, and you can inspect

00:12:33 it properly.

00:12:34 Whereas like 10 years ago, you're talking about we need to go and buy a million dollars

00:12:38 of hardware to build an identical environment to see if this new version is going to work for us.

00:12:43 Right. And maybe you have like downtime the whole weekend, the team stays all night and they do the

00:12:48 testing and the rollout. And, you know, these days when I go to websites and I see we're down for

00:12:53 maintenance or we have even like we have scheduled maintenance over this like two to four hour window.

00:12:57 I'm just like, what are they doing? Like what possibly could take four hours to upgrade? Like

00:13:08 four hours, it doesn't take anyway. It just seems pretty wild when you see it. But that used to be

00:13:11 common, right? So I guess, yeah. So it doesn't matter as much.

00:13:14 Yeah, it still matters for some really big applications. I know some of the biggest software vendors still have four -hour

00:13:20 maintenance windows every Saturday. We definitely have to live through some of that pain at the

00:13:24 moment. But more and more, I think people are using this sort of automated deployment and

00:13:29 automated infrastructure, which is making it a lot easier to upgrade. That's awesome.

00:13:34 What about the beta version or the alpha version even of 3 .8?

00:13:38 You guys said late October for the main release.

00:13:42 For the main release, but we work that back.

00:13:44 When will we see stuff that we can start playing with?

00:13:46 Can we already?

00:13:47 I know, Anthony, you get it in build from source a lot and then play with it,

00:13:51 and you guys do as well.

00:13:53 But when does the average person who just wants to install a beta or something like that get access to it?

00:13:59 Any alpha release is released in both the forum of sources that you can freely build.

00:14:05 If you're cloning the repository from GitHub, there's tags that tell you exactly

00:14:10 when a particular release was made.

00:14:12 But also for alphas, betas, and later release candidates and actual versions that we release,

00:14:18 we do have binaries, right?

00:14:19 So for both macOS and Windows, we have plenty of binaries that you can use to test out your software.

00:14:26 I would advise to do it as early as possible.

00:14:29 especially 3 .8 was kind of like a shy release.

00:14:34 Right, because we had the whole governance thing, all the major changes were sort of put in.

00:14:39 Yes, so now we are just four weeks before the first beta, which is the feature freeze for us, right?

00:14:46 Since beta 1 to the main 3 .8 .0 release, we are just fixing bugs.

00:14:52 In some unlikely cases, maybe even reverting features that we identified

00:14:56 are not ready for prime time, unlikely to happen. What is more likely to happen is this is the time where you know that breaking

00:15:04 changes are no longer being, new breaking changes are no longer being accepted. So it's a great time

00:15:10 to actually start using your CI to test your libraries, your applications on Python 3 .8 as well.

00:15:16 Expect problems. There's things that we have not identified, even though we have our other

00:15:21 extensive regression suite of tests. But it's great to be able to identify those things early.

00:15:27 So by the time the distributors come in and package Python 3 .8, its quality is good and we're transparent.

00:15:33 We just can run your application with minimal churn.

00:15:36 That's pretty cool.

00:15:37 Can you test it with Tox or what's the best way to test on 3 .7 and 3 .8 beta or whatever?

00:15:43 There's many possible ways depending on what particular operating system you're using.

00:15:48 For open source projects that are already using a CI system like Travis,

00:15:53 There are ways to just utilize the latest development version of Python.

00:15:57 And at the moment, it's 3 .8.

00:15:59 So just by just saying that you would also like to run your tests on the development version

00:16:04 of Python, you're going to get beta version like in a month.

00:16:07 That currently is going to be a form of alpha.

00:16:10 So that is probably easiest because you don't have to actually install anything locally on

00:16:14 your computer, which tends to make things complex when you have many interpreter versions with

00:16:19 you.

00:16:20 So homebrewing, Patrick, likes to default to one Python 3 version, one Python 2 version.

00:16:25 So there's PyEnv that you can use to have multiple installations.

00:16:29 And obviously, yes, there's Tox.

00:16:31 They actually work rather well together.

00:16:33 So you can set up your matrix of tests that later are run online, but you can also run them locally, which is what I'm doing.

00:16:40 Yeah, okay.

00:16:41 That seems pretty easy.

00:16:42 All right, Anthony, let's kick off this PEP section and talking about the actual features,

00:16:48 which, as we all know, appear as Python enhancement proposals and they go through a lifecycle and whatnot.

00:16:54 If people are wondering what peps are out there, what might make it into 3 .8 and so on,

00:16:58 where would they go to find that out?

00:17:00 So I think on the python .org website, and there's a list of peps.

00:17:03 There's also a PEP index on the list of peps.

00:17:06 I've also made a small web app called Pep Explorer, where you can go and search and filter

00:17:11 and pull specific Python versions and get the status of the peps.

00:17:16 So I use Pep Explorer because I spend time looking at peps and reading about them and

00:17:21 trying to understand what's coming in future versions.

00:17:24 So yeah, if you're just curious, I'd say the Pep Explorer is probably a good way to go.

00:17:27 Yeah, the Pep Explorer is pretty awesome.

00:17:29 It's just a nice little grid.

00:17:30 It's on GitHub pages, right?

00:17:32 Yeah.

00:17:33 Yeah.

00:17:33 And I'll just link to that.

00:17:34 And of course, people can go to python .org.

00:17:36 But yeah, it's really nice to just keep track of that.

00:17:39 And I find that super helpful.

00:17:41 All right.

00:17:42 So let's kick it off.

00:17:43 maybe since you're holding the mic, we'll go with you first.

00:17:47 You know, what's like one of the notable things that's coming that you want to talk about, what PEP or feature?

00:17:52 So I thought I'd cover off the two ones that changed the language first.

00:17:56 Okay.

00:17:57 So there's assignment expressions, colloquially known as the walrus operator.

00:18:02 The walrus operator.

00:18:04 Yeah, so this is PEP572.

00:18:06 Yeah, PEP572.

00:18:07 So in Python, if you want to assign a value to a variable, you use the equals symbol, that doesn't return anything.

00:18:15 So if you just do a equals one in the REPL, then that won't return anything in the REPL.

00:18:21 An assignment expression is basically a way of combining the assignment of a value to a variable

00:18:27 and returning the variable back again.

00:18:29 So the reason you would want to do that is in some statements, for example, within list comprehensions,

00:18:36 within while statements, for example, within if statements, The thing in the if statement, the comparison, for example,

00:18:43 you can actually do assignments inside the comparison, and it just removes some additional code that you might have to do.

00:18:51 And also, there's a few other examples in list and dictionary comprehensions

00:18:55 where you can do some fairly smart things inside the comprehension.

00:18:58 Yeah, when I first saw this, I thought, interesting.

00:19:01 I don't know if it's really needed, but I wasn't super against it or anything.

00:19:05 But certainly seeing it in the list comprehension space and seeing it used in other places as well,

00:19:10 I think I'm pretty positive on this language change.

00:19:13 It's pretty nice.

00:19:14 Certainly anytime you need an expression, right?

00:19:17 Within like some kind of comprehension, maybe a lambda or something like that.

00:19:21 Like this often is the only way to, you know, do it.

00:19:25 Like, so if you want to create a variable, but also test it in a list comprehension,

00:19:31 and that might be the response of a function.

00:19:33 Like you can maybe have to call that twice.

00:19:35 Once when you test it and once when you put it into the list, Now you could assign it and then test it, right?

00:19:40 So these things get simpler.

00:19:42 Yeah, they get simpler.

00:19:42 I think looking at the syntax, people's initial responses often, I can't see where I would

00:19:47 use that, but it takes a while for these types of pieces of syntax to become common because

00:19:53 once you know the patterns in which you would use it and you've memorized them and then you

00:19:57 start to use it more and more over time.

00:20:01 This portion of Talk Python To Me is brought to you by Microsoft and Azure Pipelines.

00:20:06 Azure Pipelines is a CI CD service that supports Windows, Linux, and Mac.

00:20:10 It lets you run automatic builds and tests of your Python code on each commit or pull request.

00:20:15 It is fully integrated with GitHub, and it lets you define your continuous integration and delivery pipelines with a simple YAML file.

00:20:21 Azure Pipelines is free for individuals and small teams.

00:20:24 If you're maintaining an open source project, you'll even get unlimited build minutes and 10 concurrent pipelines.

00:20:29 Many Python projects are already using Azure Pipelines.

00:20:32 So get started for free at talkpython .fm slash Microsoft.

00:20:39 And then the second PEP, I guess, changes the language slightly is positional only arguments.

00:20:44 And basically this is PEP 570, which has also been accepted and merged into Python 3 .8.

00:20:51 It wasn't part of alpha 3, so it'll be in the alpha 4 release, I believe.

00:20:55 And basically this one is you add a forward slash in the list of parameters in a function definition so that it says that it's only positional arguments in this function.

00:21:07 The reason for that is basically to protect an API to ensure that people only use positional arguments and they don't start to use them as keyword arguments.

00:21:18 Yeah, it's pretty interesting.

00:21:20 It's like the anti -keyword -only argument one, right?

00:21:24 which, so with the keyword argument one, I don't know that many people actually know about it,

00:21:29 but it's pretty cool.

00:21:30 So if you say, you know, function, parenthesis, star, comma, argument, argument, argument,

00:21:36 those all have to be explicitly called as keyword arguments.

00:21:39 This is like, I want to make it impossible, at least in this section of the parameters,

00:21:45 to call them as keyword arguments, right?

00:21:47 Yeah, it's a cool feature.

00:21:48 And it's also going to help with a lot of the standard library.

00:21:51 That's the other justification.

00:21:52 And there's a lot of the Python standard library where the API needs to be protected so that it can be iterated on,

00:21:59 where this feature is basically going to help lock that down.

00:22:02 And also in 3 .7, there were some improvements to the performance of method calls.

00:22:07 That performance improvement doesn't work with keyword arguments.

00:22:10 I see.

00:22:10 So basically, you could potentially use this as a way of enforcing that performance improvement.

00:22:15 Okay, that's interesting.

00:22:16 The example that I saw, I think if I remember this correctly, was just like range.

00:22:20 Like even just knowing when you see stuff, if you quickly read it, like you could have range and say stop and then start and then step.

00:22:29 Or you could have start and then stop and then step.

00:22:31 Or you could have step and then start.

00:22:32 And just seeing, I mean, even though the words are kind of similar.

00:22:35 And it's going, no, I want you to always just say start and then stop and then step or whatever, right?

00:22:41 Like just requiring them to not have this sort of almost arbitrariness of the order of the parameters seemed like an interesting idea there as well.

00:22:48 Yeah, an additional detail is the fact that, you know, many of the functions that are implemented

00:22:53 in C don't implement keyword arguments. So they're effectively positional only by the sheer fact that

00:23:00 they are just being implemented in C. And this just enables us to express those same APIs in

00:23:06 Python faithfully, so that alternative implementations recreate the API in exactly the same way.

00:23:12 Oh, yeah, that's interesting. So you don't want like the leaky abstraction of the C

00:23:16 implementation to leak out and maybe break PyPy or something like this? Yeah,

00:23:21 so currently, like the issue is actually the opposite, where PyPy does not necessarily care that, you know,

00:23:27 some argument is positional only in CPython. So they allow for keyword use of it. And then

00:23:34 that piece of code is problematic going back to CPython. So that is just, you know,

00:23:39 caring of, you know, making your library code, your application code, sort of exchangeable between runtimes.

00:23:45 Yeah, interesting.

00:23:46 What about Cython?

00:23:47 Cython is its own kind of thing because it's a language that is being compiled

00:23:52 or rather transpiled to a bunch of C or C++, which is then compiled to a C module.

00:23:58 They are kind of free to do a lot of modifications that Python itself is not free to do

00:24:04 because they're compile time modifications.

00:24:06 Right, their transpiler can make the adjustment it needs anyway, right?

00:24:09 Yes, the source code that you're reading is not the source code that is being executed.

00:24:14 interesting all right what's the next PEP that you want to feature you want to talk about let's

00:24:18 cover a few of them and in fact like the slew of peps is uh all related to typing uh let me start

00:24:24 with something old which is PEP 544 protocols so that PEP should have been accepted a long time ago

00:24:31 but it did not because of the governance or situation so protocol is this like kind of like

00:24:37 interface inheritance type of thing like what what's going on protocols essentially is a way to

00:24:44 introduce duck typing to static typing to type checkers so you can have interfaces well or like

00:24:51 protocols they are called protocols across the python documentation too which is why we're using

00:24:55 that name too but you can have essentially implicit interfaces that are being implemented

00:25:00 by a class by a type and then the type checker is able to act on them when you express a need for a

00:25:07 as an argument to a function.

00:25:09 For example, if your function accepts anything that has a read method, now you can express that type.

00:25:16 That's really cool.

00:25:17 I'm super excited about this.

00:25:18 Because if you take two things, like maybe a set and a dictionary, but you want to express,

00:25:23 I'm going to have those types and I want to work with them.

00:25:25 But really all I care about is I can iterate it.

00:25:27 Or that's probably not the perfect example.

00:25:29 But you know, like it's hard to kind of make the type system express that now.

00:25:33 And this just says, well, if it has an add and a pop method, we're good like whatever right that's is that protocols yes

00:25:39 so protocols is the answer like to a question that we've received a lot early on when uh PEP 484 came out like the original

00:25:47 you know formation of static typing for python that isn't static typing in direct opposition

00:25:54 to what we have been telling everybody to do for all those years which is duck typing like if it um

00:26:00 if it quacks like a duck and looks like a duck it is a duck we don't care if this instance is

00:26:05 working. We just care that the calls find the right methods with the right arguments and everything

00:26:12 is fine. So now with protocols, you can actually structurally express this, that all you care about

00:26:18 is a given field or a given method.

00:26:20 I like it. I know you're a proponent of type hints and mypy and all that kind of stuff. How do you see the state of that these days?

00:26:27 Well, we're definitely on the rise there. At my time at Instagram and at Facebook,

00:26:34 we've seen a lot of improvements, both in terms of security, you know, a team velocity, and as well,

00:26:41 just being able to comprehend the source code when types were introduced to the biggest PHP

00:26:48 component of facebook .com. And so since, I guess, 2013, I wanted to see something similar in Python.

00:26:56 So like pep484 came out, you know, soon enough, Python 3 started getting adopted more and more. And,

00:27:02 And this is when annotations, which are the nice way to express types, have been gaining adoption.

00:27:09 And these days, from what I've heard at the conference now, 90 % of functions in the Instagram code base, which is north of 2 million lines of code at the moment, is covered in types, which is amazing.

00:27:23 That is a big achievement.

00:27:25 So definitely, this trend is on the rise, which I am very happy about.

00:27:30 Yeah, that's awesome.

00:27:31 Anthony, what are your thoughts on type hints, type annotations?

00:27:34 And do you like them?

00:27:35 Have they changed your code?

00:27:36 Do you use them?

00:27:37 I actually use them very rarely.

00:27:39 In 3 .7, there's the type annotations, the delayed evaluation type annotations.

00:27:45 Yeah, it's gotten a little nicer in that way.

00:27:46 In 3 .7, which makes it a bit easier in terms of what you have to import and when.

00:27:51 But the only reason I use them seldomly is because I mainly work on libraries which I publish to PyPI,

00:27:58 which are used by people who have Python 3 .5, 3 .6, and some 2 .7 as well.

00:28:04 So I really have to cover the lowest common denominator when it comes to users

00:28:08 because they're mainly utility libraries that I work on, not sort of single deployment applications.

00:28:15 Yeah, or something like Black that doesn't really get consumed directly,

00:28:19 but it's more executed, right?

00:28:21 Like Black or pytest or something.

00:28:22 Yeah, interesting.

00:28:23 What's the next one?

00:28:24 All right, so the next PEP would be PEP 585 that I actually wrote.

00:28:30 Well, it's still in draft form.

00:28:32 So to kind of set the stage for the PEP, what Anthony said is like there's plenty of cases

00:28:37 where currently typing that was added rather carefully to the language requires you to

00:28:44 import names that you're later using as types.

00:28:47 There's some situations where you are introducing names to your global scope just for type aliasing

00:28:53 or to introduce type variables.

00:28:56 Right.

00:28:56 For example, if you've got a function and you want to say its return type is this

00:29:00 object, you now have to import at the top.

00:29:02 If you had never actually had that part called, maybe it would have never been imported until lazily.

00:29:07 There's changes in behavior because of that, right?

00:29:10 Yeah, this is often problematic, right?

00:29:12 Like what is even more like just cumbersome for the user is that there is plenty of either built -in types

00:29:18 or abstract -based classes that have their equivalents in the typing module,

00:29:23 meaning if you want to express that some argument is a list of string, you have to import an uppercase list from the typing module

00:29:30 and say uppercase list of string.

00:29:33 And I always found that clumsy, right?

00:29:35 I always found that it is something new that you have to explain to new programmers that are first interacting with typing.

00:29:43 And there's not really a great reason for that.

00:29:45 We wanted the actual lowercase list to be orthogonal and not know anything about the static typing concept,

00:29:53 which is mostly used by an external type checker.

00:29:56 It does not have a big runtime component.

00:29:59 It does have a little, right?

00:30:00 Because you can inherit from generic types.

00:30:02 So you can actually create your own data structure where you say that this is, I don't know,

00:30:07 a collection of types T, right?

00:30:10 So that this is a possibility.

00:30:12 But for very many cases, this runtime component is just a hindrance.

00:30:16 It's something that you have to remember to import.

00:30:18 The names look different because they're uppercase and lowercase.

00:30:22 They might look exactly the same in form of set, but they actually mean something else

00:30:26 now.

00:30:27 Because the point being, so that's the first issue.

00:30:30 And the second issue is that this is something that sits in memory, right?

00:30:34 This is something that you spend time on when you're starting up your program.

00:30:38 So I always felt like this is something that we can maybe live without.

00:30:43 Hence PEP 563, which actually postpones evaluation of annotations.

00:30:48 That was introduced in Python 3 .7.

00:30:50 And stemming from that, you know, having that foot in the door that like now the annotations

00:30:56 are not evaluated anymore, we can regain some of the usability that people expect just by

00:31:02 the fact that this can be still valid Python syntax, but it doesn't have to be valid at

00:31:06 runtime.

00:31:07 So we can get away without importing things from typing.

00:31:11 You know, the type checker will know exactly what you mean anyway, right?

00:31:14 We can come back to using a lowercase list of string instead of uppercase list of string

00:31:20 And a few other things.

00:31:22 You still do the bracket of string?

00:31:24 Yes, yes.

00:31:24 But on the lowercase list type?

00:31:25 Yeah, so we will never do pointy brackets for that, like in Java or C++,

00:31:32 because our LL1 parser is unable to deal with that case.

00:31:37 Maybe if we switch to a different one, of which there is discussion, maybe then that would be possible.

00:31:42 But at that point, it will still be way too late.

00:31:45 Yeah, I think it's fine the way it works.

00:31:47 It's different, but it's just totally...

00:31:48 It's different, but it's a way of expression.

00:31:50 There's nothing that makes the angle brackets in templates or generics necessarily the right way, yeah?

00:31:56 Yes, exactly. It's like as long as humans understand what those things mean, the goal has been achieved.

00:32:03 So yeah, the rest of the PEP 585 is just an attempt to reform some of the pre -existing constructs in the typing module,

00:32:13 like creating new types, casting, aliasing, or type variables into variable annotations so that they are also not evaluated at import time,

00:32:23 which enables, again, usage of types that are not imported and some of those tricks with syntax like lowercase list and dict and whatnot.

00:32:31 So that's 5 .8 .5.

00:32:34 While we're on this performance and type annotations and stuff, what's the story of mypyC?

00:32:40 Oh, this is actually a very interesting story.

00:32:42 So mypy has traditionally been slow, to the point where running it over the entire Instagram code base

00:32:50 was taking over five minutes, right?

00:32:53 So this was a thing that you could do in continuous integration, but you could not absolutely run it

00:32:58 in an editor or whatnot.

00:32:59 We had some hacky workarounds to at least make people in the editors happy.

00:33:04 I wrote a silly flake 8 mypy plugin at some point that kind of brought us somewhere

00:33:09 it was useful for a while.

00:33:11 But all of that was just not very great.

00:33:13 So in the meantime, mypy started implementing incremental typing, meaning the graph of your modules, which did not change,

00:33:21 can be cached so that with every change, like most of your computation is already pre -done.

00:33:27 And that is evolving to this point now.

00:33:30 With well -populated cache, that cuts the time to around 40, 50 seconds.

00:33:34 So it's like a six, seven times improvement.

00:33:37 Yeah, it's a big improvement.

00:33:39 So that's good.

00:33:40 but still the cold type checking was like rather slowish.

00:33:43 In the meantime, Facebook started developing its own type checker for Python.

00:33:47 Well, more with the goal of creating a static analysis tooling that just uses types.

00:33:52 So the type checker part was only the base of the static analysis that was being performed

00:34:00 on that very code with the important use case of doing security checks.

00:34:06 And one of the goals of that, you know, new type checker was like, we have to be faster

00:34:11 than mypy, right?

00:34:12 Yeah.

00:34:12 Like, so that created competition and competition is always good.

00:34:15 So in the meantime, like, Yuka Lektostalor, like, revived his original idea that, hey,

00:34:20 if we have types, we can actually try to compile the Python code in a way that runs it way faster

00:34:28 now.

00:34:28 What does it compile to?

00:34:29 So that's interesting, right?

00:34:31 So the mypyC compiler actually creates a C extension.

00:34:36 It actually transpiles to C.

00:34:38 This sounds weird until you think about the C API that Python provides.

00:34:43 And the Python C API is meant to be consumed by C.

00:34:46 So it is just natural that you would have a generator that emits valid C for your given use case.

00:34:52 And it turns out that with just a few constraints on how your program works,

00:34:57 you can achieve 20 to 30 times performance boosts with that.

00:35:02 So that's great.

00:35:03 And in a real production application like mypy, it's consistently four times faster.

00:35:11 This portion of Talk Python is sponsored by Microsoft and Visual Studio Code.

00:35:15 Visual Studio Code is a free, open -source, and lightweight code editor that runs on Mac,

00:35:20 Linux, and Windows with rich Python support.

00:35:22 Download Visual Studio Code and install the Python extension to get coding with support

00:35:26 for tools you love like Jupyter, Black Formatting, Pilot, pytest, and more.

00:35:30 And just announced this month, you can now work with remote Python code bases using the new Visual Studio Code remote extensions.

00:35:38 Use the full power of Visual Studio Code when coding in containers, in Windows subsystem for Linux, and over SSH connections.

00:35:45 Yep, that's right. Auto completions, debugging, the terminal, source control, your favorite extensions.

00:35:50 Everything works just right in the remote environment.

00:35:53 Get started with Visual Studio Code now at talkpython .fm slash Microsoft.

00:35:59 Do you see use cases for that outside just mypy, like random person doing data science

00:36:05 that needs their Python parts to go faster?

00:36:08 Currently, mypyC tries to limit their scope since they perceive the attempts by previous

00:36:15 projects that meant to speed up Python.

00:36:18 Those attempts failed mostly on trying to be 100 % compatible with every single feature

00:36:24 of Python.

00:36:25 So they're focusing on a subset.

00:36:27 but they're growing that subset as much as they needed.

00:36:31 And the big missing piece currently is there is no async await support.

00:36:36 And with that support, I could actually have black compiled, which could also

00:36:41 significantly speed up the formatter, which is already pretty performance, already does pretty well.

00:36:48 But that would just make it so much better for the users.

00:36:50 So in fact, I think I managed to get Sully, the core developer of mypyC,

00:36:56 rather excited about the prospect of having Black as the next production customer of MyPayC. So we'll

00:37:04 see. I have my fingers crossed. Yeah, that's exciting. All right, Anthony, what's the next

00:37:08 one on our list of cool features in 3 .8? So this one is actually still in draft. It hasn't actually

00:37:13 been decided and potentially might be deferred to a later release if it gets accepted. But when I've

00:37:19 talked about features, at least proposed preps, this one gets quite a bit of attention and they're

00:37:24 runtime audit hooks. And basically the PEP is a way of setting a callable when certain

00:37:32 system methods within the Python standard library get called. For example, opening a network socket

00:37:38 or requesting a URL or opening a file or lots of different cases, I guess, of sort of low -level

00:37:45 standard library functions or methods. When they get called, then you get notified.

00:37:50 That's super cool. So like if for some reason I'm in a lockdown environment, I want to use some package or write some app and it's, we think it's not talking to the network or the file system, but it turns out all of a sudden it's opening sockets or DNS stuff. That might be something to inspect.

00:38:08 Yeah. So potentially you could lock down a Python distribution or a Python process to not be able to open certain URLs or open network sockets under certain circumstances.

00:38:19 And it's cool. So with the hooks, do I get to say, I saw what you did and okay, or I saw what you did and no, you don't get it. Is it like a place to stop it?

00:38:28 Yeah. The default is just as an FYI. But if you wanted to raise a runtime error or something else in line, then it would actually stop the request through to the function.

00:38:40 That's pretty awesome. I think this is pretty interesting. I know there's some restricted environments and even like app stores and stuff that maybe it would be cool to package this up and use it. So yeah, definitely nice. Lucas, what do you think about this one?

00:38:51 Well, I actually think this is very important. If you ever worked for a break on an organization, very often the audit trail of what actually happened is important, not just for security reasons. Very often, cascading errors that end up with an entire site being down are very hard to foresee.

00:39:09 like you know the very easy to make mistakes or like long fix they're all patched like you know

00:39:16 there's not a big red switch that if you just press the button you know the site goes down it's

00:39:20 very often something that it was hard to you know combine and having the trail of oh this happened

00:39:27 first and then another thing happened later like that is very valuable so i see this feature not

00:39:33 only as a security feature but as just you know like a post -mortem kind

00:39:37 of feature as well that's Anthony, do you envision this might enable a different set of tooling?

00:39:44 We have visual debuggers now.

00:39:46 Could you maybe have other types of analysis and tooling and whatnot?

00:39:51 Yeah, in terms of tooling, I guess there's a lot of things in the standard library that you might want to add hooks in.

00:39:57 And also an easy way of putting hooks into additional modules as well.

00:40:01 And then having people to catch those and deal with those separately.

00:40:04 I can definitely think of a few examples of libraries, deserialization libraries, not naming any specifically, that have …

00:40:13 Rhymes with sickle?

00:40:15 That have security backdoors, just in terms of the way they work.

00:40:19 So unless you explicitly specify to load it with a safe mode, then you can actually run …

00:40:25 That was a different one, a different rhyme maybe.

00:40:27 Oh, okay.

00:40:27 Yeah, XML as well is another one.

00:40:30 Yeah, yeah.

00:40:30 There are sort of known, I guess, security backdoors in certain libraries,

00:40:35 and basically this could be a way of protecting against those.

00:40:37 Okay, yeah, that's great, because it should not be doing these operations while loading this file.

00:40:42 Yeah, if you're loading a YAML file or an XML file, it shouldn't be opening network sockets.

00:40:48 Yeah, probably not, or issuing sub -process commands or any of these not -so -lovely things.

00:40:55 All right, Lucas, what's next on our list?

00:40:57 I would like to just say that there's quite a few peps are still in draft form and the authors have like an entire four more weeks in which they can decide

00:41:05 to finish their PEP and publish it so things might change but the ones that i'm like personally

00:41:09 interested in is always of course typing so let me just cover two more like the first one is pep

00:41:16 586 so that's literal types and second one is 589 which is typed dict both of them are kind of an

00:41:23 example of you know our type system kind of starting uh conservatively and then growing

00:41:29 based on need, right?

00:41:30 So literal types are very interesting because there are a bunch of calls

00:41:34 where the behavior, like the return type or the cascading other arguments

00:41:40 that you're going to use in the function depend not on the type of an argument,

00:41:45 but on the actual value that you are passing.

00:41:49 Like a positive integer, negative integer, something like this, or what?

00:41:52 So parametric types are kind of hard, but what we're doing with literal types

00:41:55 is something like the open built -in.

00:41:58 Like with the open built -in, you have a certain number of modes, right?

00:42:01 And depending on whether you're saying RB or R, the resulting IO is either bytes or strings.

00:42:08 And currently, there is certain hackery both in mypy and Pyre to just, you know, work around this.

00:42:14 But it would be good if the actual type system supported this feature.

00:42:18 So literal is all about being able to express those types so that if you pass none here, it's going to behave differently.

00:42:26 If you pass on string here, it's going to behave differently if that string is RB or is WB or is R and so on and so on.

00:42:36 So that's literal types.

00:42:38 There's some very, very interesting edge cases and deep thought in that PEP.

00:42:44 It is surprisingly long and complex.

00:42:46 I'm not going to go into this now.

00:42:48 The other one is though, type dict.

00:42:51 Originally, dictionaries have been envisioned in the static typing as, oh, there's this key value store.

00:42:59 So there's keys of a certain type and there's values of a certain type.

00:43:03 What happens in practice is that a lot of pre -existing Python applications do not use named tuples,

00:43:09 do not use adders or data classes, which are very new.

00:43:13 So instead, they use kind of lightweight classes in the form of dictionaries that have keys and values of various types.

00:43:23 So there can be name, which is a string, but there can be a birth year, which is going to be an int, right?

00:43:30 And based on the actual name of that key, you're going to have different types.

00:43:35 So that was very cumbersome to express in the previous form.

00:43:40 Almost like a schema, yeah.

00:43:42 Yes, it's like very much like schemas.

00:43:44 So now like there is a way to describe a type dictionary in the form of like a data class -like type,

00:43:52 like where you just express it like, you know, class -like saying, this dictionary is going to have keys that are like this,

00:43:58 and this key is going to be a string, this other key is going to be an int.

00:44:03 That solves already a lot.

00:44:04 But like then the interesting part is when those things start nesting.

00:44:09 That actually enables you to construct like rather complex schemas that can be used directly in JSON or, you know, in other forms of serialization.

00:44:18 So that PEP alone is also very useful in practice.

00:44:21 Even though you could just say like people are doing it wrong, they should be using, you know, name tuples or other forms of typing instead.

00:44:27 Well, you kind of have to be pragmatic, you know, like you see pre -existing valid

00:44:32 use cases of this and you have to just adhere to those.

00:44:35 Yeah, interesting.

00:44:36 I guess since you're really into typing and you're on the core dev side of things, what do you think about libraries, especially I'm thinking of like web frameworks that use typing for like serialization and stuff?

00:44:51 So like Molten, for example, you can have a class that has fields, but also those fields have types.

00:44:59 And then you say this web function takes this class, but it's like really a form submission.

00:45:05 and it'll like convert stuff to integers or like validate against the types.

00:45:09 Is that in your mind awesome or is that an abuse of the type system?

00:45:13 So this is interesting, right?

00:45:14 Because obviously as long as the type system is kind of an extension of the type system

00:45:20 we're using for type checking, or maybe it's even exactly the same, like that is using a

00:45:24 shared vocabulary.

00:45:25 That's great.

00:45:26 Like, you know, we support that.

00:45:27 Like we would wish to see type hints in more places.

00:45:31 In fact, in 3 .7, I extended single dispatch so that now you can just use annotations on arguments instead of saying, you know, register off and like you can just say register and using the annotations of the first argument, it'll behave like, you know, as you expect.

00:45:48 So you can use type annotations at runtime for whatever you want, as long as the type

00:45:54 system is kind of, you know, the same with what we're using it for.

00:45:58 Some use cases use annotations, function annotations in incompatible ways.

00:46:03 And that creates issues because an increasing amount of tooling like Visual Studio Code,

00:46:08 you know, PyCharm and whatnot, like gets confused by seeing something that, you know, is clearly

00:46:13 not a type in the place where types are expected.

00:46:16 So I kind of, yeah.

00:46:17 Yeah, an example of that.

00:46:19 So this example I gave you with Moulton seems like it's consistent.

00:46:22 The type checker says it takes an int.

00:46:24 It's actually an int at runtime.

00:46:26 But I can't remember, but some of the other frameworks, maybe REST frameworks,

00:46:30 they would say like you could say that this parameter is a header.

00:46:34 And what it actually is the string value with that name out of the header.

00:46:39 It's like the value comes from the header.

00:46:40 But at runtime, it's not a header.

00:46:43 It's not a dictionary.

00:46:43 Whatever the header is, it's actually a string or an int or something.

00:46:47 Yeah, I see.

00:46:47 It seemed like it was really cool and clever, but also like incongruent with what Python intended.

00:46:52 A certain amount of those things like our valid use cases, like let's say in the case of adders,

00:46:58 adders like create valid classes for you from minimal information that you provide in source code.

00:47:05 So this class is being fully functional at runtime.

00:47:09 However, the type checker does not know this.

00:47:12 It just sees like just some magic decorator and just this minimal set of attributes on it.

00:47:17 And it does not know that a certain amount of built -in methods have been created

00:47:23 and a certain amount of functionality within it and whatnot has been added.

00:47:27 So at least in the case of mypyEmpire, additional functionality had to be implemented in those type checkers

00:47:34 to understand that those types actually behave a bit differently from regular classes.

00:47:40 But that's just something that users want, something that users need.

00:47:43 And so based on that, we're going to be extending that.

00:47:46 All right, cool, cool.

00:47:48 Anthony, what do you got next on our list here?

00:47:49 There's actually everything we have for 3 .8.

00:47:51 All right, so ship it, we're good?

00:47:53 Yeah, I think we're done now.

00:47:54 So actually that PEP in particular, the type dictionary PEP, I've been thinking if anyone's in the JSON schema project,

00:48:01 it's really cool.

00:48:02 It's basically a way of defining a schema for JSON documents.

00:48:07 You can definitely see that if this PEP gets accepted, somebody will build tooling to integrate between the JSON schemas and this new type dict type.

00:48:16 Yeah, and it makes perfect sense.

00:48:17 I mean, dictionaries are so similar to JSON in a sense, and they both have this sort of dynamicness but mixed types.

00:48:24 I mean, they're very, very sort of mappable, yeah?

00:48:27 Yeah, so I think it's just a matter of time until someone builds a library

00:48:30 where you give it a JSON schema and it will generate a type dict class, and then you use that class.

00:48:35 Similar in the same way that you in an ORM, when you would describe like a data class,

00:48:41 and then you would deploy it as a database.

00:48:43 It's basically like a similar way of reflecting documents.

00:48:46 That's cool.

00:48:46 I can definitely see it for serialization.

00:48:48 Like you say, this function takes a type dict, but what actually it is a form post or a JSON post

00:48:54 or like a REST call or something like that.

00:48:56 That's cool.

00:48:56 So let's see.

00:48:58 Did we talk about multiprocessing?

00:49:00 Is that coming in 3 .8 or is that beyond?

00:49:02 That's in 3 .8.

00:49:03 So one particular thing that is not PEP -worthy, but it's still a very interesting new feature

00:49:08 is that traditionally multiprocessing, which has been created to solve the gil problem,

00:49:14 has solved it partially.

00:49:16 What I mean by this is that, yes, there is a master process that creates a bunch of children

00:49:21 and then delegates work to it.

00:49:23 So you can just call Python functions and those Python functions actually are executed

00:49:28 on the other side in the child process.

00:49:30 But the way this is achieved was that function call has been pickling the arguments of the function you're calling.

00:49:38 That ended up being on the child side.

00:49:41 That child unpickled the arguments.

00:49:43 It did the computation it needed.

00:49:45 And then if there was a return value it wanted, it actually had to pickle that return value again and pass it back to the master process.

00:49:52 And the master process unpickled the return value again.

00:49:55 And if that's big, it's very slow, for example.

00:49:57 Exactly.

00:49:57 So like for small things, that was mostly fine.

00:50:00 But if you had like a gigantic haystack and you were looking for a needle in it, just, you know, pickling that haystack was taking.

00:50:08 And then I'm picking on the other side was taking a lot of time.

00:50:11 We were going to run that on all six cores.

00:50:13 So here's six copies of our like 10 megabyte, whatever.

00:50:17 That is actually annoying because like if you had like a master process that say it gets web requests, right?

00:50:24 In the time that you're spending on pickling that haystack, nothing else can be actually done in Python because the gil is still there on that master process.

00:50:35 So you are solving the gil problem only partially.

00:50:38 So now multiprocessing introduces this new fantastic feature where you can declare a shared memory segment and share that memory between parents and children.

00:50:50 What that does is you can actually get away with a lot of serialization and deserialization.

00:50:57 So for certain kinds of tasks like search, like filtering, this will decrease the churn just needed to pass data around.

00:51:06 Meaning it will bring us way closer to the world we want to see, which is that, yes, there are certain Python processes.

00:51:13 They still have the gil, but it does not matter because we can use as many of those processes as we have cores and everything is fine.

00:51:19 Yeah, and you don't have the replication of memory and the copying and all that.

00:51:22 That's awesome.

00:51:23 Yes.

00:51:23 So I'm really excited when I saw that come out.

00:51:25 I'm like, oh, this is going to be great.

00:51:26 So that's in 3 .8?

00:51:27 Yes, that is already in.

00:51:28 Cool.

00:51:29 And what about the subinterpreter 5 .5 .4?

00:51:33 That's beyond?

00:51:34 Oh, so that's interesting.

00:51:35 That is kind of related.

00:51:36 Yeah, they're in the same category of things.

00:51:38 Yes, however, the multiprocessing feature does have limitations, right?

00:51:42 Like the shared memory segment is not right for any arbitrary Python object.

00:51:47 There's like, you know, restrictions on what types you can use.

00:51:50 That was actually a complex functionality to be added, you know, within particular operating

00:51:55 systems, shared memory handling is way different.

00:51:57 So you have to understand how those differences work and which process is now responsible for

00:52:03 creating that shared memory segment and shutting it down and freeing that memory when everything

00:52:08 is, you know, shutting down.

00:52:09 So that is all great work by Davin Potts.

00:52:12 Like, multiprocessing is one thing, but subinterpreters is what if you had this multiprocessing API and actually just had one process and just used many Python interpreters within it, each with its own gil.

00:52:25 To achieve that, many changes in the Python C API have to be added.

00:52:28 Like, you know, a much cleanup internally in terms of what constitutes local and what constitutes global state have to be done.

00:52:36 Eric Snow is working hard on that.

00:52:38 As far as I can tell, this is deferred to Python 3 .9.

00:52:42 I'm eagerly awaiting that.

00:52:43 I think this is going to be a great improvement.

00:52:45 Yeah, it could definitely change the threading story.

00:52:48 In multipress processing strong in Python, async await is super cool for IO bound stuff.

00:52:55 But threads have always been a kind of, well, sometimes they're helpful, sometimes they're not.

00:52:59 It depends.

00:53:00 And this could be awesome, right?

00:53:01 You could just dedicate a sub -processor, a sub -interpreter, excuse me, to each thread, right?

00:53:06 And really get free of that.

00:53:08 I agree.

00:53:08 Cool.

00:53:08 All right. Well, thank you both for sharing what's coming. Pretty excited about 3 .8.

00:53:15 Cool. That was a pleasure.

00:53:16 Yeah, it's going to be great.

00:53:17 Yeah. And on that topic as well, I guess we've got 3 .9. So, some of the PEPs are being deferred

00:53:22 to 3 .9. And on the topic of sub -interpreters, the unpacking of the startup sequence,

00:53:27 and also the initialization configuration, there's two proposals for that. One is PEP 4 .3 .2,

00:53:33 and the other's PEP 587, which are interrelated because if you have sub -interpreters,

00:53:38 you want the interpreter startup time to be fast and also the configuration to be flexible.

00:53:43 So I think 3 .9 will definitely see some more proposals related to that.

00:53:49 Awesome.

00:53:49 Which are going to hopefully improve the startup time of Python 3.

00:53:53 As we know, it's a little behind where Python 2 was for various reasons, but that'll be a great step forward.

00:53:59 Yeah, that'd be really awesome.

00:54:00 And then it also might make this sub -interpreter stuff better if those little sub interpreters can get created faster as well. I don't know how related

00:54:07 they are, but pretty cool. Pretty cool. All right. One, we used up almost all our time,

00:54:12 so I won't keep you guys much longer, but especially Lucas, let me ask you this, like,

00:54:16 will there be a Python four and does it matter? I mean, on one hand, like we've got stuff that's

00:54:21 0 .1, two versions that have been around for 10 years with a hundred releases. We've got Python

00:54:28 three. If we don't have like major breaking changes, is there a reason to start calling it

00:54:32 four and five and six, or is that just going to like scare people with the history or like,

00:54:37 what do you, what's your perspective here?

00:54:38 We are at Python 3 .8 now. We're about to release 3 .9 later, you know, another 18 months later. Historically, Guido expressed his distaste with

00:54:49 numbers after the decimal point that have more than one digit. And so he disliked the notion of

00:54:57 having 2 .10, 2 .11, and same with 3 .10, 3 .11. However, we have both philosophical and technical

00:55:05 challenges with just releasing a Python 4. Well, the obvious philosophical one is that

00:55:11 the transition between Python 2 and Python 3 was very, very challenging, right? It took us a lot

00:55:16 of effort. And there's a lot of fatigue, I think, in the community to just not go through that again

00:55:21 for a while. Absolutely. Our closets are still full of skeletons. So we are really trying hard

00:55:28 not to make that mistake again. It's not only a problem for the users, it was also unpleasant and

00:55:34 a problem for the core developers. So we are really careful to make changes in a very incremental

00:55:40 manner now and communicate them well and make them gradually so that we are disrupting our users

00:55:46 the least, which just means calling something Python 4, well, would probably be just scary on

00:55:53 its own, just on the power of that number. But just more practically speaking, because of this

00:55:58 Python 2 and 3 transition, there is a ton of code in the wild that does checks exactly for the number

00:56:04 3 in sys version, version info. And those checks would, you know, become invalid if we introduced

00:56:11 python 4 like which is one of the reasons why you know like Linux had problems when it suddenly

00:56:17 became Linux 3 and why we have windows 10 now just for that practical reason i do expect that we're

00:56:24 gonna see python 3 .10 first at least before we ever decide to call the next release python 4 yeah

00:56:31 yeah so 3 .10 is way more likely maybe we should call it python 6 because then it's like two times three

00:56:37 Well, I was wondering if there's a proposal to introduce calendar versioning to Python.

00:56:41 Oh, yeah.

00:56:41 What do you think about calendar versioning?

00:56:43 If Python 2 .7 was called 2014 .1, then maybe people would reconsider.

00:56:48 Really?

00:56:49 2014?

00:56:50 What's up here?

00:56:50 We just upgraded from 2013.

00:56:53 It would certainly remind people how old their Python distribution is.

00:56:55 So maybe they'll upgrade faster.

00:56:58 That's funny.

00:56:58 Well, I'm in no power to just make that change.

00:57:02 I could be in power to create a PEP about it.

00:57:04 but this is probably not a sword I'm willing to fall on.

00:57:08 However, let me tell you this, all of my private projects do use calendar versioning.

00:57:13 That's the only versioning that I am familiar and comfortable with.

00:57:16 There's obviously semantic versioning, but I don't know about others, but at least I don't see myself being as strict

00:57:23 and consistent with applying semantic versioning every time.

00:57:26 What does it mean to push the major version versus minor version?

00:57:29 Yes, so obviously there's rules, but the devil is in the application.

00:57:33 Do you apply those rules consistently and every given time?

00:57:37 I wrote an auto formatter because I was not able to apply rules of code styling consistently and every time.

00:57:44 So I don't trust myself enough to do the same for semantic versioning.

00:57:48 And if I'm not doing that, then my users cannot depend on what they expect from semantic versioning.

00:57:53 Hence, just using calendar versioning is way easier, adopted by many popular projects like Ubuntu, like Twisted, like others.

00:58:01 Yeah, I love the calendar versioning.

00:58:02 I don't know that it makes sense for like the main Python.

00:58:05 Maybe, maybe it does, maybe it doesn't.

00:58:07 It would be effective on showing how old some stuff is.

00:58:10 But certainly I feel like semantic versioning requires, like on libraries, it requires some expertise in that library.

00:58:17 Like I depend on library A.

00:58:20 It depends on library B.

00:58:21 I see that when I pip installed it, it's 0 .1 .3.

00:58:26 Six months later, is that out of date?

00:58:28 I have no idea.

00:58:29 Like I don't even know like roughly how old that is.

00:58:32 But if I saw the calendar version on all the dependencies or stuff I'm not super familiar with, I'd be like, oh, yeah, this is actually, this is pretty much new or it's old.

00:58:40 Like, it just, it makes it easier for newcomers, I think.

00:58:43 Yeah.

00:58:44 All right, guys.

00:58:44 Thank you for being on the show and sharing all this and looking forward to when you actually release 3 .8.

00:58:48 I'm looking forward to that, too.

00:58:50 Thank you very much.

00:58:50 I can imagine.

00:58:51 Thanks, Michael.

00:58:51 Yeah, bye.

00:58:53 This has been another episode of Talk Python to Me.

00:58:56 Our guests in this episode have been Lucas Lenga and Anthony Shaw.

00:59:00 And it's been brought to you by Microsoft.

00:59:02 If you're a Python developer, Microsoft has you covered.

00:59:05 From VS Code and their modern editor plugins, to Azure Pipelines for Continuous Integration,

00:59:10 and serverless Python functions on Azure.

00:59:13 Check them out at talkpython .fm slash Microsoft.

00:59:17 Want to level up your Python?

00:59:19 If you're just getting started, try my Python Jumpstart by Building 10 Apps course.

00:59:24 Or if you're looking for something more advanced, check out our new async course that digs into

00:59:28 all the different types of async programming you can do in Python. And of course, if you're

00:59:33 interested in more than one of these, be sure to check out our everything bundle. It's like a

00:59:37 subscription that never expires. Be sure to subscribe to the show, open your favorite podcatcher

00:59:42 and search for Python. We should be right at the top. You can also find the iTunes feed at slash

00:59:47 iTunes, the Google Play feed at /play and the direct RSS feed at /rss on talkpython .fm.

00:59:54 This is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it.

00:59:58 Now get out there and write some Python code.

