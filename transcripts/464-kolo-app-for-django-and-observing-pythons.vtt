WEBVTT

00:00:00.001 --> 00:00:02.100
Do you want to look inside your Django requests?

00:00:02.100 --> 00:00:06.400
How about all of your requests in development and see where they overlap?

00:00:06.400 --> 00:00:10.140
If that sounds useful, you should definitely check out Colo.

00:00:10.140 --> 00:00:13.100
It's a pretty incredible extension for your editor.

00:00:13.100 --> 00:00:16.660
VS Code at the moment, more editors to come most likely.

00:00:16.660 --> 00:00:19.920
We have Wilhelm Klopp on to tell us all about it.

00:00:19.920 --> 00:00:25.000
This is Talk Python in May, episode 464, recorded May 9th, 2024.

00:00:25.000 --> 00:00:27.940
Are you ready for your host, here he is!

00:00:28.160 --> 00:00:31.380
You're listening to Michael Kennedy on Talk Python to Me.

00:00:31.380 --> 00:00:35.140
Live from Portland, Oregon, and this segment was made with Python.

00:00:35.140 --> 00:00:41.320
Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:41.320 --> 00:00:43.060
This is your host, Michael Kennedy.

00:00:43.060 --> 00:00:45.720
Follow me on Mastodon, where I'm @mkennedy,

00:00:45.720 --> 00:00:50.540
and follow the podcast using @talkpython, both on fosstodon.org.

00:00:50.540 --> 00:00:55.640
Keep up with the show and listen to over seven years of past episodes at talkpython.fm.

00:00:56.000 --> 00:00:59.440
We've started streaming most of our episodes live on YouTube.

00:00:59.440 --> 00:01:06.980
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.

00:01:06.980 --> 00:01:09.500
This episode is sponsored by Sentry.

00:01:09.500 --> 00:01:11.480
Don't let those errors go unnoticed.

00:01:11.480 --> 00:01:12.360
Use Sentry.

00:01:12.360 --> 00:01:15.440
Get started at talkpython.fm/sentry.

00:01:16.220 --> 00:01:20.060
And it's also brought to you by us over at Talk Python Training.

00:01:20.060 --> 00:01:24.680
Did you know that we have over 250 hours of Python courses?

00:01:24.680 --> 00:01:25.860
Yeah, that's right.

00:01:25.860 --> 00:01:28.440
Check them out at talkpython.fm/courses.

00:01:28.440 --> 00:01:31.800
Well, welcome to Talk Python to Me.

00:01:31.800 --> 00:01:32.200
Hello.

00:01:32.200 --> 00:01:33.320
Yeah, excited to be here, Michael.

00:01:33.320 --> 00:01:36.220
I've been listening to Talk Python like for, I can't even remember how long,

00:01:36.220 --> 00:01:38.820
but I'm pretty sure it was before I had a first Python job.

00:01:38.820 --> 00:01:40.940
So, yeah, a long, long time.

00:01:41.460 --> 00:01:42.280
That's amazing.

00:01:42.280 --> 00:01:44.280
Well, now you're helping create it.

00:01:44.280 --> 00:01:44.920
Yeah, exactly.

00:01:44.920 --> 00:01:49.320
We're going to talk about Colo, your Visual Studio Code, Django.

00:01:49.320 --> 00:01:50.900
I don't even know what to call it.

00:01:50.900 --> 00:01:52.680
It's pretty advanced, pretty in-depth.

00:01:52.680 --> 00:01:54.760
Extension seems to be not quite enough.

00:01:54.760 --> 00:01:56.340
So, what any project?

00:01:56.340 --> 00:01:58.740
People are going to really dig that, people who Django.

00:01:58.740 --> 00:02:04.920
And we'll see what the future plans are if we can talk you into other ones.

00:02:04.920 --> 00:02:06.400
But for now, Django plus...

00:02:06.400 --> 00:02:07.100
100%.

00:02:07.100 --> 00:02:09.880
Yeah, Django plus VS Code is going to be super interesting.

00:02:09.880 --> 00:02:12.820
When we get to that, of course, you must know the drill.

00:02:12.820 --> 00:02:13.880
Tell us a bit about yourself.

00:02:13.880 --> 00:02:14.600
Yeah, for sure.

00:02:14.600 --> 00:02:15.780
So, my name is Will.

00:02:15.780 --> 00:02:18.120
I've been using Django since...

00:02:18.120 --> 00:02:22.420
Well, I guess I've been using Python since about 2013, I want to say.

00:02:22.420 --> 00:02:23.940
So, a little over 10 years.

00:02:23.940 --> 00:02:26.980
And, yeah, I just kind of fell in love with it.

00:02:26.980 --> 00:02:28.240
Wanted to make websites.

00:02:28.240 --> 00:02:29.420
Started using Django.

00:02:29.420 --> 00:02:32.200
And, yeah, I guess never really looked back.

00:02:32.200 --> 00:02:34.340
That was in school back then.

00:02:34.340 --> 00:02:38.140
But kind of always had a love for tinkering and building side projects.

00:02:38.140 --> 00:02:39.860
I actually studied...

00:02:39.860 --> 00:02:41.300
I did a management degree in university.

00:02:41.300 --> 00:02:44.480
But I really loved hanging out with all the computer science kids, all the computer science

00:02:44.480 --> 00:02:44.820
students.

00:02:44.820 --> 00:02:47.560
And I think a part of me really wanted to impress them.

00:02:47.560 --> 00:02:49.380
So, I was always building side projects.

00:02:49.380 --> 00:02:52.640
And one of them was actually a Slack app called Simple Poll.

00:02:53.040 --> 00:02:57.280
And, yeah, we were trying to, like, organize something in Slack and really felt like the

00:02:57.280 --> 00:02:57.900
need for polls.

00:02:57.900 --> 00:03:00.960
So, built this little side project just, like, during university.

00:03:00.960 --> 00:03:02.800
And then it became really, really popular.

00:03:02.800 --> 00:03:06.300
And a few years later, it became my full-time job.

00:03:06.300 --> 00:03:08.020
So, for the past, like...

00:03:08.020 --> 00:03:08.300
Awesome.

00:03:08.300 --> 00:03:08.640
Yeah.

00:03:08.720 --> 00:03:12.660
Four years, I've been running Simple Polls, a Slack app, building out the team up to,

00:03:12.660 --> 00:03:13.660
like, seven, eight of us.

00:03:13.660 --> 00:03:16.000
And I had a great time doing that.

00:03:16.000 --> 00:03:20.020
In the middle, I actually worked at GitHub for two years, working on Ruby and Rails.

00:03:20.020 --> 00:03:20.840
And that was super fun.

00:03:20.840 --> 00:03:23.880
Like, a great company, great people, huge code base.

00:03:23.880 --> 00:03:24.940
Learned a lot there.

00:03:24.940 --> 00:03:25.940
That was really fun.

00:03:25.940 --> 00:03:29.740
But, yeah, I left after about two years to work full-time on Simple Polls.

00:03:29.740 --> 00:03:31.940
So, Simple Polls have been running as a side project kind of in the background.

00:03:32.380 --> 00:03:35.860
And actually, it's interesting, like, I think kind of the order of events, thinking back,

00:03:35.860 --> 00:03:38.060
Microsoft was...

00:03:38.060 --> 00:03:39.540
Acquired GitHub while I was there.

00:03:39.540 --> 00:03:45.960
And then suddenly, all of my colleagues started talking about buying boats and leaving the company.

00:03:45.960 --> 00:03:50.540
And I thought, hmm, I don't quite have boat money.

00:03:50.540 --> 00:03:52.820
But how can I...

00:03:52.820 --> 00:03:54.440
What's an ace I might have up my sleeve?

00:03:54.440 --> 00:03:58.740
And it was Simple Poll, which had got, like, tons of users, but I never monetized it.

00:03:58.740 --> 00:04:00.420
So, I set out to monetize it.

00:04:00.560 --> 00:04:04.520
And then a year later, it was actually bringing in more revenue than my salary at GitHub.

00:04:04.520 --> 00:04:06.400
So, I decided to quit.

00:04:06.400 --> 00:04:08.220
So, that's kind of the Simple Poll backstories.

00:04:08.220 --> 00:04:12.620
So, Simple Polls, a Django app, reasonably sized now, a bunch of people working on it.

00:04:12.620 --> 00:04:18.140
And then, yeah, at some point in the journey of building Simple Poll, I kind of started playing around with Colo.

00:04:18.140 --> 00:04:21.540
So, Colo also kind of, just like Simple Poll, started as a side project.

00:04:21.540 --> 00:04:27.860
But now, not to make polls in Slack, but instead to improve my own developer experience building Simple Poll.

00:04:28.040 --> 00:04:37.740
So, kind of built it as my own tool for making Django, working with Django more fun, give me more insight, give me access to some of the data that I felt was so close.

00:04:37.740 --> 00:04:41.100
But that I had to just, like, manually get in there and print out.

00:04:41.500 --> 00:04:47.340
So, the reason Colo started out as supporting just Django and VS Code is because that's what I was using.

00:04:47.340 --> 00:04:48.900
And it was an internal side project.

00:04:48.900 --> 00:04:53.220
And now, actually handed over Simple Poll to a new CEO.

00:04:53.220 --> 00:04:57.520
I'm no longer involved day to day, and I'm working full-time on Colo.

00:04:58.340 --> 00:05:01.220
Man, congratulations on, like, multiple levels.

00:05:01.220 --> 00:05:01.760
That's awesome.

00:05:01.760 --> 00:05:02.200
Thank you.

00:05:02.200 --> 00:05:02.520
Yeah.

00:05:02.520 --> 00:05:05.860
I want to talk to you a bit about Simple Poll for just a minute.

00:05:05.860 --> 00:05:09.040
But before then, you pointed out, like, look, I made this side project.

00:05:09.040 --> 00:05:11.820
And how many hours were you spending on it?

00:05:11.820 --> 00:05:12.560
A week, maybe?

00:05:12.560 --> 00:05:13.300
Oh, it was interesting.

00:05:13.300 --> 00:05:16.860
So, honestly, like, so this was, like, right at the beginning, like, when it was first started.

00:05:16.860 --> 00:05:18.140
Yeah, it's a good time.

00:05:18.140 --> 00:05:19.240
It's a good question.

00:05:19.240 --> 00:05:25.600
I always joke that the best thing about my management degree was that I had a lot of free time to, like, do, build side projects.

00:05:25.640 --> 00:05:28.740
Honestly, I think it could have been, like, 20, 30, 40 hours a week.

00:05:28.740 --> 00:05:29.020
Yeah.

00:05:29.020 --> 00:05:29.400
Yeah.

00:05:29.400 --> 00:05:30.620
That was, yeah.

00:05:30.620 --> 00:05:32.760
I think, yeah, it definitely varied week to week.

00:05:32.760 --> 00:05:33.560
And then later on?

00:05:33.560 --> 00:05:33.980
Yeah.

00:05:33.980 --> 00:05:37.580
And then while I was working, when I had a full-time job as a software engineer, yeah, that was a lot tougher.

00:05:37.580 --> 00:05:39.080
It was, like, nights and weekends.

00:05:39.080 --> 00:05:41.840
Rarely had energy during the week to work on it.

00:05:41.840 --> 00:05:48.340
And then, honestly, like, since it was a real project with real users, I ended up spending a lot of the weekend doing, like, support.

00:05:48.340 --> 00:05:49.340
Like, support stuff.

00:05:49.340 --> 00:05:50.040
Yeah, absolutely.

00:05:50.040 --> 00:05:50.700
Support.

00:05:50.700 --> 00:05:55.120
And, like, then you charge, and then now you have finance stuff and, like, legal stuff to do.

00:05:55.200 --> 00:05:56.640
So that wasn't super fun.

00:05:56.640 --> 00:06:01.440
It really slows down the features and the creation of stuff, doesn't it?

00:06:01.440 --> 00:06:01.820
Yeah.

00:06:01.820 --> 00:06:09.260
I would say I probably spent fully 50% of my full-time job doing email support, that kind of stuff.

00:06:09.260 --> 00:06:12.760
You know, just, like, there's tons of people taking courses and listening to podcasts.

00:06:12.760 --> 00:06:13.760
Yeah, yeah, yeah.

00:06:13.760 --> 00:06:15.000
And they'll have questions and thoughts.

00:06:15.000 --> 00:06:16.640
And, you know, it's awesome.

00:06:16.640 --> 00:06:18.680
But it also is really tricky.

00:06:18.680 --> 00:06:21.620
So the reason I ask is I always find it fascinating.

00:06:21.620 --> 00:06:24.220
You'll see, like, news articles.

00:06:24.220 --> 00:06:24.800
I don't know.

00:06:24.800 --> 00:06:25.960
They're always click-baity or whatever.

00:06:26.400 --> 00:06:31.080
This person makes three times their job working 10 hours a week on this other thing.

00:06:31.080 --> 00:06:33.060
Like, you make three times what you make for your job.

00:06:33.060 --> 00:06:34.300
What are you doing at your job?

00:06:34.300 --> 00:06:35.200
You know what I mean?

00:06:35.200 --> 00:06:36.080
Right?

00:06:36.320 --> 00:06:41.220
The ability to say you can make that step where you go from kind of tired at night's

00:06:41.220 --> 00:06:44.700
extra time and squeezing on the weekends to full-time, full energy.

00:06:44.700 --> 00:06:45.000
Yeah.

00:06:45.000 --> 00:06:49.560
If it's already doing well, you know, on, like, a very thin life support, like, then give it

00:06:49.560 --> 00:06:51.040
full-time and energy.

00:06:51.040 --> 00:06:53.020
It's just, of course, it's going to be better, right?

00:06:53.060 --> 00:06:53.600
It's so interesting.

00:06:53.600 --> 00:06:55.320
I actually have a lot of thoughts about this.

00:06:55.320 --> 00:06:57.160
Maybe I should write something about this at some point.

00:06:57.160 --> 00:07:01.800
But yeah, I actually think running, like, a bootstrap side project kind of business as

00:07:01.800 --> 00:07:07.140
you have a job can be really good because it really forces you to prioritize and build the

00:07:07.140 --> 00:07:08.140
most important things.

00:07:08.140 --> 00:07:08.440
Yeah.

00:07:08.440 --> 00:07:09.720
It's kind of like having kids.

00:07:09.720 --> 00:07:10.340
Oh, nice.

00:07:10.340 --> 00:07:10.660
Yeah, yeah.

00:07:10.660 --> 00:07:11.760
I need to try that someday.

00:07:11.760 --> 00:07:13.660
Oh, you'll be real tired.

00:07:13.660 --> 00:07:15.500
I tell you, you'll love to prioritize your time.

00:07:15.500 --> 00:07:17.600
Yeah, I think it really forces you to prioritize.

00:07:17.600 --> 00:07:21.760
So I actually sometimes recommend when folks ask me, like, for advice, like, should I quit my

00:07:21.760 --> 00:07:23.220
job to go all in or not?

00:07:23.220 --> 00:07:28.480
I actually sometimes think there's a lot of nice stability and that comes from having a

00:07:28.480 --> 00:07:28.680
job.

00:07:28.680 --> 00:07:30.820
Plus, it's actually really nice to have coworkers.

00:07:30.820 --> 00:07:32.000
It's nice to have structure.

00:07:32.000 --> 00:07:36.500
Like, you actually need to take all of that, well, work in a way on yourself.

00:07:36.500 --> 00:07:39.540
Like, it's, you know, if you have to make your own structure, like, if you're building your

00:07:39.540 --> 00:07:41.580
own thing, and that can actually be a bit tricky.

00:07:41.580 --> 00:07:43.020
Like, I really struggled with that at the beginning.

00:07:43.020 --> 00:07:47.260
So I think there's something to be said for, yeah, for spending, like, limited time on something,

00:07:47.260 --> 00:07:49.660
basically, and prioritizing just the most important.

00:07:49.660 --> 00:07:50.140
That's an interesting angle.

00:07:50.360 --> 00:07:52.240
And I don't necessarily disagree with that.

00:07:52.240 --> 00:07:52.980
That's interesting.

00:07:52.980 --> 00:07:57.580
So for me, it was interesting, like, in terms of like, how much, like, you know, life support

00:07:57.580 --> 00:08:00.500
energy you put in versus like, full time energy.

00:08:00.500 --> 00:08:03.640
It was growing decently, like while I was still at GitHub.

00:08:04.160 --> 00:08:07.880
And I thought, okay, I'm gonna go in on this full time.

00:08:07.880 --> 00:08:13.580
And if I go from like, 10 hours a week, or less to like 40 hours a week, that would probably

00:08:13.580 --> 00:08:14.960
4x the growth rate as well.

00:08:14.960 --> 00:08:16.000
That's how it works.

00:08:16.000 --> 00:08:16.240
Right?

00:08:16.240 --> 00:08:17.960
And like, totally didn't.

00:08:17.960 --> 00:08:19.960
Like, it totally didn't work.

00:08:19.960 --> 00:08:25.480
In fact, like, the month after I left, I had like my first down month, where like the revenue

00:08:25.480 --> 00:08:26.120
decreased.

00:08:26.380 --> 00:08:28.460
And I was like, wait a minute, what's going on here?

00:08:28.460 --> 00:08:29.620
How that doesn't make any sense.

00:08:29.620 --> 00:08:30.300
That's not fair.

00:08:30.300 --> 00:08:34.920
So I think that also points that like, there, yeah, you can definitely spend more hours on

00:08:34.920 --> 00:08:35.140
something.

00:08:35.140 --> 00:08:39.580
And it can be like the wrong things or not doubling down on something that's really working.

00:08:40.140 --> 00:08:44.560
So, but overall, obviously, you at some point, like just being able to like test out more

00:08:44.560 --> 00:08:45.940
ideas is like really valuable.

00:08:45.940 --> 00:08:50.520
And for that, like, if you only have time to do support on your project, that's really working

00:08:50.520 --> 00:08:55.620
well, and your full time job is the rest of the how you spend your week, then yeah, feels

00:08:55.620 --> 00:08:59.060
like you should give yourself some time to build features and maybe quit the job.

00:08:59.060 --> 00:08:59.360
Yeah.

00:08:59.360 --> 00:09:06.440
It's also an interesting point about the structure, because not everyone is gonna get up at eight

00:09:06.440 --> 00:09:09.760
o'clock, sit at their desk, and they're gonna be like, you know, I kind of can just

00:09:09.760 --> 00:09:10.520
do whatever.

00:09:10.520 --> 00:09:14.160
And it's, it's a, it's its own discipline, its own learned skill.

00:09:14.160 --> 00:09:14.780
100%.

00:09:14.780 --> 00:09:14.960
Yeah.

00:09:14.960 --> 00:09:20.400
I remember like one of the first weeks after I was full time on simple call, I woke up in

00:09:20.400 --> 00:09:22.300
the morning and said, well, the money's coming in.

00:09:22.300 --> 00:09:23.240
I don't need to work.

00:09:23.240 --> 00:09:24.020
I don't have a boss.

00:09:24.020 --> 00:09:26.440
And I just sit in bed and watch YouTube videos all day.

00:09:26.440 --> 00:09:29.260
And then I just felt miserable at the end of the day.

00:09:29.260 --> 00:09:31.700
Like the, I was like, this is supposed to feel great.

00:09:31.700 --> 00:09:34.920
Why all this freedom I've wanted and dreamt about for so long?

00:09:34.920 --> 00:09:36.680
We're like, why does it not feel great?

00:09:36.680 --> 00:09:38.340
Yeah.

00:09:38.680 --> 00:09:42.160
It also, also feels like risk and more different kinds of responsibility.

00:09:42.160 --> 00:09:42.760
All right.

00:09:42.760 --> 00:09:43.960
So simple poll.

00:09:43.960 --> 00:09:48.020
The reason I said it'd be worth talking about a little bit is, you know, Slack's a popular

00:09:48.020 --> 00:09:50.120
platform and this is based on Django, right?

00:09:50.120 --> 00:09:52.000
So simple poll is a full on Django app.

00:09:52.000 --> 00:09:52.280
Yeah.

00:09:52.400 --> 00:09:53.340
And it's funny.

00:09:53.340 --> 00:09:58.200
Sometimes people joke that, I don't know if you've gone through the official Django tutorial,

00:09:58.200 --> 00:10:00.780
but in there you actually make a polls app in the browser.

00:10:00.780 --> 00:10:05.280
Sometimes people joke, wait, did you just turn this into like a Slack app?

00:10:05.280 --> 00:10:07.960
And then you productize the getting started tutorial.

00:10:07.960 --> 00:10:08.300
Yeah.

00:10:08.300 --> 00:10:09.460
Exactly.

00:10:09.960 --> 00:10:14.960
But yeah, like it turned out that like polls and then, yeah, getting, you know, your team

00:10:14.960 --> 00:10:18.760
more connected and Slack and more engaged are like things people really care about.

00:10:18.760 --> 00:10:24.500
So it came to the Slack, simple poll joined the Slack platform like at the perfect time and

00:10:24.500 --> 00:10:27.340
has just been growing super well since then.

00:10:27.440 --> 00:10:32.180
Tell people a little bit about what it takes technically to make a Slack app.

00:10:32.180 --> 00:10:35.700
I mean, Slack is not built in Python as far as I know.

00:10:35.700 --> 00:10:40.260
And it's probably JavaScript and Electron, mostly the people interact with, right?

00:10:40.260 --> 00:10:41.160
So what is the deal here?

00:10:41.160 --> 00:10:42.140
It's actually super interesting.

00:10:42.140 --> 00:10:47.200
So the way you build like a Slack app, it's actually all backend based.

00:10:47.200 --> 00:10:52.360
So when a user interacts in Slack, Slack sends your app, your backend, like a JSON payload

00:10:52.360 --> 00:10:54.480
saying like this user clicked this button.

00:10:54.880 --> 00:10:59.820
And then you can just send a JSON payload back saying, all right, now show this message.

00:10:59.820 --> 00:11:00.800
Now show this modal.

00:11:00.800 --> 00:11:05.700
And they have their own JSON based block kit framework where you can render different types

00:11:05.700 --> 00:11:06.200
of content.

00:11:06.200 --> 00:11:10.720
So you don't actually have to think about JavaScript or React or any of their stack at all.

00:11:10.720 --> 00:11:15.140
It's basically all sending JSON payloads around and calling various parts of the Slack API.

00:11:15.140 --> 00:11:20.620
So you can build a Slack app in your favorite language, any kind of exotic language if you wanted

00:11:20.620 --> 00:11:20.900
to.

00:11:20.900 --> 00:11:23.200
But yeah, I love Python.

00:11:23.340 --> 00:11:25.260
So I decided to build it in Python and Django.

00:11:25.260 --> 00:11:29.220
So yeah, actually building Slack apps is a really like pleasant experience.

00:11:29.220 --> 00:11:33.040
What's the deployment backend story look like?

00:11:33.040 --> 00:11:35.040
Is it a pass sort of thing?

00:11:35.040 --> 00:11:36.000
Serverless?

00:11:36.000 --> 00:11:37.320
VMs?

00:11:37.320 --> 00:11:39.460
At the time, it was Heroku.

00:11:39.460 --> 00:11:40.800
Simbup was running on Heroku.

00:11:41.480 --> 00:11:45.640
And then I think a few years ago, we migrated it to AWS.

00:11:45.640 --> 00:11:48.580
So now it's running on AWS and ECS.

00:11:48.580 --> 00:11:49.040
Nice.

00:11:49.040 --> 00:11:49.560
Okay.

00:11:49.560 --> 00:11:51.100
So Docker for the win.

00:11:51.100 --> 00:11:51.560
Right on.

00:11:51.560 --> 00:11:52.560
How does it work in TalkBison?

00:11:52.560 --> 00:11:53.020
I'm curious.

00:11:53.020 --> 00:11:54.520
How, what's, where are you deployed?

00:11:54.700 --> 00:11:55.960
It's all DigitalOcean.

00:11:55.960 --> 00:12:03.820
And then I have one big, like eight, eight CPU server running, I think, 16 different Django

00:12:03.820 --> 00:12:04.400
apps.

00:12:04.400 --> 00:12:05.320
Not Django, sorry.

00:12:05.320 --> 00:12:05.920
Docker apps.

00:12:05.920 --> 00:12:06.700
No, sorry.

00:12:06.700 --> 00:12:12.460
Docker apps that are all, all doing like, you know, some of them share database that's in

00:12:12.460 --> 00:12:19.780
Docker and some of them do sort of have their own self-contained pair of like web app and

00:12:19.780 --> 00:12:20.940
database and so on.

00:12:20.940 --> 00:12:25.620
But it's all, it's all Docker on one big server, which is fairly new for me.

00:12:25.620 --> 00:12:26.600
And it's, it's glorious.

00:12:26.600 --> 00:12:27.380
It's glorious.

00:12:27.380 --> 00:12:27.980
That's awesome.

00:12:27.980 --> 00:12:28.740
Very cool.

00:12:28.740 --> 00:12:29.000
Yeah.

00:12:29.000 --> 00:12:30.080
All right.

00:12:30.080 --> 00:12:32.580
So again, congrats on this.

00:12:32.580 --> 00:12:33.240
Very, very neat.

00:12:33.240 --> 00:12:35.140
Let's talk Colo.

00:12:35.140 --> 00:12:35.720
Let's do it.

00:12:35.720 --> 00:12:40.680
I first came across this, I've come across it independently twice.

00:12:42.200 --> 00:12:47.900
Once when the Django chat guys recommended that I talk to you because they're like,

00:12:47.900 --> 00:12:49.080
Will's doing cool stuff.

00:12:49.080 --> 00:12:50.180
You should definitely talk to him.

00:12:50.180 --> 00:12:53.020
This Django thing for VS Code is super cool.

00:12:53.020 --> 00:12:58.400
But also I can't remember there's somebody on your team whose social media profile I came

00:12:58.400 --> 00:13:01.860
across and I saw this and I'm like, oh, this is, this is pretty neat.

00:13:01.860 --> 00:13:04.320
I think we even covered it on the Python Bytes podcast.

00:13:04.320 --> 00:13:05.060
Oh, no way.

00:13:05.060 --> 00:13:05.580
Let's see.

00:13:05.580 --> 00:13:06.340
Yeah, sure.

00:13:06.340 --> 00:13:07.640
In January we did.

00:13:07.640 --> 00:13:12.000
So that's what we talked about a little bit, but this just looks like such a neat thing.

00:13:12.000 --> 00:13:17.560
And it's, I encourage people to, who may be interested in this, to visit colo.app because

00:13:17.560 --> 00:13:21.480
it's a super visual sort of experience of understanding your code, right?

00:13:21.480 --> 00:13:22.080
Would you agree?

00:13:22.080 --> 00:13:22.540
Yeah.

00:13:22.540 --> 00:13:23.420
I mean, a hundred percent.

00:13:23.420 --> 00:13:23.680
Yeah.

00:13:23.680 --> 00:13:24.580
A funny thought.

00:13:24.580 --> 00:13:29.640
I hadn't really thought that a podcast is going to be a hard way to describe the visual

00:13:29.640 --> 00:13:32.380
beauty and magic that Colo can bring to your code.

00:13:32.380 --> 00:13:33.720
But yeah, a hundred percent.

00:13:33.720 --> 00:13:33.940
Yeah.

00:13:33.940 --> 00:13:38.980
So Colo like very much started as like the idea of, Hey, like I should be able to see

00:13:38.980 --> 00:13:40.720
like how my code actually flows.

00:13:40.720 --> 00:13:45.580
I think like all of us, as we build software, as we write our Python code, we have this kind

00:13:45.580 --> 00:13:49.340
of like mental model of how all the different functions like fit together.

00:13:49.340 --> 00:13:54.640
How like a bit of data ends up from like the beginning, like to the end, like it passes through

00:13:54.640 --> 00:13:55.560
maybe a bunch of functions.

00:13:55.560 --> 00:13:58.460
It passes through a bunch of like classes, a bunch of loops.

00:13:58.460 --> 00:14:03.480
All the state gets like modified and we have this kind of like mental picture of all of

00:14:03.480 --> 00:14:04.160
that in our head.

00:14:04.160 --> 00:14:09.860
And the kind of very beginning of Colo, the question I asked myself was like, is there a

00:14:09.860 --> 00:14:11.680
way we can just like visualize that?

00:14:11.680 --> 00:14:15.580
Is there a way we can just actually print that out onto a screen?

00:14:15.580 --> 00:14:20.540
So if you go to colo.app, it kind of looks like this funny sun chart with like lots of kind

00:14:20.540 --> 00:14:26.460
of a sunny tree chart with lots of nodes going from the center and like going off into the

00:14:26.460 --> 00:14:30.520
distance, which I think is like, yeah, similar to like what folks kind of might already have

00:14:30.520 --> 00:14:32.820
in their head about like how the code flows.

00:14:32.820 --> 00:14:40.560
Maybe another way to describe it is imagine like you enable a debugger at the beginning

00:14:40.560 --> 00:14:46.780
of every function and at the end of every function in your code and you print out like what was

00:14:46.780 --> 00:14:47.440
the function name?

00:14:47.440 --> 00:14:48.600
What were the input arguments?

00:14:48.600 --> 00:14:49.880
What was the return value?

00:14:49.880 --> 00:14:54.720
And then you arrange all of that in a graph that then shows which function called which other

00:14:54.720 --> 00:14:55.080
function.

00:14:55.080 --> 00:14:57.220
It almost looks like what you get out of profilers.

00:14:57.220 --> 00:14:57.720
Right.

00:14:57.720 --> 00:15:02.720
You know, where you say like, okay, this function took 20%, but if you expand it out, I'll say,

00:15:02.720 --> 00:15:06.160
well, really spent 5% there, 10% there, and then a bunch of it.

00:15:06.160 --> 00:15:08.000
And you can kind of traverse that.

00:15:08.000 --> 00:15:08.700
100%.

00:15:08.700 --> 00:15:09.060
Yeah.

00:15:09.060 --> 00:15:12.960
I'm guessing you're not really interested in how long it took, although maybe you can probably

00:15:12.960 --> 00:15:13.760
get that out of it.

00:15:13.760 --> 00:15:16.740
It's the important is more what is the dependency?

00:15:16.740 --> 00:15:21.400
What are the variables being passed and like understanding individual behavior, right?

00:15:21.400 --> 00:15:22.060
Or maybe.

00:15:22.060 --> 00:15:22.520
Yeah.

00:15:22.520 --> 00:15:22.900
What do you think?

00:15:23.020 --> 00:15:23.520
Yeah, 100%.

00:15:23.520 --> 00:15:26.700
I think like, it's interesting because Colo actually uses under the hood, like a bunch

00:15:26.700 --> 00:15:28.320
of the Python profiling APIs.

00:15:28.320 --> 00:15:31.440
And I think people often think of Colo as a profiler.

00:15:31.440 --> 00:15:36.300
We do actually have a traditional profiling based chart, which puts the timing at the center.

00:15:36.300 --> 00:15:41.260
But you're absolutely right that the focus of our like main chart, the one that we're both

00:15:41.260 --> 00:15:46.920
looking at that has like this idea of the function overview and like which function calls which.

00:15:46.920 --> 00:15:52.620
The idea there is like absolutely the hierarchy and seeing like giving yourself that same mental

00:15:52.620 --> 00:15:56.980
model that someone who's worked on a code base for three months has in their head immediately

00:15:56.980 --> 00:15:58.740
like yourself by just looking at it.

00:16:00.360 --> 00:16:03.320
This portion of Talk Python To Me is brought to you by Sentry.

00:16:03.320 --> 00:16:04.420
Code breaks.

00:16:04.420 --> 00:16:05.740
It's a fact of life.

00:16:05.740 --> 00:16:07.880
With Sentry, you can fix it faster.

00:16:07.880 --> 00:16:13.580
As I've told you all before, we use Sentry on many of our apps and APIs here at Talk Python.

00:16:13.580 --> 00:16:18.800
I recently used Sentry to help me track down one of the weirdest bugs I've run into in a long

00:16:18.800 --> 00:16:19.300
time.

00:16:19.300 --> 00:16:20.260
Here's what happened.

00:16:20.480 --> 00:16:26.280
When signing up for our mailing list, it would crash under a non-common execution pass, like

00:16:26.280 --> 00:16:31.520
situations where someone was already subscribed or entered an invalid email address or something

00:16:31.520 --> 00:16:32.020
like this.

00:16:32.020 --> 00:16:38.020
The bizarre part was that our logging of that unusual condition itself was crashing.

00:16:38.020 --> 00:16:41.220
How is it possible for our log to crash?

00:16:41.220 --> 00:16:43.780
It's basically a glorified print statement.

00:16:43.780 --> 00:16:45.480
Well, Sentry to the rescue.

00:16:45.480 --> 00:16:50.340
I'm looking in the crash report right now, and I see way more information than you'd expect

00:16:50.340 --> 00:16:51.940
to find in any log statement.

00:16:51.940 --> 00:16:54.980
And because it's production, debuggers are out of the question.

00:16:54.980 --> 00:17:01.640
I see the traceback, of course, but also the browser version, client OS, server OS, server

00:17:01.640 --> 00:17:06.880
OS version, whether it's production or Q&A, the email and name of the person signing up.

00:17:06.880 --> 00:17:08.920
That's the person who actually experienced the crash.

00:17:08.920 --> 00:17:11.760
Dictionaries of data on the call stack and so much more.

00:17:11.760 --> 00:17:12.700
What was the problem?

00:17:12.700 --> 00:17:20.080
I initialized the logger with the string info for the level rather than the enumeration.info.

00:17:20.200 --> 00:17:22.400
which was an integer based enum.

00:17:22.400 --> 00:17:27.720
So the login statement would crash saying that I could not use less than or equal to between

00:17:27.720 --> 00:17:28.960
strings and ints.

00:17:28.960 --> 00:17:30.380
Crazy town.

00:17:30.380 --> 00:17:33.980
But with Sentry, I captured it, fixed it.

00:17:33.980 --> 00:17:36.580
And I even helped the user who experienced that crash.

00:17:36.580 --> 00:17:38.000
Don't fly blind.

00:17:38.000 --> 00:17:39.680
Fix code faster with Sentry.

00:17:39.680 --> 00:17:43.720
Create your Sentry account now at talkpython.fm/sentry.

00:17:43.940 --> 00:17:50.220
And if you sign up with the code TALKPYTHON, all capital, no spaces, it's good for two free

00:17:50.220 --> 00:17:54.820
months of Sentry's business plan, which will give you up to 20 times as many monthly events

00:17:54.820 --> 00:17:56.080
as well as other features.

00:17:57.820 --> 00:18:02.740
Usually in the way these charts turn out, you can notice that there's like points of interest.

00:18:02.740 --> 00:18:04.700
Like there's one function that has a lot of children.

00:18:04.700 --> 00:18:09.500
So that clearly is coordinating like a bunch of the work where you can see kind of similarities

00:18:09.500 --> 00:18:12.240
in the structure of the some of the subtrees.

00:18:12.360 --> 00:18:15.820
So you know, oh, okay, maybe that's like a loop and it's the same thing happening a couple

00:18:15.820 --> 00:18:16.240
times.

00:18:16.240 --> 00:18:21.640
So you can essentially, I get this overview and then it's fully interactive and you can

00:18:21.640 --> 00:18:23.760
dive in to like what exactly is happening.

00:18:23.760 --> 00:18:24.180
Yeah.

00:18:24.180 --> 00:18:25.100
Is it interactive?

00:18:25.100 --> 00:18:28.160
So I can like click on these pieces and it'll pull them up.

00:18:28.160 --> 00:18:32.080
We actually, and this is what's, it'll be live by the time this podcast goes live.

00:18:32.080 --> 00:18:34.780
We actually have a playground in the browser.

00:18:34.780 --> 00:18:36.120
This is also super fun.

00:18:36.120 --> 00:18:36.840
We can talk about this.

00:18:36.840 --> 00:18:38.160
Let me drop you a link real quick.

00:18:38.160 --> 00:18:40.380
This will be at play.colo.app.

00:18:40.800 --> 00:18:45.540
So with this, yeah, this is super fun because this is fully Python just running in the browser

00:18:45.540 --> 00:18:47.480
using Pyodide and like WebAssembly.

00:18:47.480 --> 00:18:48.120
Nice.

00:18:48.120 --> 00:18:48.520
Okay.

00:18:48.520 --> 00:18:53.300
But yeah, so this is the fully visual version where you can, yeah, it defaults to loading

00:18:53.300 --> 00:18:55.140
like a simple Fibonacci algorithm.

00:18:55.140 --> 00:18:55.560
Yeah.

00:18:55.560 --> 00:19:00.360
And you can see like what the cola visualization of Fibonacci looks like.

00:19:00.360 --> 00:19:03.740
And you can actually edit the code and see how it changes with your edits and all of that.

00:19:03.740 --> 00:19:05.000
We have a couple other examples.

00:19:05.000 --> 00:19:05.640
Wow.

00:19:05.640 --> 00:19:08.360
The pandas one and the whack-a-mole one are pretty intense.

00:19:08.360 --> 00:19:09.380
They're pretty wild pictures.

00:19:09.380 --> 00:19:12.080
They look like sort of Japanese fans or whatever.

00:19:12.080 --> 00:19:13.620
You know, those little paper ones.

00:19:13.620 --> 00:19:18.020
We once had a competition at a conference to see who could make like the most fun looking

00:19:18.020 --> 00:19:20.340
algorithm and visualize it with Kolo.

00:19:20.340 --> 00:19:22.060
But yeah, like it's fun.

00:19:22.060 --> 00:19:23.720
Like visualizing code is really great.

00:19:23.720 --> 00:19:24.980
That's awesome.

00:19:24.980 --> 00:19:26.360
So this is super cool.

00:19:26.360 --> 00:19:28.540
It's just all from scratch.

00:19:28.540 --> 00:19:30.840
It's besides Pyodide here.

00:19:31.120 --> 00:19:34.820
Not like VS Code in the browser or anything like that.

00:19:34.820 --> 00:19:37.400
I think it's using Monaco in this case or CodeMirror.

00:19:37.400 --> 00:19:41.920
But otherwise, this is all is Pyodide and a little bit of React to like pull kind of the

00:19:41.920 --> 00:19:42.520
data together.

00:19:42.520 --> 00:19:43.000
Uh-huh.

00:19:43.000 --> 00:19:44.520
But yeah, we're really, yeah.

00:19:44.520 --> 00:19:44.860
Wow.

00:19:44.960 --> 00:19:46.200
It's otherwise homemade.

00:19:46.200 --> 00:19:57.740
This is kind of like the kind of what Kolo has been for like the past like two years or so has been this kind of side project for our SimplePol to help like just visualize and understand code better.

00:19:57.740 --> 00:20:04.500
The SimplePol code base, to be honest, has grown so large that like there's parts of it that I wrote like five years ago that I don't understand anymore.

00:20:04.500 --> 00:20:10.220
And it's like annoying to get back to that and having to spend like a day to re-familiarize myself with everything.

00:20:10.220 --> 00:20:15.380
It's a lot nicer to just like to actually kind of explain like end to end how it works.

00:20:15.380 --> 00:20:19.780
You install like in a Django project, you install Kolo as a middleware.

00:20:19.780 --> 00:20:27.140
And then as you just browse and use your Django app and make requests, traces get saved.

00:20:27.540 --> 00:20:28.960
So Kolo records these traces.

00:20:28.960 --> 00:20:32.080
They actually get saved in a local SQLite database.

00:20:32.080 --> 00:20:37.620
Then you can view the traces, which includes the visualization, but also like lots of other data.

00:20:37.620 --> 00:20:39.520
Like you can actually see in the version you have there.

00:20:39.520 --> 00:20:43.920
Like we show every single function call, like the inputs and outputs for each function call.

00:20:43.920 --> 00:20:48.580
So that main idea of Kolo is to like really show you everything that happened in your code.

00:20:48.580 --> 00:20:57.520
So in a Django app, that would be like the request, the response, like all the headers, every single function call, input and output, outbound request, SQL query.

00:20:57.520 --> 00:21:00.200
So really the goal is to show you everything.

00:21:00.900 --> 00:21:04.280
You can view these stored traces either through VS Code.

00:21:04.280 --> 00:21:12.500
And this is also will be live by the time this episode goes live through like a web middleware version, which is a bit similar to Django debug toolbar.

00:21:12.500 --> 00:21:15.320
Not sure if you've played around much with Django debug toolbar.

00:21:15.320 --> 00:21:15.960
Yeah, a little bit.

00:21:15.960 --> 00:21:16.200
Yeah.

00:21:16.200 --> 00:21:17.920
And those things are actually pretty impressive.

00:21:17.920 --> 00:21:18.520
Right.

00:21:18.520 --> 00:21:20.580
I played out with that one in the pyramid one.

00:21:20.580 --> 00:21:26.920
And yeah, you can see more than I think you would reasonably expect from just a little thing on the side of your web app.

00:21:27.060 --> 00:21:27.800
Yeah, yeah, exactly.

00:21:27.800 --> 00:21:31.180
And that's very much our goal to like very kind of deep insight.

00:21:31.180 --> 00:21:34.240
In our minds, this is almost like a bit like old news.

00:21:34.240 --> 00:21:36.800
Like we've been using this for like a few years, basically.

00:21:36.800 --> 00:21:41.500
And then at some point, like last year, we started playing around with this idea of like,

00:21:41.500 --> 00:21:48.060
OK, so we have this trace that has information about like pretty much everything that happened in like a request.

00:21:48.240 --> 00:21:54.340
Is there any way we could use that to solve this like reasonably large pain point for us, which is like writing tests?

00:21:54.340 --> 00:21:55.340
I'm actually curious.

00:21:55.340 --> 00:21:56.860
Do you enjoy writing tests?

00:21:56.860 --> 00:21:58.820
I'll tell you what I used to actually.

00:21:58.820 --> 00:22:01.100
I used to really enjoy writing tests.

00:22:01.100 --> 00:22:03.000
I used to enjoy thinking a lot about it.

00:22:03.000 --> 00:22:10.600
And then as the projects would get bigger, I'm like, you know, this is these tests don't really cover what I need them to cover anymore.

00:22:10.600 --> 00:22:12.960
And they're kind of dragging it down.

00:22:12.960 --> 00:22:18.980
And then, you know, the thing that really kind of knocked it out for me is I'd have like teammates and they wouldn't care about the tests at all.

00:22:18.980 --> 00:22:23.220
So they would break the tests or just write a bunch of code without tests.

00:22:23.220 --> 00:22:27.320
And I felt kind of like a parent cleaning up after kids.

00:22:27.320 --> 00:22:28.400
You're like, why is it so?

00:22:28.400 --> 00:22:29.840
Can we just pick up?

00:22:29.840 --> 00:22:30.880
Like, why are there dishes here?

00:22:30.880 --> 00:22:32.840
You know, just going around.

00:22:32.840 --> 00:22:34.120
I'm like, this is not what I want to do.

00:22:34.120 --> 00:22:35.600
Like, I want to just write software.

00:22:35.600 --> 00:22:38.440
And like, I understand the value of tests, of course.

00:22:38.440 --> 00:22:39.300
A hundred percent.

00:22:39.300 --> 00:22:47.440
At the same time, I feel like maybe higher order integration tests often, for me at least, serve more value.

00:22:47.440 --> 00:22:52.040
Because it's like, I could write 20 little unit tests or I could write two integration tests.

00:22:52.040 --> 00:22:53.240
And it's probably going to work.

00:22:53.240 --> 00:22:54.940
I'm actually completely with you on that.

00:22:54.940 --> 00:22:55.260
Okay.

00:22:55.260 --> 00:22:55.880
Right on.

00:22:55.880 --> 00:22:59.080
The bang for the buck of integration tests are like great.

00:22:59.080 --> 00:23:00.820
Like really, really useful.

00:23:00.820 --> 00:23:04.140
You can almost think of tests as having like two purposes.

00:23:04.140 --> 00:23:08.380
One being like, well, actually, I think this would be too simple in explanation.

00:23:08.380 --> 00:23:11.700
Let me not make grand claims about all the uses of tests.

00:23:11.700 --> 00:23:20.020
I think the use of it that most people are after is this idea of like, what I've built isn't going to break by accident.

00:23:20.020 --> 00:23:20.360
Yeah.

00:23:20.460 --> 00:23:27.900
Like you want confidence that any future change you make doesn't impact a bunch of unrelated stuff that it's not supposed to impact.

00:23:27.900 --> 00:23:32.140
I think that's what most people are after with tests.

00:23:32.140 --> 00:23:37.220
And I think for that specific desired result, like integration tests are the way to go.

00:23:37.280 --> 00:23:43.100
And there's some cool writing about this from, I wrote a little blog post about Kolo's test generation abilities.

00:23:43.840 --> 00:23:53.180
And in there, I linked to a post from Kent C. Dodds from the JavaScript community who has a great post about, I think it's called write tests, not too many, mostly integration.

00:23:53.180 --> 00:23:54.840
Kind of after this idea of like,

00:23:54.840 --> 00:23:55.660
Nice.

00:23:55.660 --> 00:23:56.420
Yeah, yeah, yeah.

00:23:56.420 --> 00:23:58.500
Eat not too much, mostly vegetables.

00:23:58.700 --> 00:24:00.080
I think that's the, yeah, exactly.

00:24:00.080 --> 00:24:00.680
Exactly.

00:24:00.680 --> 00:24:01.080
Yeah.

00:24:01.080 --> 00:24:02.100
I'm a big fan of that.

00:24:02.100 --> 00:24:03.260
And actually it's interesting.

00:24:03.260 --> 00:24:06.300
I've speaking to a bunch of folks over the past like year about tests.

00:24:06.300 --> 00:24:10.260
A lot of engineers think about writing tests as vegetables.

00:24:10.260 --> 00:24:24.600
And obviously some people love vegetables and some of us love writing tests, but it seems like for a lot of folks, it's kind of like a obviously necessary part of creating great software, but it's maybe not like the most fun part of our job.

00:24:24.600 --> 00:24:30.420
Or you pick up some project, you're a consultant, or you're taking over some open source project.

00:24:30.420 --> 00:24:31.540
You're like, this has no tests.

00:24:31.540 --> 00:24:31.940
Right.

00:24:31.940 --> 00:24:35.520
It's kind of like running a linter and it says there's a thousand errors.

00:24:35.520 --> 00:24:36.800
You're like, well, we're not going to do that.

00:24:36.800 --> 00:24:37.620
Yeah.

00:24:37.940 --> 00:24:42.020
We're just not going to run the linter against it because it's just too messed up at this point.

00:24:42.020 --> 00:24:42.260
Right.

00:24:42.260 --> 00:24:42.700
It's interesting.

00:24:42.700 --> 00:24:48.340
You mentioned the picking up like a project with no tests, because I think within the next three months, we're not quite there yet.

00:24:48.340 --> 00:24:55.780
But I think in the next three months with Colo's test generation abilities, we'll have a thing where, yeah, all we need is a Python code base to get started.

00:24:55.780 --> 00:25:01.360
And then we can bring that to like a really respectable level of code coverage just by using Colo.

00:25:01.360 --> 00:25:01.680
Okay.

00:25:01.680 --> 00:25:02.160
How?

00:25:03.660 --> 00:25:08.440
I was kind of describing a second ago how like we, SimplePol has tons of integration tests.

00:25:08.440 --> 00:25:15.000
SimplePol actually is about 80,000 lines of application code, not including migrations and like config files.

00:25:15.000 --> 00:25:17.900
And then it's about 100,000 lines of tests.

00:25:17.900 --> 00:25:20.180
And most of that is integration tests.

00:25:20.180 --> 00:25:22.020
So SimplePol very well, very well tested.

00:25:22.020 --> 00:25:24.220
Lots of, you know, really mostly integration tests.

00:25:24.500 --> 00:25:27.540
But it is always a bit of a chore to like write them.

00:25:27.540 --> 00:25:34.280
So we started thinking about like, hmm, this like Colo tracing we're doing, can that help us with making tests somehow?

00:25:34.280 --> 00:25:36.300
And then we started experimenting with it.

00:25:36.300 --> 00:25:40.680
And like to our surprise, it's actually, yeah, I'm still sometimes surprised that it actually works.

00:25:40.780 --> 00:25:53.320
But basically the idea is that if you have a trace that has, that captures everything in the request, you can kind of invert it to build a integration test.

00:25:53.320 --> 00:25:55.740
So let me give an example of what that means.

00:25:55.740 --> 00:26:01.980
The biggest challenge we found with creating integration tests is actually the test data setup.

00:26:02.260 --> 00:26:09.540
So getting your application into the right shape before you can send a request to it or before you can call a certain function.

00:26:09.540 --> 00:26:11.380
That's like kind of the hardest part.

00:26:11.380 --> 00:26:15.320
Writing the asserts is almost like easy or even like fun.

00:26:15.320 --> 00:26:15.620
Right.

00:26:15.620 --> 00:26:17.960
There's the three A's of unit testing.

00:26:17.960 --> 00:26:19.600
Range, assert, and act.

00:26:19.600 --> 00:26:21.260
Wait, arrange, act, and assert.

00:26:21.260 --> 00:26:21.620
Exactly.

00:26:21.620 --> 00:26:25.080
The first and the third one that you kind of have data on, right?

00:26:25.080 --> 00:26:25.720
Exactly.

00:26:25.720 --> 00:26:25.980
Yeah.

00:26:25.980 --> 00:26:27.640
So we're like, wait a second.

00:26:28.040 --> 00:26:32.000
We actually can like kind of extract this, like the act.

00:26:32.000 --> 00:26:38.200
So like the setting, sorry, the arrange, setting up the data, the act, like actually making the HTTP request.

00:26:38.200 --> 00:26:43.720
And then the assert, like to ensure the status change or that the request go to 200 or something.

00:26:43.720 --> 00:26:44.860
We actually have the data for this.

00:26:44.860 --> 00:26:46.240
It's reasonably straightforward.

00:26:46.240 --> 00:26:54.720
Like if you capture in, you know, just your like normal, like imagine you have a local to-do app and you browse like a to-do kind of demo, simple to-do app.

00:26:54.720 --> 00:26:57.840
And you browse to the homepage and the homepage maybe lists the to-dos.

00:26:57.840 --> 00:27:01.940
And if you've got Kolo enabled, then Kolo will have captured the request, right?

00:27:01.940 --> 00:27:05.020
So like the request went to the homepage and it returned a 200.

00:27:05.020 --> 00:27:09.420
So that's already like two things we can now turn into code in our integration test.

00:27:09.420 --> 00:27:15.980
So first step being, well, I guess this is the act and the assert in the sense that the assert is the 200.

00:27:15.980 --> 00:27:19.080
And then the act is firing off a request to the homepage.

00:27:19.240 --> 00:27:23.620
Now the tricky bit, and this is where it gets the most fun, is the arrange.

00:27:23.620 --> 00:27:30.560
So if we just put those two things into our test, in our to-imaginary test, there wouldn't have been any to-dos there, right?

00:27:30.560 --> 00:27:32.220
So it's actually not an interesting test yet.

00:27:32.220 --> 00:27:39.600
But in your local version where the trace was recorded, you actually had maybe like three to-dos already in your database.

00:27:39.600 --> 00:27:40.780
Does that make sense so far?

00:27:40.780 --> 00:27:41.840
Yeah, yeah, absolutely.

00:27:41.840 --> 00:27:50.360
On the homepage, like your to-do app might make a SQL query to like select all the to-dos or all the to-dos for the currently logged in user.

00:27:50.360 --> 00:27:57.660
And then Kolo would store that SQL query, would store that select, and would also store actually what data the database returned.

00:27:57.660 --> 00:28:03.100
This is actually something where, yeah, Kolo goes beyond a lot of the existing kind of like debugging tooling that might exist.

00:28:03.100 --> 00:28:07.680
Like actually showing exactly what data the database returned in a given SQL query.

00:28:07.680 --> 00:28:11.660
But imagine we get like a single to-do returned, right?

00:28:11.660 --> 00:28:20.080
We now know that to replicate this like trace in our test, we need to start by seeding that to-do into the database.

00:28:20.080 --> 00:28:22.620
That's where like the trace inversion comes in.

00:28:22.620 --> 00:28:35.760
If like a request starts with a select of like the to-do table, then the first thing that needs to happen in the integration test is actually a like creating like an insert into the database for that to-do.

00:28:35.760 --> 00:28:44.340
And now when you fire off the request to the homepage, it actually goes through your real code path where like an actual to-do gets loaded and gets printed out onto the page.

00:28:44.340 --> 00:28:56.740
So that's like the most basic kind of example of like how can you turn like a locally captured trace of a request that like made a SQL query and return 200 into like an integration test.

00:28:56.940 --> 00:28:57.680
Yeah, that's awesome.

00:28:57.680 --> 00:29:15.580
One of the things that makes me want to write fewer unit tests or not write a unit test in a certain case is I can test given using mocking, given my, let's say SQLAlchemy or Beanie or whatever Django Rm model theoretically matches the database.

00:29:15.800 --> 00:29:19.140
I can do some stuff, set some values and check that that's all good.

00:29:19.140 --> 00:29:29.540
But in practice, if the shape, if the schema in the database doesn't match the shape of my object, the system freaks out and crashes and says, well, that's not going to work, right?

00:29:29.540 --> 00:29:30.160
There's no way.

00:29:30.280 --> 00:29:32.840
And so it doesn't matter how good I mock it out.

00:29:32.840 --> 00:29:36.920
It has to go kind of end to end before I feel very good about it.

00:29:36.920 --> 00:29:37.320
Oh, yeah.

00:29:37.320 --> 00:29:37.540
Okay.

00:29:37.540 --> 00:29:39.020
It's going to really, really work, right?

00:29:39.020 --> 00:29:39.460
Exactly.

00:29:39.460 --> 00:29:40.800
That's an interesting story.

00:29:40.800 --> 00:29:46.880
Like you're saying to like, let's actually see if we can just create the data, but like let it run all the way through, right?

00:29:46.880 --> 00:29:47.960
I'm totally with you.

00:29:47.960 --> 00:29:52.680
And I think I've often seen like unit tests pass and say, I mean, there's like lots of memes about this, right?

00:29:52.700 --> 00:29:55.580
How like unit tests say everything is good, but the server is down.

00:29:55.580 --> 00:29:56.500
Like, how is that possible?

00:29:56.500 --> 00:30:03.600
I think in Django world, it's reasonably common to write integration tests like this, as in like the actual database gets hit.

00:30:03.600 --> 00:30:15.200
You have this idea of like the Django test client, which sends like a, you know, real in air quotes, HTTP request through the entire Django stack, as opposed to doing the more unit test approach.

00:30:15.200 --> 00:30:16.680
So it hits the routes.

00:30:16.680 --> 00:30:19.980
It hits like all of the, that sort of stuff all the way.

00:30:19.980 --> 00:30:20.240
Yeah.

00:30:20.240 --> 00:30:21.040
And the template.

00:30:21.040 --> 00:30:21.380
Yeah.

00:30:21.380 --> 00:30:21.660
Yeah.

00:30:21.980 --> 00:30:36.580
And then at the end, you can assert based on like the content of the response, or you can check, like, imagine if we go back to the to-do example, if we're testing like the add to-do endpoint or form submission, then you could make a database query at the end.

00:30:36.580 --> 00:30:42.740
And Colo actually does this as well, because like, again, we know like that you inserted a to-do in your request.

00:30:42.740 --> 00:30:44.420
So we can actually make an assert.

00:30:44.420 --> 00:30:47.080
This is a different example of the trace inversion.

00:30:47.400 --> 00:30:56.240
If there's an insert in your request that you've captured, then we know at the end of the integration test, we want to assert that this row now exists in the database.

00:30:56.240 --> 00:31:01.820
So you can assert at the very end to say, does this row actually exist in the database now?

00:31:01.900 --> 00:31:05.980
So it's a very nice kind of reasonably end to end, but still integration test.

00:31:05.980 --> 00:31:10.040
It's not like a brittle click around in the browser and kind of hope for the best kind of thing.

00:31:10.040 --> 00:31:14.900
It's like, as we said at the beginning, I think like integration tests just get you great bank for your buck.

00:31:14.900 --> 00:31:15.720
They really do.

00:31:16.080 --> 00:31:20.120
It's like the 80-20 rule of unit testing for sure.

00:31:20.120 --> 00:31:20.420
Yeah.

00:31:20.420 --> 00:31:24.460
Talk Python To Me is partially supported by our training courses.

00:31:24.460 --> 00:31:29.580
If you're a regular listener of the podcast, you surely heard about Talk Python's online courses.

00:31:29.580 --> 00:31:31.660
But have you had a chance to try them out?

00:31:31.660 --> 00:31:34.900
No matter the level you're looking for, we have a course for you.

00:31:34.900 --> 00:31:41.260
Our Python for Absolute Beginners is like an introduction to Python, plus that first year computer science course that you never took.

00:31:41.260 --> 00:31:48.120
Our data-driven web app courses build a full PyPI.org clone along with you right on the screen.

00:31:48.120 --> 00:31:51.060
And we even have a few courses to dip your toe in with.

00:31:51.060 --> 00:31:56.420
See what we have to offer at training.talkpython.fm or just click the link in your podcast player.

00:31:56.420 --> 00:31:59.660
So is this all algorithmic?

00:31:59.660 --> 00:31:59.880
Yep.

00:31:59.880 --> 00:32:00.640
Great question.

00:32:00.640 --> 00:32:01.820
Is it LLMs?

00:32:01.820 --> 00:32:04.580
Like how much VC funding are you looking for?

00:32:04.580 --> 00:32:07.640
Like, you know, like if you've got LLMs in there, like they're coming out of the woodwork.

00:32:07.640 --> 00:32:08.160
No, I'm just kidding.

00:32:08.160 --> 00:32:10.460
No, how does this happen?

00:32:10.540 --> 00:32:14.000
It's actually all algorithmic and rule-based at the moment.

00:32:14.000 --> 00:32:21.920
So this idea of a select becomes like an insert and an insert becomes like a select assert.

00:32:21.920 --> 00:32:24.860
We were surprised how far we could get with just rules.

00:32:24.860 --> 00:32:30.880
The benefit we have is that we kind of have this like full-sized SimplePol Django code base to play around with.

00:32:30.880 --> 00:32:36.040
And yeah, like generating integration tests in SimplePol just like fully works.

00:32:36.040 --> 00:32:42.160
There's a bunch of tweaks we like had to make to as soon as I guess you work in kind of like outside of a demo example.

00:32:42.160 --> 00:32:49.160
You want like time mocking and HTTP mocking and you want to use your like factory boy factories.

00:32:49.420 --> 00:32:53.500
And maybe you have a custom unit test like base class and all of this.

00:32:53.500 --> 00:32:55.640
But yeah, it like it actually works now.

00:32:55.640 --> 00:32:58.220
I gave a talk at DjangoCon Europe last year.

00:32:58.220 --> 00:33:07.440
It's kind of like a bit of a wow moment in the audience where, yeah, you just click generate test and it generates you like a hundred line integration test and the test actually passes.

00:33:07.440 --> 00:33:11.940
So that was like people started just started clapping, which was a great feeling.

00:33:11.940 --> 00:33:14.100
I'm still a bit surprised that it works on it.

00:33:14.100 --> 00:33:15.480
But yeah, no LLM at all.

00:33:15.480 --> 00:33:19.080
I do think like LLMs could probably make these tests like even better.

00:33:19.080 --> 00:33:28.360
Or you know how I was saying a second ago, like in three months, we could go take a code base from like zero test coverage to maybe like 60%, 80%.

00:33:28.360 --> 00:33:33.360
I imagine if we made use of LLMs, that would help make that happen.

00:33:33.360 --> 00:33:33.900
Yeah.

00:33:33.900 --> 00:33:34.460
Yeah.

00:33:34.460 --> 00:33:37.760
You could talk to it about like, well, these things aren't covered.

00:33:37.760 --> 00:33:38.120
Right.

00:33:38.120 --> 00:33:39.460
What can we do to cover them?

00:33:39.460 --> 00:33:39.740
Yeah.

00:33:39.740 --> 00:33:43.600
I don't know if you maybe could do fully, fully automated.

00:33:43.600 --> 00:33:45.740
Just push the button and let it generate it.

00:33:45.740 --> 00:33:49.920
But, you know, it could also be like a conversational, not a conversation, sort of a guided.

00:33:49.920 --> 00:33:51.840
Let's get the rest of the test.

00:33:51.840 --> 00:33:53.700
You know, like, okay, we're down to 80.

00:33:53.700 --> 00:33:56.200
We've got 80%, but there's the last bit are a little tricky.

00:33:56.200 --> 00:33:57.520
Like what ones are missing?

00:33:57.660 --> 00:33:57.800
Right.

00:33:57.800 --> 00:33:59.420
So how do you think we could do this?

00:33:59.420 --> 00:34:02.600
Is that, no, no, you need to, that's not really the kind of data we're going to pass.

00:34:02.600 --> 00:34:03.320
You know, I don't know.

00:34:03.320 --> 00:34:04.600
It seems something like that.

00:34:04.600 --> 00:34:04.760
Right.

00:34:04.760 --> 00:34:05.600
I really like that.

00:34:05.600 --> 00:34:10.380
I had not thought about like a conversation as a way to generate tests, but that makes so much sense.

00:34:10.380 --> 00:34:10.740
Right.

00:34:10.740 --> 00:34:15.820
It kind of bringing the developer along with them where it's gotten too hard or something, you know?

00:34:15.820 --> 00:34:16.100
Yeah.

00:34:16.100 --> 00:34:19.600
There's something cool about just clicking a button and see how much code coverage you could get to.

00:34:19.600 --> 00:34:21.080
But chatting to it.

00:34:21.080 --> 00:34:27.640
I think also, honestly, like so far, like our test generation logic is a bit of a black box.

00:34:27.640 --> 00:34:29.620
It just kind of like works.

00:34:29.620 --> 00:34:29.920
Yeah.

00:34:29.920 --> 00:34:31.360
Until the point where like it doesn't.

00:34:31.360 --> 00:34:35.900
So we're actually kind of in the process of like shining a bit more of a light into like,

00:34:35.900 --> 00:34:45.940
like essentially the like internal data model that Colo keeps track of to know what the database state should be like in this arrange part of the integration test.

00:34:46.320 --> 00:34:59.820
And yeah, we're actually like in the process of like, yeah, talking to a bunch of users who are already using it and also finding like companies who want to increase their increase their test coverage or who have problems with their testing and want to improve that.

00:34:59.820 --> 00:35:03.120
And kind of working closely with them to make that happen.

00:35:03.120 --> 00:35:07.780
That's kind of a huge focus for us as we figure out, like, how do we want to monetize Colo?

00:35:07.880 --> 00:35:14.300
Like so far, Colo has just been kind of supported by SimplePool as a side project, but we're kind of making it real, making it its own business.

00:35:14.300 --> 00:35:18.180
So and we think the test generation is going to play a big part in that.

00:35:18.180 --> 00:35:18.460
Right.

00:35:18.460 --> 00:35:21.680
Like that could be a certainly a premium team feature sort of thing.

00:35:21.680 --> 00:35:22.280
Exactly.

00:35:22.280 --> 00:35:22.560
Yeah.

00:35:22.560 --> 00:35:22.960
Yeah.

00:35:22.960 --> 00:35:23.260
Yeah.

00:35:23.260 --> 00:35:24.080
Enterprise.

00:35:24.080 --> 00:35:26.540
Enterprise version comes with auto testing.

00:35:26.540 --> 00:35:28.260
Yeah, exactly.

00:35:28.260 --> 00:35:28.960
Something like that.

00:35:28.960 --> 00:35:29.160
Yeah.

00:35:29.160 --> 00:35:29.440
Yeah.

00:35:29.440 --> 00:35:33.040
If there's anyone listening and like they're keen to increase their code coverage, please email me.

00:35:33.040 --> 00:35:35.740
Maybe we can leave my email in the in the notes or something like that.

00:35:35.820 --> 00:35:37.660
Yeah, I'll put your contact info in the show notes for sure.

00:35:37.660 --> 00:35:38.560
It's actually really nice.

00:35:38.560 --> 00:35:40.340
It's just W at Colo dot app.

00:35:40.340 --> 00:35:41.100
Oh, very nice.

00:35:41.100 --> 00:35:52.440
So yeah, if anyone's listening and wants to kind of like increase their code coverage or has a lot of code bases that have zero coverage that would benefit from getting to like some level of coverage, we'd love to help you and talk to you.

00:35:52.440 --> 00:35:59.720
Even if the solution doesn't like involve using Colo, just really, really keen to talk to anyone about like Python tests and what can be done there.

00:35:59.720 --> 00:36:01.360
So yeah, please hit me up.

00:36:01.360 --> 00:36:01.720
Awesome.

00:36:01.720 --> 00:36:04.180
Yeah, I'll definitely put some details in the show notes for that.

00:36:04.180 --> 00:36:05.600
I have some questions as well.

00:36:05.660 --> 00:36:05.800
Please.

00:36:05.800 --> 00:36:06.200
Yes.

00:36:06.200 --> 00:36:06.820
Right here.

00:36:06.820 --> 00:36:12.440
I'm looking at the web page and the angle bracket title is Colo for Django.

00:36:12.440 --> 00:36:17.780
But in the playground thing you sent me, it was on plain Python code.

00:36:17.780 --> 00:36:19.100
It was on algorithms.

00:36:19.100 --> 00:36:23.100
It was on pandas, which I thought was pretty interesting how much you could see inside pandas.

00:36:23.100 --> 00:36:29.940
Makes me wonder, you know, if you look at the web frameworks, there's two or three more that are pretty popular out there and they all support middleware.

00:36:30.220 --> 00:36:30.880
Yeah, 100%.

00:36:30.880 --> 00:36:35.480
So Colo kind of started as like this like side project for our Django app.

00:36:35.480 --> 00:36:37.900
And I think that that's why we kind of went there first.

00:36:37.900 --> 00:36:40.180
It's kind of the audience we know best.

00:36:40.180 --> 00:36:41.680
You can do dogfood as well.

00:36:41.680 --> 00:36:41.960
Yeah.

00:36:41.960 --> 00:36:42.440
Exactly.

00:36:42.440 --> 00:36:43.240
Dogfooded.

00:36:43.240 --> 00:36:52.860
Lily, who's an engineer on the team, and who's been building a lot of the Python side of Colo, is like a core contributor to Django.

00:36:53.360 --> 00:36:55.420
So Django is like really where we're home.

00:36:55.420 --> 00:37:01.240
And to be honest, I think when building a new product, it's kind of nice to keep the audience somewhat small initially.

00:37:01.240 --> 00:37:06.460
Keep like building for very specific needs as opposed to going like very wide, very early.

00:37:06.460 --> 00:37:08.880
That was kind of very much, very much the intention.

00:37:08.880 --> 00:37:15.540
But there's no reason why Colo can't support Flask, FastAPI, the scientific Python stack.

00:37:15.540 --> 00:37:18.820
As you can see in the playground, it does totally work on plain Python.

00:37:19.260 --> 00:37:28.560
It's really just a matter of honestly, like FastAPI support would probably be like a 40 line config file in our code.

00:37:28.560 --> 00:37:34.780
And there's actually, yeah, we're thinking of ways to make that actually a bit more pluggable as well.

00:37:34.780 --> 00:37:39.420
There's only like so many things we can reasonably support well ourselves.

00:37:39.420 --> 00:37:44.120
I was going to say, if somebody else out there has an open source project, they want it to have good support for this, right?

00:37:44.120 --> 00:37:49.040
Like, hey, I run HTTPX or I run Litestar or whatever.

00:37:49.220 --> 00:37:50.960
And I want mine to look good here too, right?

00:37:50.960 --> 00:37:51.520
Totally.

00:37:51.520 --> 00:37:55.800
So the thing you can do already today is there's a little bit of config you can pass in.

00:37:55.800 --> 00:37:58.840
And actually, if you look back on the pandas example, you'll see this.

00:37:58.840 --> 00:38:03.820
By default, Colo actually doesn't show you library code if you use it in your own code base.

00:38:03.820 --> 00:38:07.960
But you can tell it, show me everything that happened, like literally everything.

00:38:07.960 --> 00:38:09.920
And then it will do that for you.

00:38:09.920 --> 00:38:16.980
So in this example you're looking at, or if anyone's looking at the playground, if you look at the pandas example, it'll say like include everything in pandas.

00:38:16.980 --> 00:38:19.360
And that'll give you like a lot more context.

00:38:19.360 --> 00:38:27.120
The thinking there is that most people don't really need, like the issues you're going to be looking at will be in your own code or in your own company's code base.

00:38:27.360 --> 00:38:30.240
You don't really need to look at the abstractions, but you totally can.

00:38:30.240 --> 00:38:42.480
But yeah, to answer the question, like we have this like internal version of a plugin system where, yeah, like anyone could add FastAPI support or like a great insight into PyTorch or what have you.

00:38:42.480 --> 00:38:48.260
The way it all works technically really is it's totally built on top of this Python API called set profile.

00:38:48.260 --> 00:38:49.040
I'm not sure.

00:38:49.040 --> 00:38:51.200
Have you used, have you come across this before?

00:38:51.200 --> 00:38:52.900
It's a bit similar to set trace actually.

00:38:52.900 --> 00:38:53.960
Yeah, I think so.

00:38:53.960 --> 00:38:58.240
I think I've done it for some C profile things before.

00:38:58.240 --> 00:38:59.220
I'm not totally sure.

00:38:59.220 --> 00:38:59.740
Yeah.

00:38:59.740 --> 00:39:00.040
Yeah.

00:39:00.040 --> 00:39:08.380
It's a really neat API to be honest, because Python calls back to your, like the callback that you register on every function, enter and exit.

00:39:08.460 --> 00:39:13.740
And then Colo essentially looks at all of these functions, enters and exits and decides which ones are interesting.

00:39:13.740 --> 00:39:21.400
So the matter of like supporting say FastAPI is basically just telling Colo, these are the FastAPI functions that are interesting.

00:39:21.400 --> 00:39:25.720
This is the FastAPI function for, for like an HTTP request that was served.

00:39:25.720 --> 00:39:28.900
This is the HTTP response or similarly for SQLAlchemy.

00:39:28.900 --> 00:39:33.020
This is the function where the query was actually executed and sent to the database.

00:39:33.020 --> 00:39:35.480
This is the variable, which has the query result.

00:39:35.480 --> 00:39:37.400
Like there's a little bit more to it.

00:39:37.680 --> 00:39:43.200
And I'm definitely like, yeah, generalizing, but it's kind of like in principle, it's as simple as that.

00:39:43.200 --> 00:39:46.660
It's like telling Colo, here's the bits of code in a given library that are interesting.

00:39:46.660 --> 00:39:50.840
Now just kind of like display that and make that available for the test generation.

00:39:50.840 --> 00:39:51.220
Excellent.

00:39:51.220 --> 00:39:58.620
Yeah, I totally agree with you that getting focused, it probably gets you some more full attention from the Django audience.

00:39:58.620 --> 00:40:02.820
And the Django audience is quite a large and influential group in the Python web space.

00:40:03.040 --> 00:40:05.220
So that makes a ton of sense, especially since you're using it.

00:40:05.220 --> 00:40:12.000
By the way, it was Lily's Mastodon profile, I believe, that I ran across that I first discovered Colo from.

00:40:12.000 --> 00:40:13.660
So of all the places, yeah.

00:40:13.660 --> 00:40:16.540
Or a post from her or something like that.

00:40:16.540 --> 00:40:17.040
That's awesome.

00:40:17.040 --> 00:40:17.380
Cool.

00:40:17.380 --> 00:40:17.680
All right.

00:40:17.760 --> 00:40:20.180
So let's talk about a couple other things here.

00:40:20.180 --> 00:40:20.640
Let's do it.

00:40:20.640 --> 00:40:24.380
For people who haven't seen it yet, like you get quite a bit of information.

00:40:24.380 --> 00:40:31.860
So if you see like the get request, you actually see the JSON response that was returned out of that request.

00:40:31.860 --> 00:40:35.520
And it integrates kind of into your editor directly, right?

00:40:35.520 --> 00:40:38.140
If you've seen CodeLens before, it's kind of like CodeLens, right?

00:40:38.140 --> 00:40:41.800
Yeah, this is another thing which I think is pretty novel with Colo.

00:40:41.800 --> 00:40:48.680
Like I think it's reasonably common for existing debugging tools to show you like, oh yeah, this is the headers for the request.

00:40:48.680 --> 00:40:50.860
Or this is like the response status code.

00:40:50.860 --> 00:40:59.300
But especially working with the Slack API in SimplePol, you're constantly looking at payloads and what were the values for things and what are you returning.

00:40:59.300 --> 00:41:03.800
In production, you don't directly get to even make those or receive those requests, right?

00:41:03.800 --> 00:41:07.700
There's some like system in Slack who was like chatting with your thing.

00:41:07.700 --> 00:41:09.440
You're like, well, what is happening here, right?

00:41:09.440 --> 00:41:12.460
Not that you would actually run this in there, but you know.

00:41:12.460 --> 00:41:21.480
I mean, it's funny you mentioned this because there is one experiment we want to run of kind of actually enabling these extremely deep and detailed Colo traces in production.

00:41:21.480 --> 00:41:23.880
We haven't explored this too much yet.

00:41:23.880 --> 00:41:26.440
And I think we're going to focus a little bit more on the test generation.

00:41:26.840 --> 00:41:38.220
But you could imagine like a user who's using, who's on the Talk Python site and they've got some incredibly niche error that no one else is like encountering.

00:41:38.220 --> 00:41:41.040
And you've tried to reproduce it, but you can't reproduce it.

00:41:41.040 --> 00:41:45.640
Maybe there's a little bit of information in like your logging system, but it's just not enough.

00:41:45.640 --> 00:41:49.060
And you keep adding more logging and you keep adding more logging and it's just not helping.

00:41:49.660 --> 00:41:55.600
Like imagine a world where you can say just for that user, like enable Colo and enable like these really deep traces.

00:41:55.600 --> 00:42:05.000
And then you can see whenever the user next interacts, like the value for every single variable, for every single code path that executed for that user.

00:42:05.000 --> 00:42:06.300
That's just like, yeah.

00:42:06.300 --> 00:42:09.240
I think one of our users described it as like a debugger on steroids.

00:42:09.240 --> 00:42:10.000
Yeah, yeah.

00:42:10.000 --> 00:42:10.960
It's pretty interesting.

00:42:10.960 --> 00:42:18.320
Sounds a little bit like what you get with Sentry and some of those things, but maybe also a little bit different.

00:42:18.560 --> 00:42:23.800
So, you know, you could do something like, here's a dear user with problem.

00:42:23.800 --> 00:42:24.620
Here's a URL.

00:42:24.620 --> 00:42:30.800
If you click this, it'll set a cookie in your browser and then all subsequent behavior, it just, it's on it.

00:42:30.800 --> 00:42:31.320
You know what I mean?

00:42:31.320 --> 00:42:32.320
It's like recording it.

00:42:32.320 --> 00:42:32.700
Yeah.

00:42:32.700 --> 00:42:33.700
That'd be pretty interesting.

00:42:33.700 --> 00:42:34.040
Yeah.

00:42:34.040 --> 00:42:39.480
I think it makes sense in the case, like if a user, it could even be an automated support thing, right?

00:42:39.480 --> 00:42:45.200
Like if a couple of sites have this where you can like do like a debug dump before you submit your support ticket.

00:42:45.200 --> 00:42:47.100
This is almost like that.

00:42:47.100 --> 00:42:53.720
And then as an engineer who's tasked with digging into that user's bug, you don't have to start with like piecing together.

00:42:54.420 --> 00:42:58.680
What was this variable at this time when they made that request three days ago?

00:42:58.680 --> 00:43:00.300
You like, you can just see it.

00:43:00.300 --> 00:43:04.200
If an error ever encounters an exception on your site, you just set the cookie.

00:43:04.200 --> 00:43:04.520
Right.

00:43:04.520 --> 00:43:07.940
Everything else they do is now just recorded until you turn it off on them.

00:43:07.940 --> 00:43:08.320
Oh my gosh.

00:43:08.320 --> 00:43:09.740
You're giving me so many good ideas.

00:43:09.740 --> 00:43:10.460
That'd be fun, right?

00:43:10.460 --> 00:43:11.520
Start writing this stuff down.

00:43:11.520 --> 00:43:13.360
Hey, let's record it.

00:43:13.360 --> 00:43:13.820
It'll be fine.

00:43:13.820 --> 00:43:14.340
That's awesome.

00:43:14.480 --> 00:43:14.640
Yeah.

00:43:14.640 --> 00:43:16.900
There's a bunch of stuff that's interesting.

00:43:16.900 --> 00:43:18.060
People can check it on the site.

00:43:18.060 --> 00:43:19.280
It's all good.

00:43:19.280 --> 00:43:22.660
However, we talked a little bit about the production thing.

00:43:22.660 --> 00:43:30.920
Like another thing you could do for production, this requires both a decent amount of traffic and maybe you could actually pull this off on just a single server.

00:43:30.920 --> 00:43:37.000
But you could do like, let's just run this for 1% of the traffic so that you don't kill the system.

00:43:37.000 --> 00:43:48.320
But you get, you know, if that's why you have enough traffic is like statistically significant sampling of what people do without actually recording a million requests a day or something insane.

00:43:48.320 --> 00:43:49.020
A hundred percent.

00:43:49.020 --> 00:43:50.720
I think there's really something there.

00:43:50.720 --> 00:43:59.040
Or like I could go on about this whole idea of like runtime data and like improving software understanding for days because I just think like it's really this like missing layer, right?

00:43:59.100 --> 00:44:05.560
Like all of us constantly imagine like what is like we play computer looking at our code, imagining what the values can be.

00:44:05.560 --> 00:44:10.880
But like, yeah, say you're looking at some complex function in production and you want to understand how it works.

00:44:10.880 --> 00:44:18.560
Like how useful would it be if you could see like the 10, the last 10 times it was called, like what were the values going into it and what were the values coming out of it?

00:44:18.560 --> 00:44:22.140
Like that would be, I just think like, why do we not have this already?

00:44:22.140 --> 00:44:26.500
Like why does your editor not show you for every single function in the code base?

00:44:26.660 --> 00:44:30.380
Give examples of like how it's actually used like in production.

00:44:30.380 --> 00:44:30.700
Yeah.

00:44:30.700 --> 00:44:32.440
And then use those to generate unit tests.

00:44:32.440 --> 00:44:38.000
And if there's an error, use that to generate the edge case, like the negative case, not the positive case, unit test, right?

00:44:38.000 --> 00:44:38.380
There you go.

00:44:38.380 --> 00:44:38.760
Exactly.

00:44:38.760 --> 00:44:40.540
It's all like kind of hanging together.

00:44:40.540 --> 00:44:41.380
Like, yeah.

00:44:41.380 --> 00:44:42.420
Yeah.

00:44:42.420 --> 00:44:44.320
Once you have the data, you have interesting options.

00:44:44.320 --> 00:44:44.580
Yeah.

00:44:44.580 --> 00:44:45.260
Business model.

00:44:45.260 --> 00:44:50.760
This is not, this, I maybe should have started sooner with this, but it's not entirely open source.

00:44:50.900 --> 00:44:54.820
It may be a little, little bits and pieces of it, but in general, it's not open source.

00:44:54.820 --> 00:44:55.480
That's correct.

00:44:55.480 --> 00:44:55.800
Yeah.

00:44:55.800 --> 00:44:56.060
Yeah.

00:44:56.060 --> 00:44:57.560
No, I'm putting that out there as a negative, right?

00:44:57.560 --> 00:45:00.740
This looks like a super powerful tool that people can use to write, write code it.

00:45:00.740 --> 00:45:01.980
And that's fine.

00:45:01.980 --> 00:45:02.280
Yeah.

00:45:02.280 --> 00:45:03.820
I think the open source question is super interesting.

00:45:03.820 --> 00:45:08.540
Like it's always been like something we've thought about or, or considered.

00:45:08.540 --> 00:45:22.660
I think there is, yeah, with, with developer tools, I think business models are always super interesting and we want to make sure that we can have a business model for Colo and like run it as like a sustainable thing, as opposed to it just being like a simple pole side project kind of indefinitely.

00:45:22.820 --> 00:45:26.780
Be great if Colo could like support itself and yeah, have a business model.

00:45:26.780 --> 00:45:32.520
I think that's how it can like really fulfill its potential in a way, but that's not to say that like Colo won't ever be open source.

00:45:32.520 --> 00:45:35.860
Like I think there's a lot to be said for open sourcing it.

00:45:35.860 --> 00:45:42.600
I think especially like the capturing of the traces is maybe something like I could see us open sourcing.

00:45:42.740 --> 00:45:44.620
I think the open source community is fantastic.

00:45:44.620 --> 00:45:48.380
I do also think it's not like a thing you get for free, right?

00:45:48.380 --> 00:45:54.540
Like as soon as you say, Hey, we're open source, you open yourself up to contributions, right?

00:45:54.540 --> 00:45:59.780
And to like the community actually getting involved and that's great, but it also takes time.

00:45:59.780 --> 00:46:08.660
And I think like, that's a path I would like to go down when we're a little bit clearer on like what Colo actually is and like where it's valuable.

00:46:08.660 --> 00:46:09.620
If that makes sense.

00:46:09.620 --> 00:46:10.100
Yeah, sure.

00:46:10.220 --> 00:46:25.220
If it turns out that no one cares about like what, how, like how to visualize code, then like, that's a great, like learning for us to have made, but I'd rather get there without like a lot of work in the middle that we could have kind of avoided, if that makes sense.

00:46:25.220 --> 00:46:25.860
So for sure.

00:46:25.860 --> 00:46:34.080
It feels like once we have a better sense of the shape of Colo and what the business model actually looks like, then we can be a bit more.

00:46:34.080 --> 00:46:34.700
Yeah.

00:46:34.700 --> 00:46:39.880
We can invest into open source a little bit more, but to be honest, like based on how everything's looking right now.

00:46:39.900 --> 00:46:41.520
I would not be surprised at all.

00:46:41.520 --> 00:46:46.960
If like big chunks, it was like Colo becomes open core or big chunks of it are like open source.

00:46:46.960 --> 00:46:47.960
It makes sense to me.

00:46:47.960 --> 00:46:49.480
It is fully free at the moment.

00:46:49.480 --> 00:46:51.040
So I should, that's worth calling out.

00:46:51.040 --> 00:46:52.340
There's no cost or anything.

00:46:52.340 --> 00:46:55.900
You can also like, you know, you download the Python package and guess what?

00:46:55.900 --> 00:46:57.220
You can look at all of the code.

00:46:57.220 --> 00:46:59.420
Like it actually is all of theirs.

00:46:59.420 --> 00:47:01.100
It is all kind of visible.

00:47:01.320 --> 00:47:15.140
That kind of leads into the next question is I've never used GitHub Copilot and a few of those other things because it's like here, check this box to allow us to upload all of your code and maybe your access keys and everything else.

00:47:15.140 --> 00:47:15.720
That's interesting.

00:47:15.880 --> 00:47:19.320
So we can one trainer models and two, you know, give you some answers.

00:47:19.320 --> 00:47:21.360
And that just always felt a little bit off to me.

00:47:21.360 --> 00:47:24.180
What's the story with the data?

00:47:24.480 --> 00:47:27.780
At the moment, Colo is like entirely like a local product, right?

00:47:27.780 --> 00:47:29.200
So it's all local.

00:47:29.200 --> 00:47:36.180
Like you don't have to, you can get like all of the visualization, everything just by using local Colo in VS Code.

00:47:36.180 --> 00:47:40.400
We do have a way to like upload traces and share them like with a colleague.

00:47:40.400 --> 00:47:46.340
This is actually also something I think is like kind of playing with the idea of like writing a little like Colo manifesto.

00:47:46.340 --> 00:47:47.860
Like what are the things that we believe in?

00:47:47.860 --> 00:47:52.940
One of them that I believe in, and this goes back to the whole like runtime layer on top of code.

00:47:52.940 --> 00:47:58.460
And like there's this whole dimension, this like third dimension to code that we're all simulating in our heads.

00:47:58.460 --> 00:48:13.640
I think like it should totally be possible to not just like link to a snippet of code like on GitHub, but it should be possible to have a like link like a URL to a specific execution of code, like a specific function and actually talk about that.

00:48:13.640 --> 00:48:16.060
It's kind of wild to me that we don't have this at the moment.

00:48:16.060 --> 00:48:20.720
Like you can't send a link to a colleague saying, hey, look at this execution.

00:48:20.720 --> 00:48:21.880
That looks a bit weird.

00:48:22.160 --> 00:48:25.660
We ran this in continuous integration and it crashed, but I don't understand.

00:48:25.660 --> 00:48:26.840
Let's look at the exact.

00:48:26.840 --> 00:48:27.320
Right.

00:48:27.320 --> 00:48:28.120
The whole deal.

00:48:28.120 --> 00:48:29.760
You can link to like CI runs.

00:48:29.760 --> 00:48:31.300
You can link to like sentry errors.

00:48:31.300 --> 00:48:40.140
But like if you're just seeing something slightly weird locally or like even something slightly like weird in production where there's no area, you can't really like link link to that.

00:48:40.540 --> 00:48:45.680
Anyway, like this is kind of a roundabout way of me saying that like I think that totally should be a thing.

00:48:45.680 --> 00:48:50.560
Like you should be able to link like generically to like an execution of a function or execution of a request.

00:48:51.320 --> 00:48:54.360
Like that would totally have to live somewhere.

00:48:54.360 --> 00:48:54.600
Right.

00:48:54.600 --> 00:49:00.780
So this is where there's some idea of like Colo cloud comes in and this is where you could like connect your repository.

00:49:00.780 --> 00:49:08.940
And then Colo would like as part of that, you know, just like GitHub does have access to your code and like show you the code in like the Colo cloud.

00:49:08.940 --> 00:49:13.100
So I think there's definitely like useful things that are possible there.

00:49:13.240 --> 00:49:15.820
But at the moment, it's a fully local experience.

00:49:15.820 --> 00:49:19.120
Like your code doesn't ever leave your system.

00:49:19.120 --> 00:49:26.840
You can if you want to like upload traces and then Colo stores the like trace data, not the code, just the trace data.

00:49:26.840 --> 00:49:28.840
But yeah, very local experience right now.

00:49:28.840 --> 00:49:29.160
Yeah.

00:49:29.160 --> 00:49:30.600
A little SQLite database.

00:49:30.600 --> 00:49:31.020
Exactly.

00:49:31.020 --> 00:49:31.300
Yep.

00:49:31.300 --> 00:49:31.540
Yeah.

00:49:31.540 --> 00:49:32.480
SQLite's pretty awesome.

00:49:32.480 --> 00:49:34.160
It's a credible piece of software.

00:49:34.160 --> 00:49:35.480
Yeah, it really, really is.

00:49:35.480 --> 00:49:39.980
Let's close out our conversation here with a little bit of a request from Michael.

00:49:39.980 --> 00:49:41.680
Right now it's VS Code only.

00:49:41.780 --> 00:49:43.580
Any chance for some PyCharm in there?

00:49:43.580 --> 00:49:46.080
This is our top request, like PyCharm support.

00:49:46.080 --> 00:49:46.380
Yeah.

00:49:46.380 --> 00:49:50.180
And we've decided super small team, like we want to kind of support everyone.

00:49:50.180 --> 00:49:58.780
But we've been working very heavily actually the past few months on a web-based version, which is, I'm happy to say, like very much nearing completion.

00:49:58.780 --> 00:50:06.400
And there's a few bits and pieces where like it's really nice to be integrated super deeply into the editor, like the code lenses and all of that.

00:50:06.400 --> 00:50:09.400
And I think there's a chance we'll have that for PyCharm eventually as well.

00:50:09.400 --> 00:50:20.500
But we actually found that like building out this web version, there's a few things that are actually much nicer when you have the full control over the UI in terms of like browsing around a trace, highlighting little bits of code.

00:50:20.860 --> 00:50:24.520
So for example, in Colo, like a given function call, we call a frame.

00:50:24.520 --> 00:50:32.640
And you can look at a given frame, both in VS Code, but also in the web version and see the code and see all of the data that passed through the code.

00:50:33.160 --> 00:50:40.740
But something we can do in the web version we can't do in VS Code is actually show where the current function was called from and actually show like a preview of that code.

00:50:40.740 --> 00:50:43.540
In VS Code, you can't really show like, you can link to it.

00:50:43.540 --> 00:50:45.680
Yeah, you can layer multiple files together or a difference.

00:50:45.680 --> 00:50:46.740
Yeah, exactly.

00:50:46.740 --> 00:50:47.060
Yeah.

00:50:47.060 --> 00:50:59.360
There's actually a lot of, like I was surprised by how many different novel, like kind of ways we had in the web that we just never even considered with like a direct editor integration in terms of displaying this runtime data.

00:50:59.540 --> 00:51:03.840
So like long story short, like you, you know, you want a PyCharm integration.

00:51:03.840 --> 00:51:05.260
Let me give you something even better.

00:51:05.260 --> 00:51:05.800
Yeah.

00:51:05.800 --> 00:51:06.580
A web version.

00:51:06.580 --> 00:51:18.020
So would that work like you run a certain command or something when you run your web app and then it just generates the SQLite file and then you could just explore it with a web view or what are you?

00:51:18.020 --> 00:51:19.780
Yeah, it's actually kind of cooler than that.

00:51:19.780 --> 00:51:28.960
So if you're using Django or in the future, like other things with a typical middleware, you would just like go to your, you would just go to localhost 8000 slash Colo.

00:51:29.080 --> 00:51:29.720
Yeah, yeah, yeah.

00:51:29.720 --> 00:51:33.320
Kind of like you do for open API docs.

00:51:33.320 --> 00:51:33.640
Yep.

00:51:33.640 --> 00:51:35.180
And then the whole experience is just there.

00:51:35.180 --> 00:51:40.440
If you're not using a middleware, we'll have a command like Colo serve or something like that.

00:51:40.440 --> 00:51:43.260
And that'll host the same experience for you.

00:51:43.260 --> 00:51:49.640
Just make sure it's off by default or it only responds on localhost or something like that.

00:51:49.640 --> 00:51:50.780
Yeah, exactly.

00:51:50.780 --> 00:51:52.500
Don't let people ship it on accident.

00:51:52.500 --> 00:51:54.260
That would be bad news.

00:51:54.260 --> 00:51:55.460
No production use of this.

00:51:55.460 --> 00:51:55.900
Yeah.

00:51:55.900 --> 00:52:02.560
I mean, people already know about the Django debug settings, but I guess you could sort of layer onto that, right?

00:52:02.560 --> 00:52:03.060
Probably.

00:52:03.140 --> 00:52:05.000
Yeah, I think we actually do that at the moment.

00:52:05.000 --> 00:52:06.960
But yeah, it's worth remembering.

00:52:06.960 --> 00:52:07.880
I know.

00:52:07.880 --> 00:52:11.180
I'm just thinking of like, oh, this is really cool to explore.

00:52:11.180 --> 00:52:12.460
A hundred percent.

00:52:12.460 --> 00:52:14.040
CNN.com is awesome.

00:52:14.040 --> 00:52:14.760
Look what it's doing.

00:52:14.760 --> 00:52:16.960
Look at all these requests and all this.

00:52:16.960 --> 00:52:18.060
Yeah, exactly.

00:52:18.060 --> 00:52:19.080
A hundred percent.

00:52:19.340 --> 00:52:19.460
Yeah.

00:52:19.460 --> 00:52:19.760
Yeah.

00:52:19.760 --> 00:52:21.500
Oh, and the API key is so interesting.

00:52:21.500 --> 00:52:25.720
Anyway, that's a bit of a side conversation.

00:52:25.720 --> 00:52:28.360
So let's just wrap it up with final call action.

00:52:28.360 --> 00:52:29.860
People are interested.

00:52:29.860 --> 00:52:30.580
What do they do?

00:52:30.580 --> 00:52:32.420
Yeah, colo.app and check it out.

00:52:32.420 --> 00:52:33.780
We have the Playground link there.

00:52:33.780 --> 00:52:34.940
Play.colo.app.

00:52:34.940 --> 00:52:37.840
Easiest way to kind of see what Colo is and what Colo does.

00:52:37.840 --> 00:52:43.800
But we'll say the most powerful way to actually see Colo in action is to use it on your own code base.

00:52:44.320 --> 00:52:51.360
So seeing the visualization and the test generation capabilities is just like, yeah, the most useful when you use it on your code base.

00:52:51.360 --> 00:52:54.100
So hopefully the Playground can entice that a little bit.

00:52:54.100 --> 00:53:02.820
And yeah, really the main, most important thing for us right now is, yeah, chatting to folks who want to increase their test coverage, want to like build automated testing as part of their workflow.

00:53:02.820 --> 00:53:05.380
And yeah, work very closely with you to make that happen.

00:53:05.380 --> 00:53:10.060
So if that's you, please email me at w at colo.app.

00:53:10.060 --> 00:53:12.220
You need that pause for the W. That's right.

00:53:12.220 --> 00:53:13.680
The two ads.

00:53:13.680 --> 00:53:14.600
Awesome.

00:53:14.600 --> 00:53:16.160
Will, thanks for being on the show.

00:53:16.160 --> 00:53:18.440
Congrats on both of your projects.

00:53:18.440 --> 00:53:19.160
They look really neat.

00:53:19.160 --> 00:53:19.920
Thanks so much for having me.

00:53:19.920 --> 00:53:20.120
Yeah.

00:53:20.120 --> 00:53:21.160
So excited to have been on.

00:53:21.160 --> 00:53:21.820
Yeah, you bet.

00:53:21.820 --> 00:53:22.180
Bye.

00:53:22.180 --> 00:53:22.460
Bye.

00:53:22.460 --> 00:53:26.740
This has been another episode of Talk Python to Me.

00:53:26.740 --> 00:53:28.560
Thank you to our sponsors.

00:53:28.560 --> 00:53:30.180
Be sure to check out what they're offering.

00:53:30.180 --> 00:53:31.600
It really helps support the show.

00:53:31.600 --> 00:53:33.820
Take some stress out of your life.

00:53:33.820 --> 00:53:39.620
Get notified immediately about errors and performance issues in your web or mobile applications with Sentry.

00:53:39.620 --> 00:53:44.620
Just visit talkpython.fm/sentry and get started for free.

00:53:44.620 --> 00:53:48.220
And be sure to use the promo code talkpython, all one word.

00:53:48.220 --> 00:53:49.940
Want to level up your Python?

00:53:49.940 --> 00:53:53.980
We have one of the largest catalogs of Python video courses over at Talk Python.

00:53:54.220 --> 00:53:59.160
Our content ranges from true beginners to deeply advanced topics like memory and async.

00:53:59.160 --> 00:54:01.840
And best of all, there's not a subscription in sight.

00:54:01.840 --> 00:54:04.740
Check it out for yourself at training.talkpython.fm.

00:54:04.740 --> 00:54:06.840
Be sure to subscribe to the show.

00:54:06.840 --> 00:54:09.620
Open your favorite podcast app and search for Python.

00:54:09.620 --> 00:54:10.940
We should be right at the top.

00:54:10.940 --> 00:54:16.100
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

00:54:16.100 --> 00:54:20.300
and the direct RSS feed at /rss on talkpython.fm.

00:54:20.300 --> 00:54:23.260
We're live streaming most of our recordings these days.

00:54:23.260 --> 00:54:26.680
If you want to be part of the show and have your comments featured on the air,

00:54:26.680 --> 00:54:31.100
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

00:54:31.100 --> 00:54:33.160
This is your host, Michael Kennedy.

00:54:33.160 --> 00:54:34.440
Thanks so much for listening.

00:54:34.440 --> 00:54:35.600
I really appreciate it.

00:54:35.600 --> 00:54:37.500
Now get out there and write some Python code.

00:54:37.500 --> 00:54:58.900
I'll see you next time.

