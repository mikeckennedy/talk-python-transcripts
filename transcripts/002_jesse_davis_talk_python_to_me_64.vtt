WEBVTT

00:00:00.001 --> 00:00:09.760
Talk Python to me. Episode number two with guest Jesse Davis recorded Sunday, April 5th, 2015.

00:00:09.760 --> 00:00:39.700
Hello and welcome to Talk Python to me, a weekly

00:00:39.700 --> 00:00:45.020
podcast on Python, the language, the libraries, the ecosystem, and the personalities. This is your

00:00:45.020 --> 00:00:50.460
host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy and keep up with the show and listen

00:00:50.460 --> 00:00:56.880
to past episodes at talkpythontome.com. This episode, we'll be talking to Jesse Davis from

00:00:56.880 --> 00:01:02.320
MongoDB about PyMongo and of course, MongoDB. Before we get to the interview, I have a quick

00:01:02.320 --> 00:01:08.280
message to share. Since we launched a week ago, the response has been overwhelming. I've received many

00:01:09.640 --> 00:01:15.100
feedback. I want to thank everyone who contacted the show. However, I could use your help to make

00:01:15.100 --> 00:01:19.980
sure the show continues to grow and thrive. If you know someone who would be interested in listening to

00:01:19.980 --> 00:01:26.340
the show, please send them a link to talkpythontome.com or share this on Twitter or Facebook. Do you know of

00:01:26.340 --> 00:01:30.920
someone who would make a great guest or have a great show topic in mind? Send me a note and I'll set it up.

00:01:30.920 --> 00:01:36.980
In other excellent news, we have a show sponsor. I want to thank Python Gear from pythongear.com for

00:01:36.980 --> 00:01:42.700
sponsoring this episode and you'll hear more about them later. If you'd like to sponsor a future episode,

00:01:42.700 --> 00:01:48.140
please contact us at talkpythontome.com slash sponsor. Now onto the show.

00:01:48.140 --> 00:01:56.780
Let me introduce Jesse. Jesse Davis is a staff engineer at MongoDB in New York City. He works

00:01:56.780 --> 00:02:04.440
on the MongoDB driver team and develops PyMongo and the MongoC driver. He's the author of the async

00:02:04.440 --> 00:02:09.220
MongoDB driver called Motor and he contributes to Tornado and AsyncIO.

00:02:09.220 --> 00:02:11.560
Jesse, welcome to the show.

00:02:11.560 --> 00:02:13.140
Thanks, Michael.

00:02:13.140 --> 00:02:17.840
It's really great to have you here on the show. And, you know, we've known each other

00:02:17.840 --> 00:02:22.820
sort of as acquaintances for a couple of years. As you know, I'm a MongoDB master,

00:02:23.080 --> 00:02:31.200
which is kind of like an MVP community expert program you guys run. So yearly, we'll come up there and we'll have some really interesting conversations.

00:02:31.200 --> 00:02:40.580
And we've always enjoyed the sessions where you come down and talk to sort of the external experts about working with MongoDB from Python.

00:02:40.580 --> 00:02:58.260
Yeah, we've been doing those about once a year and we've got the next one coming up in a month. And I really look forward to those too. We get some of our best ideas. It definitely creates a year's worth of ideas, if not more, to kind of mull over and implement after each one of those sessions.

00:02:58.760 --> 00:03:10.080
Yeah, those are really fantastic meetings. I really, really enjoy them. So I've seen that you've done a ton of stuff with Python. You know, before we get into the details of MongoDB and PyMongo and all that, you know, how'd you get started?

00:03:10.760 --> 00:03:29.760
So it's a funny story, really, as they say. I began when I graduated from Oberlin College 15 years ago, I was a C++ guy, to the extent that I knew any programming language, really, particularly well at the age of 22.

00:03:29.760 --> 00:03:59.740
I thought that I was a C++ and graphics guy.

00:03:59.740 --> 00:04:00.740
flight patterns.

00:04:00.740 --> 00:04:03.640
Wow, that sounds like a really interesting thing to jump into.

00:04:03.640 --> 00:04:29.720
It was a great gig and I did really, really poorly at it. So I spent about two years there and realized that I wasn't yet a grown-up. I was really screwing up my life and I was a bad software engineer. So I quit the job and went out into the world to try to get my head straight. And I spent a summer biking through France.

00:04:29.720 --> 00:04:44.100
And then I spent a year at a Zen monastery in Southern California. And when I checked back with Austin Digital whether they wanted me to come back to work for them, they said no, because I had not proven myself there.

00:04:44.100 --> 00:05:02.920
So I came to New York to continue my Zen study with a place called the Village Zendo here and to start being a layman and a software professional again. And there were no C++ jobs in New York at the time.

00:05:02.920 --> 00:05:03.920
What kind of jobs were there?

00:05:03.920 --> 00:05:04.920
What kind of jobs were there?

00:05:04.920 --> 00:05:30.920
Well, this was fall of 2004. So the whole market was kind of in bad shape. There had been the NASDAQ crash in July of 2001 and then there was September 11th. And New York hadn't recovered from that yet. So all of the C++ people from all of the banks were still unemployed and I couldn't compete with them.

00:05:30.920 --> 00:05:53.820
So what I did find was an educational startup called Wireless Generation in Brooklyn. In recent years, it's become Amplify Education. And they were willing to take a shot at me, even though the job was in Python and Oracle. And I didn't know either of those.

00:05:53.820 --> 00:05:56.420
That's a long ways from graphics and C++.

00:05:56.420 --> 00:06:06.300
Yeah, it was a huge leap. And it was pretty tough, but I had good mentors and I started using Python there.

00:06:06.300 --> 00:06:18.400
That's excellent. So then you carried on digging into Python and I saw that you have a ton of open source projects on GitHub that are successful or contribute to them.

00:06:19.240 --> 00:06:22.120
And somehow you found your way over to MongoDB from there, huh?

00:06:22.120 --> 00:06:41.320
Yeah. So after a few years working for Wireless Generation, I wanted to get a little more breadth. And I also wanted to make sure that I didn't become so senior that I couldn't continue to program, which was a pressure that I experienced there to move into management.

00:06:41.440 --> 00:06:47.760
That's kind of the curse of success for some programmers is, you know, you're really good at this. Stop doing it now. Go manage people, right?

00:06:47.760 --> 00:06:59.440
Yeah, exactly. And so to jump ahead a little bit, now at MongoDB, we've figured out how to do that by creating this whole separate track of staff engineers, which is the track I'm on now.

00:06:59.800 --> 00:07:29.780
Oh, that's excellent.

00:07:29.780 --> 00:07:32.500
Data storage layer for applications like that.

00:07:32.500 --> 00:07:38.040
Even though MongoDB was brand new at the time, like I started using it at version like 0.8 or something.

00:07:38.040 --> 00:07:42.120
Yeah, is this like 2009, 2010 timeframe or something like that?

00:07:42.120 --> 00:07:43.940
Yeah, exactly.

00:07:44.500 --> 00:07:48.840
And it was such a cool product.

00:07:48.840 --> 00:08:12.020
And within the New York tech startup scene, it was such a rarity as a big infrastructure systems project in a New York City startup that when I finally got tired of freelancing and I wanted to settle down and make a substantial contribution to a single product, I called Elliot and I said, I'm ready to come in from the cold.

00:08:12.020 --> 00:08:12.720
And he said, great.

00:08:12.720 --> 00:08:13.960
That's excellent.

00:08:13.960 --> 00:08:16.740
That's Elliot Horowitz, who's the CTO of MongoDB, right?

00:08:16.740 --> 00:08:18.220
Yeah, exactly.

00:08:18.220 --> 00:08:18.620
Yeah.

00:08:18.620 --> 00:08:26.580
So I suspect most people who are listening to this show have heard of MongoDB, although maybe not everybody.

00:08:26.580 --> 00:08:29.100
And they might maybe just know it as a buzzword.

00:08:29.100 --> 00:08:32.200
Can you give us the quick elevator pitch of what MongoDB is?

00:08:32.440 --> 00:08:32.840
Sure.

00:08:32.840 --> 00:08:32.840
Sure.

00:08:32.840 --> 00:08:36.020
So it stores your data.

00:08:36.020 --> 00:08:37.060
It's a database.

00:08:37.060 --> 00:08:45.620
And it stores your data not in rows and columns, but in a non-relational document format.

00:08:45.620 --> 00:08:49.780
And the format is called BSON, which is a binary JSON format.

00:08:50.780 --> 00:08:56.040
So if you know JSON, MongoDB's data format is very familiar.

00:08:56.040 --> 00:09:00.740
It consists of objects, which have a set of key value pairs.

00:09:00.740 --> 00:09:11.440
And these documents can also contain arrays, strings, numbers, dates, and about a dozen primitive data types.

00:09:11.440 --> 00:09:19.760
MongoDB lets you index and query this kind of object-oriented data in a very rich way.

00:09:20.180 --> 00:09:36.380
So among the document databases that we compete with, we have a particular advantage when it comes to our ability to declare multiple indexes on a collection,

00:09:36.380 --> 00:09:42.720
the sophistication of our query language and our statistical aggregation capabilities,

00:09:42.920 --> 00:09:52.680
and our ability to let you do very complex update operations where you can add a member to a set within a document

00:09:52.680 --> 00:09:56.420
or do math on numbers within those documents.

00:09:56.420 --> 00:10:02.480
One of the things that I find people coming from a relational database world feel like,

00:10:02.480 --> 00:10:06.660
a lot of times they're like, well, it's really cool you can have these kind of hierarchical structures

00:10:06.660 --> 00:10:12.920
that more closely match the way your objects look in memory in your program.

00:10:12.920 --> 00:10:16.960
But you probably can't query properly deep down with this stuff.

00:10:16.960 --> 00:10:19.860
So if I've got, let's take a super simple example, like a bookstore,

00:10:19.860 --> 00:10:25.180
and the bookstore has books and the books have reviews as nested, like a nested array.

00:10:25.180 --> 00:10:29.820
Well, what if I just want to know all the books that have five-star reviews?

00:10:29.820 --> 00:10:31.240
Could I query that?

00:10:31.240 --> 00:10:32.160
Right, exactly.

00:10:32.160 --> 00:10:41.920
And we do provide that, and that distinguishes us somewhat from the much simpler sort of key value store

00:10:41.920 --> 00:10:45.940
or other simplified document database product.

00:10:45.940 --> 00:10:47.260
Yeah, definitely.

00:10:47.260 --> 00:10:50.360
And I think, you know, of all the NoSQL databases,

00:10:50.360 --> 00:10:55.160
MongoDB is one of the few that would reasonably be something you could consider

00:10:55.160 --> 00:11:01.740
as your standard general purpose database, not just some kind of high-scale special use case.

00:11:01.740 --> 00:11:02.980
Yeah, that's exactly right.

00:11:02.980 --> 00:11:07.540
And MongoDB is not the best answer to every single question, obviously.

00:11:07.540 --> 00:11:11.240
There is data that is naturally relational,

00:11:11.240 --> 00:11:17.060
and then there is data that should naturally be put in some other simpler,

00:11:17.060 --> 00:11:19.180
more specialized NoSQL database.

00:11:19.180 --> 00:11:24.780
But MongoDB is very much targeted to be the best answer to many questions

00:11:24.780 --> 00:11:28.760
questions and a pretty good answer to an even broader set of questions.

00:11:28.760 --> 00:11:35.860
So you can use it as your default database in the way that you might have in the past been used to,

00:11:35.860 --> 00:11:41.620
MySQL or Postgres being a pretty good answer to many questions and the best answer to many others.

00:11:42.580 --> 00:11:45.320
This episode is sponsored by Python Gear.

00:11:45.320 --> 00:11:47.520
We know you're a huge fan of Python,

00:11:47.520 --> 00:11:52.180
and Python Gear has an excellent way to put your enthusiasm for Python on display.

00:11:52.180 --> 00:11:57.940
Visit pythongear.com and pick up Python or Django t-shirts, stickers, and more.

00:11:57.940 --> 00:12:00.420
Hand screen printed on American apparel,

00:12:00.420 --> 00:12:03.460
these are shirts that are made to last and are very comfortable.

00:12:04.120 --> 00:12:08.660
What's more, a portion of all sales will benefit either the Python Software Foundation

00:12:08.660 --> 00:12:10.580
or the Django Software Foundation.

00:12:10.580 --> 00:12:13.680
Tell Python Gear thank you for sponsoring this podcast

00:12:13.680 --> 00:12:17.360
by visiting their site at pythongear.com and ordering a t-shirt.

00:12:17.360 --> 00:12:20.100
They're also helping us with a small contest.

00:12:20.100 --> 00:12:23.680
We're giving away a free t-shirt to one lucky listener.

00:12:23.680 --> 00:12:27.880
Visit talkpythontimi.com, click on Friends of the Show,

00:12:27.880 --> 00:12:31.280
enter your email address, and we'll pick a winner before the next episode.

00:12:31.280 --> 00:12:32.980
Now, back to the show.

00:12:32.980 --> 00:12:38.940
So, I've got MongoDB, and by the way, in case people didn't know,

00:12:38.940 --> 00:12:42.180
it's open source, you can go to GitHub and check it out or see the progress.

00:12:42.180 --> 00:12:46.480
I've gotten it, but probably I downloaded it from mongodb.org,

00:12:46.480 --> 00:12:48.000
and it's running.

00:12:48.000 --> 00:12:49.340
Now I've got my Python app.

00:12:49.340 --> 00:12:50.220
What do I do?

00:12:50.220 --> 00:12:50.960
Right.

00:12:50.960 --> 00:12:56.780
So, MongoDB's network protocol is called the MongoDB Wire Protocol,

00:12:56.780 --> 00:13:01.060
and it's a basic TCP protocol.

00:13:01.060 --> 00:13:04.160
So, you need something that knows how to talk that protocol

00:13:04.160 --> 00:13:10.120
and knows how to convert between your Python data structures,

00:13:10.120 --> 00:13:13.020
your dicts and lists and strings and numbers,

00:13:13.020 --> 00:13:15.240
to BSON and back.

00:13:15.240 --> 00:13:16.440
So, you need a driver.

00:13:16.440 --> 00:13:21.640
And the standard driver for MongoDB is called PyMongo,

00:13:21.980 --> 00:13:26.120
and you install it from PyPI via PIP, install PyMongo.

00:13:26.120 --> 00:13:32.120
The current version is about to be 3.0,

00:13:32.120 --> 00:13:34.280
which we'll release in just about a week,

00:13:34.280 --> 00:13:35.940
which is very exciting.

00:13:35.940 --> 00:13:37.860
Yeah, that's big news.

00:13:37.860 --> 00:13:41.700
Like, you guys have been trying to have a sort of a major unification

00:13:41.700 --> 00:13:43.760
of all the different drivers for the different languages.

00:13:44.080 --> 00:13:45.080
Is this part of that effort?

00:13:45.080 --> 00:13:46.400
Yeah, that's exactly right.

00:13:46.400 --> 00:13:51.700
So, PyMongo 3 has big behavioral and API improvements

00:13:51.700 --> 00:13:52.800
and standardizations,

00:13:52.800 --> 00:14:00.140
and that those changes are matched by the MongoDB Ruby driver 2.0,

00:14:00.140 --> 00:14:02.080
the C driver 1.2,

00:14:02.080 --> 00:14:03.600
the nose driver 2.0,

00:14:03.720 --> 00:14:04.720
and so on.

00:14:04.720 --> 00:14:08.240
And much more than ever before,

00:14:08.240 --> 00:14:11.760
we are all converging on the same set of behaviors

00:14:11.760 --> 00:14:13.040
and the same set of APIs.

00:14:13.040 --> 00:14:14.140
That's really cool.

00:14:14.140 --> 00:14:16.100
One of the real benefits of Mongo, I think,

00:14:16.100 --> 00:14:18.060
is it has great support for so many languages.

00:14:18.060 --> 00:14:20.040
So, if you choose your database,

00:14:20.040 --> 00:14:22.820
you're like, oh, wait, maybe this is better from, you know,

00:14:22.820 --> 00:14:23.980
Java for some reason.

00:14:23.980 --> 00:14:26.600
It still has a good data access story.

00:14:26.600 --> 00:14:27.580
So, that's fantastic.

00:14:27.580 --> 00:14:28.620
That's getting even better.

00:14:28.620 --> 00:14:29.620
Yeah, right.

00:14:29.620 --> 00:14:30.620
That's exactly right.

00:14:30.620 --> 00:14:35.360
So, we have drivers in 10 programming languages,

00:14:35.360 --> 00:14:41.240
and plus, even if you're using something weird like R or Haskell or Erlang,

00:14:41.240 --> 00:14:43.320
there's something out there in the community for you

00:14:43.320 --> 00:14:46.700
because writing a basic driver is actually fairly easy.

00:14:46.700 --> 00:14:50.440
We're really focused on making sure that each of these drivers

00:14:50.440 --> 00:14:54.260
feels right to experts in that language.

00:14:54.260 --> 00:14:56.420
So, PyMongo is very Pythonic,

00:14:56.420 --> 00:14:59.000
and it's written by Python experts,

00:14:59.540 --> 00:15:02.440
and its style and its documentation and so on

00:15:02.440 --> 00:15:04.280
are all very Python-y

00:15:04.280 --> 00:15:06.020
while at the same time balancing that

00:15:06.020 --> 00:15:07.320
with some degree of consistency

00:15:07.320 --> 00:15:10.560
with the nine other programming languages that we support.

00:15:10.560 --> 00:15:13.120
Yeah, there's got to be some interesting tension there.

00:15:13.120 --> 00:15:14.780
Huge, huge tension.

00:15:14.780 --> 00:15:17.260
It's the toughest problem that we face,

00:15:17.260 --> 00:15:19.340
and we are just in the last year or two

00:15:19.340 --> 00:15:22.640
really figuring out good bits to tackle that

00:15:22.640 --> 00:15:24.660
and to make those decisions correctly.

00:15:24.660 --> 00:15:25.820
Yeah, cool.

00:15:25.820 --> 00:15:28.640
So, you play a pretty big part in PyMongo, right?

00:15:28.820 --> 00:15:31.600
Yeah, I've been Bernie Hackett.

00:15:31.600 --> 00:15:36.840
My boss in Palo Alto is the PyMongo developer and maintainer,

00:15:36.840 --> 00:15:40.240
and I've been assisting him for the last three years

00:15:40.240 --> 00:15:41.960
as his second-in-command.

00:15:42.840 --> 00:15:48.820
And my main contributions to the driver are its concurrency design,

00:15:48.820 --> 00:15:55.880
its implementation of distributed systems type problem solving,

00:15:55.880 --> 00:15:58.980
and the connection pool.

00:15:58.980 --> 00:16:05.720
And with the 3.0 release, that's actually kind of done for the moment.

00:16:06.960 --> 00:16:11.300
And so I'm putting a lot of that work to rest now

00:16:11.300 --> 00:16:16.520
and moving on to become the primary maintainer of the C driver for MongoDB

00:16:16.520 --> 00:16:21.120
so that that part of the team can move into the kernel team

00:16:21.120 --> 00:16:22.380
and make contributions there.

00:16:22.380 --> 00:16:23.640
Oh, that's excellent.

00:16:23.640 --> 00:16:26.700
And that's even a little bit back to your roots from Austin,

00:16:26.700 --> 00:16:29.720
in some ways, I guess, right, with the C++ story.

00:16:30.740 --> 00:16:31.760
Yeah, exactly.

00:16:31.760 --> 00:16:37.740
Parts of my brain that has been idle for a decade are coming back online,

00:16:37.740 --> 00:16:39.620
and it's a really fun feeling.

00:16:39.620 --> 00:16:40.580
I know it is.

00:16:40.580 --> 00:16:41.660
Yeah, yeah.

00:16:41.660 --> 00:16:46.620
If audience members, if you've been programming Python for 10 years straight,

00:16:46.620 --> 00:16:49.840
like I have, I really can't recommend enough

00:16:49.840 --> 00:16:53.580
learning a very different programming language or reviving one.

00:16:53.680 --> 00:16:55.720
It's incredibly satisfying.

00:16:55.720 --> 00:16:59.440
Yeah, and gives you interesting problem solving skills

00:16:59.440 --> 00:17:03.240
that you don't necessarily develop if you stay in just one language.

00:17:03.240 --> 00:17:03.740
So that's great.

00:17:03.740 --> 00:17:04.380
Yeah.

00:17:04.380 --> 00:17:07.040
Now, there's a bunch of ways to talk to MongoDB,

00:17:07.040 --> 00:17:08.700
even just from Python, right?

00:17:08.700 --> 00:17:10.380
So there's PyMongo.

00:17:10.380 --> 00:17:11.420
What else is there?

00:17:11.420 --> 00:17:15.780
So PyMongo is the general purpose driver,

00:17:15.780 --> 00:17:18.280
and it's the most featureful, the most standard,

00:17:18.580 --> 00:17:19.700
the best maintained,

00:17:19.700 --> 00:17:26.800
but it's not optimized for some specialized use cases.

00:17:26.800 --> 00:17:33.800
And you can think of these as CPU-bound versus I.O.-bound use cases.

00:17:33.800 --> 00:17:34.700
Right, okay.

00:17:34.700 --> 00:17:36.820
So for the I.O.-bound,

00:17:36.820 --> 00:17:39.860
cases where you've got a web application

00:17:39.860 --> 00:17:43.320
that has a huge number of client connections,

00:17:43.320 --> 00:17:46.780
but they're often kind of idle or sleepy connections,

00:17:46.780 --> 00:17:50.500
like if you're implementing a chat server

00:17:50.500 --> 00:17:52.400
or something with web sockets,

00:17:52.400 --> 00:17:56.880
you want to use an async framework in Python,

00:17:56.880 --> 00:17:59.320
like Tornado or Twisted

00:17:59.320 --> 00:18:03.320
or in the Python 3.4 standard library,

00:18:03.320 --> 00:18:04.820
we've got async.io now.

00:18:04.820 --> 00:18:06.280
Yeah, that's a cool new feature.

00:18:06.280 --> 00:18:09.800
Right, so these are awesome async frameworks,

00:18:09.800 --> 00:18:11.760
and they solve that problem brilliantly,

00:18:11.760 --> 00:18:14.980
but they've got a gigantic compatibility issue.

00:18:16.020 --> 00:18:18.820
none of the existing libraries work with them.

00:18:18.820 --> 00:18:24.060
None of the existing sort of outside MongoDB libraries don't work with them,

00:18:24.060 --> 00:18:26.580
or like PyMongo itself doesn't work with them,

00:18:26.580 --> 00:18:27.140
or how do you mean?

00:18:27.140 --> 00:18:28.640
Well, I mean both of those.

00:18:28.640 --> 00:18:33.660
So if you've got basically a driver for any database

00:18:33.660 --> 00:18:36.980
that's not written specifically for one of these async frameworks,

00:18:36.980 --> 00:18:40.140
then it won't work with that async framework.

00:18:41.140 --> 00:18:44.780
So you need a specialized database driver for Tornado and MySQL.

00:18:44.780 --> 00:18:49.840
You need a specialized database driver for Tornado and Postgres.

00:18:49.840 --> 00:18:51.300
Right.

00:18:51.300 --> 00:18:54.380
And you need a specialized driver for Tornado and MongoDB.

00:18:55.100 --> 00:18:57.640
So I wrote that over the last few years,

00:18:57.640 --> 00:18:58.620
and it's called Motor,

00:18:58.620 --> 00:19:02.680
because it's taking the beginning of Mongo and Tornado.

00:19:02.680 --> 00:19:03.280
Excellent.

00:19:03.280 --> 00:19:04.540
Right.

00:19:04.540 --> 00:19:05.880
Plus it's a cool name,

00:19:05.880 --> 00:19:07.920
and somehow it was not yet taken on PyPI.

00:19:08.460 --> 00:19:15.920
So Motor is the now standard official async driver for MongoDB and Tornado,

00:19:15.920 --> 00:19:21.900
and over the next year I'm going to be expanding it out to cover async.io next,

00:19:21.900 --> 00:19:23.880
and then eventually twist it as well,

00:19:23.880 --> 00:19:26.620
so that it will just integrate with whatever you're using right now.

00:19:26.620 --> 00:19:27.120
Nice.

00:19:27.120 --> 00:19:29.140
And does that work with Python 3 and 2,

00:19:29.140 --> 00:19:30.940
or is that sort of a 2 thing for now,

00:19:30.940 --> 00:19:31.860
or what's the story there?

00:19:32.160 --> 00:19:35.480
That will work with Python 2.6 plus,

00:19:35.480 --> 00:19:41.320
so 2.6, 2.7, 3.3, 3.4, 3.5, when 3.5 is out.

00:19:41.320 --> 00:19:44.240
So how does that work with different implementations,

00:19:44.240 --> 00:19:45.400
like PyPI, for example?

00:19:45.400 --> 00:19:46.060
Sure.

00:19:46.060 --> 00:19:50.560
In the past, Motor and PyPI didn't work together very well,

00:19:50.560 --> 00:19:53.500
but that was about a year ago that I last personally tested them.

00:19:53.500 --> 00:19:56.580
It was correct, but it was slow,

00:19:56.580 --> 00:20:00.780
due to some very specific details about PyPI.

00:20:01.800 --> 00:20:03.060
In recent months,

00:20:03.060 --> 00:20:06.460
somebody that I didn't know posted benchmarks

00:20:06.460 --> 00:20:12.520
that showed that Tornado, Motor, and PyPI were actually blazingly fast,

00:20:12.520 --> 00:20:14.460
but I haven't personally reproduced that,

00:20:14.460 --> 00:20:18.820
so at the moment it's just kind of a hopeful sign

00:20:18.820 --> 00:20:20.940
rather than something that I would officially endorse.

00:20:20.940 --> 00:20:21.340
Sure.

00:20:21.340 --> 00:20:22.440
That's really good news, though.

00:20:22.440 --> 00:20:25.740
It looks like PyPI is moving on and has a lot of activity there,

00:20:25.740 --> 00:20:26.760
so that's really cool.

00:20:26.760 --> 00:20:27.520
I agree.

00:20:27.520 --> 00:20:27.980
Yeah.

00:20:27.980 --> 00:20:29.960
I've also heard of something called Mon Area.

00:20:29.960 --> 00:20:30.460
What's that?

00:20:30.460 --> 00:20:31.080
Right.

00:20:31.220 --> 00:20:34.160
So we've got this other branch of specialization.

00:20:34.160 --> 00:20:39.480
So the three categories that I think of are general purpose,

00:20:39.480 --> 00:20:41.320
PyO bound, and that's for Motor,

00:20:41.320 --> 00:20:45.520
and then there's CPU bound, and that's what Monary is for.

00:20:45.520 --> 00:20:50.280
Monary is a NumPy driver for MongoDB.

00:20:50.280 --> 00:20:51.560
Oh, that's interesting.

00:20:51.560 --> 00:20:52.040
Wow.

00:20:52.040 --> 00:20:52.960
Isn't it?

00:20:53.480 --> 00:20:55.480
I found out about it a few years ago.

00:20:55.480 --> 00:21:00.000
It was written by a quantitative analyst named David Beach.

00:21:00.000 --> 00:21:05.100
He needed it for something, some specific financial application that he was doing.

00:21:05.100 --> 00:21:13.900
And he noticed that if you stream BSON data through PyMongo and then into NumPy from there,

00:21:13.900 --> 00:21:15.400
it's pretty slow.

00:21:15.660 --> 00:21:18.820
And your data conversion is typically your bottleneck.

00:21:18.820 --> 00:21:20.240
MongoDB is fast.

00:21:20.240 --> 00:21:21.080
NumPy is fast.

00:21:21.080 --> 00:21:27.760
But converting each number from one data format to the next is very expensive,

00:21:27.760 --> 00:21:29.220
and it's a lot of wasted work.

00:21:29.920 --> 00:21:38.840
So he wrote a little bit of C code, which queries MongoDB using the C driver rather than PyMongo,

00:21:38.840 --> 00:21:46.760
converts the BSON data directly into NumPy arrays without passing through any Python data structure,

00:21:46.760 --> 00:21:52.000
and then hands you giant buffers of numbers that it got from MongoDB.

00:21:52.660 --> 00:21:59.420
And then you can use NumPy's incredibly fast statistical methods on that data.

00:21:59.420 --> 00:22:00.760
That's really fantastic.

00:22:00.760 --> 00:22:06.740
So if maybe you're storing a bunch of data in Mongo for big data on numerical type stuff,

00:22:06.740 --> 00:22:09.220
this would be the thing for you from Python.

00:22:09.220 --> 00:22:10.200
Exactly.

00:22:10.200 --> 00:22:14.240
And that's a pretty common use case among financial institutions.

00:22:14.240 --> 00:22:19.360
There's also a lot of universities doing big bioinformatics with MongoDB.

00:22:20.720 --> 00:22:28.100
And there's generally a lot of use within the scientific community for storing numeric data in MongoDB.

00:22:28.100 --> 00:22:37.620
Since NumPy has such a rich set of statistical routines that you can just take off the shelf,

00:22:37.620 --> 00:22:44.400
being able to go between the two in Python incredibly fast is an awesome feature.

00:22:44.400 --> 00:22:50.420
So Monary can do upwards of a million queries per second on commodity hardware.

00:22:50.420 --> 00:22:55.260
And, or query upwards of a million documents per second.

00:22:55.260 --> 00:22:56.800
That's amazing.

00:22:56.800 --> 00:23:00.520
We've been adding features to it over the years.

00:23:00.520 --> 00:23:04.800
We had a couple of interns last summer, Matt Cotter and Kyle Suarez.

00:23:04.800 --> 00:23:10.060
And now a new hire who's working for me, Anna Hurley,

00:23:10.060 --> 00:23:13.860
is adding more and more features to Monary every month.

00:23:13.960 --> 00:23:15.380
So it's becoming better documented.

00:23:15.380 --> 00:23:17.300
It's now read-write.

00:23:17.300 --> 00:23:21.040
So you can insert some NumPy arrays into MongoDB.

00:23:22.180 --> 00:23:24.900
And it's similarly optimized along that path.

00:23:24.900 --> 00:23:32.560
And we're adding SSL and authentication, which financial institutions will probably want if they're analyzing financial data.

00:23:32.560 --> 00:23:47.760
And that's kind of, that fills in the other portion of the environment where you're doing single-threaded CPU-bound calculations on numeric data within MongoDB.

00:23:48.300 --> 00:23:53.820
Yeah, that really does open up the whole science story for MongoDB a little bit more from Python anyway.

00:23:53.820 --> 00:23:54.480
That's really cool.

00:23:54.480 --> 00:24:01.720
So what surprises you most about what you see people doing with Mongo from Python or even with PyMongo specifically?

00:24:01.720 --> 00:24:08.880
What most often surprises me is there are certain mistakes that are incredibly common.

00:24:09.200 --> 00:24:11.480
And I wish we could figure out how to stamp them out.

00:24:11.480 --> 00:24:22.280
And the main mistake that I see people make is that they create a new Mongo client class instance for every HTTP request.

00:24:23.200 --> 00:24:35.820
And so they pay the price of TCP setup, very often SSL and authentication setup, and then the TCP slow start algorithm.

00:24:35.820 --> 00:24:40.580
All of this incredible overhead involved in opening a socket.

00:24:40.580 --> 00:24:42.900
And then they do one query and shut it all down.

00:24:44.680 --> 00:24:49.160
And when they say, oh, and they defeat connection pooling as well.

00:24:49.160 --> 00:24:58.020
And there's this sort of strange resistance to just creating a single global variable, which is the Mongo client.

00:24:58.020 --> 00:24:59.260
And I don't understand.

00:24:59.260 --> 00:25:04.860
I think they're coming from Java, where it's frowned upon to have one module-level global variable.

00:25:05.520 --> 00:25:19.860
But it means that among Python programmers who make this mistake, which is a huge number of people, their throughput is probably a third or a quarter or a fifth of what they should be seeing.

00:25:19.860 --> 00:25:21.220
Wow, that's amazing.

00:25:21.220 --> 00:25:23.440
And it's easy to fix.

00:25:23.440 --> 00:25:24.460
I don't understand apps to persuade people.

00:25:24.460 --> 00:25:26.220
It's incredibly easy to fix.

00:25:26.220 --> 00:25:27.240
That's the thing, right?

00:25:27.240 --> 00:25:27.780
Right.

00:25:27.780 --> 00:25:31.700
Doing it correctly is easier than doing it wrong, and yet doing it wrong is very common.

00:25:31.700 --> 00:25:32.100
Yeah.

00:25:32.100 --> 00:25:37.020
Well, hopefully people out there listening will go make a global Mongo client.

00:25:37.020 --> 00:25:38.020
I hope so.

00:25:38.020 --> 00:25:48.460
And we're also adding a best practices document to the PyMongo documentation in the next release that I hope will further dissuade people from making this error.

00:25:48.460 --> 00:25:49.720
Yeah, that'd be great.

00:25:49.720 --> 00:25:55.620
Almost would be cool to have a list of, like, these are the top five worst things you could do that we see out in the wild, so don't do them.

00:25:55.620 --> 00:25:57.920
You know, something like that would be nice to put up somewhere.

00:25:57.920 --> 00:26:01.440
That's a good idea, although honestly, it's really only top one.

00:26:01.440 --> 00:26:06.060
Like, if you don't do that, you're probably doing a good job.

00:26:06.060 --> 00:26:06.860
Excellent.

00:26:06.860 --> 00:26:09.000
So you guys just had a big release as well.

00:26:09.000 --> 00:26:15.420
You've kind of changed the entire underlying file system with something called WireTiger, and you've released version 3.0.

00:26:15.420 --> 00:26:17.800
What's the quick rundown of that?

00:26:17.800 --> 00:26:18.580
That's pretty exciting.

00:26:18.580 --> 00:26:19.420
Right.

00:26:19.540 --> 00:26:21.640
So it's not the default at the moment.

00:26:21.640 --> 00:26:23.240
It's opt-in.

00:26:23.240 --> 00:26:31.680
But with MongoDB 3.0, we made the option available to swap our old storage engine with WireTiger.

00:26:32.540 --> 00:26:41.900
And the performance characteristics are still a little complex, so I'm not going to make any inexpert pronouncements on that.

00:26:41.900 --> 00:26:42.420
Sure.

00:26:42.420 --> 00:26:54.340
But for the large number of use cases, WireTiger seems to be much, much higher performance, and it especially has much better concurrency.

00:26:54.340 --> 00:27:02.100
So if you're doing a lot of simultaneous writes on certain kinds of hardware, you should see a lot better throughput with WireTiger.

00:27:02.100 --> 00:27:04.880
So it's really exciting.

00:27:04.880 --> 00:27:07.120
And we also acquired that company.

00:27:07.120 --> 00:27:09.340
It was our first acquisition so that we could...

00:27:09.340 --> 00:27:19.680
The WireTiger open source project continues, but it means that we have that expertise in-house to make sure that WireTiger and MongoDB work perfectly together.

00:27:19.680 --> 00:27:20.560
That's right.

00:27:20.720 --> 00:27:23.860
They were from Berkeley DB or something like that originally, right?

00:27:23.860 --> 00:27:29.160
I think a lot of the WireTiger people were among the Berkeley DB developers, yes.

00:27:29.160 --> 00:27:29.820
Yeah, excellent.

00:27:29.820 --> 00:27:32.660
You have some opinions on editors, right?

00:27:32.660 --> 00:27:34.560
Like Vim versus PyCharm.

00:27:34.560 --> 00:27:36.040
What are your thoughts there?

00:27:36.040 --> 00:27:37.020
Yeah.

00:27:37.020 --> 00:27:46.380
So in recent years, I've spent a lot of time mentoring young people or just working together with a lot of junior developers.

00:27:46.380 --> 00:27:50.040
And what I particularly noticed is that everybody uses Vim for everything.

00:27:50.660 --> 00:27:57.300
And it's kind of sad to watch because I say, go find this method.

00:27:57.640 --> 00:28:16.560
And then I sort of have to sit around for a little bit, drinking tea and watching them grepping their files and doing like an incremental search through each file with Vim until, you know, they're searching for like death space, create collection or something in order to find this method.

00:28:16.620 --> 00:28:23.260
And it's just sad.

00:28:23.260 --> 00:28:30.900
And when people watch me, it's just, you know, this isn't bragging.

00:28:30.900 --> 00:28:36.560
It's just, if you use the right tool for the job, you can leap around really easily.

00:28:36.560 --> 00:28:40.420
And it's not just navigation.

00:28:40.420 --> 00:28:43.940
It's for huge search and replace jobs.

00:28:43.940 --> 00:28:54.700
PyCharm has all of these modes and all of these wonderful ways of breaking down big code change tasks to make sure that you complete them correctly.

00:28:55.220 --> 00:28:58.400
Using a visual debugger is also completely invaluable.

00:28:58.400 --> 00:29:02.420
Like when I see somebody say, I have this bug.

00:29:02.420 --> 00:29:03.600
And I say, well, what if you try it?

00:29:03.600 --> 00:29:05.580
And they say, well, I added 100 print statements.

00:29:05.580 --> 00:29:07.460
I know that something's wrong.

00:29:07.460 --> 00:29:14.160
And invariably, even though they've spent hours on it, I say, well, let's get it into PyCharm.

00:29:14.820 --> 00:29:18.780
And I use a couple of breakpoints and a few watchpoints.

00:29:18.780 --> 00:29:22.680
And we find it because that's what a debugger is for.

00:29:22.680 --> 00:29:23.400
That's right.

00:29:23.400 --> 00:29:27.200
A picture is worth a thousand words and you can kind of say the same about a visual debugger, right?

00:29:27.200 --> 00:29:28.100
Yeah, exactly.

00:29:28.100 --> 00:29:33.440
You don't have to ask via a print statement, is this what I expect?

00:29:33.440 --> 00:29:34.240
Oh, it is.

00:29:34.240 --> 00:29:34.480
Okay.

00:29:34.480 --> 00:29:35.760
Well, is this what I expect?

00:29:35.760 --> 00:29:36.720
Oh, it is.

00:29:36.720 --> 00:29:37.280
Right.

00:29:37.280 --> 00:29:44.180
You just have everything displayed for you and you can immediately see what it is about the code that isn't matching your expectations.

00:29:44.740 --> 00:29:45.560
Yeah, that's awesome.

00:29:45.560 --> 00:29:46.960
I totally agree with you.

00:29:46.960 --> 00:29:48.880
And I'm a big fan of PyCharm as well.

00:29:48.880 --> 00:29:50.320
I use it for all my Python work.

00:29:50.320 --> 00:29:57.640
And you can just hit like shift two times and type something and it'll just take you to a file or to a method or to a variable.

00:29:57.640 --> 00:29:58.980
It's fantastic.

00:29:58.980 --> 00:30:00.300
Yeah, I agree.

00:30:00.300 --> 00:30:05.060
It also shows you your unused imports and it checks your style while you go.

00:30:05.060 --> 00:30:06.900
So you start making that error as well.

00:30:06.900 --> 00:30:09.540
Yeah, you're sort of PEP8 compliant straight away.

00:30:09.540 --> 00:30:10.880
Exactly.

00:30:10.880 --> 00:30:12.100
Awesome.

00:30:12.100 --> 00:30:13.640
All right.

00:30:13.640 --> 00:30:15.360
Well, let me ask you one more question.

00:30:15.360 --> 00:30:22.740
So out there on PyPI, there's tons and tons, you know, 65,000, 56,000, something like that packages.

00:30:22.740 --> 00:30:24.860
There's some great ones out there.

00:30:24.860 --> 00:30:25.560
Do you have any favorites?

00:30:25.560 --> 00:30:27.640
PyMongo and Motor maybe, huh?

00:30:27.640 --> 00:30:29.560
Yeah.

00:30:29.560 --> 00:30:31.740
PyMongo is a great package.

00:30:31.900 --> 00:30:32.940
It's one of the most popular.

00:30:32.940 --> 00:30:32.940
It's one of the most popular.

00:30:32.940 --> 00:30:38.040
And Motor is a fun little project written by some smart guy somewhere.

00:30:38.040 --> 00:30:39.060
I wonder who that was.

00:30:41.460 --> 00:30:42.880
I'm also a big fan.

00:30:42.880 --> 00:30:47.480
And so another package I wrote that I'm very fond of is called Toro.

00:30:47.480 --> 00:30:49.240
It's T-O-R-O.

00:30:49.740 --> 00:30:56.680
And it's a set of things that are like locks, queues, conditions, event variables.

00:30:56.680 --> 00:30:59.440
But it's not for multi-threading.

00:30:59.640 --> 00:31:01.820
It's for Tornado coroutines.

00:31:01.820 --> 00:31:03.020
Oh, okay.

00:31:03.020 --> 00:31:07.760
So it kind of extends the analogy between coroutines and threads.

00:31:07.760 --> 00:31:17.320
And it makes it possible for your asynchronous coroutines, which are optimized for I-O-bound applications using something like Tornado.

00:31:17.320 --> 00:31:23.780
It lets them coordinate using the same kinds of patterns you're used to with threads.

00:31:23.780 --> 00:31:32.100
So you can make consumer-producer coroutines using the exact same pattern as you're used to for producer and consumer threads.

00:31:32.840 --> 00:31:47.820
I'm working with Tornado's author, Ben Darnell, to contribute Toro piece-by-piece into Tornado so that Tornado will have those features built in with Tornado 4.2.

00:31:47.820 --> 00:31:50.800
It has nothing to do with MongoDB.

00:31:50.800 --> 00:31:56.800
I think it's one of the things I like about it is that it's just this separate project that I kind of use recreationally.

00:31:56.800 --> 00:32:02.080
And it's also just got a lot of really fun patterns that it's fun to think about.

00:32:02.660 --> 00:32:03.840
Yeah, that's really cool.

00:32:03.840 --> 00:32:12.460
You know, that kind of programming, trying to coordinate asynchronous coroutines, sounds like a really interesting sort of problem or puzzle to solve, you know?

00:32:12.460 --> 00:32:13.060
Right.

00:32:13.060 --> 00:32:16.420
And a lot of those questions have already been answered for threads.

00:32:16.420 --> 00:32:27.820
So if you have the same primitives or if you have analogous primitives to use with coroutines, then you can use the same answers that people have developed for threads for the last few decades.

00:32:28.040 --> 00:32:28.440
Fantastic.

00:32:28.440 --> 00:32:30.220
So, yeah, people should check out Toro.

00:32:30.220 --> 00:32:30.780
Very cool.

00:32:30.780 --> 00:32:33.960
People have been listening to us talk and rave about MongoDB.

00:32:33.960 --> 00:32:38.800
And in case you guys don't know, I'm a huge fan of MongoDB as well and use it for many projects.

00:32:38.800 --> 00:32:42.340
If people are excited, they want to get started, what do they need to do?

00:32:42.340 --> 00:32:50.520
So you can pip install PyMongo and then you can go to mongodb.org and download the MongoDB server.

00:32:50.520 --> 00:32:54.440
It's among other awesome things about MongoDB.

00:32:54.440 --> 00:32:58.260
You install it by untarring it and then starting it, period.

00:32:59.200 --> 00:33:09.780
And if you want to learn more, the PyMongo documentation online at api.mongodb.org slash python has a complete tutorial for you.

00:33:09.780 --> 00:33:16.820
And if you want to go a little deeper, there's an excellent online course called M101P.

00:33:16.820 --> 00:33:19.220
So that's MongoDB 101 for Python.

00:33:19.700 --> 00:33:24.700
And the next section of that class starts on May 26th, I think.

00:33:24.700 --> 00:33:25.880
Excellent.

00:33:25.880 --> 00:33:29.160
And is that education.mongodb.org?

00:33:29.160 --> 00:33:30.260
I forget the URL.

00:33:30.260 --> 00:33:31.200
Yeah, that's correct.

00:33:31.200 --> 00:33:32.180
Yep, exactly.

00:33:32.180 --> 00:33:33.240
Excellent.

00:33:33.240 --> 00:33:37.920
Okay, well, is there anything else you want to sort of give a shout out to or get people's attention focused on?

00:33:37.920 --> 00:33:40.920
I'm just really excited to be on this podcast.

00:33:40.920 --> 00:33:43.980
And I think that this podcast is excellent.

00:33:43.980 --> 00:33:48.760
And I'm looking forward to listening to the next episodes while I'm on the subway.

00:33:48.760 --> 00:33:50.040
Excellent.

00:33:50.040 --> 00:33:50.740
Thank you, Jesse.

00:33:50.740 --> 00:33:52.500
It's been a really great conversation.

00:33:52.500 --> 00:33:55.100
And I think people are going to be super interested in this stuff.

00:33:55.100 --> 00:33:55.920
It's good.

00:33:55.920 --> 00:33:58.160
MongoDB is such a fun project to work with.

00:33:58.160 --> 00:34:03.320
When I was working with relational databases, I always felt like, oh, there's this sort of database and it's a necessary evil.

00:34:03.320 --> 00:34:06.140
And it's kind of resisting what I'm trying to build in my app.

00:34:06.180 --> 00:34:10.900
And you switched to Mongo and it's just sort of frictionless design and evolution in your app.

00:34:10.900 --> 00:34:14.080
And so thanks for all your work on making that a possibility.

00:34:14.080 --> 00:34:15.420
Thanks so much, Michael.

00:34:15.420 --> 00:34:16.140
You bet.

00:34:16.140 --> 00:34:16.680
Talk to you later.

00:34:16.680 --> 00:34:17.840
Bye.

00:34:17.840 --> 00:34:23.260
This has been another episode of Talk Python to Me.

00:34:23.260 --> 00:34:27.040
I want to thank our sponsor, Python Gear, for making this show possible.

00:34:27.040 --> 00:34:34.000
Please visit pythongear.com, get an awesome T-shirt or sticker, and let them know you heard about them on Talk Python to Me.

00:34:34.700 --> 00:34:36.160
Smix, take us out of here.

00:34:36.160 --> 00:34:58.760
Bye.

00:34:58.760 --> 00:34:59.080
Thank you.

