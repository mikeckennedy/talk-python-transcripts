00:00:00 Do you have a new web project coming up?

00:00:01 Are you thinking about choosing Django or maybe Flask?

00:00:03 Those are excellent frameworks, but you might also want to check out TurboGears.

00:00:08 It was created and released around the same time as Django.

00:00:10 It lets you start your project as a micro framework, kind of like Flask,

00:00:14 and yet you can scale up to a full stack solution, more like Django.

00:00:17 It has built-in support for both relational databases via SQLAlchemy and MongoDB.

00:00:24 This week, Alessandro Molina is here to tell us all about TurboGears.

00:00:28 This is episode number 35 of Talk Python To Me, recorded October 28th, 2015.

00:00:57 Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the ecosystem,

00:01:05 and the personalities.

00:01:06 This is your host, Michael Kennedy.

00:01:09 Follow me on Twitter where I'm @mkennedy.

00:01:11 Keep up with the show and listen to past episodes at talkpython.fm, and follow the show on Twitter via at Talk Python.

00:01:18 This episode is brought to you by Hired and CodeShip.

00:01:21 Thank them for supporting the show on Twitter via at Hired underscore HQ and at CodeShip.

00:01:26 Hey, everyone.

00:01:28 Before we get to the interview, I want to tell you about a project I'm working on,

00:01:32 and I need your help to make it happen.

00:01:34 I've been asked by many listeners something along the lines of, how do I get started learning Python?

00:01:38 Or, I'm new to Python.

00:01:40 What should I focus on?

00:01:41 And sometimes people even ask, how do I get a job as a Python programmer?

00:01:46 I've decided to answer this question via a roundtable discussion format between people who just got into the industry as new developers

00:01:53 and people who make decisions about hiring new developers on Python teams.

00:01:57 This is where you come in.

00:01:59 If you're a newly hired Python developer, maybe you got your job in the last year or so,

00:02:03 would you come on the show and spend 10 minutes talking about how you learned Python and how you got started in software development?

00:02:10 Maybe what it was that got you your first job?

00:02:13 That kind of stuff?

00:02:14 On the other hand, if you're a technical leader responsible for hiring Python developers,

00:02:19 would you come on the show for also 10 minutes and give us recommendations for new and aspiring developers?

00:02:25 Maybe what you look for, what skills are really important to you, and just what you think they need to do to get started

00:02:32 and land that first interview and that first job.

00:02:34 You can read about the whole project in a blog post I just wrote at bit.ly slash talkpythonhiring.

00:02:42 Talkpythonhiring.

00:02:44 What do you say?

00:02:44 Can you come be part of the show and help your fellow developers?

00:02:47 I'm looking for maybe three to four people from each group.

00:02:50 If this isn't you, but you know someone who is the perfect fit for this little project of mine,

00:02:56 send them the link and encourage them to be part of it.

00:02:58 All right, now let's get on to the show.

00:03:00 Alessandro, welcome to the show.

00:03:04 Hi, Michael.

00:03:05 Thank you.

00:03:05 Hey, thanks for being on the podcast.

00:03:08 We've got some cool web stuff to talk about today.

00:03:10 So we're going to talk about TurboGear, its history, its evolution, why it's so awesome, and its future.

00:03:17 But before we get into all that cool stuff, let's talk about your story.

00:03:21 How did you get started in programming in Python?

00:03:23 I actually started programming in a totally different language, which was C++, and I actually hated Python at the beginning.

00:03:32 I was forced to use it at work at the company of a friend of mine, and then using it day by day, it's impossible to not fall in love with it,

00:03:41 because it's so clear, so fast, to rapidly prototype things, especially when compared to C++.

00:03:47 And so at the end, I started using Python for everything in my career.

00:03:52 And since I moved here in Turing and founded Accent, we worked on Python on practically everything.

00:04:00 That's really interesting.

00:04:02 So why didn't you like it in the beginning?

00:04:04 Well, it's really strange.

00:04:06 If you are a C++ developer, you're probably used to structuring your things a lot, thinking a lot about how you should make a class,

00:04:17 or everything is pretty much like the beauty behind the architecture of your code.

00:04:24 While Python is more direct, you can rapidly prototype things.

00:04:28 And at the beginning, I thought it was not a great idea to start throwing code which you can also like monkey patch or use mix-ins,

00:04:37 which are really powerful concepts, but if you don't pay attention to them, you might misuse them and end up with some chaos in your code,

00:04:48 which C++ somehow forced you to avoid doing that.

00:04:53 But at the end, clarity and simplicity of the language clearly wins over much of the other benefits of a mild structured language for me.

00:05:04 Yeah, I think a lot of people have that reaction.

00:05:06 It manifests itself in different ways.

00:05:09 So I think one of those common ways is people see Python so simple, doing things so simply, and they think, oh, well, this is so simple, it must not be a real language.

00:05:21 Like, where is the compile and link step?

00:05:24 And where is all of this, you know, other structure?

00:05:28 And so, you know, what good is Python for?

00:05:32 Is this just like kind of like a better scripting language rather than bash?

00:05:36 Right.

00:05:36 I mean, I get asked that question literally often.

00:05:38 Yeah.

00:05:39 My first impression was that too, but it was clearly wrong.

00:05:43 Yeah.

00:05:45 I mean, you can give some really interesting examples.

00:05:48 Like the guy from PayPal, Mahmoud Hashemi, who was on show number four, actually has a bunch of amazing examples of, you know, sort of discrediting that idea.

00:05:59 But it's a very common idea.

00:06:00 So you started there, and then you worked with Python, and over time you just fell in love with it, huh?

00:06:06 Yeah.

00:06:07 I think I went through something similar, I guess, in the beginning as well.

00:06:11 But it didn't take long to convince me that, you know, it was a good idea.

00:06:15 Let's talk about TurboGears.

00:06:18 What's TurboGears?

00:06:21 Well, TurboGears is a web development framework.

00:06:23 There are actually a lot in the Python ecosystem.

00:06:27 But I think it's one really particular one because that's some of the key concepts that you do not see often in other frameworks.

00:06:35 For example, TurboGears started as a collection of the best libraries available when TurboGears was created.

00:06:44 So it didn't start as a framework from scratch, okay?

00:06:48 It saw that there were really good ideas around and started and tried to collect them together.

00:06:54 And then moved into something more complex and more architectured into a real framework itself.

00:07:03 So the idea was, the original idea was, hey, look, here's a really cool templating engine.

00:07:09 And over here is some sort of HTTP processing library.

00:07:13 And here's a great little web server.

00:07:15 And if we just stitch these together into a package and kind of wire them together, hey, we have a web framework, right?

00:07:22 Yeah.

00:07:23 Practically, the core idea was that one.

00:07:25 So the team at the time started with Cherry Pie, with KID, with SQL objects, which were the most used technologies at the time, because we are talking around 2005 or something like that.

00:07:38 And they collected them all together, put a widgets library on top of that, which was at the time the TurboGears widgets library.

00:07:49 And then they started to create extensions and whatever was possible to evolve over that set of libraries and ended up having TurboGears, which at the time was something really powerful.

00:08:04 Because we are talking in years where even Django was just getting started.

00:08:11 Django was launched like two months before TurboGears.

00:08:14 So they got, like being created at the same time, whereas not much was available around.

00:08:20 So who was the original creator?

00:08:22 Well, TurboGears has been created at the version one, was created by Kevin Dungor, who works right now, I think, at Mozilla, if I'm not wrong.

00:08:33 And I don't know if he still works on web stack or web development and things like that.

00:08:40 But then he moved away from TurboGears and Mark Ram to cover the development of the 2.0 version and started rewriting it on top of pylons, which was like more modern technology at the time, was just getting at its peak of usage.

00:09:01 And new technologies like SQLAlchemy and new technologies like SQLAlchemy and Genshi was available.

00:09:07 So they decided to rewrite TurboGears from scratch and move from Cherry Pie and so on to pylons and Genshi and SQLAlchemy.

00:09:18 So to a totally different stack, which was better from their point of view.

00:09:24 But of course, it was totally different in new technology.

00:09:28 Yeah.

00:09:29 Did that make upgrading challenging?

00:09:30 Yeah.

00:09:31 Yeah.

00:09:31 Actually, one of the core reasons why TurboGears lost in user base and popularity at the time was because a lot of people had been scared by this move away from everything they were using for their daily development and had to rewrite most of their web application to a different framework, different template engine.

00:09:57 I actually were just getting started with TurboGears at the time.

00:10:04 I did like two web application with TurboGears one.

00:10:08 And I remember that I was really frustrated because I had to rewrite everything from scratch, like especially for the database part, because SQL object and SQLAlchemy are really, really different.

00:10:21 SQLAlchemy is far more flexible, more powerful, but it's a lot different from the syntax and the way you use SQL object usually.

00:10:32 Yeah.

00:10:32 Yeah.

00:10:32 So it's not just a, you know, pip install TurboGears upgrade and off you go.

00:10:39 It's a pretty serious thing to make that change.

00:10:41 And so that caused a lot of problems, like you said, for people getting frustrated.

00:10:45 Yeah.

00:10:46 That's, I think one of the reasons why we learned the lesson.

00:10:51 And then we tried to avoid breaking backward compatibility from version 2.1 and forward.

00:10:59 We never brought backward compatibility again, even when we switched away from pylons and we brought things.

00:11:06 That's been one of the core targets for TurboGears to try to not make the same error twice.

00:11:14 So going forward and for a long time since you upgraded to, it's like basically, all right, we're guaranteeing that you can more or less just continue to upgrade as we do releases.

00:11:26 Right?

00:11:27 Yeah, exactly.

00:11:28 For example, now we support Python 3, which as we know has a lot of differences and some libraries are not available on Python 3.

00:11:38 Like when TurboGear started, there was a paste.

00:11:43 And then we moved to a tool we created ourselves, Gearbox.

00:11:48 But the commands are the same and the options are the same.

00:11:52 And you just pick install one or the other.

00:11:54 And if you are on an old version of Python, you can also install paste and go on using that one.

00:12:01 So even when we replace technologies, we guarantee that you can use the new one or the old one and both will work for the long term.

00:12:09 And when we write a technology ourselves, we try to make sure that it's the same as the previous one as for the interface for the user and so on.

00:12:21 Okay, that's really great.

00:12:22 I think that's the right path.

00:12:24 You know, these apps are going to probably be long lived.

00:12:28 And so you want to be able to keep supporting them, right?

00:12:31 Before you mentioned a lot of interesting technologies like Gearbox and some of the other stuff that are the building blocks of TurboGears.

00:12:40 But before we get into that level of detail, let's talk a little bit about the philosophy of TurboGears.

00:12:48 On the webpage for TurboGears, on TurboGears.org, you have a couple of sort of reasons that TurboGears 2 was created, right?

00:12:59 So you say TurboGears 2, it's kind of based on the good ideas from Django, TurboGears 1, and Ruby on Rails and those types of things.

00:13:07 But you guys had frustrations with all of those frameworks.

00:13:12 Yeah, well, one of the core ideas behind TurboGears is to actually make possible to make a structure of your web application,

00:13:23 which is really simple and organized.

00:13:25 Okay, like one of the core parts that got frustrated me with frameworks like Django, Flask, or even Pylons itself,

00:13:35 which TurboGears was based on, was their routing.

00:13:38 Because while regular expressions are really, really powerful, if you have a huge project, they start to get somehow messy.

00:13:46 You have a lot of regular expressions.

00:13:48 You have to try to resolve them to understand where the code that serves that page or performs that action is actually.

00:13:55 And so if you work on a team and you have to test this project to another developer who has never seen that project before,

00:14:03 he will need a lot of time to get started into the project and understand where things are going, how things are done,

00:14:12 and where the code that does something is actually is.

00:14:15 And TurboGears actually uses a totally different dispatch model, which is called object dispatch,

00:14:21 on top of which everything, every URL, by default, is the path of your object.

00:14:30 So it's much like the pyramid traversal, if you have ever seen it, but it doesn't use dictionaries.

00:14:35 It uses objects.

00:14:37 So every controller has actually methods, which are the URLs you expose, and it can have subcontrollers, which are subparts of your website.

00:14:49 And if you do not provide any regular expression or any special routing on top of that,

00:14:54 they just get served exactly where you will find the object itself.

00:14:59 So if I see a user new URL, I know that it will be properly served by the new method inside the user file,

00:15:09 and I can go there and start doing whatever I need to do without needing to understand the structure of the project and things like that.

00:15:18 And this philosophy of having a framework which is easy for big projects and for people having to get started on an already existing project

00:15:29 is also visible on the template engine, because TurboGears uses one of the few template engines that is able to validate your HTML code.

00:15:39 So if you did something wrong with your HTML code, you do not discover it when you see the page and see that it's actually broken.

00:15:47 But you discover it at compile time when the template engine is compiled.

00:15:53 It will provide you with errors, for example.

00:15:55 You forgot to close the tag or things like that.

00:15:59 Oh, that's really cool.

00:16:00 Yeah, you know, I'm a big fan of both Pyramid and Flask.

00:16:04 This thing that you point out about the routing is, it is really annoying to have to configure that somewhere else

00:16:11 rather than just, hey, the way my files are laid out, boom, this is how it works, right?

00:16:16 Which is really, really nice.

00:16:17 And then down into the classes and so on.

00:16:19 So in TurboGears, you've got sort of the way of writing code that handles the requests are by creating controller classes, right?

00:16:28 So you derive from like a base class and then you add methods to that base class, right?

00:16:34 Exactly.

00:16:35 Of course, not everything that you write in your class is exposed as a URL because that would be a security issue.

00:16:42 But you can easily make things from a method to a web page.

00:16:47 The difference is just you have to put a decorator on top of the method and it becomes available.

00:16:53 Yeah, I really like the way that you guys are doing that there.

00:16:57 That's cool.

00:16:57 The other thing that you mentioned that's pretty nice is the templating engine is sort of self-verifying.

00:17:04 Like I'm using the Chameleon templates right now on my website.

00:17:09 And if something goes wrong, it's usually just a 500 server error.

00:17:14 You know, something is wrong.

00:17:16 Sorry.

00:17:17 Yeah.

00:17:18 It's really hard often to track down what's going on when you get that wrong.

00:17:23 Sometimes it gives you a good error message and sometimes it doesn't.

00:17:26 Well, you are already lucky because I remember that when I started working with Ruby on Rails,

00:17:33 there was Herb, which was the template engine.

00:17:37 And if something was wrong, you actually didn't get any error.

00:17:40 Your users were a broken page and nothing else.

00:17:44 So at least Chameleon provides you errors.

00:17:48 And what Genshi and the template engine to Ruby is using, try to do, is actually trying to parse the structure of your file.

00:18:00 So your template must be valid HTML.

00:18:03 And they parse it and they try to understand how it's made.

00:18:07 They try even to optimize it.

00:18:10 And they point out the exact error.

00:18:13 Like you forgot to close this tag at this line.

00:18:16 So you know where something was broken.

00:18:18 And as they actually parse the code, when you need to translate your web page,

00:18:25 it's really, really easy because everything which is inside the tag can be translated.

00:18:31 You don't have to mark with get text calls and things like that around.

00:18:35 If it is inside the call, it's a string that can be translated.

00:18:39 Yeah, that's really excellent.

00:18:41 So I don't know much about that template engine.

00:18:44 Is it possible to write like semi-structured HTML5?

00:18:49 Or does it have to be sort of pure XHTML?

00:18:52 So for example, with like HTML5, it's fine to just put like an angle bracket BR

00:18:58 with no, you know, closing, like auto-closing slash or self-closing slash

00:19:04 and things like that.

00:19:05 What's the story around that?

00:19:07 This episode is brought to you by Hired.

00:19:20 Hired is a two-sided curated marketplace that connects the world's knowledge workers

00:19:25 to the best opportunities.

00:19:27 Each offer you receive has salary and equity presented right up front.

00:19:31 And you can view the offers to accept or reject them before you even talk to the company.

00:19:36 Typically, candidates receive five or more offers in just the first week.

00:19:40 And there are no obligations ever.

00:19:42 Sounds pretty awesome, doesn't it?

00:19:44 Well, did I mention there's a signing bonus?

00:19:47 Everyone who accepts a job from Hired gets a $2,000 signing bonus.

00:19:51 And as Talk Python listeners, it gets way sweeter.

00:19:56 Use the link Hired.com slash Talk Python To Me and Hired will double the signing bonus to $4,000.

00:20:02 Opportunities knocking.

00:20:04 Visit Hired.com slash Talk Python To Me and answer the call.

00:20:18 Well, actually, if you're using Genshi, which is the default template engine for Google years,

00:20:24 you will have to write perfectly structured HTML files.

00:20:29 So you need to close your tags in line and things like that.

00:20:34 That's to actually tell to Genshi that you didn't forget to close the tag, but you did it on purpose.

00:20:41 But that's for that specific reason, because a great engine needs to be really structured and well validated.

00:20:49 Then if you want to output HTML5 and maybe avoid closing your head, avoid closing your body, or things like that,

00:21:03 you can just tell Google years to output the result in HTML5 mode.

00:21:08 And it will do that for you.

00:21:10 That might be even considered a really powerful feature, because if you want to switch from HTML5 to XHTML or even HTML4,

00:21:20 you just have to change the configuration options.

00:21:23 And this template engine will output the code you ask him to do.

00:21:28 That's really cool.

00:21:29 You know, I personally don't mind at all writing, you know, properly structured XHTML,

00:21:35 because I feel like I have, like you said, control I can check.

00:21:38 Okay, this is exactly right.

00:21:40 I guess it's probably a personal preference, but I like it.

00:21:44 Yeah.

00:21:45 So another one of the goals you guys had when you created TurboGear's 2 was, you said you want, unlike things like Django and Rails,

00:21:53 you want to be able to start as a micro framework, but scale up to a full stack solution.

00:21:58 What does that mean?

00:21:59 Well, actually, when TurboGear's was created, it was totally a full stack framework.

00:22:04 So it got started as full stack.

00:22:07 But as the community started moving forward more API development and web services and things like that,

00:22:16 it was clear that a full stack framework is far more complex than what you need to get started with a prototype on an API or similar things.

00:22:26 And then when we rewrote TurboGear's in version 2.3 removing pylons, and we took the chance to rewrite everything on top of a core,

00:22:39 which would make possible to have something which is a micro framework, so which provides everything you would expect, like a routing, like the configuration of your application,

00:22:54 but doesn't provide additional features like the template engine or the caching layer or things like that,

00:23:02 which you can turn on and turn off and replace with whatever library you want whenever you want.

00:23:09 For example, if I start to a new TurboGear's project, I will get it with Genshi, which is the default template engine.

00:23:17 Now if I want to use like Macro or Jinja or things like that, because I prefer to work with them,

00:23:25 I can actually start with a project that uses them instead of Genshi, and everything will work anyway.

00:23:33 Because when working as a micro framework, you actually do not have any template engine at the beginning.

00:23:40 You register one, and registering it just means enabling an option, and you get started with that one.

00:23:49 For if you want to turn on also database because you need SQL Archemy, you turn on another option, and SQL Archemy is enabled.

00:23:57 If you want to use something which TurboGear doesn't support at the moment,

00:24:02 you can just set up itself like you would with any other microframe or by flask or bottle or things like that.

00:24:10 Yeah, that's cool.

00:24:12 So if I want to, I could just create a single Python file, create a class, which is a controller,

00:24:18 and have a single method on there and give it the expose decorator, and more or less just, say, serve that.

00:24:27 And then I don't have the overhead of the database libraries, all the templating stuff.

00:24:34 All those different things are kind of not there.

00:24:37 So if I were writing like a really, really simple JSON-based service or something, maybe that would make sense.

00:24:43 Yeah.

00:24:44 Let me tell you an example.

00:24:47 Yesterday, one of the guys in our team needed a little tool to preview the result of a bootstrap theme he was working on.

00:24:58 And then I just created a quick and dirty file with TurboGear to render the theme, replacing some variables through the template engine and nothing else.

00:25:10 So I started with the microframework mode.

00:25:12 I started with what's called minimal mode in TurboGear.

00:25:17 Then we decided that it would have been cool to be able to upload multiple versions of the template and switch between them

00:25:24 and see the differences proposed to the other team members, which one was better and so on.

00:25:30 And to do that, we needed the database where to register everything.

00:25:34 We needed a crude where to create and update and modify the themes and things like that.

00:25:41 So I just switched to the full-strap framework.

00:25:44 I enabled the TurboGear's admin and I got the code for free.

00:25:49 I got the database set up for me.

00:25:51 And I have been able to create a full application in half an hour, starting from a single file and then moving to a full-strap application with login registration, multiple crowds, and so on.

00:26:07 Yeah, that's really interesting.

00:26:08 Because I think there's these two camps or two philosophies in Python web frameworks.

00:26:15 You've got things like Django, which are super full-strap, super comprehensive.

00:26:22 They even have admin backends and user management.

00:26:25 And they're big things, right?

00:26:27 And then on the other hand, you've got things like Flask and Bottle that are just very, very focused on, we will get the request to your method and then it's up to you.

00:26:37 You know, to some degree, right?

00:26:39 And so the ability to not rewrite that, go, well, it was working in Flask, but we need more.

00:26:44 So, whoop, off we go to Django.

00:26:46 But you just sort of grow it.

00:26:48 That's a pretty cool idea.

00:26:49 Yeah.

00:26:50 That's one of our objectives, what we are trying to do.

00:26:54 Yeah.

00:26:55 Another one that you have is you said you want to make sure that the code that you write for the web framework is code that is as natural as writing just a function.

00:27:03 Yeah.

00:27:04 Well, that's one of the philosophies behind the object dispatch system and so on.

00:27:10 We don't want people to have to mess with things like person parameters or the dispatch itself or things like that.

00:27:20 You just want a web page that accepts some parameters and you can get them through a get URL encoded method or you can get them in the body of the post or whatever.

00:27:37 It doesn't matter.

00:27:38 You just want some parameters to your code and you want to return something when that parameters arrive.

00:27:45 So, we really think that writing a web page is much like writing a Python method.

00:27:51 You get something and you output something else.

00:27:54 So, Python methods are perfect for doing that.

00:27:58 And so, to produce actually just whatever parameter you get into your page, it gets converted to an argument of your methods with the same name.

00:28:08 And whatever you return from your method is actually just a response of your web page.

00:28:15 Yeah.

00:28:16 That's interesting.

00:28:17 So, suppose I've got a user controller and a method called show and it's supposed to show the details of the user and I want to pass like the user ID to go maybe to a database and pull it out.

00:28:32 What is, could I have like user ID in the method for my show method?

00:28:37 Yeah.

00:28:38 You will just have a parameter which is an argument of your method which is named user ID, for example.

00:28:44 If I pass in the URL a user ID parameter, that will be the value of your argument.

00:28:51 Or, as Python supports position arguments, if you pass forward slash one, one will go into the user ID parameter as it is the first argument of the function.

00:29:04 That's awesome.

00:29:05 Yeah, I really like that because, you know, like I said, I'm a fan of Pyramid, but it's kind of challenging to get, you know, the route data and the post data and all those different things like gathered back up.

00:29:18 So, you can start actually, you know, processing the request.

00:29:21 So, that's really cool.

00:29:22 Another one of your philosophies is you wanted a powerful and flexible ORM with real multi-database support.

00:29:29 What's the story there?

00:29:30 When we started, one of the main issues with SQL Object was actually that it was not as flexible as SQLAlchemy.

00:29:40 And when we moved to SQLAlchemy, we saw that it was really simple to set up something like master-slave configurations on SQLAlchemy and the route and methods and queries depending on what we were doing through the SQLAlchemy session and things like that.

00:29:59 So, when you are used Turbo Gears, you actually get out of the box something like the master-slave support.

00:30:06 Whenever a method does only read, it will be rooted to the slaves by Turbo Gears itself.

00:30:13 It is tried.

00:30:14 If it tries to write something, it will be rooted to the master of your database configuration.

00:30:21 And that's possible thanks to the SQLAlchemy unit of work because at the end of the request, when the unit of work is flushed, you know if it contains only reads or it will contain any change of the documents.

00:30:35 And so, you can decide where you should perform those operations.

00:30:40 Yeah, SQLAlchemy is pretty awesome.

00:30:42 And that whole unit of work idea and auto-commit or auto-rollback of transactions on errors, there's a lot of really neat stuff.

00:30:49 That's cool that you're leveraging that.

00:30:51 Yeah, and that's also something we are trying to leverage also MongoDB.

00:30:57 That's the reason why we choose Ming as the MongoDB library for Turbo Gears because that's pretty much the same concept.

00:31:05 You get an identity map, so you don't have duplicates in your code.

00:31:10 You get a unit of work, so you can flush all your changes at the end and have a single optimized set of actions instead of replicating the updates to your database.

00:31:22 And you can decide to perform something when the changes are flushed and things like that.

00:31:29 Yeah, that's really cool.

00:31:30 And I think it's great that you support MongoDB and get a choice.

00:31:34 So, sort of the whole relational database story is covered by SQLAlchemy, which is pretty comprehensive.

00:31:40 And then if you want good NoSQL integration, nice document database, well, MongoDB is pretty straightforward choice, right?

00:31:47 Yeah, actually, I've been using MongoDB for years now.

00:31:52 And then, like, 70% of the web applications I'm starting are based on MongoDB because it's a really powerful and convenient technology.

00:32:02 And so, I wanted to go to use Web as much support for MongoDB as it had for SQLAlchemy.

00:32:09 And as we have a middleware, which is called Sprox, which permits to convert the queries in the two formats, it was not so difficult to provide support for MongoDB in most TurboGias extensions, like the TurboGias admin or the registration module or things like that.

00:32:31 So, whenever you plug an extension into TurboGias, you can be pretty sure that it will probably work with MongoDB too.

00:32:40 Yeah, that's excellent.

00:32:41 Yeah, that's excellent.

00:32:41 And I totally agree with you.

00:32:43 Like, at least 75% of the time, if I'm doing a new web app and it needs a database, you know, I need a reason not to use MongoDB, not a reason to use it, you know?

00:32:52 Yeah, it's the same for me.

00:32:54 Yeah, it's awesome.

00:32:56 So, another thing you talked about is sort of built-in support for horizontal data partitioning or what's known as sharding.

00:33:03 So, that's actually something that's not strictly related to TurboGias itself, as we say, because it's another of those features which SQLAlchemy makes possible.

00:33:13 But as TurboGias works on the concept of having one or multiple database sessions available, if you want to work on different nodes of your database and perform sharding, you can just set up different database sessions, one for each shard, and register your models on one session or the other.

00:33:38 And whenever you perform a query on this or that model or whatever any extension, the admin or whatever you're using performs a query on that model, it will know that it has to perform that query on that database shard.

00:33:52 Yeah, that's really cool.

00:33:54 And that works with relational databases as well?

00:33:56 Well, for MongoDB, it works really simple.

00:33:59 And while for SQLAlchemy, you actually lose the ability to perform joins when doing that because you're actually storing the data scattered across multiple databases.

00:34:09 Yeah.

00:34:10 Okay.

00:34:11 Yeah, you definitely have to give up a little bit on the relational side, which is kind of what the NoSQL databases are doing anyway to get better.

00:34:17 So, it's all good.

00:34:18 It's all good with me.

00:34:19 So, one of the other things you talked about is support for multiple data exchange formats.

00:34:25 Is that kind of like the hypermedia component of REST?

00:34:29 Like, I could do a GET against a URL and have the accept type as image or the accept type as JSON and have it return different stuff based on that?

00:34:39 Yeah.

00:34:40 Actually, something like that because the routing of TurboGirth itself permits to register multiple expositions of your method.

00:34:51 And so, your method is able to respond like three different things.

00:34:55 You can return a webpage.

00:34:56 You can return a PDF file or you can return whatever you want.

00:35:01 And whenever the routing understands that there is an accept header or any other reason, for example, it also works by the extension.

00:35:11 If I put .json at the end of my URL, the TurboGirth will try to route to something which is able to respond as JSON.

00:35:21 So, if your method is able to respond to HTML and JSON, it will serve you the JSON version if the URL ends with JSON.

00:35:29 Or if the URL has an accept header that says I only accept JSON.

00:35:34 Yeah, that's a really cool feature.

00:35:36 I love that.

00:35:38 Maybe we could talk a little bit about the different, how TurboGirth compares against the different frameworks.

00:35:44 Well, we already saw a lot of the things that TurboGirth does different from the other frameworks.

00:35:51 But I think that the core part is the philosophy of making everything really, really simple.

00:35:58 TurboGirth tries to be really simple for simple things while making complex things possible.

00:36:06 So, you have routing receive just writing a method.

00:36:11 You have a template engine which is a check server for you.

00:36:15 You have a strong integration with the database, but you can even turn it off if you want.

00:36:21 So, it's really just a different way of balancing things.

00:36:27 I would not say that there is something in TurboGirth you cannot do in Django or something you cannot do in Flask.

00:36:33 It's just a different way of balancing the features.

00:36:36 Like, Django is much more on get up quickly and start with what you have to do.

00:36:43 While Flask is more get maximum flexibility.

00:36:46 TurboGirth tries to be a little bit in the middle, balancing between everything should be quick, but you can have an option to turn it off and do it your way.

00:36:58 Yeah.

00:36:59 Yeah, that's that start as a micro framework, but grow.

00:37:02 And that's very cool.

00:37:03 So, do you want to talk about the future of TurboGirth and where things are going?

00:37:08 Yeah, that's an interesting topic because we recently tried to switch to a frequent release cycle.

00:37:15 So, during the last year, we tried to release a new version every three months.

00:37:21 So, it's a really interesting change from the idea of releasing when you have feature risks to releasing at that time.

00:37:31 Whatever you have, you have.

00:37:32 It doesn't matter.

00:37:34 But that's a really important switch because it made possible to see faster feedbacks and faster correction of errors and things like that.

00:37:44 And so, it even made more important the do not break backward compatibility philosophy because with frequent releases, you will have frequent issues if you avoid sticking at that philosophy.

00:38:01 And so, right now, we recently referred, as I told you, from Pylons, which was using TurboGirth 2.2, to a totally separated core, which is written by the TurboGirth team itself.

00:38:16 Because we wanted to support Python 3.

00:38:19 And as we know, Pylons itself will never support Python 3, probably, because it now merged with the Pyramid project.

00:38:27 Right, right.

00:38:28 And by the way, thank you for making Python 3 such a key part of the effort.

00:38:34 I think, you know, things are moving in that way.

00:38:38 But everyone's got to do a little bit of work like you're talking about here to make it actually a common reality, right?

00:38:45 This episode is brought to you by CodeShip.

00:39:02 CodeShip has launched organizations, create teams, set permissions for specific team members, and improve collaboration in your continuous delivery workflow.

00:39:11 Maintain centralized control over your organization's projects and teams with CodeShip's new organizations plan.

00:39:16 And as Talk Python listeners, you can save 20% off any premium plan for the next three months.

00:39:22 Just use the code TALKPYTHON, all caps, no spaces.

00:39:26 Check them out at CodeShip.com and tell them thanks for supporting the show on Twitter where they're at, CodeShip.

00:39:37 I think that right now you can start doing practically everything on Python 3 and use it day by day.

00:39:45 But I see a lot of people still scared by the change, still unsure if they should do it or not.

00:39:53 And so it's more like a people problem than a technology problem because the technology is there and the most common frameworks and libraries are available.

00:40:06 But you're still unsure.

00:40:08 You still have the question, and if?

00:40:10 If I find something which is missing, what will I do?

00:40:15 Yeah, I think there's definitely the painful history of it.

00:40:19 But my philosophy these days is the same as with manga.

00:40:23 Like, I need a reason not to use Python 3.

00:40:25 So if I'm going to start something new, it'll also go down that route.

00:40:29 That's cool, though.

00:40:30 Okay.

00:40:31 So then you also had some ideas about the future of Genji and the templating, right?

00:40:37 Yeah, that's one.

00:40:38 It's again related to Python 3 because it's really sad that the Genji project is not moving forward a lot recently.

00:40:47 Actually, they have a few fixes and changes for compatibility with Python 3.4 and Python 3.5.

00:40:55 But there is not going to be a release soon as far as I know.

00:40:59 They are trying to get back on track, and I saw that they are talking about moving Genji to GitHub.

00:41:05 But still, it's unsure if it will happen and when it will happen.

00:41:09 So as we want to stick to a framework that has the same features and we want to stick to the template engine that works with the same way,

00:41:19 we are actually experimenting with various different template engines that will make possible to migrate your project from Genji to another template engine without having to change much of your code.

00:41:33 For example, we are experimenting with Kajiki, which has been created one of the past two years contributors, which is the Rick Copeland.

00:41:43 And we are trying to provide a quick way to move away from Genji to Kajiki without having to change everything.

00:41:50 We have a command in Gearbox, which is the toolset for TurboGear.

00:41:55 So you have a command to upgrade your templates from Genji to Kajiki, and you don't have to change anything else.

00:42:03 The command will move the templates from one to the other, much like the conversion tool moves your code from Python 2 to Python 3 and things like that.

00:42:16 But still, we are still experimenting.

00:42:20 So currently, both of them are available in TurboGear.

00:42:23 So when you start a project, you can choose to use whatever you want, and Genshin is still the default.

00:42:29 But it's just a possibility we have in case we will need to take another choice due to Python 3 support and Python evolution.

00:42:42 Speaking of Python 3, one of the really cool features is the async and await sort of parallelism concurrency stuff.

00:42:54 Is there any way to incorporate that into TurboGear's?

00:42:58 Well, currently, TurboGear has been support for G-Event for a lot of time, but we do not have any support for a SyncIO.

00:43:09 We are thinking about that.

00:43:11 We are still in a research phase because we are not sure that it will be such an easy thing to achieve on everything of the framework.

00:43:23 For example, you can already put in front of TurboGear's a WISG-E server, which is based on a SyncIO and that your application is set asynchronously.

00:43:39 But that wouldn't provide any much benefit because your I.O. through the database or things like that will still block.

00:43:47 So it doesn't make a lot of sense.

00:43:51 And so it's much more a problem of the technologies available than of TurboGear's itself because until SQLAlchemy, for example, provides full support for a SyncIO, we cannot provide support for a SyncIO and things like that.

00:44:08 Yeah, that makes sense because those are the places you really want to use a SyncIO anyway, right?

00:44:14 Yeah.

00:44:14 It's all the database calls and things like that.

00:44:16 Yeah.

00:44:19 Somewhat related to that is the whole HTTP2 thing that's coming, right?

00:44:26 Where a single request can come in and it can actually process many files and so on.

00:44:33 So like maybe the browser makes a request to the server and it gets the main page, but then it also gets like the CSS files and the JavaScript and, you know, a different style of processing.

00:44:46 And I don't know if any of the WSGI servers support that yet.

00:44:52 I don't know of any that do.

00:44:54 What do you see about TurboGear's WSGI and HTTP2 coming down the road?

00:45:00 Well, that's actually a really interesting question because it's such a big change because you're actually multiplexing multiple requests inside the same channel.

00:45:14 That probably is not enough to rethink your HTTP server.

00:45:18 You should also rethink your communication channel.

00:45:22 You should rethink WSGI.

00:45:24 You should rethink a lot of the way the current Python web application works.

00:45:32 So it's not something that only matters to the web framework.

00:45:37 It's probably something that matters far less to the web framework than to the WSGI protocol itself.

00:45:43 I mean, WSGI, as we know, doesn't have a great support for things like asynchronous or interleaved requests and things like that.

00:45:54 But we have been able to cope for the past years and still go on supporting things like WebSocket or protocol evolution and things like that.

00:46:05 But here we are talking about a much bigger change.

00:46:09 We are talking about, like, it doesn't work anymore.

00:46:12 It's not like a common idea of, here is your request, give me your response.

00:46:16 It's much like, here is a part of your request.

00:46:20 And then you can get a part of another request, totally different request.

00:46:23 And you should interleaved them.

00:46:26 And you should be able to start processing one while you still are waiting for the other and so on.

00:46:34 So it probably requires a much different programming model, which actually AsyncIO might help achieving.

00:46:40 Yeah, I was just thinking as you were talking there that, you know, when you get to that level, AsyncIO might be the thing required to unlock that in Python.

00:46:49 Because the threading story is not super easy to just, you know, kick that off as a bunch of threaded requests, right?

00:46:56 You need some way to sort of interleave those reasonably, right?

00:46:59 Yeah, exactly.

00:47:02 And all these changes in the Python world and in the web development world are the reason why I'm also thinking about rewriting for the 2.4 version of TurboGios, the config system.

00:47:16 Because so far, the TurboGios config system has been pretty hard, well-structured, much like the Django config system.

00:47:24 You have a bunch of options, which you can set to turn on and turn off feature.

00:47:28 Then you can register middleware, some things like that.

00:47:32 But the configuration itself stops to something like options and things like that.

00:47:37 While I would like to achieve something more similar to the way Pyramid works, where you can register even pieces of your configuration process and extend your configuration process and things like that.

00:47:50 Which I thought I needed to evolve to evolve to different technologies and things like switch to a different programming part in the like,

00:47:59 like, Helsinki or HTTP2.

00:48:01 And it will make possible for people to go on using TurboGios even in the future.

00:48:08 And even when they have to switch to a different way.

00:48:12 And even when they have to switch to a different way to the way to the server.

00:48:14 Like, you can enable by plugging an additional configuration step in your configuration and setup system.

00:48:21 It's going to be an interesting time when it switches to HTTP2, isn't it?

00:48:26 Yeah, it definitely will be.

00:48:31 I think we are in an interesting moment for web development because it's still exploring where it has to go.

00:48:39 We are no more at the time of websites.

00:48:42 We are not yet at the time of whatever it will be in the future.

00:48:47 We are still in the most interesting period, probably.

00:48:52 Yeah, it's a great time to be a developer.

00:48:54 I feel like, you know, there was in the early web, like everybody thought the web was a brochure, right?

00:49:00 It was like a document and it was just fixed.

00:49:03 And then now we know it can be so much more, but we haven't really gotten it, right?

00:49:08 Yeah, exactly.

00:49:09 Yeah, yeah.

00:49:10 Very cool.

00:49:11 So let's talk about some of the other things that you have going on, some other open source projects, maybe.

00:49:17 So you already talked about Kajiki, how do you say Rick Copeland's template engine?

00:49:23 I would probably say it's Kajiki, but I'm not sure.

00:49:28 Yeah, yeah, yeah, okay.

00:49:28 Kajiki, yeah, Kajiki.

00:49:30 So just for people listening, that's K-A-J-I-K-I.

00:49:34 And I'll put the link in the website.

00:49:37 So we already talked about that one, but then you have some other ones.

00:49:40 You have one called Depot.

00:49:41 What's that?

00:49:43 Well, Depot is a really interesting project because like a year ago or so, we had a project we worked on that needed to switch file storage during the deployment.

00:49:55 Actually, we developed everything, storing files locally.

00:49:58 And then the customer decided that it wanted to go on a path that didn't support saving files.

00:50:05 So we had to switch to something different for storing files.

00:50:09 We wanted to go to grid.fs on MongoDB.

00:50:12 And so we had to revise the code.

00:50:14 And we did that like writing everything related to saving files the day before the go live of the project, which is not a really good idea.

00:50:23 So we learned from that error.

00:50:26 And we wanted to create a framework that made possible to save, read, and sell files in web applications without caring at all about where they are saved.

00:50:37 And so we started Depot.

00:50:39 I started working on Depot as just an abstraction layer.

00:50:43 And it evolved on something much more powerful and much more convenient.

00:50:48 For example, right now, Depot supports filters on your files.

00:50:52 So you can, for example, add a filter that creates multiple thumbnails on your images when you upload them.

00:50:59 Or you can integrate with the unit of work of SQLAlchemy because Depot has strict integration with MongoDB and SQLAlchemy.

00:51:08 And whenever your transaction rolls back, even your files go back at the previous state.

00:51:14 So a previous state of the file is recovered.

00:51:16 Or if you uploaded a new file, it's automatically deleted for you whenever the column is deleted or the transaction is all bad.

00:51:25 That is actually a seriously cool feature.

00:51:28 Yeah, absolutely.

00:51:30 And Depot started as an extension for TurboGios.

00:51:34 But pretty early, I decided that it would benefit Pratica Any web framework because it didn't have any requirements on the framework itself.

00:51:42 And now it's a library that you can use on top of everything.

00:51:45 I know a lot of people are using it with Flask.

00:51:48 And it was like just one configure command at the beginning of your web application.

00:51:53 And you are Depot ready to save your files.

00:51:56 Yeah, okay.

00:51:57 That looks really cool.

00:51:58 And the fact that it integrates with GridFS and the real file system makes me think you could point it at things like Cloud Blob Storage and other places pretty easily, right?

00:52:09 Yeah, we also have support for S3, for example.

00:52:13 And right now we have support for those three.

00:52:16 But if you want to provide support for another storage, you can just subclass the storage class, provide your own, and register it with Depot.

00:52:26 So if people want to have additional backends, it's totally possible and really, really simple.

00:52:31 Okay.

00:52:32 Yeah, that's really awesome.

00:52:33 Another one that you have is DukePy.

00:52:36 DukePy.

00:52:37 Yeah, I started working DukePy again for my own needs because I'm now a really Python lover.

00:52:49 I want to use Python for everything.

00:52:51 Okay.

00:52:52 So whenever I have on my system to set up Node.js just to compile my CoffeeScript, and right now I'm using mostly ECMAScript.

00:53:02 So to compile my ECMAScript to the current version and things like that, I was really frustrated by the fact that I needed to set up Node.js just for that.

00:53:13 To have Google or whatever you want to use to compile your REST pipeline and convert your SAS to CSS and unify your JS or whatever.

00:53:27 Because Node is one of the environments where these tools are mostly available because they are being written by JavaScript developers.

00:53:39 So I started to look around for a solution that would make possible to run those tools on Python.

00:53:45 So take the CoffeeScript compiler and things like that and run it on Python so that I could also integrate in my middleware and directly serve the CoffeeScript file from my web framework without needing to pre-compile them and things like that.

00:54:02 And I saw that the tools available at Python for that are not really simple to use.

00:54:09 They are really, really powerful because we have a layer for SpiderMonkey.

00:54:13 We have a layer for V8 and things like that.

00:54:17 But it's not really easy to set them up.

00:54:19 You need to compile a lot of dependencies and things like that.

00:54:23 And then I started working with DuckTapes, which is a really simple JavaScript interpreter written in plain C.

00:54:31 And I started embedding it in a toolkit, which is actually DuckPy, which you can just pip install and have a full working JavaScript interpreter in Python.

00:54:45 So you can run JavaScript from Python.

00:54:47 And the main difference from the other technology is you just need to pip install it and it will work because it's just a single file that gets compiled without any external dependency.

00:55:00 Now that's a cool project.

00:55:02 Yeah.

00:55:04 And it provides out of the box when you pip install it, it already provides the Bevel.js compiler, the CoffeeScript compiler, and a few other tools built into the project itself.

00:55:14 So you just pip install it and you can compile your ECMAScript 6 to ECMAScript 5 and go on working without the need of an external tool.

00:55:23 Yeah, nice.

00:55:24 I'm a fan of less.

00:55:25 Does it support less?

00:55:27 Well, currently we do not have less itself inside DuckPy because I'm actually a SAS SCSS user.

00:55:34 So I use LibSAS, which is available for Python.

00:55:38 But it's really easy to add it because you just have an execute function where you can pass the JavaScript code that gets executed.

00:55:47 So you can pass the last compiler code to DuckPy and provide him with the input that needs to be compiled.

00:55:56 And you will get back the soon with the compiled code.

00:55:59 That's at least how it works for the Bevel.js compiler and so on.

00:56:03 Yeah.

00:56:03 Okay.

00:56:03 Very cool.

00:56:04 So if for some reason I want to serve less files and I set them up right in the system directly off of like talkpython.fm and I want to minify my JavaScript without actually running that.

00:56:18 You know, I just push the real JavaScript unminified versions up there and I want them swished together.

00:56:25 Could I just sort of set up some kind of web handler that when I saw a request for a JavaScript file it would cache and minify that and return it back using DuckPy?

00:56:35 Yes, exactly.

00:56:37 I'm actually using a framework which is called Web Assets, which is available for any web framework.

00:56:43 You can set it on top of whatever you want.

00:56:47 And it provides a middleware and a caching layer and whatever that compiles the assets through a bunch of filters.

00:56:55 And so you can register a filter which uses DuckPy to compile your LAS or to compile your JavaScript.

00:57:03 And Web Assets will provide all the caching and intelligence to understand whenever it changes and needs to be recompiled.

00:57:10 Oh, that's really awesome.

00:57:11 Okay.

00:57:13 I'll add a link to all those things in the share notes.

00:57:16 Very cool.

00:57:17 Alessandro, we're getting pretty close to the end of the show.

00:57:21 Do you have maybe some final call to actions or want to tell people what they should do to get started with TurboGear?

00:57:28 Well, actually, there is only one call to action that I really want to tell people that want to get started with TurboGear,

00:57:36 which is just ask.

00:57:38 Ask for whatever you want.

00:57:40 Ask for features and things like that.

00:57:42 Because I think that one of the more important parts of a framework is actually that people complain about it.

00:57:50 Okay?

00:57:50 Things can only improve if you complain.

00:57:53 Otherwise, it's just my vision of how the framework should be.

00:57:57 And feedbacks are really, really important.

00:58:00 And that's the reason why we are starting to see agile methodologies and frequency cycles and things like that used every day in computer development.

00:58:13 Because when you have something as complex as a software, which has minions on variables and things like that, you cannot take the right choice on your own.

00:58:24 You always need to have feedbacks and users to tell you where are their problems and how things should evolve and improve.

00:58:33 Yeah, that's a really cool philosophy.

00:58:34 You know, start with something somewhat minimum viable and then like let it grow however it grows, right?

00:58:40 Yeah.

00:58:41 Everyone, let the TurboGear's team know what you need.

00:58:45 That's awesome.

00:58:45 All right.

00:58:46 Two more questions before I let you go.

00:58:48 If you're going to write some Python code, what editor do you open up?

00:58:51 Well, as an editor, I use Beam.

00:58:54 But as a development environment, I'm using PyCharm.

00:58:59 Yeah.

00:58:59 Okay.

00:59:00 Very cool.

00:59:01 Very cool.

00:59:01 And of all the PyPI packages out there, what are some that you think are amazing that people aren't using?

00:59:08 Maybe web assets?

00:59:10 Yeah.

00:59:11 Web assets, I can definitely suggest it.

00:59:14 It's one of the tools that I use most frequently and it works perfectly.

00:59:19 It's been around for a lot of times.

00:59:21 So you can use it on production and go on safely.

00:59:25 This has been a fun conversation.

00:59:27 And it's been great to think about the future of the web and web frameworks.

00:59:31 So thanks for being on the show.

00:59:33 Thank you, Michael, for listening to me.

00:59:35 Yeah, you bet.

00:59:36 Talk to you later.

00:59:36 Bye.

00:59:39 This has been another episode of Talk Python To Me.

00:59:42 Today's guest was Alessandro Molina.

00:59:44 And this episode has been sponsored by Hired and CodeChip.

00:59:46 Thank you guys for supporting the show.

00:59:48 Hired wants to help you find your next big thing.

00:59:51 Visit Hired.com slash Talk Python To Me to get five or more offers with salary and equity presented right up front and a special listener signing bonus of $4,000.

01:00:01 CodeChip wants you to always keep shipping.

01:00:03 Check them out at CodeChip.com and thank them on Twitter via at CodeChip.

01:00:07 Don't forget the discount code for listeners.

01:00:09 It's easy.

01:00:10 Talk Python, all caps, no spaces.

01:00:12 Did you know you can personally support the show too?

01:00:15 Just visit Patreon.com slash mkennedy and join over 100 listeners who contribute between $1 to $2 per episode.

01:00:23 You can find the links from the show at talkpython.fm/episodes slash show slash 35.

01:00:29 Be sure to subscribe to the show.

01:00:31 Open your favorite podcatcher and search for Python.

01:00:34 We should be right at the top.

01:00:35 You can also find the iTunes and direct RSS feeds in the footer of the website.

01:00:39 Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

01:00:44 You can hear the entire song on talkpython.fm.

01:00:47 This is your host, Michael Kennedy.

01:00:49 Thank you so much for listening.

01:00:50 Smix, take us out of here.

01:00:52 Stay tuned.

01:00:54 My voice, there's no norm that I can feel within.

01:00:56 Haven't been sleeping.

01:00:58 I've been using lots of rest.

01:00:59 I'll pass the mic back to who rocked it best.

01:01:02 I'll pass the mic back to who rocked it best.

01:01:06 I'll pass the mic back to who rocked it best.

01:01:08 I'll pass the mic back to who rocked it best.

01:01:11 I'll pass the mic back to who rocked it best.

01:01:11 I'll pass the mic back to who rocked it best.

01:01:14 I'll pass the mic back to who rocked it best.

