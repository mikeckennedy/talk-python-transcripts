WEBVTT

00:00:00.001 --> 00:00:04.560
Many of you studied computer science at a university to get into programming and your careers.

00:00:04.560 --> 00:00:09.360
I bet most of you came through some self-study or some sort of backdoor into the industry.

00:00:09.360 --> 00:00:11.420
I count myself among that crowd.

00:00:11.420 --> 00:00:16.260
This is one of the true bright spots of our industry that we can earn our way in

00:00:16.260 --> 00:00:19.360
without necessarily going and getting formal college degrees.

00:00:19.360 --> 00:00:23.320
But sometimes that academic formalism would come in handy.

00:00:23.320 --> 00:00:25.580
That's where David Kopech's book is a great resource.

00:00:25.580 --> 00:00:29.120
It's an approachable and quick introduction to computer science,

00:00:29.120 --> 00:00:30.960
and that's our topic on this episode.

00:00:30.960 --> 00:00:36.140
This is Talk Python to Me, episode 211, recorded March 3rd, 2019.

00:00:36.140 --> 00:00:52.880
Welcome to Talk Python to Me, a weekly podcast on Python,

00:00:52.880 --> 00:00:55.940
the language, the libraries, the ecosystem, and the personalities.

00:00:55.940 --> 00:00:57.880
This is your host, Michael Kennedy.

00:00:58.080 --> 00:01:00.020
Follow me on Twitter where I'm @mkennedy.

00:01:00.020 --> 00:01:03.760
Keep up with the show and listen to past episodes at talkpython.fm.

00:01:03.760 --> 00:01:06.180
And follow the show on Twitter via at Talk Python.

00:01:06.180 --> 00:01:08.960
This episode is brought to you by Microsoft.

00:01:08.960 --> 00:01:11.640
Be sure to check out what they're offering during their segments.

00:01:11.640 --> 00:01:13.120
It really helps support the show.

00:01:14.460 --> 00:01:15.080
Hey, everyone.

00:01:15.080 --> 00:01:18.580
Before we get to our interview with David, I want to share some super exciting news.

00:01:18.580 --> 00:01:22.320
You've probably heard about our 100 Days of Code with Python course.

00:01:22.320 --> 00:01:27.180
Well, Bob, Julian, and I are back with another 100 Days of Code course.

00:01:27.180 --> 00:01:29.460
This time, it's all about the web.

00:01:29.640 --> 00:01:32.600
We've created a course called 100 Days of Web in Python.

00:01:32.600 --> 00:01:39.160
And it's a similar style course, but it covers so many of the web technologies that you might be interested in.

00:01:39.160 --> 00:01:40.500
Want to learn about async?

00:01:40.500 --> 00:01:41.320
That's in there.

00:01:41.320 --> 00:01:43.100
Want to learn about Django?

00:01:43.100 --> 00:01:44.420
It's in there.

00:01:44.420 --> 00:01:51.240
How about API Star, Flask, Pyramid, SQLAlchemy, database migrations, on and on and on.

00:01:51.240 --> 00:01:53.820
Service functions, all that stuff, it's in there.

00:01:53.820 --> 00:01:59.980
So if you're interested in the web and you want to really get started, you owe it to yourself to check out the 100 Days of Web in Python.

00:01:59.980 --> 00:02:04.280
Just visit training.talkpython.fm and you'll find it right in the course section.

00:02:04.280 --> 00:02:05.820
Now, let's talk to David.

00:02:05.820 --> 00:02:07.620
Dave, welcome to Talk Python.

00:02:07.620 --> 00:02:08.180
Hi, Michael.

00:02:08.180 --> 00:02:09.160
It's a pleasure to be here.

00:02:09.160 --> 00:02:10.320
It's great to have you here.

00:02:10.320 --> 00:02:20.940
You've written a really cool book and you're talking about some great problems in computer science that I think will be beneficial to almost everyone listening, regardless of their experience level.

00:02:20.940 --> 00:02:23.000
So I'm super excited to talk to you about that.

00:02:23.000 --> 00:02:25.820
Of course, before we do, though, let's start with your story.

00:02:25.820 --> 00:02:26.960
How did you get into programming in Python?

00:02:26.960 --> 00:02:29.180
Well, my dad was a computer science professor.

00:02:29.180 --> 00:02:32.380
So I started programming when I was a little kid.

00:02:32.380 --> 00:02:33.320
He taught me basic.

00:02:33.320 --> 00:02:36.960
I first got into Python when I was in graduate school.

00:02:36.960 --> 00:02:41.220
So I was doing my master's degree at Dartmouth and all the classes were in Python.

00:02:41.220 --> 00:02:43.660
So I thought, wow, I better become an expert in Python.

00:02:43.660 --> 00:02:47.500
And I quickly got up to speed and really fell in love with the language.

00:02:47.500 --> 00:02:57.280
I loved it for its succinctness more than anything, how you could write a program in Python and it would really look similar to the pseudocode that you maybe originally saw in an algorithm.

00:02:57.280 --> 00:02:59.560
Yeah, I do think that's a really great aspect of it.

00:02:59.560 --> 00:03:01.160
What languages did you learn before?

00:03:01.160 --> 00:03:04.380
You said basic in the early ages, but you probably learned something in between.

00:03:04.600 --> 00:03:08.520
Basic in the early ages, then I was really into Java when I was a teenager.

00:03:08.520 --> 00:03:12.960
And then I got into Objective-C when I got interested in developing for the Mac.

00:03:12.960 --> 00:03:16.960
I'd been all around the block, if you will, and then in graduate school, got into Python.

00:03:16.960 --> 00:03:17.740
Yeah, interesting.

00:03:17.740 --> 00:03:21.000
Objective-C is a different language as well.

00:03:21.000 --> 00:03:23.260
I'm just thinking, you know, coming from Java to Python, right?

00:03:23.260 --> 00:03:25.700
Like it's, there's a lot of symbol differences.

00:03:25.700 --> 00:03:28.860
Did that strike you as strange or did you find it refreshing?

00:03:28.860 --> 00:03:29.920
I found it refreshing.

00:03:30.140 --> 00:03:32.840
I found how succinct it is, again, really refreshing.

00:03:32.840 --> 00:03:36.460
I mean, Java has this notorious reputation for being verbose.

00:03:36.460 --> 00:03:37.700
So does Objective-C.

00:03:37.700 --> 00:03:41.500
A lot of people get scared off by Objective-C's very verbose syntax.

00:03:41.500 --> 00:03:43.580
So Python was a breath of fresh air.

00:03:43.580 --> 00:03:44.360
I feel the same way.

00:03:44.360 --> 00:03:45.000
It's pretty awesome.

00:03:45.000 --> 00:03:45.300
Okay.

00:03:45.300 --> 00:03:47.540
So what do you do today?

00:03:47.540 --> 00:03:49.640
You went to grad school and you started computer science.

00:03:49.640 --> 00:03:52.240
You're passing the baton to the younger generation.

00:03:52.380 --> 00:03:56.500
Well, yeah, I worked as a software developer for a few years and now, yeah, I'm an assistant

00:03:56.500 --> 00:03:57.800
professor of computer science.

00:03:57.800 --> 00:04:00.000
So kind of following in my dad's footsteps a little bit.

00:04:00.000 --> 00:04:02.240
Yeah, that sounds like a really fun job.

00:04:02.240 --> 00:04:06.020
You get all these new people who are excited about programming and work with them for a couple

00:04:06.020 --> 00:04:07.520
of years and bring them along, right?

00:04:07.520 --> 00:04:11.940
It's really exciting to see people having those aha moments when they first really grasp a

00:04:11.940 --> 00:04:12.260
concept.

00:04:12.260 --> 00:04:15.760
And so, yeah, it's a job that's really gratifying and a lot of fun.

00:04:15.760 --> 00:04:16.260
Yeah, that's cool.

00:04:16.260 --> 00:04:17.500
What's your favorite course to teach?

00:04:17.500 --> 00:04:19.040
I like teaching iOS development.

00:04:19.200 --> 00:04:22.600
Maybe your Python listeners won't like me saying that, but that's one of my favorite

00:04:22.600 --> 00:04:23.480
classes to teach.

00:04:23.480 --> 00:04:23.720
Yeah.

00:04:23.720 --> 00:04:26.260
Well, it's just such an exciting platform, right?

00:04:26.260 --> 00:04:29.580
There's just so many inputs, right?

00:04:29.580 --> 00:04:35.840
Like there's GPS and altitude and even with regular programming, a lot of times you don't

00:04:35.840 --> 00:04:37.120
get that device feel.

00:04:37.120 --> 00:04:39.920
But with iOS and I guess Android as well, you do, right?

00:04:39.920 --> 00:04:40.580
Yeah, absolutely.

00:04:40.580 --> 00:04:42.520
Another fun class is emerging languages.

00:04:42.520 --> 00:04:46.840
We kind of explore languages that are still on the periphery of industry and just becoming

00:04:46.840 --> 00:04:47.820
more popular.

00:04:47.820 --> 00:04:49.980
And that's really exciting because it keeps me fresh.

00:04:49.980 --> 00:04:50.640
Yeah, absolutely.

00:04:50.640 --> 00:04:52.360
What are some of the languages that are emerging?

00:04:52.360 --> 00:04:56.240
So this semester we're doing Go, Swift and Clojure.

00:04:56.240 --> 00:05:00.560
And so some people might be like, oh, those are those have already been around for a little

00:05:00.560 --> 00:05:00.860
bit.

00:05:00.860 --> 00:05:03.520
They're all around 10, five to 10 years old.

00:05:03.520 --> 00:05:08.400
And, you know, if you think about a computer science curriculum, it moves a lot slower than

00:05:08.400 --> 00:05:09.220
industry moves.

00:05:09.220 --> 00:05:13.120
So these are languages that aren't usually taught in college or university level.

00:05:13.120 --> 00:05:13.380
Yeah.

00:05:13.380 --> 00:05:14.680
It's pretty cool that you're covering those.

00:05:14.680 --> 00:05:15.720
All right.

00:05:15.720 --> 00:05:18.340
So let's talk about the main topic.

00:05:18.340 --> 00:05:20.880
These classic computer science problems.

00:05:20.880 --> 00:05:24.400
You wrote a couple of books around classic computer science problems.

00:05:24.400 --> 00:05:27.560
We'll touch on the books and more on the main ideas from them.

00:05:27.560 --> 00:05:33.720
But let's just start with, you know, what makes a computer science problem classic?

00:05:33.720 --> 00:05:39.400
Well, for the purposes of the book, we thought about a classic problem as one that somebody

00:05:39.400 --> 00:05:43.180
who has a bachelor's degree in computer science would probably be familiar with.

00:05:43.180 --> 00:05:49.860
So what have been taught in the college classrooms for the past, you know, 30 or 40 years, as long

00:05:49.860 --> 00:05:52.360
as computer science programs have pretty much been around.

00:05:52.360 --> 00:05:57.860
So if you go to somebody who has a CS degree, they probably heard about one of these problems.

00:05:58.000 --> 00:05:58.160
Okay.

00:05:58.160 --> 00:05:59.680
So that's our basis.

00:05:59.680 --> 00:06:02.940
But then we had to also expand that into a whole book.

00:06:02.940 --> 00:06:08.180
So we also just went over problem solving techniques that we think anyone who works in

00:06:08.180 --> 00:06:12.020
software development, whether they have a CS degree or not, should be familiar with.

00:06:12.020 --> 00:06:16.640
And then we're using problems to illustrate those classic problem solving techniques.

00:06:16.640 --> 00:06:18.440
Yeah, I think that's a really great approach.

00:06:18.440 --> 00:06:23.240
We recently did a beginners and experts episode on the show.

00:06:23.240 --> 00:06:25.480
Time shifting hasn't released yet.

00:06:25.480 --> 00:06:28.140
So yeah, there's no way you could have heard it, but it's been recorded and will come out

00:06:28.140 --> 00:06:28.820
before this one.

00:06:28.820 --> 00:06:35.120
And we talked about, you know, what is the real, one of the core differences between somebody

00:06:35.120 --> 00:06:38.240
who's been programming for a long time and somebody who's new, right?

00:06:38.240 --> 00:06:43.520
Like it takes, you know, a couple of months maybe to jump in and learn a language or learn

00:06:43.520 --> 00:06:47.460
some important package like Django or SQLAlchemy or something like that.

00:06:47.460 --> 00:06:53.960
But it seemed like one of the really big challenges a lot of the beginners laid out is you see a

00:06:53.960 --> 00:06:58.540
problem, you see a whole bunch of APIs and like, how do you even break it down into something

00:06:58.540 --> 00:07:00.020
you can start to solve, right?

00:07:00.020 --> 00:07:03.860
These like partitioning problems into something you can think about.

00:07:03.860 --> 00:07:06.460
Do you think that's a big problem you see with your students?

00:07:06.460 --> 00:07:06.900
Absolutely.

00:07:06.900 --> 00:07:10.700
I mean, if you've, you're never even familiar with the problem solving techniques, how are you

00:07:10.700 --> 00:07:12.140
going to know that you should be applying them?

00:07:12.420 --> 00:07:13.820
And so that's kind of the purpose of the book.

00:07:13.820 --> 00:07:15.320
It's very broad in its scope.

00:07:15.320 --> 00:07:19.580
That's been one of the criticisms of it, frankly, is that it doesn't go deep enough into any of

00:07:19.580 --> 00:07:22.720
the particular problem solving techniques, but it's not supposed to.

00:07:22.720 --> 00:07:26.680
It's supposed to be a broad introduction, give you a little bit of a taste of each of them.

00:07:26.680 --> 00:07:30.860
And then maybe you know enough about them to know when they should be applied, but you're

00:07:30.860 --> 00:07:33.160
not necessarily an expert in any of them just by reading the book.

00:07:33.160 --> 00:07:34.500
Yeah, that makes a lot of sense.

00:07:34.500 --> 00:07:40.580
One thing to think about is it feels to me like these classic problems, regardless whether they're

00:07:40.580 --> 00:07:45.460
in your book or I think back to when I saw some of these, I don't have a CS degree.

00:07:45.460 --> 00:07:50.740
I have a math degree, but I have what's like roughly a minor in CS.

00:07:51.740 --> 00:07:56.600
My university didn't have CS or minors at all, really, but same idea.

00:07:56.600 --> 00:08:02.120
And so when I saw these, and it feels like the ones you covered as well a lot here, I think

00:08:02.120 --> 00:08:07.700
it's pretty typical, is it's very much focused on algorithms, data structures, and so on.

00:08:07.700 --> 00:08:14.820
It's not like, here's how we're going to render a web page or generate a data-backed rest and

00:08:14.820 --> 00:08:16.500
point or things like that, right?

00:08:16.500 --> 00:08:22.800
It's not about GUIs, and it's more focused on what is the core problem, what are the right

00:08:22.800 --> 00:08:26.920
algorithms and data structures and ways of thinking about it to solve it, right?

00:08:26.920 --> 00:08:27.980
That's absolutely true.

00:08:27.980 --> 00:08:32.480
On the other hand, at the end of every chapter, we include a small section called real-world

00:08:32.480 --> 00:08:33.120
applications.

00:08:33.120 --> 00:08:37.380
And it tries to bring them back into the day-to-day software development world.

00:08:37.500 --> 00:08:41.900
So how are people in apps that you're probably familiar with actually using these techniques

00:08:41.900 --> 00:08:42.880
to solve problems?

00:08:42.880 --> 00:08:48.640
I think a lot of us as software developers, we get into a mode of kind of API plumbing, where

00:08:48.640 --> 00:08:54.420
we end up kind of just hooking up other people's libraries, hooking up APIs together, and we get

00:08:54.420 --> 00:08:57.700
a little bit away from the problem-solving parts of software development.

00:08:57.700 --> 00:09:02.460
And for people who felt like they've been in kind of that API plumbing mode for too long,

00:09:02.460 --> 00:09:04.280
maybe they'll find this book a little refreshing.

00:09:04.280 --> 00:09:06.000
Yeah, I think they will as well.

00:09:06.300 --> 00:09:09.680
So who do you think should study this kind of stuff, right?

00:09:09.680 --> 00:09:14.180
I mean, you talked about the API plumbing, and sometimes people will make the distinction

00:09:14.180 --> 00:09:16.920
between coders and software developers.

00:09:16.920 --> 00:09:18.020
I'm not really sure I like that.

00:09:18.020 --> 00:09:22.540
But should everybody really understand these algorithms deeply?

00:09:22.540 --> 00:09:24.760
Who should really pay attention to this, do you think?

00:09:24.760 --> 00:09:28.840
I think anyone who's a software developer should be familiar with these problem-solving techniques.

00:09:28.840 --> 00:09:32.600
This book is actually geared for people who don't have a CS degree.

00:09:32.600 --> 00:09:35.620
It's to introduce those concepts that you missed out on.

00:09:35.700 --> 00:09:40.580
By being a programmer and not having that CS education, giving you a basis to understand

00:09:40.580 --> 00:09:43.940
what everyone else is talking about when they talk about something like a neural network or

00:09:43.940 --> 00:09:44.840
genetic algorithm.

00:09:44.840 --> 00:09:46.060
What is that stuff?

00:09:46.060 --> 00:09:48.720
And when should you actually be using a technique like that?

00:09:48.720 --> 00:09:53.920
So I really think it's a broadly applicable set of topics that everyone should at least be

00:09:53.920 --> 00:09:54.740
familiar with.

00:09:54.740 --> 00:09:56.340
Again, it doesn't mean you need to be an expert.

00:09:56.340 --> 00:09:58.620
It doesn't mean you need to go do four years of study.

00:09:58.860 --> 00:10:03.360
But when you run into a problem in your software development day job, or even if you're just

00:10:03.360 --> 00:10:07.380
doing software development as a hobby, you should know what tools are available to you to solve

00:10:07.380 --> 00:10:07.500
it.

00:10:07.500 --> 00:10:07.680
Right.

00:10:07.680 --> 00:10:11.600
Even simple stuff like, oh, that should be a dictionary or that should be a set versus a

00:10:11.600 --> 00:10:11.880
list.

00:10:11.880 --> 00:10:12.680
Yeah, absolutely.

00:10:12.680 --> 00:10:14.080
Yeah, for sure.

00:10:14.080 --> 00:10:14.440
Okay.

00:10:15.180 --> 00:10:20.880
Well, one of the things I really liked about your presentation of all these classic computer

00:10:20.880 --> 00:10:25.140
science problems was one, it was in Python, but it was in modern Python.

00:10:25.140 --> 00:10:29.140
And I mean, really modern Python, not like, oh, it was three, five or something, right?

00:10:29.140 --> 00:10:33.560
You, you really made proper use of a lot of the cool new features.

00:10:33.960 --> 00:10:35.040
Yeah, that was a goal.

00:10:35.040 --> 00:10:39.680
You know, we put together a team when we started the Python version of the book that and we said,

00:10:39.680 --> 00:10:43.300
we need to have a team that's really familiar with the latest techniques, because we want

00:10:43.300 --> 00:10:46.340
this book to hopefully be evergreen for a few years.

00:10:46.340 --> 00:10:50.260
We want people to feel like if they buy it two years from now, it's using fairly modern

00:10:50.260 --> 00:10:50.620
Python.

00:10:50.620 --> 00:10:54.040
So we decided from the beginning, we're going to do Python 3.7.

00:10:54.040 --> 00:10:55.800
And, you know, really cutting edge stuff.

00:10:55.800 --> 00:10:58.400
And we're actually going to use features from Python 3.7.

00:10:58.860 --> 00:11:04.820
Things like data classes, things like recent additions to type hints.

00:11:04.820 --> 00:11:10.720
And I will say that especially the decision to use type hints was a very controversial one

00:11:10.720 --> 00:11:13.000
amongst the reviewers of the book.

00:11:13.000 --> 00:11:15.720
So Manning has a pretty extensive review process.

00:11:15.720 --> 00:11:21.420
Every one of their books goes through three sessions of external expert reviewers looking

00:11:21.420 --> 00:11:22.080
at the material.

00:11:22.080 --> 00:11:26.280
And there were a couple of reviewers every time who said, you know what, I feel like the type

00:11:26.280 --> 00:11:28.120
hints are not standard Python.

00:11:28.480 --> 00:11:33.320
They're really a fad or they're really just something that takes away from the succinctness

00:11:33.320 --> 00:11:36.440
of the language, which, like I mentioned before, is something I love about the language, how

00:11:36.440 --> 00:11:37.040
succinct it is.

00:11:37.040 --> 00:11:38.180
And I kind of agree.

00:11:38.180 --> 00:11:42.600
You know, obviously your code does look a little more bulky with all the type hints inside of

00:11:42.600 --> 00:11:42.780
it.

00:11:42.780 --> 00:11:47.860
On the other hand, we wanted to do where we thought the puck might be going.

00:11:47.860 --> 00:11:50.140
And type hints are becoming more popular.

00:11:50.140 --> 00:11:55.220
And there definitely is some value that they add, and arguably in terms of readability, knowing

00:11:55.220 --> 00:11:58.460
right away what a function is going to return is a nice thing.

00:11:58.460 --> 00:11:59.820
without having to read through it.

00:11:59.820 --> 00:12:03.040
And we took a bit of a gamble on it.

00:12:03.040 --> 00:12:07.920
And I hope that for people who are interested in type hints, this book might be a gateway into

00:12:07.920 --> 00:12:09.260
getting even more interested in them.

00:12:09.260 --> 00:12:09.880
I think so.

00:12:09.880 --> 00:12:14.120
You know, I'm personally a big fan of type hints in Python.

00:12:14.420 --> 00:12:16.140
I think they can go overboard.

00:12:16.140 --> 00:12:18.720
I think they can make the code look too bulky.

00:12:18.720 --> 00:12:25.240
But there's something really powerful about just sprinkling a few of them here and there

00:12:25.240 --> 00:12:30.400
and then having your editor, your IDE, whatever, just come to life knowing exactly what you're

00:12:30.400 --> 00:12:31.000
working with.

00:12:31.000 --> 00:12:33.620
And even catching errors and mistakes.

00:12:33.620 --> 00:12:34.460
That's pretty powerful.

00:12:34.540 --> 00:12:35.140
Yeah, absolutely.

00:12:35.140 --> 00:12:39.540
I mean, the ability to use something like mypy and know ahead of time where some of your

00:12:39.540 --> 00:12:43.020
errors lie before you get to runtime is really great.

00:12:43.020 --> 00:12:47.900
When it comes to self-documenting your code, there's also a big advantage with type hints,

00:12:47.900 --> 00:12:52.120
which is you right away know what these parameters are supposed to be.

00:12:52.120 --> 00:12:54.760
You right away know what this function is supposed to return.

00:12:55.100 --> 00:12:57.400
It can make your comments a little less bulky.

00:12:57.400 --> 00:13:01.940
So you're kind of trading off a little bit of bulkiness in the code for maybe a little

00:13:01.940 --> 00:13:05.120
bit of less need to be so explicit in your comments.

00:13:05.120 --> 00:13:05.460
Right.

00:13:05.460 --> 00:13:05.720
Yeah.

00:13:05.720 --> 00:13:09.220
If you say something's a Boolean, you don't need to describe in the comments, hey, this

00:13:09.220 --> 00:13:09.660
is a Boolean.

00:13:09.660 --> 00:13:11.780
It's like, well, colon Boole, we're good.

00:13:11.780 --> 00:13:12.300
Exactly.

00:13:12.300 --> 00:13:12.700
Yeah.

00:13:12.700 --> 00:13:12.900
Yeah.

00:13:12.900 --> 00:13:13.480
It's pretty interesting.

00:13:13.480 --> 00:13:19.180
So reading through your examples, though, you know, when I think of like, why do I care

00:13:19.180 --> 00:13:19.820
about type hints?

00:13:19.820 --> 00:13:24.920
I care about them mostly for the reason, like personally, I care about them for the reason

00:13:24.920 --> 00:13:30.980
that I laid out, which is I love how it makes the editors like PyCharm and VS Code really

00:13:30.980 --> 00:13:32.800
help you a lot.

00:13:32.800 --> 00:13:33.000
Right.

00:13:33.000 --> 00:13:37.400
It helps you deeply understand the types you've been passed around and give you autocomplete

00:13:37.400 --> 00:13:38.200
and stuff like that.

00:13:38.200 --> 00:13:40.900
Or error, you know, sort of PEP 8 type error checking.

00:13:40.900 --> 00:13:42.000
It's like 8 type error checking.

00:13:42.000 --> 00:13:47.440
There's mypy, which you mentioned, which was really instrumental in helping Dropbox convert

00:13:47.440 --> 00:13:51.280
like a million lines of Python 2 to Python 3, which I thought is an interesting use.

00:13:51.280 --> 00:13:54.280
But the third one that I realized looking through your stuff is,

00:13:54.740 --> 00:14:00.740
it's really nice when you have just static text, not in an editor, right?

00:14:00.740 --> 00:14:01.980
It's just sitting there on the page.

00:14:01.980 --> 00:14:06.640
I don't have a command click go to definition to see what's happening on this function.

00:14:06.640 --> 00:14:10.420
But it, you know, if you put the type hints right there, you're like, oh, well, this is

00:14:10.420 --> 00:14:11.560
returning a list of ints.

00:14:11.560 --> 00:14:16.040
So I don't need to go and like try to find out where that was in the writing.

00:14:16.040 --> 00:14:18.920
I can just see that's a list of ints and go with that.

00:14:18.920 --> 00:14:19.560
That's pretty cool.

00:14:19.560 --> 00:14:20.220
Yeah, absolutely.

00:14:20.580 --> 00:14:22.940
I mean, that's supposed to be the goal is that it's more readable.

00:14:22.940 --> 00:14:27.500
Now, when you first see them, and if you're not used to them, I think it is actually less

00:14:27.500 --> 00:14:27.860
readable.

00:14:27.860 --> 00:14:29.880
And it takes some time to get used to.

00:14:29.880 --> 00:14:35.100
So I think it's a fair criticism of those reviewers that for some people, the type hints

00:14:35.100 --> 00:14:39.180
do actually make the code at first glance less readable, especially if you're not familiar

00:14:39.180 --> 00:14:39.540
with them.

00:14:39.820 --> 00:14:43.900
We did include a short appendix, appendix C to the book that kind of gives you a crash

00:14:43.900 --> 00:14:44.900
course in type hints.

00:14:44.900 --> 00:14:51.380
But it's really just a matter of spending time with them to really start to gain the benefits

00:14:51.380 --> 00:14:52.960
of the readability, I think.

00:14:52.960 --> 00:14:55.320
Yeah, it does take a little bit of getting used to.

00:14:55.320 --> 00:14:59.240
You know, two things I actually learned, even though I'm a big advocate and fan, I use the

00:14:59.240 --> 00:15:00.660
type annotations a lot.

00:15:00.660 --> 00:15:05.440
One of the things that I saw that you were using, a couple of things that were pretty cool.

00:15:06.100 --> 00:15:11.360
One, you were using from future import annotations, Dunder future annotation.

00:15:11.360 --> 00:15:14.500
That's kind of a new feature coming for type hints, right?

00:15:14.500 --> 00:15:15.500
Want to tell people about that?

00:15:15.500 --> 00:15:16.180
Yeah, absolutely.

00:15:16.180 --> 00:15:21.760
So if you have, for lack of a better word, recursive type hints, so a type hint that refers to the

00:15:21.760 --> 00:15:28.880
type inside of it, up to version 3.7 and this new annotations feature added to under Dunder

00:15:28.880 --> 00:15:33.820
future, you would have to actually put it in as a string in quotes.

00:15:34.260 --> 00:15:40.420
And if you now import annotations, you can actually just put the type as its actual type

00:15:40.420 --> 00:15:43.760
name without putting it in quotes, which is how the language will work in the future.

00:15:43.760 --> 00:15:46.300
But for now, we have to have that in future.

00:15:46.300 --> 00:15:51.400
Yeah, there's always this limitation where like, it's super common to have a class that interacts

00:15:51.400 --> 00:15:53.720
with itself, right?

00:15:53.720 --> 00:15:54.160
Exactly.

00:15:54.160 --> 00:15:58.220
You know, like I've got a class, maybe it has a static method, and it's going to take another

00:15:58.220 --> 00:15:58.420
one.

00:15:58.420 --> 00:16:02.640
Like just for comparison, like, is this instance of me less than another instance of me?

00:16:03.020 --> 00:16:06.840
If you want to put that in type annotations, that was really tricky to understand what to

00:16:06.840 --> 00:16:10.300
do without this new future version of stuff.

00:16:10.300 --> 00:16:12.920
Because the class technically wasn't finished being defined yet.

00:16:12.920 --> 00:16:16.880
So you couldn't say the name of it within like the functions or the properties or whatever.

00:16:16.880 --> 00:16:17.640
Yeah, absolutely.

00:16:17.640 --> 00:16:18.560
Yeah, interesting.

00:16:18.560 --> 00:16:23.120
Another one that I thought was interesting is the ability to define a generic type.

00:16:23.580 --> 00:16:26.260
I literally had never seen that or tried that.

00:16:26.260 --> 00:16:30.840
But you have a lot of data structures that you're defining to be generic, like a generic

00:16:30.840 --> 00:16:32.040
of T, like bracket, bracket.

00:16:32.040 --> 00:16:32.580
Yeah, absolutely.

00:16:32.580 --> 00:16:33.140
That's interesting.

00:16:33.140 --> 00:16:36.720
Yeah, we're trying to make all the code in the book as generic as possible.

00:16:36.720 --> 00:16:40.720
And let me use that term more broadly than just the type in specific version of it.

00:16:40.720 --> 00:16:44.380
We want to write algorithms that can work for many different problems.

00:16:44.380 --> 00:16:49.040
We don't want to code them so specifically that they're only solutions to the one problem at

00:16:49.040 --> 00:16:49.260
hand.

00:16:49.260 --> 00:16:53.060
We want them to be techniques that you could then just drop in the same method, the same

00:16:53.060 --> 00:16:55.900
class, and use it in a totally different program.

00:16:55.900 --> 00:17:00.220
So in most languages, we have something called generic programming.

00:17:00.220 --> 00:17:02.020
So in Java, you have generics.

00:17:02.020 --> 00:17:04.020
In C++, you have templates.

00:17:04.020 --> 00:17:09.720
In type hints in Python, you have the generic type, which is similar to those other two methods

00:17:09.720 --> 00:17:10.560
in those other languages.

00:17:10.560 --> 00:17:15.740
It's a way of saying, you know, I don't know exactly what type I'm going to be using in this

00:17:15.740 --> 00:17:16.100
problem.

00:17:16.520 --> 00:17:20.200
So here's a type that can fit in for any type.

00:17:20.200 --> 00:17:23.180
And that is what a generic type is.

00:17:23.180 --> 00:17:27.660
It's a, I don't know yet what the type is, but at runtime, we're going to figure out what

00:17:27.660 --> 00:17:28.260
the type is.

00:17:28.260 --> 00:17:29.140
Yeah, it's interesting.

00:17:29.140 --> 00:17:36.400
It's like the list of int or list of string type of feature that you can get from if you

00:17:36.400 --> 00:17:37.160
import it from typing.

00:17:37.160 --> 00:17:39.520
But you can more broadly, you can make it for your own types.

00:17:39.520 --> 00:17:39.920
That's cool.

00:17:39.920 --> 00:17:43.880
Yes, you said data classes, f strings, all the good stuff, right?

00:17:43.880 --> 00:17:47.760
I just want to give a shout out to the cool sticker I saw at PyCascades recently.

00:17:47.760 --> 00:17:54.500
They had a sticker for new versions of Python and said, F quote, yes, exclamation mark quote.

00:17:54.500 --> 00:17:55.520
So F yes.

00:17:55.520 --> 00:17:56.260
It was beautiful.

00:17:56.260 --> 00:17:56.660
Yeah.

00:17:56.660 --> 00:18:01.220
I mean, there's so many different ways to do string interpolation in Python and f-strings

00:18:01.220 --> 00:18:03.080
are just so beautiful compared to the older ways.

00:18:03.180 --> 00:18:03.880
They are for sure.

00:18:05.560 --> 00:18:10.460
This portion of Talk Python is sponsored by Microsoft and Visual Studio Code.

00:18:10.460 --> 00:18:15.280
Visual Studio Code is a free, open source, and lightweight code editor that runs on Mac,

00:18:15.280 --> 00:18:17.740
Linux, and Windows with rich Python support.

00:18:17.740 --> 00:18:22.380
Download Visual Studio Code and install the Python extension to get coding with support for

00:18:22.380 --> 00:18:25.840
tools you love like Jupyter, Black Formatting, Pilot, pytest, and more.

00:18:25.840 --> 00:18:31.400
And just announced this month, you can now work with remote Python code bases using the new Visual

00:18:31.400 --> 00:18:33.080
Studio Code remote extensions.

00:18:33.080 --> 00:18:38.160
Use the full power of Visual Studio Code when coding in containers, in Windows subsystem for

00:18:38.160 --> 00:18:40.240
Linux, and over SSH connections.

00:18:40.240 --> 00:18:41.260
Yep, that's right.

00:18:41.260 --> 00:18:45.240
Auto completions, debugging, the terminal, source control, your favorite extensions.

00:18:45.240 --> 00:18:48.060
Everything works just right in the remote environment.

00:18:48.060 --> 00:18:52.700
Get started with Visual Studio Code now at talkpython.fm/Microsoft.

00:18:54.500 --> 00:18:58.780
One thing I wanted to ask you about is you've done this book in Python,

00:18:58.780 --> 00:19:03.880
understanding these classic computer science programs, and you've done the same problems,

00:19:03.880 --> 00:19:06.660
not the exact same book, but basically the same problems, right?

00:19:06.660 --> 00:19:10.100
In Swift, because you had a classic science problems in Swift as well.

00:19:10.100 --> 00:19:13.320
I'd love to get your thought on comparing those two experiences.

00:19:13.320 --> 00:19:13.860
Absolutely.

00:19:13.860 --> 00:19:19.280
So most people would not be surprised that the Python version was more succinct,

00:19:19.280 --> 00:19:23.740
and a lot of people would not be surprised that the Python standard library

00:19:23.740 --> 00:19:26.700
is a lot richer than the Swift standard library.

00:19:26.700 --> 00:19:29.480
And so there were actually parts of the code.

00:19:29.480 --> 00:19:33.260
First of all, when we were doing the Python book, we wanted the book to be, of course,

00:19:33.260 --> 00:19:34.140
totally Pythonic.

00:19:34.140 --> 00:19:39.440
So we put together a team of reviewers and also the technical editor that were really

00:19:39.440 --> 00:19:44.120
experienced Python programmers who were making sure that we were not just porting over the

00:19:44.120 --> 00:19:46.520
Swift book and it was still looking like Swift in Python.

00:19:46.520 --> 00:19:49.420
We wrote most of the problems again from scratch.

00:19:49.420 --> 00:19:56.040
But there were situations where there was whole methods from the Swift book that we could totally

00:19:56.040 --> 00:20:01.700
eliminate in the Python book because those techniques already exist in the standard library.

00:20:01.700 --> 00:20:06.960
And so while in the book, we only basically use the Python standard library, we don't use any

00:20:06.960 --> 00:20:07.920
external libraries.

00:20:07.920 --> 00:20:14.600
That still meant that we were able to eliminate whole sections of code that just don't exist in

00:20:14.600 --> 00:20:15.620
the Swift standard library.

00:20:15.620 --> 00:20:20.520
As far as the languages go, I mean, Swift has been inspired by Python in some of its syntax.

00:20:20.520 --> 00:20:24.660
So there are actually parts of it that look surprisingly similar.

00:20:24.660 --> 00:20:28.640
But as a whole, like I mentioned, the Python code is certainly more succinct.

00:20:28.640 --> 00:20:32.080
I'd say the Python code is probably more readable as a whole.

00:20:32.640 --> 00:20:35.780
And working with the two languages, Swift is a moving target, right?

00:20:35.780 --> 00:20:41.560
Swift, every version of Swift, there's sometimes some breaking syntax changes and it can be kind

00:20:41.560 --> 00:20:41.880
of annoying.

00:20:41.880 --> 00:20:43.660
It's starting to stabilize the last couple of years.

00:20:43.660 --> 00:20:48.480
Python, of course, is an extremely mature language with extremely mature tooling.

00:20:48.480 --> 00:20:51.940
And so that was, of course, a pleasure as a book writer.

00:20:51.940 --> 00:20:55.380
You don't want to be writing code that is going to be obsolete a year from now.

00:20:55.380 --> 00:21:01.780
So that was, you know, much more fun on working, not having to think about that when writing

00:21:01.780 --> 00:21:02.400
the Python book.

00:21:02.400 --> 00:21:02.600
Yeah.

00:21:02.600 --> 00:21:06.980
You know, I don't think it would be a major difference just remembering, reading through

00:21:06.980 --> 00:21:08.220
all the solutions you have.

00:21:08.220 --> 00:21:14.280
But one of the big differences with Swift is it's one of the most statically typed, safest

00:21:14.280 --> 00:21:17.640
of all the languages that I've worked with, at least.

00:21:17.640 --> 00:21:23.720
Because, you know, not only does it have a type system, it has things like these are read-only

00:21:23.720 --> 00:21:26.720
reference variables and all sorts of stuff like that, right?

00:21:26.720 --> 00:21:29.760
Like the constant or like nullable.

00:21:29.960 --> 00:21:34.220
You have to explicitly say a type is nullable or it can never be the equivalent of none and

00:21:34.220 --> 00:21:34.960
things like that.

00:21:34.960 --> 00:21:37.960
Did that make a big difference or not so much?

00:21:37.960 --> 00:21:39.240
I think it does for the reader.

00:21:39.240 --> 00:21:43.800
I think because there's a lot of cognitive overhead that goes with all of those safety

00:21:43.800 --> 00:21:44.300
features.

00:21:44.580 --> 00:21:46.980
So having to always think about, should this be an optional?

00:21:46.980 --> 00:21:50.080
Oh, if this isn't optional, do I have to unwrap it here?

00:21:50.080 --> 00:21:52.440
That's the type of stuff you have to constantly think about in Swift.

00:21:52.440 --> 00:21:55.460
And in Python, your mind is a little more free.

00:21:55.960 --> 00:22:00.220
So it actually makes the code more readable and easier to think about when you don't have

00:22:00.220 --> 00:22:02.080
to think about all those safety features.

00:22:02.080 --> 00:22:05.820
I think Swift code takes longer to write than Python code.

00:22:05.820 --> 00:22:11.440
It might be safer at runtime, but it also takes, I think, less time to read Python code than Swift

00:22:11.440 --> 00:22:15.060
code as well, because you're not reading through all of those hoops you have to jump through

00:22:15.060 --> 00:22:15.620
for safety.

00:22:15.620 --> 00:22:18.040
Yeah, that's my sense from my limited experience as well.

00:22:18.040 --> 00:22:18.700
All right.

00:22:18.700 --> 00:22:21.100
Let's dig into some of these classic problems.

00:22:21.100 --> 00:22:25.540
And I would say you start off all of your problems with this one as well.

00:22:25.540 --> 00:22:32.920
But I would say one of the most mind-bending ideas of problem solving when you first come

00:22:32.920 --> 00:22:38.440
into properly study programming rather than just like, oh, here's a loop and here's a variable.

00:22:38.440 --> 00:22:40.400
I'll make it work is recursion.

00:22:40.400 --> 00:22:41.700
Absolutely.

00:22:41.700 --> 00:22:44.520
It's just like, wait, how does this work?

00:22:44.520 --> 00:22:48.580
There's no loops, but we're going across a set or something crazy like that, right?

00:22:48.580 --> 00:22:48.940
Yeah.

00:22:48.940 --> 00:22:52.940
Recursion is something that does bend your mind the first time you see it.

00:22:52.940 --> 00:22:55.240
And it requires a new way of thinking.

00:22:55.240 --> 00:22:58.760
The crazy thing is there's whole programming languages that are based around recursion.

00:22:58.760 --> 00:23:01.560
I mean, if you look at some of the functional programming languages, they don't even have

00:23:01.560 --> 00:23:01.920
loops.

00:23:01.920 --> 00:23:05.160
Anytime you want to repeat yourself, you have to do recursion.

00:23:05.160 --> 00:23:08.540
Recursion is not a technique you want to apply every time you program.

00:23:08.540 --> 00:23:12.880
Recursion is a technique you want to apply when it makes more sense to you.

00:23:12.880 --> 00:23:17.460
Because any problem that you can solve recursively, you can also solve iteratively.

00:23:17.460 --> 00:23:19.120
So you can also solve using loops.

00:23:19.120 --> 00:23:23.900
So they really are two different ways of just repeating yourself.

00:23:23.900 --> 00:23:28.500
But it's a question of which one makes more sense to you in your mind when you're abstracting away

00:23:28.500 --> 00:23:30.800
the problem and thinking about how you want to solve it.

00:23:30.800 --> 00:23:36.780
So there are situations where even though a loop might actually be more performant, which it often

00:23:36.780 --> 00:23:44.180
is in a language like Python, the recursive way of approaching the problem is more similar to how you

00:23:44.180 --> 00:23:45.860
might have written it down on paper, let's say.

00:23:45.860 --> 00:23:46.120
Right.

00:23:46.120 --> 00:23:50.580
Or maybe it perfectly matches the data structure you're trying to interact with, right?

00:23:50.580 --> 00:23:55.140
If I have like a tree data structure or something hierarchical, that's often really easy to work

00:23:55.140 --> 00:23:56.540
with in a recursion way.

00:23:56.540 --> 00:24:01.700
Because, you know, the recursion step is take one of the sub elements and work on it as if it

00:24:01.700 --> 00:24:03.960
was the whole thing until you're out of sub elements, right?

00:24:03.960 --> 00:24:04.400
Absolutely.

00:24:04.400 --> 00:24:07.700
And we sometimes call structures like that even recursive data structures.

00:24:07.700 --> 00:24:08.200
Absolutely.

00:24:08.200 --> 00:24:09.080
Yeah, for sure.

00:24:09.080 --> 00:24:15.000
And this one, the example was a Fibonacci sequence, of which I'm also a fan for these little demos

00:24:15.000 --> 00:24:17.480
that's complicated enough, but not super complicated.

00:24:17.480 --> 00:24:18.840
It's nice to work with.

00:24:18.900 --> 00:24:22.740
So you said, all right, well, let's try to solve the Fibonacci sequence problem with recursion

00:24:22.740 --> 00:24:28.280
because, well, the first two numbers are either 0 and 1 or 1 and 1, depending on who you ask.

00:24:28.280 --> 00:24:30.360
And then it's you add those two together.

00:24:30.360 --> 00:24:36.200
So you have, you know, F of N is just F of N minus 1 plus F of N minus 2.

00:24:36.200 --> 00:24:38.880
And it's super easy to do recursion.

00:24:38.880 --> 00:24:42.900
But it turns out that recursion kind of goes a little bit crazy in its naive way.

00:24:43.420 --> 00:24:49.560
For example, Fibonacci at 20 using recursion does 21,891 calls.

00:24:49.560 --> 00:24:50.620
That's a lot.

00:24:50.620 --> 00:24:54.700
So you said, well, the reason is we keep asking the same question again and again.

00:24:54.700 --> 00:24:55.880
What is a Fibonacci at 10?

00:24:55.880 --> 00:25:00.360
And if you want 11, you ask, you know, that the same subsequence a whole bunch of times, right?

00:25:00.360 --> 00:25:00.660
Right.

00:25:00.660 --> 00:25:05.100
So then you get into memoization, which is a funky word, but a very cool technique.

00:25:05.100 --> 00:25:05.860
Yeah.

00:25:05.860 --> 00:25:06.700
Very good for performance.

00:25:06.700 --> 00:25:07.220
Absolutely.

00:25:07.440 --> 00:25:14.400
I mean, yeah, the Fibonacci sequence is for listeners who aren't familiar with it is each of the numbers is the sum of the previous two numbers.

00:25:14.400 --> 00:25:21.400
So it goes 0, 1, 1, then 1 plus 1 is 2, then 2 plus 1 is 3, then 3 plus 2 is 5, etc.

00:25:21.400 --> 00:25:21.820
Right.

00:25:21.820 --> 00:25:28.140
And so how can if you actually write that recursively, it looks incredibly similar to how we just defined it.

00:25:28.140 --> 00:25:30.200
We just said it's the sum of the previous two numbers.

00:25:30.200 --> 00:25:39.560
So recursively, you can actually write, take the Fibonacci number of the previous one, n minus 1, and add it to the Fibonacci number of two ago.

00:25:39.560 --> 00:25:41.720
So Fibonacci of n minus 2.

00:25:41.720 --> 00:25:45.360
It's actually like two lines of code, maybe three lines of code in Python.

00:25:45.360 --> 00:25:53.660
That's, like you mentioned, not very performant because you do all of those recursive calls many, many, many times when you do a large number.

00:25:53.660 --> 00:25:57.220
And we show in the book how you kind of go through a tree of them.

00:25:57.640 --> 00:26:05.940
So we go through six different ways of solving the problem, each of them getting a little bit more performance or just doing it in a slightly different way.

00:26:05.940 --> 00:26:08.720
One way to solve the problem is with memoization.

00:26:08.720 --> 00:26:16.900
In memoization, you actually store results that you've already computed so that if you need to compute them again, you can just look them up.

00:26:16.900 --> 00:26:18.180
That's basically the idea.

00:26:18.180 --> 00:26:24.040
It's a fancy word for a really simple idea, which is basically just let's store results that we've already come up with.

00:26:24.040 --> 00:26:26.900
And then we can just look them up instead of having to calculate them again.

00:26:27.500 --> 00:26:29.320
So in Python, it's super easy to do that.

00:26:29.320 --> 00:26:31.260
You can do that using a dictionary.

00:26:31.260 --> 00:26:32.900
You can just store in a dictionary.

00:26:32.900 --> 00:26:35.920
Here's a previous result for a certain set of parameters.

00:26:35.920 --> 00:26:38.780
In the case of Fibonacci sequence, it's just a single parameter.

00:26:38.780 --> 00:26:40.760
Which Fibonacci number are we trying to look up?

00:26:40.760 --> 00:26:42.320
We can just store that in a dictionary.

00:26:42.320 --> 00:26:47.040
There's also a built-in facility in Python called LRU cache.

00:26:47.040 --> 00:26:49.240
And this is from the functools package.

00:26:49.500 --> 00:27:00.460
And you can use that to automatically store the result of a function so that the next time the function is called, we just auto look in that cache for what the last result is.

00:27:00.460 --> 00:27:11.740
So that's a little tip from the Python standard library that can just make a huge performance difference for all kinds of different mathematical calculations because you're not going to have to do them again.

00:27:11.740 --> 00:27:13.580
They're just already going to be stored for you.

00:27:13.780 --> 00:27:15.800
Or anything that can be cached, basically.

00:27:15.800 --> 00:27:16.200
Right.

00:27:16.320 --> 00:27:19.840
So you put the LRU cache decorator on your function.

00:27:19.840 --> 00:27:22.500
And that function could be computing Fibonacci numbers.

00:27:22.500 --> 00:27:26.420
Or it could be going to a database and making complicated queries.

00:27:26.420 --> 00:27:34.640
But you're like, well, if this is however old or maybe this rarely, rarely changes between runs of the app, you only need to ask the database once.

00:27:34.640 --> 00:27:36.440
And then you hold on to the answer, right?

00:27:36.440 --> 00:27:37.080
Yeah, absolutely.

00:27:37.340 --> 00:27:43.560
And that's one of the things I love is when we're able to teach something that's actually an important computer science topic, memoization.

00:27:43.560 --> 00:27:51.620
But we're also teaching you something about the Python standard library that easily in your day-to-day software development can really save you a ton of performance cost.

00:27:51.620 --> 00:27:51.840
Yeah.

00:27:51.840 --> 00:27:53.280
I agree.

00:27:53.280 --> 00:27:54.400
Super, super nice.

00:27:54.400 --> 00:27:55.280
Final takeaway.

00:27:55.280 --> 00:27:59.760
Well, I guess I talked about there being 21,000 function calls for Fibonacci at 20.

00:27:59.760 --> 00:28:01.540
If you use memoization, it's 39.

00:28:01.540 --> 00:28:01.940
Right.

00:28:01.940 --> 00:28:07.680
Even so, directly implementing it with generators and just a straight loop is still much faster.

00:28:07.680 --> 00:28:08.000
Right.

00:28:08.000 --> 00:28:08.740
Then it's just 20.

00:28:08.740 --> 00:28:11.460
So it's literally just every single one.

00:28:11.460 --> 00:28:13.180
Let's say we're doing Fibonacci number of 20.

00:28:13.180 --> 00:28:18.740
We just have to do basically going around the loop 20 times, one for each number in the sequence.

00:28:18.740 --> 00:28:24.820
So that's a situation where, yeah, iterative, which is loops, is actually more performant than recursive.

00:28:24.820 --> 00:28:27.100
And that you'll often find is the case.

00:28:27.100 --> 00:28:32.540
Even though recursion is a really cool technique, usually it's actually faster to do things with loops in Python.

00:28:32.540 --> 00:28:40.300
It's more about optimizing for understanding versus performance, which maybe understanding is better at first, unless it really matters.

00:28:40.300 --> 00:28:40.760
Exactly.

00:28:40.760 --> 00:28:41.120
Yeah.

00:28:41.220 --> 00:28:51.760
So, you know, one thing I wanted to ask you about, like, when I learned about the yield concepts and these generator ideas and whatnot, like, that's pretty mind-blowing.

00:28:51.760 --> 00:28:58.880
And would that almost be its own sort of classic CS problem is these lazy deferred execution types of things?

00:28:58.880 --> 00:29:00.060
You know, maybe it should be.

00:29:00.060 --> 00:29:02.260
I mean, we should have covered it as such in the book.

00:29:02.260 --> 00:29:04.360
We don't go into it in a huge amount of detail.

00:29:04.360 --> 00:29:08.020
We kind of assume the reader is familiar with generators and maybe we shouldn't have.

00:29:08.300 --> 00:29:15.220
And, you know, that's something I should have prefaced our whole conversation with is we wrote the book for intermediate to advanced Python programmers.

00:29:15.220 --> 00:29:20.320
So it's really not appropriate for people who are just learning Python for the first time.

00:29:20.320 --> 00:29:26.220
We already assume that you've been doing Python development for probably a couple of years before you pick up this book.

00:29:26.300 --> 00:29:31.020
So we don't go into explaining every detail of generators.

00:29:31.020 --> 00:29:37.080
And, you know, now that I think about it, maybe we should have because even some intermediate and advanced programmers are not always familiar with them.

00:29:37.080 --> 00:29:37.780
I think it's okay.

00:29:37.780 --> 00:29:51.160
But I do think this idea of solving problems with generators, it's just so powerful and just unlocks a lot of potential for interesting pipelines and other types of execution with, you know, like, usually simpler code.

00:29:51.160 --> 00:29:52.200
Yeah, absolutely.

00:29:52.200 --> 00:29:53.300
It's a non-generated version.

00:29:53.300 --> 00:29:54.140
So, yeah, pretty interesting.

00:29:54.140 --> 00:29:58.140
So another area that you focused on was data representation.

00:29:58.760 --> 00:30:05.020
And in a pretty simple form, not like, is this a pointer rich data structure or is sparse or things like that.

00:30:05.020 --> 00:30:09.920
But, you know, you focused on trying to represent DNA, right?

00:30:09.920 --> 00:30:11.100
I think is what it is.

00:30:11.100 --> 00:30:12.980
You had codons and stuff like that.

00:30:12.980 --> 00:30:15.520
Actually, it was just the amino acids at first.

00:30:15.520 --> 00:30:18.880
So you're just like, well, how do we store this?

00:30:18.880 --> 00:30:19.860
We could store it as a string.

00:30:20.700 --> 00:30:24.440
And, you know, the AC, T, G, each one could be a string.

00:30:24.440 --> 00:30:27.940
And that would be pretty large in terms of representing data.

00:30:27.940 --> 00:30:31.480
You could store it as integers, but even integers are not very efficient in Python.

00:30:31.480 --> 00:30:34.020
So then you started working with bits and bytes, right?

00:30:34.020 --> 00:30:34.660
Yeah.

00:30:34.860 --> 00:30:41.880
So, you know, oftentimes we don't even think about how some, what we think are really simple bits of data are going to be stored.

00:30:41.880 --> 00:30:51.840
So your first inkling when you're thinking, how should I store the letters A, C, T, and G to represent DNA might be, why don't I just store them as strings, right?

00:30:51.840 --> 00:30:52.720
Because those are letters.

00:30:52.720 --> 00:30:53.960
So that makes sense.

00:30:53.960 --> 00:30:55.780
Letters can be parts of strings.

00:30:56.340 --> 00:31:04.560
But actually, you know, if you only have four different things that you want to store, you can do that with just two bits of information per thing.

00:31:04.560 --> 00:31:08.880
Because two bits can represent up to four different numbers, right?

00:31:08.880 --> 00:31:13.360
And so each of those four different numbers could represent one of those four letters.

00:31:13.360 --> 00:31:19.540
And so if for a string, we're going to end up storing approximately eight bits for every character.

00:31:19.540 --> 00:31:22.460
So eight bits for A, eight bits for T, et cetera.

00:31:23.020 --> 00:31:31.440
And if we do it as a number and we can actually just store two bits for A, two bits for T, that's actually a 75% space savings.

00:31:31.440 --> 00:31:40.340
Just from thinking about the fact that, oh, I actually don't need that many different possibilities that a string provides for this type of data.

00:31:40.340 --> 00:31:42.140
So it sounds like common sense.

00:31:42.140 --> 00:31:43.160
It is common sense.

00:31:43.160 --> 00:31:46.440
But we don't even think about that sort of thing a lot of the time.

00:31:46.440 --> 00:31:47.640
And so we're wasting a lot of data.

00:31:47.640 --> 00:31:48.340
It's not obvious at all.

00:31:48.340 --> 00:31:48.640
Yeah.

00:31:48.720 --> 00:31:55.040
In something low level like C, you talk explicitly about the data types very, very carefully.

00:31:55.040 --> 00:31:56.500
This is a four byte integer.

00:31:56.500 --> 00:31:57.540
That's a two byte integer.

00:31:57.540 --> 00:32:03.900
But even integers in Python are like 28 bytes each for like the number zero.

00:32:03.900 --> 00:32:04.820
Well, yeah.

00:32:04.820 --> 00:32:09.320
But at least the number zero to 256 are, you know, flywheel pre-allocated.

00:32:09.320 --> 00:32:10.060
So they're shared.

00:32:10.060 --> 00:32:15.460
But, you know, normal numbers take up a lot of space because they're really embedded within these PyObjects.

00:32:15.460 --> 00:32:15.780
Right.

00:32:15.780 --> 00:32:18.640
Things that are tracked by Python with reference counting and all that.

00:32:18.640 --> 00:32:21.200
And we're not saying that you should always be doing this, right?

00:32:21.200 --> 00:32:24.860
Maybe it actually is a lot more convenient a lot of the time to just use strings.

00:32:24.860 --> 00:32:26.600
And you absolutely should do that.

00:32:26.600 --> 00:32:32.580
But if you're not even aware that there was a better way or there was a more at least space efficient way,

00:32:32.580 --> 00:32:38.840
maybe there's a situation where you're not storing kilobytes of data, but you're storing gigabytes or terabytes of data.

00:32:39.200 --> 00:32:41.880
And you could have actually been saving 75% of the space.

00:32:41.880 --> 00:32:42.460
Well, wow.

00:32:42.460 --> 00:32:43.740
Maybe it's relevant then.

00:32:43.740 --> 00:32:46.020
So, again, it's just something we want to make people aware of.

00:32:46.020 --> 00:32:50.480
We're not saying you should always be finding the absolute most efficient way to store everything.

00:32:50.480 --> 00:32:50.840
Right.

00:32:50.840 --> 00:32:54.000
Or you have a RESTful API that's exchanging JSON.

00:32:54.000 --> 00:33:06.160
And you're like, you know, if we wrote this in straight TCP packets and we just did this bitwise storage, we could drop, you know, the traffic by 95% or something.

00:33:06.420 --> 00:33:08.480
Sure. I mean, but that sounds really painful.

00:33:08.480 --> 00:33:13.300
And that doesn't sound like something I'd rather just exchange the JSON, I think, most of the time.

00:33:13.300 --> 00:33:21.420
Yeah. I'm thinking of like places where, you know, PayPal has an API that's called like several billion times a day.

00:33:21.420 --> 00:33:22.780
And it needs really, really low.

00:33:22.780 --> 00:33:25.080
Like, it's got to be pretty far out there.

00:33:25.080 --> 00:33:26.100
Yeah, absolutely.

00:33:26.100 --> 00:33:28.720
It's got to be an extreme case before you want to start.

00:33:28.720 --> 00:33:30.140
Yeah. Going down that road.

00:33:30.140 --> 00:33:30.700
Yeah, absolutely.

00:33:30.700 --> 00:33:31.780
All right.

00:33:31.820 --> 00:33:39.360
So another one that I thought was an interesting one was the Towers of Hanoi, because it's super painful to solve by hand.

00:33:39.360 --> 00:33:41.720
You know, you sit down and it looks real simple.

00:33:41.720 --> 00:33:43.880
You've got these three towers that each have these little disks.

00:33:43.880 --> 00:33:46.120
Disks are bigger as you go down.

00:33:46.340 --> 00:33:50.000
And the job is to move them from one end to the other end.

00:33:50.000 --> 00:33:52.820
But the rule is the big ones can't go on top of the little ones.

00:33:52.820 --> 00:33:55.460
So how do you, you know, what series of operations?

00:33:55.460 --> 00:33:58.340
It's kind of like the Rubik's Cube type of thing, right?

00:33:58.740 --> 00:34:03.060
But the solution turns out to be beautifully solved with recursion, right?

00:34:03.060 --> 00:34:03.780
Right. Yeah.

00:34:03.780 --> 00:34:06.440
I mean, so it sounds like a really simple problem.

00:34:06.440 --> 00:34:09.500
So we have three different, let's call them towers.

00:34:09.500 --> 00:34:11.020
And we have three disks.

00:34:11.020 --> 00:34:14.380
And we want to move all the disks from one tower to another tower.

00:34:14.380 --> 00:34:15.640
How can we do that?

00:34:15.640 --> 00:34:19.520
Well, if you actually try to work it out, it's several steps.

00:34:19.520 --> 00:34:22.080
And they're not completely obvious when you just look at it.

00:34:22.080 --> 00:34:24.840
Although it does help to be able to see a model of it.

00:34:24.840 --> 00:34:26.520
So it's a little hard to describe on a podcast.

00:34:27.100 --> 00:34:32.540
But what's interesting is that the solution actually just comes down to figuring out two things.

00:34:32.540 --> 00:34:34.840
One is how do I move a single disk?

00:34:34.840 --> 00:34:38.480
And the second one is how do I move all the rest of the disks?

00:34:38.480 --> 00:34:44.460
And that actually lends itself to a really succinct recursive solution.

00:34:44.460 --> 00:34:45.880
Just a few lines of code.

00:34:45.880 --> 00:34:48.540
And then it can solve it actually for any number of disks.

00:34:48.540 --> 00:34:50.940
Not just three, but let's say we had 10 disks.

00:34:50.940 --> 00:34:54.920
Well, we can actually solve that by just knowing how to solve the first disk.

00:34:54.920 --> 00:34:59.440
And then having some step that we do for moving all the rest of the disks.

00:34:59.440 --> 00:35:07.660
So it's kind of mind-blowing when you actually see how succinct it is to solve it for any number of disks recursively.

00:35:07.660 --> 00:35:11.980
And I don't think we can explain it wonderfully on the podcast.

00:35:12.080 --> 00:35:15.320
But I guess people will just have to take our word for it.

00:35:15.320 --> 00:35:17.840
It is really, really interesting.

00:35:17.840 --> 00:35:19.880
Like the last move is obvious.

00:35:19.880 --> 00:35:21.300
You just move the disk over.

00:35:21.300 --> 00:35:22.760
It's kind of mind-blowing.

00:35:22.760 --> 00:35:29.560
And I do think it's a perfect application of this idea of how recursion really nicely fits these things.

00:35:29.560 --> 00:35:35.880
Because I think it would be really tough to implement that with loops and just, you know, mutable data structures and whatnot.

00:35:35.880 --> 00:35:36.620
Yeah, absolutely.

00:35:36.620 --> 00:35:46.000
So one that I thought was really nice tying together algorithms and data structures in a way that's kind of mind-blowing, to be honest, was maze traversal.

00:35:46.120 --> 00:35:48.940
Yeah, you know, there's so many different ways to traverse a maze.

00:35:48.940 --> 00:35:54.100
And this is actually a really good practice for people who are going into coding interviews.

00:35:54.100 --> 00:35:59.500
Because there's a lot of these techniques for solving a maze that often come up in coding interviews.

00:35:59.500 --> 00:36:02.640
Things like depth-first search, breadth-first search.

00:36:03.060 --> 00:36:09.940
And then at the end of the chapter, we go into A star, which is actually the most efficient algorithm for finding a path through a maze.

00:36:09.940 --> 00:36:16.560
But it's remarkable how all of these techniques, when you write them out in code, they're very, very similar.

00:36:16.560 --> 00:36:21.700
And all you have to actually change between depth-first search and breadth-first search, for example, is the data structure.

00:36:21.700 --> 00:36:26.520
So in both of those, you're keeping track of where am I going to look next?

00:36:26.520 --> 00:36:27.760
We call that the frontier.

00:36:27.760 --> 00:36:31.460
So where are the next places on the grid?

00:36:31.600 --> 00:36:33.380
Let's say the maze is a grid.

00:36:33.380 --> 00:36:37.280
Where are the next slots on the grid that I'm going to look at next?

00:36:37.280 --> 00:36:41.100
In depth-first search, you use a stack.

00:36:41.100 --> 00:36:46.740
So you just keep going through and you keep adding the next places you're going to look onto the stack.

00:36:46.740 --> 00:36:49.680
In breadth-first search, you use a queue.

00:36:49.680 --> 00:36:54.160
And so all the rest of the code stays exactly the same.

00:36:54.160 --> 00:36:55.960
You don't change a single other thing in your code.

00:36:55.960 --> 00:37:01.200
You just change, okay, for the frontier, the next places I'm going to look at, I'm going to use a queue instead of a stack.

00:37:01.340 --> 00:37:04.580
And then the way that we traverse the maze totally changes.

00:37:04.580 --> 00:37:07.480
In depth-first search, we kind of take a stab at it.

00:37:07.480 --> 00:37:09.160
We go as far as we can through.

00:37:09.160 --> 00:37:12.560
And if we hit a wall, we backtrack to the last location.

00:37:12.560 --> 00:37:14.500
That's probably the way real people would, right?

00:37:14.500 --> 00:37:18.720
Like if you were put in, as a human, put into a maze, you would just go until you hit a wall.

00:37:18.720 --> 00:37:23.420
You would probably not apply some breadth-first algorithm, little notebook or whatever, right?

00:37:23.420 --> 00:37:23.760
Right.

00:37:23.760 --> 00:37:24.060
Yeah.

00:37:24.060 --> 00:37:25.700
As human beings, that's how we usually think.

00:37:25.800 --> 00:37:27.800
I think we kind of think in a depth-first way.

00:37:27.800 --> 00:37:30.240
But a breadth-first search is super systematic.

00:37:30.240 --> 00:37:31.500
It says, you know what?

00:37:31.500 --> 00:37:34.380
Let's first look at the nodes that are one away from where we started.

00:37:34.380 --> 00:37:37.020
Then let's look at the nodes that are two away from where we started.

00:37:37.020 --> 00:37:39.240
Then let's look at the nodes that are three away from where we started.

00:37:39.920 --> 00:37:48.100
And just by changing from a stack to a queue, and for those that don't know, a stack is a data structure where the last item we put in is the first item we take out.

00:37:48.100 --> 00:37:53.420
And a queue is a data structure where the first item we put in is the first item we take out.

00:37:53.420 --> 00:37:59.680
Just making that change of data structure, so literally changing one line of code, totally changes how we traverse the maze.

00:37:59.680 --> 00:38:05.000
And so maze traversal is an awesome way of kind of illustrating the difference between depth-first search and breadth-first search.

00:38:05.000 --> 00:38:09.460
Yeah, and then so you have the queue, the depth-first one?

00:38:09.460 --> 00:38:10.720
No, in the breadth-first one.

00:38:10.720 --> 00:38:19.320
And then you come to A-star, which uses a new data structure, but is also pretty similar in the implementation called a priority queue.

00:38:19.320 --> 00:38:19.760
Right.

00:38:19.760 --> 00:38:21.620
I don't believe I've seen a priority queue.

00:38:21.620 --> 00:38:29.880
Yeah, so this is a place where the Python standard library is pretty cool because the Python standard library has built-in facilities for handling heaps.

00:38:29.880 --> 00:38:33.380
And a heap is a data structure that's at the basis of a priority queue.

00:38:33.380 --> 00:38:48.780
What a priority queue does is instead of a stack where we say last thing in, take that thing out first, and a queue where we say first thing in, take that thing out first, with a priority queue we say, let's assign every item we put into the data structure a quote-unquote priority.

00:38:48.780 --> 00:38:54.100
And when we take things out of the data structure, let's take them out by their priority.

00:38:54.100 --> 00:38:58.160
So the first thing we take out might be the thing with the highest priority.

00:38:58.600 --> 00:39:02.460
So we have a way of kind of tagging each element and saying, here's your priority.

00:39:02.460 --> 00:39:06.340
And then when we pull them out, we're going to efficiently pull them out by their priority.

00:39:06.340 --> 00:39:11.780
So in A-star search, what we want to have is some kind of heuristic for traversing the maze.

00:39:11.780 --> 00:39:16.000
Instead of just dumbly saying, oh, what are the next things next to where I am right now?

00:39:16.300 --> 00:39:23.720
Let's instead say, looking at my next possibilities, which one do I think will get me closest to the goal?

00:39:23.720 --> 00:39:29.520
And the way we usually do that on a maze is actually just using a straight line.

00:39:29.520 --> 00:39:31.600
So sometimes called Euclidean distance.

00:39:31.600 --> 00:39:34.780
Just draw a line from the next places I'm looking at to the goal.

00:39:34.780 --> 00:39:39.360
And the shortest line, that's probably the one that's getting me closest to where I want to go.

00:39:39.580 --> 00:39:47.340
And so we can then put all of those next nodes into the priority queue ordered by how long is that line?

00:39:47.340 --> 00:39:50.320
And how long that line is, is what the priority is.

00:39:50.320 --> 00:39:52.780
And we just take the ones out that have the shortest lines next.

00:39:52.780 --> 00:39:57.940
And that gets us to an algorithm that will actually get us very efficiently from the start to the goal.

00:39:59.200 --> 00:40:02.040
This portion of Talk Python to Me is brought to you by Microsoft.

00:40:02.040 --> 00:40:07.320
For ultimate developer productivity in the cloud, use Azure extensions for Visual Studio Code.

00:40:07.320 --> 00:40:11.500
You can deploy and debug your serverless Python apps directly from your editor.

00:40:11.500 --> 00:40:16.520
On Azure, you can run your Python apps as serverless code on Linux web apps and functions,

00:40:16.520 --> 00:40:23.100
or on top of managed Kubernetes, and easily connect data from database services, including Postgres and MySQL.

00:40:23.240 --> 00:40:31.500
You can also use Azure DevOps to create cross-platform builds of your Python packages with hosted macOS, Linux, and Windows build machines.

00:40:31.500 --> 00:40:35.220
And publish them to Azure Artifacts for your own hosted PyPI feed.

00:40:35.220 --> 00:40:39.220
Azure DevOps is free for open source projects, and many are using it already.

00:40:39.220 --> 00:40:43.080
Get started for free at talkpython.fm/Microsoft.

00:40:44.360 --> 00:40:54.240
You also mentioned this idea of the Manhattan distant metric, where you can't actually walk diagonal on a maze, where it's a grid, or something like that.

00:40:54.240 --> 00:40:54.500
Right?

00:40:54.500 --> 00:40:57.200
And you also can't do that in cities where they're laid out on grids.

00:40:57.200 --> 00:40:57.380
Right?

00:40:57.380 --> 00:40:58.780
There is no diagonal travel.

00:40:58.780 --> 00:41:00.740
It's over one, back one.

00:41:00.740 --> 00:41:05.160
So, like, the diagonal is effectively as long as going, you know, around the border on these things.

00:41:05.160 --> 00:41:07.420
So, you can also even get a little more accurate with that.

00:41:07.420 --> 00:41:07.580
Right?

00:41:07.580 --> 00:41:07.900
Right.

00:41:07.900 --> 00:41:14.340
So, yeah, the straight line is always the shortest way to get from point A to point B, but straight lines don't always work.

00:41:14.340 --> 00:41:14.620
Right?

00:41:14.620 --> 00:41:28.380
So, if we're on a grid where we can only go horizontally and vertically from one spot to another, we actually can use a different heuristic known as the Manhattan distance, which is named after the borough of Manhattan of New York City, where all the streets are on a grid pattern.

00:41:28.380 --> 00:41:28.700
Right?

00:41:28.700 --> 00:41:35.700
And so, when you want to walk, you have to walk a certain number of blocks to the right or left, and a certain number of blocks up or down.

00:41:35.700 --> 00:41:54.700
And if you actually do that calculation on a maze that can only go horizontally and vertically, it's going to give you a better estimation of how long it'll take to get from some location to another location than the straight line will, because it's closer to how you can actually move.

00:41:54.700 --> 00:41:54.940
Yeah.

00:41:54.940 --> 00:42:09.100
So, yeah, what I thought was really interesting about the coming together of all of these three, well, the three ways of solving this maze problem, were you have basically the same algorithm, and it's really about the data structure that makes it all work.

00:42:09.100 --> 00:42:10.360
And that was pretty cool.

00:42:10.360 --> 00:42:10.700
Yeah.

00:42:10.700 --> 00:42:21.360
A lot of people have said that's one of their biggest aha moments throughout the book, is where we can go and just change the data structure, and the whole solution, how it actually works, changes, even though the rest of the code doesn't.

00:42:21.360 --> 00:42:22.100
Yeah, it's super cool.

00:42:22.300 --> 00:42:26.940
Another area that was pretty interesting was the whole set of constraint problems.

00:42:26.940 --> 00:42:35.940
So, you have a couple in here that we could touch on, the Australian map coloring, the sin plus more equals money, maybe some more realistic problems after that.

00:42:35.940 --> 00:42:36.140
Yeah.

00:42:36.140 --> 00:42:41.420
What's cool about those problems is how we can think about them all together as really one problem-solving technique.

00:42:41.420 --> 00:42:43.300
So, let me tell you a little bit about the problem.

00:42:43.300 --> 00:42:53.660
So, the Australian map coloring problem is one where we take all the regions of Australia, and we want to fill each of them in with a color, and we only want to use three colors, let's say red, green, and blue.

00:42:53.660 --> 00:43:02.000
So, is it possible to find a color that we can put on each region without any of them next to each other having the same color?

00:43:02.060 --> 00:43:03.940
And the answer is, of course, yes.

00:43:03.940 --> 00:43:05.860
We see this on maps all the time, right?

00:43:05.860 --> 00:43:08.200
So, how can we solve this with a computer?

00:43:08.200 --> 00:43:12.760
Well, one way of thinking about the problem is as a constraint satisfaction problem.

00:43:13.220 --> 00:43:17.080
And what a constraint satisfaction problem is, is it has three parts to it.

00:43:17.080 --> 00:43:17.760
It has variables.

00:43:17.760 --> 00:43:20.140
In the case of this problem, it would be the regions.

00:43:20.140 --> 00:43:22.140
So, the regions of Australia are our variables.

00:43:22.140 --> 00:43:25.320
Then a constraint satisfaction problem always has domains.

00:43:25.320 --> 00:43:28.560
Those are what can we fill in for each of the variables.

00:43:28.560 --> 00:43:30.720
In this case, that would be red, green, or blue.

00:43:30.720 --> 00:43:32.640
That's the domain of each of those variables.

00:43:32.640 --> 00:43:35.120
Each of them has to be one of those values for our solution.

00:43:35.120 --> 00:43:38.800
And then the last part of constraint satisfaction problem is the constraints.

00:43:39.400 --> 00:43:45.460
In the case of this problem, the constraint is that any two regions next to each other can't have the same color.

00:43:45.460 --> 00:43:47.040
So, we actually have a bunch of constraints.

00:43:47.040 --> 00:43:50.840
We have one for every single set of regions that are next to each other.

00:43:50.840 --> 00:43:55.840
So, a constraint satisfaction problem solver can solve this problem,

00:43:55.840 --> 00:44:02.780
but it can also solve any other kind of problem that we can define using variables, domains, and constraints.

00:44:02.780 --> 00:44:07.020
And so, we can write a constraint satisfaction problem solver just once,

00:44:07.200 --> 00:44:11.880
and then we can use it for other kinds of problems besides just the Australian map coloring problem,

00:44:11.880 --> 00:44:15.060
such as the one that you mentioned, SEM plus more equals money.

00:44:15.060 --> 00:44:16.520
That's a crypt arithmetic problem.

00:44:16.520 --> 00:44:17.260
It says...

00:44:17.260 --> 00:44:18.640
Those seem so different.

00:44:18.640 --> 00:44:18.980
Yeah.

00:44:18.980 --> 00:44:24.620
And yet, the same problem technique or solution will hit them both, right?

00:44:24.620 --> 00:44:25.680
So, yeah, tell us about that one.

00:44:25.680 --> 00:44:26.420
It's really interesting.

00:44:26.420 --> 00:44:27.440
Yeah, it's totally different.

00:44:27.440 --> 00:44:30.740
SEM plus more equals money is what we call a crypt arithmetic problem.

00:44:30.740 --> 00:44:35.440
If you line up the letters S-E-N-D and the letters M-O-R-E,

00:44:35.440 --> 00:44:38.660
and you said each of these letters is going to represent a digit.

00:44:38.660 --> 00:44:43.080
So, maybe E is four and, you know, maybe N is five or something like that.

00:44:43.080 --> 00:44:46.140
And then underneath them, as if it was an arithmetic problem,

00:44:46.140 --> 00:44:50.680
we put the letters M-O-N-E-Y, money, the word money.

00:44:51.020 --> 00:44:54.760
And we also say that each of those letters has to be a corresponding digit.

00:44:54.760 --> 00:45:00.760
What digits can we fill in for each of those letters that will lead to SEM plus more equaling money?

00:45:00.760 --> 00:45:05.020
Well, if you think about it, it actually is a constraint satisfaction problem again.

00:45:05.020 --> 00:45:05.620
Here's why.

00:45:05.620 --> 00:45:08.040
Each of the letters is our variable.

00:45:08.040 --> 00:45:09.500
So, S might be a variable.

00:45:09.500 --> 00:45:10.680
E might be a variable.

00:45:10.680 --> 00:45:11.740
N might be a variable.

00:45:11.740 --> 00:45:15.600
Each of the possible values of those letters is our domain.

00:45:15.600 --> 00:45:19.320
So, the digits, zero through nine, are the domain of each of those letters.

00:45:19.720 --> 00:45:20.540
And here's our constraint.

00:45:20.540 --> 00:45:24.720
Our constraint is that for whatever digits I fill in for each of those letters,

00:45:24.720 --> 00:45:28.060
the combination of SEM plus more must equal money.

00:45:28.060 --> 00:45:30.580
So, again, it's actually a constraint satisfaction problem.

00:45:30.580 --> 00:45:32.500
But when you first look at it, you might be like,

00:45:32.500 --> 00:45:34.960
wow, this seems totally different from the map coloring problem.

00:45:34.960 --> 00:45:36.700
But actually, they're the same kind of problem.

00:45:36.700 --> 00:45:38.300
Yeah, that's pretty amazing.

00:45:38.300 --> 00:45:40.420
And once you lay it out like that, it's obvious.

00:45:40.420 --> 00:45:43.640
But I would never look at those two things and go, yeah, that's the same problem.

00:45:43.640 --> 00:45:44.540
Right, absolutely.

00:45:44.540 --> 00:45:48.240
So, that's one of the things I like about studying these classic problems,

00:45:48.380 --> 00:45:55.580
is they show you this larger symmetry or commonality across different,

00:45:55.580 --> 00:45:56.880
what seem like different problems.

00:45:56.880 --> 00:45:58.760
And like, oh, it's a recursion problem.

00:45:58.760 --> 00:46:01.740
It's a, you know, one of these constraint problems.

00:46:01.740 --> 00:46:03.660
Or it's a graph problem or something like that.

00:46:03.660 --> 00:46:07.820
Yeah, it's amazing how many different ways we can apply the same problem solving techniques.

00:46:07.820 --> 00:46:12.600
So, when you're talking about these techniques, you know, like these constraint algorithms are not

00:46:12.600 --> 00:46:13.580
particularly new.

00:46:13.580 --> 00:46:19.060
But you did talk about one being, coming along that is actually new, something called constraint

00:46:19.060 --> 00:46:19.820
propagation.

00:46:19.820 --> 00:46:21.460
What's the story there?

00:46:21.460 --> 00:46:25.820
Well, I wouldn't say it's new, but it's a more advanced way of solving these constraint

00:46:25.820 --> 00:46:26.720
satisfaction problems.

00:46:26.720 --> 00:46:30.460
So, in the chapter, we teach you a way called backtracking search.

00:46:30.860 --> 00:46:32.740
And it's actually a type of depth first search.

00:46:32.740 --> 00:46:35.700
So, it kind of builds on, this is chapter three of the book, it kind of builds on chapter

00:46:35.700 --> 00:46:37.560
two's explanation of depth first search.

00:46:37.560 --> 00:46:41.100
And in backtracking search, it's every time you hit a wall.

00:46:41.100 --> 00:46:46.460
So, every time we found a way of filling in domains for these variables that solves the

00:46:46.460 --> 00:46:49.320
constraints, but then it doesn't solve one of them.

00:46:49.320 --> 00:46:50.660
We go backwards.

00:46:50.660 --> 00:46:55.040
And we try to find a different fill-in that doesn't lead us into that wall.

00:46:55.040 --> 00:47:01.680
In constraint propagation, we instead ahead of time try to figure out, okay, I think this

00:47:01.680 --> 00:47:02.520
is going to work well.

00:47:02.520 --> 00:47:06.080
And we might still do a backtracking search at the end to make sure it really does work

00:47:06.080 --> 00:47:06.380
well.

00:47:06.380 --> 00:47:11.040
But instead of doing it after we've already hit a wall, we try to figure out what's going

00:47:11.040 --> 00:47:13.680
to work before we hit the wall at the very beginning.

00:47:13.680 --> 00:47:16.600
We don't actually get into the details of how that works in the book.

00:47:16.600 --> 00:47:18.020
It's kind of more of an advanced technique.

00:47:18.340 --> 00:47:20.720
But it's a little more efficient.

00:47:20.720 --> 00:47:25.180
And so, if you were going to solve this on a really big problem, so a problem that, let's

00:47:25.180 --> 00:47:30.580
say, had hundreds of variables and hundreds of domains and constraints, then maybe you would

00:47:30.580 --> 00:47:33.120
want to use something more advanced than the technique we teach in the book.

00:47:33.120 --> 00:47:37.580
What are some of the real world places where these constraint problems show up?

00:47:37.580 --> 00:47:39.560
I would say the most common is probably scheduling.

00:47:39.560 --> 00:47:44.420
So, if you think about a bunch of people want to meet and they have all of them at different

00:47:44.420 --> 00:47:48.320
availabilities, we could think about the individual people that want to meet as the

00:47:48.320 --> 00:47:53.540
variables, what their availabilities are as their domains, and who needs to be at that

00:47:53.540 --> 00:47:55.100
meeting as the constraints.

00:47:55.100 --> 00:48:02.080
And there's actually real life schedulers that use constraint satisfaction techniques to do

00:48:02.080 --> 00:48:02.540
scheduling.

00:48:02.540 --> 00:48:06.600
I can't tell you for sure if that's what Google Calendar uses, for example, but it wouldn't

00:48:06.600 --> 00:48:07.160
surprise me.

00:48:07.160 --> 00:48:07.800
Yeah, of course.

00:48:07.800 --> 00:48:08.880
So, very powerful.

00:48:08.880 --> 00:48:13.820
And I think the idea of the common technique across non-obvious things is really great with

00:48:13.820 --> 00:48:14.520
that set of problems.

00:48:14.520 --> 00:48:17.540
Another one are graph problems.

00:48:17.540 --> 00:48:24.100
Not parabola, but vertices and edges types of graph theory problems, right?

00:48:24.180 --> 00:48:24.460
Yeah.

00:48:24.460 --> 00:48:30.020
And I think this is an area that people who have a math degree or a CS degree are totally

00:48:30.020 --> 00:48:30.740
familiar with.

00:48:30.740 --> 00:48:35.920
And sometimes people who are self-taught programmers don't have any experience with.

00:48:35.920 --> 00:48:40.740
And it's, again, it's something that is applicable to actually a wide range of different problems.

00:48:40.740 --> 00:48:43.880
And you might not even realize it when you're first seeing it.

00:48:43.900 --> 00:48:45.540
Because what is a graph?

00:48:45.540 --> 00:48:50.080
Well, a graph is technically a set of vertices that are connected to each other by edges.

00:48:50.080 --> 00:48:52.540
And it's really an abstract math concept.

00:48:52.540 --> 00:48:55.780
But in the real world, we actually see them all the time.

00:48:55.780 --> 00:48:59.440
So anytime you see a network, that's basically a graph.

00:48:59.440 --> 00:49:02.640
For example, the subway in New York City, that's a graph.

00:49:02.640 --> 00:49:04.340
Every one of the stations is a vertice.

00:49:04.340 --> 00:49:08.200
And edges are the tunnels that connect each of those stations.

00:49:08.200 --> 00:49:12.280
If you want to lay out electric wire throughout a neighborhood, that's a graph.

00:49:12.420 --> 00:49:14.640
Each of the houses you need to hook up, that's a vertice.

00:49:14.640 --> 00:49:19.620
And the line you're going to run from one house to another or to the poles, that's an edge.

00:49:19.620 --> 00:49:25.780
So we can actually use this concept of just having vertices and edges to represent a huge number

00:49:25.780 --> 00:49:26.680
of different problems.

00:49:26.680 --> 00:49:32.560
And what we teach in the chapter is a bunch of different techniques for solving common problems

00:49:32.560 --> 00:49:37.660
you'd fall into when you want to use these graphs, such as how do I find the shortest path

00:49:37.660 --> 00:49:39.720
from one vertice to another?

00:49:39.720 --> 00:49:42.320
Or to put it in the context of what we just mentioned,

00:49:42.400 --> 00:49:46.400
how do I find the shortest path from one subway station to another subway station?

00:49:46.400 --> 00:49:54.260
Or how do I use the minimum amount of edges of certain lengths to connect all the different

00:49:54.260 --> 00:49:56.660
vertices in the context of the electric wire?

00:49:56.660 --> 00:50:02.140
How do I use as little electric wire as possible to electrify this whole neighborhood?

00:50:02.140 --> 00:50:07.200
And that's actually the problem that originally inspired some of these algorithms in Czech Republic.

00:50:07.520 --> 00:50:10.900
They were trying to electrify large parts of Czech Republic.

00:50:10.900 --> 00:50:15.500
And some mathematicians in Czech Republic in the 1920s and 1930s came up with the algorithms

00:50:15.500 --> 00:50:19.760
for finding the least amount of electric wire to electrify the country.

00:50:19.760 --> 00:50:20.940
That's a pretty cool bit of history.

00:50:20.940 --> 00:50:21.540
I didn't know that.

00:50:21.540 --> 00:50:24.780
I do like you in there when you're presenting the problem.

00:50:24.780 --> 00:50:29.360
You talk about the hyperloop and some of the interesting things you might consider.

00:50:29.520 --> 00:50:32.380
So you have a bunch of connections between the major cities.

00:50:32.380 --> 00:50:38.100
And you imagine those are hyperloop, Elon Musk, high speed tube things, connecting them.

00:50:38.100 --> 00:50:43.060
And you said, look, here's the map of the US and here's the cities and maybe the tracks.

00:50:43.060 --> 00:50:44.500
But throw away the map.

00:50:44.500 --> 00:50:47.940
Just think of these as connections and the points.

00:50:47.940 --> 00:50:49.720
And then how do you get from one point to the other?

00:50:50.260 --> 00:50:54.500
You also said some interesting things like, you know, probably it's longer to make a connection

00:50:54.500 --> 00:50:58.540
at a city than it is to travel between two cities, given that those things are supposed

00:50:58.540 --> 00:51:01.500
to travel, you know, supersonic effectively.

00:51:01.500 --> 00:51:02.080
Right.

00:51:02.080 --> 00:51:05.820
So that completely changes the way you think about solving the problem, right?

00:51:05.820 --> 00:51:06.180
Right.

00:51:06.180 --> 00:51:09.700
I mean, the hyperloop is supposed to be, for people that don't know, this super fast way

00:51:09.700 --> 00:51:12.980
of going 700 miles per hour in some tubes underground, right?

00:51:13.100 --> 00:51:16.260
If you're going 700 miles per hour, what do you care about more?

00:51:16.260 --> 00:51:17.840
How long the routes are?

00:51:17.840 --> 00:51:20.960
Do you care like that it's a thousand miles from one to another?

00:51:20.960 --> 00:51:24.780
Or do you care how many stops you're going to have to make along the way?

00:51:24.780 --> 00:51:28.380
Because it actually might be every time you make a stop, there's a little layover.

00:51:28.380 --> 00:51:33.260
And that will actually end up taking more time, even if the other route is a longer distance.

00:51:33.260 --> 00:51:38.340
So we use the hyperloop as a motivating problem to go through a bunch of these different graph

00:51:38.340 --> 00:51:38.820
algorithms.

00:51:39.140 --> 00:51:45.440
And one thing we find is that the distance that it takes might not matter as much as how

00:51:45.440 --> 00:51:49.180
many stops we make along the way for something like the hyperloop.

00:51:49.180 --> 00:51:53.660
And so there's a different algorithm you'd use for how many stops you want to make versus

00:51:53.660 --> 00:51:56.140
the route that might have the shortest distance.

00:51:56.140 --> 00:51:56.520
Right.

00:51:56.520 --> 00:52:01.060
Just to talk about things like minimum spanning trees, where like maybe what is the minimum

00:52:01.060 --> 00:52:05.940
amount of money or track or tube you can lay to actually just connect these things,

00:52:05.940 --> 00:52:08.200
regardless of what sufficient, right?

00:52:08.200 --> 00:52:08.440
Right.

00:52:08.640 --> 00:52:12.380
So if we think about every major city in the United States and we want to connect them

00:52:12.380 --> 00:52:12.900
all, right?

00:52:12.900 --> 00:52:18.980
How do you actually draw connections between all of them that would use the minimum amount

00:52:18.980 --> 00:52:23.720
of money to build, let's say, because it's going to be the minimum amount of track that you

00:52:23.720 --> 00:52:24.440
would have to lay?

00:52:24.440 --> 00:52:29.300
You know, as a human being, we can solve that pretty easily if there's like five cities,

00:52:29.300 --> 00:52:29.720
right?

00:52:29.720 --> 00:52:32.220
We may be even able to solve that if there's 10 cities.

00:52:32.220 --> 00:52:37.200
When you start thinking about 15 or 20 or 30, you need an efficient way for a computer to

00:52:37.200 --> 00:52:38.540
do that.

00:52:38.540 --> 00:52:41.700
And finding the minimum spanning tree is what we call those algorithms.

00:52:41.700 --> 00:52:42.080
Yeah.

00:52:42.080 --> 00:52:42.920
It's pretty cool.

00:52:42.920 --> 00:52:47.640
Another one, another category of problems that you talked about, and they seem to have a lot

00:52:47.640 --> 00:52:52.100
to do with games like board games and stuff, were the adversarial search problems.

00:52:52.360 --> 00:52:59.100
So these apply to zero sum, two player, perfect information games, unlike say a poker or something

00:52:59.100 --> 00:53:01.860
where you don't know what the other player has or can play, right?

00:53:01.860 --> 00:53:02.100
Right.

00:53:02.100 --> 00:53:07.200
So a very common thing that people do when they're learning programming is programming tic-tac-toe.

00:53:07.200 --> 00:53:10.100
It's just, for some reason, it's just something people love to do.

00:53:10.100 --> 00:53:15.860
Super easy to program tic-tac-toe when you're just saying, okay, player one is going to put X

00:53:15.860 --> 00:53:18.660
somewhere on the board and player two is going to put O somewhere on the board.

00:53:18.960 --> 00:53:19.460
That's easy.

00:53:19.460 --> 00:53:22.340
But what if you want the computer to play tic-tac-toe perfectly?

00:53:22.340 --> 00:53:29.260
So your first instinct might be, oh, so I'll just hard code that every time there's two

00:53:29.260 --> 00:53:32.100
things next to each other, have the computer do a block.

00:53:32.100 --> 00:53:37.180
Or every time there are the boards totally open, have the computer play center.

00:53:37.180 --> 00:53:42.520
But there's actually an algorithm called Minimax that instead of having to hard code every possible

00:53:42.520 --> 00:53:48.600
position, we can just have a way of figuring out what the best position is all the time by

00:53:48.600 --> 00:53:55.080
searching through what the result will be of the opponent's move to the computer's move.

00:53:55.080 --> 00:53:59.100
And then the result of the best move I can make to the opponent's move back and forth,

00:53:59.100 --> 00:54:01.560
back and forth till I get to the end of the game.

00:54:01.560 --> 00:54:06.240
Or sometimes in Minimax, like in a much more complex game than tic-tac-toe, something like

00:54:06.240 --> 00:54:10.320
chess or checkers, we won't get to the end of the game, but we'll get, let's say, five or

00:54:10.320 --> 00:54:11.480
six moves into the future.

00:54:11.480 --> 00:54:14.740
And we can then just see how good is the position at that point.

00:54:14.740 --> 00:54:21.200
So Minimax is an algorithm that we can use for any game that's basically two players that

00:54:21.200 --> 00:54:23.960
we can actually look at the whole board at once.

00:54:24.160 --> 00:54:28.180
And that's what we call perfect information, being able to see all the information about

00:54:28.180 --> 00:54:32.160
the game at any given time and have a computer play it really, really well.

00:54:32.160 --> 00:54:35.100
And this is the way that chess engines work, for example.

00:54:35.100 --> 00:54:40.700
Most of them use Minimax or more advanced variants of it that allow them to play better than any

00:54:40.700 --> 00:54:41.740
grandmaster in the world.

00:54:41.740 --> 00:54:47.920
And on a modern computer, you can program yourself a chess engine that'll be any of your friends.

00:54:47.920 --> 00:54:49.240
Easily.

00:54:49.240 --> 00:54:50.060
It's not that hard.

00:54:50.440 --> 00:54:50.620
Yeah.

00:54:50.620 --> 00:54:51.220
Yeah.

00:54:51.220 --> 00:54:54.700
You get a little IoT and a camera and some computer vision.

00:54:54.700 --> 00:54:56.940
They just take it to the tournament and hold it above, right?

00:54:56.940 --> 00:54:57.600
Yeah, exactly.

00:54:57.600 --> 00:54:58.060
Yeah.

00:54:58.060 --> 00:54:58.780
Yeah.

00:54:58.780 --> 00:54:59.420
It's pretty cool.

00:54:59.420 --> 00:55:00.040
That's a nice one.

00:55:00.040 --> 00:55:05.380
Now, I saved the craziest ones to ask you about for last because I looked through the

00:55:05.380 --> 00:55:09.420
examples and it still is kind of sketchy in my mind, but it's very interesting.

00:55:09.420 --> 00:55:15.800
That's the whole category of genetic algorithms where you don't really know the solution, but you

00:55:15.800 --> 00:55:20.340
turn loose a bunch of different algorithms and then they tweak themselves.

00:55:20.340 --> 00:55:23.000
And they evolve to try to find the solution.

00:55:23.000 --> 00:55:24.160
Tell us about that.

00:55:24.160 --> 00:55:24.480
Yeah.

00:55:24.480 --> 00:55:29.160
So with genetic algorithms, we don't usually know the way to solve the problem.

00:55:29.160 --> 00:55:34.320
So it might be a problem that's so hard that we don't know any way to efficiently come up

00:55:34.320 --> 00:55:35.040
with a solution.

00:55:35.040 --> 00:55:42.220
And so instead, we borrow this idea from nature of trying a lot of different solutions and slightly

00:55:42.220 --> 00:55:47.080
modifying them when we think they're getting closer to the actual solution.

00:55:47.460 --> 00:55:49.460
So in the real world, right?

00:55:49.460 --> 00:55:52.580
We have evolution and natural selection, right?

00:55:52.580 --> 00:55:57.480
You have some species comes up and it's really well adapted to its environment.

00:55:57.480 --> 00:55:58.640
So it has more children.

00:55:58.640 --> 00:56:03.680
And then some other modification to it might actually make it less adapted.

00:56:03.680 --> 00:56:04.800
So it has less children.

00:56:05.260 --> 00:56:09.460
And the species that's better adapted is the one that tends to survive over time, right?

00:56:09.460 --> 00:56:13.280
So it's just applying that same idea to solutions to a problem on a computer.

00:56:13.280 --> 00:56:17.920
We're saying, oh, I'm going to maybe at first even randomly try a bunch of random different

00:56:17.920 --> 00:56:18.500
solutions.

00:56:18.500 --> 00:56:22.860
The ones that seem to work better, oh, I'll let those solutions propagate.

00:56:22.860 --> 00:56:24.360
I'll modify them slightly.

00:56:24.360 --> 00:56:25.800
So it's like they're having children.

00:56:26.060 --> 00:56:30.820
And I'll let those children be the progenitors of the next generation of possible solutions.

00:56:30.820 --> 00:56:34.060
And the ones that didn't seem to work so well, well, I'm going to let them die.

00:56:34.060 --> 00:56:36.740
Unfortunately, that's how natural selection works.

00:56:36.740 --> 00:56:42.640
And so I'll keep hopefully slowly building by making small random modifications closer to

00:56:42.640 --> 00:56:44.080
an actual solution to the problem.

00:56:44.080 --> 00:56:50.900
Now, doing anything randomly is never probably going to be your first reach for solution to

00:56:50.900 --> 00:56:51.340
a problem.

00:56:51.640 --> 00:56:55.480
When you do something randomly, there's a strong possibility it'll take a really long

00:56:55.480 --> 00:56:58.160
time to really get to a good solution.

00:56:58.160 --> 00:57:03.060
So even if you're climbing in the right direction, as we do in genetic algorithms, right?

00:57:03.060 --> 00:57:08.060
So you only want to use genetic algorithms when you really can't think of any other way to

00:57:08.060 --> 00:57:09.000
approach this problem.

00:57:09.000 --> 00:57:13.700
But there are some situations where they work pretty well because we don't know any better

00:57:13.700 --> 00:57:15.300
way to really solve the problem.

00:57:15.300 --> 00:57:15.660
Sure.

00:57:15.660 --> 00:57:21.520
So I understand the idea of letting it evolve, like the algorithm evolve.

00:57:21.520 --> 00:57:22.980
You tweak it in a little way.

00:57:22.980 --> 00:57:29.920
But it seems to me like you almost have to give it the algorithm a fixed structure, right?

00:57:29.920 --> 00:57:35.920
You're going to try to do this with these seven, like almost constants or constraints that you're

00:57:35.920 --> 00:57:36.600
going to apply.

00:57:36.600 --> 00:57:41.460
But you're always going to like try to fit this type of calculation or this type of thing

00:57:41.460 --> 00:57:41.820
to it.

00:57:41.820 --> 00:57:45.520
Like how much variation can you actually get as these evolve?

00:57:45.520 --> 00:57:46.480
You're absolutely right.

00:57:46.480 --> 00:57:48.980
You do have to kind of set some constraints at the front.

00:57:48.980 --> 00:57:54.720
So for example, if I'm trying to find the solution to a math problem, right?

00:57:54.720 --> 00:58:00.100
And I have X and Y and X and Y, I need to know what are the right numbers that should fill in for X

00:58:00.100 --> 00:58:01.920
and Y to solve the math problem, right?

00:58:02.800 --> 00:58:08.260
It would be really helpful if instead of generating any random numbers at the very start, I put them

00:58:08.260 --> 00:58:09.660
within a reasonable range.

00:58:09.660 --> 00:58:14.720
Like if I know just before I start the problem that probably X and Y are going to be between

00:58:14.720 --> 00:58:19.640
zero and 100, it would be good if I just generated random X and Ys to start out with that are only

00:58:19.640 --> 00:58:20.780
between zero and 100.

00:58:20.780 --> 00:58:25.320
Because otherwise I could just go way off in the left field and never get anywhere close to

00:58:25.320 --> 00:58:25.780
my solution.

00:58:25.780 --> 00:58:26.580
So you're absolutely right.

00:58:26.580 --> 00:58:31.720
You have to have some knowledge of the problem to set it up appropriately for a genetic algorithm.

00:58:31.720 --> 00:58:32.000
Right.

00:58:32.000 --> 00:58:33.920
So it's not, well, is it possible?

00:58:33.920 --> 00:58:35.300
I guess let me just ask you that way.

00:58:35.300 --> 00:58:40.620
That, you know, I start up with an algorithm that says we're going to try to use this equation to

00:58:40.620 --> 00:58:45.600
match some kind of answer and it evolves itself into using a neural network instead.

00:58:45.600 --> 00:58:45.880
Oh.

00:58:45.880 --> 00:58:47.700
It can't make that much of a change, can it?

00:58:47.700 --> 00:58:52.020
No, it can't make, you know, it's interesting you mentioned that, you know, we do have a chapter

00:58:52.020 --> 00:58:53.100
in the book on neural networks.

00:58:53.100 --> 00:58:56.240
Neural networks are the hardest technique we go over in the book.

00:58:56.240 --> 00:59:00.660
If you want to do something even harder, I have a colleague at work and he works on using

00:59:00.660 --> 00:59:02.920
genetic algorithms with neural networks.

00:59:02.920 --> 00:59:03.960
Okay.

00:59:03.960 --> 00:59:05.000
That's pretty interesting.

00:59:05.000 --> 00:59:05.320
Yeah.

00:59:05.320 --> 00:59:10.040
Trying to evolve the neural networks to more accurately solve a certain problem.

00:59:10.040 --> 00:59:15.140
So yes, it is possible to combine the two techniques, but your listeners should not worry

00:59:15.140 --> 00:59:19.220
that if you just program a genetic algorithm, it will not morph itself into a neural network.

00:59:19.220 --> 00:59:22.320
There may be a singularity, but probably not.

00:59:22.320 --> 00:59:22.720
Not yet.

00:59:22.720 --> 00:59:23.560
Not for that path.

00:59:23.560 --> 00:59:23.720
Yeah.

00:59:23.720 --> 00:59:25.440
Not that way.

00:59:25.440 --> 00:59:25.680
No.

00:59:25.680 --> 00:59:26.560
That's cool.

00:59:26.560 --> 00:59:30.400
So I guess, you know, that covers many of the problems you laid out.

00:59:30.400 --> 00:59:34.040
There are some other popular ones like the knapsack and traveling salesman problems and

00:59:34.040 --> 00:59:35.460
some others we didn't cover as well.

00:59:35.460 --> 00:59:39.180
But there's a lot of cool techniques that I think are worth studying here.

00:59:39.180 --> 00:59:40.620
Which one is your favorite?

00:59:40.620 --> 00:59:46.900
So I would say that I actually like the graph problems best because we're doing something there

00:59:46.900 --> 00:59:51.780
that is motivated by a real world problem, which is building out a transportation network

00:59:51.780 --> 00:59:53.180
throughout the whole chapter.

00:59:53.180 --> 00:59:59.500
One thing that people might be a little suspicious of is that the book is full of toy problems,

00:59:59.500 --> 00:59:59.920
right?

00:59:59.920 --> 01:00:00.980
And that is true.

01:00:00.980 --> 01:00:05.340
A lot of the problems in the book are problems that are a little fanciful.

01:00:05.560 --> 01:00:10.320
They're not necessarily something that you're going to come across on a day-to-day basis because

01:00:10.320 --> 01:00:15.480
we have to have problems small enough that you can actually learn all of them in a fairly

01:00:15.480 --> 01:00:16.880
short chapter, right?

01:00:16.880 --> 01:00:21.800
We can't get into all the details of a really sophisticated problem, unfortunately, in a book

01:00:21.800 --> 01:00:23.420
of this length and this broad.

01:00:24.200 --> 01:00:25.780
So a lot of them are kind of toy problems.

01:00:25.780 --> 01:00:29.200
It's more about learning the techniques that you use on these toy problems and how they

01:00:29.200 --> 01:00:31.140
might apply to your real world problems.

01:00:31.140 --> 01:00:35.980
In the graph problem chapter, I think right away you can see how that problem is similar

01:00:35.980 --> 01:00:37.580
to a lot of real world problems.

01:00:37.580 --> 01:00:41.800
All the time, we're trying to figure out what's the most efficient way to traverse some kind

01:00:41.800 --> 01:00:42.300
of network.

01:00:42.660 --> 01:00:47.640
If you're working in even API plumbing, you might have a bunch of nodes that you need

01:00:47.640 --> 01:00:48.040
to hit.

01:00:48.040 --> 01:00:52.460
And what's the most efficient way to traverse hitting all those nodes in a certain order?

01:00:52.460 --> 01:00:55.100
That lends itself maybe to a graph problem.

01:00:55.100 --> 01:00:59.620
So the graph problem chapter, I really love just because it's so immediately applicable.

01:00:59.620 --> 01:01:00.960
Yeah, that's a good one.

01:01:00.960 --> 01:01:06.800
So one of the things that was evident to me was that choosing the right data structure was

01:01:06.800 --> 01:01:10.100
really important and learning the algorithms is good.

01:01:10.160 --> 01:01:14.420
But I think also knowing the data structures, maybe it's even more important in some ways.

01:01:14.420 --> 01:01:19.280
So for people who maybe are self-taught, what are some of the most important data structures?

01:01:19.280 --> 01:01:24.560
And where do you think they might have holes that they don't realize are blind spots that

01:01:24.560 --> 01:01:25.320
they should go check out?

01:01:25.320 --> 01:01:29.780
Well, if you're programming in Python, you got to be really, really familiar with lists and

01:01:29.780 --> 01:01:30.580
with dictionaries.

01:01:30.580 --> 01:01:35.200
I mean, if you're not at least an expert in those two, you're not using Python to its full

01:01:35.200 --> 01:01:40.040
extent because they are just so all over the language and all over the standard

01:01:40.040 --> 01:01:40.600
library.

01:01:40.600 --> 01:01:44.680
So you should at a minimum be familiar with lists and dictionaries.

01:01:44.680 --> 01:01:48.240
Now, then there's more abstract data structures that are built on top of those.

01:01:48.240 --> 01:01:52.380
Everyone should be familiar with stacks and queues, which are built on top of lists.

01:01:52.380 --> 01:01:56.520
And again, those are, like we mentioned earlier, structures that the first thing I put into them

01:01:56.520 --> 01:02:00.720
might be the first thing I get out in the case of a queue, or the last thing I put into

01:02:00.720 --> 01:02:04.400
them is the first thing I take out in the case of a stack.

01:02:04.400 --> 01:02:06.120
Everyone should be familiar with those two.

01:02:06.540 --> 01:02:10.780
Then we get into some that are a little bit more esoteric, like a priority queue.

01:02:10.780 --> 01:02:15.660
They're really useful to know about in certain applications or certain algorithms that are

01:02:15.660 --> 01:02:19.640
pretty useful algorithms like A-star, which we talked about earlier, that you can't implement

01:02:19.640 --> 01:02:20.320
without them.

01:02:20.320 --> 01:02:25.340
So you might not use them every day, but there are situations where it's good to be at least

01:02:25.340 --> 01:02:26.440
familiar with them.

01:02:26.700 --> 01:02:31.740
We don't do a lot of work in the book with trees, which some people might find surprising.

01:02:31.740 --> 01:02:36.280
But I'd say that's a common hole that people have is not being familiar with how to build

01:02:36.280 --> 01:02:37.760
a tree and how to structure a tree.

01:02:37.760 --> 01:02:42.260
And, you know, one thing people use this book for sometimes I've heard in the Swift book as

01:02:42.260 --> 01:02:44.140
well is preparing for interviews.

01:02:44.140 --> 01:02:49.380
Unfortunately, I think unfortunately, a lot of programming interviews have become very kind

01:02:49.380 --> 01:02:50.640
of algorithmic problem solving.

01:02:50.940 --> 01:02:55.480
I think knowing all these data structures will help you a lot when doing those interviews.

01:02:55.480 --> 01:03:01.880
And so I'd recommend everyone be familiar with stacks, queues, priority queues, trees, of

01:03:01.880 --> 01:03:03.340
course, lists and dictionaries.

01:03:03.340 --> 01:03:05.740
Everyone who programs in Python should be an expert on dictionaries.

01:03:05.740 --> 01:03:06.440
I'm sure you'd agree.

01:03:06.440 --> 01:03:06.840
I do.

01:03:06.840 --> 01:03:12.120
I definitely agree that, you know, the dictionaries especially show up not just where you use them,

01:03:12.260 --> 01:03:15.680
but they also show up as foundational things, right?

01:03:15.680 --> 01:03:19.560
Like for the backing, holding all the fields and attributes of a class, for example.

01:03:19.560 --> 01:03:20.960
So super, super important.

01:03:20.960 --> 01:03:21.520
Yeah.

01:03:21.520 --> 01:03:26.440
So I guess one other question along those lines is people are excited about this topic.

01:03:26.440 --> 01:03:27.560
Maybe they get your book.

01:03:27.560 --> 01:03:28.760
Where else could they go?

01:03:28.760 --> 01:03:33.220
I mean, are there good MOOCs like Carnegie Mellon or something like that?

01:03:33.220 --> 01:03:34.040
Or where should they go?

01:03:34.040 --> 01:03:35.400
I'll point out a few different resources.

01:03:35.400 --> 01:03:38.980
So first of all, I should say this book is not a textbook.

01:03:39.200 --> 01:03:42.360
So it doesn't teach you a lot of the math behind these algorithms.

01:03:42.360 --> 01:03:44.920
It doesn't teach you big O notation.

01:03:44.920 --> 01:03:48.460
It uses big O notation a little bit, but it doesn't really go into a lot about it.

01:03:48.460 --> 01:03:51.400
So we really wanted to make it a really approachable book.

01:03:51.400 --> 01:03:52.760
So we kept the math to a minimum.

01:03:52.760 --> 01:03:56.740
We even tried to keep the math to a minimum in chapters like the neural networks chapter

01:03:56.740 --> 01:03:58.380
and the k-means clustering chapter.

01:03:58.380 --> 01:04:03.180
These more kind of AI chapters, machine learning chapters, because we wanted the book to be approachable.

01:04:03.180 --> 01:04:07.420
That said, that means that we're not really giving you the full story.

01:04:07.420 --> 01:04:11.520
And so if you really want to get the full story, there's a couple textbooks I'd recommend.

01:04:11.520 --> 01:04:14.740
One is Algorithms by Sedgwick and Wayne.

01:04:14.740 --> 01:04:19.100
That's a really common college textbook on algorithms and data structures.

01:04:19.100 --> 01:04:23.540
And it is probably the most approachable, in my opinion, of the textbooks.

01:04:23.540 --> 01:04:24.420
It's really well written.

01:04:24.420 --> 01:04:26.540
Unfortunately, it's in Java, not in Python.

01:04:26.540 --> 01:04:28.100
So that kind of sucks.

01:04:28.100 --> 01:04:31.460
But it's still a really easy, readable textbook.

01:04:31.460 --> 01:04:36.960
The classic textbook in this area is called Introduction to Algorithms by Corman and his

01:04:36.960 --> 01:04:39.040
co-authors, CLRS, it's sometimes called.

01:04:39.040 --> 01:04:41.300
That is a really good textbook.

01:04:41.300 --> 01:04:43.880
It's more reference quality material.

01:04:43.880 --> 01:04:48.680
Some people say it's a little bit less approachable than just the Algorithms book by Sedgwick.

01:04:48.680 --> 01:04:54.160
In terms of online resources, strongly would recommend the Algorithms course on Khan Academy.

01:04:54.600 --> 01:04:57.300
Again, unfortunately, it's in JavaScript, not in Python.

01:04:57.300 --> 01:05:01.860
But having looked at a bunch of these resources, I really think for new learners, that's a really

01:05:01.860 --> 01:05:03.400
strong course on Khan Academy.

01:05:03.400 --> 01:05:07.760
If you want to get more into the machine learning type of stuff we talked about in the book, like

01:05:07.760 --> 01:05:12.280
K-means clustering and neural networks, then the machine learning course on Coursera taught

01:05:12.280 --> 01:05:16.920
by Andrew Ng has become kind of a standard that a lot of people go through.

01:05:16.920 --> 01:05:19.000
And it's very high quality.

01:05:19.000 --> 01:05:24.700
And unfortunately, again, it's in MATLAB slash Octave instead of Python.

01:05:24.700 --> 01:05:29.400
I don't think there are a couple Python textbooks and data structures and algorithms.

01:05:29.400 --> 01:05:32.440
None of them have become, let's say, classics.

01:05:32.440 --> 01:05:35.780
So I can't individually recommend any of them.

01:05:35.780 --> 01:05:38.920
I'm also not immediately familiar with all of them.

01:05:38.920 --> 01:05:43.400
But I do think most of these resources for anyone who's been doing a year or two of Python,

01:05:43.400 --> 01:05:47.040
you'd be quickly able to read most of the ones that we mentioned.

01:05:47.040 --> 01:05:47.320
Right.

01:05:47.320 --> 01:05:47.580
Okay.

01:05:47.580 --> 01:05:48.560
Well, that sounds great.

01:05:48.560 --> 01:05:51.300
Well, Dave, I think we're getting pretty low on our time.

01:05:51.300 --> 01:05:54.460
So we've used it about up and talking about all these great things.

01:05:54.460 --> 01:05:55.980
So I guess we'll have to leave it here.

01:05:55.980 --> 01:05:59.880
But let me ask you the two questions before we call it a show.

01:05:59.880 --> 01:06:03.080
If you're going to write some Python code, what editor do you use?

01:06:03.080 --> 01:06:04.600
I'm all about PyCharm now.

01:06:04.600 --> 01:06:05.260
Big fan.

01:06:05.260 --> 01:06:05.760
Right on.

01:06:05.760 --> 01:06:06.120
Me too.

01:06:06.360 --> 01:06:11.160
And then notable PyPI package, even though, ironically, you didn't really use many of them

01:06:11.160 --> 01:06:12.700
in your examples.

01:06:12.700 --> 01:06:15.680
What's maybe one folks haven't heard of that they should know about?

01:06:15.680 --> 01:06:16.500
Well, I don't know.

01:06:16.500 --> 01:06:17.740
People are familiar with it, I'm sure.

01:06:17.740 --> 01:06:18.520
scikit-learn.

01:06:18.520 --> 01:06:21.760
I think scikit-learn just has so much functionality built in.

01:06:21.760 --> 01:06:26.060
And let me just add, you know, the purpose of reading a book like this is not that you're

01:06:26.060 --> 01:06:28.240
going to go implement all of these techniques yourself.

01:06:28.240 --> 01:06:32.960
It's so that you're going to know which open source library to include in your project.

01:06:33.160 --> 01:06:36.260
We don't expect you to go implement scikit-learn yourself.

01:06:36.260 --> 01:06:39.860
But when you use scikit-learn, which of the algorithms from it should you be using?

01:06:39.860 --> 01:06:40.860
Yeah, it makes a lot of sense.

01:06:40.860 --> 01:06:41.760
Yeah.

01:06:41.760 --> 01:06:45.220
You don't want to go and reinvent 10 years of lots of work, right?

01:06:45.220 --> 01:06:46.340
It's like reinventing NumPy.

01:06:46.340 --> 01:06:48.460
You wouldn't do it, but understanding what's happening is really good.

01:06:48.460 --> 01:06:48.820
Exactly.

01:06:48.820 --> 01:06:49.140
Yeah.

01:06:49.140 --> 01:06:49.340
Cool.

01:06:49.340 --> 01:06:50.120
All right.

01:06:50.120 --> 01:06:51.080
Well, final call to action.

01:06:51.080 --> 01:06:55.820
People want to get more into learning these algorithms and data structures and these classic

01:06:55.820 --> 01:06:56.160
problems.

01:06:56.160 --> 01:06:56.640
What do they do?

01:06:56.720 --> 01:06:58.240
Well, you can get the book from Manning.

01:06:58.240 --> 01:07:00.080
Manning's a publisher, manning.com.

01:07:00.080 --> 01:07:02.580
And I think you're going to be offering a promo code for your listeners.

01:07:02.580 --> 01:07:05.260
It's called Classic Computer Science Problems in Python.

01:07:05.260 --> 01:07:08.900
It's also going to be available on Amazon starting at the beginning of April.

01:07:08.900 --> 01:07:09.200
Okay.

01:07:09.200 --> 01:07:10.340
Sounds great.

01:07:10.340 --> 01:07:13.240
Well, Dave, thank you for being on the show.

01:07:13.240 --> 01:07:14.560
It was great to talk to you about all these things.

01:07:14.560 --> 01:07:16.760
There's a bunch of cool stuff you put together here.

01:07:16.760 --> 01:07:17.740
Thanks a lot for having me, Michael.

01:07:17.740 --> 01:07:18.320
It was a real pleasure.

01:07:18.320 --> 01:07:18.680
You bet.

01:07:18.680 --> 01:07:18.860
Bye.

01:07:19.060 --> 01:07:23.000
This has been another episode of Talk Python to Me.

01:07:23.000 --> 01:07:27.480
Our guest on this episode was David Kopech, and it's been brought to you by Microsoft.

01:07:27.480 --> 01:07:31.040
If you're a Python developer, Microsoft has you covered.

01:07:31.040 --> 01:07:36.140
From VS Code and their modern editor plugins, to Azure Pipelines for continuous integration,

01:07:36.140 --> 01:07:38.920
and serverless Python functions on Azure.

01:07:38.920 --> 01:07:42.580
Check them out at talkpython.fm/Microsoft.

01:07:42.580 --> 01:07:44.840
Want to level up your Python?

01:07:45.200 --> 01:07:49.700
If you're just getting started, try my Python Jumpstart by Building 10 Apps course.

01:07:49.700 --> 01:07:54.780
Or if you're looking for something more advanced, check out our new async course that digs into

01:07:54.780 --> 01:07:57.860
all the different types of async programming you can do in Python.

01:07:57.860 --> 01:08:01.820
And of course, if you're interested in more than one of these, be sure to check out our

01:08:01.820 --> 01:08:02.520
Everything Bundle.

01:08:02.520 --> 01:08:04.400
It's like a subscription that never expires.

01:08:04.400 --> 01:08:06.700
Be sure to subscribe to the show.

01:08:06.700 --> 01:08:09.200
Open your favorite podcatcher and search for Python.

01:08:09.200 --> 01:08:10.340
We should be right at the top.

01:08:10.340 --> 01:08:15.160
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:08:15.560 --> 01:08:19.340
and the direct RSS feed at /rss on talkpython.fm.

01:08:19.340 --> 01:08:21.420
This is your host, Michael Kennedy.

01:08:21.420 --> 01:08:22.920
Thanks so much for listening.

01:08:22.920 --> 01:08:24.000
I really appreciate it.

01:08:24.000 --> 01:08:25.740
Now get out there and write some Python code.

01:08:25.740 --> 01:08:26.380
I'll see you next time.

01:08:26.380 --> 01:08:26.380
Bye.

01:08:26.380 --> 01:08:26.380
Bye.

01:08:26.380 --> 01:08:26.400
Bye.

01:08:26.400 --> 01:08:27.040
Bye.

01:08:27.040 --> 01:08:27.040
Bye.

01:08:27.040 --> 01:08:27.040
Bye.

01:08:27.040 --> 01:08:27.040
Bye.

01:08:27.040 --> 01:08:27.040
Bye.

01:08:27.040 --> 01:08:27.680
Bye.

01:08:27.680 --> 01:08:27.680
Bye.

01:08:27.680 --> 01:08:27.680
Bye.

01:08:27.680 --> 01:08:27.680
Bye.

01:08:27.680 --> 01:08:27.680
Bye.

01:08:27.680 --> 01:08:28.320
Bye.

01:08:28.320 --> 01:08:28.320
Bye.

01:08:28.320 --> 01:08:28.320
Bye.

01:08:28.320 --> 01:08:28.320
Bye.

01:08:28.320 --> 01:08:28.320
Bye.

01:08:28.320 --> 01:08:28.960
Bye.

01:08:28.960 --> 01:08:28.960
Bye.

01:08:28.960 --> 01:08:28.960
Bye.

01:08:28.960 --> 01:08:28.960
Bye.

01:08:28.960 --> 01:08:29.600
Bye.

01:08:29.600 --> 01:08:29.600
Bye.

01:08:29.600 --> 01:08:29.600
Bye.

01:08:29.600 --> 01:08:29.600
Bye.

01:08:29.600 --> 01:08:29.600
Bye.

01:08:29.600 --> 01:08:29.600
Bye.

01:08:29.600 --> 01:08:29.600
Bye.

01:08:29.600 --> 01:08:30.240
Bye.

01:08:30.240 --> 01:08:30.240
Bye.

01:08:30.240 --> 01:08:30.240
Bye.

01:08:30.240 --> 01:08:30.240
Bye.

01:08:30.240 --> 01:08:30.240
Bye.

01:08:30.240 --> 01:08:30.240
Bye.

01:08:30.240 --> 01:08:30.240
Bye.

01:08:30.240 --> 01:08:30.880
Bye.

01:08:30.880 --> 01:08:30.880
Bye.

01:08:30.880 --> 01:08:30.880
Bye.

01:08:30.880 --> 01:08:30.880
Bye.

01:08:30.880 --> 01:08:30.880
Bye.

01:08:30.880 --> 01:08:30.880
Bye.

01:08:30.880 --> 01:08:30.880
Bye.

01:08:30.880 --> 01:08:31.520
Bye.

01:08:31.520 --> 01:08:31.520
Bye.

01:08:31.520 --> 01:08:31.520
Bye.

01:08:31.520 --> 01:08:31.520
Bye.

01:08:31.520 --> 01:08:32.160
Bye.

01:08:32.160 --> 01:08:32.160
Bye.

01:08:32.160 --> 01:08:32.160
Bye.

01:08:32.160 --> 01:08:32.160
Bye.

01:08:32.160 --> 01:08:32.160
Bye.

01:08:32.160 --> 01:08:32.160
Bye.

01:08:32.160 --> 01:08:32.160
Bye.

01:08:32.160 --> 01:08:32.800
Bye.

01:08:32.800 --> 01:08:32.800
Bye.

01:08:32.800 --> 01:08:32.800
Bye.

01:08:32.800 --> 01:08:32.800
Bye.

01:08:32.800 --> 01:08:32.800
Bye.

01:08:32.800 --> 01:08:33.440
Bye.

01:08:33.440 --> 01:08:33.440
Bye.

01:08:33.440 --> 01:08:33.440
Bye.

01:08:33.440 --> 01:08:33.440
Bye.

01:08:33.440 --> 01:08:34.080
Bye.

01:08:34.080 --> 01:08:34.080
Bye.

01:08:34.080 --> 01:08:34.080
Bye.

01:08:34.080 --> 01:08:34.080
Bye.

01:08:34.080 --> 01:08:34.080
Bye.

01:08:34.080 --> 01:08:34.720
Bye.

01:08:34.720 --> 01:08:34.720
Bye.

01:08:34.720 --> 01:08:34.720
Bye.

01:08:34.720 --> 01:08:34.720
Bye.

01:08:34.720 --> 01:08:35.360
Bye.

01:08:35.360 --> 01:08:35.360
Bye.

01:08:35.360 --> 01:08:35.360
Bye.

01:08:35.360 --> 01:08:35.360
Bye.

01:08:35.360 --> 01:08:36.000
Bye.

01:08:36.000 --> 01:08:36.000
Bye.

01:08:36.000 --> 01:08:36.000
Bye.

01:08:36.000 --> 01:08:36.000
Bye.

01:08:36.000 --> 01:08:36.640
Bye.

01:08:36.640 --> 01:08:36.640
Bye.

01:08:36.640 --> 01:08:36.640
Bye.

01:08:36.640 --> 01:08:37.280
Bye.

01:08:37.280 --> 01:08:37.280
Bye.

01:08:37.280 --> 01:08:37.280
Bye.

01:08:37.280 --> 01:08:37.280
Bye.

01:08:37.280 --> 01:08:37.920
Bye.

01:08:37.920 --> 01:08:37.920
Bye.

01:08:37.920 --> 01:08:37.920
Bye.

01:08:37.920 --> 01:08:38.560
Bye.

01:08:38.560 --> 01:08:38.560
Bye.

01:08:38.560 --> 01:08:38.560
Bye.

01:08:38.560 --> 01:08:39.200
Bye.

01:08:39.200 --> 01:08:39.200
Bye.

01:08:39.200 --> 01:08:39.200
Bye.

01:08:39.200 --> 01:08:39.200
Bye.

01:08:39.200 --> 01:08:39.840
Bye.

01:08:39.840 --> 01:08:39.840
Bye.

01:08:39.840 --> 01:08:39.840
Bye.

01:08:39.840 --> 01:08:39.840
Bye.

01:08:39.840 --> 01:08:40.480
Bye.

01:08:40.480 --> 01:08:40.480
Bye.

01:08:40.480 --> 01:08:40.480
Bye.

01:08:40.480 --> 01:08:41.120
Bye.

01:08:41.120 --> 01:08:41.120
Bye.

01:08:41.120 --> 01:08:41.120
Bye.

01:08:41.120 --> 01:08:41.760
Bye.

01:08:41.760 --> 01:08:41.760
Bye.

01:08:41.760 --> 01:08:41.760
Bye.

01:08:41.760 --> 01:08:42.400
Bye.

01:08:42.400 --> 01:08:42.900
you

01:08:42.900 --> 01:08:43.400
you

01:08:43.400 --> 01:08:43.900
you

01:08:43.900 --> 01:08:45.900
Thank you.

01:08:45.900 --> 01:09:15.880
Thank you.

