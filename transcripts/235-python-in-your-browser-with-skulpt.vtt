WEBVTT

00:00:00.001 --> 00:00:04.060
Do you dream of a day when you can write Python in the browser rather than using JavaScript?

00:00:04.060 --> 00:00:09.120
This is no pipe dream. There are several ways to write Python that run in the browser already.

00:00:09.120 --> 00:00:12.980
One of the leaders here is Sculpt. This is not just an experiment. Real,

00:00:12.980 --> 00:00:18.840
powerful web applications with rich client-side code, Python code, are out in the wild and built

00:00:18.840 --> 00:00:24.240
with Sculpt today. We dig into it with Meredith Loof and Albert-Jan Nyberg on this episode.

00:00:24.240 --> 00:00:29.720
This is Talk Python To Me, episode 235, recorded September 26th, 2019.

00:00:29.720 --> 00:00:48.200
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the ecosystem,

00:00:48.200 --> 00:00:53.300
and the personalities. This is your host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy.

00:00:53.300 --> 00:00:57.040
Keep up with the show and listen to past episodes at talkpython.fm,

00:00:57.040 --> 00:00:59.540
and follow the show on Twitter via at Talk Python.

00:00:59.980 --> 00:01:04.560
This episode is brought to you by Linode and Tidelift. Please check out what they're offering

00:01:04.560 --> 00:01:08.640
during their segments. It really helps support the show. Welcome to Talk Python To Me.

00:01:08.640 --> 00:01:09.580
Hello, great to be here.

00:01:09.580 --> 00:01:10.560
Hi, thank you.

00:01:10.560 --> 00:01:15.200
Yeah, it's great to have you both. And Meredith, welcome back. We talked about your cool project,

00:01:15.200 --> 00:01:18.080
Anvil, about two years ago, wasn't it, on the show?

00:01:18.080 --> 00:01:21.080
Gosh, yeah. November 2017. Feels like a lifetime ago.

00:01:21.080 --> 00:01:22.320
Yeah, in Anvil years.

00:01:22.320 --> 00:01:25.260
Oh, yes. Well, startup time operates. It's like dog years, only more intense.

00:01:25.400 --> 00:01:30.700
Yeah, yeah, absolutely. And nice to have you here, Albert. So I kind of want to start the

00:01:30.700 --> 00:01:36.080
conversation here. We're going to talk about Python in the browser with Sculpt. So I want to start the

00:01:36.080 --> 00:01:41.880
conversation with just each of you talking about your involvement in the project. I know you both

00:01:41.880 --> 00:01:47.020
have done various things to keep it rolling and work on it day to day. So tell us about it. Albert,

00:01:47.020 --> 00:01:47.520
you want to go first?

00:01:47.520 --> 00:01:55.580
I started using Sculpt because of a very bad decision I made a few years ago. Eight years ago,

00:01:55.580 --> 00:02:01.520
I think. We had the idea that we wanted to write cloud validation and server-side validation in the

00:02:01.520 --> 00:02:07.240
same language, so we'd only have to write them once. And our backend at that point was in C#,

00:02:07.240 --> 00:02:13.480
and the frontend was in JavaScript. And the only thing we could run in both ends was Python.

00:02:14.000 --> 00:02:15.980
So we ended up with Sculpt.

00:02:15.980 --> 00:02:21.500
That's a funny path, right? I wouldn't think if you combine JavaScript and C# that you end up

00:02:21.500 --> 00:02:21.900
with Python.

00:02:21.900 --> 00:02:30.060
Yeah. I wouldn't advise anybody to do this. It did put me in this position where we found Sculpt in this

00:02:30.060 --> 00:02:36.400
slightly disheveled state because the original author had sort of left it. And we ran into problems,

00:02:36.400 --> 00:02:39.540
and I started fixing them. And yeah, it slowly grows.

00:02:39.720 --> 00:02:41.660
Yeah. Who was the original author? Was that Brad Miller?

00:02:41.660 --> 00:02:44.860
No. Scott. I've forgotten his name.

00:02:44.860 --> 00:02:50.440
Yeah. So Sculpt is not totally new. I was looking through some of the docs and stuff. I certainly

00:02:50.440 --> 00:02:56.280
saw 2011 here and there. And that actually would put the timeframe almost exactly the timeframe that

00:02:56.280 --> 00:02:56.980
you're talking about, Albert.

00:02:56.980 --> 00:03:01.880
Yeah. The original author started off as this. He was really frustrated with JavaScript,

00:03:02.320 --> 00:03:05.040
and he liked Python a lot. So he's like, how hard can you do it?

00:03:05.040 --> 00:03:06.900
Famous last words.

00:03:06.900 --> 00:03:11.260
Yeah. No, but he's like an amazing software engineer because he got such a long way. He

00:03:11.260 --> 00:03:18.520
got the compiler and the parser and everything. And, you know, he got the sizable chunk working,

00:03:18.520 --> 00:03:23.220
but then abandoned it. There was other stuff to do, probably. And we found it in that state,

00:03:23.220 --> 00:03:24.720
and we just took it from there.

00:03:24.880 --> 00:03:25.080
Great.

00:03:25.080 --> 00:03:29.080
Ask your next question because I'm going to come in at the point of the story where I actually come in.

00:03:29.080 --> 00:03:33.560
Yeah. I was going to say, so Albert, what's your relationship to the project today? I know that

00:03:33.560 --> 00:03:39.000
you're doing a lot of like overseeing issues and merging PRs and things like that. Are you leading

00:03:39.000 --> 00:03:41.760
the project or are you working with someone else who is?

00:03:41.760 --> 00:03:49.280
The official leader is Brad Miller. Okay. He took the main ownership over, but two or three in the line

00:03:49.280 --> 00:03:56.620
of the people I contributed most. And, you know, I feel this thing where if people do issues or pull

00:03:56.620 --> 00:04:03.200
requests, I always feel obliged to act on them. So I do. Yeah. There's no official split of task here.

00:04:03.200 --> 00:04:05.940
Sure. Sure. Marith, tell us about your involvement.

00:04:05.940 --> 00:04:11.400
So I came to Sculpt a little bit later. It would have been, oh, I guess sometime around 2015.

00:04:11.400 --> 00:04:17.080
So I came to Sculpt via Anvil, which if you haven't heard of it, it's a tool for building

00:04:17.080 --> 00:04:21.800
full stack web apps with nothing but Python. So Python in the browser, Python on the server,

00:04:21.800 --> 00:04:26.740
function calls from one to the other. It's all very nice, but obviously to achieve that vision,

00:04:26.740 --> 00:04:33.380
you need to run Python in the web browser as well. So we launched out on a little Safari of Python

00:04:33.380 --> 00:04:39.480
options for running Python in the web browser. And I was actually already familiar with Sculpt from

00:04:39.480 --> 00:04:46.160
some educational work we had done as part of an outreach workshop at the University of Cambridge,

00:04:46.160 --> 00:04:53.000
where my co-founder Ian and I did our PhDs. And so it was the closest tool to hand. Actually,

00:04:53.000 --> 00:04:59.020
when we looked around, we realized it was in fact, the best tool for building a new way to drive web

00:04:59.020 --> 00:05:03.620
environments with Python. Because as we'll probably discuss later, a lot of the other approaches,

00:05:03.620 --> 00:05:10.720
they think very JavaScript-y, and Sculpt thinks very Python-y, and then makes whoever's embedding

00:05:10.720 --> 00:05:14.100
it in the web page do the work, which is, as far as I'm concerned, the right way around.

00:05:14.100 --> 00:05:19.140
Yeah, if you want to bring Python to the browser, right, it should be as Pythonic as possible. And then

00:05:19.140 --> 00:05:20.560
then you make it work, right?

00:05:20.560 --> 00:05:26.520
That's the idea. Yes. Well, that's certainly Sculpt's idea. And certainly Anvil's idea.

00:05:26.640 --> 00:05:35.400
So I jumped in then, I sort of announced my arrival with a major pull request turning Sculpt's

00:05:35.400 --> 00:05:40.680
fundamentally JavaScript-like model, which is to say that it had to execute all at once and then be

00:05:40.680 --> 00:05:46.120
finished, into this asynchronous model where you could write blocking Python code, and then the

00:05:46.120 --> 00:05:50.460
JavaScript runtime, it could sort of hand control back to the JavaScript runtime for a little bit. And then

00:05:50.460 --> 00:05:54.860
when some asynchronous operation had completed, like going to the server for something or getting

00:05:54.860 --> 00:06:02.760
some user entry, it could resume your Python code exactly where it was. And from there, I've become,

00:06:02.760 --> 00:06:09.920
like Albert, one of the more active contributors on the project. And as Albert said, there isn't really

00:06:09.920 --> 00:06:17.740
division of tasks. We all just jump in wherever it is that we see efforts in need of things. So I do a lot

00:06:17.740 --> 00:06:25.080
of work on the compiler. I do sort of a cleanup of bugs that people find in Sculpt, typically while

00:06:25.080 --> 00:06:29.580
using Anvil in advanced ways. And of course, the reason I'm here...

00:06:29.580 --> 00:06:32.360
You're like, wait, that should work in Python, right? But it's not.

00:06:32.360 --> 00:06:37.060
Yes, absolutely. You know, like any non-core Python implementation, there are going to be

00:06:37.060 --> 00:06:42.020
divergence bugs where CPython does one thing and we do the other, and we need to run in and fix those.

00:06:42.140 --> 00:06:49.480
And of course, most recently, Albert and I did the big upgrade of Sculpt from the Python 2.7

00:06:49.480 --> 00:06:56.200
grammar to the Python 3.7 grammar, which opens the door to us moving to an actual Python 3 world in

00:06:56.200 --> 00:06:59.320
Sculpt, getting in under the wire for the end of life for Python 2.

00:06:59.320 --> 00:07:03.220
Yeah, beautiful. Yeah. So heck, you've got months to spare, at least one.

00:07:03.220 --> 00:07:06.300
Days, whole days, Michael.

00:07:06.300 --> 00:07:08.600
Whole days. It's so much time.

00:07:08.740 --> 00:07:09.180
It's good, though.

00:07:09.180 --> 00:07:15.140
Yeah, it's got to feel good because, yeah, it was 2.7 or even 2.6 for quite a while. So it's great to see

00:07:15.140 --> 00:07:16.000
making progress.

00:07:16.000 --> 00:07:16.260
Yeah.

00:07:16.260 --> 00:07:16.800
That's awesome.

00:07:16.800 --> 00:07:21.920
Updating the grammar to 2.7 was one of my first big projects in Python.

00:07:21.920 --> 00:07:26.760
And that was only one step, and that took me, I think, a summer of coding.

00:07:26.760 --> 00:07:33.500
Just looking at the way that Sculpt creates the JavaScript or the JavaScript stuff is implemented

00:07:33.500 --> 00:07:38.200
for even something like a print hello world, there's like a lot of stuff going on in JavaScript

00:07:38.200 --> 00:07:43.160
there that it's kind of got to set up the environment. So yeah, I can imagine changing and making those

00:07:43.160 --> 00:07:44.200
changes took some work.

00:07:44.200 --> 00:07:50.520
That question cuts to the core of one of the biggest design questions for every Python in

00:07:50.520 --> 00:07:57.760
the browser implementation, which is essentially, are you trying to do the minimum possible to

00:07:57.760 --> 00:08:06.300
allow you to write Python in a JavaScript world? And, you know, Transcript, for example, is an

00:08:06.300 --> 00:08:11.820
example of a project that really does take that approach. It translates Python to JavaScript code that

00:08:11.820 --> 00:08:18.300
looks very much like the Python code. And the price it pays for that is that it's somewhat loose on the

00:08:18.300 --> 00:08:23.860
Python semantics. And the way you interact with the page is certainly not Pythonic at all, if you

00:08:23.860 --> 00:08:24.700
want to do any IO.

00:08:24.700 --> 00:08:25.020
Right.

00:08:25.020 --> 00:08:32.180
And Sculpt is right the way at the other end of the spectrum, where you say, I don't care how much work

00:08:32.180 --> 00:08:39.360
the JavaScript has to do around here, I am going to deliver a Python-y experience to the user and

00:08:39.360 --> 00:08:44.800
allow them to be interactive and allow them to think about the outside world as a Python

00:08:44.800 --> 00:08:49.360
programmer would, you know, as something you can print to, as opposed to something where you get

00:08:49.360 --> 00:08:55.340
some document object and then get some HTML element, and then you do some translated DOM manipulation on

00:08:55.340 --> 00:08:56.340
it and jump out a window.

00:08:56.340 --> 00:08:59.520
Exactly, exactly. Like what? I was trying to avoid all this. Now I'm back, right?

00:08:59.520 --> 00:09:04.720
At the beginning here, I do want to throw out something real quick for you, Marith, because

00:09:04.720 --> 00:09:10.160
a lot of these attempts to do this kind of stuff, what I feel like it results in, and

00:09:10.160 --> 00:09:15.280
you tell me if your experience is like this maybe, is it results in like a minimum proof

00:09:15.280 --> 00:09:22.000
of concept feeling, you know, like, oh yeah, so I technically could do NumPy here in this

00:09:22.000 --> 00:09:27.120
example, or I technically could do like this Python thing and Rust a little bit, but it's

00:09:27.120 --> 00:09:31.980
actually anything real and interesting is kind of like beyond it, right? It kind of sounds like

00:09:31.980 --> 00:09:36.240
you're describing that maybe with transcript a tiny bit. But the reason I bring this up

00:09:36.240 --> 00:09:41.860
is your use case, we're using Sculpt with Anvil. Those are massive applications doing

00:09:41.860 --> 00:09:48.500
complete end-to-end application Python, much of which I would say 80% of which is in the

00:09:48.500 --> 00:09:53.140
front, in the browser. You're building single page applications with a UI with Python.

00:09:53.420 --> 00:10:00.060
That's the point. So if you want to take a step back and ask if you're trying to put Python

00:10:00.060 --> 00:10:07.800
in the front end, what exactly are you trying to accomplish? And sometimes, you know, somebody

00:10:07.800 --> 00:10:11.260
might think, oh well, you know, I like Python, I want to hack around with a compiler, that's

00:10:11.260 --> 00:10:16.240
fine, you know, I'm going to do this as a hobby. But if you want to actually use it, then you need

00:10:16.240 --> 00:10:23.600
to know what it is you're trying to do. And especially Python people tend to be back-end

00:10:23.600 --> 00:10:31.800
or data or sysadmins or systems programmers. We will look at the web and go, that is ridiculous.

00:10:31.800 --> 00:10:37.060
Like the bar that you have to meet to build a full web application is way too high. To build an

00:10:37.060 --> 00:10:42.440
application on the quote-unquote traditional stack, you need to know like HTML and JavaScript and CSS and

00:10:42.440 --> 00:10:46.360
Python for the back-end and SQL for the database and then React and then Redux and then Webpack and then

00:10:46.360 --> 00:10:50.120
Bootstrap and then SAS and I've run out of fingers to count on, but there's more.

00:10:50.120 --> 00:10:54.080
And Nginx and Microwisgee and Ansible and...

00:10:54.080 --> 00:11:01.660
Oh god, yes, make it stop. Right. And some people look at that and the most acute pain points they can

00:11:01.660 --> 00:11:06.800
see are to do with the JavaScript ecosystem. They go, these JavaScript frameworks are out of control.

00:11:06.800 --> 00:11:11.020
If we could only replace JavaScript with a nicer language, we would solve this problem.

00:11:12.020 --> 00:11:17.540
And actually, I think that's missing the point slightly. I'm firmly convinced that the problem

00:11:17.540 --> 00:11:22.820
with the web is not actually JavaScript. The problem with the web that makes it so difficult

00:11:22.820 --> 00:11:28.900
to program is that there are so many layers of which JavaScript is just one. So if you take a typical

00:11:28.900 --> 00:11:33.220
web application, right, your data is going to start as rows in a database. You're going to transform

00:11:33.220 --> 00:11:38.420
those into objects, say Python objects in your server-side code. Then you're going to transform

00:11:38.420 --> 00:11:43.940
those into JSON on HTTP endpoints with get, post, put, delete, silly, simple set of verbs.

00:11:43.940 --> 00:11:48.020
And then you're going to transform those into JavaScript objects in the client. And then you're going to transform

00:11:48.020 --> 00:11:54.020
that into HTML DOM and you're going to transform that into pixels with CSS. All of those layers come with a

00:11:54.020 --> 00:11:58.900
big impedance mismatch and you grow all sorts of hairy frameworks, right?

00:11:58.900 --> 00:12:04.180
Orms to turn database rows into Python objects are the least of your problems, right? It's the

00:12:04.180 --> 00:12:09.300
JavaScript frameworks that are the biggest and hairiest of these translation layers. And so that's where

00:12:09.300 --> 00:12:14.420
people go, oh, JavaScript must be the problem. But if you just swap JavaScript out for Python,

00:12:14.420 --> 00:12:18.820
you haven't actually reduced the number of times you need to translate your data from

00:12:18.820 --> 00:12:23.380
one representation into another, and you haven't reduced the complexity of your application. And I

00:12:23.380 --> 00:12:28.020
think that's fundamentally what gives you that kind of proof of concept feeling about something like

00:12:28.020 --> 00:12:32.900
transcript. Because you build some code with transcript and you go, yay, I've written some Python and it

00:12:32.900 --> 00:12:39.700
runs in the web browser. But actually, to interact with the outside world, that Python has to do

00:12:40.820 --> 00:12:47.780
things every bit as unpleasant as what your JavaScript would have had to do. And so you haven't actually

00:12:47.780 --> 00:12:52.820
got yourself to the Pythonic nirvana that you were chasing. And obviously, on a large scale,

00:12:52.820 --> 00:12:57.140
this is what we're trying to solve with Anvil, because we're trying to give you an environment

00:12:57.140 --> 00:13:01.540
where you really can just write a Python function on the server and then just write some Python code on

00:13:01.540 --> 00:13:06.820
the client and just call that function and just make some text appear on the screen by manipulating

00:13:06.820 --> 00:13:12.180
a Python object. That's a very large full stack conception of it. But even in the small, I think

00:13:12.180 --> 00:13:19.940
Sculpt has this one right as well. Because Sculpt is widely used outside Anvil. It's used in educational

00:13:19.940 --> 00:13:26.900
environments. It's used in a game that you just showed us before this call. What was it, Code Combat?

00:13:26.900 --> 00:13:28.740
Code Combat at CodeCombat.com.

00:13:28.740 --> 00:13:32.580
Until we were prepping for this call, I didn't even know it used Sculpt. It's always great to find your code

00:13:32.580 --> 00:13:37.620
being used in strange places like that. But it's used a lot in educational contexts.

00:13:37.620 --> 00:13:42.420
If you're teaching someone, you can't afford to let them touch the JavaScript API because they will run

00:13:42.420 --> 00:13:45.700
away screaming. You've got to give them a Python experience if you're teaching them.

00:13:45.700 --> 00:13:50.500
And so those are the values with which Sculpt gets imbued from all directions.

00:13:50.500 --> 00:14:01.380
If you look at Sculpt, Sculpt treats the browser as a platform to run things on it. And CPython treats

00:14:01.380 --> 00:14:10.180
C and the operating system as a platform to run Python on. And from Sculpt, there's almost no way to touch

00:14:10.180 --> 00:14:15.860
the environment. It's up to the person writing the extensions in JavaScript.

00:14:15.860 --> 00:14:21.140
The integration layer, right? The person who says import Sculpt, import the Python, take the

00:14:21.140 --> 00:14:24.180
Python code and bang them together to create app.

00:14:24.180 --> 00:14:27.620
If you want to have something to happen in the browser, you will have to write some JavaScript

00:14:27.620 --> 00:14:31.940
code and you will have to write that in a way that you can call it from Sculpt. And you can't,

00:14:31.940 --> 00:14:39.780
there's no native stuff. We used to have eval in JS eval in Sculpt. I removed that a while ago because...

00:14:39.780 --> 00:14:42.820
Thank you! That's good.

00:14:42.820 --> 00:14:48.900
Well, it's actually a security risk because all these tools are running users' code and

00:14:48.900 --> 00:14:54.180
storing that in databases. And it's better that they don't execute JavaScript that they write

00:14:54.180 --> 00:14:59.140
themselves. That's probably true. It's generally true when it's straight JavaScript and if it's

00:14:59.140 --> 00:15:03.460
embedded within a Python app, it's probably also true. There's a side security rant I could go on all

00:15:03.460 --> 00:15:08.100
day about this. Part of this problem with having all these layers in the web stack is that what you get

00:15:08.100 --> 00:15:12.100
is programming languages with the source code for others programming languages embedded in them,

00:15:12.100 --> 00:15:18.500
right? What you typically ship a client is HTML with JavaScript embedded in it, which generates

00:15:18.500 --> 00:15:23.860
actually more HTML sometimes with JavaScript embedded in it. And CSS embedded in that HTML inside the

00:15:23.860 --> 00:15:30.900
JavaScript. And the JavaScript ecosystem is something where you could not remove the eval-like qualities

00:15:30.900 --> 00:15:36.500
of it because it's baked into the whole system from top to bottom. And again, Sculpt has that luxury

00:15:36.500 --> 00:15:42.020
because the browser is being treated like a runtime environment, not like something that should be

00:15:42.020 --> 00:15:43.380
protruding into your living space.

00:15:43.380 --> 00:15:50.180
This portion of Talk Python To Me is brought to you by Linode. Are you looking for hosting that's fast,

00:15:50.180 --> 00:15:54.900
simple, and incredibly affordable? Well, look past that bookstore and check out Linode at

00:15:54.900 --> 00:16:03.460
talkpython.fm/linode. That's L-I-N-O-D-E. Plans start at just $5 a month for a dedicated server with a gig of RAM.

00:16:03.460 --> 00:16:07.780
They have 10 data centers across the globe. So no matter where you are or where your users are,

00:16:07.780 --> 00:16:12.580
there's a data center for you. Whether you want to run a Python web app, host a private Git server,

00:16:12.580 --> 00:16:19.140
or just a file server, you'll get native SSDs on all the machines, a newly upgraded 200 gigabit network,

00:16:19.140 --> 00:16:24.660
24/7 friendly support, even on holidays, and a seven day money back guarantee. Need a little help with

00:16:24.660 --> 00:16:29.620
your infrastructure? They even offer professional services to help you with architecture, migrations,

00:16:29.620 --> 00:16:36.100
and more. Do you want a dedicated server for free for the next four months? Just visit talkpython.fm/linode.

00:16:36.100 --> 00:16:41.540
Now, before we get too far into this, I kind of want to do a survey of the other options. You've

00:16:41.540 --> 00:16:46.660
mentioned Transcript and we've talked about Sculpt and there's some other ones. And I also want to ask

00:16:46.660 --> 00:16:54.100
you the question, it probably is a slightly skewed audience here, does Python even belong in

00:16:55.140 --> 00:17:02.420
the front end. Did you see Russell Keith McGee's, either of you, his talk about black swans at the

00:17:02.420 --> 00:17:07.700
most recent PyCon 2019? We skimmed it very briefly before this recording, so not really.

00:17:07.700 --> 00:17:12.580
I'll summarize because, you know, a ton of the listeners also won't have heard it. So basically,

00:17:12.580 --> 00:17:19.620
he gave a talk, I think it was the opening keynote at PyCon 2019 in the US. And he said, look, Python is

00:17:19.620 --> 00:17:27.780
great. We love Python, but there are real challenges that could threaten its great rise and super popularity,

00:17:27.780 --> 00:17:34.260
which is wonderful for everybody involved in it. But what is the most popular type of computer these days?

00:17:34.260 --> 00:17:40.420
It's a phone and a tablet. Does Python run there? No. If I'm a new developer and I want to have,

00:17:40.420 --> 00:17:45.700
you know, some program I create and I want to share it with my friends, how do I package up a Python app

00:17:45.700 --> 00:17:51.380
and share it? Right? If the answer is you pretty much, you know, it's super hard or you can't, then

00:17:51.380 --> 00:17:56.020
maybe the choice is, well, I'll go write some other language. Right? And one of them that he said was,

00:17:56.020 --> 00:18:03.380
if I need to learn JavaScript anyway to write web applications and I could do it in Node, why would

00:18:03.380 --> 00:18:07.620
I bother learning Python if I'm just getting started anyway? Because I'm going to have to learn

00:18:07.620 --> 00:18:13.300
JavaScript. So let me just learn one and go from there. So he was making the case that the lack of

00:18:13.300 --> 00:18:20.580
Python in the browser, it could cause a serious sort of drain of the enthusiasm and newcomers to the

00:18:20.580 --> 00:18:24.500
whole language. So what do you guys think? Python belong in the front end? I mean, obviously,

00:18:24.500 --> 00:18:28.100
you're doing a lot of work to put it there. But where do you see this?

00:18:28.100 --> 00:18:32.580
I have a rant. So, Albert, if you want to jump in first, you have about five seconds.

00:18:32.580 --> 00:18:41.140
I, at the moment, can't advise a website to go right there front end in Python, unless you're

00:18:41.140 --> 00:18:47.540
using Anvil. Sculpt won't be your friend because it will make you work really hard to do that.

00:18:47.540 --> 00:18:52.260
Yeah. And this is more of a broader question, not is like today to answer, right?

00:18:52.260 --> 00:18:59.220
Does it belong there? Yeah. I think eventually we will find a way to properly put it there,

00:18:59.860 --> 00:19:03.300
but we aren't there yet. Okay. Meredith, you had something to say about this,

00:19:03.300 --> 00:19:08.180
you indicated. I'm afraid, and this is where I have to tread very carefully because I'm on a Python

00:19:08.180 --> 00:19:17.140
podcast, but I am not a Python partisan. We, I can hear the in-drawn breath, we picked up Python for

00:19:17.140 --> 00:19:25.220
Anvil because it is the language of education. It is the world's first programming language for people

00:19:25.220 --> 00:19:32.100
who are trying to teach new people to code because it is friendly, because it is easy to comprehend,

00:19:32.100 --> 00:19:39.620
because it is easy to pick up. And the web, which is our target platform, is the very opposite of that

00:19:39.620 --> 00:19:48.260
in so many ways. And we wanted to bring those virtues to the web. And as it happened, Python looked the

00:19:48.260 --> 00:19:54.100
likeliest tool for us to pick up and try to ram through that barrier. I am not wedded to Python

00:19:54.100 --> 00:19:59.300
being the choice of technology that produces this. It just seemed like the best shot for exactly what

00:19:59.300 --> 00:20:05.540
we were doing at the time. I don't think Python has any God-given right to rule the development world.

00:20:05.540 --> 00:20:13.460
I think it has to stand or fall on its own two feet and on its own merits. And I think we as a community

00:20:13.460 --> 00:20:21.620
should be chagrined at the idea that a Pythonic experience is not available for web development.

00:20:21.620 --> 00:20:28.740
That the values that Python is the torch bearer for in the programming language community aren't

00:20:28.740 --> 00:20:33.380
available on so many of these platforms that are the popular development platforms.

00:20:33.380 --> 00:20:38.900
Yeah. Python, the language itself is merely a delivery mechanism. And I don't want to get

00:20:38.900 --> 00:20:43.940
tribal about whether that is the way to deliver the web. As it happens, it's the loose solution we've

00:20:43.940 --> 00:20:48.660
chosen. But I don't think Python belongs on the web. I think Pythonic values belong on the web.

00:20:48.660 --> 00:20:54.420
Very interesting. And like you said, just choosing, just replacing the syntax of JavaScript with the

00:20:54.420 --> 00:21:01.380
syntax of Python might not necessarily make that difference, right? So let's also talk a little bit

00:21:01.380 --> 00:21:07.460
about the history because I think it'll be interesting. There's some newcomers and some

00:21:07.460 --> 00:21:14.820
projects that have been there a long time. So Sculpt has been around for a while, at least since 2011.

00:21:14.820 --> 00:21:21.700
What are some, we talked about Transcript. What are some of the others? Either of you take it.

00:21:21.700 --> 00:21:27.220
At this point, I have to plug a blog post written by my colleague, Sean Taylor Morgan, because he just gave

00:21:27.220 --> 00:21:33.940
a talk at PyCon UK walking through exactly the answer to your question. So hopefully that link's going to be

00:21:33.940 --> 00:21:35.220
appearing in the show notes. Okay.

00:21:35.220 --> 00:21:42.420
But the broad swing of these things is it's a thing people have tried. There are a bunch of different

00:21:42.420 --> 00:21:49.140
ones. I don't actually know the order of when they came up, but there is Sculpt, which we're talking about a lot.

00:21:49.140 --> 00:21:56.420
There is Transcript, which is a Python to JavaScript compiler that produces JavaScript code that looks

00:21:56.420 --> 00:22:01.540
very much like the Python code. So pretty concise, but at the cost of not exactly the right semantics.

00:22:01.540 --> 00:22:19.060
It's also because it's compiled to JavaScript. You don't run the Python. In Sculpt,

00:22:19.060 --> 00:22:25.460
you can use our very limited debugger to actually pause

00:22:25.460 --> 00:22:37.620
Python at a certain point and look at variables. And this debugger lives in the Python runtime on your

00:22:37.620 --> 00:22:45.540
browser. And with Transcript, it doesn't run. It runs the JavaScript and you write Python.

00:22:45.540 --> 00:22:50.180
Right, right. Yeah. So it seems like with Sculpt, looking at it, it basically creates a

00:22:50.180 --> 00:22:54.900
little runtime environment. It creates the modules variables and it

00:22:55.300 --> 00:23:01.140
little switch to run all the code and things like that. And it does seem like it's creating

00:23:01.140 --> 00:23:05.380
a little execution environment for your Python. And it just continues to run there. Yeah.

00:23:05.380 --> 00:23:10.500
Brighton is exactly the same. I don't want to say that. Transcript is, I think,

00:23:10.500 --> 00:23:16.500
is reasonably new and the guy's doing a great job. But he's making

00:23:19.300 --> 00:23:28.340
modern Python compilable to JavaScript. And Brighton is an older project, but does a similar job.

00:23:28.340 --> 00:23:32.500
Yeah, there's a big difference there, of course, in that Transcript is ahead of time compiled to

00:23:32.500 --> 00:23:37.700
JavaScript. Brighton is actually compiled in the browser. So Brighton is a project that lets you

00:23:37.700 --> 00:23:42.740
write script tags like you write in your HTML script tags, script type equals text, JavaScript. You can

00:23:42.740 --> 00:23:49.220
write script type equals text, Python and write Python code everywhere you'd run JavaScript. And then

00:23:49.220 --> 00:23:55.700
there is a library that you load into your browser and it will then search through your document and

00:23:55.700 --> 00:24:03.780
translate all of, translate the Python as the page loads. So it's, it's kind of this, it's a sort of

00:24:03.780 --> 00:24:09.380
middle ground. It's not dynamic, but you couldn't do like an interactive write some code, hit enter and

00:24:09.380 --> 00:24:19.060
run it thing with Brighton like you can with, with Sculpt. So I'd say like Brighton Transcript are both

00:24:19.060 --> 00:24:24.660
sort of aimed at like, I would just like to do a straight swap out of my JavaScript for my Python

00:24:24.660 --> 00:24:30.820
in this code. And Sculpt is actually in a different part of the design space next to projects like

00:24:31.620 --> 00:24:37.780
PyPy.js and Pyodide, where you take a Python runtime and put it into the browser.

00:24:37.780 --> 00:24:43.540
Okay, so there's PyPy.js. And I've covered that before on the show quite a while ago. My

00:24:43.540 --> 00:24:49.060
understanding it could be outdated was that project is not really active anymore. Is that accurate? Do you

00:24:49.060 --> 00:24:56.500
know? No, I actually worked on that. It isn't active anymore. Ryan from Mozilla started that and

00:24:57.220 --> 00:25:03.780
I investigated it quite heavily because this gives you the whole of Python. This gives you like a

00:25:03.780 --> 00:25:11.940
full reference implementation of Python in the browser. But compiling PyPy.js is something special.

00:25:11.940 --> 00:25:19.380
I've never tried it, but it's awesome. But it turns out it's like 12 to 15 megabytes of very,

00:25:19.380 --> 00:25:25.540
very, very dense ASM.js that outputs it. Yeah. Yeah, it takes a few seconds to put a browser to understand.

00:25:25.540 --> 00:25:33.300
So it's the PyPy, P-Y-P-Y comes from the PyPy project, which is the compiled version alternative to

00:25:33.300 --> 00:25:39.620
CPython, right? So it basically, as you said, the ASM.js bit is, well, let's take that C code and compile

00:25:39.620 --> 00:25:44.260
that to JavaScript and then just download it, which is pretty large.

00:25:44.260 --> 00:25:49.860
It's even more fun than that. So PyPy is a Python interpreter that's written in Python,

00:25:49.860 --> 00:25:54.020
which itself feels like a little bit of a contradiction. Because if you had a Python

00:25:54.020 --> 00:25:57.940
interpreter written in Python, wouldn't you need another interpreter to interpret it? And then you'd

00:25:57.940 --> 00:26:03.460
just be like double stacking. But what it's actually, how PyPy is actually done is that it's written in a

00:26:03.460 --> 00:26:10.980
subset of Python called RPython, which can be translated effectively to machine code. And so there is an

00:26:10.980 --> 00:26:14.580
RPython to native code compiler.

00:26:14.580 --> 00:26:18.580
It's actually RPython compiles to C and not to native.

00:26:18.580 --> 00:26:20.500
And then that compiles to native. Yeah.

00:26:20.500 --> 00:26:26.260
So, okay, C and then to thing. And then you stick the C code in through in script.

00:26:26.260 --> 00:26:34.340
But PyPyJS, you can actually run, you can actually compile the JIT compiler. So what you get is you

00:26:34.340 --> 00:26:42.260
write Python in your browser, and then PyPyJS interprets that. And it jits C code to the

00:26:42.260 --> 00:26:49.780
ASM C code jitter that jits that. And that jits to the JavaScript. And the JavaScript is also,

00:26:49.780 --> 00:26:51.940
of course, a JIT environment. Yeah.

00:26:51.940 --> 00:26:55.540
It's like this two stage rocket every time you press run.

00:26:55.540 --> 00:27:00.660
It's a magnificent engineering achievement, but it's like getting an elephant to fly. The most

00:27:00.660 --> 00:27:02.580
impressive thing is that you did it. Yeah.

00:27:02.580 --> 00:27:05.460
Yeah. No. And it's actually, it's faster than CPython.

00:27:05.460 --> 00:27:08.020
PyPy.js is faster than CPython.

00:27:08.020 --> 00:27:08.820
Yes.

00:27:08.820 --> 00:27:11.140
Oh, Lordy. Right. Okay. Yes.

00:27:11.140 --> 00:27:17.060
Well, that's because PyPyJS, if you've ever run PyPy on your machine compared to CPython,

00:27:17.060 --> 00:27:23.780
PyPy is massively faster. So it's so much faster that even compiled to JavaScript, it's a little

00:27:23.780 --> 00:27:29.380
bit faster than CPython. But the problem is that you never notice that performance is a performance

00:27:29.380 --> 00:27:36.100
gain with PyPyJS because it's a 15 megabyte JavaScript download. And then the browser takes

00:27:36.660 --> 00:27:44.980
a synchronous process to read all that JavaScript. That to me sounds like the weak point of PyPyJS is

00:27:44.980 --> 00:27:51.140
you've now given the browser this huge amount of source code to go jitting and processing in and of

00:27:51.140 --> 00:27:57.940
itself. My experience with PyPy has been like small stuff is fast, but I tried to get my websites to run

00:27:57.940 --> 00:28:02.020
under and it was actually slower. I don't know. There must've been something going on there. Anyway,

00:28:02.020 --> 00:28:05.140
that was a little bit older and that's in a hibernation. And then-

00:28:05.140 --> 00:28:10.100
Well, because Mozilla have moved on to Pyodide, which is a much more sensible implementation. The

00:28:10.100 --> 00:28:11.140
same thing for the modern web.

00:28:11.140 --> 00:28:14.260
Yeah. Well, tell us about Pyodide. I mean, I covered it actually not long ago,

00:28:14.260 --> 00:28:16.580
but not everyone's heard that episode.

00:28:16.580 --> 00:28:21.300
Right. Well, in which case I'm going to tread very carefully because I will be much less expert than your

00:28:21.300 --> 00:28:29.380
previous guest, but it's a full CPython implementation with a whole bunch of common data science native

00:28:30.100 --> 00:28:36.020
libraries that include native code like NumPy and Pandas all compiled to WebAssembly.

00:28:36.020 --> 00:28:41.940
So it's really impressive to use. It's like part of the iodide project, which is just kind of like a

00:28:41.940 --> 00:28:45.700
Jupyter notebook, except all executing your browser, not having to go back to a server.

00:28:46.180 --> 00:28:51.060
And again, if you load up the sample page and run a few lines of Python code,

00:28:51.060 --> 00:28:58.660
there will be this period of grunting and straining while your computer downloads this blob of WebAssembly

00:28:58.660 --> 00:29:04.660
that is the compiled CPython in WebAssembly with all these libraries attached.

00:29:05.140 --> 00:29:11.780
But once it then gets up and running, then you have this amazing data manipulation environment

00:29:11.780 --> 00:29:16.500
right in your browser and you can do things like using NumPy right in your browser. And that's the

00:29:16.500 --> 00:29:19.700
only Python in the browser technology that can pull that trick off.

00:29:19.700 --> 00:29:24.020
It is pretty impressive. And I definitely think in this use case, if you're going to bundle up the C code,

00:29:24.020 --> 00:29:29.860
bundling it to WebAssembly is a way better place to bundle it than to bundle it to JavaScript, which is

00:29:29.860 --> 00:29:33.380
then turned around and like, it's like shipping source versus shipping the app.

00:29:33.380 --> 00:29:35.860
You know, it's just so much easier to run it that way.

00:29:35.860 --> 00:29:41.220
But parsing WebAssembly is so much easier than parsing JavaScript.

00:29:41.220 --> 00:29:43.540
Right. It's meant for machines to read. Yeah.

00:29:43.540 --> 00:29:44.900
Not for humans. No.

00:29:44.900 --> 00:29:45.860
No.

00:29:45.860 --> 00:29:49.140
Even though some JavaScript gets pretty obfuscated, but still.

00:29:49.140 --> 00:29:53.460
It's not reading characters and parsing it as a abstract syntax tree probably.

00:29:53.460 --> 00:29:57.060
So yeah, this is an interesting project. I don't know where it's going to go.

00:29:57.060 --> 00:30:02.100
I think in order for this type of thing to work, probably there's two things that need to happen.

00:30:02.100 --> 00:30:09.940
One, we need really good CDN support so that you get the WebAssembly CPython once ever,

00:30:09.940 --> 00:30:14.100
and then it's just from cache or something like that.

00:30:14.100 --> 00:30:19.860
The other is a smaller CPython. Do you need to ship the whole standard library and all these things?

00:30:19.860 --> 00:30:23.860
Like, is there a way to have smaller Python that you can then embed?

00:30:23.860 --> 00:30:24.260
Right.

00:30:24.260 --> 00:30:30.900
Certainly, you're not going to run an e-commerce site off that WebAssembly Python interpreter. It's just got too much startup latency.

00:30:30.900 --> 00:30:32.100
Yeah, absolutely.

00:30:32.100 --> 00:30:39.940
The future of a CDN global Python interpreter that people can rely on being fast because everyone will have loaded it once.

00:30:39.940 --> 00:30:43.220
It's a very attractive future, but it's a long way away from now.

00:30:43.220 --> 00:30:51.140
The fact that Mozilla is making this stuff means that there are definitely people at Mozilla thinking about this very hard.

00:30:51.140 --> 00:30:57.220
So it's definitely, I don't think it's impossible, very likely even, that it will happen.

00:30:57.700 --> 00:31:00.580
Oh yeah, and we'll be sitting there waving pom-poms when it happens.

00:31:00.580 --> 00:31:15.140
Yeah, that would be cool. To be honest, like what I would rather see than a CDN is Mozilla ship the WebAssembly binary with Firefox and have Chrome ship the same thing, you know, Python 3.7 or 3.8 or whatever, and just update it.

00:31:15.140 --> 00:31:18.740
Browsers update frequently. Just update that on release.

00:31:18.740 --> 00:31:23.920
That would be awesome, but I think that they would have to, they're probably not going to pick winners like that.

00:31:23.920 --> 00:31:32.000
You know, we as a community would have to demonstrate that that would be grabbed with both hands before we can persuade a big browser platform like that to ship it.

00:31:32.000 --> 00:31:34.020
Of course, they did it with JavaScript, right?

00:31:34.020 --> 00:31:38.680
So, I mean, there was no other choice, but they do ship a JavaScript runtime in there.

00:31:38.680 --> 00:31:43.460
I think that's more than enough on the alternatives, and we'll probably hear from folks.

00:31:43.460 --> 00:31:51.060
They can put messages in the comments on the show page like, oh, did you hear about some name that I can't even imagine, a project that I didn't know about, right?

00:31:51.060 --> 00:31:52.300
So, check that out as well.

00:31:52.300 --> 00:32:02.580
I feel like we've done a pretty good job of covering Sculpt and its positioning in terms of its features and things like that and sort of compare and contrast.

00:32:02.580 --> 00:32:06.800
Maybe the next thing that we could talk about is how do I get started?

00:32:06.800 --> 00:32:08.040
So, I'm a web developer.

00:32:08.040 --> 00:32:11.700
I want to do something with Python.

00:32:12.340 --> 00:32:13.680
I'm going to choose Sculpt to do it.

00:32:13.680 --> 00:32:15.360
Maybe a couple of things.

00:32:15.360 --> 00:32:18.120
What are the use cases where that makes sense?

00:32:18.120 --> 00:32:20.040
And then what are the steps to get started?

00:32:20.040 --> 00:32:27.820
So, I'd say by far the most common use case is if you're building an application where you want your user to write Python.

00:32:27.820 --> 00:32:30.700
So, Anvil is an obvious example here.

00:32:30.700 --> 00:32:44.320
But there's also something called Trinket for whom Albert's done some work, which is a nice education-focused environment where you can, you know, bring up, write some Python code, you know, do a turtle, draw some graphics, and have that just run.

00:32:44.860 --> 00:32:50.360
So, for them, something like Sculpt was an easy choice because they could edit in the browser, just run it right there in the browser.

00:32:50.360 --> 00:32:52.680
Things like CodeCompat.

00:32:52.680 --> 00:32:52.980
Yeah.

00:32:52.980 --> 00:32:54.020
Trinket is really nice.

00:32:54.020 --> 00:33:01.860
You get here and it gives you like a wonderful little editor with autocomplete and it gives you a canvas or whatever.

00:33:01.860 --> 00:33:03.200
Oh, do they have autocomplete now?

00:33:03.200 --> 00:33:03.620
Hurrah!

00:33:03.820 --> 00:33:04.560
I'm pretty sure they did.

00:33:04.560 --> 00:33:06.200
Let me double-check that before I...

00:33:06.200 --> 00:33:07.160
No, no, they have.

00:33:07.160 --> 00:33:08.540
It's based on Jedi.

00:33:08.540 --> 00:33:09.480
Yeah, yeah, it's all there.

00:33:09.480 --> 00:33:10.340
It's super nice.

00:33:10.340 --> 00:33:14.300
It even goes object dot thing and it even autocompletes that.

00:33:14.300 --> 00:33:15.080
It's really nice.

00:33:15.080 --> 00:33:16.780
It's not just autocompleting the characters.

00:33:16.780 --> 00:33:21.720
If you want to see a proper autocomplete implementation with Sculpt, you do have to look at Anvil, though.

00:33:21.720 --> 00:33:23.640
Yes, of course.

00:33:23.640 --> 00:33:30.880
What Trinket does is they send your Python to the server and then let Jedi look at it.

00:33:31.140 --> 00:33:35.460
And Jedi gives you then the list of completions and then we set up.

00:33:35.460 --> 00:33:36.060
I see.

00:33:36.060 --> 00:33:38.380
So they remote out the autocomplete.

00:33:38.380 --> 00:33:38.740
Yes.

00:33:38.740 --> 00:33:39.320
Okay.

00:33:39.320 --> 00:33:44.940
And the problem with that is, of course, if you're doing high-velocity typing, you have the latency of you to the server to back.

00:33:44.940 --> 00:33:48.920
And that is going to seriously cramp your style if you're writing code in a hurry.

00:33:48.920 --> 00:33:52.220
So the Anvil autocompletor is actually built on top of Sculpt.

00:33:52.220 --> 00:33:55.500
We grabbed the Sculpt like parser and compiler.

00:33:55.500 --> 00:34:00.500
And so what we do is if you hit tab in Anvil, we replace your cursor with like a random symbol.

00:34:00.500 --> 00:34:08.020
And then we parse your module into an abstract syntax tree and then walk over it in JavaScript in the web browser.

00:34:08.020 --> 00:34:14.560
And then by the time we've walked down through several modules, you know, noticing all the variables that are in scope along the way,

00:34:14.560 --> 00:34:18.860
by the time we hit that magic symbol that represents your cursor, we know what's in scope.

00:34:18.920 --> 00:34:20.340
And then we know what we can offer for autocomplete.

00:34:20.340 --> 00:34:21.060
That's super cool.

00:34:21.060 --> 00:34:35.520
Having a compiler that is easy to start hacking around with and that exposes like primitives, like the abstract syntax tree and like the parser in the browser is a really great tool if you want to start messing around with compilers.

00:34:36.040 --> 00:34:43.480
Again, if you want to start building things, to go back to your original question, what would be the best use of Sculpt?

00:34:43.480 --> 00:34:49.480
Really, it's if you're developing something where you want someone to be writing Python as part of using the thing you're building.

00:34:49.480 --> 00:34:56.800
Yeah, so Anvil is a real good example because you're a development environment to run the result of that on your own custom cloud.

00:34:57.360 --> 00:35:03.040
Trinket is nice because Trinket is a pretty cool IDE, not IDE, editor in the browser.

00:35:03.040 --> 00:35:06.340
It's got some IDE features and sort of a visual output component.

00:35:06.340 --> 00:35:08.960
You had started to mention code combat as well, I think.

00:35:08.960 --> 00:35:13.580
Yeah, and again, that's, I mean, you only showed it to us shortly before this call.

00:35:13.580 --> 00:35:20.140
But this idea that, you know, you write some Python code and then it runs interactively as your characters do things.

00:35:20.140 --> 00:35:26.240
Again, Sculpt was a really good fit for that because writing code into this thing is how you use it.

00:35:26.340 --> 00:35:36.300
Yeah, exactly. The way you play the game is you fill out, it says you're in this dungeon, you need this character to navigate the maze and then build a fence to keep the creatures out or whatever.

00:35:36.300 --> 00:35:43.680
And so you write that out in code with little bits of autocomplete and it just runs that Python to see if you won the game or not or won the level.

00:35:43.680 --> 00:35:48.560
This portion of Talk Python To Me is brought to you by Tidelift.

00:35:48.560 --> 00:35:55.600
Tidelift is the first managed open source subscription, giving you commercial support and maintenance for the open source dependencies.

00:35:55.780 --> 00:35:57.860
You use to build your applications.

00:35:57.860 --> 00:36:06.620
And with Tidelift, you not only get more dependable software, but you pay the maintainers of the exact packages you're using, which means your software will keep getting better.

00:36:06.620 --> 00:36:13.860
The Tidelift subscription covers millions of open source projects across Python, JavaScript, Java, PHP, Ruby, .NET, and more.

00:36:13.860 --> 00:36:25.880
And the subscription includes security updates, licensing, verification, and indemnification, maintenance and code improvements, package selection and version guidance, roadmap input, and tooling and cloud integration.

00:36:26.080 --> 00:36:31.160
The bottom line is you get the capabilities you'd expect and require from commercial software.

00:36:31.160 --> 00:36:40.500
Yeah, so that's a good example.

00:36:40.500 --> 00:36:42.480
Yeah, so that's a good example.

00:36:42.480 --> 00:36:43.540
What else is out there?

00:36:43.540 --> 00:36:50.440
The uses of Sculpt prove pretty much that it is very much in this interactive sphere.

00:36:50.440 --> 00:36:58.800
My original project where I did the client-side validation is actually where we run Python in a much more sort of JavaScript-y way.

00:36:59.360 --> 00:37:05.180
But again, Sculpt is not meant for that because it just makes you work way too hard to get stuff done.

00:37:05.180 --> 00:37:05.560
Right.

00:37:05.560 --> 00:37:16.980
So it's probably not a great use case to say, I'm doing AngularJS and that's all great, but I actually want these functions instead written in Python because I just can't bear to do them in JavaScript.

00:37:16.980 --> 00:37:17.660
Yeah.

00:37:18.040 --> 00:37:20.500
Get yourself a transcript for that as quickly as possible.

00:37:20.500 --> 00:37:21.200
It will be great.

00:37:21.200 --> 00:37:22.120
Probably.

00:37:22.120 --> 00:37:22.920
Yeah.

00:37:22.920 --> 00:37:27.100
Anvil is much more used for things like Anvil and Trinket, Code Combat.

00:37:27.100 --> 00:37:29.660
There's a bunch of online courses.

00:37:29.660 --> 00:37:33.980
So there's a couple of MOOCs that use Anvil.

00:37:33.980 --> 00:37:42.400
Some of the other contributors are people who run university courses or build online courses and interactive textbooks with Anvil.

00:37:42.400 --> 00:37:43.060
Okay, cool.

00:37:43.060 --> 00:37:44.860
Yeah, we'll link to some of those in the show notes.

00:37:44.860 --> 00:37:47.920
Yeah, so I think, Meredith, you hit a really...

00:37:47.920 --> 00:37:56.740
It's really clearly on the head saying that the use case is if you need people to create Python as part of using your project.

00:37:56.740 --> 00:38:00.520
And every one of the examples that we've seen so far is one of those.

00:38:00.520 --> 00:38:06.720
Maybe somebody else has done something out there with it that you don't do that and it's not obvious because you're not typing Python.

00:38:06.720 --> 00:38:08.320
You're just running an app.

00:38:08.320 --> 00:38:10.040
I don't know, but who knows?

00:38:10.040 --> 00:38:13.460
So it sounds like the project is pretty good.

00:38:13.460 --> 00:38:19.440
And certainly of all these use cases, I would say Anvil is the most holistic.

00:38:19.440 --> 00:38:25.500
And that's the reason I called it out because you're building entire app ecosystems with this.

00:38:25.500 --> 00:38:30.980
Also, Code Combat is a pretty rich app where it's something kind of amazing.

00:38:30.980 --> 00:38:37.140
But maybe we could talk about the limitations of what people should be aware of in trying to use it.

00:38:37.140 --> 00:38:47.880
The biggest ones we've talked about already, which is that, you know, if you're going to be integrating it into a web application where the rest of it is built using HTML and JavaScript and frameworks and so on,

00:38:47.880 --> 00:38:52.060
you're going to be doing a lot of work to expose those into your Python runtime.

00:38:52.060 --> 00:38:58.500
So it's not good for like, you know, quick integratings of bits of Python into traditional development.

00:38:59.120 --> 00:39:05.780
Obviously, none of the packages that require C like NumPy, you're going to be able to do in Sculpt because it's in JavaScript.

00:39:05.780 --> 00:39:13.860
We get the occasional question on the issues like, oh, I tried to import C strings or C string IO.

00:39:13.860 --> 00:39:16.340
And I was like, yeah, it's not going to work.

00:39:16.340 --> 00:39:17.840
Sorry, that's not going to work.

00:39:17.840 --> 00:39:19.120
So I ported string IO.

00:39:19.120 --> 00:39:22.040
And I think I'm from the pure Python implementation.

00:39:22.040 --> 00:39:27.420
But and there's like so many stuff that Python is known for, right?

00:39:27.420 --> 00:39:32.680
Oh, I want to parse in CVS or I want to parse CSV or I want to do this thing.

00:39:32.680 --> 00:39:35.000
And it's like, no, sorry, that's all written in C.

00:39:35.000 --> 00:39:36.180
Not going to happen.

00:39:36.180 --> 00:39:41.720
So is it not going to happen because it's a lot of work and you guys can't get to it?

00:39:41.720 --> 00:39:44.640
Or is it not going to happen because it doesn't make sense to happen, right?

00:39:44.640 --> 00:39:54.340
So if someone's out there and they really want the CSV package module to be part of it, like could they drop in to source slash lib and add a .csv?

00:39:54.340 --> 00:39:54.900
Yeah, yeah.

00:39:54.900 --> 00:39:56.320
Or csv.py or whatever?

00:39:56.320 --> 00:39:58.180
Yeah, 100%.

00:39:58.180 --> 00:40:03.780
And a lot of the, this is so many times my answer on the issues.

00:40:03.780 --> 00:40:11.640
Like, you know, if you really need it, like I will help you and explain where stuff fits in and how you should write, you know, external modules.

00:40:11.640 --> 00:40:14.340
There's some help files around that as well.

00:40:14.860 --> 00:40:25.660
But it's just where for active developers, maybe five, there's just no time for us to spend on stuff like that.

00:40:25.660 --> 00:40:28.120
And there's also, I mean, depends on their motivation, right?

00:40:28.120 --> 00:40:34.200
If, you know, some of those developers are in education and they're not trying, they're not focusing on like the NumPy use case.

00:40:34.200 --> 00:40:38.580
And of course, with Anvil, our answer to that question is always, well, that's okay.

00:40:38.580 --> 00:40:40.760
The server side stuff is just a function call away.

00:40:40.900 --> 00:40:46.180
So go do your deep numerical processing on the server and make one function call and do it.

00:40:46.180 --> 00:40:48.800
So, yeah, there's not a lot of pressure.

00:40:48.800 --> 00:40:49.120
Yeah.

00:40:49.120 --> 00:40:52.520
When somebody desperately needs a thing, it tends to materialize.

00:40:52.520 --> 00:40:58.780
Way back in early in my contribution to Sculpt, Sculpt acquired a working Datetime module because we needed it.

00:40:58.780 --> 00:41:03.480
And so we pulled over the pure Python implementation from PyPy, actually.

00:41:03.480 --> 00:41:03.800
Yeah.

00:41:03.800 --> 00:41:04.980
I was thinking about PyPy.

00:41:05.080 --> 00:41:08.640
How much of the stuff could just be sort of brought over from that world?

00:41:08.640 --> 00:41:13.760
A remarkable amount, but quite often it turns out that it's using, so that was a thing for

00:41:13.760 --> 00:41:14.600
with Datetime.

00:41:14.600 --> 00:41:19.080
I ended up fixing up bits of the compiler because of the slightly, some of the slightly exotic

00:41:19.080 --> 00:41:21.380
things that PyPy's implementation of Datetime was using.

00:41:21.380 --> 00:41:21.760
Okay.

00:41:21.760 --> 00:41:25.860
Sculpt is the best example of this 80-20 rule.

00:41:26.860 --> 00:41:35.260
Due to sort of sheer number of people trying stuff, we've built this 20% that 80% of the

00:41:35.260 --> 00:41:35.880
people use.

00:41:35.880 --> 00:41:43.500
But as soon as you use anything from the standard labor, as soon as you let a seriously senior

00:41:43.500 --> 00:41:48.980
Python engineer touch Sculpt, like line three, they'll be like, hey, why doesn't this work?

00:41:48.980 --> 00:41:49.580
We're like, yes.

00:41:49.580 --> 00:41:51.900
Well, let me tell you about this.

00:41:52.700 --> 00:41:56.100
It's a very long story why it doesn't work.

00:41:56.100 --> 00:42:01.240
From personal experience, I'd said that the senior Python engineer problem has got noticeably

00:42:01.240 --> 00:42:06.600
better over the time that we've been involved with Sculpt, which is probably not coincidental,

00:42:06.600 --> 00:42:10.720
given that that's a demographic and will attract slightly more than Sculpt's other users.

00:42:10.720 --> 00:42:16.540
But yeah, you'll usually find in any, if you're porting any given thing from the standard library,

00:42:16.540 --> 00:42:19.560
you'll usually find some corner case in the compiler you need to fix up.

00:42:19.560 --> 00:42:21.940
But you know, for some of us, that's our idea of a fun weekend.

00:42:22.340 --> 00:42:22.980
That's right.

00:42:22.980 --> 00:42:24.420
Guess what case I added this weekend.

00:42:24.420 --> 00:42:26.580
No, that's pretty cool.

00:42:26.580 --> 00:42:33.240
So it does sound like if people really wanted to, there's a lot of organization and at least

00:42:33.240 --> 00:42:40.260
willing to accept people adding more Python standard library support if people wanted to write it.

00:42:40.260 --> 00:42:40.860
Oh, absolutely.

00:42:40.860 --> 00:42:41.780
Bring it on.

00:42:41.780 --> 00:42:44.080
More contributors are always welcome.

00:42:44.080 --> 00:42:44.620
Yeah, yeah.

00:42:44.620 --> 00:42:46.020
So you guys take PRs and all that, huh?

00:42:46.020 --> 00:42:46.660
Yes, indeed.

00:42:46.660 --> 00:42:50.100
You'll most likely find Albert or possibly me commenting on it.

00:42:50.100 --> 00:42:50.980
Yeah, super.

00:42:50.980 --> 00:42:51.340
Yeah.

00:42:51.340 --> 00:42:57.720
And I also operate on the thing that as long as it doesn't break the tests and add functionality,

00:42:57.720 --> 00:43:00.360
there's a high likely that I will merge it.

00:43:00.360 --> 00:43:04.040
Because a lot of times I'm of the opinion it's better in than out.

00:43:04.040 --> 00:43:07.080
And like if it's part of Sculpt, people will start using it.

00:43:07.080 --> 00:43:10.360
And if there are problems with it, we'll find them and fix them later on.

00:43:10.420 --> 00:43:10.600
Sure.

00:43:10.600 --> 00:43:12.640
So let me ask you a quick question about that.

00:43:12.640 --> 00:43:17.740
If I suppose I want to have the JSON module in there.

00:43:18.100 --> 00:43:28.940
And I think right now, the JSON module inside there says something to the effect of this empty module is here to throw an exception if you try to import JSON or something like that.

00:43:28.940 --> 00:43:29.560
Yeah.

00:43:29.560 --> 00:43:30.180
This empty package.

00:43:30.180 --> 00:43:30.380
Yeah.

00:43:30.460 --> 00:43:30.600
Yeah.

00:43:30.600 --> 00:43:31.280
That's what it does.

00:43:31.280 --> 00:43:33.940
And that's actually an improvement, right?

00:43:33.940 --> 00:43:39.880
Because now instead of just going, we don't know what JSON is when you try to import it, it goes, actually, JSON is not implemented, right?

00:43:39.880 --> 00:43:40.180
Yeah.

00:43:40.240 --> 00:43:43.900
Suppose I want to go and write that.

00:43:43.900 --> 00:43:47.280
Do I write Python code or do I write JavaScript code?

00:43:47.280 --> 00:43:49.200
Or do I write combinations thereof?

00:43:49.200 --> 00:43:51.800
Like what skill set do I need to make that happen?

00:43:51.800 --> 00:43:52.840
The choice is yours.

00:43:52.840 --> 00:44:03.200
You can add things to the Sculpt standard library either with a .py file or a .js file or with a .py file that imports a module from .js.

00:44:03.200 --> 00:44:07.000
Again, it's very much like Python with native C modules.

00:44:07.000 --> 00:44:08.160
It's the same principle.

00:44:08.700 --> 00:44:11.680
Obviously, writing it in .js is an awful lot more verbose.

00:44:11.680 --> 00:44:18.480
But if you were doing JSON, that would probably be the way forward because you could grab all of the built-in JSON support in the browser.

00:44:18.480 --> 00:44:20.960
The first two letters are about JavaScript.

00:44:20.960 --> 00:44:21.460
Yeah.

00:44:21.460 --> 00:44:22.820
In JSON, right?

00:44:22.820 --> 00:44:23.040
Yeah.

00:44:23.040 --> 00:44:24.300
So that would be the place to do it.

00:44:24.300 --> 00:44:24.560
Okay.

00:44:24.560 --> 00:44:25.260
Good to know, though.

00:44:25.260 --> 00:44:25.820
Go ahead, Albert.

00:44:25.820 --> 00:44:28.820
There is actually a JSON implementation for Sculpt.

00:44:28.820 --> 00:44:30.280
It's just not in the standard lib.

00:44:30.280 --> 00:44:30.800
Oh, okay.

00:44:30.800 --> 00:44:31.460
I see.

00:44:31.460 --> 00:44:33.400
There's somebody that did it.

00:44:33.400 --> 00:44:35.660
I have somebody at Trinket that has it.

00:44:35.660 --> 00:44:40.680
This is the eternal problem of open source tools and people that develop it.

00:44:40.680 --> 00:44:42.620
There's never enough time.

00:44:42.620 --> 00:44:47.140
This is probably several lists of things that I have to do for Sculpt.

00:44:47.140 --> 00:44:49.960
And this is definitely on one of those lists.

00:44:49.960 --> 00:44:53.400
But I never import JSON in Sculpt.

00:44:53.400 --> 00:44:53.660
Yeah.

00:44:53.760 --> 00:44:55.320
So I never run into this.

00:44:55.320 --> 00:44:57.140
I always forget to add it, but we should.

00:44:57.140 --> 00:44:58.560
Oh, please do.

00:44:58.560 --> 00:44:58.860
Yes.

00:44:58.860 --> 00:45:00.740
We have users who'd be made happy by that.

00:45:00.740 --> 00:45:01.080
Okay.

00:45:01.080 --> 00:45:02.660
I've made a note to bug you after this call.

00:45:02.660 --> 00:45:04.880
Give me that implementation.

00:45:04.880 --> 00:45:05.500
Correct.

00:45:05.500 --> 00:45:06.360
Yeah.

00:45:06.360 --> 00:45:06.740
Okay.

00:45:06.740 --> 00:45:08.360
It sounds really interesting.

00:45:08.360 --> 00:45:10.260
I do have one other question.

00:45:10.260 --> 00:45:11.260
I'll contribute really quick.

00:45:11.260 --> 00:45:18.280
How precisely 100% CPython compatible does something have to be before you're willing to accept it?

00:45:18.780 --> 00:45:25.720
Could it be some subset, like if I implemented JSON, but it only did some of the things that's in the standard library?

00:45:25.720 --> 00:45:26.820
Would that be okay?

00:45:26.820 --> 00:45:28.820
Or does it have to be all or nothing?

00:45:28.820 --> 00:45:29.100
Right?

00:45:29.100 --> 00:45:33.020
Like every possible use case of CPython has to be accepted?

00:45:33.020 --> 00:45:34.760
Or what are your thoughts around that?

00:45:34.760 --> 00:45:36.020
I'll have said it better in than out.

00:45:36.140 --> 00:45:48.280
Because if that thing is accepted with stubs for the things that don't work, then it's much more likely to get fixed up than if we stood on a molehill of purity and said, no, not unless it's complete.

00:45:48.280 --> 00:45:49.460
It's like, fine.

00:45:49.460 --> 00:45:50.300
I've got to go up my life.

00:45:50.300 --> 00:45:51.700
There is a caveat to that, though.

00:45:51.700 --> 00:45:59.020
If you're adding to the compiler, we will usually say this is not how it works in CPython.

00:45:59.620 --> 00:46:02.060
So we shouldn't introduce this.

00:46:02.060 --> 00:46:06.560
And this is because we have a few of those things in Sculpt.

00:46:06.560 --> 00:46:10.720
And maybe for Anvil, it's not such a big problem.

00:46:10.720 --> 00:46:13.620
But I know I think for Anvil, it is a big problem.

00:46:13.620 --> 00:46:14.220
Oh, yeah.

00:46:14.220 --> 00:46:20.460
If you have a user that uses it, you're maintaining this wrong implementation of CPython forever.

00:46:20.580 --> 00:46:20.900
Yeah, yeah.

00:46:20.900 --> 00:46:25.680
I was thinking more of like at the module level and not at the language compiler level, sure.

00:46:25.680 --> 00:46:28.400
At the grammar level, we are very strict.

00:46:28.400 --> 00:46:38.700
And we actually use the grammar definitions from the real CPython just imported in to drive the Sculpt parser.

00:46:38.700 --> 00:46:42.580
At the compiler level, work very hard to be a strict subset.

00:46:42.580 --> 00:46:45.440
And there may be some things we don't support.

00:46:45.440 --> 00:46:50.120
But like, for example, we're in the middle of our Python 3 move and we don't have async yet.

00:46:50.280 --> 00:46:52.720
You know, it will syntax error out if you try and do that.

00:46:52.720 --> 00:46:59.800
But everything we do support in the compiler is, to the best of our ability, a strict subset of CPython.

00:46:59.800 --> 00:47:00.200
All right.

00:47:00.200 --> 00:47:00.540
Perfect.

00:47:00.540 --> 00:47:00.780
Yeah.

00:47:00.780 --> 00:47:05.160
Let's maybe round this out with two quick topics on Sculpt here.

00:47:05.160 --> 00:47:11.480
So you started by talking about adding Python 3.7.3 support, which is great.

00:47:11.480 --> 00:47:13.580
That's one of the major new things.

00:47:13.580 --> 00:47:16.220
What are the other new things that are maybe worth highlighting real quick?

00:47:16.220 --> 00:47:20.160
One of the really interesting things about the Python 3 grammar migration,

00:47:20.160 --> 00:47:28.160
is that Sculpt does not have enough developer resources to fork ourselves into a Python 3 and Python 2 version.

00:47:28.160 --> 00:47:37.540
And thanks to projects like Anvil and Trinket and all the others, we have a ton of Python 2 code in production.

00:47:37.540 --> 00:47:38.160
Right?

00:47:38.160 --> 00:47:38.460
Right.

00:47:38.520 --> 00:47:43.100
Anvil's users have written a bunch of Python 2 code in the browser.

00:47:43.100 --> 00:47:46.360
They've written the only code they could at the time, and it was Python 2, right?

00:47:46.360 --> 00:47:51.100
And on the day we upgrade, they are quite reasonably going to wake up and expect their code to work as normal.

00:47:51.840 --> 00:48:03.740
And so one of the biggest challenges of this Python 3 migration was that we actually did it while keeping compatibility with the Python 2 stuff that we already supported.

00:48:04.520 --> 00:48:08.760
And we did this with bits of old grammar imported.

00:48:08.760 --> 00:48:14.180
So there is a mode where it will accept the print statement rather than just the print function and that kind of thing.

00:48:15.140 --> 00:48:21.920
And there's switches coming through the standard library for, you know, am I behaving like Python 2 or am I behaving like Python 3?

00:48:21.920 --> 00:48:39.020
And that's one of the things about this migration that I'm most proud of, because it allowed us to move to a place where we can start, you know, moving forwards and filling out the standard library and keeping up with the fact that it's 2019 without breaking all the code that's already in production.

00:48:39.140 --> 00:48:47.220
Yeah, that's super. And you've heard that from other projects as well, like NumPy dropping Python 2 support, Django dropping Python 2 support.

00:48:47.220 --> 00:48:52.960
It's like now we're free to work on going forward and not double implementing everything.

00:48:52.960 --> 00:49:02.780
Yeah, I guess we're still a generation behind that. We're at the point where we want to add Python. We need Python 3 compatibility, but we can't let go of our Python 2 users yet.

00:49:02.780 --> 00:49:03.580
Not yet, yeah.

00:49:03.580 --> 00:49:09.060
And the pain that they went through is what, you know, we will be maintaining parallel implementations of a bunch of the standard library.

00:49:09.060 --> 00:49:12.840
And, you know, a whole bunch of flags in the compiler for some time yet.

00:49:12.840 --> 00:49:27.600
And that is pain that was inevitable from the moment the Python 3 non-backwards compatible announcement was made, that every project that's supporting this is in some way, shape or form going to have to go through this caught between two stools moment.

00:49:27.600 --> 00:49:31.560
But speaking of so much better than the alternative.

00:49:31.560 --> 00:49:36.880
Yeah, absolutely. I mean, it's extra tricky for you because your platform runs their code.

00:49:36.880 --> 00:49:42.780
It's not like, well, you just leave Python 2 on your server and you just run your Python 2 stuff there.

00:49:42.780 --> 00:49:44.520
Nobody's going to touch your server.

00:49:44.520 --> 00:49:50.860
But with Anvil, someone's going to touch your server because it's your job to make it run and update it and things like that.

00:49:50.860 --> 00:49:53.220
Right. So this is challenging on your end.

00:49:53.440 --> 00:49:57.880
Certainly, we were the most vocal people going for this compatibility approach.

00:49:57.880 --> 00:49:59.560
But, I mean, people like Trinket, again, right?

00:49:59.560 --> 00:50:07.680
Definitely. For Trinket, it was not an option to have two sculpts and load two of them.

00:50:07.680 --> 00:50:10.660
Like one for new Trinket and one for old Trinkets.

00:50:10.660 --> 00:50:14.160
That was never an option.

00:50:14.160 --> 00:50:23.420
So from their perspective, it was like, if we're ever going to move to Python 3, it has to be in the same code base.

00:50:23.420 --> 00:50:25.700
And that's a consequence of the way the sculpt is built, right?

00:50:25.700 --> 00:50:32.040
Because the way you interact, you build the environment that your user's Python code can interact with,

00:50:32.040 --> 00:50:37.860
means that the JavaScript form support that makes that happen has to talk to sculpt.

00:50:37.860 --> 00:50:43.100
And it has to talk to pieces of sculpt APIs that will evolve as sculpt evolves.

00:50:43.100 --> 00:50:49.780
And so if you tried to interact with some sculpt two fork and sculpt three at the same time,

00:50:49.780 --> 00:50:51.900
you would rapidly lose your marbles.

00:50:51.900 --> 00:50:55.040
So, yeah, for all these projects that have, you know,

00:50:55.040 --> 00:50:59.300
yes, sure, there are commercial people expecting the code behind their products,

00:50:59.300 --> 00:51:01.940
shipping lots of money to still work tomorrow morning.

00:51:01.940 --> 00:51:04.800
But equally with Trinket, right, there are a whole bunch of teachers and kids

00:51:04.800 --> 00:51:06.980
expecting the thing that worked yesterday to work tomorrow.

00:51:06.980 --> 00:51:10.940
Right. And maybe even textbooks with printed stuff that is super hard to update.

00:51:10.940 --> 00:51:11.140
Yeah.

00:51:11.140 --> 00:51:14.220
That says, go here and type this into that website and it'll work.

00:51:14.220 --> 00:51:17.300
And it's our responsibility as platform maintainers to ease the passage.

00:51:17.300 --> 00:51:18.000
Yeah, for sure.

00:51:18.000 --> 00:51:19.700
All right. Final topic.

00:51:19.700 --> 00:51:24.080
And Meredith, you know, I've spoken about this and some of the stuff here is a little surprising to me

00:51:24.080 --> 00:51:25.780
or I didn't realize it or whatever.

00:51:25.780 --> 00:51:27.180
So I think it's interesting.

00:51:27.740 --> 00:51:29.660
But I'll give you the first word on this.

00:51:29.660 --> 00:51:34.320
It seems to me like a lot of the energy around some of the stuff we talked about.

00:51:34.320 --> 00:51:36.600
Pyodide is in the WebAssembly space.

00:51:36.600 --> 00:51:44.280
And certainly any of the ASM.js and Scriptum solutions should go down the WebAssembly direction.

00:51:44.280 --> 00:51:45.940
But what about Sculpt?

00:51:45.940 --> 00:51:49.060
Does it make sense to have a WebAssembly version of Sculpt?

00:51:49.060 --> 00:51:51.180
Is that something you all are thinking about?

00:51:51.180 --> 00:51:52.260
What's the story there?

00:51:52.260 --> 00:52:00.260
I don't think that we would write the compiler in WebAssembly or make a compiler that compiles a compiler in WebAssembly.

00:52:01.020 --> 00:52:09.240
So what might happen is that we might support, you know, libraries that are written in WebAssembly

00:52:09.240 --> 00:52:17.840
or some of like the big switch statement that Sculpt produces might be in WebAssembly.

00:52:17.840 --> 00:52:24.060
But the biggest problems there is that the interop between JavaScript and WebAssembly is,

00:52:24.060 --> 00:52:26.480
from what I understand, mostly via post message.

00:52:27.220 --> 00:52:29.540
So very, yeah, very slow, slow.

00:52:29.540 --> 00:52:33.320
Not in Sculpt world, nothing is slow quickly.

00:52:33.320 --> 00:52:37.300
So Sculpt is quite slow by itself.

00:52:37.300 --> 00:52:38.780
No, it's not the problem that it's slow.

00:52:38.780 --> 00:52:43.560
The problem is that Sculpt requires that switch statement to be pretty synchronous.

00:52:43.560 --> 00:52:49.720
And so waiting for a function call that would, you know, you would have to put that in suspensions.

00:52:50.220 --> 00:52:59.720
I don't see there's no obvious path for Sculpt to move to WebAssembly, although given enough time and it might happen,

00:52:59.720 --> 00:53:01.680
stuff might happen in that space.

00:53:01.680 --> 00:53:06.800
But I sooner see it as external libraries being written in WebAssembly.

00:53:06.800 --> 00:53:07.180
Okay.

00:53:07.180 --> 00:53:08.460
I think that's exactly right.

00:53:09.340 --> 00:53:16.300
For as long as you have to, like, use a knife and fork and oven gloves to communicate between WebAssembly and JavaScript,

00:53:16.300 --> 00:53:24.240
then it's going to not make a lot of sense for something like Sculpt to be in WebAssembly.

00:53:24.240 --> 00:53:27.060
But the idea of native libraries is very appealing.

00:53:27.920 --> 00:53:31.620
And there are, again, Mozilla taking the lead on a lot of this,

00:53:31.620 --> 00:53:38.580
there are a whole bunch of rumblings about improving the interop story between WebAssembly and JavaScript.

00:53:38.580 --> 00:53:43.580
And if that arrives further down the line, then it could start to make more sense for us.

00:53:43.580 --> 00:53:50.240
It would be an interesting development around the core hot loop of, you know, process each bytecode.

00:53:50.240 --> 00:53:54.460
And also, it might be a way to bring in the C libraries, right?

00:53:54.960 --> 00:53:58.880
You could ship that as a WebAssembly instead of a C implementation, for example.

00:53:58.880 --> 00:53:59.600
Yeah, exactly.

00:53:59.600 --> 00:54:00.020
Okay.

00:54:00.020 --> 00:54:00.560
Yeah.

00:54:00.560 --> 00:54:04.440
Honestly, it was surprising to me when we first spoke, right, what I was referring to,

00:54:04.440 --> 00:54:07.880
is that the interop was so limited between WebAssembly and JavaScript.

00:54:07.880 --> 00:54:10.560
I figure, like, it's probably just passing a pointer.

00:54:10.560 --> 00:54:11.600
It's all the same, right?

00:54:11.600 --> 00:54:14.440
Kind of like PyObject pointers or whatever, right?

00:54:14.440 --> 00:54:15.080
I guess not.

00:54:15.080 --> 00:54:19.580
I think the hype about, I think there's, the WebAssembly is clearly, right,

00:54:19.640 --> 00:54:26.700
that is the opening of the door to browser-side runtimes that are not shackled to the JavaScript

00:54:26.700 --> 00:54:29.960
way of doing things, by which I don't just mean JavaScript the language, but I mean that

00:54:29.960 --> 00:54:31.920
whole stack I was ranting about earlier.

00:54:31.920 --> 00:54:37.720
And there's a whole bunch of people who see the light behind that door and are getting very

00:54:37.720 --> 00:54:38.240
excited.

00:54:38.240 --> 00:54:40.260
But the door is not all the way open yet.

00:54:40.500 --> 00:54:45.960
There's still a lot you have to do and a lot you would have to do to deploy, really,

00:54:45.960 --> 00:54:53.480
any non-JavaScript-shaped thing into the browser in a way that's not like a native game engine.

00:54:53.480 --> 00:54:53.780
Sure.

00:54:53.780 --> 00:54:54.200
Right.

00:54:54.200 --> 00:54:57.480
Where it's entirely contained within WebAssembly, right?

00:54:57.480 --> 00:54:58.240
Something like that.

00:54:58.240 --> 00:55:00.940
Something like Anvil is, like, 90% interop, right?

00:55:00.940 --> 00:55:06.540
The reason you're writing that Python code in the browser is to drive visual elements on

00:55:06.540 --> 00:55:06.940
the browser.

00:55:06.940 --> 00:55:13.020
And so, actually, I would be unsurprised if, you know, even if we put in all that enormous

00:55:13.020 --> 00:55:17.240
amount of work in the current state of things, it wouldn't necessarily even improve performance.

00:55:17.240 --> 00:55:22.080
But that stuff is coming, and I think the world is moving in the right direction.

00:55:22.080 --> 00:55:23.020
We just have to hang on.

00:55:23.020 --> 00:55:23.720
Yeah, sounds good.

00:55:23.720 --> 00:55:24.000
All right.

00:55:24.000 --> 00:55:24.540
Well, thanks for that.

00:55:24.540 --> 00:55:25.520
Okay.

00:55:25.520 --> 00:55:30.240
I think we've probably used up all the time that we have to talk about Sculpt and this Python

00:55:30.240 --> 00:55:31.040
in the browser world.

00:55:32.180 --> 00:55:36.240
Well, let me ask you really quickly here, each of you, the two questions at the end of

00:55:36.240 --> 00:55:37.060
the show I always ask.

00:55:37.060 --> 00:55:38.700
Albert, we'll go with you first.

00:55:38.700 --> 00:55:41.600
If you're going to write some Python code, what editor do you use?

00:55:41.600 --> 00:55:42.140
PyCharm.

00:55:42.140 --> 00:55:42.620
PyCharm.

00:55:42.620 --> 00:55:42.960
Right on.

00:55:42.960 --> 00:55:47.460
These days, of course, a lot of the time I use Anvil's built-in editor, but PyCharm is

00:55:47.460 --> 00:55:49.000
still the gold standard, right?

00:55:49.000 --> 00:55:52.980
It's, you know, when I'm writing my autocomputer, it's their autocomputer I have my enemies eyes

00:55:52.980 --> 00:55:53.200
on.

00:55:53.200 --> 00:55:55.160
How does it work over here?

00:55:55.160 --> 00:55:55.780
Dang, that's nice.

00:55:55.780 --> 00:55:56.460
All right, let's do that.

00:55:56.460 --> 00:55:57.740
I agree.

00:55:57.740 --> 00:55:58.320
Cool.

00:55:58.320 --> 00:55:58.400
Cool.

00:55:58.400 --> 00:56:05.180
And then reverse order, notable PyPI package that maybe folks don't know about, but you've

00:56:05.180 --> 00:56:05.580
ran across.

00:56:05.580 --> 00:56:06.420
You're like, this is amazing.

00:56:06.420 --> 00:56:08.660
I should tell people about package X.

00:56:08.660 --> 00:56:09.040
Right?

00:56:09.040 --> 00:56:09.780
Postal.

00:56:09.780 --> 00:56:16.060
Like, just transforming user input into valid postal addresses for basically anywhere on

00:56:16.060 --> 00:56:16.440
Earth.

00:56:16.440 --> 00:56:22.920
It's one of those things that the task that will drive you wild, except you can just pip install

00:56:22.920 --> 00:56:25.860
it and then somebody has solved this whole scary problem for you.

00:56:25.860 --> 00:56:26.600
It's awesome.

00:56:26.600 --> 00:56:30.120
It downloads enormous quantities of data, but it's awesome.

00:56:30.120 --> 00:56:35.200
Python bindings for lib postal for fast international address parsing and normalization.

00:56:35.200 --> 00:56:36.100
Oh, it sounds great.

00:56:36.100 --> 00:56:36.560
Albert?

00:56:36.560 --> 00:56:42.500
I'm going to falter on this question, to be brutally honest, because I've not been a Python

00:56:42.500 --> 00:56:44.800
developer for as long as I've been a Sculpt developer.

00:56:44.800 --> 00:56:47.100
I kind of went the wrong way around.

00:56:47.100 --> 00:56:52.420
I started as a JavaScript developer and then learned Python because of Sculpt.

00:56:52.420 --> 00:56:55.440
Well, I think that's like kind of the reality of it, right?

00:56:55.540 --> 00:57:00.420
Like you think of the core developers as being super Python developers, and they are, but

00:57:00.420 --> 00:57:05.080
a lot of their day to day, I think, is to write C code, you know, to make Python go.

00:57:05.080 --> 00:57:08.320
And for you, it's you've got to write JavaScript to make Sculpt go, right?

00:57:08.320 --> 00:57:10.080
Well, my day job is actually in Python.

00:57:10.080 --> 00:57:13.540
I pip install and all this stuff, but I don't pick packages that often.

00:57:13.540 --> 00:57:17.320
So I don't have any interesting new packages to display.

00:57:17.420 --> 00:57:19.520
I'll throw one out for you that people might not know about.

00:57:19.520 --> 00:57:21.060
HTTPX.

00:57:21.060 --> 00:57:22.420
Have either of you heard of that one?

00:57:22.420 --> 00:57:22.800
Oh, well.

00:57:22.800 --> 00:57:25.300
So you may have heard of something called Request.

00:57:25.300 --> 00:57:25.980
You've heard of that, right?

00:57:25.980 --> 00:57:27.000
Uh-huh.

00:57:27.000 --> 00:57:28.020
Yeah, everyone has.

00:57:28.400 --> 00:57:37.680
So this is a 100% API compatible thing with Request, but it adds on HTTP2 support.

00:57:37.680 --> 00:57:40.260
It adds on async and await support.

00:57:40.260 --> 00:57:45.900
It has some cool intermediate like background parallel work for like doing a whole bunch of

00:57:45.900 --> 00:57:47.160
like requests and stuff.

00:57:47.340 --> 00:57:52.560
There's a bunch of sort of modern HTTP support on top of the Request API.

00:57:52.560 --> 00:57:53.440
Sweet.

00:57:53.440 --> 00:57:54.380
Yeah, it's pretty cool.

00:57:54.380 --> 00:57:55.360
That's a good one.

00:57:55.360 --> 00:57:56.760
I love the async and await stuff.

00:57:56.760 --> 00:58:00.880
I can't wait to add that to Sculpt.

00:58:00.880 --> 00:58:01.860
Yeah.

00:58:01.860 --> 00:58:02.620
That'll be super.

00:58:02.620 --> 00:58:03.040
Yeah.

00:58:03.040 --> 00:58:05.080
One of the wonderful things about opening that grammar thing.

00:58:05.080 --> 00:58:09.740
Now, all we need to do is just get that into the compiler and we have the technology.

00:58:09.740 --> 00:58:11.340
I am so excited for what happens next.

00:58:11.340 --> 00:58:12.060
That's super cool.

00:58:12.060 --> 00:58:15.300
And I think async and await pairs super well with JavaScript anyway.

00:58:15.720 --> 00:58:19.420
And I think it's even coming to the new version of JavaScript if it's not already here.

00:58:19.420 --> 00:58:20.400
Yeah, it is.

00:58:20.400 --> 00:58:20.980
Definitely.

00:58:20.980 --> 00:58:21.480
Sweet.

00:58:21.480 --> 00:58:21.820
All right.

00:58:21.820 --> 00:58:23.500
Thank you all for being here.

00:58:23.500 --> 00:58:26.060
I'm going to give you one more chance for a final call to action.

00:58:26.060 --> 00:58:27.360
People want to get involved with Sculpt.

00:58:27.360 --> 00:58:28.840
Either contribute to it, use it.

00:58:28.840 --> 00:58:30.100
What do you guys say?

00:58:30.100 --> 00:58:30.660
What should they do?

00:58:30.660 --> 00:58:31.660
Come find us on GitHub.

00:58:31.660 --> 00:58:32.680
Sculpt.

00:58:32.680 --> 00:58:34.500
S-K-U-L-P-T.

00:58:34.500 --> 00:58:35.000
All right.

00:58:35.000 --> 00:58:35.220
Super.

00:58:35.220 --> 00:58:35.800
Albert?

00:58:35.800 --> 00:58:37.760
Yeah, I don't have much to add to that.

00:58:37.760 --> 00:58:40.400
You know, try it on the website, sculpt.org.

00:58:40.400 --> 00:58:40.780
Super.

00:58:40.780 --> 00:58:41.240
All right.

00:58:41.240 --> 00:58:42.740
Well, thank you both for being here.

00:58:42.740 --> 00:58:43.440
It's great to chat with you.

00:58:43.440 --> 00:58:43.880
All right.

00:58:43.880 --> 00:58:44.500
Bye-bye.

00:58:44.500 --> 00:58:48.940
This has been another episode of Talk Python To Me.

00:58:48.940 --> 00:58:52.740
Our guests on this episode were Meredith Loof and Albert Jan Nyberg.

00:58:52.740 --> 00:58:55.320
And it's been brought to you by Linode and Tidelift.

00:58:55.320 --> 00:58:59.560
Linode is your go-to hosting for whatever you're building with Python.

00:58:59.560 --> 00:59:03.140
Get four months free at talkpython.fm/linode.

00:59:03.140 --> 00:59:05.000
That's L-I-N-O-D-E.

00:59:05.640 --> 00:59:10.680
If you run an open source project, Tidelift wants to help you get paid for keeping it going strong.

00:59:10.680 --> 00:59:16.300
Just visit talkpython.fm/Tidelift, search for your package, and get started today.

00:59:16.300 --> 00:59:18.520
Want to level up your Python?

00:59:18.520 --> 00:59:23.380
If you're just getting started, try my Python Jumpstart by Building 10 Apps course.

00:59:23.660 --> 00:59:31.520
Or if you're looking for something more advanced, check out our new async course that digs into all the different types of async programming you can do in Python.

00:59:31.520 --> 00:59:36.200
And of course, if you're interested in more than one of these, be sure to check out our Everything Bundle.

00:59:36.320 --> 00:59:38.080
It's like a subscription that never expires.

00:59:38.080 --> 00:59:40.220
Be sure to subscribe to the show.

00:59:40.220 --> 00:59:42.640
Open your favorite podcatcher and search for Python.

00:59:42.640 --> 00:59:43.860
We should be right at the top.

00:59:43.860 --> 00:59:52.860
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

00:59:52.860 --> 00:59:54.940
This is your host, Michael Kennedy.

00:59:54.940 --> 00:59:56.440
Thanks so much for listening.

00:59:56.440 --> 00:59:57.480
I really appreciate it.

00:59:57.480 --> 00:59:59.240
Now get out there and write some Python code.

00:59:59.240 --> 01:00:20.080
I'll see you next time.

