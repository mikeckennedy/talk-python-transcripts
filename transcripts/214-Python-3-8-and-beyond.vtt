WEBVTT

00:00:00.020 --> 00:00:05.040
Python 3 .8 is coming soon. It's scheduled for release at the end of October 2019, and you can

00:00:05.260 --> 00:00:10.260
already download test versions today. Given that Python ships on an 18 -month cycle, it's time to

00:00:10.260 --> 00:00:14.600
talk about what's coming for us Python developers in the fall. On this episode, I meet up with Lucas

00:00:14.900 --> 00:00:18.980
Lenga and Anthony Shaw to chat about the highlights of this upcoming version of Python.

00:00:19.580 --> 00:00:25.040
Also, quick show note, we recorded this on location in Cleveland at PyCon 2019. There may be a small

00:00:25.300 --> 00:00:29.080
amount of background noise, but I think you'll barely notice. This is Talk Python to Me,

00:00:29.320 --> 00:00:32.599
Episode 214, recorded May 5th, 2019.

00:00:46.460 --> 00:00:50.960
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the

00:00:51.100 --> 00:00:52.460
ecosystem, and the personalities.

00:00:53.140 --> 00:00:54.360
This is your host, Michael Kennedy.

00:00:54.840 --> 00:00:56.540
Follow me on Twitter, where I'm @mkennedy.

00:00:56.980 --> 00:01:01.600
Keep up with the show and listen to past episodes at talkpython .fm and follow the show on Twitter

00:01:01.750 --> 00:01:02.660
via at Talk Python.

00:01:03.400 --> 00:01:05.420
This episode is brought to you by Microsoft.

00:01:06.120 --> 00:01:08.040
Be sure to check out what they're offering during their segments.

00:01:08.500 --> 00:01:09.600
It really helps support the show.

00:01:10.480 --> 00:01:13.120
Lucas, Anthony, welcome back to Talk Python, both of you guys.

00:01:13.460 --> 00:01:13.540
Hello.

00:01:13.940 --> 00:01:14.400
Hi, Michael.

00:01:14.550 --> 00:01:15.000
Good to be back.

00:01:15.160 --> 00:01:16.320
Yeah, it's great to have you back.

00:01:16.610 --> 00:01:22.040
We are not recording over Skype far distances, but in fact, we're right here at PyCon.

00:01:22.400 --> 00:01:26.259
And who knows how the audio for this is going to come out, but hopefully it'll sound good

00:01:26.280 --> 00:01:29.960
enough, but it's great to be here on site in Cleveland with both of you. It's a

00:01:29.960 --> 00:01:30.120
unique

00:01:30.420 --> 00:01:32.400
experience to actually see you doing the recording.

00:01:32.600 --> 00:01:33.960
Yeah, it's really good to be here in Cleveland.

00:01:34.620 --> 00:01:37.800
The sun has finally come out today after the third day of PyCon.

00:01:38.180 --> 00:01:42.380
The fog was pretty incredibly epic and that was pretty special. And yeah, Lucas,

00:01:42.940 --> 00:01:46.460
the latency on this video call is incredible, man. It's so, it's lifelike.

00:01:46.640 --> 00:01:49.600
Yeah. So this video call is like 3D. It's amazing.

00:01:49.860 --> 00:01:54.460
Yeah, it's amazing. So thank you both for being here. We're going to talk about Python 3 .8 and

00:01:54.480 --> 00:01:57.920
maybe looking a little bit beyond that, some of the peps that are out there and all the cool stuff

00:01:58.060 --> 00:02:02.300
there. But, you know, let's just start with PyCon. Like, how's your experience this year? It felt a

00:02:02.330 --> 00:02:04.040
little different to me. I'll say why in a minute,

00:02:04.160 --> 00:02:07.740
but you go first. I'm Kashlanga. I've been co -chairing

00:02:07.920 --> 00:02:12.460
the Language Summit this year with Mariata, and this is an absolutely new experience for me. So

00:02:12.620 --> 00:02:16.900
that was interesting, actually herding all the cats at the right time to the right spots,

00:02:17.270 --> 00:02:22.700
you know, pre -selecting talks, actually making sure that everybody has the opportunity to speak,

00:02:22.980 --> 00:02:24.660
making sure that everybody is engaged.

00:02:25.120 --> 00:02:25.640
That was new.

00:02:25.700 --> 00:02:29.240
So I was very happy to have it over with after that day.

00:02:30.480 --> 00:02:31.600
I've heard it went pretty well.

00:02:31.820 --> 00:02:32.900
So I was happy about this.

00:02:33.220 --> 00:02:36.880
The rest of PyCon was also rather intense so far for me.

00:02:37.340 --> 00:02:40.780
I've had a talk about Black and then an extended Q &A

00:02:40.800 --> 00:02:43.040
that I just performed during the poster

00:02:43.040 --> 00:02:44.360
session on Sunday morning.

00:02:44.620 --> 00:02:45.140
That's really awesome.

00:02:45.340 --> 00:02:48.500
I feel like Black is one of these things that has just taken off.

00:02:49.140 --> 00:02:52.780
I often ask people what module they recommend or package.

00:02:52.960 --> 00:02:54.940
or what is like special that they've seen.

00:02:55.490 --> 00:02:58.340
And it's way more than any other single answer is black.

00:02:58.820 --> 00:02:59.140
That's awesome.

00:02:59.410 --> 00:02:59.520
Congratulations.

00:02:59.980 --> 00:03:00.520
Yeah, thank you.

00:03:01.020 --> 00:03:01.780
I'm very happy about it.

00:03:01.790 --> 00:03:04.360
In fact, I think there was at least five talks

00:03:04.580 --> 00:03:05.880
that mentioned, you know,

00:03:06.090 --> 00:03:07.900
using black as a good thing in them.

00:03:08.040 --> 00:03:09.660
So it seems like, you know,

00:03:10.380 --> 00:03:11.840
we've solved an issue that people had.

00:03:12.080 --> 00:03:13.360
We've solved a problem that people had.

00:03:13.400 --> 00:03:14.500
Yeah, we've had these linters

00:03:14.780 --> 00:03:16.600
and they've tell us what you're doing wrong.

00:03:16.900 --> 00:03:18.880
And we're just like, can't you just fix it?

00:03:18.960 --> 00:03:20.180
Like, I don't want to be told what's wrong.

00:03:20.210 --> 00:03:21.060
I just want it to be better.

00:03:21.320 --> 00:03:22.100
Yeah, well, the difference

00:03:22.120 --> 00:03:24.220
between Black and other autoformatters,

00:03:24.950 --> 00:03:27.300
of which we have a few in the Python community,

00:03:27.350 --> 00:03:30.240
is that Black was kind of brave,

00:03:30.620 --> 00:03:31.660
obnoxious enough to tell you

00:03:31.930 --> 00:03:34.500
that it's going to just be done in one way.

00:03:34.620 --> 00:03:35.780
It's not really configurable.

00:03:36.300 --> 00:03:38.520
But that kind of changes it to a workflow tool

00:03:38.700 --> 00:03:40.260
where if you decide to use the tool,

00:03:40.360 --> 00:03:43.580
now the question of autoformatting sort of disappears.

00:03:43.710 --> 00:03:45.160
The question of how to format your code

00:03:45.170 --> 00:03:46.740
is no longer a problem

00:03:47.210 --> 00:03:49.560
when you're developing your own projects.

00:03:49.800 --> 00:03:50.960
Yeah, and if you're on a team,

00:03:51.080 --> 00:03:53.960
you don't have to have this debate anymore of how we do stuff, right?

00:03:53.960 --> 00:03:55.300
You just run black and that's how you do it.

00:03:55.380 --> 00:03:55.620
Absolutely.

00:03:55.920 --> 00:03:56.100
Awesome.

00:03:56.340 --> 00:03:56.420
Okay.

00:03:56.880 --> 00:03:57.820
Anthony, how's your PyCon going?

00:03:58.040 --> 00:03:59.640
Like, what do you notice this year that's special?

00:03:59.940 --> 00:04:02.880
Yeah, this is the first PyCon I've actually given a talk.

00:04:03.020 --> 00:04:04.700
So that was definitely a milestone for me.

00:04:04.860 --> 00:04:05.600
Yeah, what was the talk?

00:04:05.680 --> 00:04:06.740
It was on code complexity.

00:04:07.060 --> 00:04:10.020
And I talked about Wiley, which is a project I've been working on.

00:04:10.620 --> 00:04:13.860
And then the principles of code complexity and why complexity is bad.

00:04:13.980 --> 00:04:16.120
So how awesome cyclomatic complexity is?

00:04:16.280 --> 00:04:17.660
I actually talk about how it's inevitable,

00:04:18.040 --> 00:04:20.739
the more users you have to have more cyclomatic complexity.

00:04:21.459 --> 00:04:27.080
people ask me how the talk went and my response so far has been i don't remember because i was so

00:04:27.220 --> 00:04:32.820
nervous that it was just a sort of adrenaline fueled dream so that was um yeah really cool and

00:04:32.880 --> 00:04:39.040
then yesterday there was mentored sprints that's new right which is a new thing this year and that's

00:04:39.140 --> 00:04:44.260
probably the highlight actually for pycon so far is actually just being in there and mentoring people

00:04:44.840 --> 00:04:49.560
and to contribute to the different projects and working with someone who ended up being able to

00:04:49.580 --> 00:04:52.700
send a pull request through to CPython by the end of the day.

00:04:53.110 --> 00:04:55.660
And I think it was their first one, which is awesome.

00:04:55.900 --> 00:04:56.720
Yeah, that's super cool.

00:04:56.820 --> 00:05:00.080
That's got to help adoption and contributions,

00:05:00.350 --> 00:05:00.460
right?

00:05:00.600 --> 00:05:04.040
Because even me personally, I think about, okay, well, I'd love to do something,

00:05:04.240 --> 00:05:08.100
but I really don't even know how to get started, how to build it,

00:05:08.220 --> 00:05:10.900
what the right rules or expectations are.

00:05:10.970 --> 00:05:12.000
Like, it's a lot of work.

00:05:12.060 --> 00:05:15.000
And if somebody can sit down who's done that or is at least knowledgeable about that

00:05:15.000 --> 00:05:19.540
and walks you through it, like the second time onward is much more likely

00:05:19.560 --> 00:05:20.480
to be smooth yeah

00:05:20.480 --> 00:05:23.780
and it was a proper amount of time allocated as well it was i think it's just

00:05:23.860 --> 00:05:29.380
over four hours on the second day in the afternoon so it's good enough time to actually sit and work

00:05:29.460 --> 00:05:34.540
on a proper a proper issue um or a proper feature and actually work through it from start to finish

00:05:34.800 --> 00:05:39.320
yeah you actually got a pr in place not just started or whatever yeah exactly so yeah that's

00:05:39.380 --> 00:05:39.500
awesome

00:05:39.500 --> 00:05:40.640
to

00:05:40.640 --> 00:05:45.140
me it felt like when i walked into the expo hall that the booths were a little bit bigger

00:05:45.640 --> 00:05:48.180
there were a little bit more people. It just seemed like a little bit,

00:05:49.160 --> 00:05:52.000
I don't know, there are a little more people, a little more energy, even than last year. And last

00:05:52.030 --> 00:05:53.700
year was amazing. I don't know. Did you have this feeling?

00:05:53.900 --> 00:05:55.400
Yeah, I was particularly impressed with

00:05:55.650 --> 00:05:59.580
the portrait of Guido at the Capital One booth,

00:05:59.740 --> 00:06:01.560
which you've got to see online if you haven't

00:06:01.590 --> 00:06:05.280
seen a picture of it already. Yeah, their booth was really artistic. It was pretty cool. Nice.

00:06:05.880 --> 00:06:12.800
All right. So it's great to be here at PyCon, but let's talk about the future. Let's start with the

00:06:12.820 --> 00:06:18.260
idea of when is Python 3 .8 going to be out? How precisely didn't we know that? And Lucas,

00:06:18.460 --> 00:06:23.540
maybe just say a little bit about like, you're mostly in control of this at the moment, right?

00:06:23.660 --> 00:06:25.740
Like the release schedule and management and whatnot, right?

00:06:25.980 --> 00:06:30.000
Currently, I'm serving as the release manager of Python 3 .8. And

00:06:30.000 --> 00:06:31.940
I wrote the schedule for where

00:06:32.080 --> 00:06:36.620
things are going to go. Traditionally, Python has been released every 18 months, which puts Python

00:06:36.750 --> 00:06:42.080
3 .8 at the end of this year. Like, you know, and in particular, like, you know, give or take,

00:06:42.140 --> 00:06:47.060
it should be the end of October. The reason why I'm not saying a particular date, even though it

00:06:47.160 --> 00:06:53.260
is in the PEP, is that those things tend to be a bit fluid. Like in the past three alphas that I

00:06:53.380 --> 00:06:58.160
released, like we've been a day early or a day late pretty much every time. Yeah, would you

00:06:58.160 --> 00:06:58.260
be

00:06:58.380 --> 00:07:00.100
willing to like hold up a release

00:07:00.100 --> 00:07:03.360
if there's some important feature that's two days away? In fact,

00:07:03.500 --> 00:07:10.680
like this time, there was a small issue, well, but small in size, but big in significance that

00:07:10.700 --> 00:07:18.540
I held up Alpha 4 that I had a bit of time for early in the week, which kind of makes me late for my own schedule now.

00:07:18.620 --> 00:07:22.200
And I have to release Alpha 4 tomorrow at the start of sprints.

00:07:22.480 --> 00:07:26.120
But those things are more important to get right than to get on time.

00:07:26.400 --> 00:07:27.880
And this is something.

00:07:28.040 --> 00:07:29.480
Yeah, especially when it's 18 months.

00:07:29.560 --> 00:07:29.940
If you were

00:07:29.940 --> 00:07:32.700
shipping monthly updates, like whatever, just ship what you got, right?

00:07:32.700 --> 00:07:37.300
But if it's 18 months, that couple of days, that means a big, big deal, right?

00:07:37.380 --> 00:07:38.180
This is exactly

00:07:38.180 --> 00:07:38.580
the point.

00:07:38.700 --> 00:07:52.160
We try to make the consecutive releases, even on the alpha level, consecutively better and not introduce a breakage that is going to be later reverted since every release, including alphas, is being tested by our users.

00:07:52.310 --> 00:07:59.580
And we're happy to see actually alpha releases being increasingly used by the community to test their own libraries and applications.

00:08:00.010 --> 00:08:04.460
That used to be our problem, that it was only after the beta releases.

00:08:04.780 --> 00:08:08.520
And in fact, RCs very often were the first releases that users would see.

00:08:09.060 --> 00:08:16.920
Nowadays, with like PyPI working better, with CI options being out there for pretty much everybody,

00:08:17.600 --> 00:08:19.980
we see more adoption of alpha releases, which is great.

00:08:20.160 --> 00:08:26.960
But that is also a bigger responsibility on the alpha releases because you are no longer free to just make a breaking change and then later revert it.

00:08:27.000 --> 00:08:27.980
Well, it's alpha anyway.

00:08:28.250 --> 00:08:29.060
Well, no, it isn't.

00:08:29.340 --> 00:08:29.960
Didn't you see what it

00:08:29.960 --> 00:08:30.080
was?

00:08:30.210 --> 00:08:30.780
It said alpha.

00:08:30.800 --> 00:08:31.460
Yes, now

00:08:31.460 --> 00:08:37.900
we would need to have feature toggles that look at the alpha version to see whether a particular bug exists or not.

00:08:37.960 --> 00:08:38.940
And we don't want that.

00:08:39.039 --> 00:08:46.420
This might be a slightly political question, but have the releases of Python recently become more stable?

00:08:47.280 --> 00:08:58.060
It feels to me that people have almost zero trepidation or worry about just adopting 3 .7 when they had 3 .6 or 3 .6 when they had 3 .5 these days.

00:08:58.240 --> 00:09:03.180
And it seemed like there was more concern about what's going to break when I go to the next, you know, semi -major version.

00:09:03.500 --> 00:09:05.000
Has that changed or is that like perception?

00:09:05.380 --> 00:09:09.140
For a number of years, the only version that people used was 2 .7.

00:09:09.580 --> 00:09:10.980
And that was for a long time.

00:09:11.340 --> 00:09:21.100
So it created this false perception that like Python is infallible, that every particular update of it like never introduces issues that were not there before.

00:09:21.320 --> 00:09:21.580
Because

00:09:21.580 --> 00:09:22.660
they were just minor fixes.

00:09:22.920 --> 00:09:23.100
Exactly.

00:09:24.430 --> 00:09:25.100
That was good.

00:09:25.860 --> 00:09:27.940
You know, at the same time, a blessing and a curse.

00:09:28.160 --> 00:09:31.560
since every particular version of Python,

00:09:31.860 --> 00:09:34.480
like including Python 2 .4 to Python 2 .5,

00:09:34.660 --> 00:09:36.380
Python 2 .5 to Python 2 .6,

00:09:36.920 --> 00:09:38.920
did introduce internal changes

00:09:39.400 --> 00:09:43.900
that made large projects actually complex to migrate.

00:09:44.280 --> 00:09:46.420
The biggest example from the Python 2 world

00:09:46.580 --> 00:09:49.860
where it was when Python 2 .5 was released.

00:09:50.440 --> 00:09:53.980
Zope at the time created such a problem for itself

00:09:54.300 --> 00:09:55.859
that it took them enough time

00:09:56.000 --> 00:09:59.200
that they migrated to Python 2 .6 directly.

00:09:59.580 --> 00:10:02.960
So the previous version worked on Python 2 .4,

00:10:03.430 --> 00:10:05.900
whereas the next one directly on Python 2 .6,

00:10:06.080 --> 00:10:06.920
they did not migrate in time for 2 .5.

00:10:06.920 --> 00:10:07.980
Right, it took so long to migrate.

00:10:08.030 --> 00:10:08.180
They're

00:10:08.180 --> 00:10:09.620
like, let's just aim for the next one,

00:10:09.720 --> 00:10:09.800
huh?

00:10:09.920 --> 00:10:13.040
So this is all just like a long, long introduction

00:10:13.240 --> 00:10:15.680
to just let you know that in Python 3,

00:10:16.000 --> 00:10:17.060
there are also changes.

00:10:18.140 --> 00:10:19.940
Many of those changes are deliberate, right?

00:10:20.120 --> 00:10:23.000
We are changing how the internal memory representation

00:10:23.280 --> 00:10:24.720
of objects looks like.

00:10:24.740 --> 00:10:27.900
We are introducing and removing bytecodes.

00:10:28.340 --> 00:10:31.420
We can change how modules get initialized.

00:10:31.920 --> 00:10:35.680
You know, there's multiple things that might break real applications,

00:10:36.540 --> 00:10:40.160
but breaking them in ways where it is impossible for us

00:10:40.360 --> 00:10:43.080
to guarantee eternal compatibility with those

00:10:43.080 --> 00:10:43.340
things.

00:10:43.580 --> 00:10:47.140
Sure, but this greater adoption of alpha versions and testing and CI

00:10:47.540 --> 00:10:48.340
probably doesn't hurt, right?

00:10:48.500 --> 00:10:50.260
Some kind of crashers, right?

00:10:50.680 --> 00:10:51.240
Downright

00:10:51.240 --> 00:10:52.380
bugs and whatnot.

00:10:52.780 --> 00:10:56.320
That I feel like we are doing a better job these days with.

00:10:57.090 --> 00:11:04.460
Also just because Python 3 finally gets enough adoption that those versions get vetted much better.

00:11:04.660 --> 00:11:05.100
Right, absolutely.

00:11:05.440 --> 00:11:08.960
When I started contributing, we were just working on Python 3 .2.

00:11:09.270 --> 00:11:15.040
So for a number of years, almost none of the things I worked on were actually very heavily used in the industry.

00:11:15.760 --> 00:11:17.440
Nowadays, the situation is different.

00:11:18.000 --> 00:11:27.020
So fortunately, the time between a change and actually having real users report on it is way shorter, which makes the QLT just better.

00:11:27.140 --> 00:11:27.720
Yeah, that's awesome.

00:11:28.340 --> 00:11:30.000
Anthony, let me ask you what your

00:11:30.000 --> 00:11:31.120
perception of that's like.

00:11:31.180 --> 00:11:35.120
You work for a pretty major company that probably has stability in mind and stuff.

00:11:35.700 --> 00:11:39.160
What's your perspective and what are you seeing at Dimension Data and places like that?

00:11:39.340 --> 00:11:43.660
It's definitely become easier for people to install newer versions of Python, which is really helping.

00:11:44.340 --> 00:11:49.480
So in terms of, I guess, moving towards things running as microservices on Docker, for example,

00:11:50.220 --> 00:11:55.040
there's this, it's not a single system running a specific version that's got to support all

00:11:55.040 --> 00:11:55.820
these different applications.

00:11:55.970 --> 00:11:58.160
Right, it's not cross your fingers or upgrading the server.

00:11:58.460 --> 00:12:00.020
Yeah, we're not running on the mainframe anymore.

00:12:00.310 --> 00:12:05.900
So I think that that's really helping in terms of there's more automation for systems deployment

00:12:06.540 --> 00:12:11.360
and there's a lot more tooling being used to automate like the building of new environments.

00:12:12.020 --> 00:12:16.820
there's this kind of idea of immutable infrastructure now where you basically create

00:12:17.280 --> 00:12:20.400
infrastructure in the cloud and you build it on a specific version.

00:12:20.660 --> 00:12:22.080
You don't change it, right, ever.

00:12:22.320 --> 00:12:22.580
Yeah.

00:12:22.710 --> 00:12:28.380
So I think that has actually made it easier to move to newer versions because you can

00:12:28.440 --> 00:12:33.240
just spin up new infrastructure with the new version, test how it works, and you can inspect

00:12:33.270 --> 00:12:33.700
it properly.

00:12:34.370 --> 00:12:38.179
Whereas like 10 years ago, you're talking about we need to go and buy a million dollars

00:12:38.200 --> 00:12:43.340
of hardware to build an identical environment to see if this new version is going to work for us.

00:12:43.500 --> 00:12:43.900
Right. And maybe

00:12:43.900 --> 00:12:47.880
you have like downtime the whole weekend, the team stays all night and they do the

00:12:48.020 --> 00:12:53.060
testing and the rollout. And, you know, these days when I go to websites and I see we're down for

00:12:53.280 --> 00:12:57.540
maintenance or we have even like we have scheduled maintenance over this like two to four hour window.

00:12:57.560 --> 00:13:08.160
I'm just like, what are they doing? Like what possibly could take four hours to upgrade? Like

00:13:08.180 --> 00:13:11.800
four hours, it doesn't take anyway. It just seems pretty wild when you see it. But that used to be

00:13:11.930 --> 00:13:14.360
common, right? So I guess, yeah. So it doesn't matter as much.

00:13:14.560 --> 00:13:15.760
Yeah, it still matters for some

00:13:16.240 --> 00:13:20.300
really big applications. I know some of the biggest software vendors still have four -hour

00:13:20.850 --> 00:13:24.640
maintenance windows every Saturday. We definitely have to live through some of that pain at the

00:13:24.770 --> 00:13:29.780
moment. But more and more, I think people are using this sort of automated deployment and

00:13:29.940 --> 00:13:33.420
automated infrastructure, which is making it a lot easier to upgrade. That's awesome.

00:13:34.100 --> 00:13:38.100
What about the beta version or the alpha version even of 3 .8?

00:13:38.200 --> 00:13:42.460
You guys said late October for the main release.

00:13:42.540 --> 00:13:44.800
For the main release, but we work that back.

00:13:44.940 --> 00:13:46.780
When will we see stuff that we can start playing with?

00:13:46.880 --> 00:13:47.400
Can we already?

00:13:47.960 --> 00:13:51.640
I know, Anthony, you get it in build from source a lot and then play with it,

00:13:51.740 --> 00:13:52.920
and you guys do as well.

00:13:53.480 --> 00:13:57.020
But when does the average person who just wants to install a beta

00:13:57.160 --> 00:13:59.080
or something like that get access to it?

00:13:59.120 --> 00:14:00.200
Any alpha release

00:14:00.200 --> 00:14:03.260
is released in both the forum of sources

00:14:03.260 --> 00:14:04.460
that you can freely build.

00:14:05.000 --> 00:14:07.580
If you're cloning the repository from GitHub,

00:14:08.320 --> 00:14:10.020
there's tags that tell you exactly

00:14:10.180 --> 00:14:12.100
when a particular release was made.

00:14:12.530 --> 00:14:14.620
But also for alphas, betas,

00:14:14.860 --> 00:14:16.420
and later release candidates

00:14:16.660 --> 00:14:18.380
and actual versions that we release,

00:14:18.670 --> 00:14:19.800
we do have binaries, right?

00:14:19.960 --> 00:14:22.240
So for both macOS and Windows,

00:14:22.410 --> 00:14:24.120
we have plenty of binaries

00:14:24.170 --> 00:14:25.860
that you can use to test out your software.

00:14:26.070 --> 00:14:28.660
I would advise to do it as early as possible.

00:14:29.120 --> 00:14:30.120
especially 3

00:14:30.120 --> 00:14:33.720
.8 was kind of like a shy release.

00:14:34.100 --> 00:14:37.040
Right, because we had the whole governance thing,

00:14:37.420 --> 00:14:39.540
all the major changes were sort of put in.

00:14:39.740 --> 00:14:40.880
Yes, so now

00:14:40.880 --> 00:14:44.440
we are just four weeks before the first beta,

00:14:44.520 --> 00:14:46.500
which is the feature freeze for us, right?

00:14:46.940 --> 00:14:50.320
Since beta 1 to the main 3 .8 .0 release,

00:14:50.600 --> 00:14:51.940
we are just fixing bugs.

00:14:52.520 --> 00:14:54.360
In some unlikely cases,

00:14:54.680 --> 00:14:56.680
maybe even reverting features that we identified

00:14:56.800 --> 00:14:58.080
are not ready for prime time,

00:14:58.220 --> 00:15:03.920
unlikely to happen. What is more likely to happen is this is the time where you know that breaking

00:15:04.160 --> 00:15:10.080
changes are no longer being, new breaking changes are no longer being accepted. So it's a great time

00:15:10.080 --> 00:15:16.020
to actually start using your CI to test your libraries, your applications on Python 3 .8 as well.

00:15:16.380 --> 00:15:21.620
Expect problems. There's things that we have not identified, even though we have our other

00:15:21.940 --> 00:15:27.020
extensive regression suite of tests. But it's great to be able to identify those things early.

00:15:27.300 --> 00:15:31.020
So by the time the distributors come in and package Python 3 .8,

00:15:31.460 --> 00:15:33.700
its quality is good and we're transparent.

00:15:33.830 --> 00:15:36.720
We just can run your application with minimal churn.

00:15:36.920 --> 00:15:37.520
That's pretty cool.

00:15:37.790 --> 00:15:43.400
Can you test it with Tox or what's the best way to test on 3 .7 and 3 .8 beta or whatever?

00:15:43.680 --> 00:15:45.700
There's many possible ways depending on what

00:15:45.700 --> 00:15:47.940
particular operating system you're using.

00:15:48.460 --> 00:15:52.720
For open source projects that are already using a CI system like Travis,

00:15:53.100 --> 00:15:57.120
There are ways to just utilize the latest development version of Python.

00:15:57.780 --> 00:15:59.480
And at the moment, it's 3 .8.

00:15:59.660 --> 00:16:04.380
So just by just saying that you would also like to run your tests on the development version

00:16:04.430 --> 00:16:07.420
of Python, you're going to get beta version like in a month.

00:16:07.580 --> 00:16:09.580
That currently is going to be a form of alpha.

00:16:10.160 --> 00:16:14.300
So that is probably easiest because you don't have to actually install anything locally on

00:16:14.300 --> 00:16:19.640
your computer, which tends to make things complex when you have many interpreter versions with

00:16:19.760 --> 00:16:19.900
you.

00:16:20.660 --> 00:16:25.160
So homebrewing, Patrick, likes to default to one Python 3 version, one Python 2 version.

00:16:25.480 --> 00:16:29.220
So there's PyEnv that you can use to have multiple installations.

00:16:29.960 --> 00:16:31.140
And obviously, yes, there's Tox.

00:16:31.360 --> 00:16:33.020
They actually work rather well together.

00:16:33.350 --> 00:16:37.280
So you can set up your matrix of tests that later are run online,

00:16:37.720 --> 00:16:40.160
but you can also run them locally, which is what I'm doing.

00:16:40.480 --> 00:16:40.780
Yeah, okay.

00:16:41.340 --> 00:16:42.000
That seems pretty easy.

00:16:42.580 --> 00:16:45.780
All right, Anthony, let's kick off this PEP section

00:16:46.160 --> 00:16:47.820
and talking about the actual features,

00:16:48.100 --> 00:16:51.700
which, as we all know, appear as Python enhancement proposals

00:16:51.970 --> 00:16:53.940
and they go through a lifecycle and whatnot.

00:16:54.680 --> 00:16:57.160
If people are wondering what peps are out there,

00:16:57.320 --> 00:16:58.820
what might make it into 3 .8 and so on,

00:16:58.980 --> 00:17:00.000
where would they go to

00:17:00.000 --> 00:17:00.460
find that out?

00:17:00.600 --> 00:17:02.200
So I think on the python .org website,

00:17:02.420 --> 00:17:03.380
and there's a list of peps.

00:17:03.680 --> 00:17:05.939
There's also a PEP index on the list of peps.

00:17:06.459 --> 00:17:09.260
I've also made a small web app called Pep Explorer,

00:17:09.699 --> 00:17:11.560
where you can go and search and filter

00:17:11.760 --> 00:17:13.540
and pull specific Python versions

00:17:14.339 --> 00:17:15.760
and get the status of the peps.

00:17:16.199 --> 00:17:21.100
So I use Pep Explorer because I spend time looking at peps and reading about them and

00:17:21.189 --> 00:17:23.380
trying to understand what's coming in future versions.

00:17:24.120 --> 00:17:27.620
So yeah, if you're just curious, I'd say the Pep Explorer is probably a good way to go.

00:17:27.740 --> 00:17:29.180
Yeah, the Pep Explorer is pretty awesome.

00:17:29.360 --> 00:17:29.980
It's just a nice little

00:17:29.980 --> 00:17:30.300
grid.

00:17:30.520 --> 00:17:32.720
It's on GitHub pages, right?

00:17:32.840 --> 00:17:32.940
Yeah.

00:17:33.120 --> 00:17:33.280
Yeah.

00:17:33.660 --> 00:17:34.660
And I'll just link to that.

00:17:34.940 --> 00:17:36.720
And of course, people can go to python .org.

00:17:36.940 --> 00:17:39.200
But yeah, it's really nice to just keep track of that.

00:17:39.400 --> 00:17:41.320
And I find that super helpful.

00:17:41.960 --> 00:17:42.220
All right.

00:17:42.480 --> 00:17:43.840
So let's kick it off.

00:17:43.980 --> 00:17:46.460
maybe since you're holding the mic, we'll go with you first.

00:17:47.090 --> 00:17:49.400
You know, what's like one of the notable things that's coming

00:17:49.410 --> 00:17:52.020
that you want to talk about, what PEP or feature?

00:17:52.260 --> 00:17:52.640
So I thought

00:17:52.640 --> 00:17:53.880
I'd cover off the

00:17:53.880 --> 00:17:55.140
two ones that changed

00:17:55.140 --> 00:17:56.700
the language first.

00:17:56.760 --> 00:17:56.860
Okay.

00:17:57.100 --> 00:17:59.040
So there's assignment expressions,

00:17:59.960 --> 00:18:02.020
colloquially known as the walrus operator.

00:18:02.380 --> 00:18:03.440
The walrus operator.

00:18:04.320 --> 00:18:06.060
Yeah, so this is PEP572.

00:18:06.380 --> 00:18:07.760
Yeah, PEP572.

00:18:07.830 --> 00:18:12.200
So in Python, if you want to assign a value to a variable,

00:18:12.820 --> 00:18:15.740
you use the equals symbol, that doesn't return anything.

00:18:15.930 --> 00:18:18.820
So if you just do a equals one in the REPL,

00:18:18.910 --> 00:18:20.920
then that won't return anything in the REPL.

00:18:21.520 --> 00:18:24.260
An assignment expression is basically a way of combining

00:18:24.900 --> 00:18:26.960
the assignment of a value to a variable

00:18:27.540 --> 00:18:29.040
and returning the variable back again.

00:18:29.340 --> 00:18:32.780
So the reason you would want to do that is in some statements,

00:18:33.620 --> 00:18:35.580
for example, within list comprehensions,

00:18:36.270 --> 00:18:39.320
within while statements, for example, within if statements,

00:18:40.220 --> 00:18:43.540
The thing in the if statement, the comparison, for example,

00:18:43.700 --> 00:18:46.700
you can actually do assignments inside the comparison,

00:18:47.400 --> 00:18:50.840
and it just removes some additional code that you might have to do.

00:18:51.420 --> 00:18:55.100
And also, there's a few other examples in list and dictionary comprehensions

00:18:55.640 --> 00:18:58.060
where you can do some fairly smart things inside the comprehension.

00:18:58.420 --> 00:19:00.760
Yeah, when I first saw this, I thought, interesting.

00:19:01.280 --> 00:19:04.320
I don't know if it's really needed, but I wasn't super against it or anything.

00:19:05.220 --> 00:19:08.400
But certainly seeing it in the list comprehension space

00:19:08.660 --> 00:19:10.080
and seeing it used in other places as well,

00:19:10.200 --> 00:19:13.080
I think I'm pretty positive on this language change.

00:19:13.400 --> 00:19:14.300
It's pretty nice.

00:19:14.760 --> 00:19:17.000
Certainly anytime you need an expression, right?

00:19:17.180 --> 00:19:21.600
Within like some kind of comprehension, maybe a lambda or something like that.

00:19:21.740 --> 00:19:25.740
Like this often is the only way to, you know, do it.

00:19:25.760 --> 00:19:31.100
Like, so if you want to create a variable, but also test it in a list comprehension,

00:19:31.300 --> 00:19:33.020
and that might be the response of a function.

00:19:33.120 --> 00:19:34.460
Like you can maybe have to call that twice.

00:19:35.660 --> 00:19:38.260
Once when you test it and once when you put it into the list,

00:19:38.660 --> 00:19:40.700
Now you could assign it and then test it, right?

00:19:40.940 --> 00:19:42.020
So these things get simpler.

00:19:42.320 --> 00:19:42.920
Yeah, they get simpler.

00:19:42.980 --> 00:19:47.500
I think looking at the syntax, people's initial responses often, I can't see where I would

00:19:47.660 --> 00:19:52.960
use that, but it takes a while for these types of pieces of syntax to become common because

00:19:53.360 --> 00:19:57.400
once you know the patterns in which you would use it and you've memorized them and then you

00:19:57.580 --> 00:19:58.960
start to use it more and more over time.

00:20:01.720 --> 00:20:05.540
This portion of Talk Python To Me is brought to you by Microsoft and Azure Pipelines.

00:20:06.060 --> 00:20:09.780
Azure Pipelines is a CI CD service that supports Windows, Linux, and Mac.

00:20:10.400 --> 00:20:14.780
It lets you run automatic builds and tests of your Python code on each commit or pull request.

00:20:15.400 --> 00:20:20.860
It is fully integrated with GitHub, and it lets you define your continuous integration and delivery pipelines with a simple YAML file.

00:20:21.380 --> 00:20:23.700
Azure Pipelines is free for individuals and small teams.

00:20:24.100 --> 00:20:28.960
If you're maintaining an open source project, you'll even get unlimited build minutes and 10 concurrent pipelines.

00:20:29.700 --> 00:20:32.160
Many Python projects are already using Azure Pipelines.

00:20:32.540 --> 00:20:36.220
So get started for free at talkpython .fm slash Microsoft.

00:20:39.000 --> 00:20:43.580
And then the second PEP, I guess, changes the language slightly is positional only arguments.

00:20:44.400 --> 00:20:51.040
And basically this is PEP 570, which has also been accepted and merged into Python 3 .8.

00:20:51.580 --> 00:20:54.980
It wasn't part of alpha 3, so it'll be in the alpha 4 release, I believe.

00:20:55.320 --> 00:21:06.920
And basically this one is you add a forward slash in the list of parameters in a function definition so that it says that it's only positional arguments in this function.

00:21:07.600 --> 00:21:18.420
The reason for that is basically to protect an API to ensure that people only use positional arguments and they don't start to use them as keyword arguments.

00:21:18.780 --> 00:21:20.040
Yeah, it's pretty interesting.

00:21:20.220 --> 00:21:24.240
It's like the anti -keyword -only argument one, right?

00:21:24.420 --> 00:21:26.760
which, so with the keyword argument one,

00:21:26.880 --> 00:21:29.000
I don't know that many people actually know about it,

00:21:29.060 --> 00:21:29.720
but it's pretty cool.

00:21:30.420 --> 00:21:33.980
So if you say, you know, function, parenthesis, star, comma,

00:21:34.760 --> 00:21:35.680
argument, argument, argument,

00:21:36.040 --> 00:21:38.760
those all have to be explicitly called as keyword arguments.

00:21:39.540 --> 00:21:42.300
This is like, I want to make it impossible,

00:21:43.020 --> 00:21:44.720
at least in this section of the parameters,

00:21:45.360 --> 00:21:47.400
to call them as keyword arguments, right?

00:21:47.560 --> 00:21:48.340
Yeah, it's a cool feature.

00:21:48.610 --> 00:21:49.980
And it's also going to help with

00:21:49.980 --> 00:21:51.000
a lot of the standard library.

00:21:51.200 --> 00:21:52.080
That's the other justification.

00:21:52.940 --> 00:21:58.820
And there's a lot of the Python standard library where the API needs to be protected so that it can be iterated on,

00:21:59.340 --> 00:22:01.640
where this feature is basically going to help lock that down.

00:22:02.220 --> 00:22:06.540
And also in 3 .7, there were some improvements to the performance of method calls.

00:22:07.300 --> 00:22:09.960
That performance improvement doesn't work with keyword arguments.

00:22:10.300 --> 00:22:10.500
I see.

00:22:10.860 --> 00:22:15.720
So basically, you could potentially use this as a way of enforcing that performance improvement.

00:22:15.860 --> 00:22:16.620
Okay, that's interesting.

00:22:16.920 --> 00:22:20.540
The example that I saw, I think if I remember this correctly, was just like range.

00:22:20.980 --> 00:22:29.000
Like even just knowing when you see stuff, if you quickly read it, like you could have range and say stop and then start and then step.

00:22:29.010 --> 00:22:31.160
Or you could have start and then stop and then step.

00:22:31.160 --> 00:22:32.160
Or you could have step and then start.

00:22:32.170 --> 00:22:35.380
And just seeing, I mean, even though the words are kind of similar.

00:22:35.910 --> 00:22:40.980
And it's going, no, I want you to always just say start and then stop and then step or whatever, right?

00:22:41.080 --> 00:22:48.160
Like just requiring them to not have this sort of almost arbitrariness of the order of the parameters seemed like an interesting idea there as well.

00:22:48.400 --> 00:22:53.320
Yeah, an additional detail is the fact that, you know, many of the functions that are implemented

00:22:53.410 --> 00:23:00.360
in C don't implement keyword arguments. So they're effectively positional only by the sheer fact that

00:23:00.420 --> 00:23:06.360
they are just being implemented in C. And this just enables us to express those same APIs in

00:23:06.470 --> 00:23:11.920
Python faithfully, so that alternative implementations recreate the API in exactly the same way.

00:23:12.140 --> 00:23:16.800
Oh, yeah, that's interesting. So you don't want like the leaky abstraction of the C

00:23:16.780 --> 00:23:21.260
implementation to leak out and maybe break PyPy or something like this? Yeah,

00:23:21.270 --> 00:23:21.740
so currently,

00:23:21.870 --> 00:23:27.400
like the issue is actually the opposite, where PyPy does not necessarily care that, you know,

00:23:27.660 --> 00:23:34.460
some argument is positional only in CPython. So they allow for keyword use of it. And then

00:23:34.860 --> 00:23:39.040
that piece of code is problematic going back to CPython. So that is just, you know,

00:23:39.600 --> 00:23:43.540
caring of, you know, making your library code, your application code,

00:23:43.640 --> 00:23:45.680
sort of exchangeable between runtimes.

00:23:45.920 --> 00:23:46.380
Yeah, interesting.

00:23:46.600 --> 00:23:47.240
What about Cython?

00:23:47.700 --> 00:23:49.040
Cython is its own kind of thing

00:23:49.300 --> 00:23:52.340
because it's a language that is being compiled

00:23:52.580 --> 00:23:55.440
or rather transpiled to a bunch of C or C++,

00:23:55.860 --> 00:23:58.120
which is then compiled to a C module.

00:23:58.720 --> 00:24:02.160
They are kind of free to do a lot of modifications

00:24:02.760 --> 00:24:04.700
that Python itself is not free to do

00:24:04.960 --> 00:24:06.440
because they're compile time modifications.

00:24:06.540 --> 00:24:06.940
Right, their

00:24:06.940 --> 00:24:08.920
transpiler can make the adjustment

00:24:09.000 --> 00:24:09.700
it needs anyway, right?

00:24:09.860 --> 00:24:10.060
Yes,

00:24:10.080 --> 00:24:11.520
the source code that you're reading

00:24:11.700 --> 00:24:13.540
is not the source code that is being executed.

00:24:14.860 --> 00:24:18.800
interesting all right what's the next PEP that you want to feature you want to talk about let's

00:24:18.850 --> 00:24:24.100
cover a few of them and in fact like the slew of peps is uh all related to typing uh let me start

00:24:24.110 --> 00:24:24.940
with something old

00:24:24.940 --> 00:24:31.240
which is PEP 544 protocols so that PEP should have been accepted a long time ago

00:24:31.460 --> 00:24:36.000
but it did not because of the governance or situation so

00:24:36.000 --> 00:24:37.699
protocol is this like kind of like

00:24:37.940 --> 00:24:41.540
interface inheritance type of thing like what what's going on protocols

00:24:41.540 --> 00:24:43.720
essentially is a way to

00:24:44.040 --> 00:24:50.900
introduce duck typing to static typing to type checkers so you can have interfaces well or like

00:24:51.080 --> 00:24:54.900
protocols they are called protocols across the python documentation too which is why we're using

00:24:55.040 --> 00:25:00.220
that name too but you can have essentially implicit interfaces that are being implemented

00:25:00.560 --> 00:25:07.680
by a class by a type and then the type checker is able to act on them when you express a need for a

00:25:07.700 --> 00:25:09.020
as an argument to a function.

00:25:09.480 --> 00:25:12.300
For example, if your function accepts anything

00:25:12.700 --> 00:25:14.100
that has a read method,

00:25:14.780 --> 00:25:16.160
now you can express that type.

00:25:16.500 --> 00:25:17.100
That's really

00:25:17.100 --> 00:25:17.340
cool.

00:25:17.420 --> 00:25:18.440
I'm super excited about this.

00:25:18.660 --> 00:25:20.240
Because if you take two things,

00:25:20.580 --> 00:25:22.640
like maybe a set and a dictionary,

00:25:23.100 --> 00:25:23.780
but you want to express,

00:25:23.920 --> 00:25:25.180
I'm going to have those types

00:25:25.200 --> 00:25:25.980
and I want to work with them.

00:25:25.980 --> 00:25:27.840
But really all I care about is I can iterate it.

00:25:27.960 --> 00:25:29.500
Or that's probably not the perfect example.

00:25:29.580 --> 00:25:31.160
But you know, like it's hard to kind of

00:25:31.400 --> 00:25:33.260
make the type system express that now.

00:25:33.280 --> 00:25:34.040
And this just says,

00:25:34.540 --> 00:25:37.100
well, if it has an add and a pop method,

00:25:37.200 --> 00:25:39.820
we're good like whatever right that's is that protocols yes

00:25:39.820 --> 00:25:41.700
so protocols is the answer like

00:25:41.700 --> 00:25:47.460
to a question that we've received a lot early on when uh PEP 484 came out like the original

00:25:47.900 --> 00:25:53.980
you know formation of static typing for python that isn't static typing in direct opposition

00:25:54.270 --> 00:26:00.580
to what we have been telling everybody to do for all those years which is duck typing like if it um

00:26:00.860 --> 00:26:05.440
if it quacks like a duck and looks like a duck it is a duck we don't care if this instance is

00:26:05.460 --> 00:26:11.840
working. We just care that the calls find the right methods with the right arguments and everything

00:26:12.020 --> 00:26:18.060
is fine. So now with protocols, you can actually structurally express this, that all you care about

00:26:18.280 --> 00:26:20.160
is a given field or a given method.

00:26:20.420 --> 00:26:22.560
I like it. I know you're a proponent of

00:26:22.940 --> 00:26:27.700
type hints and mypy and all that kind of stuff. How do you see the state of that these days?

00:26:27.940 --> 00:26:30.040
Well, we're definitely on the rise

00:26:30.040 --> 00:26:34.420
there. At my time at Instagram and at Facebook,

00:26:34.700 --> 00:26:41.400
we've seen a lot of improvements, both in terms of security, you know, a team velocity, and as well,

00:26:41.780 --> 00:26:47.480
just being able to comprehend the source code when types were introduced to the biggest PHP

00:26:48.140 --> 00:26:55.680
component of facebook .com. And so since, I guess, 2013, I wanted to see something similar in Python.

00:26:56.290 --> 00:27:01.820
So like pep484 came out, you know, soon enough, Python 3 started getting adopted more and more. And,

00:27:02.140 --> 00:27:08.740
And this is when annotations, which are the nice way to express types, have been gaining adoption.

00:27:09.500 --> 00:27:23.480
And these days, from what I've heard at the conference now, 90 % of functions in the Instagram code base, which is north of 2 million lines of code at the moment, is covered in types, which is amazing.

00:27:23.820 --> 00:27:25.160
That is a big achievement.

00:27:25.420 --> 00:27:29.760
So definitely, this trend is on the rise, which I am very happy about.

00:27:30.120 --> 00:27:30.840
Yeah, that's awesome.

00:27:31.180 --> 00:27:34.080
Anthony, what are your thoughts on type hints, type annotations?

00:27:34.340 --> 00:27:35.360
And do you like them?

00:27:35.740 --> 00:27:36.480
Have they changed your code?

00:27:36.600 --> 00:27:36.940
Do you use them?

00:27:37.180 --> 00:27:38.840
I actually use them very rarely.

00:27:39.280 --> 00:27:44.820
In 3 .7, there's the type annotations, the delayed evaluation type annotations.

00:27:45.020 --> 00:27:46.740
Yeah, it's gotten a little nicer in that way.

00:27:46.900 --> 00:27:51.180
In 3 .7, which makes it a bit easier in terms of what you have to import and when.

00:27:51.780 --> 00:27:57.440
But the only reason I use them seldomly is because I mainly work on libraries which I publish to PyPI,

00:27:58.340 --> 00:28:04.520
which are used by people who have Python 3 .5, 3 .6, and some 2 .7 as well.

00:28:04.630 --> 00:28:08.380
So I really have to cover the lowest common denominator when it comes to users

00:28:08.920 --> 00:28:11.380
because they're mainly utility libraries that I work on,

00:28:11.580 --> 00:28:15.540
not sort of single deployment applications.

00:28:15.920 --> 00:28:19.560
Yeah, or something like Black that doesn't really get consumed directly,

00:28:19.840 --> 00:28:20.940
but it's more executed, right?

00:28:21.160 --> 00:28:22.380
Like Black or pytest or something.

00:28:22.740 --> 00:28:23.160
Yeah, interesting.

00:28:23.580 --> 00:28:24.180
What's the next one?

00:28:24.340 --> 00:28:28.880
All right, so the next PEP would be PEP 585

00:28:28.880 --> 00:28:30.360
that I actually wrote.

00:28:30.500 --> 00:28:31.700
Well, it's still in draft form.

00:28:32.100 --> 00:28:37.120
So to kind of set the stage for the PEP, what Anthony said is like there's plenty of cases

00:28:37.460 --> 00:28:43.500
where currently typing that was added rather carefully to the language requires you to

00:28:44.080 --> 00:28:46.600
import names that you're later using as types.

00:28:47.180 --> 00:28:53.620
There's some situations where you are introducing names to your global scope just for type aliasing

00:28:53.620 --> 00:28:55.560
or to introduce type variables.

00:28:56.260 --> 00:28:56.420
Right.

00:28:56.710 --> 00:28:57.980
For example, if you've got a function

00:28:58.510 --> 00:29:00.000
and you want to say its return type is this

00:29:00.000 --> 00:29:00.240
object,

00:29:00.740 --> 00:29:02.100
you now have to import at the top.

00:29:02.420 --> 00:29:04.640
If you had never actually had that part called,

00:29:04.860 --> 00:29:07.200
maybe it would have never been imported until lazily.

00:29:07.700 --> 00:29:10.040
There's changes in behavior because of that, right?

00:29:10.240 --> 00:29:12.160
Yeah, this is often problematic, right?

00:29:12.320 --> 00:29:13.080
Like what is

00:29:13.080 --> 00:29:15.120
even more like just cumbersome for the user

00:29:15.400 --> 00:29:18.320
is that there is plenty of either built -in types

00:29:18.540 --> 00:29:20.180
or abstract -based classes

00:29:20.520 --> 00:29:23.180
that have their equivalents in the typing module,

00:29:23.460 --> 00:29:27.240
meaning if you want to express that some argument is a list of string,

00:29:27.280 --> 00:29:30.440
you have to import an uppercase list from the typing module

00:29:30.520 --> 00:29:32.740
and say uppercase list of string.

00:29:33.300 --> 00:29:35.560
And I always found that clumsy, right?

00:29:35.700 --> 00:29:39.360
I always found that it is something new that you have to explain

00:29:39.560 --> 00:29:42.980
to new programmers that are first interacting with typing.

00:29:43.220 --> 00:29:45.420
And there's not really a great reason for that.

00:29:45.560 --> 00:29:49.680
We wanted the actual lowercase list to be orthogonal

00:29:50.040 --> 00:29:52.860
and not know anything about the static typing concept,

00:29:53.180 --> 00:29:56.120
which is mostly used by an external type checker.

00:29:56.180 --> 00:29:58.780
It does not have a big runtime component.

00:29:59.240 --> 00:30:00.200
It does have a little, right?

00:30:00.260 --> 00:30:02.560
Because you can inherit from generic types.

00:30:02.660 --> 00:30:04.920
So you can actually create your own data structure

00:30:05.540 --> 00:30:07.200
where you say that this is, I don't know,

00:30:07.220 --> 00:30:10.040
a collection of types T, right?

00:30:10.160 --> 00:30:11.500
So that this is a possibility.

00:30:12.120 --> 00:30:13.380
But for very many cases,

00:30:14.000 --> 00:30:15.980
this runtime component is just a hindrance.

00:30:16.180 --> 00:30:18.280
It's something that you have to remember to import.

00:30:18.480 --> 00:30:19.420
The names look different

00:30:19.620 --> 00:30:21.520
because they're uppercase and lowercase.

00:30:22.000 --> 00:30:26.660
They might look exactly the same in form of set, but they actually mean something else

00:30:26.900 --> 00:30:27.040
now.

00:30:27.800 --> 00:30:30.880
Because the point being, so that's the first issue.

00:30:30.980 --> 00:30:34.180
And the second issue is that this is something that sits in memory, right?

00:30:34.360 --> 00:30:38.000
This is something that you spend time on when you're starting up your program.

00:30:38.840 --> 00:30:42.840
So I always felt like this is something that we can maybe live without.

00:30:43.660 --> 00:30:48.480
Hence PEP 563, which actually postpones evaluation of annotations.

00:30:48.580 --> 00:30:50.120
That was introduced in Python 3 .7.

00:30:50.880 --> 00:30:56.340
And stemming from that, you know, having that foot in the door that like now the annotations

00:30:56.480 --> 00:31:01.900
are not evaluated anymore, we can regain some of the usability that people expect just by

00:31:02.340 --> 00:31:06.660
the fact that this can be still valid Python syntax, but it doesn't have to be valid at

00:31:06.780 --> 00:31:06.920
runtime.

00:31:07.540 --> 00:31:10.520
So we can get away without importing things from typing.

00:31:11.060 --> 00:31:14.160
You know, the type checker will know exactly what you mean anyway, right?

00:31:14.340 --> 00:31:20.840
We can come back to using a lowercase list of string instead of uppercase list of string

00:31:20.920 --> 00:31:21.880
And a few other things.

00:31:22.100 --> 00:31:23.540
You still do the bracket of string?

00:31:24.140 --> 00:31:24.200
Yes, yes.

00:31:24.200 --> 00:31:25.160
But on the lowercase list type?

00:31:25.360 --> 00:31:29.260
Yeah, so we will never do pointy brackets for that,

00:31:29.680 --> 00:31:31.360
like in Java or C++,

00:31:32.190 --> 00:31:36.420
because our LL1 parser is unable to deal with that case.

00:31:37.000 --> 00:31:38.560
Maybe if we switch to a different one,

00:31:38.660 --> 00:31:39.880
of which there is discussion,

00:31:40.860 --> 00:31:42.420
maybe then that would be possible.

00:31:42.620 --> 00:31:45.240
But at that point, it will still be way too late.

00:31:45.400 --> 00:31:46.260
Yeah, I think it's

00:31:46.260 --> 00:31:46.960
fine the way it works.

00:31:47.120 --> 00:31:48.440
It's different, but it's just totally...

00:31:48.460 --> 00:31:50.500
It's different, but it's a way of expression.

00:31:50.580 --> 00:31:56.400
There's nothing that makes the angle brackets in templates or generics necessarily the right way, yeah?

00:31:56.520 --> 00:32:00.500
Yes, exactly. It's like as long as humans understand what those

00:32:00.500 --> 00:32:02.660
things mean, the goal has been achieved.

00:32:03.280 --> 00:32:12.880
So yeah, the rest of the PEP 585 is just an attempt to reform some of the pre -existing constructs in the typing module,

00:32:13.020 --> 00:32:17.280
like creating new types, casting, aliasing, or type variables

00:32:18.020 --> 00:32:23.260
into variable annotations so that they are also not evaluated at import time,

00:32:23.520 --> 00:32:26.860
which enables, again, usage of types that are not imported

00:32:27.240 --> 00:32:31.220
and some of those tricks with syntax like lowercase list and dict and whatnot.

00:32:31.900 --> 00:32:34.020
So that's 5 .8 .5.

00:32:34.280 --> 00:32:37.940
While we're on this performance and type annotations and stuff,

00:32:38.600 --> 00:32:40.180
what's the story of mypyC?

00:32:40.480 --> 00:32:42.100
Oh, this is actually a very interesting story.

00:32:42.340 --> 00:32:45.820
So mypy has traditionally been slow,

00:32:46.220 --> 00:32:48.560
to the point where running it

00:32:48.660 --> 00:32:50.160
over the entire Instagram code base

00:32:50.400 --> 00:32:53.060
was taking over five minutes, right?

00:32:53.140 --> 00:32:54.700
So this was a thing that you could do

00:32:54.720 --> 00:32:55.760
in continuous integration,

00:32:56.000 --> 00:32:58.420
but you could not absolutely run it

00:32:58.420 --> 00:32:59.400
in an editor or whatnot.

00:32:59.780 --> 00:33:01.620
We had some hacky workarounds

00:33:01.800 --> 00:33:04.300
to at least make people in the editors happy.

00:33:04.420 --> 00:33:06.580
I wrote a silly flake 8 mypy plugin

00:33:06.660 --> 00:33:09.260
at some point that kind of brought us somewhere

00:33:09.420 --> 00:33:10.780
it was useful for a while.

00:33:11.180 --> 00:33:13.140
But all of that was just not very great.

00:33:13.580 --> 00:33:17.380
So in the meantime, mypy started implementing incremental typing,

00:33:17.700 --> 00:33:20.780
meaning the graph of your modules, which did not change,

00:33:21.420 --> 00:33:24.040
can be cached so that with every change,

00:33:24.220 --> 00:33:27.020
like most of your computation is already pre -done.

00:33:27.600 --> 00:33:29.560
And that is evolving to this point now.

00:33:30.360 --> 00:33:34.580
With well -populated cache, that cuts the time to around 40, 50 seconds.

00:33:34.800 --> 00:33:37.100
So it's like a six, seven times

00:33:37.100 --> 00:33:37.640
improvement.

00:33:37.800 --> 00:33:38.900
Yeah, it's a big improvement.

00:33:39.100 --> 00:33:39.920
So that's good.

00:33:40.200 --> 00:33:43.180
but still the cold type checking was like rather slowish.

00:33:43.260 --> 00:33:46.600
In the meantime, Facebook started developing its own type checker for Python.

00:33:47.020 --> 00:33:52.620
Well, more with the goal of creating a static analysis tooling that just uses types.

00:33:52.920 --> 00:34:00.240
So the type checker part was only the base of the static analysis that was being performed

00:34:00.600 --> 00:34:06.000
on that very code with the important use case of doing security checks.

00:34:06.740 --> 00:34:11.060
And one of the goals of that, you know, new type checker was like, we have to be faster

00:34:11.220 --> 00:34:11.940
than mypy, right?

00:34:12.179 --> 00:34:12.260
Yeah.

00:34:12.399 --> 00:34:15.399
Like, so that created competition and competition is always good.

00:34:15.960 --> 00:34:20.860
So in the meantime, like, Yuka Lektostalor, like, revived his original idea that, hey,

00:34:20.899 --> 00:34:27.840
if we have types, we can actually try to compile the Python code in a way that runs it way faster

00:34:28.040 --> 00:34:28.179
now.

00:34:28.399 --> 00:34:29.399
What does it compile to?

00:34:29.840 --> 00:34:31.000
So that's interesting, right?

00:34:31.080 --> 00:34:35.879
So the mypyC compiler actually creates a C extension.

00:34:36.340 --> 00:34:38.260
It actually transpiles to C.

00:34:38.860 --> 00:34:43.300
This sounds weird until you think about the C API that Python provides.

00:34:43.419 --> 00:34:46.040
And the Python C API is meant to be consumed by C.

00:34:46.460 --> 00:34:51.720
So it is just natural that you would have a generator that emits valid C for your given use case.

00:34:52.300 --> 00:34:57.139
And it turns out that with just a few constraints on how your program works,

00:34:57.760 --> 00:35:02.260
you can achieve 20 to 30 times performance boosts with that.

00:35:02.270 --> 00:35:02.840
So that's great.

00:35:03.440 --> 00:35:08.160
And in a real production application like mypy, it's consistently four times faster.

00:35:11.080 --> 00:35:15.040
This portion of Talk Python is sponsored by Microsoft and Visual Studio Code.

00:35:15.700 --> 00:35:19.840
Visual Studio Code is a free, open -source, and lightweight code editor that runs on Mac,

00:35:20.000 --> 00:35:22.160
Linux, and Windows with rich Python support.

00:35:22.820 --> 00:35:26.740
Download Visual Studio Code and install the Python extension to get coding with support

00:35:26.770 --> 00:35:30.420
for tools you love like Jupyter, Black Formatting, Pilot, pytest, and more.

00:35:30.740 --> 00:35:37.580
And just announced this month, you can now work with remote Python code bases using the new Visual Studio Code remote extensions.

00:35:38.280 --> 00:35:44.660
Use the full power of Visual Studio Code when coding in containers, in Windows subsystem for Linux, and over SSH connections.

00:35:45.160 --> 00:35:49.740
Yep, that's right. Auto completions, debugging, the terminal, source control, your favorite extensions.

00:35:50.320 --> 00:35:52.580
Everything works just right in the remote environment.

00:35:53.160 --> 00:35:57.240
Get started with Visual Studio Code now at talkpython .fm slash Microsoft.

00:35:59.400 --> 00:35:59.680
Do

00:35:59.680 --> 00:36:05.500
you see use cases for that outside just mypy, like random person doing data science

00:36:05.810 --> 00:36:08.060
that needs their Python parts to go faster?

00:36:08.780 --> 00:36:10.180
Currently, mypyC tries

00:36:10.180 --> 00:36:15.080
to limit their scope since they perceive the attempts by previous

00:36:15.580 --> 00:36:18.180
projects that meant to speed up Python.

00:36:18.890 --> 00:36:24.500
Those attempts failed mostly on trying to be 100 % compatible with every single feature

00:36:24.510 --> 00:36:24.980
of Python.

00:36:25.510 --> 00:36:27.400
So they're focusing on a subset.

00:36:27.980 --> 00:36:31.260
but they're growing that subset as much as they needed.

00:36:31.580 --> 00:36:35.360
And the big missing piece currently is there is no async await support.

00:36:36.020 --> 00:36:39.500
And with that support, I could actually have black compiled,

00:36:40.400 --> 00:36:41.060
which could also

00:36:41.060 --> 00:36:44.660
significantly speed up the formatter,

00:36:44.940 --> 00:36:47.540
which is already pretty performance, already does pretty well.

00:36:48.040 --> 00:36:50.120
But that would just make it so much better for the users.

00:36:50.720 --> 00:36:56.220
So in fact, I think I managed to get Sully, the core developer of mypyC,

00:36:56.720 --> 00:37:00.440
rather excited about the prospect of having

00:37:00.440 --> 00:37:04.700
Black as the next production customer of MyPayC. So we'll

00:37:04.840 --> 00:37:08.540
see. I have my fingers crossed. Yeah, that's exciting. All right, Anthony, what's the next

00:37:08.560 --> 00:37:10.800
one on our list of cool features in 3 .8? So

00:37:10.800 --> 00:37:13.440
this one is actually still in draft. It hasn't actually

00:37:13.560 --> 00:37:19.280
been decided and potentially might be deferred to a later release if it gets accepted. But when I've

00:37:19.400 --> 00:37:24.660
talked about features, at least proposed preps, this one gets quite a bit of attention and they're

00:37:24.660 --> 00:37:31.440
runtime audit hooks. And basically the PEP is a way of setting a callable when certain

00:37:32.440 --> 00:37:37.600
system methods within the Python standard library get called. For example, opening a network socket

00:37:38.260 --> 00:37:44.720
or requesting a URL or opening a file or lots of different cases, I guess, of sort of low -level

00:37:45.440 --> 00:37:49.980
standard library functions or methods. When they get called, then you get notified.

00:37:50.340 --> 00:38:08.480
That's super cool. So like if for some reason I'm in a lockdown environment, I want to use some package or write some app and it's, we think it's not talking to the network or the file system, but it turns out all of a sudden it's opening sockets or DNS stuff. That might be something to inspect.

00:38:08.820 --> 00:38:19.360
Yeah. So potentially you could lock down a Python distribution or a Python process to not be able to open certain URLs or open network sockets under certain circumstances.

00:38:19.600 --> 00:38:20.020
And it's

00:38:20.020 --> 00:38:21.580
cool. So with the hooks, do I get to say,

00:38:21.700 --> 00:38:22.700
I

00:38:22.700 --> 00:38:28.220
saw what you did and okay, or I saw what you did and no, you don't get it. Is it like a place to stop it?

00:38:28.510 --> 00:38:29.760
Yeah. The

00:38:29.760 --> 00:38:39.780
default is just as an FYI. But if you wanted to raise a runtime error or something else in line, then it would actually stop the request through to the function.

00:38:40.020 --> 00:38:51.560
That's pretty awesome. I think this is pretty interesting. I know there's some restricted environments and even like app stores and stuff that maybe it would be cool to package this up and use it. So yeah, definitely nice. Lucas, what do you think about this one?

00:38:51.640 --> 00:38:53.080
Well, I actually think this

00:38:53.080 --> 00:39:09.220
is very important. If you ever worked for a break on an organization, very often the audit trail of what actually happened is important, not just for security reasons. Very often, cascading errors that end up with an entire site being down are very hard to foresee.

00:39:09.580 --> 00:39:15.580
like you know the very easy to make mistakes or like long fix they're all patched like you know

00:39:16.160 --> 00:39:20.820
there's not a big red switch that if you just press the button you know the site goes down it's

00:39:20.830 --> 00:39:27.520
very often something that it was hard to you know combine and having the trail of oh this happened

00:39:27.740 --> 00:39:33.320
first and then another thing happened later like that is very valuable so i see this feature not

00:39:33.410 --> 00:39:37.980
only as a security feature but as just you know like a post -mortem kind

00:39:37.980 --> 00:39:39.380
of feature as well that's

00:39:39.400 --> 00:39:43.960
Anthony, do you envision this might enable a different set of tooling?

00:39:44.620 --> 00:39:46.620
We have visual debuggers now.

00:39:46.940 --> 00:39:51.120
Could you maybe have other types of analysis and tooling and whatnot?

00:39:51.320 --> 00:39:56.680
Yeah, in terms of tooling, I guess there's a lot of things in the standard library that you might want to add hooks in.

00:39:57.120 --> 00:40:00.920
And also an easy way of putting hooks into additional modules as well.

00:40:01.340 --> 00:40:04.000
And then having people to catch those and deal with those separately.

00:40:04.700 --> 00:40:12.940
I can definitely think of a few examples of libraries, deserialization libraries, not naming any specifically, that have …

00:40:13.060 --> 00:40:14.460
Rhymes with sickle?

00:40:15.700 --> 00:40:18.960
That have security backdoors, just in terms of the way they work.

00:40:19.470 --> 00:40:25.420
So unless you explicitly specify to load it with a safe mode, then you can actually run …

00:40:25.460 --> 00:40:27.260
That was a different one, a different rhyme maybe.

00:40:27.430 --> 00:40:27.780
Oh, okay.

00:40:27.930 --> 00:40:29.180
Yeah, XML

00:40:29.180 --> 00:40:30.420
as well is another one.

00:40:30.490 --> 00:40:30.780
Yeah, yeah.

00:40:30.920 --> 00:40:34.820
There are sort of known, I guess, security backdoors in certain libraries,

00:40:35.200 --> 00:40:37.380
and basically this could be a way of protecting against those.

00:40:37.500 --> 00:40:38.460
Okay, yeah, that's great,

00:40:38.820 --> 00:40:42.360
because it should not be doing these operations while loading this file.

00:40:42.880 --> 00:40:45.720
Yeah, if you're loading a YAML file or an XML file,

00:40:45.980 --> 00:40:47.340
it shouldn't be opening network sockets.

00:40:48.580 --> 00:40:52.040
Yeah, probably not, or issuing sub -process commands

00:40:52.400 --> 00:40:55.000
or any of these not -so -lovely things.

00:40:55.880 --> 00:40:57.520
All right, Lucas, what's next on our list?

00:40:57.880 --> 00:40:59.900
I would like to just say that there's quite a few

00:40:59.900 --> 00:41:00.140
peps

00:41:00.160 --> 00:41:05.020
are still in draft form and the authors have like an entire four more weeks in which they can decide

00:41:05.020 --> 00:41:09.640
to finish their PEP and publish it so things might change but the ones that i'm like personally

00:41:09.920 --> 00:41:15.480
interested in is always of course typing so let me just cover two more like the first one is pep

00:41:16.440 --> 00:41:23.160
586 so that's literal types and second one is 589 which is typed dict both of them are kind of an

00:41:23.300 --> 00:41:28.980
example of you know our type system kind of starting uh conservatively and then growing

00:41:29.400 --> 00:41:30.520
based on need, right?

00:41:30.800 --> 00:41:32.680
So literal types are very interesting

00:41:32.960 --> 00:41:34.520
because there are a bunch of calls

00:41:34.780 --> 00:41:37.400
where the behavior, like the return type

00:41:37.740 --> 00:41:40.340
or the cascading other arguments

00:41:40.480 --> 00:41:41.680
that you're going to use in the function

00:41:42.220 --> 00:41:45.160
depend not on the type of an argument,

00:41:45.640 --> 00:41:48.820
but on the actual value that you are passing.

00:41:49.240 --> 00:41:51.000
Like a positive integer, negative integer,

00:41:51.180 --> 00:41:52.100
something like this, or what?

00:41:52.160 --> 00:41:53.880
So parametric types are kind of hard,

00:41:54.020 --> 00:41:55.540
but what we're doing with literal types

00:41:55.660 --> 00:41:57.720
is something like the open built -in.

00:41:58.180 --> 00:42:00.920
Like with the open built -in, you have a certain number of modes, right?

00:42:01.100 --> 00:42:04.160
And depending on whether you're saying RB or R,

00:42:04.740 --> 00:42:07.740
the resulting IO is either bytes or strings.

00:42:08.060 --> 00:42:12.040
And currently, there is certain hackery both in mypy and Pyre

00:42:12.220 --> 00:42:14.180
to just, you know, work around this.

00:42:14.660 --> 00:42:18.060
But it would be good if the actual type system supported this feature.

00:42:18.180 --> 00:42:21.620
So literal is all about being able to express those types

00:42:22.080 --> 00:42:26.020
so that if you pass none here, it's going to behave differently.

00:42:26.460 --> 00:42:36.620
If you pass on string here, it's going to behave differently if that string is RB or is WB or is R and so on and so on.

00:42:36.820 --> 00:42:37.860
So that's literal types.

00:42:38.620 --> 00:42:44.020
There's some very, very interesting edge cases and deep thought in that PEP.

00:42:44.060 --> 00:42:46.020
It is surprisingly long and complex.

00:42:46.240 --> 00:42:47.560
I'm not going to go into this now.

00:42:48.100 --> 00:42:50.440
The other one is though, type dict.

00:42:51.220 --> 00:42:58.900
Originally, dictionaries have been envisioned in the static typing as, oh, there's this key value store.

00:42:59.020 --> 00:43:02.520
So there's keys of a certain type and there's values of a certain type.

00:43:03.340 --> 00:43:09.200
What happens in practice is that a lot of pre -existing Python applications do not use named tuples,

00:43:09.440 --> 00:43:13.260
do not use adders or data classes, which are very new.

00:43:13.380 --> 00:43:22.800
So instead, they use kind of lightweight classes in the form of dictionaries that have keys and values of various types.

00:43:23.500 --> 00:43:30.240
So there can be name, which is a string, but there can be a birth year, which is going to be an int, right?

00:43:30.270 --> 00:43:35.900
And based on the actual name of that key, you're going to have different types.

00:43:35.950 --> 00:43:40.660
So that was very cumbersome to express in the previous form.

00:43:40.740 --> 00:43:41.980
Almost like a schema, yeah.

00:43:42.340 --> 00:43:44.380
Yes, it's like very much like schemas.

00:43:44.580 --> 00:43:48.380
So now like there is a way to describe a type dictionary

00:43:48.630 --> 00:43:52.040
in the form of like a data class -like type,

00:43:52.540 --> 00:43:54.960
like where you just express it like, you know, class -like saying,

00:43:55.480 --> 00:43:58.380
this dictionary is going to have keys that are like this,

00:43:58.740 --> 00:44:02.680
and this key is going to be a string, this other key is going to be an int.

00:44:03.060 --> 00:44:04.440
That solves already a lot.

00:44:04.640 --> 00:44:08.960
But like then the interesting part is when those things start nesting.

00:44:09.560 --> 00:44:13.640
That actually enables you to construct like rather complex schemas

00:44:13.740 --> 00:44:17.880
that can be used directly in JSON or, you know, in other forms of serialization.

00:44:18.120 --> 00:44:21.140
So that PEP alone is also very useful in practice.

00:44:21.300 --> 00:44:23.800
Even though you could just say like people are doing it wrong,

00:44:23.860 --> 00:44:27.340
they should be using, you know, name tuples or other forms of typing instead.

00:44:27.960 --> 00:44:30.180
Well, you kind of have to be pragmatic, you know,

00:44:30.220 --> 00:44:32.100
like you see pre -existing valid

00:44:32.100 --> 00:44:33.220
use cases of this

00:44:33.580 --> 00:44:34.040
and you have

00:44:34.040 --> 00:44:35.140
to just adhere to those.

00:44:35.320 --> 00:44:36.240
Yeah, interesting.

00:44:36.440 --> 00:44:51.240
I guess since you're really into typing and you're on the core dev side of things, what do you think about libraries, especially I'm thinking of like web frameworks that use typing for like serialization and stuff?

00:44:51.420 --> 00:44:59.080
So like Molten, for example, you can have a class that has fields, but also those fields have types.

00:44:59.360 --> 00:45:04.520
And then you say this web function takes this class, but it's like really a form submission.

00:45:05.140 --> 00:45:08.280
and it'll like convert stuff to integers or like validate against the types.

00:45:09.040 --> 00:45:12.960
Is that in your mind awesome or is that an abuse of the type system?

00:45:13.260 --> 00:45:14.220
So this is interesting, right?

00:45:14.290 --> 00:45:16.100
Because obviously as long as

00:45:16.100 --> 00:45:19.880
the type system is kind of an extension of the type system

00:45:20.060 --> 00:45:24.720
we're using for type checking, or maybe it's even exactly the same, like that is using a

00:45:24.840 --> 00:45:25.420
shared vocabulary.

00:45:25.780 --> 00:45:26.120
That's great.

00:45:26.200 --> 00:45:27.660
Like, you know, we support that.

00:45:27.670 --> 00:45:31.420
Like we would wish to see type hints in more places.

00:45:31.620 --> 00:45:48.020
In fact, in 3 .7, I extended single dispatch so that now you can just use annotations on arguments instead of saying, you know, register off and like you can just say register and using the annotations of the first argument, it'll behave like, you know, as you expect.

00:45:48.160 --> 00:45:54.020
So you can use type annotations at runtime for whatever you want, as long as the type

00:45:54.380 --> 00:45:58.020
system is kind of, you know, the same with what we're using it for.

00:45:58.620 --> 00:46:03.680
Some use cases use annotations, function annotations in incompatible ways.

00:46:03.740 --> 00:46:08.200
And that creates issues because an increasing amount of tooling like Visual Studio Code,

00:46:08.500 --> 00:46:13.020
you know, PyCharm and whatnot, like gets confused by seeing something that, you know, is clearly

00:46:13.260 --> 00:46:15.960
not a type in the place where types are expected.

00:46:16.280 --> 00:46:17.540
So I kind of, yeah.

00:46:17.760 --> 00:46:18.860
Yeah, an example of that.

00:46:19.020 --> 00:46:21.880
So this example I gave you with Moulton seems like it's consistent.

00:46:22.640 --> 00:46:24.280
The type checker says it takes an int.

00:46:24.400 --> 00:46:25.500
It's actually an int at runtime.

00:46:26.500 --> 00:46:30.120
But I can't remember, but some of the other frameworks, maybe REST frameworks,

00:46:30.780 --> 00:46:33.680
they would say like you could say that this parameter is a header.

00:46:34.260 --> 00:46:38.340
And what it actually is the string value with that name out of the header.

00:46:39.100 --> 00:46:40.580
It's like the value comes from the header.

00:46:40.760 --> 00:46:42.260
But at runtime, it's not a header.

00:46:43.220 --> 00:46:43.760
It's not a dictionary.

00:46:43.900 --> 00:46:46.520
Whatever the header is, it's actually a string or an int or something.

00:46:47.100 --> 00:46:47.380
Yeah, I see.

00:46:47.560 --> 00:46:49.660
It seemed like it was really cool and clever,

00:46:49.880 --> 00:46:52.680
but also like incongruent with what Python intended.

00:46:52.880 --> 00:46:54.380
A certain amount of those things

00:46:54.580 --> 00:46:55.720
like our valid use cases,

00:46:56.000 --> 00:46:58.480
like let's say in the case of adders,

00:46:58.820 --> 00:46:59.460
adders like

00:46:59.460 --> 00:47:02.040
create valid classes for you

00:47:02.200 --> 00:47:05.040
from minimal information that you provide in source code.

00:47:05.560 --> 00:47:09.340
So this class is being fully functional at runtime.

00:47:09.860 --> 00:47:12.040
However, the type checker does not know this.

00:47:12.420 --> 00:47:14.739
It just sees like just some magic decorator

00:47:14.740 --> 00:47:17.200
and just this minimal set of attributes on it.

00:47:17.990 --> 00:47:22.960
And it does not know that a certain amount of built -in methods have been created

00:47:23.360 --> 00:47:27.100
and a certain amount of functionality within it and whatnot has been added.

00:47:27.720 --> 00:47:30.460
So at least in the case of mypyEmpire,

00:47:30.960 --> 00:47:34.880
additional functionality had to be implemented in those type checkers

00:47:34.880 --> 00:47:39.880
to understand that those types actually behave a bit differently from regular classes.

00:47:40.130 --> 00:47:43.820
But that's just something that users want, something that users need.

00:47:43.880 --> 00:47:46.840
And so based on that, we're going to be extending that.

00:47:46.910 --> 00:47:47.660
All right, cool, cool.

00:47:48.160 --> 00:47:49.480
Anthony, what do you got next on our list here?

00:47:49.840 --> 00:47:51.800
There's actually everything we have for 3 .8.

00:47:51.940 --> 00:47:52.820
All right, so ship it,

00:47:52.970 --> 00:47:53.240
we're good?

00:47:53.360 --> 00:47:54.280
Yeah, I think we're done now.

00:47:54.520 --> 00:47:57.900
So actually that PEP in particular, the type dictionary PEP,

00:47:58.420 --> 00:48:01.100
I've been thinking if anyone's in the JSON schema project,

00:48:01.680 --> 00:48:02.260
it's really cool.

00:48:02.360 --> 00:48:06.500
It's basically a way of defining a schema for JSON documents.

00:48:07.000 --> 00:48:09.320
You can definitely see that if this PEP gets accepted,

00:48:09.940 --> 00:48:16.100
somebody will build tooling to integrate between the JSON schemas and this new type dict type.

00:48:16.280 --> 00:48:17.580
Yeah, and it makes perfect sense.

00:48:17.820 --> 00:48:21.620
I mean, dictionaries are so similar to JSON in a sense,

00:48:21.760 --> 00:48:24.560
and they both have this sort of dynamicness but mixed types.

00:48:24.840 --> 00:48:26.940
I mean, they're very, very sort of mappable, yeah?

00:48:27.080 --> 00:48:29.660
Yeah, so I think it's just a matter of time until someone builds a library

00:48:30.020 --> 00:48:34.000
where you give it a JSON schema and it will generate a type dict class,

00:48:34.090 --> 00:48:35.120
and then you use that class.

00:48:35.580 --> 00:48:40.580
Similar in the same way that you in an ORM, when you would describe like a data class,

00:48:41.120 --> 00:48:42.680
and then you would deploy it as a database.

00:48:43.320 --> 00:48:46.000
It's basically like a similar way of reflecting documents.

00:48:46.380 --> 00:48:46.660
That's cool.

00:48:46.690 --> 00:48:48.240
I can definitely see it for serialization.

00:48:48.460 --> 00:48:54.260
Like you say, this function takes a type dict, but what actually it is a form post or a JSON post

00:48:54.420 --> 00:48:56.140
or like a REST call or something like that.

00:48:56.200 --> 00:48:56.400
That's cool.

00:48:56.959 --> 00:48:57.800
So let's see.

00:48:58.040 --> 00:49:00.120
Did we talk about multiprocessing?

00:49:00.680 --> 00:49:02.040
Is that coming in 3 .8 or is that beyond?

00:49:02.620 --> 00:49:03.240
That's in 3 .8.

00:49:03.320 --> 00:49:08.260
So one particular thing that is not PEP -worthy, but it's still a very interesting new feature

00:49:08.580 --> 00:49:13.920
is that traditionally multiprocessing, which has been created to solve the gil problem,

00:49:14.580 --> 00:49:16.240
has solved it partially.

00:49:16.660 --> 00:49:21.240
What I mean by this is that, yes, there is a master process that creates a bunch of children

00:49:21.480 --> 00:49:23.440
and then delegates work to it.

00:49:23.600 --> 00:49:27.840
So you can just call Python functions and those Python functions actually are executed

00:49:28.040 --> 00:49:29.920
on the other side in the child process.

00:49:30.640 --> 00:49:37.620
But the way this is achieved was that function call has been pickling the arguments of the function you're calling.

00:49:38.480 --> 00:49:41.020
That ended up being on the child side.

00:49:41.520 --> 00:49:43.680
That child unpickled the arguments.

00:49:43.910 --> 00:49:45.340
It did the computation it needed.

00:49:45.640 --> 00:49:52.240
And then if there was a return value it wanted, it actually had to pickle that return value again and pass it back to the master process.

00:49:52.370 --> 00:49:55.060
And the master process unpickled the return value again.

00:49:55.370 --> 00:49:57.140
And if that's big, it's very slow, for example.

00:49:57.200 --> 00:49:57.340
Exactly.

00:49:57.540 --> 00:50:00.220
So like for small things, that was mostly fine.

00:50:00.480 --> 00:50:08.420
But if you had like a gigantic haystack and you were looking for a needle in it, just, you know, pickling that haystack was taking.

00:50:08.600 --> 00:50:11.160
And then I'm picking on the other side was taking a lot of time.

00:50:11.320 --> 00:50:12.560
We were going to run that on all six

00:50:12.560 --> 00:50:12.880
cores.

00:50:13.060 --> 00:50:16.780
So here's six copies of our like 10 megabyte, whatever.

00:50:17.060 --> 00:50:17.460
That is

00:50:17.460 --> 00:50:24.000
actually annoying because like if you had like a master process that say it gets web requests, right?

00:50:24.100 --> 00:50:35.440
In the time that you're spending on pickling that haystack, nothing else can be actually done in Python because the gil is still there on that master process.

00:50:35.700 --> 00:50:38.140
So you are solving the gil problem only partially.

00:50:38.780 --> 00:50:50.140
So now multiprocessing introduces this new fantastic feature where you can declare a shared memory segment and share that memory between parents and children.

00:50:50.240 --> 00:50:56.400
What that does is you can actually get away with a lot of serialization and deserialization.

00:50:57.020 --> 00:51:05.520
So for certain kinds of tasks like search, like filtering, this will decrease the churn just needed to pass data around.

00:51:06.060 --> 00:51:13.420
Meaning it will bring us way closer to the world we want to see, which is that, yes, there are certain Python processes.

00:51:13.760 --> 00:51:19.700
They still have the gil, but it does not matter because we can use as many of those processes as we have cores and everything is fine.

00:51:19.880 --> 00:51:22.800
Yeah, and you don't have the replication of memory and the copying and all that.

00:51:22.900 --> 00:51:23.140
That's awesome.

00:51:23.340 --> 00:51:23.500
Yes.

00:51:23.680 --> 00:51:25.360
So I'm really excited when I saw that come out.

00:51:25.480 --> 00:51:26.440
I'm like, oh, this is going to be great.

00:51:26.620 --> 00:51:27.240
So that's in 3 .8?

00:51:27.400 --> 00:51:28.440
Yes, that is already in.

00:51:28.560 --> 00:51:28.740
Cool.

00:51:29.000 --> 00:51:33.400
And what about the subinterpreter 5 .5 .4?

00:51:33.600 --> 00:51:34.200
That's beyond?

00:51:34.680 --> 00:51:35.400
Oh, so that's interesting.

00:51:35.580 --> 00:51:36.100
That is kind

00:51:36.100 --> 00:51:36.500
of related.

00:51:36.920 --> 00:51:38.720
Yeah, they're in the same category of things.

00:51:38.820 --> 00:51:42.680
Yes, however, the multiprocessing feature does have limitations, right?

00:51:42.840 --> 00:51:46.900
Like the shared memory segment is not right for any arbitrary Python object.

00:51:47.000 --> 00:51:50.500
There's like, you know, restrictions on what types you can use.

00:51:50.780 --> 00:51:55.000
That was actually a complex functionality to be added, you know, within particular operating

00:51:55.260 --> 00:51:57.880
systems, shared memory handling is way different.

00:51:57.980 --> 00:52:03.180
So you have to understand how those differences work and which process is now responsible for

00:52:03.660 --> 00:52:07.820
creating that shared memory segment and shutting it down and freeing that memory when everything

00:52:08.020 --> 00:52:09.020
is, you know, shutting down.

00:52:09.140 --> 00:52:11.860
So that is all great work by Davin Potts.

00:52:12.280 --> 00:52:24.720
Like, multiprocessing is one thing, but subinterpreters is what if you had this multiprocessing API and actually just had one process and just used many Python interpreters within it, each with its own gil.

00:52:25.020 --> 00:52:28.860
To achieve that, many changes in the Python C API have to be added.

00:52:28.980 --> 00:52:36.480
Like, you know, a much cleanup internally in terms of what constitutes local and what constitutes global state have to be done.

00:52:36.900 --> 00:52:38.700
Eric Snow is working hard on that.

00:52:38.920 --> 00:52:42.020
As far as I can tell, this is deferred to Python 3 .9.

00:52:42.460 --> 00:52:43.640
I'm eagerly awaiting that.

00:52:43.740 --> 00:52:45.400
I think this is going to be a great improvement.

00:52:45.700 --> 00:52:48.180
Yeah, it could definitely change the threading story.

00:52:48.740 --> 00:52:55.140
In multipress processing strong in Python, async await is super cool for IO bound stuff.

00:52:55.420 --> 00:52:59.500
But threads have always been a kind of, well, sometimes they're helpful, sometimes they're not.

00:52:59.500 --> 00:52:59.920
It depends.

00:53:00.450 --> 00:53:01.340
And this could be awesome, right?

00:53:01.380 --> 00:53:06.880
You could just dedicate a sub -processor, a sub -interpreter, excuse me, to each thread, right?

00:53:06.940 --> 00:53:07.960
And really get free of that.

00:53:08.040 --> 00:53:08.380
I agree.

00:53:08.560 --> 00:53:08.620
Cool.

00:53:08.680 --> 00:53:14.480
All right. Well, thank you both for sharing what's coming. Pretty excited about 3 .8.

00:53:15.060 --> 00:53:15.860
Cool. That was a pleasure.

00:53:16.140 --> 00:53:17.100
Yeah, it's going to be great.

00:53:17.320 --> 00:53:22.080
Yeah. And on that topic as well, I guess we've got 3 .9. So, some of the PEPs are being deferred

00:53:22.080 --> 00:53:27.040
to 3 .9. And on the topic of sub -interpreters, the unpacking of the startup sequence,

00:53:27.780 --> 00:53:33.480
and also the initialization configuration, there's two proposals for that. One is PEP 4 .3 .2,

00:53:33.600 --> 00:53:36.800
and the other's PEP 587, which are interrelated

00:53:37.030 --> 00:53:38.680
because if you have sub -interpreters,

00:53:38.750 --> 00:53:41.000
you want the interpreter startup time to be fast

00:53:41.600 --> 00:53:43.380
and also the configuration to be flexible.

00:53:43.760 --> 00:53:46.340
So I think 3 .9 will definitely see

00:53:46.600 --> 00:53:49.000
some more proposals related to that.

00:53:49.100 --> 00:53:49.280
Awesome.

00:53:49.580 --> 00:53:53.500
Which are going to hopefully improve the startup time of Python 3.

00:53:53.940 --> 00:53:56.340
As we know, it's a little behind where Python 2 was

00:53:56.750 --> 00:53:59.480
for various reasons, but that'll be a great step forward.

00:53:59.640 --> 00:54:00.400
Yeah, that'd be really awesome.

00:54:00.600 --> 00:54:03.520
And then it also might make this sub -interpreter stuff

00:54:03.540 --> 00:54:07.300
better if those little sub interpreters can get created faster as well. I don't know how related

00:54:07.380 --> 00:54:12.140
they are, but pretty cool. Pretty cool. All right. One, we used up almost all our time,

00:54:12.220 --> 00:54:16.200
so I won't keep you guys much longer, but especially Lucas, let me ask you this, like,

00:54:16.760 --> 00:54:21.440
will there be a Python four and does it matter? I mean, on one hand, like we've got stuff that's

00:54:21.600 --> 00:54:27.900
0 .1, two versions that have been around for 10 years with a hundred releases. We've got Python

00:54:28.160 --> 00:54:32.720
three. If we don't have like major breaking changes, is there a reason to start calling it

00:54:32.740 --> 00:54:37.000
four and five and six, or is that just going to like scare people with the history or like,

00:54:37.130 --> 00:54:38.840
what do you, what's your perspective here?

00:54:38.920 --> 00:54:43.100
We are at Python 3 .8 now. We're about to release 3 .9

00:54:43.320 --> 00:54:49.540
later, you know, another 18 months later. Historically, Guido expressed his distaste with

00:54:49.880 --> 00:54:57.240
numbers after the decimal point that have more than one digit. And so he disliked the notion of

00:54:57.260 --> 00:55:05.220
having 2 .10, 2 .11, and same with 3 .10, 3 .11. However, we have both philosophical and technical

00:55:05.840 --> 00:55:11.660
challenges with just releasing a Python 4. Well, the obvious philosophical one is that

00:55:11.960 --> 00:55:16.900
the transition between Python 2 and Python 3 was very, very challenging, right? It took us a lot

00:55:16.900 --> 00:55:18.460
of effort. And there's a lot of fatigue,

00:55:18.960 --> 00:55:19.540
I think, in the

00:55:19.540 --> 00:55:21.520
community to just not go through that again

00:55:21.540 --> 00:55:28.860
for a while. Absolutely. Our closets are still full of skeletons. So we are really trying hard

00:55:28.920 --> 00:55:34.860
not to make that mistake again. It's not only a problem for the users, it was also unpleasant and

00:55:34.860 --> 00:55:40.620
a problem for the core developers. So we are really careful to make changes in a very incremental

00:55:40.800 --> 00:55:46.180
manner now and communicate them well and make them gradually so that we are disrupting our users

00:55:46.180 --> 00:55:53.100
the least, which just means calling something Python 4, well, would probably be just scary on

00:55:53.110 --> 00:55:58.400
its own, just on the power of that number. But just more practically speaking, because of this

00:55:58.530 --> 00:56:04.220
Python 2 and 3 transition, there is a ton of code in the wild that does checks exactly for the number

00:56:04.400 --> 00:56:11.420
3 in sys version, version info. And those checks would, you know, become invalid if we introduced

00:56:11.440 --> 00:56:17.540
python 4 like which is one of the reasons why you know like Linux had problems when it suddenly

00:56:17.880 --> 00:56:24.540
became Linux 3 and why we have windows 10 now just for that practical reason i do expect that we're

00:56:24.540 --> 00:56:31.440
gonna see python 3 .10 first at least before we ever decide to call the next release python 4 yeah

00:56:31.440 --> 00:56:31.660
yeah

00:56:31.660 --> 00:56:37.140
so 3 .10 is way more likely maybe we should call it python 6 because then it's like two times three

00:56:37.160 --> 00:56:40.780
Well, I was wondering if there's a proposal to introduce calendar versioning to Python.

00:56:41.100 --> 00:56:41.480
Oh, yeah.

00:56:41.480 --> 00:56:42.780
What do you think about calendar versioning?

00:56:43.120 --> 00:56:48.520
If Python 2 .7 was called 2014 .1, then maybe people would reconsider.

00:56:48.880 --> 00:56:48.980
Really?

00:56:49.340 --> 00:56:49.600
2014?

00:56:50.180 --> 00:56:50.620
What's up here?

00:56:50.860 --> 00:56:52.300
We just upgraded from 2013.

00:56:53.140 --> 00:56:55.760
It would certainly remind people how old their Python distribution is.

00:56:55.920 --> 00:56:57.100
So maybe they'll upgrade faster.

00:56:58.080 --> 00:56:58.480
That's funny.

00:56:58.580 --> 00:56:59.940
Well, I'm in no power

00:56:59.940 --> 00:57:01.780
to just make that change.

00:57:02.060 --> 00:57:04.380
I could be in power to create a PEP about it.

00:57:04.420 --> 00:57:08.060
but this is probably not a sword I'm willing to fall on.

00:57:08.620 --> 00:57:09.900
However, let me tell you this,

00:57:10.380 --> 00:57:13.180
all of my private projects do use calendar versioning.

00:57:13.320 --> 00:57:16.700
That's the only versioning that I am familiar and comfortable with.

00:57:16.960 --> 00:57:18.300
There's obviously semantic versioning,

00:57:18.440 --> 00:57:19.460
but I don't know about others,

00:57:19.660 --> 00:57:23.000
but at least I don't see myself being as strict

00:57:23.340 --> 00:57:26.320
and consistent with applying semantic versioning every time.

00:57:26.320 --> 00:57:26.680
What does it

00:57:26.680 --> 00:57:29.340
mean to push the major version versus minor version?

00:57:29.860 --> 00:57:30.020
Yes,

00:57:30.300 --> 00:57:31.300
so obviously there's rules,

00:57:31.560 --> 00:57:33.580
but the devil is in the application.

00:57:33.840 --> 00:57:37.020
Do you apply those rules consistently and every given time?

00:57:37.200 --> 00:57:44.140
I wrote an auto formatter because I was not able to apply rules of code styling consistently and every time.

00:57:44.620 --> 00:57:47.840
So I don't trust myself enough to do the same for semantic versioning.

00:57:48.040 --> 00:57:53.780
And if I'm not doing that, then my users cannot depend on what they expect from semantic versioning.

00:57:53.920 --> 00:58:00.780
Hence, just using calendar versioning is way easier, adopted by many popular projects like Ubuntu, like Twisted, like others.

00:58:01.140 --> 00:58:02.440
Yeah, I love the calendar versioning.

00:58:02.460 --> 00:58:05.080
I don't know that it makes sense for like the main Python.

00:58:05.660 --> 00:58:07.140
Maybe, maybe it does, maybe it doesn't.

00:58:07.520 --> 00:58:09.660
It would be effective on showing how old some stuff is.

00:58:10.280 --> 00:58:17.040
But certainly I feel like semantic versioning requires, like on libraries, it requires some expertise in that library.

00:58:17.260 --> 00:58:19.540
Like I depend on library A.

00:58:20.000 --> 00:58:21.360
It depends on library B.

00:58:21.900 --> 00:58:25.760
I see that when I pip installed it, it's 0 .1 .3.

00:58:26.600 --> 00:58:28.660
Six months later, is that out of date?

00:58:28.940 --> 00:58:29.740
I have no idea.

00:58:29.880 --> 00:58:32.000
Like I don't even know like roughly how old that is.

00:58:32.060 --> 00:58:40.020
But if I saw the calendar version on all the dependencies or stuff I'm not super familiar with, I'd be like, oh, yeah, this is actually, this is pretty much new or it's old.

00:58:40.120 --> 00:58:43.060
Like, it just, it makes it easier for newcomers, I think.

00:58:43.520 --> 00:58:43.600
Yeah.

00:58:44.180 --> 00:58:44.440
All right, guys.

00:58:44.820 --> 00:58:48.640
Thank you for being on the show and sharing all this and looking forward to when you actually release 3 .8.

00:58:48.800 --> 00:58:49.920
I'm looking forward to that, too.

00:58:50.040 --> 00:58:50.440
Thank you very much.

00:58:50.500 --> 00:58:50.980
I can imagine.

00:58:51.160 --> 00:58:51.560
Thanks, Michael.

00:58:51.740 --> 00:58:52.060
Yeah, bye.

00:58:53.180 --> 00:58:55.560
This has been another episode of Talk Python to Me.

00:58:56.320 --> 00:58:59.480
Our guests in this episode have been Lucas Lenga and Anthony Shaw.

00:59:00.000 --> 00:59:01.460
And it's been brought to you by Microsoft.

00:59:02.760 --> 00:59:05.160
If you're a Python developer, Microsoft has you covered.

00:59:05.530 --> 00:59:10.020
From VS Code and their modern editor plugins, to Azure Pipelines for Continuous Integration,

00:59:10.800 --> 00:59:12.920
and serverless Python functions on Azure.

00:59:13.420 --> 00:59:16.440
Check them out at talkpython .fm slash Microsoft.

00:59:17.720 --> 00:59:18.860
Want to level up your Python?

00:59:19.290 --> 00:59:23.620
If you're just getting started, try my Python Jumpstart by Building 10 Apps course.

00:59:24.180 --> 00:59:28.940
Or if you're looking for something more advanced, check out our new async course that digs into

00:59:28.900 --> 00:59:33.080
all the different types of async programming you can do in Python. And of course, if you're

00:59:33.240 --> 00:59:37.100
interested in more than one of these, be sure to check out our everything bundle. It's like a

00:59:37.360 --> 00:59:42.120
subscription that never expires. Be sure to subscribe to the show, open your favorite podcatcher

00:59:42.320 --> 00:59:46.760
and search for Python. We should be right at the top. You can also find the iTunes feed at slash

00:59:47.080 --> 00:59:53.380
iTunes, the Google Play feed at /play and the direct RSS feed at /rss on talkpython .fm.

00:59:54.100 --> 00:59:58.020
This is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it.

00:59:58.360 --> 00:59:59.820
Now get out there and write some Python code.

