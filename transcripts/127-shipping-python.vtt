WEBVTT

00:00:00.001 --> 00:00:03.680
To make software useful, honestly, to even make it real, you have to ship it.

00:00:03.680 --> 00:00:08.060
Building that web app? Then get ready to deploy it. Building a tool set for data scientists?

00:00:08.060 --> 00:00:12.780
How are you going to send them that application? Did you manage to get a cool GUI app going in

00:00:12.780 --> 00:00:17.780
Python using PySign? It's time to have your users start downloading it. Python is an amazing

00:00:17.780 --> 00:00:21.900
ecosystem, but one of the frailer parts of it has been shipping or deploying software,

00:00:21.900 --> 00:00:26.800
especially to end users. In this episode, you'll meet Cliff. Join the two of us as we discuss

00:00:26.800 --> 00:00:32.100
where we are and where we're going with shipping Python code. This is Talk Python to Me,

00:00:32.100 --> 00:00:53.640
episode 127, recorded June 12, 2017. Welcome to Talk Python to Me, a weekly podcast on Python,

00:00:53.640 --> 00:00:58.220
the language, the libraries, the ecosystem, and the personalities. This is your host,

00:00:58.220 --> 00:01:02.740
Michael Kennedy. Follow me on Twitter where I'm @mkennedy. Keep up with the show and listen to past

00:01:02.740 --> 00:01:09.300
episodes at talkpython.fm and follow the show on Twitter via at talkpython. This episode has been

00:01:09.300 --> 00:01:14.140
brought to you by Rollbar and Datadog. Be sure to check out what they're offering during their

00:01:14.140 --> 00:01:19.680
segments. It helps support the show. Hey, everyone. Two things I want to share quickly before we jump

00:01:19.680 --> 00:01:23.680
into the conversation with Cliff. First, when we started talking with him about what he's up to

00:01:23.680 --> 00:01:28.720
day to day, at the time of the recording, he couldn't announce the company name or say too much

00:01:28.720 --> 00:01:33.480
about what he was doing. But they have since launched, and their name is Pilot. Pilot does

00:01:33.480 --> 00:01:38.240
bookkeeping for startups using a combination of expert human bookkeepers and software automation.

00:01:38.240 --> 00:01:44.420
It's a software service that does your books, not an app for you to do your own books. So you can find

00:01:44.420 --> 00:01:49.160
out more about them by visiting pilot.com. And while you're there, you can imagine that

00:01:49.160 --> 00:01:54.600
Glyph has definitely shipped some Python code to it. Next, I have a new course to announce. I just

00:01:54.600 --> 00:02:01.020
released RESTful and HTTP APIs in Pyramid. This course will teach you the mechanics of building

00:02:01.020 --> 00:02:07.740
amazing APIs in Python, of course. But you also learn the theory of RESTful HTTP services in general,

00:02:07.740 --> 00:02:13.000
how to design them, when and how to use HTTP verbs and status codes, content negotiation,

00:02:13.000 --> 00:02:19.280
and even a little SQLAlchemy. Check the course out at talkpython.fm/REST. That's R-E-S-T.

00:02:19.280 --> 00:02:23.780
Now let's talk about shipping some software. Glyph, welcome to Talk Python.

00:02:23.780 --> 00:02:24.900
It's great to be here.

00:02:24.900 --> 00:02:28.540
Yeah, it's a real honor to have you on the show. You've done so much cool stuff. And

00:02:28.540 --> 00:02:32.680
I'm surprised our paths haven't crossed more, but I'm glad they're crossing today.

00:02:32.680 --> 00:02:37.480
Same here. And I gotta say, I know you're always so complimentary of your guests, and it's an

00:02:37.480 --> 00:02:42.360
honor to be on the show. But I gotta say, you podcasters do some real good for the Python

00:02:42.360 --> 00:02:45.480
community yourselves. I feel like I'm talking to a rock star here, too.

00:02:45.480 --> 00:02:47.220
Well, thank you so much.

00:02:47.220 --> 00:02:54.980
It's just a great way to access the culture of the elite in the Python community, the luminaries.

00:02:54.980 --> 00:02:59.900
I know a lot of people listen to this show and really get a sense of what the culture of the

00:02:59.900 --> 00:03:03.560
community is like from it. So we all appreciate what you do for the community.

00:03:03.740 --> 00:03:10.080
Thank you so much. I definitely see that as like one of the major services that we provide,

00:03:10.080 --> 00:03:15.460
you know, just to get the backstory. Like everybody knows about requests. They know about

00:03:15.460 --> 00:03:19.320
Twisted. They know about all these things, but you know, they just know the API. They don't know

00:03:19.320 --> 00:03:23.940
the story and the people. So as much as we can share that, that's awesome. Speaking of stories,

00:03:23.940 --> 00:03:25.280
how do you get into programming?

00:03:25.480 --> 00:03:30.000
Well, that's a very long one. A lot of people, you know, there's a sort of stereotypical story

00:03:30.000 --> 00:03:36.120
of like, well, I had an Altair when I was a kid and I learned basic. And so I had a kind of

00:03:36.120 --> 00:03:42.440
oddball version of that, which is that my father, who's a fairly prominent software developer himself,

00:03:42.440 --> 00:03:45.100
he was an APL programmer when I was a kid.

00:03:45.100 --> 00:03:47.320
APL blows me away, by the way.

00:03:47.320 --> 00:03:50.520
Yeah. Have you ever actually seen like a full APL program?

00:03:50.740 --> 00:03:54.780
I've seen little snippets and it's incredible. Could you just describe what the syntax looks like

00:03:54.780 --> 00:03:56.820
to everyone? Cause it's really not standard.

00:03:56.820 --> 00:04:02.660
Imagine that you were an astronaut on the moon at an archeological dig and you found a tablet

00:04:02.660 --> 00:04:08.240
that was a programming language from an alien civilization. That's what APL looks like. It's

00:04:08.240 --> 00:04:14.480
a combination of geometric symbols and Greek letters. And I think there might be some Hebrew letters in

00:04:14.480 --> 00:04:20.620
there. It is a very odd sort of programming language in that it comes off this

00:04:20.620 --> 00:04:26.220
evolutionary branch that did not have a lot of other languages on it. And it's definitely not

00:04:26.220 --> 00:04:33.840
the main one, you know, the sort of algal derived C, C++ type programming languages that we're all

00:04:33.840 --> 00:04:34.660
used to these days.

00:04:34.660 --> 00:04:39.920
Yeah. It's really a great description, like an alien one. When people ask me to describe it,

00:04:39.920 --> 00:04:46.960
I think of it's like, if Egyptians used hero graphics to like program, like this would be APL basically.

00:04:47.320 --> 00:04:52.180
Yeah, very much so. so, and of course, when I started learning to program at eight years old,

00:04:52.180 --> 00:04:53.900
that was not what I was looking for.

00:04:53.900 --> 00:04:55.620
Did you try to learn APL at that age?

00:04:55.620 --> 00:05:01.680
Dad tried to teach me. That's might not be the same thing. So I sort of learned a little bit of APL

00:05:01.680 --> 00:05:07.760
just enough to, start trying to write a text adventure, Zork style video game.

00:05:07.760 --> 00:05:13.900
So, I learned how to do the very first thing, which was variable assignment. So that when you would type

00:05:13.900 --> 00:05:20.100
West, it would print out the description of the room to the West. And that's kind of where I stayed

00:05:20.100 --> 00:05:24.760
in terms of programming sophistication for the next decade or so. Oh, well, maybe not decade,

00:05:24.760 --> 00:05:29.460
maybe around eight years. But I, so I started off trying, I didn't want to learn a program. I just

00:05:29.460 --> 00:05:37.160
wanted to be able to do just enough to make these Zork style video games. And I could not, without

00:05:37.160 --> 00:05:42.620
learning to code, obviously I couldn't actually get anywhere. So I went from there, which was APL 68K

00:05:42.620 --> 00:05:51.340
on the Amiga to HyperCard on the Mac. And, HyperCard was, I don't know, probably some of your

00:05:51.340 --> 00:05:57.500
listeners are familiar, but maybe not all of them. HyperCard was a English like scripting environment

00:05:57.500 --> 00:06:04.160
where you weren't writing a program, like a textual thing. You would launch HyperCard and you'd start

00:06:04.160 --> 00:06:09.940
editing these documents, which were a combination of like buttons and text fields, as well as little

00:06:09.940 --> 00:06:15.600
scripts that were attached to each of them. And so I spent a long time very, very tediously kind

00:06:15.600 --> 00:06:20.480
of teaching myself to code by accident because I had chosen this environment because it was the one

00:06:20.480 --> 00:06:26.580
where you didn't have to know how to code. And finally, after years of resisting this, I discovered

00:06:26.580 --> 00:06:33.160
what a variable was. I discovered that you could like have a value that didn't have to be like put

00:06:33.160 --> 00:06:38.760
into a text field or stored as a buttons label. Like you could just actually have a abstract notion

00:06:38.820 --> 00:06:44.840
of a value. And that sort of blew my mind. But, and one of the reasons I'm telling the story is like,

00:06:44.840 --> 00:06:51.900
I feel like that archetype that we have of the kid who learned basic and was programming since they were

00:06:51.900 --> 00:06:56.480
like five years old, kind of discourages other people from getting into coding. They feel like,

00:06:56.480 --> 00:06:58.480
Oh, I couldn't do this. It takes forever.

00:06:58.480 --> 00:06:59.780
I'm too old to get started.

00:06:59.780 --> 00:07:05.100
Yeah. Like you have to do this from it's, it's like a language learning. You can only do it when

00:07:05.100 --> 00:07:11.160
you're really young. And I, despite having a story where I did learn to code pretty young, I feel like

00:07:11.160 --> 00:07:16.660
it's important to emphasize. I screwed it up as hard as I could. And I really like squandered every

00:07:16.660 --> 00:07:24.420
opportunity to learn anything useful until I was at least 16. At which point I actually started to

00:07:24.420 --> 00:07:30.860
learn to code. I learned some C++, and then I learned some Java and started actually making games

00:07:30.860 --> 00:07:36.120
because it was pretty hard to do it without actually knowing how to do any of the coding part of coding.

00:07:36.120 --> 00:07:42.720
So I went from there where I was doing a bunch of kind of hobby projects and game development. I got a

00:07:42.720 --> 00:07:50.380
job at a small software company in New Jersey and had a terrible, terrible experience writing their

00:07:50.380 --> 00:07:57.760
flagship application in Java. We were reporting it from an old legacy, a database system to Java.

00:07:57.760 --> 00:08:06.480
And I went wrong with that experience. What didn't go wrong. It was a interesting lesson in depending on

00:08:06.480 --> 00:08:13.360
proprietary software you don't pay for. The major thing that went wrong was the Java runtime environment

00:08:13.360 --> 00:08:19.420
on the Mac at the time would leak about three quarters of a megabyte of memory every time you opened a

00:08:19.420 --> 00:08:25.200
window. And since this was a closed source runtime and our entire application was based around these

00:08:25.200 --> 00:08:31.840
windows that would open and close, you would lose just megabytes of memory at a time. And, it was

00:08:31.840 --> 00:08:39.620
many like as a cocky 19 year old, I didn't know anything about doing metrics or setting performance targets or

00:08:39.620 --> 00:08:43.740
anything like that. So we got several months into the project and I of course had been reassuring

00:08:43.740 --> 00:08:47.020
everyone the whole time, like, this is going to go great. This is going to be fantastic. It's going to

00:08:47.020 --> 00:08:52.820
be so much better. We got close to what should have been the end date of the project and it turned into

00:08:52.820 --> 00:08:58.240
frantic bug hunt, trying to figure out where these problems were coming from in our code. And it turned

00:08:58.240 --> 00:09:00.400
out they were coming from the Java runtime.

00:09:00.400 --> 00:09:05.040
Oh yeah. And so you're, you're thinking, what are we doing wrong? Let's, let's double check it one

00:09:05.040 --> 00:09:06.680
more time and there's nothing you can do, right?

00:09:06.680 --> 00:09:11.220
Right. It's never the compiler until one day it actually is the compiler. And then you're in a

00:09:11.220 --> 00:09:17.680
really bad situation. So I spent a while trying to debug that. I really, I did like Java as a

00:09:17.680 --> 00:09:23.820
programming language, but I left that job shortly thereafter, just because I felt like dying of shame

00:09:23.820 --> 00:09:28.280
after convincing everyone this is going to be great. And then, you know, that was a huge disaster.

00:09:28.780 --> 00:09:34.480
So as a formative experience that taught me that maybe I should be looking for systems that have an

00:09:34.480 --> 00:09:38.720
open source component, that if there's a horrible, horrible bug, I can kind of get down into the

00:09:38.720 --> 00:09:42.600
runtime and fix it myself. And that's one of the things that led me to discover Python.

00:09:42.600 --> 00:09:48.740
At the time between jobs, I was kind of working on this text adventure. Once again, this is a

00:09:48.740 --> 00:09:53.860
recurring theme in my program. I bet you're a fan of muds and these types of things.

00:09:53.860 --> 00:09:57.500
Oh yeah. No, I was definitely played one or two in my time.

00:09:57.500 --> 00:09:58.280
Nice. Me too.

00:09:58.280 --> 00:10:03.580
And so, yeah, so I was developing this thing and I had written it all in Java and it was a giant,

00:10:03.580 --> 00:10:12.480
massive multi-threading, like four or five threads per connection. This was, many of your listeners,

00:10:12.480 --> 00:10:17.640
I hope will be too young to remember this or will have blanked it out as a traumatic memory.

00:10:17.640 --> 00:10:22.520
But this was a time when there were, there was actually a marketing term, massively multi-threaded.

00:10:22.860 --> 00:10:25.840
This was like a good thing that you would be proud of that your code would do.

00:10:25.840 --> 00:10:34.420
And so this Java thing definitely qualified and it was full of just unfixable race conditions and bugs.

00:10:34.420 --> 00:10:41.900
So one of the things that the Python language had, which I didn't have exposure to in Java or any of

00:10:41.900 --> 00:10:48.080
my previous C++ work was the select module. And the select module, I discovered it first because we,

00:10:48.640 --> 00:10:54.660
one of the people who was helping me out with this was developing a kind of client server protocol.

00:10:54.660 --> 00:11:00.200
This was a mud with like a rich text front end so that it wasn't just a console.

00:11:00.200 --> 00:11:03.580
Graphics and background patterns and things like that.

00:11:03.800 --> 00:11:14.940
And so he was rewriting this communication layer with the client and he was tired of coordinating the five or six threads that got involved in the networking layer.

00:11:14.940 --> 00:11:25.740
And so he just wrote it to use the select module to detect which of the operations that we might need to do to the socket were available, read or write or error.

00:11:26.140 --> 00:11:30.840
And I had never seen such a thing before. And I thought to myself, that's interesting.

00:11:30.840 --> 00:11:33.620
So you could do like two or three things at a time, but without threads.

00:11:33.620 --> 00:11:37.680
And that's more or less where Twisted came from was I had started investigating that.

00:11:37.680 --> 00:11:42.320
And it ended up being a much simpler, less error prone way to develop apps.

00:11:42.320 --> 00:11:47.020
And so I fell in love with Python on many levels simultaneously.

00:11:47.020 --> 00:11:51.020
One of them was that it made that whole style of programming possible.

00:11:51.020 --> 00:11:58.120
Another was that it sort of was this thin foam padding around C that made it easier to distribute applications.

00:11:58.120 --> 00:12:00.780
And this thing's not sharp. It doesn't cut me anymore. Does it hurt?

00:12:01.240 --> 00:12:13.200
Exactly. Yes, it was. Physically, it didn't hurt. Actually, I was typing so many fewer lines of code in Python that I wasn't developing serious wrist pain or anything at the time.

00:12:13.200 --> 00:12:17.160
But like after a day of coding, I would feel it if I were writing in C++ or Java.

00:12:17.160 --> 00:12:22.680
And in Python, like it literally did not hurt me to code. So that was a pretty big upgrade.

00:12:22.680 --> 00:12:26.500
That's really good. That's cool. Yeah, that's an unexpected benefit.

00:12:27.260 --> 00:12:35.920
So I think this using things like IO ports and completion ports, this type of programming that's sort of asynchronous but not threaded.

00:12:35.920 --> 00:12:41.400
That's something that takes a while to run into maybe a little bit less these days.

00:12:41.400 --> 00:12:47.880
But certainly, it's really easy to jump into threading straight away and just think I need parallelism. Let's go create threads.

00:12:47.880 --> 00:12:54.340
It's kind of interesting how it depends where you come from, like different programming cultures, I think give different exposures to this.

00:12:54.340 --> 00:13:01.260
I actually did a PyCon talk a couple years ago called So Simple You Could Even Do It in JavaScript about event-driven programming.

00:13:01.260 --> 00:13:10.160
Because if you come from a background, not just of JavaScript, but of any kind of graphical user interface, event-driven programming is very natural.

00:13:10.160 --> 00:13:12.240
It just seems like something you do.

00:13:12.240 --> 00:13:14.240
Even like VB6 or something like that. Yeah.

00:13:14.240 --> 00:13:20.500
Right. Just because it's really clear when you're saying like on click, do X, on mouse down, do Y, right?

00:13:20.500 --> 00:13:22.840
Like those types of things make intuitive sense.

00:13:22.840 --> 00:13:26.000
The problem is when you're kind of in a back-end environment.

00:13:26.000 --> 00:13:30.220
You're talking to a database or you're doing some kind of transaction processing.

00:13:30.220 --> 00:13:33.580
And then you have to say on transaction complete.

00:13:33.580 --> 00:13:36.460
And you think to yourself, but wait a second, why can't I just block?

00:13:36.460 --> 00:13:38.400
Like this is kind of like a function call.

00:13:38.400 --> 00:13:40.560
And that's when thread seems really appealing.

00:13:40.620 --> 00:13:48.620
And if you've been developing things that way, then it just seems natural to keep developing them that way once you have concurrency.

00:13:48.620 --> 00:13:53.440
I do think that it's definitely kind of becoming more popular in that domain.

00:13:53.440 --> 00:14:04.460
But there are lots and lots of programmers that you might consider sort of novice or like not really or like non-programmers who can code, who actually take to it very easily.

00:14:04.460 --> 00:14:08.840
And so it's kind of an interesting piece of expertise that people pick up in odd ways.

00:14:08.840 --> 00:14:09.620
Yeah, I'm sure.

00:14:09.620 --> 00:14:16.620
And also the rise of JavaScript, the rise of Node.js, they really put that front and center like it's unavoidable.

00:14:16.620 --> 00:14:17.060
Exactly.

00:14:17.060 --> 00:14:20.840
And it's that same thing where you just say, you know, on click equals and then some code.

00:14:20.840 --> 00:14:22.800
And it intuitively makes sense.

00:14:22.800 --> 00:14:27.220
You don't have to explain that that's an event handler and, you know, the cascading model in JavaScript.

00:14:27.220 --> 00:14:30.720
You can learn a whole lot about handling events before you hear the word event.

00:14:30.720 --> 00:14:31.380
Yeah, for sure.

00:14:32.000 --> 00:14:36.080
So what do you do day to day for like professional work?

00:14:36.080 --> 00:14:41.280
I work at a startup that is started by one of your previous guests, I believe.

00:14:41.280 --> 00:14:42.640
Jessica McKellar.

00:14:42.640 --> 00:14:43.120
Okay.

00:14:43.120 --> 00:14:44.360
Is one of the founders.

00:14:44.360 --> 00:14:47.520
And we do bookkeeping.

00:14:47.520 --> 00:14:49.860
Actually, we're a bookkeeping service.

00:14:49.860 --> 00:14:52.060
Primarily, I think right now for startups.

00:14:52.060 --> 00:14:59.660
But the idea behind the company is there's lots of apps for doing your own bookkeeping like QuickBooks.

00:14:59.660 --> 00:15:03.620
We do the work of bookkeeping with software, though.

00:15:03.620 --> 00:15:06.060
So we can automatically classify transactions.

00:15:06.060 --> 00:15:09.380
And so our product is not software.

00:15:09.380 --> 00:15:10.880
It's your books.

00:15:10.880 --> 00:15:12.140
So awesome.

00:15:12.140 --> 00:15:12.420
Yeah.

00:15:12.420 --> 00:15:12.600
Yeah.

00:15:12.600 --> 00:15:13.420
That sounds really awesome.

00:15:13.520 --> 00:15:15.560
But of course, you know, we have some software behind the scenes.

00:15:15.560 --> 00:15:22.180
So since podcasts are a durable cultural artifact and our name is temporary, I will avoid saying our name.

00:15:22.180 --> 00:15:24.260
Hopefully we'll have a permanent one soon.

00:15:24.260 --> 00:15:26.860
Well, it sounds like a really noble goal.

00:15:27.800 --> 00:15:32.680
There are pretty decent bookkeeping bits of software like QuickBooks.

00:15:32.680 --> 00:15:34.500
I'm not sure I'm willing to judge it.

00:15:34.500 --> 00:15:37.280
FreshBooks, Invoiced, those types of things.

00:15:37.280 --> 00:15:44.060
But that doesn't solve the problem of like, hey, I would rather like do something technical and not force myself to become an accountant.

00:15:44.060 --> 00:15:44.420
Right?

00:15:44.420 --> 00:15:44.840
Yeah.

00:15:44.840 --> 00:15:47.800
We are bookkeeping for companies that don't want to worry about bookkeeping.

00:15:47.800 --> 00:15:48.280
Right.

00:15:48.280 --> 00:15:53.020
And we have a real focus on automation and trying to make things kind of seamlessly just work.

00:15:53.020 --> 00:15:53.420
Nice.

00:15:53.420 --> 00:15:54.640
That sounds really fun.

00:15:54.640 --> 00:15:56.660
Do you guys have like machine learning and stuff going on there?

00:15:56.840 --> 00:16:04.180
We have, I guess I could say we have proprietary machine intelligence, which might mean machine learning or might mean a pile of regexes.

00:16:04.180 --> 00:16:05.060
Who could say?

00:16:05.060 --> 00:16:05.360
Yeah, sure.

00:16:05.360 --> 00:16:06.140
Yeah, who could say?

00:16:06.140 --> 00:16:06.420
All right.

00:16:06.420 --> 00:16:06.700
Awesome.

00:16:06.700 --> 00:16:08.720
Well, it sounds like a really fun project.

00:16:08.720 --> 00:16:14.320
So we're going to talk about some, spend a little time on your PyCon talk.

00:16:14.320 --> 00:16:18.560
Now, this is the PyCon 2016 talk, but were you at the 2017 PyCon?

00:16:18.560 --> 00:16:19.380
I was.

00:16:19.380 --> 00:16:21.700
In fact, I spoke at the 2017 PyCon.

00:16:21.700 --> 00:16:22.300
That's right.

00:16:22.300 --> 00:16:22.600
That's right.

00:16:22.600 --> 00:16:22.820
I do.

00:16:22.820 --> 00:16:24.720
I also have, we're going to also talk about your talk there.

00:16:24.720 --> 00:16:26.080
How was that experience?

00:16:26.080 --> 00:16:26.620
What do you think?

00:16:26.620 --> 00:16:28.840
I mean, PyCon is always a highlight of the year.

00:16:28.840 --> 00:16:30.980
There's just so much stuff that goes on.

00:16:30.980 --> 00:16:33.440
I can't possibly consume all of it.

00:16:33.440 --> 00:16:38.480
One of the really interesting things about PyCon is for a technical conference that has like a really large number of tracks.

00:16:38.480 --> 00:16:46.240
And in fact, not only does it have a large number of tracks, but there's kind of an intentional scheduling thing they do where they will put high profile talks up against each other.

00:16:47.080 --> 00:16:53.080
So Corey Benfield, for example, gave a really good talk right at the same time as I did.

00:16:53.080 --> 00:16:54.640
So I didn't get to see his.

00:16:54.640 --> 00:16:54.880
Yeah.

00:16:54.880 --> 00:16:57.140
And that was inside requests or something like that, right?

00:16:57.140 --> 00:17:02.400
I believe that was, I always get mixed up which year it is, but yes, I think that was it this year.

00:17:02.400 --> 00:17:02.700
Okay.

00:17:03.460 --> 00:17:07.980
But there's so much stuff going on beyond just the talks.

00:17:07.980 --> 00:17:09.140
I mean, there's the summits.

00:17:09.140 --> 00:17:16.220
There's just an incredible hallway track where there's people doing open spaces and informal conversations.

00:17:16.220 --> 00:17:24.380
And it's a real opportunity for open source projects to get together and be strategic, which is not something that we get to do a lot in open source.

00:17:24.380 --> 00:17:47.820
But we get to sit down and see people from Twisted and Requests and AsyncIO and Flask and Jinja and Django, all in the same room, all kind of talking about the future of Python and how we're all going to add features to our various projects and things that we can work together on, standards we can collaborate on.

00:17:47.820 --> 00:17:52.840
And so there's so much stuff going on at PyCon, no matter what your level of skill is.

00:17:52.840 --> 00:17:54.540
There's a lot of new folks.

00:17:54.540 --> 00:18:03.940
Every year at PyCon, I learn something really interesting about some of the software that I work on from someone who's either never used it or who's just started using it for something really unusual.

00:18:03.940 --> 00:18:06.720
So I love hearing from those types of people as well.

00:18:06.720 --> 00:18:07.540
Yeah.

00:18:07.540 --> 00:18:09.340
So PyCon, always amazing.

00:18:09.340 --> 00:18:09.580
Yeah.

00:18:09.580 --> 00:18:10.940
I definitely look forward to it.

00:18:10.940 --> 00:18:12.520
I'm already looking forward to the next one.

00:18:12.520 --> 00:18:16.160
And it's like 49 weeks away or something, right?

00:18:16.160 --> 00:18:19.180
Just to start get a calendar, start checking them off or something.

00:18:19.500 --> 00:18:24.760
I really like what they do with the program committee where there are also a lot of new speakers every year.

00:18:24.760 --> 00:18:27.480
Like there are people sharing new and different perspectives.

00:18:27.480 --> 00:18:30.780
It's not, you know, obviously I give great talks.

00:18:30.780 --> 00:18:32.160
You should go see all of my talks.

00:18:32.160 --> 00:18:33.460
They're all archived.

00:18:34.200 --> 00:18:41.880
But it's not just me and Corey and Hinnick and Guido standing up every year and giving the same talk over and over again.

00:18:41.880 --> 00:18:55.200
It's like if we want to be, if the old timers want to get up on stage and say something, it's a very competitive environment because there are people talking about monitoring black holes with Python or...

00:18:55.960 --> 00:18:59.640
...innovating robots in factories or all sorts of stuff, right?

00:18:59.640 --> 00:19:00.020
Yeah.

00:19:00.020 --> 00:19:07.580
There's just so much, especially with the uptick in data science, there's so much science going on that has Python involved in it in some way.

00:19:07.580 --> 00:19:07.820
Yeah.

00:19:07.820 --> 00:19:08.340
That's interesting.

00:19:08.340 --> 00:19:14.560
It's probably going to only get more competitive in that there are more people and more disciplines it's pulling from.

00:19:14.560 --> 00:19:15.080
Exactly.

00:19:15.080 --> 00:19:16.940
And it's great to see that reflected.

00:19:16.940 --> 00:19:20.980
I like to say that Python is always the second best language for everything.

00:19:21.280 --> 00:19:35.020
So it's never quite the best thing you can reach for, but as soon as you need to do two things, suddenly it's the best language because you can't do machine learning and be a web server at the same time in any other language nearly as well.

00:19:35.020 --> 00:19:40.500
Unless you want to try to write it in R, which I hear is theoretically possible, but I'm not sure it's a good idea.

00:19:40.500 --> 00:19:41.100
Yeah.

00:19:41.100 --> 00:19:43.080
Well, it comes down to that same thing.

00:19:43.080 --> 00:19:47.220
I can guarantee you R is not the second best language for writing a web server.

00:19:47.220 --> 00:19:49.300
That's right.

00:19:49.300 --> 00:19:50.180
That's right.

00:19:50.180 --> 00:19:54.380
This portion of Talk Python to Me has been brought to you by Rollbar.

00:19:54.380 --> 00:19:58.080
One of the frustrating things about being a developer is dealing with errors.

00:19:58.080 --> 00:20:07.100
Relying on users to report errors, digging through log files, trying to debug issues, or getting millions of alerts just flooding your inbox and ruining your day.

00:20:07.100 --> 00:20:13.860
With Rollbar's full stack error monitoring, you get the context, insight, and control you need to find and fix bugs faster.

00:20:13.860 --> 00:20:17.840
Adding Rollbar to your Python app is as easy as pip install Rollbar.

00:20:18.280 --> 00:20:22.080
You can start tracking production errors and deployments in eight minutes or less.

00:20:22.080 --> 00:20:26.260
Are you considering self-hosting tools for security or compliance reasons?

00:20:26.260 --> 00:20:29.840
Then you should really check out Rollbar's compliant SaaS option.

00:20:29.840 --> 00:20:39.200
Get advanced security features and meet compliance without the hassle of self-hosting, including HIPAA, ISO 27001, Privacy Shield, and more.

00:20:39.560 --> 00:20:40.580
They'd love to give you a demo.

00:20:40.580 --> 00:20:42.280
Give Rollbar a try today.

00:20:42.280 --> 00:20:45.960
Go to talkpython.fm/Rollbar and check them out.

00:20:45.960 --> 00:20:56.560
I definitely want to touch on a few of your projects before we get into shipping software because you've got some popular projects and you've got to package them up and ship them.

00:20:56.560 --> 00:20:58.260
So maybe we could touch them.

00:20:58.260 --> 00:21:03.260
Like probably the best known one is Twisted and the stuff that's spun out from Twisted, right?

00:21:03.260 --> 00:21:08.040
I think that that will probably hound me to my grave is the most popular thing I've ever done.

00:21:08.040 --> 00:21:08.340
Yes.

00:21:10.040 --> 00:21:10.440
Yeah.

00:21:10.440 --> 00:21:11.560
You don't get a pick, right?

00:21:11.560 --> 00:21:12.960
Indeed, we do not.

00:21:12.960 --> 00:21:17.840
So maybe tell people what Twisted is for those people who don't know.

00:21:17.840 --> 00:21:22.960
Twisted is an event-driven programming system networking engine for Python.

00:21:22.960 --> 00:21:33.760
It's a thing that basically if things happen on the network or over the passage of time and you want to get a method called on your objects, as a result of that, Twisted can help you out.

00:21:33.760 --> 00:21:35.580
It's got web client and server.

00:21:35.580 --> 00:21:37.220
It's got an IMAP client and server.

00:21:37.220 --> 00:21:39.960
It's got a DNS client and server.

00:21:39.960 --> 00:21:41.880
It's got a whole bunch of protocols implemented.

00:21:41.880 --> 00:21:50.020
And it's also got a lot of stuff that lets you kind of combine asynchronous control flows in various interesting ways.

00:21:50.020 --> 00:21:53.500
It's kind of almost the original framework for this.

00:21:53.500 --> 00:21:58.040
I hesitate to say that because there are a lot of precursors that Twisted drew from.

00:21:58.040 --> 00:22:02.960
But a lot of those precursors were much more special-cased and kind of purpose-specific.

00:22:03.400 --> 00:22:13.460
Whereas Twisted, like the concept of a deferred originally came from Twisted and deferreds eventually moved kind of front-end into JavaScript and eventually deferreds became promises.

00:22:13.460 --> 00:22:17.820
And promises are obviously a very popular thing for JavaScript developers to use these days.

00:22:18.560 --> 00:22:21.680
So Twisted is both new and dynamic.

00:22:21.680 --> 00:22:23.720
There's lots of interesting stuff going on in that community.

00:22:23.720 --> 00:22:26.700
Lots of modern practices being adopted.

00:22:26.700 --> 00:22:33.480
But it's also very kind of venerable and pretty old as a non-legacy technology goes.

00:22:33.480 --> 00:22:34.100
Yeah.

00:22:34.100 --> 00:22:40.580
It was definitely one of the original ways to write this style program that you talked about in the beginning,

00:22:40.580 --> 00:22:45.660
where it's kind of IO completion port, not just 100 threads running next to each other, right?

00:22:45.720 --> 00:22:50.560
Right. And one of the things we did, we actually presented a paper at Usenix at the very beginning of the Twisted project,

00:22:50.560 --> 00:22:55.640
talking about the need for kind of a high-level interface to things like IO completion ports.

00:22:55.640 --> 00:23:00.780
Because at the time, FreeBSD was adding KQ, and Linux was starting to add ePoll,

00:23:00.780 --> 00:23:05.360
and Solaris had its own high-performance multiplexing mechanism.

00:23:05.360 --> 00:23:06.440
But of course...

00:23:06.440 --> 00:23:08.640
You guys are like, stop the madness. We can't have all of these.

00:23:08.640 --> 00:23:11.260
Well, actually, we were kind of almost saying the opposite.

00:23:11.260 --> 00:23:15.000
We were like, this is great, all these hyper-optimized, low-level kernel things.

00:23:15.000 --> 00:23:18.500
And I guarantee you, no one will ever write an application to talk to one of these.

00:23:18.500 --> 00:23:21.920
You're going to get the three biggest servers out there to do it,

00:23:21.920 --> 00:23:27.180
and then no other app will ever be able to take advantage of your custom kernel special thing.

00:23:27.180 --> 00:23:33.720
We need a way for apps to write against a common API so that when the kernel goes off and does some crazy new thing,

00:23:33.720 --> 00:23:37.540
we can actually use it without having to rewrite all of our code from scratch.

00:23:37.540 --> 00:23:45.800
So there was definitely an element of stop the madness from the perspective of stop putting all of these new .h files that I have to include.

00:23:45.800 --> 00:23:48.020
Like, they're not helping me.

00:23:48.020 --> 00:23:48.940
Yeah, yeah.

00:23:48.940 --> 00:23:49.920
It sounds really interesting.

00:23:49.920 --> 00:23:53.480
So Twisted's still going strong, huh?

00:23:53.480 --> 00:23:55.880
People are still doing interesting new things with it?

00:23:55.940 --> 00:23:56.780
Oh, yeah, absolutely.

00:23:56.780 --> 00:24:00.980
One of the interesting things about it, which I did predict when AsyncIO came out,

00:24:00.980 --> 00:24:04.300
there were a lot of people who don't like Twisted for one reason or another

00:24:04.300 --> 00:24:08.080
and who were sort of sharpening their knives when AsyncIO came out.

00:24:08.080 --> 00:24:09.080
And they were like, oh, great.

00:24:09.080 --> 00:24:11.040
Now, you know, we don't have to use Twisted anymore.

00:24:11.040 --> 00:24:12.180
It's like, it's true.

00:24:12.180 --> 00:24:14.220
If you don't like Twisted, there's like more options now.

00:24:14.220 --> 00:24:19.920
But there was a sense among many people that it was going to kind of be the doom of Twisted.

00:24:19.920 --> 00:24:22.300
Oh, now there's this event loop in the standard library.

00:24:22.300 --> 00:24:30.920
But one of the interesting things that came out of that was that event loop is just one small piece of what Twisted did.

00:24:30.920 --> 00:24:36.440
And we did not want to have to be the kind of standard bearers for all event-driven programming in Python.

00:24:36.440 --> 00:24:46.460
We wanted to provide like a nice little suite of protocols that all work together nicely and like tools to help you with testing and like generally be like a framework.

00:24:46.460 --> 00:24:53.480
But it would sort of be like if Django, let's say, were the only way to speak HTTP from Python.

00:24:53.480 --> 00:24:58.680
And one day somebody came out with a second web server or there was like a web server in the standard library.

00:24:58.680 --> 00:24:59.460
Yeah, watch out.

00:24:59.460 --> 00:25:00.460
There's a bottle now.

00:25:00.460 --> 00:25:02.640
Everyone's going to just stop using Django.

00:25:02.640 --> 00:25:03.260
Exactly.

00:25:03.260 --> 00:25:06.620
It's like, no, Django does like one or two other things that you might want to do.

00:25:06.620 --> 00:25:07.780
And Twisted's the same way.

00:25:07.780 --> 00:25:10.320
We've actually seen a big uptick in activity and interest.

00:25:10.320 --> 00:25:12.800
A lot of other people starting to pick up Twisted.

00:25:12.800 --> 00:25:16.280
Because for a long time there was a vacuum in the standard library.

00:25:16.280 --> 00:25:20.160
It really wasn't clear how Python was going to do concurrency.

00:25:20.160 --> 00:25:25.780
And now that the answer is like async await, event-driven I.O., that's what's coming.

00:25:25.780 --> 00:25:26.420
That's the future.

00:25:26.420 --> 00:25:27.140
It's like, oh, okay.

00:25:27.140 --> 00:25:30.000
Well, Twisted's been in the future for the last 15 years.

00:25:30.000 --> 00:25:31.100
That's cool.

00:25:31.100 --> 00:25:38.240
Are you thinking of, or can you already like access it in Python 3 with like async and await type programming models?

00:25:38.240 --> 00:25:38.680
Oh, yeah.

00:25:38.680 --> 00:25:39.420
No, we support.

00:25:39.420 --> 00:25:44.260
So I believe we've been adding new features every release for the last couple of years.

00:25:44.260 --> 00:25:46.220
I'm not sure exactly where everything landed.

00:25:46.220 --> 00:25:58.840
But in 17.5, which is a release that just came out, I believe, yesterday, we have full support for converting deferreds into futures and creating futures from deferreds.

00:25:59.440 --> 00:26:06.940
So not only can you use async await, which you've been able to do for a while with Twisted, you can even use Twisted in the middle of an async I.O. app.

00:26:06.940 --> 00:26:11.360
You can switch to use some Twisted library code and then switch back anytime you want.

00:26:11.360 --> 00:26:13.760
So it fully integrates at every layer.

00:26:13.760 --> 00:26:14.880
Oh, that's awesome.

00:26:15.200 --> 00:26:17.940
It's got coroutine support for interacting with futures.

00:26:17.940 --> 00:26:19.800
It's got event loop support.

00:26:19.800 --> 00:26:21.980
It's got an async I.O. reactor that you can use.

00:26:21.980 --> 00:26:24.620
So you can map Twisted's event loop on top of async I.O.

00:26:24.620 --> 00:26:33.360
There's TXTULIP, which is a third-party thing that's been able to do this for a really long time, even before Tulip became async I.O.

00:26:33.400 --> 00:26:34.620
and got it at the standard library.

00:26:34.620 --> 00:26:39.760
So we've been really – I mean, Twisted has always been a very integration-focused project.

00:26:39.760 --> 00:26:45.000
I mean, we speak gross, difficult protocols like IMAP, so you don't have to.

00:26:45.920 --> 00:26:49.140
And, you know, we do the low-level plumbing so you don't have to, too.

00:26:49.140 --> 00:26:51.000
Yeah, that sounds really, really nice.

00:26:51.000 --> 00:26:54.080
So two quick comparison questions.

00:26:54.080 --> 00:27:03.320
First of all, what do you think of some of the new frameworks coming out, like UVLoop and things like Sanic and Jopronto and those efforts there?

00:27:03.320 --> 00:27:08.620
I mean, I think it's great that everybody's learning this new paradigm and doing cool little experiments with it.

00:27:08.620 --> 00:27:22.140
I do think that there is maybe a slightly odd perspective where people are looking at something like Sanic, which is brand new and kind of named after a weird meme,

00:27:22.140 --> 00:27:27.640
to be equally kind of feature-complete and robust as something like Twisted.

00:27:27.640 --> 00:27:37.120
And I think that in many cases, like, the comparison is almost unfair because, like, it's not like Sanic comes with its own DNS server, right?

00:27:37.200 --> 00:27:41.880
Like, there's a lot more stuff in the Twisted ecosystem and in the Twisted core.

00:27:41.880 --> 00:27:46.680
I think both those projects, personally, I think they're pretty interesting and they look very promising.

00:27:46.680 --> 00:27:50.360
But I don't feel like they're close to ready yet.

00:27:50.360 --> 00:27:52.740
Yeah, I think that, I mean, they're certainly ready for some things.

00:27:52.740 --> 00:27:55.140
And I wouldn't want to discourage people from trying them out.

00:27:55.140 --> 00:27:58.480
But I also think that it's important to kind of calibrate your expectations.

00:27:58.480 --> 00:28:04.460
I mean, there are many things that Twisted still doesn't do right after 15 years of trying to do this.

00:28:05.140 --> 00:28:12.640
And so I think that there's also, like, Curio and Trio, like, weird new event loop models that people are experimenting with.

00:28:12.640 --> 00:28:13.720
Yeah, that was my second question.

00:28:13.720 --> 00:28:23.640
Like, Curio also sounds a little bit similar to Twisted in that it's trying to really be the loop and, you know, talk different protocols in the network and stuff like that.

00:28:23.820 --> 00:28:29.860
I mean, I think that the idea behind Curio and Trio was kind of to invent a new style of programming.

00:28:29.860 --> 00:28:33.820
And Twisted has this kind of unofficial policy of no new ideas.

00:28:33.820 --> 00:28:36.600
We don't implement anything, like, novel or original.

00:28:36.600 --> 00:28:49.000
Everything that Twisted does at a kind of fundamental level is something that my dad was doing on Stratus mainframes with, in C, in, like, the 80s and 90s.

00:28:49.500 --> 00:29:02.680
So, you know, we are not as focused on kind of being a research platform, which means that, you know, there's kind of less interesting new agey stuff in Twisted that might spark an interesting research direction.

00:29:02.680 --> 00:29:07.520
But it also means that you can kind of let Twisted be boring and make your application be the interesting part.

00:29:07.520 --> 00:29:10.240
Yeah, well, sometimes boring is good if you're building on top of it.

00:29:10.240 --> 00:29:11.060
That is our hope.

00:29:11.880 --> 00:29:12.240
Nice.

00:29:12.240 --> 00:29:12.520
All right.

00:29:12.520 --> 00:29:16.720
So you want to just maybe touch a little bit on some of your other projects that you want to mention?

00:29:16.720 --> 00:29:18.640
And then we can talk about shipping software.

00:29:18.640 --> 00:29:19.220
Sure.

00:29:19.220 --> 00:29:24.940
I mean, a couple that I think are always need to be mentioned in the same breath as Twisted are Klein and Trek.

00:29:24.940 --> 00:29:26.820
Klein is like Flask, but for Twisted.

00:29:26.820 --> 00:29:28.740
Trek is like Requests, but for Twisted.

00:29:28.740 --> 00:29:32.480
They're a little bit different than Flask and Requests in certain ways.

00:29:33.320 --> 00:29:43.380
But if you want to build like a kind of standard service-oriented app or like a little web app with Twisted in an event-driven way, those are pretty much almost required.

00:29:43.380 --> 00:29:43.840
Right.

00:29:43.840 --> 00:29:54.280
Because you're going to need to not just listen on HTTP, like Twisted, the web server that comes with Twisted, you should think of like as a competitor to Apache or Nginx, not Django or Flask.

00:29:54.540 --> 00:30:02.440
It's a web server and it's designed to be, the API that it offers is designed to be kind of like a configuration language for composing resources together.

00:30:02.440 --> 00:30:04.920
Whereas like Klein is an app platform.

00:30:04.920 --> 00:30:07.340
You can write a little server with it.

00:30:07.980 --> 00:30:12.600
And then there's also TX Acme, which is based.

00:30:12.600 --> 00:30:27.140
So I made a project called TX S&I, which was just sort of designed to make it easy to dump your SSL certificates into files without caring what order the private key and the chain certificate and the nine other things you seem to need to dump into a SSL configuration.

00:30:27.140 --> 00:30:32.760
You could just kind of put them all in a file in any order and call it like your domain.pem and it would automatically get loaded.

00:30:33.460 --> 00:30:38.640
And then Tristan Seligman built on top of that with TX Acme, which is a Let's Encrypt implementation for Twisted.

00:30:38.640 --> 00:30:49.860
So you can just like combine those three things and get a service that automatically listens on an SSL port, automatically provisions the certificate and gives you nice async server and client web APIs.

00:30:49.860 --> 00:30:52.020
Oh, that sounds like a fun set of building blocks.

00:30:52.020 --> 00:30:54.060
So yeah, so those are the ones you should definitely check out.

00:30:54.060 --> 00:31:03.280
We've also been trying to make an effort to move some of the data structures that Twisted uses that have nothing to do with event-driven programming, that are just kind of useful Python library functionality, out.

00:31:03.280 --> 00:31:10.780
So Mahmoud Hashemi recently extracted our URL object into a project called Hyperlink.

00:31:10.780 --> 00:31:20.320
And Hyperlink got adopted partially as part of that inter-project communication and collaboration that I mentioned at PyCon into the Python HyperOrg.

00:31:20.320 --> 00:31:28.120
The name and the fact that the org is called Hyper are just kind of a coincidence, but people I'm sure are going to assume that it's called Hyperlink because it was made by Hyper.

00:31:28.820 --> 00:31:43.120
But that's a really handy object if you need to parse URLs like a web browser does, like dealing with Unicode and all the different places that Unicode can show up and parsing percent escaped stuff into human readable text.

00:31:43.120 --> 00:31:45.220
That's a handy library to have.

00:31:45.220 --> 00:31:46.000
That sounds nice.

00:31:46.000 --> 00:31:52.940
And that's the kind of stuff you don't want to mess with, with weird escapes people can do to get around security and all sorts of stuff, right?

00:31:53.020 --> 00:31:56.280
Oh, yeah, you can find slashes in all kinds of strange places.

00:31:56.280 --> 00:32:00.900
And yeah, Hyperlink, it's because it kind of parses like a browser does.

00:32:00.900 --> 00:32:08.180
It lets you do all kinds of interesting stuff, like interesting transformations where you can say there's like a click method that'll take a URL and give you a new URL.

00:32:08.300 --> 00:32:21.440
It's like a link to the URL, which is the kind of thing where if you like doing web crawling or, you know, indexing web documents, it's the sort of thing you have to be able to do a lot.

00:32:21.440 --> 00:32:23.680
So, but there's a couple others.

00:32:23.680 --> 00:32:35.900
There's also incremental, which is we have a version object in Twisted because we were very concerned with backward compatibility and long term support for various things that you need to be able to track versions.

00:32:35.900 --> 00:32:38.040
So we spun that out to a different library.

00:32:38.040 --> 00:32:41.860
It's also eventually, which is because we're concerned about compatibility.

00:32:41.860 --> 00:32:45.460
Compatibility means you need to have deprecations.

00:32:45.460 --> 00:32:52.940
And so eventually is a library for deprecating stuff and eventually removing it, which is where it comes from.

00:32:52.940 --> 00:32:54.440
Yeah, I really like that project.

00:32:54.440 --> 00:33:05.440
Yeah, we're hoping it becomes a little more popular because like in such a high level dynamic language as Python, you need to be kind of disciplined about making sure that you communicate to your users like, hey, this is going away.

00:33:05.440 --> 00:33:07.100
It's going to stop working in so many versions.

00:33:07.100 --> 00:33:10.840
And like this is perhaps segwaying into our main topic here.

00:33:10.840 --> 00:33:21.240
It's important to be able to do that because you want people to be if they're packaging applications, including your stuff, if it's part of their requirements that text, you want them to be able to upgrade regularly.

00:33:21.460 --> 00:33:27.560
But you also want them to know how much technical debt they've got pending and like how much work they have to do before they can upgrade again.

00:33:27.560 --> 00:33:28.000
Yeah.

00:33:28.000 --> 00:33:33.280
And you don't have the compiler with a, you know, a deprecated flag right there.

00:33:33.280 --> 00:33:33.540
Right.

00:33:33.620 --> 00:33:37.460
And so you basically have this runtime thing that does something similar, which is cool.

00:33:37.460 --> 00:33:37.960
Exactly.

00:33:37.960 --> 00:33:38.380
Yeah.

00:33:38.380 --> 00:33:38.680
Nice.

00:33:38.680 --> 00:33:40.160
Hey, everyone.

00:33:40.160 --> 00:33:40.580
This is Michael.

00:33:40.580 --> 00:33:41.980
Let me tell you about Datadog.

00:33:41.980 --> 00:33:43.140
They're sponsoring this episode.

00:33:43.140 --> 00:33:47.120
Performance and bottlenecks don't exist just in your application code.

00:33:47.120 --> 00:33:49.960
Modern applications are systems built upon systems.

00:33:49.960 --> 00:33:53.160
And Datadog lets you view the system as a whole.

00:33:53.400 --> 00:33:55.500
Let's say you have a Python web app running Flask.

00:33:55.500 --> 00:34:00.780
It's built upon MongoDB and hosted and scaled out on a set of Ubuntu servers running Nginx and MicroWSGI.

00:34:00.780 --> 00:34:05.800
Add Datadog and you can view and monitor and even get alerts across all of these systems.

00:34:05.800 --> 00:34:09.760
Datadog has a great getting started tutorial that takes just a few moments.

00:34:09.760 --> 00:34:13.260
And if you complete it, they'll send you a sweet Datadog t-shirt for free.

00:34:13.260 --> 00:34:14.200
Don't hesitate.

00:34:14.200 --> 00:34:18.320
Visit talkpython.fm/Datadog and see what you've been missing.

00:34:18.320 --> 00:34:20.940
That's talkpython.fm/Datadog.

00:34:22.360 --> 00:34:32.720
You gave a really nice talk and you structured it in the form of a play, more or less, at PyCon 2016 called Shipping Software to Users with Python.

00:34:32.720 --> 00:34:35.140
And this is something I'm also super passionate about.

00:34:35.140 --> 00:34:45.680
And I feel like we've seen the growth curves of Python really, really taking off and, surprisingly, even in the last few years, becoming much more popular than it was.

00:34:45.680 --> 00:34:52.000
But I think if we had a better deployment story, it would even be steeper, that curve.

00:34:52.320 --> 00:34:53.020
I totally agree.

00:34:53.020 --> 00:35:04.420
And this is one of the reasons that I wanted to write that talk in the first place was that I was and am really passionate about Python being available to people kind of where they are.

00:35:04.680 --> 00:35:12.140
One of the things that drove me to talk about deployment is it's cool that Python's usable as a web service thing.

00:35:12.140 --> 00:35:18.560
It's certainly been a huge driver of economic activity and scientific discovery in that kind of role.

00:35:18.940 --> 00:35:27.260
But there's also something just tremendously empowering about being able to program your own computer and make it do useful stuff for you.

00:35:27.260 --> 00:35:27.660
Yeah.

00:35:27.760 --> 00:35:37.420
And the problem with having a kind of broken deployment story is it seems like a kind of arcane technical solution, system deployment or application packaging.

00:35:37.420 --> 00:35:44.040
But when you think about it, it's really just like some fifth grader makes a hilarious guess the number game.

00:35:44.460 --> 00:35:46.620
And then they want to share it with their friend.

00:35:46.620 --> 00:35:49.020
Like what do they do at that point?

00:35:49.020 --> 00:35:51.880
They go to their friend's house and they set up their machine to run it.

00:35:51.880 --> 00:35:52.080
Right.

00:35:52.080 --> 00:35:52.540
Exactly.

00:35:52.540 --> 00:35:56.060
They take their laptop over there because that's all you can do these days.

00:35:56.420 --> 00:36:05.480
And so that often drives educators away from Python because if they do it in Java or they do it in – so in Java, it's a little bit weird.

00:36:05.480 --> 00:36:10.100
You often have like a strange runtime environment that all the students have to set up.

00:36:10.100 --> 00:36:13.440
But if it's in JavaScript, they just load the web page and there it is, right?

00:36:13.440 --> 00:36:13.920
Yep.

00:36:13.920 --> 00:36:18.040
And Swift is making inroads there as well with their playgrounds and all that kind of stuff as well.

00:36:18.040 --> 00:36:18.640
Exactly.

00:36:18.640 --> 00:36:23.720
And Swift is as amazing as playgrounds are and there's a lot to like about them.

00:36:24.060 --> 00:36:38.080
It's almost the thing that I was – it's sort of the nightmare scenario that I'm afraid of, which is why I really think we should get our deployment story together in the Python community, which is that it kind of draws this line between technical people and non-technical people.

00:36:38.080 --> 00:36:41.100
And if you're like a real programmer, you ship to the app store.

00:36:41.100 --> 00:36:45.100
And if you're just playing around, you use playgrounds.

00:36:45.100 --> 00:36:52.140
And that dichotomy creates this sense that people are not empowered to do like real programming or make real apps.

00:36:52.900 --> 00:36:55.500
And I think there's two sides to that.

00:36:55.500 --> 00:37:02.040
Apple's also done quite a bit to reduce the barrier to entry on shipping software into the app store.

00:37:02.040 --> 00:37:03.760
It's a lot less expensive than it used to be.

00:37:03.760 --> 00:37:05.400
It's a lot less effort than it used to be.

00:37:05.400 --> 00:37:10.360
But it is still this hurdle that, for example, kids are just never going to get over.

00:37:10.500 --> 00:37:23.380
Whereas when I was learning to program as a kid, the sense that grown-up professional, serious software company like Broderbund could make something and put it on floppy disks and then you could do the same thing was very powerful.

00:37:23.380 --> 00:37:29.580
It was really – it gave you a sense that you could do something real in a way that kids don't get to experience in a lot of different levels.

00:37:29.780 --> 00:37:36.060
Like if a kid wants to be a doctor when they grow up, they can't like kind of do some surgery just to try it out, right?

00:37:36.060 --> 00:37:38.200
But as programmers –

00:37:38.200 --> 00:37:38.320
That's right. We hope not.

00:37:38.320 --> 00:37:39.600
Exactly.

00:37:40.080 --> 00:37:48.960
But as programmers, you know, we have this luxury of the safety of being able to potentially make something that's like real and useful and shareable.

00:37:48.960 --> 00:37:51.620
But if deployment doesn't work, you don't get any of that.

00:37:51.620 --> 00:37:52.740
Yeah. Yeah, absolutely.

00:37:52.740 --> 00:38:06.940
And on the other end of the spectrum, if you go to the pro places and you say, let's write some – especially like the one that really strikes me is, let's write a GUI app in Python that we're going to ship around, right?

00:38:06.940 --> 00:38:12.500
Like it certainly is possible and we'll talk about some of the tools that you can do it with.

00:38:12.500 --> 00:38:19.660
But it's not as easy as some of the other here's the thing I compiled and you just take it and it just runs stories.

00:38:19.660 --> 00:38:22.080
Right. It's really not very streamlined.

00:38:22.080 --> 00:38:25.520
And it is getting better, but again, I guess we can talk about how.

00:38:25.520 --> 00:38:26.680
Yeah, yeah, absolutely.

00:38:26.680 --> 00:38:31.700
So you said that you had your talk sort of focused in different areas.

00:38:31.700 --> 00:38:40.500
Like you were focused on maybe the people that create libraries, the people who run stuff in the cloud, like web developer types.

00:38:40.980 --> 00:38:50.620
And then this third one where we talk about either from a kid perspective, like learning or from a pro perspective, shipping stuff to end users, right?

00:38:50.620 --> 00:38:53.360
Was that basically the three areas you were focusing on?

00:38:53.360 --> 00:38:54.200
More or less, yeah.

00:38:54.200 --> 00:39:03.940
I mean I also talked a little bit about the people maintaining the infrastructure in Python, but that's kind of more of a like telling them to consider those other three perspectives.

00:39:04.260 --> 00:39:10.880
Right. Okay. So you went through some of the stuff that you can do for the server side and that's pretty straightforward.

00:39:10.880 --> 00:39:12.280
Like we can make packages.

00:39:12.280 --> 00:39:16.680
We can use things like Twine and ship those up to PyPI.

00:39:16.680 --> 00:39:18.900
We can package them as wheels.

00:39:18.900 --> 00:39:20.540
We have requirements.txts.

00:39:20.540 --> 00:39:21.480
Like that kind of stuff.

00:39:21.480 --> 00:39:27.280
I don't know. It's super clean, but it certainly works well once you get used to it.

00:39:27.280 --> 00:39:31.640
Like I've had a few people who are learning Python web development come to me and say, this is all really hard.

00:39:31.640 --> 00:39:32.900
How do I make this stuff work?

00:39:32.900 --> 00:39:33.760
Like I don't know what to do.

00:39:33.760 --> 00:39:38.300
So maybe it's not hard, but it, and you kind of touched on that.

00:39:38.300 --> 00:39:41.620
It's like, it's confusing or not clear what the steps are.

00:39:41.620 --> 00:39:49.480
Yeah. One of the problems is, you know, we actually have a fair amount of documentation at this point, except there's so much of it now.

00:39:49.480 --> 00:39:53.240
We trip over our own feet trying to explain to users how to do this kind of stuff.

00:39:53.240 --> 00:40:00.160
And so you end up with something where it's like, it's actually pretty straightforward to assemble a Docker container, let's say.

00:40:00.560 --> 00:40:10.360
But you'll find so many half written tutorials and there's so many concepts and so many separate tools that you have to chain together that most people do not end up on the fast path.

00:40:10.360 --> 00:40:14.400
They do not end up just doing the one thing that's going to be easy for them.

00:40:14.480 --> 00:40:24.140
And I think that that's getting a little bit better in terms of like what things people are linking to and what you happen to find just thanks to PageRank kind of finding the better articles over time.

00:40:24.140 --> 00:40:27.020
But yeah, it's starting to stabilize a little bit as well.

00:40:27.260 --> 00:40:30.640
Yeah, it's definitely been a long slog to get here, though.

00:40:30.640 --> 00:40:32.620
And where we are is definitely not ideal.

00:40:32.620 --> 00:40:41.100
One of the points I think that I didn't make in the talk that's probably worth talking about is that Python is not a deployment platform.

00:40:41.100 --> 00:40:50.180
And so everything that we do, the things that I talked about in the talk, the things that we're talking about now, distutils, setup.py, virtualenv, right?

00:40:50.180 --> 00:40:53.360
These are mostly developer tools.

00:40:53.540 --> 00:40:58.720
They're for assembling the software into some shape, but they're not really for shipping it.

00:40:58.720 --> 00:41:07.640
And one of the reasons that Cloud Python has gotten a lot better is that most of the assumption about where you're deploying your stuff is shifting towards containers.

00:41:07.640 --> 00:41:11.440
And Docker is a deployment platform.

00:41:11.440 --> 00:41:17.100
That is a system with like a pretty clear contract of what goes into a software artifact.

00:41:17.100 --> 00:41:18.420
Like it's a Docker image.

00:41:18.420 --> 00:41:19.520
That's it.

00:41:19.520 --> 00:41:21.040
There are really no other options.

00:41:21.040 --> 00:41:22.500
How do you run it?

00:41:22.580 --> 00:41:23.640
Well, it's got an entry point.

00:41:23.640 --> 00:41:24.760
And that's it.

00:41:24.760 --> 00:41:27.420
Like there's a couple of things you might need to document.

00:41:27.420 --> 00:41:35.360
I have a whole separate series of blog posts and stuff about type system for Docker and how it needs to be more expressive.

00:41:35.360 --> 00:41:40.620
But basically, if you hand an ops person a Docker image, they more or less know what to do with it.

00:41:40.620 --> 00:41:44.640
It's a clear integration point between Python people and systems people.

00:41:45.140 --> 00:41:52.520
And the tools that we have at our disposal, like pip, like distutils, like virtualenv, make sense in that context.

00:41:52.520 --> 00:41:57.440
And we can pretty easily script them to do the right thing to build a Docker image.

00:41:57.920 --> 00:42:01.360
But Docker is just one deployment platform.

00:42:01.360 --> 00:42:15.400
And the problem is we need tools that deploy Python to multiple different deployment targets and not try to come up with a quote unquote Python deployment target that is universal and works.

00:42:15.860 --> 00:42:24.480
Right. Like, for example, in the GUI space, just because you get a Docker container and you can ship that to end users and go, now run the Docker container.

00:42:24.480 --> 00:42:26.720
Right. There's no Docker run on my iPhone.

00:42:26.720 --> 00:42:27.240
Right.

00:42:27.240 --> 00:42:28.260
Yeah, exactly.

00:42:28.780 --> 00:42:30.780
That shows up in a couple of different places.

00:42:30.780 --> 00:42:35.240
I mean, there's any kind of GUI front end thing suffers from this.

00:42:35.240 --> 00:42:40.080
Like the GUI front end stuff just can't be shipped in that style.

00:42:40.080 --> 00:42:43.900
But also it can't be as easily shipped with shell scripts.

00:42:43.900 --> 00:42:44.140
Right.

00:42:44.140 --> 00:42:53.920
The reason Docker works so nicely with the Python tool chain is that most of the things that we've sort of been building up from are a combination of dependency on some Linuxy,

00:42:54.040 --> 00:43:00.640
type tools that are the low level stuff and then a script to assemble them into a coherent, like runnable shape.

00:43:00.640 --> 00:43:06.120
And that's pretty easy to do in Docker, but that's a lot harder to do on, let's say, Windows.

00:43:06.120 --> 00:43:06.600
Right.

00:43:06.600 --> 00:43:11.880
Where ultimately you're just trying to get a P executable or zip file together.

00:43:11.880 --> 00:43:19.020
But the process you need to go through to do that in order to, like, integrate with the Windows compiler and all of that stuff,

00:43:19.300 --> 00:43:25.440
you actually kind of have to know about those tools and you can't just, like, write a little script and copy some binaries around.

00:43:25.440 --> 00:43:26.100
Right, right.

00:43:26.100 --> 00:43:29.380
The system's got to be, like, in a place to receive it in the first place.

00:43:29.380 --> 00:43:29.960
Exactly.

00:43:29.960 --> 00:43:30.380
Yeah.

00:43:30.380 --> 00:43:34.960
So you kind of taunted the audience a little bit with this thing you called pip.app.

00:43:34.960 --> 00:43:36.900
And you're like, okay, here's how we're going to deploy it.

00:43:36.900 --> 00:43:38.480
We're going to run this thing called pip.app.

00:43:38.480 --> 00:43:41.080
We're going to select our program.

00:43:41.080 --> 00:43:42.280
We're going to select our dependencies.

00:43:42.280 --> 00:43:46.640
We'll, you know, choose the operating system and we'll just package this puppy up, right?

00:43:46.640 --> 00:43:47.060
Yeah.

00:43:47.120 --> 00:43:48.780
And why can't we have it, right?

00:43:48.780 --> 00:43:52.680
Like, this seems like a kind of almost obvious tool.

00:43:52.680 --> 00:44:02.280
But it's, I think that one of the reasons that nobody's made such a thing is that it's, you have to care a lot about the general case.

00:44:02.280 --> 00:44:05.820
And you have to care a lot about the end user experience.

00:44:05.820 --> 00:44:10.720
And in the kind of open source world to scratch your own itch, you're never that end user, right?

00:44:10.720 --> 00:44:15.300
You've already gotten to some point that's further down the line than just, like, I don't know what Python is.

00:44:15.700 --> 00:44:29.360
But if we were thinking about making this in, like, a 1990s style desktop app where, like, a user finds your floppy disks in the store and can't talk to you after that, like, you'd better make it work just from the beginning.

00:44:29.360 --> 00:44:36.080
And if we thought about it more like that, I think that people would end up having to Google for those confusing virtual end articles a lot less often.

00:44:36.080 --> 00:44:41.640
And, you know, part of the problem is just that we don't have that many volunteers who are working on this stuff.

00:44:41.640 --> 00:44:44.800
I think you're touching on a super important point.

00:44:44.800 --> 00:44:48.100
And I've spoken to several people about this.

00:44:48.100 --> 00:45:01.880
Like, you know, I sort of opened this section by saying if we could get the deployment, especially the client side UI style deployment better, it would just open up an entire new avenue of growth for Python and where we could really leverage apps.

00:45:01.880 --> 00:45:05.880
And I was talking to somebody and said, look, this is a problem that is super important we need to solve.

00:45:05.960 --> 00:45:09.860
And I said, well, it's just not a thing that I find people who do Python do very often.

00:45:09.860 --> 00:45:10.980
We don't run into this problem.

00:45:10.980 --> 00:45:16.480
And we don't run into this problem because it's so hard that we don't even consider doing this most of the time, right?

00:45:16.480 --> 00:45:17.060
Exactly.

00:45:17.060 --> 00:45:20.680
And it's really kind of sad because, in fact, it's not that hard.

00:45:20.680 --> 00:45:24.580
And, like, 80% solutions exist for so many of these problems.

00:45:24.580 --> 00:45:24.900
Yeah.

00:45:24.900 --> 00:45:29.040
I mean, Dropbox is on, like, they always have that huge number.

00:45:29.040 --> 00:45:32.780
I'm not sure what it is, like 10 billion computers or something.

00:45:32.780 --> 00:45:34.680
They're running everywhere.

00:45:35.200 --> 00:45:36.960
And that's a Python desktop app.

00:45:36.960 --> 00:45:41.660
So clearly it's not going to, you know, wreck your company if you decide to use Python.

00:45:41.660 --> 00:45:44.780
You know, they had to do some work to make that work.

00:45:44.780 --> 00:45:46.040
And they made it work for them.

00:45:46.040 --> 00:45:52.920
And I absolutely don't want to criticize Dropbox for not doing enough to help the open source community because they've definitely done tons of stuff.

00:45:53.460 --> 00:45:55.700
Lots of really interesting work has come out of there.

00:45:55.700 --> 00:46:16.480
But at the same time, like, if somebody else wanted to follow in their footsteps and make another Python app that would deploy to, like, a zillion machines, they'd kind of have to solve a lot of the same problems again in a different way because the Python ecosystem has moved quickly and has got a lot more and better tools than when Dropbox was first started.

00:46:16.520 --> 00:46:18.520
So there's just problems.

00:46:18.520 --> 00:46:23.520
The problem is everybody who's, like, really, really concerned about this problem is already too busy already.

00:46:23.740 --> 00:46:35.240
Like, I gave this talk to try to help newer people to the community try to understand the problem because as we spent quite a while talking at the beginning of this show, I've already got a lot going on.

00:46:35.680 --> 00:46:41.860
Like, I've got to, you know, keep the books for our customers and write software to automate financial stuff at work.

00:46:41.860 --> 00:46:47.840
And then I come home and then I maintain Twisted and I maintain Climb and I maintain Track and I do all of this stuff.

00:46:47.840 --> 00:46:55.120
And I, you know, try to keep the peace in the community and make sure the mailing list doesn't go down and keep our servers running.

00:46:55.120 --> 00:47:03.600
And at the end of all that, I just don't have any time to start the fairly ambitious project to fix all of these problems.

00:47:03.600 --> 00:47:11.280
Yeah. Well, and it doesn't sound to me, from what you described just now, that you individually have this problem, right?

00:47:11.280 --> 00:47:20.480
And I feel like there needs to be, you know, a couple of major companies or a couple of major projects that are like, we need to build this app and ship it this way.

00:47:20.480 --> 00:47:25.000
And we need to just fix the tooling to make it work for us and take the community along with us.

00:47:25.000 --> 00:47:30.360
Yeah, I feel like it's the person who's going to have this exact problem is kind of hard to imagine.

00:47:30.360 --> 00:47:40.580
Because if you want to ship a desktop app and you have interesting enough logic and enough investment in Python, there's lots of ways you can just do that today.

00:47:40.740 --> 00:47:49.320
You can grab Pi to app and you can grab Pi to exe and you can work around the same seven bugs that everybody who uses them has to work around.

00:47:49.320 --> 00:47:56.320
And eventually, after you've had a couple of professional programmers hammer on it for a few weeks, you'll have a deploy pipeline that works for you.

00:47:56.320 --> 00:48:00.480
You put it into your continuous integration system and then you're good.

00:48:00.480 --> 00:48:04.680
Right. Once you get around that, you make it work, then you forget how you even made it work, right?

00:48:04.680 --> 00:48:12.820
Exactly. And then it's in your, you know, when you do something in your code that makes it stop working, then you notice and you back it out.

00:48:12.820 --> 00:48:23.160
And this is actually one of the problems I didn't talk about in the Python talk was that one of the reasons this is so pernicious is that we don't tell users to start by deploying.

00:48:23.440 --> 00:48:35.660
Because Python is so flexible and it's so empowering to just get in there and, you know, make a module and then make another module next to it and edit the first one to import the second one and then just change it and maybe even reload it on the fly.

00:48:35.660 --> 00:48:47.440
There's all this cool stuff you can do with that and with Jupyter Notebook, just typing code into cells and never even put it into a module that by the time you have something you want to deploy,

00:48:47.440 --> 00:48:59.380
you might have made a dozen mistakes about how you're loading resources or about how you're getting your code installed or the layout of your repository, right?

00:48:59.380 --> 00:49:07.760
It's pretty easy to end up in a place where you can't even write a setup.py because all your modules are expecting to import stuff from like three different paths at the same time.

00:49:07.760 --> 00:49:15.880
And at that point, you have to like back out of whatever weird structure you've got yourself into and then recreate something sensible.

00:49:15.880 --> 00:49:19.300
And that's the point where you throw up your hands and go, I'm never going to ship this thing.

00:49:19.300 --> 00:49:23.920
Like, I'm not going to rewrite my app or it's just not going to work for real apps or whatever, right?

00:49:23.920 --> 00:49:25.620
So that's super interesting.

00:49:25.620 --> 00:49:36.160
You're basically proposing that like if you know that you want to use Py2 app or Py2.exe or the cross-platform Py2 installer or Shakespeare's or some probably combination thereof,

00:49:36.160 --> 00:49:43.340
like write your hello world and then create your hello.app and start building them up together.

00:49:43.340 --> 00:49:44.400
Is that what you're proposing?

00:49:44.400 --> 00:49:49.720
Yeah, I mean, I think for anybody who's out there who's thinking, I want to make a desktop app.

00:49:49.720 --> 00:49:50.780
I want to make a mobile app.

00:49:50.780 --> 00:49:53.900
I want to make a low-level system utility.

00:49:53.900 --> 00:50:05.860
One of the categories we haven't talked about too much yet is just like if you're making a program that needs to like be a system control thing for Unix systems at a level lower than like Docker, right?

00:50:05.860 --> 00:50:10.880
Like you want to write your own SSH server or something like that that like controls a system.

00:50:10.880 --> 00:50:16.900
You also can't ship it as a Docker container because you need it to like live on the Debian or the Red Hat system.

00:50:16.900 --> 00:50:18.040
So you need to ship it as a package.

00:50:18.040 --> 00:50:25.960
So if you're in one of those categories and you're like, I want to ship this command line thing or GUI app and you're thinking, I'm definitely going to want this to have a GUI.

00:50:25.960 --> 00:50:28.800
I'm definitely going to want this to ship as part of Homebrew.

00:50:28.980 --> 00:50:31.560
I'm definitely going to want to ship this as a Debian package.

00:50:31.560 --> 00:50:46.100
Whatever it is that your deployment target is, deploy your hello world to that target and get like Travis or some kind of continuous integration system to start running it for you and doing that build and making sure that it at least basically works.

00:50:46.100 --> 00:50:48.040
Because it's really, really easy.

00:50:48.040 --> 00:50:53.080
Once you've got that set up, once you've got that pipeline working, it'll pretty much keep working.

00:50:53.080 --> 00:51:00.960
You might have the occasional problem where like some third party library has a weird like shared object that you need to install in some funny way.

00:51:00.960 --> 00:51:11.160
But if you know that at that moment when you're adding that dependency or you're installing that tool, if it breaks right then, you could say, aha, I'm not going to use that.

00:51:11.160 --> 00:51:14.520
Or I'm going to get in touch with their maintainers and say like, why is this broken?

00:51:14.920 --> 00:51:27.020
As opposed to writing a big complicated app, getting everything all done, and then ramming headfirst into this brick wall of like, now how do I put this on somebody else's machine?

00:51:27.020 --> 00:51:33.240
Because one of the things that you don't realize is you're making all kinds of decisions about how to get it to run on your machine.

00:51:33.640 --> 00:51:36.300
And they seem like totally sensible, right?

00:51:36.300 --> 00:51:40.240
You have icon.png and it's in the current directory.

00:51:40.240 --> 00:51:42.900
So you just open up icon.png and you read it.

00:51:42.900 --> 00:51:44.980
Except what's the current directory?

00:51:44.980 --> 00:51:47.320
How do you know that it's in your git checkout?

00:51:47.320 --> 00:51:50.340
Because your git checkout is not going to be there on your target machine.

00:51:50.340 --> 00:51:55.460
So unless you're going to ship dev tools to everybody, you have to think about, well, where does that resource come from?

00:51:55.460 --> 00:51:58.640
And that's exactly the kind of stuff that trips people up with packaging.

00:51:58.640 --> 00:52:00.520
Yeah, that makes a lot of sense, actually.

00:52:00.520 --> 00:52:03.960
I hadn't really thought about it that way, but it certainly makes a lot of sense.

00:52:03.960 --> 00:52:11.920
I mean, it feels a little bit like, let's write 100,000 lines of code and then run flake 8 on it to find the problems.

00:52:11.920 --> 00:52:12.680
Right.

00:52:12.680 --> 00:52:13.860
Just the first time.

00:52:13.860 --> 00:52:14.680
Exactly.

00:52:14.680 --> 00:52:17.340
And a day before you ship, right?

00:52:17.340 --> 00:52:18.060
Yeah.

00:52:18.060 --> 00:52:28.080
Or another way to think about it is like, let's write 10,000 lines of code and we'll make sure that all unit tests pass, but we'll never run it.

00:52:28.400 --> 00:52:30.700
Because we'll just assume that it'll work if we run it.

00:52:30.700 --> 00:52:36.220
But of course, you run it that first time and it's like, oh, you forgot a couple of unit tests.

00:52:36.220 --> 00:52:39.320
And your build pipeline is the same way.

00:52:39.320 --> 00:52:48.240
So this is when I talk about pip.app, what I'm really talking about is not just like, let's make it easy, but let's make it the first thing you do.

00:52:48.380 --> 00:52:52.480
So if there are bugs in it and there are problems with it, you're just doing it constantly.

00:52:52.480 --> 00:52:54.540
So you notice when there's an issue.

00:52:54.540 --> 00:52:54.940
Yeah.

00:52:54.940 --> 00:52:56.360
I think that's really great advice.

00:52:56.360 --> 00:53:02.460
So, you know, there might be a lot of people listening who don't, are not familiar with pip.app or pip.exe and how these things work.

00:53:03.660 --> 00:53:07.760
Basically, you can take this pip.app utility.

00:53:07.760 --> 00:53:09.880
So let's stick on the macOS for a moment.

00:53:09.880 --> 00:53:21.620
And it will create, like kind of embed a Python runtime that you need, all the dependency packages that you need, your code and package it up in a way that looks just like Safari or something.

00:53:21.620 --> 00:53:23.900
And users double click it and it can run.

00:53:23.900 --> 00:53:25.080
Right?

00:53:25.280 --> 00:53:25.640
Exactly.

00:53:25.640 --> 00:53:25.920
Yeah.

00:53:25.920 --> 00:53:31.180
And so they don't even necessarily, it doesn't even matter what version of Python they have, whether they have Python.

00:53:31.180 --> 00:53:40.120
It's just, they get the app, it runs because it's a self-contained unit, like other runtimes like Go or certain Windows EXEs.

00:53:40.120 --> 00:53:40.580
Yeah.

00:53:40.580 --> 00:53:44.100
And this is exactly what I meant when I said that Python is not a deployment target.

00:53:44.100 --> 00:53:46.860
Like macOS is the deployment target.

00:53:46.860 --> 00:53:49.680
And the Mac says what you have to do to be an app.

00:53:49.680 --> 00:53:52.340
And PyToApp just makes Python be that thing.

00:53:52.340 --> 00:53:52.580
Right.

00:53:52.580 --> 00:53:53.640
Here's your P list.

00:53:53.640 --> 00:53:54.580
Here's your resources.

00:53:54.820 --> 00:53:55.560
All that kind of stuff.

00:53:55.560 --> 00:53:56.080
Exactly.

00:53:56.080 --> 00:54:02.820
And it just bundles it up into the shape that macOS expects without any regard for like what else is on the system.

00:54:02.820 --> 00:54:09.280
And really like Go is sort of famous for producing these static executables where they include all of your Go dependencies.

00:54:09.280 --> 00:54:16.000
But oddly enough, Python is sort of in a better place for many operating systems than Go would be.

00:54:16.000 --> 00:54:21.380
Because what Go lets you do is it lets you put all of your binary resources into one file.

00:54:21.380 --> 00:54:23.280
But that's kind of a red herring.

00:54:23.500 --> 00:54:29.400
The thing you actually need is to put it into the shape the operating system expects, which is almost never one file.

00:54:29.400 --> 00:54:31.740
Windows is the one place that that's true.

00:54:31.740 --> 00:54:37.000
But on Windows, there's a whole system for like tacking on resources into a .exe.

00:54:37.200 --> 00:54:41.340
You can, I believe, Windows loads from the end of the binary.

00:54:41.340 --> 00:54:45.220
So you can actually tack like you can, your binary can just be a zip file.

00:54:45.220 --> 00:54:47.640
And then you stick the executable on the end.

00:54:48.080 --> 00:54:49.980
And suddenly it works and it launches.

00:54:49.980 --> 00:54:51.760
And I might be mixing that up.

00:54:51.760 --> 00:54:54.060
I know that Unix is one way and Windows is the other.

00:54:54.060 --> 00:54:55.300
And one's the beginning and one's the end.

00:54:55.300 --> 00:55:12.860
But that kind of thing is like once you know how you want your app to run, it turns out that actually on Windows and on the Mac, you often need like shared libraries or DLLs or resources or things that can't be put into a single binary.

00:55:13.320 --> 00:55:16.200
Like an app on the Mac cannot be a single binary.

00:55:16.200 --> 00:55:19.000
It has to be at least an info.plist and an executable.

00:55:19.000 --> 00:55:24.160
And practically speaking, you need a dozen other resources like icon files and other things.

00:55:24.160 --> 00:55:27.620
And similarly, like even if you're just talking about command lines, right?

00:55:27.620 --> 00:55:30.780
You think single file binary, you think, oh, that's really good for the command line.

00:55:30.780 --> 00:55:33.320
That's really how I want to run my stuff is I just want to have this one binary.

00:55:33.740 --> 00:55:36.020
And that can make the deployment process easier.

00:55:36.020 --> 00:55:40.280
But how do people actually deploy stuff onto the command line on the Mac?

00:55:40.280 --> 00:55:44.100
Do they like curl a binary in chamod plus exit?

00:55:44.100 --> 00:55:46.120
No, they brew install it, right?

00:55:46.120 --> 00:55:51.860
And homebrew has a whole complicated multi-file setup where the deployment target is homebrew.

00:55:51.860 --> 00:55:53.040
That's a really interesting point.

00:55:53.040 --> 00:55:57.040
In your little PIDA app graphic, you had the various targets.

00:55:57.040 --> 00:56:00.340
And one was Ubuntu, one was Windows, one was macOS.

00:56:00.340 --> 00:56:02.900
But another was a chocolatey install.

00:56:02.900 --> 00:56:04.380
And one was a brew install.

00:56:04.380 --> 00:56:07.460
And one was an aptitude package and things like that, right?

00:56:07.460 --> 00:56:07.880
Yeah.

00:56:07.880 --> 00:56:11.640
And each of these kind of defines its own deployment surface.

00:56:11.640 --> 00:56:16.440
And the reason that you don't want to just be randomly curling some Go binary onto your system

00:56:16.440 --> 00:56:20.660
is because that initial install is just one thing.

00:56:20.660 --> 00:56:23.180
You've also got to have an update process.

00:56:23.180 --> 00:56:26.860
And that update process probably has to be cryptographically signed or something.

00:56:26.860 --> 00:56:30.520
Like somebody needs to be in charge of making sure there's a secure pipeline to

00:56:30.520 --> 00:56:31.960
deliver it to all your users.

00:56:31.960 --> 00:56:35.600
And then that has to run on a CDN to make sure you don't have too much load.

00:56:35.600 --> 00:56:39.920
And by the time you're done with that, you've got JSON files that are describing your metadata

00:56:39.920 --> 00:56:43.640
and hashes and all kinds of other stuff which don't fit into that one binary anymore.

00:56:43.640 --> 00:56:46.260
So Go can kind of get you started.

00:56:46.260 --> 00:56:48.880
And it can make a lot of parts of this pipeline easier.

00:56:48.880 --> 00:56:52.900
But one of my favorite examples of this, which I don't think I mentioned in the talk

00:56:52.900 --> 00:56:58.520
because I think I found out about it somewhat later, is Askinima, which is a website.

00:56:58.520 --> 00:57:02.160
It's a really cool website for sharing like screencasts of terminals.

00:57:02.160 --> 00:57:02.900
Have you ever used it?

00:57:02.900 --> 00:57:03.620
No, no, I haven't.

00:57:03.620 --> 00:57:06.480
But you have to put a link in the show notes for us so we can check it out.

00:57:06.480 --> 00:57:06.860
Definitely.

00:57:06.860 --> 00:57:09.180
But the idea is it's just this little thing.

00:57:09.180 --> 00:57:14.080
It's like a social place where you can share your various like Emacs and VI sessions.

00:57:14.080 --> 00:57:14.400
Nice.

00:57:14.400 --> 00:57:14.980
That's awesome.

00:57:14.980 --> 00:57:19.600
And when you do this, they have a local TTY recording tool, which they originally wrote

00:57:19.600 --> 00:57:20.120
in Python.

00:57:20.120 --> 00:57:25.340
And then, of course, because Python makes deployment hard, they rewrote it in Go from scratch.

00:57:26.340 --> 00:57:33.360
And then they rewrote it again in Python because they just went to Python 3 and they shipped

00:57:33.360 --> 00:57:37.940
it as a thing that you brew install because it turns out going to the single file Go binary

00:57:37.940 --> 00:57:40.720
didn't really help solve their problems that much.

00:57:40.720 --> 00:57:41.100
Right.

00:57:41.280 --> 00:57:43.780
And, you know, Go is a lot lower level language.

00:57:43.780 --> 00:57:46.420
So it didn't like there were a lot of things that they lost as well.

00:57:46.760 --> 00:57:52.140
So by just kind of going straight to the never mind the single file thing, we just want to

00:57:52.140 --> 00:57:53.580
make sure that this is brew installable.

00:57:53.580 --> 00:57:57.920
It got to what their users really wanted, which is way to get it installed.

00:57:57.920 --> 00:57:59.240
That's like easy to explain.

00:57:59.240 --> 00:58:02.100
It doesn't require a lot of sysadmin knowledge to keep updated.

00:58:02.100 --> 00:58:03.100
It doesn't require a studio.

00:58:03.380 --> 00:58:03.780
Exactly.

00:58:03.780 --> 00:58:04.060
Yeah.

00:58:04.060 --> 00:58:05.900
You just type the brew install command.

00:58:05.900 --> 00:58:11.160
And the killer thing about the way that the thing that people think they want when they

00:58:11.160 --> 00:58:17.060
hear a single file is when you've got a Python install and you're doing like pip install

00:58:17.060 --> 00:58:19.060
to get your tools installed.

00:58:19.060 --> 00:58:21.340
The problem with that isn't that it's multiple files.

00:58:21.340 --> 00:58:23.540
It's that it's sharing all kinds of files.

00:58:23.540 --> 00:58:26.500
So you do a pip install A and then you do a pip install B.

00:58:26.500 --> 00:58:30.500
And if you just need tools from A and B, they can conflict with each other.

00:58:31.000 --> 00:58:37.060
So pip install B breaks A because they're all reading from the same location.

00:58:37.060 --> 00:58:39.280
All their libraries are piled on top of each other.

00:58:39.280 --> 00:58:43.720
And there's no dependency checker in pip, which makes sure that A isn't going to break.

00:58:43.720 --> 00:58:48.240
The versioning metadata isn't fine grained enough for A to even know that it's going to

00:58:48.240 --> 00:58:49.520
break when B gets pip installed.

00:58:49.520 --> 00:58:55.380
So it's just too fragile to try to share all of this stuff between Python libraries.

00:58:55.380 --> 00:59:00.920
It's not like a .so where you can have like a very, very strict binary interface.

00:59:00.920 --> 00:59:02.080
That never, ever changes.

00:59:02.080 --> 00:59:07.380
Like anything can change in any Python file anywhere and potentially break every user of

00:59:07.380 --> 00:59:07.920
that library.

00:59:07.920 --> 00:59:12.440
You pretty much need to do a full on test run of your application to make sure that it's

00:59:12.440 --> 00:59:14.800
not going to break with a new version of a dependency.

00:59:14.800 --> 00:59:18.300
So it's that sharing that becomes a really big problem.

00:59:18.300 --> 00:59:18.740
Yeah.

00:59:18.740 --> 00:59:21.840
And sometimes you can't even avoid that because you're using two packages.

00:59:21.840 --> 00:59:25.820
They might both use a dependency, but they were built against different versions of that

00:59:25.820 --> 00:59:26.860
dependency or something, right?

00:59:26.980 --> 00:59:27.380
Exactly.

00:59:27.380 --> 00:59:29.620
And there's nothing really wrong with that even.

00:59:29.620 --> 00:59:33.800
That's the, when you describe the problem, it sounds like, oh, that one library really

00:59:33.800 --> 00:59:35.620
should have ran its tests.

00:59:35.620 --> 00:59:36.840
Shame on them.

00:59:36.840 --> 00:59:41.880
But it's not really, it's, it's not their responsibility to make sure that whatever random

00:59:41.880 --> 00:59:46.160
versions of libraries on your system happen to work, they have a continuous integration system

00:59:46.160 --> 00:59:47.280
that says what they work with.

00:59:47.520 --> 00:59:53.000
And so, you know, we've gotten a lot of improvements in the Python ecosystem for library developers

00:59:53.000 --> 00:59:55.540
to put out more and more robust artifacts.

00:59:55.540 --> 01:00:00.520
But that last mile of like, put the application together, packaging everything together.

01:00:00.520 --> 01:00:08.540
One tool that I really like that I use a lot is Pipsy, pip S-I, which I don't think is actually

01:00:08.540 --> 01:00:11.640
an acronym for anything, but I pretend that it stands for pip script installer.

01:00:12.020 --> 01:00:20.880
What it does is you do Pipsy install HTTPIE, let's say, or Pipsy install Boto3 or AWS CLI

01:00:20.880 --> 01:00:21.300
or something.

01:00:21.300 --> 01:00:31.040
And it will install a new virtual env that contains just the scripts that come from that top level

01:00:31.040 --> 01:00:31.560
package.

01:00:31.560 --> 01:00:37.120
And it'll like symlink those scripts into a shared directory, but kind of hide the virtual

01:00:37.120 --> 01:00:37.720
end from you.

01:00:38.020 --> 01:00:42.280
So it's every single tool that you need is installed into a separate virtual end for

01:00:42.280 --> 01:00:44.900
its own requirements installed into it.

01:00:44.900 --> 01:00:49.880
It's still kind of a developer installation tool because you already need to have Python,

01:00:49.880 --> 01:00:51.300
you already need to have virtual end.

01:00:51.300 --> 01:00:54.920
There's like a little bit of setup that goes into installing Pipsy in the first place and

01:00:54.920 --> 01:00:55.680
bootstrapping it.

01:00:55.680 --> 01:00:58.940
But then once you've got it, at least your stuff doesn't break all the time.

01:00:58.940 --> 01:01:04.320
Like, yeah, it lets you play with stuff more aggressively or without care, right?

01:01:04.320 --> 01:01:04.660
Right.

01:01:04.700 --> 01:01:07.840
It's isolated and it's kind of installed the way that it should be, which is that each

01:01:07.840 --> 01:01:09.760
app has its own dependencies.

01:01:09.760 --> 01:01:11.840
Because again, Python is not a platform.

01:01:11.840 --> 01:01:17.680
The compatibility guarantees that a library can make in Python are not strict enough that

01:01:17.680 --> 01:01:22.380
you can have users upgrading their own stuff and then thinking it's going to work afterwards.

01:01:22.380 --> 01:01:26.140
Like you need to ship a user all of the libraries that you tested with.

01:01:26.140 --> 01:01:26.420
Yeah.

01:01:26.420 --> 01:01:26.680
Yeah.

01:01:26.680 --> 01:01:27.440
That makes a lot of sense.

01:01:27.440 --> 01:01:31.420
So one thing that you held up as a good example is Briefcase.

01:01:31.600 --> 01:01:34.960
I think that Briefcase is headed in a really good direction.

01:01:34.960 --> 01:01:40.460
I think that they, that project has set up some really good infrastructure in terms of

01:01:40.460 --> 01:01:48.420
like how they think about the long-term solution to the problem in that they have great onboarding

01:01:48.420 --> 01:01:49.180
for new contributors.

01:01:49.180 --> 01:01:50.860
They show up at lots of events.

01:01:50.860 --> 01:01:52.360
They had a great presence at PyCon.

01:01:53.160 --> 01:01:55.800
And they also, so they're, they're playing the long game here.

01:01:55.800 --> 01:01:59.020
They recognize that this is a very big complex problem.

01:01:59.020 --> 01:02:00.560
That's going to require a lot of people to solve.

01:02:00.560 --> 01:02:01.980
And that it's also multi-layered.

01:02:01.980 --> 01:02:07.400
Like one of the parts of the Beware project is not just Briefcase, but Batavia.

01:02:07.400 --> 01:02:14.000
And Batavia is this transpiler from Python byte or not transpiler.

01:02:14.000 --> 01:02:17.240
It's a Python virtual machine written in JavaScript.

01:02:17.940 --> 01:02:20.940
So that you can ship your PYCs into a web browser.

01:02:20.940 --> 01:02:26.460
And that doesn't seem like it's really related to Briefcase at first, until you realize that

01:02:26.460 --> 01:02:32.300
the vision that they're pursuing is ship Python anywhere, write all of your code in Python all

01:02:32.300 --> 01:02:36.000
the time, which is really the vision that I'm also sympathetic to.

01:02:36.000 --> 01:02:41.240
And, but unfortunately what that means is because they are taking this very long view of the problem,

01:02:41.240 --> 01:02:45.580
it's probably not the thing that you would use like right now for everything.

01:02:45.580 --> 01:02:48.640
It does have some really great iOS build templates.

01:02:48.640 --> 01:02:52.200
If you were going to do a mobile app in Python, it's probably the best place to start.

01:02:52.200 --> 01:02:52.980
Yeah, I agree with that.

01:02:52.980 --> 01:02:58.220
They, Russell Keith McGee did a, a bunch of the build work on Pythonista.

01:02:58.220 --> 01:03:05.260
So I don't think that Pythonista, that the iOS app that runs Python is itself like straight up

01:03:05.260 --> 01:03:07.860
deployed with Briefcase, but it shares a lot of that same technology.

01:03:07.860 --> 01:03:11.740
And so there's kind of a, at least a proof concept that it can work really nicely.

01:03:11.740 --> 01:03:12.600
I don't know if you've played.

01:03:12.600 --> 01:03:13.860
Yeah, I've played with Pythonista.

01:03:13.860 --> 01:03:14.940
It's a cool app for sure.

01:03:14.940 --> 01:03:20.080
It's basically, it's a Python editor and runtime for iOS.

01:03:20.080 --> 01:03:21.300
Maybe also an Android.

01:03:21.300 --> 01:03:22.160
I don't know about Android.

01:03:22.160 --> 01:03:23.440
I'm pretty sure it's just iOS.

01:03:23.440 --> 01:03:23.860
Yeah.

01:03:23.860 --> 01:03:24.220
Yeah.

01:03:24.220 --> 01:03:29.260
Which it's impressive to me that that's even possible given all the restrictions that Apple

01:03:29.260 --> 01:03:30.440
puts on executables.

01:03:30.440 --> 01:03:30.760
Yeah.

01:03:30.760 --> 01:03:35.860
I mean, they probably wouldn't like it if you started shipping apps to people in the form of

01:03:35.860 --> 01:03:39.440
like that really, really long base 64 encoded.py files.

01:03:41.080 --> 01:03:47.900
There is some tooling to actually help you write an iOS app inside Pythonista on iOS.

01:03:47.900 --> 01:03:53.920
You do need to like have a Mac to kind of bounce your project off of because you need to do the

01:03:53.920 --> 01:03:55.840
build of an iOS app on a Mac.

01:03:55.840 --> 01:03:56.300
Yeah.

01:03:56.300 --> 01:03:56.980
But I've done that.

01:03:56.980 --> 01:04:01.480
I've downloaded the templates and like made a little hello world out of the scripts that come

01:04:01.480 --> 01:04:06.660
on Pythonista, which is actually kind of another interesting reflection of the same problem from

01:04:06.660 --> 01:04:11.940
a different direction, which is that Pythonista does not have any equivalent to pip.

01:04:11.940 --> 01:04:18.980
So it's actually very hard to write full apps that take advantage of the Python ecosystem because

01:04:18.980 --> 01:04:24.280
you can't, your build pipeline can't include that kind of like, and install this requirements.txt file

01:04:24.280 --> 01:04:24.700
first.

01:04:25.380 --> 01:04:28.320
Python's less fun when you, you have no import.

01:04:28.320 --> 01:04:29.180
Yeah.

01:04:29.180 --> 01:04:33.420
I mean, Pythonista kind of cheats a little bit because it just gives you a thing that like

01:04:33.420 --> 01:04:39.740
already includes like requests and like NumPy and some pretty big chunks of SciPy, I think

01:04:39.740 --> 01:04:40.520
are also in there.

01:04:40.520 --> 01:04:44.600
So it's, it's just kind of like, ah, here's about a third of the interesting stuff in the

01:04:44.600 --> 01:04:45.220
Python ecosystem.

01:04:45.600 --> 01:04:46.920
Just in a big box.

01:04:46.920 --> 01:04:54.680
But yeah, the idea that like you can grab this, you know, from the staggering ecosystem

01:04:54.680 --> 01:04:56.660
that Python has to provide for you.

01:04:56.660 --> 01:05:01.780
That's really what makes this interesting because if you're just going to write an app, you know,

01:05:01.780 --> 01:05:07.140
do it in a Swift playground and then, you know, copy the Swift code to a Mac and write all of

01:05:07.140 --> 01:05:07.880
that yourself.

01:05:07.880 --> 01:05:10.240
It's not that much different than Python.

01:05:10.240 --> 01:05:15.140
Like Python might be a little nicer, but once you can pull in stuff, like you can pull in

01:05:15.140 --> 01:05:19.040
Jupyter or something like that and you can have like live introspection of your objects

01:05:19.040 --> 01:05:24.420
in your app or you can pull in something like NumPy and have that tremendously powerful numerical

01:05:24.420 --> 01:05:29.820
library at your disposal, it starts to make the investment in Python kind of make sense.

01:05:29.820 --> 01:05:30.260
Yeah.

01:05:30.260 --> 01:05:31.360
Yeah, it definitely does.

01:05:31.360 --> 01:05:32.980
I think Swift is a fine language.

01:05:32.980 --> 01:05:38.520
I just think their equivalent of the standard library is really, really not, not a great story.

01:05:38.520 --> 01:05:40.020
It's pretty bare bones.

01:05:40.020 --> 01:05:40.360
Yeah.

01:05:40.360 --> 01:05:43.900
But, but, you know, Python, the way Python can compete with that is by

01:05:44.680 --> 01:05:50.500
being yet more robust in the library ecosystem and not by kind of cutting itself off at the

01:05:50.500 --> 01:05:55.620
knees and saying like, here's a really streamlined deployment experience that only works if you

01:05:55.620 --> 01:05:56.800
write all of your code yourself.

01:05:56.800 --> 01:05:57.220
All right.

01:05:57.220 --> 01:05:58.140
Yeah, absolutely.

01:05:58.140 --> 01:05:59.900
We definitely don't want, I want to see that.

01:06:00.460 --> 01:06:07.000
So, Cliff, this is a bunch of great advice and hopefully a lot of inspiration for, for people

01:06:07.000 --> 01:06:11.800
that, like you said, go that last mile to kind of close the gap and make this really sweet

01:06:11.800 --> 01:06:12.580
deployment story.

01:06:12.740 --> 01:06:15.560
Well, I certainly hope that, folks get inspired to go do that.

01:06:15.560 --> 01:06:20.740
I think that, if you are kind of, if you feel like you're just a regular developer and

01:06:20.740 --> 01:06:24.280
you don't feel like you could take on something this ambitious, going and helping out the Beware

01:06:24.280 --> 01:06:29.480
folks, get briefcase into the kind of shape that it can just do a lot of this work

01:06:29.480 --> 01:06:33.940
itself is probably the best way to help out the community at this point.

01:06:34.080 --> 01:06:34.940
Yeah, I agree.

01:06:34.940 --> 01:06:40.020
And they are, they have like basically a mentorship program for first time open source contributors

01:06:40.020 --> 01:06:41.280
and they're very welcoming there.

01:06:41.280 --> 01:06:43.040
So it's, it's a nice environment.

01:06:43.040 --> 01:06:43.600
Definitely.

01:06:43.600 --> 01:06:46.640
I think that that's one of the things that they, they might do better than almost any other

01:06:46.640 --> 01:06:50.860
project I've seen is that they are really focusing on the people problems and making it

01:06:50.860 --> 01:06:54.240
easy to get involved with the project and make a real impact quickly.

01:06:54.240 --> 01:06:54.600
Yeah.

01:06:54.600 --> 01:06:57.340
It's good to see they're working on this problem as well, cause they're doing cool stuff.

01:06:57.340 --> 01:06:58.340
All right.

01:06:58.340 --> 01:07:02.340
So I think we probably should leave it there for, for that, but let me ask you the two questions.

01:07:02.520 --> 01:07:06.760
So we talked a lot about shipping Python code, but if you're going to write some Python code,

01:07:06.760 --> 01:07:07.920
what editor do you use?

01:07:07.920 --> 01:07:13.640
So we began with a story about my childhood and I feel it's only fitting to, to end on one

01:07:13.640 --> 01:07:18.000
because I've heard you ask this question of a lot of people and they all give you an answer

01:07:18.000 --> 01:07:23.700
and I have an answer, but I think it's important to reflect on where that comes from.

01:07:23.700 --> 01:07:30.760
When I was 10 years old, my father sat me down and he said, you're going to grow up and

01:07:30.760 --> 01:07:36.820
people are going to tell you that you should be a VI user or you should be an Emacs user.

01:07:36.820 --> 01:07:40.040
And what I have to tell you is they're both wrong.

01:07:40.040 --> 01:07:44.920
You need to do both editors because sometimes you're going to be SSH'd into some machine

01:07:44.920 --> 01:07:46.360
that you have.

01:07:46.360 --> 01:07:49.500
He probably said telneted, but you know, sign of the times.

01:07:49.500 --> 01:07:50.540
Same basic thing.

01:07:50.540 --> 01:07:55.020
You're going to be in on some console where you can't install anything and Emacs isn't there

01:07:55.020 --> 01:07:56.180
and the environment's set up wrong.

01:07:56.220 --> 01:07:58.700
And you're really going to want to know how to be able to exit VI.

01:07:58.700 --> 01:08:04.800
And at the same time, like Emacs is this tremendously powerful library ecosystem of all kinds of

01:08:04.800 --> 01:08:12.700
sophisticated stuff that you probably want to be able to leverage to be able to use like

01:08:12.700 --> 01:08:13.080
an IDE.

01:08:13.080 --> 01:08:17.420
So I actually learned pretty young, both Emacs and VI.

01:08:17.760 --> 01:08:22.480
And I have tried to take that philosophy to heart in that I have a working Sublime Text

01:08:22.480 --> 01:08:23.140
configuration.

01:08:23.140 --> 01:08:26.160
I've been working on upgrading that to Sublime Text 3.

01:08:26.160 --> 01:08:29.480
I haven't messed around with Adam too much yet, but I definitely intend to.

01:08:29.480 --> 01:08:33.660
And my wife is a big proponent of Visual Studio Code.

01:08:33.660 --> 01:08:38.860
So I feel like we should all learn to use editors in harmony.

01:08:38.860 --> 01:08:39.560
Yes.

01:08:39.720 --> 01:08:41.440
That said, Emacs is the best one.

01:08:41.440 --> 01:08:43.380
And that's what I use.

01:08:43.380 --> 01:08:45.180
That's a great story.

01:08:45.180 --> 01:08:45.580
Thanks.

01:08:45.580 --> 01:08:46.720
And a good answer.

01:08:46.720 --> 01:08:47.720
All right.

01:08:47.720 --> 01:08:49.500
And notable PyPI packages?

01:08:49.500 --> 01:08:51.920
I'll throw a twisted out there for you straight away.

01:08:51.920 --> 01:08:52.380
Yeah.

01:08:52.380 --> 01:08:56.240
Actually, I wanted to talk about, I wanted to bring up one that we haven't already mentioned

01:08:56.240 --> 01:08:57.740
in the course of this discussion.

01:08:57.920 --> 01:09:02.360
And so I think Hypothesis is a package that I would really recommend people check out.

01:09:02.360 --> 01:09:09.080
I haven't used it very much yet, but what Hypothesis is, is it's a generative testing framework.

01:09:09.080 --> 01:09:15.240
So you kind of give it a piece of code that you want it to test, and then you give it some

01:09:15.240 --> 01:09:21.840
variables, some ways that it can generate data or state for that code to be tested in.

01:09:22.400 --> 01:09:28.800
And then you kind of fire it off, and it will figure out what's interesting to test about

01:09:28.800 --> 01:09:30.000
your code in some ways.

01:09:30.000 --> 01:09:35.160
I'm making it sound a little bit more magical than it is, but it lets you, like if you have

01:09:35.160 --> 01:09:41.320
just a function that takes two numbers, and there are range limits on how those numbers

01:09:41.320 --> 01:09:44.020
are supposed to relate to each other, like there's one case where they're equal to each

01:09:44.020 --> 01:09:46.640
other, and there's one case where the first one's greater, and one case where the second

01:09:46.640 --> 01:09:47.080
one's greater.

01:09:47.080 --> 01:09:52.380
Hypothesis can, if properly set up, discover that those are the three things that you can't

01:09:52.380 --> 01:09:53.660
three unit tests you need to write.

01:09:53.660 --> 01:09:56.920
And there's like a whole bunch of values where it behaves one way, and a whole bunch of values

01:09:56.920 --> 01:10:00.840
where it behaves a different way, but it'll kind of like minimize and do like a binary

01:10:00.840 --> 01:10:04.020
search to find the interesting test cases for you.

01:10:04.020 --> 01:10:09.580
And so I haven't, like I said, I haven't really used it myself yet, but I have been investigating

01:10:09.580 --> 01:10:14.120
it, and it's kind of changed the way that I've thought about how tests can interact with

01:10:14.120 --> 01:10:14.400
each other.

01:10:14.400 --> 01:10:19.520
And I would, I know a couple of my friends have given it a spin on various kind of complex

01:10:19.520 --> 01:10:24.440
testing projects, and it's really helped improve the reliability of their software a lot.

01:10:24.440 --> 01:10:28.520
It's, it's found bugs in a way that like straight up unit testing generally doesn't.

01:10:28.520 --> 01:10:29.120
Yeah, it's awesome.

01:10:29.120 --> 01:10:30.800
I've definitely heard that as well.

01:10:30.800 --> 01:10:33.560
And there's some amazing stuff hypothesis can do.

01:10:33.560 --> 01:10:38.160
I actually had the David McIver on there on episode 67.

01:10:38.160 --> 01:10:41.940
So quite a while ago, but talking about that there, and it's, I'm impressed with it as well.

01:10:41.940 --> 01:10:44.640
And it pairs up with the other unit testing things.

01:10:44.640 --> 01:10:48.440
Like you can use it with pytest or with Tox or whatever.

01:10:48.440 --> 01:10:51.580
Yeah, it's really, it's a, it's kind of a power up for your tests.

01:10:51.580 --> 01:10:53.700
It's not like a whole new testing system.

01:10:53.700 --> 01:10:59.420
People have used it with Twisted's built-in TestRunner and as well as pytest and a whole bunch

01:10:59.420 --> 01:10:59.840
of other ones.

01:11:00.080 --> 01:11:00.160
Yeah.

01:11:00.160 --> 01:11:05.060
So you touched on this just a little bit, but one more chance, final call to action.

01:11:05.060 --> 01:11:08.060
You've got people caring about this deployment story.

01:11:08.060 --> 01:11:08.680
What can they do?

01:11:08.680 --> 01:11:14.260
Well, so aside from just like go help beware, the thing to do when you go help beware is

01:11:14.260 --> 01:11:20.340
if you're the sort of person who has like a virtual machine or like the ability to spin

01:11:20.340 --> 01:11:27.180
up new VMs, run a VM for some GUI operating system, whether it's macOS or Windows and pretend

01:11:27.180 --> 01:11:33.160
you don't know anything about Python and you want to just write a little GUI application,

01:11:33.160 --> 01:11:35.160
try to find a tutorial.

01:11:35.160 --> 01:11:42.980
And in your fresh new VM with no developer tools installed, try to make an app that you

01:11:42.980 --> 01:11:47.500
can run on a different VM also with no developer tools installed.

01:11:47.880 --> 01:11:53.000
And the interesting thing about this is, well, the reason this is my final call to action

01:11:53.000 --> 01:12:00.360
is if you do this, you will see all of the places that even if you yourself are only do

01:12:00.360 --> 01:12:05.400
like web-based Python and don't do a lot of stuff with GUIs or desktop apps or mobile apps,

01:12:05.400 --> 01:12:12.080
you will see all kinds of places where you know where the sharp edges are and you know exactly

01:12:12.080 --> 01:12:16.200
what to do and it's not really written down anywhere and try to figure out how to take

01:12:16.200 --> 01:12:20.980
that process to like the parts of the process that you understand that you know how to get

01:12:20.980 --> 01:12:23.100
done the same way, the right way every time.

01:12:23.100 --> 01:12:29.900
Blog about it, write about it, contribute to packaging.python.org that where there's documentation

01:12:29.900 --> 01:12:34.700
for how to set up packaging and try to think of whatever you're trying to help with these issues,

01:12:34.940 --> 01:12:43.560
whether it's Beware or just on your own blog. Remember where the actual beginning is and don't

01:12:43.560 --> 01:12:48.640
just write tutorials for people who already have pip installed and already have Python installed and

01:12:48.640 --> 01:12:53.900
already know the difference between Python 2 and Python 3. Just go back to the beginning and think

01:12:53.900 --> 01:12:58.960
hard about what it would take for a total beginner to get started because there are a lot of total

01:12:58.960 --> 01:13:04.200
beginners out there that do not have a friend to kind of shepherd them through that wilderness and I feel

01:13:04.200 --> 01:13:09.820
like we're losing a lot of new Python programmers who if only that part were easy, they would be

01:13:09.820 --> 01:13:11.460
coming to PyCon with us every year.

01:13:11.460 --> 01:13:16.440
Yeah, absolutely. Well, that's a great thing for people to try. I totally think it would be helpful

01:13:16.440 --> 01:13:21.500
to go through that whole exercise. All right, Cliff, thank you so much for being on the show. I really

01:13:21.500 --> 01:13:22.600
enjoyed chatting with you.

01:13:22.600 --> 01:13:27.620
It was a total honor to be here and see my name up in lights next to all those other luminaries that

01:13:27.620 --> 01:13:28.080
you've interviewed.

01:13:28.080 --> 01:13:30.580
I'm thrilled to put it up there. Thanks again.

01:13:32.060 --> 01:13:39.400
This has been another episode of Talk Python to Me. Rollbar takes the pain out of errors. They give you the context

01:13:39.400 --> 01:13:45.260
and insight you need to quickly locate and fix errors that might have gone unnoticed until your users complain,

01:13:45.260 --> 01:13:50.440
of course. As Talk Python to Me listeners, track a ridiculous number of errors for free at

01:13:50.440 --> 01:13:57.440
rollbar.com slash Talk Python to Me. Datadog gives you visibility into the whole system running your code. Visit

01:13:57.440 --> 01:14:02.900
Talk Python.fm slash Datadog and see what you've been missing. Don't even throw in a free t-shirt for doing the

01:14:02.900 --> 01:14:04.780
tutorial. Are you or a

01:14:04.780 --> 01:14:09.100
or a colleague trying to learn Python? Have you tried books and videos that just left you bored by

01:14:09.100 --> 01:14:12.440
covering topics point by point? Well, check out my online course,

01:14:12.440 --> 01:14:18.700
Python Jumpstart by Building 10 Apps at talkpython.fm/course to experience a more engaging way to

01:14:18.700 --> 01:14:23.660
learn Python. And if you're looking for something a little more advanced, try my WritePythonic code

01:14:23.660 --> 01:14:30.580
course at talkpython.fm/Pythonic. Be sure to subscribe to the show. Open your favorite podcatcher

01:14:30.580 --> 01:14:36.040
and search for Python. We should be right at the top. You can also find the iTunes feed at /itunes,

01:14:36.040 --> 01:14:42.020
Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

01:14:42.020 --> 01:14:46.320
This is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it.

01:14:46.320 --> 01:14:48.280
Now get out there and write some Python code.

01:14:48.280 --> 01:15:08.740
Thank you.

01:15:08.740 --> 01:15:38.720
Thank you.

