WEBVTT

00:00:00.001 --> 00:00:03.080
You've got your Python API or app running in a Docker container.

00:00:03.080 --> 00:00:03.560
Great.

00:00:03.560 --> 00:00:07.440
Are you ready to ship it to that hosted container service and head off to production?

00:00:07.440 --> 00:00:08.800
Not so fast.

00:00:08.800 --> 00:00:13.480
Have you considered how you'll manage evolving the dependencies and addressing security updates

00:00:13.480 --> 00:00:14.020
over time?

00:00:14.020 --> 00:00:17.120
Not just for the base OS, but for the installed packages?

00:00:17.120 --> 00:00:19.480
How about your pip installed dependencies?

00:00:19.480 --> 00:00:21.060
Are you running as root?

00:00:21.060 --> 00:00:23.420
If you don't know, the answer is yes.

00:00:23.420 --> 00:00:28.580
We'll discuss these and many more issues with Itamar Turner-Trowing on this episode.

00:00:28.580 --> 00:00:29.840
It's Talk Python To Me.

00:00:29.840 --> 00:00:34.660
Episode 323, recorded June 14th, 2021.

00:00:34.660 --> 00:00:53.060
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the ecosystem,

00:00:53.060 --> 00:00:54.020
and the personalities.

00:00:54.020 --> 00:00:55.820
This is your host, Michael Kennedy.

00:00:55.820 --> 00:00:58.020
Follow me on Twitter where I'm @mkennedy.

00:00:58.120 --> 00:01:01.760
And keep up with the show and listen to past episodes at talkpython.fm.

00:01:01.760 --> 00:01:04.880
And follow the show on Twitter via at Talk Python.

00:01:04.880 --> 00:01:08.100
This episode is brought to you by Sentry and Linode.

00:01:08.100 --> 00:01:10.980
And the transcripts are brought to you by Assembly AI.

00:01:10.980 --> 00:01:13.620
Please check out what they're offering during their segments.

00:01:13.620 --> 00:01:15.080
It really helps support the show.

00:01:16.360 --> 00:01:16.880
Hi, all.

00:01:16.880 --> 00:01:19.280
I have a quick announcement before we dive into the interview.

00:01:19.280 --> 00:01:25.880
Over at Talk Python Training, we just released our latest course, Python-powered chat apps with Twilio and Syngrid.

00:01:25.880 --> 00:01:29.020
Have you ever wanted to create a chatbot using Python?

00:01:29.020 --> 00:01:33.140
In this course, we'll be building an ordering system for a tech-savvy bakery.

00:01:33.700 --> 00:01:35.960
Our customers can place orders over WhatsApp.

00:01:35.960 --> 00:01:42.780
And during the chat back and forth, we'll integrate data from our Flask API, answering questions such as, what's the menu?

00:01:42.780 --> 00:01:44.300
What does that cost?

00:01:44.300 --> 00:01:44.980
And so on.

00:01:44.980 --> 00:01:56.520
Then we'll integrate this into a sweet backend that sends receipts as PDFs over emails and allows our bakers to see new orders and then mark them as fulfilled and notify the customers when they're done.

00:01:56.960 --> 00:01:59.660
In short, it's cool tech and a super fun project.

00:01:59.660 --> 00:02:01.040
Oh, and one more thing.

00:02:01.040 --> 00:02:03.140
This course is free for everyone.

00:02:03.140 --> 00:02:08.540
So if this six-hour course sounds fun, just click the link in your podcast player's show notes and jump into the course.

00:02:08.540 --> 00:02:10.940
Now, on to the Docker best practices.

00:02:10.940 --> 00:02:13.280
Itamar, welcome to Talk Python To Me.

00:02:13.280 --> 00:02:14.660
Welcome back to Talk Python To Me.

00:02:14.660 --> 00:02:16.440
It's been some time.

00:02:16.440 --> 00:02:17.920
Feels like a year or so.

00:02:17.920 --> 00:02:19.420
I'm not sure exactly how long it's been.

00:02:19.420 --> 00:02:23.800
Last time we were on, we were talking about an entirely different topic.

00:02:24.080 --> 00:02:30.260
So you get two bits on the mind map connective sort of relationship of topics here.

00:02:30.260 --> 00:02:34.140
We talked about fill and profiling data science.

00:02:34.140 --> 00:02:34.960
That was fun.

00:02:34.960 --> 00:02:35.300
Yeah.

00:02:35.300 --> 00:02:42.400
I sort of have found myself talking about a bunch of different subjects and like some people are interested in both.

00:02:42.400 --> 00:02:43.900
Some people are interested in the other.

00:02:43.900 --> 00:02:48.860
And Docker is the other thing I've spent a lot of time sort of researching and writing about.

00:02:48.860 --> 00:03:00.580
Yeah, it's I think the data science profiling one was really interesting because profiling has all these challenges and much of it is more focused around profiling running applications or profiling code that's all in Python.

00:03:00.580 --> 00:03:09.300
And so if you need to profile like, say, Fortran code or other weird sort of mix and match libraries, then that was sort of that topic, right?

00:03:09.300 --> 00:03:17.580
Yeah, so feel as a memory profiler for Python and the kind of and specifically for batch processes like data science, scientific computing.

00:03:17.580 --> 00:03:22.900
And so if you're doing scientific computing, they'll there'll be a bunch of code in Fortran and C++ and Rust.

00:03:22.900 --> 00:03:30.060
And so you want to access that memory, like sort of profile memory across all the languages you're using.

00:03:30.300 --> 00:03:37.540
Yeah, because if you've got some big glob of C code, Python thinks it's just a pointer, that little tiny pointer to some, but it turns out to be huge.

00:03:37.540 --> 00:03:39.360
Yeah, so people can check out that episode.

00:03:39.360 --> 00:03:40.180
They're interested.

00:03:40.180 --> 00:03:43.700
And yeah, just give us an update on what you've been doing since then.

00:03:43.700 --> 00:03:48.820
I've actually been trying to turn feel into a sort of make an alternative version of it that you can run in production.

00:03:48.820 --> 00:03:54.540
Profilers often have performance overheads of feel take like 40% performance off the top.

00:03:54.540 --> 00:03:58.840
Trying to make something that will run with like 1%, 2% overhead.

00:03:58.840 --> 00:04:03.980
So you can run on production and just always get reports about your memory usage for any job.

00:04:03.980 --> 00:04:10.400
So if it's like six hours in it, it crashes out of crashes or just uses too much memory, go back and look at that.

00:04:10.400 --> 00:04:11.240
Oh, that would be fantastic.

00:04:11.540 --> 00:04:14.900
We have that for like profiling in terms of performance.

00:04:14.900 --> 00:04:19.840
On some systems, you can plug them in and they'll kind of give you real time.

00:04:19.840 --> 00:04:25.760
How is my app doing in terms of, you know, here's where it's spending its time or it got slower.

00:04:25.760 --> 00:04:28.620
Maybe it's even just measuring like request response.

00:04:28.620 --> 00:04:33.020
But memory profiling has typically been pretty intensive, right?

00:04:33.020 --> 00:04:35.280
So that'd be cool if you could get it down to that level.

00:04:35.280 --> 00:04:39.180
Yeah, and this is a very good pen.

00:04:39.180 --> 00:04:41.500
Both Phil and this project are very good.

00:04:41.500 --> 00:04:42.520
Pandemic projects.

00:04:42.520 --> 00:04:45.360
It's like really, it's quite difficult to do.

00:04:45.360 --> 00:04:48.460
And it's like, but it's something that is sort of completely under my control.

00:04:48.460 --> 00:04:53.200
Like we'll get to Docker and Docker is like, there's this giant ecosystem and they all have

00:04:53.200 --> 00:04:54.800
differing opinions about how you do things.

00:04:54.800 --> 00:04:57.900
And like everything's so broken around the edges.

00:04:57.900 --> 00:05:03.980
Whereas here it's like, I have a box and it's a very complicated box, but it's under my control.

00:05:04.140 --> 00:05:04.860
And so I can do so.

00:05:04.860 --> 00:05:10.080
It's kind of relaxing in an environment where the world is not under my control.

00:05:10.080 --> 00:05:13.000
It's been a crazy time, hasn't it?

00:05:13.000 --> 00:05:13.340
Yeah.

00:05:13.340 --> 00:05:13.800
Yeah.

00:05:13.800 --> 00:05:15.420
I feel like we're getting used to it.

00:05:15.420 --> 00:05:20.980
It's odd, but you know, people just get used to whatever water they swim in eventually, I guess.

00:05:20.980 --> 00:05:21.340
Yeah.

00:05:21.340 --> 00:05:21.660
Yeah.

00:05:21.880 --> 00:05:24.020
Let's talk about Docker a little bit.

00:05:24.020 --> 00:05:31.060
So it hasn't been that long since I had, that's, I also want to shout out quick episode 274 is when

00:05:31.060 --> 00:05:33.120
we talked about Phil, people want to go back and check that out.

00:05:33.120 --> 00:05:46.040
But I had Peter McKee from Docker over there to come and talk about sort of what is Docker, you know, give us an update on Docker, the company and like sort of set the stage for Python developers, right?

00:05:46.040 --> 00:05:49.200
To kind of get going on the dev side and just start using Docker.

00:05:49.200 --> 00:05:51.380
So that was episode 308 and that was fun.

00:05:51.380 --> 00:05:59.800
But then recently you gave a talk at PyCon called Zero to Production Ready, a best practices process for Docker packaging.

00:06:00.320 --> 00:06:13.380
And so I thought that was really interesting and wanted to have you on the show so we could dive into Docker best practices for Python, but also your focus is really on production, not necessarily development, right?

00:06:13.380 --> 00:06:13.780
Yeah.

00:06:13.780 --> 00:06:14.640
Maybe we start there.

00:06:14.640 --> 00:06:26.640
Like what's Docker look like for software development as a, I just need to make my stuff run so I can code it and test it out versus, I don't know, zero downtime Kubernetes or whatever it is you're trying to do type of thing.

00:06:26.900 --> 00:06:32.140
What do those two worlds look like and maybe tell folks about when they should care about what are the advantages or whatever.

00:06:32.140 --> 00:06:32.420
Yeah.

00:06:32.420 --> 00:06:41.420
So what Docker gives you is a sort of package that contains all the files you need for the file system, contains Python.

00:06:41.420 --> 00:06:45.540
It contains all the system libraries you need to run your Python extensions.

00:06:45.540 --> 00:06:51.780
It contains all your Python dependencies, contains all your code and contains a script to launch your code.

00:06:52.180 --> 00:07:05.680
And so as a starting point, this is useful for development because if you're say on macOS or in Windows and you're deploying to Linux, you can run something locally that is the same on across different computers.

00:07:05.680 --> 00:07:17.400
Even if you are on Linux, like I have one machine that's Fedora 33, I have another machine that's Ubuntu, like they're different in a bunch of subtle and lots of subtle ways.

00:07:17.400 --> 00:07:24.060
And so by having a Docker container when I'm developing, I can have a completely consistent environment.

00:07:24.360 --> 00:07:29.480
And then know that that environment when I, when I then take that code and run in production, it'll be exactly the same there.

00:07:29.480 --> 00:07:29.720
Right.

00:07:29.720 --> 00:07:42.080
I had a, somebody reach out to me a little while ago and ask something to the effect of, I've got a bunch of different developers on my team and I want to make sure that they all have the same version of Python in the same packages.

00:07:42.080 --> 00:07:42.740
Right.

00:07:42.800 --> 00:07:45.260
And that's a legitimate thing that you might want to do.

00:07:45.260 --> 00:07:47.340
You might want to make sure that those are exactly the same.

00:07:47.340 --> 00:07:54.140
I think maybe in general, there's probably more of a concern about that than an actual problem there.

00:07:54.140 --> 00:07:58.560
You know, a lot of times either these things are going to basically work or they're going to utterly fail.

00:07:58.560 --> 00:08:06.840
I think one of the scenarios maybe where it matters more is data science, where there's slight changes in algorithms, which might lead to different, you know, ways.

00:08:06.920 --> 00:08:16.220
You train the model, which might lean to different, like it could, those kinds of changes, but say in like web apps or UI apps or something like that, it's, it's either just going to work or it's going to completely break.

00:08:16.220 --> 00:08:23.800
That said, you know, this situation you're talking about with Docker for development, like kind of solves that, but to a much bigger degree.

00:08:23.800 --> 00:08:24.060
Right.

00:08:24.060 --> 00:08:30.880
Cause you could specify in this image, we have exactly this version of Python compiled in this way.

00:08:30.880 --> 00:08:34.360
We have these libraries installed with this version.

00:08:34.460 --> 00:08:41.300
We have these environment variables set and this subsystem of Linux installed as well, but not that other way.

00:08:41.300 --> 00:08:45.360
You can completely control it way more than just, I want the same version of Python, right?

00:08:45.360 --> 00:08:52.180
And you can then go further with something like Docker compose or compose lets you start up a little network of containers.

00:08:52.180 --> 00:08:57.160
And then it's very easy to say, okay, I want to spin up Postgres or I want to spin up Redis.

00:08:57.160 --> 00:09:01.200
Whereas traditionally this would be a pain in the ass with Docker and Docker compose.

00:09:01.440 --> 00:09:04.560
You can spin up a little, all your dependency servers really easily.

00:09:04.560 --> 00:09:09.220
So then even if you're not using Docker for your own code, you can use Docker for the services

00:09:09.220 --> 00:09:11.480
you depend on to really easily spin them up.

00:09:11.480 --> 00:09:11.720
Right.

00:09:11.720 --> 00:09:15.500
I need Redis running in this way and I need Postgres in that way.

00:09:15.500 --> 00:09:18.440
And I just need them all configured and to be able to talk.

00:09:18.440 --> 00:09:20.400
So Docker compose up, right?

00:09:20.400 --> 00:09:21.020
Something like that.

00:09:21.020 --> 00:09:21.220
Yeah.

00:09:21.220 --> 00:09:21.620
Yeah.

00:09:22.280 --> 00:09:26.840
Docker compose is a way to sort of run a little network of services, makes that really easily.

00:09:26.840 --> 00:09:27.080
Yeah.

00:09:27.080 --> 00:09:32.260
Another big advantage before we get off of the development side of things is onboarding new

00:09:32.260 --> 00:09:34.480
people and new hardware, right?

00:09:34.480 --> 00:09:38.560
If you've got something really complicated like that and you get somebody on the team, instead

00:09:38.560 --> 00:09:43.520
of spending a lot of time trying to get their system put together in the right way, you just

00:09:43.520 --> 00:09:45.180
go, sell Docker, do this.

00:09:45.380 --> 00:09:45.540
Yeah.

00:09:45.540 --> 00:09:49.100
There's, there's open source projects where like you can set up the development environment

00:09:49.100 --> 00:09:55.380
that will also provide a Docker file to just let you run some tests easily, just because

00:09:55.380 --> 00:09:58.360
you're a ongoing, you're only submitting one patch.

00:09:58.360 --> 00:10:00.460
You want to run some, like some tests on it.

00:10:00.460 --> 00:10:02.000
You don't want to go the whole thing.

00:10:02.000 --> 00:10:05.800
So it's very nice when they provide a way to run the code in Docker.

00:10:05.800 --> 00:10:06.580
Yeah, absolutely.

00:10:06.580 --> 00:10:09.900
That said, I don't generally do my development in Docker.

00:10:09.900 --> 00:10:13.320
I just, just have virtual environments and roll with that.

00:10:13.320 --> 00:10:14.740
So it's not always required.

00:10:14.740 --> 00:10:16.760
A couple of thoughts from folks out in the live stream.

00:10:16.760 --> 00:10:17.600
Kim Van Wick.

00:10:17.600 --> 00:10:18.160
Hey Kim.

00:10:18.160 --> 00:10:22.200
Says Docker Compose is an excellent way to make sure all the developers are using the same

00:10:22.200 --> 00:10:23.140
tools and versions.

00:10:23.140 --> 00:10:25.880
And it's just much easier to pass around a YAML file.

00:10:25.880 --> 00:10:26.180
Yeah.

00:10:26.180 --> 00:10:31.860
Compose is like, I remember when Compose first came out and it was called Fig, I think.

00:10:31.860 --> 00:10:36.400
And it was, it took Docker from something really neat to something really useful.

00:10:36.400 --> 00:10:36.740
Yeah.

00:10:36.740 --> 00:10:37.460
Right.

00:10:37.460 --> 00:10:42.160
The promise of Docker is that I can have all these different, if I want to run, like we just

00:10:42.160 --> 00:10:43.340
described, I want to run Redis.

00:10:43.340 --> 00:10:45.360
I want to run maybe a Celery backend.

00:10:45.360 --> 00:10:47.400
I want to run Postgres.

00:10:47.400 --> 00:10:50.200
And then my dev code is going to run and talk to all that.

00:10:50.200 --> 00:10:55.280
Well, keeping those all up to date, you know, start making sure they all build those files

00:10:55.280 --> 00:10:57.420
and they all run and maybe they run in the right order.

00:10:57.420 --> 00:10:59.160
Well, that all of a sudden isn't fun anymore.

00:10:59.620 --> 00:11:03.780
But if you can create a Compose file and just say, here's the set of containers that needs

00:11:03.780 --> 00:11:07.620
to work together, bring them all up in the right order and make sure they're all up to

00:11:07.620 --> 00:11:09.680
date, you know, got their recent build and so on.

00:11:09.680 --> 00:11:12.900
Like that's a whole nother level of the promise of containers.

00:11:12.900 --> 00:11:13.300
Yeah.

00:11:13.400 --> 00:11:15.900
Also, I don't know if you know anything about this.

00:11:15.900 --> 00:11:17.980
I'll maybe take a wild guess here.

00:11:17.980 --> 00:11:22.260
But Daniel Chen out in the live stream also says, question, is there in Windows, is there

00:11:22.260 --> 00:11:28.160
any difference between WSL 2 for the Docker backend compared to Hyper-V or is Hyper-V more

00:11:28.160 --> 00:11:30.400
for backwards compatibility legacy support?

00:11:30.540 --> 00:11:33.120
I, in general, don't use Windows that much.

00:11:33.120 --> 00:11:38.980
But basically, there's two, like, since you're running Linux and Windows is not Linux, you

00:11:38.980 --> 00:11:40.860
need to have some way of running Linux.

00:11:40.860 --> 00:11:43.300
In the past, the way you do that, you would run a virtual machine.

00:11:43.300 --> 00:11:44.960
This is what it does in macOS 2, I believe.

00:11:44.960 --> 00:11:52.980
Windows subsystem for Linux is a way to transparently run Linux applications on Windows and Docker supports

00:11:52.980 --> 00:11:53.520
it these days.

00:11:53.520 --> 00:11:56.680
I suspect they would be faster, but that's just a guess.

00:11:56.680 --> 00:11:58.000
So I don't have a good...

00:11:58.000 --> 00:12:00.760
Yeah, that's my thought as well, that they would be a little more integrated.

00:12:00.760 --> 00:12:07.420
Probably you could more easily do things like mount Windows file system folders from your

00:12:07.420 --> 00:12:08.220
Docker container.

00:12:08.220 --> 00:12:08.880
I don't know.

00:12:08.880 --> 00:12:09.940
Maybe you still can't with the others.

00:12:09.940 --> 00:12:10.660
Probably you can.

00:12:10.660 --> 00:12:10.960
But...

00:12:10.960 --> 00:12:12.440
I'd expect to be faster at least, yeah.

00:12:12.440 --> 00:12:12.820
Yeah.

00:12:12.820 --> 00:12:16.080
It seems like if you want to run on Linux, you're probably...

00:12:16.080 --> 00:12:16.920
I think you're probably closer.

00:12:16.920 --> 00:12:18.280
It's definitely more lightweight.

00:12:18.280 --> 00:12:23.800
Hyper-V would be running a full-on Linux VM and then hosting Docker in that, I'm pretty

00:12:23.800 --> 00:12:23.980
sure.

00:12:23.980 --> 00:12:24.480
Yeah.

00:12:24.480 --> 00:12:24.680
Yeah.

00:12:24.680 --> 00:12:24.920
Cool.

00:12:24.920 --> 00:12:25.360
All right.

00:12:25.360 --> 00:12:27.900
Well, hopefully our guesses there, Daniel, are helpful.

00:12:27.900 --> 00:12:28.940
All right.

00:12:28.940 --> 00:12:32.260
Well, let's talk about your talk that you gave at PyCon.

00:12:32.260 --> 00:12:36.880
I mean, giving talks today at conferences, like we started the show off, like it's a weird

00:12:36.880 --> 00:12:37.500
world, right?

00:12:37.500 --> 00:12:44.660
I'm giving a talk and both doing a live stream podcast on a conference tomorrow at the Manning

00:12:44.660 --> 00:12:46.380
Developer Productivity Conference.

00:12:46.380 --> 00:12:47.460
How can I do that?

00:12:47.460 --> 00:12:48.540
We record it.

00:12:48.800 --> 00:12:49.880
We publish it.

00:12:49.880 --> 00:12:51.920
And then we have a live Q&A afterwards.

00:12:51.920 --> 00:12:56.260
So the presentation of my recording will be during the Python bytes recording tomorrow,

00:12:56.260 --> 00:12:59.640
but then the live interactive bit will be actually after.

00:12:59.640 --> 00:13:01.980
So yeah, that's the commerce world we live in.

00:13:01.980 --> 00:13:05.620
And so PyCon this year was virtual.

00:13:05.620 --> 00:13:09.680
You put together a really nice presentation sort of in this format.

00:13:09.680 --> 00:13:14.300
And yeah, like I said, I got a lot out of it and I liked what you covered there.

00:13:14.400 --> 00:13:14.560
Yeah.

00:13:14.560 --> 00:13:18.460
And so the starting point is you have the service, now you want to run it in production.

00:13:18.460 --> 00:13:25.940
And this is a very dramatic departure from running things locally, because locally, the

00:13:25.940 --> 00:13:31.100
thing you're prioritizing is basically your feedback loop, like your development feedback

00:13:31.100 --> 00:13:31.340
loop.

00:13:31.340 --> 00:13:36.060
Like if you're a web developer, you do like it and you save your code, like can you reload

00:13:36.060 --> 00:13:37.620
the page to have the new stuff running?

00:13:37.620 --> 00:13:40.280
Other applications of feedback loops are a little different.

00:13:40.400 --> 00:13:45.040
But like your goal is just as quickly as possible to interact with your code.

00:13:45.040 --> 00:13:48.740
When you're in production, you have to worry about a whole bunch of other issues because

00:13:48.740 --> 00:13:54.020
it's actually, you have users who are going to be interacting with the software or the data

00:13:54.020 --> 00:13:56.200
it's emitting will be used in the real world.

00:13:56.200 --> 00:13:59.120
It's no longer just something you're working on.

00:13:59.120 --> 00:14:04.060
It's a thing that actually has some, the output actually has some weights and meaning, some

00:14:04.060 --> 00:14:04.560
importance.

00:14:04.560 --> 00:14:06.360
You have to approach it in a different way.

00:14:06.480 --> 00:14:11.600
So some of the things that come to mind here would be downtime, you know, in a perfect

00:14:11.600 --> 00:14:17.840
world, zero downtime in a reasonable world, a couple of seconds of downtime in the world

00:14:17.840 --> 00:14:23.040
of some bizarre web companies that I cannot, I literally cannot understand eight hours of

00:14:23.040 --> 00:14:25.560
downtime because we're deploying the new version of the site.

00:14:25.560 --> 00:14:26.560
So Sunday it'll be down.

00:14:26.560 --> 00:14:27.240
Like what?

00:14:27.840 --> 00:14:32.000
I just literally, I got this a while, you know, a couple of months ago for something

00:14:32.000 --> 00:14:32.740
I was using.

00:14:32.740 --> 00:14:35.280
There's going to be hours of downtime for a site.

00:14:35.280 --> 00:14:39.120
That's just, do, do, as you said, do you upgrade to the new version of the site?

00:14:39.120 --> 00:14:40.680
That should be a button folks.

00:14:40.680 --> 00:14:41.640
That should be not long.

00:14:41.640 --> 00:14:43.940
Anyway, one of the things is downtime, right?

00:14:43.940 --> 00:14:47.660
You want to focus on that and you don't care about that at all with development.

00:14:47.660 --> 00:14:51.140
I mean, you want it to be somewhat responsive, but it doesn't matter if it's down for a moment.

00:14:53.020 --> 00:14:55.720
This portion of Talk Python Army is brought to you by Sentry.

00:14:55.720 --> 00:14:58.240
How would you like to remove a little stress from your life?

00:14:58.240 --> 00:15:03.020
Do you worry that users might be having difficulties or are encountering errors in your app right

00:15:03.020 --> 00:15:03.320
now?

00:15:03.320 --> 00:15:06.260
Would you even know it until they send that support email?

00:15:06.260 --> 00:15:11.440
How much better would it be to have the error and performance details immediately sent to

00:15:11.440 --> 00:15:16.600
you, including the call stack and values of local variables and the active user recorded

00:15:16.600 --> 00:15:17.500
in that report?

00:15:17.500 --> 00:15:20.640
With Sentry, this is not only possible, it's simple.

00:15:20.720 --> 00:15:24.400
In fact, we use Sentry on all the Talk Python web properties.

00:15:24.400 --> 00:15:30.060
We've actually fixed a bug triggered by a user and had the upgrade ready to roll out as we

00:15:30.060 --> 00:15:31.040
got their support email.

00:15:31.040 --> 00:15:32.740
That was a great email to write back.

00:15:32.740 --> 00:15:35.220
We saw your error and have already rolled out the fix.

00:15:35.220 --> 00:15:36.400
Imagine their surprise.

00:15:36.400 --> 00:15:38.620
Surprise and delight your users today.

00:15:38.620 --> 00:15:42.040
Create your Sentry account at talkpython.fm/sentry.

00:15:42.040 --> 00:15:48.300
And if you sign up with the code talkpython2021, it's good for two months of Sentry's team plan,

00:15:48.300 --> 00:15:53.340
which will give you up to 20 times as many monthly events as well as other features.

00:15:53.340 --> 00:15:58.300
So just use that code talkpython2021 as your promo code when you sign up.

00:15:58.300 --> 00:16:03.380
Another one that you made a big deal out of that can matter is security.

00:16:03.380 --> 00:16:10.180
You don't want to be in the newspaper or the news website front pages for leaking the largest

00:16:10.180 --> 00:16:11.880
data breach ever or something like that, right?

00:16:12.520 --> 00:16:13.760
Yeah, that's embarrassing.

00:16:13.760 --> 00:16:18.400
Basically, once you're packaging for production, you're at the intersection of a whole bunch

00:16:18.400 --> 00:16:18.920
of processes.

00:16:18.920 --> 00:16:20.780
This is where it starts getting complicated.

00:16:20.780 --> 00:16:24.740
You're coding, and then you have this image, and then you might want to run some tests with

00:16:24.740 --> 00:16:27.540
it, maybe integration tests, and you're going to deploy it.

00:16:27.540 --> 00:16:32.000
And then when you deploy it, you might be upgrading an existing package, existing server.

00:16:32.000 --> 00:16:32.820
It's a server.

00:16:32.820 --> 00:16:33.940
It's a batch process.

00:16:33.940 --> 00:16:34.700
Things are a little different.

00:16:35.220 --> 00:16:39.260
So there's deployment, and then things might go wrong in production, and then you might

00:16:39.260 --> 00:16:42.580
have some sort of feedback mechanism, and maybe you're going to try to reproduce the

00:16:42.580 --> 00:16:43.080
bug locally.

00:16:43.080 --> 00:16:50.140
So all of these different technological organizational processes have some interact in some way with

00:16:50.140 --> 00:16:50.640
your packaging.

00:16:50.640 --> 00:16:54.640
And so it basically makes it a lot more complicated.

00:16:54.640 --> 00:16:58.080
And then you add into it all the different technologies that are intersecting in packaging.

00:16:58.080 --> 00:17:01.600
There's a lot of details to get right, and it gets complicated very quickly.

00:17:01.600 --> 00:17:07.640
Another area that you want to get into has to do with making sure that you're running

00:17:07.640 --> 00:17:14.560
the latest version, but you're not necessarily every deployment just grabbing the latest version.

00:17:14.560 --> 00:17:19.880
So you need some way to inject stability, and you need some way that that stability doesn't

00:17:19.880 --> 00:17:24.600
lock in computer vulnerabilities or any of those kinds of issues.

00:17:24.600 --> 00:17:26.380
It also allows it to keep growing, right?

00:17:26.380 --> 00:17:26.620
Yeah.

00:17:26.620 --> 00:17:33.540
And this is sort of one of the more significant examples, but an example of the bigger picture,

00:17:33.540 --> 00:17:35.980
which is packaging is a process.

00:17:35.980 --> 00:17:39.960
And so it's not just about writing some configuration files.

00:17:39.960 --> 00:17:44.500
It's going to interact with the way you write code, and it's a thing that parts of it are going

00:17:44.500 --> 00:17:45.700
to continue over time.

00:17:45.700 --> 00:17:50.220
So when you're packaging for production, you're not just writing a few config files and calling

00:17:50.220 --> 00:17:50.620
it a day.

00:17:50.940 --> 00:17:55.800
You actually need to think about, need to set up these ongoing processes for things

00:17:55.800 --> 00:17:58.520
like security updates and for things like dependency updates.

00:17:58.520 --> 00:17:58.780
Right.

00:17:58.780 --> 00:18:01.660
It's one thing to get it running on a cluster, a container cluster.

00:18:01.660 --> 00:18:06.920
It's another to say, and here's how we're going to keep this software healthy and running

00:18:06.920 --> 00:18:08.120
over time, right?

00:18:08.120 --> 00:18:08.380
Yeah.

00:18:08.380 --> 00:18:13.340
You need to sort of think through the implications of what you're doing, and it's not just a

00:18:13.340 --> 00:18:13.880
one-off thing.

00:18:13.880 --> 00:18:14.880
It's an ongoing thing.

00:18:14.880 --> 00:18:15.820
Yeah, absolutely.

00:18:15.820 --> 00:18:16.400
All right.

00:18:16.400 --> 00:18:18.840
Let's dive into some of the details.

00:18:18.840 --> 00:18:23.280
So it turns out I discovered today, as I was pulling up your website, that you've actually

00:18:23.280 --> 00:18:29.640
written a whole bunch of stuff about production-ready Docker packaging, and that you're actually

00:18:29.640 --> 00:18:30.760
working on a handbook.

00:18:30.760 --> 00:18:32.340
I end up doing this a lot as well.

00:18:32.340 --> 00:18:38.100
I end up, I'll spend a month doing tons of research and examples and thinking about a course,

00:18:38.100 --> 00:18:42.240
and I'm like, oh, there's a couple of nice presentations or conference talks I could pull

00:18:42.240 --> 00:18:42.740
out of here.

00:18:42.740 --> 00:18:45.740
And yeah, it's a good way to do it, right?

00:18:45.740 --> 00:18:48.780
So you've been thinking a lot about this, not just for this talk, but beyond, right?

00:18:48.900 --> 00:18:49.100
Yeah.

00:18:49.100 --> 00:18:52.660
I'm sort of spending two years on it so far.

00:18:52.660 --> 00:18:56.060
Like, I have three different products up there.

00:18:56.060 --> 00:18:56.980
I've done training.

00:18:56.980 --> 00:19:00.180
There's like a lot of articles these days.

00:19:00.180 --> 00:19:01.320
It just adds up.

00:19:01.320 --> 00:19:07.560
And yeah, I've spent a lot of time looking into this because it turns out it's, I should say,

00:19:07.560 --> 00:19:10.740
I don't like Docker packaging.

00:19:10.740 --> 00:19:11.560
Okay.

00:19:11.720 --> 00:19:14.360
This isn't a thing I'm doing because this is fun.

00:19:14.360 --> 00:19:16.200
It's not actually fun.

00:19:16.200 --> 00:19:17.100
It's kind of a pain.

00:19:17.100 --> 00:19:23.700
It's just, it's very useful and it's very easy to get it wrong or to miss things.

00:19:23.700 --> 00:19:28.040
And so what I've been trying to do is sit and say, here's this really useful thing.

00:19:28.040 --> 00:19:30.440
Here are the details you need to get right.

00:19:30.440 --> 00:19:34.500
And now that I've written it down, you don't have to waste your time trying to figure this

00:19:34.500 --> 00:19:39.680
out because much of it is not, it's really useful, but it's not like, you don't feel like

00:19:39.680 --> 00:19:42.200
you're a better person for having figured this out.

00:19:42.200 --> 00:19:45.240
It's just, it's the getting, it's an obstacle.

00:19:45.240 --> 00:19:48.820
And I'm trying to get people past those obstacles that can use this useful technology.

00:19:48.820 --> 00:19:49.180
Yeah.

00:19:49.180 --> 00:19:52.920
Well, there's a lot of stuff that you talk about that is not necessarily something that

00:19:52.920 --> 00:19:57.780
would be front of mind, like security, like how to manage the versioning over time and

00:19:57.780 --> 00:19:58.380
so on.

00:19:58.380 --> 00:20:03.460
But I think also it would be quite satisfying to have, you know, take something that's janky

00:20:03.460 --> 00:20:07.540
and maybe it does have that like one hour banner on Sunday, we're going to be down from three

00:20:07.540 --> 00:20:12.240
to four upgrading our site and, and be able to remove that and say, no, we just deploy a

00:20:12.240 --> 00:20:13.160
couple of times a week now.

00:20:13.160 --> 00:20:19.360
We don't think about it because it's get push prod and then wait 30 seconds.

00:20:19.360 --> 00:20:20.960
And then prod is now the new one.

00:20:20.960 --> 00:20:21.240
Right.

00:20:21.240 --> 00:20:21.540
Yeah.

00:20:21.540 --> 00:20:22.700
I think that's a very good feeling.

00:20:22.700 --> 00:20:23.040
Yeah.

00:20:23.040 --> 00:20:26.320
And there's a bunch more you need to do that than what I talk about.

00:20:26.320 --> 00:20:27.300
I'm talking about one piece.

00:20:27.300 --> 00:20:31.720
There's also the deployment process and that there's having good observability and

00:20:31.720 --> 00:20:33.840
logging, even just the packaging part of it.

00:20:33.840 --> 00:20:36.420
Like there's a lot of details to get right that can make it a lot easier.

00:20:36.420 --> 00:20:36.800
Yeah.

00:20:36.800 --> 00:20:42.440
So the way you started the presentation, your first thought for this was that packaging,

00:20:42.440 --> 00:20:48.480
this whole Docker as production, packaging your app and Docker for production is an iterative

00:20:48.480 --> 00:20:51.520
process and maybe also layers, right?

00:20:51.520 --> 00:20:56.060
Like, so you sit, you don't necessarily start with the whole, well, we want zero downtime.

00:20:56.240 --> 00:20:58.280
You start with, can we make it run in Docker?

00:20:58.280 --> 00:20:58.560
Yeah.

00:20:58.560 --> 00:21:01.280
And you don't have to do it as an iterative process.

00:21:01.280 --> 00:21:05.780
Like if you can manage to keep all this in your head, which honestly, I can't, but there's

00:21:05.780 --> 00:21:06.620
too many details.

00:21:06.620 --> 00:21:11.820
Or if I were to start Dockerizing something, I would probably do a bunch of it in one go

00:21:11.820 --> 00:21:12.760
because I remember some of it.

00:21:12.840 --> 00:21:17.220
But if you're doing this at your job and you probably are like someone's, there's going

00:21:17.220 --> 00:21:21.000
to be an emergency or someone's going to pull you over or there's going to be a bug that

00:21:21.000 --> 00:21:21.560
you have to fix.

00:21:21.560 --> 00:21:23.200
And so you're going to get pulled away at some point.

00:21:23.200 --> 00:21:29.380
And so what you'd like to do is build your packaging in a way where if you're interrupted,

00:21:29.380 --> 00:21:31.060
you have to stop, you have to put it on hold.

00:21:31.480 --> 00:21:35.940
You can put it aside and know you're a good stopping port and you want to sort of prioritize

00:21:35.940 --> 00:21:37.100
the most important ways.

00:21:37.100 --> 00:21:42.020
So if you run, like you may just run out of time budget, like you just have limited time

00:21:42.020 --> 00:21:44.460
and you want to do the highest priority things first.

00:21:44.660 --> 00:21:46.180
And if you ever have more time, you can-

00:21:46.180 --> 00:21:50.160
Well, it sounds like what you're describing is a little bit of what happened to the software

00:21:50.160 --> 00:21:55.140
development side of things when it went from waterfall to agile or waterfall to something

00:21:55.140 --> 00:21:56.160
better, right?

00:21:56.160 --> 00:21:59.540
So many projects used to say, well, what we're going to do is we're going to build it until

00:21:59.540 --> 00:22:01.220
we're going to work on it for six months.

00:22:01.220 --> 00:22:06.700
And it's not going to be actually usable in any meaningful way until that six month point.

00:22:06.700 --> 00:22:09.760
And then maybe it drags on and it goes over budget and gets canceled.

00:22:09.760 --> 00:22:12.200
And there's just all sorts of, you know, you get no user feedback.

00:22:12.200 --> 00:22:14.640
There's all these kinds of problems trying to build software.

00:22:14.640 --> 00:22:19.200
So it doesn't surprise me that there would be lots of advantages to trying to apply that

00:22:19.200 --> 00:22:20.980
same sort of iterative thinking.

00:22:20.980 --> 00:22:25.500
Like, let's make sure that each step along the way, we have something that's useful and

00:22:25.500 --> 00:22:26.920
more useful than it was before.

00:22:26.920 --> 00:22:27.220
Yeah.

00:22:27.220 --> 00:22:32.620
And also, even if you know you have the time budget to do all of it, having a good understanding

00:22:32.620 --> 00:22:36.600
of the priorities means you can focus on the really important things.

00:22:36.600 --> 00:22:37.000
Yeah.

00:22:37.000 --> 00:22:39.420
Like large images are very visible.

00:22:39.420 --> 00:22:40.540
Like it's very easy.

00:22:40.540 --> 00:22:42.820
Like you can look at your image and say, why is this two gigabyte?

00:22:42.820 --> 00:22:43.800
Like this is ridiculous.

00:22:44.120 --> 00:22:48.540
And then you can go into this rabbit hole of like trying to make your image smaller.

00:22:48.540 --> 00:22:50.040
And that's a fine thing to do.

00:22:50.040 --> 00:22:57.180
But if you deploy an image that's insecure and nice and small, that's not the best trade-off.

00:22:57.180 --> 00:23:03.660
I would venture to say that your organization would not praise you for your efforts to make

00:23:03.660 --> 00:23:04.100
it small.

00:23:04.100 --> 00:23:07.060
But rather, they would be pretty upset about the security problems, right?

00:23:07.260 --> 00:23:07.460
Yeah.

00:23:07.460 --> 00:23:07.500
Yeah.

00:23:07.500 --> 00:23:13.520
And so like security seems like a high priority, like automation's high priority.

00:23:13.520 --> 00:23:17.080
And the order you might actually do it, it might be slightly different depending on your

00:23:17.080 --> 00:23:19.100
particular domain you're working on.

00:23:19.100 --> 00:23:19.520
Right.

00:23:19.640 --> 00:23:21.800
But yeah, you want to think about.

00:23:21.800 --> 00:23:23.440
It's a bit of a priority stack, right?

00:23:23.440 --> 00:23:27.480
Like what is most important to me or what is most foundational to the whole, this whole

00:23:27.480 --> 00:23:29.020
packaging and Docker process.

00:23:29.020 --> 00:23:29.260
Yeah.

00:23:29.300 --> 00:23:35.060
So you actually put up some six points that you thought were sort of stages in your talk.

00:23:35.060 --> 00:23:35.200
Yeah.

00:23:35.200 --> 00:23:36.020
Get something working.

00:23:36.020 --> 00:23:38.180
That's just, can you use Docker at all?

00:23:38.180 --> 00:23:40.220
Obviously, if it doesn't work, it's not going to be useful.

00:23:40.560 --> 00:23:43.780
And then number two, even before continuous integration, security.

00:23:43.780 --> 00:23:47.860
I can see that people would overlook that, but that's not trivial, right?

00:23:47.860 --> 00:23:48.120
Yeah.

00:23:48.120 --> 00:23:54.520
And like security is sort of a never ending thing, like, because you have to deal with security

00:23:54.520 --> 00:23:54.920
updates.

00:23:54.920 --> 00:24:01.340
But if you want to, like, you don't need complete automation to like spin up a server somewhere

00:24:01.340 --> 00:24:02.000
and test something.

00:24:02.000 --> 00:24:06.540
Like if you're using Heroku, you can like push a Docker image to Heroku and spin up a server.

00:24:06.540 --> 00:24:06.740
Yeah.

00:24:06.740 --> 00:24:08.480
You could manually do a get push.

00:24:08.480 --> 00:24:09.280
Yeah.

00:24:09.280 --> 00:24:10.440
You can push stuff.

00:24:10.920 --> 00:24:12.600
But, and then try it out.

00:24:12.600 --> 00:24:17.820
But if it's talking to like a production database and it's not secure, that's the problem.

00:24:17.820 --> 00:24:22.060
And packaging is only one small part of the security and most of it's going to be application

00:24:22.060 --> 00:24:25.360
security, but it still comes into it and it's still important.

00:24:25.360 --> 00:24:25.660
Right.

00:24:25.660 --> 00:24:25.940
Right.

00:24:25.940 --> 00:24:29.000
Little Bobby tables is still a problem, even if it's running in Docker.

00:24:29.000 --> 00:24:30.100
Yes.

00:24:30.100 --> 00:24:31.960
That's right.

00:24:31.960 --> 00:24:32.260
Okay.

00:24:32.260 --> 00:24:33.400
So number two is security.

00:24:33.400 --> 00:24:35.900
And then number three is continuous integration.

00:24:36.420 --> 00:24:43.640
So making sure that like when we check in code that it's tested in Docker, guessing the tester

00:24:43.640 --> 00:24:48.340
run, the system, something of a Docker compose up type of thing happens and it's all good.

00:24:48.340 --> 00:24:50.800
Then correctness and debugability.

00:24:51.040 --> 00:24:53.080
So correctness is obvious, right?

00:24:53.080 --> 00:24:54.520
It needs to work.

00:24:54.520 --> 00:24:55.680
It needs to have fresh data.

00:24:55.680 --> 00:24:58.360
It can't have like stale caches and weird things like that.

00:24:58.360 --> 00:25:00.380
But debugability is interesting.

00:25:00.380 --> 00:25:02.800
Maybe you want to focus on that for just a sec?

00:25:02.960 --> 00:25:03.360
Sure.

00:25:03.360 --> 00:25:08.140
So the idea is that like once you have automated builds, you might start actually running things

00:25:08.140 --> 00:25:09.540
for product in production for real.

00:25:09.540 --> 00:25:14.080
Or even if not, you're going to have, if you're building an image for every pull request, now

00:25:14.080 --> 00:25:15.020
you have a bunch of images.

00:25:15.020 --> 00:25:17.040
And so someone files a bug.

00:25:17.040 --> 00:25:20.880
How do you know what version of your code, like which Docker image, do they know which Docker

00:25:20.880 --> 00:25:21.580
image they were using?

00:25:21.580 --> 00:25:22.960
What version of the code it matches to?

00:25:22.960 --> 00:25:27.280
If something crashes, like, are you going to get actual, are you going to get logs that someone

00:25:27.280 --> 00:25:28.080
can report or not?

00:25:28.080 --> 00:25:33.200
If you don't go to the effort of exporting the volume that has where the logs get written,

00:25:33.200 --> 00:25:36.660
every new deploy gets a new fresh set of logs.

00:25:36.660 --> 00:25:36.980
Yeah.

00:25:36.980 --> 00:25:42.200
So yeah, like logging to standard out or standard error is the other way you deal with logs in

00:25:42.200 --> 00:25:42.460
Docker.

00:25:42.460 --> 00:25:47.320
But you need to like put some minimal thought into like, where are my logs going to go?

00:25:47.320 --> 00:25:47.620
Yeah.

00:25:47.620 --> 00:25:52.000
Another thing that gets really tricky around that kind of stuff, I feel, has to do with

00:25:52.000 --> 00:25:54.780
the fact that there's just so many moving parts a lot of times.

00:25:54.780 --> 00:25:57.800
You know, you've got your Celery Docker container.

00:25:57.980 --> 00:25:59.400
You've got your Redis Docker container.

00:25:59.400 --> 00:26:01.340
You've got your Postgres Docker container.

00:26:01.340 --> 00:26:03.120
You've got your app Docker container.

00:26:03.120 --> 00:26:06.180
You're doing microservices, like who knows how many.

00:26:06.180 --> 00:26:08.960
And then all of those things have logs.

00:26:08.960 --> 00:26:13.820
Do you use anything, any of the services that try to bring all those logs into one place?

00:26:13.820 --> 00:26:16.280
Not a huge amount of experience on any particular one.

00:26:16.280 --> 00:26:22.080
I have, or I've built a system like that, which these days I wouldn't recommend using, but

00:26:22.080 --> 00:26:24.760
it's more for this point only for scientific computing.

00:26:24.760 --> 00:26:24.960
Yeah.

00:26:24.960 --> 00:26:30.260
But before the log as a service, log aggregation as a service was a thing.

00:26:30.260 --> 00:26:30.520
Yeah.

00:26:30.520 --> 00:26:32.940
I've worked on like airline reservation system.

00:26:32.940 --> 00:26:33.460
I had one of these.

00:26:33.460 --> 00:26:38.860
And this was a like eye opener for me being able to see logs going between five services

00:26:38.860 --> 00:26:40.880
in like multiple different protocols.

00:26:41.240 --> 00:26:44.000
So you could make debugging vastly simpler.

00:26:44.000 --> 00:26:44.340
Yeah.

00:26:44.340 --> 00:26:51.280
So you really like anything that lets you trace across services with a tracing ID will

00:26:51.280 --> 00:26:54.500
make your, like once you have more than one service, it'll make your life much easier.

00:26:54.500 --> 00:27:02.640
However, I, my recommendation is avoid microservices unless your company has 500 people or something

00:27:02.640 --> 00:27:02.920
like that.

00:27:02.920 --> 00:27:03.020
Yeah.

00:27:03.020 --> 00:27:09.100
It's an amazing architectural design pattern when there, there needs to be autonomy for

00:27:09.100 --> 00:27:10.280
different parts of the application.

00:27:10.280 --> 00:27:13.820
Like this team works on the front end little bits here.

00:27:13.820 --> 00:27:18.740
This team works on the user authentication and identity part APIs.

00:27:18.740 --> 00:27:25.400
And, but you know, looking at the most recent PSF JetBrains survey, that is not the number

00:27:25.400 --> 00:27:30.160
of employees, number of people on a team type of description for most Python developers.

00:27:30.160 --> 00:27:34.340
It's like a handful of folks all working on a lot of it.

00:27:34.340 --> 00:27:34.540
Right.

00:27:34.540 --> 00:27:34.880
Yeah.

00:27:34.880 --> 00:27:38.320
And if you look at the companies that are doing microservices successfully at scale,

00:27:38.320 --> 00:27:42.340
they will have a team of, you know, three to five people working on one service.

00:27:42.340 --> 00:27:48.820
So if you have a team of five people, 20 services, you are doing like a hundred times more services

00:27:48.820 --> 00:27:50.560
per developer than the big companies.

00:27:50.560 --> 00:27:50.980
Yeah.

00:27:50.980 --> 00:27:56.120
And that's a lot of complexity you've just added to your life and it is often unnecessary.

00:27:56.120 --> 00:27:56.600
Yeah.

00:27:56.600 --> 00:27:59.580
Here, let's, I'll pull up the survey.

00:27:59.580 --> 00:28:02.160
So Python developer survey 2020 results.

00:28:02.340 --> 00:28:07.520
If you search in that for team, not team city, employment work, working in a team versus

00:28:07.520 --> 00:28:10.080
working independently, about half the people work on a team.

00:28:10.080 --> 00:28:13.560
But if you look at the team size, 75% are two to seven.

00:28:13.560 --> 00:28:13.920
Yeah.

00:28:13.920 --> 00:28:15.320
That should be one microservice.

00:28:15.320 --> 00:28:15.720
Yeah.

00:28:15.720 --> 00:28:17.280
It's really microservices.

00:28:17.280 --> 00:28:21.700
And there are applications that are actually, there are distributed systems where you actually,

00:28:21.700 --> 00:28:26.600
it makes sense to do more, but like any time you make something more distributed, you

00:28:26.600 --> 00:28:28.740
are adding a vast amount of complexity.

00:28:28.740 --> 00:28:31.140
And so if you can avoid it, avoid it.

00:28:31.140 --> 00:28:31.280
Yeah.

00:28:31.280 --> 00:28:32.720
Well, here's the way that I think about it.

00:28:32.720 --> 00:28:35.040
I think about microservices.

00:28:35.040 --> 00:28:41.320
They have a tons of value and they move where the complexity of your application lives.

00:28:41.320 --> 00:28:47.040
So what you end up with is very simple, relatively simple, small, easy bits of code.

00:28:47.040 --> 00:28:53.000
But what you also end up with is a much more complex deployment DevOps coordination story.

00:28:53.160 --> 00:28:57.640
So when I think about microservices, the farther you go towards microservices, the more you're

00:28:57.640 --> 00:29:02.000
taking the code complexity of a large app and architectural patterns and separation.

00:29:02.000 --> 00:29:03.840
And you're saying, well, we don't need any of that.

00:29:03.840 --> 00:29:04.700
Let's make it real simple.

00:29:04.700 --> 00:29:09.900
And we move that complexity to coordinating a bunch of services that are always up, that are

00:29:09.900 --> 00:29:13.520
debuggable across services and versioned and all those things.

00:29:13.520 --> 00:29:18.280
And when I think about that for me, I'm way better at software complexity than I am at deployment

00:29:18.280 --> 00:29:18.800
complexity.

00:29:18.800 --> 00:29:23.620
So I'm more successful not putting it where I don't have my experience or skillset.

00:29:23.620 --> 00:29:23.920
You know?

00:29:23.980 --> 00:29:28.960
It's actually software complexity too, because if you call a function, you're going to call

00:29:28.960 --> 00:29:29.380
a function.

00:29:29.380 --> 00:29:32.960
If you send a message to another service, it may never arrive.

00:29:32.960 --> 00:29:34.920
It may be delayed arbitrarily.

00:29:34.920 --> 00:29:35.500
Yeah.

00:29:35.500 --> 00:29:42.480
And so the communication becomes and the reliability of a thing you're calling, the switch from a

00:29:42.480 --> 00:29:48.360
function within the same process to remote service is a sort of huge increase in unpredictability

00:29:48.360 --> 00:29:49.520
and sources of error.

00:29:49.520 --> 00:29:50.200
That's a good point.

00:29:50.240 --> 00:29:55.680
Because as for many things that could go wrong with, say, calling some function or a

00:29:55.680 --> 00:30:00.660
sort of class level method, not having it get called is not one of the things you'd have

00:30:00.660 --> 00:30:01.300
to worry about.

00:30:01.300 --> 00:30:02.280
Yeah.

00:30:02.280 --> 00:30:02.460
Right?

00:30:02.460 --> 00:30:06.220
You might crash because the file system isn't there, isn't accessible.

00:30:06.220 --> 00:30:07.560
The database isn't there.

00:30:07.560 --> 00:30:09.980
But it's not that you couldn't even call it, right?

00:30:09.980 --> 00:30:10.540
That's going to happen.

00:30:10.540 --> 00:30:10.860
Yeah.

00:30:10.860 --> 00:30:16.620
Before we move on, Kim says, FileBeat, Logstash, Prometheus, and Protainer.

00:30:16.620 --> 00:30:17.320
Oh, Protainer.

00:30:17.320 --> 00:30:17.940
I've never heard of that one.

00:30:18.180 --> 00:30:20.300
Can all help with logs from Docker in various ways.

00:30:20.300 --> 00:30:20.760
Awesome.

00:30:20.760 --> 00:30:22.180
Good resources to check out.

00:30:22.180 --> 00:30:22.720
Okay.

00:30:22.720 --> 00:30:27.600
Last one on your quick hit list before we dive into some of the details is faster builds

00:30:27.600 --> 00:30:28.840
and smaller images.

00:30:28.840 --> 00:30:31.280
I think we skipped reproducible builds.

00:30:31.280 --> 00:30:32.680
Who needs reproducibility?

00:30:32.680 --> 00:30:32.920
Yeah.

00:30:32.920 --> 00:30:33.920
Let's go with reproducibility.

00:30:33.920 --> 00:30:34.240
Yeah.

00:30:34.240 --> 00:30:39.060
And so this is the static versus dynamic change of dependencies that you talked about,

00:30:39.060 --> 00:30:44.620
where on the one hand, you really don't want every time you reinstall your application to

00:30:44.620 --> 00:30:48.180
get the latest dependencies because a new version of Django comes out.

00:30:48.180 --> 00:30:52.580
You don't want your code to suddenly start running on it just because it came out.

00:30:52.580 --> 00:30:52.820
Right.

00:30:52.820 --> 00:30:53.960
And maybe you're not aware, right?

00:30:53.960 --> 00:30:58.280
Because you have the older version of Django, as you suggest, and you're working on it.

00:30:58.280 --> 00:30:59.680
You get push.

00:30:59.680 --> 00:31:00.520
It goes to CI.

00:31:00.940 --> 00:31:05.840
And then that ideally is going to like some sort of continuous delivery and it's grabbed

00:31:05.840 --> 00:31:07.520
just the latest, which is not what you had.

00:31:07.520 --> 00:31:08.480
And then it runs with it.

00:31:08.480 --> 00:31:09.560
Like that could be bad news.

00:31:09.560 --> 00:31:09.800
Yeah.

00:31:09.800 --> 00:31:11.940
This happens a lot of like dev tools.

00:31:11.940 --> 00:31:15.680
And then like, oh, I'm going to go check if there's been a new release today.

00:31:15.680 --> 00:31:16.600
And the matter is less.

00:31:16.600 --> 00:31:21.760
But when it's your actual production software, that's not, oh, I wasted 20 minutes figuring

00:31:21.760 --> 00:31:22.560
out a failed build.

00:31:22.560 --> 00:31:25.020
It's my code is acting weird in production.

00:31:25.320 --> 00:31:29.920
On the other hand, if you just freeze all your dependencies and never change them, then

00:31:29.920 --> 00:31:34.680
at some point you're going to be running on a version of software from two or three or

00:31:34.680 --> 00:31:35.500
five years ago.

00:31:35.500 --> 00:31:40.700
Like I've, the extreme cases, like there are organizations still running on Python too.

00:31:40.700 --> 00:31:48.560
And this is, becomes very problematic because upgrades become more and more terrifying the more

00:31:48.560 --> 00:31:49.280
you put them off.

00:31:49.280 --> 00:31:51.260
Because it's not just like Django.

00:31:51.640 --> 00:31:56.680
It's like, you have to upgrade Python and Django and three other major libraries you depend

00:31:56.680 --> 00:31:57.000
on.

00:31:57.000 --> 00:32:00.460
And it's, it's like this project.

00:32:00.460 --> 00:32:04.080
And it's a project that's not features or bug fixers or anything.

00:32:04.080 --> 00:32:05.200
It's just risk.

00:32:05.200 --> 00:32:07.500
But if you put it off more, then it's more risk.

00:32:07.500 --> 00:32:09.080
And so you need a process that's ongoing.

00:32:09.080 --> 00:32:14.240
So you need both in the short term to be, make sure your builds are identical, reproducible

00:32:14.240 --> 00:32:16.960
and long or mostly identical.

00:32:16.960 --> 00:32:21.200
And then the longterm you need the process to continuously update so that upgrades are

00:32:21.200 --> 00:32:22.280
not this terrifying thing.

00:32:22.280 --> 00:32:24.320
They're just a standard part of your development process.

00:32:24.320 --> 00:32:24.640
Yeah.

00:32:24.640 --> 00:32:29.460
I had Carlton and Will on from Django chat a while ago talking about deployment.

00:32:29.460 --> 00:32:33.620
And we came up with the idea that there are basically two types of applications.

00:32:33.620 --> 00:32:37.420
There's ones that you're going to continue to add features to, and you're going to care

00:32:37.420 --> 00:32:40.080
about, and you have a, maybe a team dedicated to it.

00:32:40.080 --> 00:32:42.980
And for those, you never want to be that far from the latest thing.

00:32:43.220 --> 00:32:47.760
Just like you described, the farther you get, the more frightening and the more potential

00:32:47.760 --> 00:32:50.460
problems you have if we take on the latest, right?

00:32:50.460 --> 00:32:56.080
Because if you're on Django 2 and it's Django 4.5 is out in some future world, you're like,

00:32:56.080 --> 00:32:59.660
well, we finally need to move to get that because the other one's gone fully unsupported.

00:32:59.660 --> 00:33:01.320
Well, that's like you said, as a project.

00:33:01.320 --> 00:33:05.240
Because if you're always kind of just in dev, sort of rolling into later one and then deciding

00:33:05.240 --> 00:33:08.740
to roll that out, like that's a much smaller challenge.

00:33:08.740 --> 00:33:10.500
So those should absolutely stay there.

00:33:10.620 --> 00:33:16.160
Also, we talked about a set of apps, a type of app that falls into the, please don't

00:33:16.160 --> 00:33:16.580
touch it.

00:33:16.580 --> 00:33:19.840
And if you do touch it and break it, it's now your baby.

00:33:19.840 --> 00:33:22.120
It's some horrible legacy code.

00:33:22.120 --> 00:33:25.040
The person who created it probably doesn't work at the company anymore.

00:33:25.040 --> 00:33:26.500
Nobody really likes it.

00:33:26.500 --> 00:33:29.240
It's not important, but it needs to be there.

00:33:29.240 --> 00:33:30.980
Like it's some internal app or something, right?

00:33:30.980 --> 00:33:34.360
Like maybe those, you just freeze those in time.

00:33:34.360 --> 00:33:37.200
They're very likely not public facing or something.

00:33:37.200 --> 00:33:41.880
But certainly if you care about continuing to work on this thing and adding features to

00:33:41.880 --> 00:33:44.740
it and it matters, then keep it not too far.

00:33:44.740 --> 00:33:45.720
That's the tension.

00:33:45.720 --> 00:33:50.400
You don't want to just constantly ship the latest thing because maybe that's a major release of

00:33:50.400 --> 00:33:52.520
some library, but at the same time, you don't want to freeze it.

00:33:54.480 --> 00:33:57.340
This portion of Talk Python To Me is sponsored by Linode.

00:33:57.340 --> 00:34:02.380
Visit talkpython.fm/Linode to see why Linode has been voted the top infrastructure

00:34:02.380 --> 00:34:05.780
as a service provider by both G2 and TrustRadius.

00:34:05.780 --> 00:34:11.460
From their award-winning support, which is offered 24, 7, 365 to every level of user,

00:34:11.460 --> 00:34:15.940
to the ease of use and setup, it's clear why developers have been trusting Linode for

00:34:15.940 --> 00:34:18.520
projects both big and small since 2003.

00:34:18.860 --> 00:34:24.100
Deploy your entire application stack with Linode's one-click app marketplace or build

00:34:24.100 --> 00:34:28.440
it all from scratch and manage everything yourself with supported centralized tools like Terraform.

00:34:28.440 --> 00:34:34.680
Linode offers the best price-to-performance value for all compute instances, including GPUs

00:34:34.680 --> 00:34:39.060
as well as block storage, Kubernetes, and their upcoming bare metal release.

00:34:39.060 --> 00:34:44.960
Linode makes cloud computing fast, simple, and affordable, allowing you to focus on your

00:34:44.960 --> 00:34:46.860
projects, not your infrastructure.

00:34:46.860 --> 00:34:52.120
Visit talkpython.fm/Linode and sign up with your Google account, your GitHub account,

00:34:52.120 --> 00:34:55.280
or your email address, and you'll get $100 in credit.

00:34:55.280 --> 00:35:00.360
That's talkpython.fm/Linode, or just click the link in your podcast player's show notes.

00:35:00.360 --> 00:35:02.420
And thank them for supporting Talk Python.

00:35:02.420 --> 00:35:07.220
Quick comment back to the monolith.

00:35:07.220 --> 00:35:13.440
Tolines says, can you speak to microservices versus monolith, in particular for ML applications?

00:35:14.080 --> 00:35:16.080
I think that's a little bit different.

00:35:16.080 --> 00:35:17.880
I haven't really thought of it from an ML perspective.

00:35:17.880 --> 00:35:18.540
You got thoughts?

00:35:18.540 --> 00:35:23.320
My decent, a decent rule of thumb is, are you working on a web application where there's

00:35:23.320 --> 00:35:25.360
hundreds of developers working on that application?

00:35:25.360 --> 00:35:27.520
And the answer is yes.

00:35:27.520 --> 00:35:32.700
Then someone in the organization is going to bring up microservices.

00:35:32.700 --> 00:35:37.580
Anything smaller than that, just don't think about it.

00:35:37.580 --> 00:35:42.640
Once you're small enough, I tend to feel the same way about Kubernetes.

00:35:42.640 --> 00:35:48.840
There's a lot of technologies for a company with 5,000 people or 500 people or 50 people

00:35:48.840 --> 00:35:50.060
or five people or one person.

00:35:50.060 --> 00:35:54.120
Each organizational size, you're going to want different technologies because different

00:35:54.120 --> 00:35:58.860
architectures because, when I say applications, we'll have 500 developers or five developers

00:35:58.860 --> 00:36:03.360
because your ability to specialize, your ability to build infrastructure are different.

00:36:03.360 --> 00:36:08.820
And so if it's a thing that an organization that has thousands of developers working, like,

00:36:08.820 --> 00:36:10.080
are you building Pinterest?

00:36:10.080 --> 00:36:11.140
Probably not.

00:36:11.140 --> 00:36:15.240
Then the technology sources Pinterest makes may not be relevant to you.

00:36:15.240 --> 00:36:15.480
Yeah.

00:36:15.480 --> 00:36:19.320
I think maybe another consideration is how much is part of that functionality shared?

00:36:19.320 --> 00:36:24.440
Are you building an API that has some models that make some prediction that a whole bunch

00:36:24.440 --> 00:36:28.580
of your company and different apps and websites and such might need?

00:36:28.580 --> 00:36:30.260
And, you know, maybe that's its own thing.

00:36:30.260 --> 00:36:34.200
But if it's only being shared in one place, maybe not.

00:36:34.200 --> 00:36:37.640
There's an interesting article that was from 2019.

00:36:37.640 --> 00:36:39.540
Might be worth people checking out.

00:36:39.540 --> 00:36:44.660
It's called Give Me Back My Monolith from Craig Kirsten's.

00:36:44.660 --> 00:36:48.440
Anyway, I'm not going to go into it here, but it's kind of an interesting read.

00:36:48.440 --> 00:36:49.660
People can check that out if they want.

00:36:49.660 --> 00:36:50.340
All right.

00:36:50.340 --> 00:36:52.860
We talked about faster builds and small images now.

00:36:52.860 --> 00:36:53.440
We're there.

00:36:53.440 --> 00:36:54.360
Tell us about that.

00:36:54.360 --> 00:36:56.680
People who are new to Docker, haven't done a lot with Docker.

00:36:56.680 --> 00:37:04.280
There's a lot of things you can do to result in a smaller, physically a smaller image size,

00:37:04.280 --> 00:37:04.480
right?

00:37:04.480 --> 00:37:06.080
A smaller file on disk.

00:37:06.080 --> 00:37:06.280
Yeah.

00:37:06.280 --> 00:37:12.120
It's very easy to get a giant image in Docker because the Docker image format is basically

00:37:12.120 --> 00:37:14.080
in many ways like a Git history.

00:37:14.080 --> 00:37:17.360
So every time you make a change, it's not overriding.

00:37:17.580 --> 00:37:18.340
It's adding.

00:37:18.340 --> 00:37:19.700
So there's a history there.

00:37:19.700 --> 00:37:20.960
The history is always there.

00:37:20.960 --> 00:37:25.340
So if you delete a file, it doesn't make the Docker image any smaller if it was added in

00:37:25.340 --> 00:37:25.940
a previous layer.

00:37:25.940 --> 00:37:26.160
Right.

00:37:26.160 --> 00:37:27.960
If it was added in a different layer, that's right.

00:37:27.960 --> 00:37:28.300
Yeah.

00:37:28.300 --> 00:37:31.660
If you structure things right, there's a bunch you can do to make your images smaller.

00:37:31.920 --> 00:37:39.300
And similarly, Docker has a bunch of features to allow you to not have to run pip install

00:37:39.300 --> 00:37:42.780
every single time you rebuild your image because the dependencies haven't changed.

00:37:42.780 --> 00:37:46.660
So it can just cache those files for you, but you have to set it up right.

00:37:46.660 --> 00:37:47.180
So it does that.

00:37:47.180 --> 00:37:54.060
And you can go from a half an hour build to a one minute build depending on how you built

00:37:54.060 --> 00:37:54.720
your Docker image.

00:37:55.100 --> 00:37:59.820
So LP Linux being my current favorite example, although maybe that's going to get fixed over

00:37:59.820 --> 00:38:00.280
the next year.

00:38:00.280 --> 00:38:04.680
One of the things that's super interesting about that as well is the ordering as well as the

00:38:04.680 --> 00:38:08.600
grouping of those commands can really matter.

00:38:08.600 --> 00:38:14.760
So for example, if the first thing that you do in your Docker file is to copy over your source

00:38:14.760 --> 00:38:19.220
code, then the next thing to do is to do an apps update, apps upgrade.

00:38:19.360 --> 00:38:24.400
Then the next thing to do is to install the dependencies and so on and so on.

00:38:24.400 --> 00:38:24.600
Right.

00:38:24.600 --> 00:38:30.160
Every time any file that you're working on, even like an unrelated CSS file changes, everything

00:38:30.160 --> 00:38:31.460
below that has to be rebuilt.

00:38:31.460 --> 00:38:31.740
Right.

00:38:31.740 --> 00:38:34.820
And if you make a point to say, well, let's reorder that.

00:38:34.820 --> 00:38:37.660
So the very last thing we do is copy our files over.

00:38:37.660 --> 00:38:42.020
Then as you make changes, like you won't, those other layers will just be up to date.

00:38:42.020 --> 00:38:46.780
And one cool trick that I've seen that you can make that even better is somewhere in that

00:38:46.780 --> 00:38:47.480
intermediate bit.

00:38:47.480 --> 00:38:53.600
You could even copy your requirements or pyproject.toml file over and then install those and then

00:38:53.600 --> 00:38:57.240
copy the rest of your code over, which looks like a stupid duplication.

00:38:57.240 --> 00:38:58.660
Like, why are you just copying this one file?

00:38:58.660 --> 00:39:04.000
You already copied it in the next one, but you can cache that pip install, pip compile step,

00:39:04.000 --> 00:39:04.920
make it faster.

00:39:04.920 --> 00:39:05.240
Yeah.

00:39:05.240 --> 00:39:11.040
But basically, if you understand how Docker caching works, then you can sort of structure

00:39:11.040 --> 00:39:12.180
Docker file in the right way.

00:39:12.180 --> 00:39:14.040
And then you get caching.

00:39:14.500 --> 00:39:18.560
Then you need extra steps to get it working in CI, but you can get a much faster build.

00:39:18.560 --> 00:39:19.160
So it'll work.

00:39:19.160 --> 00:39:20.320
The fast scene is super clear.

00:39:20.320 --> 00:39:21.680
Tell us about smaller though.

00:39:21.680 --> 00:39:23.300
What do you really focus on for smaller?

00:39:23.300 --> 00:39:29.320
So some of it is just things where various packaging tools are optimized for development

00:39:29.320 --> 00:39:29.900
by default.

00:39:30.240 --> 00:39:35.480
So if you do pip install and you do something like NumPy, this can be, or if you're, let's

00:39:35.480 --> 00:39:41.460
say, let's go, the big packages, like things like TensorFlow, like these packages, some of

00:39:41.460 --> 00:39:42.880
these packages are hundreds of megabytes.

00:39:42.880 --> 00:39:44.620
Like they're just huge.

00:39:44.620 --> 00:39:49.040
So you download the package and then it unpacks it and installs all the files.

00:39:49.220 --> 00:39:53.600
And then by default, pip will keep a copy of that downloaded file in a directory.

00:39:53.600 --> 00:39:55.520
Probably the intermediate build output.

00:39:55.520 --> 00:39:57.140
The wheel file you downloaded.

00:39:57.140 --> 00:39:58.480
Potentially all that stuff.

00:39:58.480 --> 00:39:58.700
Yeah.

00:39:58.700 --> 00:40:00.520
It'll keep a copy of the wheel file.

00:40:00.520 --> 00:40:07.460
The idea is like you might be doing another virtual end in another two hours.

00:40:07.560 --> 00:40:10.320
And so when you do pip install, this time it can just, it doesn't have to download it.

00:40:10.320 --> 00:40:11.520
It can just use the cache version.

00:40:11.520 --> 00:40:13.840
And for development, that's great.

00:40:13.840 --> 00:40:18.820
But for a Docker image, you are never going to call pip install again.

00:40:18.820 --> 00:40:22.900
So keeping this file is just like an extra 400 megabytes of this space.

00:40:22.900 --> 00:40:25.220
And so there's a command line option for pip install.

00:40:25.220 --> 00:40:27.580
It says --no cache there.

00:40:27.580 --> 00:40:27.880
Yeah.

00:40:27.880 --> 00:40:28.940
And then it doesn't keep a copy.

00:40:28.940 --> 00:40:34.520
And now you're, you haven't, you're free to put a bunch of space by adding, which can be

00:40:34.520 --> 00:40:38.940
fairly considerable if you're doing certain, especially for data science tools.

00:40:38.940 --> 00:40:39.200
Right.

00:40:39.200 --> 00:40:43.140
You add it up across all the dependencies and their transitive dependencies and so on.

00:40:43.140 --> 00:40:43.300
Right.

00:40:43.300 --> 00:40:43.640
Yeah.

00:40:43.640 --> 00:40:46.700
That's like just not storing files you don't need.

00:40:46.700 --> 00:40:52.100
One of the mind shifts you got to get into to work with this stuff is you will never, ever

00:40:52.100 --> 00:40:54.380
change the Docker configuration.

00:40:54.380 --> 00:40:55.100
Right.

00:40:55.100 --> 00:40:57.020
It's not like, oh, there's updates to Linux.

00:40:57.020 --> 00:41:00.520
So I'm going to go in and like app update it, or there's an update to my requirements.

00:41:00.520 --> 00:41:02.360
So I'm going to reinstall the requirements.

00:41:02.820 --> 00:41:05.840
You recreate a new Docker image and you throw away the old Docker image.

00:41:05.840 --> 00:41:06.160
Right.

00:41:06.160 --> 00:41:09.880
So there's a lot of the things that are there to make that next step.

00:41:09.880 --> 00:41:10.340
Right.

00:41:10.340 --> 00:41:16.580
Pip installing, again, work well are just liabilities and negative effects on your Docker image.

00:41:16.580 --> 00:41:16.780
Right.

00:41:16.780 --> 00:41:17.080
Yeah.

00:41:17.080 --> 00:41:23.360
Because Docker images are sort of designed to be treated as immutable artifacts, which is

00:41:23.360 --> 00:41:24.540
sort of great.

00:41:24.540 --> 00:41:28.200
But also like you're dealing with a whole bunch of tools that don't really have that assumption.

00:41:28.200 --> 00:41:33.220
And so you have to figure out ways to make those two conflicting goals work together.

00:41:33.220 --> 00:41:33.500
Yeah.

00:41:33.500 --> 00:41:39.100
Another interesting thing that Peter brought up, Peter McKee in the other episode we did

00:41:39.100 --> 00:41:43.900
not too long ago, was intermediate frameworks and all sorts of stuff.

00:41:43.900 --> 00:41:49.220
It doesn't apply super well to the Python space, but maybe there's certain aspects, especially

00:41:49.220 --> 00:41:50.980
in the data science side that might.

00:41:51.380 --> 00:41:55.780
So for example, if you're going to install like the development setup for Python, not

00:41:55.780 --> 00:41:59.180
just the ability to run, but to do pip installs and do all sorts of things.

00:41:59.180 --> 00:42:04.140
The example he gave was if you're going to have something that runs in Go, well, one of the

00:42:04.140 --> 00:42:08.140
steps you might install might do is like, well, we're going to install the Go compiler and

00:42:08.140 --> 00:42:08.920
all that business.

00:42:08.920 --> 00:42:10.680
And we're going to compile the artifact.

00:42:10.680 --> 00:42:11.700
And then you would try to run it.

00:42:11.760 --> 00:42:16.340
It's like, you create a separate container that will take the code and compile it and

00:42:16.340 --> 00:42:20.740
give you the binary, just copy the binary without the compiler back in there.

00:42:20.740 --> 00:42:22.280
So maybe there's some techniques like that.

00:42:22.280 --> 00:42:22.640
I don't know.

00:42:22.640 --> 00:42:27.600
I mean, I don't see it quite as well in Python because we can't fully package it up as reliably.

00:42:27.600 --> 00:42:28.380
But yeah.

00:42:28.380 --> 00:42:33.900
So a common, so this happens a bunch if you're compiling your own custom C extensions.

00:42:33.900 --> 00:42:34.620
Yeah.

00:42:34.620 --> 00:42:38.000
So one way you can deal with that is like, you can have a thing that generates wheels and

00:42:38.000 --> 00:42:41.500
then like you build your Docker image, you just download the compiled wheel.

00:42:41.500 --> 00:42:45.240
But if you want to do it in your Docker image, you're going to have to install a compiler,

00:42:45.240 --> 00:42:49.040
but then you don't, that compiler package is going to be in your final image.

00:42:49.040 --> 00:42:50.760
So it just makes your image bigger.

00:42:50.760 --> 00:42:51.880
You don't need GCC.

00:42:51.880 --> 00:42:56.380
And so you can use a multi-stage build, which is probably what he was describing.

00:42:56.380 --> 00:42:56.960
Yeah.

00:42:56.960 --> 00:43:02.400
So the one easy way to do that is you create a virtual env, install all your code, and then

00:43:02.400 --> 00:43:05.840
you copy just the virtual env into a new Docker image.

00:43:06.380 --> 00:43:10.060
And then the new Docker image just has the resulting self-contained virtual env, doesn't

00:43:10.060 --> 00:43:11.800
have any of the compilers that you needed to build it.

00:43:11.800 --> 00:43:11.980
Right.

00:43:11.980 --> 00:43:14.120
No matter what else might've been over there.

00:43:14.120 --> 00:43:14.380
Yeah.

00:43:14.380 --> 00:43:14.640
Yeah.

00:43:14.640 --> 00:43:18.240
Maybe you could even use something like PEX if you really cared to like compile that or

00:43:18.240 --> 00:43:20.800
to bundle that into a zip and then run that directly.

00:43:20.800 --> 00:43:22.200
I'm not sure, but possibly.

00:43:22.200 --> 00:43:22.740
Yeah.

00:43:22.740 --> 00:43:27.160
Tim out there in the live stream says, dash dash, no cash dir has made my evening.

00:43:27.160 --> 00:43:27.560
Thanks.

00:43:27.560 --> 00:43:28.720
I never thought about it.

00:43:28.720 --> 00:43:30.660
The intermediate files from pip only from app.

00:43:30.660 --> 00:43:31.020
Yeah.

00:43:31.020 --> 00:43:35.520
Then also Docker on build option can help a bit with that scenario.

00:43:35.520 --> 00:43:36.080
Yeah.

00:43:36.080 --> 00:43:36.980
But not including the dev tools.

00:43:36.980 --> 00:43:37.260
Okay.

00:43:37.260 --> 00:43:37.920
That's cool.

00:43:37.920 --> 00:43:41.820
I may have deprecated on builds, but I could be misremembering.

00:43:41.820 --> 00:43:43.680
That would be too bad because I just learned about it.

00:43:43.680 --> 00:43:45.320
Okay.

00:43:45.320 --> 00:43:49.840
Those are the six things that you talk about in this iterative process or this layered process.

00:43:49.840 --> 00:43:55.320
It's like step one, your first deliverable or your first package of this as Docker sprint

00:43:55.320 --> 00:44:00.580
would be get something working in either the single container or the suite of containers

00:44:00.580 --> 00:44:01.440
from Docker Compose.

00:44:01.440 --> 00:44:03.380
Step two is make sure they're secure.

00:44:03.380 --> 00:44:04.980
Step three, getting them running in CI.

00:44:04.980 --> 00:44:08.240
Step four, make sure that they're correct and debuggable.

00:44:08.240 --> 00:44:14.400
Number five is reproducibility with that balance of not exactly the latest, but not super old

00:44:14.400 --> 00:44:14.780
and stale.

00:44:14.780 --> 00:44:17.080
And then finally fast builds and small images.

00:44:17.080 --> 00:44:17.420
Yeah.

00:44:17.420 --> 00:44:22.580
And then along the way, there's a whole bunch of different things you can do depending what

00:44:22.580 --> 00:44:25.700
tools you're using and like what's your priorities are.

00:44:25.700 --> 00:44:26.740
And yeah.

00:44:26.740 --> 00:44:28.860
Can maybe give some examples if we have time.

00:44:28.860 --> 00:44:29.660
Yeah, absolutely.

00:44:29.660 --> 00:44:30.540
We got a little bit of time.

00:44:30.540 --> 00:44:31.140
I thought that'd be fun.

00:44:31.140 --> 00:44:38.440
So we could dive into just get something working, which is like a hand line of a couple of lines

00:44:38.440 --> 00:44:39.840
in Docker, like see Docker symbol.

00:44:39.840 --> 00:44:40.140
Yeah.

00:44:40.140 --> 00:44:40.700
Yeah.

00:44:40.700 --> 00:44:45.540
You choose a base image, copy your code and run pip install and say, this is what I want

00:44:45.540 --> 00:44:46.540
you to run when you start up.

00:44:46.540 --> 00:44:48.760
And for many applications, I'll do the trick.

00:44:48.760 --> 00:44:53.680
So I'm always wondering what is a good container base to start from, right?

00:44:53.680 --> 00:44:59.120
So you have this Python 3.9 Slim Buster version as the base.

00:44:59.120 --> 00:44:59.620
Yeah.

00:44:59.620 --> 00:45:00.860
There's a bunch of different options, right?

00:45:00.860 --> 00:45:01.840
What do you think?

00:45:01.840 --> 00:45:06.280
So the first thing is you want a, these are all based on Linux distributions typically.

00:45:06.420 --> 00:45:10.600
So you want a Linux distribution that's some sort of long-term support where like they are

00:45:10.600 --> 00:45:16.640
both guaranteeing backwards compatibility in terms of like binary ABIs, but also in terms

00:45:16.640 --> 00:45:18.840
of features, but they're also doing security backboards.

00:45:19.000 --> 00:45:24.720
So like Debian stable, Ubuntu long-term support, Red Hat Enterprise Linux, they all are going

00:45:24.720 --> 00:45:27.260
to give you this stability guarantee.

00:45:27.260 --> 00:45:31.420
They'll say, we'll give you a stable operating system with security updates to it.

00:45:31.420 --> 00:45:33.300
So you want something that's based on one of those probably.

00:45:33.720 --> 00:45:37.540
And then you need to, you typically are going to want a up-to-date Python.

00:45:37.540 --> 00:45:43.100
And these distributions will sometimes like backport, new versions of Python.

00:45:43.100 --> 00:45:44.680
And so you can use that.

00:45:44.680 --> 00:45:50.100
So you can say, I'm going to use like Ubuntu long-term support from 2020.

00:45:50.100 --> 00:45:54.440
And like it has Python 3.8 and maybe they just added 3.9.

00:45:54.440 --> 00:45:54.960
I'm not sure.

00:45:54.960 --> 00:45:56.280
I saw something to that effect.

00:45:56.880 --> 00:45:57.740
And then you can go with that.

00:45:57.740 --> 00:46:04.340
Or Docker maintains these things for the official, in quotes, Docker images for Python.

00:46:04.340 --> 00:46:09.180
And basically what they do is they take Debian stable and then they compile all the different

00:46:09.180 --> 00:46:10.340
versions of Python for it.

00:46:10.340 --> 00:46:14.840
So you can get 3.7 or 3.8 or 3.9 and 3.10 when it comes out, regardless of what's in Debian

00:46:14.840 --> 00:46:15.180
stable.

00:46:15.180 --> 00:46:17.360
So it's Debian stable plus an extra Python.

00:46:17.360 --> 00:46:22.740
So Python colon 3.9 is Debian stable plus 3.9.

00:46:22.740 --> 00:46:24.100
Then they have two variants.

00:46:24.100 --> 00:46:26.580
One has a bunch of extra packages and one has fewer.

00:46:27.120 --> 00:46:29.160
One with fewer packages is the dash slim.

00:46:29.160 --> 00:46:33.100
And then the dash buster is which version of Debian you're using.

00:46:33.100 --> 00:46:38.500
And the reason you don't have to specify that, but like maybe like at the end of the year,

00:46:38.500 --> 00:46:41.080
maybe early next year, there's going to be a new version of Debian stable.

00:46:41.080 --> 00:46:46.340
And so you don't want overnight to go from Debian 10 to Debian 11 as your base image.

00:46:46.340 --> 00:46:51.740
You would probably want to just at least do that consciously, right?

00:46:51.740 --> 00:46:55.980
And so saying dash buster means I want to stick to Debian 10 buster.

00:46:56.440 --> 00:47:00.300
And for those who don't know, Debian Linux releases are based on Toy Story characters.

00:47:00.300 --> 00:47:01.300
Nice.

00:47:01.300 --> 00:47:03.360
So Buster is one of them, right?

00:47:03.360 --> 00:47:03.800
Yeah.

00:47:03.800 --> 00:47:07.080
And I don't remember what the next one is.

00:47:07.080 --> 00:47:09.700
There's Debian unstable, which is named CID.

00:47:09.700 --> 00:47:12.200
It's always Debian unstable and it's always CID.

00:47:12.200 --> 00:47:13.100
They never release it.

00:47:13.600 --> 00:47:14.240
That's cool.

00:47:14.240 --> 00:47:14.800
All right.

00:47:14.800 --> 00:47:21.660
So in this example, it's the Docker file says from Python colon 3.9 dash slim dash buster,

00:47:21.660 --> 00:47:24.340
which means all the stuff that you described there.

00:47:24.340 --> 00:47:29.080
And then you copy your files over, you run pip install to install the dependencies.

00:47:29.080 --> 00:47:32.240
And then you just basically start your app as the entry point.

00:47:32.240 --> 00:47:34.160
And that is, hey, we got something working.

00:47:34.160 --> 00:47:36.620
This is probably an oversimplification.

00:47:36.840 --> 00:47:41.560
There might be a database thing that also needs to start up and run its bits and so on.

00:47:41.560 --> 00:47:43.200
But yeah, that's pretty much it, right?

00:47:43.200 --> 00:47:44.360
It's pretty simple.

00:47:44.360 --> 00:47:49.360
Typically pretty simple to just get everything's working because it's just install some packages

00:47:49.360 --> 00:47:52.260
and then tell it to run the scripts when you run a container.

00:47:52.260 --> 00:47:52.560
Yeah.

00:47:52.980 --> 00:47:57.660
It's pretty much whatever you need to do to get a new machine set up to run this,

00:47:57.660 --> 00:47:59.600
do that in this file and you're good to go.

00:47:59.600 --> 00:47:59.880
Yeah.

00:47:59.880 --> 00:48:04.720
And I guess seeing a comment on the chat and I should add that as far as I can tell,

00:48:04.720 --> 00:48:08.900
Docker on build is not deprecated, but I'm not sure.

00:48:08.900 --> 00:48:09.640
So maybe.

00:48:09.640 --> 00:48:10.100
All right.

00:48:10.100 --> 00:48:10.380
All right.

00:48:10.380 --> 00:48:11.360
I'll have to look into it.

00:48:11.360 --> 00:48:12.800
Sounds good.

00:48:12.800 --> 00:48:15.160
So getting it working is super straightforward.

00:48:15.160 --> 00:48:15.560
Yep.

00:48:15.560 --> 00:48:18.120
But getting something secure is interesting.

00:48:18.120 --> 00:48:19.140
Let me go back.

00:48:19.140 --> 00:48:20.640
I think we might be skipping around a bit,

00:48:20.720 --> 00:48:25.160
but you're talking about having that version specified there of Slim Buster.

00:48:25.160 --> 00:48:30.840
I know how we'll get new dependencies for the Python code up there.

00:48:30.840 --> 00:48:32.460
And if there's some kind of security problem,

00:48:32.460 --> 00:48:37.880
what will probably happen is Dependabot on GitHub will send me a PR that says,

00:48:37.880 --> 00:48:41.700
warning, warning, your version of web framework has such and such CVE.

00:48:41.700 --> 00:48:42.800
We've created a PR.

00:48:42.800 --> 00:48:43.960
You accept it.

00:48:43.960 --> 00:48:45.700
You push it back to the right branch.

00:48:45.700 --> 00:48:48.700
That kicks off the whole process and everything goes again, right?

00:48:49.000 --> 00:48:55.020
That keeps like the flow of the somewhat fresh code and dependencies going through your system.

00:48:55.020 --> 00:49:00.020
However, how do I keep that same thing happening for Linux, right?

00:49:00.020 --> 00:49:04.320
Suppose Linux has some security vulnerability in the version that I've got,

00:49:04.320 --> 00:49:08.980
or I've got Nginx running and it has something like that I need to update.

00:49:08.980 --> 00:49:12.060
Like, what is the trigger that helps me know?

00:49:12.060 --> 00:49:14.060
Like, what is the process that helps me know?

00:49:14.400 --> 00:49:19.700
Oh, you need to, even if this is a somewhat stable, stale project that we haven't touched for a month,

00:49:19.700 --> 00:49:23.920
you need to somehow go give it a kick to like force it to get the latest and do that again.

00:49:23.920 --> 00:49:27.260
Because there's no auto app upgrade running there.

00:49:27.260 --> 00:49:27.560
Yeah.

00:49:27.560 --> 00:49:31.360
So one thing to note is some people assume that the Debian,

00:49:31.360 --> 00:49:34.680
like the official Python or even official Debian or whatever,

00:49:34.680 --> 00:49:38.740
the official base images from Docker get security updates every time they come out.

00:49:38.740 --> 00:49:39.500
They don't.

00:49:39.820 --> 00:49:42.600
Some of them get updated fairly frequently.

00:49:42.600 --> 00:49:46.940
Some of them, like the CentOS one, which I guess people are probably switching away from,

00:49:46.940 --> 00:49:49.840
but for a while it was a lot of people probably using it.

00:49:49.840 --> 00:49:53.300
The CentOS base image will not be updated for months at a time.

00:49:53.300 --> 00:49:57.720
And so they are relying on, and the Debian ones,

00:49:57.720 --> 00:50:00.700
well, I have seen them like lag on security updates by two weeks.

00:50:00.880 --> 00:50:04.780
So Debian has released a new security update, but the Docker image hasn't been updated.

00:50:04.780 --> 00:50:07.020
Which is not ideal because you're telling all the hackers,

00:50:07.020 --> 00:50:11.740
here's the problem that you can just go look for in systems that lag on getting their patches.

00:50:11.740 --> 00:50:12.120
Yeah.

00:50:12.120 --> 00:50:18.740
And so you as someone who is creating a Docker image cannot rely on the base images to be up to date.

00:50:18.740 --> 00:50:22.440
You need to install security updates when you build your Docker image.

00:50:22.440 --> 00:50:23.320
But what's that look like?

00:50:23.960 --> 00:50:28.280
The step two is apt update, apt upgrade, dash Y, or something like that?

00:50:28.280 --> 00:50:28.460
Yeah.

00:50:28.460 --> 00:50:31.280
apt get update, and then apt get minus Y upgrade.

00:50:31.280 --> 00:50:34.660
You can add a few more command line options to make your image smaller.

00:50:34.660 --> 00:50:36.040
But yeah, it's basically you do an upgrade.

00:50:36.040 --> 00:50:38.100
But there's a problem.

00:50:38.100 --> 00:50:40.960
Docker has, as we talked about, has this caching thing,

00:50:40.960 --> 00:50:44.620
where if you rebuild an image and nothing's changed, it will just use a cache layer.

00:50:45.080 --> 00:50:48.560
So when you rebuild your image, if you are using caching to speed up builds,

00:50:48.560 --> 00:50:51.800
it'll look at Docker apt get, look at the apt get update, apt get upgrade,

00:50:51.800 --> 00:50:53.160
and say, well, this is unchanged.

00:50:53.160 --> 00:50:54.220
Same command.

00:50:54.220 --> 00:50:56.080
And so it'll just use a cache layer.

00:50:56.080 --> 00:50:56.380
Yeah.

00:50:56.380 --> 00:50:59.180
And you absolutely will very likely be doing that.

00:50:59.180 --> 00:51:04.620
Because it's like five minutes versus three seconds to restart and build and test your app.

00:51:04.620 --> 00:51:06.660
So everyone is going to be using the caching.

00:51:06.660 --> 00:51:09.020
Maybe not CI, CD, but everywhere else.

00:51:09.020 --> 00:51:12.100
I mean, you probably typically will want it in CI, CD too.

00:51:12.260 --> 00:51:16.820
And so the result is that if you've set up caching to speed things up,

00:51:16.820 --> 00:51:19.060
that caching will ensure you don't get security updates.

00:51:19.060 --> 00:51:26.000
And so basically what you have to do is just have this process where once a day or once a week,

00:51:26.000 --> 00:51:31.420
or in response to CVs coming out, you rebuild your image from scratch without caching.

00:51:31.420 --> 00:51:35.400
So you can just say every night at 3 a.m. when no one's working,

00:51:35.400 --> 00:51:39.720
we are going to rebuild our image from scratch without caching.

00:51:40.260 --> 00:51:45.460
And so our image will always have the latest security updates.

00:51:45.460 --> 00:51:47.980
And then if you're in a system that has continuous deployment,

00:51:47.980 --> 00:51:50.180
you can then just automatically deploy that.

00:51:50.180 --> 00:51:53.900
Wait, how do you make the little banner that says you're going to be down Sunday from 3 to 5

00:51:53.900 --> 00:51:54.780
when you do that part?

00:51:54.780 --> 00:51:55.440
Just kidding.

00:51:55.440 --> 00:51:56.140
Yeah.

00:51:56.220 --> 00:52:02.820
So this is easier if you have a process that you trust enough to do automatic deploys like anytime you want.

00:52:02.820 --> 00:52:07.740
But you basically have to rebuild your image from scratch without caching,

00:52:07.740 --> 00:52:14.200
either whenever a security update comes out or just on a regular basis and redeploy if it's a server,

00:52:14.420 --> 00:52:19.000
because you have these immutable artifacts that if you're running a VM,

00:52:19.000 --> 00:52:24.220
like you can just have like a cron job that installs security updates nightly.

00:52:24.220 --> 00:52:26.580
Like there's unattended upgrades package in Debian.

00:52:26.580 --> 00:52:28.480
For Docker images, you can't do that.

00:52:28.480 --> 00:52:32.160
And so you have to rebuild from scratch with security updates and then redeploy.

00:52:32.160 --> 00:52:33.980
And this is an ongoing process.

00:52:34.260 --> 00:52:38.900
Yeah, I'm glad you pointed out the caching because it's not enough to go out and say,

00:52:38.900 --> 00:52:42.280
oh, every once a day or once a week, we'll just do a Docker build.

00:52:42.280 --> 00:52:43.000
Oh, it's up to date.

00:52:43.000 --> 00:52:43.760
Actually, we're good.

00:52:43.760 --> 00:52:44.980
Yeah, no.

00:52:44.980 --> 00:52:46.040
Not so much.

00:52:46.040 --> 00:52:47.400
Yeah.

00:52:47.400 --> 00:52:47.640
Yeah.

00:52:47.640 --> 00:52:49.360
And that's why I brought this up because I think it's tricky.

00:52:49.360 --> 00:52:53.840
Like there's a natural flow that like kicks that refresh cycle off for code,

00:52:53.840 --> 00:52:57.740
but not for the infrastructure itself, unless you think about it.

00:52:57.740 --> 00:52:58.360
Yeah.

00:52:58.360 --> 00:53:01.580
So you need to explicitly think about and set up these processes,

00:53:01.580 --> 00:53:03.560
either some way to get notified of CVs

00:53:03.560 --> 00:53:09.300
or you can probably, if you have a bunch of registries, have security scanners.

00:53:09.300 --> 00:53:12.480
They'll scan your images for security problems.

00:53:12.480 --> 00:53:14.600
And so you can run those in a schedule, maybe.

00:53:14.600 --> 00:53:19.020
Honestly, the easiest though is probably just do a forced rebuild 5 a.m. or something.

00:53:19.020 --> 00:53:19.500
Yeah.

00:53:19.500 --> 00:53:24.440
And that next time every developer that comes in and runs the command Docker compose up,

00:53:24.440 --> 00:53:25.480
going to do a Docker build.

00:53:25.480 --> 00:53:28.940
It's going to see the things out of date and it'll just trigger a let's get the fresh.

00:53:28.940 --> 00:53:29.220
Yeah.

00:53:29.220 --> 00:53:29.520
Yeah.

00:53:29.520 --> 00:53:33.140
And it turns out security scanners are also have some,

00:53:33.360 --> 00:53:34.660
bad defaults.

00:53:34.660 --> 00:53:36.100
So you'll get,

00:53:36.100 --> 00:53:39.240
there's a lot of security problems that are not really problems.

00:53:39.240 --> 00:53:42.560
Like the upstream maintainer has closed it as won't fix,

00:53:42.560 --> 00:53:47.080
or it's not going to get fixed in Debian stable until the next release of Debian stable.

00:53:47.080 --> 00:53:50.480
And so the Debian maintainers are basically have decided that it is not worth fixing.

00:53:50.480 --> 00:53:51.880
And so there's nothing you can do.

00:53:51.880 --> 00:53:53.980
Most security scanners will flag those.

00:53:53.980 --> 00:53:56.700
And so you'll run a scanner on an updated image and it'll say,

00:53:56.700 --> 00:53:58.720
you have 60 security vulnerabilities.

00:53:59.120 --> 00:53:59.620
But you,

00:53:59.620 --> 00:54:04.100
if you turn on the flag that says only tell me about security vulnerabilities that I can actually fix,

00:54:04.100 --> 00:54:05.600
that actually have updates from Debian.

00:54:05.600 --> 00:54:07.620
And then you run that and it'll say you're fine.

00:54:08.040 --> 00:54:11.780
And that is probably a much more realistic assessment of your risk because it's like,

00:54:11.780 --> 00:54:16.900
there are bugs that are never going to be fixed because the GLAB C maintainers have said,

00:54:16.900 --> 00:54:17.520
no,

00:54:17.520 --> 00:54:18.160
won't fix.

00:54:18.160 --> 00:54:19.060
This is not our problem.

00:54:19.060 --> 00:54:19.880
It's like,

00:54:19.880 --> 00:54:20.740
it's not a real bug.

00:54:20.740 --> 00:54:20.980
Yeah.

00:54:21.100 --> 00:54:25.320
I suspect you could also get notified about things that like are not observable really.

00:54:25.320 --> 00:54:25.800
So,

00:54:25.800 --> 00:54:26.360
oh,

00:54:26.360 --> 00:54:27.600
there's a problem in the system,

00:54:27.600 --> 00:54:32.120
but we actually have a firewall blocking that port and we have no interaction with it.

00:54:32.120 --> 00:54:32.320
Right.

00:54:32.320 --> 00:54:32.740
It's like,

00:54:32.740 --> 00:54:34.940
how much do you worry about those kinds of things?

00:54:34.940 --> 00:54:38.420
You may as well upgrade and redeploy because maybe one day your firewall will fail,

00:54:38.420 --> 00:54:43.920
but like there's a whole bunch of just like utter noise if you don't configure your securities

00:54:43.920 --> 00:54:44.500
kind of correctly.

00:54:44.500 --> 00:54:44.780
Yeah.

00:54:44.780 --> 00:54:45.320
All right.

00:54:45.320 --> 00:54:46.940
Wrapping up this bit of the topic,

00:54:46.940 --> 00:54:50.860
Kim says forced rebuild is a great for your own images based on Debian or other OS.

00:54:50.960 --> 00:54:52.560
You probably still need some kind of scanning.

00:54:52.560 --> 00:54:53.020
Yeah.

00:54:53.020 --> 00:54:54.240
If you're not able to build it yourself.

00:54:54.240 --> 00:54:54.700
Yeah.

00:54:54.700 --> 00:54:55.300
Makes sense.

00:54:55.300 --> 00:54:55.840
All right.

00:54:55.840 --> 00:54:57.940
We got a little bit of time to touch on a couple of things.

00:54:57.940 --> 00:55:01.980
One of the areas stage two was security.

00:55:01.980 --> 00:55:03.720
You always want different layers.

00:55:03.720 --> 00:55:04.720
I talked about a firewall.

00:55:04.720 --> 00:55:07.220
We're talking about security updates and patches,

00:55:07.220 --> 00:55:09.860
but there's layers of security you want.

00:55:09.860 --> 00:55:13.440
And one of the very straightforward ones is you probably don't want to run this as root.

00:55:13.440 --> 00:55:16.060
And like certain systems will even warn you about this.

00:55:16.060 --> 00:55:19.340
So if I try to pseudo brew something on my Mac,

00:55:19.340 --> 00:55:20.000
it'll complain.

00:55:20.100 --> 00:55:20.740
Like you should never,

00:55:20.740 --> 00:55:21.760
ever run brew as root.

00:55:21.760 --> 00:55:22.320
What are you doing?

00:55:22.320 --> 00:55:22.960
Are you crazy?

00:55:22.960 --> 00:55:23.660
Stop doing that.

00:55:23.660 --> 00:55:26.620
I think micro whiskey might warn that you're running this root.

00:55:26.620 --> 00:55:28.560
If you look at the logs when you started up.

00:55:28.560 --> 00:55:31.680
So when I run Docker and I just get that simple,

00:55:31.680 --> 00:55:32.440
get started one,

00:55:32.440 --> 00:55:33.220
what does that run as?

00:55:33.220 --> 00:55:33.480
Yeah.

00:55:33.480 --> 00:55:34.160
So by default,

00:55:34.160 --> 00:55:35.620
Docker runs as root.

00:55:35.620 --> 00:55:36.040
Oh,

00:55:36.040 --> 00:55:36.660
okay.

00:55:36.660 --> 00:55:40.920
That kind of makes sense because all these system packages are designed to be installed as

00:55:40.920 --> 00:55:41.160
root.

00:55:41.160 --> 00:55:44.220
And so if you're going to install system packages or install security updates,

00:55:44.220 --> 00:55:45.520
you have to be a root by default.

00:55:45.700 --> 00:55:47.320
But as soon as you've,

00:55:47.320 --> 00:55:49.740
you've switched to like installing your Python code,

00:55:49.740 --> 00:55:54.440
you should stop being root and create a new user and switch that user because otherwise

00:55:54.440 --> 00:55:58.380
your application will be running as root and root inside a container is more restricted,

00:55:58.380 --> 00:56:02.240
restricted, but it's still not as restricted as a normal user.

00:56:02.240 --> 00:56:08.320
And different runtime systems might take more aggressive steps to restrict what you can do.

00:56:08.320 --> 00:56:11.680
And so sometimes it might be okay, but just a good best practice.

00:56:11.680 --> 00:56:13.360
You're, you don't know where your things are going to run.

00:56:13.360 --> 00:56:14.160
Things might change around.

00:56:14.160 --> 00:56:15.560
Just don't run as root.

00:56:15.560 --> 00:56:16.740
What you're saying is basically,

00:56:16.740 --> 00:56:20.840
if you run as root in a Docker container and somebody takes over your container,

00:56:20.840 --> 00:56:24.700
well, the worst thing they can do is like crash around inside of the container.

00:56:24.860 --> 00:56:28.160
It's not like they now have full access to the machine, but, you know,

00:56:28.160 --> 00:56:30.940
maybe those rights are propagated onward.

00:56:30.940 --> 00:56:33.960
Like maybe they can do something else to, I don't know,

00:56:33.960 --> 00:56:37.060
decrypt something that then gets them further in the network.

00:56:37.060 --> 00:56:38.820
Like there's, there's challenges that could happen, right?

00:56:38.820 --> 00:56:45.280
So it is much easier to escape a container and onto the host if you're running as root,

00:56:45.280 --> 00:56:50.760
because you, like in Linux, security access is granted by these things called capabilities.

00:56:51.520 --> 00:56:54.460
And if you're root, you have a little bit more capabilities.

00:56:54.460 --> 00:56:57.500
It gives you a larger attack service on Linux kernel.

00:56:57.500 --> 00:57:01.380
And so if there's a bug in the Linux kernel, it's easier to take it over if you're root.

00:57:01.380 --> 00:57:05.300
There are other things you can do to like restrict all capabilities to containers,

00:57:05.300 --> 00:57:06.600
even if you're running as a normal user.

00:57:06.600 --> 00:57:11.940
So like if you're running the ping utility, for example, it gets a little bit of extra,

00:57:11.940 --> 00:57:13.880
it gets an extra capability often.

00:57:13.880 --> 00:57:15.240
So it can do a ping.

00:57:15.740 --> 00:57:20.000
And then if there's a bug in the ping command, then you can sort of,

00:57:20.000 --> 00:57:22.060
and you can insert code into it somehow,

00:57:22.060 --> 00:57:25.640
then it'll execute it with elevated privileges and you can do more stuff.

00:57:25.640 --> 00:57:25.980
And so.

00:57:25.980 --> 00:57:26.240
Yeah.

00:57:26.240 --> 00:57:27.500
You don't want that.

00:57:27.500 --> 00:57:27.980
Yeah.

00:57:28.020 --> 00:57:33.500
And so you want to like run as a normal user that will restrict the attack surface on the Linux kernel,

00:57:33.500 --> 00:57:38.020
like removing all capabilities or restrict the attack surface even more.

00:57:38.020 --> 00:57:39.660
And you do these things.

00:57:39.660 --> 00:57:42.980
And for many applications, it won't really matter too much,

00:57:42.980 --> 00:57:45.640
but it's very, it's not a lot of work.

00:57:45.640 --> 00:57:49.960
And it's like a little bit more assurance that if someone does somehow take over,

00:57:49.960 --> 00:57:53.260
you'll limit the damage they can cause because they're only restricted to this container.

00:57:53.260 --> 00:57:53.520
Yeah.

00:57:53.860 --> 00:57:54.100
Okay.

00:57:54.100 --> 00:57:54.640
Good advice.

00:57:54.640 --> 00:57:56.800
And that uses the add user Docker command.

00:57:56.800 --> 00:57:57.520
Very cool.

00:57:57.520 --> 00:58:00.860
And then let's see, what was the next one here?

00:58:00.860 --> 00:58:02.360
We talked about the security updates.

00:58:02.360 --> 00:58:04.180
Like that's, that's a challenge.

00:58:04.180 --> 00:58:08.320
So what do I need to think about for continuous integration automated builds,

00:58:08.320 --> 00:58:10.280
specifically with regard to Docker?

00:58:10.280 --> 00:58:12.020
Is there anything special?

00:58:12.020 --> 00:58:12.380
Like.

00:58:12.380 --> 00:58:15.960
So first it's just doing the actual work of automating it.

00:58:15.960 --> 00:58:20.940
So like you really, it's really nice if every time you push to your Git repository,

00:58:20.940 --> 00:58:23.180
every time you pull it across, it builds a Docker image for you.

00:58:23.500 --> 00:58:26.020
Because then like you can test it.

00:58:26.020 --> 00:58:29.080
Maybe you can write additional tests to actually use a Docker image,

00:58:29.080 --> 00:58:30.740
do integration tests, that sort of thing.

00:58:30.740 --> 00:58:30.980
Yeah.

00:58:30.980 --> 00:58:34.980
Like for example, there was a really cool framework or library.

00:58:34.980 --> 00:58:36.640
I can't remember exactly what it is.

00:58:36.640 --> 00:58:37.880
We talked about it on Python Byte.

00:58:37.880 --> 00:58:41.940
That instead of trying to mock out, say your database or,

00:58:41.940 --> 00:58:43.640
it was mostly databases.

00:58:43.640 --> 00:58:48.680
There's a Docker, there's like a testing library you can use that will bring up a Docker container

00:58:48.680 --> 00:58:51.100
running Mongo or Postgres or something,

00:58:51.100 --> 00:58:52.300
and then fill it with test data.

00:58:52.300 --> 00:58:54.300
And you just connect those things and say,

00:58:54.300 --> 00:58:55.860
yeah, you can talk to the database.

00:58:55.860 --> 00:58:56.280
You don't care.

00:58:56.280 --> 00:58:57.120
It's test data.

00:58:57.120 --> 00:58:57.860
Might as well.

00:58:57.860 --> 00:58:58.060
Yeah.

00:58:58.060 --> 00:59:00.680
Testing with a real database is so much easier these days.

00:59:00.680 --> 00:59:01.700
It'd just be the default.

00:59:01.700 --> 00:59:04.660
Like you shouldn't be, if you're didn't deploy with Postgres,

00:59:04.660 --> 00:59:07.700
you shouldn't test with SQLite because like they're different enough

00:59:07.700 --> 00:59:09.920
that there'll be bugs that you're going to miss.

00:59:09.920 --> 00:59:10.220
Yeah.

00:59:10.220 --> 00:59:14.520
And so once you have that automation of like building for every pull request,

00:59:14.520 --> 00:59:19.220
you don't, you start having this issue where you don't want the image you built

00:59:19.220 --> 00:59:23.740
for the feature one, two, three branch to overwrite your production image.

00:59:23.740 --> 00:59:24.960
That would be awkward.

00:59:24.960 --> 00:59:27.900
But you would still like continuous integration to do its job and say,

00:59:27.900 --> 00:59:29.000
you checked in this thing.

00:59:29.000 --> 00:59:30.600
It was okay or not okay.

00:59:30.600 --> 00:59:31.140
Yeah.

00:59:31.140 --> 00:59:35.380
And it's useful to have like images uploaded for every pull request that you can download

00:59:35.380 --> 00:59:36.360
and maybe play around with it.

00:59:36.640 --> 00:59:40.600
But you don't want feature branches images to interfere with your production image.

00:59:40.600 --> 00:59:46.180
One easy way to do that is to name your Docker images based on the Git branch.

00:59:46.180 --> 00:59:50.140
So like you can just use the Git branch as the part after the colon, the tag.

00:59:50.140 --> 00:59:55.180
So it can be like your image colon main, if it's the main branch or your image colon feature

00:59:55.180 --> 00:59:56.940
one, two, three, it's the feature one, two, three branch.

00:59:56.940 --> 00:59:57.200
Yeah.

00:59:57.200 --> 01:00:01.180
That works really well with like Git flow feature branch style programming as well.

01:00:01.180 --> 01:00:02.780
I created an issue.

01:00:02.780 --> 01:00:05.840
Then I create a branch named something along those lines.

01:00:05.940 --> 01:00:07.460
Then I create a PR along those lines.

01:00:07.460 --> 01:00:08.020
And oh, guess what?

01:00:08.020 --> 01:00:10.200
Here's the container that goes with that thing, right?

01:00:10.200 --> 01:00:10.500
Yeah.

01:00:10.500 --> 01:00:14.680
And you can also do things like name your Docker image based on the Git commit.

01:00:14.680 --> 01:00:18.420
So you can sort of go from Git commit to corresponding Docker image really easily.

01:00:18.420 --> 01:00:18.720
Yeah.

01:00:18.720 --> 01:00:19.120
Yeah.

01:00:19.120 --> 01:00:19.960
That's a really cool idea.

01:00:19.960 --> 01:00:22.980
I did find that package, by the way, in case people are interested.

01:00:22.980 --> 01:00:25.920
It's called test containers dash Python.

01:00:25.920 --> 01:00:30.880
Anyway, the idea is you just say like with my SQL container, do your tests.

01:00:30.880 --> 01:00:34.520
And it like literally creates a Docker container with your test data and all that stuff.

01:00:34.520 --> 01:00:35.780
So people can check that out.

01:00:35.820 --> 01:00:36.320
That's kind of cool.

01:00:36.320 --> 01:00:36.800
All right.

01:00:36.800 --> 01:00:39.480
Well, we're getting a little bit short on time here.

01:00:39.480 --> 01:00:44.360
What else do you want to throw out for people who are thinking about a lot of these best practices?

01:00:44.360 --> 01:00:47.520
We touched on a lot of them, but I know there's plenty more to go.

01:00:47.520 --> 01:00:49.060
Like for example, faster builds.

01:00:49.060 --> 01:00:52.780
You talk about, say, pre-compiling the PYC files.

01:00:53.140 --> 01:00:53.440
Yeah.

01:00:53.440 --> 01:00:57.420
That's more for that actually do slower builds, but it'll give you a faster startup.

01:00:57.420 --> 01:00:58.020
That's what I mean.

01:00:58.020 --> 01:00:58.200
Yeah.

01:00:58.200 --> 01:00:58.420
Sorry.

01:00:58.420 --> 01:01:04.960
Since this comes up a bunch, Alpine Linux is not a thing you want, is often not a thing you

01:01:04.960 --> 01:01:06.600
want to use for your Docker base image.

01:01:07.100 --> 01:01:11.760
And the reason is Alpine Linux is highly recommended for if you want small images.

01:01:11.760 --> 01:01:15.860
And it's kind of nice because you install, like installing the Alpine packages somehow, I don't

01:01:15.860 --> 01:01:19.320
know what they do, but it's vastly faster than like installing Debian packages.

01:01:19.860 --> 01:01:22.260
And you get small images and it's kind of nice.

01:01:22.260 --> 01:01:27.580
Problem is Alpine Linux uses a different standard C library than most Linux distributions.

01:01:27.580 --> 01:01:29.420
Most Linux distributions use Glybcy.

01:01:29.420 --> 01:01:32.700
Alpine uses Musil or Musil.

01:01:32.700 --> 01:01:33.700
I don't know how to pronounce it.

01:01:33.700 --> 01:01:39.080
And binary wheels are compiled by default on Linux for Glybcy.

01:01:39.080 --> 01:01:45.080
And so if you install Python packages on Alpine Linux, you will not get binary wheels.

01:01:45.080 --> 01:01:46.660
You're going to have to compile them from scratch.

01:01:46.660 --> 01:01:49.800
And so what happens is people say, oh, I'm going to use Alpine Linux.

01:01:49.920 --> 01:01:51.180
It's going to make my images smaller.

01:01:51.180 --> 01:01:55.720
And they try to install like a Postgres package, which is pre-compiled and doesn't work.

01:01:55.720 --> 01:02:00.120
They're like, okay, so now I'll install a compiler and I'll install the Postgres headers.

01:02:00.120 --> 01:02:05.300
Now you have this image that has compiler and Postgres headers in it, and you have to compile

01:02:05.300 --> 01:02:05.740
stuff.

01:02:05.740 --> 01:02:10.380
And like when you get to like data science or scientific computing, you're like compiling

01:02:10.380 --> 01:02:14.020
these massive packages that take a really long time to compile and all your builds are super

01:02:14.020 --> 01:02:14.380
slow.

01:02:15.080 --> 01:02:21.020
And you can do a whole bunch of work to then use a multi-stage build so your image is small.

01:02:21.020 --> 01:02:23.940
And then you can use caching so the builds are fast.

01:02:23.940 --> 01:02:28.480
And then, but, or you can just use a different Linux distribution and use binary wheels.

01:02:28.860 --> 01:02:30.100
Don't cause yourself the challenge.

01:02:30.100 --> 01:02:31.340
Just use something else, huh?

01:02:31.340 --> 01:02:38.680
But there is a PEP that I believe was accepted to start the process of building wheels for Alpine.

01:02:38.680 --> 01:02:42.160
And I've started seeing some packaging tools who started adding support.

01:02:42.340 --> 01:02:48.440
And so it may be that in a year or two, it'll be just like everyone builds binary wheels for

01:02:48.440 --> 01:02:50.320
like many Linux, just the Glibsie.

01:02:50.320 --> 01:02:53.760
People might start building wheels, binary wheels for Alpine.

01:02:53.760 --> 01:02:56.560
And when that happens, there'll be much less of an issue.

01:02:56.560 --> 01:02:59.940
But until then, avoid using Alpine Linux as your base image.

01:02:59.940 --> 01:03:00.200
Yeah.

01:03:00.200 --> 01:03:02.320
You want to close it out with a PYC thing?

01:03:02.660 --> 01:03:03.020
Sure.

01:03:03.020 --> 01:03:09.440
So when you start up a Python program, it loads in your Python source files and then compiles them.

01:03:09.440 --> 01:03:12.980
And compilation here is not really the same as compiling a C extension.

01:03:12.980 --> 01:03:14.700
It's basically a one-to-one translation.

01:03:14.700 --> 01:03:17.760
It compiles them to bytecode and writes them out as PYC files.

01:03:17.760 --> 01:03:22.840
And then the next time you start, it can just load the PYC file and that will make your application

01:03:22.840 --> 01:03:23.600
start up quickly.

01:03:23.600 --> 01:03:27.660
And so if you're doing some sort of like, many applications, it doesn't matter.

01:03:27.660 --> 01:03:32.320
If you're doing like a serverless kind of thing where like you want things to start up

01:03:32.320 --> 01:03:37.040
really quickly, like having to compile the PYC is, it's going to add some startup time.

01:03:37.040 --> 01:03:41.540
I guess any times where the container lifetime, the life cycle is short, right?

01:03:41.540 --> 01:03:44.540
Let's say with a web app, you would start it and it would run for hours.

01:03:44.540 --> 01:03:45.680
And so it doesn't matter, right?

01:03:45.680 --> 01:03:46.020
Yeah.

01:03:46.020 --> 01:03:49.580
So it's like it took you another 20 milliseconds to start off.

01:03:49.580 --> 01:03:50.960
It's going to be run for three days.

01:03:51.200 --> 01:03:56.780
But if you're doing like a serverless thing where like 20 milliseconds might be a significant

01:03:56.780 --> 01:03:58.540
chunk of the latency of your service.

01:03:58.540 --> 01:04:03.160
So when you build your Docker image, you can pre-compile all your PYC files and then it'll

01:04:03.160 --> 01:04:05.760
be in the image and you won't have, then your startup will be faster.

01:04:05.760 --> 01:04:09.640
And the reason you have to actually think about this is that Docker images are immutable.

01:04:09.640 --> 01:04:14.560
So like your container starts up, it compiles and writes the PYCs, but those PYCs never make

01:04:14.560 --> 01:04:15.580
it to the original image.

01:04:15.580 --> 01:04:20.680
Every time you start the image, it has the same immutable artifact, unlike your local home directory.

01:04:20.860 --> 01:04:25.720
And so if you really want the fastest startup, you can make your image a bit larger and compile

01:04:25.720 --> 01:04:26.260
the PYCs.

01:04:26.260 --> 01:04:31.180
Basically that becomes a step in your Docker build files to compile the PYCs ahead of time.

01:04:31.180 --> 01:04:31.440
Yeah.

01:04:31.440 --> 01:04:31.760
Okay.

01:04:31.760 --> 01:04:32.380
Awesome.

01:04:32.380 --> 01:04:33.120
Great advice.

01:04:33.120 --> 01:04:33.900
Many, many tips.

01:04:33.900 --> 01:04:36.020
I think we're going to have to leave it there.

01:04:36.020 --> 01:04:39.660
We're getting basically running out of time, but yeah, really nice talk.

01:04:39.660 --> 01:04:43.840
I'll link to your talk that you did at PyCon and thanks for coming here and sharing the audio

01:04:43.840 --> 01:04:44.700
version with us.

01:04:44.700 --> 01:04:45.720
Thanks for inviting me.

01:04:45.720 --> 01:04:46.280
Of course.

01:04:46.280 --> 01:04:48.440
Before you get out of here though, there's the final two questions.

01:04:48.440 --> 01:04:50.840
If you're going to write some Python code, what editor do you use?

01:04:50.840 --> 01:04:56.140
I use SpaceMax, which is kind of like they took Emacs and they configured it like 20 years.

01:04:56.140 --> 01:04:58.560
That's like you're jumping 20 years into the future.

01:04:58.560 --> 01:05:03.460
It's like it's Emacs, but with all the things you need pre-configured to actually have a

01:05:03.460 --> 01:05:04.960
nice development environment.

01:05:04.960 --> 01:05:07.220
And it has VI bindings and Emacs bindings.

01:05:07.220 --> 01:05:08.420
I use the Emacs bindings.

01:05:08.420 --> 01:05:10.460
But if you like Vim, you can use the VI bindings.

01:05:10.460 --> 01:05:11.180
Yeah.

01:05:11.180 --> 01:05:11.440
Cool.

01:05:11.440 --> 01:05:16.180
Their subtitle and sub-subtitle is a community-driven Emacs distribution.

01:05:16.180 --> 01:05:18.460
The best editor is neither Emacs nor Vim.

01:05:18.460 --> 01:05:19.760
It's Emacs and Vim.

01:05:19.760 --> 01:05:22.100
I honestly don't use the Vim bindings at all.

01:05:22.100 --> 01:05:27.700
I'm using it for like, it does all the IDE stuff you want out of the box.

01:05:27.700 --> 01:05:30.520
So it's just, it's a much more modern experience.

01:05:30.520 --> 01:05:30.920
Okay.

01:05:30.920 --> 01:05:31.540
Really cool.

01:05:31.540 --> 01:05:33.300
And then notable PyPI package?

01:05:33.900 --> 01:05:38.180
Py03, which is a way to create Python extensions in Rust.

01:05:38.180 --> 01:05:45.080
I've used it to create both for Phil, my memory profiler, but also I wrapped some Rust library

01:05:45.080 --> 01:05:45.440
with it.

01:05:45.440 --> 01:05:51.180
It's really, really nice way to create fast, safe extensions for Python.

01:05:51.180 --> 01:05:57.520
And it comes, there's a packaging tool called Maturin, M-A-T-U-R-I-N, which was probably the

01:05:57.520 --> 01:05:59.820
nicest Python packaging I've experienced I've ever had.

01:05:59.820 --> 01:06:05.160
Like you add like three lines, like you had a PyProject line file, which is like three

01:06:05.160 --> 01:06:05.520
lines.

01:06:05.520 --> 01:06:09.780
You add like a tiny bit of metadata and now you can build wheels and you can pip install

01:06:09.780 --> 01:06:11.340
and it just works.

01:06:11.340 --> 01:06:15.580
And it's just amazingly smooth development experience.

01:06:15.580 --> 01:06:16.320
That's fantastic.

01:06:16.320 --> 01:06:16.720
Yeah.

01:06:16.840 --> 01:06:21.620
So basically if you're going to write a C extensions, maybe reconsider that and write

01:06:21.620 --> 01:06:23.240
them in Rust and use this possible.

01:06:23.240 --> 01:06:24.020
Yeah.

01:06:24.020 --> 01:06:31.320
It's like Rust is like, gives you the same performance that you would get from C or C++, but it's

01:06:31.320 --> 01:06:31.860
much safer.

01:06:31.860 --> 01:06:38.020
And as someone used to write C++ long ago, like I, I've learned it in the, over the past

01:06:38.020 --> 01:06:38.580
couple of years.

01:06:38.580 --> 01:06:42.000
And it's like, it is the language I always wanted C++ to be.

01:06:42.220 --> 01:06:42.460
Yeah.

01:06:42.460 --> 01:06:43.140
I hear you.

01:06:43.140 --> 01:06:44.740
I did a lot of C++ as well.

01:06:44.740 --> 01:06:47.960
I was always bringing in these things like smart pointers and other stuff.

01:06:47.960 --> 01:06:49.040
It's like, why does it have to be hard?

01:06:49.040 --> 01:06:50.480
Can't we just like make this better?

01:06:50.480 --> 01:06:53.780
It's not a simple language because if you want performance, you need to do work.

01:06:53.780 --> 01:06:57.700
And it, the way it has a very different paradigm, but it's really lovely language.

01:06:57.700 --> 01:07:02.100
You'll write much safer code and Py03 makes it really nice to write Python extensions.

01:07:02.100 --> 01:07:02.520
Yeah.

01:07:02.520 --> 01:07:03.000
Cool.

01:07:03.000 --> 01:07:03.180
Cool.

01:07:03.180 --> 01:07:05.660
And then Talden's out there has a interesting comment.

01:07:05.660 --> 01:07:07.160
Is that like an isotope?

01:07:07.220 --> 01:07:12.460
I think it's a reference to like oxidization, like O3, but.

01:07:12.460 --> 01:07:12.840
Yeah.

01:07:12.840 --> 01:07:13.300
Yeah.

01:07:13.300 --> 01:07:14.020
Because it rusts.

01:07:14.020 --> 01:07:15.960
And there's a lot of oxidizing happening.

01:07:15.960 --> 01:07:16.480
Yeah.

01:07:16.480 --> 01:07:17.000
Around.

01:07:17.000 --> 01:07:18.220
There's also PyOxidizer.

01:07:18.220 --> 01:07:18.700
Yeah.

01:07:18.700 --> 01:07:19.620
There's another project.

01:07:19.620 --> 01:07:19.720
There's another project.

01:07:19.720 --> 01:07:20.400
Yeah.

01:07:20.400 --> 01:07:25.460
That's like a completely different project, but yeah, it's another rust pun.

01:07:25.460 --> 01:07:26.080
Packaging.

01:07:26.080 --> 01:07:26.720
Yeah, exactly.

01:07:26.720 --> 01:07:27.500
Very, very cool.

01:07:27.500 --> 01:07:28.240
All right.

01:07:28.240 --> 01:07:29.400
Final call to action.

01:07:29.400 --> 01:07:31.080
People are interested in this.

01:07:31.080 --> 01:07:31.720
They want to go deeper.

01:07:31.980 --> 01:07:36.760
You've got some various things that you can find on your website, pythonspeed.com slash

01:07:36.760 --> 01:07:37.020
Docker.

01:07:37.020 --> 01:07:37.460
Yep.

01:07:37.460 --> 01:07:38.040
Where do they go?

01:07:38.040 --> 01:07:38.460
What do you tell them?

01:07:38.460 --> 01:07:38.620
Yeah.

01:07:38.620 --> 01:07:43.300
So if you go to pythonspeed.com slash Docker, there's a whole bunch of free articles about

01:07:43.300 --> 01:07:44.220
various best practices.

01:07:44.220 --> 01:07:49.240
If you're specifically interested in the process that we covered today, there's a PyCon talk,

01:07:49.240 --> 01:07:54.820
but also if you go to pythonspeed.com slash Docker process, it's also linked on that page.

01:07:54.820 --> 01:07:57.420
It's like an introduction to Dockerizing for production.

01:07:57.980 --> 01:08:02.040
It's basically like a little mini ebook I wrote that's about 10 pages, but it goes over

01:08:02.040 --> 01:08:06.440
this process that we talked about today and sort of prose and talks about sort of the

01:08:06.440 --> 01:08:09.980
decisions you have to make and how it integrates your organizational processes.

01:08:09.980 --> 01:08:10.840
That's super cool.

01:08:10.840 --> 01:08:11.100
Yeah.

01:08:11.100 --> 01:08:15.840
And on that site, the slash Docker, it has a bunch of articles and it has a very small

01:08:15.840 --> 01:08:17.400
scroll bar and a lot of stuff below it.

01:08:17.400 --> 01:08:19.480
So yeah, there's a lot of things going on.

01:08:19.480 --> 01:08:21.760
People can go check out for more resources there, right?

01:08:21.760 --> 01:08:22.060
Yeah.

01:08:22.060 --> 01:08:26.680
And I have a bunch of paid products if anyone's interested about Docker packaging from intro

01:08:26.680 --> 01:08:28.980
to much more detailed one.

01:08:28.980 --> 01:08:32.680
And if you use the code talkpython, you can get a 15% discount.

01:08:32.680 --> 01:08:33.380
Oh, fantastic.

01:08:33.380 --> 01:08:33.740
Awesome.

01:08:33.740 --> 01:08:34.300
Yeah.

01:08:34.300 --> 01:08:35.220
So be sure to do that.

01:08:35.220 --> 01:08:40.340
Thank you so much for being on the show and sharing a lot of your hard-earned Docker experience.

01:08:40.340 --> 01:08:40.600
Yeah.

01:08:40.600 --> 01:08:41.460
Thanks for inviting me.

01:08:41.460 --> 01:08:42.240
You bet.

01:08:42.240 --> 01:08:42.960
Great to talk to you.

01:08:42.960 --> 01:08:43.260
You too.

01:08:43.260 --> 01:08:43.440
Bye.

01:08:43.440 --> 01:08:43.600
Bye.

01:08:45.060 --> 01:08:47.780
This has been another episode of Talk Python To Me.

01:08:47.780 --> 01:08:50.780
Our guest in this episode was Itamar Turner-Trowing.

01:08:50.780 --> 01:08:54.180
It has been brought to you by Sentry, Linode, and Assembly AI.

01:08:54.180 --> 01:08:56.920
Take some stress out of your life.

01:08:56.920 --> 01:09:00.820
Get notified immediately about errors in your web applications with Sentry.

01:09:00.820 --> 01:09:04.940
Just visit talkpython.fm/sentry and get started for free.

01:09:04.940 --> 01:09:09.780
And use the promo code talkpython2021 when you sign up.

01:09:09.780 --> 01:09:14.820
Simplify your infrastructure and cut your cloud bills in half with Linode's Linux virtual machines.

01:09:15.080 --> 01:09:18.200
Develop, deploy, and scale your modern applications faster and easier.

01:09:18.200 --> 01:09:23.160
Visit talkpython.fm/Linode and click the Create Free Account button to get started.

01:09:23.160 --> 01:09:27.380
Transcripts for this and all of our episodes are brought to you by Assembly AI.

01:09:27.380 --> 01:09:30.040
Do you need a great automatic speech-to-text API?

01:09:30.040 --> 01:09:32.580
Get human-level accuracy in just a few lines of code.

01:09:32.580 --> 01:09:35.440
Visit talkpython.fm/assemblyai.

01:09:35.440 --> 01:09:37.220
Want to level up your Python?

01:09:37.220 --> 01:09:41.280
We have one of the largest catalogs of Python video courses over at Talk Python.

01:09:41.720 --> 01:09:46.440
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:09:46.440 --> 01:09:49.120
And best of all, there's not a subscription in sight.

01:09:49.120 --> 01:09:52.020
Check it out for yourself at training.talkpython.fm.

01:09:52.020 --> 01:09:56.700
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

01:09:56.700 --> 01:09:58.000
We should be right at the top.

01:09:58.000 --> 01:10:03.160
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:10:03.160 --> 01:10:07.380
and the direct RSS feed at /rss on talkpython.fm.

01:10:08.380 --> 01:10:10.800
We're live streaming most of our recordings these days.

01:10:10.800 --> 01:10:14.220
If you want to be part of the show and have your comments featured on the air,

01:10:14.220 --> 01:10:18.580
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:10:18.580 --> 01:10:20.480
This is your host, Michael Kennedy.

01:10:20.480 --> 01:10:21.780
Thanks so much for listening.

01:10:21.780 --> 01:10:22.940
I really appreciate it.

01:10:22.940 --> 01:10:24.840
Now get out there and write some Python code.

01:10:24.840 --> 01:10:45.460
I'll see you next time.

01:10:45.460 --> 01:11:15.440
Thank you.

