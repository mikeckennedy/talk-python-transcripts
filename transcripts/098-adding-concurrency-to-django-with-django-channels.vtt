WEBVTT

00:00:00.001 --> 00:00:06.500
One of the major areas of innovation in Python, especially Python 3, is advances in async and

00:00:06.500 --> 00:00:11.580
concurrent programming. Yet when working with any of the major web frameworks, Django, Flask,

00:00:11.580 --> 00:00:17.280
or Pyramid, there is basically no concurrency option. That's why Andrew Godin decided to tackle

00:00:17.280 --> 00:00:22.620
the issue on the Django side with his project Django Channels. This is Talk Python to Me,

00:00:22.620 --> 00:00:26.460
episode 98, recorded January 17, 2017.

00:00:26.460 --> 00:00:55.700
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the

00:00:55.700 --> 00:01:00.320
ecosystem, and the personalities. This is your host, Michael Kennedy. Follow me on Twitter

00:01:00.320 --> 00:01:05.240
where I'm @mkennedy. Keep up with the show and listen to past episodes at talkpython.fm

00:01:05.240 --> 00:01:12.000
and follow the show on Twitter via at Talk Python. This episode is brought to you by Metis and

00:01:12.000 --> 00:01:16.200
Hired. Thank both of them for supporting the show by checking out what they have to offer

00:01:16.200 --> 00:01:19.940
during their segments. Andrew, welcome to Talk Python.

00:01:19.940 --> 00:01:21.440
Thank you. It's very nice to be here.

00:01:21.600 --> 00:01:26.120
Yeah, I'm excited to have another Django topic on the show. I don't cover Django that

00:01:26.120 --> 00:01:31.900
often and people really love it. And I'm excited to sort of mix together the worlds of asynchronous

00:01:31.900 --> 00:01:36.160
programming and Django and this cool project that you're working on called Django Channels.

00:01:36.160 --> 00:01:40.440
Yeah, I'm excited to talk about it too. Like it's combining one of the hot new things in

00:01:40.440 --> 00:01:45.080
Async with one of the boring old things in Django, one might say. But yeah, it's going to be a good

00:01:45.080 --> 00:01:48.500
thing to talk about. Hopefully people can learn some stuff from this.

00:01:48.660 --> 00:01:52.880
Yeah, I'm sure they will. I'm sure they will. And before we dig into that though, let's hear

00:01:52.880 --> 00:01:53.960
your story. How do you get into programming?

00:01:53.960 --> 00:01:59.660
So I have sort of those almost cliche stories. Like I got into programming about the age of 14

00:01:59.660 --> 00:02:07.360
or 13 or so. Just like sort of the young sort of programmer model. I started off weirdly on a,

00:02:07.360 --> 00:02:14.100
I think it was a Palm Pilot 3 X. Just writing in like sort of simple basic program running small

00:02:14.100 --> 00:02:18.760
games. And that quickly went into like doing JavaScript and websites and then doing PHP.

00:02:18.760 --> 00:02:24.440
And then finally about, about 10 years ago now going over into doing Python. And I've been doing

00:02:24.440 --> 00:02:25.460
Python ever since pretty much.

00:02:25.460 --> 00:02:28.980
That's really cool. What language did you program the Palm Pilot thing in?

00:02:28.980 --> 00:02:33.720
It was like a weird variant of basic. Like I need to go back and like find the actual program,

00:02:33.720 --> 00:02:38.740
like posterity, but it was like a very simple basic, had like basic graphical stuff and audio

00:02:38.740 --> 00:02:46.200
stuff. Like a simple breakout clone, a sort of touchscreen keyboard, a few things like games

00:02:46.200 --> 00:02:49.720
and interactivity has always been a big part of my attraction to programming. So like that's,

00:02:49.720 --> 00:02:54.580
that's why I started out doing definitely. And that's kind of almost still where I do a lot

00:02:54.580 --> 00:02:56.440
of my hobby stuff outside of web stuff.

00:02:56.440 --> 00:03:01.380
Oh yeah, that's cool. Games, games are definitely fun. Although they're both easier and harder

00:03:01.380 --> 00:03:05.640
these days, right? The programming languages are better. The tooling is better. But if you're

00:03:05.640 --> 00:03:10.500
going to make a serious game, like that's a, that's a team of people for a year, right? Like

00:03:10.500 --> 00:03:14.180
it, it's not just, you can throw out something really simple and it'll sort of compete.

00:03:14.180 --> 00:03:20.020
Oh, like starting a game is super easy. Finishing and polishing one is the hardest thing in the world.

00:03:20.020 --> 00:03:25.160
Like I've, I've released one of them. It took me like almost two years for a simple puzzle game.

00:03:25.160 --> 00:03:29.800
So I'm very aware of how hard it is. I have a lot of respect for those teams that make actual

00:03:29.800 --> 00:03:30.420
proper games.

00:03:30.420 --> 00:03:35.200
I do as well. Absolutely. I worked on some 3d simulators and stuff for a while and

00:03:35.200 --> 00:03:39.460
after that, I'm like, okay, this is really interesting and it's probably not something

00:03:39.460 --> 00:03:46.480
I want to do anymore. So, so you said you got into Python about 10 years ago. Like what was the,

00:03:46.480 --> 00:03:47.860
how do you get introduced to it?

00:03:47.860 --> 00:03:53.320
Oh, it's all a bit hazy now. So I know in particular that, actually it was more than 10 years ago.

00:03:53.320 --> 00:03:58.080
It's about 12 years ago now. So that the first thing I ran into, like I was running PHP apps at the

00:03:58.080 --> 00:04:03.160
time for, you know, for about three or four years before this. And then I ran into turbo gears and turbo gears

00:04:03.160 --> 00:04:07.520
back then was just sort of a couple of other packages glued together with extra stuff.

00:04:07.520 --> 00:04:12.200
And that was my introduction to web programming in Python in particular. Like I was looking for an

00:04:12.200 --> 00:04:17.980
avenue away from PHP and you know, the number of security vulnerabilities, even in my first open

00:04:17.980 --> 00:04:23.900
source product back then was astonishing, including the ability to read the ETC password file. So that

00:04:23.900 --> 00:04:24.320
was fun.

00:04:24.740 --> 00:04:29.100
So I was like looking, I was looking for a sort of alternate language and I think Python

00:04:29.100 --> 00:04:32.740
cropped up as like a common suggestion and turbo gears was one of the big things at that point.

00:04:32.740 --> 00:04:38.700
Django was around, but very young and new as well. And so I sort of started out doing turbo gears for,

00:04:38.700 --> 00:04:44.980
for a couple of years. And then I had the opportunity to go and work at an agency with Simon Willison,

00:04:44.980 --> 00:04:51.420
who's one of the co-creators of Django. And it is those four or five short weeks with Simon,

00:04:51.420 --> 00:04:57.160
who is, if you ever meet him, one of the most enthusiastic people in the world that converted

00:04:57.160 --> 00:05:02.580
me from turbo gears to Django by almost just force of personality. And I've been doing Django pretty

00:05:02.580 --> 00:05:03.220
much ever since.

00:05:03.220 --> 00:05:07.740
Oh, that's really great. It's, it's lovely to be around people that are so excited about technology.

00:05:07.740 --> 00:05:10.040
It just, it draws you in, doesn't it?

00:05:10.100 --> 00:05:13.840
Oh yeah. I learned so much. Like I basically pair programmed with him for like,

00:05:13.840 --> 00:05:18.180
you know, three weeks continuously almost. And I just learned so much both about like,

00:05:18.180 --> 00:05:22.340
not only like how Django works and how Python works in general, but also like a lot of the

00:05:22.340 --> 00:05:26.260
philosophies of like, you know, things like the Zen of Python that you don't necessarily learn going

00:05:26.260 --> 00:05:29.880
into the language per se, but you sort of pick up along the way. So that's the kind of stuff that's

00:05:29.880 --> 00:05:30.460
really valuable.

00:05:30.460 --> 00:05:32.520
Oh yeah, absolutely. That's really, really great.

00:05:33.580 --> 00:05:38.520
Let's talk about this project that you've created, Django Channels. Can you just kind

00:05:38.520 --> 00:05:40.880
of tell us briefly, you know, what is Django Channels?

00:05:40.880 --> 00:05:44.880
It's a very hard thing to describe, but I'll have a go. So Django Channels is actually,

00:05:44.880 --> 00:05:48.540
it's kind of two things. It's important to, as we talk about it more in the podcast.

00:05:48.540 --> 00:05:55.020
So first of all, so the headline feature as you were is Django Channels is a way of having

00:05:55.020 --> 00:06:01.100
WebSockets supported in Django. And we can, we can go in later on as to why that's difficult and hard,

00:06:01.100 --> 00:06:06.860
but needless to say that until Channels existed, WebSockets was very hard to do in Django just

00:06:06.860 --> 00:06:12.200
due to some of the technical limitations therein. But the second part of Channels is sort of this

00:06:12.200 --> 00:06:16.200
underlying layer of like to solve the problem in WebSockets, there's a lot of interesting

00:06:16.200 --> 00:06:22.880
technical challenges that go with that. And so part of it is like, well, how do we solve the problem of

00:06:22.880 --> 00:06:28.640
writing semi-asynchronous code, not fully asynchronous code, but semi-asynchronous code with Django and having

00:06:28.880 --> 00:06:33.920
things like the Django ORM and the middleware and stuff and things that people are familiar with

00:06:33.920 --> 00:06:38.720
still work. Like how do we keep all that stuff familiar yet also have an extra power in there?

00:06:38.720 --> 00:06:43.540
And so it's sort of this two-faced story of the underlying solution that powers everything.

00:06:43.540 --> 00:06:47.520
And then on top of it, the nice layer of, and here's WebSockets support to go on top of it.

00:06:47.520 --> 00:06:51.860
Okay. And just making that really easy and giving people a great API for it, huh?

00:06:52.080 --> 00:06:56.900
Yeah. So like, you know, the channels part, sort of the top layer is very much the let's have a nice

00:06:56.900 --> 00:07:02.820
design thing with a good developer experience that says, hey, you can WebSockets. And more importantly,

00:07:02.820 --> 00:07:08.120
it's very hard to shoot yourself in the foot or deadlock or live lock or any of the things that

00:07:08.120 --> 00:07:12.240
asynchronous programming gives you as like sort of loaded ammunition very easily.

00:07:13.120 --> 00:07:18.980
Absolutely. So before we dig into your project too much, like let's talk about how asynchronous

00:07:18.980 --> 00:07:22.920
programming in Django without your project works today.

00:07:22.920 --> 00:07:28.840
Today, Django doesn't really do nearly anything asynchronously. So like if you are at all familiar

00:07:28.840 --> 00:07:35.540
with Python's asynchronous solutions, Python really wasn't designed to have asynchronous programming in

00:07:35.540 --> 00:07:39.900
it, which is fair enough. It's a very old language. It's incredibly old at this point in some ways.

00:07:40.120 --> 00:07:46.720
And so especially in Django, which itself is over a decade old now and was built back when Python

00:07:46.720 --> 00:07:52.520
2.4 was fresh and young, a lot of the ways Django is built are not built around the ideas of async.

00:07:52.520 --> 00:07:56.860
And in Python, you have to build with async specifically in mind and build around things

00:07:56.860 --> 00:08:03.020
like async, hyalur, twisted to have support for that stuff. And so before today, you just couldn't

00:08:03.020 --> 00:08:08.780
do it in Django. Like there's no way you could like yield and let something else run. Like if you wanted

00:08:08.780 --> 00:08:15.340
to do say, go and fetch a couple of web pages, you might be able to fetch those in parallel in

00:08:15.340 --> 00:08:19.920
one worker process, but that's as much as you could do. You couldn't share the load. And in particular,

00:08:19.920 --> 00:08:26.000
things like WebSockets, you would have to tie up a single Python process for every terminated socket,

00:08:26.000 --> 00:08:32.920
which as you can imagine, quickly wastes all of your worker processes. Like for HTTP, it's great. Like

00:08:32.920 --> 00:08:39.100
the process spins up, does a request. You know, if you've got a good site, like maybe two,

00:08:39.100 --> 00:08:44.080
300 milliseconds, finishes the request, moves on to the next request. With a socket, it holds open

00:08:44.080 --> 00:08:49.060
forever. And so you're quickly going to run out of those non-asynchronous worker threads. And like,

00:08:49.060 --> 00:08:51.960
that's kind of the problem that you butt up against very quickly.

00:08:52.480 --> 00:08:57.940
Yeah. You're going to run out of space really quick. If that's the case. Sorry, our website is busy. We

00:08:57.940 --> 00:09:03.200
have seven people on it. Could you come back later? Yes. You're in a queue. You're number five in the

00:09:03.200 --> 00:09:08.240
queue. Exactly. You could give them a cool little countdown. That would be nice. Oh yeah, no. You can

00:09:08.240 --> 00:09:12.460
make it really not a really nice experience around this really whole full internal programming you have.

00:09:12.460 --> 00:09:19.520
Nice. So what was the motivation or what pushed you to go and create channels? Like it's one thing to say

00:09:19.520 --> 00:09:24.360
Django doesn't support this ASIC model super well. It's another to go and I'm going to fix it.

00:09:24.360 --> 00:09:30.840
Yeah. And you think I would have learned as well. So like for this list is not familiar. My path into

00:09:30.840 --> 00:09:37.020
Django core team in particular was based on writing South, which was Django's sort of what one of the initial

00:09:37.020 --> 00:09:42.240
migration frameworks for database migrations for Django. And over the time, about eight years it took, I think,

00:09:42.240 --> 00:09:48.720
it became the de facto solution and then the only solution really much. And then finally it was moved into core.

00:09:49.060 --> 00:09:55.600
And so I had basically just finished like doing all the porting into Django core. I finally,

00:09:55.600 --> 00:10:00.660
like after eight years had a bit of a break. And of course I went, what other hard problem

00:10:00.660 --> 00:10:06.160
needs solving that I can go and look at? Like this is the awful part of my sort of like idle thinking.

00:10:06.580 --> 00:10:12.360
And in particular, I've been interested in WebSockets for quite a while. So like since they came on sort of the browser scene,

00:10:12.360 --> 00:10:18.180
well, four or five years ago now, I'm not, I can't remember the timeline perfectly. I've been looking at them

00:10:18.180 --> 00:10:24.120
sort of very intently. And like in particular for game related reasons, right? Like WebSockets are this

00:10:24.120 --> 00:10:29.740
unique thing in the web where you have very low latency, bi-directional communication with no overhead.

00:10:29.880 --> 00:10:33.980
like Ajax is like one way. It's got quite a lot of overhead. It's quite slow.

00:10:33.980 --> 00:10:37.720
And it's hard to even send things from the server to the client without prompting. So I was like, okay,

00:10:38.220 --> 00:10:43.700
I'm interested in this. And then back then I sort of played around a bit. I used eventlets and sort of

00:10:43.700 --> 00:10:49.240
kept up with the ever-changing WebSocket specification, sort of fixed eventlets as the

00:10:49.240 --> 00:10:53.060
spec changed a little bit and tried to keep up for it. And then, and then dropped off for a while.

00:10:53.060 --> 00:10:59.160
And about that time, Aymeric Augustin sort of took on the challenge of WebSockets and Django himself.

00:10:59.160 --> 00:11:04.500
And he made his own attempt to this where he had a different arrangement to it. And I sort of played around

00:11:04.500 --> 00:11:06.760
with that, like, okay, this is, this is pretty interesting. I like that.

00:11:06.760 --> 00:11:10.660
And there were lots of other attempts. And a lot of the common pattern was that you would,

00:11:10.660 --> 00:11:16.140
you would have Django running normally with WSGI. And then you would also have a separate process.

00:11:16.140 --> 00:11:22.480
And that separate process terminates WebSockets. And then somehow, often with either mystery or some

00:11:22.480 --> 00:11:27.560
kind of magic, the two processes communicate with each other. And you can hand off things from Django

00:11:27.560 --> 00:11:31.880
to WebSockets and vice versa. But it was always sort of bolted on. It wasn't, it wasn't really a good

00:11:31.880 --> 00:11:36.500
sort of like clean solution. It often didn't feel like Django as well. You know, it was,

00:11:36.500 --> 00:11:40.980
this extra server you ran just WebSockets. And I was like, at some point, you have to have that

00:11:40.980 --> 00:11:45.660
separate server idea, as we'll come to later anyway. But I wanted to sort of like, how can we make the

00:11:45.660 --> 00:11:50.860
solution that is more encompassing, that supports both WebSockets, and also other things that need

00:11:50.860 --> 00:11:56.100
the same kind of problems, like long pulling HTTP, and sort of other protocols, like incident of things

00:11:56.100 --> 00:12:00.600
protocols are often like this too. So how do we encompass all those problems into a common thing

00:12:00.600 --> 00:12:03.720
that also feels like Django integrates really well with Django?

00:12:03.720 --> 00:12:10.600
Right. That sounds like a great, great goal. And really definitely something to start working for

00:12:10.600 --> 00:12:16.360
to bring all that in there. I think one of the challenges is you want to support WebSockets,

00:12:16.360 --> 00:12:22.640
but you also talked about like HTTP long polling. And there's a few other styles as well.

00:12:23.440 --> 00:12:27.920
Some kind of like frame, like long, slow frame or something like that.

00:12:27.920 --> 00:12:28.400
Yeah.

00:12:28.400 --> 00:12:29.060
What's that called?

00:12:29.060 --> 00:12:34.760
There's lots of different names for it. Like, I forget. The idea in particular is that you open a,

00:12:34.760 --> 00:12:39.920
you have a response and you send it in the chunked encoding. You send like one chunk and then wait.

00:12:39.920 --> 00:12:44.060
And browsers can actually, the JavaScript doesn't actually look at chunks that come in. So you sort

00:12:44.060 --> 00:12:46.860
of like fake a one-way socket that way.

00:12:46.980 --> 00:12:53.220
Exactly. So the challenge is you've got WebSockets, which when you started this project, what year was that?

00:12:53.220 --> 00:12:58.020
The project was conceived in late 2014, I would say.

00:12:58.020 --> 00:13:04.700
But there was a long period of me playing around with prototypes and ideas and a lot of failed attempts

00:13:04.700 --> 00:13:10.340
and failed API versions at trying to make a good API before it sort of emerged in 2015, pretty much.

00:13:10.340 --> 00:13:16.040
Okay. So you didn't have too much of the problem of browsers not supporting it, but still,

00:13:16.160 --> 00:13:21.760
if you support WebSockets, long polling, some of the other variations, you've got to have like graceful

00:13:21.760 --> 00:13:29.100
fallback and negotiation and all sorts of interesting things that not just implementing pure WebSockets

00:13:29.100 --> 00:13:33.880
solves, right? You've got kind of a better solution than that or a broader solution.

00:13:33.880 --> 00:13:37.280
Well, actually, so no, so channels doesn't do fallback. And it's one of the things that's

00:13:37.280 --> 00:13:41.820
interesting and like one of the things we plan to do, but like, so in terms of scoping, one thing I have

00:13:41.820 --> 00:13:45.200
learned from South is trying to keep scope small. And in particular,

00:13:45.340 --> 00:13:51.380
I wanted to solve the problem of the core problem of how do we have basic async stuff in Django

00:13:51.380 --> 00:13:57.160
initially without having the fallback stuff. And we are working on fallback, but like in Django,

00:13:57.160 --> 00:14:03.580
in channels today, you can do long polling. You can do the sort of frame by frame push. You can do

00:14:04.940 --> 00:14:09.200
the fallback stuff. And so the fallback stuff isn't there mostly because I didn't want to reinvent the

00:14:09.200 --> 00:14:14.040
wheel in that regard. I wanted to reuse one of the existing solutions like Sock.js or Socket.io,

00:14:14.040 --> 00:14:18.880
one of the other ones that already exists in the JavaScript world. And so the initial version was,

00:14:18.980 --> 00:14:25.260
okay, let's build initial great support for just WebSockets, just long polling, just pushing stuff.

00:14:25.260 --> 00:14:30.520
And then later on, come and then join them together into a more sort of cohesive whole,

00:14:30.520 --> 00:14:31.660
if you will want that stuff.

00:14:31.920 --> 00:14:36.860
I see. So even though you support the different protocols, it's basically you're saying like,

00:14:36.860 --> 00:14:42.500
look, if you want to use this in your web app, put some bit of JavaScript that will select it for you.

00:14:42.500 --> 00:14:47.140
And we'll just stick with that one rather than having some really complicated negotiation.

00:14:47.460 --> 00:14:52.600
It's partially that. And partially also what I tell a lot of people is that in some ways,

00:14:52.600 --> 00:14:56.700
if you're just using one of the wrappers around sort of that hides all the different things it's

00:14:56.700 --> 00:15:01.100
transporting over, you don't have as many guarantees, right? Like if you have a wrapper,

00:15:01.100 --> 00:15:04.700
you don't know your underlying connection is actually good at bi-directional communication.

00:15:04.700 --> 00:15:08.940
It might just be a long poll Ajax call. And those are really bad at say,

00:15:08.940 --> 00:15:14.500
pushing data from the server to the client. So in many ways, I'm encouraging this for,

00:15:14.920 --> 00:15:18.340
if you really need WebSockets, like a hundred percent, like, you know, you're doing

00:15:18.340 --> 00:15:22.580
real time-ish kind of stuff or programming or games or whatever, or chat stuff,

00:15:22.580 --> 00:15:25.460
then this is the right stuff to do. Like you've got the right level of abstraction.

00:15:25.460 --> 00:15:30.060
If you want that sort of wrapper around stuff, sure, you can do it, but you might be better off

00:15:30.060 --> 00:15:35.380
just building anything long pole anyway, because then you can build to a set of guarantees that you

00:15:35.380 --> 00:15:39.360
can sort of understand. Right. That is the problem. If you let the system auto select

00:15:39.360 --> 00:15:44.280
basically different transport protocols is you don't really know what you're going to get, right?

00:15:44.700 --> 00:15:48.520
Yeah. And of course, WebSockets are more efficient. Like often you want to pick them

00:15:48.520 --> 00:15:53.300
over long polling, but in terms of scoping and trying to sort of pick what to work on,

00:15:53.300 --> 00:15:56.440
I pushed that stuff back in favor of just getting it working first.

00:15:56.440 --> 00:16:01.020
Yeah. That makes a lot of sense. So I haven't checked can I use.com for WebSockets in a while.

00:16:01.020 --> 00:16:06.720
What's the likelihood that people coming to my site would be able to use the best version,

00:16:06.720 --> 00:16:07.260
the WebSockets?

00:16:07.400 --> 00:16:11.100
So you have a deadly combination of it's mostly supported by all the new browsers.

00:16:11.100 --> 00:16:16.200
So, you know, like your new Chrome's new Firefox's I think even Edge has support for it these days,

00:16:16.200 --> 00:16:19.620
but you've got problems like mobile Safari, I think still doesn't support it properly.

00:16:19.620 --> 00:16:22.640
The old Android Chrome's probably won't do it properly either.

00:16:22.900 --> 00:16:27.500
And then on top of that, you have the problem where WebSockets isn't normal HTTP.

00:16:27.500 --> 00:16:31.020
And so a lot of proxies and corporate firewalls just block it entirely.

00:16:31.020 --> 00:16:38.640
And even then, if that works properly, your server and your hosting has to support HTTP 1.1

00:16:38.640 --> 00:16:40.340
to correctly get this protocol.

00:16:40.340 --> 00:16:45.360
So what happens is it starts off HTTP and then sort of upgrades itself midstream into a binding protocol

00:16:45.360 --> 00:16:47.080
and just binary happens in the middle of it.

00:16:47.180 --> 00:16:52.420
And so if you don't understand 1.1, then your HTTP server is going to go like,

00:16:52.420 --> 00:16:53.040
what's happening?

00:16:53.040 --> 00:16:55.940
And just like basically return 200 OK and break everything.

00:16:55.940 --> 00:16:59.780
So it's really sort of you need to trio things to work properly.

00:16:59.780 --> 00:17:02.000
And sometimes that can be pretty tricky to have.

00:17:02.000 --> 00:17:02.480
Right.

00:17:02.480 --> 00:17:06.200
And you don't always have great visibility, especially with the proxy servers or the firewalls.

00:17:06.200 --> 00:17:10.480
Yeah, the firewalls are the worst thing because like browsers, you can test in JavaScript pretty easily.

00:17:10.480 --> 00:17:13.140
And the server side stuff you have control over.

00:17:13.140 --> 00:17:17.880
But sometimes those proxies or firewalls can really sort of throw a wrench in the works.

00:17:17.880 --> 00:17:18.720
Oh, yeah, absolutely.

00:17:18.720 --> 00:17:21.120
So we talked about WebSockets and log polling.

00:17:21.120 --> 00:17:24.200
What are some of the other features that you support?

00:17:24.200 --> 00:17:28.700
There's things like custom events and tasks and a number of other things as well, right?

00:17:28.700 --> 00:17:29.880
This is what I mentioned in the beginning.

00:17:29.880 --> 00:17:32.100
Like it's not just the support for WebSockets on top.

00:17:32.100 --> 00:17:36.940
Like there's this whole underlying layer that's basically an event driven layer inside Django.

00:17:37.540 --> 00:17:41.220
And it happens that on top of that, there is WebSockets and log polling.

00:17:41.220 --> 00:17:44.820
But also you can use the same code for whatever you like.

00:17:44.820 --> 00:17:50.780
So if you want, you can have a custom set of events or custom channels that you send things to.

00:17:50.780 --> 00:17:53.360
You can have custom protocols, interfaces.

00:17:53.360 --> 00:18:00.260
So right now that people working on things like a Slack interface that sort of there are channels for when you get a Slack message into your server.

00:18:00.260 --> 00:18:01.580
So you can write bots very easily.

00:18:01.860 --> 00:18:10.380
So you can do things like if there's like 10 people on the site, one person could send a message and you could like broadcast that out to the other people who are around.

00:18:10.380 --> 00:18:10.960
Exactly.

00:18:10.960 --> 00:18:11.260
Yeah.

00:18:11.260 --> 00:18:20.460
And so like that in particular, the thing called groups and groups is a sort of built in primitive for almost like broadcasting to multiple and receiving channels.

00:18:20.460 --> 00:18:22.960
So it's like basically channels is a couple of primitives.

00:18:22.960 --> 00:18:24.960
Like there's a channel where you can send and receive stuff.

00:18:24.960 --> 00:18:26.960
There's a lot of guarantees around the way it's designed.

00:18:27.360 --> 00:18:34.720
There's groups for broadcast and then sort of this interface or API for sort of low level talking and communication between processes.

00:18:34.720 --> 00:18:37.320
And on top of those primitives is built.

00:18:37.320 --> 00:18:39.680
The WebSocket spec is built the HTTP spec.

00:18:39.680 --> 00:18:48.140
And if you want to, as we're doing it at Eventbrite, in fact, you can then take that low level spec and build, say, a service oriented architecture system on top of it as well.

00:18:48.140 --> 00:18:49.560
And that's what we're doing at Eventbrite.

00:18:49.560 --> 00:18:50.480
Oh, very cool.

00:18:50.480 --> 00:18:52.580
So you guys are using Django channels at Eventbrite?

00:18:52.580 --> 00:18:54.600
Well, so in particular, the underlying layer.

00:18:54.600 --> 00:18:59.240
So the underlying layer is rather unimaginatively called ASGI or ASCII.

00:18:59.240 --> 00:19:02.200
And what it is, it's definitely not a whiskey replacement.

00:19:02.200 --> 00:19:03.000
100% not.

00:19:03.000 --> 00:19:11.840
And what the idea is, it's like ASGI is a specification for there is a thing that can pass messages around on named channels.

00:19:11.840 --> 00:19:15.420
And you can send to named channels and you can receive from them.

00:19:15.500 --> 00:19:22.620
And it gives you a few basic guarantees, the methods to call on objects, a bit like dbapi2 is in Python, dbapi2.

00:19:22.620 --> 00:19:27.320
So things like, you know, there is a send method, there is a receive method.

00:19:27.320 --> 00:19:30.360
You can do groups in certain ways.

00:19:30.360 --> 00:19:41.860
And if you just have that, you can take things like the Redis transport we've built that Django channels runs on and use it for whatever you like and do message passing inside just pure Python.

00:19:41.860 --> 00:19:42.780
Like you don't even need Django.

00:19:42.780 --> 00:19:45.120
Like that part is a pure Python library.

00:19:45.320 --> 00:19:45.800
That's really cool.

00:19:45.800 --> 00:19:51.740
So basically, if you've got something that can act as a transport like Redis, like a Redis Q or something, then you're good?

00:19:51.740 --> 00:19:52.160
Well, yeah.

00:19:52.160 --> 00:19:53.200
So it's more than that.

00:19:53.200 --> 00:19:57.240
So like what happens is like the ASGI spec gives you certain guarantees.

00:19:57.240 --> 00:20:00.140
For example, it guarantees messages delivered at most once.

00:20:00.140 --> 00:20:02.100
So either you get it or you don't.

00:20:02.100 --> 00:20:05.880
The opposite choice being at least once, meaning you get it or you get two of them.

00:20:05.880 --> 00:20:07.640
And that's a choice you have to make.

00:20:07.640 --> 00:20:12.320
And it has a lot of those choices like, so you have a message expiry, so you get like 60 seconds.

00:20:12.320 --> 00:20:14.300
You have back pressure, so you know if a channel is full.

00:20:14.800 --> 00:20:23.860
Sort of all these sort of guarantees that if you're building any sort of distributed system, you want to know what these guarantees are and sort of program against them so you understand your trade-offs you're making.

00:20:24.320 --> 00:20:30.280
And so it comes with a preset set of trade-offs and then code built against those ready.

00:20:30.280 --> 00:20:32.680
So like there's one that uses Redis for transports using lists.

00:20:32.680 --> 00:20:35.880
There's one that uses a local shared memory segment.

00:20:35.880 --> 00:20:38.880
There's one that just works inside a process for like sort of unit testing.

00:20:39.100 --> 00:20:41.600
So you have a nice lightweight one to write unit tests against.

00:20:41.600 --> 00:20:46.460
And also we have somebody working on a RabbitMQ one right now as well to use RabbitMQ if you want to use that stuff.

00:20:46.460 --> 00:20:46.920
Oh, yeah.

00:20:46.920 --> 00:20:47.900
That sounds really cool.

00:20:47.900 --> 00:20:48.820
A lot of options there.

00:20:49.940 --> 00:20:53.560
Let me take just a moment and tell you about Metis, a sponsor of this episode.

00:20:53.560 --> 00:20:57.120
A data scientist's responsibilities can range far and wide.

00:20:57.120 --> 00:21:03.060
How can you be sure you have the necessary skills and training to enter the field or keep up with emerging technologies?

00:21:03.060 --> 00:21:11.320
Metis, a data science training company based in New York City, San Francisco, Chicago, and Seattle, provides full-time immersive boot camps,

00:21:11.580 --> 00:21:16.360
evening part-time professional development courses, online resources, and corporate programs,

00:21:16.360 --> 00:21:22.680
all with a goal of training you to become a data scientist and help you stay on top of new and necessary skills.

00:21:22.680 --> 00:21:30.260
Metis has a long list of professional development courses starting soon in any of these four cities taught by industry leaders.

00:21:30.260 --> 00:21:31.780
Interested in honing your skills?

00:21:31.780 --> 00:21:33.360
Then these courses are for you.

00:21:33.360 --> 00:21:34.700
How do they work?

00:21:34.700 --> 00:21:39.180
Courses on topics like data visualization, deep learning with TensorFlow, machine learning,

00:21:39.180 --> 00:21:45.100
and statistical foundations run two nights a week for six weeks during the evening hours that fit into your busy schedule.

00:21:45.100 --> 00:21:50.340
These courses are laser-focused on relevant topics and skills that are sure to enhance your career.

00:21:50.340 --> 00:21:55.160
They have a special offer for you at thisismetis.com slash talkpython.

00:21:55.160 --> 00:21:56.940
Be sure to check out what they're offering.

00:21:56.940 --> 00:21:58.140
It helps support the show.

00:21:58.140 --> 00:22:05.280
You talked about ASGI, and people are familiar with WSGI, Web Service Gateway Interface.

00:22:05.280 --> 00:22:06.660
What's ASGI?

00:22:06.660 --> 00:22:07.500
What's the A for?

00:22:07.500 --> 00:22:08.400
Asynchronous?

00:22:08.560 --> 00:22:09.320
Asynchronous, exactly.

00:22:09.320 --> 00:22:10.880
As I said, it's very unimaginative.

00:22:10.880 --> 00:22:17.080
Essentially, I had to find a name, and I stupidly chose to go with changing one letter of WSGI.

00:22:17.080 --> 00:22:19.260
It's not even that similar to WSGI.

00:22:19.260 --> 00:22:24.540
It does also have a way to transport HTTP over it, and that's kind of where it's semi-related.

00:22:24.540 --> 00:22:29.900
But also, it's basically more of a specification for message passing at some point as well.

00:22:29.900 --> 00:22:34.400
So, not the best name, but it's now stuck in everywhere, so I can't really change it.

00:22:34.400 --> 00:22:35.120
Right, absolutely.

00:22:35.120 --> 00:22:40.340
Well, and if you look at the WSGI interface, the API, it's really, really simple.

00:22:41.000 --> 00:22:45.220
And there's really very few hooks for asynchronous programming in there, right?

00:22:45.220 --> 00:22:46.580
Especially bi-directional stuff.

00:22:46.580 --> 00:22:47.060
Exactly.

00:22:47.060 --> 00:22:51.460
In fact, one of the things I love about WSGI so much is how simple it is.

00:22:51.460 --> 00:22:54.360
The interface, literally, you must be a callable.

00:22:54.360 --> 00:22:56.000
You must take two arguments.

00:22:56.320 --> 00:22:58.480
That's the entire interface of WSGI, pretty much.

00:22:58.480 --> 00:23:02.240
There's a specification of what the environment looks like and where you get your stuff from,

00:23:02.240 --> 00:23:03.460
but it's very, very simplistic.

00:23:03.460 --> 00:23:08.160
And so, certainly, that was an inspiration to me of like, well, I want something that's

00:23:08.160 --> 00:23:10.360
similarly very simplistic that you can write against as well.

00:23:10.360 --> 00:23:12.440
And so, that kind of came along.

00:23:12.440 --> 00:23:18.660
But the thing, and the place where WSGI falls down, is that it has no support for asynchronous

00:23:18.660 --> 00:23:19.460
programming at all.

00:23:19.560 --> 00:23:20.600
Like I said, it's a callable.

00:23:20.600 --> 00:23:22.220
It's not a yielding thing.

00:23:22.220 --> 00:23:24.080
It's not a twisted deferred returner.

00:23:24.080 --> 00:23:27.480
It's just a blocking callable that returns when the request is done.

00:23:27.480 --> 00:23:28.040
All right.

00:23:28.040 --> 00:23:30.780
That's like the exact opposite of asynchronous APIs.

00:23:30.780 --> 00:23:32.040
Pretty much, yeah.

00:23:32.040 --> 00:23:33.660
Interesting.

00:23:33.660 --> 00:23:41.420
So, if I write some code here against ASGI, how interchangeable is that?

00:23:41.420 --> 00:23:44.440
Like, what web servers kind of run around?

00:23:44.440 --> 00:23:47.020
Like, a micro WSGI, G-Unicorn.

00:23:47.020 --> 00:23:48.640
Like, does it plug into any of those?

00:23:48.700 --> 00:23:49.940
Or what's the story there?

00:23:49.940 --> 00:23:51.180
There's two separate things.

00:23:51.180 --> 00:23:53.040
There's ASGI, which is like sort of the same.

00:23:53.040 --> 00:23:54.860
Like, here's the thing you can send messages to.

00:23:54.860 --> 00:23:58.360
And then there's the HTTP over ASGI specification.

00:23:58.360 --> 00:24:00.780
That's kind of the WSGI equivalent, right?

00:24:00.780 --> 00:24:02.980
That's like the, here's how we encode requests.

00:24:02.980 --> 00:24:05.240
Here's where the URL variables come.

00:24:05.240 --> 00:24:06.820
Here's how you send a chunk response.

00:24:06.820 --> 00:24:10.380
Like, that stuff is specified as like the format of messages you send over the channels,

00:24:10.380 --> 00:24:10.780
basically.

00:24:10.780 --> 00:24:18.600
And because of the way it supports more than WSGI, it is, of course, not directly compatible.

00:24:18.600 --> 00:24:23.580
And so, in particular, right now, there is one reference server, which is called Daphne.

00:24:23.580 --> 00:24:29.540
Daphne is basically bits of Twisted and bits of Autobahn, which is the really good Python

00:24:29.540 --> 00:24:34.440
WebTockets library, sort of hot glued together in a way that just sort of does the specification.

00:24:35.340 --> 00:24:40.120
And people are also working on, there's been a micro whiskey plugin being worked on.

00:24:40.120 --> 00:24:46.020
Somebody has very bravely been working on a Microsoft IIS plugin, which is really impressive.

00:24:46.020 --> 00:24:46.720
Oh, yeah.

00:24:46.720 --> 00:24:47.940
That's interesting.

00:24:47.940 --> 00:24:49.200
Serious work going into that one.

00:24:49.640 --> 00:24:54.580
But in particular, there's also the idea that it's a superset.

00:24:54.580 --> 00:24:57.940
And so, an adapter from one to the other is not hard to write.

00:24:57.940 --> 00:25:01.980
And in fact, there is a half written adapter already in the code base, where you can plug

00:25:01.980 --> 00:25:06.260
in an ASGI backend to a WSGI server.

00:25:06.260 --> 00:25:07.520
It sort of just translates between them.

00:25:07.520 --> 00:25:12.940
But the key problem is, of course, that doesn't let you run WebSockets because WSGI doesn't

00:25:12.940 --> 00:25:13.620
support WebSockets.

00:25:13.620 --> 00:25:20.020
And so, that lets you sort of proxy things to servers that look like old traditional

00:25:20.020 --> 00:25:22.540
websites, but doesn't give you all the new features that you might want.

00:25:22.540 --> 00:25:26.380
And for those new features, things will have to be like natively supported, basically.

00:25:26.380 --> 00:25:26.760
Yeah.

00:25:26.760 --> 00:25:28.400
So, that's why you've got things like Daphne.

00:25:28.400 --> 00:25:28.880
Exactly.

00:25:28.880 --> 00:25:31.100
So, Daphne is like sort of the reference server.

00:25:31.100 --> 00:25:35.040
And I would love to get like a proper micro whiskey support in there as well.

00:25:35.040 --> 00:25:37.620
Like a second option, maybe Junicle.

00:25:37.620 --> 00:25:42.360
I just sit down with these servers and like seriously look at them and see if I can like

00:25:42.360 --> 00:25:46.680
think of like, can I patch them or like, can I change the design set?

00:25:46.680 --> 00:25:48.840
Like just solve that story.

00:25:48.840 --> 00:25:51.140
So, I'm not just like here, run my special web server.

00:25:51.140 --> 00:25:51.820
It'll be fine.

00:25:51.820 --> 00:25:54.560
It's written by just Andrew on his spare time.

00:25:54.560 --> 00:25:55.760
It's probably okay.

00:25:55.760 --> 00:25:57.140
And change that story.

00:25:57.140 --> 00:26:01.080
Like there is a ecosystem of things you can pick from is the idea.

00:26:01.080 --> 00:26:01.400
Yeah.

00:26:01.400 --> 00:26:02.540
That's really fantastic.

00:26:02.540 --> 00:26:07.300
And cheers to the guy doing IIS because when you're hosting on Windows or you want to host

00:26:07.300 --> 00:26:10.580
it in somewhere like Azure or something like, that's the only choice, right?

00:26:10.580 --> 00:26:13.580
It's not like Linux where there's a variety of things you put together.

00:26:13.580 --> 00:26:17.240
It's just like people on Windows, they just use IIS and that's that.

00:26:17.240 --> 00:26:19.820
So, that's really cool that it could unlock that.

00:26:19.820 --> 00:26:23.540
Let's talk a little bit about the sort of Django patterns.

00:26:23.540 --> 00:26:28.380
Like how is this similar or different to the stuff that people already know?

00:26:28.380 --> 00:26:30.740
Like the idea is to sort of keep it familiar.

00:26:30.740 --> 00:26:35.620
So, obviously, we can't make it the same as Django because like some of the things that

00:26:35.620 --> 00:26:38.520
sort of hobble Whiskey also hobble Django.

00:26:38.520 --> 00:26:42.860
Like Django views are the same kind of they take a request, they return a response.

00:26:42.860 --> 00:26:44.540
You can't really do much inside them.

00:26:44.540 --> 00:26:49.080
And so, my goal was to take things that look and feel familiar and crucially have the same

00:26:49.080 --> 00:26:50.680
safety guarantees as normal Django.

00:26:50.680 --> 00:26:55.200
So, you can code with them the same way but also support these extra abilities.

00:26:55.200 --> 00:26:59.080
And so, like the main thing here is and the sort of top of the thing is things called

00:26:59.080 --> 00:27:02.740
consumers and consumers map pretty much to Django views.

00:27:02.740 --> 00:27:08.460
And the idea is whereas a Django view takes a request and returns a response, a channel's

00:27:08.460 --> 00:27:12.560
consumer gets a message and then can send zero or more other messages.

00:27:12.560 --> 00:27:19.360
So, for example, if you wanted to listen to incoming WebSocket like chat messages, the

00:27:19.360 --> 00:27:21.040
consumer will be tied to the request channel.

00:27:21.320 --> 00:27:25.860
And every time you send a thing in on WebSocket, it would be like, okay, I've got a message.

00:27:25.860 --> 00:27:26.940
It would launch the consumer.

00:27:26.940 --> 00:27:32.520
The consumer can run, handle the message, and then maybe send some messages to other clients

00:27:32.520 --> 00:27:36.140
or sort of broadcast it, store it to a database, and then it exits straight away.

00:27:36.140 --> 00:27:41.060
And the key thing here is that the consumer, it takes one argument, which is a message object,

00:27:41.060 --> 00:27:42.540
which is kind of like the request object.

00:27:42.540 --> 00:27:46.720
You can have session and auth support the same way you can in Django too with decorators.

00:27:46.720 --> 00:27:50.320
It's like message.channel session or message.user, that kind of stuff.

00:27:50.320 --> 00:27:56.060
And also, as long as you stick to the thing of not doing blocking options, blocking things

00:27:56.060 --> 00:28:00.680
in the consumer, it actually makes it almost difficult, almost impossible to deadlock the

00:28:00.680 --> 00:28:05.740
process because it's not proper async because you can't block or listen to other channels.

00:28:05.740 --> 00:28:10.540
And because you sort of have to take the message, run through the logic, and then exit pretty

00:28:10.540 --> 00:28:15.260
much immediately, it means that we can actually churn through messages in the same way that

00:28:15.260 --> 00:28:21.120
Django might churn through HTTP requests with a very similar kind of set of guarantees and

00:28:21.120 --> 00:28:21.800
safety concerns.

00:28:21.800 --> 00:28:22.920
Well, that's really interesting.

00:28:22.920 --> 00:28:31.240
I hadn't really thought of the views themselves actually having to be so cognizant of this async

00:28:31.240 --> 00:28:32.840
world, but it totally makes sense.

00:28:32.840 --> 00:28:33.220
Yeah.

00:28:33.740 --> 00:28:38.520
And in particular, the nice thing is that views end up being just a subset of consumers

00:28:38.520 --> 00:28:44.900
because a view takes a request, which is just a message in channels land, and it returns

00:28:44.900 --> 00:28:46.500
a response, which means sending a message.

00:28:46.500 --> 00:28:50.720
So it actually means that views end up being a subset of consumers and it all sort of neatly

00:28:50.720 --> 00:28:51.660
wraps around.

00:28:51.660 --> 00:28:52.140
Sure.

00:28:52.140 --> 00:28:56.780
You talked a couple of times about the ability to basically deadlock yourself.

00:28:56.780 --> 00:28:58.080
Yes.

00:28:58.200 --> 00:29:03.440
I've seen that before in some of this WebSocket sort of callback style programming where you're

00:29:03.440 --> 00:29:08.080
waiting and you can't receive the message because you're waiting, but you're not going

00:29:08.080 --> 00:29:08.700
to get a response.

00:29:08.700 --> 00:29:13.360
Can you maybe describe some of the ways in which you could like wrap yourself around in that

00:29:13.360 --> 00:29:17.340
trouble or just sort of give somebody an idea what to look out for?

00:29:17.340 --> 00:29:17.760
Yeah.

00:29:17.760 --> 00:29:22.540
So the classic thing is where you have a process that sort of it gets a message and say it then

00:29:22.540 --> 00:29:23.460
waited for a second message.

00:29:23.460 --> 00:29:28.400
It's like, okay, I'm going to send a thing and say, I want X and then wait to get X back.

00:29:28.400 --> 00:29:33.520
The problem is if one process says, I want X, the other process says, okay, I've got X,

00:29:33.520 --> 00:29:35.040
I want Y to the other process.

00:29:35.040 --> 00:29:40.980
They're both then blocked in the thing of waiting for their response, but they both can't serve

00:29:40.980 --> 00:29:42.600
the response to the other process.

00:29:42.600 --> 00:29:43.960
And that's a deadlock basically.

00:29:43.960 --> 00:29:49.400
And that's very easy to get into if you don't have either an excellent knowledge of your

00:29:49.400 --> 00:29:52.140
system architecture and asynchronous programming.

00:29:52.580 --> 00:29:57.540
Or if you have a framework that sort of builds in or so what channels it isn't, but channels

00:29:57.540 --> 00:30:01.680
deliberately doesn't give you full async so that it's much harder to toot yourself in

00:30:01.680 --> 00:30:02.040
the foot.

00:30:02.040 --> 00:30:07.840
Like we don't let you block on things because that makes it very hard to like, we said,

00:30:07.840 --> 00:30:10.020
yeah, you can't, you can't be blocked.

00:30:10.020 --> 00:30:12.200
You can't deadlock because you're waiting on something.

00:30:12.200 --> 00:30:13.420
If you can't wait on something, right?

00:30:13.420 --> 00:30:14.240
Exactly.

00:30:14.240 --> 00:30:18.700
And if you want to, if you want to have that sort of low level control, you can just drop

00:30:18.700 --> 00:30:23.240
down into sort of normal Python and just write your own async stuff against the ASGI interface.

00:30:23.240 --> 00:30:29.520
But the channels level, sort of higher level one that we keep sort of safer and easier to

00:30:29.520 --> 00:30:29.760
stomach.

00:30:29.760 --> 00:30:33.880
So the idea is like, if you're coming into this as a web developer or maybe using as a

00:30:33.880 --> 00:30:39.560
brand new developer, the number of scenarios where you can have not only errors, but errors

00:30:39.560 --> 00:30:41.920
that are impossible to debug is greatly reduced.

00:30:41.920 --> 00:30:45.900
because deadlocks not only nasty, but knowing they've happened and debugging that that's

00:30:45.900 --> 00:30:47.200
what's happening is really difficult.

00:30:47.200 --> 00:30:48.300
It's super difficult.

00:30:48.300 --> 00:30:48.740
Yeah.

00:30:48.740 --> 00:30:52.240
And I heard them described as Heisen bugs.

00:30:52.240 --> 00:30:53.000
Yes.

00:30:53.000 --> 00:30:58.080
Because, you know, even when you like know that they're there by observing them or interacting,

00:30:58.080 --> 00:31:02.880
like putting logging or other stuff sometimes can change the timing, which actually changes

00:31:02.880 --> 00:31:03.180
them.

00:31:03.180 --> 00:31:03.840
Right.

00:31:03.840 --> 00:31:05.640
So super hard.

00:31:05.640 --> 00:31:09.580
One of the, one of the worst things is they often happen only under high load.

00:31:09.580 --> 00:31:11.720
So like, imagine you have like 10 worker threads.

00:31:11.720 --> 00:31:15.520
If you just have like, like five requests a second, it will happen perfectly fine.

00:31:15.520 --> 00:31:20.660
As soon as you hit like over 10 requests a second, say, and you use all 10 of the threads,

00:31:20.660 --> 00:31:24.960
that could then trigger the deadlock because all the thread, all the work is suddenly consumed

00:31:24.960 --> 00:31:25.140
up.

00:31:25.140 --> 00:31:27.140
There's no spare workers to handle these extra requests.

00:31:27.140 --> 00:31:30.440
And so like, it might be fine in development and you need to point to production.

00:31:30.440 --> 00:31:31.340
It's fine in production.

00:31:31.340 --> 00:31:36.540
And then one Sunday evening when your website's under high loads, suddenly it locks up and there's

00:31:36.540 --> 00:31:37.160
no traceback.

00:31:37.160 --> 00:31:37.840
Like what's happening?

00:31:37.840 --> 00:31:38.500
I don't understand.

00:31:38.500 --> 00:31:40.700
It's like, it's a really nasty sign of error.

00:31:40.700 --> 00:31:41.120
Yeah.

00:31:41.120 --> 00:31:42.060
It's super bad.

00:31:42.060 --> 00:31:44.960
And I think it's awesome that your framework like makes that harder.

00:31:44.960 --> 00:31:50.120
That usually that's the kind of stuff that happens right when you need the website to

00:31:50.120 --> 00:31:50.560
work most.

00:31:50.560 --> 00:31:53.840
We're running a new ad or we got featured on Hacker News or whatever.

00:31:53.840 --> 00:31:54.980
Boom.

00:31:54.980 --> 00:31:55.520
It's dead.

00:31:55.520 --> 00:31:56.360
Yeah.

00:31:56.360 --> 00:31:57.740
And it's, it's not perfect, obviously.

00:31:57.740 --> 00:32:01.560
Like we can't stop everything, but like the Jenga philosophy is try and make these things

00:32:01.560 --> 00:32:02.360
hard, but a fault.

00:32:02.360 --> 00:32:04.440
And so that's kind of tried to be reflected here.

00:32:04.540 --> 00:32:04.700
Yeah.

00:32:04.700 --> 00:32:06.280
That's absolutely a good philosophy.

00:32:06.280 --> 00:32:11.760
So some other design patterns around Jenga that are maybe related like routing and messaging.

00:32:11.760 --> 00:32:12.180
Yeah.

00:32:12.180 --> 00:32:14.280
So in the other things that's familiar.

00:32:14.280 --> 00:32:15.320
So routing.

00:32:15.320 --> 00:32:20.080
So the idea is when you say, I have a consumer of this channel, you have to sort of say like

00:32:20.080 --> 00:32:20.600
a view.

00:32:20.760 --> 00:32:23.620
You have to tie that consumer to the channel.

00:32:23.620 --> 00:32:29.740
So like, well, this consumer handles incoming messages on the WebSocket.receive channel.

00:32:29.740 --> 00:32:34.260
And it handles the ones where the path is slash chat.

00:32:34.260 --> 00:32:40.600
And so there's a thing that looks very like Jenga's URL routing, but is channel routing instead.

00:32:40.600 --> 00:32:43.000
It's like, it's not quite the same, but very familiar.

00:32:43.000 --> 00:32:45.340
It's like a list of regular expressions basically.

00:32:45.540 --> 00:32:49.480
And it has, again, very similar guarantees and a lot of power in there.

00:32:49.480 --> 00:32:53.980
And then, as I said before, messages are very much like requests and that like they have

00:32:53.980 --> 00:32:54.800
information on them.

00:32:54.800 --> 00:32:56.080
You can store stuff on them.

00:32:56.080 --> 00:32:57.080
There's session support in there.

00:32:57.080 --> 00:33:03.040
It's like, it all feels a bit like you're writing Jenga views and URLs, but it's a bit more powerful

00:33:03.040 --> 00:33:05.580
with a bit extra, with a few extra options.

00:33:05.580 --> 00:33:05.940
Okay.

00:33:05.940 --> 00:33:06.340
Yeah.

00:33:06.340 --> 00:33:06.720
Very cool.

00:33:06.720 --> 00:33:09.200
And what's the programming model look like?

00:33:09.200 --> 00:33:12.180
Like how is it the same as Jenga or how is it different?

00:33:12.180 --> 00:33:16.680
So to the end developer, it looks largely the same as normal Jenga.

00:33:16.680 --> 00:33:22.420
In particular, channels in its default state runs all of your code, the writer's consumers

00:33:22.420 --> 00:33:23.620
and stuff, synchronously.

00:33:23.620 --> 00:33:27.480
Like you don't ever run into an async option.

00:33:27.480 --> 00:33:30.960
And particularly we run the whole of Jenga synchronously too, because like we can't make

00:33:30.960 --> 00:33:31.600
Jenga async.

00:33:31.600 --> 00:33:35.740
So we just run Jenga synchronously with the sort of, the way design helps us run it in sort

00:33:35.740 --> 00:33:36.360
of a worker thread.

00:33:36.360 --> 00:33:39.460
And all the async is handled away from Jenga, basically.

00:33:40.000 --> 00:33:42.700
So if you're coming in from that end, it looks pretty much like normal Jenga.

00:33:42.700 --> 00:33:47.460
However, if you want to do sort of more advanced stuff or handle different protocols or even

00:33:47.460 --> 00:33:53.920
do your own async programming, it sort of drops down and becomes more of a pure Python thing

00:33:53.920 --> 00:33:57.740
where you can use whatever framework you like that you can use async.io, you can use twisted,

00:33:57.740 --> 00:33:58.820
you can use other things.

00:33:59.260 --> 00:34:05.840
And then you just call the ASGI API, send and receive stuff as you need to.

00:34:05.840 --> 00:34:11.480
So for example, Daphne is a purely asynchronous twisted program that happens to call ASGI in

00:34:11.480 --> 00:34:12.400
the right way inside of it.

00:34:12.400 --> 00:34:16.800
So like you sort of get the choice of, do you want the familiar happy world of Jenga without

00:34:16.800 --> 00:34:17.520
much power?

00:34:17.520 --> 00:34:20.940
Or do you want the raw unbridled power of async?

00:34:20.940 --> 00:34:24.200
But you sort of need to be prepared to go into that particular world.

00:34:24.440 --> 00:34:26.020
Yeah, you're going down the rabbit hole there.

00:34:26.020 --> 00:34:26.600
Interesting.

00:34:26.600 --> 00:34:27.360
Exactly.

00:34:27.800 --> 00:34:32.700
So is this, if I'm doing the async variant, is this still in the same process as Jenga

00:34:32.700 --> 00:34:35.560
or is this like a totally different thing?

00:34:35.560 --> 00:34:36.760
So it's a different process.

00:34:36.760 --> 00:34:40.340
In particular, like one of the things when I sat down, part of that initial period when

00:34:40.340 --> 00:34:43.740
I was sort of like trying to design channels and go through the different options, I had

00:34:43.740 --> 00:34:48.000
some things that were threading, some things were using the multi-process module, some things

00:34:48.000 --> 00:34:52.060
were using green threads or like yielding like generators.

00:34:52.400 --> 00:34:59.060
And eventually I realized that if you're building a large system, as you know, as I do at work

00:34:59.060 --> 00:35:03.420
on a daily basis, you're always going to have more than one server, which means you're always

00:35:03.420 --> 00:35:04.840
going to have to have more than one process.

00:35:04.840 --> 00:35:10.660
And so given that, if I made a model that was just natively multi-processed from the get-go,

00:35:10.660 --> 00:35:13.880
that would make a lot of sense in like, not just multi-process, multi-server.

00:35:13.880 --> 00:35:17.820
Like let's make the model that is by default, it expects to run everything on like a different

00:35:17.820 --> 00:35:21.880
CPU entirely with no shared memory or no shared state and work backwards from there.

00:35:22.200 --> 00:35:27.040
And so everything is basically done in a separate process and message passing happens

00:35:27.040 --> 00:35:27.640
between them.

00:35:27.640 --> 00:35:29.340
And so that's how things are coordinated.

00:35:29.340 --> 00:35:35.120
So it's a bit like, say like if you've ever used Go, for example, Go, a lot of Go primitives

00:35:35.120 --> 00:35:40.260
rely heavily on passing things between Go threads in a thing they call channels as well, which

00:35:40.260 --> 00:35:41.600
is similar but different to channels.

00:35:41.600 --> 00:35:44.440
Yeah, I was going to ask you that about the relationship.

00:35:44.440 --> 00:35:45.600
The name is the same.

00:35:45.600 --> 00:35:47.980
The idea is kind of similar in some ways.

00:35:47.980 --> 00:35:51.420
Like, was there any inspiration or similarity?

00:35:51.720 --> 00:35:56.140
Is it just random similarity or is there more to it with Go and their channels?

00:35:56.140 --> 00:35:56.540
Oh, no.

00:35:56.540 --> 00:36:00.360
So the direct similarity that they both share a common ancestor, which is the language called

00:36:00.360 --> 00:36:01.000
CSP.

00:36:01.000 --> 00:36:05.040
So when I went to university in Oxford, they invented CSPs.

00:36:05.040 --> 00:36:06.820
They definitely teach it and they're very proud of it.

00:36:06.820 --> 00:36:10.760
It's a language for basically proving asynchronous programs.

00:36:10.760 --> 00:36:15.640
And so it's sort of a very abstract grammar of like, oh, we have a process that emits event

00:36:15.640 --> 00:36:20.220
X onto channel Y and then a process that consumes channel Y and then gets event X and then does

00:36:20.220 --> 00:36:20.540
Y.

00:36:20.540 --> 00:36:25.500
And in its core, it's kind of this way of sort of like you can write a set of assumptions

00:36:25.500 --> 00:36:28.720
and prove that programs don't deadlock, which is an incredibly nice way of doing things.

00:36:28.940 --> 00:36:32.640
But it also has these fundamental ideas of processes and channels and splits.

00:36:32.640 --> 00:36:35.840
And so that's where my ideas came from.

00:36:35.840 --> 00:36:40.860
And then sort of via Go, I think the name channels came from Go as well, but like a different take

00:36:40.860 --> 00:36:46.100
on that same core concept of these are communicating sequential processes, which is what CSP stands

00:36:46.100 --> 00:36:46.300
for.

00:36:47.040 --> 00:36:53.560
Yeah, this whole actor model is quite powerful for avoiding deadlocks and race conditions

00:36:53.560 --> 00:36:56.680
and, you know, writing to the same piece of memory at the same time.

00:36:56.680 --> 00:36:58.680
And a lot of the threading problems go away, right?

00:36:58.680 --> 00:37:02.500
And not just that, but also like understanding as a developer, like reasoning about systems

00:37:02.500 --> 00:37:06.280
is much easier when they are very separate components you can read about individually.

00:37:06.280 --> 00:37:11.180
Like if it's all integrated into one big lump, then trying to work out what happening is pretty

00:37:11.180 --> 00:37:11.540
difficult.

00:37:11.540 --> 00:37:14.540
If they're separated out, it's like, oh, here is Daphne.

00:37:14.980 --> 00:37:19.900
Daphne just translates HTTP requests to messages and messages to HTTP responses.

00:37:19.900 --> 00:37:24.060
Writing tests for that is a lot easier because we just write tests where we put one thing

00:37:24.060 --> 00:37:26.040
in one end, the other thing comes up the other end and vice versa.

00:37:26.040 --> 00:37:28.020
Yeah, you have very clear, explicit boundaries.

00:37:28.020 --> 00:37:29.460
These are the messages.

00:37:29.460 --> 00:37:31.140
Here's where the messages come in.

00:37:31.140 --> 00:37:31.920
Here's where they go out.

00:37:31.920 --> 00:37:34.060
And basically, this is what they consist of, right?

00:37:34.060 --> 00:37:34.360
Yeah.

00:37:34.360 --> 00:37:35.260
And then that scales up too.

00:37:35.260 --> 00:37:39.720
Like if you're doing engineering at scale, as in with a large team, those boundaries then

00:37:39.720 --> 00:37:40.580
become team boundaries.

00:37:40.580 --> 00:37:46.920
That really helps you sort of distribute not only the testing, but also like the cognitive

00:37:46.920 --> 00:37:49.640
workload of understanding what the system is doing at any one time that you can draw the

00:37:49.640 --> 00:37:53.920
same boundaries and have teams work on shared understanding in a much better way as well.

00:37:53.920 --> 00:37:54.160
Yeah.

00:37:54.160 --> 00:37:57.920
That's a really good point to think about how it lets people scale, not just software.

00:37:57.920 --> 00:37:58.360
Oh, yeah.

00:37:58.360 --> 00:37:59.260
Scaling.

00:37:59.460 --> 00:38:04.820
I'm very proud these days that scaling software development is about half code scaling, about

00:38:04.820 --> 00:38:06.160
half people scaling.

00:38:06.160 --> 00:38:10.420
Like it's very important to get your team all understanding each other and not being at each

00:38:10.420 --> 00:38:11.300
other's throats all the time.

00:38:11.300 --> 00:38:13.460
And a big part of that is good specs and good APIs.

00:38:13.460 --> 00:38:14.400
Yeah, that's awesome.

00:38:25.620 --> 00:38:28.240
This portion of Talk Python To Me is brought to you by Hired.

00:38:28.240 --> 00:38:31.280
Hired is the platform for top Python developer jobs.

00:38:31.280 --> 00:38:35.540
Create your profile and instantly get access to 3,500 companies who will work to compete

00:38:35.540 --> 00:38:36.080
with you.

00:38:36.080 --> 00:38:40.340
Take it from one of Hired's users who recently got a job and said, I had my first offer on

00:38:40.340 --> 00:38:44.240
Thursday after going live on Monday and I ended up getting eight offers in total.

00:38:44.240 --> 00:38:47.700
I've worked with recruiters in the past, but they've always been pretty hit and miss.

00:38:47.700 --> 00:38:50.540
I tried LinkedIn, but I found Hired to be the best.

00:38:50.540 --> 00:38:52.640
I really liked knowing the salary up front.

00:38:52.640 --> 00:38:55.000
Privacy was also a huge seller for me.

00:38:55.700 --> 00:38:56.680
Sounds awesome, doesn't it?

00:38:56.680 --> 00:38:58.680
Well, wait until you hear about the sign-in bonus.

00:38:58.680 --> 00:39:02.120
Everyone who accepts a job from Hired gets a thousand dollars signing bonus.

00:39:02.120 --> 00:39:04.760
And as Talk Python listeners, it gets way sweeter.

00:39:04.760 --> 00:39:09.380
Use the link Hired.com slash Talk Python To Me and Hired will double the signing bonus to

00:39:09.380 --> 00:39:10.000
$2,000.

00:39:10.000 --> 00:39:11.800
Opportunity's knocking.

00:39:11.800 --> 00:39:15.560
Visit Hired.com slash Talk Python To Me and answer the door.

00:39:22.220 --> 00:39:27.660
So if I'm going to run Django app using channels, how's this work?

00:39:27.660 --> 00:39:28.720
Can I run it the same?

00:39:28.720 --> 00:39:31.240
Probably Daphne is involved somewhere, right?

00:39:31.240 --> 00:39:33.880
Basic level, you run two processes.

00:39:33.880 --> 00:39:34.640
You run Daphne.

00:39:34.640 --> 00:39:38.480
And what Daphne does is Daphne terminates HTTP and WebSockets for you.

00:39:38.480 --> 00:39:43.280
So that's what you expose to the world on port 80 or whatever, or probably behind Nginx doing

00:39:43.280 --> 00:39:44.980
static file serving or something.

00:39:45.440 --> 00:39:47.860
And that sort of fills the role that, say, like G Unicorn might fill.

00:39:47.860 --> 00:39:49.700
Like, here's a process that terminates HTTP.

00:39:49.700 --> 00:39:54.180
And then separately, you run one or more Django worker processes.

00:39:54.180 --> 00:39:59.900
And those processes look at the channel queues that are in this sort of channel routing we

00:39:59.900 --> 00:40:04.500
mentioned earlier and sort of just run the consumers on those channels as messages come

00:40:04.500 --> 00:40:04.800
through.

00:40:04.800 --> 00:40:08.940
And so at a base level, you run one Daphne and you run one worker.

00:40:08.940 --> 00:40:11.720
And then it just sort of works as normal Django does.

00:40:11.940 --> 00:40:12.800
And in particular, I see.

00:40:12.800 --> 00:40:18.400
So the request comes in and if it's like a channel request for, say, WebSockets, it just

00:40:18.400 --> 00:40:21.000
stops at Daphne and gets processed there.

00:40:21.000 --> 00:40:26.600
But if it's something that matches for Django view or something, it will like pass through

00:40:26.600 --> 00:40:28.040
to the Django worker process?

00:40:28.040 --> 00:40:28.460
No.

00:40:28.460 --> 00:40:30.200
So in fact, Daphne does both of them.

00:40:30.200 --> 00:40:35.920
So like both HTTP and WebSockets both get turned into messages on channels.

00:40:35.920 --> 00:40:39.800
So that's kind of the difference to a lot of those previous solutions I talked about near

00:40:39.800 --> 00:40:45.740
the start of the show is that channels has a sort of slightly ambitious goal maybe of putting

00:40:45.740 --> 00:40:46.880
everything over channels.

00:40:46.880 --> 00:40:48.460
This includes HTTP as well.

00:40:48.460 --> 00:40:53.900
So what happens is if you have a HTTP request that comes into Daphne, Daphne takes it, it decodes

00:40:53.900 --> 00:40:58.040
it into the ASGI HTTP format, pass that to Django.

00:40:58.040 --> 00:41:04.340
And then Django has a native ASGI handler next to the WHGI handler that takes that, turns it

00:41:04.340 --> 00:41:06.900
directly into a request object and then runs the views on that stuff too.

00:41:06.900 --> 00:41:07.260
Okay.

00:41:07.260 --> 00:41:08.400
Yeah, that's very cool.

00:41:08.400 --> 00:41:11.960
So it is the same system as the channels running over basically.

00:41:11.960 --> 00:41:12.540
Okay.

00:41:12.540 --> 00:41:12.940
Excellent.

00:41:12.940 --> 00:41:16.060
And you still have things like run server and so on?

00:41:16.060 --> 00:41:16.500
Right.

00:41:16.500 --> 00:41:20.700
So run server, like as for development, just you type run, like if you install channels

00:41:20.700 --> 00:41:24.160
or type run server, it just runs Daphne and worker for you in the same process.

00:41:24.160 --> 00:41:25.920
It's no sort of fitting around there.

00:41:25.920 --> 00:41:27.120
It's just easy to get going.

00:41:27.260 --> 00:41:31.320
And it means you basically, you can pip install channels, put it in your installed apps, and

00:41:31.320 --> 00:41:34.820
then WebSockets just work on your development server straight away, which is really nice

00:41:34.820 --> 00:41:36.060
to have for sort of hacking around.

00:41:36.060 --> 00:41:40.680
And then sort of the other thing you can have, and I sort of recommend, especially to people

00:41:40.680 --> 00:41:45.240
who are wary or like people who are like died in the wall ops people, should we say, is

00:41:45.240 --> 00:41:51.480
you can run both WSGI and channels at the same time and just route WebSockets to Daphne

00:41:51.480 --> 00:41:55.680
and then route normal requests to say MicroWSGI or G-Unicorn.

00:41:55.680 --> 00:42:00.740
And so that way you can use sort of more proven software for your main site, but still use

00:42:00.740 --> 00:42:03.180
channels for your other stuff if you want that sort of that trade-off.

00:42:03.180 --> 00:42:04.120
Oh, that's pretty interesting.

00:42:04.120 --> 00:42:08.460
And you're thinking put something like Nginx in front of it and switch on like protocol

00:42:08.460 --> 00:42:09.540
or something.

00:42:09.540 --> 00:42:09.940
Yeah.

00:42:09.940 --> 00:42:14.000
So you can switch these things, switch on as URL paths, like things on us like slash WS

00:42:14.000 --> 00:42:18.660
WebSockets, but you can, with a couple of tricks, switch on the upgrade header as well,

00:42:18.660 --> 00:42:20.340
which is how you upgrade WebSockets.

00:42:20.340 --> 00:42:21.940
So like there are ways and means.

00:42:21.940 --> 00:42:26.260
It's tricky to switch dynamically based on what's coming in.

00:42:26.260 --> 00:42:27.560
Like you can do it.

00:42:27.560 --> 00:42:28.720
It's very hard to.

00:42:28.720 --> 00:42:31.600
So generally I recommend like sort of a path-based solution.

00:42:31.600 --> 00:42:35.740
And like there's examples in the channels docs and mailing lists about like how that might

00:42:35.740 --> 00:42:37.820
run as well and sort of examples how to set that stuff up.

00:42:37.820 --> 00:42:38.100
All right.

00:42:38.100 --> 00:42:39.680
So what's the extensibility story here?

00:42:39.680 --> 00:42:42.700
So channels is in fact, it's very much built around extensibility.

00:42:42.700 --> 00:42:46.280
Like as I said before, like it's not that much in the base package.

00:42:46.280 --> 00:42:48.820
You sort of WebSocket supports there and that kind of stuff.

00:42:48.820 --> 00:42:53.620
But like it's designed to be built upon in sort of a community way like Django's itself.

00:42:53.620 --> 00:42:59.300
So things, for example, like the ability to have proper heart beating of people connected.

00:42:59.300 --> 00:43:00.740
So, you know, they're definitely still connected.

00:43:00.740 --> 00:43:03.180
Like that is a thing that you could put on top of channels.

00:43:03.320 --> 00:43:07.880
And so what I'm trying to do is like foster a community of third-party apps that are built

00:43:07.880 --> 00:43:09.540
against channels and the common specifications.

00:43:09.540 --> 00:43:16.120
In many ways, that's why I took it upon myself to build a sort of more official, it's not the

00:43:16.120 --> 00:43:19.940
right, but to build a singular solution that we can sort of almost tout as Django solution

00:43:19.940 --> 00:43:20.740
for this stuff.

00:43:20.920 --> 00:43:23.480
So that there is a common thing that people can build against.

00:43:23.480 --> 00:43:29.060
Because like a lot of the part of Django success is having a common standard people write against.

00:43:29.060 --> 00:43:30.560
Like it's a common known factor.

00:43:30.560 --> 00:43:34.620
And so really it's designed around that idea of like, yeah, everyone's going to have the

00:43:34.620 --> 00:43:35.280
same routing.

00:43:35.280 --> 00:43:37.420
Everyone's going to have the same idea of consumers.

00:43:37.420 --> 00:43:42.720
Like things integrate the same kind of way and like trying to encourage that kind of ecosystem

00:43:42.720 --> 00:43:43.240
as it were.

00:43:43.480 --> 00:43:44.120
Yeah, absolutely.

00:43:44.120 --> 00:43:48.440
I, you know, that's definitely a hallmark of Django is all the pieces you can bring

00:43:48.440 --> 00:43:51.040
together to make it more than what it is out of the box.

00:43:51.040 --> 00:43:51.540
Exactly.

00:43:51.540 --> 00:43:52.120
Nice.

00:43:52.120 --> 00:43:57.080
Are there like some notable third-party packages or projects that you want to talk about?

00:43:57.080 --> 00:43:58.660
Not, not, I can talk to my head.

00:43:58.660 --> 00:44:00.020
Like I don't know them off by heart.

00:44:00.020 --> 00:44:03.860
We have, we have a page on the docs that links to a couple of ones that are already going.

00:44:03.860 --> 00:44:04.400
Okay.

00:44:04.400 --> 00:44:04.720
Awesome.

00:44:04.720 --> 00:44:07.800
There's also a few more that aren't on there yet.

00:44:07.800 --> 00:44:10.600
I encourage the developers to add links to the doc.

00:44:10.600 --> 00:44:11.000
Okay.

00:44:11.000 --> 00:44:11.780
So let's see.

00:44:11.780 --> 00:44:13.420
We talked about Daphne a little bit.

00:44:13.860 --> 00:44:16.600
Tell me some of the packages that you're using to put this together.

00:44:16.600 --> 00:44:17.020
Yeah.

00:44:17.020 --> 00:44:21.420
So like one of the things was like trying like Django for a long time is criticized as being,

00:44:21.420 --> 00:44:23.260
oh, Django is one giant package.

00:44:23.260 --> 00:44:24.620
It's not split in separate bits.

00:44:24.620 --> 00:44:26.280
So I went the entire opposite way.

00:44:26.280 --> 00:44:28.340
There are five different packages as part of channels.

00:44:28.340 --> 00:44:34.880
So you have the base channels package, which is the, basically the Django plugin side of

00:44:34.880 --> 00:44:38.600
things as Django third-party app or second-party app, I guess, or first-party app.

00:44:38.600 --> 00:44:41.180
But it's a Django pluggable app that you load into Django.

00:44:41.540 --> 00:44:44.960
It does all the routing and run server overloading we talked about before and gives you sort of

00:44:44.960 --> 00:44:46.400
the nice user experience.

00:44:46.400 --> 00:44:47.780
But it doesn't give you the serving.

00:44:47.780 --> 00:44:49.340
And so Daphne is the other half of that.

00:44:49.340 --> 00:44:51.120
Daphne is the service.

00:44:51.120 --> 00:44:57.020
So Daphne is the server that terminates HTTP and WebSockets and sort of translates them through

00:44:57.020 --> 00:44:57.960
into channels for you.

00:44:57.960 --> 00:45:01.720
If there was something else there, you could just use channels and a different thing that

00:45:01.720 --> 00:45:02.200
wasn't Daphne.

00:45:02.320 --> 00:45:04.320
But for now, we bundle them together pretty much.

00:45:04.320 --> 00:45:07.080
And then underneath that, there is the ASGI packages.

00:45:07.080 --> 00:45:10.620
So the things that build this sort of low-level protocol we build upon.

00:45:10.620 --> 00:45:15.060
So there's ASGI ref, which is sort of the base ASGI library.

00:45:15.060 --> 00:45:16.960
It has the conformance test suite in it.

00:45:16.960 --> 00:45:20.760
So you can, like, if you're writing a new ASGI backend, you just load up the conformance

00:45:20.760 --> 00:45:24.100
tests and it just tests your spec, which is really nice to have for new implementations.

00:45:24.680 --> 00:45:27.760
And it has a memory backend too for testing, like, in-memory for unit tests.

00:45:27.760 --> 00:45:30.220
And on top of that, you have two different backends.

00:45:30.220 --> 00:45:32.880
The Redis backend called ASGI underscore Redis.

00:45:32.880 --> 00:45:36.640
And that is a standard Redis backend, the one we recommend for production use.

00:45:36.640 --> 00:45:42.220
It uses Redis lists and blocking pops and Lua scripts and a few other things in there.

00:45:42.220 --> 00:45:45.860
And it has built-in sharding if you want to use more than one server to scale up.

00:45:45.860 --> 00:45:51.600
And then as sort of a midway point, there's a ASGI underscore IPC backend that only works

00:45:51.600 --> 00:45:52.400
on one server.

00:45:52.640 --> 00:45:56.780
And it's designed for, if you don't want to run a separate Redis server as well, you

00:45:56.780 --> 00:45:58.940
just want to run things on one machine, keep it simple.

00:45:58.940 --> 00:46:02.780
It doesn't perform nearly as well, but it is zero configuration.

00:46:02.780 --> 00:46:07.780
You just basically just load it up as the option backend, just set the same prefix and things

00:46:07.780 --> 00:46:10.140
just talk to each other on the same machine via a shared memory segment.

00:46:10.140 --> 00:46:11.220
Oh yeah, that's really nice.

00:46:11.220 --> 00:46:11.780
Really nice.

00:46:11.780 --> 00:46:16.580
So what's the story with Python 2 versus Python 3 on this project?

00:46:16.580 --> 00:46:19.300
So everything is built Python 3 first.

00:46:19.300 --> 00:46:22.480
And in fact, Django itself is going Python 3 only very soon.

00:46:22.480 --> 00:46:24.240
as of the next major release, I believe.

00:46:24.240 --> 00:46:26.080
That's in Django 2.

00:46:26.080 --> 00:46:31.200
And so it's built with Python 3 first, but also Python 2 support is still there.

00:46:31.200 --> 00:46:35.260
So channel supports the previous LTS of Django and up.

00:46:35.260 --> 00:46:36.460
So that's 1.8 and up.

00:46:36.460 --> 00:46:38.580
And 1.8 supports Python 2.7.

00:46:38.580 --> 00:46:40.780
So it supports Python 2.7 and Python 3.

00:46:41.200 --> 00:46:43.540
All my testing and all my developments done on Python 3.

00:46:43.540 --> 00:46:47.280
And then we have Travis just running Python 2 tests occasionally.

00:46:47.280 --> 00:46:50.420
And I'll just occasionally pop down to Python 2 and make sure things work expected.

00:46:50.420 --> 00:46:56.300
But I've seen like one bug that was Python 2 specific in the entire time I've been developing

00:46:56.300 --> 00:46:56.740
so far.

00:46:56.740 --> 00:46:59.780
So it's not really a concern at all in that regard.

00:47:00.040 --> 00:47:01.180
Oh, that's really fantastic.

00:47:01.180 --> 00:47:04.580
And I'd love to see you doing this in Python 3 first.

00:47:04.580 --> 00:47:09.380
You know, I talked to the guys at the Beware project, and they're doing Python 3 only.

00:47:09.380 --> 00:47:14.400
I'm surprised to hear about Django going Python 3, although excited to hear it.

00:47:14.740 --> 00:47:20.360
I think Python 3 is really, it's crossed some kind of threshold or critical mass recently,

00:47:20.360 --> 00:47:21.180
I feel.

00:47:21.180 --> 00:47:22.920
Yeah, like, I feel the same way too.

00:47:22.920 --> 00:47:26.900
Like, in the last year or year and a half or so, we definitely crossed that threshold of,

00:47:26.900 --> 00:47:30.660
like, things are coming out in Python 3 only, a lot of cases.

00:47:30.660 --> 00:47:35.700
We're finding libraries at work now that were like, oh, this great accounting library is only

00:47:35.700 --> 00:47:36.460
on Python 3.

00:47:36.460 --> 00:47:38.820
And then suddenly, like, we need to move code to Python 3.

00:47:38.820 --> 00:47:40.960
It's become almost this trend now.

00:47:40.960 --> 00:47:44.600
And, like, it's difficult for a big company like Eventbrite to move to Python 3, of course.

00:47:44.840 --> 00:47:48.840
But definitely, a sea change is definitely happening these days.

00:47:48.840 --> 00:47:51.960
And everything I write from scratch is done on Python 3.

00:47:51.960 --> 00:47:52.960
Yeah, that's fantastic.

00:47:52.960 --> 00:47:59.760
I feel like I'm noticing it in that people are apologizing for it being Python 2 in the

00:47:59.760 --> 00:48:03.360
cases where it is, or they feel guilty or bad about it or whatever.

00:48:03.360 --> 00:48:06.340
Whereas a few years ago, it was kind of like, yeah, it's Python 2, of course.

00:48:06.340 --> 00:48:08.500
Like, haha, Python 3, whatever, right?

00:48:08.500 --> 00:48:09.780
So this is really cool.

00:48:09.780 --> 00:48:13.800
Tell me a little bit about Django going Python 3, if you know any of the backstory.

00:48:14.020 --> 00:48:14.920
What's going on there?

00:48:14.920 --> 00:48:18.780
So we decided quite a while ago to draw a line in the sand, as it were.

00:48:18.780 --> 00:48:21.840
So, like, you know, at some point, we need to do Python 3 only.

00:48:21.840 --> 00:48:27.000
In many ways, because Django's job is, in some ways, as a leader in this area.

00:48:27.000 --> 00:48:30.380
Like, if Django is Python 3 only, that's a big signal to a lot of other Python packages that,

00:48:30.380 --> 00:48:32.040
yes, you can do this too.

00:48:32.040 --> 00:48:32.860
It's a huge signal.

00:48:32.860 --> 00:48:33.580
It's a huge signal.

00:48:33.720 --> 00:48:35.420
And so the line was decided.

00:48:35.420 --> 00:48:37.180
And, like, we debated for a long while.

00:48:37.180 --> 00:48:41.120
I'd be like, well, like, what version of Django should we do it on?

00:48:41.120 --> 00:48:42.700
Like, when should we do it?

00:48:42.700 --> 00:48:47.480
And so different core developers were arguing at different times for, like, oh, well, can

00:48:47.480 --> 00:48:48.220
we do it now?

00:48:48.220 --> 00:48:51.420
So I think, like, two or three years ago, people would say, like, oh, let's just do it now.

00:48:51.420 --> 00:48:52.400
Let's just switch straight away.

00:48:52.920 --> 00:48:59.040
And then eventually we decided that Django 2.0 is the first release to only support Python

00:48:59.040 --> 00:48:59.380
3.

00:48:59.380 --> 00:49:01.340
And in particular, Python 3.5 and above.

00:49:01.340 --> 00:49:05.400
Because the reasoning being that Python 3 is small enough that people are pretty much

00:49:05.400 --> 00:49:06.640
on the newest version of Python 3.

00:49:06.640 --> 00:49:09.260
There's not many differences that start upgrading to Python 3.5.

00:49:09.260 --> 00:49:15.540
And so what this means to Django in particular is we can remove swathes of compatibility code.

00:49:15.540 --> 00:49:16.960
Like, there's so much in there.

00:49:16.960 --> 00:49:21.280
Some of the core devs are literally chomping at the bit to just delete huge reams of code

00:49:21.280 --> 00:49:22.420
that are just Python 2.0 specific.

00:49:23.120 --> 00:49:26.160
And in particular, like, we can use things like all the new features.

00:49:26.160 --> 00:49:28.880
We can get some of the class inheritance stuff and get done properly.

00:49:28.880 --> 00:49:32.820
Like, all the sort of stuff that we had to sort of keep going with Python 2 and keep it

00:49:32.820 --> 00:49:34.540
there is all being swept away.

00:49:34.540 --> 00:49:39.600
And the nice thing, too, is that because it's Django 2.0, we can say, okay, this is a nice

00:49:39.600 --> 00:49:40.400
big change.

00:49:40.400 --> 00:49:43.180
And in fact, like, the Django number system is changing entirely.

00:49:43.180 --> 00:49:48.180
So for reference, what's happening is we're making it so that Django's releases are...

00:49:48.840 --> 00:49:53.720
There's every major LTS will be the last number in its major number.

00:49:53.720 --> 00:49:55.380
So like 1.11 will be the last one.

00:49:55.380 --> 00:49:57.480
Then we'll have 2.0, 2.1, 2.2.

00:49:57.480 --> 00:49:59.120
Then 2.3 is the next LTS.

00:49:59.120 --> 00:50:00.980
And 3.0, 3.1, 3.2.

00:50:00.980 --> 00:50:01.740
And 3.3, the LTS.

00:50:01.740 --> 00:50:03.080
And that kind of strategy.

00:50:03.620 --> 00:50:08.840
And it just happens that it's kind of timed nicely that Python 3.5 support happens in

00:50:08.840 --> 00:50:09.400
Django 2.

00:50:09.400 --> 00:50:12.160
So it's a good reason to call it Django 2, I think.

00:50:12.160 --> 00:50:15.300
We were worried for a while in Django Core that there wouldn't be a good thing in Django

00:50:15.300 --> 00:50:15.520
2.

00:50:15.520 --> 00:50:18.800
We'd be like, oh, and this is just another maintenance release of Django with some bug

00:50:18.800 --> 00:50:19.060
fixes.

00:50:19.060 --> 00:50:21.580
But it's nice to have a bit of a sort of big change in there as well.

00:50:21.580 --> 00:50:23.260
Yeah, that's really cool.

00:50:23.260 --> 00:50:28.200
And I think changing the major version number sends a strong signal like this thing is different.

00:50:28.620 --> 00:50:28.820
Exactly.

00:50:28.820 --> 00:50:30.380
And it's easy to pull.

00:50:30.380 --> 00:50:37.300
I've been doing for the last three or so years now, pausing code to Python 3, really not that

00:50:37.300 --> 00:50:37.720
hard.

00:50:37.720 --> 00:50:42.300
Once you get your head around what's going on, and if your encodings are already good.

00:50:42.300 --> 00:50:47.000
It's like Python 3, and I like this about Python 3, really punishes you for not having good

00:50:47.000 --> 00:50:49.180
encodings, like knowing where your bytes come from.

00:50:49.180 --> 00:50:54.960
Which for developing channels, which is all about handling bytes over the wire versus encoded

00:50:54.960 --> 00:50:57.440
messages or URLs, is incredibly useful.

00:50:57.600 --> 00:51:01.040
Like, oh, well, you've tried to pass this byte string to the Unicode string function.

00:51:01.040 --> 00:51:01.820
It just blows up.

00:51:01.820 --> 00:51:05.440
It's like having, as long as that's all in order and you know where your strings are coming

00:51:05.440 --> 00:51:08.760
from, it's pretty painless to port in my experience.

00:51:08.760 --> 00:51:09.780
Yeah, that's really excellent.

00:51:09.780 --> 00:51:15.080
And it is sort of that network layer that you see some of the differences between Python

00:51:15.080 --> 00:51:19.940
2 and Python 3 more when you're down at the string level and taking bytes and converting

00:51:19.940 --> 00:51:20.180
them.

00:51:20.180 --> 00:51:21.780
But yeah, it sounds really good.

00:51:21.780 --> 00:51:23.100
Yeah, it's really good.

00:51:23.100 --> 00:51:26.380
Like, my main complaint is that I keep typing print with a space rather than print with a

00:51:26.380 --> 00:51:26.940
parenthesis.

00:51:26.940 --> 00:51:29.260
Like, muscle memory is a really hard thing to undo.

00:51:29.260 --> 00:51:30.240
Yeah, absolutely.

00:51:30.740 --> 00:51:40.580
So when we talked about WSGI and we talked about AWSGI, the asynchronous thing, what came

00:51:40.580 --> 00:51:48.240
to mind for me was this concept of WSGI 2, which is being sort of brought into existence by

00:51:48.240 --> 00:51:52.300
the pressure that HTTP 2 is putting on the WSGI specification, right?

00:51:52.300 --> 00:51:52.720
Yeah.

00:51:53.380 --> 00:51:54.460
Other pressures too.

00:51:54.460 --> 00:51:55.960
WebSockets is part of those pressures as well.

00:51:55.960 --> 00:51:56.760
Yeah, absolutely.

00:51:56.760 --> 00:51:58.120
Well, I was, you're right.

00:51:58.120 --> 00:51:59.680
WebSockets predates HTTP 2.

00:51:59.680 --> 00:52:03.820
But all this sort of, we want to run more than one thing over this channel and we want

00:52:03.820 --> 00:52:07.080
to sometimes do it in binary, like just doesn't work at all.

00:52:07.080 --> 00:52:13.440
So can you talk a little bit about like WSGI 2 and maybe how that like would either help

00:52:13.440 --> 00:52:15.960
or is parallel to what you're doing?

00:52:16.160 --> 00:52:16.440
Yeah.

00:52:16.440 --> 00:52:18.660
So like I actually involved in discussions for a while.

00:52:18.660 --> 00:52:23.400
So there's a group in Python called WebSig and WebSig is sort of the place where things

00:52:23.400 --> 00:52:24.740
about WSGI get discussed.

00:52:24.740 --> 00:52:29.160
And there's been on and off for like a few years now, at least, I came in pretty late to

00:52:29.160 --> 00:52:31.420
discussion, this idea of WSGI 2.

00:52:32.100 --> 00:52:38.840
And one of the main problems is that if you want to call it WSGI, it has to look a lot

00:52:38.840 --> 00:52:42.020
like WSGI and in theory, backwards compatible as well.

00:52:42.020 --> 00:52:44.020
And that really hinders the approach.

00:52:44.020 --> 00:52:49.120
And like, as of the time of recording, there's been very little progress on WSGI 2 for like

00:52:49.120 --> 00:52:51.140
about two years, if not longer.

00:52:51.140 --> 00:52:55.480
Lots of different ideas about what should be done or different approaches, like how do we

00:52:55.480 --> 00:52:56.440
even make things async?

00:52:56.440 --> 00:53:04.220
And so my conclusion to that was that like Django needs something, we needed something

00:53:04.220 --> 00:53:06.440
that existed and worked.

00:53:06.440 --> 00:53:10.920
And I read through all the threads and tried to educate myself on the arguments and the

00:53:10.920 --> 00:53:15.760
reasons behind different people's visions and wants for WSGI 2 and took some of those

00:53:15.760 --> 00:53:20.020
with me to the design of ASGI and in particular the HTTP layer on top of it.

00:53:20.120 --> 00:53:26.000
But at the same time, I don't want to stride in and declare a replacement for the WSGI

00:53:26.000 --> 00:53:28.700
with ASGI, rather it's a different thing.

00:53:28.700 --> 00:53:31.980
I also think that a different thing is the right solution.

00:53:31.980 --> 00:53:39.140
I think that Python web systems are more than just handling HTTP responses these days.

00:53:39.140 --> 00:53:46.180
And so my ultimate goal is probably to try and sit down, get Django and get more implementations

00:53:46.180 --> 00:53:47.000
of this going through.

00:53:47.000 --> 00:53:51.460
And then when we have a good set of reference implementation, like two references on either

00:53:51.460 --> 00:53:58.060
end, it's proven in production, then take that proven thing back to WebSIG and say, hey,

00:53:58.060 --> 00:54:02.740
can we decide on this thing that's already in place that has proof behind it?

00:54:02.740 --> 00:54:05.920
And then we can see what's happening with it rather than trying to argue in the abstract,

00:54:05.920 --> 00:54:06.400
basically.

00:54:06.400 --> 00:54:10.060
Yeah, I think arguing in the abstract is really hard to do.

00:54:10.060 --> 00:54:11.320
It's very difficult.

00:54:11.320 --> 00:54:14.540
Yeah, you can just go around and around and around.

00:54:14.540 --> 00:54:19.840
And I, you know, I don't know exactly what's happening internally at WebSIG, but if it's

00:54:19.840 --> 00:54:23.580
been kind of idle for two years and HTTP2 is coming, the web is not standing still.

00:54:23.580 --> 00:54:27.080
So I feel like, you know, maybe there's some of that going on.

00:54:27.080 --> 00:54:28.400
I am perfectly willing.

00:54:28.400 --> 00:54:34.280
If someone comes up tomorrow with an amazing WSGI 2 spec that everyone adopts, I will immediately

00:54:34.280 --> 00:54:35.460
drop and support that stuff.

00:54:35.460 --> 00:54:40.080
But like, given the lack of movement, I felt that someone has to do something.

00:54:40.260 --> 00:54:42.600
And so I decided to be that someone and do something.

00:54:42.600 --> 00:54:43.480
Yeah, this is really cool.

00:54:43.480 --> 00:54:48.600
I mean, if you get this to be successful and proven, like you said, it's really easy to

00:54:48.600 --> 00:54:51.280
take it back and go, look, this is more or less working.

00:54:52.060 --> 00:54:53.220
Let's make a spec.

00:54:53.220 --> 00:54:58.640
Let's extract a spec out of this general idea rather than debate at an infinite item.

00:54:58.640 --> 00:54:59.020
Exactly.

00:54:59.020 --> 00:55:03.380
I've been trying to keep conversations going with like various authors or luminaries of

00:55:03.380 --> 00:55:04.180
Python web stuff.

00:55:04.180 --> 00:55:07.820
Like not enough, but like getting opinions and feedback on like the way things are done.

00:55:07.820 --> 00:55:12.620
It's like silly things like cleaning up the, like I said, encoding, cleaning up the encoding

00:55:12.620 --> 00:55:14.640
of how strings are passed around in ASGI.

00:55:14.800 --> 00:55:20.060
Like ASGI has an exact specification of which bits of the request come through as Unicode

00:55:20.060 --> 00:55:24.500
and which bits come through as bytes, which WSGI does not have and can kind of never have.

00:55:24.500 --> 00:55:27.440
So like I've been trying to keep a lot of those things in mind.

00:55:27.440 --> 00:55:33.280
And I don't know if it'd be successful in the end, but I'm hoping that like pragmatism is worth

00:55:33.280 --> 00:55:33.820
a lot here.

00:55:33.820 --> 00:55:41.060
And even if the message passing sort of asynchronous bit doesn't survive, the basic format of here's

00:55:41.060 --> 00:55:44.640
how you take a request and put it into a message dict would still be useful.

00:55:44.640 --> 00:55:45.380
Yeah.

00:55:45.380 --> 00:55:50.140
I think it's really positive that you're working on this and hopefully, hopefully that can,

00:55:50.140 --> 00:55:55.180
you know, fall this, this blockade or whatever, whatever is going on there.

00:55:55.180 --> 00:55:58.560
Some point like doing open source collaboration is really difficult.

00:55:58.560 --> 00:55:59.580
Like it takes a lot of effort.

00:55:59.680 --> 00:56:03.060
So like it takes not just me, but other people.

00:56:03.060 --> 00:56:04.600
So hopefully we can get something, something out.

00:56:04.600 --> 00:56:05.040
Yeah.

00:56:05.040 --> 00:56:05.520
Hopefully.

00:56:05.520 --> 00:56:11.920
I mean, WSGI itself has been so important and so successful that it's just really scary

00:56:11.920 --> 00:56:12.840
and hard to change.

00:56:12.840 --> 00:56:16.040
So I think that's, it's almost a victim of its own success in that regard.

00:56:16.040 --> 00:56:16.340
Yeah.

00:56:16.340 --> 00:56:22.160
WSGI is like right next to CGI and like how pervasive and successful it's been.

00:56:22.160 --> 00:56:26.500
Like every like Python web program runs on it.

00:56:26.500 --> 00:56:28.760
It's incredibly, it's incredibly simple.

00:56:28.980 --> 00:56:33.800
It's very powerful and the pluggability of different servers is like a huge boon in its

00:56:33.800 --> 00:56:34.520
deployment, right?

00:56:34.520 --> 00:56:39.400
Like deployment in Python is never as easy as PHP, but it's pretty damn close considering

00:56:39.400 --> 00:56:40.980
like we have all these different options.

00:56:40.980 --> 00:56:43.740
So that's really something to aspire to.

00:56:43.740 --> 00:56:49.200
I think like WSGI is an amazing specification that I am always in awe of, like every time.

00:56:49.200 --> 00:56:55.040
Like I'm very pleased that the original authors like decided to settle on it like so long ago

00:56:55.040 --> 00:56:55.460
as well.

00:56:56.160 --> 00:56:56.860
Yeah, absolutely.

00:56:56.860 --> 00:57:00.820
It's been going like 15 years or something and it's still going strong.

00:57:00.820 --> 00:57:03.060
It just, it's starting to show its age.

00:57:03.060 --> 00:57:09.120
That world was much less about serving multiple things and bi-directional stuff over the same

00:57:09.120 --> 00:57:10.820
channel and all sorts of things like that.

00:57:10.820 --> 00:57:11.200
Right.

00:57:11.200 --> 00:57:14.680
To survive 15 years in software is an incredibly long time.

00:57:14.680 --> 00:57:18.580
Like when Django hit 10, I was feeling, I was already feeling like a bit old.

00:57:18.580 --> 00:57:19.020
Right.

00:57:19.240 --> 00:57:21.360
So yeah, like it's, it's really impressive.

00:57:21.360 --> 00:57:22.180
Yeah, absolutely.

00:57:22.180 --> 00:57:23.160
Okay.

00:57:23.160 --> 00:57:24.620
So that's, that's really great.

00:57:24.620 --> 00:57:30.440
So maybe, maybe one final question is how's all this useful beyond Django?

00:57:30.440 --> 00:57:32.400
Like it's, it's cool that we can plug it into Django.

00:57:32.400 --> 00:57:33.620
What else can we do with it?

00:57:33.620 --> 00:57:39.240
So like really my goal, my ambitious goal at the end of all of this, I think is to make

00:57:39.240 --> 00:57:41.800
writing distributed systems in Python easier.

00:57:42.320 --> 00:57:47.060
And maybe not even in Python, maybe in general, but like, you know, I am, as like my career

00:57:47.060 --> 00:57:53.140
goes on, I find myself writing software, distributed systems are the one challenge I keep both enjoying

00:57:53.140 --> 00:57:54.880
and the challenges me time and time again.

00:57:54.880 --> 00:58:00.240
And like, I would love to have this idea of message passing, this idea of channels and passing

00:58:00.240 --> 00:58:05.920
messages and these, these primitives be the way that Python programs in general, like not

00:58:05.920 --> 00:58:12.240
just HTTP, but like chatbots and like internet of things systems and like stats systems, all

00:58:12.240 --> 00:58:16.640
these things have this common base construct to build upon and talk to each other and message

00:58:16.640 --> 00:58:16.920
pass.

00:58:16.920 --> 00:58:19.560
And like, I think that's the ultimate goal beyond Django.

00:58:19.560 --> 00:58:21.400
There's certainly a long way to get there.

00:58:21.400 --> 00:58:25.540
The middle goal is to have other Python web stuff work with it as well.

00:58:25.540 --> 00:58:31.960
But I have like, you know, and I think it's nice to have somewhat grand ambitions for improving

00:58:31.960 --> 00:58:33.300
Python in general.

00:58:33.300 --> 00:58:36.780
Like the, like, I like Python, the language a lot.

00:58:36.780 --> 00:58:38.520
Like I'm not just a Django person, right?

00:58:38.520 --> 00:58:40.540
Like Python is my real home in many ways.

00:58:40.620 --> 00:58:44.120
So I want to make sure that everyone can benefit from this stuff and to really push the state

00:58:44.120 --> 00:58:45.260
of the art forward in that respect.

00:58:45.260 --> 00:58:45.660
Yeah.

00:58:45.660 --> 00:58:49.640
That's, that's really cool that it's, it's got that sort of broader goal.

00:58:49.640 --> 00:58:54.380
You know, you're talking a lot about moving to Python three and this is Python three first.

00:58:54.380 --> 00:58:59.920
Do you see a world where you could use this idea of channels and this as the infrastructure

00:58:59.920 --> 00:59:06.640
for those channels mixed in with like async and await to be, to make Python much more go like?

00:59:06.860 --> 00:59:08.240
That's kind of one of the ideas.

00:59:08.240 --> 00:59:08.520
Yeah.

00:59:08.520 --> 00:59:13.560
It's like, it's like channels in the spec, ASGI in the spec rather, has provisions for a

00:59:13.560 --> 00:59:15.460
async code compatible receive command.

00:59:15.460 --> 00:59:19.440
So you can do, you can await on receive and how it blocked correctly and do all that kind

00:59:19.440 --> 00:59:19.780
of stuff.

00:59:19.780 --> 00:59:25.200
So the idea is really that you can, and moreover, like it's not just that you can write async code,

00:59:25.200 --> 00:59:29.020
it's that you can also write synchronous code and have that intermixed.

00:59:29.140 --> 00:59:34.700
Like, cause I'm a strong proponent of if the code you can write can be synchronous or

00:59:34.700 --> 00:59:37.740
at least can be written in a synchronous fashion, that's fine.

00:59:37.740 --> 00:59:40.900
As long as it interoperates properly, like synchronous code is easier to reason about.

00:59:40.900 --> 00:59:42.440
It's easier to test in many cases.

00:59:42.440 --> 00:59:48.000
So if we can have a system that supports both async code natively and synchronous code natively

00:59:48.000 --> 00:59:52.540
and they interact properly and you can plug and replace different parts of the system correctly

00:59:52.540 --> 00:59:56.720
and like, oh, well, we've written this part of the system, like, you know, this waiting

00:59:56.720 --> 01:00:03.340
room system here is in ASUNKO, whereas like this emailing system here is in twisted and

01:00:03.340 --> 01:00:05.300
this part of the system over here is in synchronous code.

01:00:05.300 --> 01:00:08.840
I think that's also a good goal to aim for, like flexibility is really important.

01:00:08.840 --> 01:00:09.660
Yeah, absolutely.

01:00:09.660 --> 01:00:10.500
All right.

01:00:10.500 --> 01:00:12.060
That sounds, that sounds like a cool feature.

01:00:12.060 --> 01:00:13.400
I'm looking forward to seeing it.

01:00:13.400 --> 01:00:14.420
Let's hope we get there.

01:00:14.420 --> 01:00:15.580
For sure.

01:00:15.580 --> 01:00:16.540
All right.

01:00:16.540 --> 01:00:18.060
So I think maybe we'll just leave it here.

01:00:18.060 --> 01:00:22.200
This is a really cool project that you put together and I'm excited to see it gain

01:00:22.200 --> 01:00:22.560
attraction.

01:00:22.560 --> 01:00:23.580
Thank you.

01:00:23.580 --> 01:00:24.580
Yeah, you bet.

01:00:24.580 --> 01:00:28.760
So before I let you out of here, let me ask you two questions I always ask at the end of

01:00:28.760 --> 01:00:29.060
the show.

01:00:29.060 --> 01:00:33.400
First of all, if you can write some code, Python code, other code, what editor do you open

01:00:33.400 --> 01:00:33.580
up?

01:00:33.580 --> 01:00:34.880
I'm a Sublime Text user.

01:00:34.880 --> 01:00:36.340
I have been for like four or five years now.

01:00:36.340 --> 01:00:38.480
It's just, it's got Python in it too.

01:00:38.480 --> 01:00:39.840
So you can't argue with that really, can you?

01:00:39.840 --> 01:00:42.560
And now it's definitely the home for Python there.

01:00:42.560 --> 01:00:45.480
Have you checked out the Anaconda plugin for it?

01:00:45.480 --> 01:00:46.260
I haven't, no.

01:00:46.260 --> 01:00:46.660
Okay.

01:00:46.660 --> 01:00:51.400
I have my own sort of set of plugins and some custom plugins I've collected over the years

01:00:51.400 --> 01:00:53.440
that sort of, they sort of work together mostly.

01:00:53.440 --> 01:00:54.820
It's pretty decent.

01:00:54.820 --> 01:00:55.400
Nice.

01:00:55.400 --> 01:00:55.780
All right.

01:00:55.780 --> 01:00:59.320
And there's 96,000 packages on PyPI.

01:00:59.320 --> 01:01:04.060
There's a ton that you've probably come across that people haven't heard of necessarily or you'd

01:01:04.060 --> 01:01:04.620
like to recommend.

01:01:04.620 --> 01:01:05.860
What's on your mind?

01:01:05.860 --> 01:01:09.160
And the one I've used most recently, I was really impressed with it is Cryptography, which

01:01:09.160 --> 01:01:11.200
is actually quite new given the name is quite generic.

01:01:11.200 --> 01:01:16.640
It's a really well done crypto package that is designed in a way where it's very hard

01:01:16.640 --> 01:01:17.520
to shoot yourself in the foot.

01:01:17.520 --> 01:01:19.040
As you know, I'm a big believer in this.

01:01:19.040 --> 01:01:25.000
It comes with these amazing, fully featured primitives for, oh, here is a way to do symmetrical

01:01:25.000 --> 01:01:25.900
mesh encryption.

01:01:25.900 --> 01:01:28.620
Here is a way to do asymmetrical public private key encryption.

01:01:28.620 --> 01:01:30.840
And it's just like, there's safe defaults.

01:01:30.840 --> 01:01:31.820
It's easy to use.

01:01:31.820 --> 01:01:37.020
And as long as you follow the docs, you end up with a really nice solution that is compatible

01:01:37.020 --> 01:01:37.420
properly.

01:01:37.420 --> 01:01:38.520
And like, it's pretty quick.

01:01:38.600 --> 01:01:42.260
And like, that's what we use inside ASCII reddit if you want at rest encryption.

01:01:42.260 --> 01:01:45.620
So like cryptography is my current favorite PyPI package.

01:01:45.620 --> 01:01:46.780
Oh, that's really cool.

01:01:46.780 --> 01:01:52.480
I definitely think cryptography and hashing and password management, that stuff is better

01:01:52.480 --> 01:01:57.480
put into a library or package and just really baked in with the best practices and you just

01:01:57.480 --> 01:01:58.220
follow the steps.

01:01:58.220 --> 01:01:58.480
Yeah.

01:01:58.480 --> 01:01:59.900
I do not want to have to think about it.

01:01:59.900 --> 01:02:03.800
Like I want somebody else who's more intelligent than me to solve the problem so I can use their

01:02:03.800 --> 01:02:04.140
code.

01:02:04.140 --> 01:02:05.140
It does that really well.

01:02:05.260 --> 01:02:05.840
Yeah, that's great.

01:02:05.840 --> 01:02:06.940
I'm going to have to check that out.

01:02:06.940 --> 01:02:07.780
All right.

01:02:07.780 --> 01:02:11.860
So before we get out of here, final call to action, how do people get started with channels?

01:02:11.860 --> 01:02:15.740
Like what kind of support or help are you looking for?

01:02:15.740 --> 01:02:19.720
So yeah, so like I'd encourage anyone who's interested to go over to channels.readthedocs.io.

01:02:19.720 --> 01:02:21.040
It's sort of the main channels documentation.

01:02:21.040 --> 01:02:25.280
You can see installation instructions, a short tutorial stuff there.

01:02:25.280 --> 01:02:27.320
And there's also a big list of stuff we want to work on.

01:02:27.320 --> 01:02:31.180
So our GitHub repository, which is github.com/Django slash channels.

01:02:31.180 --> 01:02:34.300
There's a whole list of issues there filtered by experience level.

01:02:34.300 --> 01:02:35.220
You want to have that kind of stuff.

01:02:35.920 --> 01:02:39.060
You can email Django developers or Django users with questions about channels.

01:02:39.060 --> 01:02:40.260
It's all part of the Django project.

01:02:40.260 --> 01:02:44.680
And then if you want to do work on a big project, we even have some funding available for bigger

01:02:44.680 --> 01:02:45.100
projects.

01:02:45.100 --> 01:02:49.520
We can dish out for sort of things that are, you know, at least a couple of weeks, sort

01:02:49.520 --> 01:02:52.240
of bigger tasks that wouldn't be tackled otherwise in spare time.

01:02:52.240 --> 01:02:57.200
So if you're interested in any of those things, like get in touch, mainly this or get in touch

01:02:57.200 --> 01:02:57.760
with me directly.

01:02:57.760 --> 01:02:59.500
I'm Andrew Goldbin on Twitter.

01:02:59.500 --> 01:03:00.900
Just all that stuff.

01:03:00.900 --> 01:03:01.980
I'm happy to talk about channels.

01:03:01.980 --> 01:03:03.340
Oh, that's really great.

01:03:03.340 --> 01:03:05.200
So lots of ways people can get involved.

01:03:05.200 --> 01:03:05.840
So many.

01:03:05.840 --> 01:03:06.440
Yeah.

01:03:06.440 --> 01:03:06.900
Cool.

01:03:07.480 --> 01:03:10.860
Andrew, thanks so much for taking the time to talk with me and sharing your project.

01:03:10.860 --> 01:03:11.900
Thank you so much for having me on.

01:03:11.900 --> 01:03:12.360
It's been a pleasure.

01:03:12.360 --> 01:03:12.800
Yep.

01:03:12.800 --> 01:03:13.060
Bye.

01:03:14.320 --> 01:03:17.340
This has been another episode of Talk Python to Me.

01:03:17.340 --> 01:03:22.320
Today's guest has been Andrew Godin, and this episode has been sponsored by Metis and Hired.

01:03:22.320 --> 01:03:24.280
Thank them both for supporting the show.

01:03:24.280 --> 01:03:26.760
Want to learn data science?

01:03:26.760 --> 01:03:32.800
Well, don't forget to visit thisismetis.com slash talkpython to learn more about their upcoming

01:03:32.800 --> 01:03:33.300
courses.

01:03:33.300 --> 01:03:37.880
Get the skills that you need to succeed in the fast-paced world of data science.

01:03:37.880 --> 01:03:40.580
Hired wants to help you find your next big thing.

01:03:40.580 --> 01:03:45.320
Visit Hired.com slash Talk Python To Me to get five or more offers with salary and equity

01:03:45.320 --> 01:03:49.080
presented right up front and a special listener signing bonus of $2,000.

01:03:49.080 --> 01:03:51.760
Are you or a colleague trying to learn Python?

01:03:51.760 --> 01:03:56.420
Have you tried books and videos that just left you bored by covering topics point by point?

01:03:56.420 --> 01:04:02.080
Well, check out my online course, Python Jumpstart by building 10 apps at talkpython.fm slash

01:04:02.080 --> 01:04:05.040
course to experience a more engaging way to learn Python.

01:04:05.040 --> 01:04:09.820
And if you're looking for something a little more advanced, try my Write Pythonic Code course

01:04:09.820 --> 01:04:12.380
at talkpython.fm/pythonic.

01:04:12.380 --> 01:04:14.860
Be sure to subscribe to the show.

01:04:14.860 --> 01:04:17.060
Open your favorite podcatcher and search for Python.

01:04:17.060 --> 01:04:18.300
We should be right at the top.

01:04:18.300 --> 01:04:24.080
You can also find the iTunes feed at /itunes, Google Play feed at /play, and

01:04:24.080 --> 01:04:27.600
direct RSS feed at /rss on talkpython.fm.

01:04:27.600 --> 01:04:32.700
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

01:04:32.700 --> 01:04:37.400
Corey just recently started selling his tracks on iTunes, so I recommend you check it out at

01:04:37.400 --> 01:04:39.380
 talkpython.fm/music.

01:04:39.380 --> 01:04:43.820
You can browse his tracks he has for sale on iTunes and listen to the full-length version

01:04:43.820 --> 01:04:44.740
of the theme song.

01:04:44.740 --> 01:04:46.820
This is your host, Michael Kennedy.

01:04:46.820 --> 01:04:48.100
Thanks so much for listening.

01:04:48.100 --> 01:04:49.280
I really appreciate it.

01:04:49.280 --> 01:04:51.440
Smix, let's get out of here.

01:04:52.740 --> 01:04:53.900
Staying with my voice.

01:04:53.900 --> 01:04:55.700
There's no norm that I can fill within.

01:04:55.700 --> 01:04:56.920
Haven't been sleeping.

01:04:56.920 --> 01:04:58.540
I've been using lots of rest.

01:04:58.540 --> 01:05:01.420
I'll pass the mic back to who rocked it best.

01:05:01.420 --> 01:05:12.800
I'll pass the mic.

01:05:12.800 --> 01:05:13.360
Bye.

01:05:13.360 --> 01:05:13.620
.

01:05:13.620 --> 01:05:14.120
you

