WEBVTT

00:00:00.001 --> 00:00:02.740
Does it seem like your Python projects are getting bigger and bigger?

00:00:02.740 --> 00:00:07.780
Are you feeling the pain as your code base expands and gets tougher to debug and maintain?

00:00:07.780 --> 00:00:12.880
Patrick Viafor is here to help us write more maintainable, longer-lived, and more enjoyable

00:00:12.880 --> 00:00:13.820
Python code.

00:00:13.820 --> 00:00:19.560
This is Talk Python to Me, episode 332, recorded August 30th, 2021.

00:00:19.560 --> 00:00:35.580
Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:35.580 --> 00:00:37.300
This is your host, Michael Kennedy.

00:00:37.300 --> 00:00:41.500
Follow me on Twitter, where I'm @mkennedy, and keep up with the show and listen to past

00:00:41.500 --> 00:00:43.480
episodes at talkpython.fm.

00:00:43.480 --> 00:00:46.540
And follow the show on Twitter via at Talk Python.

00:00:46.740 --> 00:00:50.200
We've started streaming most of our episodes live on YouTube.

00:00:50.200 --> 00:00:55.900
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming

00:00:55.900 --> 00:00:57.720
shows and be part of that episode.

00:00:57.720 --> 00:01:03.840
This episode is brought to you by Clubhouse, soon to be known as Shortcut, by masterworks.io,

00:01:03.840 --> 00:01:07.240
and the transcripts are brought to you by assembly.ai.

00:01:07.240 --> 00:01:09.640
Please check out what they're offering during their segments.

00:01:09.640 --> 00:01:10.960
It really helps support the show.

00:01:10.960 --> 00:01:13.400
Pat, welcome to Talk Python to Me.

00:01:13.400 --> 00:01:14.080
Thank you.

00:01:14.080 --> 00:01:15.180
I'm so honored to be here.

00:01:15.180 --> 00:01:15.980
Long-time listener.

00:01:16.580 --> 00:01:17.360
Oh, that's fantastic.

00:01:17.360 --> 00:01:18.960
I really, really appreciate that.

00:01:18.960 --> 00:01:20.860
It's an honor to have you here.

00:01:20.860 --> 00:01:24.860
We're talking about one of these subjects that I really enjoy.

00:01:24.860 --> 00:01:28.120
I feel like it's one of these more evergreen type of topics.

00:01:28.120 --> 00:01:34.180
You know, it's super fun to talk about the new features in Flask 2.0, but that's only relevant

00:01:34.180 --> 00:01:35.900
for so long and for so many people.

00:01:35.900 --> 00:01:41.080
But writing software that's reliable, that can be changed over time, doing so in a Pythonic

00:01:41.080 --> 00:01:45.220
way, that's good stuff to learn no matter where you are in your career.

00:01:45.260 --> 00:01:46.580
Oh, I absolutely agree.

00:01:47.040 --> 00:01:51.500
You've written a book called Robust Python, which caught my interest.

00:01:51.500 --> 00:01:57.760
I, as you can imagine, get a couple of books and ideas said to me periodically per day.

00:01:57.760 --> 00:02:00.700
And so they don't usually appeal to me.

00:02:00.700 --> 00:02:04.820
But this one really does for the reasons that I exactly stated in the opening.

00:02:04.820 --> 00:02:09.780
And we're just going to sort of riff on this more broad idea of what is robust Python?

00:02:09.780 --> 00:02:11.200
What is clean code?

00:02:11.320 --> 00:02:15.300
Like, how do you do this in Python and make it maintainable for both you in the future

00:02:15.300 --> 00:02:16.960
and other people and so on?

00:02:16.960 --> 00:02:17.900
Yeah, sounds good.

00:02:17.900 --> 00:02:20.140
Before we get to that, though, let's start with you.

00:02:20.140 --> 00:02:21.020
What's your story?

00:02:21.020 --> 00:02:25.140
So I got into programming like many males my age.

00:02:25.240 --> 00:02:26.960
I loved video games as a kid.

00:02:26.960 --> 00:02:29.320
And I was 12 or 13.

00:02:29.320 --> 00:02:34.620
And some ad in one of my video game magazines caught my eye for video game creator studio.

00:02:34.620 --> 00:02:35.180
Oh, nice.

00:02:35.180 --> 00:02:42.640
And it was this C++, just C++ engine, but it provided easy ways to do sprites and animations

00:02:42.640 --> 00:02:43.800
and particle effects.

00:02:43.800 --> 00:02:46.560
And they gave you step-by-step instructions.

00:02:46.560 --> 00:02:47.900
Here's how you build Pong.

00:02:47.900 --> 00:02:49.240
Here's how you build Frogger.

00:02:49.240 --> 00:02:50.080
And here are the assets.

00:02:50.080 --> 00:02:51.520
I started riffing on it.

00:02:51.520 --> 00:02:52.680
I really came to love it.

00:02:52.680 --> 00:02:59.300
I then took a programming class in high school, True Basic, which I don't remember much of other

00:02:59.300 --> 00:03:01.720
than I don't think I'd ever go back to it now.

00:03:01.720 --> 00:03:06.680
But it interested me enough that I decided to go to computer science college.

00:03:06.680 --> 00:03:10.640
I learned more about the video game industry, especially some of the hours they work and said,

00:03:10.740 --> 00:03:15.180
you know what, maybe the video game industry is not for me, but I still loved programming

00:03:15.180 --> 00:03:15.760
at its heart.

00:03:15.760 --> 00:03:20.680
So I continued on and just found a few jobs after college and just went from there.

00:03:20.680 --> 00:03:24.340
As far as Python went, I worked in telecom for a little bit.

00:03:24.340 --> 00:03:27.560
And early 2010s, we had some test software.

00:03:27.560 --> 00:03:30.060
It was all written in the Tickle programming language.

00:03:30.060 --> 00:03:33.340
And that is an interesting programming language.

00:03:33.340 --> 00:03:36.560
As far as types go, everything's treated as a string.

00:03:36.560 --> 00:03:38.940
And it led to some very unmaintainable code.

00:03:39.140 --> 00:03:43.320
So a few sharp engineers and myself, we decided, you know, what would it look like if we wrote

00:03:43.320 --> 00:03:43.980
this in Python?

00:03:43.980 --> 00:03:46.960
And a whole test of the automation was born from there.

00:03:46.960 --> 00:03:50.220
And we just went, wow, Python makes everything nicer.

00:03:50.220 --> 00:03:52.840
Like, this is so much pleasurable to work with.

00:03:52.840 --> 00:03:55.580
And I've done like C++ and Java before then.

00:03:55.580 --> 00:03:57.860
So Python was this breath of fresh air.

00:03:57.920 --> 00:03:59.280
And I just fell in love with the language.

00:03:59.280 --> 00:03:59.880
Yeah.

00:03:59.880 --> 00:04:03.100
Those are both very syntax symbol heavy languages.

00:04:03.100 --> 00:04:05.080
I've done a ton of C++.

00:04:05.080 --> 00:04:07.720
I did professional C++ development for a while.

00:04:07.720 --> 00:04:09.540
I have never done much Java.

00:04:09.540 --> 00:04:12.020
But yeah, they're really interesting.

00:04:12.020 --> 00:04:16.720
I remember when I came to Python, I came from C#, but also from C++.

00:04:16.980 --> 00:04:23.540
And just in my mind, those symbols, all the parentheses on the if statements and the semicolons

00:04:23.540 --> 00:04:26.900
at the end of the line and all that business, it was just required.

00:04:26.900 --> 00:04:28.820
That's just what language is needed to be.

00:04:28.820 --> 00:04:30.360
And then they weren't there.

00:04:30.360 --> 00:04:32.720
And I'm like, I just, I'm having a hard time with this.

00:04:32.720 --> 00:04:32.960
Right.

00:04:33.020 --> 00:04:34.440
And I felt it was weird.

00:04:34.440 --> 00:04:39.320
But then when I went back just to work on like a project that was still ongoing, it seemed

00:04:39.320 --> 00:04:39.800
more weird.

00:04:39.800 --> 00:04:40.640
I'm like, wait a minute.

00:04:40.640 --> 00:04:43.720
My eye, you know, like the wool has been taken off my eyes.

00:04:43.720 --> 00:04:48.400
I know now these are not required and still here I am continuing to write them.

00:04:48.400 --> 00:04:52.240
And it just drove me crazy once I realized I don't have to put these things here.

00:04:52.240 --> 00:04:53.700
It's just this language that makes me.

00:04:53.700 --> 00:04:55.360
And so, yeah, it was really nice.

00:04:55.360 --> 00:04:55.960
Yeah.

00:04:55.960 --> 00:04:56.420
Yeah.

00:04:56.420 --> 00:04:58.540
Python kind of captured that magic for me.

00:04:58.540 --> 00:05:04.060
And it's funny because going back to C++ every once in a while, my C++ got a lot better

00:05:04.060 --> 00:05:04.920
because of Python.

00:05:04.920 --> 00:05:06.380
You start focusing on the simple.

00:05:06.380 --> 00:05:07.280
That's nice.

00:05:07.280 --> 00:05:07.520
Yeah.

00:05:07.520 --> 00:05:08.560
Yeah, exactly.

00:05:08.560 --> 00:05:11.820
You're not trying to flex with your double pointers and all that kind of stuff.

00:05:11.820 --> 00:05:13.500
It's like, we don't need this.

00:05:13.500 --> 00:05:14.160
Let's not do this.

00:05:14.160 --> 00:05:14.500
Come on.

00:05:14.500 --> 00:05:15.080
Very cool.

00:05:15.080 --> 00:05:15.780
So how about now?

00:05:15.780 --> 00:05:16.240
What are you doing?

00:05:16.240 --> 00:05:18.940
So right now I am a software engineer at Canonical.

00:05:18.940 --> 00:05:20.960
I'm on their public cloud team.

00:05:20.960 --> 00:05:27.120
So we're building the Ubuntu operating system for public clouds, AWS, Azure, GCE, a couple others.

00:05:27.720 --> 00:05:36.180
And so we customize the images for clouds, work with a lot of other canonical teams to make sure that their changes are reflected in our software.

00:05:36.180 --> 00:05:41.080
We maintain the CICD pipelines to deliver those as often as we can.

00:05:41.080 --> 00:05:45.700
Most of the toolings are in Python, so I get to use Python day to day, which makes me happy.

00:05:45.700 --> 00:05:46.920
Oh, that's really cool.

00:05:46.920 --> 00:05:49.080
What kind of features are we talking about here?

00:05:49.080 --> 00:05:50.560
Or aspects?

00:05:50.560 --> 00:05:52.660
Yeah, general hardware enablement.

00:05:52.920 --> 00:05:56.240
Clouds may have new instances, new processor types.

00:05:56.240 --> 00:05:58.920
Working to make sure that that's enabled.

00:05:58.920 --> 00:06:01.260
Do a lot of close work with our kernel team.

00:06:02.040 --> 00:06:05.220
Features that the cloud themselves might request.

00:06:05.220 --> 00:06:06.520
Maybe, you know.

00:06:06.520 --> 00:06:10.980
Like something the cloud needs to set up and maintain the VM aspect.

00:06:10.980 --> 00:06:11.500
Yeah.

00:06:11.500 --> 00:06:11.800
Okay.

00:06:11.800 --> 00:06:13.640
More on the infrastructure side.

00:06:13.640 --> 00:06:16.140
Maybe how do they hibernate their VMs?

00:06:16.140 --> 00:06:16.780
Okay.

00:06:16.780 --> 00:06:18.180
How do they improve boot speed?

00:06:18.180 --> 00:06:19.080
Those sort of changes.

00:06:19.080 --> 00:06:19.720
Yeah.

00:06:19.820 --> 00:06:21.500
Or how do they improve the security profile?

00:06:21.500 --> 00:06:23.660
That's something I'm working on right now with some of our clouds.

00:06:23.660 --> 00:06:24.280
Yeah.

00:06:24.280 --> 00:06:25.580
Super, super important.

00:06:25.580 --> 00:06:26.000
Yeah.

00:06:26.000 --> 00:06:31.220
That's part of the promise to go into the cloud is often there's better security and better durability.

00:06:31.220 --> 00:06:36.540
But if it fails, it fails for potentially all of some big chunk of the internet, right?

00:06:36.540 --> 00:06:39.100
Like that's the consequence of failure is also higher.

00:06:39.100 --> 00:06:39.460
So.

00:06:39.460 --> 00:06:39.780
Yeah.

00:06:39.780 --> 00:06:39.980
Yeah.

00:06:39.980 --> 00:06:44.700
You have to be very aware of how many people are using your software when you deploy to the cloud.

00:06:44.700 --> 00:06:46.820
Does it make you nervous to work on that kind of stuff?

00:06:46.820 --> 00:06:47.640
Oh, absolutely.

00:06:48.300 --> 00:06:48.460
Yeah.

00:06:48.460 --> 00:06:52.320
I wouldn't, I'd be lying if I said it didn't, but you, you learn to be careful.

00:06:52.320 --> 00:07:01.520
You learn to really focus on making everyone, you know, having good communication between your teams, making sure there's no surprises for anyone, that sort of thing.

00:07:01.520 --> 00:07:04.460
I remember that as well, just working on certain things.

00:07:04.460 --> 00:07:09.760
Like the first e-commerce system I wrote, I'm like, this thing's going to be charging thousands of dollars per transaction.

00:07:09.760 --> 00:07:11.420
And I might screw this up.

00:07:11.420 --> 00:07:14.360
And I'm really worried for deploying it for the whole company.

00:07:14.360 --> 00:07:16.220
There's like big purchases people were doing.

00:07:16.680 --> 00:07:18.180
And it made me really nervous.

00:07:18.180 --> 00:07:30.720
But at the same time, one of the things I've come to learn over my career programming is it's one of the things that will really put a sad, sad look on your face is if you spend a lot of time and create beautiful software and no one uses it.

00:07:30.720 --> 00:07:31.440
That's right.

00:07:31.440 --> 00:07:32.040
Yeah.

00:07:32.040 --> 00:07:37.100
So the, even though it may be stressful that it's getting used a lot and it's really central, that's also amazing, right?

00:07:37.100 --> 00:07:37.540
Yeah.

00:07:37.540 --> 00:07:42.620
But it's also made me a better programmer because you just start thinking about explicit error cases more.

00:07:42.620 --> 00:07:47.560
And my last job, I mentioned I did telecom and 911 calls get routed through your equipment.

00:07:47.560 --> 00:07:49.020
You don't want to fail that.

00:07:49.020 --> 00:07:50.140
And yeah.

00:07:50.140 --> 00:07:50.660
Wow.

00:07:51.100 --> 00:07:57.760
It is scary at first, but you learn to develop disciplines over time of, okay, how do we make sure we're not making mistakes?

00:07:57.760 --> 00:08:04.420
You know, speaking of that, I think that's maybe a good segue in to talk about this idea of robust Python.

00:08:04.420 --> 00:08:08.640
First of all, like, let's just talk about your book for just a minute and then we'll just get into the general idea of it.

00:08:08.640 --> 00:08:10.580
Like what motivated you to write this book?

00:08:11.020 --> 00:08:13.640
So I mentioned I've done C++ development in the past.

00:08:13.640 --> 00:08:23.040
I started diving heavy into modern C++ and how it uses a lot more type safety features and some earlier versions of C++.

00:08:23.040 --> 00:08:29.120
Did a quick dabble into Haskell just from a learning perspective and really started to love static types.

00:08:29.120 --> 00:08:31.680
But my day-to-day language was Python.

00:08:31.680 --> 00:08:36.160
So I really, really dove deep on, you know, how do I make my Python safer moving forward?

00:08:36.160 --> 00:08:38.100
So I pitched to a few publishers.

00:08:38.100 --> 00:08:42.480
I want to write a book about, you know, type system best practices in Python.

00:08:42.480 --> 00:08:43.740
Let's talk type checkers.

00:08:43.740 --> 00:08:46.680
Let's talk about design types and so on and so forth.

00:08:46.680 --> 00:08:51.400
O'Reilly, who published my book, they bit and they said, oh, that sounds interesting.

00:08:51.400 --> 00:08:53.160
Can we expand the scope a little bit more?

00:08:53.160 --> 00:08:56.800
And I thought, okay, well, why do I write types in Python?

00:08:56.800 --> 00:08:59.280
Why do I, you know, advocate type systems?

00:08:59.280 --> 00:09:04.040
It's to make things more maintainable, make things live longer, to make things clearer.

00:09:04.040 --> 00:09:06.540
And the idea of robust Python came out of that.

00:09:06.540 --> 00:09:09.860
Well, I think it's really a pretty interesting idea.

00:09:09.860 --> 00:09:21.100
I do think when you come from these languages like C++ or Java or something, there is something to be said for it literally is verified to be clicked together.

00:09:21.280 --> 00:09:23.120
Just like a perfect jigsaw puzzle.

00:09:23.120 --> 00:09:23.700
Yeah.

00:09:23.700 --> 00:09:23.980
Right.

00:09:23.980 --> 00:09:27.160
It won't catch every error, but it can catch more errors.

00:09:27.160 --> 00:09:28.260
And that's a good thing.

00:09:28.260 --> 00:09:28.800
Yeah.

00:09:28.800 --> 00:09:33.760
Well, I remember how excited I was when I got my first non-trivial C++ thing to compile.

00:09:33.760 --> 00:09:35.260
And I'm like, yes, I've done it.

00:09:35.260 --> 00:09:37.660
Little did I know, like I was in for it.

00:09:37.660 --> 00:09:41.140
I mean, it was out of compiler errors and into like real errors.

00:09:41.140 --> 00:09:41.680
Yeah.

00:09:41.680 --> 00:09:42.620
At that point.

00:09:42.620 --> 00:09:42.900
Right.

00:09:42.900 --> 00:09:43.380
Yeah.

00:09:43.380 --> 00:09:44.400
The fun errors.

00:09:44.400 --> 00:09:44.760
Right.

00:09:45.220 --> 00:09:45.540
Yeah.

00:09:45.540 --> 00:09:46.660
Exactly.

00:09:46.660 --> 00:09:47.680
The why, what is it?

00:09:47.680 --> 00:09:48.400
What is it?

00:09:48.400 --> 00:09:49.260
Seg fault?

00:09:49.260 --> 00:09:49.600
Whatever.

00:09:49.600 --> 00:09:51.120
I don't know.

00:09:51.120 --> 00:09:52.120
We're going to work on that.

00:09:52.120 --> 00:09:55.160
So anyway, that was, that was really interesting.

00:09:55.580 --> 00:09:59.160
I, I do think that it's not required, right?

00:09:59.160 --> 00:10:02.760
I do think that there is really interesting code being written in Python.

00:10:02.760 --> 00:10:06.020
And you can see that how it's, it's being adopted in all these ways.

00:10:06.020 --> 00:10:11.580
The biggest, maybe example I have in mind of these two things side by side is, you know,

00:10:11.580 --> 00:10:16.620
YouTube versus Google video and how Google video was in Python with 20 engineers.

00:10:16.620 --> 00:10:19.240
Google video was a hundred C++ engineers.

00:10:19.240 --> 00:10:22.580
And eventually Google just said, all right, we're going to put that project aside and buy

00:10:22.580 --> 00:10:25.080
YouTube because they just keep out running us in features.

00:10:25.500 --> 00:10:25.700
Yeah.

00:10:25.700 --> 00:10:29.380
I think that's the beauty of Python is that you can build things fast.

00:10:29.380 --> 00:10:31.140
You can see them working faster.

00:10:31.140 --> 00:10:34.200
And you don't have to fight the compiler as much of the way.

00:10:34.200 --> 00:10:36.160
So it's almost like these two things are at odds.

00:10:36.160 --> 00:10:38.500
And the answer is just Python's gradual typing.

00:10:38.500 --> 00:10:40.700
You just type as you need to.

00:10:40.700 --> 00:10:42.720
You add typing where it makes sense.

00:10:42.720 --> 00:10:47.120
And I won't be prescriptive and say you need types everywhere, but there are certain places

00:10:47.120 --> 00:10:49.920
where it makes a lot of sense and save you money and time.

00:10:49.920 --> 00:10:53.800
I do find it pretty interesting how they've implemented types in Python.

00:10:53.800 --> 00:10:58.520
And to be clear, this idea of robust Python that you're focused on, types is just one part

00:10:58.520 --> 00:11:00.980
of it, but it sounds like it was the genesis of it.

00:11:00.980 --> 00:11:02.300
It was absolutely the genesis.

00:11:02.300 --> 00:11:02.740
Yeah.

00:11:02.740 --> 00:11:02.960
Yeah.

00:11:03.600 --> 00:11:08.340
So we have sort of two other realities that we might look at.

00:11:08.340 --> 00:11:10.640
We could look at C++ or C# or Java.

00:11:10.640 --> 00:11:12.020
They're all the same in that regard.

00:11:12.020 --> 00:11:14.600
They're like static compiled languages.

00:11:14.600 --> 00:11:19.380
And then we've got something that's much closer to Python with TypeScript, where they said,

00:11:19.380 --> 00:11:20.300
we have the same problem.

00:11:20.300 --> 00:11:26.080
We have JavaScript, which is even less typed because the runtime types are all just weird

00:11:26.080 --> 00:11:28.060
dictionary prototype things anyway.

00:11:28.480 --> 00:11:33.520
And we want to make that reliable for larger scale software and integrations and stuff.

00:11:33.520 --> 00:11:34.840
So we create TypeScript.

00:11:34.840 --> 00:11:39.700
But the real fork in the road, I think that was interesting is the TypeScript people said,

00:11:39.700 --> 00:11:43.260
we're going to apply the ideas of absolute strict typing.

00:11:43.260 --> 00:11:45.920
Once you start down that path, it's all down that path.

00:11:46.040 --> 00:11:47.600
And they have to match up.

00:11:47.600 --> 00:11:54.400
Whereas in Python, it's like, let's help you down this path, but not give up the zen of Python,

00:11:54.400 --> 00:11:59.180
where you can easily put things together and you're not restricted by this type system.

00:11:59.180 --> 00:12:05.160
But if you run the right tools, be that PyCharm, VS Code, or mypy or something like that,

00:12:05.160 --> 00:12:08.300
it'll be there to help you make it better in lots of ways.

00:12:08.300 --> 00:12:09.020
Oh, absolutely.

00:12:09.020 --> 00:12:12.100
I think that's a really creative and interesting aspect of it.

00:12:12.100 --> 00:12:12.620
Yeah.

00:12:12.620 --> 00:12:13.020
Yeah.

00:12:13.020 --> 00:12:14.360
I absolutely agree with that.

00:12:15.420 --> 00:12:22.160
A lot of things that I discuss throughout the book is the idea that these are tools in your toolbox.

00:12:22.160 --> 00:12:24.000
And so I talk about types.

00:12:24.000 --> 00:12:25.900
I talk about API design.

00:12:25.900 --> 00:12:26.980
I talk about sensibility.

00:12:26.980 --> 00:12:30.200
They're all tools and they shouldn't be applied everywhere.

00:12:30.200 --> 00:12:33.680
I really want to start focusing on first principles.

00:12:33.680 --> 00:12:35.940
Why do we do the things we do in software engineering?

00:12:35.940 --> 00:12:38.360
And what are the most appropriate for them?

00:12:38.360 --> 00:12:42.400
You had a really interesting quote in your book about software engineering.

00:12:42.400 --> 00:12:48.260
And I've always sort of struggled to have this conversation with people like, oh, are you a programmer?

00:12:48.260 --> 00:12:49.280
Are you a coder?

00:12:49.280 --> 00:12:50.720
Are you an engineer?

00:12:50.720 --> 00:12:52.480
Like, where are you on that?

00:12:52.480 --> 00:12:54.620
Like, is that even a meaningful distinction?

00:12:54.620 --> 00:12:59.620
And to a large degree, I've always felt like it was just sort of whatever sort of culture you're in.

00:12:59.860 --> 00:13:01.920
You know, if you're in a startup, it's one thing.

00:13:01.920 --> 00:13:05.500
If you're in like a giant enterprise, they may value a different title in a different way.

00:13:05.500 --> 00:13:06.600
It's all kind of the same.

00:13:06.600 --> 00:13:11.840
But you had this cool quote that said something like software engineering is programming integrated over time.

00:13:11.840 --> 00:13:12.380
Yes.

00:13:12.380 --> 00:13:19.860
And I wish I could claim credit for that, but that actually came from Titus Winters of Google and C++ Con or CPP Con Talk.

00:13:19.860 --> 00:13:22.240
And it's just really resonated with me.

00:13:22.240 --> 00:13:29.220
We program, but software engineering is the efforts of that programming over years or decades.

00:13:29.220 --> 00:13:31.580
Your code will live decades.

00:13:31.580 --> 00:13:34.740
The more valuable it is, the longer live it probably will be.

00:13:34.900 --> 00:13:38.620
I've worked on code that's been 15 years old when I started on it.

00:13:38.620 --> 00:13:42.480
And there's code that I wrote 12 years ago that's still running operationally.

00:13:42.480 --> 00:13:44.820
And that scares me to some degree.

00:13:44.820 --> 00:13:48.160
Because like, oh, did I know what I was doing back then?

00:13:48.160 --> 00:13:55.580
But it just reemphasized like why it's so important to think towards the future of what your audience.

00:13:55.580 --> 00:13:57.920
You're going to have maintainers that come after you.

00:13:57.920 --> 00:14:00.180
And do you want them to curse your name?

00:14:00.180 --> 00:14:03.440
Or do you want them to be like, oh, thank goodness, this person wrote something that I can use.

00:14:03.440 --> 00:14:04.300
It's really easy.

00:14:04.840 --> 00:14:06.840
And I always prefer the latter on that.

00:14:06.840 --> 00:14:08.240
I also like to say.

00:14:08.240 --> 00:14:13.640
And the nicer code that you write and the more durable and long live code that you write,

00:14:13.640 --> 00:14:19.880
the more it can continue to have a life even after you've stepped away from the project, right?

00:14:19.880 --> 00:14:22.020
It's like, this thing is still working well.

00:14:22.020 --> 00:14:26.140
We can keep growing it rather than it's turned into a complete pile of junk that we've got to

00:14:26.140 --> 00:14:27.820
throw away and start over, right?

00:14:27.820 --> 00:14:29.960
So that's a goal that you might want.

00:14:29.960 --> 00:14:32.200
And then also that long-term maintainer might be you.

00:14:32.200 --> 00:14:32.700
Yep.

00:14:32.700 --> 00:14:33.480
Yep.

00:14:33.560 --> 00:14:37.960
You might be working out five years from now and you go, why did I make the decisions that I did?

00:14:37.960 --> 00:14:38.780
I don't remember this.

00:14:38.780 --> 00:14:41.180
Maybe you've jumped to a different project and came back.

00:14:41.180 --> 00:14:42.580
It absolutely can be you.

00:14:44.460 --> 00:14:48.180
This portion of Talk Python To Me is brought to you by Clubhouse.io.

00:14:48.180 --> 00:14:50.180
Happy with your project management tool?

00:14:50.180 --> 00:14:55.420
Most tools are either too simple for a growing engineering team to manage everything or way

00:14:55.420 --> 00:14:58.560
too complex for anyone to want to use them without constant prodding.

00:14:58.560 --> 00:15:03.280
Clubhouse.io, which soon will be changing their name to Shortcut, is different though, because

00:15:03.280 --> 00:15:03.720
it's worse.

00:15:03.720 --> 00:15:04.380
No, wait.

00:15:04.380 --> 00:15:05.180
No, I mean, it's better.

00:15:05.180 --> 00:15:09.040
Clubhouse is project management built specifically for software teams.

00:15:09.160 --> 00:15:13.820
It's fast, intuitive, flexible, powerful, and many other nice positive adjectives.

00:15:13.820 --> 00:15:16.420
Key features include team-based workflows.

00:15:16.420 --> 00:15:21.720
Individual teams can use Clubhouse's default workflows or customize them to match the way

00:15:21.720 --> 00:15:22.180
they work.

00:15:22.180 --> 00:15:24.200
Org-wide goals and roadmaps.

00:15:24.200 --> 00:15:28.320
The work in these workflows is automatically tied into larger company goals.

00:15:28.560 --> 00:15:33.900
It takes one click to move from a roadmap to a team's work to individual updates and back.

00:15:33.900 --> 00:15:35.780
Type version control integration.

00:15:35.780 --> 00:15:40.760
Whether you use GitHub, GitLab, or Bitbucket, Clubhouse ties directly into them so you can

00:15:40.760 --> 00:15:42.640
update progress from the command line.

00:15:42.640 --> 00:15:44.420
Keyboard-friendly interface.

00:15:44.420 --> 00:15:49.580
The rest of Clubhouse is just as friendly as their power bar, allowing you to do virtually

00:15:49.580 --> 00:15:51.500
anything without touching your mouse.

00:15:51.500 --> 00:15:52.760
Throw that thing in the trash.

00:15:52.760 --> 00:15:54.340
Iteration planning.

00:15:54.800 --> 00:15:59.380
Set weekly priorities and then let Clubhouse run the schedule for you with accompanying burndown

00:15:59.380 --> 00:16:00.520
charts and other reporting.

00:16:00.520 --> 00:16:05.160
So give it a try over at talkpython.fm/clubhouse.

00:16:05.160 --> 00:16:08.380
Again, that's talkpython.fm/clubhouse.

00:16:08.380 --> 00:16:09.880
Choose Clubhouse.

00:16:09.880 --> 00:16:14.940
Again, soon to be known as Shortcut, because you shouldn't have to project manage your project

00:16:14.940 --> 00:16:15.340
management.

00:16:17.620 --> 00:16:23.660
Let's talk about some of the core ideas that you have about making software maintainable,

00:16:23.660 --> 00:16:24.480
reliable.

00:16:24.480 --> 00:16:30.960
One of the things you talk about is the separation of time and how code has to communicate or the

00:16:30.960 --> 00:16:37.040
artifacts that we all produce around code has to communicate with people both maybe almost

00:16:37.040 --> 00:16:37.560
immediately.

00:16:37.560 --> 00:16:38.320
Right?

00:16:38.400 --> 00:16:42.500
Like, I'm working on this project with a couple of other developers and we need to,

00:16:42.500 --> 00:16:43.620
like, keep it going forward.

00:16:43.620 --> 00:16:47.800
The other one is, like, way down in the future, someone comes back and they're like, oh, I'm

00:16:47.800 --> 00:16:48.620
new here.

00:16:48.620 --> 00:16:49.800
The person who created it left.

00:16:49.800 --> 00:16:52.960
Maybe talk about some of those ideas that you've covered.

00:16:52.960 --> 00:16:53.000
Yeah.

00:16:53.000 --> 00:16:57.240
And so it feels a little weird because what we're talking about is asynchronous communication.

00:16:57.240 --> 00:17:01.400
And it's weird to talk about that on a Python podcast and not talk about async away.

00:17:01.400 --> 00:17:02.400
Yeah, exactly.

00:17:02.400 --> 00:17:05.820
But it's asynchronous communication in real life, which I actually think is much harder.

00:17:06.320 --> 00:17:09.020
You have to think about your time traveling to some degree.

00:17:09.020 --> 00:17:12.140
You have to think about the future and you have to communicate to them.

00:17:12.140 --> 00:17:13.740
You probably will never meet them.

00:17:13.740 --> 00:17:15.100
You'll never talk to them.

00:17:15.100 --> 00:17:17.860
The only thing that lives on are the artifacts you create.

00:17:17.860 --> 00:17:23.400
So your code, your documentation, your commit messages, that's what people in the future are

00:17:23.400 --> 00:17:25.640
going to construct this mental model of your work from.

00:17:25.640 --> 00:17:27.860
They're going to be doing archaeology when things go wrong.

00:17:27.860 --> 00:17:29.620
Why is this code the way it is?

00:17:29.620 --> 00:17:31.120
Is it safe to change?

00:17:31.120 --> 00:17:32.720
What were the original intentions?

00:17:33.100 --> 00:17:37.720
And so the more you can embed that into code you write and the surrounding commit messages,

00:17:37.720 --> 00:17:43.300
documentation, the more robust your code base is going to be, the more you're communicating

00:17:43.300 --> 00:17:44.280
intent future.

00:17:44.280 --> 00:17:49.440
That's one of the things that was so important for 2020, 2021 for all of us, right?

00:17:49.440 --> 00:17:53.400
Like, yeah, we didn't know how much we were going to need it because there's always been

00:17:53.400 --> 00:17:54.020
this kind of tension.

00:17:54.020 --> 00:17:58.060
Well, there's the open source world and these other projects.

00:17:58.060 --> 00:18:02.560
And there's those weird remote teams, but we come to our cubicles and we all sit down

00:18:02.560 --> 00:18:05.480
and we have our stand up in the morning and we write our software together.

00:18:05.480 --> 00:18:11.580
And like that's, and we use, you know, Perforce or something internal where we lock the file.

00:18:11.580 --> 00:18:13.900
No one else can edit the file till I unlock the file, right?

00:18:13.900 --> 00:18:15.900
Like there's these, these different ways.

00:18:15.900 --> 00:18:19.020
And we've been moving more and more towards this sort of everything.

00:18:19.020 --> 00:18:23.380
Even if the person is right next to you, the way we work is as if they were across the

00:18:23.380 --> 00:18:23.720
world.

00:18:23.940 --> 00:18:24.340
Yeah.

00:18:24.340 --> 00:18:28.840
And, you know, it's, it's been really, I guess, lucky for us as an industry that that

00:18:28.840 --> 00:18:30.260
was mostly in place.

00:18:30.260 --> 00:18:31.300
Yes, absolutely.

00:18:31.300 --> 00:18:32.120
That actually became true.

00:18:32.120 --> 00:18:32.960
Yep.

00:18:32.960 --> 00:18:38.820
And so I think you touched on an interesting point of a lot of developers think, oh, if

00:18:38.820 --> 00:18:40.840
we're close in space, we can collaborate.

00:18:40.840 --> 00:18:44.800
You know, I don't have to worry about my remote teams and I don't have to worry about, you

00:18:44.800 --> 00:18:46.280
know, someone global.

00:18:46.780 --> 00:18:51.440
But by thinking of that, your collaboration in that terms, it sets you up to think about

00:18:51.440 --> 00:18:55.960
the future as well, because you could be asynchronous in space or asynchronous time.

00:18:55.960 --> 00:18:56.460
Right.

00:18:56.460 --> 00:19:00.000
And basically the same tools are there to, to address it.

00:19:00.000 --> 00:19:01.540
The same strategies help with both.

00:19:01.540 --> 00:19:02.160
Yeah.

00:19:02.160 --> 00:19:08.080
So one of the things that you talked about was this principle of least surprise.

00:19:08.080 --> 00:19:09.120
Yeah.

00:19:09.120 --> 00:19:10.820
Tell us about that principle.

00:19:10.820 --> 00:19:11.140
Yeah.

00:19:11.220 --> 00:19:13.960
The principle of least surprise also known as the principle of least astonishment.

00:19:13.960 --> 00:19:19.860
I feel like it's safe to say most developers have gone through a code base and been legitimately

00:19:19.860 --> 00:19:22.520
surprised and went, that function does that?

00:19:22.520 --> 00:19:23.480
Oh my goodness.

00:19:23.480 --> 00:19:24.840
I would never have thought that.

00:19:24.840 --> 00:19:30.460
Once worked on a nasty bug where the get event function was setting an event.

00:19:30.460 --> 00:19:33.140
And I kept overlooking it because I'm like, what's a get event?

00:19:33.140 --> 00:19:34.020
It's just a getter.

00:19:34.020 --> 00:19:35.000
I can ignore this.

00:19:35.000 --> 00:19:36.180
And like two days later.

00:19:36.180 --> 00:19:37.020
This will have no side effects.

00:19:37.020 --> 00:19:38.020
This will be fine.

00:19:38.020 --> 00:19:38.780
Two days later.

00:19:38.780 --> 00:19:40.400
I'm like, let me go step through this.

00:19:40.400 --> 00:19:41.840
And I was floored.

00:19:41.840 --> 00:19:43.580
I'm like, of course this explains my bug.

00:19:43.580 --> 00:19:48.240
So your goal when developing software is you don't want to surprise your future readers.

00:19:48.240 --> 00:19:53.900
I mean, I think this is why people say avoid clever code, favor clear code over clever code.

00:19:53.900 --> 00:19:56.260
You don't want to surprise readers.

00:19:56.260 --> 00:20:00.040
Many, many people may not be as well versed in the languages.

00:20:00.040 --> 00:20:03.340
Maybe they're coming from a different language, maybe from TypeScript to Python.

00:20:03.340 --> 00:20:11.180
The more you rely on clever tricks or poor naming or just the wrong patterns, you're throwing people off for a pee and they need.

00:20:11.180 --> 00:20:16.120
There's an added cognitive burden that they must then carry to understand what you've read.

00:20:16.120 --> 00:20:20.000
One of the beautiful things about different abstractions are here's a function.

00:20:20.000 --> 00:20:21.380
I read the function name.

00:20:21.380 --> 00:20:22.780
That's all I need to know.

00:20:22.780 --> 00:20:24.180
Here's a class.

00:20:24.180 --> 00:20:25.760
I understand what the class does.

00:20:25.760 --> 00:20:28.660
I don't need to go and look into the details.

00:20:28.660 --> 00:20:33.660
And it lets you build these more larger building blocks of conceptual models.

00:20:33.860 --> 00:20:35.400
But if that's not true, right?

00:20:35.400 --> 00:20:40.680
Like if a getter is a setter, well, then all of a sudden those things are all out the window and that's bad.

00:20:40.680 --> 00:20:41.160
Yeah.

00:20:41.160 --> 00:20:45.580
I mean, we work by building mental models and you need trust to build those mental models.

00:20:45.580 --> 00:20:50.920
And as soon as that trust is violated, it just starts taking time to do everyday tasks.

00:20:50.920 --> 00:20:54.120
You say, I want to implement a single API endpoint.

00:20:54.120 --> 00:20:59.900
Well, if I have to go dig through 10 different files just to make sure I'm doing everything right, that's going to slow me down.

00:21:00.640 --> 00:21:09.300
If I can trust that my mental model is correct and that it's been shown to be correct time and time again, I can put more faith in that code and I can feel safer to start changing.

00:21:09.300 --> 00:21:10.620
Yeah, for sure.

00:21:10.620 --> 00:21:19.660
Another thing that I really liked about some of your ideas was that you talked about people having good intentions, even if they write bad code.

00:21:19.660 --> 00:21:22.680
Like they're trying their best and they're for the most part.

00:21:22.680 --> 00:21:27.320
I mean, there might be people who are just lazy or whatever, but for the most part, like they tried to write this well.

00:21:27.440 --> 00:21:32.080
Even if it came out bad, they probably tried to write it well and it just didn't turn out as good as they hoped.

00:21:32.080 --> 00:21:38.120
Or even they wrote it well and it's just changed over time and those original assumptions got lost.

00:21:38.120 --> 00:21:38.960
Right, right.

00:21:38.960 --> 00:21:42.800
It made sense in the early days and the assumptions or the context changed.

00:21:42.800 --> 00:21:44.540
Now it's no longer accurate.

00:21:44.540 --> 00:21:44.820
Yeah.

00:21:44.820 --> 00:21:49.020
Or it's inflexible and it's really hard to use to extend to your current use case.

00:21:49.020 --> 00:21:50.160
I see that all the time.

00:21:50.540 --> 00:21:54.380
One of the ideas that I thought was interesting is this idea of legacy code.

00:21:54.380 --> 00:21:57.480
And I've always been kind of fascinated with what does legacy code mean?

00:21:57.480 --> 00:21:57.980
Yeah.

00:21:57.980 --> 00:22:01.120
Because legacy code for one person could be COBOL.

00:22:01.120 --> 00:22:05.340
Legacy code for another person could be Python 2.6.

00:22:05.340 --> 00:22:06.640
That's pretty old.

00:22:06.640 --> 00:22:11.640
It could even just be Python 3.6 that's been around for a while, right?

00:22:12.180 --> 00:22:14.080
And there's different people who have different definitions.

00:22:14.080 --> 00:22:18.600
Michael Feathers has a cool book called Working Effectively or Effectively Working with Legacy Code.

00:22:18.600 --> 00:22:19.220
Something like that.

00:22:19.220 --> 00:22:20.920
That's an interesting book.

00:22:20.920 --> 00:22:25.340
I believe it comes from maybe a slightly different time, but still some of the ideas will make you think.

00:22:25.340 --> 00:22:30.980
And I was going to quote that book actually because his is a legacy code base is a code base that doesn't have tests.

00:22:30.980 --> 00:22:33.460
And I used to think that for a long time.

00:22:33.460 --> 00:22:39.080
I love tests, but I've come to evolve my understanding of legacy code.

00:22:39.080 --> 00:22:41.180
And here's where the definition I've settled on.

00:22:41.180 --> 00:22:43.580
It's a legacy code, a legacy code base.

00:22:43.580 --> 00:22:47.380
It's a code base in which you can no longer communicate to the original authors or maintains.

00:22:47.380 --> 00:22:50.680
So the length of time doesn't matter as much.

00:22:50.680 --> 00:22:59.040
If you've lost contact from the original authors, all you have is the code base and its surrounding documentation to understand why it's doing the things it does.

00:22:59.040 --> 00:23:02.660
So that's become my favorite definition for legacy code as a place.

00:23:02.660 --> 00:23:03.600
Yeah, I like that one too.

00:23:03.600 --> 00:23:05.280
I don't really like the tests one.

00:23:05.280 --> 00:23:13.340
I see where it comes from, but I feel like it's judging a world from too strict of a place.

00:23:13.340 --> 00:23:20.480
Because not every piece of code is written in a way that it has to be absolutely correct.

00:23:20.480 --> 00:23:21.100
Yeah.

00:23:21.100 --> 00:23:21.720
Right.

00:23:21.720 --> 00:23:26.660
So I think this is also a good way to sort of scope this conversation.

00:23:26.660 --> 00:23:34.020
Because a lot of times people hear, oh, I have to use protocols and I have to use mypy and I have to use X, Y, and Z.

00:23:34.020 --> 00:23:38.080
And I have to do all these fancy things because Pat and Michael said so because they were awesome.

00:23:38.080 --> 00:23:39.780
And it's a big hassle.

00:23:39.780 --> 00:23:40.860
I don't think I need it.

00:23:40.860 --> 00:23:43.620
But here I'm trying to be a good software developer, right?

00:23:43.620 --> 00:23:44.760
So I'll give you an example.

00:23:45.420 --> 00:23:55.160
Years ago, I switched all the Talk Python stuff, especially the Talk Python training stuff, from relational databases and SQLAlchemy over to MongoDB and MongoEngine.

00:23:55.160 --> 00:24:02.080
And so I had to write a whole ton of code that would take a couple of tables and then put them into a structure and then put them in Mongo.

00:24:02.080 --> 00:24:04.060
And that was all fine and good.

00:24:04.060 --> 00:24:05.140
But here's the thing.

00:24:05.220 --> 00:24:09.300
The moment that code ran successfully, I never wanted to run it again.

00:24:09.300 --> 00:24:10.920
It only had to run once.

00:24:10.920 --> 00:24:12.360
It had to move the data one time.

00:24:12.360 --> 00:24:18.440
When it was done, there was no scenario where I cared about its typing or I cared about its continuous integration.

00:24:18.440 --> 00:24:20.040
I could have deleted it.

00:24:20.040 --> 00:24:21.840
I just kept it because, hey, source control.

00:24:21.840 --> 00:24:24.320
But there's these scenarios, right?

00:24:24.320 --> 00:24:38.580
On the other hand, you talk about if you're an online reservation system, like the reservation booking engine, that part needs an entirely different bit of attention and mindset than my little migration script, right?

00:24:38.580 --> 00:24:38.960
Yeah.

00:24:38.960 --> 00:24:42.680
And what I see is what value are the things delivering?

00:24:42.680 --> 00:24:45.240
Some things have one-off value, and that's perfectly okay.

00:24:45.240 --> 00:24:51.140
Your migration script, it's service value, but there won't be much value derived from it in the future.

00:24:51.640 --> 00:24:54.900
Maybe from an archaeology standpoint of how did I go do this?

00:24:54.900 --> 00:24:56.040
Yes, exactly.

00:24:56.040 --> 00:24:56.440
Maybe.

00:24:56.440 --> 00:25:07.480
With something that's core to a business, a reservation booking engine, it delivers value when you built it, but you want it to keep delivering value throughout its lifetime.

00:25:07.480 --> 00:25:12.900
And furthermore, the people who are working on it want to deliver value just as fast as you did in the beginning.

00:25:12.900 --> 00:25:15.540
So you don't want to slow down the future.

00:25:15.540 --> 00:25:19.840
You start getting into where you get product managers saying, why is this taking so long?

00:25:19.840 --> 00:25:21.520
This is super easy.

00:25:21.520 --> 00:25:24.720
Why do you have to spend three weeks just adding this one little field?

00:25:24.720 --> 00:25:31.280
And the answer is often, oh, you know, we didn't think about how to enable value faster when we built it.

00:25:31.280 --> 00:25:36.580
And there's a tricky line there because you can't just go play everything and say, I'm going to make everything super flexible.

00:25:36.780 --> 00:25:38.680
That often has the reverse effect.

00:25:38.680 --> 00:25:41.600
It makes things too flexible and that becomes unmaintainable.

00:25:41.600 --> 00:25:46.440
But there's a fine line between saying, okay, I'm going to think for the future and deliver value now.

00:25:46.540 --> 00:25:46.980
Yeah.

00:25:46.980 --> 00:25:55.880
If every dependency can be replaced and everything can be configured from a file, some settings file and like you never, you know, eventually that becomes a nightmare.

00:25:55.880 --> 00:25:56.720
It sounds cool.

00:25:56.720 --> 00:25:57.520
It's not cool.

00:25:57.520 --> 00:25:58.900
I worked on some of those.

00:25:58.900 --> 00:25:59.160
Yeah.

00:25:59.160 --> 00:26:00.300
It's just painful.

00:26:00.500 --> 00:26:05.060
And so here's the advice I give to people who want to think about how to make their code base more maintainable.

00:26:05.060 --> 00:26:09.340
Target your moneymakers, the things that produce value, because those are the things you want to protect.

00:26:09.340 --> 00:26:11.700
And whatever value means to you.

00:26:11.700 --> 00:26:13.280
Target things with high churn.

00:26:13.280 --> 00:26:15.220
So you can look in your Git history.

00:26:15.220 --> 00:26:16.960
You can see what files change the most.

00:26:16.960 --> 00:26:19.500
Chances are those are the files that are being read the most.

00:26:19.500 --> 00:26:21.400
They're the files that people are working in the most.

00:26:21.840 --> 00:26:28.660
Putting more safeguards in those files, making them more extensible will pay off just because more people are using them.

00:26:28.660 --> 00:26:32.540
Look for areas where you do large swaths of changes.

00:26:32.540 --> 00:26:37.160
It's called shotgun surgery, where if you want to add a single thing, you have to touch 20 files.

00:26:37.160 --> 00:26:41.020
The same 20 files keep getting changed again and again in a grouping.

00:26:41.020 --> 00:26:47.420
That tells you that, you know, if I were someone coming in new to the project, how do I know it's 20 and not 19, 21?

00:26:47.420 --> 00:26:48.840
That's a place we can simplify.

00:26:48.840 --> 00:26:51.760
Those are the things that are super easy to forget a case.

00:26:52.260 --> 00:26:52.440
Oh, yeah.

00:26:52.440 --> 00:27:03.400
Like, oh, we added this feature and every if statement had an else if that covered the new thing, except for that one where we did the auditing or except for that one where we checked if they were an admin.

00:27:03.400 --> 00:27:04.500
Oh, that one.

00:27:04.500 --> 00:27:05.720
Now everyone's an admin.

00:27:05.720 --> 00:27:06.020
Whoops.

00:27:06.020 --> 00:27:06.580
Yep.

00:27:06.580 --> 00:27:18.280
And so that's the sort of places where I think type hinting is and other strategies are super useful because you can start encoding that those ideas of I want to catch this when I miss a case.

00:27:18.280 --> 00:27:25.120
You can start encoding that into your checks, into linters, type checkers, static analysis, and so on and so forth.

00:27:25.120 --> 00:27:25.720
Important.

00:27:25.720 --> 00:27:30.920
I think people are pretty familiar with the typing system these days.

00:27:31.060 --> 00:27:32.040
I think it's really cool.

00:27:32.040 --> 00:27:43.620
The new type system is coming along with more things like 3.9 now lets you write lowercase set bracket integers or whatever rather than from typing import capital set.

00:27:43.620 --> 00:27:45.300
And then you can say it in parallel, right?

00:27:45.300 --> 00:27:46.380
That's really nice.

00:27:46.380 --> 00:27:52.880
With the pipe union definition, you can do like none, pipe, a thing instead of optional.

00:27:52.880 --> 00:27:53.540
Yeah.

00:27:53.540 --> 00:27:56.160
All of those are really nice and so on.

00:27:56.160 --> 00:28:06.980
I suspect that a lot of people are using types for their editor but are not going any further than that with anything like mypy or continuous integration or any of those.

00:28:06.980 --> 00:28:10.100
Do you want to maybe speak to like the use case of both of those?

00:28:10.100 --> 00:28:10.660
Yeah.

00:28:10.660 --> 00:28:13.940
So the use of editors alone is valuable.

00:28:13.940 --> 00:28:15.240
You get autocomplete.

00:28:15.240 --> 00:28:17.140
I mean, autocomplete alone.

00:28:17.140 --> 00:28:18.140
You get squiggly if you do it wrong.

00:28:18.140 --> 00:28:18.540
Yeah.

00:28:18.540 --> 00:28:19.820
I mean, that's right.

00:28:19.820 --> 00:28:21.680
Autocomplete alone is so good.

00:28:21.680 --> 00:28:30.100
And I was just thinking when you were talking about that getter that was actually a setter, there's a really good chance that whoever wrote that code knew that was bad.

00:28:30.100 --> 00:28:39.920
And yet their tooling was such that it was so error prone for them to change the name that they were willing to live with a getter that changed values.

00:28:40.120 --> 00:28:54.000
Because they're like, I could break so much stuff in ways I don't understand if I don't have like a proper set of tools, like a proper editor that'll do multifile refactoring and continuous integration and all of those things.

00:28:54.000 --> 00:28:54.280
Right.

00:28:54.280 --> 00:28:59.000
And so this is sort of like in that vein of your tools now do more for you.

00:28:59.000 --> 00:28:59.480
Yeah.

00:28:59.480 --> 00:29:14.780
And so if you take a look at how costly errors are, an error of the customer is incredibly costly when you factor in support and testing and, you know, field engineering, whatever you need to resolve that customer context, not to mention loss of customer faith.

00:29:14.780 --> 00:29:15.980
Yeah, that's a big one.

00:29:15.980 --> 00:29:25.340
It's expensive for, you know, tests in the later stages of QA to catch an error too, because now our development hasn't been planning to go fix this test or this code.

00:29:25.340 --> 00:29:29.640
We have to stop what we're doing and go back and fix this test that maybe worked on three weeks ago.

00:29:29.640 --> 00:29:32.600
The best time to catch an error is immediately after you write it.

00:29:32.600 --> 00:29:35.020
And that's where that tooling comes in with your editors.

00:29:35.020 --> 00:29:38.300
As you're typing, if you can find an error, great.

00:29:38.300 --> 00:29:41.040
You is the least amount of costs you could have spent.

00:29:41.040 --> 00:29:46.180
And then the second least amount, in my opinion, is letting some sort of stack analysis tool catch it.

00:29:46.180 --> 00:29:47.140
Something like my pie.

00:29:47.140 --> 00:29:52.560
So using types, you can say, you know, I want to encode some assumptions to my code base.

00:29:52.560 --> 00:29:54.820
This value will never be none.

00:29:54.820 --> 00:29:56.300
This value may be none.

00:29:56.300 --> 00:29:59.420
This value may be an enter string or this string.

00:29:59.420 --> 00:30:03.020
If you're right that it's never none, you never have to check it for none.

00:30:03.020 --> 00:30:03.520
Right.

00:30:03.520 --> 00:30:06.280
But if you're wrong, you always have to check it for none.

00:30:06.280 --> 00:30:06.580
Right.

00:30:06.580 --> 00:30:07.260
Which is it?

00:30:07.260 --> 00:30:07.700
Yeah.

00:30:07.700 --> 00:30:10.760
We don't want to do defensive programming of checking is none.

00:30:10.880 --> 00:30:14.020
every single variable we create in every function in vacation.

00:30:14.020 --> 00:30:16.120
That would just, it wouldn't be fun.

00:30:16.120 --> 00:30:20.060
But your alternative, if you don't have that tooling is, all right, does this function return

00:30:20.060 --> 00:30:20.360
none?

00:30:20.360 --> 00:30:22.080
Let me go look at its source code.

00:30:22.080 --> 00:30:23.820
Oh, it calls five other functions.

00:30:23.820 --> 00:30:25.340
Let me go look at their source code.

00:30:25.340 --> 00:30:27.280
Oh, this calls something to the database.

00:30:27.280 --> 00:30:28.560
Is that a nullable feel?

00:30:28.560 --> 00:30:34.180
And anytime you're making someone trawl through your code base to try to answer a question of,

00:30:34.180 --> 00:30:35.720
can this value be none?

00:30:35.720 --> 00:30:37.140
You're wasting their time.

00:30:37.140 --> 00:30:41.460
And they're either going to delay delivering features.

00:30:41.460 --> 00:30:43.180
That just adds up over time.

00:30:43.180 --> 00:30:45.020
Or they're going to make some incorrect assumptions.

00:30:45.020 --> 00:30:48.360
And that's going to cause mistakes, which will lead to time and waste money.

00:30:48.700 --> 00:30:53.440
You've already talked about focusing your attention to put things like type annotations on the

00:30:53.440 --> 00:30:56.640
parts that matter and not necessarily stress about the parts that don't, especially for

00:30:56.640 --> 00:30:57.840
code that's being retrofitted.

00:30:57.840 --> 00:30:58.700
Oh, absolutely.

00:30:58.700 --> 00:30:59.880
I think that's not right.

00:30:59.980 --> 00:31:03.560
Like the thing that logs, you know, it's going to turn whatever to a string.

00:31:03.560 --> 00:31:07.660
And if it comes out as like, you know, some object at some address, like we'll catch it

00:31:07.660 --> 00:31:08.440
later and figure it out.

00:31:08.440 --> 00:31:12.220
But it's the core thing that you want that stuff to be right.

00:31:12.220 --> 00:31:18.360
But one of the things that can be challenging is the interest and the buy-in and the love for

00:31:18.360 --> 00:31:21.480
this idea might not be uniform across your team.

00:31:21.480 --> 00:31:22.840
No, no.

00:31:22.840 --> 00:31:26.520
You know, and I've seen the same thing for testing and I've seen the same thing for

00:31:26.520 --> 00:31:30.920
continuous integration, not necessarily the same person in the same thing, but you know,

00:31:30.920 --> 00:31:34.980
it's like if there's a person on your team that just doesn't care about the continuous

00:31:34.980 --> 00:31:40.020
integration and it turns off all the notifications that the continuous integration fails and then

00:31:40.020 --> 00:31:44.880
they keep checking in stuff and failing the build, you know, like not again, I got to

00:31:44.880 --> 00:31:49.060
go fix this because this person doesn't bother to check their thing and it just gets super

00:31:49.060 --> 00:31:49.580
frustrated.

00:31:49.580 --> 00:31:52.880
And I feel like probably typing has a similar analogy to that.

00:31:52.880 --> 00:31:53.500
It does.

00:31:53.580 --> 00:31:59.820
And that's why if you're in a legacy code base or even a maintained code base that doesn't

00:31:59.820 --> 00:32:04.040
have a whole lot of typing in it, there's alternatives you can have just beyond being strategic where

00:32:04.040 --> 00:32:04.440
you pick.

00:32:04.440 --> 00:32:09.980
There's some fantastic tooling like monkey type, which can annotate your code base for you.

00:32:09.980 --> 00:32:12.340
There's Google's type checker, pi type.

00:32:12.340 --> 00:32:14.920
It can do type checking without type annotations.

00:32:15.220 --> 00:32:19.460
And it does it in a little bit different philosophy than my pi, which I think is capital.

00:32:19.460 --> 00:32:25.540
It tries to infer based on just the values throughout your function bodies, the types should be without type

00:32:25.540 --> 00:32:25.680
annotations.

00:32:25.680 --> 00:32:35.060
So there might be ways to get the benefits without actually making the full commitment to those type checkers for just type

00:32:35.060 --> 00:32:36.180
annotations in general.

00:32:36.620 --> 00:32:39.920
There's also, I mean, tie your value to it.

00:32:39.920 --> 00:32:41.320
Look through your bug reports.

00:32:41.320 --> 00:32:49.060
If you find out that, hey, you know, we've had 12 dereferences of none in the past, you know,

00:32:49.060 --> 00:32:49.440
month.

00:32:49.440 --> 00:32:52.460
None type does not have such attribute, whatever.

00:32:52.460 --> 00:32:52.900
Right.

00:32:53.080 --> 00:32:55.320
And it's cost us X amount of dollars.

00:32:55.320 --> 00:33:00.660
I can now go to someone and say, look, this is costing us real money and cut like our time.

00:33:00.660 --> 00:33:02.860
Sometimes data speaks volumes.

00:33:02.860 --> 00:33:08.040
if you're having a tough time convincing people, I often say, find the data to back it up.

00:33:08.040 --> 00:33:09.240
Look through your bug reports.

00:33:09.240 --> 00:33:10.720
If I, what would we have caught?

00:33:10.720 --> 00:33:12.800
Oh, how much faster could we go?

00:33:12.800 --> 00:33:17.420
Oh, how much I'll do, do a, just even an informal survey around your developer base.

00:33:17.420 --> 00:33:20.400
How much more confident do you feel working in your code?

00:33:20.540 --> 00:33:25.980
and use that data to decide, yes, this is working or no, we need to look at alternative

00:33:25.980 --> 00:33:26.500
strategies.

00:33:26.500 --> 00:33:28.640
How much autocomplete do you get?

00:33:28.640 --> 00:33:31.140
I mean, that might be a winner, right?

00:33:31.140 --> 00:33:32.180
That would for me, actually.

00:33:32.180 --> 00:33:37.620
This portion of Talk Python is brought to you by masterworks.io.

00:33:37.620 --> 00:33:40.880
You have an investment portfolio worth more than a hundred thousand dollars.

00:33:40.880 --> 00:33:42.340
Then this message is for you.

00:33:42.340 --> 00:33:47.160
There's a $6 trillion asset class that's in almost every billionaire's portfolio.

00:33:47.640 --> 00:33:52.640
In fact, on average, they allocate more than 10% of their overall portfolios to it.

00:33:52.640 --> 00:33:58.560
It's outperformed the S&P, gold, and real estate by nearly twofold over the last 25 years.

00:33:58.560 --> 00:34:03.760
And no, it's not cryptocurrency, which many experts don't believe is a real asset class.

00:34:03.760 --> 00:34:05.880
We're talking about contemporary art.

00:34:06.200 --> 00:34:11.500
Thanks to a startup revolutionizing fine art investing, rather than shelling out $20 million

00:34:11.500 --> 00:34:16.240
to buy an entire Picasso painting yourself, you can now invest in a fraction of it.

00:34:16.240 --> 00:34:18.740
Few realize just how lucrative it can be.

00:34:18.740 --> 00:34:25.860
Contemporary art pieces returned 14% on average per year between 1995 and 2020, beating the S&P

00:34:25.860 --> 00:34:27.520
by 174%.

00:34:28.060 --> 00:34:33.000
Masterworks was founded by a serial tech entrepreneur and top 100 art collector.

00:34:33.000 --> 00:34:38.920
After he made millions on art investing personally, he set out to democratize the asset class for

00:34:38.920 --> 00:34:40.540
everyone, including you.

00:34:40.540 --> 00:34:44.940
Masterworks has been featured in places like the Wall Street Journal, the New York Times,

00:34:44.940 --> 00:34:45.520
and Bloomberg.

00:34:45.520 --> 00:34:49.120
With more than 200,000 members, demand is exploding.

00:34:49.120 --> 00:34:54.840
But lucky for you, Masterworks has hooked me up with 23 passes to skip their extensive waitlist.

00:34:55.360 --> 00:34:57.480
Just head over to our link and secure your spot.

00:34:57.480 --> 00:35:03.600
Visit talkpython.fm/masterworks or just click the link in your podcast player's show notes.

00:35:03.600 --> 00:35:07.920
And be sure to check out their important disclosures at masterworks.io slash disclaimer.

00:35:07.920 --> 00:35:14.320
I do want to move on to some other ideas because it's not all about typing, but I think typing

00:35:14.320 --> 00:35:20.520
unlocks a lot of these sort of durability ideas that you're covering there.

00:35:20.980 --> 00:35:25.780
So another one that you talked a lot about, I think is really interesting in this context,

00:35:25.780 --> 00:35:30.160
has to do with collection types and knowing the right data type.

00:35:30.160 --> 00:35:30.720
Yes.

00:35:30.720 --> 00:35:33.500
And that matters so much, right?

00:35:33.500 --> 00:35:38.060
Like somebody might use a dictionary where they should have used a set or something.

00:35:38.060 --> 00:35:41.220
And you're like, well, you used a dictionary, so you made me to look this up by value.

00:35:41.220 --> 00:35:42.740
Like, no, no, I just want to have one of everything.

00:35:43.740 --> 00:35:46.020
Okay, but why do we use the dictionary?

00:35:46.020 --> 00:35:48.700
But people, when they're new, they don't necessarily know that.

00:35:48.700 --> 00:35:50.180
They find the first thing that works.

00:35:50.180 --> 00:35:51.600
They're like, oh, a dictionary worked for this.

00:35:51.600 --> 00:35:52.400
We're using dictionaries.

00:35:52.400 --> 00:35:57.180
But beyond that, it means something for certain container types and other things, right?

00:35:57.180 --> 00:35:57.720
Yeah.

00:35:57.720 --> 00:36:01.180
I think if you look at this on a Python of, you know, there should only be one way to do

00:36:01.180 --> 00:36:01.340
it.

00:36:01.340 --> 00:36:03.680
Most people say, but there's multiple ways to do that.

00:36:03.680 --> 00:36:04.620
Like, I can use a dictionary.

00:36:04.620 --> 00:36:05.480
I can use a set.

00:36:05.800 --> 00:36:08.520
I can use a list and just search for unique values.

00:36:08.520 --> 00:36:11.120
And it's encoded in a string and you can parse it every time.

00:36:11.120 --> 00:36:11.620
Yeah.

00:36:11.620 --> 00:36:17.380
The choices you make, the abstractions you choose, communicate a certain intent.

00:36:17.380 --> 00:36:21.040
When you choose to use a set, that tells me I can iterate over it.

00:36:21.040 --> 00:36:22.560
There won't be any duplicates.

00:36:22.560 --> 00:36:27.840
And I don't, I won't be looking things up by key.

00:36:27.840 --> 00:36:31.080
When I think of a dictionary, I think of a mapping from key to value.

00:36:31.080 --> 00:36:32.440
The keys must be unique.

00:36:32.840 --> 00:36:37.300
But if all I care about was the keys and no values, like there's added cognitive,

00:36:37.300 --> 00:36:40.180
just dissonance of why do I have values for this dictionary?

00:36:40.180 --> 00:36:41.100
They're all serious.

00:36:41.100 --> 00:36:42.040
It doesn't make sense.

00:36:42.040 --> 00:36:42.320
Yeah.

00:36:42.320 --> 00:36:44.940
It goes back to the principle of, Lisa Sashman.

00:36:44.940 --> 00:36:49.220
You get surprised like, oh, this dictionary is being used as a set.

00:36:49.220 --> 00:36:50.300
I get it now.

00:36:50.300 --> 00:36:54.840
And if you're not addressing that as you find it, you're just kicking the can onto a future

00:36:54.840 --> 00:36:59.100
maintainer who then has to add that to the 20 other things he's trying to keep track of

00:36:59.100 --> 00:37:02.480
throughout their maintenance of the program.

00:37:02.480 --> 00:37:03.440
yeah.

00:37:03.440 --> 00:37:03.800
Yeah.

00:37:03.800 --> 00:37:08.700
The, you, you mentioned that one of my big pet peeves is, so a dictionary, I

00:37:08.700 --> 00:37:10.200
say is a mapping from key to value.

00:37:10.200 --> 00:37:12.260
That's typically a homogenous mapping.

00:37:12.260 --> 00:37:14.960
Every key is the same type and every value is the same type.

00:37:14.960 --> 00:37:21.140
But we really, really, really love dictionaries for things like JSON responses or relationships

00:37:21.140 --> 00:37:21.640
of data.

00:37:21.640 --> 00:37:25.880
And that can be so detrimental to maintain ability of code bases.

00:37:25.880 --> 00:37:26.860
If you're not careful.

00:37:26.860 --> 00:37:29.600
The problem is a type checker.

00:37:29.600 --> 00:37:32.980
Isn't the greatest at saying, oh, this is a dict.

00:37:32.980 --> 00:37:34.660
Some of the keys are strings.

00:37:34.660 --> 00:37:35.660
Others are bits.

00:37:35.660 --> 00:37:37.640
Others are decimals.

00:37:37.640 --> 00:37:39.880
And the values are all over the type.

00:37:39.880 --> 00:37:42.760
you can use a type stick to try to get around that.

00:37:42.760 --> 00:37:45.120
But really what you're talking about is a relationship of data.

00:37:45.120 --> 00:37:50.820
when you talk about dictionaries, you're getting into the, well, you, if I see, let's

00:37:50.820 --> 00:37:51.820
say I'm code review.

00:37:51.820 --> 00:37:54.400
Not only were, put this in concrete terms.

00:37:54.400 --> 00:37:55.600
I'm code reviewing some code.

00:37:55.600 --> 00:37:59.980
I see someone accessing dictionary and the key is foot.

00:37:59.980 --> 00:38:05.380
I have to go look at all of where that dictionary was created and modified to make sure that

00:38:05.380 --> 00:38:08.240
who is actually a valid field in that dictionary.

00:38:08.240 --> 00:38:09.620
I have no guarantees.

00:38:09.620 --> 00:38:13.860
Just if I see dict and a type checker, I'm sorry, a type annotation.

00:38:13.860 --> 00:38:16.260
So again, it's that trawling through the code base.

00:38:16.260 --> 00:38:18.440
Oh, this is actually coming from an API.

00:38:18.440 --> 00:38:24.060
Now I have to go read the API and I can't effectively code review code or maintain code.

00:38:24.060 --> 00:38:28.440
If I'm just reading that through without doing that every time to make sure something hasn't

00:38:28.440 --> 00:38:29.020
changed.

00:38:29.020 --> 00:38:32.100
So in this case, I'd say use a data class.

00:38:32.100 --> 00:38:34.380
You know, you have explicit fields.

00:38:34.380 --> 00:38:36.760
You can, you can lean on your tooling.

00:38:36.760 --> 00:38:43.300
If you mess up the field, you aren't expecting to see new fields get created and probably 95,

00:38:43.300 --> 00:38:44.720
99% of the time.

00:38:44.720 --> 00:38:48.180
Or, and I'm like, I will prefer a data class to a dictionary.

00:38:48.180 --> 00:38:51.220
If I have heterogeneous data almost all the time.

00:38:51.220 --> 00:38:51.720
Yeah.

00:38:51.740 --> 00:38:56.520
And maybe get it back like, like a flask API call called JSON.

00:38:56.520 --> 00:38:59.720
And then just jam that star star of that thing into the data class.

00:38:59.720 --> 00:39:00.380
Something like that.

00:39:00.380 --> 00:39:00.860
Yep.

00:39:00.860 --> 00:39:01.380
Yep.

00:39:01.380 --> 00:39:03.840
And I know you've talked about Pydantic on the show.

00:39:03.840 --> 00:39:04.840
Oh, a lot.

00:39:04.840 --> 00:39:05.940
I love Pydantic.

00:39:05.940 --> 00:39:11.060
Just, you know, define a model, let it parse that JSON response and just build that data

00:39:11.060 --> 00:39:11.840
class for me.

00:39:11.840 --> 00:39:13.140
Throw an error if it's invalid.

00:39:13.300 --> 00:39:17.120
And I really liked that model of, of attacking programs like that.

00:39:17.120 --> 00:39:18.200
I love Pydantic.

00:39:18.200 --> 00:39:21.600
I love how it, it tries to sort of be flexible.

00:39:21.600 --> 00:39:26.580
It's like, if we, if I think we can fix this, if you had a thing that is a string, but in

00:39:26.580 --> 00:39:29.680
the string, it really is parsable to a number and it's supposed to be a number.

00:39:29.820 --> 00:39:32.220
I'll just go ahead and do that type conversion for you.

00:39:32.220 --> 00:39:34.600
If not, give you a decent error message.

00:39:34.600 --> 00:39:36.020
It's really, really lovely.

00:39:36.020 --> 00:39:36.600
Yep.

00:39:36.600 --> 00:39:40.180
So if I'm, I'm working with APIs, I love Pydantic for that, that reason that you just outlined,

00:39:40.180 --> 00:39:45.600
but I'll often convert it to a data class or Pydantic data class so that I can say, this

00:39:45.600 --> 00:39:49.820
is a relationship of data and I can kind of shape how a user uses that relationship of

00:39:49.820 --> 00:39:51.680
data throughout the lifetime of the code.

00:39:51.820 --> 00:39:52.220
Yeah.

00:39:52.220 --> 00:39:57.320
It's an interesting tension on how much those models get used throughout all the tiers of

00:39:57.320 --> 00:39:59.140
your app and how much you want to keep them separate.

00:39:59.140 --> 00:40:01.940
Have you seen, SQL model?

00:40:01.940 --> 00:40:02.720
I believe it's called.

00:40:02.720 --> 00:40:03.760
Oh, I have not.

00:40:03.760 --> 00:40:04.620
I have not.

00:40:04.620 --> 00:40:05.020
Okay.

00:40:05.020 --> 00:40:06.320
here we go.

00:40:06.320 --> 00:40:08.360
You probably heard a FastAPI, right?

00:40:08.360 --> 00:40:08.820
Yeah, of course.

00:40:08.820 --> 00:40:12.680
Obviously that's where Pydantic got, I think it's, it's a big boost.

00:40:12.680 --> 00:40:18.780
So Sebastian Ramirez came out a few days ago with, this thing called SQL model and it

00:40:18.780 --> 00:40:21.800
already, I think it's less than a week old and has 4,000 GitHub.

00:40:21.800 --> 00:40:26.180
stars, which is amazing, but basically it's a merging of Pydantic and SQLAlchemy.

00:40:26.180 --> 00:40:26.920
Oh, fantastic.

00:40:26.920 --> 00:40:32.880
It has a SQLAlchemy, you didn't work model and it underlying has all the SQLAlchemy

00:40:32.880 --> 00:40:35.900
stuff, but it's models are actually Pydantic models.

00:40:35.900 --> 00:40:36.460
Yeah.

00:40:36.460 --> 00:40:41.160
And I think this is just another illustration of why thinking about what types things are,

00:40:41.160 --> 00:40:43.920
even if you're not doing type annotations, why that's so important.

00:40:43.920 --> 00:40:46.400
It goes back to how do we build mental models?

00:40:46.400 --> 00:40:51.780
How do we build these, these abstractions in our brain that we can rely upon as we

00:40:51.780 --> 00:40:52.780
work through our code base?

00:40:52.780 --> 00:40:56.720
I do think this is interesting in that you could use the same model at the data level

00:40:56.720 --> 00:41:00.520
internal to your app, and then you could even use the API level, but there's also people

00:41:00.520 --> 00:41:02.860
are saying, but maybe that's not a good idea.

00:41:02.860 --> 00:41:08.800
Maybe you want to separate those in, in interesting ways for like one can change and the other doesn't

00:41:08.800 --> 00:41:09.480
have to change.

00:41:09.660 --> 00:41:11.660
But yeah, I've, I see a lot of value to this thing.

00:41:11.660 --> 00:41:12.660
It's, it looks exciting.

00:41:12.660 --> 00:41:17.540
And I mean, the answer to that's going to probably be, it depends if your application needs them

00:41:17.540 --> 00:41:18.340
to be the same.

00:41:18.400 --> 00:41:20.440
Lovely surprise, make them the same.

00:41:20.440 --> 00:41:22.260
If they have different reasons to change.

00:41:22.260 --> 00:41:23.980
This is something I see a lot too.

00:41:23.980 --> 00:41:26.260
We all get the dry principle.

00:41:26.260 --> 00:41:28.320
Don't repeat yourself and rain in our head.

00:41:28.320 --> 00:41:30.520
And we think, oh, source code looks the same.

00:41:30.520 --> 00:41:32.140
We must deduplicate it.

00:41:32.140 --> 00:41:37.060
But if that source code can change for different reasons, you're going to add more headaches

00:41:37.060 --> 00:41:38.260
by deduplicating it.

00:41:38.260 --> 00:41:39.880
You're going to start adding special cases.

00:41:39.880 --> 00:41:43.100
Well, this thing needs to change, but the other thing doesn't.

00:41:43.100 --> 00:41:44.500
How do I reconcile that?

00:41:44.500 --> 00:41:45.240
Special cases.

00:41:45.240 --> 00:41:50.820
And soon you, you've become the very thing you've sworn to destroy as you build that out.

00:41:50.820 --> 00:41:56.600
It's just littered with special cases as you're trying to tie together two things that have

00:41:56.600 --> 00:41:57.700
two separate contexts.

00:41:58.500 --> 00:42:03.180
So, you know, if you want to use something like SQL model for a API level and your internal

00:42:03.180 --> 00:42:06.840
data model, ask yourself, do these have different reasons for change?

00:42:06.840 --> 00:42:09.040
Maybe, maybe in the future.

00:42:09.040 --> 00:42:11.760
And like a lot of this is just empathy for the future.

00:42:11.760 --> 00:42:16.520
When I talk about maintainable code, robust code, you have to have empathy for those future

00:42:16.520 --> 00:42:18.100
maintainers, put yourself in their shoes.

00:42:18.100 --> 00:42:24.020
Are they going to want to migrate sometime and maybe change the API that they present to

00:42:24.020 --> 00:42:25.820
customers or users or other developers?

00:42:25.820 --> 00:42:28.360
Do you want to change your database at the same time?

00:42:28.360 --> 00:42:30.220
If so, keep them together.

00:42:30.220 --> 00:42:34.520
If you want to keep that separate so that you have certain migration paths, maybe you keep

00:42:34.520 --> 00:42:35.020
them separate.

00:42:35.020 --> 00:42:36.760
And so it's going to depend case by case.

00:42:36.760 --> 00:42:41.820
But again, everything comes down to those first principles of what are you communicating

00:42:41.820 --> 00:42:44.240
with your intent when you make that decision in your code?

00:42:44.240 --> 00:42:48.260
Like we've touched on, you're building different things at different times under different

00:42:48.260 --> 00:42:48.760
constraints.

00:42:49.000 --> 00:42:53.600
Are you building Instagram's API, which millions of people and apps are using?

00:42:53.600 --> 00:42:58.260
Or are you building something really quick so you can get that app to work for marketing

00:42:58.260 --> 00:42:59.900
for the next thing for the week?

00:42:59.900 --> 00:43:00.500
Right?

00:43:00.500 --> 00:43:01.060
Yeah.

00:43:01.060 --> 00:43:05.740
If, if it's that the second one, then you, you don't want to worry about too much abstraction

00:43:05.740 --> 00:43:07.680
and you just want to go like, I just need these to be in sync.

00:43:07.680 --> 00:43:08.460
The data goes here.

00:43:08.460 --> 00:43:09.400
We're going to send over the API.

00:43:09.400 --> 00:43:10.100
We're going to be good.

00:43:10.100 --> 00:43:10.260
Right?

00:43:10.260 --> 00:43:11.120
This is going to fly.

00:43:11.120 --> 00:43:16.080
On the other hand, if you're building something incredibly consumed and long lived, then maybe

00:43:16.080 --> 00:43:18.680
you have different design patterns and care about it.

00:43:18.680 --> 00:43:24.680
And I think it's important to think about organizational boundaries is the users, the consumers,

00:43:24.680 --> 00:43:30.200
the actors in your use cases are, is there an organizational boundary separating in the Instagram

00:43:30.200 --> 00:43:30.760
case?

00:43:30.760 --> 00:43:35.620
The people who are going to be using my API, I have no control over in my organization.

00:43:35.620 --> 00:43:37.900
It's general public as far as I'm concerned.

00:43:38.420 --> 00:43:43.140
If it's just someone on my team using it, we can work through, okay, you know, I'm changing

00:43:43.140 --> 00:43:43.720
this API.

00:43:43.720 --> 00:43:45.140
Let me help you through that.

00:43:45.140 --> 00:43:50.540
But if it's someone outside your team or outside your organization, you're going to have a backwards

00:43:50.540 --> 00:43:51.900
compatibility to think about.

00:43:51.900 --> 00:43:56.120
You're going to have all these vast amount of things that people are going to complain about.

00:43:56.120 --> 00:43:59.300
And you need to think about that and say, okay, can I make these changes?

00:43:59.300 --> 00:44:01.200
And is it good for my user base?

00:44:01.200 --> 00:44:04.280
Even though I can't control them, the best I can do is entice them.

00:44:04.280 --> 00:44:07.800
You'll never be able to force someone to use something they don't want to.

00:44:07.860 --> 00:44:10.920
If you don't have that control over them, that's why we have open source forks.

00:44:10.920 --> 00:44:16.300
One of the ideas that I think comes up in this, this whole story, and you talk a lot about

00:44:16.300 --> 00:44:22.000
like inheritance, both inheritance in terms of class hierarchies and even multiple inheritance,

00:44:22.000 --> 00:44:28.320
but also maybe the more traditional interface style with protocols, just so that you can express

00:44:28.320 --> 00:44:30.360
pipe stuff separately, right?

00:44:30.420 --> 00:44:35.040
In interesting ways without coming up with inheritance beasts and whatnot.

00:44:35.040 --> 00:44:35.600
Yeah.

00:44:35.600 --> 00:44:38.980
So one thing I did want to give people a quick shout out.

00:44:38.980 --> 00:44:41.480
So we've all heard of solid principles, right?

00:44:41.480 --> 00:44:45.660
And I've, I really enjoyed the solid principles and I thought they were super interesting.

00:44:45.660 --> 00:44:46.380
I still do.

00:44:46.380 --> 00:44:47.880
I think they're pretty great.

00:44:48.240 --> 00:44:54.860
I recently came across a presentation and it was, I kind of over on Richard Campbell's

00:44:54.860 --> 00:44:59.440
show.net rocks, which I know people probably don't care about that now, but they actually

00:44:59.440 --> 00:45:03.120
talked about this thing called Cupid, which is an alternative to solid.

00:45:03.300 --> 00:45:04.700
I'm going to go check that out.

00:45:04.700 --> 00:45:07.100
And it was super, it has nothing to do with.net.

00:45:07.100 --> 00:45:09.080
It's just like software in general patterns.

00:45:09.080 --> 00:45:13.920
Like what, what do we know now, 20 years later, that doesn't necessarily make so much sense

00:45:13.920 --> 00:45:14.440
for solid.

00:45:14.440 --> 00:45:16.160
And what is the alternative?

00:45:16.160 --> 00:45:17.320
And he has this really cute name.

00:45:17.320 --> 00:45:22.000
So as people are thinking about maybe those kinds of levels, like that's a pretty interesting

00:45:22.000 --> 00:45:22.580
to check out.

00:45:22.580 --> 00:45:23.020
Yeah.

00:45:23.020 --> 00:45:27.680
And I like thinking of solid again, going back to first principles, there are things that

00:45:27.680 --> 00:45:29.000
I like about solid.

00:45:29.220 --> 00:45:35.460
There are things I also think get a bad rep because they're associated with heavy, heavy

00:45:35.460 --> 00:45:40.060
OO code bases that have class hierarchies that are just unmanageable.

00:45:40.060 --> 00:45:42.880
Probably multiple templates in there somehow.

00:45:42.880 --> 00:45:43.240
Yeah.

00:45:43.240 --> 00:45:46.420
And we've kind of grouped these things together.

00:45:46.420 --> 00:45:51.460
So an example, like one of the most misunderstood ones, in my opinion, is the list of substitution

00:45:51.460 --> 00:45:53.240
principle of the solid principles.

00:45:53.240 --> 00:45:57.920
And like it applies when you're doing duck typing in Python, which has nothing to do with

00:45:57.920 --> 00:45:58.800
class hierarchies.

00:45:58.800 --> 00:46:02.520
It doesn't have anything to do with interfaces or things like that.

00:46:02.520 --> 00:46:04.180
It's a turnaround substitutability.

00:46:04.180 --> 00:46:09.700
And so when we talk about duck typing in Python, it's, well, multiple types can represent some

00:46:09.700 --> 00:46:10.100
behavior.

00:46:10.100 --> 00:46:13.740
Maybe they support an addition method and a subtraction method.

00:46:13.740 --> 00:46:18.080
Can they be substituted into this function that's expecting addition and subtraction?

00:46:18.080 --> 00:46:19.300
And so when we think about-

00:46:19.300 --> 00:46:21.840
I do addition and subtraction on dates and times.

00:46:21.840 --> 00:46:23.880
Another might do it on like imaginary numbers.

00:46:23.880 --> 00:46:27.460
But the concept of adding and subtracting things, you can reuse that, right?

00:46:27.460 --> 00:46:27.960
Something like that.

00:46:28.380 --> 00:46:33.480
And so things like list of substitutability, excuse me, list of substitutability principle

00:46:33.480 --> 00:46:38.400
talks about how do you think about substitutability from your requirements and from your behaviors?

00:46:38.400 --> 00:46:42.140
And you can get value from that without ever touching a class.

00:46:42.300 --> 00:46:51.400
So I think all too often we lump those solid principles to a strict OO of the 90s or the knots and think that they aren't as useful.

00:46:51.400 --> 00:46:54.160
I'm going to have to check out Kupin and see how that's changed as well.

00:46:54.160 --> 00:47:03.240
I would expect that a lot of the same first principles are true, but they've kind of reframed it in a way that is more applicable to how we program today.

00:47:03.240 --> 00:47:05.520
I don't remember all the details exactly.

00:47:05.520 --> 00:47:09.180
So, but yeah, something roughly along those lines.

00:47:09.180 --> 00:47:10.060
I think that makes sense.

00:47:10.060 --> 00:47:19.860
So one thing I do also want to just sort of get your thoughts on before we leave it completely in the dust is you talked about a lot of times you've got a dictionary and it's supposed to represent some stuff.

00:47:20.340 --> 00:47:25.060
Maybe it's a response from an API where it says, you know, here was what you requested.

00:47:25.060 --> 00:47:26.320
Here was the status code.

00:47:26.320 --> 00:47:28.240
Here's what the cloud cost of that is.

00:47:28.240 --> 00:47:33.120
And here's like the, you know, some, something that looks like that maybe doesn't make sense as a dictionary.

00:47:33.120 --> 00:47:36.840
Maybe it gets moved into like a Pydantic model or something like that.

00:47:36.840 --> 00:47:37.020
Right.

00:47:37.020 --> 00:47:44.720
But the other one is I have 10,000 users and I want to put their email address as the key and their user object as the value.

00:47:44.720 --> 00:47:48.380
And given an email address, I want to know super fast, which user is that?

00:47:48.380 --> 00:47:49.840
Or do I have that user at all?

00:47:49.900 --> 00:47:51.700
In that case, the dictionary makes a lot of sense.

00:47:51.700 --> 00:47:52.200
Absolutely.

00:47:52.200 --> 00:47:58.700
But there's a super big difference to say the keys represent like the same thing across different results.

00:47:58.700 --> 00:48:06.820
Whereas the same data structure, a dictionary represents this heterogeneous, like not really a class, but kind of a class.

00:48:06.820 --> 00:48:16.660
How do you position those so that beginners understand that those are completely unrelated things that need to be thought about separately, but they kind of appear the same in code?

00:48:16.660 --> 00:48:19.680
Because when I'm talking to people about dictionaries and I'm teaching, they're like,

00:48:19.680 --> 00:48:21.620
Oh, well, why would you use a dictionary here?

00:48:21.620 --> 00:48:24.540
Because over here you were doing it this other way, but now it's like a database.

00:48:24.540 --> 00:48:25.520
Like, what are you doing with it?

00:48:25.520 --> 00:48:26.040
This is weird.

00:48:26.040 --> 00:48:28.040
Why are these not, why are they the same but different?

00:48:28.480 --> 00:48:29.480
So here's how I find it.

00:48:29.480 --> 00:48:35.140
So for the key mapping value, I would say there's a few use cases you're going to have.

00:48:35.140 --> 00:48:41.420
You're going to either be iterating over the dictionary to do something on every element, or you're going to be looking up a specific element.

00:48:41.420 --> 00:48:45.800
And that element that lookup is dynamic, typically passing in some value.

00:48:46.280 --> 00:48:50.000
Maybe it's a variable that contains the email address in your example.

00:48:50.000 --> 00:48:57.320
For something like an API response, something that might be more heterogeneous, something that should be a data class or a Pydantic model, what have you.

00:48:57.320 --> 00:48:59.840
You typically aren't iterating over every key.

00:49:00.280 --> 00:49:07.700
You're looking up specific keys, but it's static to the index, meaning you're passing in string literals between the square brackets.

00:49:07.700 --> 00:49:10.060
This is the key I want on this circumstance.

00:49:10.060 --> 00:49:13.840
You know, the name, the age, the date of birth.

00:49:13.840 --> 00:49:14.440
Right.

00:49:14.440 --> 00:49:20.600
And so you're looking up specific fields and you're building a relationship between different key value pairs.

00:49:20.600 --> 00:49:23.820
A name, age, and date of birth is a relationship called purse.

00:49:23.820 --> 00:49:33.800
With your dictionary, you're doing, or with your mapping, your key value mapping, there's no relationship between email one to user object one and email two to user object two.

00:49:33.800 --> 00:49:35.960
The relationship is just from key to value.

00:49:35.960 --> 00:49:39.360
And that's typically what I explain to people trying to discern the difference.

00:49:39.660 --> 00:49:48.240
That's a really interesting way to think about it because, yeah, you will almost always use static literal strings when it's the heterogeneous API response style.

00:49:48.240 --> 00:49:50.480
And you will almost never do that.

00:49:50.480 --> 00:49:53.920
Why would you say, quote, type in the email address?

00:49:53.920 --> 00:49:55.500
You would just have that object.

00:49:55.500 --> 00:50:01.640
You wouldn't need to type in, like, you would just never create that structure in the first place, which I think is really interesting.

00:50:01.640 --> 00:50:10.040
So, yeah, if you're dynamically passing in the keys, it's probably all the same object, but different ones of them as opposed to an API response.

00:50:10.040 --> 00:50:13.760
And I think that's the heart of why I really wanted to write about robust Python.

00:50:13.760 --> 00:50:18.880
So I've been programming for a while now, and I make a lot of decisions as a senior engineer.

00:50:18.880 --> 00:50:22.580
I really started to step back and ask myself, why do I make these decisions?

00:50:22.580 --> 00:50:25.100
Why do I choose a dictionary over a data class?

00:50:25.100 --> 00:50:27.300
Why do I choose a class over a data class?

00:50:27.300 --> 00:50:30.400
Why do I choose an acceptance test over a unit test?

00:50:30.500 --> 00:50:35.960
Why do I choose to do a plug-in here, but a dependency injection somewhere else?

00:50:35.960 --> 00:50:37.760
And I just wanted to start documenting.

00:50:37.760 --> 00:50:40.260
Here's why I make the decisions I did.

00:50:40.260 --> 00:50:47.300
Here's why, what intent I'm trying to communicate through in the hopes that we start normalizing that conversation more in our field.

00:50:47.300 --> 00:50:49.480
Why are we doing the things we do?

00:50:49.480 --> 00:50:51.480
As a beginner, it's frustrating.

00:50:51.480 --> 00:50:51.960
Oh, wow.

00:50:51.960 --> 00:50:53.020
You use a dictionary here.

00:50:53.020 --> 00:50:53.580
Why?

00:50:53.580 --> 00:50:55.880
How did you ever know to do that?

00:50:55.880 --> 00:50:56.120
Yeah.

00:50:56.120 --> 00:50:56.500
Yeah.

00:50:56.500 --> 00:51:00.380
And so I wanted to really capture, again, I've said it a lot.

00:51:00.420 --> 00:51:02.800
The first principle, why am I doing the things I'm doing?

00:51:02.800 --> 00:51:09.740
What are the things I often give as advice to junior programmers, intermediate programmers, too, and senior programmers?

00:51:10.300 --> 00:51:23.560
It's just, it was really enlightening for me to really step back and try to dissect why I do the things I do in Python and come up with, here are the valid engineering reasons behind it and try to frame that in terms of maintainability.

00:51:24.020 --> 00:51:24.100
Yeah.

00:51:24.100 --> 00:51:25.100
I think that's very valuable.

00:51:25.100 --> 00:51:26.660
I think it'll help people learn.

00:51:26.660 --> 00:51:28.460
Because it's not enough to see it by example.

00:51:28.460 --> 00:51:29.700
You're like, well, these both kind of work.

00:51:29.700 --> 00:51:32.300
It's like, yeah, but they mean something different.

00:51:32.300 --> 00:51:34.560
They totally communicate something different.

00:51:34.560 --> 00:51:37.260
A couple of thoughts from the live stream I want to share.

00:51:37.260 --> 00:51:44.000
Kim Van Wick out there says fantastic advice about having too much configurability.

00:51:44.480 --> 00:51:50.320
Far too often, I prematurely de-dupe two similar blocks of code and then find myself adding special cases.

00:51:50.320 --> 00:51:51.100
I wouldn't need, yeah.

00:51:51.100 --> 00:51:53.020
That sounds like what you were saying as well.

00:51:53.020 --> 00:51:53.520
Yeah.

00:51:53.520 --> 00:51:57.660
And so what I would say is that there's a difference between policies and mechanism.

00:51:57.660 --> 00:52:01.040
The policies are your business logic and the mechanisms are how you go to do something.

00:52:01.040 --> 00:52:02.960
Logging module in Python is fantastic.

00:52:02.960 --> 00:52:03.860
You're logging.

00:52:04.020 --> 00:52:09.060
The logger module doesn't care what you're logging, how you're logging it, when you're logging it.

00:52:09.060 --> 00:52:10.300
It's just the mechanism.

00:52:10.300 --> 00:52:12.300
To dev null, who cares?

00:52:12.300 --> 00:52:12.860
Yeah.

00:52:12.860 --> 00:52:13.420
It's all the same.

00:52:13.420 --> 00:52:15.420
But the what you're logging is your policy.

00:52:15.420 --> 00:52:21.400
And so very often I try to find a way to say, okay, how do I make my mechanisms de-duplicate?

00:52:21.400 --> 00:52:23.100
Because those are what I have to reuse.

00:52:23.100 --> 00:52:25.100
My business rules are going to change.

00:52:25.100 --> 00:52:26.540
They're going to change for different reasons.

00:52:26.540 --> 00:52:30.800
I want to make that simple to define business rules, but keep the mechanisms reusable.

00:52:30.800 --> 00:52:33.600
You want to be able to compose those mechanisms together.

00:52:33.980 --> 00:52:39.480
Also on the live stream, Mr. Hypermagnetic says, is it faster to look up a user or whatever

00:52:39.480 --> 00:52:43.140
from a dictionary rather than iterate over a list?

00:52:43.140 --> 00:52:48.360
And I think, boy, oh boy, if you've been down that path, you know there's a difference.

00:52:48.360 --> 00:52:52.100
This is coming from an advice from a C++ programmer who really cared about performance.

00:52:52.100 --> 00:52:52.780
Measure it.

00:52:52.780 --> 00:52:54.500
Use cases can be surprising.

00:52:54.500 --> 00:53:01.320
If there are times where a contiguous block of memory with a binary search is faster than

00:53:01.320 --> 00:53:02.480
a dictionary lookup.

00:53:02.800 --> 00:53:04.700
But you will not know until you measure it.

00:53:04.700 --> 00:53:08.100
There are also things that need to be faster than your program.

00:53:08.100 --> 00:53:10.720
And there are many things that don't fast in your program.

00:53:10.720 --> 00:53:13.500
I think it's important being aware of which one those are.

00:53:13.500 --> 00:53:19.140
You don't want to, not to sound cliche, the whole premature optimization is the root of all

00:53:19.140 --> 00:53:19.540
evil.

00:53:19.540 --> 00:53:25.580
Breaking that down a bit, you don't want to just optimize everything because it takes time to

00:53:25.580 --> 00:53:26.380
optimize things.

00:53:26.520 --> 00:53:28.420
And it can obfuscate your code to optimize.

00:53:28.420 --> 00:53:32.580
Why am I entering over a list when a dictionary lookup can be just as useful?

00:53:32.580 --> 00:53:37.820
If you measure the parts that need to be fast and you say, this is slow and this way is

00:53:37.820 --> 00:53:38.200
faster.

00:53:38.360 --> 00:53:44.880
As long as you have a comment and a good commit message that says why you're doing the slightly

00:53:44.880 --> 00:53:48.120
obfuscated way or breaking that law of least surprise.

00:53:48.360 --> 00:53:52.720
As long as you have those breadcrumbs for someone to follow and go, oh, it's for speed.

00:53:52.720 --> 00:53:55.180
This is critical performance loop of my application.

00:53:55.180 --> 00:53:59.180
Maybe it's the web request handler or something in a database engine.

00:53:59.180 --> 00:54:03.040
You want to get those breadcrumbs so people can learn why you made the choices you did.

00:54:03.040 --> 00:54:07.740
The last thing you want someone in five years to say, oh, they were iterating over lists because

00:54:07.740 --> 00:54:09.780
they don't know that a dictionary exists.

00:54:09.780 --> 00:54:11.760
Let me go change that and slow down your app.

00:54:11.760 --> 00:54:15.200
But without that measurement, without that data, it's a fruitless endeavor.

00:54:15.200 --> 00:54:19.540
I mean, for a lot of data in general, a dictionary lookup would be a lot faster.

00:54:19.540 --> 00:54:26.140
But if what you have to do is every time create the dictionary and then do the lookup, probably

00:54:26.140 --> 00:54:31.020
that act of creating the dictionary erases the speed up of, because you would have just,

00:54:31.020 --> 00:54:32.600
you're kind of looping it over anyway, right?

00:54:32.600 --> 00:54:34.680
So it certainly, it depends.

00:54:34.680 --> 00:54:35.800
But yeah, if it's pre-created.

00:54:35.800 --> 00:54:37.840
Yeah, don't take what I've said as prescriptive.

00:54:37.840 --> 00:54:40.520
Measure, measure, measure, measure.

00:54:40.520 --> 00:54:41.680
Yeah, absolutely.

00:54:41.680 --> 00:54:41.760
Absolutely.

00:54:41.760 --> 00:54:49.760
And the invoking just your command line application with dash MC profile is super illuminating.

00:54:49.760 --> 00:54:51.440
How long have I spent in a function?

00:54:51.440 --> 00:54:53.940
How long, how many times did I call this function?

00:54:53.940 --> 00:54:57.140
Where is most of my execution time spent in?

00:54:57.140 --> 00:55:00.640
And it might be that the bottleneck you think you have is somewhere else completely.

00:55:00.640 --> 00:55:03.820
Well, yeah, that's actually a really important point as well.

00:55:03.820 --> 00:55:09.380
If you do that C profile and you find you're spending 5% of your time in that part you're trying

00:55:09.380 --> 00:55:15.300
to optimize, if you could make it go to zero, it's still going to be 95% as fast, right?

00:55:15.300 --> 00:55:21.860
So it might be able to be sped up significantly, but it might not actually be germane to making

00:55:21.860 --> 00:55:25.960
your program feel any faster because it's like optimizing nothing, basically.

00:55:26.220 --> 00:55:27.660
And I don't want to misrepresent.

00:55:27.660 --> 00:55:32.160
To go back to the question on the live stream, typically a dictionary lookup will be faster than

00:55:32.160 --> 00:55:33.100
entering or row list.

00:55:33.100 --> 00:55:34.900
I expect that most of the time.

00:55:34.900 --> 00:55:37.580
I would not rely on that all of the time.

00:55:37.580 --> 00:55:38.140
Yeah.

00:55:38.140 --> 00:55:39.020
That's why I advocate measuring.

00:55:39.020 --> 00:55:39.580
Yeah.

00:55:39.580 --> 00:55:41.040
Measuring, measuring, measuring.

00:55:41.300 --> 00:55:45.320
I've definitely been in a place where I'm like, oh, this 6,000 line, super complicated

00:55:45.320 --> 00:55:47.660
thing that is hard to understand and work on.

00:55:47.660 --> 00:55:49.260
This is where it's slow.

00:55:49.260 --> 00:55:53.680
And no, it was just some other like wrong data structure and some other very simple part.

00:55:53.680 --> 00:55:57.220
But if I didn't measure, I would have gone and tried to rewrite the part.

00:55:57.220 --> 00:55:59.060
I was like barely understanding.

00:55:59.060 --> 00:56:01.120
I would have probably broken it and still would have been slow.

00:56:01.220 --> 00:56:01.620
Yeah.

00:56:01.620 --> 00:56:03.900
I forget who mentioned it.

00:56:03.900 --> 00:56:08.300
There's the order of writing things is you make it correct so that, and you have tests

00:56:08.300 --> 00:56:10.260
around it so that you know that it stays correct.

00:56:10.260 --> 00:56:14.280
You then work on making it clear and then you make it fast if it needs to be.

00:56:14.280 --> 00:56:18.120
And that last part is optional based on, is this slowing, actually slowing me down?

00:56:18.120 --> 00:56:19.280
Is there a business value I'm losing?

00:56:19.280 --> 00:56:22.180
If it, you know, there are certain things I work with.

00:56:22.180 --> 00:56:25.000
I, we're publishing something once a day.

00:56:25.000 --> 00:56:26.720
Something takes another five minutes.

00:56:26.720 --> 00:56:28.460
I don't really care.

00:56:28.460 --> 00:56:33.420
Like my time is spent better on focus on parallelization or things of that nature.

00:56:33.420 --> 00:56:38.640
And so it's just really understanding why things are slowing down and where a little bit.

00:56:38.640 --> 00:56:41.400
There's a little bit of a tangent of robust Python, but it's an interesting question to

00:56:41.400 --> 00:56:41.820
bring up.

00:56:41.820 --> 00:56:43.960
Number less, you know, is that five minutes?

00:56:43.960 --> 00:56:45.340
Are you waiting on that five minutes?

00:56:45.340 --> 00:56:46.160
No, no, no.

00:56:46.160 --> 00:56:47.340
You kick it off and then you go.

00:56:47.340 --> 00:56:48.260
Yeah, exactly.

00:56:48.260 --> 00:56:49.880
Then you probably don't care.

00:56:49.880 --> 00:56:50.600
I care at all.

00:56:50.600 --> 00:56:55.440
But speaking of, time, I'm sure there are a ton of people listening that are like,

00:56:55.440 --> 00:57:01.620
I would love to take some of these ideas, maybe using my pie or putting more types or

00:57:01.620 --> 00:57:04.880
looking at stuff like Pydantic and so on.

00:57:04.880 --> 00:57:12.380
But at the same time, I, there's a lot of pressure on me to just from the time I receive the request

00:57:12.380 --> 00:57:14.620
to get some feature done until the feature is done.

00:57:14.740 --> 00:57:20.900
And the people making that request, managers, business owners, clients, whatever, they don't

00:57:20.900 --> 00:57:23.820
care that much about robust Python.

00:57:23.820 --> 00:57:24.320
No.

00:57:24.320 --> 00:57:29.020
They want minimum input of money and time for output of features.

00:57:29.020 --> 00:57:35.200
But anyone who has done that for any extended period of time knows that that is a net negative.

00:57:35.200 --> 00:57:35.860
Yes.

00:57:35.860 --> 00:57:37.380
How do you address that?

00:57:37.380 --> 00:57:41.260
I'll give you some thoughts of what I've done, but how do you address that for people who

00:57:41.260 --> 00:57:46.080
the way I feel receiving that I want to frame the conversation for a sub it is your duty

00:57:46.080 --> 00:57:49.080
to deliver value as quickly as you can.

00:57:49.080 --> 00:57:54.080
It is also your duty to make it so that your maintainers can deliver value at the same space

00:57:54.080 --> 00:57:54.880
in the same space.

00:57:54.880 --> 00:57:59.240
So if you're making, if you're delivering value today, but hindering your ability to deliver

00:57:59.240 --> 00:58:02.380
a month, three months from now, that's a problem.

00:58:02.380 --> 00:58:08.160
Now I'm not saying jeopardize your MVP or go-to market, but making sure that the business

00:58:08.160 --> 00:58:11.620
people understand, I can do this, I'm not going to be able to do this again.

00:58:11.620 --> 00:58:14.420
The other part that I say that is just practice.

00:58:14.420 --> 00:58:18.100
Practice with these sort of concepts and apply them in small places.

00:58:18.100 --> 00:58:19.660
You can do things incrementally.

00:58:19.660 --> 00:58:23.140
Maybe there's a couple hundred lines of a library you have.

00:58:23.140 --> 00:58:26.400
Just write type annotations for that or make it more extensible.

00:58:26.400 --> 00:58:29.200
Find small little wins here and there.

00:58:29.200 --> 00:58:34.020
And as you keep working out, just this Boy Scout rule, leave the code base cleaner than you

00:58:34.020 --> 00:58:34.460
found it.

00:58:34.800 --> 00:58:37.840
So if I'm, if I'm going into something and said, you know what, these assumptions don't

00:58:37.840 --> 00:58:38.500
hold up anymore.

00:58:38.500 --> 00:58:43.620
I can't fix it all right now, but I can do one incremental step that makes it easier.

00:58:43.620 --> 00:58:48.420
The next time I'm in here, I take those little bites over time and slowly morph into something

00:58:48.420 --> 00:58:52.660
as like, okay, as we start slowing down delivery, I'm starting to make those improvements.

00:58:52.660 --> 00:58:54.740
And then we start speeding up back again.

00:58:55.440 --> 00:59:02.600
Because there is a real tension between deliver it now and how making sure that you are going

00:59:02.600 --> 00:59:04.800
to be able to deliver hastily in the future.

00:59:04.800 --> 00:59:11.140
And by no means am I advocating gold plating where, oh, make everything maintainable now.

00:59:11.140 --> 00:59:15.000
Because there's typically a business behind this and you don't want the business to fail.

00:59:15.000 --> 00:59:18.520
You need to be able to be able to ship early and often.

00:59:18.660 --> 00:59:21.980
And it's that often part that is often the tricky part.

00:59:21.980 --> 00:59:22.740
It is tricky.

00:59:22.740 --> 00:59:27.020
Practice, practice, practice, and target where you're applying these ideas.

00:59:27.020 --> 00:59:30.680
You don't have to put all that flexibility in there first, right?

00:59:30.680 --> 00:59:31.980
You write it one way, you get it out.

00:59:31.980 --> 00:59:33.780
But then you have refactoring tools.

00:59:33.780 --> 00:59:34.780
You have continuous integration.

00:59:34.780 --> 00:59:39.460
You have things that allow you to make those changes as long as you keep using them and as

00:59:39.460 --> 00:59:40.900
long as the code doesn't get too bad.

00:59:41.320 --> 00:59:44.600
And here's one of the things I've always liked seeing.

00:59:44.600 --> 00:59:46.440
I forget who said this.

00:59:46.440 --> 00:59:47.100
There's a great quote.

00:59:47.100 --> 00:59:50.720
It's like, to make a hard change, first make the hard change easy.

00:59:50.720 --> 00:59:52.020
That's the hard part.

00:59:52.020 --> 00:59:53.600
And then go make the easy change.

00:59:53.600 --> 00:59:54.240
Yeah.

00:59:54.240 --> 00:59:58.940
When you see, like a lot of teams do some sort of estimation of their stories.

00:59:58.940 --> 01:00:00.380
How big will this effort take?

01:00:00.380 --> 01:00:05.100
If you see consistently high estimates, this is always a large.

01:00:05.100 --> 01:00:07.020
We're always doing larges and extra larges.

01:00:07.440 --> 01:00:11.600
Ask yourself, what would it take to make this a small?

01:00:11.600 --> 01:00:13.480
Sometimes you use Sivanachi numbers.

01:00:13.480 --> 01:00:17.040
If this is an eight, what would it take for me to make this a three?

01:00:17.040 --> 01:00:20.200
And some of your listeners may be like, what are you talking about?

01:00:20.200 --> 01:00:22.200
But estimation, we're estimating effort.

01:00:22.200 --> 01:00:22.600
Right.

01:00:22.600 --> 01:00:23.080
Yeah.

01:00:23.080 --> 01:00:26.580
Traditionally, way, way back in the day, people used to estimate in hours.

01:00:26.580 --> 01:00:27.960
How many hours is this going to take you?

01:00:27.960 --> 01:00:31.620
And it's like, that is a granularity that we don't have.

01:00:31.620 --> 01:00:33.660
I can't tell you is it 17 or 18 hours.

01:00:33.660 --> 01:00:39.260
I can tell you is it two hours or two days, but I can't tell you whether it's 17 hours.

01:00:39.260 --> 01:00:44.200
And so when you get large estimates again and again, ask yourself, are these estimates because

01:00:44.200 --> 01:00:49.280
of necessary complexity, complexity that's inherent to my domain, or is it accidental complexity

01:00:49.280 --> 01:00:50.500
that's built up over time?

01:00:50.500 --> 01:00:51.480
I have to talk.

01:00:51.480 --> 01:00:57.740
So necessary complexity is, you know, the deep workings of a neural net or flight controller

01:00:57.740 --> 01:00:58.080
software.

01:00:58.080 --> 01:00:59.940
Like these are inherently hard problems.

01:01:00.260 --> 01:01:05.260
I can't make that simpler, not without making a whole lot of money revamping an industry,

01:01:05.260 --> 01:01:08.680
but things like tax preparation, right?

01:01:08.680 --> 01:01:13.840
Like there is a minimum set of complexity to just figure out what that answer is because

01:01:13.840 --> 01:01:15.000
the rules are complex.

01:01:15.000 --> 01:01:15.380
Yeah.

01:01:15.380 --> 01:01:21.700
But if let's take that tax, if I have to, you know, maybe add a new rule and it's just a

01:01:21.700 --> 01:01:28.680
simple multiplication somewhere, I shouldn't have to add 20 to 30 files of changes just to

01:01:28.680 --> 01:01:32.720
implement that one thing, because it's going to happen again and again and again.

01:01:32.720 --> 01:01:36.520
And so you look through these common cases and say, you know, we keep saying this is a large

01:01:36.520 --> 01:01:36.860
effort.

01:01:36.860 --> 01:01:38.120
How do I make that smaller?

01:01:38.120 --> 01:01:42.700
And then you say, oh, you know, if we just restructured things here, you often find that

01:01:42.700 --> 01:01:48.000
the same amount of effort to go make that hard change easy will pay off in one to two

01:01:48.000 --> 01:01:52.100
cycles of like, okay, now that we're doing this again and again and again, like, yes,

01:01:52.100 --> 01:01:54.680
I took an extra day longer or week longer.

01:01:54.680 --> 01:01:56.920
And again, be mindful of your schedules.

01:01:56.920 --> 01:02:01.340
I'm not saying so schedules intentionally, but find that wiggle room where you can band together

01:02:01.340 --> 01:02:03.340
with your team and find those areas.

01:02:03.700 --> 01:02:06.120
Oh, this is a place that we can get some gains back.

01:02:06.120 --> 01:02:11.020
I often like to set junior engineers on the team at these sort of tasks.

01:02:11.020 --> 01:02:12.740
They get more familiar with the code.

01:02:12.740 --> 01:02:15.600
They often don't have as many responsibilities as a senior engineer.

01:02:15.600 --> 01:02:20.720
And they can just get that understanding and they feel like, oh, I've done something that

01:02:20.720 --> 01:02:21.920
really, really matters.

01:02:21.920 --> 01:02:23.660
I really like being an engineer.

01:02:23.660 --> 01:02:24.380
Right, so you're made on a cleanup job.

01:02:24.380 --> 01:02:25.040
Yeah.

01:02:25.040 --> 01:02:27.760
And that has worked wonders for me as well.

01:02:27.760 --> 01:02:28.580
And like, it's just worked.

01:02:28.580 --> 01:02:29.360
It's a win-win.

01:02:29.480 --> 01:02:33.760
And then you're delivering those features, those same things you're doing again and again

01:02:33.760 --> 01:02:35.320
at a much greater speed.

01:02:35.320 --> 01:02:38.240
And that saves you time to go do the next thing after.

01:02:38.240 --> 01:02:44.640
My approach to this, I mean, it only works with certain groups of stakeholders, I suppose.

01:02:44.640 --> 01:02:47.900
But when somebody would ask me, how long does this feature take?

01:02:47.900 --> 01:02:50.660
It wasn't like, well, here's the essence of the feature.

01:02:50.660 --> 01:02:53.080
Like it will work and you can click the button.

01:02:53.080 --> 01:02:55.260
Here's how much it'll take to add error handling.

01:02:55.260 --> 01:02:57.260
Here's how much it'll take to add logging.

01:02:57.480 --> 01:03:01.540
Here's how much it'll add to make that work in continuous integration and have tests.

01:03:01.540 --> 01:03:06.060
And here's how much we got to do to like not add technical debt while adding this feature.

01:03:06.060 --> 01:03:06.320
Right.

01:03:06.320 --> 01:03:09.200
Instead of presenting like, well, here's your menu.

01:03:09.200 --> 01:03:11.300
Well, all I want is the feature.

01:03:11.300 --> 01:03:12.140
Just give me the feature.

01:03:12.140 --> 01:03:12.420
Right.

01:03:12.420 --> 01:03:17.480
I just say, okay, well, if the feature is three hours, the other two hours, like five hours,

01:03:17.480 --> 01:03:19.960
it can take me five hours or whatever like metric used.

01:03:20.180 --> 01:03:27.200
That is what delivering it means in a professional setting is that it is done, not that it's minimal

01:03:27.200 --> 01:03:30.840
path, zero errors and zero bad data will execute.

01:03:30.840 --> 01:03:31.200
Right.

01:03:31.200 --> 01:03:34.240
They're not the same, but it's easy to get sucked into the minimum.

01:03:34.240 --> 01:03:35.880
How quick can I do this?

01:03:35.880 --> 01:03:37.960
I bet I can do it an hour if I really fly.

01:03:37.960 --> 01:03:38.240
Right.

01:03:38.700 --> 01:03:41.160
And I think that's a trap we often fall into.

01:03:41.160 --> 01:03:46.620
Like we're as engineers, it is our, it's our responsibility to provide accurate estimates

01:03:46.620 --> 01:03:48.560
for what's best for the business.

01:03:48.760 --> 01:03:53.040
And like, if you say, oh, I can do this without tests, what you're really telling people are

01:03:53.040 --> 01:03:56.760
I can do it, but I can't guarantee it will keep working after I deploy it.

01:03:56.760 --> 01:04:00.620
Cause I will have no way of knowing I've removed that visibility of tests.

01:04:00.620 --> 01:04:03.740
Tell me, oh, this important thing that you really wanted now.

01:04:03.740 --> 01:04:05.320
No idea if it's working now.

01:04:05.320 --> 01:04:05.740
Sorry.

01:04:05.740 --> 01:04:10.220
And like, once you start framing it like that, people go, okay, yeah.

01:04:10.220 --> 01:04:10.720
Yeah.

01:04:10.720 --> 01:04:10.980
Okay.

01:04:10.980 --> 01:04:11.960
Let's see what we can do.

01:04:11.960 --> 01:04:16.080
And you might need to have some hard conversations with the people who manage us.

01:04:16.080 --> 01:04:17.780
It might be need more headcount.

01:04:17.780 --> 01:04:18.740
We don't need us.

01:04:18.740 --> 01:04:20.340
We can't take as many projects.

01:04:20.340 --> 01:04:24.100
We can't take, you know, we can't take this much complexity.

01:04:24.100 --> 01:04:29.680
Maybe, you know, maybe a worldwide pandemic is happening and are, you know, we've been severely

01:04:29.680 --> 01:04:35.380
impacted and I mean, you can't, to some degree, you can't fix poor management of something,

01:04:35.380 --> 01:04:38.160
but you can coach your way up to try to get out of it.

01:04:38.160 --> 01:04:39.740
Some people are very receptive to that.

01:04:39.740 --> 01:04:40.880
Some people are not.

01:04:40.880 --> 01:04:45.240
And in the places that aren't, I mean, you have to ask yourself, is this something that

01:04:45.240 --> 01:04:49.320
I'm going to live with or is this something that bothers me and I need to think about other

01:04:49.320 --> 01:04:49.780
things?

01:04:49.780 --> 01:04:54.660
Well, I think you're probably in a pretty good space if you're making that clear to people.

01:04:54.660 --> 01:04:58.380
So I think if you're proposing a feature or how long will it take to do this feature,

01:04:58.380 --> 01:05:01.680
then you just, you just include what that means for a feature to be done.

01:05:01.780 --> 01:05:06.240
Like it has, it, it's not like zero bad data and it works sometimes.

01:05:06.240 --> 01:05:08.480
Like it's, it works for real.

01:05:08.480 --> 01:05:12.120
The harder story is we've gotten into a bad place.

01:05:12.120 --> 01:05:15.580
We need to not add features and just refactor improvement.

01:05:15.580 --> 01:05:18.500
Like that is a different story than like, what does that mean?

01:05:18.500 --> 01:05:20.360
And that's a really tough one.

01:05:20.360 --> 01:05:24.780
Cause if I'm a business person, I'm never going to say, yes, please stop feature delivery

01:05:24.780 --> 01:05:29.640
and making money for us to go build the same thing we already have.

01:05:29.640 --> 01:05:31.620
Like that's a tough sell to a business.

01:05:31.620 --> 01:05:34.220
And I really think just an incremental approach.

01:05:34.220 --> 01:05:36.740
And again, I mentioned earlier targeting strategically.

01:05:36.740 --> 01:05:39.560
What are your most used libraries or parts of code?

01:05:39.560 --> 01:05:41.820
What are the areas with the highest bug count?

01:05:41.820 --> 01:05:43.160
Put data to that.

01:05:43.160 --> 01:05:47.420
Hey, we've had five customer complaints about a crash in your system.

01:05:47.420 --> 01:05:48.860
They're linked to this one piece.

01:05:48.860 --> 01:05:53.060
If we start doing this, we save X amount of money and we would have kept that one customer.

01:05:53.460 --> 01:05:58.360
That's the sort of thing that speaks when you're getting against those somewhat unrealistic business

01:05:58.360 --> 01:05:58.800
pressures.

01:05:58.800 --> 01:06:01.420
You have to speak on their, on their level.

01:06:01.420 --> 01:06:06.280
And I, what I'm saying is a little wrong because it's not an us versus them type mentality.

01:06:06.280 --> 01:06:07.480
You're in this together.

01:06:07.480 --> 01:06:11.720
You feel us versus them at some times, but you need to work together, make them understand

01:06:11.720 --> 01:06:15.260
here are the business implications of the choices we're making.

01:06:15.260 --> 01:06:15.840
Exactly.

01:06:15.980 --> 01:06:19.840
I mean, you're the engineer and they're the business people, but you've got to just put

01:06:19.840 --> 01:06:25.300
the situation in terms that they appreciate and they can decide if it makes sense for them.

01:06:25.300 --> 01:06:25.700
Yeah.

01:06:25.700 --> 01:06:32.200
I would also add people out there listening that if the answer is almost never, can we clean

01:06:32.200 --> 01:06:33.680
up technical debt and make this better?

01:06:33.680 --> 01:06:38.760
You probably will end up with a team over time who is full of people who don't care about

01:06:38.760 --> 01:06:40.780
erasing technical debt and making it better.

01:06:40.780 --> 01:06:44.500
And it's only just going to get worse and worse in combinatorial ways.

01:06:44.960 --> 01:06:50.160
It's, it's not where the top engineers want to be and they don't get excited about coming

01:06:50.160 --> 01:06:54.920
to work where they have to like, you know, sneak in something that's unreliable and cram

01:06:54.920 --> 01:06:57.220
new features into broken, ugly code.

01:06:57.220 --> 01:07:02.080
And something I've learned over a long time programming is almost every technical solution,

01:07:02.080 --> 01:07:05.260
there's a people or process problem at the root of it.

01:07:05.260 --> 01:07:08.940
Like there, there's a lot of things that we think, oh, code can solve this.

01:07:08.940 --> 01:07:11.280
If I just refactor this, everything will be great.

01:07:11.280 --> 01:07:12.880
But there's a people aspect of this.

01:07:12.880 --> 01:07:14.280
And I'm not putting down those people.

01:07:14.280 --> 01:07:17.180
Like everyone around you is just living, breathing human being.

01:07:17.180 --> 01:07:21.680
They all have their own hopes, their own dreams, their own obstacles, their own places in life.

01:07:21.680 --> 01:07:26.240
And we, we have to recognize that sometimes, sometimes you have to work with the people

01:07:26.240 --> 01:07:28.240
in order to solve that technical problem.

01:07:28.240 --> 01:07:32.580
So much for the, mythos of the software engineer in the basement by themselves, huh?

01:07:33.000 --> 01:07:36.960
And I think that, that, stereotype is long dead for the most part.

01:07:36.960 --> 01:07:37.460
I agree.

01:07:37.460 --> 01:07:37.920
I agree.

01:07:37.920 --> 01:07:38.940
All right.

01:07:38.940 --> 01:07:42.000
Well, we go on and on, but I think we're out of time.

01:07:42.300 --> 01:07:46.740
So thanks for all your thoughts on this and, and the book's interesting and we'll talk

01:07:46.740 --> 01:07:47.320
more about it in a second.

01:07:47.320 --> 01:07:51.080
But before we do, if you're going to write some of this code, work on some of these ideas,

01:07:51.080 --> 01:07:52.780
you know, what editor are you up to?

01:07:52.780 --> 01:07:53.400
Yeah.

01:07:53.400 --> 01:07:57.100
I use VS Code, cause I still jump between languages quite a bit.

01:07:57.100 --> 01:07:58.440
And I like the flexibility of that.

01:07:58.440 --> 01:08:00.600
for a onesie twosie, I'll use a van.

01:08:00.600 --> 01:08:01.120
Cool.

01:08:01.120 --> 01:08:02.980
Then notable PI PI package.

01:08:02.980 --> 01:08:04.800
I'm going to call it Stevedore.

01:08:04.800 --> 01:08:09.620
Cause, a package used for, plugins, doing plugin development.

01:08:09.620 --> 01:08:15.700
I think it's really neat how it uses a, the packages entry points so that you can deploy

01:08:15.700 --> 01:08:17.700
plugins as separate pip installable packages.

01:08:17.700 --> 01:08:19.620
just something I wish more people knew about.

01:08:19.800 --> 01:08:20.380
That's awesome.

01:08:20.380 --> 01:08:20.560
Yeah.

01:08:20.560 --> 01:08:24.960
One of the things we don't put, we didn't cover, but it's also part of this robust story

01:08:24.960 --> 01:08:28.980
that you tell is about extensibility, about plugins, about all those kinds of things.

01:08:28.980 --> 01:08:29.140
Right.

01:08:29.140 --> 01:08:29.320
Yeah.

01:08:29.320 --> 01:08:32.380
And that just goes back to making the common cases simple.

01:08:32.380 --> 01:08:36.480
If you, if you're doing something again and again and again, make it easy for people to

01:08:36.480 --> 01:08:36.860
do that.

01:08:36.860 --> 01:08:39.080
And extensible code is a way to do that.

01:08:39.080 --> 01:08:39.500
Yeah.

01:08:39.500 --> 01:08:40.880
Like that tax example, right?

01:08:40.880 --> 01:08:44.620
If, if you could plug in the formulas that are applied in this place and then like you just

01:08:44.620 --> 01:08:47.540
add it in and maybe it just picks it up and goes, that would be ideal.

01:08:47.540 --> 01:08:47.900
Yeah.

01:08:47.900 --> 01:08:48.460
All right.

01:08:48.460 --> 01:08:48.780
Awesome.

01:08:48.780 --> 01:08:49.540
Good recommendation.

01:08:49.760 --> 01:08:50.840
One that I had not heard of.

01:08:50.840 --> 01:08:51.500
All right.

01:08:51.500 --> 01:08:52.860
So people are interested in this idea.

01:08:52.860 --> 01:08:54.560
I assume that they can check out your book.

01:08:54.560 --> 01:08:56.960
Maybe tell people about that real quick.

01:08:56.960 --> 01:09:01.840
And then like, what else would you provide as resources or places to get started?

01:09:01.840 --> 01:09:03.200
Yeah.

01:09:03.200 --> 01:09:08.460
I think just talking to senior members on your team, talking to junior members on your team,

01:09:08.460 --> 01:09:14.660
learning how people use the code around you, keeping an ear for your, your stakeholders,

01:09:14.660 --> 01:09:19.620
your code developers, think about the code you write, think about the implications it has.

01:09:19.720 --> 01:09:20.840
I mean, just listen.

01:09:20.840 --> 01:09:22.580
Most of this is empathy.

01:09:22.580 --> 01:09:24.520
I thought I was writing a technical book.

01:09:24.520 --> 01:09:26.180
I wrote a book about empathy instead.

01:09:26.180 --> 01:09:27.080
Just didn't know it.

01:09:27.080 --> 01:09:31.000
Put yourself in other people's shoes and think about how they're going to be receiver code

01:09:31.000 --> 01:09:34.060
a month from now, a year from now, five years from now.

01:09:34.740 --> 01:09:41.860
And again, just, I mean, a lot of talks you'll see at Python or the other Python conferences,

01:09:41.860 --> 01:09:44.600
you'll see these nuggets of truth throughout them.

01:09:44.600 --> 01:09:47.920
Ask yourself, why are they making the decisions they do?

01:09:47.920 --> 01:09:53.360
And see if you can really understand the kind of the root cause of why they're using this

01:09:53.360 --> 01:09:55.860
feature, especially as new features come out with Python.

01:09:56.120 --> 01:09:59.220
A lot of great ideas in here and I had a fun time talking about them.

01:09:59.220 --> 01:09:59.600
Oh, me too.

01:09:59.600 --> 01:10:00.180
Yeah.

01:10:00.180 --> 01:10:00.980
Thanks for being here, Pat.

01:10:00.980 --> 01:10:02.080
Been an absolute pleasure.

01:10:02.080 --> 01:10:03.520
Thank you so much.

01:10:03.520 --> 01:10:04.200
You're welcome.

01:10:04.200 --> 01:10:04.600
Bye.

01:10:04.600 --> 01:10:05.180
Bye.

01:10:05.980 --> 01:10:08.880
This has been another episode of Talk Python to Me.

01:10:08.880 --> 01:10:13.860
Our guest in this episode was Patrick Viafor, and it's been brought to you by Clubhouse,

01:10:13.860 --> 01:10:15.780
Masterworks, and Assembly AI.

01:10:15.780 --> 01:10:21.260
Choose clubhouse.io for tracking all of your work because you shouldn't have to project manage

01:10:21.260 --> 01:10:22.300
your project management.

01:10:22.300 --> 01:10:25.280
Visit talkpython.fm/clubhouse.

01:10:25.280 --> 01:10:30.220
Make contemporary art your investment portfolio's unfair advantage.

01:10:30.220 --> 01:10:33.980
With Masterworks, you can invest in fractional works of fine art.

01:10:33.980 --> 01:10:36.980
Visit talkpython.fm/masterworks.

01:10:36.980 --> 01:10:40.100
Do you need a great automatic speech-to-text API?

01:10:40.100 --> 01:10:42.640
Get human-level accuracy in just a few lines of code.

01:10:42.640 --> 01:10:45.400
Visit talkpython.fm/assemblyai.

01:10:45.400 --> 01:10:47.280
Want to level up your Python?

01:10:47.280 --> 01:10:51.320
We have one of the largest catalogs of Python video courses over at Talk Python.

01:10:51.320 --> 01:10:56.500
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:10:56.500 --> 01:10:59.160
And best of all, there's not a subscription in sight.

01:10:59.160 --> 01:11:02.060
Check it out for yourself at training.talkpython.fm.

01:11:02.220 --> 01:11:03.980
Be sure to subscribe to the show.

01:11:03.980 --> 01:11:06.760
Open your favorite podcast app and search for Python.

01:11:06.760 --> 01:11:08.080
We should be right at the top.

01:11:08.080 --> 01:11:13.240
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:11:13.240 --> 01:11:17.440
and the direct RSS feed at /rss on talkpython.fm.

01:11:18.300 --> 01:11:20.860
We're live streaming most of our recordings these days.

01:11:20.860 --> 01:11:24.280
If you want to be part of the show and have your comments featured on the air,

01:11:24.280 --> 01:11:28.700
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:11:28.700 --> 01:11:30.540
This is your host, Michael Kennedy.

01:11:30.540 --> 01:11:31.840
Thanks so much for listening.

01:11:31.840 --> 01:11:33.000
I really appreciate it.

01:11:33.000 --> 01:11:34.900
Now get out there and write some Python code.

01:11:34.900 --> 01:11:55.500
I'll see you next time.

