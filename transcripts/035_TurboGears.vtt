WEBVTT

00:00:00.001 --> 00:00:01.440
Do you have a new web project coming up?

00:00:01.440 --> 00:00:03.980
Are you thinking about choosing Django or maybe Flask?

00:00:03.980 --> 00:00:05.660
Those are excellent frameworks,

00:00:05.660 --> 00:00:08.040
but you might also want to check out TurboGears.

00:00:08.040 --> 00:00:10.500
It was created and released around the same time as Django.

00:00:10.500 --> 00:00:13.500
It lets you start your project as a micro framework,

00:00:13.500 --> 00:00:14.560
kind of like Flask,

00:00:14.560 --> 00:00:17.180
and yet you can scale up to a full stack solution,

00:00:17.180 --> 00:00:17.960
more like Django.

00:00:17.960 --> 00:00:21.520
It has built-in support for both relational databases

00:00:21.520 --> 00:00:24.260
via SQLAlchemy and MongoDB.

00:00:24.260 --> 00:00:26.900
This week, Alessandro Molina

00:00:26.900 --> 00:00:28.920
is here to tell us all about TurboGears.

00:00:28.920 --> 00:00:32.380
This is episode number 35 of Talk Python To Me,

00:00:32.380 --> 00:00:35.120
recorded October 28th, 2015.

00:00:57.840 --> 00:01:01.820
Welcome to Talk Python To Me,

00:01:01.820 --> 00:01:03.860
a weekly podcast on Python,

00:01:03.860 --> 00:01:05.820
the language, the libraries, the ecosystem,

00:01:05.820 --> 00:01:06.920
and the personalities.

00:01:06.920 --> 00:01:09.040
This is your host, Michael Kennedy.

00:01:09.040 --> 00:01:11.040
Follow me on Twitter where I'm @mkennedy.

00:01:11.040 --> 00:01:13.420
Keep up with the show and listen to past episodes

00:01:13.420 --> 00:01:14.940
at talkpython.fm,

00:01:14.940 --> 00:01:17.500
and follow the show on Twitter via at Talk Python.

00:01:18.460 --> 00:01:21.580
This episode is brought to you by Hired and CodeShip.

00:01:21.580 --> 00:01:26.920
Thank them for supporting the show on Twitter via at Hired underscore HQ and at CodeShip.

00:01:26.920 --> 00:01:28.600
Hey, everyone.

00:01:28.600 --> 00:01:32.140
Before we get to the interview, I want to tell you about a project I'm working on,

00:01:32.140 --> 00:01:33.580
and I need your help to make it happen.

00:01:34.400 --> 00:01:37.260
I've been asked by many listeners something along the lines of,

00:01:37.260 --> 00:01:38.760
how do I get started learning Python?

00:01:38.760 --> 00:01:40.700
Or, I'm new to Python.

00:01:40.700 --> 00:01:41.920
What should I focus on?

00:01:41.920 --> 00:01:43.740
And sometimes people even ask,

00:01:43.740 --> 00:01:45.980
how do I get a job as a Python programmer?

00:01:46.680 --> 00:01:50.160
I've decided to answer this question via a roundtable discussion format

00:01:50.160 --> 00:01:53.080
between people who just got into the industry as new developers

00:01:53.080 --> 00:01:57.760
and people who make decisions about hiring new developers on Python teams.

00:01:57.760 --> 00:01:59.520
This is where you come in.

00:01:59.520 --> 00:02:01.420
If you're a newly hired Python developer,

00:02:01.420 --> 00:02:03.540
maybe you got your job in the last year or so,

00:02:03.540 --> 00:02:06.700
would you come on the show and spend 10 minutes talking about

00:02:06.700 --> 00:02:10.360
how you learned Python and how you got started in software development?

00:02:10.360 --> 00:02:13.440
Maybe what it was that got you your first job?

00:02:13.440 --> 00:02:14.280
That kind of stuff?

00:02:14.820 --> 00:02:17.160
On the other hand, if you're a technical leader

00:02:17.160 --> 00:02:19.300
responsible for hiring Python developers,

00:02:19.300 --> 00:02:21.980
would you come on the show for also 10 minutes

00:02:21.980 --> 00:02:25.120
and give us recommendations for new and aspiring developers?

00:02:25.120 --> 00:02:28.920
Maybe what you look for, what skills are really important to you,

00:02:28.920 --> 00:02:32.040
and just what you think they need to do to get started

00:02:32.040 --> 00:02:34.440
and land that first interview and that first job.

00:02:34.440 --> 00:02:38.560
You can read about the whole project in a blog post I just wrote

00:02:38.560 --> 00:02:42.100
at bit.ly slash talkpythonhiring.

00:02:42.100 --> 00:02:43.500
Talkpythonhiring.

00:02:44.160 --> 00:02:44.900
What do you say?

00:02:44.900 --> 00:02:47.800
Can you come be part of the show and help your fellow developers?

00:02:47.800 --> 00:02:50.440
I'm looking for maybe three to four people from each group.

00:02:50.440 --> 00:02:56.000
If this isn't you, but you know someone who is the perfect fit for this little project of mine,

00:02:56.000 --> 00:02:58.980
send them the link and encourage them to be part of it.

00:02:58.980 --> 00:03:00.900
All right, now let's get on to the show.

00:03:00.900 --> 00:03:04.200
Alessandro, welcome to the show.

00:03:04.680 --> 00:03:05.220
Hi, Michael.

00:03:05.220 --> 00:03:05.900
Thank you.

00:03:05.900 --> 00:03:08.400
Hey, thanks for being on the podcast.

00:03:08.400 --> 00:03:10.780
We've got some cool web stuff to talk about today.

00:03:10.960 --> 00:03:17.340
So we're going to talk about TurboGear, its history, its evolution, why it's so awesome, and its future.

00:03:17.340 --> 00:03:21.240
But before we get into all that cool stuff, let's talk about your story.

00:03:21.240 --> 00:03:22.920
How did you get started in programming in Python?

00:03:23.420 --> 00:03:32.160
I actually started programming in a totally different language, which was C++, and I actually hated Python at the beginning.

00:03:32.160 --> 00:03:41.720
I was forced to use it at work at the company of a friend of mine, and then using it day by day, it's impossible to not fall in love with it,

00:03:41.800 --> 00:03:47.600
because it's so clear, so fast, to rapidly prototype things, especially when compared to C++.

00:03:47.600 --> 00:03:52.820
And so at the end, I started using Python for everything in my career.

00:03:52.820 --> 00:04:00.620
And since I moved here in Turing and founded Accent, we worked on Python on practically everything.

00:04:00.620 --> 00:04:02.520
That's really interesting.

00:04:02.520 --> 00:04:04.140
So why didn't you like it in the beginning?

00:04:04.140 --> 00:04:06.860
Well, it's really strange.

00:04:06.860 --> 00:04:17.320
If you are a C++ developer, you're probably used to structuring your things a lot, thinking a lot about how you should make a class,

00:04:17.320 --> 00:04:24.220
or everything is pretty much like the beauty behind the architecture of your code.

00:04:24.220 --> 00:04:28.120
While Python is more direct, you can rapidly prototype things.

00:04:28.420 --> 00:04:37.380
And at the beginning, I thought it was not a great idea to start throwing code which you can also like monkey patch or use mix-ins,

00:04:37.380 --> 00:04:48.120
which are really powerful concepts, but if you don't pay attention to them, you might misuse them and end up with some chaos in your code,

00:04:48.120 --> 00:04:53.300
which C++ somehow forced you to avoid doing that.

00:04:53.880 --> 00:05:04.180
But at the end, clarity and simplicity of the language clearly wins over much of the other benefits of a mild structured language for me.

00:05:04.180 --> 00:05:06.500
Yeah, I think a lot of people have that reaction.

00:05:06.500 --> 00:05:09.240
It manifests itself in different ways.

00:05:09.400 --> 00:05:21.480
So I think one of those common ways is people see Python so simple, doing things so simply, and they think, oh, well, this is so simple, it must not be a real language.

00:05:21.480 --> 00:05:24.800
Like, where is the compile and link step?

00:05:24.800 --> 00:05:28.720
And where is all of this, you know, other structure?

00:05:28.720 --> 00:05:32.540
And so, you know, what good is Python for?

00:05:32.540 --> 00:05:35.660
Is this just like kind of like a better scripting language rather than bash?

00:05:36.000 --> 00:05:36.160
Right.

00:05:36.160 --> 00:05:38.620
I mean, I get asked that question literally often.

00:05:38.620 --> 00:05:39.580
Yeah.

00:05:39.580 --> 00:05:43.840
My first impression was that too, but it was clearly wrong.

00:05:43.840 --> 00:05:45.560
Yeah.

00:05:45.560 --> 00:05:48.060
I mean, you can give some really interesting examples.

00:05:48.060 --> 00:05:58.940
Like the guy from PayPal, Mahmoud Hashemi, who was on show number four, actually has a bunch of amazing examples of, you know, sort of discrediting that idea.

00:05:59.020 --> 00:06:00.400
But it's a very common idea.

00:06:00.400 --> 00:06:06.200
So you started there, and then you worked with Python, and over time you just fell in love with it, huh?

00:06:06.200 --> 00:06:07.120
Yeah.

00:06:07.120 --> 00:06:11.520
I think I went through something similar, I guess, in the beginning as well.

00:06:11.520 --> 00:06:15.480
But it didn't take long to convince me that, you know, it was a good idea.

00:06:15.480 --> 00:06:18.340
Let's talk about TurboGears.

00:06:18.340 --> 00:06:20.040
What's TurboGears?

00:06:21.040 --> 00:06:23.800
Well, TurboGears is a web development framework.

00:06:23.800 --> 00:06:27.000
There are actually a lot in the Python ecosystem.

00:06:27.000 --> 00:06:35.260
But I think it's one really particular one because that's some of the key concepts that you do not see often in other frameworks.

00:06:35.260 --> 00:06:44.620
For example, TurboGears started as a collection of the best libraries available when TurboGears was created.

00:06:44.880 --> 00:06:48.720
So it didn't start as a framework from scratch, okay?

00:06:48.720 --> 00:06:54.160
It saw that there were really good ideas around and started and tried to collect them together.

00:06:54.160 --> 00:07:03.060
And then moved into something more complex and more architectured into a real framework itself.

00:07:03.720 --> 00:07:09.720
So the idea was, the original idea was, hey, look, here's a really cool templating engine.

00:07:09.720 --> 00:07:13.340
And over here is some sort of HTTP processing library.

00:07:13.340 --> 00:07:15.040
And here's a great little web server.

00:07:15.040 --> 00:07:22.240
And if we just stitch these together into a package and kind of wire them together, hey, we have a web framework, right?

00:07:22.240 --> 00:07:23.320
Yeah.

00:07:23.320 --> 00:07:25.740
Practically, the core idea was that one.

00:07:25.740 --> 00:07:38.860
So the team at the time started with Cherry Pie, with KID, with SQL objects, which were the most used technologies at the time, because we are talking around 2005 or something like that.

00:07:38.860 --> 00:07:49.040
And they collected them all together, put a widgets library on top of that, which was at the time the TurboGears widgets library.

00:07:49.280 --> 00:08:04.280
And then they started to create extensions and whatever was possible to evolve over that set of libraries and ended up having TurboGears, which at the time was something really powerful.

00:08:04.280 --> 00:08:11.200
Because we are talking in years where even Django was just getting started.

00:08:11.200 --> 00:08:14.900
Django was launched like two months before TurboGears.

00:08:14.900 --> 00:08:20.360
So they got, like being created at the same time, whereas not much was available around.

00:08:20.360 --> 00:08:22.500
So who was the original creator?

00:08:22.500 --> 00:08:33.700
Well, TurboGears has been created at the version one, was created by Kevin Dungor, who works right now, I think, at Mozilla, if I'm not wrong.

00:08:33.700 --> 00:08:40.200
And I don't know if he still works on web stack or web development and things like that.

00:08:40.200 --> 00:09:01.220
But then he moved away from TurboGears and Mark Ram to cover the development of the 2.0 version and started rewriting it on top of pylons, which was like more modern technology at the time, was just getting at its peak of usage.

00:09:01.760 --> 00:09:07.440
And new technologies like SQLAlchemy and new technologies like SQLAlchemy and Genshi was available.

00:09:07.440 --> 00:09:18.140
So they decided to rewrite TurboGears from scratch and move from Cherry Pie and so on to pylons and Genshi and SQLAlchemy.

00:09:18.140 --> 00:09:24.320
So to a totally different stack, which was better from their point of view.

00:09:24.320 --> 00:09:28.520
But of course, it was totally different in new technology.

00:09:28.520 --> 00:09:29.500
Yeah.

00:09:29.540 --> 00:09:30.880
Did that make upgrading challenging?

00:09:30.880 --> 00:09:31.120
Yeah.

00:09:31.120 --> 00:09:31.760
Yeah.

00:09:31.760 --> 00:09:57.220
Actually, one of the core reasons why TurboGears lost in user base and popularity at the time was because a lot of people had been scared by this move away from everything they were using for their daily development and had to rewrite most of their web application to a different framework, different template engine.

00:09:57.820 --> 00:10:04.160
I actually were just getting started with TurboGears at the time.

00:10:04.160 --> 00:10:08.420
I did like two web application with TurboGears one.

00:10:08.420 --> 00:10:21.660
And I remember that I was really frustrated because I had to rewrite everything from scratch, like especially for the database part, because SQL object and SQLAlchemy are really, really different.

00:10:21.660 --> 00:10:31.840
SQLAlchemy is far more flexible, more powerful, but it's a lot different from the syntax and the way you use SQL object usually.

00:10:32.500 --> 00:10:32.840
Yeah.

00:10:32.840 --> 00:10:32.900
Yeah.

00:10:32.900 --> 00:10:39.180
So it's not just a, you know, pip install TurboGears upgrade and off you go.

00:10:39.180 --> 00:10:41.860
It's a pretty serious thing to make that change.

00:10:41.860 --> 00:10:45.480
And so that caused a lot of problems, like you said, for people getting frustrated.

00:10:45.480 --> 00:10:46.440
Yeah.

00:10:46.560 --> 00:10:51.100
That's, I think one of the reasons why we learned the lesson.

00:10:51.100 --> 00:10:59.560
And then we tried to avoid breaking backward compatibility from version 2.1 and forward.

00:10:59.560 --> 00:11:06.480
We never brought backward compatibility again, even when we switched away from pylons and we brought things.

00:11:06.480 --> 00:11:14.620
That's been one of the core targets for TurboGears to try to not make the same error twice.

00:11:14.620 --> 00:11:26.340
So going forward and for a long time since you upgraded to, it's like basically, all right, we're guaranteeing that you can more or less just continue to upgrade as we do releases.

00:11:26.340 --> 00:11:27.100
Right?

00:11:27.100 --> 00:11:28.680
Yeah, exactly.

00:11:28.680 --> 00:11:38.960
For example, now we support Python 3, which as we know has a lot of differences and some libraries are not available on Python 3.

00:11:38.960 --> 00:11:42.900
Like when TurboGear started, there was a paste.

00:11:43.560 --> 00:11:48.360
And then we moved to a tool we created ourselves, Gearbox.

00:11:48.360 --> 00:11:52.440
But the commands are the same and the options are the same.

00:11:52.440 --> 00:11:54.980
And you just pick install one or the other.

00:11:54.980 --> 00:12:01.520
And if you are on an old version of Python, you can also install paste and go on using that one.

00:12:01.660 --> 00:12:09.860
So even when we replace technologies, we guarantee that you can use the new one or the old one and both will work for the long term.

00:12:09.860 --> 00:12:21.000
And when we write a technology ourselves, we try to make sure that it's the same as the previous one as for the interface for the user and so on.

00:12:21.260 --> 00:12:22.840
Okay, that's really great.

00:12:22.840 --> 00:12:24.820
I think that's the right path.

00:12:24.820 --> 00:12:28.140
You know, these apps are going to probably be long lived.

00:12:28.140 --> 00:12:31.500
And so you want to be able to keep supporting them, right?

00:12:31.500 --> 00:12:40.840
Before you mentioned a lot of interesting technologies like Gearbox and some of the other stuff that are the building blocks of TurboGears.

00:12:40.840 --> 00:12:48.380
But before we get into that level of detail, let's talk a little bit about the philosophy of TurboGears.

00:12:48.700 --> 00:12:59.780
On the webpage for TurboGears, on TurboGears.org, you have a couple of sort of reasons that TurboGears 2 was created, right?

00:12:59.780 --> 00:13:07.440
So you say TurboGears 2, it's kind of based on the good ideas from Django, TurboGears 1, and Ruby on Rails and those types of things.

00:13:07.440 --> 00:13:11.920
But you guys had frustrations with all of those frameworks.

00:13:12.220 --> 00:13:23.080
Yeah, well, one of the core ideas behind TurboGears is to actually make possible to make a structure of your web application,

00:13:23.080 --> 00:13:25.860
which is really simple and organized.

00:13:25.860 --> 00:13:35.340
Okay, like one of the core parts that got frustrated me with frameworks like Django, Flask, or even Pylons itself,

00:13:35.500 --> 00:13:38.500
which TurboGears was based on, was their routing.

00:13:38.500 --> 00:13:46.360
Because while regular expressions are really, really powerful, if you have a huge project, they start to get somehow messy.

00:13:46.360 --> 00:13:47.860
You have a lot of regular expressions.

00:13:48.060 --> 00:13:55.900
You have to try to resolve them to understand where the code that serves that page or performs that action is actually.

00:13:55.900 --> 00:14:03.700
And so if you work on a team and you have to test this project to another developer who has never seen that project before,

00:14:03.700 --> 00:14:12.340
he will need a lot of time to get started into the project and understand where things are going, how things are done,

00:14:12.460 --> 00:14:15.760
and where the code that does something is actually is.

00:14:15.760 --> 00:14:21.840
And TurboGears actually uses a totally different dispatch model, which is called object dispatch,

00:14:21.840 --> 00:14:29.940
on top of which everything, every URL, by default, is the path of your object.

00:14:30.100 --> 00:14:35.980
So it's much like the pyramid traversal, if you have ever seen it, but it doesn't use dictionaries.

00:14:35.980 --> 00:14:37.300
It uses objects.

00:14:37.300 --> 00:14:49.380
So every controller has actually methods, which are the URLs you expose, and it can have subcontrollers, which are subparts of your website.

00:14:49.820 --> 00:14:54.780
And if you do not provide any regular expression or any special routing on top of that,

00:14:54.780 --> 00:14:59.180
they just get served exactly where you will find the object itself.

00:14:59.180 --> 00:15:09.360
So if I see a user new URL, I know that it will be properly served by the new method inside the user file,

00:15:09.360 --> 00:15:17.100
and I can go there and start doing whatever I need to do without needing to understand the structure of the project and things like that.

00:15:18.100 --> 00:15:29.580
And this philosophy of having a framework which is easy for big projects and for people having to get started on an already existing project

00:15:29.580 --> 00:15:39.240
is also visible on the template engine, because TurboGears uses one of the few template engines that is able to validate your HTML code.

00:15:39.240 --> 00:15:47.960
So if you did something wrong with your HTML code, you do not discover it when you see the page and see that it's actually broken.

00:15:47.960 --> 00:15:53.000
But you discover it at compile time when the template engine is compiled.

00:15:53.000 --> 00:15:55.900
It will provide you with errors, for example.

00:15:55.900 --> 00:15:58.980
You forgot to close the tag or things like that.

00:15:59.680 --> 00:16:00.820
Oh, that's really cool.

00:16:00.820 --> 00:16:04.440
Yeah, you know, I'm a big fan of both Pyramid and Flask.

00:16:04.440 --> 00:16:11.160
This thing that you point out about the routing is, it is really annoying to have to configure that somewhere else

00:16:11.160 --> 00:16:16.340
rather than just, hey, the way my files are laid out, boom, this is how it works, right?

00:16:16.340 --> 00:16:17.380
Which is really, really nice.

00:16:17.380 --> 00:16:19.220
And then down into the classes and so on.

00:16:19.760 --> 00:16:28.740
So in TurboGears, you've got sort of the way of writing code that handles the requests are by creating controller classes, right?

00:16:28.740 --> 00:16:34.480
So you derive from like a base class and then you add methods to that base class, right?

00:16:34.480 --> 00:16:35.360
Exactly.

00:16:35.360 --> 00:16:42.460
Of course, not everything that you write in your class is exposed as a URL because that would be a security issue.

00:16:42.680 --> 00:16:47.760
But you can easily make things from a method to a web page.

00:16:47.760 --> 00:16:53.480
The difference is just you have to put a decorator on top of the method and it becomes available.

00:16:53.480 --> 00:16:57.000
Yeah, I really like the way that you guys are doing that there.

00:16:57.000 --> 00:16:57.520
That's cool.

00:16:57.520 --> 00:17:04.960
The other thing that you mentioned that's pretty nice is the templating engine is sort of self-verifying.

00:17:04.960 --> 00:17:09.420
Like I'm using the Chameleon templates right now on my website.

00:17:09.420 --> 00:17:14.060
And if something goes wrong, it's usually just a 500 server error.

00:17:14.060 --> 00:17:16.980
You know, something is wrong.

00:17:16.980 --> 00:17:17.840
Sorry.

00:17:17.840 --> 00:17:18.140
Yeah.

00:17:18.140 --> 00:17:23.480
It's really hard often to track down what's going on when you get that wrong.

00:17:23.480 --> 00:17:26.960
Sometimes it gives you a good error message and sometimes it doesn't.

00:17:26.960 --> 00:17:33.660
Well, you are already lucky because I remember that when I started working with Ruby on Rails,

00:17:33.660 --> 00:17:37.380
there was Herb, which was the template engine.

00:17:37.380 --> 00:17:40.900
And if something was wrong, you actually didn't get any error.

00:17:40.900 --> 00:17:44.040
Your users were a broken page and nothing else.

00:17:44.040 --> 00:17:48.400
So at least Chameleon provides you errors.

00:17:48.400 --> 00:17:54.820
And what Genshi and the template engine to Ruby is using, try to do,

00:17:54.820 --> 00:18:00.000
is actually trying to parse the structure of your file.

00:18:00.380 --> 00:18:03.640
So your template must be valid HTML.

00:18:03.640 --> 00:18:07.740
And they parse it and they try to understand how it's made.

00:18:07.740 --> 00:18:09.520
They try even to optimize it.

00:18:10.220 --> 00:18:13.040
And they point out the exact error.

00:18:13.040 --> 00:18:16.040
Like you forgot to close this tag at this line.

00:18:16.040 --> 00:18:18.840
So you know where something was broken.

00:18:18.840 --> 00:18:25.260
And as they actually parse the code, when you need to translate your web page,

00:18:25.260 --> 00:18:30.840
it's really, really easy because everything which is inside the tag can be translated.

00:18:31.140 --> 00:18:35.640
You don't have to mark with get text calls and things like that around.

00:18:35.640 --> 00:18:39.640
If it is inside the call, it's a string that can be translated.

00:18:39.880 --> 00:18:41.480
Yeah, that's really excellent.

00:18:41.480 --> 00:18:44.420
So I don't know much about that template engine.

00:18:44.420 --> 00:18:49.440
Is it possible to write like semi-structured HTML5?

00:18:49.440 --> 00:18:52.780
Or does it have to be sort of pure XHTML?

00:18:52.780 --> 00:18:58.500
So for example, with like HTML5, it's fine to just put like an angle bracket BR

00:18:58.500 --> 00:19:04.000
with no, you know, closing, like auto-closing slash or self-closing slash

00:19:04.000 --> 00:19:05.280
and things like that.

00:19:05.620 --> 00:19:07.100
What's the story around that?

00:19:07.100 --> 00:19:20.860
This episode is brought to you by Hired.

00:19:20.860 --> 00:19:25.860
Hired is a two-sided curated marketplace that connects the world's knowledge workers

00:19:25.860 --> 00:19:27.380
to the best opportunities.

00:19:27.380 --> 00:19:31.660
Each offer you receive has salary and equity presented right up front.

00:19:31.860 --> 00:19:36.480
And you can view the offers to accept or reject them before you even talk to the company.

00:19:36.480 --> 00:19:40.880
Typically, candidates receive five or more offers in just the first week.

00:19:40.880 --> 00:19:42.840
And there are no obligations ever.

00:19:42.840 --> 00:19:44.940
Sounds pretty awesome, doesn't it?

00:19:44.940 --> 00:19:47.020
Well, did I mention there's a signing bonus?

00:19:47.020 --> 00:19:51.100
Everyone who accepts a job from Hired gets a $2,000 signing bonus.

00:19:51.100 --> 00:19:55.420
And as Talk Python listeners, it gets way sweeter.

00:19:56.340 --> 00:20:02.980
Use the link Hired.com slash Talk Python To Me and Hired will double the signing bonus to $4,000.

00:20:02.980 --> 00:20:04.700
Opportunities knocking.

00:20:04.700 --> 00:20:08.320
Visit Hired.com slash Talk Python To Me and answer the call.

00:20:18.620 --> 00:20:24.620
Well, actually, if you're using Genshi, which is the default template engine for Google years,

00:20:24.620 --> 00:20:29.500
you will have to write perfectly structured HTML files.

00:20:29.500 --> 00:20:34.040
So you need to close your tags in line and things like that.

00:20:34.040 --> 00:20:40.320
That's to actually tell to Genshi that you didn't forget to close the tag, but you did it on purpose.

00:20:41.320 --> 00:20:49.600
But that's for that specific reason, because a great engine needs to be really structured and well validated.

00:20:49.600 --> 00:21:03.180
Then if you want to output HTML5 and maybe avoid closing your head, avoid closing your body, or things like that,

00:21:03.180 --> 00:21:08.220
you can just tell Google years to output the result in HTML5 mode.

00:21:08.220 --> 00:21:10.260
And it will do that for you.

00:21:10.260 --> 00:21:20.820
That might be even considered a really powerful feature, because if you want to switch from HTML5 to XHTML or even HTML4,

00:21:20.820 --> 00:21:23.900
you just have to change the configuration options.

00:21:23.900 --> 00:21:28.040
And this template engine will output the code you ask him to do.

00:21:28.480 --> 00:21:29.520
That's really cool.

00:21:29.520 --> 00:21:35.380
You know, I personally don't mind at all writing, you know, properly structured XHTML,

00:21:35.380 --> 00:21:38.580
because I feel like I have, like you said, control I can check.

00:21:38.580 --> 00:21:40.140
Okay, this is exactly right.

00:21:40.140 --> 00:21:44.140
I guess it's probably a personal preference, but I like it.

00:21:44.140 --> 00:21:44.660
Yeah.

00:21:45.240 --> 00:21:53.380
So another one of the goals you guys had when you created TurboGear's 2 was, you said you want, unlike things like Django and Rails,

00:21:53.380 --> 00:21:58.120
you want to be able to start as a micro framework, but scale up to a full stack solution.

00:21:58.120 --> 00:21:59.180
What does that mean?

00:21:59.900 --> 00:22:04.340
Well, actually, when TurboGear's was created, it was totally a full stack framework.

00:22:04.340 --> 00:22:07.300
So it got started as full stack.

00:22:07.300 --> 00:22:16.600
But as the community started moving forward more API development and web services and things like that,

00:22:16.600 --> 00:22:26.220
it was clear that a full stack framework is far more complex than what you need to get started with a prototype on an API or similar things.

00:22:26.220 --> 00:22:33.440
And then when we rewrote TurboGear's in version 2.3 removing pylons,

00:22:33.440 --> 00:22:39.400
and we took the chance to rewrite everything on top of a core,

00:22:39.400 --> 00:22:46.420
which would make possible to have something which is a micro framework,

00:22:46.420 --> 00:22:54.420
so which provides everything you would expect, like a routing, like the configuration of your application,

00:22:54.420 --> 00:23:02.760
but doesn't provide additional features like the template engine or the caching layer or things like that,

00:23:02.760 --> 00:23:09.080
which you can turn on and turn off and replace with whatever library you want whenever you want.

00:23:09.080 --> 00:23:17.760
For example, if I start to a new TurboGear's project, I will get it with Genshi, which is the default template engine.

00:23:17.760 --> 00:23:25.340
Now if I want to use like Macro or Jinja or things like that, because I prefer to work with them,

00:23:25.340 --> 00:23:33.340
I can actually start with a project that uses them instead of Genshi, and everything will work anyway.

00:23:33.340 --> 00:23:40.440
Because when working as a micro framework, you actually do not have any template engine at the beginning.

00:23:40.440 --> 00:23:49.860
You register one, and registering it just means enabling an option, and you get started with that one.

00:23:49.860 --> 00:23:57.300
For if you want to turn on also database because you need SQL Archemy, you turn on another option, and SQL Archemy is enabled.

00:23:57.300 --> 00:24:02.020
If you want to use something which TurboGear doesn't support at the moment,

00:24:02.020 --> 00:24:10.160
you can just set up itself like you would with any other microframe or by flask or bottle or things like that.

00:24:10.160 --> 00:24:12.140
Yeah, that's cool.

00:24:12.140 --> 00:24:18.780
So if I want to, I could just create a single Python file, create a class, which is a controller,

00:24:18.780 --> 00:24:24.440
and have a single method on there and give it the expose decorator,

00:24:24.940 --> 00:24:27.980
and more or less just, say, serve that.

00:24:27.980 --> 00:24:34.260
And then I don't have the overhead of the database libraries, all the templating stuff.

00:24:34.260 --> 00:24:37.440
All those different things are kind of not there.

00:24:37.440 --> 00:24:43.460
So if I were writing like a really, really simple JSON-based service or something, maybe that would make sense.

00:24:43.460 --> 00:24:44.760
Yeah.

00:24:44.760 --> 00:24:47.460
Let me tell you an example.

00:24:47.460 --> 00:24:58.720
Yesterday, one of the guys in our team needed a little tool to preview the result of a bootstrap theme he was working on.

00:24:58.720 --> 00:25:10.560
And then I just created a quick and dirty file with TurboGear to render the theme, replacing some variables through the template engine and nothing else.

00:25:10.560 --> 00:25:12.980
So I started with the microframework mode.

00:25:12.980 --> 00:25:16.580
I started with what's called minimal mode in TurboGear.

00:25:17.100 --> 00:25:24.480
Then we decided that it would have been cool to be able to upload multiple versions of the template and switch between them

00:25:24.480 --> 00:25:30.380
and see the differences proposed to the other team members, which one was better and so on.

00:25:30.380 --> 00:25:34.280
And to do that, we needed the database where to register everything.

00:25:34.280 --> 00:25:41.460
We needed a crude where to create and update and modify the themes and things like that.

00:25:41.460 --> 00:25:44.540
So I just switched to the full-strap framework.

00:25:44.740 --> 00:25:49.200
I enabled the TurboGear's admin and I got the code for free.

00:25:49.200 --> 00:25:51.460
I got the database set up for me.

00:25:51.460 --> 00:26:06.900
And I have been able to create a full application in half an hour, starting from a single file and then moving to a full-strap application with login registration, multiple crowds, and so on.

00:26:07.120 --> 00:26:08.660
Yeah, that's really interesting.

00:26:08.660 --> 00:26:14.940
Because I think there's these two camps or two philosophies in Python web frameworks.

00:26:15.500 --> 00:26:22.360
You've got things like Django, which are super full-strap, super comprehensive.

00:26:22.360 --> 00:26:25.180
They even have admin backends and user management.

00:26:25.180 --> 00:26:27.400
And they're big things, right?

00:26:27.860 --> 00:26:37.920
And then on the other hand, you've got things like Flask and Bottle that are just very, very focused on, we will get the request to your method and then it's up to you.

00:26:37.920 --> 00:26:39.680
You know, to some degree, right?

00:26:39.680 --> 00:26:44.600
And so the ability to not rewrite that, go, well, it was working in Flask, but we need more.

00:26:44.600 --> 00:26:46.120
So, whoop, off we go to Django.

00:26:46.920 --> 00:26:48.400
But you just sort of grow it.

00:26:48.400 --> 00:26:49.300
That's a pretty cool idea.

00:26:49.300 --> 00:26:50.300
Yeah.

00:26:50.300 --> 00:26:54.220
That's one of our objectives, what we are trying to do.

00:26:54.220 --> 00:26:55.080
Yeah.

00:26:55.080 --> 00:27:03.880
Another one that you have is you said you want to make sure that the code that you write for the web framework is code that is as natural as writing just a function.

00:27:03.880 --> 00:27:04.700
Yeah.

00:27:04.700 --> 00:27:10.400
Well, that's one of the philosophies behind the object dispatch system and so on.

00:27:10.920 --> 00:27:20.640
We don't want people to have to mess with things like person parameters or the dispatch itself or things like that.

00:27:20.640 --> 00:27:37.360
You just want a web page that accepts some parameters and you can get them through a get URL encoded method or you can get them in the body of the post or whatever.

00:27:37.360 --> 00:27:38.380
It doesn't matter.

00:27:38.560 --> 00:27:45.720
You just want some parameters to your code and you want to return something when that parameters arrive.

00:27:45.720 --> 00:27:51.920
So, we really think that writing a web page is much like writing a Python method.

00:27:51.920 --> 00:27:54.800
You get something and you output something else.

00:27:54.800 --> 00:27:57.620
So, Python methods are perfect for doing that.

00:27:58.240 --> 00:28:08.600
And so, to produce actually just whatever parameter you get into your page, it gets converted to an argument of your methods with the same name.

00:28:08.600 --> 00:28:15.880
And whatever you return from your method is actually just a response of your web page.

00:28:15.880 --> 00:28:16.560
Yeah.

00:28:16.560 --> 00:28:17.460
That's interesting.

00:28:17.460 --> 00:28:32.100
So, suppose I've got a user controller and a method called show and it's supposed to show the details of the user and I want to pass like the user ID to go maybe to a database and pull it out.

00:28:32.100 --> 00:28:37.560
What is, could I have like user ID in the method for my show method?

00:28:37.560 --> 00:28:38.080
Yeah.

00:28:38.080 --> 00:28:44.480
You will just have a parameter which is an argument of your method which is named user ID, for example.

00:28:44.480 --> 00:28:50.940
If I pass in the URL a user ID parameter, that will be the value of your argument.

00:28:51.560 --> 00:29:04.740
Or, as Python supports position arguments, if you pass forward slash one, one will go into the user ID parameter as it is the first argument of the function.

00:29:04.740 --> 00:29:05.780
That's awesome.

00:29:05.780 --> 00:29:18.640
Yeah, I really like that because, you know, like I said, I'm a fan of Pyramid, but it's kind of challenging to get, you know, the route data and the post data and all those different things like gathered back up.

00:29:18.640 --> 00:29:21.560
So, you can start actually, you know, processing the request.

00:29:21.560 --> 00:29:22.460
So, that's really cool.

00:29:22.460 --> 00:29:29.440
Another one of your philosophies is you wanted a powerful and flexible ORM with real multi-database support.

00:29:29.440 --> 00:29:30.840
What's the story there?

00:29:30.840 --> 00:29:40.180
When we started, one of the main issues with SQL Object was actually that it was not as flexible as SQLAlchemy.

00:29:40.420 --> 00:29:59.800
And when we moved to SQLAlchemy, we saw that it was really simple to set up something like master-slave configurations on SQLAlchemy and the route and methods and queries depending on what we were doing through the SQLAlchemy session and things like that.

00:29:59.800 --> 00:30:06.760
So, when you are used Turbo Gears, you actually get out of the box something like the master-slave support.

00:30:06.760 --> 00:30:13.640
Whenever a method does only read, it will be rooted to the slaves by Turbo Gears itself.

00:30:13.640 --> 00:30:14.900
It is tried.

00:30:14.900 --> 00:30:21.140
If it tries to write something, it will be rooted to the master of your database configuration.

00:30:21.140 --> 00:30:35.360
And that's possible thanks to the SQLAlchemy unit of work because at the end of the request, when the unit of work is flushed, you know if it contains only reads or it will contain any change of the documents.

00:30:35.360 --> 00:30:39.620
And so, you can decide where you should perform those operations.

00:30:40.540 --> 00:30:42.420
Yeah, SQLAlchemy is pretty awesome.

00:30:42.420 --> 00:30:49.900
And that whole unit of work idea and auto-commit or auto-rollback of transactions on errors, there's a lot of really neat stuff.

00:30:49.900 --> 00:30:51.380
That's cool that you're leveraging that.

00:30:51.380 --> 00:30:57.020
Yeah, and that's also something we are trying to leverage also MongoDB.

00:30:57.020 --> 00:31:05.020
That's the reason why we choose Ming as the MongoDB library for Turbo Gears because that's pretty much the same concept.

00:31:05.020 --> 00:31:10.540
You get an identity map, so you don't have duplicates in your code.

00:31:10.540 --> 00:31:22.900
You get a unit of work, so you can flush all your changes at the end and have a single optimized set of actions instead of replicating the updates to your database.

00:31:22.900 --> 00:31:29.240
And you can decide to perform something when the changes are flushed and things like that.

00:31:29.240 --> 00:31:30.900
Yeah, that's really cool.

00:31:30.900 --> 00:31:34.820
And I think it's great that you support MongoDB and get a choice.

00:31:34.820 --> 00:31:40.780
So, sort of the whole relational database story is covered by SQLAlchemy, which is pretty comprehensive.

00:31:40.780 --> 00:31:47.980
And then if you want good NoSQL integration, nice document database, well, MongoDB is pretty straightforward choice, right?

00:31:47.980 --> 00:31:52.560
Yeah, actually, I've been using MongoDB for years now.

00:31:52.840 --> 00:32:02.020
And then, like, 70% of the web applications I'm starting are based on MongoDB because it's a really powerful and convenient technology.

00:32:02.020 --> 00:32:09.360
And so, I wanted to go to use Web as much support for MongoDB as it had for SQLAlchemy.

00:32:09.360 --> 00:32:31.400
And as we have a middleware, which is called Sprox, which permits to convert the queries in the two formats, it was not so difficult to provide support for MongoDB in most TurboGias extensions, like the TurboGias admin or the registration module or things like that.

00:32:31.400 --> 00:32:39.860
So, whenever you plug an extension into TurboGias, you can be pretty sure that it will probably work with MongoDB too.

00:32:40.580 --> 00:32:41.040
Yeah, that's excellent.

00:32:41.040 --> 00:32:41.400
Yeah, that's excellent.

00:32:41.400 --> 00:32:43.020
And I totally agree with you.

00:32:43.020 --> 00:32:52.300
Like, at least 75% of the time, if I'm doing a new web app and it needs a database, you know, I need a reason not to use MongoDB, not a reason to use it, you know?

00:32:52.300 --> 00:32:54.400
Yeah, it's the same for me.

00:32:54.400 --> 00:32:55.740
Yeah, it's awesome.

00:32:56.620 --> 00:33:03.520
So, another thing you talked about is sort of built-in support for horizontal data partitioning or what's known as sharding.

00:33:03.520 --> 00:33:13.980
So, that's actually something that's not strictly related to TurboGias itself, as we say, because it's another of those features which SQLAlchemy makes possible.

00:33:13.980 --> 00:33:38.060
But as TurboGias works on the concept of having one or multiple database sessions available, if you want to work on different nodes of your database and perform sharding, you can just set up different database sessions, one for each shard, and register your models on one session or the other.

00:33:38.060 --> 00:33:52.500
And whenever you perform a query on this or that model or whatever any extension, the admin or whatever you're using performs a query on that model, it will know that it has to perform that query on that database shard.

00:33:52.500 --> 00:33:54.300
Yeah, that's really cool.

00:33:54.300 --> 00:33:56.460
And that works with relational databases as well?

00:33:56.460 --> 00:33:59.840
Well, for MongoDB, it works really simple.

00:33:59.840 --> 00:34:09.520
And while for SQLAlchemy, you actually lose the ability to perform joins when doing that because you're actually storing the data scattered across multiple databases.

00:34:09.520 --> 00:34:10.960
Yeah.

00:34:10.960 --> 00:34:11.400
Okay.

00:34:11.400 --> 00:34:17.680
Yeah, you definitely have to give up a little bit on the relational side, which is kind of what the NoSQL databases are doing anyway to get better.

00:34:17.680 --> 00:34:18.780
So, it's all good.

00:34:18.780 --> 00:34:19.500
It's all good with me.

00:34:19.500 --> 00:34:25.040
So, one of the other things you talked about is support for multiple data exchange formats.

00:34:25.260 --> 00:34:29.640
Is that kind of like the hypermedia component of REST?

00:34:29.640 --> 00:34:39.200
Like, I could do a GET against a URL and have the accept type as image or the accept type as JSON and have it return different stuff based on that?

00:34:39.200 --> 00:34:40.360
Yeah.

00:34:40.360 --> 00:34:50.800
Actually, something like that because the routing of TurboGirth itself permits to register multiple expositions of your method.

00:34:51.500 --> 00:34:55.380
And so, your method is able to respond like three different things.

00:34:55.380 --> 00:34:56.800
You can return a webpage.

00:34:56.800 --> 00:35:01.920
You can return a PDF file or you can return whatever you want.

00:35:01.920 --> 00:35:11.340
And whenever the routing understands that there is an accept header or any other reason, for example, it also works by the extension.

00:35:11.340 --> 00:35:21.320
If I put .json at the end of my URL, the TurboGirth will try to route to something which is able to respond as JSON.

00:35:21.320 --> 00:35:29.800
So, if your method is able to respond to HTML and JSON, it will serve you the JSON version if the URL ends with JSON.

00:35:29.800 --> 00:35:34.700
Or if the URL has an accept header that says I only accept JSON.

00:35:34.700 --> 00:35:36.740
Yeah, that's a really cool feature.

00:35:36.740 --> 00:35:37.340
I love that.

00:35:38.620 --> 00:35:44.840
Maybe we could talk a little bit about the different, how TurboGirth compares against the different frameworks.

00:35:44.840 --> 00:35:51.740
Well, we already saw a lot of the things that TurboGirth does different from the other frameworks.

00:35:51.740 --> 00:35:58.840
But I think that the core part is the philosophy of making everything really, really simple.

00:35:58.840 --> 00:36:06.100
TurboGirth tries to be really simple for simple things while making complex things possible.

00:36:06.760 --> 00:36:11.340
So, you have routing receive just writing a method.

00:36:11.340 --> 00:36:15.340
You have a template engine which is a check server for you.

00:36:15.340 --> 00:36:21.720
You have a strong integration with the database, but you can even turn it off if you want.

00:36:21.720 --> 00:36:26.980
So, it's really just a different way of balancing things.

00:36:27.340 --> 00:36:33.440
I would not say that there is something in TurboGirth you cannot do in Django or something you cannot do in Flask.

00:36:33.440 --> 00:36:36.580
It's just a different way of balancing the features.

00:36:36.580 --> 00:36:43.080
Like, Django is much more on get up quickly and start with what you have to do.

00:36:43.080 --> 00:36:46.240
While Flask is more get maximum flexibility.

00:36:46.920 --> 00:36:58.320
TurboGirth tries to be a little bit in the middle, balancing between everything should be quick, but you can have an option to turn it off and do it your way.

00:36:58.320 --> 00:36:59.300
Yeah.

00:36:59.300 --> 00:37:02.160
Yeah, that's that start as a micro framework, but grow.

00:37:02.160 --> 00:37:03.320
And that's very cool.

00:37:03.320 --> 00:37:07.840
So, do you want to talk about the future of TurboGirth and where things are going?

00:37:08.000 --> 00:37:15.720
Yeah, that's an interesting topic because we recently tried to switch to a frequent release cycle.

00:37:15.720 --> 00:37:21.720
So, during the last year, we tried to release a new version every three months.

00:37:21.720 --> 00:37:31.080
So, it's a really interesting change from the idea of releasing when you have feature risks to releasing at that time.

00:37:31.080 --> 00:37:32.680
Whatever you have, you have.

00:37:32.680 --> 00:37:33.840
It doesn't matter.

00:37:34.240 --> 00:37:44.620
But that's a really important switch because it made possible to see faster feedbacks and faster correction of errors and things like that.

00:37:44.620 --> 00:38:00.680
And so, it even made more important the do not break backward compatibility philosophy because with frequent releases, you will have frequent issues if you avoid sticking at that philosophy.

00:38:01.520 --> 00:38:16.400
And so, right now, we recently referred, as I told you, from Pylons, which was using TurboGirth 2.2, to a totally separated core, which is written by the TurboGirth team itself.

00:38:16.400 --> 00:38:19.100
Because we wanted to support Python 3.

00:38:19.100 --> 00:38:27.220
And as we know, Pylons itself will never support Python 3, probably, because it now merged with the Pyramid project.

00:38:27.520 --> 00:38:28.700
Right, right.

00:38:28.700 --> 00:38:34.700
And by the way, thank you for making Python 3 such a key part of the effort.

00:38:34.700 --> 00:38:38.260
I think, you know, things are moving in that way.

00:38:38.260 --> 00:38:45.780
But everyone's got to do a little bit of work like you're talking about here to make it actually a common reality, right?

00:38:45.780 --> 00:39:02.200
This episode is brought to you by CodeShip.

00:39:02.200 --> 00:39:11.040
CodeShip has launched organizations, create teams, set permissions for specific team members, and improve collaboration in your continuous delivery workflow.

00:39:11.640 --> 00:39:16.940
Maintain centralized control over your organization's projects and teams with CodeShip's new organizations plan.

00:39:16.940 --> 00:39:22.480
And as Talk Python listeners, you can save 20% off any premium plan for the next three months.

00:39:22.480 --> 00:39:26.000
Just use the code TALKPYTHON, all caps, no spaces.

00:39:26.000 --> 00:39:31.720
Check them out at CodeShip.com and tell them thanks for supporting the show on Twitter where they're at, CodeShip.

00:39:37.860 --> 00:39:45.900
I think that right now you can start doing practically everything on Python 3 and use it day by day.

00:39:45.900 --> 00:39:53.680
But I see a lot of people still scared by the change, still unsure if they should do it or not.

00:39:53.680 --> 00:40:06.060
And so it's more like a people problem than a technology problem because the technology is there and the most common frameworks and libraries are available.

00:40:06.060 --> 00:40:08.100
But you're still unsure.

00:40:08.100 --> 00:40:10.660
You still have the question, and if?

00:40:10.660 --> 00:40:14.800
If I find something which is missing, what will I do?

00:40:15.560 --> 00:40:19.200
Yeah, I think there's definitely the painful history of it.

00:40:19.200 --> 00:40:23.600
But my philosophy these days is the same as with manga.

00:40:23.600 --> 00:40:25.700
Like, I need a reason not to use Python 3.

00:40:25.700 --> 00:40:29.920
So if I'm going to start something new, it'll also go down that route.

00:40:29.920 --> 00:40:30.640
That's cool, though.

00:40:30.640 --> 00:40:31.020
Okay.

00:40:31.020 --> 00:40:36.480
So then you also had some ideas about the future of Genji and the templating, right?

00:40:37.600 --> 00:40:38.840
Yeah, that's one.

00:40:38.840 --> 00:40:47.460
It's again related to Python 3 because it's really sad that the Genji project is not moving forward a lot recently.

00:40:47.460 --> 00:40:55.560
Actually, they have a few fixes and changes for compatibility with Python 3.4 and Python 3.5.

00:40:55.980 --> 00:40:59.760
But there is not going to be a release soon as far as I know.

00:40:59.760 --> 00:41:05.180
They are trying to get back on track, and I saw that they are talking about moving Genji to GitHub.

00:41:05.180 --> 00:41:09.540
But still, it's unsure if it will happen and when it will happen.

00:41:09.540 --> 00:41:19.920
So as we want to stick to a framework that has the same features and we want to stick to the template engine that works with the same way,

00:41:19.920 --> 00:41:33.560
we are actually experimenting with various different template engines that will make possible to migrate your project from Genji to another template engine without having to change much of your code.

00:41:33.560 --> 00:41:43.080
For example, we are experimenting with Kajiki, which has been created one of the past two years contributors, which is the Rick Copeland.

00:41:43.860 --> 00:41:50.860
And we are trying to provide a quick way to move away from Genji to Kajiki without having to change everything.

00:41:50.860 --> 00:41:55.840
We have a command in Gearbox, which is the toolset for TurboGear.

00:41:55.840 --> 00:42:03.540
So you have a command to upgrade your templates from Genji to Kajiki, and you don't have to change anything else.

00:42:03.540 --> 00:42:16.540
The command will move the templates from one to the other, much like the conversion tool moves your code from Python 2 to Python 3 and things like that.

00:42:16.540 --> 00:42:20.260
But still, we are still experimenting.

00:42:20.260 --> 00:42:23.660
So currently, both of them are available in TurboGear.

00:42:23.660 --> 00:42:29.600
So when you start a project, you can choose to use whatever you want, and Genshin is still the default.

00:42:29.600 --> 00:42:42.840
But it's just a possibility we have in case we will need to take another choice due to Python 3 support and Python evolution.

00:42:42.840 --> 00:42:54.060
Speaking of Python 3, one of the really cool features is the async and await sort of parallelism concurrency stuff.

00:42:54.060 --> 00:42:58.140
Is there any way to incorporate that into TurboGear's?

00:42:58.140 --> 00:43:09.260
Well, currently, TurboGear has been support for G-Event for a lot of time, but we do not have any support for a SyncIO.

00:43:09.260 --> 00:43:11.400
We are thinking about that.

00:43:11.400 --> 00:43:23.560
We are still in a research phase because we are not sure that it will be such an easy thing to achieve on everything of the framework.

00:43:23.560 --> 00:43:39.880
For example, you can already put in front of TurboGear's a WISG-E server, which is based on a SyncIO and that your application is set asynchronously.

00:43:39.880 --> 00:43:47.640
But that wouldn't provide any much benefit because your I.O. through the database or things like that will still block.

00:43:47.640 --> 00:43:50.060
So it doesn't make a lot of sense.

00:43:51.120 --> 00:44:07.940
And so it's much more a problem of the technologies available than of TurboGear's itself because until SQLAlchemy, for example, provides full support for a SyncIO, we cannot provide support for a SyncIO and things like that.

00:44:08.100 --> 00:44:14.160
Yeah, that makes sense because those are the places you really want to use a SyncIO anyway, right?

00:44:14.160 --> 00:44:14.480
Yeah.

00:44:14.480 --> 00:44:16.720
It's all the database calls and things like that.

00:44:16.720 --> 00:44:17.680
Yeah.

00:44:19.340 --> 00:44:26.200
Somewhat related to that is the whole HTTP2 thing that's coming, right?

00:44:26.200 --> 00:44:33.800
Where a single request can come in and it can actually process many files and so on.

00:44:33.800 --> 00:44:45.160
So like maybe the browser makes a request to the server and it gets the main page, but then it also gets like the CSS files and the JavaScript and, you know, a different style of processing.

00:44:46.360 --> 00:44:52.700
And I don't know if any of the WSGI servers support that yet.

00:44:52.700 --> 00:44:54.800
I don't know of any that do.

00:44:54.800 --> 00:45:00.620
What do you see about TurboGear's WSGI and HTTP2 coming down the road?

00:45:00.620 --> 00:45:13.200
Well, that's actually a really interesting question because it's such a big change because you're actually multiplexing multiple requests inside the same channel.

00:45:14.060 --> 00:45:18.740
That probably is not enough to rethink your HTTP server.

00:45:18.740 --> 00:45:22.780
You should also rethink your communication channel.

00:45:22.780 --> 00:45:24.420
You should rethink WSGI.

00:45:24.420 --> 00:45:32.260
You should rethink a lot of the way the current Python web application works.

00:45:32.260 --> 00:45:36.800
So it's not something that only matters to the web framework.

00:45:37.040 --> 00:45:43.480
It's probably something that matters far less to the web framework than to the WSGI protocol itself.

00:45:43.480 --> 00:45:54.180
I mean, WSGI, as we know, doesn't have a great support for things like asynchronous or interleaved requests and things like that.

00:45:54.740 --> 00:46:05.580
But we have been able to cope for the past years and still go on supporting things like WebSocket or protocol evolution and things like that.

00:46:05.580 --> 00:46:09.540
But here we are talking about a much bigger change.

00:46:09.540 --> 00:46:12.680
We are talking about, like, it doesn't work anymore.

00:46:12.960 --> 00:46:16.980
It's not like a common idea of, here is your request, give me your response.

00:46:16.980 --> 00:46:20.080
It's much like, here is a part of your request.

00:46:20.080 --> 00:46:23.880
And then you can get a part of another request, totally different request.

00:46:23.880 --> 00:46:26.400
And you should interleaved them.

00:46:26.400 --> 00:46:34.240
And you should be able to start processing one while you still are waiting for the other and so on.

00:46:34.240 --> 00:46:40.600
So it probably requires a much different programming model, which actually AsyncIO might help achieving.

00:46:40.600 --> 00:46:49.060
Yeah, I was just thinking as you were talking there that, you know, when you get to that level, AsyncIO might be the thing required to unlock that in Python.

00:46:49.060 --> 00:46:56.160
Because the threading story is not super easy to just, you know, kick that off as a bunch of threaded requests, right?

00:46:56.160 --> 00:46:59.980
You need some way to sort of interleave those reasonably, right?

00:46:59.980 --> 00:47:01.680
Yeah, exactly.

00:47:02.280 --> 00:47:16.480
And all these changes in the Python world and in the web development world are the reason why I'm also thinking about rewriting for the 2.4 version of TurboGios, the config system.

00:47:16.480 --> 00:47:24.280
Because so far, the TurboGios config system has been pretty hard, well-structured, much like the Django config system.

00:47:24.280 --> 00:47:28.880
You have a bunch of options, which you can set to turn on and turn off feature.

00:47:28.880 --> 00:47:31.820
Then you can register middleware, some things like that.

00:47:32.160 --> 00:47:37.000
But the configuration itself stops to something like options and things like that.

00:47:37.000 --> 00:47:50.440
While I would like to achieve something more similar to the way Pyramid works, where you can register even pieces of your configuration process and extend your configuration process and things like that.

00:47:50.440 --> 00:47:59.280
Which I thought I needed to evolve to evolve to different technologies and things like switch to a different programming part in the like,

00:47:59.280 --> 00:48:01.280
like, Helsinki or HTTP2.

00:48:01.280 --> 00:48:08.080
And it will make possible for people to go on using TurboGios even in the future.

00:48:08.080 --> 00:48:12.920
And even when they have to switch to a different way.

00:48:12.920 --> 00:48:14.920
And even when they have to switch to a different way to the way to the server.

00:48:14.920 --> 00:48:21.920
Like, you can enable by plugging an additional configuration step in your configuration and setup system.

00:48:21.920 --> 00:48:26.920
It's going to be an interesting time when it switches to HTTP2, isn't it?

00:48:26.920 --> 00:48:31.760
Yeah, it definitely will be.

00:48:31.760 --> 00:48:39.300
I think we are in an interesting moment for web development because it's still exploring where it has to go.

00:48:39.300 --> 00:48:42.480
We are no more at the time of websites.

00:48:42.480 --> 00:48:47.140
We are not yet at the time of whatever it will be in the future.

00:48:47.140 --> 00:48:52.280
We are still in the most interesting period, probably.

00:48:52.280 --> 00:48:54.420
Yeah, it's a great time to be a developer.

00:48:54.420 --> 00:49:00.980
I feel like, you know, there was in the early web, like everybody thought the web was a brochure, right?

00:49:00.980 --> 00:49:03.220
It was like a document and it was just fixed.

00:49:03.220 --> 00:49:08.420
And then now we know it can be so much more, but we haven't really gotten it, right?

00:49:08.420 --> 00:49:09.940
Yeah, exactly.

00:49:09.940 --> 00:49:10.780
Yeah, yeah.

00:49:10.780 --> 00:49:11.200
Very cool.

00:49:11.200 --> 00:49:17.220
So let's talk about some of the other things that you have going on, some other open source projects, maybe.

00:49:17.880 --> 00:49:23.720
So you already talked about Kajiki, how do you say Rick Copeland's template engine?

00:49:23.720 --> 00:49:28.040
I would probably say it's Kajiki, but I'm not sure.

00:49:28.040 --> 00:49:28.940
Yeah, yeah, yeah, okay.

00:49:28.940 --> 00:49:30.540
Kajiki, yeah, Kajiki.

00:49:30.540 --> 00:49:34.580
So just for people listening, that's K-A-J-I-K-I.

00:49:34.580 --> 00:49:37.600
And I'll put the link in the website.

00:49:37.600 --> 00:49:40.260
So we already talked about that one, but then you have some other ones.

00:49:40.260 --> 00:49:41.140
You have one called Depot.

00:49:41.140 --> 00:49:42.060
What's that?

00:49:43.200 --> 00:49:55.400
Well, Depot is a really interesting project because like a year ago or so, we had a project we worked on that needed to switch file storage during the deployment.

00:49:55.400 --> 00:49:58.880
Actually, we developed everything, storing files locally.

00:49:58.880 --> 00:50:05.000
And then the customer decided that it wanted to go on a path that didn't support saving files.

00:50:05.360 --> 00:50:09.220
So we had to switch to something different for storing files.

00:50:09.220 --> 00:50:12.080
We wanted to go to grid.fs on MongoDB.

00:50:12.080 --> 00:50:14.400
And so we had to revise the code.

00:50:14.400 --> 00:50:23.320
And we did that like writing everything related to saving files the day before the go live of the project, which is not a really good idea.

00:50:23.320 --> 00:50:26.320
So we learned from that error.

00:50:26.320 --> 00:50:37.940
And we wanted to create a framework that made possible to save, read, and sell files in web applications without caring at all about where they are saved.

00:50:37.940 --> 00:50:39.700
And so we started Depot.

00:50:39.700 --> 00:50:43.460
I started working on Depot as just an abstraction layer.

00:50:43.460 --> 00:50:47.680
And it evolved on something much more powerful and much more convenient.

00:50:48.020 --> 00:50:52.700
For example, right now, Depot supports filters on your files.

00:50:52.700 --> 00:50:59.740
So you can, for example, add a filter that creates multiple thumbnails on your images when you upload them.

00:50:59.740 --> 00:51:08.680
Or you can integrate with the unit of work of SQLAlchemy because Depot has strict integration with MongoDB and SQLAlchemy.

00:51:08.680 --> 00:51:14.280
And whenever your transaction rolls back, even your files go back at the previous state.

00:51:14.400 --> 00:51:16.840
So a previous state of the file is recovered.

00:51:16.840 --> 00:51:25.320
Or if you uploaded a new file, it's automatically deleted for you whenever the column is deleted or the transaction is all bad.

00:51:25.320 --> 00:51:28.680
That is actually a seriously cool feature.

00:51:28.680 --> 00:51:30.600
Yeah, absolutely.

00:51:30.600 --> 00:51:34.280
And Depot started as an extension for TurboGios.

00:51:34.280 --> 00:51:42.320
But pretty early, I decided that it would benefit Pratica Any web framework because it didn't have any requirements on the framework itself.

00:51:42.320 --> 00:51:45.560
And now it's a library that you can use on top of everything.

00:51:45.560 --> 00:51:48.200
I know a lot of people are using it with Flask.

00:51:48.200 --> 00:51:53.780
And it was like just one configure command at the beginning of your web application.

00:51:53.780 --> 00:51:56.380
And you are Depot ready to save your files.

00:51:56.380 --> 00:51:57.600
Yeah, okay.

00:51:57.600 --> 00:51:58.760
That looks really cool.

00:51:58.760 --> 00:52:09.400
And the fact that it integrates with GridFS and the real file system makes me think you could point it at things like Cloud Blob Storage and other places pretty easily, right?

00:52:09.600 --> 00:52:13.460
Yeah, we also have support for S3, for example.

00:52:13.460 --> 00:52:16.800
And right now we have support for those three.

00:52:16.800 --> 00:52:26.040
But if you want to provide support for another storage, you can just subclass the storage class, provide your own, and register it with Depot.

00:52:26.040 --> 00:52:31.580
So if people want to have additional backends, it's totally possible and really, really simple.

00:52:31.960 --> 00:52:32.440
Okay.

00:52:32.440 --> 00:52:33.460
Yeah, that's really awesome.

00:52:33.460 --> 00:52:36.660
Another one that you have is DukePy.

00:52:36.660 --> 00:52:37.460
DukePy.

00:52:37.460 --> 00:52:49.500
Yeah, I started working DukePy again for my own needs because I'm now a really Python lover.

00:52:49.780 --> 00:52:51.580
I want to use Python for everything.

00:52:51.580 --> 00:52:52.140
Okay.

00:52:52.140 --> 00:53:02.180
So whenever I have on my system to set up Node.js just to compile my CoffeeScript, and right now I'm using mostly ECMAScript.

00:53:02.420 --> 00:53:13.720
So to compile my ECMAScript to the current version and things like that, I was really frustrated by the fact that I needed to set up Node.js just for that.

00:53:13.720 --> 00:53:27.200
To have Google or whatever you want to use to compile your REST pipeline and convert your SAS to CSS and unify your JS or whatever.

00:53:27.200 --> 00:53:38.260
Because Node is one of the environments where these tools are mostly available because they are being written by JavaScript developers.

00:53:39.100 --> 00:53:45.960
So I started to look around for a solution that would make possible to run those tools on Python.

00:53:45.960 --> 00:54:02.120
So take the CoffeeScript compiler and things like that and run it on Python so that I could also integrate in my middleware and directly serve the CoffeeScript file from my web framework without needing to pre-compile them and things like that.

00:54:02.120 --> 00:54:09.360
And I saw that the tools available at Python for that are not really simple to use.

00:54:09.360 --> 00:54:13.860
They are really, really powerful because we have a layer for SpiderMonkey.

00:54:13.860 --> 00:54:17.040
We have a layer for V8 and things like that.

00:54:17.040 --> 00:54:19.280
But it's not really easy to set them up.

00:54:19.280 --> 00:54:22.600
You need to compile a lot of dependencies and things like that.

00:54:23.360 --> 00:54:31.700
And then I started working with DuckTapes, which is a really simple JavaScript interpreter written in plain C.

00:54:31.700 --> 00:54:45.560
And I started embedding it in a toolkit, which is actually DuckPy, which you can just pip install and have a full working JavaScript interpreter in Python.

00:54:45.700 --> 00:54:47.820
So you can run JavaScript from Python.

00:54:47.820 --> 00:55:00.640
And the main difference from the other technology is you just need to pip install it and it will work because it's just a single file that gets compiled without any external dependency.

00:55:00.640 --> 00:55:02.800
Now that's a cool project.

00:55:02.800 --> 00:55:03.880
Yeah.

00:55:04.000 --> 00:55:14.940
And it provides out of the box when you pip install it, it already provides the Bevel.js compiler, the CoffeeScript compiler, and a few other tools built into the project itself.

00:55:14.940 --> 00:55:23.940
So you just pip install it and you can compile your ECMAScript 6 to ECMAScript 5 and go on working without the need of an external tool.

00:55:23.940 --> 00:55:24.600
Yeah, nice.

00:55:24.600 --> 00:55:25.620
I'm a fan of less.

00:55:25.620 --> 00:55:26.580
Does it support less?

00:55:27.340 --> 00:55:34.600
Well, currently we do not have less itself inside DuckPy because I'm actually a SAS SCSS user.

00:55:34.600 --> 00:55:38.940
So I use LibSAS, which is available for Python.

00:55:38.940 --> 00:55:47.940
But it's really easy to add it because you just have an execute function where you can pass the JavaScript code that gets executed.

00:55:47.940 --> 00:55:56.200
So you can pass the last compiler code to DuckPy and provide him with the input that needs to be compiled.

00:55:56.200 --> 00:55:59.300
And you will get back the soon with the compiled code.

00:55:59.300 --> 00:56:03.260
That's at least how it works for the Bevel.js compiler and so on.

00:56:03.260 --> 00:56:03.540
Yeah.

00:56:03.540 --> 00:56:03.960
Okay.

00:56:03.960 --> 00:56:04.580
Very cool.

00:56:04.580 --> 00:56:18.860
So if for some reason I want to serve less files and I set them up right in the system directly off of like talkpython.fm and I want to minify my JavaScript without actually running that.

00:56:18.860 --> 00:56:24.480
You know, I just push the real JavaScript unminified versions up there and I want them swished together.

00:56:25.040 --> 00:56:35.480
Could I just sort of set up some kind of web handler that when I saw a request for a JavaScript file it would cache and minify that and return it back using DuckPy?

00:56:35.480 --> 00:56:37.100
Yes, exactly.

00:56:37.100 --> 00:56:43.900
I'm actually using a framework which is called Web Assets, which is available for any web framework.

00:56:43.900 --> 00:56:46.760
You can set it on top of whatever you want.

00:56:47.420 --> 00:56:55.240
And it provides a middleware and a caching layer and whatever that compiles the assets through a bunch of filters.

00:56:55.240 --> 00:57:03.420
And so you can register a filter which uses DuckPy to compile your LAS or to compile your JavaScript.

00:57:03.420 --> 00:57:10.660
And Web Assets will provide all the caching and intelligence to understand whenever it changes and needs to be recompiled.

00:57:10.660 --> 00:57:11.760
Oh, that's really awesome.

00:57:11.760 --> 00:57:13.100
Okay.

00:57:13.100 --> 00:57:16.760
I'll add a link to all those things in the share notes.

00:57:16.960 --> 00:57:17.420
Very cool.

00:57:17.420 --> 00:57:21.440
Alessandro, we're getting pretty close to the end of the show.

00:57:21.440 --> 00:57:28.600
Do you have maybe some final call to actions or want to tell people what they should do to get started with TurboGear?

00:57:28.600 --> 00:57:36.840
Well, actually, there is only one call to action that I really want to tell people that want to get started with TurboGear,

00:57:36.840 --> 00:57:38.920
which is just ask.

00:57:38.920 --> 00:57:40.840
Ask for whatever you want.

00:57:40.840 --> 00:57:42.820
Ask for features and things like that.

00:57:42.880 --> 00:57:50.440
Because I think that one of the more important parts of a framework is actually that people complain about it.

00:57:50.440 --> 00:57:50.800
Okay?

00:57:50.800 --> 00:57:53.720
Things can only improve if you complain.

00:57:53.720 --> 00:57:57.560
Otherwise, it's just my vision of how the framework should be.

00:57:57.980 --> 00:58:00.360
And feedbacks are really, really important.

00:58:00.360 --> 00:58:13.840
And that's the reason why we are starting to see agile methodologies and frequency cycles and things like that used every day in computer development.

00:58:13.840 --> 00:58:24.180
Because when you have something as complex as a software, which has minions on variables and things like that, you cannot take the right choice on your own.

00:58:24.180 --> 00:58:32.440
You always need to have feedbacks and users to tell you where are their problems and how things should evolve and improve.

00:58:33.080 --> 00:58:34.520
Yeah, that's a really cool philosophy.

00:58:34.520 --> 00:58:40.180
You know, start with something somewhat minimum viable and then like let it grow however it grows, right?

00:58:40.180 --> 00:58:41.320
Yeah.

00:58:41.320 --> 00:58:45.060
Everyone, let the TurboGear's team know what you need.

00:58:45.060 --> 00:58:45.660
That's awesome.

00:58:45.660 --> 00:58:46.740
All right.

00:58:46.740 --> 00:58:48.180
Two more questions before I let you go.

00:58:48.180 --> 00:58:51.540
If you're going to write some Python code, what editor do you open up?

00:58:51.540 --> 00:58:54.780
Well, as an editor, I use Beam.

00:58:54.780 --> 00:58:59.080
But as a development environment, I'm using PyCharm.

00:58:59.080 --> 00:58:59.820
Yeah.

00:58:59.820 --> 00:59:00.100
Okay.

00:59:00.100 --> 00:59:01.080
Very cool.

00:59:01.080 --> 00:59:01.520
Very cool.

00:59:01.520 --> 00:59:08.900
And of all the PyPI packages out there, what are some that you think are amazing that people aren't using?

00:59:08.900 --> 00:59:10.080
Maybe web assets?

00:59:10.080 --> 00:59:11.420
Yeah.

00:59:11.420 --> 00:59:14.540
Web assets, I can definitely suggest it.

00:59:14.540 --> 00:59:19.960
It's one of the tools that I use most frequently and it works perfectly.

00:59:19.960 --> 00:59:21.720
It's been around for a lot of times.

00:59:21.720 --> 00:59:25.120
So you can use it on production and go on safely.

00:59:25.120 --> 00:59:27.680
This has been a fun conversation.

00:59:27.680 --> 00:59:31.820
And it's been great to think about the future of the web and web frameworks.

00:59:31.820 --> 00:59:33.120
So thanks for being on the show.

00:59:33.120 --> 00:59:35.700
Thank you, Michael, for listening to me.

00:59:35.700 --> 00:59:36.360
Yeah, you bet.

00:59:36.360 --> 00:59:36.940
Talk to you later.

00:59:36.940 --> 00:59:37.560
Bye.

00:59:39.500 --> 00:59:42.200
This has been another episode of Talk Python To Me.

00:59:42.360 --> 00:59:44.180
Today's guest was Alessandro Molina.

00:59:44.180 --> 00:59:46.940
And this episode has been sponsored by Hired and CodeChip.

00:59:46.940 --> 00:59:48.660
Thank you guys for supporting the show.

00:59:48.660 --> 00:59:51.260
Hired wants to help you find your next big thing.

00:59:51.260 --> 01:00:00.020
Visit Hired.com slash Talk Python To Me to get five or more offers with salary and equity presented right up front and a special listener signing bonus of $4,000.

01:00:01.300 --> 01:00:03.220
CodeChip wants you to always keep shipping.

01:00:03.220 --> 01:00:07.540
Check them out at CodeChip.com and thank them on Twitter via at CodeChip.

01:00:07.540 --> 01:00:09.420
Don't forget the discount code for listeners.

01:00:09.420 --> 01:00:10.020
It's easy.

01:00:10.020 --> 01:00:12.240
Talk Python, all caps, no spaces.

01:00:12.240 --> 01:00:15.640
Did you know you can personally support the show too?

01:00:15.640 --> 01:00:22.700
Just visit Patreon.com slash mkennedy and join over 100 listeners who contribute between $1 to $2 per episode.

01:00:23.300 --> 01:00:29.520
You can find the links from the show at talkpython.fm/episodes slash show slash 35.

01:00:29.520 --> 01:00:31.920
Be sure to subscribe to the show.

01:00:31.920 --> 01:00:34.180
Open your favorite podcatcher and search for Python.

01:00:34.180 --> 01:00:35.380
We should be right at the top.

01:00:35.380 --> 01:00:39.320
You can also find the iTunes and direct RSS feeds in the footer of the website.

01:00:39.320 --> 01:00:44.240
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

01:00:44.240 --> 01:00:47.140
You can hear the entire song on talkpython.fm.

01:00:47.140 --> 01:00:49.040
This is your host, Michael Kennedy.

01:00:49.040 --> 01:00:50.620
Thank you so much for listening.

01:00:50.620 --> 01:00:52.600
Smix, take us out of here.

01:00:52.600 --> 01:00:54.600
Stay tuned.

01:00:54.600 --> 01:00:56.880
My voice, there's no norm that I can feel within.

01:00:56.880 --> 01:00:58.100
Haven't been sleeping.

01:00:58.100 --> 01:00:59.740
I've been using lots of rest.

01:00:59.740 --> 01:01:02.600
I'll pass the mic back to who rocked it best.

01:01:02.600 --> 01:01:06.600
I'll pass the mic back to who rocked it best.

01:01:06.600 --> 01:01:08.940
I'll pass the mic back to who rocked it best.

01:01:08.940 --> 01:01:11.040
I'll pass the mic back to who rocked it best.

01:01:11.040 --> 01:01:11.920
I'll pass the mic back to who rocked it best.

01:01:11.920 --> 01:01:14.000
I'll pass the mic back to who rocked it best.

01:01:14.000 --> 01:01:14.260
I'll pass the mic back to who rocked it best.

