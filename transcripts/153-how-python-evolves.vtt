WEBVTT

00:00:00.001 --> 00:00:04.740
If you spent some time in the Python community, you've probably heard the term PEP, which stands

00:00:04.740 --> 00:00:10.820
for Python Enhancement Proposal. In fact, the very first one was created in June 2000,

00:00:10.820 --> 00:00:16.900
and its purpose was to define the PEP process itself. Our guest this week, Nick Coghlan,

00:00:16.900 --> 00:00:23.200
was a co-author on that very PEP and many, many more. In this episode, we're going to discuss

00:00:23.200 --> 00:00:29.240
PEPs and how Python officially evolves, but also there are many other forces that drive and influence

00:00:29.240 --> 00:00:35.020
Python. So let's dig into all of these right now. This is Talk Python to Me, episode 153,

00:00:35.020 --> 00:00:55.900
recorded February 6th, 2018. Welcome to Talk Python to Me, a weekly podcast on Python, the language,

00:00:55.900 --> 00:01:01.000
the libraries, the ecosystem, and the personalities. This is your host, Michael Kennedy. Follow me on

00:01:01.000 --> 00:01:06.140
Twitter where I'm @mkennedy. Keep up with the show and listen to past episodes at talkpython.fm,

00:01:06.140 --> 00:01:12.640
and follow the show on Twitter via at Talk Python. This episode is brought to you by Linode and Datadog.

00:01:12.640 --> 00:01:16.320
Be sure to check out their offers during their segments. It really helps support the show.

00:01:16.320 --> 00:01:22.020
Talk Python to Me is partially supported by our training courses. Have you heard about the 100

00:01:22.020 --> 00:01:28.260
Days of Code Challenge? It's a challenge where you write code for an hour a day for 100 days. It's helped

00:01:28.260 --> 00:01:34.420
many developers finally master programming, but it can be hard to know what to study or have resources

00:01:34.420 --> 00:01:41.680
to focus on. That's why we wrote not one, but two 100 Days of Code courses. 100 Days of Code in Python,

00:01:41.680 --> 00:01:48.840
which covers mostly pure Python, and 100 Days of Web in Python, which covers a whole spectrum of web

00:01:48.840 --> 00:01:54.160
frameworks and concepts. If you've been thinking about taking the 100 Days of Code Challenge, be sure to visit

00:01:54.160 --> 00:02:00.660
training.talkpython.fm and check out our courses. They are the 100 Days of Projects and Lessons with a tidy

00:02:00.660 --> 00:02:07.780
bow on top just for you. Nick, welcome to Talk Python. Hey, very happy to be here. Oh, it's a real honor to have

00:02:07.780 --> 00:02:14.260
you on the show. You've been at this Python thing for quite some time. So going on 15 years, I think. Yeah, that's

00:02:14.260 --> 00:02:20.540
awesome. So our main focus today is going to be to talk about how Python evolves, all the different forces

00:02:20.540 --> 00:02:25.980
that press on it, the PEP process, all these great things. But before we get into those, let's just get your

00:02:25.980 --> 00:02:31.420
story. How did you get into programming in Python? So I'm actually one of those folks who got into it as a kid. My parents

00:02:31.420 --> 00:02:40.080
got our first computer when I was like, nine or 10, I think, which was a Apple IIe that spent lots of time playing

00:02:40.080 --> 00:02:44.700
Winter Olympics and stuff on that with my siblings. And anyway, I don't actually remember the name of

00:02:44.700 --> 00:02:50.820
the book, but it was like this big green thing, which had instructions on how to do programming in

00:02:50.820 --> 00:02:58.760
Apple Basic. So yeah, so the classic 10 print, hello world, go to 10 type thing. Yeah, maybe a little

00:02:58.760 --> 00:03:04.780
indentation and it screams across the screen, zigzag. Yeah. Yeah, basically. And you couldn't save

00:03:04.780 --> 00:03:09.820
anything because the computer didn't have a hard drive. It's so crazy how storage used to be. I remember

00:03:09.820 --> 00:03:15.940
some of my friends, they had, it must've been an Apple. I can't remember what it was, but had like

00:03:15.940 --> 00:03:22.180
a big cassette player and you would plug it in and like the cassette somehow provided data to the

00:03:22.180 --> 00:03:28.340
computer. And I don't even remember how that works. I just missed the cassette era with the computers at

00:03:28.340 --> 00:03:33.860
my place. So we had a, we had the big five and a quarter inch floppy, floppy disks, which actually

00:03:33.860 --> 00:03:39.300
were floppy. They were actually floppy. That's where the name came from. Cause they weren't for a long time.

00:03:39.300 --> 00:03:44.300
No, the three and a half were never floppy unless you broke them open. Once you broke the case open,

00:03:44.300 --> 00:03:51.560
then the disc inside was very floppy. But yeah, a friend of mine did have a Commodore 64 though. And

00:03:51.560 --> 00:03:56.760
that was the, you put the tape in, you play the game. So how did it work? Did the tape basically

00:03:56.760 --> 00:04:01.680
load the data into memory and then it would just run from there? Or like, I don't know. Yeah.

00:04:01.680 --> 00:04:05.880
Yeah. That's, that's technology used to be so crazy. Now it's a little more standardized.

00:04:05.880 --> 00:04:09.000
It's still crazy, but less bizarre, I guess.

00:04:09.000 --> 00:04:14.860
Yeah. We were just using a magnetic tape on reels instead of a, crystalline structure in a USB

00:04:14.860 --> 00:04:15.200
key.

00:04:15.200 --> 00:04:19.440
Yeah, that's right. I guess we'll, we'll look back on this time as quaint when we're talking

00:04:19.440 --> 00:04:24.860
about quantum computers and you know, whatever comes in 10 years, right? And AI is in, who knows?

00:04:24.960 --> 00:04:28.540
The one that amuses me is you look back at shows like Babylon five and stuff where they

00:04:28.540 --> 00:04:33.300
have their data crystals and you go, we literally have data crystals. That's what a USB key is.

00:04:33.300 --> 00:04:38.960
Yeah. We really live farther in the future than I think we really appreciate. All right. So you did

00:04:38.960 --> 00:04:43.040
some of this like early, really programming, this funky era, which we're talking about,

00:04:43.040 --> 00:04:45.220
but then moved on from there, I'm sure.

00:04:45.220 --> 00:04:50.060
Yep. So then I discovered in high school that programming was something you could do as a career,

00:04:50.060 --> 00:04:54.440
which was cool. And then I went into university as a computer systems engineer.

00:04:54.440 --> 00:05:02.440
which is kind of you computer systems engineering basically lives at the boundary between electrical

00:05:02.440 --> 00:05:06.220
and electronic engineering and software engineering.

00:05:06.220 --> 00:05:11.780
Back then there were, there were not really software development degrees, right? You either,

00:05:11.780 --> 00:05:18.820
I mean, I, in the, the sort of software engineering, not computer science side. Oh yeah. Nice.

00:05:18.820 --> 00:05:24.120
So Australia is a bit different from the U S. So for us, you guys are ahead of us basically. Yeah.

00:05:24.120 --> 00:05:35.220
I was in university from 95 through to 2000. And so when I started, you could do a straight up

00:05:35.220 --> 00:05:39.840
information technology degree with a software, there was a software subspecialty in that,

00:05:39.840 --> 00:05:45.780
or you could do computer system engineering under the engineering department, which is what I did.

00:05:46.000 --> 00:05:52.880
I think by the time I graduated, there was a straight up software engineering program.

00:05:52.880 --> 00:05:56.320
And I think that was through the engineering department.

00:05:56.320 --> 00:05:59.780
That's cool. I know those were coming on right around then. I missed that whole time.

00:05:59.780 --> 00:06:06.560
My college started in 91. So yeah, just, just missed that window as well. Like I started before the web.

00:06:06.640 --> 00:06:10.540
So that was fun. I remember the web coming out. That was so fun, right?

00:06:10.540 --> 00:06:17.520
That was the other thing was our high school it teacher was, he basically, he also ran the

00:06:17.520 --> 00:06:24.500
afterschool computer club, funnily enough. And so he was introducing us to like the mosaic browser and

00:06:24.500 --> 00:06:31.160
Netscape Navigator 1.0 and a bunch of us in 93, it would have been. So grade 10,

00:06:31.820 --> 00:06:35.620
we're all getting into the, online multi-user dungeon type stuff.

00:06:35.620 --> 00:06:43.340
Paulie.clarkson.sos.net, is a domain name that's embedded in my brain because that was the

00:06:43.340 --> 00:06:44.160
mud we played on.

00:06:44.160 --> 00:06:48.340
Those were such fun times. That's so awesome. I played a bunch of those as well. All right. So,

00:06:48.340 --> 00:06:52.720
so how did you learn Python in college or did it come after that?

00:06:52.720 --> 00:06:59.780
So I have a funny, university story about Python, which is our networking teacher in 99.

00:07:00.260 --> 00:07:06.400
This was wanted to try and level the playing field amongst all the students for the networking project

00:07:06.400 --> 00:07:12.740
he was giving us, which was like a protocol design type thing. And he basically, so he told us the

00:07:12.740 --> 00:07:16.240
standard language for the assignment is going to be Python because none of you will know that,

00:07:16.240 --> 00:07:22.280
which is, so that's funny now looking back at it 20 years later, it's like no lecturer would do that

00:07:22.280 --> 00:07:28.040
today. But the other one was that I actually put my hand up in class and said, do we have to use

00:07:28.040 --> 00:07:33.800
Python or we could, can we use a language we already know like Java? And so he said, sure, if you really

00:07:33.800 --> 00:07:38.580
want to. But then I did the, did the assignment in Python. I'm going, okay, yeah, I don't want to anymore.

00:07:38.580 --> 00:07:41.420
And so that was still Python 152 at that point.

00:07:41.420 --> 00:07:45.800
Wow. Those are pretty early days, but yeah, the contrast with Java probably was pretty stark.

00:07:45.800 --> 00:07:52.460
Yeah, absolutely. We were mostly interested in the wire protocol structure. So using the struct module to

00:07:52.460 --> 00:07:57.600
construct messages to send them back and forth. So yeah, that was quite a cool assignment. But

00:07:57.600 --> 00:08:02.880
interestingly, I didn't, didn't touch Python again for another like three years after that, I think.

00:08:02.880 --> 00:08:03.340
Wow.

00:08:03.340 --> 00:08:03.800
Yeah.

00:08:03.800 --> 00:08:08.560
Nice. And then you probably graduated three years later or so. And then was it work that brought

00:08:08.560 --> 00:08:09.300
it to you or what happened?

00:08:09.300 --> 00:08:16.020
Yeah. So, so what happened was I'd actually started working for Boeing Australia on the

00:08:16.020 --> 00:08:20.900
Australian defense forces, high frequency radio communications infrastructure as an undergrad.

00:08:20.900 --> 00:08:27.260
And so that became a full-time job after I graduated. And the system I was working on was actually a

00:08:27.260 --> 00:08:34.040
digital signal processing system for voice detection in HF. And essentially in HF, the problem is ordinary

00:08:34.040 --> 00:08:39.720
scrunchies don't work because HF is just very crackly and poppy. And so if you want to try and detect voice,

00:08:39.720 --> 00:08:46.200
you actually have to do signal analysis to say, where's the energy? Is this just random crackling

00:08:46.200 --> 00:08:51.480
noise or does it actually look vaguely like a human voice? And so that was all going along fine.

00:08:51.480 --> 00:08:58.520
C programming for the DSP, but we didn't really have a proper test harness for it. We just had a C

00:08:58.520 --> 00:09:03.220
application that ran on the host system. And if it got to the end without crashing, awesome.

00:09:03.760 --> 00:09:05.640
Basically it's good. Now we're going to ship it.

00:09:05.640 --> 00:09:13.120
Funnily enough, we kept finding bugs in the DSP software in the next level of integration testing.

00:09:13.120 --> 00:09:15.420
It's like, who knew?

00:09:15.420 --> 00:09:17.500
Who knew? What a mystery.

00:09:17.500 --> 00:09:20.980
And so anyway, so we needed to do a better job of testing this.

00:09:20.980 --> 00:09:27.620
And so there was a, another part of the system to orchestrate starting and stopping

00:09:27.620 --> 00:09:33.740
services and bringing sites online and offline. And they just recently got a

00:09:33.740 --> 00:09:40.320
approval to use, introduce Python 2.2 into the system so they could use it as this control

00:09:40.320 --> 00:09:45.560
and orchestration language, which was on the approved languages list, which meant, and it

00:09:45.560 --> 00:09:48.060
had this wonderful thing called the Python unit test module.

00:09:48.060 --> 00:09:53.180
Yeah. I remember back then C++ didn't have very many options and C even less, right?

00:09:53.180 --> 00:09:59.400
We actually had a in-house thing that engineers in Boeing Australia had designed for writing

00:09:59.400 --> 00:10:06.140
tests in C++. And this was around the time where a colleague had inspired me to learn Eiffel.

00:10:06.140 --> 00:10:11.360
We were fully into the extreme programming, test-driven development, all that sort of stuff.

00:10:11.360 --> 00:10:14.580
Yeah. All that stuff was going strong then. It was so amazing. Yeah.

00:10:14.580 --> 00:10:20.220
Yeah. And so, so they'd written that. And so it was a choice between that and the, the Python

00:10:20.220 --> 00:10:26.220
stuff. But the beautiful thing that the Python stuff had was, so our host system was running

00:10:26.220 --> 00:10:36.100
Windows NT and Python had the wave module that would let us play wave files out of the host

00:10:36.100 --> 00:10:42.680
system, which was very handy because we needed to play those to, to check for the reactions from

00:10:42.680 --> 00:10:48.540
the signal processing software. And then, and this is why I sometimes say that it's Dave Beasley's

00:10:48.540 --> 00:10:56.500
fault that I'm a Python programmer, the SWIG existed. And so what SWIG let us do is we had a C++ driver

00:10:56.500 --> 00:11:02.780
that ran on the host that the main production application used to talk to the DSPs.

00:11:03.620 --> 00:11:12.680
And so what SWIG let us do, or let me do was basically, I just wrote one .ifile for SWIG to wrap the production

00:11:12.680 --> 00:11:21.000
driver. And then suddenly I had this unit test system where I could call the production driver to set things

00:11:21.000 --> 00:11:28.000
up in the DSP, call the wave module to play audio files out of the test system, and then monitor over the

00:11:28.000 --> 00:11:33.860
network to say, did the signal processing software send the messages we expected it to send?

00:11:33.860 --> 00:11:38.720
Oh yeah, that's really cool. That's awesome. Yeah. So practicality wins the day, right? There's some

00:11:38.720 --> 00:11:40.140
simple tools to solve the problem. Yeah.

00:11:40.140 --> 00:11:46.400
That's kind of continued that I've always been a huge fan of Python for testing because it means that

00:11:46.400 --> 00:11:53.160
like when you try to do testing in C and C++ directly, you spend a lot of time building test

00:11:53.160 --> 00:11:59.680
scaffolding to let you say, is this thing the same as that thing? Or is this what I expected? And so the

00:11:59.680 --> 00:12:05.820
beauty of being in Python is you can express a lot of things more simply in the Python code than you

00:12:05.820 --> 00:12:10.800
can in the production code. Right. It lets you move faster. It lets your tests be easier to maintain

00:12:10.800 --> 00:12:15.940
over time. Yeah, it's wonderful. And so you just get this really nice combination of the tests in Python

00:12:15.940 --> 00:12:20.500
express your intent. And then it doesn't matter what your production code is in. You're just saying,

00:12:20.500 --> 00:12:25.760
am I matching my intent, whether it's faster or through a different mechanism or whatever.

00:12:25.960 --> 00:12:30.760
Yeah, really nice. So you're probably not still doing that same project today, right? What are

00:12:30.760 --> 00:12:36.380
you working on now? I worked on that project in different roles for like 12 years. But yeah,

00:12:36.380 --> 00:12:41.860
so technically right now I'm not doing anything. So I finished up at Red Hat at the end of last year. And

00:12:41.860 --> 00:12:48.040
so right now I'm talking to a few different people about what I'm going to do next.

00:12:48.040 --> 00:12:49.120
That's awesome. Yeah.

00:12:49.120 --> 00:12:51.560
So take your time to kind of find the next big thing.

00:12:51.720 --> 00:12:56.660
I've got the luxury of not having to make a quick decision about what I want to do next.

00:12:56.660 --> 00:13:02.360
And so it means I'm kind of going, what do I really want to be doing? Because to be honest,

00:13:02.360 --> 00:13:07.100
I've spent the six years since I left Boeing, I've been completely in the software infrastructure

00:13:07.100 --> 00:13:15.220
space. And it's like, while I don't dislike that, I do really miss being able to point at a piece of

00:13:15.220 --> 00:13:18.360
hardware and say, my software makes that work.

00:13:18.360 --> 00:13:22.920
Yeah. So when are we going to be riding in your next self-driving airplane that you're creating or

00:13:22.920 --> 00:13:25.240
your next Friday, right? It's coming a few years out, right?

00:13:25.240 --> 00:13:30.260
So that's the thing of, it's very tempting to just say, you know what, I'm kind of going to get

00:13:30.260 --> 00:13:35.220
out of the software infrastructure world and go back into the physical hardware that does stuff.

00:13:35.220 --> 00:13:39.900
But at the same time, there's a lot of interesting stuff to be done in open source supply chain

00:13:39.900 --> 00:13:44.180
management. So yeah, of course, there's so many interesting problems, right? There's definitely

00:13:44.180 --> 00:13:49.480
no shortage of that. That's awesome. All right. So let's go ahead and talk about our main topic,

00:13:49.480 --> 00:13:55.720
which is how Python evolves. And, you know, we were talking just before I hit record. And I feel like

00:13:55.720 --> 00:14:03.380
the two major ways that kind of drive where Python goes is kind of from the official inside,

00:14:03.380 --> 00:14:09.440
which is this PEP process and these other meetings and core developers. And then there's the outside

00:14:09.440 --> 00:14:13.640
world where nobody asks for permission, they just go make stuff. And then you guys look at it and go,

00:14:13.720 --> 00:14:17.840
wait, actually, they're doing really cool stuff over here. Does that really drive that control like a

00:14:17.840 --> 00:14:23.080
satellite in space? How are you doing that? Right? You're dealing with Python. So there's these sort

00:14:23.080 --> 00:14:30.080
of two forces, right? The internal peps and the external just what people are doing. So what do you

00:14:30.080 --> 00:14:30.680
think about that?

00:14:30.920 --> 00:14:37.340
I kind of mentally break it up into two problems. So it's the thing of applying Python to a problem

00:14:37.340 --> 00:14:45.220
domain. And that's the case of like, even Python 152 was an entirely usable orchestration language.

00:14:45.220 --> 00:14:52.360
Python 2.2 was exceptional. That's why we stuck with it for so long at Boeing. And so in that sense,

00:14:52.360 --> 00:14:57.720
it becomes the case of take Python as it exists today, apply it to a problem you have today,

00:14:57.720 --> 00:15:02.460
and write whatever libraries you need in order to model that domain successfully.

00:15:02.460 --> 00:15:10.800
So like that, again, gets back to my original exposure to it as hardware testing and orchestration

00:15:10.800 --> 00:15:17.160
for an existing system. Like, I don't recall any time when I was doing that saying, oh, I wish Python

00:15:17.160 --> 00:15:23.400
whatever, because it was the case of it did everything I needed it to do. And anything it didn't already do,

00:15:23.400 --> 00:15:28.880
we'd just add a library for it. And we were actually doing a lot of stuff with Corba at the time as our

00:15:28.880 --> 00:15:35.400
distributed communication protocol. And there were actually a bunch of different request brokers for

00:15:35.400 --> 00:15:42.940
Python out there. So that was, and so for that, Python dev doesn't need to be involved. And this

00:15:42.940 --> 00:15:48.480
occasionally frustrates people because they want us to be the single authority for all things Python.

00:15:48.480 --> 00:15:53.320
And they're like going, we, you need to do something about blah. And we're like going, yeah,

00:15:53.320 --> 00:15:57.880
why doesn't need to be us. It's like, we're not the domain experts on that.

00:15:57.880 --> 00:16:02.400
Yeah, that's really interesting. And that is definitely something that's different in,

00:16:02.400 --> 00:16:10.340
in the Python world from other organizations that are much more sort of mothership oriented.

00:16:10.340 --> 00:16:15.320
I'm thinking Apple and Microsoft, right? Like if something is going to happen in those ecosystems,

00:16:15.320 --> 00:16:19.580
there's very much like a blessing from the people who make the decisions.

00:16:19.580 --> 00:16:21.300
Yeah. And that just doesn't happen here, right?

00:16:21.300 --> 00:16:25.340
Well, and this is one of the interesting things. So this might be a bit of a tangent,

00:16:25.340 --> 00:16:31.000
but the hardware system that I worked on for Boeing, a lot of the time I spent working on that was

00:16:31.000 --> 00:16:34.560
actually as a system architect rather than a software developer. And when you're doing system

00:16:34.560 --> 00:16:40.000
architecture, you spend a lot of time doing make buy decisions of whether you're going to write

00:16:40.000 --> 00:16:44.420
something or whether you're going to buy something that somebody else is selling, which means you end

00:16:44.420 --> 00:16:50.540
up doing a lot of spending a lot of time thinking about incentives and trajectories and, and why is a

00:16:50.540 --> 00:16:56.240
vendor doing a certain thing? And what does that mean for you using them as a vendor? And if you look at

00:16:56.240 --> 00:17:02.960
the history of programming languages, like C came about because people just needed an abstraction

00:17:02.960 --> 00:17:05.980
layer over assembling, like rewriting.

00:17:05.980 --> 00:17:07.920
It was absolutely necessary. Yes.

00:17:07.920 --> 00:17:15.180
Yeah. So, so it was absolutely necessary. And, and so that was kind of, that kind of evolved out of the,

00:17:15.180 --> 00:17:21.000
the needs of hardware manufacturers because they didn't want to rewrite their own software for every

00:17:21.000 --> 00:17:26.040
new version of their hardware. That was actually quite a user-driven evolution there.

00:17:26.040 --> 00:17:32.240
Like at that point, that was vendors solving the problem that they had and not necessarily trying

00:17:32.240 --> 00:17:39.940
to use it to sell, to lock in customers. But then you look at things like emergence of Java driven by

00:17:39.940 --> 00:17:46.920
Sun to try and stay relevant in a world where Microsoft were eating their lunch. As it turns out, it just made

00:17:46.920 --> 00:17:54.420
it easier for Linux to eat Sun's lunch. So, so I don't think Java actually worked out quite the way Sun might

00:17:54.420 --> 00:18:00.360
have hoped. Then it ended up at Oracle and Oracle is still trying to use it as a, as a way for them to stay

00:18:00.360 --> 00:18:08.320
relevant. C-Sharp came out of Microsoft after they got into a big argument with Sun over Visual J++. So,

00:18:08.320 --> 00:18:15.500
very much driven by Microsoft's things of how do we, how do we do something about this Java thing and make sure we

00:18:15.500 --> 00:18:20.320
stay relevant in the business software world. Go, driven by Google trying to write things.

00:18:20.320 --> 00:18:26.980
Apple really, really want people to develop on Apple for Apple, exclusively for Apple and say,

00:18:26.980 --> 00:18:31.660
we'll do your market segmentation for you by excluding anybody who can't afford our hardware.

00:18:31.660 --> 00:18:36.380
But it means if you write for Apple platforms, you're writing for wealthy people who will probably be able

00:18:36.380 --> 00:18:43.740
to pay you. And so, so yeah. And so it becomes that thing of most languages exist in this space of having

00:18:43.740 --> 00:18:49.420
been designed for a company that's trying to sell you something. Sun were trying to sell you servers.

00:18:49.420 --> 00:18:56.360
Microsoft wanted to sell you Windows. Apple want to sell you tablets and iPhones and Mac machines.

00:18:56.600 --> 00:19:03.260
And so, so there's those commercial incentives behind there. And then you come into the Python world and it's

00:19:03.260 --> 00:19:10.260
like, well, Guido wanted to program his computer more easily and he wanted to make it easier for people to

00:19:10.260 --> 00:19:17.900
learn to program. And so, so the incentives behind it are very different. And then you also look at,

00:19:17.900 --> 00:19:22.840
you look at how the Python Software Foundation was set up. It was set up as a public interest charity,

00:19:22.840 --> 00:19:30.420
not as a trade association. And so, and then you add in the fact that like some of Python's biggest

00:19:30.420 --> 00:19:35.380
vendors don't even recognize that they're in the Python business. They're just shipping this thing

00:19:35.380 --> 00:19:39.740
that came with their Linux distro. They sure you might want to use this or we use this. You might want

00:19:39.740 --> 00:19:44.860
to as well. And so the vendors are all really quite passive and hands-off as well. They're just going,

00:19:44.860 --> 00:19:50.820
yeah, whatever, we'll just do whatever, we'll just ship it. And so, so yeah, so you end up with this

00:19:50.820 --> 00:19:57.840
very different dynamic where the large corporations uses, but not really driving the direction of the

00:19:57.840 --> 00:19:58.260
language.

00:19:58.260 --> 00:20:01.800
It's really interesting. And I'm sure people who come from those spaces that you named,

00:20:01.800 --> 00:20:06.300
they look around and they're like, what, there's really, there's really no one group that just tells

00:20:06.300 --> 00:20:08.680
me the way, right? It's pretty interesting.

00:20:10.680 --> 00:20:15.660
This portion of Talk Python To Me is brought to you by Linode. Are you looking for bulletproof hosting

00:20:15.660 --> 00:20:20.200
that's fast, simple, and incredibly affordable? Look past that bookstore and check out Linode at

00:20:20.200 --> 00:20:27.800
 talkpython.fm/Linode. That's L-I-N-O-D-E. Plans start at just $5 a month for a dedicated server

00:20:27.800 --> 00:20:32.460
with a gig of RAM. They have 10 data centers across the globe. So no matter where you are,

00:20:32.460 --> 00:20:38.100
there's a data center near you. Whether you want to run your Python web app, host a private get server,

00:20:38.100 --> 00:20:44.800
or file server, you'll get native SSDs on all the machines, a newly upgraded 200 gigabit network,

00:20:44.800 --> 00:20:50.760
24-7 friendly support, even on holidays, and a seven-day money-back guarantee. Do you need a little help

00:20:50.760 --> 00:20:56.260
with your infrastructure? They even offer professional services to help you get started with architecture,

00:20:56.260 --> 00:21:01.440
migrations, and more. Get a dedicated server for free for the next four months. Just visit

00:21:01.440 --> 00:21:10.380
 talkpython.fm/Linode. So I think maybe one of the places to start is the Python that you described

00:21:10.380 --> 00:21:18.080
back when you started your project in Boeing was being used to solve different problems than it

00:21:18.080 --> 00:21:24.720
necessarily is now. And there's basically, even if you just talk about Python, obviously the syntax is

00:21:24.720 --> 00:21:29.900
there. But what that means and how people use that could be really different based on who they are and

00:21:29.900 --> 00:21:34.920
how they're solving problems. Whenever I even read like data science code, I feel like I'm reading

00:21:34.920 --> 00:21:40.440
almost like a different dialect of the language because the mannerisms and the libraries just make

00:21:40.440 --> 00:21:44.480
it feel really different than say like a web app that's like really broken into little pieces and

00:21:44.480 --> 00:21:51.960
stuff. So I think I've mainly used Python myself in the use cases of test automation, which I would

00:21:51.960 --> 00:21:56.540
still say I've used it more for test automation than I have for anything else. Hardware simulators,

00:21:57.080 --> 00:22:03.600
particularly when you're working on a big thing like HF radio communications, you're not going to

00:22:03.600 --> 00:22:09.060
have a 10 kilowatt radio transmitter sitting next to your desk. You're not going to have giant antenna

00:22:09.060 --> 00:22:14.140
switch matrix sitting next to your desk. And even if you do, you might have one or two, which isn't

00:22:14.140 --> 00:22:19.780
going to scale to automate testing for the whole system. So by writing simulators for those things

00:22:19.780 --> 00:22:27.400
in Python, you can just do that relatively easily and test things that you just cannot test in reality.

00:22:27.400 --> 00:22:32.580
So that's, that's an interesting use case. And then yeah, the straight up web application development

00:22:32.580 --> 00:22:37.800
dating from the CGI days, which is actually how we wrote the original version of the system

00:22:37.800 --> 00:22:42.460
orchestration, distributed system orchestration, which you now mostly see in things like Ansible and

00:22:42.460 --> 00:22:45.580
salt in the Python rapids around Docker and Kubernetes.

00:22:45.580 --> 00:22:50.760
Yeah. You even have people doing things like building, like say microcontroller code where

00:22:50.760 --> 00:22:56.960
your Python program is almost, almost is the operating system, right? Like you wire your Lambda

00:22:56.960 --> 00:23:02.360
expressions directly to hardware interrupts. It's like, there's this whole, whole thing. And what I

00:23:02.360 --> 00:23:08.100
think is really interesting and both a challenge, and I think it's a challenge that's been well met by the

00:23:08.100 --> 00:23:13.720
language designers, the language team and Guido in particular, is Python can be used in all these

00:23:13.720 --> 00:23:19.360
ways. And it, it doesn't feel like it's built specifically for one of them. You know what I

00:23:19.360 --> 00:23:24.120
mean? Like, like, if I were to look at R, like R is made for a thing, right? It's for solving math

00:23:24.120 --> 00:23:28.320
problems. And then you can kind of do other stuff with it. Whereas Python also solves math problems

00:23:28.320 --> 00:23:33.300
really well, but it also builds web apps amazing or controls space telescopes or you name it or automates

00:23:33.300 --> 00:23:39.120
hardware, right? And I think this gets back to the origins in the ABC research language,

00:23:39.120 --> 00:23:44.540
where the goal of ABC was to be a language for teaching people how computers work or how to think

00:23:44.540 --> 00:23:49.540
computationally. And then Python was basically Guido's version of that, that you could actually use to,

00:23:49.540 --> 00:23:57.520
that he could use for automating things. And so it becomes that thing of that base layer of imperative

00:23:57.520 --> 00:24:05.360
procedural programming of do thing A, do thing B, if condition, do thing C or do thing D,

00:24:05.360 --> 00:24:13.980
do thing E five times, do thing F until we run out of stuff. That basic procedural stuff,

00:24:13.980 --> 00:24:19.840
it's fascinating. Like if you go read standard operating procedures, work instructions and so forth

00:24:19.840 --> 00:24:25.140
that are written for humans, those are your basic constructs of how we give directions to each other.

00:24:25.520 --> 00:24:34.380
And so it's only, only when you go to build more complex systems, do you start needing all of the

00:24:34.380 --> 00:24:40.160
other constructs of computer science. And, and it's the thing of you start with imperative programming

00:24:40.160 --> 00:24:45.280
because that's the way humans think. And it's if humans are going to write a checklist or break down

00:24:45.280 --> 00:24:49.820
a task step-by-step to give to each other, they're going to start with that procedural model.

00:24:50.420 --> 00:24:55.680
But there's a reason computer science involved all these other things because that procedural

00:24:55.680 --> 00:24:58.780
problem, procedural modeling has scalability issues.

00:24:58.780 --> 00:25:01.780
Both in terms of complexity for sure. Yeah.

00:25:01.780 --> 00:25:07.000
Yeah. And so, but it's, if you look at the way a lot of, a lot of languages are written, they're saying

00:25:07.000 --> 00:25:12.420
they have a very strong opinion on this is how we're going to deal with complexity.

00:25:12.660 --> 00:25:18.080
And that's great if you have a problem which fits well into that complexity management model.

00:25:18.080 --> 00:25:24.940
And the beauty of Python is Python says, well, you're going to have procedural stuff in there

00:25:24.940 --> 00:25:31.940
somewhere. So start with procedural. But we know procedural doesn't scale to large teams,

00:25:31.940 --> 00:25:40.660
to large code bases. So we're going to offer you these, all these other options for refactoring your code

00:25:40.660 --> 00:25:47.220
as you better understand the problem you have. And that basically means it's, you have this common

00:25:47.220 --> 00:25:55.160
procedural subset, but then you have all of these different approaches to data modeling and computational

00:25:55.160 --> 00:25:59.720
flow modeling and all that sort of stuff where once you figure out what kind of problem you have,

00:25:59.720 --> 00:26:01.420
you can move in that direction.

00:26:01.420 --> 00:26:06.900
Yeah. And I feel like you've kind of captured one of the really special things about the language.

00:26:06.900 --> 00:26:13.820
And that is, you can start simple, but it's not a simplistic language. Whereas Java and C#,

00:26:13.820 --> 00:26:19.700
they say you work in this big formal framework from Hello World onward, right? You take all the

00:26:19.700 --> 00:26:24.860
complexity management from the beginning. And there's other languages like say, visual basic that are

00:26:24.860 --> 00:26:29.200
like, no, the world is simple enough, we're going to build simple things, but you hit an upper bound,

00:26:29.200 --> 00:26:33.940
you're like, okay, well, I can't use this anymore. Because you know, I don't know, threading or whatever,

00:26:33.940 --> 00:26:37.620
right? There's some, there's just a bunch of things you can't build with this simpler language. And somehow

00:26:37.620 --> 00:26:41.500
Python's managed to cross that gap. And that's pretty, pretty awesome.

00:26:41.500 --> 00:26:47.520
So I think one of the ways we actually do that is if you look under the hood of a lot of those higher level

00:26:47.520 --> 00:26:56.140
constructs, ultimately, they just boil down to procedural internals. Like at runtime, we are literally running

00:26:56.140 --> 00:27:06.700
through and doing stuff procedurally. And we, I think of it as the kind of a no privileged access concept, which is not

00:27:06.700 --> 00:27:13.760
actually true. We do have privileged access and the interpreter can do things that ordinary Python code can't. But as far as we

00:27:13.760 --> 00:27:22.440
can, we make it so that all of the syntactic sugar that we provide for things like classes and so on and so forth, we do our

00:27:22.440 --> 00:27:29.700
best to make sure that there is an actual procedural equivalent, that any syntactic construct, like beyond the basic

00:27:29.700 --> 00:27:37.980
arithmetic, you can write out a pure Python equivalent may not run as fast, and it you may not get the error handling

00:27:37.980 --> 00:27:45.320
right. But conceptually, there is a Python equivalent of that's just procedural code, which is quite fun.

00:27:45.320 --> 00:27:52.380
That's a really cool philosophy. So maybe let's focus on some specific domain. So we touched on them a little bit, but we

00:27:52.380 --> 00:27:58.680
have, you know, web frameworks, GUI libraries, scientific stacks, and these have all evolved over time. One of the

00:27:58.680 --> 00:28:03.060
examples of space from the sort of infrastructure world you're talking about is Ansible.

00:28:03.060 --> 00:28:10.620
One of the things I like about Ansible is if you look at, like Python's basically been part of Linux

00:28:10.620 --> 00:28:18.640
distributions almost from the beginning. Like I think it was there, it was there in 1.5. So it was there in

00:28:18.640 --> 00:28:24.060
Red Hat Linux, it ended up becoming part of Red Hat Enterprise Linux, they had to deal with the Python 2

00:28:24.060 --> 00:28:29.580
transition. And now they're dealing with the Python 2 to Python 3 transition. But anyway, by being there by

00:28:29.580 --> 00:28:34.080
default, and it was always there on all the Red Hat systems, because it was part of the package manager,

00:28:34.080 --> 00:28:41.180
it was usually there on other distros, because some utility or other would be on the system that needed

00:28:41.180 --> 00:28:48.300
it. And anyway, so it meant that sysadmins started doing lots of admin scripting in Python. They'd write

00:28:48.300 --> 00:28:53.960
these tools in Python, and everybody would write their own. And, and then they kind of like going, well, hang on,

00:28:53.960 --> 00:29:00.360
why is every admin having to write their own custom code for all the same tasks. And so in a lot of

00:29:00.360 --> 00:29:09.800
ways, you can look at Ansible as a way of going, well, how about we turn the actual automation bits

00:29:09.800 --> 00:29:18.320
into modules that you put up on a, put up on, say, Ansible Galaxy, which you then, which you can then use

00:29:18.320 --> 00:29:23.480
from a declarative thing to say, I want all of this stuff to happen in this order. And that then gives you

00:29:23.480 --> 00:29:29.820
that more structured notion of what are the concepts that admins need to care about, rather than the

00:29:29.820 --> 00:29:34.440
precise syntax of a full loop or whatever. And so you get this kind of, you go from this procedural

00:29:34.440 --> 00:29:38.800
model, model down at the Python layer, up to a declarative model further up the stack.

00:29:38.800 --> 00:29:44.500
And you get so much flexibility when you say, this is the state I want it to be in. I don't care how that

00:29:44.500 --> 00:29:48.580
happens. You just make that happen. If you want to change how you do that, I don't care. I just want the

00:29:48.580 --> 00:29:53.540
end state to have Nginx installed with this SSL certificate or whatever, right?

00:29:53.540 --> 00:29:58.380
One of the phrases I use for this is the idea of executable knowledge, which is the case of you can

00:29:58.380 --> 00:30:04.680
have a domain expert write a piece of software and they know all the nitty gritty, horrible details

00:30:04.680 --> 00:30:15.000
of how messy reality is because humans, humans in history. But as a user, you don't need to care.

00:30:15.000 --> 00:30:21.300
You're just like going, I'm just going to trust you to know more about that than I do and say, make it so.

00:30:21.300 --> 00:30:27.840
And then one of the things I love about the scientific Python stack is like people talk about, oh, programmers

00:30:27.840 --> 00:30:31.620
need to be good at math. And you're like going, no, programmers are terrible at math.

00:30:31.620 --> 00:30:36.100
I have this conversation a lot with a lot of people and they say, well, what kind of math did I study?

00:30:36.100 --> 00:30:39.440
He's like, you know, I barely use algebra for my job.

00:30:39.660 --> 00:30:44.320
And it's the thing of most of us stopped learning math in high school. And I did learn a bunch of

00:30:44.320 --> 00:30:49.040
engineering mathematics and actually working a signal processing job. I finally understood what

00:30:49.040 --> 00:30:54.900
a fast Fourier transform was really for, which had never clicked for me in university. But in my day to

00:30:54.900 --> 00:30:59.060
day job now, I don't, I don't use any of that. I haven't used that since I was doing the signal

00:30:59.060 --> 00:31:05.100
processing stuff. And even when I was using it, the actual fast Fourier transform, I just called TI's

00:31:05.100 --> 00:31:10.740
library to do it. And so it's the same with scientific stack today. Like modern research

00:31:10.740 --> 00:31:18.100
mathematics is spectacularly sophisticated, whether you're looking at the numeric algorithms and

00:31:18.100 --> 00:31:24.980
array oriented programming or calculus or whatever. But in Python, you can just go, well, I'm not

00:31:24.980 --> 00:31:30.540
going to understand all of that myself. I'm just going to import pandas and have magic happen.

00:31:30.540 --> 00:31:35.020
Right. Or I'm going to set up a random forest or some deep learning thing by five lines of

00:31:35.020 --> 00:31:36.400
configuration or something. Yeah.

00:31:36.400 --> 00:31:40.920
And you're like, I'm going, and it's that thing of you should be simpler than implementation. Like

00:31:40.920 --> 00:31:46.720
you should be able to use things without understanding how they're implemented. And I think that's the

00:31:46.720 --> 00:31:53.480
beauty of how the domain specific tools evolve is people are able to write them, expose these common

00:31:53.480 --> 00:31:56.220
APIs as import magic from here.

00:31:56.320 --> 00:31:57.980
All right. All right. QXKCD.

00:31:57.980 --> 00:32:07.200
And then you have access as a user to all of this amazing domain knowledge that you then don't have

00:32:07.200 --> 00:32:12.940
to, you can learn it if you want to, or you may learn it by necessity when it breaks. And you're like,

00:32:12.940 --> 00:32:15.520
it's like when it breaks, you get to keep all the pieces.

00:32:15.520 --> 00:32:20.160
Yeah. There's also this difference of being like, I'm learning it enough to implement it or

00:32:20.160 --> 00:32:25.600
completely work in it, or I'm learning the concept of it really well. Like, like I,

00:32:25.600 --> 00:32:31.280
I understand the relational model of a database and indexes and all these things, but I don't know

00:32:31.280 --> 00:32:35.180
that I could go write a database from scratch without a lot of research, but that's okay. I

00:32:35.180 --> 00:32:37.340
don't mind using a database. It works fine, you know?

00:32:37.340 --> 00:32:43.420
Yeah. Well, and SQLAlchemy is another really good example of executable knowledge. Like I highly

00:32:43.420 --> 00:32:49.580
recommend some of the talks about the design of that and the work that goes into keeping things

00:32:49.580 --> 00:32:55.660
responsive at the application level and avoiding round trips to the database while at the same time,

00:32:55.660 --> 00:33:00.580
making sure you don't get yourself into trouble with case-to-coherency and all that sort of stuff.

00:33:00.580 --> 00:33:04.700
It's an amazing piece of work, but at a user level, it's import.

00:33:04.700 --> 00:33:06.180
Yeah. It's amazingly simple, right?

00:33:06.180 --> 00:33:06.440
Yeah.

00:33:06.700 --> 00:33:11.740
So another really interesting area, especially in the evolution part is because, you know,

00:33:11.740 --> 00:33:20.180
Python is, it came out in 1991. So it's seen a lot of different UI stories along the ways,

00:33:20.180 --> 00:33:27.540
right? And it's, it's spread so far and wide. And to be honest, the UI story today is so unlike it was,

00:33:27.540 --> 00:33:33.500
you know, in the early days. So maybe touch a little bit on this evolution through the,

00:33:33.500 --> 00:33:37.680
like the Windows macOS Linux UI story.

00:33:37.680 --> 00:33:41.660
And one of the ways this comes up is people are going, why is TCLTK in the standard library?

00:33:41.660 --> 00:33:47.400
And so TCLTK has been there longer than I've been using Python. And one of the interesting things

00:33:47.400 --> 00:33:54.880
is, so when I started working professionally in 98, Linux just wasn't there for the design of big

00:33:54.880 --> 00:33:58.680
systems. And this was actually a source of frustration on the system I was working on,

00:33:58.680 --> 00:34:02.720
because there was a lot of servers where we're running Windows NT on them. And we're just like,

00:34:02.720 --> 00:34:07.180
going, why? And there were a bunch of other servers, we were running Solaris on them. And we're like,

00:34:07.180 --> 00:34:11.760
going, why? And then you looked at when those operating systems were picked and the state Linux

00:34:11.760 --> 00:34:16.780
was in at that time and just like going, yeah, okay. I understand this decision completely.

00:34:16.780 --> 00:34:17.460
Fair enough. Yeah.

00:34:17.460 --> 00:34:19.140
And switching now would...

00:34:19.140 --> 00:34:19.960
Committed. Yeah.

00:34:19.960 --> 00:34:23.220
We did end up switching a bunch of those things out for Linux eventually, but,

00:34:23.400 --> 00:34:27.060
but it took some time and it took some work. And so anyway, so you look in the late nineties,

00:34:27.060 --> 00:34:32.000
Linux isn't really a presence yet. It's starting to become a thing, but, but it's

00:34:32.000 --> 00:34:34.500
ad hoc and experimental and...

00:34:34.500 --> 00:34:37.920
Yeah. And it's desktop story is even more ad hoc and more experimental, right?

00:34:37.920 --> 00:34:41.120
And so lots of things we take for granted today just don't exist.

00:34:41.120 --> 00:34:48.880
Like GNOME. GNOME was founded in 98. And so anyway, and so TKinter was just how you did cross-platform

00:34:48.880 --> 00:34:55.760
Unix GUIs. If you wanted a GUI that worked on AIX and worked on Solaris and worked on various other

00:34:55.760 --> 00:35:01.820
things, you use TKinter. And hey, it works on Windows too. Doesn't look anything like a native

00:35:01.820 --> 00:35:03.240
Windows app, but it works on Windows.

00:35:03.240 --> 00:35:09.520
It looks like transplated from another world, but yeah, you could put stuff in the text boxes.

00:35:09.520 --> 00:35:16.160
Yeah. And so TCLTK was the way you did cross-platform in the late nineties. And so at that point that was

00:35:16.160 --> 00:35:21.140
before the pip process, before SourceForge development. So before any of that. And so it was

00:35:21.140 --> 00:35:25.540
like, yeah, idle ended up in the standard library. So there was a default editor and it was all cool.

00:35:25.680 --> 00:35:34.220
But then as Windows became increasingly popular and as Linux became increasingly popular, you basically had

00:35:34.220 --> 00:35:43.440
people writing native Win32 apps. You had QT as a C++ wrapper that tried to tie, tried to use native widgets

00:35:43.440 --> 00:35:50.540
when it could, emulated when it couldn't. And then you had GTK emerging as this is the way Linux distros are going

00:35:50.540 --> 00:35:56.640
to do their desktop applications. Right. And just to put it in this perspective in time, like when Windows 95

00:35:56.640 --> 00:36:04.600
hit, that was a major, major change in the desktop environment, right? Like that really was a big splash, sort of

00:36:04.600 --> 00:36:10.280
like the iPhone landing in the phone world. Yeah, absolutely. So it's not surprising that a lot of people, you know,

00:36:10.280 --> 00:36:17.380
went to this Win32 space with MFC or whatever they were using. And it was also around about then that you basically

00:36:17.380 --> 00:36:25.920
could make a good living either selling prepackaged Windows software or software for download. Like the

00:36:25.920 --> 00:36:30.560
internet was just becoming a thing. Yeah, there was that two cows and all those places coming along. The

00:36:30.560 --> 00:36:37.320
internet was coming along. Yeah, it was great. And so it was the idea of pay to download was a thing. You

00:36:37.320 --> 00:36:42.160
basically clicked through and gave somebody money to download stuff from their website. Yeah. Another one

00:36:42.160 --> 00:36:49.220
that came up was WX Python. This was the thing of so kind of along a similar line to QT, there was WX

00:36:49.220 --> 00:36:58.200
widgets. And WX widgets was that thing of how do I write cross platform macOS Windows and Unixy

00:36:58.200 --> 00:37:05.160
applications without having to rewrite my GUI for everyone. And then so that WX Python wrapped WX widgets.

00:37:05.520 --> 00:37:12.580
We had PyQT from Riverbank to wrap QT. And so none of these ever got added to the standard library because

00:37:12.580 --> 00:37:17.520
just the rate of evolution and the size of complexity of the libraries they were binding to

00:37:17.520 --> 00:37:24.340
TCLPK is tiny by comparison. And so, yeah, and so it became the case of that kind of started the

00:37:24.340 --> 00:37:31.520
to this day unresolved fight between QT and GTA on Linux. And personally, I use KDE just because it's,

00:37:31.520 --> 00:37:40.460
I grew up with Windows, use Windows and DOS since DOS 5, I think. And so, yeah, and so I'm just used

00:37:40.460 --> 00:37:47.080
to the Windows paradigms of how things work. And so as much as people who like, who are fond of macOS X

00:37:47.080 --> 00:37:50.840
might go, oh, but this way is better. I'm like going, it might be better for you. It's not for me.

00:37:50.840 --> 00:37:57.040
It just got so complicated that it was just like, there is no standard. So there's nothing we can pull

00:37:57.040 --> 00:38:00.580
into the standard library and say, this is the way things are going to be from now on.

00:38:00.580 --> 00:38:06.340
Right. And the licensing is a little weird on QT. And so there's just like a bunch of stuff that

00:38:06.340 --> 00:38:12.040
just is not a good fit, right? And like GTK's efforts to support, well, so the problem with GTK

00:38:12.040 --> 00:38:18.980
is that its efforts to support anything cross-platform isn't really a thing. Like it's the,

00:38:18.980 --> 00:38:26.980
essentially the Linux and Unix-y equivalent of the Win32 APIs. Like it itself is not really

00:38:26.980 --> 00:38:32.040
cross-platform because it doesn't delegate to platform native stuff when you're running it

00:38:32.040 --> 00:38:32.740
somewhere other than Linux.

00:38:32.740 --> 00:38:36.980
Right. And that's really important because that's what it takes to make your app look like

00:38:36.980 --> 00:38:38.640
it belongs in that environment.

00:38:38.640 --> 00:38:42.380
Yeah. You have to use the native widgets rather than skinning your own emulation.

00:38:42.380 --> 00:38:48.520
Yeah. So right after this whole sort of thing, the world kind of said, okay, well, Java and C-sharp

00:38:48.520 --> 00:38:54.840
and Windows forums and WPF and Swing and just all of this stuff kind of scrambled it further.

00:38:54.840 --> 00:39:00.720
That was the C, C++ world, which is kind of CPython's native stomping grounds. That was complex

00:39:00.720 --> 00:39:07.660
enough. And then we had the whole thing of, oh, writing C and C++ directly is really hard.

00:39:07.860 --> 00:39:12.780
And it's really hard to secure. So managed languages are going to be the answer.

00:39:12.780 --> 00:39:19.000
And then Sun and Microsoft get into a fight. And so you end up with Java and C-sharp, right? And the

00:39:19.000 --> 00:39:27.600
JVM and the CLR rather than one platform. So that's like, okay, cool. That makes life even more

00:39:27.600 --> 00:39:30.240
complicated for everyone. Then Apple came along.

00:39:30.240 --> 00:39:35.360
Somehow they became relevant again, right? Because they were on the verge of being barely relevant.

00:39:35.360 --> 00:39:40.420
Never gone away completely because they always had that graphic designer, creative artist market.

00:39:40.420 --> 00:39:47.400
And so there was always that, there was always that strong core of like, they were always second.

00:39:47.400 --> 00:39:55.040
Like Windows completely took over the desktop, but Apple always had that like five to 10% of diehard

00:39:55.040 --> 00:40:02.420
macOS fans. And I think it was, I think it was Autodesk stuff like tended to run really well

00:40:02.420 --> 00:40:12.000
on the Macs. And so anyway, but then the iPhone happened and people are like, oh, we need touch

00:40:12.000 --> 00:40:17.340
interfaces. We can't assume there's a mouse and keyboard all the time. And so it's like, okay,

00:40:17.340 --> 00:40:21.480
what are your cocoa bindings like? What are your carbon bindings like? And I lost track at carbon.

00:40:21.480 --> 00:40:25.740
I haven't paid any attention since then. I don't know if it's still carbon or if they've moved on to

00:40:25.740 --> 00:40:31.100
something else by now. But yeah. And so, and so that was like, oh, okay. Everybody needs to

00:40:31.100 --> 00:40:37.340
care about macOS X again. And then Google came along and said, well, the native base platform for Android

00:40:37.340 --> 00:40:45.720
isn't going to be the underlying Linux core. It's going to be the Dalvik layer. And so if you want

00:40:45.720 --> 00:40:52.800
everything to run snappily and use native widgets and be nice, you really need to be running in the

00:40:52.800 --> 00:40:58.740
platform Java runtime. And then you're just like going, and if you don't do that, then you're either

00:40:58.740 --> 00:41:02.980
going to be bridging into Java, which is slow, or you're going to be using non-native widgets and

00:41:02.980 --> 00:41:09.600
emulating the native ones. And you're just like, oh, really? This was already, this was already terrible.

00:41:09.840 --> 00:41:11.360
And you just made it worse.

00:41:11.360 --> 00:41:16.960
Yeah. And you've got things like Electron JS and Cordova and Ionic and all these other frameworks

00:41:16.960 --> 00:41:20.500
are trying to make the web sort of fit into this world. And they're all pretty neat. And every one

00:41:20.500 --> 00:41:26.780
of these kind of had their space, but it just makes the story harder for what is the path for Python

00:41:26.780 --> 00:41:30.320
in some sort of UI story. There are some options though, right?

00:41:30.320 --> 00:41:35.460
WX Widgets and WX Python, when they were designed, basically said, okay, there's three big things we need

00:41:35.460 --> 00:41:38.400
to care about. We need to care about Windows. We need to care about macOS X.

00:41:38.760 --> 00:41:43.320
We need to care about GTK. And so they basically said, we're going to provide an abstraction layer

00:41:43.320 --> 00:41:48.200
over those three things. You write to our abstraction layer, and then we'll translate it as appropriate

00:41:48.200 --> 00:41:49.620
for any given platform.

00:41:49.620 --> 00:41:51.940
Have you been tracking the Phoenix project from them?

00:41:51.940 --> 00:41:57.360
I was for a while because that was the gating thing for their Python 3 support. I haven't looked

00:41:57.360 --> 00:41:58.360
at it recently though.

00:41:58.360 --> 00:42:04.380
Yeah. So they just like this week, maybe released WX Python 4.0, which is the whole Phoenix release.

00:42:04.380 --> 00:42:08.560
I don't know how much that was before, but it's, it seems like this might be coming back.

00:42:08.680 --> 00:42:12.100
It's a solid option. I actually wrote an app in this morning and it was really nice.

00:42:12.100 --> 00:42:16.500
That's really cool to hear because there's a, Robin Dunn wrote a book, WX Python

00:42:16.500 --> 00:42:19.560
in action, like 15 years ago, 10 years ago.

00:42:19.560 --> 00:42:20.640
Time for a second edition.

00:42:20.640 --> 00:42:23.360
Yeah. Yeah. But I was one of the tech reviewers for that.

00:42:23.360 --> 00:42:29.360
Oh, nice. I think the name says a lot, right? The code name is Phoenix. Like it's a back sort

00:42:29.360 --> 00:42:30.680
of from the ashes.

00:42:30.680 --> 00:42:34.760
They were really, because they were tightly tied to the CC++ libraries. They were kind

00:42:34.760 --> 00:42:40.840
of that whole Java and C# and the web thing made life really difficult for them because,

00:42:40.840 --> 00:42:44.920
because all these shifting paradigms and expectations were all happening.

00:42:46.760 --> 00:42:51.740
This portion of talk Python to me is sponsored by Datadog with infrastructure, monitoring,

00:42:51.740 --> 00:42:56.680
distributed tracing, and now logging Datadog provides end to end visibility into the health

00:42:56.680 --> 00:43:00.820
and performance of your Python applications. With out of the box support for frameworks like

00:43:00.820 --> 00:43:05.760
Django bottle and flask. You can start monitoring your application performance within minutes.

00:43:05.760 --> 00:43:11.200
Start monitoring your Python applications with a free trial. And as an added bonus, Datadog will

00:43:11.200 --> 00:43:16.460
send you a free t-shirt. Just visit talkpython.fm/Datadog for more details.

00:43:16.460 --> 00:43:22.000
Yeah. Another one I have high hopes for is the project from Beware.

00:43:22.000 --> 00:43:28.340
Yes. And Beware's Toga is the one I think is really interesting. So it's still relatively

00:43:28.340 --> 00:43:36.800
young, still lots of missing pieces. But yeah, it's based on that core notion of to really give

00:43:36.800 --> 00:43:41.680
a compelling user experience for somebody that is expecting a platform native experience,

00:43:41.680 --> 00:43:46.660
you need to actually use the native widgets. That if you're emulating the widgets, then

00:43:46.660 --> 00:43:52.800
users can tell because application can be cross-platform. Users, generally speaking, are not.

00:43:52.800 --> 00:43:59.400
They're using one platform. They're expecting your application to behave like all the other things

00:43:59.400 --> 00:44:00.560
on that platform.

00:44:00.560 --> 00:44:05.200
Right. You just want to reach all the users, but they're probably in one place individually for the

00:44:05.200 --> 00:44:09.880
most part. Yeah. Yeah. And generally speaking, users will be like, they have the native apps for

00:44:09.880 --> 00:44:15.400
whatever client device they're using, plus they have a web experience. And then maybe they have a

00:44:15.400 --> 00:44:21.160
native desktop OS as well. That's increasingly becoming a thing of, no, lots of people do everything

00:44:21.160 --> 00:44:28.600
on their tablet or on their phone. They have no desktop. And so, yeah. And so Toga basically take the

00:44:28.600 --> 00:44:34.920
point of view of, okay, CSS is good as a way of styling things and doing layout and all that sort

00:44:34.920 --> 00:44:41.480
of stuff. So let's lift that in and use that as the basis of styling your application.

00:44:41.480 --> 00:44:43.260
That's a brilliant design choice, I think.

00:44:43.260 --> 00:44:47.940
Yeah. And say, okay, let's not reinvent that. Let's just use that. But at the same time,

00:44:47.940 --> 00:44:55.000
no, I don't think they use the DOM. I don't think they pulled the whole DOM in, but they made sure that

00:44:55.000 --> 00:45:01.320
whatever they did was easy to translate into HTML5 DOM. And so essentially what they let you do is

00:45:01.320 --> 00:45:06.040
rather than having to choose between, am I writing a web app or am I writing a native app?

00:45:06.040 --> 00:45:15.020
They treat HTML5 as another target environment. And so you basically, one of the things you can get out

00:45:15.020 --> 00:45:21.160
of your project is a Django 5 progressive web app that say, okay, so we target the browser as a

00:45:21.160 --> 00:45:27.040
platform. There's your web app. And here's your native iPhone app. Here's your native Android app.

00:45:27.040 --> 00:45:34.040
And it's really impressive the amount of underlying infrastructure they've developed for this.

00:45:34.040 --> 00:45:38.760
Yeah. There's a lot of building pieces, a lot of cross compilers, and a lot of stuff that makes

00:45:38.760 --> 00:45:39.320
this possible.

00:45:39.320 --> 00:45:43.980
And one of the big things they realized was that they didn't have to write a Python compiler for every

00:45:43.980 --> 00:45:50.220
target environment. What they could do is they could use CPython as the core compiler and emit CPython

00:45:50.220 --> 00:46:00.840
AST, I think, and then go from the AST layer into JavaScript by the Bartavia project and into the JVM

00:46:00.840 --> 00:46:08.460
by the VOC project. And then anywhere else that has native C APIs, then they can just use CPython.

00:46:08.860 --> 00:46:13.180
But it was that big thing of that in the web, they really needed the native JavaScript implementation

00:46:13.180 --> 00:46:23.240
just because currently the cost of getting from another language runtime into JavaScript to access

00:46:23.240 --> 00:46:29.640
the DOM is just too slow for really snappy responsiveness on applications.

00:46:30.500 --> 00:46:35.280
So WebAssembly might change that once they add some DOM interfaces.

00:46:35.280 --> 00:46:40.100
But for now, I'm really interested in to see how WebAssembly is going to affect this because

00:46:40.100 --> 00:46:45.960
there's a lot of JavaScript, Python to JavaScript options like Brython, Sculpt, Transcript, Batavia.

00:46:45.960 --> 00:46:51.600
If that becomes like a native thing that is fast, like that actually might be really interesting.

00:46:51.800 --> 00:47:00.360
One of the ways I put it is JavaScript's in an interesting position where it's ubiquitous because

00:47:00.360 --> 00:47:02.900
for historical reasons that...

00:47:02.900 --> 00:47:03.400
Because Netscape.

00:47:03.400 --> 00:47:04.300
We actually...

00:47:04.300 --> 00:47:04.900
Because Netscape.

00:47:04.900 --> 00:47:07.020
But also because we managed to avoid the vendor fight.

00:47:07.020 --> 00:47:07.680
Yeah, that's true.

00:47:07.680 --> 00:47:11.680
Microsoft actually eventually came to the party and said, okay, we'll just implement JavaScript

00:47:11.680 --> 00:47:12.260
as written.

00:47:13.260 --> 00:47:20.780
And so that Java versus C# style split never happened, which is kind of astonishing.

00:47:20.780 --> 00:47:23.800
Those were bitter fights over the whole browser internet time.

00:47:23.800 --> 00:47:27.240
So surprising that that language made it through as a shared item.

00:47:27.240 --> 00:47:28.420
And that's just...

00:47:28.420 --> 00:47:32.220
It's astonishing that it survived the vendor turf wars.

00:47:32.220 --> 00:47:34.420
And full credit to them for dealing with that.

00:47:34.420 --> 00:47:38.680
Yeah, but maybe it wouldn't have if JavaScript had been more important at the time.

00:47:38.680 --> 00:47:42.240
But at the time, it was kind of like jQuery was the pinnacle.

00:47:42.240 --> 00:47:43.740
You could animate in a little thing.

00:47:43.740 --> 00:47:45.040
You could put a little calendar.

00:47:45.040 --> 00:47:49.960
But it wasn't like Angular and all these other major front end things.

00:47:49.960 --> 00:47:52.460
Whereas the major part of your app is now that thing.

00:47:52.460 --> 00:47:53.740
And I think that is the thing of...

00:47:53.740 --> 00:47:57.980
You kind of do need that freedom of the vendors are there.

00:47:57.980 --> 00:48:00.880
So you have the credibility and the resources.

00:48:00.880 --> 00:48:03.640
But they're not really paying attention.

00:48:03.640 --> 00:48:06.160
And they're not trying to use you as a competitive weapon.

00:48:06.160 --> 00:48:09.220
Because yeah, that's when things get really messy.

00:48:09.220 --> 00:48:10.340
Yeah, that's really interesting.

00:48:10.720 --> 00:48:12.780
So let's focus on another area for a moment.

00:48:12.780 --> 00:48:17.820
Let's talk about sort of the meta tooling, like the packaging and software distribution story around Python.

00:48:17.820 --> 00:48:21.380
Like we have things like Briefcase from the Bware guys.

00:48:21.380 --> 00:48:23.480
You just the same area that we just talked about.

00:48:23.480 --> 00:48:24.680
We've got CX Freeze.

00:48:24.680 --> 00:48:26.460
I use PyInstaller in that project.

00:48:26.460 --> 00:48:27.760
I talked about WX Python.

00:48:27.760 --> 00:48:30.300
There's a bunch of options and more that we're not even listening.

00:48:30.300 --> 00:48:31.980
There's pip, obviously.

00:48:31.980 --> 00:48:35.620
But maybe talk a little bit about the evolution of that kind of stuff.

00:48:35.620 --> 00:48:37.280
This is a fascinating thing.

00:48:37.280 --> 00:48:41.560
Because back when I worked for Boeing, we did a lot of stuff with Windows.

00:48:41.560 --> 00:48:43.240
And so we were running Windows installers.

00:48:43.240 --> 00:48:50.780
And writing software that actually properly respects platform conventions is genuinely difficult.

00:48:50.780 --> 00:48:52.020
It's super difficult, yeah.

00:48:52.080 --> 00:49:04.660
Back when I worked for Red Hat, one of my biggest complaints was that there basically isn't any developer documentation for here is how to write a well-behaved Linux application.

00:49:04.660 --> 00:49:06.780
Like they just don't exist.

00:49:07.460 --> 00:49:11.620
And you've got bits scattered over in the file system hierarchy stand and all that sort of stuff.

00:49:11.620 --> 00:49:19.080
And so you're just like going, the reason people don't write well-behaved applications is they have no idea what the rules are.

00:49:19.080 --> 00:49:28.980
Because none of the Linux vendors have actually written the equivalent of Apple's user interface guidelines or Microsoft's user interface guidelines.

00:49:28.980 --> 00:49:33.380
And you need those to say, what should I be doing?

00:49:33.380 --> 00:49:35.300
Because otherwise I'll just make something.

00:49:35.300 --> 00:49:38.920
Where do I even put the program on the computer when I install it?

00:49:38.920 --> 00:49:40.780
What's it supposed to do there, right?

00:49:40.780 --> 00:49:45.120
And it's like, and like Linux devs will say, oh, but file system hierarchy standard.

00:49:45.120 --> 00:49:48.280
And I'm like going, have you tried to read that documentation?

00:49:48.280 --> 00:49:50.900
It's all written for system administrators.

00:49:50.900 --> 00:49:56.600
It's like none of it's written for software developers of here is what your application should do.

00:49:56.600 --> 00:49:58.340
And so you're just like going, okay.

00:49:58.980 --> 00:50:14.140
So how about we just define a simpler format that lets developers not worry about the whole mess that's out there and say, like, you just write your application as a monolithic thing that drops into a directory and just tag bits of it with what they are.

00:50:14.360 --> 00:50:19.740
And then we can write tooling that will distribute things out into the right places.

00:50:19.980 --> 00:50:38.760
And the beauty of working, and this is something we've been working really hard to enable on the disutil sig level, which is that, so we focus primarily on the developer use case of I'm installing this to hack on it, not to just run it as an application.

00:50:39.100 --> 00:50:48.880
And so you want to be able to run test suites, you want to install dependencies in order to run a modified version that you've made local changes to and all that sort of stuff.

00:50:48.880 --> 00:50:52.300
We're really primarily interested in the developer experience.

00:50:53.100 --> 00:51:11.440
But at the same time, we're trying to get to a point where we make our description formats actually specified standards so that applications other than Python itself can read them.

00:51:11.440 --> 00:51:31.580
And then once you do that, and once you start describing things in static metadata formats, then suddenly you enable stuff like PIX, which is the Python executable format, and basically takes that and says, okay, well, here's a thing where you just have to add a Python runtime and say, run that thing.

00:51:31.580 --> 00:51:37.860
And also getting to the point of actually having true single binary executables.

00:51:37.860 --> 00:51:44.460
Yeah, for people who are listening, PIX is basically like a bizarro hack on a zip file that contains a bunch of Python code, right?

00:51:44.460 --> 00:51:51.200
But it lets you package up everything that you need into like one distributable binary thing.

00:51:51.200 --> 00:51:58.620
Slight tangent, that's actually a case where we made a change through a tracker issue to enable execution of zip files.

00:51:58.620 --> 00:52:01.500
And we forgot to mention it in the Python 2.6 What's New?

00:52:04.020 --> 00:52:08.040
Which they meant, we're like going, why does nobody know that Python can do this?

00:52:08.040 --> 00:52:16.920
We're like going, oh, because the only mention is like buried in the news file for Python 2.6.

00:52:16.920 --> 00:52:19.740
We never actually put it in the What's New.

00:52:19.740 --> 00:52:20.400
How funny.

00:52:20.400 --> 00:52:27.960
And so then I think it was around Python 3.4 or 3.5, we actually added zip app to the standard library.

00:52:28.300 --> 00:52:32.020
Not to let you execute this thing, but to provide some tools for creating them.

00:52:32.020 --> 00:52:38.540
And so then I think after we did that, then more people were aware that the capability existed and had existed since 2.6.

00:52:38.540 --> 00:52:39.780
Wait, why does this exist?

00:52:39.780 --> 00:52:41.660
Can you actually turn making that part of this?

00:52:41.660 --> 00:52:48.260
So what do you think about, to me, one of the challenges of Python outside the server space, right?

00:52:48.260 --> 00:52:50.980
The server space, everything seems basically handled to me.

00:52:50.980 --> 00:52:57.660
But if I want to write an application, let's say I go and use WX Python or PyQT or something like that.

00:52:57.660 --> 00:52:58.680
And I get this nice app.

00:52:58.680 --> 00:53:02.580
I want to give this, you know, we talked about 2CALs and the download stuff.

00:53:02.580 --> 00:53:03.300
And here's my zip.

00:53:03.300 --> 00:53:11.460
And I'm going to, like, the story for that in Python is, I think it's coming along, but it's still pretty early days.

00:53:11.460 --> 00:53:18.040
Things like PyInstaller and stuff, you can make these sort of binaries that don't even require Python on the machine or the dependencies, right?

00:53:18.040 --> 00:53:24.040
You don't have to describe, hey, dear user, you begin by, you know, creating a virtual environment and pip installing these things.

00:53:24.040 --> 00:53:28.240
Like, that's, you know, that's not the average, like, non-developer workflow.

00:53:28.240 --> 00:53:29.400
Yeah, exactly.

00:53:29.400 --> 00:53:31.820
So here's my .app or my .exe.

00:53:31.820 --> 00:53:32.500
There's one thing.

00:53:32.500 --> 00:53:33.300
I double-click it.

00:53:33.300 --> 00:53:34.300
That's it.

00:53:34.300 --> 00:53:37.560
How do you see the current space where we're going?

00:53:37.560 --> 00:53:38.960
Are you optimistic around that?

00:53:38.960 --> 00:53:40.180
Do you think it matters?

00:53:40.180 --> 00:53:41.420
I think it does matter.

00:53:41.420 --> 00:53:49.620
Interestingly, because it's one of those things, like, desktop, I think, is going to go the way of kind of like an artist's drawing table.

00:53:49.620 --> 00:53:54.700
Like, most people don't have a drawing table in their house.

00:53:54.700 --> 00:53:57.320
But if you're a professional artist, you probably will.

00:53:57.320 --> 00:54:04.820
And so it becomes that thing of you get to the point where vast majority of stuff can be done with just a phone or a tablet.

00:54:05.160 --> 00:54:11.040
But there will be things where professional things or hobbyist things.

00:54:11.040 --> 00:54:12.360
We just like going, no, no, no.

00:54:12.360 --> 00:54:13.140
I want a desktop.

00:54:13.140 --> 00:54:13.420
Right.

00:54:13.420 --> 00:54:14.180
You know, one example.

00:54:14.180 --> 00:54:16.240
People say this stuff a lot.

00:54:16.240 --> 00:54:17.240
And I do agree with you.

00:54:17.440 --> 00:54:25.020
One example might be, like, if you're writing software, like, for your company of, like, 10,000 stock traders.

00:54:25.020 --> 00:54:26.040
And they all look at the market.

00:54:26.040 --> 00:54:29.400
They have, you know, those insane, like, six screen, nine screen configurations.

00:54:29.920 --> 00:54:36.860
And they want their little dashboard to absolutely update insanely fast, just almost client server style.

00:54:36.860 --> 00:54:37.060
Right.

00:54:37.060 --> 00:54:45.520
Like, like a mobile app or a high latency web app or something is probably not going to be a replacement for those kinds of environments.

00:54:45.520 --> 00:54:46.340
Yeah, exactly.

00:54:46.340 --> 00:54:48.400
You're going to have those specialist applications.

00:54:48.620 --> 00:55:14.740
And I think the direction we're going to go is, again, talking about the Beware stuff, I really like the direction they've taken with Briefcase, where the idea is, instead of trying to convince developers to care about all these potential deployment targets, you instead get them to describe the information that they have that the computer cannot figure out automatically in a way that's useful to them for their own development environments.

00:55:14.840 --> 00:55:18.360
So, in this case, Python-level dependency descriptions, that sort of stuff.

00:55:18.360 --> 00:55:21.660
And then you just try and automate everything from that point forward.

00:55:21.660 --> 00:55:30.920
And so, Russell Keith McGee, the founder of RebootBware, has a wonderful demo of, what is it, six platforms in 20 minutes.

00:55:30.920 --> 00:55:35.140
He does have his machine already set up to publish to all the different platforms.

00:55:35.140 --> 00:55:37.720
So, like, he has Xcode stuff pre-installed.

00:55:38.020 --> 00:55:49.600
But, yeah, so in 20 minutes, he goes from a blank page to a built Android application, a built iOS application, a built Django web application, a Windows installer.

00:55:49.600 --> 00:55:54.660
I don't think he has Flatpak in there as well yet, but I think he was looking at it.

00:55:54.660 --> 00:56:02.160
So, yeah, and so it becomes that thing of, as a developer, you just go, I write my app, and then I can do cross-platform stuff without too much pain.

00:56:02.160 --> 00:56:05.320
Sounds a little bit like what Ansible does for server orchestration.

00:56:05.480 --> 00:56:11.660
I think so. It's about encapsulating that executable knowledge of what does a native app look like on these platforms.

00:56:11.660 --> 00:56:16.840
Right, and so are you optimistic on, like, Python as a language for building mobile apps?

00:56:16.840 --> 00:56:17.680
Yeah, I think so.

00:56:17.680 --> 00:56:18.620
Somewhere in the future.

00:56:18.620 --> 00:56:32.620
And I don't know yet whether that will come about through the Beware VOC model or whether it will be a result of getting decent WebAssembly DOM access and doing things that way or some combination thereof.

00:56:33.620 --> 00:56:47.280
Because one of the interesting things about WebAssembly DOM models is it then raises the prospect of potentially exposing native widgets through those interfaces, which all becomes quite interesting.

00:56:47.280 --> 00:56:48.260
Yeah, that's for sure.

00:56:48.260 --> 00:56:53.820
One thing that might be an interesting path that is not any of the ones you mentioned, those all could be good.

00:56:54.680 --> 00:56:55.800
And we only need one, right?

00:56:55.800 --> 00:57:10.420
One could be PyPy, actually, to some degree, or the Pigeon project, where the way that they got Csharpen.net onto iOS and Android was they basically used the JIT compiler and then just ahead of time compiled it.

00:57:10.420 --> 00:57:22.340
So if you could get some form of, like, JIT compilation, say, via PyPy, and you just don't JIT it, you just fully compile it for the machine and then drop it there, maybe that would actually be a good path.

00:57:22.420 --> 00:57:34.740
I don't know what the state of PyPy pre-compilation caching is, because certainly, like, PyPy's current challenge, I think, is with startup time and warming up the JIT.

00:57:35.200 --> 00:57:38.000
And there's a lot of ways to mitigate that and manage that.

00:57:38.000 --> 00:57:45.540
And in particular, mobile environments where people tend not to close applications down completely, they just suspend them in the background.

00:57:45.540 --> 00:57:48.720
Yeah, that does have the potential to work quite well.

00:57:48.720 --> 00:57:49.020
Yeah.

00:57:49.020 --> 00:57:53.360
I don't see anybody pursuing it, but it's still yet one more potential path in the future.

00:57:53.360 --> 00:58:04.120
It's actually one of the interesting things is that I still think there's not a lot of understanding of how compelling and revolutionary PyPy is as a technology.

00:58:04.820 --> 00:58:19.860
And I think it kind of gets back to the case of so many of us are using Python for orchestration use cases where we were kind of like, well, if our Python code becomes the performance bottleneck, something's gone horribly, horribly wrong at a system architectural level.

00:58:19.860 --> 00:58:22.520
Like, it's not supposed to be in the critical path.

00:58:22.520 --> 00:58:25.160
We really frustrate the PyPy guys, by the way.

00:58:25.160 --> 00:58:30.260
It's like, sorry, the PyPy crew trying to avoid guys for that kind of thing.

00:58:30.660 --> 00:58:37.320
But Intel wrote a instruction set emulator in PyPy.

00:58:37.320 --> 00:58:39.520
So I think that was the Pidgin project that you mentioned.

00:58:39.520 --> 00:58:47.420
And yeah, and they're just like going, hey, without tuning the JIT, we're kind of rivaling QMU for performance.

00:58:47.420 --> 00:58:49.140
And you're just like going, seriously?

00:58:49.140 --> 00:58:51.440
That's astonishing.

00:58:51.860 --> 00:58:57.640
Yeah, the Intel guys are doing a lot of stuff at the like chip level to optimize Python and PyPy.

00:58:57.640 --> 00:58:58.880
And they're doing contributions back.

00:58:58.880 --> 00:58:59.640
It's really pretty cool.

00:58:59.640 --> 00:59:01.000
And yeah, and that's been really cool.

00:59:01.000 --> 00:59:03.540
I've spoken to some of those folks.

00:59:03.540 --> 00:59:19.940
But the interesting thing is, we haven't yet seen anybody try to write a Java bytecode interpreter or a LLVM IR interpreter or a JavaScript interpreter in the PyPy technology.

00:59:19.940 --> 00:59:26.820
And the interesting thing is, those are the ones which actually have the really, really heated cross-interpreted performance debates.

00:59:26.820 --> 00:59:29.640
Where it's like, oh, a new release came out.

00:59:29.640 --> 00:59:31.600
Well, we will have multiple articles.

00:59:31.600 --> 00:59:36.960
How fast is it on the competitive benchmarks between the different implementations?

00:59:36.960 --> 00:59:42.660
And I mean, that's one of the things you always see for V8 or new browser versions or that sort of stuff.

00:59:42.660 --> 00:59:44.320
It's like, oh, how does it do on the benchmarks?

00:59:44.320 --> 00:59:45.040
Yeah, exactly.

00:59:45.040 --> 00:59:46.920
We run this JavaScript benchmark.

00:59:46.920 --> 00:59:49.380
It's slightly faster than V8 now.

00:59:49.380 --> 00:59:50.100
So take that.

00:59:50.100 --> 00:59:52.100
Yeah, things like that.

00:59:52.100 --> 00:59:57.420
We just don't have that kind of competitive performance mindset in the Python world.

00:59:57.420 --> 01:00:00.400
I think that we're heading down that path a little bit.

01:00:00.400 --> 01:00:10.560
I mean, you look at the work that Victor Stinner has been doing to optimize things around the Python 3.5, 3.6 timeframe was like, look, performance is a feature.

01:00:10.560 --> 01:00:12.700
And we're now going to get serious about making this faster.

01:00:12.700 --> 01:00:15.220
I think there is a lot of work being done there.

01:00:15.220 --> 01:00:15.720
But you're right.

01:00:15.720 --> 01:00:16.860
There's still a long ways to go.

01:00:16.860 --> 01:00:17.100
Yeah.

01:00:17.100 --> 01:00:20.560
But it's just one of those things, like having been in the vendor space as well.

01:00:20.780 --> 01:00:25.700
It's like you've never had customers coming to you and say, we want you to make our Python code faster.

01:00:25.700 --> 01:00:33.760
And so when customers aren't actually banging on vendors' doors saying, we want you to make this faster, then it doesn't happen.

01:00:33.760 --> 01:00:42.840
Whereas in the JavaScript world, we had the driver of browser vendors wanted people using their browser so that they could get their browsing data.

01:00:43.180 --> 01:00:53.580
And it's like running JavaScript faster meant more responsive websites, which meant people enjoyed using the browser more, which then meant they would use your browser, which meant you could get their data.

01:00:53.580 --> 01:00:54.100
Yeah.

01:00:54.100 --> 01:00:56.720
That you're at the end of that line, that funnel, by the way.

01:00:56.980 --> 01:01:02.620
But I think it's really interesting that, say, Google, for example, who really doesn't care how you use the web.

01:01:02.620 --> 01:01:11.400
They just want you on the web more, doing more web stuff to a large degree, is like, we're going to build V8 and make this super fast so that we can make these more engaging apps.

01:01:11.400 --> 01:01:13.520
So you're just on the web and you might do more searches.

01:01:13.520 --> 01:01:15.220
So we get your ad money.

01:01:15.220 --> 01:01:16.860
We can retarget you.

01:01:16.940 --> 01:01:18.520
We can show you more ads more quickly.

01:01:18.520 --> 01:01:19.720
Exactly.

01:01:19.720 --> 01:01:22.020
Yeah, that's a pretty interesting thing.

01:01:22.020 --> 01:01:23.520
So we're kind of getting short on time.

01:01:23.520 --> 01:01:29.100
So let's maybe do just a little bit of a conversation about how the standard library and the language evolved.

01:01:29.100 --> 01:01:38.320
Because when people think of evolution of Python, they might think, well, that means a new library or there's like new syntax for some other comprehension I haven't imagined.

01:01:38.320 --> 01:01:41.700
This is what people like to think of when they go, how Python evolves.

01:01:41.700 --> 01:01:45.140
And so the biggest thing is essentially CPython's issue tracker.

01:01:45.720 --> 01:01:56.520
So one of the interesting things about Python is we haven't gone the direction of actually defining a formal international standard of what it means for something to be Python.

01:01:56.520 --> 01:02:03.360
Instead, what we have is we have a informal language reference as part of the CPython documentation.

01:02:03.360 --> 01:02:08.500
And then CPython itself is the reference interpreter.

01:02:08.500 --> 01:02:12.900
And so I should actually probably say what I mean by CPython.

01:02:13.180 --> 01:02:15.900
Because for a lot of people, they go, what's CPython?

01:02:15.900 --> 01:02:17.440
We just use Python here.

01:02:17.440 --> 01:02:18.540
Yeah, I type Python.

01:02:18.540 --> 01:02:19.000
It goes.

01:02:19.000 --> 01:02:20.820
I don't know what the CPython is.

01:02:20.820 --> 01:02:22.700
And so this is one of the interesting things is.

01:02:22.700 --> 01:02:24.460
So there's actually two different things.

01:02:24.460 --> 01:02:31.820
There's Python the language, which is the thing you actually type into a text file, which then needs to be interpreted by something or compiled by something.

01:02:32.220 --> 01:02:41.740
And then the thing that actually executes when you type Python at the command line, we call imaginatively CPython because it's Python implemented in C.

01:02:41.740 --> 01:02:45.460
In truth, the code base is actually more Python than it is C.

01:02:45.460 --> 01:02:51.880
But the core engine, like the compiler and the eval loop and the built-in types are written in C.

01:02:51.880 --> 01:02:55.240
The core heart, the byte coder is handed off to C eval.c.

01:02:55.240 --> 01:02:57.660
There's a for loop and a switch statement in C.

01:02:57.660 --> 01:02:59.640
And that's kind of where the execution happens.

01:02:59.640 --> 01:03:00.300
But yeah.

01:03:00.300 --> 01:03:01.680
That's where the magic happens.

01:03:01.680 --> 01:03:01.960
Yeah.

01:03:02.440 --> 01:03:20.100
And so we started using CPython more deliberately and more consciously and more of our documentation actually after the 2010 language and VM summits, which was when we got a bunch of the implementers of different VMs together.

01:03:20.100 --> 01:03:32.500
So CPython, Jython, IronPython, PyPy, and basically talked about how can we essentially help alternative implementations to grow and reduce the barriers to use.

01:03:32.500 --> 01:03:36.720
Turns out the biggest barrier to use is C extension API compatibility.

01:03:36.720 --> 01:03:38.500
Yeah, that's definitely true.

01:03:38.500 --> 01:03:38.860
Yeah.

01:03:38.860 --> 01:03:40.040
And that's...

01:03:40.040 --> 01:03:43.280
That's both the cursing and the blessing of it, right?

01:03:43.280 --> 01:03:47.660
Because without that, the scientific computation stuff just wouldn't happen here.

01:03:47.660 --> 01:03:48.200
Yeah.

01:03:48.200 --> 01:03:48.800
And that's right.

01:03:48.800 --> 01:03:51.920
And so that's been an ongoing challenge for a long time.

01:03:51.920 --> 01:03:52.960
We're working on that.

01:03:52.960 --> 01:03:57.760
Which gets us back to the how the interpreter and language itself evolve.

01:03:57.760 --> 01:04:05.640
And so the core of this is the issue tracker at bugs.python.org because that's actually not just bugs.

01:04:05.640 --> 01:04:07.320
It's also enhancement requests.

01:04:07.320 --> 01:04:09.260
So one of the categories there is enhancement.

01:04:09.260 --> 01:04:13.060
And so that becomes a case of, oh, we think this API should be added.

01:04:13.060 --> 01:04:16.780
We think this API could use another flag on it.

01:04:16.960 --> 01:04:25.220
And so that basically becomes a case of, hey, can we make people's lives a bit easier once they can change their baseline version of Python more easily?

01:04:25.220 --> 01:04:34.320
One of the other things that's making this more desirable and have it happen more often is when we're getting more and more organizations now that are...

01:04:34.320 --> 01:04:42.320
They have automated testing regimes that are sufficiently robust that updating to a new version of Python is no longer scary.

01:04:42.320 --> 01:04:42.720
Right.

01:04:42.720 --> 01:04:47.220
Things like talks and whatnot that can do multi-version targeting and stuff, right?

01:04:47.380 --> 01:04:47.520
Yeah.

01:04:47.520 --> 01:04:55.880
But also I think when Python 3.6 came out, I think Facebook had upgraded their production infrastructure in less than a week.

01:04:55.880 --> 01:04:56.220
Yeah.

01:04:56.220 --> 01:04:56.460
Yeah.

01:04:56.460 --> 01:04:58.080
They were like, I remember the tweet.

01:04:58.080 --> 01:04:59.860
I think it was from Jason Fried.

01:04:59.860 --> 01:05:02.980
It was something to the effect of Python 3.6 came out on Tuesday.

01:05:02.980 --> 01:05:05.000
We're now running on Python 3.6 in production.

01:05:05.000 --> 01:05:07.780
And it was like Thursday that he sent that message out.

01:05:07.780 --> 01:05:08.440
It was incredible.

01:05:08.440 --> 01:05:08.800
Yeah.

01:05:08.800 --> 01:05:09.980
Might have been Lukash maybe.

01:05:10.140 --> 01:05:10.600
Oh, yeah, yeah.

01:05:10.600 --> 01:05:11.220
It could have been actually.

01:05:11.220 --> 01:05:11.780
Yeah, yeah.

01:05:11.780 --> 01:05:12.280
It could have been.

01:05:12.280 --> 01:05:18.720
And then someone replied going, I just thought about the sheer scale of that.

01:05:18.720 --> 01:05:20.800
And that's nothing short of astonishing.

01:05:20.800 --> 01:05:31.200
But the thing is with CI auto-deployment pipelines, it becomes that thing of you submit the PR that changes the base version in your Docker image.

01:05:31.200 --> 01:05:38.600
And if CI passes, well, you have just as much confidence in that change as you do in any other change to your code base.

01:05:39.380 --> 01:05:45.600
And so you're no longer talking about, oh, rebase means weeks or months of manual QA anymore.

01:05:45.600 --> 01:05:49.640
A rebase just runs through the same CI as everything else.

01:05:49.640 --> 01:05:56.820
Well, and you also have these sophisticated deployment techniques, I'm sure, places like Facebook use, where they don't necessarily switch everything.

01:05:56.820 --> 01:06:00.200
Maybe 1% of the traffic hits the new one, and then 20, and then 100%.

01:06:00.200 --> 01:06:05.760
You know, they can, like, gradually throw that out to the world before they hit millions of people and see what happens.

01:06:05.920 --> 01:06:13.040
It's that thing of, because automated testing has gotten so much better, rebasing to new Python versions is easier.

01:06:13.300 --> 01:06:19.960
Which means that they can more quickly get to the point of, we got the enhancement into the core.

01:06:19.960 --> 01:06:24.040
That means we can get rid of our workaround for that capability not being there.

01:06:24.040 --> 01:06:30.260
And the payoff for that is, like, within the couple of years that you can plan around.

01:06:30.260 --> 01:06:32.860
You can say, okay, we'll do the hacky way now.

01:06:33.240 --> 01:06:35.080
We'll get the proper fix into the core.

01:06:35.080 --> 01:06:38.940
Then we can throw away the hack in several months' time.

01:06:38.940 --> 01:06:40.300
That gets a lot more attractive.

01:06:40.300 --> 01:06:48.640
And so, whereas in more traditional environments, you may be supporting old Python versions for 5, 8, 10 years.

01:06:48.640 --> 01:06:53.600
Which kind of kills your incentive to say, oh, I need this in the standard library.

01:06:53.600 --> 01:06:55.260
And you're going, well, no, I really don't.

01:06:55.260 --> 01:06:57.560
I need it in a library that I can upgrade.

01:06:57.940 --> 01:07:02.200
Yeah, you've got to be able to pip install that, because you're not changing the base runtime.

01:07:02.200 --> 01:07:03.160
Yeah, very interesting.

01:07:03.160 --> 01:07:05.280
So, getting back to the enhancement requests.

01:07:05.280 --> 01:07:08.120
Filing the enhancement request is kind of the first step.

01:07:08.120 --> 01:07:14.720
It's like, hey, that can be, so you can either do that directly, or you can post to the Python ideas mailing list and say,

01:07:14.720 --> 01:07:16.940
hey, should I file an enhancement request for this?

01:07:16.940 --> 01:07:18.080
How is it likely to be received?

01:07:18.560 --> 01:07:24.580
And so, enhancement requests, it's easiest to get a good review for modules that actually have an active maintainer.

01:07:24.580 --> 01:07:28.880
So, in the Python developer guide, we have a page called the experts index.

01:07:28.880 --> 01:07:36.540
And essentially, the expert index, as core developers, we can add ourselves to that in particular areas.

01:07:36.880 --> 01:07:46.500
And essentially, when we add ourselves, we're saying, I feel both confident and entitled to make design decisions about this module or about this part of the interpreter.

01:07:46.500 --> 01:07:55.980
And quite often, the biggest problem that folks with enhancement requests face is that they're not being explicitly told no.

01:07:55.980 --> 01:07:59.740
It's that nobody's telling them, yes, we're going to do that.

01:07:59.740 --> 01:08:05.920
And quite often, the reason nobody's telling them yes is that nobody feels both confident and entitled to say, yes, that's a good idea.

01:08:05.920 --> 01:08:06.620
Right, exactly.

01:08:06.620 --> 01:08:09.100
Because it's sort of out of their little specialty.

01:08:09.100 --> 01:08:11.520
And so, you know, it's just floating out there.

01:08:11.520 --> 01:08:13.740
And so, they're just like going, oh, it might be a good idea.

01:08:13.740 --> 01:08:20.860
Like, I think for a long time, there was a proposed improvement to MIME type handling in the standard library.

01:08:20.860 --> 01:08:28.700
And it just kind of sat there forever because we didn't actually have any MIME experts on the current team.

01:08:28.700 --> 01:08:31.980
And it was a huge change that combined.

01:08:32.620 --> 01:08:41.700
It didn't clearly separate a massive refactoring of the MIME handling module from here is the bits that are actually wrong and need to be fixed.

01:08:41.700 --> 01:08:48.340
And at that point, you just kind of end up in an impasse because you're just like going, well, we're not confident enough in the change to say yes to it.

01:08:48.340 --> 01:08:51.840
But at the same time, we're pretty sure the status quo isn't right.

01:08:51.840 --> 01:08:52.140
Right.

01:08:52.280 --> 01:08:53.020
That's tough.

01:08:53.020 --> 01:08:54.400
But yeah, I see it.

01:08:54.400 --> 01:08:55.040
All right.

01:08:55.040 --> 01:08:55.900
So, how about the language?

01:08:55.900 --> 01:08:57.760
What if we want a new feature in the language?

01:08:57.760 --> 01:08:59.900
Like, I want a triple slash that means something.

01:08:59.900 --> 01:09:01.160
I want to put that in there.

01:09:01.160 --> 01:09:01.460
Okay.

01:09:01.460 --> 01:09:02.400
Go to the triple slash.

01:09:02.400 --> 01:09:03.160
Okay.

01:09:03.400 --> 01:09:14.300
So, that actually starts the same way, either on the Python ideas mailing list and that's like, basically, it's very hard to go wrong starting with the Python ideas mailing list.

01:09:14.300 --> 01:09:26.220
You're just going, the main way people go wrong is they present their idea with the implication that it's an obviously good idea and we're clearly idiots for not having implemented it already.

01:09:26.220 --> 01:09:28.980
That tends not to go over so well.

01:09:28.980 --> 01:09:30.000
But so long as-

01:09:30.000 --> 01:09:31.680
So, how you win friends and influence people, right?

01:09:31.680 --> 01:09:45.220
So long as people come in with the genuine questioning mindset of, would this be a good idea or might it contain the seeds of a good idea, that tends to be a much better foundation for discussion.

01:09:45.220 --> 01:09:49.180
Because either it will not be a good idea.

01:09:49.180 --> 01:09:56.660
There's a comment along the lines of, like, the number of ways we can make Python worse is unbounded.

01:09:56.660 --> 01:10:00.700
The number of ways we can make it better is a relatively limited subset.

01:10:00.880 --> 01:10:02.820
Or is always better in a language.

01:10:02.820 --> 01:10:13.620
I feel like there are some language designers, you know, thinking like Swift and the C# team, they seem to just be like, well, we have a job as a language designer, so we're going to continue to design the language.

01:10:13.620 --> 01:10:15.640
And so, what features are we adding?

01:10:15.640 --> 01:10:19.180
The shipping period is like, well, there don't necessarily need to be more features.

01:10:19.180 --> 01:10:21.520
You're just making it worse now, right?

01:10:21.520 --> 01:10:22.660
It's getting complicated.

01:10:22.840 --> 01:10:25.060
So I really like that the Python is cautious about that.

01:10:25.060 --> 01:10:28.080
Cognitive burden is something we think about a lot.

01:10:28.080 --> 01:10:35.160
Because every time you add to an API or add more keywords or anything, you are necessarily making things harder to learn.

01:10:35.160 --> 01:10:37.620
Especially if there's multiple ways to do the same thing.

01:10:37.620 --> 01:10:39.880
But there's like a slightly better, newer way.

01:10:39.880 --> 01:10:42.300
It just makes it confusing.

01:10:42.300 --> 01:10:47.380
When the new way is just obviously better in every way, those are the ones you're really happy about.

01:10:47.380 --> 01:10:47.620
Right.

01:10:47.680 --> 01:10:49.100
Like f-strings, perhaps, maybe.

01:10:49.100 --> 01:10:51.560
F-strings are exactly the example I was going to bring up.

01:10:51.560 --> 01:10:59.460
Because they're not only the most concise way of formatting strings, but when you can use them, they're also the fastest.

01:10:59.460 --> 01:11:08.720
And this is something not a lot of people realize, is that with both percent formatting and the .format method, Python has to interpret the formatting string at runtime.

01:11:08.720 --> 01:11:16.780
So it means it has to scan through it, find all the fields, calculate the field substitutions, and it's all just kind of horrible and slow.

01:11:16.940 --> 01:11:21.780
The beauty of f-strings is because they're syntax, you can get the compiler to help.

01:11:21.780 --> 01:11:29.920
And so with f-strings, we do all of that thing of breaking it up into segments at compile time.

01:11:29.920 --> 01:11:34.980
So in the bytecode or the PYC file, it's like already sort of partitioned it.

01:11:34.980 --> 01:11:46.620
In the compiled form, all you have is an alternating sequence of text segment, format operation, text segment, format operation, text segment, format operation.

01:11:46.620 --> 01:11:53.160
And so it can basically, all of that string passing code happens at compile time.

01:11:53.660 --> 01:11:59.660
And so it's not only the nicest to write and the easiest to read, it's also the fastest.

01:11:59.660 --> 01:12:01.160
That sounds like a win in future.

01:12:01.160 --> 01:12:01.560
Yeah.

01:12:01.560 --> 01:12:02.560
So it was like, cool.

01:12:02.560 --> 01:12:10.240
And then what it means is that then all the other runtime formatting options, they're all still there and you still have all your different trade-offs between them for when you might want to use them.

01:12:10.500 --> 01:12:12.940
But for straight up text formatting, you don't need them anymore.

01:12:12.940 --> 01:12:19.400
And those kinds of ideas that kind of win on all the boxes and it's like, those are the ones most likely to get approved.

01:12:19.540 --> 01:12:25.180
That basic enhancement proposal process of proposing things on Python ideas or on bungas.python.org.

01:12:25.180 --> 01:12:27.960
Essentially, we have an escalation mechanism for those.

01:12:27.960 --> 01:12:33.700
So if it fits in somebody's personal area of expertise, we may just approve it on the issue tracker and say, yep, that's a great idea.

01:12:33.700 --> 01:12:36.340
It's an area I'm confident making decisions about.

01:12:36.340 --> 01:12:40.120
I'll just approve it on my own authority and merge it.

01:12:40.120 --> 01:12:43.220
So those are wonderful from a contributor experience point of view.

01:12:43.220 --> 01:12:44.680
It's like, hey, I made a suggestion.

01:12:44.680 --> 01:12:45.300
It was accepted.

01:12:45.300 --> 01:12:45.780
Cool.

01:12:45.780 --> 01:12:48.460
I made a proposed change to Python.

01:12:48.460 --> 01:12:53.120
Those are kind of the exception rather than the most common case.

01:12:53.120 --> 01:13:09.160
And what happens when that doesn't work is we may ask that a suggestion get taken to Python ideas if it's relatively vague or to Python dev if the suggestion is clear and the bit that's unclear is should we do it or not?

01:13:09.160 --> 01:13:09.440
Right.

01:13:09.440 --> 01:13:10.280
It needs debate.

01:13:10.280 --> 01:13:13.420
So Python dev is mainly for yes or no type questions.

01:13:13.420 --> 01:13:17.700
Python ideas is for I don't even know what the question is.

01:13:17.700 --> 01:13:22.960
What should the question be is kind of a useful way of thinking of those two mailing lists.

01:13:23.460 --> 01:13:30.160
But sometimes that's still not enough to resolve the question.

01:13:30.160 --> 01:13:36.860
So it's an enhancement proposal process.

01:13:36.860 --> 01:13:43.560
And that's also a useful thing.

01:13:43.560 --> 01:13:50.260
And that's also a useful thing.

01:13:50.260 --> 01:14:12.720
And so the idea of the process is to provide a document that summarizes the discussion, summarizes the tradeoffs that have been discussed, and nominates a particular person to make the final decision, which is basically yes or no, or let's put it off and reconsider it later.

01:14:12.720 --> 01:14:17.420
And so by default, that's always Guido as the lead language designer.

01:14:17.420 --> 01:14:28.780
But we have a delegation mechanism in place where any core developer can say, I'm happy to make the final decision on this and basically be responsible for the fallout.

01:14:31.360 --> 01:14:31.840
Yeah.

01:14:31.840 --> 01:14:33.680
And that can be wide-ranging.

01:14:33.680 --> 01:14:34.300
Yeah.

01:14:34.300 --> 01:14:34.440
Yeah.

01:14:34.440 --> 01:14:34.660
Yeah.

01:14:34.660 --> 01:14:35.000
Yeah.

01:14:35.000 --> 01:14:35.800
That's interesting.

01:14:36.060 --> 01:14:47.720
In a lot of cases, we also use the PEP process when we're like going, we're happy with the idea in principle, but there's a bunch of lower-level details to work out before it becomes actually implementable.

01:14:48.180 --> 01:14:53.580
And in those cases, there's usually arbitrary design decisions that need to be made along the way.

01:14:53.580 --> 01:14:56.800
And it's like, it doesn't really matter which way you go.

01:14:56.800 --> 01:14:58.560
You just have to pick one and stick with it.

01:14:58.980 --> 01:15:09.560
And so the BDFL and delegation process is useful for that as well because that's when you just say, look, if there's an arbitrary decision to be made, this is the person who makes it.

01:15:10.100 --> 01:15:16.920
And the beauty of this is that it gives us a way to say yes to complex suggestions.

01:15:16.920 --> 01:15:35.400
I think the record for getting a complex proposal through from proposal to implementation was something like eight days to add the matrix multiplication operator from the point where Nathaniel submitted the PEP to when it was actually implemented.

01:15:36.120 --> 01:15:45.240
And that was an interesting one because that actually came out of Nathaniel researching the history of operator proposals to Python.

01:15:45.240 --> 01:15:52.000
And it turned out nobody had ever actually suggested, let's just add a matrix multiplication operator.

01:15:52.000 --> 01:15:59.920
They'd always just gone, they'd all be in a case of let's add the ability for users to define their own infix operators.

01:16:00.340 --> 01:16:06.220
And they'd always failed on the basis of not adequately demonstrating the use case.

01:16:06.220 --> 01:16:17.120
And then what Nathaniel did was he went and looked and talked to all the scientific community and said, what are we actually feeling pain for about?

01:16:17.500 --> 01:16:29.700
And he went, well, it turns out we're really only feeling the pain for matrix multiplication because you need a way to spell element wise multiplication and you need a way to spell matrix multiplication.

01:16:29.700 --> 01:16:35.940
And Python just simply didn't offer enough infix operators to let you do that.

01:16:35.940 --> 01:16:40.380
Like you needed, so you had to choose and it was all very complicated.

01:16:40.620 --> 01:16:48.100
Nathaniel really did his research, understood the problem, wrote the PEP and said, this is the problem.

01:16:48.100 --> 01:16:49.600
This is what we want to do about it.

01:16:49.600 --> 01:16:51.560
This is why we chose the simple we did.

01:16:51.560 --> 01:16:53.620
And Guido went, sure.

01:16:53.620 --> 01:16:55.180
Yeah, that's awesome.

01:16:55.180 --> 01:16:58.300
That's a real blueprint for other people who want to do stuff like this.

01:16:58.300 --> 01:17:13.620
It's still my favorite enhancement proposal this day because it was just a beautiful example of researching the problem, understanding the need and explaining it clearly to people that weren't in that environment and weren't regularly writing scientific software.

01:17:13.860 --> 01:17:31.360
And one of the cute things was that it would have been even faster, except that there was a question in there about left associativity versus right associativity, where the description in the PEP was, we didn't ask for this because we assumed you'd say no.

01:17:31.360 --> 01:17:33.960
And Guido went, well, no, no, no.

01:17:33.960 --> 01:17:36.960
I might say yes if you have a valid use case for it.

01:17:37.380 --> 01:17:43.680
And so it was like, oh, okay, we need to go discuss that on the scientific mailing list to figure out what we actually want then.

01:17:43.680 --> 01:17:44.860
We'll get back to you.

01:17:44.860 --> 01:17:45.400
Yeah.

01:17:45.400 --> 01:17:49.980
And so there was an extra couple of days in there while I went and figured out, do we actually want that?

01:17:49.980 --> 01:17:52.700
And then they came back and said, well, we don't actually want it.

01:17:52.700 --> 01:17:53.600
That's cool.

01:17:53.600 --> 01:17:55.440
That's a really nice, really nice example.

01:17:55.440 --> 01:17:56.180
All right.

01:17:56.180 --> 01:18:00.280
We're totally out of time, but I want to still get you with the last two questions, as I always do.

01:18:00.280 --> 01:18:02.980
So if you're going to write some Python code, what editor do you use?

01:18:02.980 --> 01:18:08.760
I use VS Code these days, and I used KDE's Kate editor for a very long time.

01:18:08.760 --> 01:18:12.520
And it was only the VS Code has better Python plugins.

01:18:12.520 --> 01:18:15.740
I think VS Code with the Python plugin is a really nice option.

01:18:15.740 --> 01:18:17.520
So I definitely like it as well.

01:18:17.520 --> 01:18:19.400
And notable PyPI package.

01:18:19.400 --> 01:18:20.400
We've seen many.

01:18:20.400 --> 01:18:21.880
Notable PyPI package.

01:18:21.880 --> 01:18:23.340
Oh.

01:18:23.340 --> 01:18:25.800
Maybe something that somebody doesn't know about.

01:18:25.800 --> 01:18:29.500
Not the most popular, but like, oh, they should know about this thing that they probably don't.

01:18:29.500 --> 01:18:29.760
Hang on.

01:18:29.760 --> 01:18:30.420
That's a different question.

01:18:30.420 --> 01:18:35.600
One that I'm really, really pleased that it exists is Nipi, N-I-P-I.

01:18:35.600 --> 01:18:39.020
And that is neuroimaging data manipulation.

01:18:39.020 --> 01:18:41.300
Like, I personally have no use case for it.

01:18:41.300 --> 01:18:44.820
I am just really, really happy that it exists because...

01:18:44.820 --> 01:18:45.440
Yeah, that's awesome.

01:18:45.440 --> 01:18:47.060
That's just really cool.

01:18:47.060 --> 01:18:53.440
So one that I really, really love using for writing command line applications is Click.

01:18:53.440 --> 01:18:55.340
So Click for writing command line application.

01:18:55.340 --> 01:18:57.140
I think a lot of people have heard of that one.

01:18:57.140 --> 01:18:58.920
But it's still a really, really nice option.

01:18:58.920 --> 01:19:07.740
Yeah, it's just as a way of writing command line applications that are easy to test, easy to compose, easy to write in the first place.

01:19:08.040 --> 01:19:17.540
And the fact that it puts your command line passing right next to the function that implements a given subcommand is just a really nice way of doing things.

01:19:17.540 --> 01:19:18.200
Very, very good.

01:19:18.200 --> 01:19:19.800
I definitely like those recommendations.

01:19:19.800 --> 01:19:20.340
All right.

01:19:20.340 --> 01:19:21.200
So people are excited.

01:19:21.200 --> 01:19:24.160
They have ideas for improving Python at many levels.

01:19:24.160 --> 01:19:25.180
They want to get in touch with you.

01:19:25.180 --> 01:19:26.380
What's the final call to action?

01:19:26.380 --> 01:19:29.660
Not you in particular, but you as a group of people who make these decisions.

01:19:29.760 --> 01:19:34.200
Python developer guide is a really worthwhile document to read.

01:19:34.200 --> 01:19:38.040
We get a lot of common questions about how do I get started hacking on Python?

01:19:38.040 --> 01:19:40.400
How do I make suggestions for changing the language?

01:19:40.400 --> 01:19:44.480
And essentially, we try and make sure the developer guide answers those.

01:19:44.480 --> 01:19:48.860
It does make it rather large, but it's a complicated project.

01:19:49.080 --> 01:19:56.700
The other one I would point out is that posting suggestions to Python ideas is almost never the wrong thing to do.

01:19:56.700 --> 01:19:59.560
Just make sure they're phrased as suggestions, not as demands.

01:19:59.560 --> 01:20:01.380
Yeah.

01:20:01.380 --> 01:20:02.380
You're asking a favor.

01:20:02.380 --> 01:20:04.320
So approach the situation that way, right?

01:20:04.320 --> 01:20:05.380
Yes, exactly.

01:20:05.380 --> 01:20:06.280
Yeah.

01:20:06.280 --> 01:20:06.560
Awesome.

01:20:06.560 --> 01:20:06.880
All right.

01:20:06.880 --> 01:20:11.300
Well, Nick, it's been really great to share your perspective on all these changes in Python.

01:20:11.300 --> 01:20:12.100
It's been great.

01:20:12.100 --> 01:20:12.420
Okay.

01:20:12.420 --> 01:20:12.800
Awesome.

01:20:12.800 --> 01:20:14.240
I've had a great time.

01:20:14.240 --> 01:20:18.760
Sorry if I ramble a bit, but I really enjoyed talking about this stuff.

01:20:18.760 --> 01:20:19.320
Yeah.

01:20:19.320 --> 01:20:20.600
It's really interesting.

01:20:20.600 --> 01:20:21.680
So thanks for taking the time.

01:20:21.680 --> 01:20:22.180
Talk to you later.

01:20:22.180 --> 01:20:22.660
Okay.

01:20:22.660 --> 01:20:23.300
Thank you very much.

01:20:23.300 --> 01:20:27.280
This has been another episode of Talk Python to Me.

01:20:27.280 --> 01:20:33.780
Today's guest has been Nick Coghlan, and this episode has been brought to you by Linode and Datadog.

01:20:33.780 --> 01:20:37.860
Linode is bulletproof hosting for whatever you're building with Python.

01:20:37.860 --> 01:20:42.180
Get four months free at talkpython.fm/Linode.

01:20:42.180 --> 01:20:43.960
That's L-I-N-O-D-E.

01:20:43.960 --> 01:20:48.080
Datadog gives you visibility into the whole system running your code.

01:20:48.080 --> 01:20:52.400
Visit talkpython.fm/Datadog and see what you've been missing.

01:20:52.400 --> 01:20:54.600
Don't even throw in a free t-shirt for doing the tutorial.

01:20:54.600 --> 01:20:57.420
Are you or a colleague trying to learn Python?

01:20:57.420 --> 01:21:02.080
Have you tried books and videos that just left you bored by covering topics point by point?

01:21:02.080 --> 01:21:08.100
Well, check out my online course, Python Jumpstart, by building 10 apps at talkpython.fm/course

01:21:08.100 --> 01:21:10.720
to experience a more engaging way to learn Python.

01:21:11.140 --> 01:21:18.040
And if you're looking for something a little more advanced, try my Write Pythonic code course at talkpython.fm/pythonic.

01:21:19.040 --> 01:21:20.780
Be sure to subscribe to the show.

01:21:20.780 --> 01:21:22.960
Open your favorite podcatcher and search for Python.

01:21:22.960 --> 01:21:24.200
We should be right at the top.

01:21:24.200 --> 01:21:33.500
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

01:21:33.900 --> 01:21:35.400
This is your host, Michael Kennedy.

01:21:35.400 --> 01:21:36.760
Thanks so much for listening.

01:21:36.760 --> 01:21:37.820
I really appreciate it.

01:21:37.820 --> 01:21:39.780
Now get out there and write some Python code.

01:21:39.780 --> 01:21:59.660
I'll see you next time.

01:21:59.660 --> 01:22:00.280
Thank you.

