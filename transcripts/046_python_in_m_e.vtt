WEBVTT

00:00:00.001 --> 00:00:03.060
What did you experience the last time you watched a movie in a theater?

00:00:03.060 --> 00:00:06.640
Were you captivated by the fast-paced action and special effects?

00:00:06.640 --> 00:00:12.340
Deeply moved by the characters that came to life during those two hours when the outside world just melted away?

00:00:12.340 --> 00:00:14.260
Yeah, movies are still magical.

00:00:14.260 --> 00:00:18.880
What was likely not top of mind was all the work that went into that movie,

00:00:18.880 --> 00:00:23.360
from the editing of the audio and video, to the special effects, the rendering, the coordination,

00:00:23.360 --> 00:00:25.260
and maybe hundreds of creative professionals.

00:00:25.620 --> 00:00:29.880
It turns out that Python plays a key role in coordinating all of that production work,

00:00:29.880 --> 00:00:31.700
and that's what this episode is all about.

00:00:31.700 --> 00:00:37.560
Join me as I talk with Rob Blau from Autodesk about Python in the movies and entertainment business.

00:00:37.560 --> 00:00:43.000
This is Talk Python To Me, episode number 46, recorded January 28, 2016.

00:00:43.000 --> 00:00:49.940
I'm a developer in many senses of the word,

00:00:49.940 --> 00:00:54.300
because I make these applications, but I also use these verbs to make this music.

00:00:54.540 --> 00:00:58.860
I construct it line by line, just like when I'm coding another software design.

00:00:58.860 --> 00:01:02.000
In both cases, it's about design patterns.

00:01:02.000 --> 00:01:05.060
Anyone can get the job done, it's the execution that matters.

00:01:05.060 --> 00:01:07.200
I have many interests, sometimes...

00:01:07.200 --> 00:01:10.900
Welcome to Talk Python To Me, a weekly podcast on Python,

00:01:10.900 --> 00:01:13.960
the language, the libraries, the ecosystem, and the personalities.

00:01:13.960 --> 00:01:16.100
This is your host, Michael Kennedy.

00:01:16.100 --> 00:01:18.080
Follow me on Twitter, where I'm @mkennedy.

00:01:18.080 --> 00:01:21.980
Keep up with the show and listen to past episodes at talkpython.fm,

00:01:21.980 --> 00:01:24.580
and follow the show on Twitter via at talkpython.

00:01:24.580 --> 00:01:28.940
This episode is brought to you by SnapCI and OpBeat.

00:01:28.940 --> 00:01:33.620
Thank them for supporting the show on Twitter via snap underscore CI and OpBeat.

00:01:33.620 --> 00:01:35.560
Hey, everyone.

00:01:35.560 --> 00:01:39.660
Two weeks ago, I told you I had a huge announcement that I was really excited to share with you,

00:01:39.660 --> 00:01:40.340
but couldn't.

00:01:40.340 --> 00:01:44.120
Now that everything is in place, it's time to share my big plan with you.

00:01:44.600 --> 00:01:50.000
When I started this podcast almost a year ago, I had modest expectations and more than a little

00:01:50.000 --> 00:01:52.340
uncertainty about how it would be received by the community.

00:01:52.340 --> 00:01:57.600
And honestly, every day I'm blown away by how many people's lives I touch and help educate

00:01:57.600 --> 00:02:00.040
in some part of Python that was less well known to them.

00:02:00.040 --> 00:02:04.760
I get a huge amount of satisfaction spending time making Python more relevant to you through

00:02:04.760 --> 00:02:05.360
this podcast.

00:02:05.860 --> 00:02:07.780
I've been thinking about how I do more of that.

00:02:07.780 --> 00:02:14.000
I believe the natural counterpart to this podcast, which exposes people to new ideas and inspires

00:02:14.000 --> 00:02:19.380
them to learn more about Python, is a comprehensive set of online courses to help you go from inspired

00:02:19.380 --> 00:02:24.860
to empowered, from new developer to highly effective developer, from specialized developer to a

00:02:24.860 --> 00:02:25.620
well-rounded one.

00:02:25.620 --> 00:02:30.860
So today, I'm announcing the first course and taking the first step on a journey to build

00:02:30.860 --> 00:02:33.580
this resource for you and the whole Python community.

00:02:33.580 --> 00:02:39.920
Over the next two years, I plan to release 20 high-quality online courses that will be between

00:02:39.920 --> 00:02:41.540
three to ten hours each.

00:02:41.540 --> 00:02:46.700
These no-fluff courses will strive to make you effective with some corner of the Python ecosystem,

00:02:46.700 --> 00:02:51.500
including the Python language, web apps, databases, GUIs, parallelism, and more.

00:02:51.500 --> 00:02:56.920
The first course will be about the Python programming language, and will take a fun and playful approach

00:02:56.920 --> 00:03:00.640
to teaching you the language details such as classes, loops, variables, and more.

00:03:01.120 --> 00:03:03.860
It's called Python Jumpstart by Building 10 Applications.

00:03:03.860 --> 00:03:07.940
It'll be about six hours long, and it will be a comprehensive introduction to the Python

00:03:07.940 --> 00:03:08.300
language.

00:03:08.300 --> 00:03:11.560
If this project resonates with you, I need your help.

00:03:11.560 --> 00:03:16.380
As of today, I'm launching a Kickstarter to make the first course, this first step on

00:03:16.380 --> 00:03:17.420
my journey, a reality.

00:03:17.420 --> 00:03:20.960
Take a moment to visit the Kickstarter to see what it's all about.

00:03:20.960 --> 00:03:25.920
Just go to talkpython.fm/course, and you'll be redirected to the Kickstarter page.

00:03:26.480 --> 00:03:31.080
There are many reward levels, but the main one is the $29 student reward, which gives you

00:03:31.080 --> 00:03:33.820
lifetime access to the course at a significant discount.

00:03:33.820 --> 00:03:38.520
If you believe in this project and want to help, please tweet about the Kickstarter, share

00:03:38.520 --> 00:03:40.560
it with your coworkers, or even back it yourself.

00:03:41.200 --> 00:03:45.120
I'm really excited to start down this path to build something amazing for the community,

00:03:45.120 --> 00:03:46.880
and I can't do it without you.

00:03:46.880 --> 00:03:50.860
So any support or word-of-mouth endorsements you can give me will be deeply appreciated.

00:03:50.860 --> 00:03:52.800
Please let me know what you think.

00:03:52.800 --> 00:03:58.300
Send me a message over email, contact at talkpython.fm, or on Twitter via at Talk Python.

00:03:58.840 --> 00:04:03.900
I'm also doubling my efforts on this podcast as well, so keep listening and sending in suggestions

00:04:03.900 --> 00:04:07.160
and feedback, and I'll do my best to bring you interesting and relevant episodes.

00:04:07.160 --> 00:04:11.640
Now, let's hear from Rob Blau about making movies and video games with Python.

00:04:11.640 --> 00:04:13.660
Rob, welcome to the show.

00:04:13.660 --> 00:04:14.960
It's great to be here.

00:04:14.960 --> 00:04:15.620
Thanks for having me.

00:04:15.620 --> 00:04:16.620
Oh, you're welcome.

00:04:16.620 --> 00:04:17.560
Thanks for coming.

00:04:17.560 --> 00:04:19.760
I'm super excited to talk about Autodesk.

00:04:19.760 --> 00:04:22.440
You guys kind of make a little bit of everything.

00:04:22.440 --> 00:04:24.800
There's so many different pieces of software that you write.

00:04:25.440 --> 00:04:29.360
And it sounds like Python plays some pretty cool part in that.

00:04:29.360 --> 00:04:30.460
Yeah, definitely.

00:04:30.460 --> 00:04:33.420
So Autodesk is a great company.

00:04:33.420 --> 00:04:37.300
The company mission is to help people build cool things.

00:04:37.300 --> 00:04:43.220
So pretty much software that helps people realize their creative vision.

00:04:43.220 --> 00:04:49.780
The largest piece is kind of on the AutoCAD, like production architecture side.

00:04:49.780 --> 00:04:56.420
And the piece of Autodesk that I work in is the media and entertainment division.

00:04:56.420 --> 00:05:03.740
So we get to work with animation houses, visual effects houses, and help build the software

00:05:03.740 --> 00:05:08.340
that they use to do the cool things they do to put pixels and games together.

00:05:08.860 --> 00:05:09.860
That's really cool.

00:05:09.860 --> 00:05:18.680
So if I jump on a train and I go over to the airport and I get on a plane, fly somewhere,

00:05:18.680 --> 00:05:26.380
and find my way to a movie theater, how many of those different experiences are modeled or

00:05:26.380 --> 00:05:28.460
somehow created with Autodesk things?

00:05:29.300 --> 00:05:35.740
Chances are every single step of the way from the car that you jumped into, somewhere along

00:05:35.740 --> 00:05:39.960
the way from the factory that it was created in and the robots that made it, they were designed

00:05:39.960 --> 00:05:46.740
using some of the Autodesk software, the actual car itself, the models, all of the pre-visualization

00:05:46.740 --> 00:05:49.400
that people do in order to figure out what it's going to be.

00:05:49.400 --> 00:05:51.620
And then the actual instructions for building it.

00:05:51.620 --> 00:05:53.720
Autodesk makes products that do that.

00:05:54.860 --> 00:06:00.220
I mean, the city streets and the planning, it's incredible, the places that the software

00:06:00.220 --> 00:06:02.400
is used, and then the airplane, the exact same thing.

00:06:02.400 --> 00:06:04.700
And then you're going to the movie theater.

00:06:04.700 --> 00:06:07.960
The movie theater itself was probably done by an architect who was using AutoCAD in some

00:06:07.960 --> 00:06:13.700
way, shape, or form, or Revit, which is used to build bigger projects and make sure that

00:06:13.700 --> 00:06:19.320
all of the various components in the building, like the HVAC and the design and the wiring,

00:06:19.320 --> 00:06:22.460
all talk to each other and will work once you actually build it.

00:06:23.620 --> 00:06:30.200
And then you finally get the movie showing and you start seeing, nowadays, almost every

00:06:30.200 --> 00:06:35.740
single shot has some kind of visual effect on it, whether it's just a little bit of 2D

00:06:35.740 --> 00:06:40.140
cleanup that happens up to the full 3D.

00:06:40.140 --> 00:06:46.140
The actual environment is completely created from scratch inside of some software.

00:06:46.840 --> 00:06:53.420
Autodesk makes some of the most widely used pieces of software for that, like Maya 3 Studio

00:06:53.420 --> 00:06:54.440
Max.

00:06:54.440 --> 00:06:59.840
All of those are used to model and render what you're seeing up on screen.

00:06:59.840 --> 00:07:02.000
That actually kind of blows my mind.

00:07:02.000 --> 00:07:04.920
That's even more intense than my original thought.

00:07:04.920 --> 00:07:05.760
That's awesome, though.

00:07:05.760 --> 00:07:06.960
It's really cool.

00:07:06.960 --> 00:07:12.340
Fun mission to have to just make it easier for people to realize their creative vision.

00:07:12.340 --> 00:07:13.620
It's a nice one.

00:07:14.020 --> 00:07:15.360
Yeah, I bet it is.

00:07:15.360 --> 00:07:17.600
So let's totally dig into that.

00:07:17.600 --> 00:07:20.560
But before we do, maybe sort of give me your background story.

00:07:20.560 --> 00:07:24.100
Like, how do you get into this place where you're working on basically building everything

00:07:24.100 --> 00:07:26.460
that makes up the synthetic world?

00:07:26.460 --> 00:07:29.680
I had kind of a roundabout way there.

00:07:29.680 --> 00:07:33.260
I went to school for computer science.

00:07:33.260 --> 00:07:42.300
So from Boston, went to MIT and graduated around the first tech boom, did a couple of dot coms

00:07:42.300 --> 00:07:47.440
at that point and built up kind of just a varied background.

00:07:47.560 --> 00:07:53.580
I did a lot of scripting, a lot of database work, a lot of just systems admin kind of stuff.

00:07:53.580 --> 00:07:57.940
Just there was a startup culture and you did whatever you had to do to get going.

00:07:57.940 --> 00:08:04.600
And from that, I went to actually a Linux conference and saw a presentation from DreamWorks,

00:08:04.600 --> 00:08:08.500
DreamWorks Animation, where they were presenting how they're using Linux because they were one

00:08:08.500 --> 00:08:14.720
of the first companies to switch over to kind of big open source software as the foundation

00:08:14.720 --> 00:08:16.200
of the technology that they're using.

00:08:16.200 --> 00:08:17.060
Interesting.

00:08:17.060 --> 00:08:18.380
What were they switching from?

00:08:18.380 --> 00:08:18.840
Do you know?

00:08:18.840 --> 00:08:20.180
Silicon Graphics?

00:08:20.180 --> 00:08:20.760
Yeah.

00:08:20.760 --> 00:08:22.860
Back in the day, it was kind of Silicon Graphics.

00:08:22.860 --> 00:08:23.060
Yeah.

00:08:23.440 --> 00:08:29.300
So they kind of had deals with Red Hat going and figuring out kind of the enterprise Linux

00:08:29.300 --> 00:08:29.780
distro.

00:08:29.780 --> 00:08:32.300
They were early in adopting all of that stuff.

00:08:32.300 --> 00:08:35.540
So you intersected there when they were talking about how they were using Linux.

00:08:35.540 --> 00:08:36.440
Okay.

00:08:36.440 --> 00:08:36.880
Exactly.

00:08:36.880 --> 00:08:44.560
And I got to talking with them and it turns out that they had an interesting job that was

00:08:44.560 --> 00:08:49.900
doing, it's called pipeline work in the visual effects industry, which is the software that

00:08:49.900 --> 00:08:53.220
helps tie together what all of the different departments do.

00:08:53.220 --> 00:08:57.320
So you've got an artist sitting there, they've got a very specific job to do.

00:08:57.320 --> 00:09:02.540
It's almost like in an assembly line in a factory, you've got your station where you're doing your

00:09:02.540 --> 00:09:07.320
very specific thing, except with an artist, it's a very creative process, but they still have to

00:09:07.320 --> 00:09:12.740
take work done by somebody else, get it working for them, do what they're supposed to do to it,

00:09:12.740 --> 00:09:15.260
package it up for somebody else and then hand it to somebody else.

00:09:15.260 --> 00:09:19.860
And all of those pieces other than that creative work is kind of overhead that it's

00:09:19.860 --> 00:09:21.740
nice to artists to not have to do.

00:09:21.740 --> 00:09:24.640
And that's where this idea of pipeline comes in.

00:09:24.640 --> 00:09:29.980
So I was kind of fascinated by that right from this original conversation.

00:09:29.980 --> 00:09:35.780
Plus I had about 10 Boston winters and the idea of California sounded pretty good.

00:09:35.780 --> 00:09:43.240
So I went to work for DreamWorks where I was for five years and was a member of their pipeline

00:09:43.240 --> 00:09:47.020
department, ended up being a supervisor in that department.

00:09:47.820 --> 00:09:52.600
And that actually is where I first started using Python extensively.

00:09:53.600 --> 00:10:00.880
The pipeline at DreamWorks was Pro-based because back originally when you were doing text processing

00:10:00.880 --> 00:10:06.500
and having to glue together different software, Pro made a lot of sense.

00:10:06.500 --> 00:10:07.000
Right.

00:10:07.000 --> 00:10:08.040
What year was that?

00:10:09.160 --> 00:10:12.200
That was about 2003, 2004.

00:10:12.200 --> 00:10:12.900
Yeah.

00:10:12.900 --> 00:10:13.920
I'm talking about right now.

00:10:13.920 --> 00:10:14.380
Yeah.

00:10:14.380 --> 00:10:17.240
Pearl was still in a pretty strong position back then.

00:10:17.240 --> 00:10:17.940
Exactly.

00:10:17.940 --> 00:10:26.140
And the pipeline that I'm talking about had been in place for like a good probably five, six,

00:10:26.140 --> 00:10:27.420
seven years before that even.

00:10:27.940 --> 00:10:30.660
So when it was written, like that was the choice.

00:10:30.660 --> 00:10:37.540
But there was something that was kind of interesting that was happening with software in the 3D space.

00:10:38.660 --> 00:10:43.660
There was already a couple of pieces of software that had Python embedded in them.

00:10:44.440 --> 00:10:53.140
And Maya actually, as one of the biggest, again, taking it back to an Autodesk product, was introducing a version that had an embedded Python.

00:10:53.960 --> 00:11:01.040
And at that point, if one of the biggest applications that you're using in your pipeline speaks Python natively,

00:11:01.040 --> 00:11:09.500
there was a pretty serious indication to DreamWorks as a whole that maybe committing to Python rather than Perl would be a great idea

00:11:09.500 --> 00:11:19.320
because all of a sudden, all of this integration work that we're doing doesn't have to end outside of the applications that we're trying to tie together.

00:11:19.320 --> 00:11:26.740
We get the chance to run inside the application with code that you're using to tie everything together,

00:11:26.740 --> 00:11:33.060
which is amazing because all of a sudden you can speak the same language throughout the entire pipeline

00:11:33.060 --> 00:11:42.160
and do a much more seamless handoff for the artists, kind of, which is, again, the purpose of all of this is to make it so that they can spend their time

00:11:42.160 --> 00:11:44.240
just doing as much creative work as possible.

00:11:44.240 --> 00:11:45.100
Right.

00:11:45.100 --> 00:11:45.980
Yeah, that's really cool.

00:11:45.980 --> 00:11:54.320
rather than trying to integrate Perl and Python and have some sort of handshake or handoff, just make it Python all the way through, right?

00:11:54.320 --> 00:11:58.200
Yep, which actually was, at the time, controversial.

00:11:58.200 --> 00:12:06.400
It was a pretty big jump to do, and it wasn't clear that Python was going to take hold in the entertainment industry the way that it has.

00:12:06.900 --> 00:12:09.540
But since then, nowadays, it's a no-brainer.

00:12:09.540 --> 00:12:14.580
Almost every new piece of software that comes out has an embedded Python interpreter,

00:12:14.580 --> 00:12:23.100
and Python studios around the world is the de facto language that's used in order to do this kind of work,

00:12:23.100 --> 00:12:28.060
in order to tie stuff together, or even just the tools that you write for artists.

00:12:28.060 --> 00:12:32.700
Unless it has to be compiled, you tend to gravitate towards Python to do it.

00:12:33.120 --> 00:12:34.540
That totally makes sense to me.

00:12:34.540 --> 00:12:38.900
What I think is interesting, and I see it happening in data science, I see it happening in education,

00:12:38.900 --> 00:12:43.520
you're telling me it happens here as well, which makes a lot of sense,

00:12:43.520 --> 00:12:51.700
is it seems like Python is becoming more and more popular, and that popularity is almost accelerating.

00:12:52.700 --> 00:12:59.940
The rate of popularity growth seems to actually be growing, which is really cool to be part of it as that's happening.

00:12:59.940 --> 00:13:03.240
Why do you think that is the case in the entertainment industry?

00:13:03.820 --> 00:13:08.040
I think I was thinking about this in advance of sitting down.

00:13:08.040 --> 00:13:18.960
A lot of it, I think it got its start by being so easy to embed and having kind of this kitchen sink approach.

00:13:18.960 --> 00:13:24.180
Those two things combined together made it so that with just a little bit of C code,

00:13:24.500 --> 00:13:32.300
all of a sudden, the scripting environment that you could offer people became incredibly rich.

00:13:32.300 --> 00:13:40.800
And because of the ease of exposing your C, C++ libraries through to Python,

00:13:40.800 --> 00:13:44.520
even if you just go natively to the Python C API,

00:13:44.520 --> 00:13:53.540
it meant that all of these programs that didn't necessarily have a great scripting language

00:13:53.540 --> 00:13:57.680
could have one without too much investment.

00:13:57.680 --> 00:14:04.440
Now, Maya actually did have an incredibly embedded scripting language, still does, called Mel,

00:14:04.440 --> 00:14:06.340
but it was only for Maya.

00:14:06.340 --> 00:14:08.440
And people were Mel experts.

00:14:08.440 --> 00:14:10.240
There was a ton of work done in Mel,

00:14:10.240 --> 00:14:15.740
but your world ended at the boundaries that Maya provided.

00:14:15.740 --> 00:14:19.240
And it didn't give you too much of a chance to extend outside of that.

00:14:19.240 --> 00:14:24.000
Whereas with Python, you get the exact same kind of scriptability,

00:14:24.000 --> 00:14:27.840
but now you get to talk to the rest of the world and the rest of the universe

00:14:27.840 --> 00:14:30.200
that's also speaking Python, which is huge.

00:14:30.200 --> 00:14:36.580
So I think the application developers saw that,

00:14:36.580 --> 00:14:39.420
and it wasn't that huge an investment to say,

00:14:39.420 --> 00:14:41.020
like, hey, let's just slap Python in there.

00:14:41.020 --> 00:14:43.620
And then it paid dividends.

00:14:43.620 --> 00:14:48.560
And then once that started happening, it almost was a no-brainer.

00:14:48.560 --> 00:14:50.580
If you're going to be doing this work,

00:14:50.580 --> 00:14:56.180
you do it in a language that all of the big applications that you're running speak natively.

00:14:56.180 --> 00:15:00.140
And everything just kind of came together around that.

00:15:00.140 --> 00:15:02.620
Yeah, it just kind of snowballs from there.

00:15:02.620 --> 00:15:03.680
Exactly.

00:15:04.160 --> 00:15:06.560
And then once it's kind of established as the de facto,

00:15:06.560 --> 00:15:09.720
then everything else that comes in just has to speak it.

00:15:09.720 --> 00:15:15.220
In the industry, there's been a ton of new open source projects

00:15:15.220 --> 00:15:16.620
that are going on,

00:15:16.620 --> 00:15:21.620
like a standard way to pass 3D geometry between applications,

00:15:22.760 --> 00:15:28.260
a standard way of describing what's going on inside of a 3D scene.

00:15:28.260 --> 00:15:33.920
And every single one of those comes with Python bindings out of the box

00:15:33.920 --> 00:15:39.700
because everybody knows that you're going to have to interact with it via Python.

00:15:39.700 --> 00:15:40.560
Right.

00:15:40.640 --> 00:15:42.660
So if you don't have the Python bindings,

00:15:42.660 --> 00:15:46.640
it's almost like you don't have a mature scripting story or something like that.

00:15:46.640 --> 00:15:47.460
Yes.

00:15:47.460 --> 00:15:51.580
And it almost like that can be the bulk of your scripting story.

00:15:51.580 --> 00:15:55.200
And if you don't write it, then someone will write it really shortly

00:15:55.200 --> 00:15:57.480
because people need it.

00:15:57.480 --> 00:16:00.360
If you're going to be used, you need to speak Python.

00:16:00.360 --> 00:16:01.520
That's interesting.

00:16:01.520 --> 00:16:03.580
You were talking about sort of, you know,

00:16:03.580 --> 00:16:07.880
you had the scripting language Mel and it was doing fine, presumably,

00:16:07.880 --> 00:16:11.080
but it kind of, it could only do its thing.

00:16:11.080 --> 00:16:15.020
And I think that's also why Python's becoming one of the major reasons

00:16:15.020 --> 00:16:17.120
why it's becoming so popular in like data science

00:16:17.120 --> 00:16:20.940
is there are languages like R and so on.

00:16:20.940 --> 00:16:23.700
But if you want to build like a full stack sort of thing,

00:16:23.700 --> 00:16:26.340
like I want to do my, you know, the data science part,

00:16:26.340 --> 00:16:29.840
I want to do my science and my visualization and my web app

00:16:29.840 --> 00:16:32.480
and my database access all in Python.

00:16:32.480 --> 00:16:35.780
You know, you can't do that in these other more specialized languages.

00:16:36.460 --> 00:16:39.320
So it's interesting to see the parallels over there.

00:16:39.320 --> 00:16:41.280
Yeah, it is.

00:16:41.280 --> 00:16:48.200
I'd actually say the thing that I'm seeing where Python isn't in play as much

00:16:48.200 --> 00:16:51.600
comes from applications that were kind of originally developed

00:16:51.600 --> 00:16:56.220
for either like a very specific workflow or from outside the industry

00:16:56.220 --> 00:16:57.000
and they're coming in.

00:16:57.540 --> 00:17:02.940
a lot of those actually start with nowadays JavaScript engines built in

00:17:02.940 --> 00:17:07.680
because I think the same story has kind of repeated itself a little bit on the JavaScript side

00:17:07.680 --> 00:17:12.480
where it's so easy to embed at this point that for very little investment,

00:17:12.480 --> 00:17:16.640
you can go ahead and have a JavaScript interpreter running inside your app,

00:17:16.640 --> 00:17:19.480
just like you can have a Python interpreter inside your application.

00:17:20.140 --> 00:17:22.040
like within the entertainment industry,

00:17:22.040 --> 00:17:26.200
those are actually some of the big areas where we're kind of have a miss

00:17:26.200 --> 00:17:28.240
in terms of getting everything to talk to each other.

00:17:28.240 --> 00:17:36.400
Photoshop is a good example where there's various somewhat convoluted ways

00:17:36.400 --> 00:17:41.820
to try to get the JavaScript that Photoshop speaks to talk to Python outside of Photoshop

00:17:41.820 --> 00:17:44.540
and various places are doing that.

00:17:44.540 --> 00:17:51.480
But again, it's that idea of just how easy it is to create a scripting environment

00:17:51.480 --> 00:17:56.480
inside of these applications where there's a lot of value to being able to talk to it

00:17:56.480 --> 00:17:57.960
without writing compiled code.

00:17:57.960 --> 00:18:02.400
You know, I think the whole V8, the thing happening with Node,

00:18:02.400 --> 00:18:06.780
but really the V8 engine itself being a separate thing that you can host

00:18:06.780 --> 00:18:09.540
has done some pretty amazing stuff for JavaScript.

00:18:09.540 --> 00:18:11.020
Exactly.

00:18:11.560 --> 00:18:15.360
And I think some of the full stack, like it's Python all the way through,

00:18:15.360 --> 00:18:19.420
like the whole Node story and V8 is like it's JavaScript all the way through.

00:18:19.420 --> 00:18:20.300
Yeah.

00:18:20.300 --> 00:18:23.700
And it has a lot of the similar kind of parallels where it has a little bit more

00:18:23.700 --> 00:18:26.300
of the kitchen sink, not as much as Python does,

00:18:26.300 --> 00:18:30.580
but there's more and more JavaScript libraries popping up all the time,

00:18:30.580 --> 00:18:33.060
just like there are Python libraries too.

00:18:33.060 --> 00:18:36.680
So it's interesting just seeing that pattern replicate itself.

00:18:36.680 --> 00:18:38.880
It's kind of detrimental from where I'm sitting,

00:18:38.880 --> 00:18:40.880
because I would love it if all of those things spoke Python.

00:18:40.980 --> 00:18:41.860
It would make my job easier,

00:18:41.860 --> 00:18:45.720
but it's just kind of interesting seeing that take hold again.

00:18:53.720 --> 00:18:55.460
continuous delivery.

00:18:55.460 --> 00:19:03.160
Continuous delivery isn't just a buzzword.

00:19:03.160 --> 00:19:06.820
It's a shift in productivity that will help your whole team become more efficient.

00:19:06.820 --> 00:19:12.980
With SnapCI's continuous delivery tool, you can test, debug, and deploy your code quickly and reliably.

00:19:12.980 --> 00:19:18.880
Get your product in the hands of your users faster and deploy from just about anywhere at any time.

00:19:18.880 --> 00:19:24.120
Did you know that ThoughtWorks literally wrote the book on continuous integration and continuous delivery?

00:19:24.120 --> 00:19:29.260
Connect Snap to your GitHub repo and they'll build and run your first pipeline automagically.

00:19:29.620 --> 00:19:35.840
Thanks SnapCI for sponsoring this episode by trying them for free at snap.ci slash talkpython.

00:19:44.360 --> 00:19:45.240
That is super interesting.

00:19:45.240 --> 00:19:45.700
That is super interesting.

00:19:45.700 --> 00:19:53.900
It makes a lot of sense to say either Python or JavaScript as a proposition for somebody who's not a developer but needs to automate a thing.

00:19:53.900 --> 00:20:00.740
To say your API is C++ and you've got to have this compiler with these headers and these libs you're statically linking.

00:20:00.740 --> 00:20:02.720
That just doesn't fly, does it?

00:20:03.020 --> 00:20:03.520
No.

00:20:03.520 --> 00:20:09.020
The stuff that Python is used for tends to be a lot higher level workflow.

00:20:09.020 --> 00:20:12.140
I think you're taking workflow and translating it to code.

00:20:12.140 --> 00:20:14.680
So it tends to be pretty dynamic.

00:20:14.680 --> 00:20:16.680
It needs to be updated constantly.

00:20:16.680 --> 00:20:24.720
I mean, almost each project you'll be tweaking the stuff to work how the people working on that project need to work to get their job done most efficiently.

00:20:24.720 --> 00:20:27.060
And it doesn't need to be performant, I guess.

00:20:27.060 --> 00:20:30.380
Yeah, because it's just orchestrating the things that are probably written in C.

00:20:30.380 --> 00:20:31.560
Exactly.

00:20:31.560 --> 00:20:32.540
Interesting.

00:20:32.540 --> 00:20:40.040
You were talking about JavaScript and having the JavaScript try to interact with Python somehow.

00:20:40.040 --> 00:20:44.900
And obviously getting out of a JavaScript engine can be pretty tricky because they try to sandbox you a lot.

00:20:44.900 --> 00:20:55.320
But have you looked at PyPyJS or one of these embedded JavaScript foundation Python implementations?

00:20:55.320 --> 00:20:56.940
We haven't.

00:20:56.940 --> 00:20:57.980
I guess I should qualify.

00:20:57.980 --> 00:21:10.420
What I'm doing at Autodesk is actually a group that is putting together one of these production pipelines that is just part of a production management product that we make.

00:21:10.900 --> 00:21:29.900
So I'm now not working at a studio doing all this pipeline work, but working at a software company that is, again, just trying to make it so that the various workflows that we see being done in VFX and animation, just content creation in general, we make it really easy for people to get some of the grunt work out of that.

00:21:29.900 --> 00:21:35.400
Given that setup, we're not embedding the interpreters ourselves.

00:21:35.400 --> 00:21:41.900
So I'm working on the scripting code that's going to be able to talk to that application.

00:21:41.900 --> 00:21:44.920
So it's like Photoshop has JavaScript.

00:21:44.920 --> 00:21:52.440
We're not going to be able to embed Python in it, although we could do a plugin, get an embedded Python running.

00:21:52.440 --> 00:21:57.980
But then there's a lot of threading issues and other stuff that we've tried to be as seamless as possible.

00:21:57.980 --> 00:22:01.400
But you can only do so much with an application.

00:22:01.400 --> 00:22:04.660
It all depends on what kind of SDK and API they offer you.

00:22:05.120 --> 00:22:07.140
So we don't have that level of control.

00:22:07.140 --> 00:22:16.840
But we are looking at some standard RPC kind of libraries and trying to figure out what does make for a good bridge between those worlds.

00:22:16.840 --> 00:22:17.740
Right.

00:22:17.740 --> 00:22:24.400
I think probably the easiest way to bridge JavaScript to another thing is some kind of network layer, right?

00:22:24.400 --> 00:22:28.800
Network layer or even if you're not going over the network.

00:22:28.800 --> 00:22:29.660
Yeah, exactly.

00:22:30.260 --> 00:22:35.620
Like RPC, even if it's just talking to another process on the same machine.

00:22:35.620 --> 00:22:36.620
Yes, exactly.

00:22:36.620 --> 00:22:39.060
But making that a really rich communication channel.

00:22:39.060 --> 00:22:42.700
And there's some impressive projects out there that do that.

00:22:42.700 --> 00:22:51.400
And we're actually kicking off an effort to evaluate them and try to pick one that's going to work well for us.

00:22:51.660 --> 00:22:59.100
One of the things you'd sent over is you talked about sort of Python and games.

00:22:59.100 --> 00:23:00.740
And what's the story there?

00:23:00.740 --> 00:23:01.560
Sure.

00:23:01.560 --> 00:23:12.880
Games is kind of an interesting take on all of this because VFX and pixel production has been around longer

00:23:12.880 --> 00:23:17.620
and has a bunch of different constraints than games have.

00:23:17.620 --> 00:23:34.280
So far, games have really been driven by the game engine and the developers as almost separate from the creation of the models and the shaders that show up in the game.

00:23:34.400 --> 00:23:36.140
All of those need to play well together.

00:23:36.140 --> 00:23:47.300
But it's almost been more of an agile developer kind of style than a cascade of content flowing between different departments,

00:23:47.300 --> 00:24:00.800
which is what you see in animation and VFX, mostly because the complexity of all of the environments and models that VFX has been playing around with has been higher than what you've seen in games.

00:24:01.000 --> 00:24:14.560
But that's actually switching a lot nowadays, where the complexity of production in a game is a lot of times higher than what you would see in a feature film.

00:24:14.560 --> 00:24:19.980
The need for this kind of pipeline is showing up in games more and more.

00:24:20.560 --> 00:24:32.140
But they've got this whole coding side to the game where the artists are just a piece of what's going on and they need the developers in order to tie everything that they're creating in.

00:24:32.140 --> 00:24:34.180
And it all comes together in the game engine.

00:24:34.180 --> 00:24:38.280
That is what's actually going to be running all this stuff at the end of the day.

00:24:38.280 --> 00:24:44.660
What we've seen there is there's some game engines that speak JavaScript coming out now.

00:24:44.960 --> 00:24:47.060
The tried and true has been .NET.

00:24:47.060 --> 00:24:51.760
Just a lot of this has been pretty Microsoft-centric.

00:24:51.760 --> 00:25:01.500
And the .NET code can speak Python, the iron Python that's out there, which has been kind of an interesting tie-in for us.

00:25:01.500 --> 00:25:07.760
Or Lua, actually, is another scripting language that a lot of the game engines tend to speak.

00:25:08.140 --> 00:25:10.440
But it's yet another kind of separate world.

00:25:10.440 --> 00:25:13.540
Even the .NET side has limitations.

00:25:13.540 --> 00:25:16.740
It lets us do kind of basic Python integration.

00:25:16.740 --> 00:25:24.400
But you hit brick walls pretty quickly when you want to do cross-platform networking stuff or GUIs, especially.

00:25:24.400 --> 00:25:32.240
You have to start writing things specifically for the .NET flavor as opposed to treating it just like another Python interpreter that's out there.

00:25:32.520 --> 00:25:32.880
Right.

00:25:32.880 --> 00:25:37.940
Yeah, you get very, very specific, like WPF-type stuff.

00:25:37.940 --> 00:25:41.320
You can't do PySide, PyQt type of things.

00:25:41.320 --> 00:25:43.660
That kind of, which is much more cross-platform.

00:25:43.660 --> 00:25:48.500
Can you give me just your feedback on what you've done and what it's like to work with IronPython?

00:25:48.500 --> 00:25:49.620
I haven't actually...

00:25:49.620 --> 00:25:54.060
I've played with it and looked at it, but I don't really know much about it.

00:25:54.060 --> 00:25:55.180
So it'd be interesting to hear.

00:25:55.180 --> 00:25:58.020
I've actually found it to be pretty good.

00:25:58.020 --> 00:26:10.660
The boundaries that you hit are kind of what you'd expect, where Python itself starts having dependencies on third-party libraries, like SSL implementation or the GUI kind of side of the world.

00:26:10.660 --> 00:26:21.220
But, I mean, personally, I've had fun little side projects like getting IronPython up and running in a plugin for Microsoft Office projects.

00:26:21.220 --> 00:26:24.960
So that, you know, there's an API that's available only via Python.

00:26:24.960 --> 00:26:33.960
You can start interacting with it from within Excel in order to kind of get deep scripting ability within something like that without having to write visual basics.

00:26:33.960 --> 00:26:37.960
So that you can, again, reuse that Python code base that you've got.

00:26:37.960 --> 00:26:39.460
Yeah, that's quite interesting.

00:26:40.220 --> 00:26:57.300
It's kind of a Frankenstein kind of approach, but a lot of the integration that we end up doing has some element of that because you're really trying to establish this rich Python programming environment in all of these different spots.

00:26:57.300 --> 00:26:59.400
And some of them are more conducive to it.

00:26:59.400 --> 00:27:03.120
Some of them, you kind of have to jam it in.

00:27:03.120 --> 00:27:05.320
They resist a little more, huh?

00:27:05.680 --> 00:27:06.120
Exactly.

00:27:06.120 --> 00:27:09.660
IronPython was a Microsoft project.

00:27:09.660 --> 00:27:14.560
I think it was created by people inside Microsoft or maybe they created it and promptly joined Microsoft.

00:27:14.560 --> 00:27:16.820
I can't remember the exact chronology of it.

00:27:16.820 --> 00:27:25.080
But they, a while ago, set it free and said, we're not really doing anything more with IronPython, but it's now this sort of open source project.

00:27:25.080 --> 00:27:26.420
The world can have it.

00:27:26.960 --> 00:27:33.340
And I just, like, a few hours ago, although it's been out for a couple of months, learned about this thing called Pyjion.

00:27:33.340 --> 00:27:34.620
Pyjion?

00:27:34.620 --> 00:27:36.260
P-Y-J-I-O-N.

00:27:36.260 --> 00:27:37.420
Have you heard of this?

00:27:37.420 --> 00:27:41.280
I've heard the name, but I don't actually know much more than that.

00:27:41.280 --> 00:27:49.040
It's kind of a competitor to PyPy, which is a JET compiled runtime implementation for Python.

00:27:49.400 --> 00:27:54.420
But this is one that runs on the new open source cross-platform version of .NET.

00:27:54.420 --> 00:27:57.360
So maybe there's something interesting there coming in the future.

00:27:57.360 --> 00:27:57.780
I don't know.

00:27:57.780 --> 00:27:58.420
We'll see.

00:27:58.420 --> 00:28:03.720
But it's interesting to see them taking kind of a second shot at something like that.

00:28:03.720 --> 00:28:04.220
Cool.

00:28:04.220 --> 00:28:05.280
I'll just check that out.

00:28:05.280 --> 00:28:29.240
Because something like that could potentially open up, like, the game engines that speak .NET to the deep integration with kind of the rest of the creative process that would share the pipeline from feature animation and the kinds of complex asset builds, like the models and the various assets that you see on screen, that process for games.

00:28:29.240 --> 00:28:30.460
Yeah, absolutely.

00:28:30.460 --> 00:28:37.280
I mean, IronPython seemed really cool, but kind of like you were saying, its limitation is you're all in on Windows.

00:28:37.280 --> 00:28:39.840
Like, it only runs on Windows.

00:28:39.840 --> 00:28:45.620
You have to really program against the .NET, so at the time, Windows-specific APIs.

00:28:45.620 --> 00:28:50.940
But with the cross-platform plus this, you know, maybe that sort of opens up again.

00:28:50.940 --> 00:28:52.360
It's going to be really interesting.

00:28:52.360 --> 00:28:53.500
I don't know where it is.

00:28:53.500 --> 00:28:55.400
Is that the mono environment?

00:28:55.400 --> 00:28:56.100
No.

00:28:56.100 --> 00:29:06.760
No, it's the mono environment was Miguel de Caza's work on sort of re-implementing .NET, which is Herculean.

00:29:06.760 --> 00:29:10.380
And they've gone on to do Xamarin, right, with the mobile stuff.

00:29:10.520 --> 00:29:26.800
So this is a new effort called the Core CLR by Microsoft to do a shell or a core kernel of .NET that's totally cross-platform that you can do on OS X and Linux and sort of, but, you know, official, not like a sort of frenemy-type project in what they're doing.

00:29:27.160 --> 00:29:36.700
So it'll be interesting to see if this can bring a really rich version of Python to that story, kind of like we have Jython for Java.

00:29:36.700 --> 00:29:37.900
Exactly.

00:29:37.900 --> 00:29:40.500
But, you know, that's not really updated really quickly.

00:29:40.500 --> 00:29:43.760
So maybe, I don't know, I have high hopes, but they may get dashed.

00:29:43.760 --> 00:29:44.060
We'll see.

00:29:44.060 --> 00:29:46.120
I hope it comes out awesome.

00:29:46.120 --> 00:29:46.460
We'll see.

00:29:46.460 --> 00:29:48.040
Definitely dig into that.

00:29:48.040 --> 00:29:48.380
Thanks.

00:29:48.380 --> 00:29:49.160
Yeah, you bet.

00:29:49.160 --> 00:30:04.280
This episode is brought to you by OpBeat.

00:30:04.280 --> 00:30:07.040
OpBeat is application monitoring for developers.

00:30:07.040 --> 00:30:11.500
It's performance monitoring, error logging, release tracking, and workflow in one simple product.

00:30:11.500 --> 00:30:18.220
OpBeat is integrated with your code base and makes monitoring and debugging of your production apps much faster and your code better.

00:30:18.900 --> 00:30:21.340
OpBeat is free for an unlimited number of users.

00:30:21.340 --> 00:30:28.880
And starting today, December 1st, OpBeat is announcing that their Flask support is graduating from beta to a full commercial product.

00:30:28.880 --> 00:30:32.820
Visit opbeat.com slash Flask to get started today.

00:30:32.820 --> 00:30:48.320
There sounds like a lot of positive news from all the cool things you're doing and the way you're able to weave these pipelines together.

00:30:48.640 --> 00:30:53.340
I want to kind of talk about what you see, the sticking points and so on a bit.

00:30:53.340 --> 00:31:03.380
But before we do, maybe just to give me and everyone else a better idea, could you describe what the steps are and this pipeline that you talk about?

00:31:03.380 --> 00:31:05.000
What are people doing?

00:31:05.000 --> 00:31:06.160
What does the software have to do?

00:31:06.160 --> 00:31:08.480
Just so we get a little more concrete idea there.

00:31:08.480 --> 00:31:14.320
The kind of nature of this is that you can go down these giant rabbit holes.

00:31:14.320 --> 00:31:17.700
Like you can go extremely deep into automating things.

00:31:18.360 --> 00:31:27.660
And traditionally, only fairly large studios that could afford having an R&D department had the ability to go deep.

00:31:27.660 --> 00:31:35.560
Lots of places had pipelines, but they tend to be pretty easy handoffs rather than tackling a lot of the deeper issues.

00:31:35.800 --> 00:31:39.560
It can start as early as a script.

00:31:39.560 --> 00:31:53.980
If you've got a script that you're thinking of making a movie of or that you need to do visual effects for, it tends to come in from some program that stores it as an XML file.

00:31:53.980 --> 00:32:03.840
You can write a parser for that in Python and use that in order to get a listing of here's all of the different scenes in the movie and here's the characters and location, things like that.

00:32:03.840 --> 00:32:12.820
Which, if you were doing this by hand, traditionally you would do a breakdown where you would just build up a spreadsheet of all of those things so that you can start getting your head around what you have to build.

00:32:12.820 --> 00:32:19.280
You go ahead and you start storyboarding things so that you get an idea of what everything is going to look like.

00:32:19.280 --> 00:32:21.980
And there's various software that's built around storyboarding.

00:32:22.240 --> 00:32:26.120
I mean, Photoshop is kind of one of few players in that area.

00:32:26.120 --> 00:32:37.060
Even then, you tend to just have these images that you're working on and then tracking those to say, OK, here's the current storyboards that relate to this scene.

00:32:37.060 --> 00:32:44.420
We want to hand them off to editorial that's going to start cutting them together into a movie that we can watch to get a sense of how this plays together.

00:32:44.420 --> 00:32:47.280
There's lots of iterations there that go back and forth.

00:32:47.280 --> 00:32:57.320
So you have to keep track of those files and know which ones were approved, what the notes were, so that whoever's going to be doing the next iteration on that can take those into account.

00:32:57.320 --> 00:33:05.940
And it's really trying to put some organization around a very creative, quick iteration workflow without getting in the way of that creative process.

00:33:06.500 --> 00:33:14.920
So then you start getting this editorial content together where you're cutting together these images on a timeline and you get a sense of timing.

00:33:15.440 --> 00:33:27.420
That tends to be a place where you need a lot of R&D to dig in because a lot of the editorial software out there, Avid being the biggest one, tends to be a little bit of a black box.

00:33:27.420 --> 00:33:37.480
You've got Final Cut, which has an XML spec that you can start taking apart, but you don't get a chance to understand too much of what's going on inside of editorial software.

00:33:37.720 --> 00:33:38.200
Sure.

00:33:38.200 --> 00:33:47.800
So are you guys doing actual processing of MP4 files or raw assets in Python and looking at them, that kind of stuff?

00:33:47.800 --> 00:33:58.560
So an example of how Python would tie in over there, not with Autodesk, but my previous job at a studio that's in Portland called Leica that does stop motion animation.

00:33:58.560 --> 00:34:08.780
We actually, there's a C library around this file format called AAF that is what the Avid editorial software speaks.

00:34:08.780 --> 00:34:12.620
And it's a pretty obscure format, very complicated.

00:34:12.620 --> 00:34:14.400
The API is very complicated.

00:34:14.400 --> 00:34:33.060
And we wrapped that with Python bindings so that we could take a export from Avid and really deconstruct it, which meant that we actually were able to know which storyboards an editor cut in where and what characters were in that storyboard.

00:34:33.060 --> 00:34:55.720
So that when you're going ahead and putting together a shot, you would know generally the contents of that and all of the comments that came through, all of the notes that the director had for the storyboard artist, which is incredibly valuable because in the shot, you've got to go ahead and take your 3D models and bring them in.

00:34:55.720 --> 00:35:15.600
So having the list of what's already been included from the storyboard artist gives your layout artist who's doing that work a leg up and you can get started and you can write a tool to automate the initial pass at that and then let him actually do the creative piece of that, which is where you should be spending his time rather than searching for the right models to put in.

00:35:15.600 --> 00:35:24.700
And then when it gets to animation, it's really valuable for the animator to be able to see all of the notes that the director had for the storyboard artist because they're very applicable to the job that he has to do.

00:35:25.460 --> 00:35:32.780
And none of that would be readily available without being able to connect the dots between all of those different handoffs.

00:35:32.780 --> 00:35:48.780
So connecting those dots and managing those handoffs and making it so that you can deal with this explosion of data that happens throughout this process in a kind of tractable, meaningful way is what the pipeline is responsible for.

00:35:49.000 --> 00:35:49.220
Okay.

00:35:49.220 --> 00:35:49.280
Okay.

00:35:49.280 --> 00:35:51.700
That gives me a really good view into it.

00:35:51.700 --> 00:36:02.060
I think it seems like there's all these different apps that the various people have to use, editors, artists, and so on, and they don't necessarily talk to each other.

00:36:02.060 --> 00:36:02.580
Right?

00:36:02.580 --> 00:36:03.660
So you're kind of writing.

00:36:03.660 --> 00:36:04.060
Yeah.

00:36:04.060 --> 00:36:12.260
So you're kind of writing this glue that can turn that into like one almost distributed data source or something.

00:36:12.260 --> 00:36:12.560
Right?

00:36:12.560 --> 00:36:13.760
Right.

00:36:14.180 --> 00:36:39.220
It's kind of like if you're used to using Excel on one front and you've got this text editor that you use on another front, if you were able to kind of connect those together because it knew that you're doing accounting work and it was able to actually react to the files that you're saving from the text editor, parse them, and automatically bring them into your spreadsheet so that you didn't have to manually do that.

00:36:39.220 --> 00:36:45.280
Each time you've changed one piece of information and get the rest of it in sync with that.

00:36:45.280 --> 00:36:49.020
It's kind of that on an extremely grand scale.

00:36:49.020 --> 00:37:03.060
I don't know if you have the answer off the top of your head or really no, but I'm thinking about all these different processes and all these different raw editions and then produced and sliced up editions.

00:37:04.060 --> 00:37:08.740
So these files, you know, if I go and get like a movie, it's probably a couple of gigabytes.

00:37:08.740 --> 00:37:15.520
But what's the data, the total data size for like a modern production movie or something?

00:37:15.520 --> 00:37:16.420
Do you have an idea?

00:37:16.420 --> 00:37:19.680
Oh, we're in many terabytes land nowadays.

00:37:20.200 --> 00:37:32.760
Yeah, it is terabytes and terabytes in order to do the models and the effects work and all of the simulations that need to happen in order to get the quality that we're seeing on screen.

00:37:33.820 --> 00:37:39.360
It's incredible the amount of data that goes into just those final pixels that you see.

00:37:39.360 --> 00:37:44.920
So like the gig, couple gig download that you get, which is a really high quality video that you could watch.

00:37:44.920 --> 00:37:45.700
Yeah.

00:37:45.700 --> 00:37:52.680
Each of those, you know, frames as gigabytes and gigabytes and gigabytes, like hundreds of gigs behind it alone.

00:37:52.680 --> 00:37:56.660
So we put it all together at 24 frames a second for feature length.

00:37:56.820 --> 00:37:58.400
It definitely adds up.

00:37:58.400 --> 00:37:58.740
Yeah.

00:37:58.740 --> 00:37:59.820
Wow, that's crazy.

00:37:59.820 --> 00:38:14.360
It is the scale and especially just the amount of data and the number of people involved and the amount of handoffs that happen in order to achieve that thing that is on the screen is pretty amazing.

00:38:14.360 --> 00:38:16.060
Yeah, I bet it is.

00:38:16.620 --> 00:38:22.220
Everything sounds really good, but you said that there was actually some issues that you were running into.

00:38:22.220 --> 00:38:28.280
Like one of them was that using Python 3 in this world is not something you can just necessarily jump straight into.

00:38:28.280 --> 00:38:38.220
A lot of the issues kind of around Python use almost come from how successful Python has been and how it's embedded in so many different places.

00:38:38.460 --> 00:38:53.360
We just have this versionitis problem where currently the code that we're writing, we actually support back to Python 2.4 because there's some versions of software that are out there and they've been updated since.

00:38:53.360 --> 00:38:58.260
But studios are pretty notoriously slow to update if everything is still working.

00:38:58.260 --> 00:39:00.640
It had Python 2.4 embedded in it.

00:39:00.640 --> 00:39:05.840
There's definitely a lot of Python 2.5, 2.6 that's still out there.

00:39:06.080 --> 00:39:08.900
The majority of modern stuff is on Python 2.7.

00:39:08.900 --> 00:39:14.920
There's like one notable source project that's made the jump to Python 3.

00:39:14.920 --> 00:39:29.200
But because the nature of this pipeline work is to glue stuff together, when you have a jump that's not backwards compatible, it kind of makes it hard because you have to have two different code bases.

00:39:29.200 --> 00:39:37.480
There's one that will run for all of the environments that are Python 2.5 based and one that will run for everything that's Python 3.5 based.

00:39:37.880 --> 00:39:40.180
And you can kind of work to minimize this.

00:39:40.180 --> 00:39:50.620
But there's definitely this hard jump that happens because not all of these pieces of software are going to update their Python interpreters at the same time.

00:39:50.620 --> 00:39:58.740
And there's nothing that says that you'll be able to, as a studio, be able to update to that version of that software at the same time.

00:39:58.960 --> 00:40:08.840
It gets into a whole lot of issues from just cost, support, licensing, getting the bugs out of it, down to having the resources to update your code to run in Python 3.

00:40:08.840 --> 00:40:10.020
Wow, that's crazy.

00:40:10.020 --> 00:40:18.680
That's going to be an interesting cliff for the visual effects feature animation world to get to the other side of.

00:40:18.680 --> 00:40:26.940
There's various attempts within the industry to try to control this versionitis issue because it's not just Python.

00:40:26.940 --> 00:40:31.180
There's all sorts of common libraries that are used throughout production.

00:40:31.180 --> 00:40:33.780
And whenever they don't match, it causes issues.

00:40:33.780 --> 00:40:38.640
So there's a VFX reference platform that tries to standardize some things.

00:40:38.640 --> 00:40:41.680
Python 3 isn't even on the radar of that.

00:40:41.680 --> 00:40:48.400
I think Python 2.7.whatever is the target for the foreseeable future.

00:40:48.400 --> 00:40:56.160
I think it's probably going to be dropping support with a combination of security issues that just force updates.

00:40:56.160 --> 00:41:00.600
That'll be the thing that finally gets us as an industry to the other side of that.

00:41:01.440 --> 00:41:13.920
But it is kind of unfortunate just because of the wide range of versions that you have to support and the dependent libraries and all of the complications that come up trying to develop software in that kind of an environment.

00:41:13.920 --> 00:41:16.920
Yeah, that really, that's quite challenging, it sounds like.

00:41:16.920 --> 00:41:26.340
I mean, when I think of people that are using Python 2 and they say we can't switch to Python 3, in my mind, I often think of a couple things.

00:41:26.340 --> 00:41:34.060
Like one is we have a quarter million or more lines of code that was tested and is working on Python 2.

00:41:34.060 --> 00:41:39.000
And we're just not going to change that because it's too risky and it's just, you know, it's not broken.

00:41:39.000 --> 00:41:40.220
We don't really want to mess with it.

00:41:40.220 --> 00:41:41.120
That kind of thing.

00:41:41.120 --> 00:41:48.880
And then the other is we've got some key library that we depend on, some package that itself is only Python 2.

00:41:48.880 --> 00:41:52.300
So until that gets upgraded, you can't only flip your app, right?

00:41:52.780 --> 00:41:57.240
But this is a whole nother level, like those two things still apply.

00:41:57.240 --> 00:41:58.860
They definitely still apply.

00:41:59.940 --> 00:42:01.280
They're just one part, right?

00:42:01.280 --> 00:42:10.480
Because you've got multiple compiled, distributed, shipped, non-updating, potentially pieces of software that have a host of versions packed into them.

00:42:10.480 --> 00:42:12.320
And you've got to fit into that.

00:42:12.320 --> 00:42:13.120
That's pretty crazy.

00:42:13.120 --> 00:42:19.360
And then you guys are building software that works with multiple versions of those, right?

00:42:19.360 --> 00:42:21.560
Because you're not building the pipeline to make a movie.

00:42:21.560 --> 00:42:24.520
You're building software to give to the people that are making the movie.

00:42:24.520 --> 00:42:28.220
So it's just, you know, a few more dimensions there.

00:42:28.220 --> 00:42:47.600
It actually is one of the things that really excites me about the project that I'm working on where almost for the first time, rather than building one of these just for a particular studio or as kind of just an open source project, we're trying to do it with the resources of a company like Autodesk behind it.

00:42:47.680 --> 00:42:58.360
Autodesk, which all of a sudden, like the jump to Python 3, which for the industry as a whole feels like it's a huge issue.

00:42:58.360 --> 00:43:07.840
It gives us a place where if all of these vendors for the major applications got together and said, okay, here's the version where we need to switch to Python 3.

00:43:07.840 --> 00:43:22.200
We could do a lot of the legwork for the industry as a whole and get stuff going and create that bridge over to Python 3, which doesn't exist if every studio had to do that themselves and manage it themselves.

00:43:22.200 --> 00:43:23.220
Yeah, that's really interesting.

00:43:23.220 --> 00:43:31.560
You're one of the few groups that lives, you basically are one of the few groups that live between all these pieces of software where everyone else is just consuming it, right?

00:43:32.120 --> 00:43:32.620
Exactly.

00:43:32.620 --> 00:43:43.080
And everyone, you know, almost every company figures out a way to get that in-between stuff written in order to automate stuff that they do.

00:43:43.080 --> 00:43:44.340
It's just too tedious otherwise.

00:43:45.160 --> 00:43:55.360
But we're kind of a central place where we can do that, which gives these software developers someone to work with in order to figure out some of the issues.

00:43:55.360 --> 00:44:02.260
And we definitely wouldn't encounter all of the issues that studios out there could see with the setup.

00:44:02.520 --> 00:44:11.020
But we at least can take it a big step further and prove that this kind of integration does work on the other side of that giant chasm.

00:44:11.020 --> 00:44:12.580
And here's how we did it.

00:44:12.580 --> 00:44:15.620
And here's the issues we found and help other people cross it.

00:44:15.620 --> 00:44:23.040
So another thing that you said that was kind of challenging, kind of like this version story, is PySide and PyQt.

00:44:23.040 --> 00:44:28.860
Can you maybe first of all tell people what that is so that everyone knows?

00:44:28.860 --> 00:44:30.480
And then what's the story there?

00:44:30.480 --> 00:44:37.980
Sure. Qt is a cross-platform C++ GUI toolkit.

00:44:37.980 --> 00:44:50.280
So you can build complicated applications using Qt as the components that you're using to build all of the GUI widgets and do it in a way that's cross-platform.

00:44:50.280 --> 00:44:55.560
So it runs on Linux and on OSX and on Windows.

00:44:55.760 --> 00:45:06.380
Yeah. And one thing I'd like to add about that is that's one of the few cross-platform UI frameworks that I think looks modern and really good on all the different environments.

00:45:06.380 --> 00:45:09.580
Like a lot of times you're like, whoa, that is definitely not native.

00:45:09.580 --> 00:45:11.860
That looks like a weird app or whatever, you know.

00:45:11.860 --> 00:45:15.440
But I think Qt or Qt, it's nice.

00:45:15.920 --> 00:45:19.040
Yeah. I mean, it has a rich set of widgets.

00:45:19.040 --> 00:45:20.260
They're very configurable.

00:45:20.260 --> 00:45:23.160
It ties in nicely with the native OSs.

00:45:23.160 --> 00:45:24.440
It's been around a while.

00:45:24.440 --> 00:45:25.980
It's been used in a ton of places.

00:45:25.980 --> 00:45:28.460
Some huge applications use Qt.

00:45:28.460 --> 00:45:30.220
And it's funny that you say it looks modern.

00:45:30.480 --> 00:45:39.680
There's actually been this divide in the Qt world between Qt4 and Qt5, similar to the kind of the jump to Python 3, where Qt5 is this big leap forward.

00:45:39.680 --> 00:45:47.260
And that's one of the other things that the entertainment industry is trying to navigate the jump from Qt4 to Qt5.

00:45:47.640 --> 00:46:00.540
And to go back to what is Qt and what is PySide, PySide and PyQt are two Python bindings to that Qt library so that you can build these cross-platform, good-looking, complicated UIs in complete Python.

00:46:00.540 --> 00:46:01.820
It's pretty prevalent.

00:46:01.820 --> 00:46:02.580
It's out there.

00:46:02.580 --> 00:46:03.040
It's great.

00:46:03.040 --> 00:46:07.800
But PyQt is not open source.

00:46:07.800 --> 00:46:09.380
There's licensing restrictions around it.

00:46:09.380 --> 00:46:18.780
It makes it hard to build a commercial product around that, even though kind of supporting it as a runtime is completely doable.

00:46:18.780 --> 00:46:24.240
But in order to actually run a PyQt app, you need to be licensed if it's a commercial software.

00:46:24.240 --> 00:46:34.160
PySide, it was the branch, was another implementation of that Python binding in order to kind of get around those licensing restrictions to make it so that within Python,

00:46:34.160 --> 00:46:40.360
you could build these rich GUIs without having all those licensing constraints that come with PyQt.

00:46:40.360 --> 00:46:45.560
The problem with PySide is that it's one of those open source projects that's kind of stalled out.

00:46:45.560 --> 00:46:51.560
And there has not been a version that supports Qt5.

00:46:51.560 --> 00:47:01.040
So ironically, one of the big reasons that the industry can't cleanly jump over to Qt5 is because Python is everywhere.

00:47:01.040 --> 00:47:06.760
And people have used Python to build these really awesome production tools that are Qt4.

00:47:06.760 --> 00:47:10.480
And there needs to be an upgrade path for all of that code.

00:47:10.480 --> 00:47:20.320
So figuring out how to kind of breathe some life into the PySide project and get it going has been a topic of consideration.

00:47:20.320 --> 00:47:31.020
And it's something that, with the help of that VFX reference platform that I talked about earlier, because they are trying to drive this jump to Qt5 because there's a lot of improvements there.

00:47:31.020 --> 00:47:33.580
Qt4 is starting to show some age.

00:47:33.580 --> 00:47:41.240
They're trying to drive some life into the PySide project in order to get this update to be possible.

00:47:41.760 --> 00:47:51.260
It's an interesting thing where, again, this dependency and having all of these different apps coordinate this kind of an upgrade affects how we use Python and what's possible.

00:47:51.260 --> 00:47:55.320
I tend to really think about, I guess, how that kind of paints you into a corner.

00:47:55.320 --> 00:48:05.320
I did play around with PySide and PyQt and ran into the issue of, well, the licensing on PyQt, it seems overly restrictive.

00:48:05.320 --> 00:48:12.960
I'm not really against commercial software, but it seems like, I don't know, it just seems harder or more restrictive than it should be.

00:48:12.960 --> 00:48:16.440
But then again, I tried to use PySide and it was like almost working.

00:48:16.440 --> 00:48:18.180
It was frustrating.

00:48:18.680 --> 00:48:21.220
But I knew if I could get him to work, I'd have something really cool.

00:48:21.220 --> 00:48:23.960
But I kind of gave up and went and did something else altogether.

00:48:23.960 --> 00:48:24.920
Yeah.

00:48:24.920 --> 00:48:26.920
We do a ton with PySide.

00:48:26.920 --> 00:48:32.360
It would be amazing to have it be under more active development.

00:48:32.360 --> 00:48:34.200
Like I said, it's almost there.

00:48:34.200 --> 00:48:35.340
You can do a lot with it.

00:48:35.340 --> 00:48:44.560
There's definitely kind of low-level issues with memory management and things like that at the interface between the Qt world and the Python world.

00:48:44.560 --> 00:48:57.060
that if it was under active development, we would be seeing some upgrades happen that would clean that up and make it easier to develop rich Python GUIs that are embedded in these giant applications,

00:48:57.060 --> 00:49:12.080
which is where we actually realize a lot of just saving artist time so that they don't have to hunt around for files or manually export things knowing the settings that they do.

00:49:12.080 --> 00:49:19.720
And then they can just get back to doing the creative part of their job.

00:49:19.720 --> 00:49:27.620
And all of that currently for a lot of places, unless they bought the license for PyQt, is done in PySide.

00:49:27.620 --> 00:49:41.820
Have you considered using some of the fully native options like Py, OBJ, C, OS X, and Iron Python and WPF on Windows and just having a separate UI layer?

00:49:41.820 --> 00:49:43.820
Definitely thought about it.

00:49:43.820 --> 00:49:51.860
It's a lot of overhead when something like PySide is there and you can write it once and have it work everywhere.

00:49:52.620 --> 00:49:54.840
Yeah, it makes perfect sense.

00:49:54.840 --> 00:50:12.380
It's something I've been thinking about some native apps in Python and I'm like, well, you know, how much, I guess it depends on how much of your code and complexity is in the UI itself and how much you can push down to packages that those two distinct UIs that you'd have to write would consume, you know?

00:50:12.380 --> 00:50:23.000
I mean, at that point, you start wondering, like, would it make sense to have the GUI level written in actually Objective-C for OS X directly and embed a Python interpreter and tie it in like that?

00:50:23.000 --> 00:50:33.400
Like, at that point, it being in Python, you start wondering if having that layer be Python makes sense because you're having to code it specifically for the operating system itself.

00:50:33.620 --> 00:50:37.080
And for the GUI work, you get to use Xcode in a really deep way.

00:50:37.080 --> 00:50:37.700
Right, right.

00:50:37.700 --> 00:50:39.840
Maybe just use Xcode and like Swift now.

00:50:39.840 --> 00:50:41.860
So that's pretty close to Python, actually.

00:50:41.860 --> 00:50:42.680
Something like that, right?

00:50:42.680 --> 00:50:43.160
Exactly.

00:50:43.160 --> 00:50:43.680
Yeah.

00:50:43.680 --> 00:50:45.240
Yeah, but you'd lose all the packages.

00:50:45.240 --> 00:50:45.880
Anyway.

00:50:45.880 --> 00:50:46.500
Exactly.

00:50:46.500 --> 00:50:49.460
And it needs to talk to the rest of the pipeline.

00:50:49.460 --> 00:50:59.680
Again, your general knowledge of what's going on in the production and how to translate between these different applications is usually Python logic.

00:50:59.960 --> 00:51:02.500
So you've got to figure out a way to talk to that.

00:51:02.500 --> 00:51:03.420
Yeah, yeah.

00:51:03.420 --> 00:51:05.580
It's a super interesting set of trade-offs to consider.

00:51:05.580 --> 00:51:09.240
I personally would love to see PySide really come on strong.

00:51:09.240 --> 00:51:09.780
But...

00:51:09.780 --> 00:51:10.380
It'd be amazing.

00:51:10.380 --> 00:51:10.780
Yeah.

00:51:10.780 --> 00:51:12.160
All right.

00:51:12.160 --> 00:51:15.440
I have just enough time for a few more questions for you before you go.

00:51:15.440 --> 00:51:16.360
All right.

00:51:16.360 --> 00:51:19.280
So if you're going to write some Python code, what editor do you open up?

00:51:19.280 --> 00:51:21.500
That's funny.

00:51:21.500 --> 00:51:24.260
I have switched over to Sublime.

00:51:24.260 --> 00:51:28.200
I was kind of diehard VI Vim for a long, long time.

00:51:28.400 --> 00:51:30.700
And Sublime was the first thing that I saw that I was like, okay.

00:51:30.700 --> 00:51:35.920
It's fast enough to launch and fast enough to get going that it competes.

00:51:35.920 --> 00:51:40.620
There's still definitely some stuff that I miss from them.

00:51:40.620 --> 00:51:43.780
But I've grown addicted to multiple cursors.

00:51:43.780 --> 00:51:45.060
Yeah.

00:51:45.060 --> 00:51:45.520
Okay.

00:51:45.520 --> 00:51:46.000
Very cool.

00:51:46.000 --> 00:51:46.200
Yeah.

00:51:46.200 --> 00:51:47.220
I like Sublime as well.

00:51:47.220 --> 00:51:47.980
That's nice.

00:51:49.280 --> 00:51:55.080
There's, you know, many thousands of packages out on PyPI that people can go grab.

00:51:55.080 --> 00:51:59.780
What are some of your favorites that maybe not everyone knows about that they should check out?

00:51:59.780 --> 00:52:00.760
Oh, man.

00:52:00.760 --> 00:52:02.280
I mean, it's not on PyPI.

00:52:02.400 --> 00:52:17.020
But I do think PySide and kind of being able to build a GUI in complete Python and then even package it up with like Py2XE, Py2App or that kind of flavor of that is a pretty amazing thing for people to do.

00:52:17.880 --> 00:52:24.920
It's just kind of cool to be able to take something and actually hand it off as a self-contained thing to somebody else to run.

00:52:24.920 --> 00:52:26.080
Yeah.

00:52:26.080 --> 00:52:26.900
That is really cool.

00:52:26.900 --> 00:52:36.400
And I don't think I or any of the guests have spoken about Py2App or Py2XE or CXFreeze or any of those categories of things.

00:52:36.480 --> 00:52:41.300
Maybe you could just tell everyone out there, like those you can go pip install at least one or two of them, I think.

00:52:41.300 --> 00:52:42.340
Yeah.

00:52:42.340 --> 00:52:45.060
Some of them just come with the Python distributions.

00:52:45.060 --> 00:52:55.040
So it's a way of basically compiling down and freezing the Python interpreter and your code together as a native executable.

00:52:55.040 --> 00:53:04.080
So on OSX, the Py2App will actually create a bundle that has all of the Python embedded in it.

00:53:04.080 --> 00:53:05.060
And the same thing with Py2XE.

00:53:05.900 --> 00:53:10.880
You get a standalone EXE that you can run on Windows and it'll run your code.

00:53:10.880 --> 00:53:20.460
So if you combine it with PySide, then you get this EXE that you double click on and you don't even necessarily know that you're running Python under the hood.

00:53:20.460 --> 00:53:30.340
You got to take the code that you wrote and the speed with which you got to develop it because it's all scripted and you're able to put it together with something like PySide.

00:53:31.140 --> 00:53:39.640
And at the end of the day, you end up with this self-contained thing that you can just email to somebody without them having to set up any infrastructure under it and they'll be able to run it.

00:53:39.640 --> 00:53:40.780
Yeah, that's really cool.

00:53:40.780 --> 00:53:43.380
And you can, it takes your packages and everything, right?

00:53:43.380 --> 00:53:43.980
Yep.

00:53:43.980 --> 00:53:45.120
It embeds it all.

00:53:45.560 --> 00:53:48.680
Yeah, I haven't had a real good use case for that because I mostly do web stuff.

00:53:48.680 --> 00:53:57.060
But yeah, it's really cool to think, you know, instead of zipping up a bunch of scripts and sending them, I go, oh yeah, and you need to, you know, pseudo-pip install this while you're at it.

00:53:57.240 --> 00:54:00.880
Just go, you know, here's your .app, double click it.

00:54:00.880 --> 00:54:02.840
Or here's your .exe, double click it.

00:54:02.840 --> 00:54:03.700
It's great.

00:54:03.700 --> 00:54:04.480
Nice.

00:54:04.480 --> 00:54:08.440
Final call to action or anything people should check out?

00:54:08.440 --> 00:54:12.120
Let's say there's calls to action.

00:54:12.120 --> 00:54:17.360
Then people who are interested in open source development and the PySide, I would recommend that.

00:54:17.360 --> 00:54:19.760
It would be amazing to get people interested in that again.

00:54:19.760 --> 00:54:20.740
All right.

00:54:20.740 --> 00:54:21.120
Awesome.

00:54:21.300 --> 00:54:23.140
And how do they find this project that you're working on?

00:54:23.140 --> 00:54:27.520
Is it something that's out or something you're working on still that's going to come out?

00:54:27.520 --> 00:54:30.480
It is out in a beta form.

00:54:30.480 --> 00:54:35.680
There's a production management software that Autodesk sells called Shotgun.

00:54:35.680 --> 00:54:37.780
You can go to shotgunsoftware.com.

00:54:37.780 --> 00:54:43.360
And everything that I've been talking about is the pipeline developer section of that.

00:54:43.360 --> 00:54:44.960
So the project is Toolkit.

00:54:44.960 --> 00:54:48.360
We're the pipeline toolkit for Shotgun software.

00:54:48.360 --> 00:54:49.640
All right.

00:54:49.740 --> 00:54:51.780
It sounds like a really interesting project.

00:54:51.780 --> 00:54:59.200
And definitely got a fresh look at all the barbs that live in the different versions of all these things.

00:54:59.200 --> 00:55:00.320
Yeah.

00:55:00.320 --> 00:55:06.880
I would say if people are kind of interested in the stuff that I was talking about, the project that we work on is source shared.

00:55:06.880 --> 00:55:11.240
We've got public repos on Git.

00:55:11.240 --> 00:55:17.900
The license is you kind of have to be using Shotgun as a product in order to use the project.

00:55:17.900 --> 00:55:22.840
But all of the Python code is there for people to look at, improve upon.

00:55:22.840 --> 00:55:29.960
We try to do it as a very open project so that everybody that does this kind of work can join together as a community.

00:55:29.960 --> 00:55:31.360
That's great.

00:55:31.360 --> 00:55:33.340
It's been really fun talking to you, Rob.

00:55:33.340 --> 00:55:34.280
Thanks for being on the show.

00:55:34.280 --> 00:55:35.000
Thank you.

00:55:35.000 --> 00:55:35.680
It's been a pleasure.

00:55:35.680 --> 00:55:36.220
Yeah.

00:55:36.220 --> 00:55:36.560
Bye-bye.

00:55:38.140 --> 00:55:40.700
This has been another episode of Talk Python To Me.

00:55:40.700 --> 00:55:45.440
Today's guest was Rob Blau, and this episode has been sponsored by SnapCI and OpBeat.

00:55:45.440 --> 00:55:47.180
Thank you guys for supporting the show.

00:55:47.180 --> 00:55:50.620
SnapCI is modern continuous integration and delivery.

00:55:50.620 --> 00:55:56.760
Build, test, and deploy your code directly from GitHub, all in your browser with debugging, talker, and parallelism included.

00:55:56.760 --> 00:55:59.900
Try them for free at snap.ci slash talkpython.

00:56:00.900 --> 00:56:03.740
OpBeat is mission control for your Python web applications.

00:56:03.740 --> 00:56:09.060
Keep an eye on errors, performance, profiling, and more in your Django and Flask web apps.

00:56:09.860 --> 00:56:15.120
Please take a moment to check out the online course Kickstarter at talkpython.fm/course.

00:56:15.120 --> 00:56:20.640
You get a discount for the course by signing up early and the satisfaction of helping create something amazing.

00:56:20.640 --> 00:56:27.440
You can find the links from this show at talkpython.fm/episodes slash show slash 46.

00:56:27.440 --> 00:56:29.760
Be sure to subscribe to the show.

00:56:29.760 --> 00:56:31.960
Open your favorite podcatcher and search for Python.

00:56:31.960 --> 00:56:32.960
It should be right at the top.

00:56:32.960 --> 00:56:36.700
You can also find the iTunes and direct RSS feeds in the footer of the website.

00:56:37.000 --> 00:56:41.260
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:56:41.260 --> 00:56:43.960
You can hear the entire song on talkpython.fm.

00:56:43.960 --> 00:56:45.840
This is your host, Michael Kennedy.

00:56:45.840 --> 00:56:47.420
Thank you so much for listening.

00:56:47.420 --> 00:56:49.540
Smix, take us out of here.

00:57:06.960 --> 00:57:11.600
First, developers, developers, developers, developers, developers, developers, developers, developers, developers.

00:57:11.600 --> 00:57:13.660
you

