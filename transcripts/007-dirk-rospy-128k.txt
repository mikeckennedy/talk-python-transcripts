00:00:00 Talk Python To Me, episode number seven, with guest Dirk Thomas, recorded Monday, April 27th, 2015.

00:00:08 Hello and welcome to Talk Python To Me, a weekly podcast on Python.

00:00:38 The language, the libraries, the ecosystem, and the personalities.

00:00:42 This is your host, Michael Kennedy.

00:00:44 Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes at talkpythontome.com.

00:00:52 This episode, we'll be talking to Dirk Thomas about the robot operating system ROS and ROSPi.

00:00:59 Before we get to Dirk, I have a couple of news items.

00:01:03 Top of the queue is a huge show announcement.

00:01:06 We have our first long-term sponsor of the show.

00:01:09 I'm happy to tell you that Codeship is now the premier sponsor of Talk Python.

00:01:14 Codeship is a platform for powerful continuous integration and continuous delivery as a service.

00:01:20 I'll talk more about them later in the show, but please take a moment and check them out at codeship.com

00:01:26 or follow them on Twitter where they're at codeship, C-O-D-E-S-H-I-P.

00:01:31 And if you love this podcast, please send Codeship a message to say thank you.

00:01:36 Jump on Twitter and say something like, Thank you, at Codeship, for sponsoring the Talk Python podcast.

00:01:42 You rock!

00:01:43 Or however you want to say it.

00:01:45 Next up, timestamps.

00:01:47 Several listeners have asked for something like an outline with timestamps so they can go back into the show and look up topics.

00:01:53 It's a great idea, but I'm taking that to the next level.

00:01:56 I intend to have full-text, searchable transcripts for the shows, which of course include timestamps.

00:02:03 Only a couple of shows have transcripts so far, and I'm adding them as fast as I can.

00:02:08 Check out episode number four on Enterprise Python or episode number five on SQLAlchemy

00:02:13 and click the full transcript button to the right to see what I'm talking about.

00:02:17 I think you'll find it really useful.

00:02:19 Special thanks to Mark Weimer for recommending a show on RossPi.

00:02:23 We probably wouldn't have this show that you're listening to right now without you, Mark, so thanks a bunch.

00:02:29 There are comments everywhere.

00:02:32 I've added a comment section to every show on our site.

00:02:35 So now, in addition to using @talkpython on Twitter or just emailing us,

00:02:39 you can send us feedback via the Discus comment area at the bottom of each show,

00:02:44 and I've already received some great comments that way.

00:02:46 Finally, I have created a Twitter list aggregating all the tweets from all the guests who have been on our show.

00:02:53 Visit Talk Python on Twitter, choose the View Lists option, and subscribe to the show underscore guest list.

00:03:00 There you'll find the Twitter stream from all the guests who have been on the show, and of course, that list will be growing over time.

00:03:06 You can also find the link to the list on our homepage.

00:03:09 Wow, what a week.

00:03:11 Now, let's get on to the interview with Dirk Thomas.

00:03:15 Hello, Dirk.

00:03:16 Welcome to the show.

00:03:16 Thank you for having me.

00:03:18 Yeah, I'm really excited to have you as a guest.

00:03:21 We've had some what I would consider mainstream developer topics so far, and we have more coming up.

00:03:27 Of course, they're mainstream, so we'll probably have a lot of them throughout the show.

00:03:31 But I'm thinking of things like web frameworks, data access libraries, Pyramid.

00:03:35 We're going to do a show on Flask.

00:03:37 A show on SQLAlchemy is coming out pretty soon.

00:03:41 And what we're going to talk about today is a little bit different.

00:03:44 It's a little more edgy, and I think it's something that so many people that go into software development,

00:03:51 maybe it's the reason they got into software, and then they got drug over to the financial section

00:03:55 where they're building reports out of databases or something like that, which is robotics.

00:04:00 Yeah, that's a very great project because robotics in general is, I think, more interesting than classic software engineering

00:04:08 because it's just much more hands-on, and you have real results which you can try

00:04:12 instead of the big business projects.

00:04:14 Absolutely.

00:04:15 And I think one of the things that is sort of representative of that is I do a lot of work with schools and training.

00:04:22 I do professional training for real developers, but I also help my kids' schools out with after-school projects and stuff,

00:04:29 and they very rarely want to write a financial trading system.

00:04:32 They're more like, how do we build a robot?

00:04:33 How do we build a game?

00:04:34 And so you're really involved with this thing called ROS, the Robotic Operating System,

00:04:40 and we're going to talk about that for this show.

00:04:41 Before we get to it, though, I think the listeners are really interested to hear

00:04:45 kind of how everyone who's gotten to some really cool place contributed to some great project.

00:04:49 Well, how did you get started?

00:04:50 What's your background?

00:04:51 How did you get into Python?

00:04:52 So basically my background is I started computer science at the university

00:04:56 because I liked computer.

00:04:59 I liked programming.

00:05:00 Of course, I liked games at that time.

00:05:02 So I thought computer science, that's like a nice thing to do.

00:05:05 And at the university, you learn a lot about languages and algorithms and a lot of like technical background.

00:05:13 But we also had projects at the university which were more hands-on.

00:05:17 And one of the big ones was RoboCup where you play like soccer with the robot.

00:05:22 And you try to make the robot play soccer on its own.

00:05:26 So you're not like steering him with a joystick but make him like autonomous.

00:05:28 And that was a really interesting project.

00:05:31 And that's how I got into robotics in the first place.

00:05:33 And what languages did you use to teach the robot to be autonomous?

00:05:37 Yeah.

00:05:37 So usually a lot of things in robotics, if they're like the algorithms which do like C objects in the camera and make decisions,

00:05:45 a lot of those things are like in C++ classically.

00:05:48 Of course.

00:05:49 But C++ is like a good language for doing like the lower level languages where you need a lot of libraries

00:05:56 which are only available in that language potentially.

00:05:58 Or you need like things which need to be really fast.

00:06:01 But for other things, when you do like put things together, like the glue making the overall system work,

00:06:08 that might not even require like really fast code or something.

00:06:13 And then something like Python comes in more handy because you're just much more efficient in writing code and putting things together.

00:06:19 Right.

00:06:20 It's more about understanding what you build than it is building, you know, shaving that millisecond or microsecond off there.

00:06:24 Exactly.

00:06:25 Yeah.

00:06:25 Especially if you think about like user interfaces or when you start the robot to determine which parts to start and how to configure them.

00:06:32 Those are not time critical.

00:06:33 So you want to be like as fast as possible developing them.

00:06:37 And it doesn't need to be like that fast at runtime.

00:06:40 Perfect.

00:06:40 So you started working on these robotics projects.

00:06:43 And they were in C++.

00:06:44 And somewhere along the way, you're like, all right, enough C++, Python.

00:06:48 Where did that happen?

00:06:49 Yeah, that was actually an interesting project.

00:06:51 We had like a graphical user interface to like do all the controlling of the robot and look into the state of the robot to see what it's currently doing and changing like plans.

00:07:01 And we started because the rest of the software was in C++.

00:07:05 We're all familiar with it.

00:07:06 So we started with C++, of course.

00:07:09 And then we figured out that like for a graphical user interface, you want to be really fast and developing new things to interact with the robot.

00:07:15 And I tried to like look at different languages.

00:07:19 And with some coworkers, we looked into Python.

00:07:22 And I tried first, actually, a C++ user interface, which was able to run like parts of it in Python.

00:07:30 So that was my first contact with Python.

00:07:33 Very nice.

00:07:34 So maybe you could give us a little bit of an overview of what the robotics, the sort of where Python is being used throughout the robotics industry.

00:07:43 Oh, yeah.

00:07:44 So especially in the robot operating system, which we work on at the Open Source Robotic Foundation, it is usually like twofold that you have a lot of code in C++ on one hand.

00:07:55 And on the other side, you have a lot of code in Python.

00:07:58 And usually you decide like which one is better for the part of the work you're doing.

00:08:04 And while there are many language bindings for different languages, those are the two common ones.

00:08:09 And Python especially is used for, for example, writing command line tools because they are very easy to write.

00:08:18 They are really fast to develop.

00:08:20 And you don't need like features which are specific to C++ at that point.

00:08:27 And also on the user interfaces, a lot of user interfaces are mostly based on Python.

00:08:32 Sometimes you use some C libraries if you need to access some other libraries which are not available in Python.

00:08:38 But, yeah, all those kinds of like glue code to put things together to make a bigger system, those are usually relying on Python in our cases.

00:08:48 Sure, that makes perfect sense.

00:08:50 Like when you're down talking to the serial port or the hardware interrupt, maybe Python is not the right choice.

00:08:55 But once you have that in place, you do the higher level logic, the sort of orchestration with Python, right?

00:09:00 That's actually a really interesting problem.

00:09:02 If you think about like serial communication, you would think like serial communication, very low level.

00:09:08 Like C, C++ is the most fitting language for that.

00:09:12 Sure.

00:09:12 But if you try like implementing a little communication over USB or like a serial link, actually in C++ that gets really tedious.

00:09:22 It's like a lot of work, a lot of cases to consider, and you have to do a lot manually.

00:09:27 Python is really well suited for that because you're not dealing with a lot of data because serial is usually like low bandwidth.

00:09:34 And the latency is also usually not an issue.

00:09:37 So actually writing data to a serial port or reading from a serial port, I probably would choose Python for that.

00:09:43 That's really interesting.

00:09:44 I wouldn't have guessed that, but I guess it makes sense.

00:09:47 That's cool.

00:09:47 So you're associated with the ROS project, the robotic operating system at ROS.org, ROS.org.

00:09:55 Maybe we should talk about that for a little while.

00:09:57 Yeah.

00:09:58 So when I first started at the university, we were just working on our own little software, you know, like you want to develop it yourself to learn.

00:10:06 But in the near future, we noticed that, well, it just is better to reuse something which already exists.

00:10:14 And the robot operating system has been started like seven years ago at Willow Garage.

00:10:19 And they developed it for a very huge humanoid-like robot.

00:10:25 It's like a robot on a mobile platform with two very complex arms and a head with like different camera systems.

00:10:31 And ROS was basically just the outcome of trying to use this robot and make it usable for different researchers.

00:10:41 So it was not the first goal to develop the software, but first they developed the robot, and then they developed the software for the robot, basically.

00:10:48 That's interesting.

00:10:49 So it was almost, you know, extracted from the construction of the robot and the needs that they had.

00:10:56 Yes.

00:10:57 So basically, that was the first application.

00:10:59 And seven years later, we still have like things in the software which are like basically designed and evolved based on that robot.

00:11:08 So later on, more robots came into the game, and we tried to support more of them and different variety of things.

00:11:14 But you see a lot of design decisions in the system are just based because they were like developed for that first robot.

00:11:19 So you're also working on this thing called ROSPi, which is part of the ROSCon or communication project on GitHub.

00:11:27 What's the relationship between those two?

00:11:30 So basically, ROSPi is like many things at the same time.

00:11:34 On the one hand, you have the communication system, which provides you like communication patterns like publish, subscribe, or service response, which are very common ways to communicate between components.

00:11:46 This is like the low-level like communication functionality of ROS.

00:11:52 But then there is like, and ROSPi is one of those.

00:11:55 So ROSPi is basically the Python implementation of this communication primitives.

00:12:00 But ROS provides more than just the bare communication.

00:12:05 There's on the one hand a lot of tooling.

00:12:08 So you have a lot of tools to help you develop software for robots.

00:12:12 You can introspect the state of a robot.

00:12:14 You can change things at one time.

00:12:16 Additionally, besides these tools, you have a lot of visualization.

00:12:20 Developers around the world write applications and functional components, capabilities, for example, to make a robot be able to navigate, make a robot be able to recognize objects with a camera.

00:12:36 Excellent.

00:12:36 So there's like a simulator or something.

00:12:38 Is that right?

00:12:39 Oh, yeah.

00:12:39 There's also the option for a simulator.

00:12:42 You can actually use different ones.

00:12:44 But one of the most common ones is Gazebo, which is used to try your software with a simulated robot before you actually run it on the real robot.

00:12:53 Okay.

00:12:54 So could I actually build and have a virtual robot before I even touch a piece of hardware and then decide, okay, now I'm ready to go in and actually get the hardware?

00:13:02 Yeah, absolutely.

00:13:04 And that's the big advantage because you don't want to spend the cost of the hardware first.

00:13:08 And then you figure out, oh, well, that's actually not good for a certain use case.

00:13:12 So you want to try that out before.

00:13:13 So the simulation allows you to rapidly prototype a certain design of your robot and iterate on that one.

00:13:20 You can make it run the same kind of code to drive around and pick up objects.

00:13:25 And if you're not happy with the geometry of your robot, you can change it and iterate on it over time.

00:13:31 And when you're happy with it, you actually go to the hardware.

00:13:34 Now let me take a minute and tell you about our sponsor for the show, CodeChip.

00:13:48 CodeChip is a hosted continuous delivery service focused on speed, security, and customizability.

00:13:54 You can set up continuous integration in a matter of seconds and automatically deploy when your tests have passed.

00:14:00 CodeChip supports your GitHub and Bitbucket projects.

00:14:04 You can get started with CodeChip's free plan today.

00:14:08 Should you decide to go with a premium plan, Talk Python listeners can save 20% off any plan for the next three months by using the code TALKPYTHON.

00:14:17 That's T-A-L-K-P-Y-T-H-O-N, all caps, no spaces.

00:14:24 Thanks to CodeChip for sponsoring the show, and I encourage you to check them out right now at CodeChip.com and thank them on Twitter where they're at CodeChip.

00:14:31 So you mentioned some other tools.

00:14:37 Like when I was looking through the project, I noticed there's one called RViz and one called RQT.

00:14:43 Oh, yeah.

00:14:44 So these are the two most commonly used user interfaces to interact and look into a robot and control it.

00:14:53 RViz is the older software.

00:14:56 It's like the more mature one.

00:14:57 It has more features.

00:14:58 It provides you basically with a 3D scene of the environment, and your robot can move in this 3D scene.

00:15:06 So you have a CAD model, for example, which you can import as like a mesh of the robot.

00:15:12 And the robot can actually drive through an environment which you can render.

00:15:18 And, for example, if you see a camera image from the robot's head, it can project this image into the scene as the robot sees it.

00:15:29 So it's very, very good for the user to get a feel what the robot currently sees and what his information about his world is.

00:15:36 That's really cool.

00:15:37 So it's like a 3D environment, and it basically sets the viewport of the 3D simulator to be where the camera would be?

00:15:43 Exactly.

00:15:43 And you can actually put multiple viewports in there where you have multiple views on the same scene.

00:15:48 Or you can render all the sensor information the robot has.

00:15:52 So if he has a laser in the base, you can render the laser scan itself, and you see how good does it fit with the walls where they actually are.

00:16:01 And you can, for example, render a path where the robot plans to go next.

00:16:06 It's very good for you to get a sense of why the robot is doing something, because the more complex it gets, the more difficult it is for the developer to follow what's actually going on in the system.

00:16:17 Yeah, and you said there's some debugging capabilities that can let you capture those messages and that data flowing in and replay it and stuff, right?

00:16:24 Yeah, so that's another feature for us in general, that since you try to decouple your logic into different components which communicate over messages,

00:16:34 you can record all those messages and later look at them or play them back.

00:16:39 And that helps to figure out problems which happened on a robot like yesterday.

00:16:44 But if you have the information written down to the log file, you can actually introspect the problem from yesterday and actually try to reproduce it, for example, in simulation.

00:16:54 And that helps you, like, actually fixing things which are really hard to debug otherwise.

00:16:59 Yeah, it sounds like it'd be really hard to set a breakpoint on, like, a live robot moving around.

00:17:03 But maybe you could do that on the simulator if it was, you know, getting the same sort of inputs or something, right?

00:17:08 Exactly.

00:17:09 With a simulator, you're able to reproduce it.

00:17:11 And you're not even able to do a breakpoint, actually pause the simulator and then change something in the debugging code and continue.

00:17:19 But you're actually able to, like, change your code and run it against the same laser information, for example.

00:17:25 And you can ensure that now with your changes, it's fixed.

00:17:29 With a live system, you have a hard time doing that.

00:17:31 Yeah, the reproducibility part of it sounds really hard.

00:17:34 So that's fantastic.

00:17:35 Yeah.

00:17:36 And the second part you asked about, that was RQT.

00:17:39 It's basically a different approach than Arvis.

00:17:41 So they are both, like, serving a little bit different needs.

00:17:44 And RQT is where a lot of Python comes in, actually.

00:17:48 Because Arvis is mostly based in C++.

00:17:50 It has some ability to run Python plugins.

00:17:54 And RQT is the other way around.

00:17:56 RQT is like a Python application, which has the option to run, like, C++ plugins if you really need, like, the logic, the power of C++.

00:18:07 And RQT is not built around, like, a 3D environment.

00:18:10 It's more like a, I would say, like a development environment where you can add different things.

00:18:16 So we have plugins which visualize, for example, just single numeric values over time, like a function, like a controller or a distance to an object.

00:18:26 Or you can visualize images just as a plain 2D image.

00:18:31 And you can look into all the communication which is going on.

00:18:35 So it's more like a kind of tool set the developer can use to look into certain things and have that all in one powerful environment.

00:18:42 Very nice.

00:18:44 So Arvis is kind of the simulation bit.

00:18:47 And RQT is more like setting it up and debugging it, maybe.

00:18:52 Yeah, almost.

00:18:53 The Arvis thing, though, does not do real simulation.

00:18:57 It only shows you the current 3D state.

00:18:59 It does not, it doesn't do, like, physics-based simulation or something.

00:19:04 That would be, like, a similar external tool then.

00:19:06 Right.

00:19:07 Okay.

00:19:07 Fantastic.

00:19:08 You know, mostly I touch computers through software.

00:19:12 So the hardware parts are a little unknown to me.

00:19:14 Like, if I've got servos and hydraulics and stuff, like, what do I put together to put ROS on?

00:19:22 Do I have, like, an embedded Linux in my robot?

00:19:24 Does it run on other types of things?

00:19:26 Where do I install the robot operation system?

00:19:29 It completely depends on the use case.

00:19:31 There's such a variety.

00:19:32 For example, the PR2 robot from Willow Garage I mentioned earlier is, like, this huge robot.

00:19:37 It has, like, two I7 multicore machines.

00:19:41 It's, like, a heavy beast, I would say.

00:19:43 It does a lot of things, but it's, like, it's very powerful.

00:19:46 On the other end, you have, like, really small, like, Adreno-based ones or Raspberry Pi-based computers, which just have a connector to, like, motors or sensors.

00:19:57 And that's totally enough to do, like, smaller projects.

00:20:00 So it all depends on your use case.

00:20:02 And some of the microcontrollers, depending on what you use, very common is the Linux version, the Linux distribution Ubuntu.

00:20:12 But people have run it on various different other systems.

00:20:16 So we are very flexible in that term.

00:20:19 That's really cool.

00:20:21 There's a lot of functionality here.

00:20:22 Is this something I would consider using for, like, a toy, or is it only really for, like, professional use, or is it kind of more general?

00:20:29 Would it make sense in a lot of places?

00:20:31 So that's actually the difficulty of the project, I would say, since it's an open-source project and many people contribute to it.

00:20:38 You have a large variety of people trying to use the system.

00:20:42 So on the one hand, we have the hobbyist who tries to, like, just put his, like, Raspberry Pi and a couple of motors and sensors into a small robot, like a toy,

00:20:51 which just, as, like, kids or teenagers, just trying to, like, make it, like, drive around, avoid obstacles, and that's, like, a great project.

00:20:59 And on the other hand, you have developers which really use that on, like, product-level, like, robots, which are, like, car-sized robots,

00:21:08 which drive around, for example, on a field for farming.

00:21:12 And they have to drive reliable.

00:21:14 They have to drive autonomously.

00:21:16 They have to be, like, if something goes wrong, they have to, like, have fail-safes.

00:21:20 So you have the whole spectrum of, like, kind of users which use the system.

00:21:23 Wow.

00:21:24 I suspect that presents some design challenges architecturally in the software, right?

00:21:29 Like, on one hand, you want to make it so kids can, like, build little fun robots.

00:21:33 But the requirements for a real thing that could run someone over, those are different.

00:21:38 So what's the tension like there?

00:21:41 Oh, the tension is definitely that it's really difficult to, like, satisfy, like, everybody in the community.

00:21:46 So you have, like, very different demands in terms of, like, the people who want, like, that for a hobby project.

00:21:52 They want a very lower entry barrier.

00:21:54 They want, like, really easy tutorials.

00:21:56 A lot of people are not software engineers which, like, look at those things and try to build, like, their small robot at home.

00:22:03 They're, like, eventually mechanical engineers or probably even not that, but might be teenagers just trying to play with it, right?

00:22:12 So it's really difficult to bridge that whole area of users.

00:22:18 And I would say there are a lot of design challenges.

00:22:21 So one example is when it was originally developed for the PR2, it was meant for, like, researchers, for, like, developers who knew, like, what they tried to achieve.

00:22:36 And if it didn't work, it was fine to just, like, restart, right?

00:22:39 So if the experiment didn't work, you just, like, control C everything and restart, restart the camera for the video for your presentation.

00:22:46 And you try again.

00:22:48 That was totally feasible at that time.

00:22:50 But if you have a robot, for example, Ross also runs on the Robonaut 2, which is on the ISS space station.

00:22:59 That's amazing.

00:22:59 So at that point, you probably have a harder time, like, retrying things over and over.

00:23:04 You want some kind of deterministic behavior.

00:23:07 And these are still things where Ross needs to improve in the future.

00:23:12 So we're always working on, like, making it more suitable for, like, production-level software that you can actually rely on it and can sell the product and don't have to worry about it ever going wrong.

00:23:24 But that's definitely an ongoing effort to make it more solid in these domains.

00:23:28 That's really cool.

00:23:29 I'm sure it's a challenge, but it probably also makes it a better thing in the end.

00:23:33 Oh, yeah.

00:23:33 I mean, the more use cases your software has, the more flexible it gets.

00:23:38 We often get, like, you know, a totally different operating system, which we don't even have in our office.

00:23:49 We can't even test it.

00:23:50 So we rely on external people, which use it on their systems to contribute back and make it more usable in different scenarios.

00:23:57 Wow, that's amazing.

00:23:59 So maybe we should talk a little bit about the core components.

00:24:04 Like, what is Ross meta before we talk about more how PyOnton's working there?

00:24:08 Yeah, so the core components for the communication.

00:24:12 So first of all, the system encourages the developer to split functional components in separate pieces.

00:24:21 So if you think about something which, a component which reads the camera image, and then a component which extracts from the camera image a certain feature where it wants to drive to,

00:24:33 and then the actual planning where to drive to, and then the component which talks to the motors and actually maps the drive command to a real action in the world.

00:24:45 And the system tries to, like, keep those things separate.

00:24:49 And this abstraction on the first level allows the developer later to swap out a certain thing with a new implementation and try them out.

00:24:58 And that's where all this communication infrastructure comes in, that every component talks to other components by exchanging messages.

00:25:08 It's like a data-centric approach.

00:25:11 Right, and these are asynchronous messages.

00:25:12 You kick them off, and then eventually maybe a new message comes back for you or something like that.

00:25:16 Yeah, so most of the times they are asynchronous.

00:25:18 There are times when you can do synchronous request response and you wait for the answer.

00:25:22 But this is something you usually want to avoid because maybe the answer comes in, like, two minutes.

00:25:27 That's probably not how long you want to wait.

00:25:29 So writing your code in an asynchronous fashion is usually the preferred style, yes.

00:25:34 Excellent, and Ross really encourages that with its APIs and so on, right?

00:25:38 Yes, so if you look at the PR2 robot, it runs, I think, roughly 150 processes in parallel, and they all talk to each other.

00:25:46 And as long as you remove one of the components, which has a certain interface on a message level,

00:25:54 it receives certain messages on a so-called topic, basically a named bus,

00:25:59 and it responds on another topic.

00:26:02 If you replace it with a different component which has the same kind of interface,

00:26:06 nobody will notice as long as you, like, produce similar results.

00:26:10 That's really excellent.

00:26:12 I'm sure it's good for, you know, testing or adapting or maybe even trying different pieces of hardware in your robot, right?

00:26:19 Yeah, exactly.

00:26:20 So that's another big strength of the size of the community because so many people use the software,

00:26:26 that if you have, like, a set of cameras, for example, or motors, then somebody very likely has, if it's used in other robots,

00:26:35 then somebody very likely has already implemented the driver's side of it

00:26:39 and make it a ROS component that you can just send it a ROS message, you drive forward with that speed, and the motor will do it,

00:26:48 and you don't have to take care about how it actually maps to the protocol of that motor

00:26:52 and how it communicates over serial.

00:26:54 It's all hidden and abstracted from you.

00:26:56 So these nice little building blocks are kind of there, so you're almost ready to start using the Python stuff to just orchestrate that.

00:27:02 Exactly.

00:27:03 And that's where Python is very strong at, the orchestration part.

00:27:06 For example, we have a tool which is called ROS Lounge, and it's basically a description in an XML file which tells you what kind of software

00:27:15 and programs you want to run at the same time and how they talk to each other.

00:27:18 And all this, like, orchestration happens in Python because it's just, it's way easier and faster to write, and you have the power of, like, dynamic language

00:27:28 where you don't need to know all the types at compile time.

00:27:31 It gives you a lot of, like, power over, like, static and compile languages.

00:27:36 So another strength of the core building blocks seems to be around geometry, right?

00:27:40 Like, that's got to be a real hard problem.

00:27:42 I've got all these moving parts to my robot.

00:27:44 Maybe it's got an arm and it's got wheels and it's moving around.

00:27:48 That's hard.

00:27:49 So there's support for modeling, that kind of stuff, right?

00:27:51 Yeah, exactly.

00:27:52 So if you think that you receive a camera image and in the image you see a certain object you want to grasp,

00:27:59 then you don't really know yet where that object is because you don't know without any further information

00:28:06 where your camera was when it took the picture.

00:28:09 So one thing which the robots usually keep track of is, like, first, their location in a known environment.

00:28:16 So it's usually, like, the base where your robot stands or where your wheels are.

00:28:21 But then you know all your joints and your arms and your head and neck, how all these, like, joints are oriented.

00:28:28 And then you can build up a transformation to where your camera is.

00:28:31 And to do that, like, in a very easy way, there's, like, packages which support you with that.

00:28:38 Like, geometry is one.

00:28:39 There's another one called TF for transform.

00:28:42 It can basically transform, if you see in your camera, in the middle of the camera, in a meter away, a certain object.

00:28:49 You can transform how far is that away from my left hand, for example.

00:28:53 So you can do all these computations very nicely.

00:28:56 That's cool.

00:28:57 I bet there's a lot of matrix multiplication going on in there, right?

00:29:00 Oh, yeah, for sure.

00:29:02 And that can get really difficult.

00:29:04 And depending on how complex your robot is, you have to be careful setting up the kinematic and the computation

00:29:11 that it's, like, actually, like, fast.

00:29:12 Because you probably are not interested in every joint of your robot.

00:29:15 It's probably fast, fine enough if you only know a certain amount of them.

00:29:20 That's math you want to just put into a library and forget.

00:29:23 Exactly.

00:29:24 Because not everybody wants to write and see that stuff.

00:29:26 That's right.

00:29:27 So I actually have a couple of questions from some listeners who sent in some messages or questions for you.

00:29:33 So one of them was, what's the process of writing and deploying your own packages using Rospy?

00:29:40 Oh, so that's another interesting question for Ross in general, because we don't only provide the software.

00:29:47 There's a lot of infrastructure because we have this federated approach.

00:29:50 Everybody contributes a package.

00:29:52 And I think the latest Ross release has, like, about 1,500 packages, which we build for people into Debian packages,

00:30:00 because also nobody wants to deal with, like, creating a Debian package manually,

00:30:04 if you can avoid it, because you really don't care how the internals work.

00:30:08 And so we also make this packaging process very easy.

00:30:12 So if you want to write, for example, a simple package which does a certain task,

00:30:17 you just create a repository somewhere.

00:30:22 You want to share your code.

00:30:23 A lot of our code is on GitHub, but that's not, like, the only platform.

00:30:27 You can put it, like, anywhere else.

00:30:29 You have to be able to build your package.

00:30:33 Usually, if it's Python, you have a setup.py file.

00:30:35 Additionally, we have an XML file describing, like, meta information, like what's your package's name, what's the license,

00:30:44 because people want to know if they can use your code or not.

00:30:47 What's the maintainer?

00:30:49 Does he have an email address which I can, like, talk to?

00:30:51 Is there a website which contains more information?

00:30:55 And also very important, what kind of other packages do you depend on?

00:30:59 And then, besides those meta information, it's all about your code.

00:31:03 So you put your Python code in there.

00:31:05 And after that one, you just go to our, like, website.

00:31:09 And there is a process how you can tell us that there is a repository with a ROS package.

00:31:13 And if you give us the location and we can access it, so it must be publicly readable,

00:31:18 then we can actually, like, provide that information to others.

00:31:21 And we can potentially even build, like, packages out of that.

00:31:24 And people can easily reuse it.

00:31:26 That's cool.

00:31:27 Is there, like, a central repository, kind of like PyPI with Python packages?

00:31:32 Yeah, that's kind of it.

00:31:34 But we don't separate them by language.

00:31:36 But there is a so-called repository called ROS Distro.

00:31:39 And that one defines repositories, external ones, where ROS packages are.

00:31:45 And there's, like, basically, I would say, like, two classes of packages.

00:31:49 There are the ones which are, like, released in terms of that we build, like, Debian packages out of them.

00:31:54 Or Fedora RPM packages.

00:31:57 Or whatever platform you want to imagine.

00:31:59 OS X is also one thing where we actively support people to build their code on.

00:32:05 And, yeah, you just have to register in this, like, it's basically a huge YAML file.

00:32:10 And you register your repository with a name and the URL.

00:32:13 And you can specify which branch it's coming from.

00:32:16 And after that one, anybody can use on his computer, like, a command similar to PyPI.

00:32:21 But it's a ROS-specific one which says, like, hey, give me the repository for the repository foo.

00:32:26 And it pulls down the information.

00:32:28 You can just either build it, if it's C++ code, if it's Python code, you can basically just run it.

00:32:34 So you talked about licensing.

00:32:35 And some of this, I'm sure, is open source, probably a lot of it.

00:32:39 Is there, like, a commercial ecosystem?

00:32:41 Are there companies that, like, build these packages and sell them?

00:32:45 That's a very good question.

00:32:46 I can't say for sure because the community is so big.

00:32:48 But I'm not aware of companies which sell, like, packages.

00:32:51 But there are definitely companies which use, like, the open source core packages, which are available.

00:32:59 And they build their own proprietary software on top, which they are free to do because most of the packages is licensed under BSD.

00:33:06 So we actually encourage people to build, like, commercial software on top.

00:33:10 And then they use these proprietary packages either to sell their products or use it only for their in-house robots, depending on their use case.

00:33:20 So another listener question is, says, is there a time where we can build ROS nodes without Katkin make?

00:33:27 When using ROSPy, they don't really feel that it's super Pythonic.

00:33:31 Oh, that's a good one.

00:33:33 So classically, in the very beginning, we had a tool called ROSMake, which was basically a make file, and it built the whole process.

00:33:42 And, like, two years ago, two and a half years ago, we introduced a new build system, which is called Katkin, which is based on CMake.

00:33:52 So CMake calls Python setup.py install, which is definitely not very native for a Python developer.

00:34:00 So for the current system, what I would call ROS1, which is currently ROS Indigo, we name them, like, in alphabetic order, like a lot of other projects.

00:34:10 There will be ROS Jade soon.

00:34:13 But for those things, we might not touch that because a lot of these changes will affect a lot of users.

00:34:19 And updating our tutorials and teaching the whole community to change their workflow is really difficult.

00:34:26 We learned that when we deployed the new build system, Katkin, like, two and a half years ago.

00:34:31 And we would not go for a change in the new future again, I would say.

00:34:35 Yeah, it's too much infrastructure and support knowledge around it to change it, right?

00:34:40 Exactly.

00:34:41 But we always work on, like, new stuff.

00:34:44 And that's currently one thing we focus on.

00:34:46 It's called ROS2.

00:34:47 It's basically we have learned a lot in the last seven years.

00:34:50 And we know that there are certain things where we have to make the system more flexible and more capable,

00:34:57 especially if you think about, like, really small systems like microcontrollers.

00:35:02 That's something we currently don't support very well.

00:35:04 Because of early design decisions, we use XML for some RPCs.

00:35:09 And generating XML on a microcontroller is really, like, not something you want to do.

00:35:13 That made sense, you know, seven years ago, probably, when XML was the thing, right?

00:35:19 Yeah.

00:35:19 And you had two i7s in the first robot, so they didn't care.

00:35:24 But now you have, like, Raspberry Pis and really smaller microcontrollers where you want to run stuff on.

00:35:28 And on the other hand, you have people who want to ship their robot, like the vacuum robot or their lawnmower,

00:35:34 which just works 100% of the time out of the box without ever a developer touching it.

00:35:40 The user can just use the product.

00:35:42 And for those things, the requirements are very different than the first systems ROS was built for.

00:35:48 And so we currently work on the next thing called ROS2.

00:35:53 And for this one, we actually think about and have some prototyping which have a pure, what you would call pure Python package.

00:36:01 It contains of the meta information, an XML file, because you still need, like, a coherent way to, like, describe your package.

00:36:08 Like, I don't know, like, other languages have the same thing, like manifest file, basically.

00:36:13 And beside that, you only have to set up the Py file, what you would expect.

00:36:17 And there's no, like, CMake around because you don't want to have, like, you don't need CMake to build a Python package.

00:36:23 Absolutely.

00:36:24 And then you also gain back features which the previous system didn't have.

00:36:29 For example, you could only use a very limited set of the setup.py functionality.

00:36:33 For example, like a C extension was really difficult to do because our system just, like, didn't allow you to do that.

00:36:41 But with a pure setup.py file, you can use the full power of whatever, for example, setup tools gives you to build your package.

00:36:49 That sounds fantastic.

00:36:50 So when's ROS2 planned?

00:36:53 That's always a good question.

00:36:54 Of course.

00:36:55 I would say it's going to be shipped when it's ready.

00:36:58 But we aim to release a first version in this summer.

00:37:03 But due to the scope of the project, it might not be something every user wants to switch over immediately.

00:37:10 It will be something which developers are interested in to see the new features.

00:37:14 And if they want to try it out and see how it fits their applications.

00:37:19 But it will take a long time for the majority of the user base to migrate.

00:37:24 So we don't plan to replace the original system with a new one.

00:37:29 It will be more a coexistence.

00:37:31 You can still use the old system.

00:37:32 It will be maintained.

00:37:33 And the new system will give you changes, but also more features and functionality.

00:37:38 And it's your choice when you want to adopt the new thing.

00:37:42 That's cool.

00:37:43 What kind of features are coming?

00:37:44 So that's actually a lot of things.

00:37:49 All right.

00:37:49 What are the highlights?

00:37:50 The highlights.

00:37:51 Let me think about it.

00:37:52 So the first thing is the new system uses a completely different communication system under the hood.

00:37:58 For the first version of ROS, we developed everything from serialization,

00:38:03 messages to the TCP transfer, UDP transfer, everything from scratch.

00:38:08 Because seven years ago, there was not that great library support for that.

00:38:12 But, yeah, time has changed.

00:38:14 And for the new thing, we actually rely on a standard from the OMG, which is called DDS,

00:38:20 the Data Distribution Services.

00:38:21 And relying on that gives us a lot of functionality without having to reimplement it from scratch.

00:38:28 And built on that system, we can provide you with much better support for,

00:38:33 for example, deterministic startup, reliable delivery of a message.

00:38:37 We can tell you your message got delivered, or we will give you an event like a callback and tell you that it has not.

00:38:44 And you can tune how often you want to retry it and things like this, which matter in a bigger system.

00:38:51 I could probably fill a whole podcast about the features of ROS 2, which will hopefully be better than ROS 1.

00:38:57 For example, one of the interesting things is ROS 1 always focused on Linux support, so Ubuntu.

00:39:03 There are a lot of versions where you can build it on Fedora and Pure Debian and OS X.

00:39:08 But one thing which it is not good at is building it on Windows.

00:39:12 And this is something we have fixed for the ROS 2 prototypes very early on.

00:39:17 So ROS 2 will just build natively in Visual Studio on Windows, the same as on other platforms.

00:39:24 So it's really like from day one to support it well.

00:39:27 And once you support it, it will be supported in the future.

00:39:30 But adding the support later is really difficult.

00:39:33 Yeah, because you've got to go back and fix a thousand errors and you've got to rewrite this and that.

00:39:37 That's great that you're supporting Windows as well.

00:39:38 It's nice to just say, yes, we support everything.

00:39:41 There's still a lot of people using Windows for this kind of stuff.

00:39:44 Exactly.

00:39:44 And currently, they have a really hard time using it.

00:39:46 Either they use virtual machines inside of Windows or they try it with Segwin.

00:39:51 And there are some tutorials where people make it work.

00:39:54 But it's everything but a smooth process.

00:39:56 It takes a lot of effort.

00:39:57 That's right.

00:39:58 Let's see.

00:39:59 So I have a couple of sort of larger scale pictures for you.

00:40:03 First of all, what kind of robots or automation have you seen using ROS?

00:40:07 You said something about the International Space Station, which is just amazing.

00:40:11 Oh, yeah.

00:40:12 That was actually a really interesting project.

00:40:13 The first, Robonaut, which is like a humanoid robot.

00:40:16 The first one had only torso and arms and the head.

00:40:20 That was not yet running ROS.

00:40:22 But the second iteration, which was launched last year, now has legs.

00:40:27 So it's more like four arms if you look at it.

00:40:30 And that one has a new computer system.

00:40:32 And the computer system is completely ROS-based.

00:40:34 And I think they made the choice to use ROS because it allows them to really fast prototype new functionality,

00:40:43 try them out.

00:40:44 And then if that goes well, focus on something they want to make more detailed.

00:40:51 And sure, our communication protocol is not the best one to communicate with a space station because that's definitely not designed for.

00:40:58 But they just wrapped the whole communication in the VPN tunnel.

00:41:01 And that's good enough for them because it's like it's isolated, it's secure.

00:41:06 And if our protocol has like 15 seconds or something latency to talk to the space station, that was totally fine for their use case.

00:41:14 Probably part of the benefit of the async message passing, not waiting on things and all that kind of stuff.

00:41:19 Exactly, yeah.

00:41:19 You have to be a little bit more defensive when you write your component to like not embed assumptions in your code, which don't hold in those scenarios.

00:41:29 But if you're careful about your code, obviously you can make it work for those cases.

00:41:33 Other notable use cases that you can talk about?

00:41:36 There are a lot of references of robots.

00:41:39 For example, there are a lot of industrial arms where they try to use ROS to do the higher level planning.

00:41:47 So classically, the robot in an industrial setting has like this really like tailored embedded controller, which is very robust and has to fulfill a lot of safety requirements.

00:42:02 But then you have the really complex behavior to plan a path around obstacles, probably in a dynamic environment.

00:42:11 And that's where ROS is very good at.

00:42:13 And so a lot of these use cases, they use like the industrial controllers on the lower level and then put ROS on top to do the more sophisticated dynamic environment planning.

00:42:23 And of course, there's a variety of vehicles from like small autonomous cars to like platforms in like warehouses to drive around and deliver things, which all rely on like localizing yourself and then autonomously navigating in an environment.

00:42:39 How do you see the future of robotics and what role do you think Python and ROS are playing in it?

00:42:46 I think ROS has a very bright future in robotics because the community is just very big.

00:42:53 A lot of people use it and that makes it grow very well.

00:42:57 So it addresses a lot of use cases and makes the things that people want to do achieve more easy.

00:43:04 So I think that will continue to grow and just spread into more use cases.

00:43:09 For example, quadrotors or things which are currently evolving.

00:43:13 The people, when they start these projects, look at what's out there.

00:43:15 And a lot of people just choose ROS because it helps them to like get there faster and prototype faster and get their product ready faster.

00:43:23 And usually that's to a very big amount due to Python because they can just like rapidly prototype what they have in mind.

00:43:31 And later on, if they figure out something is not fast enough or they can still like migrate code to C++ if there's need.

00:43:38 But a lot of stuff is not that critical.

00:43:41 Yeah, it seems like there's maybe two ways to go faster.

00:43:44 One hand is to write something in C++ and ROS directly.

00:43:47 And the other is maybe write a C extension for your Python code.

00:43:52 Is that a thing that would actually work?

00:43:53 Yeah, that's definitely something which works.

00:43:56 It's always a matter of like first you have to identify what's really the bottleneck.

00:44:01 And in a lot of cases, it's not the Python code.

00:44:04 It's like it's more like you have an algorithm which is just like not well structured.

00:44:09 And even if you restructure that in Python, you will be already good to go.

00:44:13 So it's really like finding the knob which you have to tune and not like just merge your code to C++ and then are not even better because your algorithm has a flaw.

00:44:23 Yeah.

00:44:24 Sometimes choosing the right data structure like a dictionary instead of a list or something would make all the difference.

00:44:30 Oh, yeah.

00:44:31 Lookups, right?

00:44:32 Exactly.

00:44:32 And especially in Python, a lot of things where you like sometimes unintentionally duplicate lists which are big instead of just mutating the list in place.

00:44:42 Those things can matter a lot.

00:44:44 So before moving code from one language to another, I would always suggest spending a good amount of like debugging and profiling before like making something like that because it's a lot of effort.

00:44:55 So it sounds like you guys are taking contributions for your projects and people are working on it.

00:45:00 They can find it at github.com/ROS, R-O-S.

00:45:05 And then the ROS pie is really in the ROS underscore com repository, right?

00:45:09 Yes, correct.

00:45:10 And probably the easiest entry point is usually wiki.ros.org because that gives you like the documentation like front end.

00:45:18 And from there, you find a lot of links to the repositories with the code.

00:45:23 And also a lot of tutorials, especially for the Python part.

00:45:26 So that sort of answers one of my other questions is if I've got, you know, a motor and I've got a Raspberry Pi and I've got some servos and I just want to make this thing.

00:45:36 I want to build a robot and I have some parts.

00:45:38 How do I get started?

00:45:39 I think the best thing for something like that is always like, I mean, depending if you want to like get there fast or if you just want the full learning experience, I would expect first like, of course, Googling.

00:45:51 We also have a platform where people ask questions.

00:45:53 It's answers.ros.org.

00:45:55 And just like, look if other people have done something similar.

00:45:58 And I'm pretty much sure that for this specific use case, people have tried that.

00:46:04 So you will see people how they did that, what kind of motors they used and what kind of applications they like try to develop and see how they did it.

00:46:13 And then try your project based on that one.

00:46:16 And I think that's always a good thing because you can just get back to the community and ask questions.

00:46:22 And usually you get like really good responses in like a short amount of time, which help you keep going on the project.

00:46:28 Did you guys do anything with the hour of code?

00:46:32 Like were there projects going on that you knew of or anything like that?

00:46:36 It seems like robotics would play a big role in that area.

00:46:40 Was the hour of code?

00:46:41 Are you familiar with this, the hour of code?

00:46:42 I'm sadly not.

00:46:44 I might miss something.

00:46:45 Oh, yeah.

00:46:46 So check it out next year.

00:46:47 It's in, oh, gosh, it feels like it was like three or four months ago.

00:46:51 Just check out code.org.

00:46:53 And there's a lot of robotics sort of projects.

00:46:57 The idea of the hour of code is have every student in the world do one hour of programming during that week.

00:47:03 And many of the projects that were sort of formed from there were robot based.

00:47:07 And so it seems like a really cool place to get involved with.

00:47:10 Oh, that sounds great because that will get the people engaged into the project.

00:47:15 That sounds really amazing.

00:47:16 Absolutely.

00:47:16 I will look that up.

00:47:17 Yeah, check it out.

00:47:17 Okay, awesome.

00:47:19 I think that might be a good place to call it a show.

00:47:21 A question I ask all my guests sort of near the end of the show is there's a ton of packages on PyPI.

00:47:28 And there's a lot of stuff on GitHub.

00:47:30 There's some really awesome stuff out there in Python you want to call people's attention to.

00:47:34 And, you know, Rospy might be the best one.

00:47:38 I don't know.

00:47:39 Yeah, Rospy, which you can sadly not get over PyPI because it requires more than just Python because of all the dependencies it uses.

00:47:46 But I think there are a good amount of tools available which came from the ROS project, which are really nice to use.

00:47:55 So just when you go through the wiki of ros.org, look at packages.

00:48:00 And maybe some of them are even useful for you without using them in the context of ROS.

00:48:05 And that's the big advantage that people can actually make use of them and apply them to different areas.

00:48:11 So anything you want to give a shout out to your organization, something like that?

00:48:16 Oh, well, I'm happy to work on the project.

00:48:19 So it's a fun project.

00:48:21 You see great results.

00:48:22 You have the hands-on experience in contrast to classic software engineering.

00:48:26 It's a great community.

00:48:28 And it's really fun to be a part of and design the future of robotics.

00:48:31 Well, thank you so much for being on the show, Dirk.

00:48:33 Thank you, Michael, for having me.

00:48:35 You bet.

00:48:35 This has been another episode of Talk Python To Me.

00:48:39 Today's guest was Dirk Thomas.

00:48:41 And this episode has been sponsored by Codeship.

00:48:44 Please check them out at Codeship.com and thank them on Twitter via at Codeship.

00:48:49 Don't forget the discount code for listeners.

00:48:52 It's easy.

00:48:52 Talk Python.

00:48:53 All caps, no spaces.

00:48:55 Remember, you can find the links to the show at talkpythontome.com slash episodes slash show slash seven.

00:49:05 And if you're feeling generous, please check out our Patreon campaign at patreon.com slash mkennedy.

00:49:09 Be sure to subscribe to the show.

00:49:12 Visit the website and choose subscribe in iTunes or grab the episode RSS feed and drop it into your favorite podcatcher.

00:49:19 You'll find the link at the bottom of every page.

00:49:21 This is your host, Michael Kennedy.

00:49:23 Thanks for listening.

00:49:25 Smix, take us out of here.

00:49:27 Stating with my voice.

00:49:29 There's no norm that I can feel within.

00:49:31 Haven't been sleeping.

00:49:32 I've been using lots of rest.

00:49:33 I'll pass the mic back to who rocked it best.

00:49:36 I'll pass the mic back to who rocked it best.

00:49:48 Bye.

00:49:48 .

00:49:49 you

