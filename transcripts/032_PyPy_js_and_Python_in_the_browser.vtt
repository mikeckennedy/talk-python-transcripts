WEBVTT

00:00:00.001 --> 00:00:03.660
Imagine a future where you're building a rich client-side web app.

00:00:03.660 --> 00:00:07.140
You start by creating some backend services, maybe in Flask or Node,

00:00:07.140 --> 00:00:10.960
create an HTML page, you throw in a few divs and ULs,

00:00:10.960 --> 00:00:15.840
and then you type script source equals main.py language equals Python.

00:00:15.840 --> 00:00:20.260
That future might just be possible for the right type of applications

00:00:20.260 --> 00:00:22.840
with Ryan Kelly's PyPy.js project.

00:00:22.840 --> 00:00:26.480
This is Talk Python to Me with guest Ryan Kelly.

00:00:27.060 --> 00:00:31.380
Show number 32 recorded Wednesday, September 30th, 2015.

00:00:54.120 --> 00:00:57.820
I have many interests, sometimes conflates my creativity.

00:00:57.820 --> 00:01:01.580
Welcome to Talk Python to Me, a weekly podcast on Python,

00:01:01.580 --> 00:01:04.620
the language, the libraries, the ecosystem, and the personalities.

00:01:04.620 --> 00:01:06.760
This is your host, Michael Kennedy.

00:01:06.760 --> 00:01:08.760
Follow me on Twitter where I'm @mkennedy.

00:01:08.760 --> 00:01:12.640
Keep up with the show and listen to past episodes at talkpython.fm

00:01:12.640 --> 00:01:15.220
and follow the show on Twitter via at Talk Python.

00:01:16.220 --> 00:01:19.340
This episode is brought to you by Hired and Codeship.

00:01:19.340 --> 00:01:23.680
Thank them for supporting the show on Twitter via at Hired underscore HQ

00:01:23.680 --> 00:01:24.700
and at Codeship.

00:01:24.700 --> 00:01:26.940
Hey, everyone.

00:01:26.940 --> 00:01:28.300
Thanks so much for listening in.

00:01:28.300 --> 00:01:31.820
No news today, so let me introduce Ryan and we'll get right to the interview.

00:01:31.820 --> 00:01:36.200
Ryan is a software developer based in Melbourne, Australia.

00:01:36.200 --> 00:01:39.320
Most of his days are spent coding in Python and JavaScript,

00:01:39.320 --> 00:01:41.480
commercially as an engineer at Mozilla,

00:01:41.600 --> 00:01:44.000
as well as for a variety of open source projects.

00:01:44.000 --> 00:01:47.360
He also maintains a strong interest in logic programming,

00:01:47.360 --> 00:01:49.640
mainly as a result of his doctoral thesis.

00:01:49.640 --> 00:01:52.420
Ryan, welcome to the show.

00:01:52.420 --> 00:01:53.420
Thanks for having me.

00:01:53.420 --> 00:01:55.560
I'm super excited that you're here today.

00:01:55.560 --> 00:01:57.460
We're going to talk about Python,

00:01:57.460 --> 00:01:59.860
but in a place that you typically don't find it,

00:01:59.860 --> 00:02:00.700
in the browser, right?

00:02:00.700 --> 00:02:01.600
Yep.

00:02:02.400 --> 00:02:04.160
Yeah, there's a lot of cool projects out there,

00:02:04.160 --> 00:02:07.020
and I'm a huge fan of the one that you've been working on.

00:02:07.020 --> 00:02:08.700
Before we get to that, though,

00:02:08.700 --> 00:02:11.260
let's talk about how you got into programming.

00:02:11.260 --> 00:02:11.920
What's your story?

00:02:11.920 --> 00:02:12.880
Sure.

00:02:12.880 --> 00:02:16.000
So I think it was quite a while ago now,

00:02:16.000 --> 00:02:19.880
and I actually started programming in JavaScript in high school way back in the day

00:02:19.880 --> 00:02:21.160
for a class, right?

00:02:21.160 --> 00:02:24.460
I was never the kid that sort of always grew up with computers.

00:02:24.460 --> 00:02:27.760
I very much just got into it for a school assignment

00:02:27.760 --> 00:02:29.680
and pretty much fell in love straight away.

00:02:30.480 --> 00:02:33.960
You know, I just fell in love with the ability to have a thought

00:02:33.960 --> 00:02:37.260
and kind of capture that in some concrete form

00:02:37.260 --> 00:02:39.440
and have it executed and have effects on the world.

00:02:39.440 --> 00:02:40.280
It's pretty amazing.

00:02:40.280 --> 00:02:44.160
And actually, that kind of subject changed my entire career path.

00:02:44.160 --> 00:02:45.700
I'd always planned to go into the sciences,

00:02:45.700 --> 00:02:51.420
and I had sort of a half a semester of computer programming in high school

00:02:51.420 --> 00:02:54.780
and changed my whole career trajectory into engineering and computer science.

00:02:54.780 --> 00:02:57.500
I think a lot of us who are in programming had that experience

00:02:57.500 --> 00:03:02.500
where maybe we didn't think that we were programmers per se, right?

00:03:02.500 --> 00:03:04.640
But then you get some experience where then you're like,

00:03:04.640 --> 00:03:06.420
wow, this is really amazing.

00:03:06.420 --> 00:03:08.940
This is really way more rewarding than a lot of other stuff.

00:03:08.940 --> 00:03:10.320
I had that experience in math.

00:03:10.320 --> 00:03:13.200
I studied lots of math, and I'm like, but we don't build anything here.

00:03:13.200 --> 00:03:17.740
Programming is so much more concrete but creative.

00:03:17.740 --> 00:03:18.400
I love it.

00:03:18.740 --> 00:03:24.680
Yeah, it's that beautiful combination of kind of creativity in the mix, right?

00:03:24.680 --> 00:03:27.240
The discovering and creating is pretty cool.

00:03:27.240 --> 00:03:28.320
Yeah, sure.

00:03:28.320 --> 00:03:29.240
So how did you get to Python?

00:03:29.240 --> 00:03:36.000
I was handed Python as a requirement for an internship I was doing in university.

00:03:37.000 --> 00:03:40.100
I went to work for a company that was doing engineering simulations.

00:03:40.100 --> 00:03:46.700
So I think like a lot of people, I sort of come to Python because it has really strong tools for doing data analysis and visualizations.

00:03:46.700 --> 00:03:52.240
So that was in a kind of typical intern project kind of way.

00:03:52.240 --> 00:03:56.520
It's kind of like, here is a relatively well-scoped project, and you're using this language, and off you go.

00:03:57.460 --> 00:04:04.220
But I just found that it really fit my head in a way that a lot of other languages that I've been dabbling around with didn't.

00:04:04.220 --> 00:04:11.280
It was just kind of super easy to get up and running and dive in, and I found that the more time I spent with it,

00:04:11.280 --> 00:04:16.180
and the more I came to understand the language and find all of these more and more interesting corners of it,

00:04:16.180 --> 00:04:17.840
it just kind of grew from there.

00:04:17.840 --> 00:04:29.280
And sort of since from that point, it's always been my kind of go-to language for side projects or projects where I'm not kind of locked into a language for other reasons.

00:04:29.280 --> 00:04:36.320
Yeah, I think Python has this rare combination of being very capable and yet very simple.

00:04:36.320 --> 00:04:41.400
There's a lot of capable languages, and there's a lot of simple languages, but they don't often intersect.

00:04:41.400 --> 00:04:42.180
So that's great.

00:04:43.140 --> 00:04:49.700
I've worked in some interesting languages like Prologue, and there's a language called Mozart, which is like a logic programming language.

00:04:49.700 --> 00:04:55.600
And they're incredibly powerful, but yeah, they don't have that just clarity that Python has.

00:04:55.600 --> 00:05:00.340
So before we get to talk about your project, you work at Mozilla, right?

00:05:00.340 --> 00:05:01.680
That's right.

00:05:01.680 --> 00:05:03.760
I'm a huge fan of Mozilla.

00:05:03.760 --> 00:05:06.080
Firefox is definitely my browser.

00:05:06.080 --> 00:05:07.520
Cool. Good to hear.

00:05:07.520 --> 00:05:09.300
Yeah, I try to spread the word.

00:05:09.300 --> 00:05:09.820
What do you do there?

00:05:09.820 --> 00:05:12.160
I used to work with the cloud services team.

00:05:12.460 --> 00:05:13.840
We're not an independent team anymore.

00:05:13.840 --> 00:05:18.900
So when I first started out, I was working on the web servers behind Firefox Sync.

00:05:18.900 --> 00:05:23.780
So doing sort of data storage and RESTful JSON APIs.

00:05:23.780 --> 00:05:27.440
They're all Python-based servers.

00:05:27.440 --> 00:05:32.160
So it's pretty standard kind of Python backend web gig.

00:05:32.160 --> 00:05:39.400
Through a series of kind of mergers and reorgs and so forth, I actually wound up on a project that's operating in Node.js.

00:05:40.200 --> 00:05:49.660
So my time these days is spent on Firefox accounts, which is the login system for Sync and for all of the new kind of cloud-based services that Mozilla is doing.

00:05:49.660 --> 00:05:53.800
And it's a 100% JavaScript shop, that team.

00:05:53.800 --> 00:05:55.820
So it's an interesting change of pace.

00:05:56.320 --> 00:06:00.620
But it does leave me kind of itching to get more involved in Python stuff on the side.

00:06:00.620 --> 00:06:02.820
Yeah, that's really interesting.

00:06:02.820 --> 00:06:10.120
I think that's a good lead into your topic because it's like Python and JavaScript, those two worlds colliding, right?

00:06:10.120 --> 00:06:11.120
Right.

00:06:12.120 --> 00:06:20.740
So maybe at a really high level, we could just talk about your project, PyPyJS, and then we could talk a little more specifically about it.

00:06:20.740 --> 00:06:21.740
Sure.

00:06:22.580 --> 00:06:31.000
So at a super high level, I like to describe it as an experiment in building a fast and compliant Python environment for the web.

00:06:31.000 --> 00:06:36.580
So concretely, it means like I want a Python interpreter that will run on top of JavaScript.

00:06:37.040 --> 00:06:45.380
So anywhere you would go that you would want to do something in JavaScript, you should be able to take Python to that platform as a first-class citizen.

00:06:45.380 --> 00:06:49.900
And obviously, a big place where JavaScript shows up is in the browser.

00:06:49.900 --> 00:06:52.580
And the browser is just dominated by JavaScript.

00:06:52.580 --> 00:06:56.280
There's really not a lot of other games in town if you want to do scripting in the browser.

00:06:56.840 --> 00:07:02.800
But I'm also kind of interested in how it might fit on the server side in Node.js or other JavaScript frameworks as well.

00:07:02.800 --> 00:07:10.100
But basically, being able to take other languages such as Python and put them anywhere where JavaScript is currently claiming as its home turf.

00:07:10.100 --> 00:07:11.300
Yeah, that's great.

00:07:11.300 --> 00:07:16.640
I mean, there's definitely been people talking how JavaScript is becoming the new assembly language of the web.

00:07:16.640 --> 00:07:17.660
And we'll get into that.

00:07:17.660 --> 00:07:24.720
So the way that I heard about your project was you gave a really excellent presentation at PyCon 2015.

00:07:24.720 --> 00:07:25.900
Oh, thank you.

00:07:26.260 --> 00:07:27.120
Yeah, yeah, definitely.

00:07:27.120 --> 00:07:28.800
What was the title of it?

00:07:28.800 --> 00:07:29.220
I forgot.

00:07:29.220 --> 00:07:31.340
PyPy.js.

00:07:31.340 --> 00:07:32.560
What, how, why?

00:07:32.560 --> 00:07:33.580
I think from memory.

00:07:33.580 --> 00:07:35.000
Yeah, that's perfect.

00:07:35.000 --> 00:07:35.660
Yeah, I think you're right.

00:07:35.660 --> 00:07:39.940
And it's on the YouTube channel for PyCon US 2015.

00:07:39.940 --> 00:07:42.320
So I'll be sure to link to that in the show notes.

00:07:42.320 --> 00:07:47.720
One of the ways you opened your talk was you talked about how Mozilla loves the web.

00:07:47.720 --> 00:07:51.800
And not just the technology of it, but sort of the whole idea and the culture of it.

00:07:51.800 --> 00:07:53.620
Can you maybe talk about that a bit?

00:07:53.620 --> 00:07:54.300
Sure.

00:07:54.300 --> 00:07:54.340
Sure.

00:07:54.340 --> 00:07:56.740
So we have this saying at Mozilla.

00:07:57.100 --> 00:08:00.960
And this was sort of one of the things that really inspired me to get started on this project.

00:08:00.960 --> 00:08:03.520
We like to say like the web is the platform.

00:08:03.520 --> 00:08:07.840
Well, this is kind of the world we want to live in is where the web is the platform.

00:08:08.780 --> 00:08:16.880
And so the web, not necessarily from a technology standpoint, but from a kind of computing platform standpoint, is pretty unique and pretty amazing.

00:08:17.580 --> 00:08:23.560
It's a platform that doesn't have any kind of all-powerful gatekeepers.

00:08:23.560 --> 00:08:28.000
It's a platform where anyone can kind of show up and start participating.

00:08:28.000 --> 00:08:34.800
You can publish stuff on the web without having to be locked into a particular hardware platform or a particular set of tools.

00:08:34.960 --> 00:08:43.140
You can show up and start consuming stuff from the web without any of the similar sets of restrictions or requirements.

00:08:43.640 --> 00:08:54.840
And so at Mozilla, we kind of see the web as a really powerful tool for empowerment and participation in the global kind of information economy.

00:08:55.920 --> 00:09:01.580
Of course, the web, you know, from a social standpoint, that's all very well.

00:09:01.580 --> 00:09:07.040
But when you get right down to the technology of the web, it doesn't necessarily tick all of those boxes, right?

00:09:07.040 --> 00:09:11.480
In a sense, the technology stack of the web is a little bit kind of restrictive.

00:09:11.480 --> 00:09:13.940
It's all kind of JavaScript and HTML in the browser.

00:09:13.940 --> 00:09:21.280
There's kind of a lot of nice sociological aspects of the web that are really unique and really valuable.

00:09:21.280 --> 00:09:25.680
And there are some technical aspects of the web that are not always to everyone's liking.

00:09:25.680 --> 00:09:27.960
So that's an interesting platform in that respect.

00:09:27.960 --> 00:09:29.360
It really is.

00:09:29.360 --> 00:09:37.080
You know, you could have sold me on this idea with that statement in 2005, no problem.

00:09:37.080 --> 00:09:48.380
But I think it's even more relevant now because we all have these app platforms and these proprietary APIs, you know, iOS, Android, OS X.

00:09:48.380 --> 00:09:53.200
There's just more and more walled gardens and proprietary stuff.

00:09:53.200 --> 00:09:54.860
Walled gardens and app stores.

00:09:55.220 --> 00:09:56.200
Yes, absolutely.

00:09:56.200 --> 00:09:58.600
And there's, you know, good financial reasons for that, right?

00:09:58.600 --> 00:09:59.040
Absolutely.

00:09:59.040 --> 00:10:01.040
And not just financial reasons.

00:10:01.040 --> 00:10:06.000
Like curated content has a lot of user value and security value and stuff like that.

00:10:06.000 --> 00:10:14.140
So the web has not completely undeserved reputation as a little bit of a security badlands because you don't know whose code you're running half the time.

00:10:14.140 --> 00:10:17.200
You just could have got to trust that the browser is going to do the right thing for you.

00:10:17.820 --> 00:10:18.160
That's right.

00:10:18.160 --> 00:10:33.380
And that's, I think, partly why the JavaScript component of the web is so crucial because if it involves Flash or ActiveX or some other, you know, high privileged C-based plugin, it's not the web.

00:10:33.380 --> 00:10:33.820
Not really.

00:10:34.000 --> 00:10:34.560
Absolutely.

00:10:34.560 --> 00:10:35.280
And you can't really trust it, right?

00:10:35.280 --> 00:10:35.840
Absolutely.

00:10:35.840 --> 00:10:41.720
And so your mission to bring things like Python to the web have to involve JavaScript somehow, right?

00:10:41.720 --> 00:10:42.940
Right.

00:10:43.140 --> 00:10:52.880
And I think there's been a long history and pretty much since the web has been a thing of trying to bring more kind of native platform functionality to the web.

00:10:53.320 --> 00:10:54.660
You know, you mentioned Flash.

00:10:54.660 --> 00:10:59.760
They've had, you know, ActiveX or Java applets, you know, way back in the day.

00:10:59.760 --> 00:11:14.120
And the web has a really long history of trying to compete with native platforms by bringing native platform technologies kind of into the web by expanding the scope of the technology stack of the web.

00:11:14.120 --> 00:11:18.960
As, you know, one after another have been kind of failures.

00:11:18.960 --> 00:11:22.480
They fail to stick for any significant length of time.

00:11:23.040 --> 00:11:25.720
And a lot of the time it's because of aspects like that security, right?

00:11:25.720 --> 00:11:29.760
You're just kind of opening up too many holes, too many opportunities for things to go wrong.

00:11:29.760 --> 00:11:42.100
Whereas if you take kind of JavaScript as your base level, then you can build on this sandbox that's had 20-odd years of, you know, figuring out how to get that right and build that model correctly.

00:11:42.100 --> 00:11:48.140
So if you take that as your foundation, you kind of get a lot of the good security stuff and the lessons learned from the web for free.

00:11:48.140 --> 00:11:50.000
Yeah, I totally agree.

00:11:50.140 --> 00:11:54.720
And it's also worth noting the birthplace of JavaScript is Mozilla, right?

00:11:54.720 --> 00:11:56.500
Well, it wasn't Mozilla back then.

00:11:56.500 --> 00:12:02.400
But yeah, sort of the heritage of JavaScript sort of comes from the same place as Mozilla.

00:12:02.400 --> 00:12:03.080
Yeah, absolutely.

00:12:03.080 --> 00:12:03.700
Yeah, absolutely.

00:12:03.820 --> 00:12:20.280
So when I think about JavaScript frameworks, there's the kind of more lightweight ones where it's, I'm writing, I'm taking some JavaScript API and I'm writing some more JavaScript code to write maybe a single page application.

00:12:20.540 --> 00:12:26.660
So I'm thinking of like Angular, you know, those types of things, jQuery, so on.

00:12:26.660 --> 00:12:38.100
And then at the other end, there's an idea of bringing more stuff into the JavaScript world using the concept of something called asm.js.

00:12:38.600 --> 00:12:40.040
Can you speak to that a little bit?

00:12:40.040 --> 00:12:45.300
So asm.js is a funny beast.

00:12:45.300 --> 00:13:00.280
It's sort of this tiny little subset of JavaScript, which if you look at it in the right light and you kind of suspend disbelief for long enough,

00:13:00.280 --> 00:13:09.040
inside of JavaScript are the semantics of a 32-bit CPU, essentially.

00:13:09.040 --> 00:13:17.520
So JavaScript has, for what is a high-level language, JavaScript has a surprising number of kind of really low-level features.

00:13:17.520 --> 00:13:23.160
Like it's got 32-bit bitwise integer operators and things like this.

00:13:24.460 --> 00:13:33.720
Asm.js basically came out of an attempt by a very smart fellow named Alonza Kai to compile C code to the web.

00:13:33.720 --> 00:13:38.320
And through a series of kind of experimenting with different ways of doing that,

00:13:38.320 --> 00:13:46.560
came to realize that there was this subset of JavaScript that you could target that implemented the semantics of the machine more or less directly,

00:13:46.560 --> 00:13:51.380
that you could then take C code and transliterate into this subset called asm.js.

00:13:52.380 --> 00:13:59.200
And because of the kind of browser wars and the JavaScript performance wars that had been going on up to that time,

00:13:59.200 --> 00:14:02.100
it also happened that that stuff would run pretty fast.

00:14:02.100 --> 00:14:10.540
So he likes to describe it as discovering a kind of low-level 32-bit assembly language hidden inside JavaScript,

00:14:10.540 --> 00:14:11.720
and I think that's pretty apt.

00:14:11.720 --> 00:14:12.860
Very cool.

00:14:12.860 --> 00:14:18.960
Have you seen the video or the PyCon presentation, Birth and Death of JavaScript by Gary Bernhardt?

00:14:19.080 --> 00:14:22.080
I was present in the audience for that talk, and I loved it.

00:14:22.080 --> 00:14:24.100
That was an amazing talk.

00:14:24.100 --> 00:14:28.160
Those of you guys out there listening who haven't seen this, I'll put it in the links.

00:14:28.160 --> 00:14:30.500
And I've referenced it before on the show.

00:14:30.500 --> 00:14:39.080
But he did a really good job of showing off Asm.js and basically bringing anything that can be written in C to the web.

00:14:39.900 --> 00:14:46.120
And one of those was like a pretty high-end video game like Quake or something like this, right?

00:14:46.120 --> 00:14:53.540
They're doing sort of more – within half the speed of Native, I think they usually get these things running.

00:14:53.540 --> 00:14:54.380
It's pretty amazing.

00:14:54.380 --> 00:14:56.060
Yeah, very, very amazing.

00:14:56.440 --> 00:15:01.320
And if you say high-end game like Quake, but I sort of sense that presentation has gone past,

00:15:01.320 --> 00:15:05.020
I think they actually have been launching with even more kind of –

00:15:05.020 --> 00:15:12.680
the very latest and greatest gaming frameworks are starting to ship support for generating Asm.js JavaScript natively.

00:15:12.680 --> 00:15:13.740
That's really amazing.

00:15:14.420 --> 00:15:19.840
Okay, so there's this idea of we can take C code and we can compile it not to machine instructions,

00:15:19.840 --> 00:15:28.500
but we can compile it to a special subset of JavaScript that then can be translated by the browsers to execute very fast.

00:15:28.500 --> 00:15:28.940
Correct.

00:15:28.940 --> 00:15:31.400
So how does this relate to your project, PyPy.js?

00:15:31.400 --> 00:15:38.780
The PyPy.js is sort of a coming together of what to me are two amazing feats of engineering, right?

00:15:38.780 --> 00:15:46.440
And one of them was Asm.js and Emscripten and this whole idea that you can treat the web more or less like a compile target,

00:15:46.440 --> 00:15:48.840
as if it were a native CPU.

00:15:48.840 --> 00:15:52.900
The other half of that, of course, is the PyPy Python interpreter,

00:15:52.900 --> 00:15:55.960
which I think you had an episode on not too long ago.

00:15:55.960 --> 00:15:56.860
That's right.

00:15:56.860 --> 00:15:58.020
That was show 21.

00:15:58.020 --> 00:16:01.660
And PyPy, the interpreter, does some really amazing stuff.

00:16:01.660 --> 00:16:02.560
It's incredible.

00:16:02.560 --> 00:16:08.560
So one of the things that I think actually was talked about a little bit in that episode,

00:16:08.560 --> 00:16:15.100
but one of the things I really like about PyPy is they weren't just focused on writing a really fast Python interpreter.

00:16:15.100 --> 00:16:21.020
They were focused on creating a platform for experimenting with interpreters.

00:16:21.020 --> 00:16:29.040
So it seemed to me the perfect kind of opportunity to learn more about both of these projects.

00:16:29.040 --> 00:16:30.320
I'll learn more about PyPy.

00:16:30.320 --> 00:16:32.820
I'll learn more about Emscripten and Asm.js.

00:16:33.940 --> 00:16:40.380
Because PyPy is structured in such a way to make it really easy to dive in and kind of change bits in and out and play around with it,

00:16:40.380 --> 00:16:48.620
I had this idea that I could get in there and like, well, I'll just find the just-in-time compiler backend inside PyPy,

00:16:48.620 --> 00:16:54.080
and we'll just change it to emit Asm.js instead of, you know, x86 or ARM assembly,

00:16:54.500 --> 00:16:58.860
which in a lot of projects would be kind of a terrifying proposition.

00:16:58.860 --> 00:17:04.660
But because of the amount of kind of just good abstractions and so forth that are inside PyPy,

00:17:04.660 --> 00:17:08.500
it actually was quite approachable as a problem.

00:17:08.500 --> 00:17:18.480
So the coming together basically looks like the PyPy interpreter toolchain run through the Emscripten compiler toolchain

00:17:18.480 --> 00:17:22.560
so that you get a version of it that is compiled to JavaScript.

00:17:22.560 --> 00:17:28.820
And then at runtime, it uses the PyPy just-in-time compiler infrastructure

00:17:28.820 --> 00:17:34.100
to take your Python code that you're running and spit out Asm.js at runtime,

00:17:34.100 --> 00:17:39.400
in the same way that a native PyPy interpreter would spit out kind of specialized native code for your application.

00:17:39.400 --> 00:17:45.900
So very much treating Asm.js as if it were just another dialect of some assembly language for a machine.

00:17:46.300 --> 00:17:46.980
That's so amazing.

00:17:46.980 --> 00:17:51.240
How long did it take you to get a proof of concept that was actually doing something?

00:17:51.240 --> 00:17:58.820
I think my very first proof of concept without the just-in-time compiler part came together pretty quickly.

00:17:58.820 --> 00:18:07.320
I lost maybe two weeks trying to figure out that Emscripten was actually assigning file descriptors

00:18:07.320 --> 00:18:09.700
at different numbers than they usually are in Unix.

00:18:09.700 --> 00:18:15.700
So like standard in is usually file descriptor zero, standard out is usually file descriptor one.

00:18:16.000 --> 00:18:18.760
And it was giving them different numbers because it had never mattered before.

00:18:18.760 --> 00:18:20.360
But PyPy really didn't like it.

00:18:20.360 --> 00:18:24.860
So there are a few kind of just like toolchain compatibility problems like that.

00:18:24.860 --> 00:18:32.140
But sort of once I got that figured out, right, is sort of just compile it as if you were running it through a cross compiler

00:18:32.140 --> 00:18:34.160
and you get it up and running pretty quickly.

00:18:34.680 --> 00:18:39.640
The JIT backend, I probably worked on, on and off for the better part of a year.

00:18:39.640 --> 00:18:45.580
I conceived this scheme at the end of PyCon Australia probably three years ago.

00:18:45.580 --> 00:18:51.020
And then I presented the kind of final first version of it at the following PyCon Australia the next year.

00:18:52.160 --> 00:18:58.420
In your presentation, you said your goal was really to bring support to the web for Python.

00:18:58.420 --> 00:19:04.560
And in your mind, that had to sort of meet three criteria, compatibility, performance, and webbishness.

00:19:04.560 --> 00:19:06.660
Can you talk about that?

00:19:06.660 --> 00:19:07.980
I wish I'd found a better word for that.

00:19:07.980 --> 00:19:10.860
I think that's the official word, yeah.

00:19:10.860 --> 00:19:11.700
Yeah.

00:19:12.860 --> 00:19:17.800
So this is not the first time people have tried to do Python-y stuff on the web.

00:19:17.800 --> 00:19:21.220
I think I even said in the talk it probably won't be the last.

00:19:21.220 --> 00:19:31.780
But it's one of those classic cases that you get in software a lot of a triangle where the three goals are kind of more or less opposed to each other.

00:19:31.780 --> 00:19:35.120
So you've had languages that compile to JavaScript.

00:19:35.120 --> 00:19:36.860
That's a thing that we know how to do.

00:19:36.860 --> 00:19:40.120
And we know how to do that relatively fast.

00:19:40.560 --> 00:19:46.080
As long as your language semantically maps to JavaScript pretty well.

00:19:46.080 --> 00:19:47.660
Python doesn't.

00:19:47.660 --> 00:19:51.960
So in Python, you have big ints by default.

00:19:51.960 --> 00:19:58.280
You have a variety of checks built into your arithmetic operators and a few things like that.

00:19:58.280 --> 00:20:05.300
So the semantics of Python are actually quite different to the semantics of JavaScript, even though they look very similar.

00:20:05.300 --> 00:20:08.780
On the one hand, it's easy to make something go fast in JavaScript.

00:20:08.780 --> 00:20:11.120
If you're not too far from the semantics of JavaScript.

00:20:11.120 --> 00:20:16.780
On the other hand, we know how to compile languages from one to the other, right?

00:20:16.780 --> 00:20:18.940
It's sort of a Turing completeness argument.

00:20:18.940 --> 00:20:34.740
So if we wanted to get a really compliant Python interpreter, you know, one that implements all of the edge cases of CPython up and running on a different platform, you know, it's not implausible that we can get that up and running.

00:20:34.820 --> 00:20:36.780
So it's interesting to see how fast we can do it.

00:20:36.780 --> 00:20:41.760
So there's kind of two relatively opposed goals there, right?

00:20:41.760 --> 00:20:46.200
Being fast and being – I like to say being Python, right?

00:20:46.240 --> 00:20:53.080
But doing all of the things that Python does, not kind of looking a bit like Python, but having JavaScript's number model and things like that.

00:20:53.080 --> 00:20:53.460
Right.

00:20:53.460 --> 00:20:53.880
Exactly.

00:20:53.880 --> 00:21:00.680
There's all these – you know, when you talk to people about JavaScript, they're like, oh, there's all these JavaScript gotchas you have to be on the lookout for.

00:21:01.060 --> 00:21:06.320
I don't typically hear people go, look out for all the Python gotchas because they're lurking everywhere, right?

00:21:06.320 --> 00:21:06.760
Right.

00:21:06.760 --> 00:21:08.700
Python's usually got your back.

00:21:19.700 --> 00:21:22.320
This episode is brought to you by Hired.

00:21:22.320 --> 00:21:28.780
Hired is a two-sided, curated marketplace that connects the world's knowledge workers to the best opportunities.

00:21:28.780 --> 00:21:37.940
Each offer you receive has salary and equity presented right up front, and you can view the offers to accept or reject them before you even talk to the company.

00:21:37.940 --> 00:21:44.300
Typically, candidates receive five or more offers in just the first week, and there are no obligations ever.

00:21:44.300 --> 00:21:46.400
Sounds pretty awesome, doesn't it?

00:21:46.660 --> 00:21:48.460
Well, did I mention there's a signing bonus?

00:21:48.460 --> 00:21:56.900
Everyone who accepts a job from Hired gets a $2,000 signing bonus, and as Talk Python listeners, it gets way sweeter.

00:21:56.900 --> 00:22:04.460
Use the link Hired.com slash Talk Python To Me, and Hired will double the signing bonus to $4,000.

00:22:04.460 --> 00:22:06.180
Opportunity's knocking.

00:22:06.180 --> 00:22:09.780
Visit Hired.com slash Talk Python To Me and answer the call.

00:22:09.780 --> 00:22:20.380
It's usually got your back.

00:22:20.380 --> 00:22:20.760
That's right.

00:22:20.760 --> 00:22:33.860
And so you can't just, for example, translate floats in Python directly over necessarily to just run as JavaScript or numbers, especially integers, like you say, over to JavaScript numbers.

00:22:33.860 --> 00:22:34.640
So there's all that.

00:22:34.640 --> 00:22:36.320
That's the compatibility bit, right?

00:22:36.320 --> 00:22:36.680
Right.

00:22:37.480 --> 00:22:39.520
So, yeah, that's the compatibility aspect.

00:22:39.520 --> 00:22:42.120
And things like parts of the standard library as well.

00:22:42.120 --> 00:22:51.400
You know, do you have all of a full implementation of the sys module, including get frame and kind of the debugger and all of these things?

00:22:52.740 --> 00:22:54.280
And it's interesting.

00:22:54.280 --> 00:22:57.700
It's sort of like, well, I don't really use those things that often.

00:22:57.700 --> 00:23:05.200
You know, I don't really depend on integer overflows escalating to big ints by default that often.

00:23:05.200 --> 00:23:07.700
Or, you know, I don't use sys get frame that often.

00:23:07.960 --> 00:23:08.960
But it's interesting.

00:23:08.960 --> 00:23:09.140
But it's interesting.

00:23:09.140 --> 00:23:22.400
As soon as you start trying to run, like, whole programs on Python, like, you'll find that, oh, you use some library somewhere that uses some library that happens to use one of those things, you know, in some corner of its API.

00:23:23.400 --> 00:23:28.720
So even though they seem like edge cases, they're often not at a whole program level.

00:23:28.720 --> 00:23:29.300
Right.

00:23:29.300 --> 00:23:32.040
They're not necessarily edge cases for small, simple things.

00:23:32.040 --> 00:23:37.620
But if you're going to really write major apps there, then all of a sudden those become things you have to worry about, right?

00:23:37.620 --> 00:23:38.340
Right.

00:23:38.340 --> 00:23:43.840
And something I'm very interested in is less about kind of writing Greenfield's Python code for the web.

00:23:43.840 --> 00:23:47.940
Because, you know, personally, I am not that unhappy writing JavaScript.

00:23:47.940 --> 00:23:54.120
I'm interested in taking Python code that you've written and putting it on the web without having to do a whole lot of work.

00:23:54.120 --> 00:23:57.960
And the compatibility aspect really is really important for things like that.

00:23:57.960 --> 00:23:59.100
Right.

00:23:59.100 --> 00:24:02.000
Like script source equals some file dot py.

00:24:02.000 --> 00:24:03.240
Something like this, right?

00:24:03.240 --> 00:24:04.340
Right.

00:24:04.480 --> 00:24:08.460
Well, so, something like that.

00:24:08.460 --> 00:24:09.240
Yeah.

00:24:09.240 --> 00:24:20.900
But it would be, you know, taking something that you've already written and being able to put it on the web and make use of all of the fun distribution aspects of the web without having to do a whole bunch of busy work to make it run in JavaScript.

00:24:20.900 --> 00:24:21.540
Right.

00:24:21.540 --> 00:24:21.920
Absolutely.

00:24:21.920 --> 00:24:29.600
So it sounds to me like pypy.js completely nails the compatibility part because it's effectively PyPy.

00:24:29.600 --> 00:24:30.440
Is that right?

00:24:30.440 --> 00:24:31.160
Correct.

00:24:31.160 --> 00:24:43.220
So the fun thing about basing this on PyPy is we essentially get the compatibility part for free because they put an amazing amount of work into being a really, really compatible with the Python language reference, cPython.

00:24:43.220 --> 00:24:44.640
And then you get to the performance.

00:24:44.640 --> 00:24:47.540
And performance has multiple aspects.

00:24:47.540 --> 00:24:48.180
All right.

00:24:48.180 --> 00:24:50.220
One is I've got my code loaded up.

00:24:50.720 --> 00:24:57.660
And now I can run this and it's doing XYZ iterations per second with such and such amount of latency.

00:24:57.660 --> 00:25:04.580
The other part of it is I visit the web page and then it responds.

00:25:04.580 --> 00:25:05.240
Right.

00:25:05.240 --> 00:25:05.760
Yes.

00:25:05.760 --> 00:25:08.460
Maybe we could talk about those a bit.

00:25:08.460 --> 00:25:09.440
Absolutely.

00:25:09.440 --> 00:25:19.240
PyPy being interpreted with a just-in-time compiler generally targets kind of steady state performance of your application.

00:25:19.240 --> 00:25:29.980
So, you know, you load some code and you run it for a while and the JIT has a chance to kick in and generate a specialized code and you get very nice kind of steady state performance for the code that you're running.

00:25:29.980 --> 00:25:42.860
And I think, again, the combination of PyPy and Asm.js means we can kind of get a lot of that more or less, I don't want to say for free, but, you know, easily in a JavaScript environment.

00:25:43.280 --> 00:25:51.500
What we really don't get and what is actually really important on the web, as you say, is that kind of initial startup experience.

00:25:51.500 --> 00:26:02.940
Like the time between hitting a web page and being able to interact with it is even more critical on the web than it is in sort of places where you'd normally find Python.

00:26:05.020 --> 00:26:10.320
And PyPy.js, realistically, right now does a pretty terrible job of it.

00:26:10.320 --> 00:26:17.480
It's only so fast you can start interacting with the page and you've got to load sort of megabytes worth of JavaScript to even start running your code.

00:26:17.880 --> 00:26:18.200
Right.

00:26:18.200 --> 00:26:25.820
And so right now, if you look, I think, you know, you have a really great page, arewepythonyet.com, that talks about a lot of cool stuff.

00:26:25.820 --> 00:26:26.880
We can get to that.

00:26:26.880 --> 00:26:35.800
But on there you have the download size, both, you know, off of disk and sort of maybe on the wire, the GZIP representation on the wire.

00:26:35.800 --> 00:26:41.300
And on disk, it's like it was a little higher, but you guys have gotten down to 15 megabytes, right?

00:26:41.300 --> 00:26:41.800
Yep.

00:26:41.800 --> 00:26:43.920
And what is that, like five on the wire?

00:26:44.120 --> 00:26:47.960
Yeah, I guess down to comfortably on a single digits on the wire.

00:26:47.960 --> 00:26:50.040
I think five is probably about right.

00:26:50.040 --> 00:26:55.120
Which for a native application is not terrible.

00:26:55.120 --> 00:26:57.760
Like that's kind of in the ballpark.

00:26:57.760 --> 00:27:01.520
But for stuff that you have to load up in order to interact with a web page, it's not great.

00:27:01.520 --> 00:27:02.600
Yeah.

00:27:02.600 --> 00:27:08.880
Typically, we talk about minification of our JavaScript and it's smaller, usually smaller than five megs.

00:27:08.880 --> 00:27:09.580
Yes.

00:27:09.580 --> 00:27:13.360
Usually not measured in megabytes, let's be quite frank about it.

00:27:13.360 --> 00:27:14.960
That's right.

00:27:14.960 --> 00:27:16.460
That's huge.

00:27:16.460 --> 00:27:17.340
What is that, 100K?

00:27:17.340 --> 00:27:18.380
No, no, that's 20 megs.

00:27:18.380 --> 00:27:24.920
But, you know, there are potential solutions, right?

00:27:24.920 --> 00:27:28.220
I mean, there are CDNs, extreme caching.

00:27:28.220 --> 00:27:29.260
Right.

00:27:29.260 --> 00:27:32.740
Could alleviate this somewhat, right?

00:27:32.820 --> 00:27:37.880
The core runtime parts could somehow be sort of shared across sites.

00:27:37.880 --> 00:27:38.900
Indeed.

00:27:38.900 --> 00:27:43.420
I think there's actually still a lot of low-hanging fruit in that size, right?

00:27:43.420 --> 00:27:51.840
So that size includes, for example, an entire Unicode character database, which is built into the interpreter in PyPy.

00:27:52.380 --> 00:27:59.420
It includes all of the standard library modules that are built into the interpreter, whether you're going to use them or not, and things like that.

00:27:59.420 --> 00:28:02.320
So there is definitely some scope for making that smaller.

00:28:02.320 --> 00:28:08.100
And I've made more minimal builds of it that are several megabytes smaller.

00:28:09.220 --> 00:28:14.080
But I don't think it's ever going to get down to, you know, tens of kilobytes in size.

00:28:14.080 --> 00:28:15.220
This is pretty unrealistic.

00:28:15.220 --> 00:28:25.340
If you go and download CPython from python.org, compressed, that's like 22, 23 megabytes, right?

00:28:25.340 --> 00:28:32.880
And so, you know, if you're going to ship the whole runtime, the implementation, the PyPy implementation, that's kind of a lower bound in some way.

00:28:32.880 --> 00:28:34.820
Exactly.

00:28:34.820 --> 00:28:38.680
But that's not always a problem.

00:28:38.680 --> 00:28:46.540
You know, if you look at this as a way to write all of your kind of interactive website scripting in Python instead of JavaScript,

00:28:46.540 --> 00:28:50.140
like you were saying, kind of script lang equals text Python,

00:28:50.800 --> 00:28:56.120
that's a tremendous amount of overhead to pay before you can do any of the interactivity on your site.

00:28:56.120 --> 00:29:03.320
But if you're doing something like shipping a kind of more appy experience that you've built in Python,

00:29:03.320 --> 00:29:08.460
kind of bootstrapping into, in the same way that you might if you're loading up a game on the web

00:29:08.460 --> 00:29:12.120
or like some sort of more heavyweight application, it's less of a big deal.

00:29:12.120 --> 00:29:18.720
So, and, you know, the games that are compiled for the web within script and have this problem as well, right?

00:29:18.720 --> 00:29:20.480
You want to get into the game and start playing it.

00:29:20.520 --> 00:29:26.180
You've got to download many more megabytes of like image assets and compiled code and all this sort of stuff.

00:29:26.180 --> 00:29:29.260
But it's okay for that use case.

00:29:29.260 --> 00:29:36.900
And I think that's sort of the point where we're at with the project now where the people that are sort of really showing an interest in starting to use it

00:29:36.900 --> 00:29:39.900
are cases where that's going to be less and less of a concern,

00:29:39.900 --> 00:29:46.480
where you're okay to kind of wait for a few seconds while you're bootstrapping into a fairly elaborate experience.

00:29:47.360 --> 00:29:47.720
Right.

00:29:47.720 --> 00:29:51.840
And like I said, once you get that loaded up the first time, you can cache it.

00:29:51.840 --> 00:29:58.060
So if you're able to wait five seconds or whatever it takes to download that, then, you know, maybe it's possible.

00:29:58.880 --> 00:30:02.260
So games are obviously one concept here.

00:30:02.260 --> 00:30:09.760
Maybe if you're doing some, like I said, single page app thing where you kind of load it up and then you just stay there for a long time.

00:30:09.760 --> 00:30:10.500
Right.

00:30:11.000 --> 00:30:26.480
So I had some preliminary kind of interactions with the Jupyter and IPython people trying to get this plugged in.

00:30:27.600 --> 00:30:30.120
And in a sense, it actually went really well.

00:30:30.120 --> 00:30:35.260
They've got a really excellent infrastructure for plugging in different language backends and different, you know,

00:30:35.260 --> 00:30:40.000
they can do Ruby or whatever plugged into their infrastructure.

00:30:40.000 --> 00:30:42.160
So that, in a sense, kind of works.

00:30:42.160 --> 00:30:46.080
Like, hey, you can plug in, plug Pypy.js and run this completely client side.

00:30:46.080 --> 00:30:51.600
Of course, then, what that's missing is all of the fun libraries that you might want to use with that.

00:30:51.600 --> 00:30:56.900
So if you want to do scientific Python on the web, scientific kind of programming on the web in Python,

00:30:56.900 --> 00:31:03.060
you're going to want things like NumPy and sort of all of the analysis libraries that typically go along with that.

00:31:03.060 --> 00:31:09.060
So I'm still interested in kind of pushing ahead and seeing where we can go with that.

00:31:09.880 --> 00:31:15.300
But I think it becomes more of a library problem at that point, making sure you can actually ship that,

00:31:15.300 --> 00:31:20.620
all of the details of that experience that people would expect and not just the Python interpreter itself.

00:31:20.620 --> 00:31:25.640
The Python interpreter itself is actually probably the easiest of the bits, right?

00:31:25.640 --> 00:31:31.380
Because then you've got to get NumPy and SciPy and scikit-learn, and a lot of those have C extensions,

00:31:31.380 --> 00:31:34.100
which then you've got to get into Asm.js again.

00:31:34.100 --> 00:31:34.540
Right.

00:31:34.540 --> 00:31:39.720
There's a lot of nuances that people building those libraries have never thought of, right?

00:31:39.720 --> 00:31:40.360
Exactly.

00:31:40.360 --> 00:31:44.160
And so in theory, that's all possible, right?

00:31:44.160 --> 00:31:49.340
It's all the same principle of we've got code for a native platform where we can retarget it for the web.

00:31:49.340 --> 00:31:52.340
But it's never quite that straightforward in practice.

00:31:52.340 --> 00:31:57.040
Do you want to talk about arewepythonyet.com a bit?

00:31:57.040 --> 00:31:57.920
Sure.

00:31:57.920 --> 00:31:59.180
Yeah.

00:31:59.180 --> 00:32:01.000
So what was the idea?

00:32:01.000 --> 00:32:06.580
You said that was inspired by some sort of performance metrics at Mozilla historically.

00:32:07.640 --> 00:32:12.580
The domain name in particular is a little kind of inside joke at Mozilla, right?

00:32:13.900 --> 00:32:24.020
When the browser performance wars were really heating up, folks that were working on JavaScript performance at Mozilla needed a place to put their public JavaScript benchmarks.

00:32:24.020 --> 00:32:32.440
And so they created this site called arewepastyet.com, which you could go to and just kind of look at all of the different JavaScript benchmarks that were running in the different engines.

00:32:33.140 --> 00:32:35.520
And it kind of became a little bit of a thing at Mozilla.

00:32:35.520 --> 00:32:46.160
So when people were talking about, oh, Firefox is a real memory hog and we need to do something about the memory usage of Firefox, you know, they started up a metrics tracking site called areweslimyet.com.

00:32:46.700 --> 00:32:55.800
We were starting to really measure our community contributions and figure out, you know, how many contributors we're getting from different parts of the world and how big the community is growing.

00:32:55.800 --> 00:33:00.780
Like they set up a metrics tracking website called arewemillionyet.com.

00:33:00.780 --> 00:33:09.180
And sort of this ongoing habit of just trying to picking things that we really want to make a big difference to and measuring them and putting it up somewhere for everyone to see.

00:33:09.460 --> 00:33:15.460
The other folks that are really keen on, you know, doing public performance measurements are the PyPy team.

00:33:15.460 --> 00:33:26.060
So the benchmarks that are on arewepythonyet.com are all taken from the PyPy Speed Center, which I haven't managed to get all of their benchmarks running, but I've got a good subset of them.

00:33:26.060 --> 00:33:37.080
But yeah, sort of both places, I guess, have a really strong history of being really upfront and public about all of their performance metrics tracking.

00:33:37.080 --> 00:33:40.920
I think it's a wonderful philosophy to try and follow in the footsteps of.

00:33:40.920 --> 00:33:42.160
Yeah, that's great.

00:33:42.160 --> 00:33:48.760
And you go there and you can really quickly see where the performance is really good and where it might lag behind.

00:33:48.760 --> 00:33:58.920
And one of the things I thought was really interesting is there are plenty of places where PyPy.js is literally faster than CPython.

00:33:58.920 --> 00:33:59.840
Yep.

00:33:59.840 --> 00:34:04.220
All of that magic, of course, is due to the PyPy JIT.

00:34:04.220 --> 00:34:09.360
And if you change the comparison to compare it to a native PyPy, of course, it's going to be uniformly slower.

00:34:09.360 --> 00:34:12.880
But yeah, I was pretty amazed.

00:34:12.880 --> 00:34:29.320
That's sort of one of the challenges I set myself when I was starting out on this little experiment was to say, look, you know, is the combination of Asm.js, you know, being almost as fast as a native platform and PyPy being kind of consistently faster than CPython.

00:34:29.920 --> 00:34:36.820
Can that in combination mean we can actually run Python benchmarks in the web faster than your standard Python interpreter?

00:34:36.820 --> 00:34:40.640
And it's pretty astonishing to find out that that is, in fact, the case.

00:34:44.640 --> 00:34:57.980
This episode is brought to you by CodeShip.

00:34:57.980 --> 00:35:06.820
CodeShip has launched organizations, create teams, set permissions for specific team members, and improve collaboration in your continuous delivery workflow.

00:35:07.240 --> 00:35:12.720
Maintain centralized control over your organization's projects and teams with CodeShip's new organizations plan.

00:35:12.720 --> 00:35:18.260
And as Talk Python listeners, you can save 20% off any premium plan for the next three months.

00:35:18.260 --> 00:35:21.780
Just use the code TALKPYTHON, all caps, no spaces.

00:35:21.780 --> 00:35:27.500
Check them out at CodeShip.com and tell them thanks for supporting the show on Twitter where they're at CodeShip.

00:35:33.960 --> 00:35:39.420
Yeah, I was, when I pulled this up, I was like, all right, let's see how many times slower it is.

00:35:39.420 --> 00:35:42.100
Is it like something we could live with because it's going to run in the browser?

00:35:42.100 --> 00:35:44.640
And I was like, wow, okay, that's really cool.

00:35:44.640 --> 00:35:53.680
It's also fun to click off the D8 interpreter in those comparisons and get just the SpiderMonkey engine.

00:35:53.680 --> 00:35:56.460
It'd get a little bit more times faster than CPython as well.

00:35:56.460 --> 00:35:57.700
That's awesome.

00:35:57.700 --> 00:36:01.540
And of course, D8 is Chrome and SpiderMonkey is Firefox, right?

00:36:02.140 --> 00:36:03.980
V8 JavaScript engine, yes.

00:36:03.980 --> 00:36:06.600
Same one that runs Node.js, right?

00:36:06.600 --> 00:36:07.600
So very interesting.

00:36:07.600 --> 00:36:13.740
So the performance story is really, really good on the execution side.

00:36:13.740 --> 00:36:18.220
But then you also have the stuff about sort of the startup and the download size and so on.

00:36:18.220 --> 00:36:19.260
Right.

00:36:19.260 --> 00:36:22.580
So there's no point, you know, trying to hide any of that stuff.

00:36:22.580 --> 00:36:24.740
There's a whole tab there about startup overhead.

00:36:24.740 --> 00:36:27.340
And it does indeed measure the download size in megabytes.

00:36:27.340 --> 00:36:30.900
And you can, you know, it's even got a little feature there.

00:36:30.900 --> 00:36:34.740
You can actually click to just test how long it'd take to load up on your machine.

00:36:34.740 --> 00:36:40.460
What's interesting here actually is the download size is one thing.

00:36:40.460 --> 00:36:43.520
Like that's kind of understood and easy to grasp.

00:36:43.520 --> 00:36:45.960
But there's also a graph of the time it takes.

00:36:45.960 --> 00:36:52.960
Like once you've downloaded that, how long does it take for the JavaScript engine to actually kind of initialize this interpreter?

00:36:52.960 --> 00:36:56.760
And that actually is on the order of a second or two just by itself, right?

00:36:56.760 --> 00:37:04.440
Kind of taking all of that JavaScript code and parsing it and loading it up into the browser is actually, you know, makes the browser work really hard.

00:37:04.800 --> 00:37:09.440
Yeah, it's a large quantity of JavaScript that you can understand, right?

00:37:09.440 --> 00:37:12.580
So, you know, you work at Mozilla.

00:37:12.580 --> 00:37:13.840
Maybe you can pull some strings.

00:37:13.840 --> 00:37:26.440
Is it, would it be possible to take projects like this, like Asm.js and PyPy.js and have them sort of certain versions shipped with browsers?

00:37:26.440 --> 00:37:34.060
So like when I load up Firefox and I hit a page and it says, give me PyPy.js, it goes, we already have that downloaded.

00:37:34.280 --> 00:37:34.800
Let's go.

00:37:34.800 --> 00:37:37.560
I'd love to think I could pull those strings.

00:37:37.560 --> 00:37:39.440
I don't know if I really have that power.

00:37:39.440 --> 00:37:55.980
But I mean, the thing about the web, and this has been a general principle of the web for a long time, right, is no one browser vendor really has the power to do that by themselves.

00:37:57.720 --> 00:38:09.180
So, you know, we could kind of put this in the browser and say, yeah, like, you know, we want to treat Python as a first class language and we're going to special case it in the browser and get a really good experience for Firefox users.

00:38:10.460 --> 00:38:21.160
But the individual market share of us or any other browser who tried to do that is probably not sufficient to, for people writing websites to be able to depend on it, right?

00:38:21.160 --> 00:38:22.280
Yeah, absolutely.

00:38:22.420 --> 00:38:26.360
And the most important use case of that would be on mobile.

00:38:26.360 --> 00:38:28.160
And then that's an even harder sell.

00:38:28.160 --> 00:38:28.840
Absolutely.

00:38:28.840 --> 00:38:29.660
Absolutely.

00:38:30.440 --> 00:38:51.920
What's really interesting and sort of segueing out of that a little bit, what you really need in order for something like this to kind of take the next step and to get over some of these kind of fundamental problems of code size or load time or whatever is, you know, if you can't find a way to hack around that in JavaScript, which for some of these things we really can't.

00:38:51.920 --> 00:39:00.560
You kind of need all of the browser vendors to agree on a way forward and sort of everyone's got to ship something better together.

00:39:00.560 --> 00:39:19.040
And one of the amazing things that's happened coming out of Asm.js and experiments like the Games initiative that have kind of proven that that's a really powerful thing is you're actually seeing all of the browser vendors sort of getting together and talking about, well, like, what's next after Asm.js?

00:39:19.040 --> 00:39:20.460
Like, how can we make this better?

00:39:21.140 --> 00:39:27.220
How can we really commit to this as the web rather than any particular browser platform?

00:39:27.220 --> 00:39:29.780
That's really, I mean, that's the way the web works, right?

00:39:29.780 --> 00:39:31.460
That's the way the web is successful anyway.

00:39:31.460 --> 00:39:41.080
Like you said, people have tried to jam their way through, you know, like, IE6 type stuff that happened back in those days, but that's not really what sticks.

00:39:41.080 --> 00:39:46.080
You've got to have a good story for getting from where the web is to where you want the web to be.

00:39:46.080 --> 00:39:50.300
And Asm.js kind of really came in and provided that.

00:39:50.360 --> 00:39:53.360
It's like, all right, we want to treat the web as a compilation target.

00:39:53.360 --> 00:39:56.380
And here's a pretty okay way of doing it.

00:39:56.380 --> 00:39:56.800
All right.

00:39:56.800 --> 00:39:58.760
You know, we can get to that point.

00:39:58.760 --> 00:40:02.820
So now you've got impetus to actually make that better.

00:40:04.420 --> 00:40:08.760
Yeah, a foundational idea to start from that everybody can start to come from.

00:40:08.760 --> 00:40:09.140
Right, exactly.

00:40:09.140 --> 00:40:19.560
You know, people had traditionally talked about JavaScript as the assembly language of the web, sort of conceptually, but Asm.js is kind of making that concrete in a very real way.

00:40:20.100 --> 00:40:26.020
The name of the kind of project that's spinning up out of that discussion is called WebAssembly.

00:40:26.020 --> 00:40:31.980
And it's very much targeted at being like, here's an actual assembly language for the web, right?

00:40:31.980 --> 00:40:46.900
It's kind of like, take that idea that Asm.js proved is plausible, you know, doing this assembly language on top of the semantics of JavaScript, but outside of the limitations of necessarily, you know, 100% backwards compatibility with JavaScript.

00:40:47.760 --> 00:40:56.680
So it's gone from kind of like, yeah, this should be the assembly language of the web and kind of like, this is what it looks like, to suddenly taking that idea really seriously.

00:40:56.680 --> 00:41:01.640
Yeah, the future is going to be super interesting when that sort of takes hold.

00:41:01.640 --> 00:41:02.140
Absolutely.

00:41:02.140 --> 00:41:12.460
And I think, you know, a lot of these problems, like the load time of the JavaScript and the download size, like they'll get better for free when that technology starts to kick in.

00:41:12.460 --> 00:41:14.040
They won't go away, but they'll get better.

00:41:14.040 --> 00:41:15.400
Right.

00:41:15.640 --> 00:41:21.620
And a lot of the stuff that you sort of shipped from your site that would have been JS files or whatever are now binary, right?

00:41:21.620 --> 00:41:22.500
In that spec?

00:41:22.500 --> 00:41:23.480
Right.

00:41:23.480 --> 00:41:23.840
Right, exactly.

00:41:23.840 --> 00:41:27.200
So Python 2 or Python 3?

00:41:27.200 --> 00:41:29.000
Currently Python 2.

00:41:29.000 --> 00:41:31.880
Mostly by default.

00:41:31.880 --> 00:41:35.260
But that describes me as well as this project.

00:41:35.260 --> 00:41:37.220
I'm one of the laggards.

00:41:37.220 --> 00:41:44.440
I'm sort of slowly coming to the realization that I'm falling behind and that I still use Python 2 by default everywhere.

00:41:45.280 --> 00:41:51.640
That said, one of the neat things about this, right, is the PyPy team are working really hard on their Python 3 compatibility.

00:41:52.260 --> 00:42:03.880
And so it's a pretty straightforward prospect to kind of ride along the coattails of that work and ship Python 3 in the browser just as easily as you can ship Python 2 on top of this technology stack.

00:42:03.880 --> 00:42:03.980
Yeah.

00:42:03.980 --> 00:42:11.260
That's great because you're just taking literally the PyPy interpreter as it is and sending it through this tool chain.

00:42:12.120 --> 00:42:17.560
Whatever support PyPy has for Python 3 more or less is the support you have for it, right?

00:42:17.560 --> 00:42:18.600
Right, exactly.

00:42:18.600 --> 00:42:20.200
It sort of just comes out the other end.

00:42:20.200 --> 00:42:26.240
And that goes for all of the other languages that people are experimenting with on top of the PyPy tool chain as well.

00:42:26.240 --> 00:42:27.140
Yeah.

00:42:27.220 --> 00:42:31.980
I read an interesting article just this week talking about Python 2 versus Python 3.

00:42:31.980 --> 00:42:35.860
And, you know, there's a lot of practical reasons that a lot of people are still doing Python 2.

00:42:35.860 --> 00:42:39.240
And this article was called Planning an Early Death for Python 2.

00:42:39.240 --> 00:42:41.200
And it had some really interesting ideas.

00:42:41.200 --> 00:42:42.220
I'll be sure to link to it.

00:42:42.300 --> 00:42:47.000
But a lot about the way, like, people culturally think and talk about Python.

00:42:47.000 --> 00:42:49.320
They were attempting to change that there.

00:42:49.320 --> 00:42:50.740
And I thought it was an interesting idea.

00:42:50.740 --> 00:42:51.960
Anyway, I'll link to that for everyone.

00:42:51.960 --> 00:42:52.720
Yeah, cool.

00:42:52.720 --> 00:43:02.800
For what it's worth, I've really noticed a change in the community in the last year or two where it's kind of Python 3 is – it seems to have kind of broken through in a sense.

00:43:02.800 --> 00:43:07.480
Like, people might look at you a little bit odd if you're not taking Python 3 seriously.

00:43:07.480 --> 00:43:10.080
Or at least it's something I've noticed anyway.

00:43:10.320 --> 00:43:12.500
Yeah, I've definitely noticed the same thing.

00:43:12.500 --> 00:43:20.980
So are there notable deployments or places that we could go find that PyPyJS is being used yet?

00:43:20.980 --> 00:43:22.120
Or is it too early for that?

00:43:22.120 --> 00:43:23.220
What's the story around there?

00:43:23.220 --> 00:43:26.040
I think it's broadly too early for that.

00:43:26.040 --> 00:43:29.960
I mean, you can go to the PyPyJS website and muck around with it.

00:43:29.960 --> 00:43:32.660
It's sort of an interesting project for me.

00:43:32.660 --> 00:43:36.600
I was sort of in the position of doing a project that I don't really want to build anything with.

00:43:36.600 --> 00:43:38.880
Like, the project itself is the point of it for me.

00:43:39.700 --> 00:43:46.720
So I've been talking to a couple of different people who are interested in trying it out as part of an actual product.

00:43:46.720 --> 00:43:54.920
In places where you might use something like IPython or sort of one of the other in-browser Python environments currently.

00:43:54.920 --> 00:43:57.460
But I don't think any of those are live yet.

00:43:57.460 --> 00:44:05.220
They've certainly – I've got people showing up and chipping into the project and trying it out and experimenting with using it in their stuff.

00:44:05.300 --> 00:44:08.140
But I don't think anyone's quite put it into production just yet.

00:44:08.140 --> 00:44:08.600
Right.

00:44:08.600 --> 00:44:12.320
And if you want to check out the code, it's at github.com/PyPyJS.

00:44:12.320 --> 00:44:15.040
So pretty easy to find, right?

00:44:16.600 --> 00:44:25.320
Do you see maybe a use case in some of the more, like, offline app-ish HTML5 apps?

00:44:25.320 --> 00:44:30.340
So I'm thinking, like, Firefox OS, like, PhoneGap-type platforms?

00:44:30.340 --> 00:44:31.360
Absolutely.

00:44:31.780 --> 00:44:38.200
So that's one of the places where the startup overhead of this whole infrastructure will be less of a problem.

00:44:38.560 --> 00:44:42.700
Because you can list, you know, the files to be downloaded as, like, your app manifest.

00:44:42.700 --> 00:44:46.060
And you kind of get better control over the caching and things like that.

00:44:46.060 --> 00:44:55.840
So it probably makes more sense in that sort of contained experience of an app than it does as, you know, a bit of scripting on the open web somewhere.

00:44:55.840 --> 00:44:57.000
Sure.

00:44:57.000 --> 00:44:58.720
Yeah, that definitely seems like it.

00:44:58.720 --> 00:44:59.860
What about Chrome OS?

00:44:59.860 --> 00:45:02.900
To be honest, I haven't thought about it.

00:45:03.400 --> 00:45:09.720
I'm not sure you're allowed to promote them, but, you know, those do have sort of prepackaged offline manifest type stuff, right?

00:45:09.720 --> 00:45:12.580
So it seems potentially would be good.

00:45:12.580 --> 00:45:28.140
And particularly as the web kind of comes to terms with that packaging of applications and more standards sort of start to emerge around it, then, you know, ideally, you don't have to make that distinction like, oh, PhoneGap or Firefox OS or Chrome OS.

00:45:28.140 --> 00:45:30.700
It's kind of like, oh, this is how we do packaged apps for the web.

00:45:30.700 --> 00:45:33.300
And Python has a place in that ecosystem.

00:45:33.540 --> 00:45:34.700
That would be a really great outcome.

00:45:34.700 --> 00:45:36.980
That would be absolutely a great outcome.

00:45:36.980 --> 00:45:44.680
There are other sort of Python in a browser type frameworks or attempts or projects.

00:45:44.680 --> 00:45:47.840
And you listed something like at least nine in your talk.

00:45:47.840 --> 00:45:50.300
You know, two that are pretty popular come to mind.

00:45:50.300 --> 00:45:51.280
One is Sculpt.js.

00:45:51.280 --> 00:45:54.460
I had Brad Miller on one of the earlier shows to talk about that.

00:45:55.040 --> 00:45:56.760
And another was Brython.

00:45:56.760 --> 00:46:04.280
And those seem more like, you know, script lang equals Python sort of type of frameworks.

00:46:04.280 --> 00:46:06.420
But they make tradeoffs to make that possible.

00:46:06.420 --> 00:46:08.180
Can you compare those a bit?

00:46:08.180 --> 00:46:09.240
Exactly.

00:46:09.500 --> 00:46:11.240
I'm not super familiar with Sculpt.

00:46:11.240 --> 00:46:14.000
But I had a look at Brython in some detail.

00:46:14.000 --> 00:46:17.860
And I'm actually quite a fan of the stuff they're doing.

00:46:17.860 --> 00:46:20.940
I think they've selected an excellent set of tradeoffs.

00:46:20.940 --> 00:46:25.440
It's a different set of tradeoffs to the ones that PyPy.js is interested in.

00:46:26.440 --> 00:46:33.280
And the big tradeoff that they make in Brython to get good performance is the number model.

00:46:33.280 --> 00:46:45.440
So if you do like a for loop, like, you know, for X in range one to 100, right, that will get turned more or less directly into a JavaScript loop over JavaScript numbers.

00:46:45.440 --> 00:46:48.340
And for that use case, it's absolutely fine.

00:46:48.340 --> 00:46:50.220
Like, JavaScript numbers will behave correctly.

00:46:51.860 --> 00:47:08.720
But if you ever happen to get yourself, get your code into a situation where, you know, you're counting up a little too high or you're dividing by a number that you're accidentally dividing by zero or something like that, then you're not quite getting the semantics of Python's number model on top of Brython.

00:47:08.720 --> 00:47:17.360
For the script kind of text equals Python use case, we're actually, like, writing new code.

00:47:17.360 --> 00:47:21.760
You can write that code for Brython, and it's a really excellent set of tradeoffs.

00:47:21.760 --> 00:47:23.940
Because you know to watch out for those things.

00:47:23.940 --> 00:47:31.460
But if you were to take a, just, you know, get some Python code off the shelf and try and run it through, then, you know, you've got more chance of it's going to trip you up.

00:47:31.460 --> 00:47:42.920
So, of course, what you get in return for making that tradeoff is you get a much better kind of startup experience, much lighter weight integration into the browser, a lot less JavaScript to load.

00:47:42.920 --> 00:47:50.400
And in some cases, sort of a tighter integration with the browser and with the native DOM and stuff like that.

00:47:51.280 --> 00:47:54.760
Right, because they can lean more heavily on JavaScript itself.

00:47:54.760 --> 00:47:55.700
Correct.

00:47:55.700 --> 00:48:00.420
So, from Brython's perspective, it's targeting JavaScript.

00:48:00.420 --> 00:48:04.540
So, it can interact with JavaScript objects and this sort of thing.

00:48:04.540 --> 00:48:14.000
From PyPyJS's perspective, it's kind of targeting this weird C-like platform that happens to run on JavaScript, but you can't really see.

00:48:15.220 --> 00:48:19.480
It's difficult for it to see the native JavaScript objects and so forth in a sensible way.

00:48:19.480 --> 00:48:25.380
You did show a way that you could interact with libraries such as jQuery and the DOM and so on.

00:48:25.380 --> 00:48:26.080
Absolutely.

00:48:26.080 --> 00:48:27.660
From PyPy.js, right?

00:48:27.660 --> 00:48:28.540
Yes.

00:48:28.540 --> 00:48:29.320
That works.

00:48:29.320 --> 00:48:32.740
That actually works surprisingly well for what it is.

00:48:32.960 --> 00:48:39.180
And the way to think about that is a lot more like C-types or CFFI.

00:48:39.180 --> 00:48:47.500
Like, it's more like you're doing a C-binding to the objects in your JavaScript world than interacting with them directly.

00:48:47.980 --> 00:48:51.900
And on top of that, you can build a nice little API that exposes them as Python objects.

00:48:51.900 --> 00:49:04.460
But when you go to use that bridge between PyPyJS and the native JavaScript environment, you're going through basically indirecting through a C-API.

00:49:05.000 --> 00:49:14.240
That makes it something of a challenge to do fast and to do things like cross-language reference cycles, for example.

00:49:14.240 --> 00:49:21.060
You know, if you've got a Python object that refers to a JavaScript object that refers back to a Python object, it can get a bit weird.

00:49:21.060 --> 00:49:24.880
But for a lot of stuff, it works surprisingly well.

00:49:25.840 --> 00:49:26.440
Oh, yeah.

00:49:26.440 --> 00:49:29.560
Because, you know, maybe you don't need super complicated interaction.

00:49:29.560 --> 00:49:35.820
But, like, I'd like to grab something out of this text box and then display it over here in this, you know, select or whatever.

00:49:35.820 --> 00:49:36.180
Yeah.

00:49:36.180 --> 00:49:36.680
Yeah.

00:49:36.680 --> 00:49:44.160
For things that are, you know, strings and things that are immutable or things that don't really have references back into Python, it's fine.

00:49:44.160 --> 00:49:45.040
No dramas at all.

00:49:45.040 --> 00:49:55.520
One thing that I was thinking about as I was thinking about your project was, you know, you're talking about taking Asm.js and focusing on that.

00:49:55.520 --> 00:49:56.940
And compiling down to this subset.

00:49:56.940 --> 00:50:06.160
And there are other projects that both describe Python sort of more fully and JavaScript more fully.

00:50:06.160 --> 00:50:15.200
So, for example, TypeScript on the JavaScript side, which is like an optionally typed JavaScript type thing that AngularJS has adopted, right?

00:50:15.200 --> 00:50:19.260
And then the type hints that are coming in Python 3.5.

00:50:19.260 --> 00:50:22.920
Do any of those types of things help here or does it just not really matter?

00:50:23.680 --> 00:50:32.400
I think the way this particular kind of collection of technologies operates is at far too low a level for those to make a difference.

00:50:32.400 --> 00:50:40.020
I think it would be really interesting to try and do higher level correspondence between those two things.

00:50:40.020 --> 00:50:44.280
But I think it would be a very different size and shape project.

00:50:44.720 --> 00:50:46.980
Yeah, it's not something you could shoehorn in, is it?

00:50:46.980 --> 00:50:47.840
Right.

00:50:47.840 --> 00:50:48.960
No, not at all.

00:50:48.960 --> 00:51:00.400
Yeah, for all of the fun of kind of having it eventually run on JavaScript, actually, the experience of building it feels a lot more like building something in C.

00:51:01.440 --> 00:51:04.820
And the JavaScript kind of just appears as a platform underneath it.

00:51:04.820 --> 00:51:10.980
Because you're using the same tool set that they use for C, like LLVM compilers and things like that, right?

00:51:10.980 --> 00:51:15.060
Right, so classic compiler tool chain that just happens to spit out JavaScript at the other end.

00:51:15.720 --> 00:51:25.340
Yeah, it's like saying, well, when I'm doing C++, how does stuff happening in machine language and assembly, you don't even think about it, right?

00:51:25.340 --> 00:51:25.620
Right.

00:51:25.620 --> 00:51:26.540
Same thing here, more or less?

00:51:26.540 --> 00:51:26.880
Right.

00:51:26.880 --> 00:51:27.580
Exactly.

00:51:28.860 --> 00:51:30.800
Well, Ryan, we're kind of coming up near the end of the show.

00:51:30.800 --> 00:51:34.600
Do you have maybe some call to actions for people out there?

00:51:34.600 --> 00:51:40.040
I'm really interested in connecting with people who want to put this to concrete use.

00:51:40.040 --> 00:51:47.860
I think what the project really needs now is kind of be driven by concrete use cases.

00:51:47.860 --> 00:51:54.960
So it's past the point of like, oh, experiment with these fun technologies and see what's possible, right?

00:51:54.960 --> 00:51:58.740
See how fast we can make it or things like that.

00:51:58.740 --> 00:52:07.080
There's still ground to cover, but that's kind of the real experimental phase of that is more or less done.

00:52:07.080 --> 00:52:17.120
And in order to go from experiment to actual product and for me to like go into the website and remove the word experiment from the description of the project,

00:52:17.120 --> 00:52:23.480
it really needs to make that jump into something that people actually would be happy to deploy and practice.

00:52:24.860 --> 00:52:32.260
I need to talk to a couple of people who are doing like Python shells in the web for a variety of reasons who are interested in trying it out.

00:52:33.380 --> 00:52:48.460
But I'd love to hear if people had a Python application that they thought would be really interesting to port to the web in the same way that you might like take a game that you've got written in Python and package it up with Py2.exe and ship it to your Windows users, right?

00:52:49.360 --> 00:52:56.200
If you've got something that you think, that'd be really great if I could just take this Python kind of application and port it to the web.

00:52:56.200 --> 00:52:58.240
I'd love to just kind of talk through the possibilities.

00:52:59.820 --> 00:53:03.520
I think that's, as much as anything, that's what the project needs right now.

00:53:03.520 --> 00:53:09.240
People to come and try and put it to use and see what works and what doesn't and we'll fix the bits that don't.

00:53:09.240 --> 00:53:12.960
A great call to action and that is what makes projects real, right?

00:53:12.960 --> 00:53:18.800
When people use them and they have to hit all the little edge cases and sort of smooth it out.

00:53:18.800 --> 00:53:20.100
So it's a real product, right?

00:53:20.100 --> 00:53:21.460
Exactly right.

00:53:21.540 --> 00:53:25.380
You sort of can't get away from the fact that you've got to download 10 mega JavaScript.

00:53:25.380 --> 00:53:31.300
You can wave your hands and pretend that's not an issue when you're doing an experiment but not when you're doing a product.

00:53:31.300 --> 00:53:33.560
Right, absolutely.

00:53:33.560 --> 00:53:41.760
So another thing that I thought you had as kind of a final call to action in your talk was the concept of filing bugs against the web.

00:53:41.760 --> 00:53:45.700
Do you want to maybe talk to that really quick because that's a cool Mozilla idea, I think.

00:53:45.700 --> 00:53:50.660
I guess the driving force for this project for me is really that philosophy.

00:53:50.860 --> 00:53:54.220
It's the idea that the web should be a first class computing platform.

00:53:54.220 --> 00:54:00.940
And a lot of people kind of in the habit of thinking like, oh, the web can't do this.

00:54:00.940 --> 00:54:05.560
Or I really want to do this on the web but it's not going to work because X, Y, and Z.

00:54:05.560 --> 00:54:14.220
And it wasn't until I actually started working at Mozilla that it kind of occurred to me that actually, you know, the web is a really fluid medium.

00:54:14.220 --> 00:54:19.960
There are a lot of people who really care deeply about the web being a really powerful platform.

00:54:20.180 --> 00:54:22.560
And sort of invested in the web.

00:54:22.560 --> 00:54:27.020
Not necessarily winning but competing with native platforms.

00:54:28.460 --> 00:54:30.980
And it's a change in perspective, right?

00:54:30.980 --> 00:54:37.600
So if you can realize, I actually like the fact that the web can't do this, I should consider that a bug in the web.

00:54:37.600 --> 00:54:41.600
That's, there's one thing to say that another thing to put it into practice, right?

00:54:41.600 --> 00:54:46.860
If you come into bugzilla.mizilla.org and you're like, bug, I can't run Python on the web.

00:54:46.860 --> 00:54:50.600
Like we may not close it as invalid straight away.

00:54:50.600 --> 00:54:55.580
But it's probably, you know, it would be Intel projects like this.

00:54:55.580 --> 00:54:57.880
A big chunk of work.

00:54:57.880 --> 00:54:59.360
I don't know.

00:54:59.700 --> 00:55:01.880
I encourage people to expect more from the web.

00:55:01.880 --> 00:55:05.880
It's actually getting more and more powerful as an application platform.

00:55:05.880 --> 00:55:17.700
And if it's something that you feel like you should be able to do but can't quite make it work on the web, like find someone at Mozilla or in the Google Chrome team or like people who will take that really seriously.

00:55:18.540 --> 00:55:24.120
There are a lot of people working in the web who want it to be just every bit as powerful as a native platform.

00:55:24.120 --> 00:55:27.060
So don't just assume that it can't.

00:55:27.060 --> 00:55:29.160
Yeah, I totally agree.

00:55:29.160 --> 00:55:33.900
That's, you know, that whole way of thinking about the web is why I brought it up because I think it's really cool.

00:55:33.900 --> 00:55:36.700
All right, two more questions before I let you go, Ryan.

00:55:36.700 --> 00:55:40.280
If you're going to write some Python code, what editor do you open up?

00:55:40.280 --> 00:55:44.580
I'm very much a Vim user.

00:55:46.080 --> 00:55:50.040
Specifically Vim in an 80 by 24 terminal window.

00:55:50.040 --> 00:55:54.580
Sort of, you've got to work pretty hard to encourage me to make it any wider than that.

00:55:54.580 --> 00:56:00.600
I don't know if that's actually a productive way to get code written or if I'm just so used to it that I can't cope with anything else.

00:56:00.600 --> 00:56:02.640
But Vim all the way.

00:56:02.640 --> 00:56:03.780
Perfect.

00:56:03.780 --> 00:56:10.360
And then there's, you know, 60 plus thousand excellent packages out on PyPI.

00:56:10.360 --> 00:56:14.300
What are some that you think people should know about that maybe they don't?

00:56:14.300 --> 00:56:15.920
Interesting.

00:56:16.540 --> 00:56:24.960
So a friend of mine from the local Australian Python community, Russell Keith McGee, who's a kind of does a lot of stuff in Django.

00:56:24.960 --> 00:56:31.600
He has an interesting new project out called Toga, which is a kind of GUI library, right?

00:56:31.600 --> 00:56:33.440
He's working on native applications.

00:56:33.940 --> 00:56:42.540
But it's a GUI library with kind of all of the last however many years of experience writing Python under its belt.

00:56:43.260 --> 00:56:48.940
So you can do fun things like pip install Toga, and it works on whatever platform you happen to be on.

00:56:48.940 --> 00:56:51.240
And you can get up and running with your GUI library.

00:56:52.040 --> 00:56:57.520
It's got things like support for iOS and Android UIs and stuff like that.

00:56:57.520 --> 00:56:58.880
So I think it's pretty neat.

00:56:58.880 --> 00:57:03.660
I haven't had a lot of excuse to play around with it, but I've kind of checked it out out of interest.

00:57:04.660 --> 00:57:10.520
So if you're working in native GUI applications in Python, I think it's really worth checking out.

00:57:10.520 --> 00:57:11.260
All right.

00:57:11.260 --> 00:57:11.580
Excellent.

00:57:11.580 --> 00:57:14.020
I hadn't heard about the one, so I'll check it out myself.

00:57:15.180 --> 00:57:16.760
Ryan, this is really excellent.

00:57:16.760 --> 00:57:18.680
Congratulations on this project.

00:57:18.680 --> 00:57:27.140
I think the fact that you brought Python to the web in a way that executes faster than CPython in a lot of ways is really an accomplishment.

00:57:27.140 --> 00:57:31.960
And maybe we'll solve this download speed thing, and it'll really take off.

00:57:31.960 --> 00:57:32.400
That'd be great.

00:57:32.400 --> 00:57:33.680
We'll see how we go.

00:57:33.680 --> 00:57:36.560
It's been a lot of fun in any case, so that counts for a lot.

00:57:36.560 --> 00:57:38.320
Yeah, it sure does.

00:57:38.320 --> 00:57:39.900
Thanks for being on the show.

00:57:39.900 --> 00:57:40.540
Talk to you later.

00:57:40.540 --> 00:57:41.780
Thanks so much, Michael.

00:57:41.780 --> 00:57:43.000
Bye.

00:57:45.000 --> 00:57:47.560
This has been another episode of Talk Python to Me.

00:57:47.560 --> 00:57:51.980
Today's guest was Ryan Kelly, and this episode has been sponsored by Hired and CodeShip.

00:57:51.980 --> 00:57:53.940
Thank you guys for supporting the show.

00:57:53.940 --> 00:57:56.620
Hired wants to help you find your next big thing.

00:57:56.620 --> 00:58:03.000
Visit Hired.com slash Talk Python to Me to get five or more offers with salary and equity presented right up front,

00:58:03.000 --> 00:58:05.760
and a special listener signing bonus of $4,000.

00:58:05.760 --> 00:58:08.900
CodeShip wants you to always keep shipping.

00:58:08.900 --> 00:58:12.940
Check them out at CodeShip.com and thank them on Twitter via at CodeShip.

00:58:13.080 --> 00:58:14.800
Don't forget the discount code for listeners.

00:58:14.800 --> 00:58:15.420
It's easy.

00:58:15.420 --> 00:58:16.380
Talk Python.

00:58:16.380 --> 00:58:17.020
All caps.

00:58:17.020 --> 00:58:17.820
No spaces.

00:58:17.820 --> 00:58:24.800
You can find the links from today's show at talkpython.fm/episodes slash show slash 32.

00:58:24.800 --> 00:58:27.280
Be sure to subscribe to the show.

00:58:27.280 --> 00:58:29.740
Open your favorite podcatcher and search for Python.

00:58:29.740 --> 00:58:31.260
We should be right at the top.

00:58:31.820 --> 00:58:35.600
You can also find the iTunes and direct RSS feeds in the footer of the website.

00:58:35.600 --> 00:58:40.580
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:58:40.580 --> 00:58:43.440
You can hear the entire song on talkpython.fm.

00:58:43.440 --> 00:58:45.460
This is your host, Michael Kennedy.

00:58:45.460 --> 00:58:46.740
Thank you for listening.

00:58:46.740 --> 00:58:48.980
Smix, take us out of here.

00:58:48.980 --> 00:59:04.900
I'm first developers.

00:59:04.900 --> 00:59:06.840
I'm first developers.

00:59:06.840 --> 00:59:07.840
I'm first developers.

00:59:07.840 --> 00:59:09.840
I'm first developers.

00:59:09.840 --> 00:59:11.500
First of all, first of all, first of all, first of all.

