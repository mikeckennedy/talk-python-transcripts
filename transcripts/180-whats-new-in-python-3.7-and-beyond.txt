00:00:00 The Python core developers recently released Python 3.7 and are now busy planning what's coming in 3.8.

00:00:05 That makes right now a great time to dig into what's included in Python 3.7

00:00:09 and see what's on deck for this next great release of CPython.

00:00:13 On this episode, we have Anthony Shaw back on the podcast to tell us all about it.

00:00:18 This is Talk Python to Me, episode 180, recorded October 1st, 2018.

00:00:22 Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:00:42 This is your host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy.

00:00:46 Keep up with the show and listen to past episodes at talkpython.fm.

00:00:50 And follow the show on Twitter via at Talk Python.

00:00:53 Hey everyone, Michael here.

00:00:55 Just a couple of things to share before we get to our chat with Anthony.

00:00:58 First, you might notice I sound slightly different this week.

00:01:01 I've been experimenting with a new audio setup.

00:01:03 Your feedback on whether this is actually an improvement is welcome.

00:01:06 Just send me a mention on Twitter via at mkennedy or at Talk Python.

00:01:10 Second, I recently released a new course and this is one I've wanted to create for a long time.

00:01:15 It's called Asynchronous Techniques and Examples in Python.

00:01:18 This is the definitive course on asynchronous programming in Python.

00:01:22 It starts out right away digging into the asyncio and the magical async and await keywords.

00:01:27 We also discussed the time-tested techniques such as threading and multiprocessing.

00:01:31 But we don't stop there.

00:01:33 Once you're using threads, you need thread safety.

00:01:35 Covered.

00:01:36 Want to write some async web apps with Flask using async and await.

00:01:39 Covered.

00:01:40 We even discussed some ways to combine these techniques for when you have some mixed CPU-based work and some IO-based work.

00:01:46 We round out the course with leveraging Cython to make our threaded code go truly fast.

00:01:52 If you're interested in this course, just visit talkpython.fm/async.

00:01:56 And if you act quickly enough, you can still grab the early bird discount.

00:01:59 Now, let's talk Python present and future with Anthony Shaw.

00:02:02 Anthony, welcome back to Talk Python.

00:02:05 Hi, Michael.

00:02:06 It's great to be back.

00:02:06 Yeah, it's super to have you here.

00:02:08 It's great to have you on as a regular.

00:02:10 You're doing so many cool things.

00:02:11 Thanks.

00:02:11 Yeah.

00:02:12 So just to let people know, you were on way back in episode 155 for Practical Steps Moving

00:02:17 to Python 3 and also in 168 for 10 Security Holes in Python.

00:02:22 Those were both fun episodes.

00:02:23 But we're kind of not just upgrading to Python 3.

00:02:26 We're cutting edge at this point, right?

00:02:28 Yeah, we're going all the way up to 11.

00:02:31 This one goes to 11.

00:02:32 Awesome.

00:02:32 Well, I'm definitely looking forward to doing that.

00:02:35 But before we get into all the details of Python 3.7 and 3.8 and the speculation around there,

00:02:40 let's just talk really quickly about what you do day to day so people know where you're coming from.

00:02:45 Great.

00:02:45 Yeah, sure.

00:02:46 I work at Dimension Data.

00:02:48 It's a big IT company.

00:02:50 And I actually work in HR, which might surprise a few people.

00:02:53 As I came from an R&D background and a couple of years ago, I made a big career change.

00:02:58 So I focus on learning now.

00:03:00 Similar to you, I guess.

00:03:02 And skills development within the organization.

00:03:05 Yeah.

00:03:05 And just so people know, that's not like a team of 10, right?

00:03:08 There's more than 10 people, I think, that take some of these programs you put together and stuff.

00:03:12 Yeah.

00:03:12 So we're about 31,000 employees.

00:03:14 And I've been running a whole bunch of learning programs and stuff like that,

00:03:19 trying to teach people Python, for example.

00:03:21 About 4,000 people are learning Python that work for us across the world, which has been fantastic.

00:03:27 And running a whole bunch of other programs as well.

00:03:29 We're basically trying to make sure that the skills of the people who work at the company

00:03:33 are up to date with all the latest technologies.

00:03:35 Wow, that's really cool.

00:03:36 And you've done some good write-ups.

00:03:37 Maybe I'll even link to them in the show notes.

00:03:39 So that's your day-to-day.

00:03:41 But then when maybe you're on an airplane or you're traveling, you decide to break out some massive open source contribution, something like that?

00:03:48 Yes.

00:03:48 So I have to travel quite a lot for my job, which means I spend a lot of time on the planes,

00:03:55 really quite bored.

00:03:56 And there's only really so many Marvel movies you can watch.

00:03:59 So really, I kind of feel some time working on open source projects involved in quite a few at the moment.

00:04:06 So all of them are Python.

00:04:08 They were a range of different languages a few years ago, but now I'm 100% Python contributions only.

00:04:14 So that's been excellent.

00:04:15 And the Apache Software Foundation just got named as a PSF fellow a couple of months ago, which was awesome.

00:04:23 Yeah, congratulations on that.

00:04:24 That's really awesome.

00:04:25 Only five people per quarter get that honor.

00:04:28 And so that's a big deal.

00:04:29 That's cool.

00:04:29 Yeah, I don't really know what I did to get that.

00:04:31 But it was really great to be among the amazing list of names of people who are on the list.

00:04:36 Yeah, that's awesome.

00:04:37 Cool.

00:04:38 Well, our topic for today is Python current and beyond, right?

00:04:44 At least the time of this recording, people go back far enough in time.

00:04:47 Maybe they'll hit 3.7 or something in the past.

00:04:49 But we're going to start by talking about what is cool in Python 3.7 people should pay attention to, they should learn about.

00:04:56 And then we're going to talk about what's coming in the next version of Python 3.8.

00:05:00 So let's start with Python 3.7.

00:05:02 Like, is it a big change?

00:05:03 What do you think?

00:05:04 I guess you kind of have to bring in the whole history of, well, not the whole history of Python 3.

00:05:09 But you have to kind of take a bigger lens to this because Python 3 has been out for 11 years now.

00:05:15 Is it 10 years, 11 years?

00:05:17 Since 2008, I believe.

00:05:19 It was just 3,000 days, like a year ago or something like that.

00:05:23 So yeah, it's been about 10 years.

00:05:27 But no offense to the developers who worked on it.

00:05:30 But the first few releases weren't really production ready.

00:05:33 So 3.0 to 3.3 were really where they introduced a lot of the major changes in Python 3.

00:05:40 And there were a lot of stability issues.

00:05:42 And there were memory leaks and stuff like that that needed to be fixed.

00:05:46 Also performance, right?

00:05:47 Like a lot of people said, well, I need to do this thing.

00:05:49 And this thing is like 50% slower in Python 3.

00:05:52 So I'm not doing it.

00:05:53 Definitely.

00:05:53 There's some major changes in Python 3 which made things significantly slower in some of the earlier releases.

00:06:00 But really, the focus was, let's not just spend 10 years and then ta-da, we've come out with something that's production ready.

00:06:07 They wanted to get something out there and get the feedback earlier on.

00:06:10 So even though Python 3 has been out for a decade, I guess the stable releases have only been out for the last four years, five years now.

00:06:18 So 3.4 was pretty stable.

00:06:21 But 3.5, definitely, that's where you sort of get picked up by some of the major Linux distributions.

00:06:26 For example, it starts to get packaged with operating systems and stuff like that.

00:06:30 Yeah, that's a great point because I feel like 3.5 is really where it was clearly the right choice.

00:06:36 Like 3.4, there was a debate at that time.

00:06:38 It was like, well, maybe, maybe not.

00:06:39 At 3.5, it was like, what are you talking about?

00:06:41 Come on, let's go.

00:06:42 Yeah, exactly.

00:06:43 And then 3.6 comes out.

00:06:44 So 3.5 included the async await, a lot more functions with asynchronous programming.

00:06:51 And also 3.6 came out with more async await features, like the generators, for example, async with statements.

00:07:01 So context managers, basically.

00:07:03 And the f strings came out in 3.6, which is yet another way of formatting strings in Python, which is pretty cool.

00:07:09 Because I don't know what, five wasn't enough or I don't know if they were.

00:07:12 And once you get to use it, actually, it's definitely my favorite way to format strings now.

00:07:17 I'm with you.

00:07:18 You know, the problem I run into with f strings is I'm like halfway through a string and I decide, oh, yeah, now I want to put this variable here.

00:07:25 I'm going to go back to the beginning and put the f and then go back and do it.

00:07:28 And, you know, I don't know.

00:07:31 That's something I just got to train myself to put the f at the front more often.

00:07:34 Yeah, so 3.7 came out.

00:07:36 And, yeah, I guess really they're an opportunity now where they can start adding some good new features.

00:07:41 For people, it's not just bug fixes and performance improvements.

00:07:44 So, yeah, it's been a pretty significant change.

00:07:47 Yeah, that's right.

00:07:48 Because Python 3 is really either as close to, you know, same as Python 2 or faster, right?

00:07:54 There's a lot of performance improvements where the argument used to be, well, I can't switch to Python 3 because it's too slow.

00:08:00 Now it's, well, if I don't, I'm going to be behind, right?

00:08:03 Yeah.

00:08:04 So 3.7 was the first release of 3 that basically across all the benchmarks was quicker than Python 2.7.

00:08:11 With one exception, which is the startup time.

00:08:14 But that's still been an ongoing issue.

00:08:18 Yeah, and it really depends on what kind of apps you're building, whether that matters.

00:08:21 If you're building, like, a background thing that runs in a queue or a web app, like, who cares about startup time?

00:08:26 If you're building a little command line app, that might matter, right?

00:08:29 Yeah.

00:08:29 But it's still milliseconds.

00:08:30 It's not.

00:08:33 It's not .NET or something, right?

00:08:35 Yeah.

00:08:35 Not WPF.

00:08:36 I just want to, like, while we're on this little micro subject of Python 2 to 3, I just want to put it out there one more time.

00:08:42 Let's all call Python 2 Legacy Python.

00:08:45 And I think that's going to start to make a little dent with the managers.

00:08:48 Yeah, we're still using the Legacy Python.

00:08:50 Can we stop doing that?

00:08:51 Yeah, it came out in June, which is winter for us.

00:08:54 So I'm on the other side of the world.

00:08:56 Yeah.

00:08:56 So, yeah, it came out in June this year, so 2018.

00:08:59 The first sort of beta versions came out earlier in the year, sort of February time.

00:09:03 And there's a couple of alphas out very early on in the new year, this 2018.

00:09:09 So, yeah, it's been out for, what are we, six months now, nearly.

00:09:12 So that's, yeah, it's kind of had the chance to pick up speed.

00:09:15 Obviously, it's not been included with any of the major distributions yet.

00:09:20 So you have to go out of your way to download and install or upgrade to Python 3.7.

00:09:25 So I'd say it's not as widely used as 3.6 or 3.5 yet.

00:09:29 But it's definitely a major step forward.

00:09:31 Yeah, it definitely is.

00:09:32 And, you know, if I log into my Ubuntu machines, it's Python 3.6.6, I think, which is already

00:09:38 really awesome, right?

00:09:39 That's way better than, too.

00:09:40 Like, that ships with the operating system.

00:09:42 So that's really cool.

00:09:42 But 3.7 has a bunch of great features.

00:09:45 Now, the reason that I thought, hey, I should have Anthony on the show is because you wrote

00:09:50 a pretty sweet course on specifically what's new in Python 3.7.

00:09:56 And it's really quite consumable.

00:09:58 It's like an hour, right?

00:09:59 Do you want to just tell us quickly about your course?

00:10:01 And we'll get into the details of the stuff.

00:10:02 Yeah, sure.

00:10:03 So the course is on Pluralsight.

00:10:04 And it's called What's New in Python 3.7.

00:10:08 And basically, I go through all of the new features and functions and show you how to

00:10:13 use them, show you any gotchas and stuff like that.

00:10:15 It's only about an hour.

00:10:16 So it's not going to take much of your time to watch.

00:10:19 But yeah, it's been fun to put it together because, you know, with each alpha and beta

00:10:25 release, I was running all the upgrades or pretty much just running on a copy of the master

00:10:30 branch on CPython development for a few months.

00:10:34 Now that it's on GitHub, right?

00:10:35 Yeah, it's finally on GitHub.

00:10:36 Yeah, yeah.

00:10:37 So it's good to kind of keep on the bleeding edge and also to read all the peps and get

00:10:42 all the background and details and stuff.

00:10:44 So I put the course together to condense all of that information down into a way that's

00:10:49 a bit easier for people to just watch, get a gist of and get going with all the cool new

00:10:54 stuff.

00:10:54 Yeah, sweet.

00:10:55 So we'll link to that in the show notes as well.

00:10:57 I guess it's worth pointing out, like this came out in June and Python right now is on

00:11:03 an 18-month shipping schedule.

00:11:07 not next June, but next Christmas, December or something like that.

00:11:11 It should be Python 3.8.

00:11:13 Right.

00:11:13 So that's the current schedule anyway.

00:11:15 Yeah.

00:11:15 So about in around August, maybe September, there is actually a Python 3.8 release schedule

00:11:21 already.

00:11:22 I think in about September 2019, we're going to start to see some beta releases of 3.8.

00:11:28 You can actually test some of the new features already if you go and download from the source.

00:11:33 If you live at the tip of the master branch.

00:11:36 Yeah, exactly.

00:11:38 There was a Python meetup in London last month.

00:11:42 And I gave a quick lightning talk showing some new 3.8 features.

00:11:45 And it basically segfaulted halfway through the demo.

00:11:49 Don't do this in production, Jess.

00:11:52 Don't run it in production.

00:11:53 Maybe hold off a little bit.

00:11:54 It's not even alpha ready yet.

00:11:55 It's very, very, very early.

00:11:57 Yeah, that's pretty cool though.

00:11:58 There's some really great stuff in there.

00:12:00 But let's start with 3.7.

00:12:01 We'll talk about 3.8 in a little bit.

00:12:02 So I guess probably the big star of the show for 3.7 is data classes, right?

00:12:08 That's the thing that is totally new and pretty obvious that most everyone could use, right?

00:12:14 Yeah, so Python has always come batteries included, which is in the form of the standard library.

00:12:19 And in the standard library, there's a whole load of things you can do.

00:12:23 You can talk to HTTP endpoints.

00:12:26 You can work with the file system.

00:12:28 You can even manipulate audio files, like all from the standard library.

00:12:33 There's all this great functionality built in.

00:12:35 And really, there's been a bit of a gap in terms of working with data structures, like APIs, for example,

00:12:43 or working with document databases.

00:12:45 The gap's been filled by a couple of third-party packages.

00:12:50 Django, for example, has its kind of built-in ORM, which helps you basically create a class called a Django model.

00:12:58 And you can have attributes on the class.

00:13:01 And then when you save that to a database, it automatically creates all the fields and stuff for you.

00:13:06 So Django is not the only one to do that.

00:13:08 There's lots of other ways of doing it.

00:13:09 There's also packages like attrs, A-T-T-R-S.

00:13:13 which is great, which does a very similar thing.

00:13:17 But the concept is that you have a class in Python.

00:13:20 You put some fields on it.

00:13:23 And basically, you can use that to represent data that's in some other system.

00:13:28 So that could be an API you're talking to or a database or it could be a memory store, for example.

00:13:34 So it's a whole bunch of border plate code you have to create.

00:13:37 If you do this from hand, you have to create all the Dunder methods that you want to use.

00:13:42 So Dunder init, for example, the Dunder EQ, Dunder Reper, Dunder STR, etc.

00:13:48 Right.

00:13:48 So it seems like you're kind of done when you've done the Dunder init and you put your fields in there.

00:13:53 But if you're going to, say, try to hash those things or compare them or sort them or you want them read only,

00:14:00 all of those things require a pretty good understanding of the Python data model and the magic methods and all that kind of stuff.

00:14:07 And data classes are just, you know, frozen equals true type thing.

00:14:11 Yeah.

00:14:11 So there's some great features in data classes.

00:14:13 So really what you have to do is you create a new class and that implements a data class.

00:14:20 And within that, then you basically have attributes on the class.

00:14:25 So these are class level attributes.

00:14:27 You have to give them type annotations.

00:14:30 Otherwise, they get ignored.

00:14:31 If you're not aware what type annotations are, it's a colon after the variable name.

00:14:36 And then the type you want to use.

00:14:38 But there's another change in type annotations in 3.7 as well, which we'll come back to maybe later.

00:14:45 And basically, you put the fields on there and then you're done.

00:14:48 And then you can basically call that class.

00:14:51 You can call the initializer or the constructor on the class and pass it all the fields that you've assigned.

00:14:56 And then there's a whole bunch of really cool features you can use.

00:15:00 For example, you can set default values.

00:15:02 You can have default factory values.

00:15:04 You can have it implements done the EQ for you, done the rep, done the STR.

00:15:09 So basically, it just gets rid of a lot of boilerplate of having a class which basically just stores data and represents some of that kind of data structure.

00:15:17 Yeah, it's really sweet.

00:15:18 And that initializer, it writes that for you, right?

00:15:22 Yeah, it writes everything for you.

00:15:23 So all you need to do is declare the class and sign the fields and then you're done.

00:15:28 That's cool.

00:15:29 Can you inherit them?

00:15:30 Can you create like a hierarchy of data classes?

00:15:31 You can.

00:15:34 I'm not saying you should.

00:15:35 I'm not saying you should.

00:15:35 I'm just wondering if you can.

00:15:36 You definitely can.

00:15:37 And there's a lot of reasons why you want to do that.

00:15:40 Now, if you want to inherit from a base class, it's important to note that within data classes, you can have fields with default values and fields with basically require a value.

00:15:53 So if you mix those things together, so if you have a base class that has both non-default and default fields and then you have a inherited class, you can't mix them in the inherited class.

00:16:05 This is probably one of the bigger limitations of the data classes package is to do with the way that it builds the done the init method.

00:16:12 But it's, yeah, that's pretty, I guess, a bit of an edge case, but it's something to watch out for.

00:16:17 Yeah, that's cool.

00:16:18 And so if I want to have some kind of check in my initializer, like this number has to be between 0 and 10, but it's written that for me, like where does that happen?

00:16:29 Yeah, so you can do it in a couple of places.

00:16:31 One would be a post init method.

00:16:33 So after the auto-generated dunder init has been called, you can have your own method which does extra stuff at the end.

00:16:41 So that could be a value check, for example.

00:16:44 It doesn't do type checking.

00:16:46 So even though it uses type annotations, I guess the Pythonic way of doing it is that they're just a friendly reminder of the type and they're not guarded in any way.

00:16:56 They're meant for linting and like build time checks, not run time checks, right?

00:17:01 Yeah, exactly.

00:17:02 Another great feature is that you can use, basically you can create immutable types.

00:17:07 So by default, they're mutable, which means you can change the values.

00:17:11 You can also create immutable types by setting frozen equals true when you basically instantiate them.

00:17:18 The frozen basically means that they're immutable, you can't change their values.

00:17:24 And also they'll implement a dunder hash method as well.

00:17:28 So they're hashable.

00:17:28 So you can use them in things like sets.

00:17:31 Also, you can use them as dictionary keys, which is pretty cool.

00:17:34 Yeah, that's really cool because you shouldn't be able to put a thing into the dictionary and then change the value of it and then make it no longer have the same key.

00:17:41 That would definitely drive you insane, which is what it effectively means if the hash value changes, right?

00:17:48 Yeah, so it's a really cool way of creating more complex dictionary keys, I guess.

00:17:53 And also moving away from just representing everything in dictionaries all the time.

00:17:59 I think when you're working with APIs and stuff like that and you're passing data around, it's convenient to just stick with dictionaries because you don't have to worry about what field you have and what types they are, etc.

00:18:11 But it's definitely nicer and it's also a lot more testable to introduce a bit more concreteness, I guess, to the types.

00:18:19 Yeah, it's cool.

00:18:19 And data classes kind of makes that less effort to do so correctly.

00:18:23 Yeah, really easy.

00:18:24 This portion of Talk By The Dermade is brought to you by Tidelift.

00:18:30 Open source software is everywhere.

00:18:32 How can we as a community ensure that the open source software we rely upon continues to get even more awesome and more dependable?

00:18:40 Tidelift believes the solution is hiding in plain sight.

00:18:43 Pay the maintainers.

00:18:44 They're dedicated to creating an effective way to do just that.

00:18:48 And today, they're excited to share that they've reached over $1 million in committed payments for maintainers available via the Tidelift platform.

00:18:56 And yes, that includes Python maintainers.

00:18:58 Income for a project grows based on usage, not the number of hours spent on the project.

00:19:03 So you can build significant income around your open source projects.

00:19:07 Tidelift is offering a guaranteed minimum $10,000 payout over the next 24 months to select projects in the Python ecosystem.

00:19:15 If you maintain a Python project, visit talkpython.fm/Tidelift to find out if your project is included.

00:19:21 That's talkpython.fm/Tidelift.

00:19:26 The next one doesn't actually sound very exciting to me, but I'm sure it's super important, is that the locales and UTF-8 got a little bit of a change, right?

00:19:34 What's the story around that?

00:19:35 How much do we need to worry about it?

00:19:37 I think we won't spend too much time on this because it's really confusing.

00:19:42 Any form of encoding is confusing.

00:19:44 It's super confusing.

00:19:45 Yeah.

00:19:45 So a local means it's, I guess, the settings on your operating system, which describe what country you're from, for example, and the way you like things to be represented.

00:19:56 So, you know, in...

00:19:57 Like, digit grouping or the order of month, date, year when you print out a date, things like that?

00:20:02 Yeah.

00:20:03 So, like, in mainland Europe, most countries would represent the number 1,000 with 1.000, whereas in the UK and the US, there would be 1,000.

00:20:14 So that's one change, I guess, and that would be in the locale.

00:20:18 Other ones would be the encoding type, which is where UTF-8 comes in, the keyboard mapping, and there's a whole bunch of other things.

00:20:25 So, basically, there's a default, which is the sort of NCC locale, which was default like 20 years ago, maybe.

00:20:35 But, you know, since computing has moved on a bit and we've had to support more countries than just the US.

00:20:41 So I would like to think that this is like the world going, let's just, let's accept everybody and let's support all of those languages.

00:20:48 But how much of this has to do with emojis?

00:20:50 It definitely helps with emojis.

00:20:55 And hopefully that's not the main...

00:20:56 My thumbs up is a square, come on.

00:20:58 Hopefully that's not the main driver.

00:21:00 But yeah, there's quite a few reasons.

00:21:03 Now, I guess Python 2 doesn't really, or say legacy Python, this problem is a bit more invisible because they use byte strings by default, whereas in Python 3, we use unicode strings by default.

00:21:17 So I guess the thing is, if you're reading from a shell pipe, for example, so you want to pipe the output of one command into your Python script, then Python will look at the locale.

00:21:30 So look at the operating system to see, you know, what settings you've got locally.

00:21:35 Now, the problem is that not everyone configures their operating system correctly.

00:21:40 There's also other scenarios like people creating Docker containers and not bothering to set the locale.

00:21:47 Exactly.

00:21:48 Like all the cloud stuff, right?

00:21:49 Yeah.

00:21:50 All the cloud stuff.

00:21:51 You just fire it up and you're like, oh, look, it works.

00:21:53 But I passed in my data file, which was in one locale, and I tried to read it in another, and there it went.

00:21:59 Exactly.

00:21:59 So if you just had that set to the, I guess, the most basic one, which would be the NCC, then that would not be with UTF-8.

00:22:07 So Unicode would not work by default.

00:22:10 So basically, in Python 3.7, they've made more assumptions about people misconfiguring their operating system to make it more friendly for Unicode.

00:22:21 Nice.

00:22:22 So the next one that you have on your list, I think, is really interesting.

00:22:26 And it's interesting because I'm like, oh, this is super.

00:22:30 This is not like, why would I ever use it?

00:22:32 I would never use this.

00:22:32 What is this about?

00:22:33 And then at the end, I'm like, oh, no, this is really useful.

00:22:36 And I feel like I really learned something.

00:22:37 And I always love it when that happens.

00:22:39 So the next one is breakpoint, right?

00:22:41 We used to import PDB, and we'd do a set trace thing.

00:22:44 Or we would fire up PyCharm or Visual Studio Code or something and just click in the side.

00:22:49 So why does Python need a breakpoint?

00:22:51 Is it just like an alias for PDB set trace?

00:22:55 Yes and no.

00:22:56 So Python 3.7 introduces a new built-in function called breakpoint.

00:23:02 So if you just write breakpoint, open, close, parentheses, anywhere in your code, when that line executes, it will jump into a debugger.

00:23:11 By default, that will be the one that comes in the standard library called PDB.

00:23:16 So anyone who's done debugging in Python today, I guess, would have learned that to jump into a debugger, you basically type import PDB semicolon.

00:23:28 Wait, wait, wait.

00:23:29 What did you say?

00:23:29 Semi-colon.

00:23:32 Oh my gosh.

00:23:33 All right.

00:23:33 Yeah.

00:23:34 So you can put it on one line and comment it out really easily, right?

00:23:36 Yeah.

00:23:37 So basically, to insert a breakpoint in Python requires two separate statements.

00:23:43 And having two lines of code to do a breakpoint kind of is confusing because then you've basically just changed your code in the way that you didn't really need to.

00:23:52 It's also, I guess, not super intuitive for people coming from other languages, people who are just used to working in an IDE and clicking on the red circle on the left-hand side.

00:24:02 You know, how do you do that in Python?

00:24:03 How do you step into a breakpoint and work in a debugging console within Python?

00:24:09 So what they've introduced is this new built-in function.

00:24:13 By default, it will just call import PDB, PDB.setTrace.

00:24:17 So it behaves the same way that you would expect.

00:24:21 But you don't have to write a semicolon.

00:24:22 That's better.

00:24:23 Yeah, exactly.

00:24:24 And it doesn't cause the linter to throw up its arms in anger that you've dared to include a semicolon in your code.

00:24:31 And so if that's all it was, I don't think actually it has that much value.

00:24:35 I'm not against having the language, but it's not that huge of a thing.

00:24:38 But then what if I don't want to use PDB?

00:24:41 Like, I don't like it.

00:24:42 There's other, even in the terminal, there's other nice sort of semi-graphical debuggers that are pretty cool, right?

00:24:48 Yeah, so what it actually does is it will eventually call breakpoint hook, which is a global variable within the sys module.

00:24:57 And like I said, by default, that's set to PDB.setTrace.

00:25:02 But you can change it to something else.

00:25:04 So there are loads of other debuggers of Python, which are a lot more friendly to use.

00:25:09 Also, there's browser-based ones like WebPDB, for example.

00:25:13 So WebPDB, when you hit that instead of as your breakpoint, it'll actually pause the code and it'll actually start up a little web server.

00:25:22 And you can open up your browser and you can navigate to it.

00:25:26 And it's just a lot easier to see and explore through the local scope and the global scope in a browser with a whole tree and everything than it is to do it in a little text console.

00:25:35 Yeah, that's awesome.

00:25:36 And basically, the breakpoint lets you customize what debugger gets called when you type breakpoint open close parentheses.

00:25:43 Yeah, so you can do it either in code.

00:25:44 So in Python, you can change the value of sys.breakpoint hook.

00:25:49 Or alternatively, you can set it using an environment variable, which is also pretty cool.

00:25:54 So if, for example, if you wanted to have breakpoints in a certain part of your code because you wanted to debug something that was running across multiple machines,

00:26:06 and one of the debuggers would be a local one and one of them might be a remote one, then you could have an environment variable set to basically change which debugger you want to use whenever breakpoint gets called.

00:26:18 Yeah, that's pretty awesome.

00:26:19 So even remote debugging.

00:26:20 I love it.

00:26:21 Yeah, it's great.

00:26:21 I think it's a great feature.

00:26:22 Yeah.

00:26:22 The next one is pretty cool.

00:26:24 So time seems pretty accurate in Python already.

00:26:29 So even like if I subtract two date times and I get a time delta, there's a lot of accuracy to like dt.total seconds or whatever it is.

00:26:37 But in Python 3.7, there's more seconds or more parts of seconds.

00:26:42 Yeah, this one really confused me when I was doing the research.

00:26:44 I think anyone who's worked with time accuracy, this would totally make sense.

00:26:49 But if you have put it in the I don't really care, I just want the time and it sounds pretty accurate, camp, which is where I was definitely from.

00:26:59 Then when the announcement came that they were introducing these nanosecond resolution time functions, it's like, okay, great.

00:27:06 Why do I need that much accuracy in my application?

00:27:11 So basically what they've changed in 3.7 is they've introduced some new functions into the time standard library module.

00:27:20 And they have the append xdunda underscore ns for nanoseconds.

00:27:27 And basically you've got a lot more accurate representation of time.

00:27:31 Right.

00:27:31 So it's not like time now returns better numbers.

00:27:35 You have to call time underscore ns, right?

00:27:38 Yeah.

00:27:38 So it's a separate function.

00:27:40 The different functions.

00:27:41 And for whatever reason, the old functions that would give you the time epoch.

00:27:46 So the time epoch was the 1st of January 1970.

00:27:50 Apparently nothing happened before then.

00:27:53 But that's basically the beginning of time.

00:27:55 In Python, it'll give you a floating point number back.

00:28:00 And anyone who's worked with floating points before will know there can be all sorts of inaccuracies.

00:28:05 So the number of seconds since the 1st of January 1970 is the major number.

00:28:11 And then the actual floating point itself is the parts after that.

00:28:16 So it's, you know, the milliseconds, for example.

00:28:18 Now, the problem is that you get all sorts of rounding issues.

00:28:22 And also they're not particularly accurate.

00:28:24 So it's not necessarily in milliseconds.

00:28:27 It's almost like the closest number that it could find depending on the operating system and the CPU that you're using.

00:28:33 So there can be these gaps and issues with accuracy in Python.

00:28:38 Anyone who's used Python before to try and measure time very accurately will probably know about these limitations.

00:28:44 So in 3.7, they've introduced a new nanosecond function, which is awesome.

00:28:48 And it will give you that in basically a long, long integer, which is the Python integer.

00:28:53 Nice. Well, I know that in that there's a time NS.

00:28:56 What else are there other underscore NS functions I can use?

00:28:59 It says get time NS.

00:29:01 There's set time NS, which you can only use in certain situations.

00:29:04 And there was a couple of others as well.

00:29:06 But those were the major ones.

00:29:07 Yeah, nice.

00:29:08 For this next one, what do you think, before we get into the details of what's new, let's just talk about type annotations.

00:29:13 You hinted at this in the data classes bit because it's very interesting that it's even required, although not checked at runtime.

00:29:19 How do you feel about type annotations?

00:29:21 So I haven't really used them very much up until 3.7 for exactly the reason that we'll talk about this next feature, actually.

00:29:30 So in 3.6, they're kind of a bit clunky to use.

00:29:35 If you want to represent anything remotely complicated, other than just a string or an int, you might have extra code you have to add to your Python modules.

00:29:43 I think it's just cumbersome.

00:29:45 And I haven't got a huge amount of value out of it so far.

00:29:48 So I think...

00:29:48 Right.

00:29:49 If you want to say a list, you'd have to say import list from typing like capital L list, not lowercase l list, things like that, right?

00:29:56 Yeah, because a lot of my code that I would write would return a tuple, for example, and the first entry would be an integer and the second one would be a dictionary.

00:30:06 And in the dictionary, then there'd be a certain structure.

00:30:09 And by the time you've had to describe all of that, it's just such a pain.

00:30:13 And it adds so much code to your...

00:30:15 And the type annotations themselves, the way to represent complex types is not particularly intuitive.

00:30:22 And if you're not familiar with type annotations either, then it's quite a bit of a blocker.

00:30:27 Yeah.

00:30:27 You know, my take on them is I really like them, but I don't think they belong everywhere.

00:30:32 But I really love type annotations on the boundaries.

00:30:35 So if I have like a data access layer and I've got some functions you call, like those functions you call, I love to put like annotations on, well, you get a list of these things back.

00:30:44 Or this one could be an optional user because they might not exist in the database.

00:30:48 And then that kind of flows enough through the editors for me that like everything else kind of picks it up.

00:30:53 But I don't turn it into like C# and put, you know, types on everything that exists, right?

00:30:58 Yeah.

00:30:59 One of the other big limitations is that if you're, you know, the type is actually a class that you've declared somewhere, then you have to import that in order to add it as an annotation.

00:31:11 Yes.

00:31:12 Yeah.

00:31:12 And that's partly what drove the changes for 3.7, right?

00:31:15 Like, so the place that made me the most crazy was it cannot be solved in the most straightforward way is that I have like, say, some kind of method on a class, like a class method on a class that returns an instance of that class.

00:31:29 I cannot say in the type system, it returns that class because it's not yet defined.

00:31:35 I mean, you could use like the string sort of cheating style, but you can't, you have to go realize there's this other way to like talk about it when it's not important and it's not as well as enforced and so on.

00:31:45 Yeah.

00:31:46 So the example I use in the course is, is sort of fictional, but you know, you could have a theater class, for example, and then in the theater, it has a number of seats and you have a seat class, which is in a separate file.

00:31:57 So in a separate submodule, and then you've got an attribute on the seat, which says which theater it belongs to, or you've got an attribute in the theater, which says how many seats there are.

00:32:07 And you can reference the seats.

00:32:08 Now, in order to do that as a type annotation, you need to import either one from each other, which creates a circular import, which Python is pretty good at handling.

00:32:16 It's not, it's not as bad as it was in C, but what it's kind of led to is kind of similar to what you see in Java and C#, which is the first, you know, 30 lines of every file is just import statements.

00:32:30 Which is a bit of a limitation really, because you're not using them for anything other than to add a type hint to the method in terms of what it returns or what it expects as parameters.

00:32:42 You're not doing anything with it.

00:32:43 And the imports obviously, you know, add quite a bit of time as well.

00:32:47 It slows the application down.

00:32:49 It's not a compile time thing.

00:32:51 It's a runtime thing.

00:32:52 So when you import all those things to just declare, here is the return type, that actually slows down the startup of that program, because now it's doing more stuff just to get to that one function.

00:33:04 Yeah.

00:33:04 Yeah, exactly.

00:33:05 All right.

00:33:06 So what's 3.7 add for us?

00:33:08 Like, how does it change this or make it better?

00:33:09 So what they've introduced is delayed evaluation type annotations, which is a very fancy way of saying that.

00:33:19 Basically, what happens is when your code gets parsed.

00:33:24 So in Python, to create the, I guess, the executable code, the Python files, the text files, or the code that you've given it needs to be parsed first, and then it needs to be compiled.

00:33:36 So at the parser stage, if you've imported from Dunder future annotations, and it will enable these delayed evaluations, then what it does is it goes and looks at all your type hints.

00:33:48 And if you'd imagine, let's say you've got a method, and you want to set the return type.

00:33:54 So you do a colon, and then the type hint, the type that you want to return.

00:33:59 Basically, what the parser will do is equivalent to just putting double quotes either side of that name.

00:34:05 So it's basically a string literal as a type hint instead of the actual reference to the type.

00:34:12 Right, which already works in the previous version.

00:34:14 Like, you can do that, sort of put it in a quote, and that actually works for, say, like, the class self-reference thing I talked about.

00:34:21 But then you don't get, like, say, refactoring help and things like that, right?

00:34:24 Yeah, so it causes issues with IDEs and other things like that.

00:34:28 So basically what this does is it supports a lot of stuff you get in IDE.

00:34:32 So the IDE would know, or should know, how to import those and reference them.

00:34:37 But it doesn't slow down your application at runtime.

00:34:40 And it's a lot easier to use because you don't have to worry about all the imports and things like that.

00:34:45 Yeah, very interesting.

00:34:46 The IDEs and the linters, they know how to still check for those things, even though Python at execution time doesn't necessarily do the imports, right?

00:34:56 Yeah, it basically pushes the problem down the path a bit, though.

00:35:00 Okay.

00:35:00 Because if you actually want to use the type annotations to find the concrete types, then you need to call a special new function called get type hints.

00:35:12 And you need to pass it the local and global scope.

00:35:16 And when you call that function, the thing, the type hints that you, if they'd referenced a class, for example, then you would have need to imported that class by that point.

00:35:27 Otherwise, that function won't work.

00:35:29 So you still have to import stuff if you want to use the type hints.

00:35:33 But it basically assumes that most people just want to use them as general annotations.

00:35:38 They don't want to use them to actually reference concrete types.

00:35:42 Right.

00:35:42 Yeah, very interesting.

00:35:43 So while we're on this type annotations thing, there's some very interesting stuff happening around type annotations in the later versions of Python.

00:35:51 And they all seem to be about trying to make Python faster, actually.

00:35:55 I mean, obviously, it was introduced to make it more understandable and help the tooling and stuff.

00:35:59 But so Cython has recently started adopting, if you have regular Python 3 type annotations, it'll use those instead of its funky way of declaring variables.

00:36:10 So it can actually take just annotated code and compile it to see better, which is pretty cool.

00:36:16 That's awesome.

00:36:16 I didn't know that.

00:36:17 Yeah, I know.

00:36:18 I just learned it as well.

00:36:19 And do you know about mypy, which is like the type verifiers, like a linter, but like deeply for typing?

00:36:25 Yeah, it's like an introspection tool, isn't it?

00:36:28 Yeah.

00:36:29 So that's pretty interesting.

00:36:30 And there's some tools to like generate the type annotations based on like runtime stuff and various interesting things.

00:36:36 But what also is interesting is Dropbox is releasing this thing called mypyC, which is a compiler that takes annotated statically typed Python code and compiles them to C extensions.

00:36:48 Wow.

00:36:48 Okay.

00:36:49 That's really cool.

00:36:50 So these are both kind of interesting things that people are playing with.

00:36:54 So anyway, those are worth maybe looking at.

00:36:56 Yeah.

00:36:56 And the important thing with this feature is that in the pep, it says that it will be the default behavior in Python 4.

00:37:03 That's pretty awesome.

00:37:04 There's going to be a Python 4 pretty soon.

00:37:05 Well, we don't know how long, but.

00:37:08 Yeah, well, a couple of 18 month iterations.

00:37:10 There's actually talk ≈Åukasz Langa is overseeing the release for Python 3.7, 3.8, I believe.

00:37:18 Definitely for 3.8, maybe 3.8, 3.9.

00:37:21 I don't want to give me the wrong numbers.

00:37:22 Yeah, thank you.

00:37:23 And he's trying to get the release cycle down to yearly, but that's kind of on hold for a little bit.

00:37:28 Okay.

00:37:29 So maybe it'll be quicker than it otherwise would have been by, you know, six month segments.

00:37:34 All right, so we opened this section, the whole podcast a little bit by talking about performance in Python 2 and 3.

00:37:41 So 3.7 brings some interesting new performance benefits, right?

00:37:45 Yeah, so I guess calling methods or calling functions in Python definitely has an overhead or an associated cost.

00:37:53 I got to say, when I first learned Python, I was blown away at how slow a function call was compared to if I inlined it effectively.

00:38:00 Right, yeah.

00:38:01 And I think it's a big deal.

00:38:02 And this leads to people writing code in certain funky ways, copying and pasting things a bit more once they learn about this quirk of Python.

00:38:11 Especially if you're using some of the frameworks because the number of, I guess, turtles deep or the number of layers that it has to go through function scrolling functions, it can really kind of slow down the application.

00:38:21 Yeah, yeah.

00:38:22 I know in SQLAlchemy that Mike Bayer very carefully worked on the architecture to minimize the function call depth, actually, for performance reasons.

00:38:30 Like, there's a lot.

00:38:32 So in 3.7 calling functions gets somewhat faster.

00:38:35 Not quite like inline assembly fast, but faster, right?

00:38:38 Yeah.

00:38:38 So basically, they've introduced some new opcodes.

00:38:42 And there's a different implementation for calling.

00:38:45 And it's quite specific, actually.

00:38:47 It's not just functions and methods in general.

00:38:49 It has to be on a bound method, which means if you've got a class and you've got a method on the class, you've instantiated it.

00:38:57 When you call it, if that class doesn't have any keyword arguments, then it will be faster than before.

00:39:04 So like I said, it's quite specific, but that probably covers quite a lot of cases.

00:39:08 But that's a really common case, right?

00:39:10 There's a lot of times when you have some kind of object and it has a function and you want to call it.

00:39:14 Like, if objects don't have functions, why would you create them, right?

00:39:18 Just put them in a data structure or something, right?

00:39:20 So it's obviously nice that those are there.

00:39:23 And I wouldn't say the majority of functions have keyword arguments.

00:39:26 So it's a good improvement.

00:39:28 Yeah.

00:39:28 No, I think it's a good step forward.

00:39:30 So it's 10% to 15% faster.

00:39:31 And in benchmarks, there's basically a speed boost because of that knock-on effect.

00:39:37 Yeah.

00:39:37 That's really cool.

00:39:38 So maybe that might even affect like what you've pip installed, right?

00:39:42 Even if you have no classes, you might be interacting with like some turtle at layer 3 that uses classes, right?

00:39:49 Yeah.

00:39:49 So even just by moving to Python 3.7, you can actually see a speed improvement on a lot of applications.

00:39:56 I've upped 10% to 15%.

00:39:57 Yeah, that's really sweet.

00:39:58 So after going through all this, doing all this research, if somebody's on 3.6, is it worth upgrading to 3.7, you think?

00:40:05 I'd definitely be worth upgrading to 3.7.1.

00:40:09 Point anything other than 0?

00:40:11 Yeah.

00:40:12 I would never upgrade to a .0 release in a production environment.

00:40:16 But definitely, I think data classes are really cool.

00:40:19 I'd been using the Atters module for a few projects and really liked it.

00:40:23 But obviously, adding yet another dependency to your application is not always desirable.

00:40:27 So it's nice to have that in the standard library.

00:40:30 The speed improvements are always welcome.

00:40:32 I think anything that can make Python faster is great.

00:40:36 The type annotations change, I think, actually makes it a lot more appealing to me because you don't have to worry so much about the import statements and things like that if you're not actually going to use them in that way.

00:40:47 So, yeah, there's some big changes.

00:40:48 I think the one that I've actually used the most is Breakpoint.

00:40:51 Just since I've switched to 3.7, just got so used to just writing Breakpoint instead of the import PDB.

00:40:58 And also worked with the pytest team to get Breakpoint supported in pytest, which was pretty fun.

00:41:05 So I got to kind of dig into some of the details.

00:41:09 Although somebody, Anthony Sotile, the other Anthony who works on pytest, there's quite a few of us actually,

00:41:15 but he raised a pull request basically saying that he proved that my pull request basically did nothing.

00:41:21 So I was a bit disheartened.

00:41:22 Oh, dear.

00:41:25 But it has a lot of test coverage.

00:41:27 That's good.

00:41:27 I hear you with the .0 release in production.

00:41:31 Right now, what I'm doing is I'm still using 3.6, 6, whatever the latest on Ubuntu is, right?

00:41:36 I keep that up to date as it ships with there.

00:41:38 But I'm doing 3.7 in dev and just making sure that I don't use any of the features yet that are going to cause trouble when I ship it.

00:41:46 So I've definitely taken my site down by accidentally using an F string in a utility function that was never called in the web app,

00:41:54 but was actually parsed by 3.5.

00:41:57 And they wouldn't start the web app.

00:41:58 So it can sneak in there.

00:42:01 But maybe you could start testing in dev or Q&A or some sort of staging environment and then someday switch pretty soon.

00:42:09 Yeah.

00:42:09 And then someday move to 3.8.

00:42:11 Yeah.

00:42:11 You could move to 3.8.

00:42:13 Although the segfault thing you're talking about, maybe not yet, maybe wait a little bit.

00:42:17 But yeah, let's do a quick preview of what's coming in 3.8.

00:42:21 Yeah, sure.

00:42:22 So there's a couple of quick, easy ones.

00:42:24 So for example, AsyncIO on Windows gets a different event loop, a proactor event loop.

00:42:31 I actually have no idea what that is.

00:42:32 I now want to go research it and see what that is.

00:42:35 But that's pretty cool that AsyncIO has these configurable, extendable event loops like UV loop and so on.

00:42:40 There's a few simple language things like a continue statement used to be illegal in a final clause, but now it's not.

00:42:49 But then there's a few other major ones.

00:42:52 You want to maybe touch on the big ones and we can hit a few small ones after that.

00:42:56 Yeah, there's been, well, there's, I guess, for every major release of Python, there's all the proposals for new features in the form of these documents called PEPs.

00:43:06 So I've been reading, I guess, some of the proposed PEPs in detail and trying to understand what they do.

00:43:12 There's a couple that have been accepted already.

00:43:15 The big controversial one, I guess, was PEP 572, which is something called assignment expressions.

00:43:22 The easiest way to understand it is that if you just do in a REPL, X equals one, enter, and then X, enter, it will return one.

00:43:32 And assignment expressions basically introduce a new syntax, which is X colon equals one, which will return one.

00:43:39 So it basically squashes those two statements together into one.

00:43:43 All right.

00:43:43 A lot of time you might be thinking, well, I would never use that.

00:43:46 Like, what is the value of this?

00:43:48 But if you're doing, well, expressions, right?

00:43:50 If I'm doing like a list comprehension and I want to do both a test and a creation of a variable or things like that, you know,

00:43:58 like there's a few interesting use cases where it does simplify the language a bit.

00:44:02 Yeah.

00:44:03 And that syntax is in other languages.

00:44:05 So people might be used to it in other places.

00:44:07 JavaScript is an example.

00:44:09 And Perl would be another one.

00:44:12 So I guess people, some people are more familiar with using that kind of syntax.

00:44:17 And yeah, if you're doing statements, like if statements, this comprehensions while statements, for example, then yeah, you can introduce this new syntax and you can basically get the value back and then use it for other things.

00:44:30 All right.

00:44:30 Maybe like a lambda expression where you've got to squeeze it into one line, possibly.

00:44:35 I don't know.

00:44:36 Yeah.

00:44:36 Yeah.

00:44:37 It's basically because you can, yeah, you can't write return statements inside where something should be a statement itself.

00:44:44 Yeah.

00:44:45 Even with semicolons, right?

00:44:46 Even with semicolons, you can't do that now.

00:44:49 Right.

00:44:50 So this was controversial partly because let's say close to half of the community really you thought like this just does not need to be added to the language.

00:45:01 We don't do this.

00:45:01 And there was like maybe a minority.

00:45:03 I'm not sure.

00:45:04 But another part of the community that really did want it.

00:45:07 And so there was actually quite a bit of a disagreement about whether it should have been accepted.

00:45:12 And the fallout of that is sort of the straw that caused Gita Van Rossum to step down as BDFL.

00:45:20 Yeah.

00:45:21 I think that some of the comments got a bit nasty, to be honest, and some of the pushback.

00:45:25 But I don't know.

00:45:27 I've seen places where it could be used.

00:45:29 And I think, yeah, that could be useful.

00:45:30 But I don't think I'd use it every day.

00:45:32 Like this is a once every now and again, you'd use it kind of thing.

00:45:36 Yeah.

00:45:36 That's kind of how I feel about it.

00:45:37 Like it's not a huge deal, but I'm not like looking forward to doing amazing stuff with it yet.

00:45:42 Yeah.

00:45:42 Like an async context manager.

00:45:44 Like, you know, that's kind of cool.

00:45:46 But it's not something you do use in everyday code.

00:45:48 Yeah, for sure.

00:45:48 So the one that's coming that I'm really positive about is the none aware or null aware operators.

00:45:56 Tell us about that.

00:45:56 Yeah.

00:45:57 So this one has been proposed, but not accepted.

00:45:59 I think it's in draft state at the moment.

00:46:02 So it's basically, again, a new syntax.

00:46:05 So anyone who works with Python a lot will know the sort of famous error that X is not an attribute of none type or something along those lines.

00:46:14 So like, I think it's one of the most common exceptions is that attribute error.

00:46:19 Something is not an attribute of none type.

00:46:22 Yeah.

00:46:22 So it's basically like it's the equivalent of a null pointer or a null reference exception in Java or C# or C++.

00:46:31 It's the Python equivalent of that.

00:46:34 So none, I guess, is our special type to represent nothing instead of null.

00:46:39 But it doesn't technically have a value similar to null.

00:46:43 It's actually a special type in itself, which means that in this PEP and their proposal, what they're proposing is basically a special set of syntax based around the question mark to allow you to basically follow branches depending on whether something is null or not.

00:47:00 So, for example, if you had a data class, if you had a data class with some fields and one of the values of the fields was null, you could reference it.

00:47:10 And then if that field itself, you wanted to call a method on it.

00:47:14 Like, I don't know, let's assume it was a string.

00:47:16 You wanted to run the upper on it.

00:47:18 If it was none, then you'd get upper as not a property of none type.

00:47:23 But basically, instead, you could do question mark dot as the method accessor.

00:47:28 Right.

00:47:29 Right.

00:47:29 Instead of object dot like field dot upper, you'd say object dot field question mark dot question mark upper.

00:47:38 Yes.

00:47:38 It also introduces something called a ternary operator, which is a double question mark.

00:47:44 But that already exists in Python, but it's pretty long form.

00:47:49 You have to say something equals something if the thing is that else, not this.

00:47:55 Yeah.

00:47:56 And it is a little bit longer.

00:47:57 The sort of double question mark null class none class operator thing does not excite me very much.

00:48:02 But this fluent style of these chaining function calls that at any step may be none is super exciting to me because you might have to check.

00:48:12 First, is the original object none?

00:48:14 OK.

00:48:14 Then if that's not the case, now is its name, you know, maybe it contains like a rich object.

00:48:20 You know, is that like an address?

00:48:21 Like, is the address none?

00:48:23 OK.

00:48:23 The address is not none.

00:48:24 So is the street not none?

00:48:26 OK, now we can call to upper on it.

00:48:28 That's like one line, right?

00:48:29 Object question mark dot address question mark dot street question mark dot upper.

00:48:35 And boom, you get either none or you get an uppercase street name.

00:48:38 I love it.

00:48:38 Yeah.

00:48:38 So if anyone works with like highly nested types, I guess, then and you have to write all these.

00:48:44 If that's not none, do this.

00:48:45 If that's not none, do this.

00:48:46 Then, yeah, this is super helpful.

00:48:48 Could be if it gets accepted.

00:48:51 Yeah, it could be.

00:48:52 It's one possible branch of the future.

00:48:55 This will be very helpful.

00:48:55 Yeah, I just one thing that I dislike a lot in my code is like sort of seesaw nested jaggedy code.

00:49:03 And this can like turn that into just like a one liner, which I think is great.

00:49:06 You also have called out runtime audit hooks.

00:49:09 What might that be useful for?

00:49:11 This is probably a security feature mainly.

00:49:14 But again, it's a proposal.

00:49:15 It's not been accepted yet.

00:49:17 But the idea is that for any built in functions.

00:49:20 Or as things in the sys module or some of the low level functions within Python standard library,

00:49:27 whenever they got called by either your code or somebody else's code, you've got the option to set like a audit hook.

00:49:36 So you might write a special application like a profiler, for example, if you're writing a profiler and you want to see every time somebody tries to open a network socket or calls a URL or something.

00:49:49 Or if you wanted to develop security application that checked anyone who is, you know, opening file handles in the operating system or...

00:49:57 Right.

00:49:57 You could build a really cool package that you can just import into your app at the beginning.

00:50:02 And it says, these operations are allowed.

00:50:04 These are not like no network access, no file access.

00:50:07 And with this, maybe you could just stop that globally in the runtime, right?

00:50:11 Yeah.

00:50:12 So kind of similar to what you can do with SE Linux, if anyone's familiar with SE Linux.

00:50:17 You can kind of lock down the kernel effectively for certain users and certain method calls can't be run.

00:50:23 So this would be similar.

00:50:25 So you could basically have a Python interpreter.

00:50:28 And when certain things are done inside Python, then your method gets called as part of an audit.

00:50:34 You could watch for the eval function.

00:50:36 Yeah, exactly.

00:50:37 It is a little bit light on the details.

00:50:41 The implementation is not finished either.

00:50:43 But I know that Steve Dauer is working on this PEP.

00:50:48 And he has said if anyone wants to help contribute to the implementation or do some testing, then the door is open.

00:50:54 Nice to get in touch with Steve Dauer.

00:50:56 Perfect.

00:50:57 So maybe I'll just throw out a few real quick ones also that are like more minor.

00:51:00 So for virtual environments, it now has an ability to activate this through PowerShell on Windows, which if you use PowerShell on Windows, that's pretty awesome.

00:51:09 Yeah, that's awesome.

00:51:10 I don't know why you wouldn't use PowerShell if you're using Windows anymore.

00:51:14 If you want to use MS-DOS, that's fine.

00:51:16 Yeah.

00:51:16 It's not the greatest shell.

00:51:18 Yeah, yeah.

00:51:19 I like Commander.

00:51:20 C-M-D-E-R.

00:51:22 I think it's commander.net on Windows.

00:51:26 So optimizations around file copies.

00:51:28 That's been improved on the Unix-based systems, right?

00:51:32 Yeah.

00:51:32 I don't think that makes a pretty big difference, actually.

00:51:35 Yeah.

00:51:35 There's some built-in, like, sysplatform-specific fast copy.

00:51:38 Like, I wonder if it uses the new Apple file system sort of replication stuff, which would be a lot faster.

00:51:45 It'd be very cool.

00:51:46 They also removed pyvnv, the script.

00:51:49 So the expected way that you create a virtual environment is python3-m spacevnv, right?

00:51:55 Yes.

00:51:55 Nice.

00:51:56 I don't really use that, but...

00:51:57 Nice.

00:51:57 Well, that's what they tell you in 3.8.

00:52:01 Other minor changes.

00:52:03 And I guess one thing that's interesting is python3.8 is temporarily...

00:52:07 Like, it's pretty far out, so this might not be a problem forever.

00:52:12 But right now, with Guido stepping down and the governance decision, like, the choice of how Python governs its decision-making is not decided.

00:52:21 No new features are going into 3.8 until they can decide how to decide on those new features.

00:52:27 Yeah.

00:52:27 That's a bit of a weird catch-22 thing there.

00:52:29 I bump into one of the core developers last month, and they said that it's likely that there'll be fewer features in 3.8 than there have been in previous releases, unless...

00:52:38 Well, until they can work this thing out, and then even then, having, I guess, faster, sort of mainly bug fix and performance improvement releases is a lot more likely to be the way forward.

00:52:51 Yeah.

00:52:51 I suspect it's going to take a little while before this gets dialed in and it becomes a smooth process again, but I'm sure they'll figure it out.

00:52:58 Yeah.

00:52:58 Well, there's a few major things that kind of need to happen in future releases.

00:53:04 I guess one thing is the startup time is still slower than legacy Python.

00:53:09 I think there's ways for them to optimize that in terms of what it loads at import at startup and how it does all the importing and caching and stuff.

00:53:18 Hopefully, that'll be quicker in newer releases.

00:53:21 And then there's a C API, which has, over time, got a little bit messy.

00:53:25 So I think there's a few proposals for Python 4 for that to have a bit of a revamp.

00:53:30 Yeah, that'll be interesting.

00:53:31 That's a little far out, but definitely be interesting.

00:53:33 Maybe it'll be rewritten in Rust.

00:53:35 Yeah, maybe.

00:53:36 Yeah, I don't know about that.

00:53:38 Anyway, that's a ways out, but definitely something to look forward to.

00:53:41 Well, I think that's probably a good place to leave it.

00:53:44 We're probably low on time, kept you long enough.

00:53:47 But before you go, I know I've asked you this at least back in episode 155, but that was a while ago.

00:53:53 I'll ask you again.

00:53:54 If you're going to write some Python code, maybe your answer has changed.

00:53:56 What editor do you use?

00:53:57 It's still Visual Studio Code.

00:53:59 Right, with the Python plugin.

00:54:01 Yeah, it's definitely a nice thing.

00:54:03 And it's like, I don't know how many times, millions, like 5, 10 million.

00:54:08 I don't know how many millions there are downloads of that Python extension for Visual Studio Code, but it's pretty remarkable.

00:54:13 Yeah, it's great.

00:54:14 Although I'm using Windows at the moment with Windows subsystem Linux, which is causing me problems because Linux creates different virtual environments to Windows.

00:54:24 So the IDE is using a different virtual environment to my actual application, which is causing me a source of pain.

00:54:30 There's all sorts of process isolation and system isolation between the Windows subsystem for Linux and Windows itself, right?

00:54:37 Yeah.

00:54:38 So that's causing me.

00:54:39 You're going to be an expert pretty soon.

00:54:40 That'd be awesome.

00:54:41 You'll be able to help people who are also doing this.

00:54:44 Nice.

00:54:45 All right.

00:54:46 So notable PyPI package?

00:54:48 Yeah, I'd recommend people check out Black if they haven't already as a code formatter.

00:54:52 It's basically, if you ever check in code and then if the build fails because you've, you know, put an extra space at the end of a line or something, and you've had that frustration, then you can use this basically as a tool to go through your code and format it for you so that it passes most code linters and style checkers and stuff like that.

00:55:13 And it's basically no options, no configuration.

00:55:15 You just run the command, give it a directory, and it will just go through and change your code for you.

00:55:20 I absolutely love that.

00:55:21 I think the code it produces is really nice, really easy to read, and it's just really easy to get set up with.

00:55:27 Yeah, most linters, they just complain to you, you should get rid of that space at the end or whatever.

00:55:31 This one just goes, yeah, I'll fix that.

00:55:33 Yeah, it just fixes it up for you and you check it in.

00:55:35 Right on.

00:55:36 All right, final call to action.

00:55:37 People are excited about 3.7.

00:55:39 What do they do?

00:55:40 They need to download it first, install it, test it out, run their applications on it, see how they're improved, and then check out some of the new features.

00:55:49 Yeah, maybe check out your course.

00:55:50 Yeah, and absolutely check out my course.

00:55:52 Yeah, like I said, it'll take less than an hour of your time.

00:55:55 It's 57 minutes.

00:55:56 And you can find out all the details on Python 3.7.

00:56:00 Yeah, awesome.

00:56:01 I definitely agree.

00:56:01 People should check it out.

00:56:02 There's some great features.

00:56:03 And Anthony, thanks for being on the show to share them with everyone.

00:56:06 Thanks, Michael.

00:56:07 It's been great to be back.

00:56:08 Yep.

00:56:08 Bye.

00:56:08 Bye.

00:56:09 This has been another episode of Talk Python to Me.

00:56:12 Our guest on this episode was Anthony Shaw, and it was brought to you by Tidelift.

00:56:17 If you run an open source project, Tidelift wants to help you get paid for keeping it going strong.

00:56:23 Just visit talkpython.fm/Tidelift, search for your package, and get started today.

00:56:28 Want to level up your Python?

00:56:30 If you're just getting started, try my Python jumpstart by building 10 apps, or our brand

00:56:35 new 100 days of code in Python.

00:56:37 And if you're interested in more than one course, be sure to check out the Everything Bundle.

00:56:40 It's like a subscription that never expires.

00:56:43 Be sure to subscribe to the show.

00:56:45 Open your favorite podcatcher and search for Python.

00:56:47 We should be right at the top.

00:56:48 You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct

00:56:54 RSS feed at /rss on talkpython.fm.

00:56:58 This is your host, Michael Kennedy.

00:57:00 Thanks so much for listening.

00:57:01 I really appreciate it.

00:57:02 Now, get out there and write some Python code.

00:57:04 Thank you.

00:57:24 Thank you.

