00:00:00 Think about how you learn most technical or detail-oriented subjects.

00:00:03 You start at the bottom, lowest level, and you create building blocks and work your way into the thing

00:00:08 that eventually you get to that you actually care about.

00:00:11 This happens in engineering. This happens in math. This even happens in programming.

00:00:15 Our guest this week, Dr. Allen Downey, believes that computation and programming can help us turn this inside-out way of teaching right-side-out again.

00:00:23 Join Alan and me as we discuss programming as a way of thinking and physical modeling and engineering in Python.

00:00:29 This is Talk Python to Me, episode 119, recorded May 30th, 2017.

00:00:58 Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:01:05 This is your host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy.

00:01:10 Keep up with the show and listen to past episodes at talkpython.fm, and follow the show on Twitter via at Talk Python.

00:01:17 This episode is brought to you by Linode and Rollbar.

00:01:20 That's right. Welcome to Linode, who has joined Talk Python to Me as a major sponsor.

00:01:25 Be sure to check out what both of them are offering during their segments. It really helps support the show.

00:01:30 Hey, everyone. I have a quick announcement before we get to our conversation.

00:01:35 I'm super excited to announce the availability of my next course, and this is one I've been wanting to write for a long time.

00:01:42 It's MongoDB for Python developers.

00:01:45 This is one of the most practical and real-world courses on document databases in MongoDB.

00:01:50 You'll learn the native query syntax PyMongo and the ODM Mongo engine.

00:01:55 We'll also cover performance tuning and production deployments.

00:01:58 Get the MongoDB course right now at training.talkpython.fm.

00:02:02 Alan, welcome to Talk Python.

00:02:05 Thank you. It's a pleasure to be here.

00:02:07 It's an honor to have you on the show.

00:02:09 I'm really excited to bring this engineering aspect of Python to all the listeners.

00:02:15 It'll be really fun, I think.

00:02:16 I hope so.

00:02:16 Indeed, indeed. It's really cool to see the different ways that people are using programming in Python

00:02:20 and certainly to see how it's slowly eating away at the big commercial monolithic type things like MATLAB and Mathematica and so on.

00:02:30 Right, right.

00:02:31 Yeah, very fun.

00:02:32 We're going to dig into that for sure, but let's start at the beginning.

00:02:35 What's your story?

00:02:35 How did you get into programming in Python?

00:02:37 I got to Python in, I think, the year 2000.

00:02:41 I have a great story, which is I actually was working in Java.

00:02:45 I was teaching at Colby College up in Waterville, Maine.

00:02:48 I was unhappy with the books.

00:02:50 I was using, so I started writing a free open source textbook, and I wrote it in Java because that's the language I was teaching in.

00:02:58 I didn't know Python at the time.

00:02:59 I'm not sure I had even heard of Python.

00:03:01 But there was a snake thing, and there was some kind of movie that British make that's kind of funny.

00:03:06 And then, right, exactly.

00:03:08 Exactly.

00:03:09 But I put my Java book out under a free license, and Jeff Elkner, who was teaching high school in Virginia at the time, kind of took me up on the offer.

00:03:18 I said, you know, you can take this book.

00:03:20 You can modify it.

00:03:21 You can do anything you want.

00:03:22 And he translated it from Java into Python and sent it back to me.

00:03:27 So I actually learned Python by reading my own book.

00:03:30 Wow.

00:03:31 Most people don't learn Python by reading their own book.

00:03:34 That's a really crazy story.

00:03:35 That's amazing.

00:03:36 It's a strange experience because it sounded like me.

00:03:40 It's my writing style, but it's telling me things I don't know.

00:03:44 Oh, no.

00:03:44 That is weird.

00:03:45 It's like in movies where the future you comes back from the future and tells you things that you don't know.

00:03:51 It's just like that.

00:03:52 Yeah.

00:03:52 Oh, my gosh.

00:03:53 That's really, really interesting.

00:03:54 It was a pretty unique thing to do back in the year 2000 to release books kind of open source, right?

00:04:00 Like now it's pretty standard that many books have some online open source component to it.

00:04:05 But that was not common then, was it?

00:04:07 I don't think so.

00:04:08 And I had no idea what I was doing.

00:04:10 In fact, the first version, because I was writing in LaTeX, and LaTeX is almost a programming language,

00:04:16 I released it under the GNU general public license because I thought of it as being source code.

00:04:22 So that was the first license I used.

00:04:24 This was before the Creative Commons licenses didn't exist yet.

00:04:28 I switched at one point to the GNU free documentation license because that made more sense.

00:04:33 And now I'm mostly using Creative Commons licenses.

00:04:36 Okay, which Creative Commons?

00:04:37 Because there's a bunch of variations, right?

00:04:39 Yeah, different ones for different books.

00:04:41 Part of it, most of mine are, I don't have the non-commercial clause on most of them.

00:04:47 But for the ones that I'm publishing with O'Reilly, that's kind of the compromise that we've settled in on,

00:04:53 which is that the versions that are on my webpage have the non-commercial clause.

00:04:58 Right.

00:04:58 And then O'Reilly has the exclusive commercial license.

00:05:01 That seems like a pretty fair deal.

00:05:02 I think it's not bad.

00:05:03 What I've done a couple of times, when people have made a substantially modified version,

00:05:08 I can give them another license.

00:05:11 I can grant it to them under a license that does not have the non-commercial clause.

00:05:15 So if someone makes a really small change, then that's still covered.

00:05:19 But if they make a bigger change, then I've got some flexibility.

00:05:21 Right.

00:05:22 Okay.

00:05:22 Yeah, very interesting.

00:05:24 I think this way of learning Python is quite amazing.

00:05:27 And, you know, it's probably not entirely new, given how many people there are in the world, but it's got to be pretty rare.

00:05:32 So tell me, what was your experience?

00:05:34 What was the impression of the language as you learned it?

00:05:37 Were you like, why did they take away all the curly braces?

00:05:40 This is so weird.

00:05:41 Or were you like, oh, this is actually kind of amazing.

00:05:43 What was your thought?

00:05:44 Oh, no, I was hooked immediately.

00:05:45 Again, I was coming from Java.

00:05:47 And so I knew the frustration of teaching Java, which is all the stuff that you have to explain on the first day, just to write hello world.

00:05:57 There's public, static, void, main, string, bracket, bracket, and all that.

00:06:02 And in Python, of course, it's print hello world.

00:06:05 Exactly.

00:06:06 It's amazing.

00:06:07 I feel like people that work in those languages like Java, and I consider myself among them.

00:06:12 I did for a long time C++ development and some C# development.

00:06:16 And they're highly structured with symbol type languages, not structured in format, but structured with many, many symbols around it.

00:06:24 And you just feel like those are required.

00:06:26 Those are the right way to do it.

00:06:27 Everything must have curly braces and extra parentheses and whatnot until you realize that it doesn't have to be there.

00:06:35 You can actually have a nice, clean language that's just equally expressive.

00:06:38 And it's really liberating when you get there finally, I think.

00:06:42 Right, because you end up having to do the indentation anyway.

00:06:44 Yeah, exactly.

00:06:45 So at that point, if you have to indent, you might as well take away the squiggly braces.

00:06:49 Exactly.

00:06:50 Fully embrace it.

00:06:51 Fully embrace it.

00:06:52 Great.

00:06:52 So you said you wrote the book when you were teaching in Maine.

00:06:56 And now you're still teaching at a university, right?

00:06:59 But you're doing it a little farther south?

00:07:00 Yes.

00:07:01 I'm at Olin College, which is just outside of Boston.

00:07:04 And it's an engineering school.

00:07:05 So it's a little bit of a different environment.

00:07:07 I used to do computer science in the context of a liberal arts education.

00:07:12 And now I'm doing computing in the context of an engineering education.

00:07:16 So is it a little more exploratory?

00:07:19 Let's try to model these things and less learn how to write operating systems, learn how to create web apps or things like this.

00:07:28 How's the difference?

00:07:29 Right.

00:07:29 Yeah.

00:07:29 Part of it is that maybe less emphasis on theory, less emphasis on getting very deep into how things work, and more on using what's there and using it to solve the problems that you're trying to solve.

00:07:44 Sometimes it's about engineering.

00:07:45 Sometimes you are modeling physical systems.

00:07:48 Other times it's developing software systems, but maybe more like software engineering and less like computer science.

00:07:57 Right.

00:07:57 People may disagree with me, but just coming from my background where I just minored in computer science, I didn't go all in.

00:08:04 I feel like computer science and programming and software development kind of are the same thing, but the true computer science part of it is much more theoretical than what a lot of people do day to day, even though they might call themselves CS folks.

00:08:18 And so I think you guys might have this more explicit here in your program, right?

00:08:24 Yeah, I think that's right.

00:08:25 I mean, computer science as a field is kind of a historical accident.

00:08:30 It came out of math departments, and then it combined with some parts of engineering.

00:08:37 I mean, there are pieces there that are mathematics.

00:08:39 They are just, that's, they're discrete mathematics.

00:08:41 There are parts that are the engineering of working with software.

00:08:46 And then there are parts that are applications, you know, using computation in science and engineering and other fields.

00:08:53 Those are three kind of different things that don't necessarily belong together in one department.

00:08:59 Yeah.

00:08:59 I suspect that in 50 years, they won't be one department anymore.

00:09:03 Yeah.

00:09:04 Okay.

00:09:04 So in 50 years, would you imagine there might be an artificial intelligence department?

00:09:08 Oh, interesting.

00:09:09 I don't know.

00:09:10 That might.

00:09:10 Or data science where that AI is a big section of it or something?

00:09:13 Yeah.

00:09:14 Data science might make more sense as a field.

00:09:18 I don't know.

00:09:20 I can't even begin to think about what this will look like.

00:09:22 It's hard to predict that far out, isn't it?

00:09:23 Yeah.

00:09:24 Sure.

00:09:24 All right.

00:09:25 So you teach a number of classes there, which is really cool.

00:09:29 We'll dig into some of the learnings and takeaways from those around sort of fixing engineering education through programming.

00:09:38 But let's start a little bit farther back.

00:09:40 You wrote a really cool article called Programming as a Way of Thinking in Scientific American, right?

00:09:45 Yes.

00:09:46 It was on their blog.

00:09:47 Yeah.

00:09:47 Yeah.

00:09:47 That's an honor, right, to be on Scientific American, a pretty cool place.

00:09:50 So I recommend people check that out.

00:09:53 I'll put a link to it.

00:09:54 But could you maybe give us the synopsis?

00:09:56 Sure.

00:09:57 I mean, it's the idea.

00:09:58 And it's not just Python, but other modern programming languages are now so expressive that I think we can move away from programming as translation.

00:10:09 It used to be that you had to write everything out using mathematics and then translate it into executable code.

00:10:17 And you see things like, you know, the name of, you know, Fortran is formula translation.

00:10:22 That's what programming was.

00:10:24 It's right in the name.

00:10:25 I remember, yeah, I remember learning Fortran.

00:10:28 I actually did a little bit of engineering work in college as well.

00:10:31 And they told me, Fortran's the most important language you'll ever learn.

00:10:35 Wait, see where that went.

00:10:37 But I remember that, you know, when they would teach programming to some degree it was, and you make this flow chart, and then you translate it into the language.

00:10:45 And that just seems so in the way these days, right?

00:10:49 Why would you ever do this?

00:10:50 It just, you write it out in the language, right?

00:10:53 Right, right.

00:10:54 And you see this now in the history of pseudocode, which is if you look at early pseudocode, it looks like mathematics notation.

00:11:01 And then gradually it starts to look more and more like Python.

00:11:05 Until you get to the point where it is Python.

00:11:08 That you realize that the pseudocode is more readable if you just write it in Python.

00:11:15 And furthermore, it's executable.

00:11:17 And of course, being executable is huge.

00:11:20 Not only because that's, you know, the purpose of code, but also now it's debuggable.

00:11:25 So now you're taking these ideas that are in your head.

00:11:28 You're expressing them directly in code without going through all these translation steps.

00:11:34 And now while you're debugging that code, you are debugging your understanding of the ideas that you're expressing.

00:11:41 You're debugging your own brain.

00:11:42 Yeah.

00:11:42 It's really, it really is amazing.

00:11:44 And the fact that you can push a button and get the answer means some of these conceptual debates about things are often instantly solved.

00:11:55 Right.

00:11:56 I think of a lot of mathematical proofs.

00:11:58 Like I'm thinking of particularly one in topology where I sat there for days working on this problem.

00:12:03 And you can work out the proof and you can write it down.

00:12:06 And it seems very much like programming, very much logical step, step, step, do this.

00:12:09 You come to a conclusion, but you're never really sure.

00:12:13 You're not a hundred percent sure.

00:12:14 Right.

00:12:15 Whereas if you can do this with a program, the cool thing is you can push a button or hit the inner key and see, you know, do I actually have this right?

00:12:25 Right.

00:12:25 There's this great story about Paul Erdős.

00:12:28 And I don't know if you've heard this.

00:12:29 This is the Monty Hall problem, which is this notorious problem in probability that almost everybody gets it wrong when they first hear this problem.

00:12:38 And even once somebody tells you what the right answer is, most people don't believe it.

00:12:43 It's just so counterintuitive.

00:12:45 So Paul Erdős, when a friend of his told him this problem, this is one of the greatest mathematical minds of the 20th century.

00:12:52 Yeah, he was truly amazing.

00:12:54 And he lived in the world of mathematics.

00:12:56 Unlike so many people, he didn't even really have possessions.

00:12:59 He just went from department to department, right?

00:13:02 Oh, I mean, he's a great story in his own right.

00:13:04 But this particular problem just, it did not click with him.

00:13:09 He refused to believe what is actually the correct answer until his friend showed him a computer simulation.

00:13:16 And exactly as you said, the power of writing code and seeing it happen is what it took.

00:13:21 There was no amount of mathematical proof that was going to be as persuasive.

00:13:25 Yeah, that's really, really amazing.

00:13:27 And so one of the things that really resonated with me from this program is a way of thinking.

00:13:32 And I think anybody who presents ideas to other people, maybe you're working at a company, you're leading your team, you want to tell them about something.

00:13:40 If you're a public speaker or if you're a teacher or whatever is traditionally, I feel like we've taught things in the reverse order, in the wrong order.

00:13:50 Like, what I'm going to do is I'm going to spend three weeks teaching you a billion little details.

00:13:54 And then in a month, you'll see that what you've actually learned is kind of cool and we'll see what we can do with it.

00:13:59 Right.

00:14:00 Right.

00:14:01 That's such a problem, isn't it?

00:14:03 Yes.

00:14:03 Yes.

00:14:04 And this is now, this is a major theme of these textbooks that I'm working on, which is exactly as you said, put the fun stuff first.

00:14:11 Show me that it works.

00:14:13 Show me why it's useful.

00:14:14 What can I do with it?

00:14:16 And now I'm interested.

00:14:18 Now I want to know how it works and we can start going top down.

00:14:22 We don't have to start with all the details and work our way up.

00:14:25 Right.

00:14:26 And what's interesting, basically what makes this really possible is we can execute the ideas and understand them from the outside in.

00:14:34 Right.

00:14:35 Like if you're going to teach math, like you can't solve a fast Fourier transform unless you literally like learn all the steps.

00:14:41 Right.

00:14:41 But if you're doing programming, you could grab like a simulation library or you want to teach threading.

00:14:47 You could just use the simple async and await stuff and just start from the outer shell.

00:14:52 Like how does this look?

00:14:53 How do we use it?

00:14:53 What's amazing about it?

00:14:55 And then now let's dig in one layer and then another layer and another layer, like basically in reverse.

00:15:00 Right.

00:15:00 Right.

00:15:01 And in fact, your Fourier transform example, that's exactly what I do in Think DSP, which is chapter one.

00:15:08 I'm using Python and I'm using SciPy.

00:15:10 It's all in Jupyter Notebooks.

00:15:12 So right away, you can grab, download a sound, download an MP3 or make your own recording.

00:15:18 Look at the Fourier transform.

00:15:20 Look at what that spectrum looks like and understand what the Fourier transform does, how you're breaking a sound up and expressing it as a sum of frequency components.

00:15:31 At the end of chapter one, you understand 90% of what you need to understand.

00:15:36 And then the last 10% is how the Fourier transform actually works.

00:15:40 Right.

00:15:40 Yeah.

00:15:41 I remember learning that stuff and it was always just like, wow, this is so in serious integration.

00:15:45 What is going on here?

00:15:46 But you don't actually see like amazing signals being extracted from some noisy environment or, you know, some signal or something.

00:15:54 Yeah.

00:15:54 That's really cool.

00:15:55 Right.

00:15:55 Right.

00:15:56 You can start with auto-tune and work your way down.

00:15:58 Exactly.

00:15:58 One of the quotes you ended that article with that I wanted to share with everyone I thought was pretty cool is was basically that modern programming languages are quantitatively different from their predecessors.

00:16:09 And we're only beginning to realize the implications of that difference.

00:16:12 You want to add a little to that?

00:16:13 That's a pretty amazing, pretty awesome thought, I think.

00:16:16 I agree with people are just beginning to realize.

00:16:18 Yes.

00:16:19 So if we do translation, if we start out thinking in natural languages and then we express it in mathematics and then we have to translate it into code, we're limited to the set of things that we can express in all three languages.

00:16:32 And we lose something at each step of the translation.

00:16:36 So my conjecture is if we don't have to do the translation, if we work directly in code, potentially we will start writing things that look very different.

00:16:45 We will start writing things that we would never have come to if we approach them mathematically.

00:16:51 But I don't think we know yet what that's going to look like because that's not how we've been trained to think.

00:16:58 I think it'll have to be the next generation who start out in Python, who start out using programming languages for exploration.

00:17:07 And we'll see what they do that ends up being different from what we do.

00:17:12 That's for sure.

00:17:12 You know, I talk to people about how they got into programming or what was exciting to them all the time.

00:17:17 And a lot of times it's, well, I first, you know, wrote my simple basic program and it did something on the screen, like echoed my name a hundred times.

00:17:26 Or I made this turtle draw a square or something.

00:17:30 I can easily see a world in 10 or 15 years where people start answering that question.

00:17:35 Like the first thing I did was, well, I pulled up this Jupyter notebook and I typed in these things.

00:17:40 And then I understood something totally different than before, right?

00:17:44 Yes.

00:17:44 Yes.

00:17:45 Or if they're going through grade school and every class that they take involves an element of computation.

00:17:52 I mean, right now there's kind of obvious stuff.

00:17:55 Like when, if people are doing trigonometry, then maybe they'll do some computing along the way.

00:18:00 But they're probably not doing things like analysis of word frequencies when they study a text.

00:18:06 But you could do that.

00:18:07 You could have students in middle school take a couple of different authors and look at the distribution of sentence lengths or the number of different words that people use in different types of articles or different authors.

00:18:21 They could do that kind of analysis.

00:18:23 Yeah.

00:18:24 That's really interesting.

00:18:25 I can imagine a world where the study of literature somewhat involves sentiment analysis on the text using machine learning or something like that, right?

00:18:35 Right.

00:18:35 And where that's not something that's unusual, but it's just, look, we've got computation as a tool.

00:18:41 We're going to apply it to everything that we study.

00:18:43 This portion of Talk Python To Me is brought to you by Linode.

00:18:48 Are you looking for bulletproof hosting that is fast, simple, and incredibly affordable?

00:18:52 Look past that bookstore and check out Linode at talkpython.fm/Linode.

00:18:57 That's L-I-N-O-D-E.

00:18:59 Plans start at just $5 a month for a dedicated server with a gig of RAM.

00:19:03 They have 10 data centers across the globe.

00:19:05 So no matter where you are, there's a data center near you.

00:19:08 Whether you want to run your Python web app, host a private Git server, or even a file server, you'll get native SSDs on all the machines, a 40 gigabit network, 24-7 friendly support, even on holidays, and a seven-day money-back guarantee.

00:19:23 Want a dedicated server for free for the next four months?

00:19:26 Use the coupon code python17 at talkpython.fm/Linode.

00:19:31 There's this big push for all kids around the world sort of learning to code.

00:19:37 And I think what we're touching on definitely highlights some of the amazing reasons why that is.

00:19:44 I don't feel like we need more programmers per se, although there's going to be a need for more programmers.

00:19:49 I think we need more people with these skills that can, like you say, apply a little bit of computation to everything.

00:19:55 Whatever it is they're doing, bring a little computation to it, right?

00:19:59 I agree.

00:19:59 I'm not trying to make everybody be a software engineer.

00:20:02 We don't need that, and they don't want that.

00:20:05 But I do think if people have basic programming skills, that becomes a pedagogic wedge.

00:20:11 You use that as a lever to learn everything else.

00:20:15 I don't know if it's a wedge or a lever.

00:20:16 I might be mixing my metaphors.

00:20:18 But it gives you a tool for learning.

00:20:20 Yeah, for sure.

00:20:21 And you have a pretty interesting place to apply that, or at least see that in action, at an engineering school where most people probably aren't programmers.

00:20:28 But they really kind of need some computation, right?

00:20:30 Right.

00:20:30 We have a range of students, both when they come in, not everybody has programmed when they get here.

00:20:36 So we are the first contact for many of them.

00:20:39 And then when they leave, not everybody's going to do software.

00:20:42 We have some who love it, and that's going to be their career.

00:20:45 And others, especially, not to stereotype, but the folks doing mechanical engineering are not necessarily the ones who love software.

00:20:53 But the chances are they're going to do something with software at some point in their careers.

00:20:58 Yeah, if even it's just to write some Python script to automate something that actually is the application they're modeling with, right?

00:21:04 Right.

00:21:05 At the very least, they can automate the boring stuff.

00:21:07 Exactly.

00:21:08 All right.

00:21:08 So maybe that's a good place to segue into your physical modeling stuff.

00:21:13 So let's talk about physical modeling in Python.

00:21:16 You're doing a course there.

00:21:18 You've got some cool libraries and stuff that you're working with.

00:21:22 You said you're basically trying to fix engineering education.

00:21:25 Maybe we could start with that.

00:21:26 That's the Olin mission.

00:21:27 So Olin College was founded because the founders thought that engineering education is broken.

00:21:33 Why is it broken?

00:21:34 A couple of ways.

00:21:35 You know, one of them is that it's divorced from the people that we're designing for.

00:21:40 So engineers, I use this analogy that it's as if the engineer is sitting in a box.

00:21:45 Somebody comes and slides a well-formulated problem under the door.

00:21:50 And you have no idea where it came from, but you craft a beautiful engineering solution and you slide it under another door with no idea where it's going.

00:21:59 And that doesn't work.

00:22:00 Engineers have to understand the people they're designing for.

00:22:04 They have to identify opportunities.

00:22:06 They have to formulate those beautiful problems and figure out, first of all, is there an engineering solution?

00:22:13 Because not always.

00:22:14 Is there going to be one?

00:22:16 And then if there is, great, let's do the engineering.

00:22:19 Let's craft a beautiful solution.

00:22:21 But now there's a ton of work to get that idea out of the lab and make it real in the world.

00:22:27 So engineering education has to hit all three parts of that, designing for people and then crafting an engineering solution and then getting it out into the world.

00:22:36 Yeah, that sounds like a really nice way to structure everything.

00:22:40 You also talked about the science and math death march.

00:22:43 What is this?

00:22:45 Well, that's the other big problem with engineering education is that there's not enough engineering.

00:22:49 Students don't see anything that really looks like engineering, that looks like the practice of engineering, at least for the first two years.

00:22:58 Very often they're doing math and science and other prerequisites.

00:23:02 And they treat engineering as if it's the reward that you get for surviving past all those hurdles.

00:23:09 But even then it tends to be, even in the second and third and fourth years, it tends to be very theoretical.

00:23:15 So students often graduate with a lot of ability to solve the problems that are in the textbook, but very little ability to do real engineering.

00:23:25 Yeah, that was my experience in college.

00:23:26 So I feel like taking programming and simulations and letting you sort of start before you fully understand all the way down is a way you could maybe move the engineering up.

00:23:38 Yeah.

00:23:38 So this is the course that I'm working on right now is called Modeling and Simulation.

00:23:42 And this is part of the first semester at Olin.

00:23:45 We have three classes that go in parallel.

00:23:48 Modeling and Simulation is about doing physical modeling.

00:23:53 So you've got a physical system.

00:23:55 You make a model of what are the important parts that you have to include?

00:23:59 What are the things that you can leave out and simplify?

00:24:01 And then do either mathematical analysis or computational simulation to use that model to either predict something.

00:24:10 You know, what will this system do in the future?

00:24:12 Explain why the system behaves the way it does.

00:24:16 Or to design something to do some kind of optimization.

00:24:19 Okay.

00:24:19 And this is like, welcome to the university.

00:24:22 Here's your dorm.

00:24:23 Here's where you get textbooks.

00:24:25 We'll see you on Monday in this class.

00:24:26 Like that early?

00:24:27 That is, yes, that's exactly right.

00:24:29 And it's, we do some programming.

00:24:32 So of the first year classes, this is the one that has the most software in it.

00:24:37 And, but again, I mentioned most people are coming in, they haven't programmed before.

00:24:41 So we are simultaneously learning a little bit of programming, but with the immediate goal of modeling physical systems.

00:24:49 That carves it down.

00:24:51 We can teach a very small subset of the language because it's not general purpose programming yet.

00:24:57 It's really application focused.

00:25:00 It's not a full multi-tier web application with a database back in the scale.

00:25:06 No, no, no.

00:25:07 Just, we're going to run this math problem against this data and go, right?

00:25:11 Exactly.

00:25:12 Right.

00:25:12 So, you know, some of the first examples are just four loops where you're updating a variable that just measures, you know, the quantity of something.

00:25:20 We're doing a bike sharing example.

00:25:22 Probably one of the first examples is, you know, you've got three different stations and your customers are moving bikes from one station to another.

00:25:29 And we're going to simulate that process and figure out, is there going to be an equilibrium?

00:25:34 Or are we going to run out of bikes?

00:25:36 Do we have to move the bikes around?

00:25:39 So, with a very simple model, I mean, we're talking about three variables and addition and subtraction.

00:25:45 But we can get some interesting questions.

00:25:47 We can see equilibrium.

00:25:48 We can see non-equilibrium.

00:25:50 We can evaluate different strategies.

00:25:52 Like, should I move the same number of bikes every day?

00:25:55 Or should I measure something and make decisions dynamically?

00:25:59 All kinds of things.

00:26:00 Yeah.

00:26:00 And that definitely ties back to the real world.

00:26:02 I just heard today, I think it was today, maybe a few days ago, that Uber is running some program where or feature where it's cheaper to get cars where there's too many cars if your destination is in a place where they need to basically move a car to effectively.

00:26:19 Ah, yes.

00:26:20 So, here it is, just on a much larger scale, right?

00:26:24 Right.

00:26:24 So, almost the opposite of surge pricing.

00:26:26 It'll be a discount if you happen to be going where we want you to go.

00:26:29 Yeah, I think that's what, yeah, they called it like a power zone or something.

00:26:32 I think it was Uber.

00:26:33 It could have been Lyft, but I'm pretty sure it's Uber.

00:26:34 Ah, interesting.

00:26:35 Yeah.

00:26:35 So, okay, you come in and you have them do these models and they can do it computationally.

00:26:41 Do they do that in Python?

00:26:42 Until this coming year, everything has been MATLAB, which has worked okay.

00:26:46 It's got some nice tools built in.

00:26:49 So, there are things like there's an ODE solver, there's a root finder, there's an optimization tool.

00:26:55 And those are great.

00:26:56 Again, thinking about going top down.

00:26:58 We can use those tools before we understand how they work.

00:27:01 So, that's been good.

00:27:02 But we're switching to Python starting this fall.

00:27:05 Oh, that's exciting.

00:27:05 So, you guys are getting ready over the summer and then it's going to launch in Python for the next set of students, huh?

00:27:11 Yes.

00:27:12 So, this is my big project this summer is rewriting a lot of the materials that we have, switching over from MATLAB to Python.

00:27:19 Okay, excellent.

00:27:19 And this time, you're going to be writing the Python, not someone sending it back to you.

00:27:23 Exactly.

00:27:24 Oh, that sounds really great.

00:27:26 Do you think that this would be, I'm sure it would be possible.

00:27:28 Would this be a likely thing without IPython notebooks and Jupyter and all that kind of stuff?

00:27:33 It certainly could.

00:27:34 I think it would be less good.

00:27:36 I think one of the nice things about Jupyter is the students can just check out a notebook.

00:27:42 And there's a nice pedagogic process there where the first time through, they can just read the code and execute it and see what it does.

00:27:52 And maybe on the second pass, they're just making small changes, like try and experiment, change a parameter, put a couple of extra statements here or there.

00:28:01 And I think you're modifying code.

00:28:02 You can learn a lot from doing that before they get to the third step, which is really, okay, now you're going to create code from scratch.

00:28:09 Sure.

00:28:10 I think that's nice to start that way.

00:28:12 Especially this is almost like their first programming course, at least for some of them.

00:28:15 So they come in and say, well, what if we moved three bikes a day instead of just two?

00:28:21 How does that change the equilibrium and play with it?

00:28:23 And you have the nice pictures.

00:28:24 Yeah, it's pretty cool.

00:28:25 And there's a lot of room for the students who are just learning to program.

00:28:28 We're going to have kind of the lower bound that says, okay, we want to make sure that everybody gets to this level.

00:28:34 At the same time, people who are coming in with experience or people who just pick it up quickly, they can go crazy.

00:28:40 I mean, there's a ton that they can go and do.

00:28:42 Yeah, cool.

00:28:42 So what are some of the libraries you're planning on using for this?

00:28:46 So a lot of it is SciPy.

00:28:48 I mentioned some of the tools in MATLAB.

00:28:50 We need an ODE solver, and there's a good one in SciPy.

00:28:55 A root finder, optimization tools.

00:28:57 That's basically it, and that's coming straight out of SciPy.

00:29:00 And then the other library that I'm looking at is called Pint.

00:29:04 And this does units, units and dimensions.

00:29:09 This, I think, if this works, will be really good.

00:29:13 Because we're doing physical modeling.

00:29:16 And in physical modeling, everything is a quantity.

00:29:18 If you tell me that the answer is five, my question is going to be, five what?

00:29:24 Five meters?

00:29:26 Five seconds?

00:29:27 Tell me the units.

00:29:28 Tell me the dimensions.

00:29:29 So one opportunity here is to do computation where every quantity has its units attached

00:29:37 to it, and they carry through the computation.

00:29:39 So if you try to add two things, it's going to check to see if they have the same units.

00:29:45 And if they don't, it's going to give you an error.

00:29:47 You can't add joules and kilograms.

00:29:48 What are you doing?

00:29:49 Exactly.

00:29:49 Exactly.

00:29:50 And if you look at the number of real scientific and engineering projects that have run into

00:29:57 problems because the units got messed up, including, I think it was at the Mars climate probe that

00:30:03 was destroyed because they had, I think, both feet and meters.

00:30:08 And that was the end of that.

00:30:10 Yeah.

00:30:10 That's really unfortunate.

00:30:12 We in the U.S. probably have a little bit of blame to take for keeping the feet, the imperial units

00:30:20 still around.

00:30:21 Oh, yeah.

00:30:22 The rest of the world has tried to move on.

00:30:24 And we're like, nope.

00:30:24 We love our feet.

00:30:25 Still measuring things in drams per fortnight.

00:30:28 Exactly.

00:30:29 But even so, you still have centimeters versus meter.

00:30:33 I mean, there's certainly room for this error, even in the unit system, the metric system,

00:30:37 rather.

00:30:38 You'd mentioned Pite earlier when we were getting things set up, and I'd forgotten.

00:30:42 I did check this out.

00:30:43 This is really cool.

00:30:44 So you can, say, create one of these Pite-type things, and you can say, like, three times meters

00:30:50 plus four times centimeters, and it will, you know, make that 3.04 meters, right?

00:30:55 Things like that.

00:30:55 It really makes it obvious and easy.

00:30:57 Yes.

00:30:57 Yep.

00:30:58 So it'll do error checking, or if you multiply two things together, the result will have the

00:31:03 right units, and it'll reduce units.

00:31:06 So if you express something as some crazy combination, it'll say, oh, that's Jules.

00:31:10 Yeah.

00:31:10 Really?

00:31:12 Yeah, Jules is a crazy unit.

00:31:14 So I think this highlights one of the things where, say, MATLAB or one of these package systems,

00:31:21 it's kind of nice in that it's self-contained and whatnot, but I don't think MATLAB has this

00:31:24 concept of this Pint library.

00:31:26 And if it has the Pint, there's, you know, a thousand other Python such libraries that

00:31:30 are really cool to bring in to just sort of make it more expressive, right?

00:31:34 Right.

00:31:35 And it also, when you're comparing languages, there's theoretically, all languages are equivalent

00:31:40 in the sense that they can compute all computable functions.

00:31:43 But there are pragmatic things.

00:31:46 There are, you know, some things are hard or easy, but there's also culture, which is around

00:31:51 MATLAB culture.

00:31:52 People tend to write fairly simple programs that are mostly script-like in the sense that

00:31:59 you're just combining existing features.

00:32:01 You're not often writing functions or functions that use other functions.

00:32:07 You're not writing objects.

00:32:09 You're not building up layers of abstraction.

00:32:12 Right.

00:32:12 You're not building reusable concepts.

00:32:16 You're taking other people's reusable concepts and making it like a final product, right?

00:32:22 Maybe not a well-factored one, but something that like, this is done when this runs.

00:32:25 I'm not going to like open source this in a way that other people can easily build on, probably.

00:32:30 I think that's often true.

00:32:31 And not because it's impossible.

00:32:33 I mean, I think there is object-oriented MATLAB out there, but it's not commonly used.

00:32:39 When you come to the Python cultural ecosystem, it's more of a software engineering world.

00:32:46 There's more abstraction, more functional decomposition, more object-oriented programming.

00:32:51 So at the risk of starting a programming language war, the overall level of software engineering

00:32:57 tends to be higher.

00:32:58 So the tools you're working with are more abstract.

00:33:02 And then from my point of view as an instructor, now I can build abstraction to put between

00:33:10 the students and the tools that they're using.

00:33:12 So what I'm planning to do, I'm making a library that's called modsim.py.

00:33:17 Most of what the students do, at least when they're getting started, is they're going to

00:33:22 use things from my library.

00:33:23 So I can put wrappers around things.

00:33:26 I can hide the details that they don't need to know about yet.

00:33:29 If I see them making the same errors over and over, I can generate really good error messages.

00:33:34 I can do argument checking.

00:33:36 I can just help them get over what I know the rough spots are going to be.

00:33:40 I think that's a great, great point.

00:33:42 I've had a couple of people who were teaching classes and then they've had students teaching

00:33:49 classes that were somehow computational and using Python said, why do I need to learn Python?

00:33:54 Can't I just learn MATLAB or Mathematica and just go on?

00:33:59 Like I've asked Jake Venderplass what he thought about this, like what he would respond.

00:34:02 What would you tell a student who comes and says, I don't really want to learn Python or

00:34:06 programming.

00:34:07 Can we just use MATLAB for this example or this class?

00:34:10 Well, you could.

00:34:10 And I'm not trying to say I'm not a total zealot.

00:34:14 And we've been teaching MATLAB for this class since 2009.

00:34:18 It's not impossible.

00:34:19 It's not terrible.

00:34:19 I think it's an okay first language, but I think Python is better.

00:34:25 I think it's a better first language.

00:34:26 Just I think the rough spots are smoother.

00:34:29 It's easier to get started.

00:34:31 And it's a general purpose programming language, which means that all of the effort that you

00:34:37 put into learning it will pay off not just for this class, but for any other class that

00:34:43 you're taking.

00:34:43 So you get a little bit more reward from that investment.

00:34:46 Yeah.

00:34:47 I think that's, that's really interesting.

00:34:48 And I think Jake Vanderplass maybe even touched on this on his keynote at PyCon last week

00:34:53 and that not everybody who goes through an engineering program or astronomy program or whatever is

00:35:00 going to be just an astronomer or just an engineer on the other side.

00:35:04 And so learning something like Python gives you a super marketable and flexible skill.

00:35:08 Learning something very focused in that discipline makes it less, right?

00:35:13 So it's also, also good job diversification possibilities, I guess.

00:35:18 Yeah, I think that's right.

00:35:19 I'm teaching at an engineering college.

00:35:21 So in some sense we are focused, but not all of our students are going to be engineers.

00:35:25 One of the things that we say is that engineering education is great preparation for a lot of things,

00:35:32 not just engineering.

00:35:33 Sure.

00:35:34 And you could go work at somewhere like Autodesk and work on AutoCAD, for example, right?

00:35:38 Or something like some company that makes software for engineers, but you could end up only using

00:35:44 a little of engineering and a lot more programming skills, right?

00:35:46 Sure.

00:35:46 Yeah.

00:35:47 Hey everyone, Michael here.

00:35:49 Let me take just a moment and thank one of our sponsors who makes this show possible.

00:35:53 This portion of Talk Python To Me has been brought to you by Rollbar.

00:35:56 One of the frustrating things about being a developer is dealing with errors.

00:35:59 Relying on users to report errors, digging through log files, trying to debug them,

00:36:04 or a million alerts just flooding your inbox and ruining your day.

00:36:07 With Rollbar's full stack error monitoring, you get the context, insight, and control you

00:36:12 need to find and fix bugs faster.

00:36:14 Adding the Rollbar Python SDK is just as easy as pip install Rollbar.

00:36:19 You can start tracking production errors and deployments in eight minutes or less.

00:36:22 Rollbar works with all the major languages and frameworks, including the Python ones like

00:36:27 Django, Flask, Pyramid, as well as Ruby, .NET, Node, iOS, and Android.

00:36:32 You can integrate Rollbar into your existing workflow.

00:36:35 Send error alerts to Slack or HipChat or automatically create new JIRA issues,

00:36:39 pivotal tracker issues, and a lot more.

00:36:41 They have a special offer for Talk Python To Me listeners.

00:36:43 Visit talkpython.fm/Rollbar.

00:36:46 Sign up and get the bootstrap plan free for 90 days.

00:36:49 That's 100,000 errors tracked for free.

00:36:51 But, you know, just between you and me, I hope you don't encounter that many errors.

00:36:55 Give Rollbar a try today.

00:36:57 Just go to talkpython.fm/Rollbar.

00:37:00 You talked at the beginning about your book.

00:37:03 What was the title?

00:37:04 Did you say the title?

00:37:04 Thinking?

00:37:05 Think Python, right?

00:37:06 Think Python.

00:37:07 Yes.

00:37:08 Right.

00:37:09 So that's a really great book.

00:37:10 And it's almost like Computer Science 101 getting started with programming, right?

00:37:15 It is.

00:37:16 It's meant for people who have never programmed before.

00:37:19 So it really starts from X equals five.

00:37:22 This is a variable.

00:37:23 This is a value.

00:37:24 But it's meant to be mostly language agnostic.

00:37:29 So the principles are the same across lots of different programming languages.

00:37:33 Certainly the family of imperative programming languages.

00:37:36 In fact, there are now, there are translations of the book in, you know, Java and Python.

00:37:42 And actually the most recent one is Perl 6.

00:37:45 The book, Think Perl 6, just comes out, just came out this week.

00:37:50 Oh, that's pretty cool.

00:37:51 Yeah, very nice.

00:37:52 Okay.

00:37:52 So what other books have you written?

00:37:54 I know you talked about your digital signal processing one, right?

00:37:58 Right.

00:37:59 So that's ThinkDSP.

00:38:00 And then the two, the data science books are ThinkStats, which is mostly about exploratory

00:38:07 data analysis.

00:38:07 And then ThinkBase, which is specifically about doing Bayesian statistics.

00:38:12 All right.

00:38:12 Are those open source in the same sense that ThinkPython was?

00:38:15 Yes.

00:38:16 Yeah, they all are.

00:38:17 So those are all, my webpage is greenteepress.com.

00:38:21 Or if you just Google my name.

00:38:23 Yeah, I'll link to all the, I'll be sure to link to them as well in the show notes.

00:38:26 Great.

00:38:27 And so, yeah, all the books are there.

00:38:28 As I said, not all under exactly the same licenses, but they're under free licenses.

00:38:33 And then Think Complexity is the other one, which is about complexity science.

00:38:38 I'm working on the second edition of that one now.

00:38:41 So that's a work in progress.

00:38:42 That sounds interesting.

00:38:43 Give us a sense of what complexity science is.

00:38:45 It's kind of an odd set of topics.

00:38:48 One way to think about it is it's the physics of complex systems, systems where you have components

00:38:55 that interact with each other.

00:38:56 Like a three-body problem and gravity, something like that?

00:38:59 Yeah.

00:39:00 So that would be an example of a system that gets chaotic.

00:39:02 And among continuous mathematics, those are interesting systems too.

00:39:07 And then in discrete math world, there are things like grids and cellular automata.

00:39:13 So things like Conway's Game of Life and Stephen Wolfram's work in CA's cellular automata.

00:39:19 And then also graph models.

00:39:22 So things like small world networks and scale-free networks and agent-based models, one of the

00:39:28 big topics.

00:39:29 So boids, things moving around in three dimensions.

00:39:33 Or there are some economic models like sugarscape and Schelling's model of segregation.

00:39:39 So those are some of the topics.

00:39:41 Yeah.

00:39:41 Oh, that sounds really interesting.

00:39:42 I just need an excuse to study them, but it sounds cool.

00:39:45 It's great stuff and they're fun.

00:39:47 They tend to have a lot of leverage, like a small amount of computation for a lot of very

00:39:53 interesting results.

00:39:54 And there are philosophical implications to almost all of it.

00:40:00 So almost every chapter ends with, here's some reading that you might want to do from

00:40:06 the philosophy of science, because we've just come face-to-face with instrumentalism and

00:40:11 reductionism and all kinds of other isms.

00:40:14 Yeah, cool.

00:40:15 It seems to me if there are parents out there listening who have to help their kid with a

00:40:20 science fair presentation, you could probably take something pretty interesting from there

00:40:25 and put a little simulation on it and make that a science fair presentation.

00:40:28 It's pretty good.

00:40:29 It's not as good as the volcano with the baking soda, but Game of Life is pretty good.

00:40:34 Yeah, for sure.

00:40:35 So another one that you are working on is called ThinkOS, right?

00:40:39 Yes.

00:40:40 That one looks interesting.

00:40:41 And this takes people who you sort of assume the reader knows Python and says, all right,

00:40:46 let's write an operating system and see.

00:40:48 Yes.

00:40:50 So this is filling a gap that I think has opened up in the computer science curriculum,

00:40:55 because it used to be that the intro classes were often in C or Java or languages that are

00:41:02 similar, so that when people get to the operating systems class, they already know a low-level

00:41:08 language.

00:41:09 And now they're ready to find out how to implement an operating system.

00:41:12 Yeah.

00:41:13 I think you're right that this is changing.

00:41:15 And it's for the better in the large scale that people are starting with higher-level languages.

00:41:19 I think even with Java, if you learn Java and you stay in a managed language or you learn

00:41:25 Python, which is more common these days, understanding malloc and all these sorts of low, low, low-level

00:41:34 things is pretty new, right?

00:41:35 Right.

00:41:36 And that's a good example.

00:41:37 I think memory management is one of the gaps.

00:41:40 So now when students get into a second or a third computer science class, now maybe they need to learn C,

00:41:48 but they need to learn memory management.

00:41:50 They need to learn a lot about that kind of system level.

00:41:53 What do the operating system calls look like?

00:41:57 What are those APIs?

00:41:58 So ThinkOS is an attempt to fill in some of that space with, on the one hand, we're going to

00:42:06 learn system level programming in C. And on the other hand, we're going to learn about

00:42:10 operating systems. But what we're going to learn is the stuff that you need to know in order to be

00:42:17 a good application level programmer.

00:42:19 Right. I think you need to know C to be a good professional programmer. I don't think you need to

00:42:24 do it all the time, but I think knowing really what happens down at that level, really what does

00:42:30 it mean for pointers to do their thing? What does it mean for memory management and so on? And have

00:42:36 that experience is pretty important, even if you spend 99.9% of your time in Python or something.

00:42:42 Yeah, I think I agree. Although I tend to be skeptical about people telling me what everybody

00:42:49 needs to know.

00:42:50 Yes, of course, of course.

00:42:52 But I think you're right. At the very least, one of the things that you're going to have

00:42:57 is a mental model of what's happening while your program is executing.

00:43:01 Right. Yeah. And I'm not necessarily, I said C, but I'm more thinking like just a language that

00:43:06 you need to have a concept of like how the thing actually runs. That's more what I'm trying to say.

00:43:12 And I think C is probably where most people get that model.

00:43:14 Yeah, I agree. And maybe it used to be assembly language. So we're still moving up. But I think

00:43:20 you're right. And you're going to have a performance model as well of what's fast and what's slow. So

00:43:27 when you start writing at the application level, if you are surprised, if things are slower than you

00:43:32 expected, maybe you can debug that because you know what's going on one level down.

00:43:37 Right. Enough tools to go and explore that and go, oh, I see why this is happening rather than,

00:43:41 that's weird. Didn't know that would be slow. I just guess that's just won't do that anymore.

00:43:47 Interesting. Okay. So I think that is a really cool book. So if you come in from Python and you

00:43:51 want to like get some, some experience and see sort of tailor, tailor made to take you from that one

00:43:58 step to the next, that's cool. And certainly understanding operating systems is good as well.

00:44:02 So let's see, where, where are you going with courses in this whole area? What do you have other

00:44:10 courses that you're teaching? Do you have other areas you're trying to explore this? Like let's use

00:44:15 computation to help people understand stuff in the right order, not the reverse order.

00:44:19 Right. I've got a bunch of projects that I work on in parallel. So I mentioned complexity. That's,

00:44:25 that's the immediate project. Sort of medium to long-term, I'm still thinking about linear algebra.

00:44:31 I think there's a big opportunity there for people to really understand that in a way that lets them

00:44:37 do things with it. I think a lot of people who've studied linear algebra,

00:44:41 they walk away with the vague notion that they can prove things about matrices, but not necessarily a

00:44:48 lot of skills for really using the entities of, of linear algebra to do work, to solve problems by

00:44:57 expressing them in that vocabulary. Right. I could tell you if a matrix is singular, I could do various

00:45:02 other things to it, but I can't apply. There's like no useful skill I take away from this. Right.

00:45:07 Basically is a way a lot of people end up experiencing it. I suspect. Yep. That's another

00:45:12 place where doing things computationally can flip the order. You can go top down starting with

00:45:17 applications and gradually understanding how they work. All right. Well, that all sounds really fun.

00:45:22 Do you think that we should be trying to get this computational stuff in middle school or like,

00:45:29 like 10, 12, 13 year old kids, like maybe a little bit less math, a little bit more programming or

00:45:36 something, or how do you think we could take this in and make it more? So it's not something they

00:45:41 experience when they get to college, but sort of everyone gets a chance to see it.

00:45:45 Oh yeah. No, I think everybody should see it. And earlier than that, I think you can do it in

00:45:49 elementary school for some definition of do it. What I'm talking about is using computational tools in

00:45:56 the context of whatever it is that you're studying at a level that's appropriate for where the kids

00:46:02 are. It can't be another class. You can't go and study English for an hour and then math for an hour

00:46:11 and then computing for an hour. I think the computing just has to be embedded everywhere. Just in the same

00:46:18 way that we use paper and pencil as a tool, we should be using computation as a tool,

00:46:22 but not just using applications that other people wrote. There should be a gradual process of

00:46:30 programming for some definition of programming for basic things, languages like Scratch that are

00:46:38 block-based where you're just organizing computational elements, gradually working up to general purpose

00:46:44 programming languages. Yeah, I totally agree. I think, I think it'd be great to see that.

00:46:49 And I suspect we will see that over time, but who knows when it really kick in at that level.

00:46:54 That's a pretty big battleship to turn the curriculum up for children.

00:46:58 Oh yeah, no question.

00:46:59 All right. Well, Alan, we're getting sort of near the end of the show. So let me ask you the

00:47:03 two questions I always ask everyone. One, first, if you're going to write some Python code,

00:47:09 what editor do you open up?

00:47:10 I do most of my programming in Emacs. And then more recently I'm writing more and more of it in

00:47:16 Jupyter notebooks while I'm exploring. And then at some point I end up taking that code out of the

00:47:21 notebooks and putting it into modules and then either Emacs or other IDs.

00:47:27 Sure. All right. Excellent. And most notable or favorite PyPI package? We're over a hundred thousand

00:47:34 by quite a ways now.

00:47:35 Right. I guess pandas is probably the thing I'm spending my most of my time working with. I love

00:47:41 it. I did a lot of statistics using my own tools for a while. And I ended up just writing a whole lot

00:47:49 of pointless code that I never should have written because 90% of what I was doing would have been a

00:47:54 one line pandas method. Yes.

00:47:58 And then the other package I mentioned is pint that I'm very interested in. Again, for doing

00:48:03 computation with quantities that have units.

00:48:05 Pint is really simple. Pandas is something that's very powerful, but definitely takes some study and

00:48:10 to really leverage it. But it's great as well. All right. So for the educators, for the students,

00:48:16 or even professional programmers listening, what's the final call to action? How can they

00:48:20 take these ideas and do more with them?

00:48:22 Well, so the physical modeling project, as I said, I'm working on that this summer.

00:48:26 We're going to be developing that course. And I'm really interested to hear from people who are doing

00:48:31 physical modeling of lots of different kinds. In particular, we're probably going to start with

00:48:37 population models and other discrete things where you've got either animals that are breeding,

00:48:44 or I mentioned bicycles moving from place to place. So discrete things moving in discrete spaces.

00:48:51 And then probably some first order systems like thermodynamics and chemical kinetics,

00:48:56 maybe some pharmacokinetics. So just looking for examples that are interesting because the

00:49:04 applications matter. So real world problems that have consequences. And really examples where

00:49:12 you have a simple model that does a lot of work for you, that you can take a complex physical system

00:49:19 and describe it with a model that is just the right amount of simple.

00:49:24 Right. The interesting problems that are not so complex, they're too daunting, right?

00:49:29 Right, right. And really do something with it that you're either making predictions that are

00:49:33 real predictions that people care about, or explaining something that's genuinely an open question,

00:49:39 or doing design where you can actually optimize something by modeling it, finding an optimum,

00:49:46 and then building that product or whatever the system is.

00:49:49 Yeah, that's really cool. You said you're going to be working on a thing called modsim.py

00:49:52 for this class. Is that going to show up on GitHub? And could people come give you feedback and stuff

00:49:58 on it?

00:49:58 Yeah, I'll probably start the GitHub repository soon. In fact, I might already have, we'll have a link to that.

00:50:04 Yeah, there's a little bit of time shifting. So whenever you get it done, even if it comes out after

00:50:08 the podcast, send it to me and I'll put it in the show notes. People can then go and check it out.

00:50:13 All right, Alan, thank you for being on the show. It's really great to chat with you.

00:50:15 Thank you very much. It's been a lot of fun.

00:50:17 Yep, you bet. Bye.

00:50:19 This has been another episode of Talk Python to Me. Today's guest has been Allen Downey. And this

00:50:26 episode has been brought to you by Linode and Rollbar. Linode is bulletproof hosting for whatever

00:50:32 you're building with Python. Get your four months free at talkpython.fm/Linode. Just use the

00:50:39 code Python17. Rollbar takes the pain out of errors. They give you the context and insight you need to

00:50:46 quickly locate and fix errors that might have gone unnoticed until your users complain, of course.

00:50:51 As Talk Python to Me listeners, track a ridiculous number of errors for free at rollbar.com slash

00:50:57 talkpythontome. Are you or a colleague trying to learn Python? Have you tried books and videos that

00:51:02 just left you bored by covering topics point by point? Well, check out my online course Python

00:51:07 jumpstart by building 10 apps at talkpython.fm/course to experience a more engaging way to learn

00:51:13 Python. And if you're looking for something a little more advanced, try my Write Pythonic code course at

00:51:19 talkpython.fm/pythonic. Be sure to subscribe to the show. Open your favorite podcatcher and search

00:51:25 for Python. We should be right at the top. You can also find the iTunes feed at /itunes, Google Play feed

00:51:31 at /play and direct RSS feed at /rss on talkpython.fm. Our theme music is Developers,

00:51:38 Developers, Developers by Corey Smith, who goes by Smix. Corey just recently started selling his tracks

00:51:43 on iTunes. So I recommend you check it out at talkpython.fm/music. You can browse his tracks

00:51:49 he has for sale on iTunes and listen to the full length version of the theme song. This is your host,

00:51:55 Michael Kennedy. Thanks so much for listening. I really appreciate it. Smix, let's get out of here.

00:52:00 Outro Music.

00:52:21 you Bye.

00:52:22 you

