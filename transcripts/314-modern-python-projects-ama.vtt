WEBVTT

00:00:00.001 --> 00:00:02.120
Here's an episode that I did not see coming.

00:00:02.120 --> 00:00:06.600
Sebastian Wibowski and I put together a live stream, Ask Me Anything, as a follow-up to

00:00:06.600 --> 00:00:09.740
some of his ideas around his recent course, Modern Python Projects.

00:00:09.740 --> 00:00:15.980
We dove deep into comparisons of poetry versus pip versus pyenv and answered questions like,

00:00:15.980 --> 00:00:17.020
do I need to use Docker?

00:00:17.020 --> 00:00:17.960
And when should I?

00:00:17.960 --> 00:00:18.580
And so on.

00:00:18.580 --> 00:00:22.400
After the AMA was over, I realized it would make a great podcast too.

00:00:22.400 --> 00:00:23.460
So here you go.

00:00:23.460 --> 00:00:28.080
This is our AMA with Sebastian, all around the ideas of modern Python workflows.

00:00:28.080 --> 00:00:29.180
I hope you enjoy it.

00:00:29.620 --> 00:00:35.060
This is Talk Python to Me, episode 314, recorded April 19th, 2021.

00:00:35.060 --> 00:00:53.000
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the

00:00:53.000 --> 00:00:54.400
ecosystem, and the personalities.

00:00:54.400 --> 00:00:56.200
This is your host, Michael Kennedy.

00:00:56.200 --> 00:00:58.400
Follow me on Twitter where I'm @mkennedy.

00:00:58.400 --> 00:01:02.120
And keep up with the show and listen to past episodes at talkpython.fm.

00:01:02.320 --> 00:01:05.280
And follow the show on Twitter via at talkpython.

00:01:05.280 --> 00:01:10.360
This episode is brought to you by 45 Drives and us over at Talk Python Training.

00:01:10.360 --> 00:01:12.520
Please check out what we're offering during those segments.

00:01:12.520 --> 00:01:13.920
It really helps support the show.

00:01:13.920 --> 00:01:18.260
Everyone out there, thank you so much for being here today.

00:01:18.260 --> 00:01:22.420
It's exciting to have you here in the live stream, or if you're watching later, watching

00:01:22.420 --> 00:01:23.700
the record.

00:01:23.700 --> 00:01:25.500
So Sebastian, welcome.

00:01:25.500 --> 00:01:27.900
It's great to have you part of this Ask Me Anything.

00:01:28.080 --> 00:01:30.040
In fact, it's your Ask Me Anything, really.

00:01:30.040 --> 00:01:30.780
Thank you.

00:01:30.780 --> 00:01:31.960
Yeah, I'm excited to be here.

00:01:31.960 --> 00:01:34.040
Yeah, of course, I'll give my thoughts as well.

00:01:34.040 --> 00:01:39.720
But you've done a lot of thinking about tooling and putting the right tools together and what

00:01:39.720 --> 00:01:45.020
maybe constitutes what you might call a modern Python project or the tool chain of a modern

00:01:45.020 --> 00:01:46.300
Python developer.

00:01:46.800 --> 00:01:50.660
And there's a couple of things that we've already done together that are maybe worth

00:01:50.660 --> 00:01:53.100
calling out that we'll build on here today.

00:01:53.100 --> 00:01:55.820
So a while ago, I guess, what was this?

00:01:55.820 --> 00:01:59.580
Oh my gosh, this was back last year, August 29th, 2020.

00:01:59.580 --> 00:02:01.260
You were on Talk Python.

00:02:01.260 --> 00:02:04.320
You came on and talked about the modern Python developers toolkit.

00:02:04.320 --> 00:02:07.840
And then we talked a little bit after that and said, you know, it would be really cool actually

00:02:07.840 --> 00:02:09.860
to put a course like this together for people.

00:02:09.960 --> 00:02:13.940
So over at Talk Python training, you created the Modern Python Projects course.

00:02:13.940 --> 00:02:18.920
This is almost a nine hour course that takes a lot of the ideas you mentioned there previously

00:02:18.920 --> 00:02:24.640
on the podcast and makes them concrete, makes it something that actually people can employ

00:02:24.640 --> 00:02:25.240
and use.

00:02:25.240 --> 00:02:29.820
And so, yeah, those are some of the things that we've done together before.

00:02:29.820 --> 00:02:35.320
But we're just going to take a broader view and talk about what this whole idea of modern

00:02:35.320 --> 00:02:36.500
Python projects might be.

00:02:36.500 --> 00:02:37.620
Yeah.

00:02:37.620 --> 00:02:41.020
So let's just kick it off with a quick high level overview.

00:02:41.020 --> 00:02:42.340
Like, what are your thoughts?

00:02:42.340 --> 00:02:45.240
What constitutes modern Python development?

00:02:45.240 --> 00:02:47.040
How has it changed over time?

00:02:47.040 --> 00:02:47.960
Things like that.

00:02:47.960 --> 00:02:49.680
Then we'll get to the people's individual questions.

00:02:49.680 --> 00:02:50.280
Yeah.

00:02:50.280 --> 00:02:55.320
So as you mentioned, this whole idea started as PyCon workshop where I wanted to share with

00:02:55.320 --> 00:02:59.640
people some ideas for tools that I've been using.

00:02:59.640 --> 00:03:04.440
And I know that a lot of other people have been using because I sometimes see people like

00:03:04.440 --> 00:03:09.220
start programming in Python and they still stick to using the default Python shell.

00:03:09.220 --> 00:03:13.760
And they don't know about many great tools that are in the ecosystem.

00:03:13.760 --> 00:03:16.680
You'll hear like, oh, I used idle to try to run this.

00:03:16.680 --> 00:03:18.460
And you're like, whoa, whoa, whoa, please don't use idle.

00:03:18.460 --> 00:03:21.880
I mean, it's built in, but there's really more helpful options these days, right?

00:03:21.880 --> 00:03:22.640
Something like this.

00:03:22.640 --> 00:03:23.040
Yeah.

00:03:23.040 --> 00:03:27.120
I mean, Python is really cool with the batteries included because you have a lot of things

00:03:27.120 --> 00:03:27.500
there.

00:03:27.500 --> 00:03:32.560
But at the same time, there are a lot of other different tools and projects that can make

00:03:32.560 --> 00:03:33.600
your life much, much easier.

00:03:33.600 --> 00:03:36.400
And that's what I wanted to share with people.

00:03:36.400 --> 00:03:36.960
Nice.

00:03:36.960 --> 00:03:41.040
And I would like to point out for people who maybe don't know, there's a lot of amazing

00:03:41.040 --> 00:03:44.340
tools that are not part of Python on purpose.

00:03:44.340 --> 00:03:47.740
And the reason they're not part of Python is not that they're amazing.

00:03:47.740 --> 00:03:52.260
It's that Python releases, it used to be every 18 months and now every 12 months.

00:03:52.260 --> 00:03:55.560
And once something goes into Python, it can't be taken out almost ever.

00:03:55.560 --> 00:04:02.800
So it's very hard to move fast and break things type of mentality with Python itself and the

00:04:02.800 --> 00:04:04.780
standard library and so on.

00:04:04.780 --> 00:04:07.640
But stuff outside of it can be much more rapid.

00:04:07.640 --> 00:04:12.900
For example, there was a conversation with the core devs around making requests, the package

00:04:12.900 --> 00:04:17.620
part of Python as a better way to do it because it's vastly a better way to do it than the built

00:04:17.620 --> 00:04:18.820
in HTTP libraries.

00:04:18.820 --> 00:04:24.160
They decided not to put requests into Python itself because they said it would actually

00:04:24.160 --> 00:04:27.980
slow down and hamper requests and make it less valuable.

00:04:27.980 --> 00:04:30.920
And it's better to leave it as its own standalone thing.

00:04:30.920 --> 00:04:36.380
And I think that touches on a lot of what you're talking about, Sebastian, is that there's what's

00:04:36.380 --> 00:04:38.420
built into Python and a lot of it is really good.

00:04:38.500 --> 00:04:43.120
But oftentimes there's better things outside and they're not likely to be moved into Python

00:04:43.120 --> 00:04:44.500
for their own good.

00:04:44.500 --> 00:04:45.220
Yeah, exactly.

00:04:45.220 --> 00:04:50.920
And since installing new packages or tools in Python is just one peep command away, it's

00:04:50.920 --> 00:04:53.820
very easy to add new tools, experiment with them.

00:04:53.820 --> 00:05:00.180
But at the same time, it's worth knowing which tools are kind of like the backed up by the

00:05:00.180 --> 00:05:02.540
Python community, like which one are the most popular.

00:05:02.540 --> 00:05:03.120
Right.

00:05:03.200 --> 00:05:05.100
What are the de facto primary ways?

00:05:05.100 --> 00:05:07.680
Like pytest, for example, would be in a case there.

00:05:07.680 --> 00:05:07.920
Yeah.

00:05:07.920 --> 00:05:08.580
Exactly.

00:05:08.580 --> 00:05:09.180
Okay.

00:05:09.180 --> 00:05:09.660
Yeah.

00:05:09.660 --> 00:05:14.500
For example, I wanted to mention Cookie Cutter because if you're looking for a way to start

00:05:14.500 --> 00:05:19.200
a new project, then you're wondering, no matter if it's like a Django website or if it's like

00:05:19.200 --> 00:05:22.580
a Python module, a lot of people know about Cookie Cutter templates.

00:05:22.580 --> 00:05:27.700
And they are a great way to start because you use a template that many people use before you.

00:05:27.820 --> 00:05:30.180
It has a lot of same defaults already set up for you.

00:05:30.180 --> 00:05:35.440
But if you never heard about Cookie Cutter templates, there is like no way you're gonna

00:05:35.440 --> 00:05:40.100
randomly find it because like Cookie Cutter doesn't even have Python in its name.

00:05:40.100 --> 00:05:43.600
So unless you know there is a tool for that, there is like no way for you to find it.

00:05:43.600 --> 00:05:43.960
Right.

00:05:43.960 --> 00:05:44.340
Exactly.

00:05:44.340 --> 00:05:45.620
But it's so super helpful.

00:05:45.620 --> 00:05:46.300
Okay.

00:05:46.300 --> 00:05:46.960
Fantastic.

00:05:46.960 --> 00:05:52.140
Well, we have a bunch of questions from the Ask Us Anything or Ask You Anything that we've

00:05:52.140 --> 00:05:55.920
already gotten because we sent out an email and said, hey, send us your questions.

00:05:55.920 --> 00:05:59.820
We're also, Norbert has a question here in the live chat.

00:05:59.820 --> 00:06:01.580
Which would you like to go with first?

00:06:01.580 --> 00:06:02.920
You want to do the live chat question?

00:06:02.920 --> 00:06:05.060
You want to pick some out of our previous ones?

00:06:05.060 --> 00:06:07.020
So we make sure we get to them since they asked first.

00:06:07.020 --> 00:06:07.520
What are your thoughts?

00:06:07.520 --> 00:06:12.380
So maybe go with the one that we got beforehand because there are some interesting questions

00:06:12.380 --> 00:06:15.320
that we picked up and I think they will be useful to more people.

00:06:15.320 --> 00:06:16.840
And then we will do the live chat.

00:06:16.840 --> 00:06:17.260
Yeah.

00:06:17.260 --> 00:06:17.580
All right.

00:06:17.580 --> 00:06:18.180
That sounds great.

00:06:18.180 --> 00:06:22.160
So folks out there, please keep putting your questions and follow up questions to what we're

00:06:22.160 --> 00:06:24.780
about to talk about in the live chat and we'll get to them.

00:06:24.780 --> 00:06:25.220
All right.

00:06:25.220 --> 00:06:31.980
So the first one is what's the point of setting up something like pyenv using VENV and so on

00:06:31.980 --> 00:06:33.960
when you can just use Docker?

00:06:33.960 --> 00:06:34.500
Yeah.

00:06:34.500 --> 00:06:38.620
So maybe a little bit of background just for people who are like not really sure what these,

00:06:38.620 --> 00:06:40.680
all these things are and then the trade-offs.

00:06:40.680 --> 00:06:41.340
Exactly.

00:06:41.340 --> 00:06:46.140
So pyenv is a tool that you can use to manage different Python versions on your computer.

00:06:46.300 --> 00:06:52.200
So for example, if you want to have Python 3.6, 3.7, 3.8, 3.9 install at the same time

00:06:52.200 --> 00:06:55.080
and easily switch between them, you can use that.

00:06:55.080 --> 00:06:58.820
And then VENV is a tool used to create virtual environments.

00:06:58.820 --> 00:07:03.100
So it's a way to isolate the dependencies of your project.

00:07:03.100 --> 00:07:08.700
So basically you would use pyenv and VENV to isolate Python and Python packages.

00:07:08.700 --> 00:07:09.140
Right.

00:07:09.140 --> 00:07:15.160
So pyenv is getting the version you want and then VENV is isolating that for a particular project, right?

00:07:15.160 --> 00:07:15.720
Exactly.

00:07:15.720 --> 00:07:16.260
Okay.

00:07:16.260 --> 00:07:17.140
They work together.

00:07:17.560 --> 00:07:24.760
And then the same thing could be solved with Docker where you have like Docker image that you use to spin Docker containers

00:07:24.760 --> 00:07:27.220
and everything is isolated inside of it.

00:07:27.220 --> 00:07:33.020
So you have a specific Python version that you choose based on which Docker image you use.

00:07:33.020 --> 00:07:39.160
And then inside this Docker container, you install pip packages and they are isolated from both your computer

00:07:39.160 --> 00:07:42.040
and other Docker images, Docker containers.

00:07:42.040 --> 00:07:45.820
And so coming back to the question, I actually use both.

00:07:45.940 --> 00:07:51.500
I use Docker in a lot of my projects and it's very convenient.

00:07:51.500 --> 00:07:57.140
And especially if you want to later deploy your project or share it with your colleagues.

00:07:57.140 --> 00:08:03.100
But at the same time, I don't want to spin up a Docker image if I just want to run a Python script.

00:08:03.100 --> 00:08:07.980
So I still use pyenv to manage Python versions on my computer.

00:08:07.980 --> 00:08:13.820
So I can use pyenv to install, to change the global version of Python on my computer.

00:08:14.320 --> 00:08:20.840
And I saw that it's already useful for me because sometimes when I'm installing packages with Homebrew,

00:08:20.840 --> 00:08:22.100
by the way, I'm using Mac.

00:08:22.100 --> 00:08:24.380
So Homebrew is the package manager for Mac.

00:08:24.380 --> 00:08:25.660
Yeah, I use Homebrew as well.

00:08:25.660 --> 00:08:30.420
And I think that's also part of the modern pool chain is that you have something that updates your tools.

00:08:30.420 --> 00:08:31.380
Yeah, exactly.

00:08:31.380 --> 00:08:32.320
Automatically.

00:08:32.520 --> 00:08:39.140
And then each time it's installing something, I see that it's trying to install some Python version in the background.

00:08:39.140 --> 00:08:44.680
And at the beginning, I was worried because it was messing up the global Python versions.

00:08:44.680 --> 00:08:49.100
But with pyenv, I have Python versions separated from my system.

00:08:49.100 --> 00:08:52.020
So whatever Homebrew is messing up there, I don't really care.

00:08:52.020 --> 00:08:58.700
I have pyenv that lives in a separate folder and it modifies the system path variables.

00:08:58.700 --> 00:09:02.640
So these separate folders are being read before the system Python.

00:09:02.640 --> 00:09:07.140
And that works in front of the Homebrew.

00:09:07.140 --> 00:09:10.900
So I don't really care what the system Python on my computer.

00:09:10.900 --> 00:09:14.120
By the way, Mac is still using 2.7.

00:09:14.620 --> 00:09:16.600
I don't care what Homebrew is installing.

00:09:16.600 --> 00:09:19.280
I have pyenv and that works really flawless.

00:09:19.280 --> 00:09:29.140
But Docker is also really great because if you want to start a project using a different Python version, you just change one variable in the Docker file and that's it.

00:09:29.140 --> 00:09:29.460
Yeah.

00:09:29.460 --> 00:09:31.400
So there are many benefits to using that.

00:09:31.400 --> 00:09:35.720
I think Docker is really useful and I do use it some of the time.

00:09:35.720 --> 00:09:42.560
But it's not the first tool that I reach for because a lot of times I don't need that complexity.

00:09:42.840 --> 00:09:50.920
You know, if I'm going to say fire up something like, oh, I need Redis just like this and I need Celery like that and I need MongoDB like set up like that.

00:09:50.920 --> 00:09:53.460
And then I want to just make that whole package work together.

00:09:53.460 --> 00:09:57.540
And I really would like it to be exactly on Ubuntu, which is the way I run things in production.

00:09:57.540 --> 00:09:59.540
Then I would definitely reach for Docker.

00:09:59.540 --> 00:10:07.820
But if I just want to just develop one of my web apps or some API I'm working on, chances are running it locally is totally good.

00:10:07.820 --> 00:10:10.200
And it's just fewer things in the mix to worry about.

00:10:10.520 --> 00:10:13.900
So to me, a virtual environment seems totally good for that.

00:10:13.900 --> 00:10:18.880
To me, it's easy to see what everyone is super excited about and then go, oh, I have to do that as well.

00:10:18.880 --> 00:10:24.540
And like that makes sense when there's enough complexity or you're in the same sort of situation that they're also excited about.

00:10:24.540 --> 00:10:26.320
But it doesn't mean it applies everywhere.

00:10:26.320 --> 00:10:32.420
Like if I just wanted to do basic Jupyter work on something that I could run on my machine, I wouldn't necessarily fire up Docker to make that happen.

00:10:32.420 --> 00:10:33.140
Yeah, exactly.

00:10:33.140 --> 00:10:40.060
I want to also point out that this question is specific about using Docker to replace Pi and virtual environments.

00:10:40.060 --> 00:10:42.620
And it's not about using Docker in general.

00:10:42.620 --> 00:10:46.520
I think we have another question coming up later about using Docker in general.

00:10:46.860 --> 00:10:47.940
Yeah, yeah, exactly.

00:10:47.940 --> 00:10:49.020
All right.

00:10:49.020 --> 00:10:55.020
Another thing worth pointing out while we have this on the screen is it doesn't work exactly on Windows, right?

00:10:55.020 --> 00:10:58.960
But there is ienv-win, W-I-N.

00:10:58.960 --> 00:10:59.520
Yeah.

00:10:59.520 --> 00:11:04.180
So the question is, what's the benefit of using that on Windows over, say, Conda?

00:11:04.180 --> 00:11:07.140
And I feel like almost it's like a general question.

00:11:07.140 --> 00:11:13.760
What's the advantages of something like Pi, ENV plus virtual environments and pip over Conda almost?

00:11:13.760 --> 00:11:23.820
I would say if you're using Conda on Windows or whatever operating system and you are happy with it, I don't really see any reason to switch to something else.

00:11:23.980 --> 00:11:31.400
I mean, Conda is like this one huge tool that you can use to manage both Python versions, dependencies, installing packages and stuff like that.

00:11:31.400 --> 00:11:34.040
So I would say if you're happy, just stick with it.

00:11:34.040 --> 00:11:45.640
But if you're not using Conda and for some reason you don't want to use it, but you're on Windows and you want to install different versions of Python, then Py and Win is a great tool to do that.

00:11:45.640 --> 00:11:48.100
Because unlike Conda, it's very specific.

00:11:48.100 --> 00:11:50.820
It's just for managing Python versions.

00:11:51.020 --> 00:11:54.120
It doesn't do a lot of other things that Conda does.

00:11:54.120 --> 00:11:59.340
But if you're looking for this specific type of tool, then I would stick with Py and Win.

00:11:59.340 --> 00:12:04.740
This portion of Talk Python is brought to you by 45 Drives.

00:12:04.740 --> 00:12:10.420
45 Drives offers the only enterprise data storage servers powered by open source.

00:12:10.420 --> 00:12:18.420
They build their solutions with off-the-shelf hardware and use software-defined open source designs that are unmatched in price and flexibility.

00:12:19.200 --> 00:12:25.260
The open source solutions 45 Drives uses are powerful, robust and completely supported from end to end.

00:12:25.260 --> 00:12:30.020
And best of all, they come with zero software licensing fees and no vendor lock-in.

00:12:30.020 --> 00:12:37.480
45 Drives offers servers ranging from 4 to 60 bays and can guide your organization through any sized data storage challenge.

00:12:37.720 --> 00:12:42.180
Check out what they have to offer over at talkpython.fm/45drives.

00:12:42.180 --> 00:12:47.820
If you get in touch with them and say you heard about their offer from us, you'll get a chance to win a custom front plate.

00:12:47.820 --> 00:12:53.400
So visit talkpython.fm/45drives or just click the link in your podcast player.

00:12:53.400 --> 00:13:07.860
I think one of the things that I would point out here is that the conda packages to some degree and certainly the official anaconda version, not initially the Honda Forge version.

00:13:07.860 --> 00:13:10.920
So you'll see if you're going to get a little bit more than the other thing.

00:13:10.920 --> 00:13:11.920
So you'll see if you're going to get a little bit more.

00:13:11.920 --> 00:13:12.920
You'll see if you're going to get a little bit more.

00:13:12.920 --> 00:13:13.920
You'll see if you're going to get a little bit more.

00:13:13.920 --> 00:13:14.920
You'll see if you're going to get a little bit more.

00:13:14.920 --> 00:13:15.920
You'll see if you're going to get a little bit more.

00:13:15.920 --> 00:13:17.980
You'll see if you're going to get a little bit more.

00:13:17.980 --> 00:13:24.060
And then eventually, you know, once it's been verified to be working well and all that, it gets brought into anaconda.

00:13:24.060 --> 00:13:26.980
And generally, that's not a big deal.

00:13:26.980 --> 00:13:30.980
But sometimes if you want to be on the absolute latest, there's a little bit of a delay.

00:13:30.980 --> 00:13:38.980
And the place where absolute latest matters the most is if there's a security vulnerability in an API framework or a web framework.

00:13:38.980 --> 00:13:44.360
You want to update if something like that were to come out, say, with Django, which has happened recently.

00:13:44.360 --> 00:13:49.660
You would like to update to the new version immediately before anybody starts poking around on those things.

00:13:49.660 --> 00:13:55.280
And things like Honda and these other more verified places sometimes lag behind.

00:13:55.280 --> 00:14:00.140
And if it takes a little bit longer to get the latest notebook, UI or whatever, who cares?

00:14:00.140 --> 00:14:09.420
But if there's an active exploit on the Internet against my thing, then you definitely are going to want the latest, latest, latest as soon as possible.

00:14:09.420 --> 00:14:13.020
So I think that's one thing to consider if that's your world.

00:14:13.020 --> 00:14:14.320
That's something I run into.

00:14:14.320 --> 00:14:15.360
Yeah.

00:14:15.360 --> 00:14:15.860
All right.

00:14:15.860 --> 00:14:21.580
Let's take a couple of things out of the live stream comments just because they're follow-ups, right?

00:14:21.580 --> 00:14:25.840
So one question is, what's the best homebrew equivalent for Windows?

00:14:25.840 --> 00:14:27.900
I've got some thoughts, but go ahead, Sebastian.

00:14:27.900 --> 00:14:28.680
Okay.

00:14:28.680 --> 00:14:30.040
I'm not a Windows user.

00:14:30.040 --> 00:14:31.040
I have no idea.

00:14:31.040 --> 00:14:35.460
I've heard about Chocolaty, but I only heard about it.

00:14:35.460 --> 00:14:35.740
Sorry.

00:14:36.240 --> 00:14:36.420
Yeah.

00:14:36.420 --> 00:14:37.460
So.

00:14:37.460 --> 00:14:38.040
Yeah.

00:14:38.040 --> 00:14:42.340
And Crested says Chocolaty and then Scoop and Winget.

00:14:42.340 --> 00:14:47.260
I don't know about Scoop or Winget, but Chocolaty is very much like Homebrew.

00:14:47.260 --> 00:14:48.820
And I'm familiar with that one.

00:14:48.820 --> 00:14:49.940
And that one works pretty well.

00:14:49.940 --> 00:14:51.240
So that's pretty cool.

00:14:51.240 --> 00:14:54.240
But I definitely recommend if you're on Windows, check out Chocolaty.

00:14:54.240 --> 00:14:56.460
If you're on Mac, check out Homebrew.

00:14:56.660 --> 00:15:00.060
And then a lot of the Linux distributions already actually have this, right?

00:15:00.060 --> 00:15:02.160
Like apt on Ubuntu and so on.

00:15:02.160 --> 00:15:05.140
You don't need to go searching for those because that's the primary way.

00:15:05.140 --> 00:15:05.840
Yeah.

00:15:05.840 --> 00:15:12.180
And then finally, Mike Levin says, the best Homebrew equivalent for Windows is an Ubuntu

00:15:12.180 --> 00:15:13.500
repo under WSL.

00:15:13.500 --> 00:15:13.800
Okay.

00:15:13.800 --> 00:15:15.140
That's an interesting one as well.

00:15:15.140 --> 00:15:15.540
But yeah.

00:15:15.540 --> 00:15:17.700
So you also have WSL, but then you have apt as well.

00:15:17.700 --> 00:15:19.120
All right.

00:15:19.120 --> 00:15:19.560
Cool.

00:15:19.560 --> 00:15:20.400
Thank you everyone for that.

00:15:20.400 --> 00:15:23.300
And we'll get back to some of the main questions as well.

00:15:23.300 --> 00:15:25.980
So next one, Sebastian.

00:15:25.980 --> 00:15:28.660
is about Poetry.

00:15:28.660 --> 00:15:33.200
I've been using setup.py in my Python projects, but I see a lot of tutorials recommending other

00:15:33.200 --> 00:15:35.360
tools like pipenv or Poetry.

00:15:35.360 --> 00:15:36.820
Should you switch?

00:15:36.820 --> 00:15:42.760
So basically, Poetry and pipenv can be used to manage projects.

00:15:42.760 --> 00:15:46.140
So they are much more than just like a setup.py replacement.

00:15:46.140 --> 00:15:51.560
Actually, pipenv is not a replacement for setup.py, but I will get to that in a moment.

00:15:51.560 --> 00:15:55.960
So basically, those are like bigger tools that you can use to manage your

00:15:55.960 --> 00:15:56.640
whole project.

00:15:56.640 --> 00:15:59.680
You can use it to like add dependencies, to update dependencies.

00:15:59.680 --> 00:16:02.760
They will manage the virtual environments for you.

00:16:02.760 --> 00:16:05.380
So you don't have to activate anything and things like that.

00:16:05.380 --> 00:16:11.360
And with Poetry, you can also publish packages to pip, which is basically a replacement for

00:16:11.360 --> 00:16:12.140
setup.py.

00:16:12.140 --> 00:16:17.000
You don't need to have setup.py with Poetry, which is kind of convenient because I always

00:16:17.000 --> 00:16:20.160
have to Google out what I should put in the setup.py.

00:16:20.880 --> 00:16:25.100
There is also a package called fleet if you want a lightweight replacement for setup.py,

00:16:25.100 --> 00:16:26.520
but that's an off topic.

00:16:26.520 --> 00:16:34.680
And if you like using setup.py, and again, you don't have a real reason to switch to something

00:16:34.680 --> 00:16:41.960
else, I would say stick with setup.py because that's like the de facto way of doing things

00:16:41.960 --> 00:16:42.440
in Python.

00:16:42.440 --> 00:16:46.200
Setup.py is supported by Python itself.

00:16:46.200 --> 00:16:51.420
There is also this project Toml that is now supported with like recent pip.

00:16:51.420 --> 00:16:55.240
But for many years, setup.py was the way of building packages.

00:16:55.240 --> 00:16:59.300
So I wouldn't just switch for the sake of switching.

00:16:59.300 --> 00:17:05.220
But if you're looking for a tool that can manage your whole project, then I would use either

00:17:05.220 --> 00:17:06.580
pip.env or Poetry.

00:17:06.860 --> 00:17:09.140
And if you want to publish, then I would go with Poetry.

00:17:09.140 --> 00:17:09.840
Yeah.

00:17:09.840 --> 00:17:14.160
And I think you also want to consider, are you building a package or are you building an

00:17:14.160 --> 00:17:14.600
application?

00:17:14.600 --> 00:17:20.140
Because some of the things that you do differently, particularly around like pip.env, is a little

00:17:20.140 --> 00:17:24.320
bit more targeted at building applications than it is packages, from my understanding.

00:17:24.320 --> 00:17:25.560
Yeah, exactly.

00:17:26.020 --> 00:17:32.280
And one thing to consider is that both Poetry and pip.env will be an external dependency for

00:17:32.280 --> 00:17:32.880
your project.

00:17:32.880 --> 00:17:39.480
So if for some reason they break or stop being maintained, then you're gonna have to migrate

00:17:39.480 --> 00:17:40.460
to something else.

00:17:40.460 --> 00:17:47.320
While if you still use setup.py and requirements files, then all the tools are there when you

00:17:47.320 --> 00:17:47.920
install Python.

00:17:47.920 --> 00:17:49.140
Yeah, that's a good point.

00:17:49.140 --> 00:17:52.380
But also, yeah, it's like a bootstrapping step to get started.

00:17:52.380 --> 00:17:57.800
So if you have setup.py, you don't need to install anything else to kind of like check

00:17:57.800 --> 00:17:58.840
it out and try it.

00:17:58.840 --> 00:18:04.100
Whereas, you know, if you have Poetry, the first thing you have to do with a new environment

00:18:04.100 --> 00:18:04.820
is set up Poetry.

00:18:04.820 --> 00:18:07.640
So then you can then initialize all the stuff, right?

00:18:07.640 --> 00:18:08.680
Yeah, exactly.

00:18:08.680 --> 00:18:12.160
I think I was recording an episode for the courses with Poetry.

00:18:12.160 --> 00:18:16.220
And the first package that I wanted to add was the latest pytest.

00:18:16.220 --> 00:18:21.880
And the first command I got was an error because Poetry already had an older version of

00:18:21.880 --> 00:18:23.200
pytest pin down.

00:18:23.200 --> 00:18:26.720
So I had to like open the config file and remove it.

00:18:26.720 --> 00:18:29.740
But the first impression was kind of weird.

00:18:29.740 --> 00:18:31.740
You try to add a package and it breaks.

00:18:31.740 --> 00:18:34.440
But otherwise, I would say it's a good tool.

00:18:34.440 --> 00:18:35.760
If you like it, use it.

00:18:35.760 --> 00:18:38.960
But keep in mind that it's yet another dependency for you.

00:18:38.960 --> 00:18:39.540
Okay.

00:18:39.540 --> 00:18:44.040
Let me ask a follow-up from Incrusted on the live stream.

00:18:45.000 --> 00:18:49.940
What is the best way, if any, for distributing Python applications to non-developers?

00:18:49.940 --> 00:18:54.800
So this conversation of Poetry and PIP-EMV and setup, all that is for developers, right?

00:18:54.800 --> 00:18:55.420
Yeah.

00:18:55.760 --> 00:19:01.880
So what's the story on where's the icon thing I can put my doc or pin to my taskbar and let

00:19:01.880 --> 00:19:02.400
people click?

00:19:02.400 --> 00:19:03.360
What do I do there?

00:19:03.360 --> 00:19:04.620
Yeah, that's a good question.

00:19:04.620 --> 00:19:09.660
I also covered this in the course because I was also looking for a way that you can distribute

00:19:09.660 --> 00:19:12.500
your Python application with people who don't know what Python is.

00:19:12.500 --> 00:19:19.640
And there is this PyInstaller package that you can use to create an executable files that contains

00:19:19.640 --> 00:19:20.440
all the dependencies.

00:19:21.320 --> 00:19:22.960
And it works really great.

00:19:22.960 --> 00:19:29.180
I was able to spin up a Windows machine, create an executable, then spin up another Windows machine

00:19:29.180 --> 00:19:32.560
without even Python installed, move it there, and it was working fine.

00:19:32.560 --> 00:19:34.580
It was using like a graphical user interface.

00:19:34.580 --> 00:19:39.700
The only downside I saw is that they are not cross-compilers.

00:19:39.700 --> 00:19:44.580
So if you want to build an application for Windows, you have to compile it on Windows.

00:19:44.580 --> 00:19:47.560
If you want to build a Mac application, you have to do the same thing on Mac.

00:19:47.980 --> 00:19:53.280
Otherwise, I would say PyInstaller is a really great way to build executable Python binaries.

00:19:53.280 --> 00:19:54.380
Yeah, I agree.

00:19:54.380 --> 00:19:55.800
And so does Patrick Lobiel.

00:19:55.800 --> 00:19:57.020
Hey, Patrick.

00:19:57.020 --> 00:19:57.640
Thanks for that.

00:19:57.640 --> 00:20:00.260
Also add one thing really quick to this.

00:20:00.260 --> 00:20:04.540
I really, really quickly, partly to show it as an example for people, and partly because

00:20:04.540 --> 00:20:06.800
this is the thing that I do all the time.

00:20:06.800 --> 00:20:13.580
I built the little thing, a little Mac menu bar app, 100% in Python, and distributed it as a

00:20:13.580 --> 00:20:16.500
.app file, just like you all are talking about here.

00:20:17.300 --> 00:20:18.500
So I created this thing.

00:20:18.500 --> 00:20:19.180
It looks like this.

00:20:19.180 --> 00:20:20.640
It does a few more things now.

00:20:20.640 --> 00:20:25.340
But if you're copying some title and you want to turn it into a file name, or you want to

00:20:25.340 --> 00:20:29.460
make sure you strip off stuff or clean out the text before you paste it somewhere else,

00:20:29.460 --> 00:20:34.240
I built this little thing that goes in the menu bar, filled it with Python, and it runs

00:20:34.240 --> 00:20:36.640
with PyInstaller, I believe.

00:20:36.640 --> 00:20:38.600
No, that uses PyToApp, actually.

00:20:38.600 --> 00:20:42.000
It's the one that it uses, I think.

00:20:42.260 --> 00:20:44.220
So anyway, there's a couple of options.

00:20:44.220 --> 00:20:49.180
But yeah, it's usually some variation of what you need to do on Windows and on Mac, and you

00:20:49.180 --> 00:20:54.160
actually have to have a Windows machine and you have to have a macOS machine in order to

00:20:54.160 --> 00:20:55.560
create those distributables.

00:20:55.560 --> 00:20:57.140
So kind of a pain there.

00:20:57.340 --> 00:21:01.640
By the way, if someone is wondering what's this PyToApp, because I was checking this as

00:21:01.640 --> 00:21:01.820
well.

00:21:01.820 --> 00:21:06.420
So there is PyInstaller that can be used for Windows, Mac, and Linux distributions.

00:21:06.420 --> 00:21:11.600
And there is this PyToApp that is like a PyInstaller, but for creating Mac application.

00:21:12.080 --> 00:21:16.100
And there's also PyToWin, which is also, again, like a subset of...

00:21:16.100 --> 00:21:17.020
PyToExe, right?

00:21:17.020 --> 00:21:18.360
Yeah, PyToExe.

00:21:18.360 --> 00:21:18.640
Yeah.

00:21:18.640 --> 00:21:21.160
That is like a subset of PyInstaller for Windows.

00:21:21.160 --> 00:21:26.460
I feel like they might be more specific, like covering, you know, adding things like icons and

00:21:26.460 --> 00:21:27.720
other stuff, maybe a little bit better.

00:21:27.720 --> 00:21:28.220
I'm not sure.

00:21:28.220 --> 00:21:32.720
For example, like this one, it has like an icon set that you create for it.

00:21:33.220 --> 00:21:40.000
And the reason I chose PyToApp is this is based on Rumps, which is a ridiculously uncomplicated

00:21:40.000 --> 00:21:42.900
like Mac notifications or something.

00:21:42.900 --> 00:21:47.340
I don't remember what the URL, the acronym stands for, but it's 100% a Mac app.

00:21:47.340 --> 00:21:52.580
So I figured I'd just use the Mac app builder thing for it because there's no chance it's

00:21:52.580 --> 00:21:56.020
running on any other thing because the framework itself is only for Macs.

00:21:56.020 --> 00:21:58.860
So yeah, anyway, let's go to the next question.

00:21:58.860 --> 00:21:59.740
Here we go.

00:21:59.740 --> 00:22:01.260
Which one should I choose?

00:22:01.600 --> 00:22:04.040
PIP, ENV, or Poetry, or something else?

00:22:04.040 --> 00:22:06.760
I would say they are both very similar.

00:22:06.760 --> 00:22:11.840
It's just that Poetry allows you to easily publish packages on PyPI.

00:22:11.840 --> 00:22:15.260
So if you're building a Python package, I would go with Poetry.

00:22:15.260 --> 00:22:19.980
If you're not building a Python package, then I think both should be fine.

00:22:19.980 --> 00:22:21.860
They offer a similar set of functionality.

00:22:21.860 --> 00:22:22.640
Okay.

00:22:22.640 --> 00:22:23.580
Yeah, very cool.

00:22:23.580 --> 00:22:24.280
Very cool.

00:22:24.280 --> 00:22:25.600
Kondo versus pip.

00:22:25.600 --> 00:22:28.600
We sort of touched on this a little bit, but maybe a little more.

00:22:28.600 --> 00:22:29.000
Yeah.

00:22:29.120 --> 00:22:35.080
So that's an interesting question because with Conda, you install binaries from the Conda

00:22:35.080 --> 00:22:35.600
repository.

00:22:35.600 --> 00:22:41.120
While with pip, you install packages from PyPI and they are not always binaries.

00:22:41.120 --> 00:22:45.480
So the main difference is when there is no binary.

00:22:46.120 --> 00:22:50.880
So if there is no binary, pip will try to build this package from sources.

00:22:50.880 --> 00:22:54.200
And if you're missing some dependencies on your computer, then it's going to crash.

00:22:54.200 --> 00:22:54.540
Right.

00:22:54.540 --> 00:22:59.320
If you're on Windows and you see cannot find vcvars.bat, this is the problem.

00:22:59.320 --> 00:22:59.800
Yeah.

00:23:00.100 --> 00:23:03.460
If you're somewhere else and it just fails to install with something that looks like

00:23:03.460 --> 00:23:06.020
a C++ compiler, that's the problem.

00:23:06.020 --> 00:23:08.360
And that's part of the problem what Conda is trying to solve, right?

00:23:08.360 --> 00:23:08.980
Exactly.

00:23:08.980 --> 00:23:14.160
So with Conda, there is no such problem because every package that is published in the Conda

00:23:14.160 --> 00:23:15.440
repository is a binary.

00:23:16.060 --> 00:23:22.280
So it contains all the dependencies, which can be super helpful if you're not like, if you're

00:23:22.280 --> 00:23:26.260
going to have a computer science background or if you're not very experienced with debugging,

00:23:26.260 --> 00:23:29.440
there's missing whatever you said, Mike.

00:23:30.520 --> 00:23:36.380
So let's say you, I don't know, if you're a data scientist and you just want to have your

00:23:36.380 --> 00:23:41.400
code running, you don't care about setting up stuff, you just want to install some packages

00:23:41.400 --> 00:23:42.360
and have it running.

00:23:42.360 --> 00:23:47.480
Conda is an excellent choice because it has like a very good support for all those data

00:23:47.480 --> 00:23:48.120
science packages.

00:23:48.120 --> 00:23:51.080
You just install them, you have all the dependencies installed.

00:23:51.080 --> 00:23:54.440
So it makes things much, much easier in that sense.

00:23:54.440 --> 00:23:54.980
Yeah.

00:23:54.980 --> 00:23:59.380
Especially in the data science world where there's really weird dependencies, like you need a Fortran

00:23:59.380 --> 00:24:02.460
compiler, like I definitely don't have that on my machine.

00:24:02.460 --> 00:24:02.900
Yeah.

00:24:02.900 --> 00:24:06.740
On the other hand, as you already mentioned, Michael, those binaries don't always have the

00:24:06.740 --> 00:24:07.440
latest version.

00:24:07.440 --> 00:24:09.580
So someone first have to create this binary.

00:24:09.580 --> 00:24:13.120
And if there is like a vulnerability, then you have a problem.

00:24:13.120 --> 00:24:19.660
And there might be some like less popular packages that are available on PyPI, but no one created

00:24:19.660 --> 00:24:20.760
a binary for Conda.

00:24:20.760 --> 00:24:25.500
So either you have to wait until someone does that or you have to create it yourself.

00:24:25.500 --> 00:24:25.900
Yeah.

00:24:25.900 --> 00:24:31.780
Because with Conda, you can also install packages from pip, from PyPI, but you basically

00:24:31.780 --> 00:24:33.720
have to build a binary yourself.

00:24:33.720 --> 00:24:38.840
So again, if you're not like very experienced developer, you probably don't know how to do

00:24:38.840 --> 00:24:39.080
this.

00:24:39.080 --> 00:24:39.440
Yeah.

00:24:39.440 --> 00:24:44.240
So I would say like the benefit of using pip is that you can install any package from PyPI

00:24:44.240 --> 00:24:49.180
while with Conda you can't, but with Conda installing things is much easier.

00:24:49.180 --> 00:24:49.620
Yeah.

00:24:49.660 --> 00:24:51.620
I think that sounds like a pretty good summary.

00:24:51.620 --> 00:24:56.060
It's worth pointing out that the workflow is quite different from a virtual environment

00:24:56.060 --> 00:24:57.280
from Conda, right?

00:24:57.280 --> 00:25:00.900
Like Conda, you create the environment off somewhere magical with the name and then you activate

00:25:00.900 --> 00:25:01.900
it by saying the name.

00:25:01.900 --> 00:25:06.420
Whereas pip, it's more, you explicitly say this one here in this location.

00:25:06.420 --> 00:25:06.960
Yeah.

00:25:06.960 --> 00:25:08.940
So Mike Levin has a chat stream.

00:25:08.940 --> 00:25:10.280
I'll go through here.

00:25:10.280 --> 00:25:10.960
Thanks, Mike.

00:25:11.440 --> 00:25:15.640
So Conda was, he says only necessary, I'll say was more necessary before pip included

00:25:15.640 --> 00:25:17.400
binaries, specifically with wheels.

00:25:17.400 --> 00:25:22.260
And now that wheels, it doesn't happen as much pip can replace Anaconda now.

00:25:22.260 --> 00:25:23.200
That's true.

00:25:23.200 --> 00:25:28.400
But Frankie one says, yeah, but not everything has a cross platform wheel as well.

00:25:28.400 --> 00:25:29.940
So I do agree with that.

00:25:29.940 --> 00:25:35.880
For example, MicroWSGI, when I install that, it seems to like compile away for good 30 seconds

00:25:35.880 --> 00:25:40.760
instead of coming with some binary version that can just drop in or so on.

00:25:40.840 --> 00:25:46.220
So yeah, I agree, Mike, that that's generally true, that things are much better now that

00:25:46.220 --> 00:25:49.020
we have wheels, but it's not also that it's not a hundred percent.

00:25:49.020 --> 00:25:49.520
What do you think?

00:25:49.520 --> 00:25:50.860
Yeah, I agree with that.

00:25:50.860 --> 00:25:56.820
And one thing that I want to also add is that while we are talking about binaries and dependencies,

00:25:56.820 --> 00:26:02.600
if you are, let's say, a web developer and you're installing Django or FastAPI, there

00:26:02.600 --> 00:26:06.660
is like very little chance that you're going to be missing some dependencies.

00:26:06.660 --> 00:26:09.200
So you probably will never have problems with pip.

00:26:10.240 --> 00:26:15.660
So for some cases using pip, it's going to be perfectly fine for all your work life.

00:26:15.660 --> 00:26:16.060
Yeah.

00:26:16.060 --> 00:26:18.600
So it's the weirder, farther out it gets.

00:26:18.600 --> 00:26:23.400
Like, like I said, Fortran dependencies with some weird C library or something.

00:26:23.400 --> 00:26:30.320
And then also Joan Pino says, I've used PyInstaller for some side projects and it works really well.

00:26:30.320 --> 00:26:31.180
Yeah, quite cool.

00:26:31.180 --> 00:26:32.620
That's definitely a neat option.

00:26:32.620 --> 00:26:35.400
All right, Sebastian, onto the next.

00:26:35.400 --> 00:26:39.700
How do you hide secrets for development for production?

00:26:39.700 --> 00:26:44.520
We've talked about, I think we haven't talked about yet, but there's, as in secret,

00:26:44.520 --> 00:26:52.600
which is quite unnerving to see, should get going along here and finding all the secrets that people have put into public repos

00:26:52.600 --> 00:26:57.340
or what were private repos, but then got turned public and people are pulling these out.

00:26:57.400 --> 00:27:00.220
That's very much not good.

00:27:00.220 --> 00:27:01.220
This is not what you want to do.

00:27:01.220 --> 00:27:03.540
Just put the secrets right in your source code.

00:27:04.020 --> 00:27:05.180
So what do you do?

00:27:05.180 --> 00:27:06.680
What are your recommendations here?

00:27:06.680 --> 00:27:14.800
So my recommendation is pretty standard to use the environment to hide the, well, the secrets and start them as environment variables.

00:27:15.400 --> 00:27:21.060
And for example, you can have like a file with the YAML extension.

00:27:21.060 --> 00:27:23.640
You can put it in the Git repository.

00:27:23.640 --> 00:27:26.220
It's just, you don't put the secrets there.

00:27:26.220 --> 00:27:29.400
You just put the structure and let's say dummy values or whatever.

00:27:29.560 --> 00:27:33.160
So you remember that you have to set up all those environment variables.

00:27:33.160 --> 00:27:33.580
Right.

00:27:33.580 --> 00:27:41.840
That's one of the challenges because if you put it in environment variables or you put it into the, some like secrets template.yaml versus secrets.yaml,

00:27:41.840 --> 00:27:43.940
where the secrets.yaml is not in the repository.

00:27:44.520 --> 00:27:46.540
In a real project, there's going to be a bunch of stuff.

00:27:46.540 --> 00:27:47.700
You got to have the names just right.

00:27:47.700 --> 00:27:51.720
And you got to like knowing what you're even supposed to fill out for the app to work is a challenge.

00:27:51.720 --> 00:27:56.200
So having this template around is super helpful, but not with the real secrets, right?

00:27:56.200 --> 00:27:56.740
Yeah.

00:27:56.740 --> 00:28:02.700
And there are some libraries that you can use that will make managing those templates much easier for you.

00:28:02.700 --> 00:28:08.760
And why am I saying about those templates is that quite often when there is no template,

00:28:08.760 --> 00:28:13.660
people start putting variables into the environment and they spin up a new server.

00:28:13.860 --> 00:28:19.640
And they realize that they forgot about some environment variables and then things stop working.

00:28:19.640 --> 00:28:27.780
So good practice is to have this like example environment variables file where you list all the variables that have to be set.

00:28:27.780 --> 00:28:37.100
And then you have like a proper environment file that you never put to the GitHub repository where you actually specify the real secrets and then you load it to the environment.

00:28:37.100 --> 00:28:38.020
Yeah.

00:28:38.020 --> 00:28:40.340
And Crested has an interesting location.

00:28:40.340 --> 00:28:42.400
Under a rock.

00:28:43.200 --> 00:28:44.040
Under a rock.

00:28:44.040 --> 00:28:44.260
Yeah.

00:28:44.260 --> 00:28:44.280
Yeah.

00:28:44.280 --> 00:28:51.420
No, but then more seriously points out that there are tools for keeping secrets in version control too, like certain vaults, right?

00:28:51.420 --> 00:29:02.200
Like HashiCorp has something and we've had some sponsors with Talk Python and things where basically set up like the equivalent of one password or LastPass, but for your server, right?

00:29:02.420 --> 00:29:02.860
Yeah, definitely.

00:29:02.860 --> 00:29:02.860
Yeah.

00:29:02.860 --> 00:29:02.940
Definitely.

00:29:02.940 --> 00:29:08.180
If you have to be more careful about your secret, it makes sense to use an external tool.

00:29:08.180 --> 00:29:13.900
But if a lot of those things can be mitigated by setting up the API keys properly.

00:29:13.900 --> 00:29:21.000
For example, if you have like an API key for AWS, you just limit what this account can do.

00:29:21.420 --> 00:29:23.080
And that way you don't spin up.

00:29:23.080 --> 00:29:27.840
If it leaks, then you don't spin up 1000 servers mining Bitcoins for you.

00:29:27.840 --> 00:29:30.820
And then you wake up with like $1 million debt or something like that.

00:29:30.820 --> 00:29:34.780
So there are different ways to mitigate depends on what's the level of risk.

00:29:34.780 --> 00:29:36.280
But the easiest thing is to use the environment.

00:29:36.740 --> 00:29:36.820
Yeah.

00:29:36.820 --> 00:29:38.420
And you can combine them as well, right?

00:29:38.420 --> 00:29:49.100
Like you could have an encryption key in the environment variable and then actually encrypt the other elements in ways and then use instead of, because that way, if it's just in the environment, you could log in.

00:29:49.100 --> 00:29:53.400
If you hack into the process, you could just go, well, OS.env, like what's in here?

00:29:53.400 --> 00:29:54.420
Let's just look around.

00:29:54.420 --> 00:29:58.020
And if it's all full of encrypted stuff, you're like, I don't have no idea how to unencrypt this.

00:29:58.020 --> 00:29:59.880
There's layers, right?

00:29:59.880 --> 00:30:03.820
And obviously running your app is lower privileges is really important.

00:30:03.820 --> 00:30:05.360
Firewalls and isolate.

00:30:05.360 --> 00:30:06.360
There's like layers.

00:30:06.440 --> 00:30:12.600
This is not the only thing, but one of the things is not to put raw passwords and API keys in your source code.

00:30:12.600 --> 00:30:13.140
Cool.

00:30:13.140 --> 00:30:13.560
All right.

00:30:13.560 --> 00:30:14.640
Let's talk Docker again.

00:30:14.640 --> 00:30:15.340
Yeah.

00:30:15.340 --> 00:30:15.860
So.

00:30:15.860 --> 00:30:17.060
Should people use Docker?

00:30:17.060 --> 00:30:17.560
What do you think?

00:30:17.560 --> 00:30:18.240
More broadly.

00:30:18.240 --> 00:30:19.080
Yeah, exactly.

00:30:19.080 --> 00:30:21.140
This is a more broad question than the first one we had.

00:30:21.140 --> 00:30:22.900
It depends who you ask.

00:30:22.900 --> 00:30:26.260
Because there are some people who will tell you that you should always use Docker.

00:30:26.260 --> 00:30:33.720
And when you start using Docker, you should spin up a Kubernetes cluster and then you finally will be able to deploy your almost static block there.

00:30:33.720 --> 00:30:34.620
Yeah.

00:30:34.620 --> 00:30:36.060
But don't listen to those people.

00:30:36.140 --> 00:30:38.760
I mean, it really depends on what you're trying to do.

00:30:38.760 --> 00:30:44.920
Because Docker has those amazing benefits that it makes deploying your application much, much easier.

00:30:45.340 --> 00:30:49.820
So especially when you want to scale something up, Docker really pays off.

00:30:49.820 --> 00:30:58.340
Because for example, let's say you're deploying your website for the first time and probably renting a virtual private server and then installing a Django website there.

00:30:58.600 --> 00:31:07.380
It's easier than writing a Docker file.

00:31:07.380 --> 00:31:10.000
It makes it much easier because you always use the same Docker file.

00:31:10.000 --> 00:31:15.120
And spinning up 100 virtual private servers by hand is probably not something that you want to do.

00:31:16.160 --> 00:31:24.940
There is a higher cost up front.

00:31:24.940 --> 00:31:33.720
And another huge advantage of Docker is that it makes collaborating with people much easier.

00:31:33.720 --> 00:31:40.060
So when I was joining a new team, there were like some setup scripts and you had to install some dependencies and you had to set up some environment variables.

00:31:40.060 --> 00:31:43.680
And then after two days, you were finally able to start coding.

00:31:43.680 --> 00:31:48.300
And now when I joined new projects that are using Docker, it's just two commands.

00:31:48.300 --> 00:31:50.080
Docker build and Docker run.

00:31:50.080 --> 00:31:53.280
And you have this whole work, all development environment running.

00:31:53.280 --> 00:31:54.620
You have the website there.

00:31:54.620 --> 00:31:55.620
You have database.

00:31:55.620 --> 00:31:57.340
You have the ready server, whatever.

00:31:57.340 --> 00:32:01.400
So it makes joining a new team much, much easier.

00:32:01.400 --> 00:32:19.640
On the other hand, let's say if you have like a Python script or like one off script that you want to, I don't know, scrape some data from the internet, there is like absolutely no point in adding yourself more work to write a Docker file if you know that you're going to be throwing away this code like tomorrow.

00:32:19.640 --> 00:32:22.340
So it depends on what's your use case.

00:32:22.340 --> 00:32:26.880
If it's for like simple things, I wouldn't bother unless you really like using Docker.

00:32:26.880 --> 00:32:30.980
But for like more advanced projects, it will probably pay off.

00:32:30.980 --> 00:32:38.300
Yeah, I was speaking with one of the Python listeners having a, what do you think about this and how do we solve this problem type of conversation?

00:32:38.300 --> 00:32:47.120
And it was basically, how do I make sure that everyone on my team has exactly the same version of Python, right?

00:32:47.120 --> 00:32:54.240
I want to make sure that they're using 3.9.2, not 3.9.3, not 3.9.1.

00:32:54.240 --> 00:32:57.620
You definitely don't want one because that has that floating point vulnerability.

00:32:57.620 --> 00:32:58.740
But you know what I mean?

00:32:58.740 --> 00:33:00.460
Like you don't want variation.

00:33:00.560 --> 00:33:01.880
You want exactly that thing.

00:33:01.880 --> 00:33:08.220
And if you really care down to that degree, you know, Docker is great because then you just make everyone run the same Docker image.

00:33:08.220 --> 00:33:16.000
You provide it in some, I don't know, local Docker hub type thing, or just put the Docker file into version control.

00:33:16.000 --> 00:33:19.980
And if it changes, then it just rebuilds and it runs and off you go, right?

00:33:19.980 --> 00:33:20.380
Yeah.

00:33:20.380 --> 00:33:20.940
Yeah.

00:33:20.940 --> 00:33:21.920
So it helps a lot for that.

00:33:21.920 --> 00:33:22.680
But I totally agree.

00:33:22.700 --> 00:33:25.100
I wouldn't use it for like super simple things.

00:33:25.100 --> 00:33:33.400
You're just causing yourself more challenges when often it's not really that useful or that needed, I guess is the way to put it.

00:33:33.860 --> 00:33:36.780
So there's some interesting follow-ups here in the live stream.

00:33:36.780 --> 00:33:43.560
In addition to under a rock, Frankie one says, I thought GitHub now automatically detects when you commit secrets accidentally.

00:33:43.960 --> 00:33:46.020
I think I did hear that it takes an attempt.

00:33:46.020 --> 00:33:49.460
I wouldn't count on GitHub catching all of my secrets.

00:33:49.600 --> 00:33:51.320
I would be more deliberate about it.

00:33:51.320 --> 00:33:52.360
Do you know anything about this?

00:33:52.360 --> 00:33:53.900
Not really.

00:33:53.900 --> 00:33:57.960
I know that there are those bots that check like for the vulnerabilities and stuff like that.

00:33:57.960 --> 00:34:02.380
So I would imagine that it also has a bot to detect secrets in the commits.

00:34:02.380 --> 00:34:03.840
But I'm just wondering how it works.

00:34:03.840 --> 00:34:07.900
Because when you push something to GitHub, it's automatically available there.

00:34:07.900 --> 00:34:14.340
So does GitHub put some blocker on your repo to not show the latest commit?

00:34:14.340 --> 00:34:21.920
Because usually what I see people doing is that they commit, they push a commit with a secret and they realize they push that.

00:34:21.920 --> 00:34:23.900
So they push another commit removing the secret.

00:34:23.900 --> 00:34:27.060
But there are like bots running through GitHub harvesting those.

00:34:27.060 --> 00:34:32.400
So the moment you push it, it's already distributed to some people or to shigit.

00:34:32.400 --> 00:34:33.820
It's too late.

00:34:33.820 --> 00:34:35.020
It's too late.

00:34:35.020 --> 00:34:37.200
The stream has already been observed.

00:34:37.200 --> 00:34:39.180
It's really not good.

00:34:39.600 --> 00:34:45.380
Related to this sort of follow on, I think related to the Docker a little bit, maybe in some ways.

00:34:45.380 --> 00:34:53.520
So THP says, if you're not an expert, Pythonista, how do you manage supply chain, full chain attacks appropriately?

00:34:53.520 --> 00:34:59.260
You want to maybe give people an idea what supply chain vulnerabilities are and then we could talk about this?

00:34:59.260 --> 00:35:01.660
I don't know what our supply chain vulnerabilities.

00:35:01.660 --> 00:35:03.420
I'll give you the run.

00:35:03.420 --> 00:35:08.700
So for example, recently there were about 4,000 malicious packages that were put into PyPI.

00:35:08.700 --> 00:35:17.760
Then there was another vulnerability where if you're running a private PyPI server so that you can have like your team can publish and share packages across applications.

00:35:17.760 --> 00:35:21.700
And then often those will like fall through to the real PyPI.

00:35:21.700 --> 00:35:25.280
So I could just say pip install requests and it'll get the one from PyPI.

00:35:25.280 --> 00:35:28.840
If I say pip install data layer, it'll get our local data layer.

00:35:28.840 --> 00:35:29.780
Right.

00:35:29.780 --> 00:35:39.920
One of the vulnerabilities was if somebody finds a way to publish your private name thing, but to PyPI with a higher version number, pip would prefer that one.

00:35:39.920 --> 00:35:41.480
And go give that.

00:35:41.480 --> 00:35:45.400
But that might be one that is some sort of vulnerability or something along those lines.

00:35:45.400 --> 00:35:45.900
Right.

00:35:45.900 --> 00:35:50.460
So this may be more like more concerning is in PHP.

00:35:50.460 --> 00:35:57.600
Somebody put in some code to run that if you put Xerodium, I believe, as a header.

00:35:57.600 --> 00:36:00.840
I think it was in the headers or no, it was in the user agent.

00:36:00.840 --> 00:36:11.360
If you put the word Xerodium and then some PHP code in the user agent and request it against a PHP site, which 79% of the Internet runs on, I think a lot.

00:36:11.360 --> 00:36:14.040
It would actually just run that arbitrary code.

00:36:14.040 --> 00:36:16.660
So those are the types of things I think that we're talking about here.

00:36:16.660 --> 00:36:17.720
That's a very good question.

00:36:17.720 --> 00:36:27.240
And to be honest, I don't really know how you can mitigate those kind of attacks because like, yeah, the package name typos can happen.

00:36:28.300 --> 00:36:31.020
And there is probably not much you can do.

00:36:31.020 --> 00:36:40.020
The only thing that comes to my mind is to use like a, if you don't know how to solve those problems, it's probably worth paying someone to take care of that.

00:36:40.020 --> 00:36:45.100
So I don't know, maybe using Heroku would be a bit more helpful.

00:36:45.500 --> 00:36:48.680
I don't know how they can mitigate this stuff.

00:36:48.680 --> 00:36:49.600
I don't know.

00:36:49.600 --> 00:36:50.280
What about you, Michael?

00:36:50.640 --> 00:36:51.920
Yeah, I got a couple of ideas.

00:36:51.920 --> 00:36:53.100
None of them are perfect.

00:36:53.100 --> 00:36:54.380
You can pin your versions.

00:36:54.380 --> 00:36:59.680
So you can go and look at all the libraries you're using and say, okay, I trust them as they are now.

00:37:00.180 --> 00:37:11.140
And if you pin the version and your requirements.txt or your pyproject.tml or whatever, you're not going to automatically get the latest version, which may have some kind of vulnerability snuck into it.

00:37:11.140 --> 00:37:15.620
So you can consciously decide to move to the next version.

00:37:15.620 --> 00:37:21.720
Hopefully, you know, if somebody were to hack into Django, maybe that gets out, but it wouldn't last very long.

00:37:21.720 --> 00:37:22.020
Right.

00:37:22.020 --> 00:37:28.200
And so if you don't automatically upgrade on just the next deploy, then you're going to at least be a little bit better off.

00:37:28.200 --> 00:37:30.180
So pin your versions, probably one.

00:37:30.180 --> 00:37:31.980
You could whitelist.

00:37:31.980 --> 00:37:42.420
You can do things like set up a private PyPI server and just whitelist packages so people can't arbitrarily install various things, but they only install ones you approve.

00:37:42.420 --> 00:37:43.700
You can use this thing.

00:37:43.700 --> 00:37:47.360
You can use this as the sneak package advisor.

00:37:47.360 --> 00:37:50.840
So if I want to learn about FastAPI, like what's the story of FastAPI?

00:37:51.280 --> 00:37:54.780
This is cool because it's not just security, but it's more than just security.

00:37:54.780 --> 00:38:13.220
Gives you like the health, the maintainability level or how much it's maintained, whether it has any known security issues, whether community is active, whether it's influential, all sorts of cool graphs about who's working on it, when it's been worked on, amount of funding, security analysis by sneak.

00:38:13.220 --> 00:38:14.560
And so on.

00:38:14.560 --> 00:38:15.900
So this is a pretty good thing.

00:38:15.900 --> 00:38:17.260
So together, right?

00:38:17.320 --> 00:38:26.840
So if I were to say I'm going to pin my versions and then those versions are going to be verified or with or maybe I'm going to create a whitelist and only allow you install from the whitelist.

00:38:26.840 --> 00:38:30.680
And I'll make sure that everything that gets through the whitelist at least has been checked out by sneak.

00:38:30.680 --> 00:38:34.920
Not perfect, but it's better than just pip install random thing and hope for the best.

00:38:35.820 --> 00:38:37.540
So yeah, anyway, let's see.

00:38:37.540 --> 00:38:42.920
And Crested also follows on with is vendoring dependencies an appropriate mitigation?

00:38:43.640 --> 00:38:50.720
Like instead of pip installing requests, like finding the key bits of requests and just copying that code into your application.

00:38:50.720 --> 00:38:52.340
It certainly would help.

00:38:52.340 --> 00:39:01.120
On the downside, if a non-intended vulnerability were to get into requests, not a hack, but just something that was a ultimately became a security hole.

00:39:01.120 --> 00:39:04.440
You've now vendored in that instead of automatically getting the upgrade, right?

00:39:04.440 --> 00:39:05.440
I don't know.

00:39:05.440 --> 00:39:05.900
What do you think?

00:39:06.300 --> 00:39:13.220
Yeah, I think it's easy to do this because you can basically put the virtual environment folder with your project and that's it.

00:39:13.220 --> 00:39:15.600
In the long run, it's probably harder to maintain.

00:39:15.600 --> 00:39:25.020
And I think, as you said, like hitting the dependency versions, making sure you don't have typos probably can save you from a lot of those problems.

00:39:25.020 --> 00:39:28.960
Yeah, be very careful when you pip install something that you get the spelling right.

00:39:28.960 --> 00:39:31.100
Because there was one of those vulnerable ones.

00:39:31.100 --> 00:39:33.880
It was something like asteroids versus asteroid.

00:39:34.580 --> 00:39:37.360
I mean, it was like plural versus singular and that was it.

00:39:37.360 --> 00:39:38.020
Right?

00:39:38.020 --> 00:39:39.420
It's very subtle.

00:39:39.420 --> 00:39:39.980
Yeah.

00:39:39.980 --> 00:39:44.900
And I guess if you're using like more popular packages, then probably should be safe.

00:39:44.900 --> 00:39:54.360
I would say like with some more obscure packages, it can maybe happen that they will get abandoned and someone will either hack the Git repository or like squat it.

00:39:54.360 --> 00:39:59.820
I don't know if it's actually possible with PyPI, but with bigger packages, it's probably not an issue.

00:39:59.820 --> 00:40:00.900
Yeah, for sure.

00:40:00.900 --> 00:40:02.600
I think it's a relative thing.

00:40:02.600 --> 00:40:04.420
So let's see.

00:40:04.420 --> 00:40:08.260
PyLang, hey PyLang, also says you can develop in a VM or Docker.

00:40:08.260 --> 00:40:11.000
And related to that, Doug Farrell.

00:40:11.000 --> 00:40:11.540
Hey, Doug.

00:40:11.540 --> 00:40:15.460
He says, really interested in how to set up a Docker-based development environment.

00:40:15.460 --> 00:40:22.500
So one of the things I think you want to distinguish here in this supply chain thing is I'm trying something out.

00:40:23.700 --> 00:40:29.160
If it's going to run that setup high when I pip install it, it could pip install virus onto my machine.

00:40:29.160 --> 00:40:32.660
If that's your concern, you can develop in a virtual machine.

00:40:32.820 --> 00:40:33.820
You can develop in Docker.

00:40:33.820 --> 00:40:38.640
Because then all it sees is what's inside the Docker machine, which is nothing, basically.

00:40:38.640 --> 00:40:39.640
So that's really cool.

00:40:39.640 --> 00:40:40.780
So that's really cool.

00:40:40.780 --> 00:40:51.680
But also, as Encrusted points out, you know, that if this is developing your application and pushing it to production, that vulnerability comes along onside the web server.

00:40:51.680 --> 00:40:52.920
So that's a challenge, right?

00:40:53.480 --> 00:40:58.720
So in this exploratory world, I think things like Docker actually help a lot solve this problem.

00:40:58.720 --> 00:41:01.420
But in a production world, it does nothing.

00:41:01.420 --> 00:41:02.300
Nothing to help.

00:41:02.300 --> 00:41:05.540
But maybe let's follow on real quick with that.

00:41:05.540 --> 00:41:09.420
I think this development environment based on Docker is pretty interesting.

00:41:09.420 --> 00:41:16.440
For example, PyCharm now lets you set up a Docker image as the run target, which you can even debug into.

00:41:16.440 --> 00:41:19.640
And so you just press run, and it starts the Docker thing.

00:41:19.640 --> 00:41:20.760
It attaches to it.

00:41:20.760 --> 00:41:22.340
You just run it there.

00:41:22.660 --> 00:41:25.240
I think VS Code also has something along these lines.

00:41:25.240 --> 00:41:26.640
What do you think about this?

00:41:26.640 --> 00:41:28.340
Yeah, because I'm using VS Code.

00:41:28.340 --> 00:41:38.860
I was trying to set it up with Docker some time ago, and it was possible to also put the breakpoints there and maybe run, let's say, a Django application in Docker and have breakpoints work there.

00:41:38.860 --> 00:41:41.560
It just requires a bit of setup.

00:41:41.560 --> 00:41:50.680
But I would guess that either by now or soon in the future, the guys from the VS Code will further simplify it.

00:41:50.840 --> 00:41:53.420
Because they just keep adding things to make stuff easier.

00:41:53.420 --> 00:41:53.920
Yeah.

00:41:53.920 --> 00:41:55.820
So it's definitely a viable option.

00:41:55.820 --> 00:41:57.060
Yeah, that sounds good.

00:41:57.460 --> 00:42:01.640
Here is the thing for PyCharm, right?

00:42:01.640 --> 00:42:04.320
I basically configure an interpreter using Docker.

00:42:04.320 --> 00:42:08.980
And just press go, and then boom, off it runs in Docker, which is, I think, pretty awesome.

00:42:11.660 --> 00:42:14.460
Talk Python To Me is partially supported by our training courses.

00:42:14.460 --> 00:42:19.200
Do you want to learn Python, but you can't bear to subscribe to yet another service?

00:42:19.200 --> 00:42:22.460
At Talk Python Training, we hate subscriptions too.

00:42:22.460 --> 00:42:28.020
That's why our course bundle gives you full access to the entire library of courses for one fair price.

00:42:28.020 --> 00:42:29.140
That's right.

00:42:29.140 --> 00:42:35.100
With the course bundle, you save 70% off the full price of our courses, and you own them all forever.

00:42:35.100 --> 00:42:41.200
That includes courses published at the time of the purchase, as well as courses released within about a year of the bundle.

00:42:41.200 --> 00:42:46.680
So stop subscribing and start learning at talkpython.fm/everything.

00:42:49.180 --> 00:42:53.280
Yeah, some comments about this basically being so much about dependencies and stuff.

00:42:53.280 --> 00:42:57.940
But I do think a lot of it really is, it's like, how do you get the right libraries?

00:42:57.940 --> 00:42:59.340
How do you keep those libraries up to date?

00:42:59.340 --> 00:43:00.380
How do you do that securely?

00:43:00.380 --> 00:43:02.380
How do you deploy those things out to the world?

00:43:02.380 --> 00:43:03.340
How do you share that with the user?

00:43:03.340 --> 00:43:06.040
So much of this stuff is a pretty interesting thing to talk about.

00:43:06.040 --> 00:43:13.600
One follow-up here from Doug is, are there resources or links that would help me and everyone understand how to build a Django debuggable Docker environment?

00:43:14.020 --> 00:43:21.200
I think actually, the thing that I have on the screen here, if you're into PyCharm, is one I'll throw that into the live chat here.

00:43:21.200 --> 00:43:27.280
I mean, that is, click these three buttons and then press the debug button and it runs in Docker.

00:43:27.280 --> 00:43:29.740
Do you have something like this for VS Code?

00:43:29.740 --> 00:43:31.840
So what I did, I checked the documentation.

00:43:31.840 --> 00:43:36.320
I think VS Code was also using Django as an example in the documentation.

00:43:36.320 --> 00:43:40.580
So you would have to dig in their docs, but they're pretty easy to follow.

00:43:40.580 --> 00:43:43.320
From the top of my head, I don't know anything.

00:43:43.900 --> 00:43:44.360
Yeah, okay.

00:43:44.360 --> 00:43:45.760
So let's see.

00:43:45.760 --> 00:43:49.920
I think Incrusted has a pretty interesting comment, question here.

00:43:49.920 --> 00:43:54.020
What's the story around code formatters, linters, and type checkers?

00:43:54.020 --> 00:43:56.800
Autocomplete got the better of them there, but no problem.

00:43:56.800 --> 00:43:58.600
Could you be more specific?

00:43:58.600 --> 00:43:59.740
Because I'm not sure.

00:43:59.740 --> 00:44:03.860
Well, yeah, I'm guessing like, did you use black?

00:44:03.860 --> 00:44:05.440
Did you use mypy?

00:44:05.440 --> 00:44:07.560
Things like that, I would guess.

00:44:07.560 --> 00:44:10.120
But yeah, Incrusted, give us a follow-up if you want.

00:44:10.120 --> 00:44:12.320
So I will start and you can clarify the question.

00:44:12.460 --> 00:44:14.840
So I would say definitely use some of those tools.

00:44:14.840 --> 00:44:17.800
Definitely, I would recommend using black.

00:44:18.480 --> 00:44:21.340
Because some people don't like it.

00:44:21.340 --> 00:44:26.460
It's opinionated and you might not like how it formats some code, even though you can actually

00:44:26.460 --> 00:44:32.920
put comments to disable formatting if you want to like preserve your beautifully form, a dictionary

00:44:32.920 --> 00:44:35.400
of list of tuples of dictionaries and stuff like that.

00:44:35.760 --> 00:44:40.900
But if everyone on your team is using code formatter, no matter if it's black or if it's something

00:44:40.900 --> 00:44:45.380
else, then at least during the code reviews, you don't have some silly discussions about

00:44:45.380 --> 00:44:46.440
code styles.

00:44:46.440 --> 00:44:51.880
And I had those discussions in the past and they were terrible because code reviews should

00:44:51.880 --> 00:44:55.620
focus on what's happening in the code, not how the code looks like.

00:44:55.880 --> 00:44:59.160
So definitely some kind of formatter is very, very useful.

00:44:59.160 --> 00:45:01.100
Black is the most popular one.

00:45:01.100 --> 00:45:02.300
It works out of the box.

00:45:02.300 --> 00:45:04.860
So I would suggest using that.

00:45:04.860 --> 00:45:10.900
And speaking of linters, I really like Flake 8, but there's also PyLint.

00:45:11.620 --> 00:45:13.840
And you can actually use both of them.

00:45:13.840 --> 00:45:20.320
And even though I have like, I don't know, eight years, nine years of Python, Flake 8 still

00:45:20.320 --> 00:45:22.840
finds some silly bugs that I'm doing in the code.

00:45:22.840 --> 00:45:28.160
And because like sometimes you're tired, you may like assign to an undefined variables and

00:45:28.160 --> 00:45:28.780
stuff like that.

00:45:28.780 --> 00:45:33.400
So instead of like waiting for your code to actually run and give you this error because

00:45:33.400 --> 00:45:39.200
there is like no compilation, so you can't get the errors beforehand, you immediately can

00:45:39.200 --> 00:45:42.740
get those easy to spot errors for free.

00:45:42.740 --> 00:45:46.460
So definitely spend some time adding them to your code editor.

00:45:46.460 --> 00:45:51.560
And then you can keep going crazy because like Flake 8 has plenty of plugins that you can

00:45:51.560 --> 00:45:52.560
further extend it.

00:45:52.560 --> 00:45:55.500
You have a bunch of other static analysis tools.

00:45:55.500 --> 00:45:57.100
I'm listing them in the course.

00:45:57.100 --> 00:46:01.840
I think there is like a website with the resources for the course that you can find some cool plugins.

00:46:01.840 --> 00:46:06.220
And there is stuff like, for example, Sorcery that I really like that gives you some

00:46:06.220 --> 00:46:08.200
recommendations of how to reformat your code.

00:46:08.200 --> 00:46:12.900
For example, when you're writing a for loop and it's basically building a list, you will

00:46:12.900 --> 00:46:17.120
get a recommendation to use a list comprehension showing you how this list comprehension will

00:46:17.120 --> 00:46:17.520
look like.

00:46:17.520 --> 00:46:19.840
So that's yet another tool that...

00:46:19.840 --> 00:46:20.000
Yeah.

00:46:20.000 --> 00:46:25.020
One of the things about Sorcery that annoyed me quite a bit is in the early days, it would

00:46:25.020 --> 00:46:27.540
recommend all these refactorings.

00:46:27.540 --> 00:46:30.540
And like nine out of 10, I'm like, yeah, that's a great refactoring.

00:46:30.540 --> 00:46:32.740
Other times like, no, this is a horrible refactoring.

00:46:32.740 --> 00:46:34.660
Like, I don't want this change.

00:46:34.880 --> 00:46:39.200
And I know the pattern I'm using is better than this, even though you are your program to think

00:46:39.200 --> 00:46:39.700
this is it.

00:46:39.700 --> 00:46:42.640
And you couldn't disable notification.

00:46:42.640 --> 00:46:48.020
So I just have this permanent mark of a warning on my screen for certain bits of code.

00:46:48.020 --> 00:46:52.340
They recently added a way to add for you to disable that on a per project basis.

00:46:52.340 --> 00:46:54.600
So now I'm also all about Sorcery.

00:46:54.600 --> 00:46:59.340
Now that I can turn off the one or two refactorings that I'm not a huge fan of, and then the rest

00:46:59.340 --> 00:47:00.420
are really nice, like you say.

00:47:00.420 --> 00:47:03.000
Yeah, I didn't have this experience with Sorcery.

00:47:03.000 --> 00:47:03.800
I like it.

00:47:03.800 --> 00:47:07.100
But as I said, there are like plenty of tools, so you can check them out.

00:47:07.100 --> 00:47:09.240
Each of them works in a slightly different way.

00:47:09.240 --> 00:47:10.220
You can combine them.

00:47:10.220 --> 00:47:12.140
You can disable some stuff if you don't like.

00:47:12.140 --> 00:47:15.280
For example, I didn't like piling because it was too strict.

00:47:15.280 --> 00:47:15.720
Yeah.

00:47:15.720 --> 00:47:20.940
Like when you had a class that had too little, too few methods, it was saying like, well,

00:47:20.940 --> 00:47:22.700
this shouldn't be class and stuff like that.

00:47:22.700 --> 00:47:26.780
Right, but maybe you're putting it there because it's going to get bigger in a month as the

00:47:26.780 --> 00:47:32.040
thing grows, but you're like putting that flexibility in now, and it's going to tell you, no, you

00:47:32.040 --> 00:47:34.500
shouldn't have it, right, which is not necessarily the case.

00:47:34.500 --> 00:47:35.020
Exactly.

00:47:35.020 --> 00:47:38.240
I mean, it's trying to make you write the most beautiful code.

00:47:38.240 --> 00:47:41.300
It's just sometimes I prefer my ugly code.

00:47:41.300 --> 00:47:42.200
Yeah.

00:47:42.200 --> 00:47:43.920
Well, yeah, for sure.

00:47:43.920 --> 00:47:45.360
And so a couple other follow-ups.

00:47:45.360 --> 00:47:48.680
Patrick Leveal says, I love using black and flake 8 with pre-commit.

00:47:48.680 --> 00:47:49.460
Very cool.

00:47:50.380 --> 00:47:53.800
The thought, Doug had the same thought as I did, that what he really likes about IDs

00:47:53.800 --> 00:47:58.940
like PyCharm and VS Code and the tools and plugins is that they basically do this while

00:47:58.940 --> 00:47:59.680
you're writing code.

00:47:59.680 --> 00:48:02.020
And to me, like I don't run flake 8 separately.

00:48:02.020 --> 00:48:07.660
I just use PyCharm with all its settings turned on, and it's super obvious if something's wrong.

00:48:07.660 --> 00:48:12.480
And actually what I did when I redid all my stuff with Sorcery, I went through like the

00:48:12.480 --> 00:48:18.560
20,000 lines of Python code that are Talk Python training, and I went and accepted every refactoring

00:48:18.560 --> 00:48:20.160
that Sorcery was giving me.

00:48:20.160 --> 00:48:22.460
Except for that one that I don't like.

00:48:22.460 --> 00:48:27.060
And then while I was going through, I found there's a few PyCharm warnings that I had been

00:48:27.060 --> 00:48:27.400
ignoring.

00:48:27.400 --> 00:48:29.580
They were fine, but they're like, you really should do this other thing.

00:48:29.580 --> 00:48:31.960
And I just fixed everything.

00:48:31.960 --> 00:48:33.220
Got it pristine and perfect.

00:48:33.220 --> 00:48:39.360
And so now I really pay attention to those warnings because there's no like leftover junk warnings.

00:48:39.360 --> 00:48:41.740
And I think that's actually a really big deal about a lot of this.

00:48:41.840 --> 00:48:43.500
And who was it over here?

00:48:43.500 --> 00:48:48.480
Someone, I don't see the comment, maybe I'll find it, but was asking basically, how hard

00:48:48.480 --> 00:48:49.480
do you enforce this?

00:48:49.480 --> 00:48:50.480
Yeah, here you go.

00:48:50.480 --> 00:48:54.400
And Chris, it says, my Py and others should be hard enforced.

00:48:54.400 --> 00:48:55.900
How strictly should you adhere to those?

00:48:55.900 --> 00:49:00.880
Like, for example, do you break continuous integration if some linter fails or something

00:49:00.880 --> 00:49:01.340
like that?

00:49:01.580 --> 00:49:02.720
Yeah, that's a very good question.

00:49:02.720 --> 00:49:06.640
I think it's a matter of how the rest of the teams like it.

00:49:06.640 --> 00:49:11.020
I work with some teams that were like very reluctant to use any of those tools.

00:49:11.020 --> 00:49:16.200
I work with some team leaders that said that CI has to work.

00:49:16.200 --> 00:49:19.660
Your commit has to pass all the CI checks.

00:49:19.660 --> 00:49:22.240
So it's a matter of preference.

00:49:22.240 --> 00:49:25.160
I mean, tools are there to help you, not to hinder you.

00:49:25.300 --> 00:49:30.580
So if some tool doesn't work well for you, you should kind of configure it or maybe replace

00:49:30.580 --> 00:49:30.800
it.

00:49:30.800 --> 00:49:31.400
Sure.

00:49:31.400 --> 00:49:37.720
So I know one question that we had kind of queued up and some people maybe a little bit

00:49:37.720 --> 00:49:41.560
touched on it, but we haven't really talked about the language hardly at all, have we?

00:49:41.560 --> 00:49:43.160
Like using language features and stuff.

00:49:43.160 --> 00:49:47.560
So what do you think about things like Hypen's, like this kind of stuff?

00:49:47.560 --> 00:49:49.620
Yeah, that's another sensitive topic.

00:49:49.620 --> 00:49:52.420
I would say they can be definitely useful.

00:49:52.900 --> 00:49:58.140
I mean, if you, especially if you have like a lot of code, some legacy code, being able

00:49:58.140 --> 00:50:03.200
to immediately see what are the argument types that the given function takes, what's the return

00:50:03.200 --> 00:50:09.240
value, what's the type of the return value a function returns in your code editor, it's

00:50:09.240 --> 00:50:09.980
super useful.

00:50:09.980 --> 00:50:10.460
Yeah.

00:50:10.460 --> 00:50:16.460
And even though with Python, we have duck typing, so we can get quite far with this.

00:50:16.460 --> 00:50:19.820
There can be some subtle bugs that type hints can help you.

00:50:20.960 --> 00:50:27.460
But the thing with type hints is, well, my problem with type hints is the same problem

00:50:27.460 --> 00:50:29.040
as with test and documentation.

00:50:29.040 --> 00:50:33.400
It's not strictly a problem, but it's a yet another thing that you have to take care of.

00:50:33.400 --> 00:50:37.820
I'm not saying I don't like writing type hints, but for example, let's say you're writing code

00:50:37.820 --> 00:50:39.580
and then you have to add tests.

00:50:39.580 --> 00:50:43.860
You have to add documentation and you have to add type hints and then you code changes and

00:50:43.860 --> 00:50:45.340
you have to update all three places.

00:50:45.840 --> 00:50:49.760
Because it's not only about updating tests and documentation, you also have to make sure

00:50:49.760 --> 00:50:54.340
that your type hints are updated because you have wrong type hints and they are useless.

00:50:54.340 --> 00:50:54.840
Yeah.

00:50:54.840 --> 00:50:58.360
And of course there are tools like mypy, but they are external tools.

00:50:58.360 --> 00:50:59.880
So you have to configure them.

00:50:59.880 --> 00:51:03.040
And at the beginning, you'll probably have a lot of warnings and stuff like that.

00:51:03.040 --> 00:51:08.360
So I would say that type hints will give you back as much love as you give them.

00:51:08.360 --> 00:51:13.620
So if you spend time making sure that the type hints are properly declared, that you're not

00:51:13.620 --> 00:51:19.360
using any in all around your code, then they are going to be very, very useful.

00:51:19.820 --> 00:51:19.940
Yeah.

00:51:19.940 --> 00:51:26.180
I absolutely love the type hints, but I think you should remain Pythonic as you think about

00:51:26.180 --> 00:51:26.540
using them.

00:51:26.540 --> 00:51:31.160
So there's, I think there's two blends is one is do you want to go down the mypy, have the

00:51:31.160 --> 00:51:36.640
checkers completely verify everything is absolutely hanging together like C# or C++

00:51:36.640 --> 00:51:39.360
compilers do like it's a hundred percent.

00:51:39.360 --> 00:51:41.640
This is an integer and everywhere it's an integer.

00:51:42.380 --> 00:51:43.960
So you like lay all that out.

00:51:43.960 --> 00:51:45.860
That's one way of using these.

00:51:45.860 --> 00:51:49.920
The other way, which is the way that I like is put them on the boundaries, right?

00:51:49.920 --> 00:51:54.440
If I'm creating a package and I want to put that package on PyPI, it would be awesome if

00:51:54.440 --> 00:52:00.160
the public API of that package all had type hints or type annotations, because then when

00:52:00.160 --> 00:52:04.540
I use it, I know automatically my editor knows automatically, am I doing the right thing or the

00:52:04.540 --> 00:52:07.660
wrong thing without having to constantly dive into the documentation?

00:52:07.660 --> 00:52:12.360
Is this a string or a class that contains the information that I'm supposed to pass?

00:52:12.360 --> 00:52:14.500
for location, right?

00:52:14.500 --> 00:52:19.380
Is that a quote Portland comma Oregon or is it a location object?

00:52:19.380 --> 00:52:22.560
But those two things said or a dictionary or what the heck goes in here, right?

00:52:22.560 --> 00:52:24.780
Like those kinds of answers just go away instantly.

00:52:24.780 --> 00:52:28.840
And when you're using it wrong, your editors will like put some kind of squiggly or something

00:52:28.840 --> 00:52:30.320
and say, no, no, you're using it wrong.

00:52:30.320 --> 00:52:35.260
And I think that's the biggest value of type hints is like right on those boundaries where

00:52:35.260 --> 00:52:37.680
you're maybe unfamiliar with it or something.

00:52:37.680 --> 00:52:39.440
It'll really communicate that across.

00:52:39.440 --> 00:52:39.840
Yeah.

00:52:39.840 --> 00:52:46.060
I wouldn't use type hints on like throwaway code, but I usually try to start to add them

00:52:46.060 --> 00:52:47.380
as my project grows bigger.

00:52:47.380 --> 00:52:51.620
So for like small project, it's easy to kind of understand what's going on, but as it keeps

00:52:51.620 --> 00:52:55.640
growing, it really pays off to start adding type hints.

00:52:55.640 --> 00:52:56.980
Yeah, for sure.

00:52:56.980 --> 00:52:58.080
All right.

00:52:58.080 --> 00:53:02.080
Getting short on our time here, but I know there's a couple of people who got in right at the beginning

00:53:02.080 --> 00:53:07.300
and we kind of skipped over it a little bit just because we were getting to the pre-questions

00:53:07.300 --> 00:53:07.560
first.

00:53:07.560 --> 00:53:10.260
But Patrick Lobiel has one that I think is worth touching about.

00:53:10.260 --> 00:53:14.900
What do you think that good Python GUI development, why do you think they're rare, especially for

00:53:14.900 --> 00:53:18.480
beginners, you know, real UI is way more motivating than terminal output?

00:53:18.480 --> 00:53:20.260
I agree that it is way more motivating.

00:53:20.640 --> 00:53:26.300
And I also agree that we're quite short on good UI development, GUI development options.

00:53:26.300 --> 00:53:27.020
Sebastian?

00:53:27.020 --> 00:53:27.560
Yeah.

00:53:27.560 --> 00:53:28.540
Same opinion.

00:53:28.540 --> 00:53:34.080
I was never using a lot of GUI, so I'm not very familiar how many tutorials are there, but

00:53:34.080 --> 00:53:40.700
I was building one for the course and I decided to use TK-Inter because it comes with Python.

00:53:41.700 --> 00:53:44.860
And there weren't that many tutorials, you're right.

00:53:44.860 --> 00:53:49.260
I found one that was very useful because it was showing a lot of different components of

00:53:49.260 --> 00:53:49.940
TK-Inter.

00:53:49.940 --> 00:53:57.260
But apart from that, I would say there weren't many showing you how to build some specific

00:53:57.260 --> 00:54:02.240
thing, like a specific project or something like that.

00:54:02.240 --> 00:54:02.740
Yeah.

00:54:02.740 --> 00:54:08.660
I just dream of the days when we got something like VB6 or Windows Forms was in .NET where

00:54:08.660 --> 00:54:10.180
you just have a nice UI thing.

00:54:10.180 --> 00:54:11.360
Oh, here's a button.

00:54:11.480 --> 00:54:12.060
Here's a text box.

00:54:12.060 --> 00:54:12.820
You put it over there.

00:54:12.820 --> 00:54:14.420
You want code to run, you double click it.

00:54:14.420 --> 00:54:15.740
You write the three lines of code.

00:54:15.740 --> 00:54:16.640
You go back to working.

00:54:16.640 --> 00:54:20.340
Like you push a button, you get a thing that you distribute to people's applications.

00:54:20.340 --> 00:54:25.820
Like I don't really understand why we don't have something like that in Python where it's

00:54:25.820 --> 00:54:28.080
sort of a visual layout, push a button.

00:54:28.080 --> 00:54:31.160
It does something, PyInstaller magic, PyToApp magic.

00:54:31.160 --> 00:54:32.340
Here's your app.

00:54:32.340 --> 00:54:33.140
Give it to someone.

00:54:33.140 --> 00:54:36.860
Like that would be transformative and we just, we don't have it.

00:54:36.860 --> 00:54:40.220
I think it's a bit of a chicken and egg thing, but one can dream, one can dream.

00:54:40.220 --> 00:54:40.560
All right.

00:54:40.900 --> 00:54:45.220
Norbert Patrick also talks about some enterprise development stuff.

00:54:45.220 --> 00:54:50.600
What's your take on things like Azure Active Directory and security topics like DB encryption,

00:54:50.600 --> 00:54:53.360
major cloud platform deployments and so on.

00:54:53.360 --> 00:54:55.740
Bit of an open-ended one, but what are your thoughts generally?

00:54:55.740 --> 00:55:00.280
I have almost no experience with Azure.

00:55:00.280 --> 00:55:03.640
And yeah, as you said, it's kind of a broad topic.

00:55:03.640 --> 00:55:08.420
So don't really know what to say here without like a specific question.

00:55:08.540 --> 00:55:09.740
I'll throw a few things out there.

00:55:09.740 --> 00:55:13.100
One, Azure Active Directory seems pretty interesting to me.

00:55:13.100 --> 00:55:18.240
One of the things that's an ultra pain is federated identity or trusting other people's identity.

00:55:18.240 --> 00:55:23.080
Like if I want to let all of your users single sign on at your place and then single sign on

00:55:23.080 --> 00:55:25.640
on my site, like that's not an easy thing to do right now.

00:55:25.720 --> 00:55:28.220
And I think Azure Active Directory makes that quite easy.

00:55:28.220 --> 00:55:32.240
I haven't done a lot with it, but in that use case, I think it's pretty useful.

00:55:32.240 --> 00:55:38.780
I honestly don't do much with Active Directory at all, like corporate accounts and like building public web apps and things like that.

00:55:38.780 --> 00:55:40.340
So that they don't make sense in that world.

00:55:40.340 --> 00:55:41.660
Database encryption.

00:55:41.660 --> 00:55:43.060
Very interesting.

00:55:43.520 --> 00:55:44.640
There's a lot of levels.

00:55:44.640 --> 00:55:46.280
Is this data encrypted at rest?

00:55:46.280 --> 00:55:47.400
Is it encrypted in memory?

00:55:47.400 --> 00:55:49.100
Is it encrypted in the response?

00:55:49.100 --> 00:55:52.560
A lot of the modern databases have like encrypted columns.

00:55:52.560 --> 00:55:56.420
For example, MongoDB has different encrypted columns you can have.

00:55:56.420 --> 00:56:02.220
And then certain clients, as they talk to it, they either may or may not be permitted to decrypt that column.

00:56:02.220 --> 00:56:06.880
So it could return all the columns or values without overexposing the data potentially.

00:56:07.080 --> 00:56:10.960
I don't do anything like that, but also encrypting backups, right?

00:56:10.960 --> 00:56:14.320
Like, what do you think about, I got to take a backup of the database.

00:56:14.320 --> 00:56:14.980
Now what?

00:56:14.980 --> 00:56:20.440
This is like the worst possible thing I could lose is the backup to the database, right?

00:56:20.440 --> 00:56:23.220
It's the only thing worse is letting people get access to the live database.

00:56:23.220 --> 00:56:25.120
I don't got thoughts on that.

00:56:25.120 --> 00:56:26.460
Like, do you have any recommendations?

00:56:26.460 --> 00:56:29.780
I can tell people what I've been doing lately, but it's not perfect.

00:56:29.780 --> 00:56:31.740
No, I will leave this question to you.

00:56:31.740 --> 00:56:35.060
So I've been using like an encrypted volumes.

00:56:35.260 --> 00:56:39.280
Like in Mac, you can create virtual encrypted volumes that you can just open and close.

00:56:39.280 --> 00:56:41.040
Like highly, highly encrypted.

00:56:41.040 --> 00:56:43.400
And so, but it appears as a drive.

00:56:43.400 --> 00:56:49.020
So I've been doing my backups lately straight to that thing and then closing the encrypted vault

00:56:49.020 --> 00:56:51.860
when I'm not actively backing up a database.

00:56:51.860 --> 00:56:54.840
So then I put that somewhere safe.

00:56:54.840 --> 00:57:00.620
But if for some reason something were to happen to it, at least what they get hold of is an encrypted

00:57:00.620 --> 00:57:03.600
vault with a huge password that they probably can't mess with.

00:57:03.600 --> 00:57:04.980
So I don't know.

00:57:04.980 --> 00:57:06.140
Lots to think about.

00:57:06.140 --> 00:57:08.380
Lots to be up late at night worrying about.

00:57:08.380 --> 00:57:09.100
Yeah.

00:57:09.100 --> 00:57:12.120
And then Vincent throws out there, we have VB style and Anvil.

00:57:12.120 --> 00:57:14.220
And yes, Anvil was certainly on my mind.

00:57:14.220 --> 00:57:15.940
I didn't quite call it out, but.

00:57:15.940 --> 00:57:19.700
I forgot about it, but then I remember them from some conferences and yeah.

00:57:19.700 --> 00:57:21.720
Anvil is really interesting in that it has that.

00:57:21.720 --> 00:57:26.420
It's the thing that that's different here is what you get is Anvil is super neat, but you

00:57:26.420 --> 00:57:29.580
do get a specific type of web application.

00:57:29.580 --> 00:57:35.900
But if that specific type of web application works for you, then they do have this VB style,

00:57:35.900 --> 00:57:39.160
drag and drop, double click, run your code, which is absolutely beautiful.

00:57:39.580 --> 00:57:48.600
But if I wanted to build Todoist or one password in Python, there's no real way to do that nicely.

00:57:48.600 --> 00:57:54.060
I think one nice thing about Anvil is that it actually generates a nice code that is readable.

00:57:54.320 --> 00:58:02.600
Because the one problem I have with this, what you see is what you get text editors is that I remember them from the time when you were building websites like that.

00:58:02.600 --> 00:58:06.060
And the resulting HTML was an abomination.

00:58:06.060 --> 00:58:08.520
You just couldn't modify it by hand anymore.

00:58:08.520 --> 00:58:15.100
So I'm worried that if we get tools like that for Python, it's also going to result in like unreadable code.

00:58:15.100 --> 00:58:18.700
But I know that Anvil actually generates a pretty nice code.

00:58:18.900 --> 00:58:24.560
Yeah, I remember some of the tools you would look at the, here's the auto generated code.

00:58:24.560 --> 00:58:26.980
And it was like, basically, there's giant comments.

00:58:26.980 --> 00:58:27.800
Don't touch this.

00:58:27.800 --> 00:58:28.740
Don't try to read this.

00:58:28.740 --> 00:58:29.580
Just leave it alone.

00:58:29.580 --> 00:58:32.460
Any attempt to mess with it will probably just break everything.

00:58:32.460 --> 00:58:34.040
Don't touch it.

00:58:34.040 --> 00:58:37.500
So Doug also thinks Anvil is awesome.

00:58:37.500 --> 00:58:38.200
Yeah, very cool.

00:58:38.200 --> 00:58:41.420
And it used to be it had to run on the Anvil cloud.

00:58:41.420 --> 00:58:44.880
I believe they've open sourced their runtime so you can like self host it and stuff.

00:58:44.880 --> 00:58:45.920
That's worth checking out.

00:58:46.120 --> 00:58:50.840
And then, I don't know, maybe, maybe this is the last, last comment.

00:58:50.840 --> 00:58:52.180
I'd say maybe one more out there.

00:58:52.180 --> 00:58:53.660
We're throwing out something out there.

00:58:53.660 --> 00:59:01.040
But Kristen says, are there any courses out there that teach you how to get started with a lot of what we're talking about without any background knowledge?

00:59:01.040 --> 00:59:07.600
I certainly will give another shout out to your course, Sebastian, Modern Python Projects over at Talk Python Training.

00:59:07.940 --> 00:59:15.560
That is definitely a great course that goes deep into all these things, like nine hours of conversation of like, here's my screen.

00:59:15.560 --> 00:59:16.640
Let's go do these things.

00:59:16.640 --> 00:59:18.840
Is it with no background knowledge?

00:59:18.840 --> 00:59:21.200
I mean, you do have to know Python, right, to do this.

00:59:21.200 --> 00:59:23.920
So basically, what are the assumptions for your course?

00:59:23.920 --> 00:59:25.460
You have to know Python.

00:59:25.460 --> 00:59:26.720
And that's it.

00:59:26.720 --> 00:59:30.140
I show you a lot of those tools, but I always start from scratch.

00:59:30.140 --> 00:59:34.860
Like, I even had like empty macOS accounts.

00:59:34.860 --> 00:59:38.720
So I made sure that I don't miss some dependencies and stuff like that.

00:59:38.720 --> 00:59:42.780
I also like spin up a Windows VM for some parts that require Windows.

00:59:42.780 --> 00:59:45.900
So I think you should be good with just knowing Python.

00:59:46.320 --> 00:59:46.680
Yeah.

00:59:46.680 --> 00:59:47.260
Okay.

00:59:47.260 --> 00:59:49.080
A couple of real quick ones here.

00:59:49.080 --> 00:59:51.100
Doug says, oh, man, yes.

00:59:51.100 --> 00:59:52.640
Visual Python would be amazing.

00:59:52.640 --> 00:59:53.600
I like Visual Basic.

00:59:53.600 --> 00:59:54.060
I agree.

00:59:54.060 --> 00:59:58.180
And then THP says, Fman build system is a pretty cool.

00:59:58.180 --> 01:00:04.300
Fman is a pretty cool UI in the Fman build system for building those things up and distributed.

01:00:04.300 --> 01:00:05.120
And that's pretty interesting.

01:00:05.120 --> 01:00:06.280
I haven't done anything with Fman.

01:00:06.280 --> 01:00:06.520
Have you?

01:00:06.520 --> 01:00:07.000
No.

01:00:07.000 --> 01:00:08.220
First time I heard the name.

01:00:08.220 --> 01:00:08.760
Yeah.

01:00:08.760 --> 01:00:11.880
It's like a file management tool, I believe, in Python.

01:00:11.880 --> 01:00:15.940
The person who created it then also built this build system and this UI on top of it.

01:00:16.080 --> 01:00:16.880
So pretty interesting.

01:00:16.880 --> 01:00:17.660
Looks cool.

01:00:17.660 --> 01:00:18.280
Let's see.

01:00:18.280 --> 01:00:20.000
There's another one from Joan.

01:00:20.000 --> 01:00:25.600
Is Quart and its async capabilities ready to level up Flask webmaps for medium-sized enterprises

01:00:25.600 --> 01:00:27.460
or currently better to stick with Flask?

01:00:27.460 --> 01:00:29.100
I have no experience with Quart.

01:00:29.100 --> 01:00:30.000
So I don't know.

01:00:30.000 --> 01:00:30.720
What about you, Michael?

01:00:30.720 --> 01:00:31.380
None.

01:00:31.380 --> 01:00:36.540
I mean, I interviewed the guy who did it and I've played around with it and it seems okay.

01:00:36.540 --> 01:00:40.320
But at enterprise, like it's got to be five nines level of up.

01:00:40.320 --> 01:00:41.880
I've never run anything like that.

01:00:41.880 --> 01:00:46.060
Honestly, if I was really, really looking to build a web app with async capabilities,

01:00:46.060 --> 01:00:49.300
I would either look at FastAPI or Starlet.

01:00:49.300 --> 01:00:54.680
Like I know people might think, oh, with FastAPI, that's an API thing, not a web thing.

01:00:54.680 --> 01:00:58.980
But to be honest, you know, it can be, definitely can be done.

01:00:58.980 --> 01:01:03.400
And I actually built a whole class on how to take FastAPI and sort of replace Flask with it.

01:01:04.100 --> 01:01:05.480
So it's not that hard.

01:01:05.480 --> 01:01:08.340
It supports templates, supports static files, all those kinds of things.

01:01:08.340 --> 01:01:09.700
It is super cool.

01:01:09.700 --> 01:01:13.780
And yeah, thanks Norbert for the shout out on the 10 apps course.

01:01:13.780 --> 01:01:14.820
That's really a fun one.

01:01:14.820 --> 01:01:18.840
But yeah, so I think actually if I was trying to go all in on async,

01:01:18.840 --> 01:01:23.900
I feel like FastAPI is one of the best async frameworks out there.

01:01:23.900 --> 01:01:26.000
It's just, it all holds together really, really well.

01:01:26.220 --> 01:01:27.640
So, all right.

01:01:27.640 --> 01:01:29.760
Yeah, I think that might be it.

01:01:29.760 --> 01:01:34.280
Sebastian, you want to just maybe give us some wrap up thoughts here on this whole idea?

01:01:34.280 --> 01:01:35.480
Well, thank you for coming.

01:01:35.480 --> 01:01:36.900
And thank you for those questions.

01:01:36.900 --> 01:01:37.780
They were really great.

01:01:37.780 --> 01:01:41.200
And I hope we answered all of them.

01:01:41.780 --> 01:01:44.440
Yeah, I think, you know, there's so much variety.

01:01:44.440 --> 01:01:47.760
I've worked in different technologies over the years.

01:01:47.760 --> 01:01:49.740
I've been doing development like 25 years or so.

01:01:49.740 --> 01:01:56.040
And some of the time you'll find some language or some ecosystem where there's sort of a central,

01:01:56.040 --> 01:02:00.580
like this is how you do things, like specifically in the Microsoft space with .NET.

01:02:00.580 --> 01:02:03.000
Here's the one web framework you use.

01:02:03.000 --> 01:02:07.820
Here's the one database ORM you use to talk to the one database you use.

01:02:07.820 --> 01:02:11.000
And while that's really helpful, now I know what to do.

01:02:11.000 --> 01:02:12.500
I do these four things and I'm good.

01:02:12.500 --> 01:02:13.780
This is the recommended way.

01:02:13.780 --> 01:02:15.020
In Python, we don't have that.

01:02:15.020 --> 01:02:21.360
And that's absolutely a blessing, but it's something of a curse as well in that there's

01:02:21.360 --> 01:02:22.780
this paradox of choice, right?

01:02:22.780 --> 01:02:24.100
Oh, it's amazing.

01:02:24.100 --> 01:02:25.400
We have this cool ORM library.

01:02:25.400 --> 01:02:26.400
Oh, wait, there's 10.

01:02:26.400 --> 01:02:29.340
Well, if there's 10 ORM libraries, which one should I choose?

01:02:29.340 --> 01:02:30.980
And we were having this conversation.

01:02:30.980 --> 01:02:31.920
Should we use Flask?

01:02:31.920 --> 01:02:32.900
Should we use FastAPI?

01:02:32.900 --> 01:02:34.480
Should we use Court on top of Flask?

01:02:34.480 --> 01:02:35.780
Should we use Django?

01:02:35.780 --> 01:02:40.880
Like you can just go on and on and on about all the trade-offs that you have to make.

01:02:40.940 --> 01:02:46.620
So I think one of the big challenges is choosing a path and then going down it.

01:02:46.620 --> 01:02:52.380
Choosing, say, I'm going to use Poetry, Flask, Microwisgee, let's go, or something like that.

01:02:52.380 --> 01:02:54.780
Whatever your branch that you happen to follow.

01:02:54.780 --> 01:02:56.620
I think that's a big challenge.

01:02:56.620 --> 01:03:01.020
And maybe I'll throw out one more thing for people out there on the live stream, if I can

01:03:01.020 --> 01:03:04.980
pull it up quick enough, is awesome-python.com.

01:03:04.980 --> 01:03:07.260
Awesome-python.com.

01:03:07.660 --> 01:03:10.600
This kind of helps at least narrow that list, right?

01:03:10.600 --> 01:03:17.200
So for example, if I'm interested in caching, like here are probably the eight most popular

01:03:17.200 --> 01:03:20.060
caching libraries that you might use or something like that.

01:03:20.060 --> 01:03:24.040
It's not perfect, but at least it gives you some way to explore when you're totally new.

01:03:24.040 --> 01:03:28.060
Because I think that that's one of the big challenges here, Sebastian, is not that there

01:03:28.060 --> 01:03:33.580
are not enough choices, but there are so many choices at each step of the way that that's

01:03:33.580 --> 01:03:34.540
a challenge, right?

01:03:34.540 --> 01:03:37.620
There's the t-shirt, I learned Python in a weekend.

01:03:37.620 --> 01:03:38.800
It was, I learned Python.

01:03:38.800 --> 01:03:40.300
It was a great weekend, right?

01:03:40.300 --> 01:03:42.760
Like that's funny and also kind of true at the language level.

01:03:42.760 --> 01:03:44.800
But I don't know about how you feel, Sebastian.

01:03:44.800 --> 01:03:48.260
I'm still learning Python after so many years and spending all day in it.

01:03:48.260 --> 01:03:50.820
Yeah, same here and like tools come and go.

01:03:50.820 --> 01:03:55.020
I bet in like five years, this list will be completely different than it is now.

01:03:55.020 --> 01:04:01.380
So it's definitely important to spend some time trying to figure out which tool you should

01:04:01.380 --> 01:04:01.760
use.

01:04:01.760 --> 01:04:05.960
Because as you say, with Python, you can mix and match different tools.

01:04:05.960 --> 01:04:09.380
And sometimes there are like no tutorials explaining how to do things.

01:04:09.380 --> 01:04:15.300
Sometimes the tool might get popular, but then it's abandoned and it's no longer maintained.

01:04:15.840 --> 01:04:18.640
So yeah, I mean, a lot of tools to choose from.

01:04:18.640 --> 01:04:20.240
Yeah, I guess we'll leave with that.

01:04:20.240 --> 01:04:24.120
There's a lot of tools to choose from and we've covered a bunch of options and a lot of trade

01:04:24.120 --> 01:04:24.440
ops here.

01:04:24.440 --> 01:04:27.240
So Sebastian, it's been great to chat with you about that.

01:04:27.240 --> 01:04:28.340
Thanks for coming on the live stream.

01:04:28.340 --> 01:04:28.860
Thank you.

01:04:28.860 --> 01:04:29.480
Likewise.

01:04:29.480 --> 01:04:30.540
It was great to talk with you.

01:04:30.540 --> 01:04:31.620
Yeah, you as well.

01:04:31.620 --> 01:04:35.420
And thank you everyone for all the questions, those who emailed them in previously and the

01:04:35.420 --> 01:04:36.080
live ones.

01:04:36.080 --> 01:04:37.200
It was a great conversation.

01:04:37.200 --> 01:04:38.400
See you around next time.

01:04:38.400 --> 01:04:39.100
Bye guys.

01:04:39.100 --> 01:04:42.360
This has been another episode of Talk Python to Me.

01:04:42.360 --> 01:04:45.360
Our guest in this episode was Sebastian Witwowski.

01:04:45.360 --> 01:04:49.680
And it's been brought to you by 45 drives and us over at Talk Python training.

01:04:49.680 --> 01:04:54.180
Solve your storage challenges with hardware powered by open source.

01:04:54.180 --> 01:05:01.120
Check out 45 drives storage servers at talkpython.fm/45 drives and skip the vendor lock-in

01:05:01.120 --> 01:05:02.520
and software licensing fees.

01:05:02.520 --> 01:05:04.360
Want to level up your Python?

01:05:04.760 --> 01:05:08.420
We have one of the largest catalogs of Python video courses over at Talk Python.

01:05:08.420 --> 01:05:13.580
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:05:13.580 --> 01:05:16.260
And best of all, there's not a subscription in sight.

01:05:16.260 --> 01:05:19.160
Check it out for yourself at training.talkpython.fm.

01:05:19.160 --> 01:05:21.060
Be sure to subscribe to the show.

01:05:21.060 --> 01:05:23.920
Open your favorite podcast app and search for Python.

01:05:23.920 --> 01:05:25.140
We should be right at the top.

01:05:25.580 --> 01:05:30.300
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:05:30.300 --> 01:05:34.500
and the direct RSS feed at /rss on talkpython.fm.

01:05:34.500 --> 01:05:37.940
We're live streaming most of our recordings these days.

01:05:37.940 --> 01:05:41.360
If you want to be part of the show and have your comments featured on the air,

01:05:41.360 --> 01:05:45.720
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:05:46.240 --> 01:05:47.620
This is your host, Michael Kennedy.

01:05:47.620 --> 01:05:48.920
Thanks so much for listening.

01:05:48.920 --> 01:05:50.080
I really appreciate it.

01:05:50.080 --> 01:05:52.000
Now get out there and write some Python code.

01:05:52.000 --> 01:06:12.760
I'll see you next time.

01:06:12.760 --> 01:06:42.740
Thank you.

