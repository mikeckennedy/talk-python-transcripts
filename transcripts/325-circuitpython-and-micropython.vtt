WEBVTT

00:00:00.001 --> 00:00:04.900
When you think about embedded programming, does it bring low-level languages and tools to mind?

00:00:04.900 --> 00:00:07.500
Maybe embedded C or even assembly language?

00:00:07.500 --> 00:00:12.520
Thanks to the groundbreaking work by Damian George back in 2014 to create MicroPython,

00:00:12.520 --> 00:00:17.320
Python is one of the very solid choices for building tiny programmable devices.

00:00:17.320 --> 00:00:21.300
On this episode, we welcome back Damian George from MicroPython,

00:00:21.300 --> 00:00:24.600
along with Scott Shawcraft from CircuitPython and Adafruit.

00:00:24.600 --> 00:00:29.700
We'll talk about how these two frameworks are solving similar problems with slightly different philosophies.

00:00:29.700 --> 00:00:35.140
More importantly, they are working closely to bring MicroPython and CircuitPython more in sync.

00:00:35.140 --> 00:00:41.640
This is Talk Python To Me, episode 325, recorded July 8th, 2021.

00:00:55.200 --> 00:01:01.260
Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:01:01.260 --> 00:01:03.060
This is your host, Michael Kennedy.

00:01:03.060 --> 00:01:05.260
Follow me on Twitter where I'm @mkennedy,

00:01:05.260 --> 00:01:08.980
and keep up with the show and listen to past episodes at talkpython.fm,

00:01:08.980 --> 00:01:12.120
and follow the show on Twitter via at Talk Python.

00:01:12.120 --> 00:01:15.340
This episode is brought to you by Sentry and Linode,

00:01:15.340 --> 00:01:18.220
and the transcripts are brought to you by Assembly AI.

00:01:18.220 --> 00:01:20.840
Please check out what they're offering during their segments.

00:01:20.840 --> 00:01:22.320
It really helps support the show.

00:01:23.200 --> 00:01:26.000
Scott, Damian, welcome to Talk Python To Me.

00:01:26.000 --> 00:01:26.980
Damian, welcome back.

00:01:26.980 --> 00:01:28.460
Scott, great to have you here.

00:01:28.460 --> 00:01:29.060
Thanks for having me.

00:01:29.060 --> 00:01:29.540
Hi, yeah.

00:01:29.540 --> 00:01:30.600
Thanks for having me as well.

00:01:30.600 --> 00:01:31.780
Really good to have you both here.

00:01:31.780 --> 00:01:34.200
And normally I ask people how they got into programming.

00:01:34.200 --> 00:01:36.060
Damian, you've already told your story,

00:01:36.060 --> 00:01:38.540
and maybe I think we'll mix it up just a little bit.

00:01:38.540 --> 00:01:42.100
Let's maybe just have you both do a quick introduction about,

00:01:42.100 --> 00:01:46.000
you know, how you fit into the Python world and what you're up to these days.

00:01:46.000 --> 00:01:47.060
Damian, you want to go first?

00:01:47.060 --> 00:01:47.480
Sure.

00:01:47.480 --> 00:01:50.060
I'm the creator of MicroPython.

00:01:50.060 --> 00:01:54.760
It's been a long journey in the past nine years or so.

00:01:54.760 --> 00:01:58.340
Before that, I was a theoretical physicist,

00:01:58.340 --> 00:02:04.840
and I studied at Melbourne University in Australia and did a PhD in theoretical physics.

00:02:04.840 --> 00:02:09.800
My PhD was in extra dimensions and kind of string theory related stuff.

00:02:09.800 --> 00:02:10.640
That's super cool.

00:02:10.640 --> 00:02:11.340
Yeah, it was.

00:02:11.840 --> 00:02:15.800
Oh, see, it couldn't be like a, you know, astrophysics type thing.

00:02:15.800 --> 00:02:18.440
It's got to be something small if you're working on MicroPython, right?

00:02:18.440 --> 00:02:19.720
Like if that's your deal.

00:02:19.720 --> 00:02:23.800
Well, the thing with the particle physics is all about the tiny, tiny things.

00:02:23.800 --> 00:02:27.280
The quarks is sort of as small as we know,

00:02:27.280 --> 00:02:32.140
but also linking to cosmology, which is the really, really huge thing.

00:02:32.140 --> 00:02:36.580
And the idea of cosmology is to link the tiny with the large.

00:02:36.720 --> 00:02:41.880
But yeah, that's all, I guess, very different from microcontrollers and programming and software

00:02:41.880 --> 00:02:44.380
and hardware and real tangible things.

00:02:44.380 --> 00:02:47.920
How'd you get from physics to programming side of things?

00:02:47.920 --> 00:02:50.600
I always liked computers and programming.

00:02:50.600 --> 00:02:54.200
And I always sort of had that as a side hobby.

00:02:54.200 --> 00:02:57.860
And I actually also studied computer engineering and mathematics.

00:02:57.860 --> 00:03:01.480
But physics was the thing I kept, you know, I did sort of professionally,

00:03:01.480 --> 00:03:02.880
if you could say that.

00:03:03.100 --> 00:03:08.820
And always had on the side, you know, microcontrollers and my desk and CNC machines

00:03:08.820 --> 00:03:11.040
and sort of half-built robots.

00:03:11.040 --> 00:03:11.700
Fantastic.

00:03:11.700 --> 00:03:12.100
Yeah.

00:03:12.100 --> 00:03:14.960
So turned that eventually into MicroPython.

00:03:14.960 --> 00:03:19.660
And when I was doing my PhD, when I was doing a postdoc in Cambridge and yeah,

00:03:19.660 --> 00:03:20.980
did a Kickstarter with MicroPython.

00:03:20.980 --> 00:03:24.880
And then that all sort of continued on and continued and grew and grew.

00:03:24.880 --> 00:03:27.700
And that's how I sort of end up where I am now.

00:03:27.700 --> 00:03:28.020
Cool.

00:03:28.260 --> 00:03:33.680
Kickstarter was so neat when it came out in 2015, 2014, whatever time that was.

00:03:33.680 --> 00:03:35.420
It seemed like it had such possibility.

00:03:35.420 --> 00:03:37.080
Now I don't hear about it as much anymore.

00:03:37.080 --> 00:03:38.460
And I know it's still out there, but...

00:03:38.460 --> 00:03:41.720
Yeah, I think it was a bit earlier than that because we did it in the end of 2013.

00:03:41.720 --> 00:03:43.940
And it had already been around a few years.

00:03:43.940 --> 00:03:44.260
Yeah.

00:03:44.260 --> 00:03:44.600
Yeah.

00:03:44.600 --> 00:03:47.580
But it was, yeah, such a huge thing back then.

00:03:47.580 --> 00:03:49.280
So super cool that you launched it on that.

00:03:49.280 --> 00:03:50.280
Scott, how about you?

00:03:50.420 --> 00:03:53.500
So I got into programming with PHP was my first language.

00:03:53.500 --> 00:03:55.760
So I came kind of like from the web side of things.

00:03:55.760 --> 00:03:59.640
And then when I wanted to do desktop apps, I found Python.

00:03:59.640 --> 00:04:05.180
And you can still find a source for page, source forge page for a program called Denu,

00:04:05.180 --> 00:04:09.460
which was like dynamic menu stuff for like managing your menus in Linux.

00:04:09.460 --> 00:04:11.340
That was my first Python program.

00:04:11.340 --> 00:04:12.680
That was 2004.

00:04:13.380 --> 00:04:14.920
So that's before I went to university.

00:04:14.920 --> 00:04:21.000
And then I got a computer engineering degree and I taught some of the intro TA classes there

00:04:21.000 --> 00:04:22.900
and did like a Python version of it there.

00:04:22.900 --> 00:04:26.020
So like Pythons kind of always followed me throughout my career.

00:04:26.020 --> 00:04:31.200
After university, I did six years in industry and then took a year off and did drone flight

00:04:31.200 --> 00:04:32.480
controller hardware stuff.

00:04:32.480 --> 00:04:37.300
And then when that was like coming to an end, when I was going to have to find a new job,

00:04:37.300 --> 00:04:40.500
I went to Adafruit and said like, hey, I need a job.

00:04:40.500 --> 00:04:44.660
And they were like, hey, we have this project in mind, our UK doing a project that we want.

00:04:44.660 --> 00:04:50.860
And it was to do bring MicroPython to their boards that had a different microcontroller

00:04:50.860 --> 00:04:53.060
than what MicroPython supported originally.

00:04:53.060 --> 00:04:59.720
So that was in August of 2016 that I started working on the Adafruit version of MicroPython,

00:04:59.720 --> 00:05:01.620
which then became CircuitPython.

00:05:01.620 --> 00:05:08.160
So CircuitPython is a fork of MicroPython that originally was for Adafruit's microcontrollers.

00:05:08.160 --> 00:05:13.500
And we've really pushed it to be really uniform and a good beginner experience.

00:05:13.500 --> 00:05:15.240
That's kind of how we fit in.

00:05:15.240 --> 00:05:16.720
Yeah, super interesting.

00:05:16.720 --> 00:05:17.020
In brief.

00:05:17.020 --> 00:05:23.160
Well, it sounds to me like with your drone experience and all the small servos and electronics

00:05:23.160 --> 00:05:27.880
and then this programming background, it's kind of a nice thing to bring together as well, right?

00:05:27.880 --> 00:05:28.240
Yeah.

00:05:28.320 --> 00:05:33.620
I mean, I had done Python for a long, long time and I had just gotten into Embedded and

00:05:33.620 --> 00:05:38.660
I really like that the software depth, so to speak, is like much thinner, right?

00:05:38.660 --> 00:05:41.600
Like there's a lot less software between the hardware and your code.

00:05:41.600 --> 00:05:43.220
And I thought that was really cool.

00:05:43.220 --> 00:05:49.560
And MicroPython was amazing how well it brings Python to those inexpensive devices.

00:05:49.560 --> 00:05:50.000
Yeah.

00:05:50.000 --> 00:05:52.740
So MicroPython was first, Damien.

00:05:52.740 --> 00:05:58.320
And then CircuitPython was forked from it to, like Scott said, to make it work a little bit

00:05:58.320 --> 00:05:59.840
closer with the Adafruit stuff.

00:05:59.840 --> 00:06:01.580
Is that sort of the history of it there?

00:06:01.580 --> 00:06:02.140
Yeah.

00:06:02.140 --> 00:06:09.200
There's sort of a different focus on the end user and what level of experience you have

00:06:09.200 --> 00:06:12.760
and kind of what you intend to do with the device.

00:06:12.760 --> 00:06:18.980
So I see it as MicroPython being used in industry and professionally to build products.

00:06:18.980 --> 00:06:25.540
And CircuitPython is to support, well, initially to support Adafruit's hardware, but also more

00:06:25.540 --> 00:06:30.860
for kind of beginners and people who are getting into hardware and want to have a sort of much

00:06:30.860 --> 00:06:36.560
easier onboarding with libraries and things that are working with the hardware that Adafruit

00:06:36.560 --> 00:06:37.240
provides.

00:06:37.780 --> 00:06:43.640
So there's a real distinction there with the audience and therefore the kind of features

00:06:43.640 --> 00:06:45.060
and things that we focus on.

00:06:45.060 --> 00:06:52.360
So there's a lot of focus in MicroPython on code coverage and making sure things are really

00:06:52.360 --> 00:06:58.220
stable or as stable as we can make them across releases so that people who are working with

00:06:58.220 --> 00:07:04.700
MicroPython in a product can continue to work and be confident that updating will fix bugs

00:07:04.700 --> 00:07:07.200
and not change other things too drastically.

00:07:07.760 --> 00:07:13.040
And we get, yeah, we get a lot of sort of requests for features and bug fixes and things from

00:07:13.040 --> 00:07:14.400
people using it professionally.

00:07:14.400 --> 00:07:19.480
And so I have to keep an eye out sort of on a lot of all these things so that when they

00:07:19.480 --> 00:07:24.440
come together, all the people I know who are using MicroPython are not going to suddenly

00:07:24.440 --> 00:07:28.980
be, have the rug pulled out from under them when they switch to the next version because

00:07:28.980 --> 00:07:30.540
something else has changed.

00:07:30.680 --> 00:07:31.120
Right.

00:07:31.120 --> 00:07:32.080
That's an interesting distinction.

00:07:32.080 --> 00:07:39.820
The sort of pro production side versus Adafruit is so very welcoming towards this is your

00:07:39.820 --> 00:07:41.780
first project, your first IoT thing.

00:07:41.780 --> 00:07:44.380
I like to build something for like a science project.

00:07:44.380 --> 00:07:46.780
I mean, Scott, maybe you could classify it better.

00:07:46.780 --> 00:07:50.320
You know, certainly better than I do what the specific focus is.

00:07:50.360 --> 00:07:54.460
But when I go to Adafruit and I look around, I get this feel that it's very much like these

00:07:54.460 --> 00:07:59.460
kits and very supportive of getting started and not like, hey, how's your robot doing?

00:07:59.460 --> 00:08:02.880
Here's where you plug in the thing for your industrial car making robot.

00:08:03.360 --> 00:08:05.280
I think you're both right on it.

00:08:05.280 --> 00:08:08.120
I think there's, there's a bit, two aspects to it.

00:08:08.120 --> 00:08:10.200
One is like the focus that I brought to the project.

00:08:10.200 --> 00:08:15.560
And I mentioned the TAing, the intro course in university, because I think that does have

00:08:15.560 --> 00:08:20.460
a lot of influence over how I drive our focus for CircuitPython is like, we're very focused

00:08:20.460 --> 00:08:25.080
on what that experience in the first five minutes that you've ever programmed, not just hardware,

00:08:25.080 --> 00:08:28.500
but programming in general, what that first five minute experience is.

00:08:28.660 --> 00:08:34.280
So we've done things like all of those CircuitPython boards that we now support are all show up

00:08:34.280 --> 00:08:37.180
as a USB drive once you've put CircuitPython on it.

00:08:37.180 --> 00:08:41.400
And so all of the tutorials and things that we've written on top of that is uniform across

00:08:41.400 --> 00:08:41.740
that.

00:08:41.740 --> 00:08:47.580
And then that dovetails nicely into Adafruit's business model, where they really do focus on

00:08:47.580 --> 00:08:52.600
beginners, because the reality is, is there's far more beginners than there are intermediate

00:08:52.600 --> 00:08:54.420
and advanced electronics folks.

00:08:54.900 --> 00:08:59.780
So from a business perspective, Adafruit's interested in the beginner side, just because

00:08:59.780 --> 00:09:02.260
that's where the vast majority of people are.

00:09:02.260 --> 00:09:02.560
Yeah.

00:09:02.560 --> 00:09:08.620
I also feel like the Zen or the ethos of Adafruit at the beginning was to inspire people getting

00:09:08.620 --> 00:09:12.040
into programming and getting into hardware, like from the beginning, right?

00:09:12.040 --> 00:09:14.000
That was sort of almost why it was founded.

00:09:14.000 --> 00:09:14.360
Yeah.

00:09:14.360 --> 00:09:19.680
I mean, like Adafruit started around, like it's always been a matter of open source software,

00:09:19.680 --> 00:09:22.760
open source hardware, and open source tutorials, right?

00:09:22.840 --> 00:09:29.140
Like Lomor, the founder of Adafruit, who goes by Lady Ada, like she started even before Adafruit

00:09:29.140 --> 00:09:34.180
was a company, writing tutorials about how people could go get all the parts to build this one

00:09:34.180 --> 00:09:34.500
thing.

00:09:34.500 --> 00:09:38.780
So that's very, you know, a lot of what we think about with CircuitPython is not necessarily

00:09:38.780 --> 00:09:42.660
teaching you new code from if statements and for loops, but actually just getting you all

00:09:42.660 --> 00:09:43.900
the code to do a project.

00:09:43.900 --> 00:09:48.640
And then from there, now it's modifying that project in the way that you want rather than

00:09:48.640 --> 00:09:50.040
starting from a blank screen.

00:09:50.260 --> 00:09:50.380
Yeah.

00:09:50.380 --> 00:09:50.920
Yeah.

00:09:50.920 --> 00:09:51.320
Very cool.

00:09:51.320 --> 00:09:55.520
Coming out in the live stream, Sean Tibor from Teaching Python Podcast.

00:09:55.520 --> 00:09:56.100
Hey, Sean.

00:09:56.100 --> 00:09:58.520
He's a teacher who teaches programming.

00:09:58.520 --> 00:10:01.640
Also, I know uses some of the Adafruit stuff in CircuitPython.

00:10:01.640 --> 00:10:04.740
It says the speed from zero to blinky lights is really important for learning.

00:10:04.740 --> 00:10:12.300
You know, we've got that study from the BBC Microbit where they gave that to, I guess, all seventh

00:10:12.300 --> 00:10:13.640
graders or something in the UK.

00:10:13.640 --> 00:10:15.540
I think that's roughly right anyway.

00:10:15.600 --> 00:10:21.060
And it really changed how many people saw themselves as interested in programming, especially

00:10:21.060 --> 00:10:26.160
young girls that, well, they're way more likely to take a programming course after having something

00:10:26.160 --> 00:10:31.260
physical and neat that you can play with rather than just a terminal with a print statement.

00:10:31.260 --> 00:10:33.040
I think that I agree with that as well.

00:10:33.040 --> 00:10:33.820
What do you all think?

00:10:33.980 --> 00:10:34.380
I agree.

00:10:34.380 --> 00:10:39.260
Getting a blinking light is, it's the hell of a world of microcontrollers, but it's actually

00:10:39.260 --> 00:10:44.460
really quite hard, you know, whatever your piece of hardware is.

00:10:44.460 --> 00:10:49.680
So often when I'm making MicroPython work on a new piece of hardware, the thing you can get

00:10:49.680 --> 00:10:52.200
to is once you can get a blinking LED, then you're sort of set.

00:10:52.660 --> 00:10:54.120
But getting there is really hard.

00:10:54.120 --> 00:10:57.140
And I'm not talking actually about blinking an LED in Python.

00:10:57.140 --> 00:11:01.620
I'm just, you know, blinking an LED however you can in assembly or C or whatever.

00:11:01.620 --> 00:11:06.280
Because, you know, getting a tool chain working, making this, you know, plugging in the board,

00:11:06.280 --> 00:11:10.180
powering it up, knowing how to power it up, knowing how to get it into a mode where you

00:11:10.180 --> 00:11:11.620
can change the firmware on it.

00:11:11.620 --> 00:11:13.680
These things take, you know, it can take days.

00:11:13.680 --> 00:11:14.780
I mean, yeah.

00:11:14.780 --> 00:11:15.580
Or longer.

00:11:15.580 --> 00:11:18.720
And why is my serial port working right?

00:11:18.720 --> 00:11:20.660
And, you know, all sorts of stuff.

00:11:20.740 --> 00:11:20.860
Yeah.

00:11:20.860 --> 00:11:27.060
So to port MicroPython to a new microcontroller, once you've got a tool chain, a way to flash

00:11:27.060 --> 00:11:32.340
the device, and you can blink an LED or write characters to a UART, then getting MicroPython

00:11:32.340 --> 00:11:34.540
working is probably another hour's worth of work.

00:11:34.540 --> 00:11:39.840
And then you've got, you know, the whole of MicroPython ecosystem that you can play with.

00:11:39.840 --> 00:11:43.480
But from a beginner's point of view, it's a similar sort of story.

00:11:43.480 --> 00:11:46.260
When they want to, they get something, they've never done it before.

00:11:46.260 --> 00:11:49.080
They've got a piece of hardware and, you know, what's going on.

00:11:49.520 --> 00:11:53.720
So blinking an LED, to get to that stage, there's a lot of kind of conceptual hurdles

00:11:53.720 --> 00:11:57.520
and also, you know, maybe installing things on your computer hurdles as well.

00:11:57.520 --> 00:12:01.720
But to get to a blinking LED is really the beginning.

00:12:01.720 --> 00:12:07.060
And then from there, you can be a whole sort of world of possibility opens up because you

00:12:07.060 --> 00:12:10.480
can see then how you can turn that into a real life project.

00:12:10.480 --> 00:12:10.860
Yeah.

00:12:10.860 --> 00:12:12.700
Start to work with the other sensors.

00:12:12.700 --> 00:12:13.600
Yeah.

00:12:13.600 --> 00:12:19.920
Things like the accelerometers or motion or microphone or anything, right?

00:12:19.920 --> 00:12:20.420
Exactly.

00:12:20.420 --> 00:12:20.780
Yep.

00:12:20.780 --> 00:12:21.160
Yeah.

00:12:21.160 --> 00:12:27.200
I think maybe it makes sense to pause for just a moment and define microcontroller for people.

00:12:27.200 --> 00:12:28.800
So I have a Mac mini here.

00:12:28.800 --> 00:12:30.380
It's small, right?

00:12:30.380 --> 00:12:31.620
That's not a microcontroller.

00:12:31.620 --> 00:12:34.560
I could get a Raspberry Pi, which is even smaller.

00:12:34.560 --> 00:12:36.240
Still not a microcontroller.

00:12:36.240 --> 00:12:40.700
Like, give us a sense for the size of these boards and like, what does the hardware look

00:12:40.700 --> 00:12:40.980
like?

00:12:40.980 --> 00:12:42.800
It's not really physical size.

00:12:42.800 --> 00:12:49.440
A microcontroller itself is actually more complicated than a PC in some sense.

00:12:49.820 --> 00:12:55.780
A PC like a Mac mini or a laptop or Raspberry Pi that has a CPU in it.

00:12:55.780 --> 00:13:02.140
And it's connected usually to a keyboard and a screen and maybe some audio and Wi-Fi, some

00:13:02.140 --> 00:13:02.740
kind of internet.

00:13:02.740 --> 00:13:05.060
And it's relatively straightforward.

00:13:05.060 --> 00:13:10.540
It's a CPU that is fast and does a lot of processing and can output to a screen at a

00:13:10.540 --> 00:13:12.620
high refresh rate and you can interact with it.

00:13:12.620 --> 00:13:19.980
But a microcontroller is a CPU plus a lot of other peripherals around it, like UART and

00:13:19.980 --> 00:13:27.540
SPI and I2C and I2S and Ethernet and Wi-Fi and then really low level stuff like DMA and

00:13:27.540 --> 00:13:33.320
things that make the microcontroller work in a microcontrollery way, timers that interrupt

00:13:33.320 --> 00:13:34.200
it very precisely.

00:13:34.200 --> 00:13:39.140
So a microcontroller is what they say sometimes a system on a chip SOC.

00:13:39.420 --> 00:13:46.400
It's a real tightly interconnected piece of silicon which has a CPU at the center which

00:13:46.400 --> 00:13:47.140
controls things.

00:13:47.140 --> 00:13:49.760
But what's more important is the things it's controlling.

00:13:49.760 --> 00:13:56.920
And it's got to do that in a really precise and real-time way so that what it's controlling,

00:13:56.920 --> 00:14:03.100
say a coffee machine or an airplane, is guaranteed to work every time the same way and run for

00:14:03.100 --> 00:14:05.360
years without having any problems.

00:14:05.920 --> 00:14:10.400
But if you have a laptop and it's probably not going to run for years without needing

00:14:10.400 --> 00:14:14.180
to be upgraded or crashing for some reason or...

00:14:14.180 --> 00:14:15.340
It's odd how that works, right?

00:14:15.340 --> 00:14:17.740
There is this kind of distinction there.

00:14:17.740 --> 00:14:24.480
It's a bit subtle, but the microcontroller is a really precise machine and a really complex

00:14:24.480 --> 00:14:25.780
machine in the way it interacts.

00:14:25.780 --> 00:14:27.040
Would you say more real-time?

00:14:27.260 --> 00:14:29.660
Yes, that's one of its tasks is to be real-time.

00:14:29.660 --> 00:14:36.520
And it's not as powerful as a laptop or a PC, but it is more sort of capable.

00:14:36.520 --> 00:14:39.540
And also programming it is a lot harder.

00:14:39.540 --> 00:14:46.540
So I think it's important to say that microcontrollers are typically used to do a single task in a larger

00:14:46.540 --> 00:14:46.980
system.

00:14:46.980 --> 00:14:53.080
So think of your car and I think a Tesla has a microcontroller that manages the door handle,

00:14:53.080 --> 00:14:53.820
for example.

00:14:53.820 --> 00:14:57.720
So microcontrollers are in a lot of things.

00:14:57.720 --> 00:14:59.920
Damien said toasters in another example.

00:14:59.920 --> 00:15:02.420
So that means that they're everywhere.

00:15:02.420 --> 00:15:04.140
You just don't see them.

00:15:04.140 --> 00:15:07.160
And that has the benefit of being very low cost.

00:15:07.160 --> 00:15:12.300
So the microcontrollers, which are like the black chip on the circuit playground you see here,

00:15:12.300 --> 00:15:14.580
they're only like a couple centimeters square.

00:15:14.960 --> 00:15:18.760
They'll cost under a dollar or a few dollars at most,

00:15:18.760 --> 00:15:21.720
which means that they're really inexpensive to get into.

00:15:21.720 --> 00:15:29.140
And in terms of processing power, what you'll see is like if my desktop has 32 gigs of RAM,

00:15:29.140 --> 00:15:34.300
right, but a microcontroller will have anywhere from like eight kilobytes of RAM up to maybe a

00:15:34.300 --> 00:15:38.220
megabyte of RAM or a few megabytes of RAM at the higher end.

00:15:38.220 --> 00:15:42.960
The distinction between like a microcontroller and a microprocessor also involves like how good it is

00:15:42.960 --> 00:15:44.220
doing multiple things.

00:15:44.220 --> 00:15:49.740
Specifically, like there's memory protection stuff that will happen in your like desktop CPU that a

00:15:49.740 --> 00:15:51.960
microcontroller typically cannot do.

00:15:51.960 --> 00:15:54.700
So really, it's usually just a single task thing.

00:15:54.700 --> 00:16:01.800
Unlike macOS or Linux or whatever, you've got the OS and then it's running your processes often in user

00:16:01.800 --> 00:16:02.200
space.

00:16:02.200 --> 00:16:03.360
They have protected memory.

00:16:03.360 --> 00:16:04.320
There's a bunch of them.

00:16:04.320 --> 00:16:07.920
The OS is doing preemptive multithreading, all those kinds of things.

00:16:07.920 --> 00:16:14.660
This, your Python program, your micro Python or CircuitPython basically is the operating system

00:16:14.660 --> 00:16:15.280
almost, right?

00:16:15.280 --> 00:16:16.960
It's like full control.

00:16:16.960 --> 00:16:17.280
Right.

00:16:19.280 --> 00:16:22.200
This portion of Talk Python or me is brought to you by Sentry.

00:16:22.200 --> 00:16:24.720
How would you like to remove a little stress from your life?

00:16:24.720 --> 00:16:29.820
Do you worry that users might be having difficulties or are encountering errors in your app right now?

00:16:29.820 --> 00:16:32.740
Would you even know it until they send that support email?

00:16:32.740 --> 00:16:38.120
How much better would it be to have the error and performance details immediately sent to you,

00:16:38.120 --> 00:16:43.980
including the call stack and values of local variables and the active user recorded in that report?

00:16:44.440 --> 00:16:47.120
With Sentry, this is not only possible, it's simple.

00:16:47.120 --> 00:16:50.880
In fact, we use Sentry on all the Talk Python web properties.

00:16:50.880 --> 00:16:57.520
We've actually fixed a bug triggered by a user and had the upgrade ready to roll out as we got their support email.

00:16:57.520 --> 00:16:59.220
That was a great email to write back.

00:16:59.220 --> 00:17:01.700
We saw your error and have already rolled out the fix.

00:17:01.700 --> 00:17:02.880
Imagine their surprise.

00:17:02.880 --> 00:17:05.120
Surprise and delight your users today.

00:17:05.120 --> 00:17:08.520
Create your Sentry account at talkpython.fm/sentry.

00:17:08.720 --> 00:17:14.760
And if you sign up with the code talkpython2021, it's good for two months of Sentry's team plan,

00:17:14.760 --> 00:17:19.820
which will give you up to 20 times as many monthly events as well as other features.

00:17:19.820 --> 00:17:24.780
So just use that code talkpython2021 as your promo code when you sign up.

00:17:27.080 --> 00:17:32.380
In some cases, there's a real-time operating system under the hood, but in some other cases, there isn't.

00:17:32.380 --> 00:17:32.640
Okay.

00:17:32.640 --> 00:17:33.360
Interesting.

00:17:33.360 --> 00:17:41.700
So one of the things that might be fun to talk about is we've got MicroPython and we've got CircuitPython.

00:17:41.700 --> 00:17:47.800
And we've also, you know, when people say Python, they often mean python.org, CPython, Python.

00:17:48.360 --> 00:18:01.680
They mean you want to start us off with maybe, like, what's the difference between this huge, I don't know how large it is, 40, 50 megabyte thing I download from python.org, and then maybe what MicroPython is.

00:18:01.680 --> 00:18:03.340
What's the same and what's different?

00:18:03.340 --> 00:18:08.160
Can I write, can I take a random Python program and run it on MicroPython and so on?

00:18:08.160 --> 00:18:14.380
It's sort of the biggest thing about if it's called Python, like MicroPython, you know, shouldn't it be just the same as Python?

00:18:14.380 --> 00:18:16.700
And why can't I just use Python instead if it's the same?

00:18:17.020 --> 00:18:17.100
Yeah.

00:18:17.100 --> 00:18:27.280
So to begin with, you can't run Python on a little microcontroller because Python, it uses too much memory is kind of the base, really the reason.

00:18:27.280 --> 00:18:32.880
Just to load the runtime libraries probably exceeds the entire working memory of some of these chips, right?

00:18:32.880 --> 00:18:40.060
Just to load sort of the mapping table of Unicode character names is megabytes of data, which MicroPython obviously doesn't support.

00:18:40.700 --> 00:18:48.700
So one of the main things when I was writing MicroPython was to make sure it didn't use memory where possible.

00:18:48.700 --> 00:18:57.500
So all of the things that could be put into read-only memory or Flash or ROM were put in there.

00:18:57.500 --> 00:19:09.160
So dictionaries and modules and things that are sort of built in, like a sys module, all of that is in read-only memory in MicroPython and CircuitPython.

00:19:09.340 --> 00:19:14.320
Whereas in normal Python, pretty much everything is put into RAM.

00:19:14.320 --> 00:19:21.400
And so when you make, if you try to run Python on a, CPython on a microcontroller, you would need megabytes of RAM.

00:19:21.900 --> 00:19:23.780
And that really is the main difference.

00:19:23.780 --> 00:19:31.880
But then there's a lot of other, you know, things on a sort of a list of things that are different to make MicroPython efficient on a microcontroller.

00:19:31.880 --> 00:19:36.700
To make it small in code size, to make it run relatively efficiently.

00:19:36.700 --> 00:19:41.800
And as part of that, we had to make some sacrifices in compatibility with CPython.

00:19:41.800 --> 00:19:43.740
So there are some things that are not the same.

00:19:43.740 --> 00:19:49.720
But for the most part, MicroPython and CircuitPython really do feel like normal Python.

00:19:50.220 --> 00:19:55.280
The syntax is the same, at least up to a given Python version, because Python keeps adding syntax.

00:19:55.280 --> 00:19:59.140
The syntax is exactly the same, and the semantics of the syntax are the same.

00:19:59.140 --> 00:20:04.920
And a lot of the built-in types, you know, will have one-to-one mapping with the same semantics and the same methods.

00:20:04.920 --> 00:20:09.360
So there's a lot of things down there that are very, very similar.

00:20:09.360 --> 00:20:12.840
And I think that's a lot of things that are very similar to Python.

00:20:12.840 --> 00:20:14.840
And I think that's a lot of things that are very similar to Python.

00:20:14.840 --> 00:20:16.780
And I think that's a lot of things that are very similar to Python.

00:20:16.780 --> 00:20:18.780
And I think that's a lot of things that are very similar to Python.

00:20:18.780 --> 00:20:20.780
And I think that's a lot of things that are very similar to Python.

00:20:20.780 --> 00:20:22.780
And I think that's a lot of things that are very similar to Python.

00:20:22.780 --> 00:20:23.780
I think that's a lot of things that are very similar to Python.

00:20:23.780 --> 00:20:23.780
And I think that's a lot of things that are very similar to Python.

00:20:23.780 --> 00:20:23.780
And I think that's a lot of things that are very similar to Python.

00:20:23.780 --> 00:20:23.780
And I think that's a lot of things that are very similar to Python.

00:20:23.780 --> 00:20:24.780
And I think that's a lot of things that are very similar to Python.

00:20:24.780 --> 00:20:25.780
And I think that's a lot of things that are very similar to Python.

00:20:25.780 --> 00:20:26.780
And I think that's a lot of things that are very similar to Python.

00:20:26.780 --> 00:20:27.780
And I think that's a lot of things that are very similar to Python.

00:20:27.780 --> 00:20:30.780
I'm expecting to patch that when we load this module.

00:20:30.780 --> 00:20:31.780
Yeah.

00:20:31.780 --> 00:20:32.780
Yeah, exactly.

00:20:32.780 --> 00:20:34.780
Scott's shaking his head like, maybe not.

00:20:34.780 --> 00:20:39.220
But even down to things like how division and modulo work with negative numbers is sort

00:20:39.220 --> 00:20:40.780
of very specific.

00:20:40.780 --> 00:20:45.780
You know, when you have A modulo B and the negative numbers, then the answer is a certain

00:20:45.780 --> 00:20:46.780
way.

00:20:46.780 --> 00:20:47.780
And MicroPython copies that as well.

00:20:47.780 --> 00:20:52.940
So there's a lot of subtleties there that you may not realize that over the years we've

00:20:52.940 --> 00:20:56.440
gotten to make sure it's the right same as CPython just because we've got a lot of tests

00:20:56.440 --> 00:21:00.440
and a lot of people giving feedback when it's not exactly as they expect.

00:21:00.440 --> 00:21:01.440
Yeah.

00:21:01.440 --> 00:21:06.440
And yeah, I mean, I've definitely learned so much about CPython and well, the Python language,

00:21:06.440 --> 00:21:08.440
because so many things I had no idea about.

00:21:08.440 --> 00:21:09.440
Like, whoa.

00:21:09.440 --> 00:21:13.440
You had to get the exact nuanced details of how this thing or that thing works, right?

00:21:13.440 --> 00:21:14.440
Yeah.

00:21:14.440 --> 00:21:15.440
Make sure it's the same.

00:21:15.440 --> 00:21:19.440
One of the things that I think is worth keeping in mind as people think about this is when somebody

00:21:19.440 --> 00:21:25.100
says, I love Python, or I think Python works this way, or Python is this thing and it's

00:21:25.100 --> 00:21:28.100
productive or it's whatever, it's slow, it's fast.

00:21:28.100 --> 00:21:30.100
They often can be talking about many things.

00:21:30.100 --> 00:21:33.100
Somebody could say, I love Python and they mean the Python syntax.

00:21:33.100 --> 00:21:36.100
Somebody could say, I love Python, or I get the standard library so cool that it comes with

00:21:36.100 --> 00:21:38.100
all of these things in the standard library.

00:21:38.100 --> 00:21:43.100
They could mean IPIP installed pandas and requests and now something cool happened.

00:21:43.100 --> 00:21:44.100
Yeah.

00:21:44.100 --> 00:21:44.100
Right.

00:21:44.100 --> 00:21:49.100
When you say Python runs there, there's like, you kind of got to say, okay, well, what are

00:21:49.100 --> 00:21:50.100
we talking about?

00:21:50.100 --> 00:21:51.100
Right?

00:21:51.100 --> 00:21:56.100
It's mostly the language for sure, but there's got to be a ton of standard library things that

00:21:56.100 --> 00:21:57.100
don't make sense.

00:21:57.100 --> 00:21:59.100
I think that's one about parsing CSS hex values.

00:21:59.100 --> 00:22:00.100
Like who cares?

00:22:00.100 --> 00:22:01.100
Tk enter.

00:22:01.100 --> 00:22:02.100
Don't care.

00:22:02.100 --> 00:22:03.100
Yeah.

00:22:03.100 --> 00:22:04.100
SQLite maybe?

00:22:04.100 --> 00:22:05.100
I don't know.

00:22:05.100 --> 00:22:10.100
I did actually do a lightning talk at the last language summit, kind of on this topic.

00:22:10.100 --> 00:22:11.100
Perfect.

00:22:11.100 --> 00:22:16.100
And like Damien was saying, like, to his credit, MicroPython is Python in the core syntax areas

00:22:16.100 --> 00:22:17.100
and the built in types.

00:22:17.100 --> 00:22:22.100
But as you kind of grow outwards into like the standard library, things get omitted a lot

00:22:22.100 --> 00:22:26.100
because the, frankly, the standard library in CPython is large.

00:22:26.100 --> 00:22:27.100
Yeah.

00:22:27.100 --> 00:22:31.100
And so I did kind of a comparison there and I can share people with the slides, but like,

00:22:31.100 --> 00:22:35.100
take all this stuff in CPython and show what's in circuit Python.

00:22:35.100 --> 00:22:36.100
That's cool.

00:22:36.100 --> 00:22:40.100
I've been having like discussions off and on with Brett Cannon about this as well.

00:22:40.100 --> 00:22:44.100
Cause he's been thinking about like, how would you define like a minimum version of Python?

00:22:44.100 --> 00:22:47.100
And I think that MicroPython did such a great job of that.

00:22:47.100 --> 00:22:48.100
It feels like Python to me.

00:22:48.100 --> 00:22:50.100
I had the background in Python before.

00:22:50.100 --> 00:22:53.100
So like coming to MicroPython, it felt very natural.

00:22:53.100 --> 00:22:55.100
So I think we're a good case for that.

00:22:55.100 --> 00:22:56.100
Yeah.

00:22:56.100 --> 00:22:57.100
I think you definitely are.

00:22:57.100 --> 00:23:02.100
You know, Brett was, I know he's been thinking a lot about WebAssembly and what would it look

00:23:02.100 --> 00:23:05.100
like if we could have Python and WebAssembly and we could have it in these other,

00:23:05.100 --> 00:23:09.100
you know, like what would a mobile Python look like and these different environments that are

00:23:09.100 --> 00:23:17.100
not just desktops plus servers and having this standard core Python subset is a pretty neat idea.

00:23:17.100 --> 00:23:18.100
Yeah.

00:23:18.100 --> 00:23:19.100
A couple of things from the live stream.

00:23:19.100 --> 00:23:24.100
Sean has a warning for everyone who gets into this, that these microcontrollers tend to multiply

00:23:24.100 --> 00:23:25.100
quickly.

00:23:25.100 --> 00:23:26.100
He started with just one or two.

00:23:26.100 --> 00:23:27.100
Now he has a whole collection.

00:23:27.100 --> 00:23:32.100
I can't see what's in your background, Damien, but Scott, you seem to have a bunch of these things

00:23:32.100 --> 00:23:33.100
gathered around.

00:23:33.100 --> 00:23:34.100
Oh yeah.

00:23:34.100 --> 00:23:36.100
This room is a mess right now.

00:23:36.100 --> 00:23:38.100
I probably have at least a dozen on my desk though as well.

00:23:38.100 --> 00:23:39.100
Yeah.

00:23:39.100 --> 00:23:44.100
There's, I just got to find new and inventive ways of actually organizing them.

00:23:44.100 --> 00:23:50.100
Cause you know, I mean, there's things like, you know, a box full of dev boards sort of in

00:23:50.100 --> 00:23:51.100
plastic blister packs.

00:23:51.100 --> 00:23:54.100
I take them out of the blister packs are too big.

00:23:54.100 --> 00:23:55.100
I try to take those out.

00:23:55.100 --> 00:23:56.100
Yeah.

00:23:56.100 --> 00:23:57.100
Oh my gosh.

00:23:57.100 --> 00:23:58.100
I have bins per manufacturer.

00:23:58.100 --> 00:24:03.100
So like STM, NRF, Atmel, of all the different development boards.

00:24:03.100 --> 00:24:04.100
Yeah.

00:24:04.100 --> 00:24:05.100
Yeah.

00:24:05.100 --> 00:24:07.100
There's just, yeah, there's a whole lot of stuff everywhere.

00:24:07.100 --> 00:24:10.100
Like just, just, they're inexpensive.

00:24:10.100 --> 00:24:13.100
They're impulse buyable, which is bad.

00:24:13.100 --> 00:24:14.100
Exactly.

00:24:14.100 --> 00:24:16.100
I'm going to buy those and one of these and yeah, amazing.

00:24:16.100 --> 00:24:18.100
But it's gotta be a collection of cool little things.

00:24:18.100 --> 00:24:19.100
Yeah.

00:24:19.100 --> 00:24:24.100
It's also important to figure out like what each individual microcontroller can do unique,

00:24:24.100 --> 00:24:25.100
uniquely.

00:24:25.100 --> 00:24:26.100
Mm-hmm.

00:24:26.100 --> 00:24:27.100
What makes something unique?

00:24:27.100 --> 00:24:31.100
Like it's obvious, like if it's a BLE chip, then that's obviously what you want to do.

00:24:31.100 --> 00:24:33.100
If it's wifi, that's what it can do.

00:24:33.100 --> 00:24:38.100
But the RP2040, which is the new chip from Raspberry Pi, like they have this really weird,

00:24:38.100 --> 00:24:43.100
unique peripheral that allows to do really, really, really real time stuff because an actual

00:24:43.100 --> 00:24:46.100
CPU and a microcontroller is still not perfectly real time.

00:24:46.100 --> 00:24:50.100
So they have this like special thing that they added that can do some really impressive

00:24:50.100 --> 00:24:51.100
real time stuff.

00:24:51.100 --> 00:24:54.100
It's very interesting to see like the stuff that's standard between all these things.

00:24:54.100 --> 00:24:55.100
And then what's different.

00:24:55.100 --> 00:24:56.100
Yeah.

00:24:56.100 --> 00:24:57.100
I can imagine.

00:24:57.100 --> 00:25:00.100
One more interesting thing I want to ask you about from the live stream.

00:25:00.100 --> 00:25:04.100
Tim out there asks, you know, what are your thoughts on circuit Python being used in TI

00:25:04.100 --> 00:25:05.100
calculators?

00:25:05.100 --> 00:25:13.100
So the new TI 84 comes with programming as, and you can write Python in here.

00:25:13.100 --> 00:25:14.100
I don't remember what the, oh, here it is.

00:25:14.100 --> 00:25:20.100
The programming bits where you can see, but yeah, I mean, I remember programming in calculators

00:25:20.100 --> 00:25:22.100
being like really, really weird.

00:25:22.100 --> 00:25:24.100
Yeah, I did that actually.

00:25:24.100 --> 00:25:25.100
Yeah.

00:25:25.100 --> 00:25:29.100
I mean, a little bit funky, but you know, having Python there is quite neat as well.

00:25:29.100 --> 00:25:29.100
And yeah.

00:25:29.100 --> 00:25:31.100
So this is a fork of circuit Python.

00:25:31.100 --> 00:25:32.100
Interesting.

00:25:32.100 --> 00:25:35.100
It's not publicly released, which is totally okay.

00:25:35.100 --> 00:25:38.100
They are careful not to call it circuit Python, which is good as well.

00:25:38.100 --> 00:25:42.100
But that does mean that like, if you go to circuit Python.org slash downloads, you won't

00:25:42.100 --> 00:25:45.100
find like the latest version of circuit Python for your calculator.

00:25:45.100 --> 00:25:47.100
But generally, I think it's great.

00:25:47.100 --> 00:25:52.100
Like, I love seeing people build on circuit Python, just like we've built on micro Python.

00:25:52.100 --> 00:25:53.100
Like, yeah, people should do that.

00:25:53.100 --> 00:25:54.100
It's really neat.

00:25:54.100 --> 00:25:55.100
Yeah, absolutely.

00:25:55.100 --> 00:25:59.100
And then another one out there that's neat that says, Matt says, "Micro Python and the

00:25:59.100 --> 00:26:02.100
new Lego spike delighted the inner teenager in me."

00:26:02.100 --> 00:26:03.100
Did you catch that?

00:26:03.100 --> 00:26:04.100
You must've known about this, right?

00:26:04.100 --> 00:26:05.100
Yes.

00:26:05.100 --> 00:26:06.100
How do you take this news?

00:26:06.100 --> 00:26:08.100
Yeah, that was pretty amazing.

00:26:08.100 --> 00:26:12.100
I don't know if it was a year or a couple of years ago, I think, maybe even longer, three

00:26:12.100 --> 00:26:13.100
years ago.

00:26:13.100 --> 00:26:14.100
Yeah, a little while.

00:26:14.100 --> 00:26:16.100
When they started, well, they contacted me about it.

00:26:16.100 --> 00:26:18.100
So it's still an ongoing thing.

00:26:18.100 --> 00:26:24.100
You can, there's a Lego education, which is separate to sort of Lego retail.

00:26:24.100 --> 00:26:26.100
Lego education is for schools.

00:26:26.100 --> 00:26:29.100
I remember using that when I was in high school a long, long time ago.

00:26:29.100 --> 00:26:33.100
Lego, it's obviously Lego, but it's the different kit and it's different focus on what you do

00:26:33.100 --> 00:26:34.100
with it.

00:26:34.100 --> 00:26:39.100
And the Lego education these days, sort of the new version of Mindstorms uses MicroPython

00:26:39.100 --> 00:26:45.100
in the hub of the sort of the central processing unit of the central sort of Lego control block.

00:26:45.100 --> 00:26:50.100
Do they expose that to the kids to play with or is it just like a runtime internal sort

00:26:50.100 --> 00:26:51.100
of thing?

00:26:51.100 --> 00:26:52.100
It's kind of both.

00:26:52.100 --> 00:26:58.100
The thing that you can get for Lego education is using MicroPython to implement sort of what

00:26:58.100 --> 00:26:59.100
what the kids say.

00:26:59.100 --> 00:27:03.100
But I think there are plans to make it so that you can actually use MicroPython directly.

00:27:03.100 --> 00:27:04.100
That'd be really neat.

00:27:04.100 --> 00:27:05.100
Yeah.

00:27:05.100 --> 00:27:06.100
Very cool.

00:27:06.100 --> 00:27:07.100
I think it's great.

00:27:07.100 --> 00:27:11.100
Scott, I asked about the comparison between MicroPython and CPython.

00:27:11.100 --> 00:27:17.100
You want to close the circle and go from maybe the differences of MicroPython and CircuitPython.

00:27:17.100 --> 00:27:21.100
Like, why are there two things here and whatnot?

00:27:21.100 --> 00:27:25.100
How people think about like, if I'm going to work with one or the other, where would they go?

00:27:25.100 --> 00:27:26.100
Yeah.

00:27:26.100 --> 00:27:31.100
So I think the why is what Damon iterated earlier is like our focus in CircuitPython really is

00:27:31.100 --> 00:27:32.100
beginners.

00:27:32.100 --> 00:27:39.100
And coming into Adafruit, I also knew that their model is that like for every device that they

00:27:39.100 --> 00:27:42.100
sell, they provide example code and drivers for it.

00:27:42.100 --> 00:27:46.100
And because Adafruit was going to do this for the Python world, we had to make sure that the

00:27:46.100 --> 00:27:51.100
hardware abstraction layer, like the modules you import in Python that allow you access to

00:27:51.100 --> 00:27:54.100
the hardware would be consistent across everything that runs CircuitPython.

00:27:54.100 --> 00:28:00.100
So you saw me get like a little niggly about like, it's not actually CircuitPython on the TI

00:28:00.100 --> 00:28:05.100
calculator because like, I think the branding of CircuitPython is really important because it means that

00:28:05.100 --> 00:28:07.100
you can download it from the website.

00:28:07.100 --> 00:28:10.100
You can use the APIs that we have standard as CircuitPython.

00:28:10.100 --> 00:28:14.100
And therefore, all of our CircuitPython libraries work on top of that.

00:28:14.100 --> 00:28:16.100
All our guides for CircuitPython work on top of that.

00:28:16.100 --> 00:28:17.100
Yeah.

00:28:17.100 --> 00:28:21.100
So that was really, you know, one of the more important things for us is having that uniform

00:28:21.100 --> 00:28:24.100
API that we can then build all of this Python software on top of.

00:28:24.100 --> 00:28:26.100
That's one of the main differences.

00:28:26.100 --> 00:28:31.100
It should be, I should say that we do actually have this layer called Blinka now that allows

00:28:31.100 --> 00:28:35.100
you to use MicroPython under the hood or actually CPython under the hood.

00:28:35.100 --> 00:28:39.100
But it presents that same CircuitPython API for other things as well.

00:28:39.100 --> 00:28:41.100
This line has been blurred some.

00:28:41.100 --> 00:28:46.100
The thing that doesn't come with that is that we, in CircuitPython, we still do ensure

00:28:46.100 --> 00:28:48.100
that your kind of workflow is the same as well.

00:28:48.100 --> 00:28:53.100
So all of the CircuitPython boards that you can download now, except in the future, this

00:28:53.100 --> 00:28:58.100
is going to change, show up as a CircuitPy drive and you can edit the code.py file on it.

00:28:58.100 --> 00:29:01.100
It runs after you save it automatically.

00:29:01.100 --> 00:29:03.100
And it's really quick and easy to iterate on.

00:29:03.100 --> 00:29:04.100
Right.

00:29:04.100 --> 00:29:08.100
So basically there's a file watcher that looks at your source file that is the program.

00:29:08.100 --> 00:29:12.100
And if it sees a change, it kind of just reboots super quick and reruns it, right?

00:29:12.100 --> 00:29:13.100
It's not even that smart.

00:29:13.100 --> 00:29:15.100
It's any write to the file system.

00:29:15.100 --> 00:29:18.100
It doesn't know what file you're writing to.

00:29:18.100 --> 00:29:20.100
It's just any write will trigger that.

00:29:20.100 --> 00:29:24.100
And the caveat I had is I'm working on a Beely only workflow as well.

00:29:24.100 --> 00:29:27.100
So in the future, there will be two ways of using CircuitPython.

00:29:27.100 --> 00:29:31.100
There will be a USB way and a Bluetooth low energy way.

00:29:31.100 --> 00:29:32.100
I see.

00:29:32.100 --> 00:29:34.100
So you don't have to actually connect physically to the thing.

00:29:34.100 --> 00:29:35.100
It could be over there.

00:29:35.100 --> 00:29:36.100
Right.

00:29:36.100 --> 00:29:37.100
You could program it.

00:29:37.100 --> 00:29:40.100
That and from phones, phones and tablets in particular.

00:29:40.100 --> 00:29:44.100
Devices that are really easily interoperable over USB.

00:29:44.100 --> 00:29:49.100
We want to bring the beginner experience of programming in CircuitPython to those devices as well.

00:29:49.100 --> 00:29:50.100
Yeah.

00:29:50.100 --> 00:29:51.100
So that's the caveat.

00:29:51.100 --> 00:29:57.100
Like right now everything does USB, but I'm like working on the micro:bit v2 right now that will not be doing USB.

00:29:57.100 --> 00:29:59.100
It'll only be doing Bluetooth low energy.

00:29:59.100 --> 00:30:00.100
That sounds more complicated.

00:30:00.100 --> 00:30:01.100
Yeah, it is.

00:30:01.100 --> 00:30:02.100
But also very useful.

00:30:02.100 --> 00:30:04.100
But I just, without a wire, you know.

00:30:04.100 --> 00:30:05.100
Yeah.

00:30:05.100 --> 00:30:07.100
I'm just thinking of when my headphones like get disconnected.

00:30:07.100 --> 00:30:08.100
I'm like, oh, interference.

00:30:08.100 --> 00:30:09.100
How frustrating.

00:30:09.100 --> 00:30:11.100
And, but you know, when that's your connection, right?

00:30:11.100 --> 00:30:12.100
Yeah.

00:30:12.100 --> 00:30:14.100
Bluetooth's come a long way and I have had it working a bit.

00:30:14.100 --> 00:30:19.100
A lot of the challenge with Bluetooth is there's no standard way of doing like file transfer.

00:30:19.100 --> 00:30:30.100
So we really like we're working on apps to be able to transfer files and apps that are letting you pull that will pull down all the example code and automatically load that over.

00:30:30.100 --> 00:30:33.100
And that file transfer API that we have is all public.

00:30:33.100 --> 00:30:36.100
So if folks want a link to that, I can send them a link to that protocol.

00:30:36.100 --> 00:30:41.100
So yeah, there's a lot more work off the device to do for it for this Bluetooth stuff.

00:30:41.100 --> 00:30:42.100
That's cool.

00:30:42.100 --> 00:30:48.100
So I see on circuitpython.org, it says Blinka and circuit Python libraries are just a pip install away.

00:30:48.100 --> 00:30:56.100
So if I'm working, but I'm on my desktop machine or server machine, can I still do like prototyping and try the libraries?

00:30:56.100 --> 00:30:57.100
What does that mean?

00:30:57.100 --> 00:30:59.100
It's not every computer.

00:30:59.100 --> 00:31:03.100
If you're on a Raspberry Pi, it will work because that is supported.

00:31:03.100 --> 00:31:09.100
If you actually, I think if you click that single board computers link, it'll show you all the ones that we specifically support.

00:31:09.100 --> 00:31:17.100
But single board computer is like a Linux class computer that usually breaks out general purpose IO, GPIO.

00:31:17.100 --> 00:31:21.100
So that's kind of the class of Linux computers that you'll be able to use this on.

00:31:21.100 --> 00:31:22.100
Okay.

00:31:22.100 --> 00:31:32.100
And then we do also have a couple cases where you could like plug something into your USB that would also like give you that GPIO on another device.

00:31:32.100 --> 00:31:36.100
This portion of Talk Python To Me is sponsored by Linode.

00:31:36.100 --> 00:31:44.100
Visit talkpython.fm/linode to see why Linode has been voted the top infrastructure as a service provider by both G2 and TrustRadius.

00:31:44.100 --> 00:31:52.100
From their award winning support, which is offered 24/7/365 to every level of user, to the ease of use and setup.

00:31:52.100 --> 00:31:57.100
It's clear why developers have been trusting Linode for projects both big and small since 2003.

00:31:57.100 --> 00:32:07.100
To pull your entire application stack with Linode's one-click app marketplace or build it all from scratch and manage everything yourself with supported centralized tools like Terraform.

00:32:07.100 --> 00:32:17.100
Linode offers the best price to performance value for all compute instances, including GPUs as well as block storage, Kubernetes, and their upcoming bare metal release.

00:32:17.100 --> 00:32:25.100
Linode makes cloud computing fast, simple, and affordable, allowing you to focus on your projects, not your infrastructure.

00:32:25.100 --> 00:32:33.100
Visit talkpython.fm/linode and sign up with your Google account, your GitHub account, or your email address and you'll get $100 in credit.

00:32:33.100 --> 00:32:38.100
That's talkpython.fm/linode or just click the link in your podcast player show notes.

00:32:38.100 --> 00:32:41.100
And thank them for supporting Talk Python.

00:32:41.100 --> 00:32:45.100
Question from the live stream from Tim again.

00:32:45.100 --> 00:32:50.100
How has the workflow changed over the past few years for SugarPython and MicroPython when deploying code?

00:32:50.100 --> 00:32:54.100
And it sounds like Matt's talking about MP remote.

00:32:54.100 --> 00:32:57.100
Tim, do you want to talk about what the deployment looks like?

00:32:57.100 --> 00:33:03.100
Yeah, there's a lot of answers to that question from a MicroPython point of view.

00:33:03.100 --> 00:33:13.100
As I mentioned, if you're using MicroPython in a product, then it's a really different setup as if you're using it in a hobby, trying to make your light turn on and off.

00:33:13.100 --> 00:33:24.100
So using it in a professional setting, you'll probably have a big sort of workflow or setup where you can freeze the code into MicroPython and deploy it or something like this.

00:33:24.100 --> 00:33:26.100
Yeah, in production, what do you put actually on there?

00:33:26.100 --> 00:33:31.100
Do you put, would you go and say, well, we're going to put a PYC file there instead of the Python file?

00:33:31.100 --> 00:33:32.100
Yeah, yeah.

00:33:32.100 --> 00:33:33.100
Or is there stuff like that you might do?

00:33:33.100 --> 00:33:39.100
Yeah, it's not, we have our MPYs sort of instead of PYC, precompiled code, yes.

00:33:39.100 --> 00:33:48.100
But there's sort of another, a further step where you can take precompiled code and then sort of freeze that into a C data structure, which becomes part of the firmware itself.

00:33:48.100 --> 00:33:55.100
So big projects might have hundreds of Python files, which are then all precompiled and frozen and then built into the firmware and then deployed onto the device.

00:33:55.100 --> 00:34:01.100
Is there any room for something like Cython or number or some one of these C compiler type things?

00:34:01.100 --> 00:34:04.100
Yeah, Cython don't really support that.

00:34:04.100 --> 00:34:13.100
But you can write C code as well if you need to, if you really need speed, you can implement a module in C and then tie that into Python quite easily.

00:34:13.100 --> 00:34:20.100
So there are lots of options in terms of making things faster or efficient or the way you do your workflow.

00:34:20.100 --> 00:34:26.100
But sort of to get back to the original question, MP Remote is a new tool that was released in the last version.

00:34:26.100 --> 00:34:32.100
And it's intended to make a workflow, well, give you more options.

00:34:32.100 --> 00:34:39.100
You can use it to copy files on and off, get a REPL on the board, or one of the main features is to mount.

00:34:39.100 --> 00:34:45.100
So make your PC's file system available on the device that you're running on.

00:34:45.100 --> 00:34:52.100
So you mount your PC's file system on your PI board or ESP32 or whatever.

00:34:52.100 --> 00:35:00.100
And then when you go onto the board and do it OS.Lister, you actually can list the files on your PC running on the board.

00:35:00.100 --> 00:35:11.100
So this allows you to basically do all your work on the PC and then your board can import and run code from the PC, read and write files from the PC.

00:35:11.100 --> 00:35:13.100
And so the workflow is very quick.

00:35:13.100 --> 00:35:22.100
And when you're sort of happy, you can then precompile or copy files, MPY files onto the board to run it disconnected from the PC.

00:35:22.100 --> 00:35:23.100
Yeah.

00:35:23.100 --> 00:35:27.100
This is also good for sort of testing integration tests of devices.

00:35:27.100 --> 00:35:32.100
They can sort of interact more closely with the PC that they're testing against.

00:35:32.100 --> 00:35:38.100
And yeah, it just aims to provide you with more tools at your fingertips to make your workflow more productive.

00:35:38.100 --> 00:35:39.100
Yeah, it's neat.

00:35:39.100 --> 00:35:46.100
When I want to put something onto my server to, you know, to upgrade like for site, something like that.

00:35:46.100 --> 00:35:47.100
I'll do some work locally.

00:35:47.100 --> 00:35:48.100
I'll do a get push.

00:35:48.100 --> 00:35:49.100
Some magic will happen.

00:35:49.100 --> 00:35:52.100
GitHub will do a web hook back over to the server.

00:35:52.100 --> 00:35:54.100
The server will grab that.

00:35:54.100 --> 00:36:01.100
It'll pull it down, install the new dependencies, restart the server through like a zero downtime sort of firewall type of thing.

00:36:01.100 --> 00:36:04.100
If I have a robot in a factory, what do I do?

00:36:04.100 --> 00:36:10.100
Is there a continuous deployment equivalent for MicroPython things or what's the story look like over there?

00:36:10.100 --> 00:36:11.100
That's a good question.

00:36:11.100 --> 00:36:12.100
We don't, we don't.

00:36:12.100 --> 00:36:20.100
I think this came up the last time we had a couple chats between like the folks that work on CircuitPython and the folks that work on MicroPython.

00:36:20.100 --> 00:36:23.100
And I think this was kind of a topic that we all said like, yeah, that would be really nice.

00:36:23.100 --> 00:36:28.100
We don't have a sort of recommended or official way to do all of that.

00:36:28.100 --> 00:36:33.100
But what I guess what you're talking about is over the updates maybe kind of answers your question.

00:36:33.100 --> 00:36:34.100
Yeah, basically.

00:36:34.100 --> 00:36:34.100
Yeah.

00:36:34.100 --> 00:36:39.100
Like if I had a Tesla, it sometimes I wake up in the morning, maybe my Tesla does different things.

00:36:39.100 --> 00:36:40.100
It's something like that.

00:36:40.100 --> 00:36:41.100
Yeah.

00:36:41.100 --> 00:36:42.100
MicroPython things.

00:36:42.100 --> 00:36:52.100
Well, if you have a factory full of robots, you probably don't want them to automatically update because you, you need to be there when it happens and you need to control it and do it at the right time and so on.

00:36:52.100 --> 00:36:53.100
Yeah.

00:36:53.100 --> 00:36:55.100
It really depends heavily on the project that you have.

00:36:55.100 --> 00:37:03.100
But over the updates are sort of definitely, yeah, the way to do this and they have been done and they are sort of out in the field.

00:37:03.100 --> 00:37:09.100
And they're done in lots of different ways, like some over Bluetooth where you download the new firmware and then.

00:37:09.100 --> 00:37:11.100
It's a little like what Scott's working on now.

00:37:11.100 --> 00:37:12.100
Yeah.

00:37:12.100 --> 00:37:13.100
Yeah.

00:37:13.100 --> 00:37:16.100
Sort of an automated way to install the new code and then reboot.

00:37:16.100 --> 00:37:27.100
But, and then other places where it's, they're connected by a USB and you can just do a normal DFU upgrade or similar, or maybe over I2C they're listening in a special mode to download new code.

00:37:27.100 --> 00:37:34.100
There are, there are lots of ways to do it and there are lots of sort of parts in MicroPython's code that allow you to do it.

00:37:34.100 --> 00:37:36.100
And it really depends on your project.

00:37:36.100 --> 00:37:38.100
I think probably Scott has a different answer.

00:37:38.100 --> 00:37:45.100
I was going to say from the hobby side, like it's never, I don't, we don't focus on the automated update story.

00:37:45.100 --> 00:37:50.100
But you know, a lot of the folks that use CircuitPython are coming from an Arduino world.

00:37:50.100 --> 00:37:53.100
So Arduino is really common hobby.

00:37:53.100 --> 00:37:57.100
It's based on C, but it's got some like stuff on top of the C stuff.

00:37:57.100 --> 00:38:02.100
But it means that you have to like have a computer that has Arduino installed that can compile the source code.

00:38:02.100 --> 00:38:07.100
And because we focus so much on this interaction of like, it shows up as a USB drive.

00:38:07.100 --> 00:38:11.100
It actually means that anybody, it makes it more accessible to update.

00:38:11.100 --> 00:38:16.100
So if, if I'm remote and somebody wrote the software for me once, but now they want me to update it.

00:38:16.100 --> 00:38:22.100
Like, even though I don't understand how it's doing, I can plug it in, it shows up as a drive and I can copy files over.

00:38:22.100 --> 00:38:31.100
So it's really has been beneficial for, for folks that way, whether it's the Python code they're updating, or a lot of our boards also come with a bootloader,

00:38:31.100 --> 00:38:34.100
which is like the software that manages what you're installing.

00:38:34.100 --> 00:38:38.100
And a lot of our bootloaders for devices also show up as a drive as well.

00:38:38.100 --> 00:38:44.100
So it's still a manual process, but it's a manual process that's gotten better from, from the previous things.

00:38:44.100 --> 00:38:51.100
Right. And from the hobby perspective, you could have a little app or something that says, oh, I noticed we're connected to this thing and we're just gonna, it's out of date.

00:38:51.100 --> 00:38:52.100
We're just going to push some stuff to it.

00:38:52.100 --> 00:38:53.100
Yeah.

00:38:53.100 --> 00:39:01.100
We actually have some community members who've really fleshed out this app called Circup, C-I-R-C-U-P, which you can pip install.

00:39:01.100 --> 00:39:06.100
And that will like figure out all the libraries on your circuit-py drive that are out of date and update them for you.

00:39:06.100 --> 00:39:07.100
Okay.

00:39:07.100 --> 00:39:08.100
Which is pretty neat.

00:39:08.100 --> 00:39:08.100
Yeah.

00:39:08.100 --> 00:39:10.100
It's kind of like the pip of circuit-python.

00:39:10.100 --> 00:39:11.100
Yeah.

00:39:11.100 --> 00:39:14.100
I'm just sure the requirements and concerns are extremely different.

00:39:14.100 --> 00:39:23.100
if you're working with, you know, a small hobby device versus something that is controlling a robot or runs a thing that shouldn't go down.

00:39:23.100 --> 00:39:23.100
Yeah.

00:39:23.100 --> 00:39:30.100
So one thing I wanted to definitely focus on while we were here together, seeing I find it is somewhere, is I do now this.

00:39:30.100 --> 00:39:33.100
The, there's a lot of work that has been done.

00:39:33.100 --> 00:39:38.100
It sounds to me like on the circuit-python side to catch up with micro-python.

00:39:38.100 --> 00:39:39.100
Is that right?

00:39:39.100 --> 00:39:39.100
Mm-hmm .

00:39:39.100 --> 00:39:40.100
You want to tell us about that, Scott?

00:39:40.100 --> 00:39:41.100
Yeah.

00:39:41.100 --> 00:39:49.100
So the history of this is like when Adafruit started paying me to work on what became circuit-python, it was like, okay, I'm going to write a whole lot of code, right?

00:39:49.100 --> 00:39:51.100
So that's when on GitHub I hit fork.

00:39:51.100 --> 00:39:54.100
That's when I add a new port for atmels.md.

00:39:54.100 --> 00:39:56.100
And that's kind of when we split.

00:39:56.100 --> 00:40:06.100
And later on we decided like, oh, you know, like we have enough changes here that it would be a lot of work for both Damien and us to get those changes merged back together.

00:40:06.100 --> 00:40:07.100
And that's still very true.

00:40:07.100 --> 00:40:13.100
But what I said at the time was that we would kind of keep pace for every stable release that we do.

00:40:13.100 --> 00:40:15.100
Keep pace with stable releases from MicroPython.

00:40:15.100 --> 00:40:18.100
That wasn't true for about like two or three years.

00:40:18.100 --> 00:40:20.100
We stopped updating.

00:40:20.100 --> 00:40:21.100
We do.

00:40:21.100 --> 00:40:22.100
It's basically a git merge, right?

00:40:22.100 --> 00:40:24.100
So it's a whole lot of work.

00:40:24.100 --> 00:40:28.100
And so I did, we had six versions of MicroPython to merge in.

00:40:28.100 --> 00:40:29.100
So I did those.

00:40:29.100 --> 00:40:35.100
That's like 112 through 115 or 110, something like that.

00:40:35.100 --> 00:40:38.100
And then since then we've actually updated 116 as well.

00:40:38.100 --> 00:40:44.100
So what's involved with that is like MicroPython has both like a PI folder, which you can think of as kind of like the VM.

00:40:44.100 --> 00:40:46.100
We think of that as kind of the core.

00:40:46.100 --> 00:40:50.100
And then there's separate ports for each main type of chip that we support.

00:40:50.100 --> 00:40:56.100
And we don't really share code with MicroPython for those different implementations for different chips.

00:40:56.100 --> 00:40:58.100
But we do share that core Python VM.

00:40:58.100 --> 00:41:03.100
So a lot of the work to merge in MicroPython is like updating all of that core stuff.

00:41:03.100 --> 00:41:16.100
And the discussions that Damien and I have had along with the other folks that work on these two projects has been like, all right, like what can we do just to get back to this world where we have the same copy of that PI folder?

00:41:16.100 --> 00:41:17.100
Yeah.

00:41:17.100 --> 00:41:23.100
Because there's like a few weird things that like CircuitPython has done that haven't been merged back into MicroPython.

00:41:23.100 --> 00:41:29.100
And we've had discussions about which things are those are interesting and which ones would we want to make configurable and things like that.

00:41:29.100 --> 00:41:30.100
Yeah. Interesting.

00:41:30.100 --> 00:41:39.100
Now that we're updated, we have this foundation where we can have this discussion again, because we actually can tell like what the differences are between the two latest versions of these projects.

00:41:39.100 --> 00:41:39.100
Yeah.

00:41:39.100 --> 00:41:40.100
Yeah.

00:41:40.100 --> 00:41:44.100
Larry Bank out of the live stream says my imaging codec still haven't been merged into MicroPython.

00:41:45.100 --> 00:41:48.100
There's a lot of things that haven't been merged into MicroPython.

00:41:48.100 --> 00:41:48.100
Yeah.

00:41:48.100 --> 00:41:51.100
David, I was going to ask you, you know, what does this mean for MicroPython?

00:41:51.100 --> 00:41:55.100
Like, obviously, it makes sense for CircuitPython to just not be out of date.

00:41:55.100 --> 00:42:00.100
And, you know, the farther you are away from one of these merges, it's more like credit card debt.

00:42:00.100 --> 00:42:01.100
And then a little bit is fine.

00:42:01.100 --> 00:42:04.100
But as it gets farther, it starts to become a problem.

00:42:04.100 --> 00:42:12.100
But in reverse, there's probably a lot of things that people who are engaged on the CircuitPython side could bring back if it was basically the same.

00:42:12.100 --> 00:42:17.100
There's some great things that CircuitPython Scott has done with garbage collection for one thing.

00:42:17.100 --> 00:42:21.100
And it would be great to share a common PY folder at least.

00:42:21.100 --> 00:42:33.100
And we have, as he said, we've had discussions about sort of how we can smooth things or make things more common and where we know we differ, you know, how we can make it easier that we differ.

00:42:33.100 --> 00:42:42.100
Recently, actually, a really good improvement in MicroPython for tab completion so that it didn't have complete underscore and also tab completed imports.

00:42:42.100 --> 00:42:46.100
You do imports based tab and then it lists the tab completes the things you can import.

00:42:46.100 --> 00:42:55.100
Some good improvements for sort of fuzzing and sanitization addresses and sort of various subtle bug fixes that have come across.

00:42:55.100 --> 00:42:58.100
So it's, yeah, look, it's really great to have an open source project.

00:42:58.100 --> 00:43:02.100
And because other people find bugs for you and fix them.

00:43:02.100 --> 00:43:03.100
Yeah.

00:43:03.100 --> 00:43:06.100
The more we can be in line, the better.

00:43:06.100 --> 00:43:12.100
And there are actually other, I mean, there are other people using MicroPython and CircuitPython as we saw with the calculator and Lego.

00:43:12.100 --> 00:43:13.100
Yeah.

00:43:13.100 --> 00:43:22.100
And I think in the early days I was happy people were using MicroPython and wasn't too concerned about sort of people forking and changing things.

00:43:22.100 --> 00:43:31.100
But these days my, I've shifted more towards, well, what can MicroPython do to make it easier for other people to use it without changing it?

00:43:31.100 --> 00:43:36.100
So when they're about to think maybe I need to fork this to do this, you're like, well, why are they about to push that button?

00:43:36.100 --> 00:43:40.100
What can we do to make it more extensible or whatever it needs to be, right?

00:43:40.100 --> 00:43:41.100
Yeah.

00:43:41.100 --> 00:43:44.100
We're going to make someone else's life easier so they don't have to fork.

00:43:44.100 --> 00:43:57.100
Not that we want to accommodate everybody and we can't, but, you know, does it make sense to talk with these people and then make sure that their needs can be met in a sensible way and maybe it helps everyone else as well.

00:43:57.100 --> 00:44:03.100
So, yeah, it just, it helps the community when you have less sort of forking and more cohesion.

00:44:03.100 --> 00:44:04.100
Yeah, it absolutely does.

00:44:04.100 --> 00:44:12.100
I mean, we've seen the Python 2, Python 3 stuff mostly get resolved by people finally moving all onto the same place where the core devs spend their time.

00:44:12.100 --> 00:44:15.100
And I think that that's, it's only been beneficial.

00:44:15.100 --> 00:44:23.100
It seems like a lot of projects are taking some of these ideas and picking up speed, whereas there used to be a lot of hesitancy as there's like too many different paths in the road.

00:44:23.100 --> 00:44:24.100
Yeah.

00:44:24.100 --> 00:44:29.100
Well, I'm just glad I did Python 3 from the beginning with MicroPython.

00:44:29.100 --> 00:44:30.100
I bet you are.

00:44:30.100 --> 00:44:33.100
I was just playing around with this.

00:44:33.100 --> 00:44:40.100
I was able to use like a smiley face emoji as a variable name and it just worked, which kind of blew my mind.

00:44:40.100 --> 00:44:47.100
So that's a super credit to Damien for making MicroPython really, really strong, really robust and really Python.

00:44:47.100 --> 00:44:48.100
Yeah.

00:44:48.100 --> 00:44:57.100
I think, you know, in terms of like CircuitPython and MicroPython, another thing that we can really compliment MicroPython with is like, we can, we're willing to be more experimental.

00:44:57.100 --> 00:45:02.100
Damien alluded to this memory allocation thing that he, I pitched to him at one point and he was like, "Ugh."

00:45:02.100 --> 00:45:05.100
I was like, "Well, we'll put it in CircuitPython, we'll see how it goes.

00:45:05.100 --> 00:45:07.100
And then you can decide whether you want it or not."

00:45:07.100 --> 00:45:16.100
So I think that's a benefit that we can have in CircuitPython is that like, because Damien really wants MicroPython to be stable, we can, we can try things out in CircuitPython.

00:45:16.100 --> 00:45:19.100
And then he can pick the things that he wants to move into MicroPython.

00:45:19.100 --> 00:45:20.100
That's a fantastic way to look at it.

00:45:20.100 --> 00:45:27.100
And the fact that you've got these merge differences, these version differences down to such a small gap.

00:45:27.100 --> 00:45:29.100
But like, well, that would have worked three years ago.

00:45:29.100 --> 00:45:30.100
I'm not sure it works now.

00:45:30.100 --> 00:45:33.100
Now you're basically experimenting on what is the real thing.

00:45:33.100 --> 00:45:47.100
Yeah, that's helpful for like this tab complete thing where like, somebody added it into CircuitPython and we merged it, but then they also made a pull request to MicroPython and like, making sure that they're starting from a closer baseline will help everybody as well.

00:45:47.100 --> 00:45:48.100
Yeah.

00:45:48.100 --> 00:45:51.100
I mean, it's, it was, it was really good to hear you do 1.16.

00:45:51.100 --> 00:45:58.100
And we're trying hard for MicroPython side to release every two months or so, so that it's easier for everybody to upgrade and thing.

00:45:58.100 --> 00:46:00.100
It doesn't take so long for a new release to come out.

00:46:00.100 --> 00:46:01.100
Yeah.

00:46:01.100 --> 00:46:03.100
And what's the schedule for CircuitPython, Scott?

00:46:03.100 --> 00:46:04.100
We don't have a set timeline.

00:46:04.100 --> 00:46:10.100
We do try to get in a rhythm of, of doing, we do both stable and pre-release releases.

00:46:10.100 --> 00:46:18.100
And we don't have kind of a fixed schedule, but we, we tend to try to have like pretty recent pre-releases out.

00:46:18.100 --> 00:46:26.100
If it's been long enough that we're recommending the pre-release over the stable release, we ask ourselves like, okay, why aren't we just calling this a stable release?

00:46:26.100 --> 00:46:27.100
Right.

00:46:27.100 --> 00:46:30.100
That gives us a forcing function to up the stable release.

00:46:30.100 --> 00:46:33.100
We are kind of in this window between major releases.

00:46:33.100 --> 00:46:39.100
So we're currently like doing 7.0 stable or pre-releases for that.

00:46:39.100 --> 00:46:47.100
That's a chance when we did all these merges, because we get a lot of instability, not because the code we're merging in is bad, but the merge is really hard and it's hard to get correct.

00:46:47.100 --> 00:46:56.100
So we're kind of in this like very big state of flux right now with CircuitPython where a lot of things are changing and we're very quickly approaching this.

00:46:56.100 --> 00:47:02.100
Like, all right, we got to stop changing things so that we can stabilize because we're no longer recommending the stable release.

00:47:02.100 --> 00:47:03.100
We're recommending the pre-release.

00:47:03.100 --> 00:47:03.100
Yeah.

00:47:03.100 --> 00:47:09.100
Because like when you, somebody introduces a new board and it's like, oh, well, that new board is not supported in the stable release.

00:47:09.100 --> 00:47:10.100
You have to use the pre-release.

00:47:10.100 --> 00:47:13.100
Like that's a largely a forcing function for us.

00:47:13.100 --> 00:47:15.100
Interesting that the hardware is driving the software like that.

00:47:15.100 --> 00:47:16.100
Yeah.

00:47:16.100 --> 00:47:20.100
And that's a thing from like a number of us are funded by Adafruit to work on it.

00:47:20.100 --> 00:47:24.100
So when Adafruit releases new hardware, we have to decide like how we're going to make it available.

00:47:24.100 --> 00:47:25.100
Absolutely.

00:47:25.100 --> 00:47:25.100
All right.

00:47:25.100 --> 00:47:28.100
Let me take one question from the live stream.

00:47:28.100 --> 00:47:29.100
This is from Murray.

00:47:29.100 --> 00:47:30.100
Hey, Murray.

00:47:30.100 --> 00:47:32.100
I don't actually know the details, but I'll read to you.

00:47:32.100 --> 00:47:33.100
I'm sure you all do.

00:47:33.100 --> 00:47:34.100
Here's a different question.

00:47:34.100 --> 00:47:37.100
What's the state of MicroPython dash lib project as regards to the bigger MicroPython project?

00:47:37.100 --> 00:47:39.100
That's a good question.

00:47:39.100 --> 00:47:44.100
The aim is to switch to, you know, improving MicroPython lib.

00:47:44.100 --> 00:47:50.100
It languished a bit because, well, there was just a lot of stuff to do in the main repository.

00:47:50.100 --> 00:48:02.100
But now that a lot of the code in the main repository has sort of stabilized and settled down and mature, there's more scope now to go and write everything.

00:48:02.100 --> 00:48:06.100
Well, write all the extra bits in Python and put them in MicroPython lib.

00:48:06.100 --> 00:48:11.100
So we have recently reorganized that repository to be a bit clearer as to what's in there.

00:48:11.100 --> 00:48:23.100
And the aim is to maintain it and keep it running and put lots of libraries in there, improve the CPython standard library support and other things.

00:48:23.100 --> 00:48:35.100
There you might have noticed there was AIOBLE, which is a asynchronous Bluetooth library, which is in MicroPython lib and is being used in production.

00:48:35.100 --> 00:48:38.100
It's pretty good in terms of stability.

00:48:38.100 --> 00:48:41.100
It's very good in terms of features and what it can do.

00:48:41.100 --> 00:48:49.100
It's really quite amazing how it makes Bluetooth simple, which is a very asynchronous thing and a very high latency thing.

00:48:49.100 --> 00:48:53.100
So having an asynchronous API is really beneficial.

00:48:53.100 --> 00:49:00.100
So that's just one example of a library that is written in Python, pure Python, and is in MicroPython lib.

00:49:00.100 --> 00:49:03.100
And we aim to continue that trend.

00:49:03.100 --> 00:49:11.100
I know that it's a little bit stale some code in there, but we will fix things in the very near future.

00:49:11.100 --> 00:49:12.100
Yeah.

00:49:12.100 --> 00:49:13.100
Yeah.

00:49:13.100 --> 00:49:14.100
Very neat.

00:49:14.100 --> 00:49:21.100
Speaking of asynchronous, what are some of the, this question, both of you, what are some of the shiny language features that are new and neat in there?

00:49:21.100 --> 00:49:22.100
Like asynchronous awake?

00:49:22.100 --> 00:49:25.100
Can I do that with the Bluetooth library or Walrus?

00:49:25.100 --> 00:49:27.100
Can I do a Walrus operator?

00:49:27.100 --> 00:49:28.100
What's going on?

00:49:28.100 --> 00:49:29.100
Like, what can I do?

00:49:29.100 --> 00:49:36.100
I think it's a micro async.io, which has, is in its third sort of iteration, third version.

00:49:36.100 --> 00:49:40.100
And that's been, I think about a year old now, that version.

00:49:40.100 --> 00:49:44.100
And that also has been used in quite a few production systems.

00:49:44.100 --> 00:49:47.100
that's also quite stable.

00:49:47.100 --> 00:50:00.100
And I think is a really good showcase of using Python on microcontrollers because things on microcontrollers, well, some things take time, like reading a sensor and waiting for a Bluetooth packet to arrive.

00:50:00.100 --> 00:50:04.100
And you've got to do lots of things at once, like blink a light to indicate progress.

00:50:04.100 --> 00:50:07.100
It'd be great to be able to take them as those events come in, right?

00:50:07.100 --> 00:50:08.100
Yeah.

00:50:08.100 --> 00:50:25.100
So event based, but also easy to sort of use because I mean, multi threading using, you know, threading in Python, you can do, you can do that on some micro Python ports, but it's heavy weight in the sense that it uses a lot of memory for each stack, a stack of each thread.

00:50:25.100 --> 00:50:27.100
And it's slow to switch and respond.

00:50:27.100 --> 00:50:29.100
So it's, it's, it's not a great solution.

00:50:29.100 --> 00:50:38.100
So cooperative multitasking, which is what asyncio is, is I think a better solution than threading on a microcontroller and even on a desktop.

00:50:38.100 --> 00:50:38.100
Yeah.

00:50:38.100 --> 00:50:40.100
And it works really well.

00:50:40.100 --> 00:50:46.100
When you have something that's well suited to asyncio, it's really, it's a really fun experience to program something that way.

00:50:46.100 --> 00:50:52.100
It's aptly named because what it's really well suited to is waiting on things like IO, right?

00:50:52.100 --> 00:50:53.100
Right.

00:50:53.100 --> 00:50:58.100
Waiting on these devices, these various sensors and stuff to come back and just say, Hey, I've got an input.

00:50:58.100 --> 00:51:00.100
I've got a call back or whatever.

00:51:00.100 --> 00:51:00.100
Right?

00:51:00.100 --> 00:51:02.100
Like that's, it seems like the perfect case.

00:51:02.100 --> 00:51:05.100
It's not like, well, we're trying to do all this computational stuff.

00:51:05.100 --> 00:51:06.100
Asyncrasy.

00:51:06.100 --> 00:51:08.100
Well, that doesn't work as quite well that way.

00:51:08.100 --> 00:51:09.100
Yeah.

00:51:09.100 --> 00:51:12.100
Like, you know, you may just want to wait for a pin to change from high to low.

00:51:12.100 --> 00:51:16.100
So you spawn a task and you do, you know, a weight on the pin.

00:51:16.100 --> 00:51:20.100
And then when that, when that statement continues, it means the pin has changed.

00:51:20.100 --> 00:51:24.100
That's hard to do in a sort of callback based system.

00:51:24.100 --> 00:51:29.100
well, it's not, I mean, it's just a different conceptually and maybe it's harder to reason about things.

00:51:29.100 --> 00:51:39.100
So there are, there, yeah, we have support for these fancy features, asyncio and the walrus operator we had in f-strings and not yet, you know, I think circuit Python has f-strings.

00:51:39.100 --> 00:51:41.100
Oh, you guys already have the f-strings.

00:51:41.100 --> 00:51:43.100
Damien has a higher bar for merging than we do.

00:51:43.100 --> 00:51:44.100
Interesting.

00:51:44.100 --> 00:51:50.100
So in circuit Python side, we have f-strings merged in, but we haven't done this work on the async stuff that Damien's really done.

00:51:50.100 --> 00:51:54.100
Because our audience's beginners are really pushed us not to do async stuff.

00:51:54.100 --> 00:52:00.100
Because I think something that beginners don't necessarily understand is like the computer literally does things in order that you want it to do.

00:52:00.100 --> 00:52:01.100
Yeah.

00:52:01.100 --> 00:52:07.100
So a lot of the examples that I, that would, that we use and that we get to people to doing is just doesn't use async.

00:52:07.100 --> 00:52:09.100
So it's not been a focus of ours.

00:52:09.100 --> 00:52:17.100
So I think that's a lot of the reasons to merge was to get the newer async stuff in and kind of hope that somebody would come along and turn it on and make sure it's all working.

00:52:17.100 --> 00:52:19.100
But kind of, we've had the opposite, opposite approach.

00:52:19.100 --> 00:52:29.100
And I think talking about async, one of the things that we've been thinking about is like, async is very networking oriented in terms of Python.

00:52:29.100 --> 00:52:34.100
And it's not necessarily clear how that impacts hardware APIs and like waiting for pins and things.

00:52:34.100 --> 00:52:41.100
So I think it's really interesting to think about how async await applies to things like spy transactions and I squared C transactions.

00:52:41.100 --> 00:52:48.100
And, and what exactly like, like we, I talked about how circuit Python has a different hardware layer than micro Python does.

00:52:48.100 --> 00:52:54.100
And like, I don't think either of us have really come up with a, like, what does that look like when you have async await support?

00:52:54.100 --> 00:52:57.100
So I'm curious to see what, what Damien comes up with.

00:52:57.100 --> 00:52:58.100
Yeah.

00:52:58.100 --> 00:53:04.100
I mean, we do, we have recently merged I2S support, which has preliminary asyncio support in it as well.

00:53:04.100 --> 00:53:09.100
So you can, yeah, asynchronously send and receive audio buffers.

00:53:09.100 --> 00:53:15.100
We also have async support for pins using, well, a small sort of piece of wrapper code.

00:53:15.100 --> 00:53:19.100
A thread safe flag is our main sort of interaction between interrupts and asyncio.

00:53:19.100 --> 00:53:26.100
So you create a thread safe flag object on the asyncio side, you can wait on the flag and on the IRQ side.

00:53:26.100 --> 00:53:32.100
So some event happens like a spy transaction completes and you get an IRQ and then you can set the thread safe flag.

00:53:32.100 --> 00:53:37.100
And then that will mean that the task waiting on that can continue.

00:53:37.100 --> 00:53:45.100
So, yeah, but I agree, Scott, that it's still early days with API for connecting IRQC and things like that into the async world.

00:53:45.100 --> 00:53:55.100
I know one project sort of working on uses asyncio and Bluetooth and thread safe flag with pins, but nothing else is async.

00:53:55.100 --> 00:53:58.100
But the things that are async are very important to be async.

00:53:58.100 --> 00:54:02.100
And a lot of the time just asyncio.sleep is the thing you want.

00:54:02.100 --> 00:54:04.100
And yeah, just wait, wait for a bit of time.

00:54:04.100 --> 00:54:07.100
So you're waiting on a PNN sleeping is actually gets you a long way.

00:54:07.100 --> 00:54:18.100
So, but I think it's still early days and even asyncio in CPython is sort of still early days in the sense that they're still trying to work through what API is good for streams.

00:54:18.100 --> 00:54:25.100
And there's trio as well, which is providing good feedback to see Python on asyncio.

00:54:25.100 --> 00:54:30.100
So it's still early days in the whole sort of Python space.

00:54:30.100 --> 00:54:31.100
Yeah.

00:54:31.100 --> 00:54:38.100
There's my favorite unsync, which is a unification layer on top of threads, multiprocessing and asyncio.

00:54:38.100 --> 00:54:45.100
And it's like, I think the whole implementation is 126 lines of Python in one file, but it's, it's glorious.

00:54:45.100 --> 00:54:46.100
All right.

00:54:46.100 --> 00:54:48.100
One final topic I want to touch on.

00:54:48.100 --> 00:54:55.100
There's been a lot of interesting work about making Python regular old server side, desktop side, CPython faster.

00:54:55.100 --> 00:54:58.100
There's been a bunch of interesting things coming on.

00:54:58.100 --> 00:55:01.100
Pigeon from Microsoft is kind of making a comeback.

00:55:01.100 --> 00:55:03.100
I think Anthony Shaw is doing some work on that.

00:55:03.100 --> 00:55:05.100
Maybe Brett Cannon as well.

00:55:05.100 --> 00:55:06.100
There's Cinder.

00:55:06.100 --> 00:55:23.100
The Instagram crew has released with really interesting stuff going on about making a lot of interesting changes in the runtime about making it faster stuff about like immortal instances that are sort of not subject to GC and reference counting and whatnot.

00:55:23.100 --> 00:55:32.100
We've got the latest language summit, you know, is talking about interesting things he's doing and focusing on to try to sort of accomplish the same goal.

00:55:32.100 --> 00:55:35.100
Like, is any of this stuff influencing what you all are thinking about?

00:55:35.100 --> 00:55:36.100
Or is it just not really applicable?

00:55:36.100 --> 00:55:44.100
Yeah, this is a really big topic because Python has a long history and it's used in a lot of places for a lot of different things.

00:55:44.100 --> 00:55:48.100
And it's built by a community, unlike other languages.

00:55:48.100 --> 00:55:56.100
I mean, yeah, lots of languages built by communities, but Python in particular is one of the more popular languages that is really just community run and funded.

00:55:56.100 --> 00:56:05.100
You might say it as something like it's built by a very diverse community, technically speaking, as opposed to say JavaScript, which is almost always web.

00:56:05.100 --> 00:56:11.100
And then kind of recently, it's been a little node, but like it's astrophysicists, it's embedded, it's data science, it's web.

00:56:11.100 --> 00:56:15.100
Like there's a lot of different pressures and areas that Python gets put in.

00:56:15.100 --> 00:56:16.100
Yeah.

00:56:16.100 --> 00:56:19.100
And, and the focus has not been on performance.

00:56:19.100 --> 00:56:23.100
It's been on usability and features and keeping it up to date.

00:56:23.100 --> 00:56:24.100
Backwards compatibility.

00:56:24.100 --> 00:56:25.100
Yeah.

00:56:25.100 --> 00:56:26.100
Yeah.

00:56:26.100 --> 00:56:30.100
I mean, it's been, it's such a, it is an old language that has evolved a long way.

00:56:30.100 --> 00:56:33.100
Like C is an old language, but C hasn't changed that much.

00:56:33.100 --> 00:56:34.100
C++ is an old language.

00:56:34.100 --> 00:56:40.100
Well, C++ has changed a lot, but it's got a very big community around it and lots of production.

00:56:40.100 --> 00:56:46.100
But Python is sort of, yeah, it's got such an sort of amazing and passionate community who do all this stuff for free.

00:56:46.100 --> 00:56:54.100
And performance is something that's sort of always been in the back of people's minds, but it needs a lot of work and it kind of needs a stable Python language to perform.

00:56:54.100 --> 00:56:59.100
You know, you can't optimize along the way of adding features.

00:56:59.100 --> 00:57:00.100
It's really hard.

00:57:00.100 --> 00:57:07.100
But anyway, this is sort of just to say that it's a big topic and lots of people have tried to make Python faster.

00:57:07.100 --> 00:57:08.100
Python faster.

00:57:08.100 --> 00:57:12.100
And PyPy is an amazing piece of software that makes Python faster.

00:57:12.100 --> 00:57:21.100
One of my first big Python projects, we used PyPy because it was really, really good and made things a lot faster, like 10 times faster.

00:57:21.100 --> 00:57:25.100
And we didn't have any sort of extension modules that didn't work with PyPy.

00:57:25.100 --> 00:57:28.100
They all did work with PyPy and it was, it was really, really good.

00:57:28.100 --> 00:57:30.100
So use that if it works for you.

00:57:30.100 --> 00:57:32.100
Although PyPy, it's a bit big though.

00:57:32.100 --> 00:57:35.100
But it's, what it does, it does really well.

00:57:35.100 --> 00:57:40.100
So on the other hand, making CPython faster, just the core CPython, I think is a fantastic goal.

00:57:40.100 --> 00:57:50.100
And I think probably the thing I would say is that any interest in Python is good for CircuitPython and MicroPython and the general Python ecosystem.

00:57:50.100 --> 00:57:53.100
Just because it's people working on Python and trying to make it better.

00:57:53.100 --> 00:57:59.100
Whether or not, you know, there's something that comes out at the end is kind of secondary.

00:57:59.100 --> 00:58:05.100
It's that people are interested in hacking on things and having fun and things will come out of it.

00:58:05.100 --> 00:58:10.100
Part of it, maybe it's not going to be a very, a super fast CPython at the end, although that would be really great.

00:58:10.100 --> 00:58:13.100
And that's what people are really, really working towards now.

00:58:13.100 --> 00:58:18.100
But I just think the general interest in Python is the biggest thing that will come to us.

00:58:18.100 --> 00:58:26.100
Is that, you know, Python will be in the headlines more and people will be talking about how it's faster now and it's interesting and it will change people's perceptions.

00:58:26.100 --> 00:58:29.100
And then people will learn more about MicroPython and through Python and C.

00:58:29.100 --> 00:58:32.100
Yeah, we'll start having to deal with all these articles.

00:58:32.100 --> 00:58:35.100
People are leaving C and Go because it's so slow now.

00:58:35.100 --> 00:58:37.100
And back on the table.

00:58:37.100 --> 00:58:39.100
Well, yeah.

00:58:39.100 --> 00:58:42.100
Python is such an ergonomic language.

00:58:42.100 --> 00:58:43.100
It's so great.

00:58:43.100 --> 00:58:44.100
Yeah, it's so lovely.

00:58:44.100 --> 00:58:48.100
I think actually the performance side is just so, so many layers, right?

00:58:48.100 --> 00:58:55.100
Like it's slow, except for if you use the SciPy libraries, all of a sudden it's really fast and then like, it's just, it's super interesting.

00:58:55.100 --> 00:58:56.100
It really depends what you're using it for.

00:58:56.100 --> 00:59:02.100
And I don't think you should, slow Python shouldn't be, it should be banished to that concept.

00:59:02.100 --> 00:59:05.100
It should be like, use Python and see if it works for you.

00:59:05.100 --> 00:59:08.100
Because, and if it doesn't, you know, then use a different language.

00:59:08.100 --> 00:59:10.100
But that's the same you say with any language.

00:59:10.100 --> 00:59:12.100
It's like use the language if it's going to work for you.

00:59:12.100 --> 00:59:13.100
Yeah.

00:59:13.100 --> 00:59:18.100
And oftentimes it's just, well, you're not using the right part of the Python ecosystem to address that problem.

00:59:18.100 --> 00:59:19.100
Yeah.

00:59:19.100 --> 00:59:20.100
Right.

00:59:20.100 --> 00:59:21.100
Yeah.

00:59:21.100 --> 00:59:22.100
Scott, do you want to maybe weigh in on that real quick before we wrap it up?

00:59:22.100 --> 00:59:23.100
We're about out of time.

00:59:23.100 --> 00:59:25.100
I generally, I delegate to Damian.

00:59:25.100 --> 00:59:28.100
Damian does a lot of work on this core and makes it really fast.

00:59:28.100 --> 00:59:33.100
I try not to get sucked into the performance stuff because I'm trying to do the workflow side of things.

00:59:33.100 --> 00:59:45.100
But I did want to point out for those folks that are coming from CPython and may not have done embedded Python, is that the boards that we run on, but both MicroPython and CircuitPython, we're very much in Moore's law territory still.

00:59:45.100 --> 00:59:51.100
The first board that I supported is 48 megahertz, but the TNT4 runs at 600 megahertz.

00:59:51.100 --> 00:59:56.100
So we can get a lot of speed within this domain by paying a few dollars more.

00:59:56.100 --> 01:00:02.100
That's important to realize is that like the things that we do for speed may not be the things that you would do in CPython.

01:00:02.100 --> 01:00:03.100
Interesting.

01:00:03.100 --> 01:00:04.100
Yeah.

01:00:04.100 --> 01:00:08.100
There's hardly a make the computer faster answer at the CPython level.

01:00:08.100 --> 01:00:12.100
We do kind of have a turbo button if we can just clock the CPU faster.

01:00:12.100 --> 01:00:13.100
Yeah.

01:00:13.100 --> 01:00:14.100
Awesome.

01:00:14.100 --> 01:00:15.100
I thought it had a turbo button.

01:00:15.100 --> 01:00:16.100
I loved it.

01:00:16.100 --> 01:00:20.100
And it was probably just as fast as what we're running MicroPython and CircuitPython on now.

01:00:20.100 --> 01:00:21.100
How interesting.

01:00:21.100 --> 01:00:22.100
Yeah, for sure.

01:00:22.100 --> 01:00:23.100
All right, you guys.

01:00:23.100 --> 01:00:25.100
Well, we could go on and on and on about this.

01:00:25.100 --> 01:00:28.100
Maybe we'll have to do another episode, but I think we're probably out of time.

01:00:28.100 --> 01:00:31.100
So I'm going to ask you a couple of wrap up questions.

01:00:31.100 --> 01:00:35.100
I normally ask the editor and IPI library.

01:00:35.100 --> 01:00:40.100
Maybe we'll go ahead and do that, but I want to throw in one more thing as well.

01:00:40.100 --> 01:00:42.100
So let's do editor first.

01:00:42.100 --> 01:00:48.100
If you're going to write some code that runs on either Circuit or MicroPython devices, what editor do you use?

01:00:48.100 --> 01:00:49.100
Vim.

01:00:49.100 --> 01:00:50.100
I've used Vim since day one, I think.

01:00:50.100 --> 01:00:51.100
Right on.

01:00:51.100 --> 01:00:52.100
Scott?

01:00:52.100 --> 01:00:53.100
I use Sublime Text.

01:00:53.100 --> 01:00:54.100
Cool.

01:00:54.100 --> 01:00:55.100
Very good.

01:00:55.100 --> 01:00:56.100
Very good.

01:00:56.100 --> 01:00:57.100
Notable PyPI package.

01:00:57.100 --> 01:00:58.100
Something out there that's pretty cool.

01:00:58.100 --> 01:01:01.100
I've seen a bunch of things going by in the live chat as we're talking.

01:01:01.100 --> 01:01:03.100
It's very active today.

01:01:03.100 --> 01:01:10.100
So I think HTTP IE is really quite a cool tool for like instead of W get.

01:01:10.100 --> 01:01:11.100
I've 100% moved to HTTP IE.

01:01:11.100 --> 01:01:21.100
I guess it's like curl or W get, but you get like syntax highlighting for your response.

01:01:21.100 --> 01:01:22.100
It's beautiful.

01:01:22.100 --> 01:01:26.100
And it's actually a good tool for when you're like working with MicroPython.

01:01:26.100 --> 01:01:29.100
If MicroPython actually accepts, you know, HTTP.

01:01:29.100 --> 01:01:31.100
It's not just for pretty printing.

01:01:31.100 --> 01:01:34.100
It's good for actual workflow as well.

01:01:34.100 --> 01:01:35.100
Yeah.

01:01:35.100 --> 01:01:36.100
Well, Scott, you got one to recommend?

01:01:36.100 --> 01:01:40.100
For the folks in CPython who are getting into hardware, if you have a Raspberry Pi, Blinka

01:01:40.100 --> 01:01:41.100
is great.

01:01:41.100 --> 01:01:42.100
Blinka.

01:01:42.100 --> 01:01:43.100
Okay.

01:01:43.100 --> 01:01:45.100
As the foundation, you'll want to find a device that you're interested in using and then

01:01:45.100 --> 01:01:46.100
you can use Blinka.

01:01:46.100 --> 01:01:47.100
Yeah.

01:01:47.100 --> 01:01:48.100
I don't know.

01:01:48.100 --> 01:01:49.100
That's a really good one.

01:01:49.100 --> 01:01:50.100
The HTTP is a good one.

01:01:50.100 --> 01:01:52.100
I'll have to take a look at that.

01:01:52.100 --> 01:01:53.100
Yeah.

01:01:53.100 --> 01:01:56.100
I've completely switched on all my servers and even on my desktop to just have that for a

01:01:56.100 --> 01:01:57.100
testy thing.

01:01:57.100 --> 01:01:58.100
It's really, really good.

01:01:58.100 --> 01:01:59.100
Okay.

01:01:59.100 --> 01:02:01.100
Here's the extra third question that normally we don't get.

01:02:01.100 --> 01:02:04.100
So if you're going to work on a project, I have all these ideas of things that I would

01:02:04.100 --> 01:02:10.100
love to create and stuff, but I don't ever know really what the right hardware for it

01:02:10.100 --> 01:02:11.100
is.

01:02:11.100 --> 01:02:14.100
So I guess, Damon, you first, if you're going to work on something and you've got some idea,

01:02:14.100 --> 01:02:16.100
you know, what kind of board would you get?

01:02:16.100 --> 01:02:20.100
Maybe you have to give us a little background, like the scope of the idea or the context, but

01:02:20.100 --> 01:02:23.100
what board would you play with if people are thinking of getting into stuff and playing

01:02:23.100 --> 01:02:24.100
with it and so on?

01:02:24.100 --> 01:02:25.100
Yeah, that's a good question.

01:02:25.100 --> 01:02:27.100
It really depends on the project.

01:02:27.100 --> 01:02:34.100
If you want something like the PI board, we started making and selling that like eight

01:02:34.100 --> 01:02:35.100
years ago.

01:02:35.100 --> 01:02:36.100
That was the first Kickstarter.

01:02:36.100 --> 01:02:38.100
And we still sell a lot of these.

01:02:38.100 --> 01:02:41.100
The original PI board down a little bit of that page.

01:02:41.100 --> 01:02:42.100
Yeah, that one.

01:02:42.100 --> 01:02:46.100
And that's just a really good general purpose workhorse with good IO support.

01:02:46.100 --> 01:02:49.100
And I use it still today to do things.

01:02:49.100 --> 01:02:50.100
And that's really cool.

01:02:50.100 --> 01:02:54.100
If you want high performance Wi-Fi Bluetooth, if you just scroll back up over it, then the

01:02:54.100 --> 01:02:57.100
new PI board D is what you need.

01:02:57.100 --> 01:03:02.100
And that, you know, that has really fast Wi-Fi and really good Bluetooth support.

01:03:02.100 --> 01:03:07.100
the Raspberry pypyco, I think is a really another really good option if you want something that

01:03:07.100 --> 01:03:11.100
has is relatively cheap and has good functionality.

01:03:11.100 --> 01:03:15.100
And this new PI O programable IO stuff that Scott was talking about.

01:03:15.100 --> 01:03:17.100
That's also a really cool option.

01:03:17.100 --> 01:03:19.100
There's a whole lot of stuff out there.

01:03:19.100 --> 01:03:20.100
Yeah, there's a lot of choice.

01:03:20.100 --> 01:03:22.100
And it's all really good choice.

01:03:22.100 --> 01:03:23.100
Exciting.

01:03:23.100 --> 01:03:24.100
Yeah, very exciting.

01:03:24.100 --> 01:03:27.100
And not super expensive, as you all were saying, like you can get them and try them.

01:03:27.100 --> 01:03:29.100
It's not a huge investment.

01:03:29.100 --> 01:03:33.100
Scott, what's your your dream board that you would recommended board you would start with?

01:03:33.100 --> 01:03:35.100
I don't think there's any one board.

01:03:35.100 --> 01:03:41.100
I see some people trying to make this particular board they have do something that it doesn't

01:03:41.100 --> 01:03:42.100
necessarily do very well.

01:03:42.100 --> 01:03:48.100
So what I recommend people is actually go to learn.adafruit.com, which is where Adafruit

01:03:48.100 --> 01:03:54.100
has all of our tutorials and look there, find a project that is close or exactly what you

01:03:54.100 --> 01:03:55.100
want to do.

01:03:55.100 --> 01:03:58.100
And then you'll see all of the stuff that you need to do that.

01:03:58.100 --> 01:04:03.100
That's where I would start, because not only are you picking the hardware that you that you

01:04:03.100 --> 01:04:06.100
could use to do what you want, but you're also getting all the software to do it as well.

01:04:06.100 --> 01:04:10.100
You're definitely getting a head start by starting from an existing project.

01:04:10.100 --> 01:04:12.100
Yeah, that's an interesting perspective.

01:04:12.100 --> 01:04:14.100
Like instead of what board do I want?

01:04:14.100 --> 01:04:15.100
Like what project?

01:04:15.100 --> 01:04:16.100
What thing do I want to create and solve?

01:04:16.100 --> 01:04:19.100
Now what hardware do I need to like facilitate that?

01:04:19.100 --> 01:04:20.100
Yeah.

01:04:20.100 --> 01:04:24.100
And then the other thing you can do is if you go to circuitpython.org/downloads, you actually

01:04:24.100 --> 01:04:26.100
can type different features.

01:04:26.100 --> 01:04:29.100
Like you want to see all the BLE boards or the Wi-Fi boards.

01:04:29.100 --> 01:04:32.100
It will filter out the boards there for you.

01:04:32.100 --> 01:04:34.100
And those are all the boards that circuitpython runs on.

01:04:34.100 --> 01:04:35.100
Very neat.

01:04:35.100 --> 01:04:36.100
Very neat.

01:04:36.100 --> 01:04:37.100
All right, you guys.

01:04:37.100 --> 01:04:39.100
Well, thank you for being here and sharing this.

01:04:39.100 --> 01:04:42.100
It's really cool to see the two projects working more closely together.

01:04:42.100 --> 01:04:43.100
So final call to action.

01:04:43.100 --> 01:04:44.100
People want to get started.

01:04:44.100 --> 01:04:45.100
One from each of you, I guess.

01:04:45.100 --> 01:04:47.100
Like what would you tell people?

01:04:47.100 --> 01:04:48.100
Well, go to micropython.org.

01:04:48.100 --> 01:04:50.100
Go to forum.micropython.org.

01:04:50.100 --> 01:04:54.100
Where our forum is, that's sort of the most active place for discussion.

01:04:54.100 --> 01:05:00.100
And then GitHub micropython/micropython is also where all of the development action is.

01:05:00.100 --> 01:05:01.100
Scott?

01:05:01.100 --> 01:05:07.100
For circuitpython, you can go to circuitpython.org and the /downloads is particularly useful

01:05:07.100 --> 01:05:09.100
if you happen to have a device already in hand.

01:05:09.100 --> 01:05:13.100
That will get you the file for that particular device.

01:05:13.100 --> 01:05:17.100
If you want to hang out with us that are working on circuitpython, we do have an Adafruit

01:05:17.100 --> 01:05:18.100
Discord server.

01:05:18.100 --> 01:05:19.100
Everybody is welcome to join.

01:05:19.100 --> 01:05:23.100
You can go to the URL adafru.it/discord.

01:05:23.100 --> 01:05:25.100
That's the short link for it.

01:05:25.100 --> 01:05:26.100
And that will get you in there.

01:05:26.100 --> 01:05:28.100
You'll see there's a circuitpython dev channel.

01:05:28.100 --> 01:05:30.100
That's where we coordinate all the development.

01:05:30.100 --> 01:05:34.100
And on GitHub, we're github.com/adafruit/circuitpython.

01:05:34.100 --> 01:05:38.100
We're moving more and more to, we have a circuitpython organization as well.

01:05:38.100 --> 01:05:42.100
So maybe at some point we'll do, we'll be github.com/circuitpython/circpython.

01:05:42.100 --> 01:05:43.100
Right on.

01:05:43.100 --> 01:05:48.100
I was also just going to throw out that you do a fair number of live stream Twitch-like

01:05:48.100 --> 01:05:49.100
things.

01:05:49.100 --> 01:05:51.100
Maybe just tell people about that as well if they want to catch you there.

01:05:51.100 --> 01:05:52.100
Yeah.

01:05:52.100 --> 01:05:56.100
So I started live streaming kind of like as the pandemic ramped up as just like something

01:05:56.100 --> 01:05:57.100
I've wanted to do.

01:05:57.100 --> 01:05:58.100
So I started doing it regularly.

01:05:58.100 --> 01:06:01.100
I do it at 2:00 PM Pacific on the Adafruit channels.

01:06:01.100 --> 01:06:03.100
So you can go to youtube.com/adafruit.

01:06:03.100 --> 01:06:05.100
It's called deep dive with Scott.

01:06:05.100 --> 01:06:07.100
There's a playlist there.

01:06:07.100 --> 01:06:13.100
They tend to be about two hours or more and very casual, no editing, but I answer questions

01:06:13.100 --> 01:06:17.100
and show off into the weeds of circuitpython stuff.

01:06:17.100 --> 01:06:20.100
And we've gotten a lot of contributors out of that, which has been great.

01:06:20.100 --> 01:06:21.100
Yeah.

01:06:21.100 --> 01:06:22.100
Fantastic.

01:06:22.100 --> 01:06:24.100
So if you want to hang out on a Friday afternoon, everybody's welcome to do that.

01:06:24.100 --> 01:06:27.100
And we've talked to Damien about joining that at some point as well.

01:06:27.100 --> 01:06:28.100
Cool.

01:06:28.100 --> 01:06:30.100
Well, I'll look forward to seeing you both over there as well.

01:06:30.100 --> 01:06:31.100
So thanks for being on the show.

01:06:31.100 --> 01:06:32.100
Thank you.

01:06:32.100 --> 01:06:33.100
Thanks, Michael.

01:06:33.100 --> 01:06:34.100
Yeah, you bet.

01:06:34.100 --> 01:06:37.100
This has been another episode of Talk Python To Me.

01:06:37.100 --> 01:06:40.100
Our guests on this episode were Damien George and Scott Shawcroft.

01:06:40.100 --> 01:06:45.100
It's been brought to you by Sentry and Linode and the transcripts are sponsored by Assembly

01:06:45.100 --> 01:06:46.100
AI.

01:06:46.100 --> 01:06:47.100
Take some stress out of your life.

01:06:47.100 --> 01:06:51.100
Get notified immediately about errors in your web applications with Sentry.

01:06:51.100 --> 01:06:59.100
Just visit talkpython.fm/sentry and get started for free and use the promo code talkpython2021

01:06:59.100 --> 01:07:01.100
when you sign up.

01:07:01.100 --> 01:07:05.100
Simplify your infrastructure and cut your cloud bills in half with Linode's Linux virtual

01:07:05.100 --> 01:07:06.100
machines.

01:07:06.100 --> 01:07:09.100
Develop, deploy, and scale your modern applications faster and easier.

01:07:09.100 --> 01:07:14.100
Visit talkpython.fm/linode and click the create free account button to get started.

01:07:14.100 --> 01:07:18.100
Transcripts for this and all of our episodes are brought to you by Assembly AI.

01:07:18.100 --> 01:07:21.100
Do you need a great automatic speech to text API?

01:07:21.100 --> 01:07:23.100
Get human level accuracy in just a few lines of code.

01:07:23.100 --> 01:07:26.100
Visit talkpython.fm/AssemblyAI.

01:07:26.100 --> 01:07:28.100
Want to level up your Python?

01:07:28.100 --> 01:07:31.100
We have one of the largest catalogs of Python video courses over at Talk Python.

01:07:31.100 --> 01:07:36.100
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:07:36.100 --> 01:07:39.100
And best of all, there's not a subscription in sight.

01:07:39.100 --> 01:07:42.100
Check it out for yourself at training.talkpython.fm.

01:07:42.100 --> 01:07:47.100
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

01:07:47.100 --> 01:07:48.100
We should be right at the top.

01:07:48.100 --> 01:07:54.100
You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct

01:07:54.100 --> 01:07:57.100
RSS feed at /rss on talkpython.fm.

01:07:57.100 --> 01:08:01.100
We're live streaming most of our recordings these days.

01:08:01.100 --> 01:08:05.100
If you want to be part of the show and have your comments featured on the air, be sure

01:08:05.100 --> 01:08:09.100
to subscribe to our YouTube channel at talkpython.fm/youtube.

01:08:09.100 --> 01:08:11.100
This is your host, Michael Kennedy.

01:08:11.100 --> 01:08:12.100
Thanks so much for listening.

01:08:12.100 --> 01:08:13.100
I really appreciate it.

01:08:13.100 --> 01:08:15.100
Now get out there and write some Python code.

01:08:15.100 --> 01:08:16.100
I'll see you next time.

01:08:16.100 --> 01:08:16.100
I'll see you next time.

01:08:16.100 --> 01:08:17.100
Bye.

01:08:17.100 --> 01:08:18.100
Bye.

01:08:18.100 --> 01:08:19.100
Bye.

01:08:19.100 --> 01:08:20.100
Bye.

01:08:20.100 --> 01:08:21.100
Bye.

01:08:21.100 --> 01:08:22.100
Bye.

01:08:22.100 --> 01:08:23.100
Bye.

01:08:23.100 --> 01:08:24.100
Bye.

01:08:24.100 --> 01:08:25.100
Bye.

01:08:25.100 --> 01:08:26.100
Bye.

01:08:26.100 --> 01:08:27.100
Bye.

01:08:27.100 --> 01:08:28.100
Bye.

01:08:28.100 --> 01:08:29.100
Bye.

01:08:29.100 --> 01:08:30.100
Bye.

01:08:30.100 --> 01:08:31.100
Bye.

01:08:31.100 --> 01:08:32.100
Bye.

01:08:32.100 --> 01:08:33.100
Bye.

01:08:33.100 --> 01:08:33.100
Bye.

01:08:33.100 --> 01:08:33.600
you

01:08:33.600 --> 01:08:34.100
you

01:08:34.100 --> 01:08:35.100
Thank you.

01:08:35.100 --> 01:08:35.960
Thank you.

01:08:35.960 --> 01:09:05.940
Thank you.

