00:00:00 You've probably heard the term syntactic sugar.

00:00:02 That is syntax within a programming language that is designed to make things easier to read or to express.

00:00:08 It makes the language sweeter for humans to use.

00:00:11 It turns out Brett Cannon has spent two years diving into and writing about Python's sweet language features

00:00:19 and how they really work down inside CPython.

00:00:22 He joins me on the show today to dive into a few of the more relevant posts

00:00:26 he's written about.

00:00:27 This is Talk Python to Me, episode 441, recorded November 1st, 2023.

00:00:32 Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:50 This is your host, Michael Kennedy.

00:00:52 Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython.

00:00:57 Both on fosstodon.org.

00:00:59 Keep up with the show and listen to over seven years of past episodes at talkpython.fm.

00:01:04 We've started streaming most of our episodes live on YouTube.

00:01:08 Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.

00:01:17 This episode is sponsored by us over at Talk Python Training.

00:01:21 Did you know that we have over 250 hours of Python courses?

00:01:25 Yeah, that's right.

00:01:27 Check them out at talkpython.fm/courses.

00:01:29 Brett, welcome back to Talk Python to Me.

00:01:34 You've been here a time or two.

00:01:35 Always great to have you here.

00:01:37 Well, thanks for having me yet again, Michael.

00:01:38 I'm glad I've not worn out my welcome quite yet.

00:01:41 You always have so much cool stuff going on and so many interesting perspectives.

00:01:44 Some would call them interesting.

00:01:47 Whether that's a positive or negative is still open to interpretation.

00:01:51 May you program in interesting times, as the old ancient proverb goes.

00:01:55 Mm-hmm.

00:01:56 So, been here a bunch of times, but real quick, just tell people a bit about yourself before we jump in.

00:02:01 Sure.

00:02:01 Just in case they don't know you.

00:02:02 Yeah.

00:02:03 Name's Brett Cannon.

00:02:04 I live in Vancouver on the unceded territories of the Squamish, Tsleil-Waututh, and Musqueam First Nations.

00:02:10 I am currently the dev manager for the Python extension in VS Code.

00:02:14 I am serving my fifth and, as of now, final term on the Python Steering Council.

00:02:20 I'm stepping down just because when we first created the Steering Council,

00:02:24 I said five years seemed like a good term limit.

00:02:26 We actually don't have term limits, but figured I'd stick to my word.

00:02:29 And I'm also, thus, also a core developer.

00:02:32 I've been doing it for just over 20 years.

00:02:34 Lucky for me, I got it, my first commit bit right after the, sorry, my first commit bit after the first PyCon.

00:02:40 So, I get to use the PyCon anniversaries as a way to keep track of that.

00:02:43 So, that's convenient.

00:02:44 That's kind of the biggies.

00:02:46 Have a cap.

00:02:46 Yeah.

00:02:47 That's usually the other thing people like.

00:02:48 Something about VS Code?

00:02:49 I've heard that word.

00:02:50 It's an editor, right?

00:02:51 Yeah, I know.

00:02:52 Someday, you'll say you use it, and I'll be very happy that day.

00:02:55 I had it open today.

00:02:57 Oh, all right.

00:02:57 Well, there, I'm happy today then.

00:02:59 Yes, indeed.

00:02:59 No, awesome.

00:03:01 So many cool things you got going on.

00:03:03 And despite all of that background in steering council, core dev, here, this time, you're

00:03:10 here to give us, like, diet advice, eating advice, like something about sugar.

00:03:15 What is it?

00:03:15 Yeah.

00:03:16 Just a slight story behind all this.

00:03:18 My wife was taking the certificate in data science course at the University of British Columbia,

00:03:24 which is actually our alma mater and where we met.

00:03:26 And she was doing her homework in a JupyterLab notebook through the browser via JupyterHub.

00:03:35 And she stopped doing the homework to go, I can't remember if it was lunch or dinner, but

00:03:39 basically stepped away for like an hour or so.

00:03:40 And then she came back and the run buttons on the cells weren't working anymore.

00:03:44 I was like, well, what's going on?

00:03:45 And I looked and I was like, oh, well, you got disconnected from the server.

00:03:48 I said, well, isn't that happening in the browser?

00:03:51 Like, no, Python doesn't run in the browser right now.

00:03:54 It's not a thing.

00:03:55 Oh, OK.

00:03:55 I think about a day or two later after she thought about it, we were in the car and I

00:04:01 still remember the exact location in Vancouver where this occurred.

00:04:03 My wife said, you know, you should probably fix that problem of Python not working in the

00:04:08 browser.

00:04:08 And I explained like what WebAssembly was and how big of a thing that would be to make

00:04:12 that all happen and all that.

00:04:13 And she literally took about a beat to wait and said, no, you should go fix that.

00:04:18 Part of that led me down the road of trying to figure out what the minimum viable Python

00:04:24 was, right?

00:04:24 Like, what is the minimal amount of Python I would have to implement in the browser or in

00:04:29 WebAssembly in this case to make Python work?

00:04:32 And I had realized that, you know, a decent amount of Python is actually what's called syntactic

00:04:37 sugar, which is really just syntax that you could actually devolve and unravel into other

00:04:43 syntax of a language and have it do the exact same thing, right?

00:04:47 It's just basically syntax that's a shortcut.

00:04:49 And so I ended up going on this very long journey, unexpectedly long, of trying to go through

00:04:56 all of Python syntax and trying to figure out which parts of the syntax was like crucial

00:05:01 and you couldn't actually re-implement it in pure Python itself and which parts you could

00:05:05 actually just make it work with Python code itself.

00:05:08 With the idea that at the end, it would have basically a list of the bits of Python that an

00:05:13 interpreter would have to implement and the other bits of syntax where you could run some

00:05:17 tool over it ahead of time.

00:05:18 It would just translate from Python to different Python code.

00:05:21 And in that way, I would just know what the exact target would have to be.

00:05:25 It might not run very fast.

00:05:26 Don't get me wrong.

00:05:27 But it would at least be a very clear definition of kind of what you have to have to really call

00:05:33 something Python.

00:05:33 It's everything else.

00:05:34 Right.

00:05:34 kind of just work around.

00:05:36 Right.

00:05:36 So the standard Python syntax we expect still works.

00:05:40 But how much do you have to work behind the scenes to make that happen?

00:05:43 So examples that come to mind for me are context managers, the width block.

00:05:47 Awesome.

00:05:48 I love them.

00:05:49 But we have try finally.

00:05:50 And you could simulate a context manager effectively with maybe a try finally, maybe an accepts in

00:05:57 there as well.

00:05:57 But you don't actually need width in the language to accomplish what it does.

00:06:02 Right.

00:06:03 Yeah.

00:06:03 Decorators are also another really good example, right?

00:06:05 Like where the concepts for that syntax predates it.

00:06:09 And it happened to just be something where Python core development team looked at where people

00:06:15 were in terms of development and what they needed from Python and realized, you know what?

00:06:20 That common pattern that people are doing would actually be would be very well served via

00:06:26 a piece of syntax.

00:06:26 So why don't we just do that?

00:06:28 Why don't we introduce that piece of syntax?

00:06:29 Make things happen.

00:06:30 As you said, with context managers were a perfect example, right?

00:06:33 Where before, if you wanted to do the right thing when you opened a file is you call the

00:06:40 open function for your file, sign it to a variable, do your try block of everything you want to

00:06:44 do with the file.

00:06:46 And then in the finally part of the try finally close that file, which I mean, if you just think

00:06:51 about it compared to a with statement is four lines, assuming you're doing reasonable formatting for

00:06:57 the assignment, the try, the finally, then the close call versus the single with open to get the exact

00:07:03 effect.

00:07:03 And then you've also got the possibility that the context manager, the thing that's used in

00:07:08 the with block can do something different if there's an exception, right?

00:07:12 Like if there's an exception, it could say if it's a database transaction, it could roll back the

00:07:15 transaction automatically.

00:07:17 Rather, if there's no exception, it could commit it automatically.

00:07:19 But there's no real magic there.

00:07:21 If you think about it in the end, you could have written that all out by hand.

00:07:23 It just would have been cumbersome.

00:07:25 But that makes the with statement very much a piece of syntactic sugar where you could totally

00:07:29 write it out, get the exact same semantic outcome.

00:07:31 It might be a little slower.

00:07:33 Probably similar performance as well.

00:07:35 And maybe similar.

00:07:37 It really depends on the syntax, right?

00:07:38 Like how complicated it is, how much of it's going to call into, at least in CPython's

00:07:43 case, into the C code and stay in the C code versus not.

00:07:46 Like with context managers, probably won't just because the point is you're going to call

00:07:50 that dunder enter method or that dunder exit method.

00:07:53 So you're calling Python code.

00:07:54 So no real, probably big shift.

00:07:56 But for stuff that we'll probably cover in this podcast, there are other bits that go into

00:08:01 the C code and stay in the C code.

00:08:03 And when that happens, stuff can go really, really fast.

00:08:05 Yeah, especially with all the work the faster CPython team's done around stuff and all that.

00:08:09 So the point is you can just start to just kind of leap into C code, stay there and get

00:08:13 stuff done way faster.

00:08:14 Comparative to writing out by hand where you're staying in the Python world, it can just take

00:08:19 a bit longer.

00:08:19 Yeah.

00:08:19 So the word sugar, I think it's a good one here.

00:08:23 I love like these ideas like code smells, code sugar, all the things.

00:08:27 It makes it sound a little frivolous, maybe like little, it's nice to have.

00:08:33 It sweetens it up.

00:08:34 You don't really need it.

00:08:34 But I do think having these different constructs, like when you see a with block, it instantly

00:08:40 conveys meaning.

00:08:41 It means we're going to create a thing.

00:08:43 We have a cleanup section.

00:08:44 We don't have to deal with it.

00:08:45 As opposed to if you see a try except finally, you have to read it and process it and see,

00:08:50 okay, does it actually do the things that would be accomplished?

00:08:53 I think these sugars let you also think, not just write less good, but think in different

00:08:59 levels of abstraction.

00:09:00 Yeah.

00:09:00 I mean, as you said, the use of the word sugar is meant to mean something sweet, something

00:09:05 nice.

00:09:05 It's a treat.

00:09:06 It's a bonus.

00:09:07 So from the perspective of if you didn't have it, you could still accomplish it.

00:09:11 But that can potentially, in a way, as you've suggested, not quite denote the benefit of it,

00:09:18 right?

00:09:19 Like if we think of sugar in terms of not something good for your diet.

00:09:22 Yeah.

00:09:23 What is your perspective on sugar, right?

00:09:25 Are you a fan of desserts or are you trying to cut it out?

00:09:27 Yeah.

00:09:27 But yeah, I mean, the hope is whenever we add syntax to Python, it's for everyone's

00:09:32 general benefit, right?

00:09:34 This is why we don't do it very often.

00:09:35 And when we do do it, it's a very thoughtful discussion, very long discussion, sometimes

00:09:40 contentious discussion.

00:09:41 Walrus operator is the famous one for that.

00:09:45 I don't understand the contention in the Walrus operator.

00:09:47 It's such a small change to the language.

00:09:50 There's so many other things that are bigger changes that could have been battles.

00:09:53 But I guess it just came to a head at that point or something, right?

00:09:56 For those of you who don't know the Walrus operator is the thing that pushed Guido kind

00:10:00 of over the edge to finally step down as being the bit of a dictator for life.

00:10:03 And it was just due to the veracity of the opposition to it and just how basically angry

00:10:10 it made people.

00:10:11 And you're right.

00:10:13 It's very small.

00:10:13 And to be honest, I've used it and I like it.

00:10:16 I get use out of it.

00:10:17 It means it.

00:10:18 I use it for its purpose, which was to add some basic syntax for those up those situations

00:10:23 where you always have that assignment and then you do something like an if.

00:10:26 for something and then you're going to do something like just be able to inline certain

00:10:30 things to just do the right thing.

00:10:32 It's not a huge thing, but it's a nice thing.

00:10:35 And in that case, I don't know.

00:10:37 Honestly, a lot of people got really concerned that they didn't see the usefulness enough that

00:10:43 they thought it was going to be a slippery slope or people are always very concerned about

00:10:49 Python getting too big and it's no longer fitting in their brain.

00:10:53 Yeah.

00:10:53 Maybe it was kind of the last straw sort of thing rather than like maybe stuff came before

00:10:57 and they're like, all right, that's it.

00:10:58 And now the walrus, the walrus, like, you know, I don't know.

00:11:02 I don't know.

00:11:03 I mean, I don't think people realize that we actually cut syntax out when we moved from Python

00:11:06 two to Python three.

00:11:07 Yeah.

00:11:08 That was all kind of brewing.

00:11:09 Yeah.

00:11:09 Like the back ticks went away.

00:11:11 Like no one knows about the back ticks anymore, but we used to have syntax for using back

00:11:14 ticks and that's now that's gone now.

00:11:16 So it's not like it's always been a add, add, add.

00:11:20 But I think it's just one of these things where it's just people were very concerned that

00:11:23 Python would get too big, too complicated, and it wouldn't be fully understandable.

00:11:26 I will say whenever we do this, we very much consider how easy it would be to understand

00:11:32 if you saw it for the first time and never received any instruction about it.

00:11:35 Right.

00:11:35 Like I would argue that walrus operator is a bit obvious if you look at the code around

00:11:39 it of what it does.

00:11:41 And so you can probably figure out what it does without being told ahead of time versus

00:11:45 other syntax and other languages where you go, I have no clue what this does.

00:11:49 Right.

00:11:49 Exactly.

00:11:50 Right.

00:11:50 Like why does plus plus and C do different things if it's in the front or the back?

00:11:55 And what's the difference?

00:11:56 Like unless you know prefix versus suffix increment and the difference in terms of referencing the

00:12:02 pointer and all this crazy stuff, like you're not going to necessarily pick up

00:12:05 on the difference unless you run your code versus something where you can just look at

00:12:08 it and just learn on the spot.

00:12:09 Well, I want to give you all a bit of a compliment, I guess, or encouragement.

00:12:14 I think the Python language is not changing too fast.

00:12:17 I think it's the stability over time is really good.

00:12:21 You compare that to other languages.

00:12:22 I mean, here's one that's kind of close to home for you since you're at Microsoft, like

00:12:26 C#.

00:12:27 I feel like that language is pretty nice, at least in the early days.

00:12:30 And now there's a whole team who are employed.

00:12:33 You don't have to make any comment.

00:12:35 I know you work there, but there's a whole team who's employed to shepherd that language.

00:12:41 And I feel like there's a feeling they always need to have some new language features because

00:12:45 it's their job to have language features.

00:12:47 There's just like a constant kind of turn, like for properties, like we have properties,

00:12:51 they have properties.

00:12:52 But I think there's four to five different ways that properties in C# that have evolved

00:12:56 over time.

00:12:57 And you're just like, yeah, it's a little better, but it's why do we have so many ways if you're

00:13:01 going to be there?

00:13:01 Right.

00:13:01 And so when I at least look at Python compared to like my background in C++ or in C#

00:13:08 or JavaScript, I feel like it's comfortable.

00:13:11 It's not stale, but it's not.

00:13:13 We don't have five ways to do properties.

00:13:15 That's a good thing.

00:13:17 Even if there's a better way to do it, it might not be worth having two to three ways just

00:13:22 for that for a slight advantage.

00:13:23 Well, thank you for the kind words.

00:13:24 Yeah.

00:13:25 I mean, we do have the Zen of Python does kind of outline the general guidelines we try to

00:13:30 follow when doing making these discussions decisions.

00:13:32 For those who've never read the Zen of Python, look, just run, import this from the REPL and

00:13:37 you'll find it.

00:13:38 And yeah, it's just the way it's designed, right?

00:13:40 We don't, hopefully there's one and hopefully only one obvious way to do anything.

00:13:46 And so it's just something we've kind of leaned into now, granted things shift.

00:13:50 Like I'm sure someone will point out the myriad of ways you can format a string now, but a

00:13:54 lot of that's backwards compatibility and just realizing, you know what?

00:13:57 We just have to accept the fact the first way we got it is no longer the best way we

00:14:02 can think of.

00:14:02 And it's enough of a jump from using string interpolation with the percent sign to using

00:14:07 f-strings that it was worth adding a second way.

00:14:11 Now, maybe someday we'll take out string interpolation.

00:14:14 I doubt it because it just works and it's just sitting there and it's not worth breaking

00:14:18 really old code.

00:14:19 But I mean, it's just the way we approach things.

00:14:21 And luckily, most people like it.

00:14:22 And I think that's kind of why some people always freak out is the words afraid somehow

00:14:26 we're going to go downhill from here and it's just the start of things or somehow Python

00:14:30 is going to be harder to learn.

00:14:31 Well, we very much try to make sure Python is a gradual curve of learning, right?

00:14:35 The basics are very straightforward and good.

00:14:37 And as you get into more advanced things like the match statement, right?

00:14:40 You'll be able to see it and understand it.

00:14:42 It'll make sense, but not something you'll necessarily learn the first month or two,

00:14:46 but it's there for when you do need it, right?

00:14:48 Like we very much try to make sure that everything makes sense on a curve from beginner to advanced

00:14:53 and try to make sure the language is useful to everyone from both a beginner to advanced

00:14:57 user.

00:14:57 It's tricky, but I like to think we're doing a decent job.

00:15:00 Yeah.

00:15:00 One of Python's really, one of its powers is that you can be super effective with it with

00:15:05 a really partial understanding of what it is, right?

00:15:08 You don't have to understand namespaces, classes, async, et cetera, et cetera.

00:15:12 You're just like, well, I think I can write these four lines in a, without even a function

00:15:15 and I'll get a cool graph that'll show my, my work or whatever, right?

00:15:18 Yep.

00:15:19 Exactly.

00:15:19 Yep.

00:15:20 And I think I have a pretty partial understanding of the match statement.

00:15:22 I know it can get pretty advanced in like how it captures and changes values, but I wrote

00:15:27 one yesterday with a partial understanding.

00:15:29 It went great.

00:15:29 Nice.

00:15:30 Yeah.

00:15:30 Indeed.

00:15:31 All right.

00:15:31 Before we move on though, got to go back to the, the, your opening because you said,

00:15:37 I created this to understand, like, if I were to solve that problem, your wife had about like,

00:15:43 you got to fix that thing about the browser.

00:15:44 And I know there's some folks in Texas who have thoughts on this as well in the PyScript

00:15:48 team, but is this project you're actively working on or just, let me gather up, do some

00:15:55 research and deep thinking about what is actually in the language that would have to carry

00:15:59 over or where's it coming from?

00:16:01 I guess.

00:16:01 No, it's not an active project of mine at the moment.

00:16:04 It ended up being mostly just an exercise and just snowballed into a thing where I just

00:16:10 didn't want to stop until I completed it.

00:16:11 Yeah.

00:16:12 How do you feel about the micro Python, PyScript angle of approaching this?

00:16:18 Yeah.

00:16:18 I mean, I think it's great that, I mean, that was the other hopeful benefit about all of this

00:16:22 is trying to nail down the definition of what Python is.

00:16:26 Yeah.

00:16:27 Cause I've heard those arguments made against micro Python that it's not quite Python cause

00:16:31 it doesn't quite run all the syntax or it doesn't have the entire standard library.

00:16:35 I've gotten into arguments with people online where they got very upset when I suggested that

00:16:41 the REPL was an optional part of Python and actually not a requirement.

00:16:45 And I just viewed it as a learning experience for me, hopefully a learning experience for

00:16:50 others as well.

00:16:51 And then after that was just trying to hopefully clarify and like, like, look, this is truly

00:16:55 what you have to have to really be Python.

00:16:57 You literally cannot implement the rest of the language without this, but everything else,

00:17:01 you could totally just do it yourself.

00:17:02 You could totally just write your tool and make it all work.

00:17:05 And as long as this existed, you could totally get it by with it.

00:17:08 And so that's kind of where I ended up.

00:17:10 I luckily the tooling around WebAssembly got far enough along.

00:17:14 Pyodide's continued to do well in the browser.

00:17:16 I've been working on the WebAssembly, the system interface, WASI side of things, and that's

00:17:21 been going pretty well.

00:17:22 So that's at least taken care of itself.

00:17:25 So I've ultimately not tackled the huge problem of trying to reimplement Python from scratch,

00:17:31 probably in Rust, just in a minimal fashion to try to make it work better in the browser.

00:17:36 That's probably a project for when I retire.

00:17:38 And I suspect that's at least a decade out, if not more.

00:17:42 So that's probably going to be put on the back burner for a while.

00:17:44 Right.

00:17:45 Yeah.

00:17:45 We could all install Bpython and run Brett Python built in Rust.

00:17:49 There you go.

00:17:49 Rust does seem to be having quite the influence.

00:17:55 an outsized influence for how popular Rust is in terms of the number of developers, but

00:18:00 it seems to be really leaving its mark on Python and other areas as well these days.

00:18:05 Yeah.

00:18:05 Well, I mean, I will fully admit I have bias because I am a fan and I do like using the

00:18:11 language, but it's one of those things where if you've been living in the C and C++ world

00:18:15 and it never was that satisfying to you, but you had to be there for whatever reason.

00:18:18 And then you discover Rust and it does things that saves you from very chronic problems.

00:18:24 Yeah.

00:18:25 Including yourself.

00:18:25 Yeah.

00:18:26 You would hope that you, people would notice and latch onto it.

00:18:29 And I mean, that's, I think that's basically what's happened is people have just discovered

00:18:32 that, oh yeah, this is useful and good.

00:18:35 And just there's enough C and C++ code in the Python community due to CPython C API that

00:18:41 I think there's just a nice cross section, right?

00:18:44 I think it's just one of these things where people have just gone like, well, I've got to

00:18:47 be, I got to do the system level programming anyway.

00:18:49 So I might as well use something that's seems like a better, a little more modern language.

00:18:53 Yeah.

00:18:53 Yeah.

00:18:53 Yeah.

00:18:54 A bit more modern.

00:18:54 And so I think that's kind of what's happened here.

00:18:56 Yeah.

00:18:57 That makes sense.

00:18:57 All right.

00:18:58 Let's talk about the sugar.

00:18:59 Okay.

00:18:59 So I think we covered pretty much what syntactic sugar is.

00:19:02 And you started this whole thing out saying the goal of this is really to kind of nail

00:19:07 down that minimum Python.

00:19:09 And I agree that the REPL is optional.

00:19:11 I like the REPL, but just, just so I can also get mail about it.

00:19:16 I like the language.

00:19:17 Like you can't take away these features once you add them.

00:19:21 Right.

00:19:21 And so it's like, what could you survive with as a minimum?

00:19:25 And then you can kind of like, what are the, what's the extras?

00:19:28 What could you build up from there?

00:19:29 Yes, exactly.

00:19:30 And the final destination maybe being, you know, CPython proper.

00:19:34 Yeah.

00:19:35 So you've got a whole bunch of different aspects of Python that you are unraveling in

00:19:41 this syntactic sugar.

00:19:42 And basically to highlight what's actually happening, how much of this is going on as you've already

00:19:47 laid out.

00:19:48 So I want to point out that I'll link to how many articles you've got here, but two years.

00:19:53 20, I think.

00:19:55 Yeah.

00:19:55 Like looking like close to 30, maybe.

00:19:57 I don't know.

00:19:58 Just eyeball it.

00:19:59 There's a lot there.

00:19:59 So I think I picked a, you know, half of those out or some, some reasonable subset.

00:20:05 That we can talk about.

00:20:06 And there's some code and stuff in here.

00:20:08 So we'll kind of have like, my thought was we could just talk about kind of like, what is

00:20:12 the essence of this?

00:20:13 Like what's really happening when you do attribute access?

00:20:16 What's really happening when you write the word pass or use a width block as we've talked

00:20:21 about a little bit.

00:20:22 So the first one here is unraveling attribute access in Python.

00:20:26 You want to tell us a bit about what actually happens if you just say, you know, like object

00:20:31 dot attribute.

00:20:32 It seems so simple, Brett.

00:20:33 There's just one dot.

00:20:35 That's the big deal.

00:20:36 Yeah.

00:20:36 Why doesn't this just, what's there to talk about?

00:20:38 I mean, when I just do something dot something magically, I get back what I expected, but there's

00:20:44 actually a lot going on there.

00:20:46 Right.

00:20:46 And it, it comes down to multiple layers, but it's all ties around Python's object model.

00:20:51 Right.

00:20:51 How do all, because I always find this weird to say, but Python's more object oriented in

00:20:57 my opinion than Java.

00:20:58 Java has these primitive types like instant quotes that have to get boxed and unboxed to

00:21:03 fake, to make them look like an object to Java itself.

00:21:06 Python doesn't have that.

00:21:07 Everything is an object.

00:21:08 A function is an object.

00:21:09 An integer is an object.

00:21:11 True is an object.

00:21:12 Seven is an object.

00:21:13 Exactly.

00:21:14 There's nothing you can name in Python.

00:21:16 That's not somehow an object.

00:21:17 Yep.

00:21:17 This idea of attributes and all this permeates all the way down into the object model, which

00:21:22 once again, defines kind of everything in a way.

00:21:24 So the key thing here is there's kind of two parts to it.

00:21:27 It's how do you look up based on inheritance, what thing is going to service the call asking

00:21:34 what is this attribute value?

00:21:36 Basically, what object is bound to this name for the attribute?

00:21:39 And after that is what methods are going to get called to make that happen?

00:21:43 Because effectively, almost everything in Python at the end of the day leads to a method call

00:21:48 or a function call.

00:21:49 Yeah.

00:21:49 First of all, it leads to a lot of times to an op code, which leads to a method call, right?

00:21:54 A Python bytecode thing.

00:21:57 And I think it's maybe also worth pointing out, like have you point out to everyone listening

00:22:01 is Python compiles to this intermediate language like Java and .NET compiled to intermediate languages.

00:22:08 It's just what happens then, right?

00:22:11 Like in those other ones, they JIT compiled to machine instructions.

00:22:13 Here it goes through like the big C eval loop and delegates to some internal C operations.

00:22:19 And a lot of those, these unravelings, like kind of look at what happens at that step, right?

00:22:23 Yeah.

00:22:23 So CPython itself is an interpreter, right?

00:22:27 So what happens is when you load up your Python code is Python parses it, what's called an abstract

00:22:33 syntax tree or AST.

00:22:34 It then takes that AST, does some stuff with it, and then it compiles it down to Python bytecode.

00:22:41 I actually gave a talk on this at PyCon Canada way back when, for those who are interested,

00:22:46 that basically goes from the steps of literally source code all the way to execution, if you

00:22:51 want more detail.

00:22:52 But effectively, yeah, we compile it down to bytecode of our own design to then execute

00:22:57 in more or less what's a big for loop in C.

00:23:01 That is a really big for loop.

00:23:03 Very big for loop.

00:23:03 And it's gotten a bit fancier thanks to the faster CPython team, right?

00:23:08 Like there's now kind of like lower level opcodes that are very type specific.

00:23:12 And we actually auto-generate the loop now thanks to them so that it's easier to maintain and

00:23:18 make tweaks to.

00:23:18 But essentially, it's literally just a set of instructions that are extreme, that kind of

00:23:23 encompass key bits of semantics in Python.

00:23:27 So for instance, for attribute access, there's literally a opcode called load adder, where on

00:23:34 the execution stack, you basically push the object you care about, the name of the thing you

00:23:38 want, and then you just call load adder on it, and it'll just look it up.

00:23:42 Actually, technically, I guess it doesn't push the name on it.

00:23:44 That's technically stored in the function.

00:23:47 There's little details I'm kind of hand-waving over, literally hand-waving if you're watching

00:23:51 the live stream.

00:23:52 But effectively, you push the object you want, you call load adder, give it an argument of

00:23:57 what it should, what attribute it wants, and then load adder opcode behind the scenes is

00:24:01 the thing that does all the magic of calling everything you'd expect, et cetera, et cetera.

00:24:04 Yeah, excellent.

00:24:05 And to view that, a lot of times what you'll do is you'll just use the dis module.

00:24:10 So if people haven't used dis, you can just dis.dis, a lot of disrespect on this function,

00:24:15 and then it tells you what the opcodes it's made of are, yeah?

00:24:19 Yeah, exactly.

00:24:19 I mean, dis is short for disassemble.

00:24:21 So literally, you can pass it a function, and it will effectively disassemble what the

00:24:26 function does into the bytecode, which is just stored as an attribute of bytes on the

00:24:32 function object and print it out nicely because the disk module knows how to map the bytes

00:24:37 to what the opcode's name is and just gives it a nice way to look and actually read and

00:24:42 understand it.

00:24:43 Okay.

00:24:43 In this example, you said, all right, look, here is the case statement in that tremendous

00:24:47 for loop switch thing that does the execution.

00:24:51 What do we do if we see load adder?

00:24:53 And ultimately, it comes down to this pyobject underscore get adder.

00:24:58 So it seems so simple.

00:25:00 It's just object dot attribute, object dot field, whatever.

00:25:02 But it turns out there's just so many variations and so much going on down here.

00:25:07 And I don't necessarily want you to go through all the details because it's pretty, some of

00:25:11 it's pretty intense C and like a lot of it, you know, optimizations and stuff.

00:25:15 But just give people a sense of what actually happens down in the guts when you try to do it.

00:25:21 Well, so in the case of attribute access, right, that effectively ends up calling the

00:25:27 get adder built-in function, right?

00:25:29 And in that case, it needs to check how many arguments it gets to start, right?

00:25:34 Did you give it two arguments or did you give it three arguments so you return a default value

00:25:38 if the attribute doesn't exist?

00:25:40 And then at the C level, we have to check whether or not what you gave it, right?

00:25:44 Because there's like a Python level, the C code all types to what's called the to py object,

00:25:50 which is basically a massive struct in the C that represents any and all Python objects.

00:25:55 So even at the C level, we don't know if you gave us a string or an integer or what did you

00:26:02 give us for the name of the attribute that you want.

00:26:05 So we got to do that, right?

00:26:07 And so there's just basic, like just safety checks to go like, nope.

00:26:12 Like when you, if you call get adder with wanting the attribute 42, which is a number,

00:26:17 it's going to throw a type error.

00:26:19 Well, that code's got to exist somewhere and this is where it exists.

00:26:22 Yeah.

00:26:23 Yeah.

00:26:23 Right.

00:26:24 And then effectively just bubbles all down to the C API where a lot of this stuff gets exposed

00:26:28 in its own way.

00:26:29 And specifically in this case, it ends up calling py object get adder.

00:26:33 Yeah.

00:26:33 And I think another thing that's pretty interesting here is it's not always just a value, right?

00:26:38 That object dot adder, that adder could be a property.

00:26:41 That adder could be a descriptor, which I guess is a generalization of a property.

00:26:45 It could be on the class type, but not on the instance type.

00:26:49 So you got to find that.

00:26:50 It could be on the instant type overriding, but only there, right?

00:26:52 Like it could not exist.

00:26:54 All of these scenarios that you got to go through.

00:26:57 And so it really, you know, it really emphasizes how much is actually going on in the runtime while

00:27:02 this single simple line seems to be running, right?

00:27:05 Yeah.

00:27:06 I mean, in the simple case, hitting the dots, not complicated.

00:27:10 Like in general, what you end up doing is you have your object, you hit dot.

00:27:15 And what it does is it looks in the dunder decked attribute of the object.

00:27:19 And there's a key matching the attribute name.

00:27:21 And it just gets the thing in the dictionary and that's it.

00:27:23 You're done.

00:27:24 But as you alluded to, how the heck do you even get to that basic case?

00:27:28 Or those more complicated cases, as you said, descriptors, right?

00:27:32 Which are how we actually implement properties.

00:27:34 Or if it's on the class versus the instance.

00:27:38 And what happens if there's inheritance or multiple inheritance?

00:27:43 Yeah.

00:27:44 Or dunder get adder was defined, right?

00:27:45 Like basically almost all of this ends up flowing through the get adder built in, which effectively

00:27:51 ends up calling the appropriate dunder get attribute method off of an object.

00:27:55 And this is one of those bare level kind of things, right?

00:27:58 Where you have to implement this to make Python work.

00:28:01 You have to basically implement the get adder built in.

00:28:03 And it has to understand how objects are structured underneath the hood to know how basically methods

00:28:09 and stuff are attached to an object.

00:28:10 You really can't fake that.

00:28:12 There's no way to not kind of have that as a low level detail that you can just unravel.

00:28:17 It has to be implemented by the interpreter.

00:28:19 And in this case, effectively, the way Python does things is it knows the order.

00:28:24 You can always actually call the MRO method on any object in order to use the method resolution

00:28:29 order.

00:28:29 And effectively what Python is doing is if it checks on something to see if it has it or not,

00:28:35 it will effectively end up calling the dunder get attribute object of method, sorry, on

00:28:40 object.

00:28:41 That's usually where it bottoms out.

00:28:42 And unless you happen to have a dunder get adder, if that fails, but that's only in the

00:28:47 failure case.

00:28:47 But really, in the end, almost everything passes through object dot dunder get attribute.

00:28:52 And that's really where all this ends up going.

00:28:54 But as you said, there's a lot of little twists and turns.

00:28:56 Yeah, a lot of these internals, you'll see the method resolution order calls.

00:29:01 And it's all about, well, there's a lot of classes and a lot of objects.

00:29:05 They can override things and they can override operators.

00:29:08 And so there's a lot of navigation to just figure it out.

00:29:11 Not just calling these get adder type of things, but what level does that even supposed to happen

00:29:17 on, given what I'm working with, right?

00:29:20 Yeah, exactly.

00:29:21 And I think this is a good example.

00:29:23 And the reason I started with this is so fundamental, right?

00:29:26 Like, how do you unravel something if you don't know how to even get an attribute off of something?

00:29:31 So this is why this was the very first post in this series.

00:29:33 Partly why I went into such detail on how to figure all this out, right?

00:29:37 Like, kind of one, this is almost a template for anyone else who wanted to go exploring on their own.

00:29:41 But I think it's also a good example of how much complexity and flexibility Python hides from users in order to make the simple work, but give you the flexibility to make the complicated possible.

00:29:53 Right.

00:29:53 Yeah.

00:29:54 Like for the vast majority of any of us for our code, it's not just does what you would think it would do.

00:30:00 And it's pretty straightforward.

00:30:01 But as soon as you get into the fancy world of descriptors.

00:30:04 SQLAlchemy.

00:30:06 Yeah.

00:30:07 I can both have a value or I can do a database query with the same thing.

00:30:10 How is that possible?

00:30:11 Right.

00:30:11 Yeah.

00:30:12 You want that magic?

00:30:13 Language has to support it somehow.

00:30:14 And it requires a lot of finesse and thinking through and a lot of mechanisms that generally get hidden from you.

00:30:22 But someone's got to write that code somewhere.

00:30:24 And in this case, it's a Python.

00:30:26 And this kind of outlines how that all happens.

00:30:30 And it's surprisingly complicated.

00:30:32 It's not horrible.

00:30:33 That was my main takeaway, too.

00:30:35 Yeah.

00:30:36 I mean, you can totally read it and follow it.

00:30:37 I don't want to scare anyone saying it's so complex you can't follow it.

00:30:40 It's just it's not just a simple two if statements and you're done.

00:30:45 It's no.

00:30:46 There's subtlety to it to make sure the common semantics make sense to people.

00:30:51 It's not going to trip people up because it's doing something weird.

00:30:54 There's a lot of thought that goes into these semantics to make sure it makes sense for the common case.

00:30:59 This portion of Talk Python to Me is brought to you by us.

00:31:03 Have you heard that Python is not good for concurrent programming problems?

00:31:08 Whoever told you that is living in the past because it's prime time for Python's asynchronous features.

00:31:13 With the widespread adoption of async methods and the async and await keywords,

00:31:18 Python's ecosystem has a ton of new and exciting frameworks based on async and await.

00:31:23 That's why we created a course for anyone who wants to learn all of Python's async capabilities,

00:31:28 async techniques and examples in Python.

00:31:31 Just visit talkpython.fm/async and watch the intro video to see if this course is for you.

00:31:36 It's only $49 and you own it forever.

00:31:39 No subscriptions.

00:31:40 And there are discounts for teams as well.

00:31:45 Another takeaway I got from looking at this is, wow, it's nice that dictionaries are fast.

00:31:49 And how fast are they to make this impossible to lean on them so much to make this happen?

00:31:54 Yeah.

00:31:54 I mean, I will say when Guido chose to use dictionaries as the namespace, it was kind of a unique decision at the time.

00:32:01 It might still be, honestly.

00:32:03 But it did simplify some things conceptually and also made it so that any wins in how dictionaries work is just a massive win universally across language.

00:32:14 Right.

00:32:15 Like if you make dictionaries work in any way better, you not only make it work when you just you personally use it as a data structure, as a container,

00:32:24 but also literally every attribute access will get faster.

00:32:27 Right.

00:32:28 Like, yeah, there's a reason why it's so fine tuned and why we don't really touch it very much because it's been tweaked over the decades by a lot of people to be extremely fast and for good reason.

00:32:40 Yep.

00:32:40 Indeed.

00:32:41 One final thought on this.

00:32:42 You know, you think of optimizing both the memory and also the performance a little bit by doing things like slots on your classes to maybe like short circuit some of this.

00:32:51 It feels like somewhere in this world lives like some kind of massive optimization that maybe that if you said I'm going to for this class, I'm going to give up some flexibility.

00:33:00 Is there some way attribute reads and writes could get lots faster?

00:33:04 I don't know.

00:33:05 What are you?

00:33:05 I'm sure this has gone round and round because it's such a hot.

00:33:09 It's just involved in almost every line of Python code, stuff like this.

00:33:12 Right.

00:33:13 Oh, yeah.

00:33:13 Yeah.

00:33:13 I mean, this plays into what the faster CPython team has been doing, right?

00:33:18 Trying to make things faster by looking at what the patterns are and if you can just kind of skip stuff.

00:33:24 Right.

00:33:25 Like, how do you short circuit this thing?

00:33:26 Can you go like, well, I just know this object's always looked this way.

00:33:29 Like, this is some of the stuff that the self programming language team at UC Santa Barbara did, I think, in the 70s, maybe 80s.

00:33:38 I'm just like, well, if we know the layout of the object is going to be consistent.

00:33:42 Yeah. Can we go seven bytes in and get four bytes?

00:33:44 That kind of thing, right?

00:33:45 Exactly.

00:33:46 And you just kind of have to, and you start to be able to calculate the shortcuts.

00:33:51 You know, like, hey, did anything change from the last time I made this assumption?

00:33:54 No? Okay.

00:33:55 Well, then I can use my assumption.

00:33:56 That's way fast.

00:33:57 Right.

00:33:57 Nobody's mocked it.

00:33:59 Nobody's dynamically messed with it.

00:34:01 Like, maybe it is just a plain thing.

00:34:03 Until somebody puts it into an edge case, is there a short circuit, right?

00:34:07 Yeah.

00:34:08 And, I mean, I don't want to go off on a tangent, but...

00:34:12 Well, I'm one of 17 topics here, Brett.

00:34:14 Like, I know probably we got lots of time.

00:34:15 I have thought about, like, after doing this, what...

00:34:20 Is there something syntactic here to add, right?

00:34:22 Is there a way to kind of come up with effectively a class definition that's way simpler for the really common cases?

00:34:31 Yeah.

00:34:31 That could be optimized extremely fast because you give away some flexibility and then the interpreter can make assumptions.

00:34:41 PyPy could make assumptions, et cetera, et cetera.

00:34:44 And would there be enough wins on that to warrant doing it, right?

00:34:48 Like, could we take the concept of kind of a data class that was just data, roughly, or something along those lines?

00:34:55 Yeah.

00:34:55 And just what could we get out of it?

00:34:57 And what kind of perf wins could we get out of it?

00:34:59 And would it be worth it?

00:35:00 Would it be worth adding syntax to the language for that case?

00:35:04 If you look at Mojo, for instance, they have a struct.

00:35:07 And that struct works in a very specific way for performance because when you say, like, this thing can't have new attributes, which you can do with slots.

00:35:15 And for those of you who don't know what slots are, if you define a dunder slots attribute on your class, you're effectively telling Python, don't create a dictionary for me.

00:35:23 Just create effectively a list underneath.

00:35:25 It's technically a C array.

00:35:27 And when I need to access something, just get it off this array.

00:35:31 So there's no dictionary.

00:35:32 You can skip all that dictionary overhead.

00:35:34 Plus, you shrink the memory because now the only amount of memory you need is that array for pointers to the PyObjects and not a dictionary, which grows and shrinks and who knows what size it's going to be.

00:35:44 If we had that built in syntactically, would that be beneficial to people or not?

00:35:49 And I have a prototype in Python code of what I'm thinking of.

00:35:53 I did a blog post on this earlier this year to try to feel out people in the community and what they thought in terms of restrictions and would it be too much or too little?

00:36:02 I subsequently prototyped what I wanted.

00:36:04 And there'll be a follow-up blog post about this is where it sits now.

00:36:08 What do people think?

00:36:09 And do people think this is worth trying to get syntax for?

00:36:12 Just don't worry about it.

00:36:13 It's too close to data classes or what?

00:36:16 Maybe it could be a keyword to the data class decorator that just makes it behave differently.

00:36:21 Who knows?

00:36:22 Yeah.

00:36:22 But so unfortunately, the tricky bit with that is it's still flowing through Python code, right?

00:36:26 Data classes is still just a module in the standard library.

00:36:28 So you can't, it's really hard to optimize that stuff without syntax to specifically say, hey, this will be different.

00:36:35 You get to treat it differently and we can literally lock it down by literally creating a different type of object at the C level that just literally doesn't give you access, right?

00:36:43 Like tuples are a good example.

00:36:45 Tuples at the C level very much just don't implement the stuff that you mutated.

00:36:50 What happens if we want to do that for classes?

00:36:51 Like how do you do frozen data classes?

00:36:53 It's a ton of properties.

00:36:55 But what happens if we had a way to just say, yep, nope, we're just literally not giving you access.

00:36:59 Would that, how much faster could that be?

00:37:01 I don't know.

00:37:02 But I suspect it would be decently faster.

00:37:04 Yeah.

00:37:05 Computers are surprisingly fast.

00:37:07 Dictionaries are surprisingly fast.

00:37:08 But there's a lot of stuff here that could be skipped that I think might be.

00:37:13 To me, I had the same thought at least.

00:37:15 Probably not with the level of sophistication you did.

00:37:17 But like, wow, there's some way to sort of do a more of a C style, just like we know the structure and the offsets.

00:37:23 Yeah.

00:37:24 Like for a restricted set, because that restricted set is mostly what people do actually do in Python.

00:37:28 They don't go crazy dynamic with stuff coming and going like sometimes, but not usually.

00:37:33 Yeah.

00:37:34 I mean, you can go read my original blog posts.

00:37:36 And if you follow me on Mastodon, you can see the follow up conversations.

00:37:39 But like the original thing, if you've been a longtime Java user, you'll know the acronym POJO, plain old Java object.

00:37:47 It was effectively the equivalent for Python.

00:37:49 Some people love that idea.

00:37:51 Some people were like, I really need methods.

00:37:53 I can't not have methods kind of thing.

00:37:56 It really depends on what people are after and what they think makes sense.

00:38:01 But there will be a follow up blog post.

00:38:03 So if you follow my blog, you'll eventually see what this hopefully all leads to, which may be nowhere beyond what I put up on PyPI.

00:38:08 But who knows?

00:38:09 Maybe it'll become Zindax someday.

00:38:11 It really depends on how the community reacts to it.

00:38:14 Cool.

00:38:14 Well, I didn't know you're looking into that.

00:38:17 So very interesting.

00:38:17 Next one.

00:38:18 Let's move on to something that also seems pretty straightforward is A minus B.

00:38:25 Yeah, right.

00:38:26 Yeah, exactly.

00:38:27 You think it makes.

00:38:28 Yeah.

00:38:28 How hard can A minus B be, right?

00:38:30 Like two objects just subtracting from one another, right?

00:38:35 We all know how this works.

00:38:36 There's I mean, there's an opcode just called binary subtract.

00:38:39 Just like there's a binary add, a binary multiply, binary divide.

00:38:42 You put the numbers on the register.

00:38:44 You do the instruction set on the CPU and you're good to go.

00:38:47 Yeah.

00:38:48 Hey, I know what five minus three is.

00:38:50 How much work can it be to make that work in Python?

00:38:51 Oh, yeah.

00:38:52 The numbers happen to be arbitrarily large and sometimes they're not numbers.

00:38:57 Sometimes they're matrices or strings or.

00:38:59 Oh, boy.

00:38:59 Okay.

00:39:00 Exactly.

00:39:00 And subtraction is not communicative.

00:39:02 So what matters here.

00:39:04 So, yeah, it gets surprisingly complicated very quickly.

00:39:07 Yeah.

00:39:07 So, yeah.

00:39:08 From from a conceptual level.

00:39:09 Yeah, it seems simple.

00:39:10 But when you figure out what that opcode actually does, it becomes way fancier.

00:39:14 Yeah.

00:39:15 And so as you dig into this, you start to realize like, OK, so this is actually controlled

00:39:20 by the Dunder sub operator on the type.

00:39:23 Right.

00:39:24 And then how do you get that method?

00:39:25 Well, this is the method resolution order on that type.

00:39:29 So you got to start navigating that.

00:39:30 And that gets pretty interesting.

00:39:32 Right.

00:39:32 Yeah.

00:39:33 Yeah.

00:39:33 Well, and let's be clear here.

00:39:35 You're a bit foreshadowing because you said, oh, you called the Dunder sub.

00:39:38 Yeah.

00:39:39 To start.

00:39:40 If that works.

00:39:41 Right.

00:39:42 Like for a lot of these things, there's lots of fallback to once again, give you that

00:39:46 flexibility to make things work as necessary.

00:39:49 So for a lot of things in Python, you can return the not implemented singleton, which you may

00:39:55 have some people may have noticed and wonder what the hell is this thing for?

00:39:57 And it's a singleton to signal to Python that, hey, there's not it's not an error happened.

00:40:03 It's just I just don't know how to handle this.

00:40:05 Right.

00:40:06 So for instance, if let's say you have left hand side minus right hand side, the first

00:40:12 step is you check to see if the left hand side has a Dunder sub method.

00:40:17 If it does, you can call that with left hand side dot Dunder sub and pass in right hand side.

00:40:23 Well, that method has the option to do something and return a value.

00:40:28 And that's what left hand side minus right hand side becomes.

00:40:30 Or it can return not implemented and say, just tell Python, nope, I don't know how to do this.

00:40:35 Probably should ask someone else.

00:40:36 Right.

00:40:36 And then this adds an extra little wrinkle now, because suddenly when you do that, that

00:40:42 says, OK, well, you know what?

00:40:43 Let's give the right hand side a try.

00:40:45 Maybe the right hand side knows how to do left hand side minus right hand side.

00:40:48 It might not be the front thing, but it might just magically know.

00:40:51 Right.

00:40:52 So in this case, for instance, you could have something of your fancy object minus four,

00:40:57 which would be your Dunder sub method.

00:41:00 And so you know how to handle integers and it works.

00:41:02 What happens if it's four minus your object?

00:41:05 Yeah.

00:41:06 Four doesn't know what to do.

00:41:07 Yeah.

00:41:07 Four's never seen your thing before.

00:41:09 I don't know what the heck to do here.

00:41:10 So in that case, four would return not implemented thing.

00:41:14 I don't know what to do here.

00:41:15 Good luck to you.

00:41:16 Maybe you'll figure it out.

00:41:17 And in this case, your object Dunder, our sub would get called with four.

00:41:22 And then maybe you'll be able to say like, hey, I might not be on the left hand side,

00:41:25 but I know how to handle myself on the right hand side.

00:41:27 And I can make this work.

00:41:28 So we try to make sure that even if some other objects don't know how to work with you,

00:41:33 as if you're involved, there's at least the opportunity for you to make it work.

00:41:36 Yeah.

00:41:36 That's pretty interesting.

00:41:37 Yes.

00:41:38 An example could be like the number four, a constant minus a vector that's meant to be

00:41:43 like a mathematical vector.

00:41:45 And it's like, okay, we just subtract that from every dimension.

00:41:47 Right.

00:41:47 And that would be totally reasonable.

00:41:49 But the four has no idea how to do that.

00:41:51 Yes.

00:41:51 And this is still the simple case.

00:41:52 Yeah.

00:41:53 So if I'll need a, I need a slight refresher on this one, but effectively there's scenarios

00:42:02 here where you call the right hand side first.

00:42:07 If it's the left hand side, one can say, I don't know what to do with this object, I think

00:42:12 in return and not implemented from the subtract, something like that.

00:42:16 Right.

00:42:16 There's also a subtle optimization in these binary operators where if it is a direct subclass

00:42:24 of the other object, you get first dibs.

00:42:28 Oh, right, right, right.

00:42:29 So that's the thing.

00:42:30 Yeah.

00:42:30 There's a lot of spam and bacon and vegetable spam and stuff that you did in here that people

00:42:36 can check out.

00:42:36 It gets surprisingly complicated.

00:42:37 But the thing here, basically, this is, let's see, you have a left hand side and a right hand

00:42:42 side, right?

00:42:42 Once again, left hand side minus right hand side.

00:42:45 Left hand side might be an integer.

00:42:46 Your right hand side, though, might be a subclass of integer, like fancy integer.

00:42:51 Okay.

00:42:51 Now, if you do int minus fancy int, it will understand how to do it because you're a subclass.

00:42:57 So it's just going to do it.

00:42:59 And it'll just do the math and return you whatever it is.

00:43:01 So like if you did five minus fancy three, five is going to return the integer two.

00:43:07 But maybe that's not what you want with your fancy int.

00:43:09 Maybe you would always, maybe you'd rather get fancy int two.

00:43:12 So how does Python make sure that you get that opportunity if you happen to be on the right

00:43:16 hand side instead of the left hand side?

00:43:17 Yeah.

00:43:17 Well, in that case, Python checks first.

00:43:20 Okay.

00:43:21 I have a left hand side and a right hand side for subtraction.

00:43:24 Is the right hand side a direct subclass of the left hand side?

00:43:28 If that's true, then you know what?

00:43:29 I'm going to give the right hand side a chance first so that they can return their subclass

00:43:34 and not have the left hand side kind of just blindly not realize that it's a different type

00:43:39 and return something else.

00:43:40 So that when it's, as I said, five minus fancy three, we actually give fancy three the first

00:43:45 chance instead of five so that you have the chance to return fancy two like you wanted and

00:43:50 not have five self-return.

00:43:52 Boring two.

00:43:53 Yeah.

00:43:53 So I think one example that comes to mind that I think might be relevant would be working with

00:43:59 units.

00:44:00 So we've got cool libraries like pint and others where you can say this is not just the

00:44:06 number five, but this is five kilograms.

00:44:09 And if I subtract, you know, a hundred milligrams from it, it's not negative 95.

00:44:14 It's, you know, four point, whatever, nine, five or whatever it turns out to be.

00:44:18 And so in this case, if you took a regular number and one of these numbers with units, you

00:44:23 could get a number with units back potentially.

00:44:25 Yeah.

00:44:26 No, that's a very good example, right?

00:44:27 Yeah.

00:44:28 This is where those, once again, very simple syntax that in the common case and in your

00:44:33 general use day to day makes total sense and happens has some really important, but subtle,

00:44:38 if you don't know about them semantics to make sure that those reasonable expectations are met,

00:44:44 right?

00:44:44 Like I totally didn't even think about this when I was doing, when I was writing this blog

00:44:48 post that like, oh yeah, God, that's a good point.

00:44:51 Like I do want to make sure that I get my special version of everything when I happen to be on the

00:44:56 right-hand side, just because I happen to be written on the right-hand side.

00:44:59 Yeah.

00:44:59 Plus is a really good example.

00:45:01 This one, right?

00:45:01 Like you could have written a plus B or B plus a makes zero difference.

00:45:05 I mean, that operator is supposed to be communicative.

00:45:07 So it can be totally just dumb luck based on how I just happened to be thinking that day,

00:45:11 what I put on the left side and what I put on the right side.

00:45:14 And that would suddenly make a difference.

00:45:15 And in this case, it just helps make sure that what you would think is the priority order of who you'd

00:45:21 want to handle this for you gets that priority.

00:45:23 But once again, it's a thing you just never think about day to day.

00:45:27 But in actuality, when you think about the really key ways that Python operates, makes a surprising

00:45:32 difference.

00:45:33 Yeah.

00:45:33 That seemingly leakiness of the language of like, well, sometimes it gives you an answer.

00:45:37 Some it doesn't.

00:45:38 Depends on how you add.

00:45:39 People wouldn't love that.

00:45:40 Yeah.

00:45:40 And then the last bit of subtlety on that one is this only happens if, by the way, Dunder

00:45:47 Sub and Dunder R Sub are different.

00:45:48 So that's another check we do because at the C level, they're actually equivalent.

00:45:53 Like there is no left side versus right side thing here.

00:45:56 So we actually check to make sure we don't waste our time asking you, hey, can you do this

00:46:00 and get back not implemented and then calling it the reverse and give me the exact same result

00:46:05 because underneath it all is the exact same method.

00:46:07 Right.

00:46:07 So it's one of those fun things of, once again, lots of little things here to try to optimize,

00:46:11 as you said, as best we can.

00:46:13 And in this case, it's one of those.

00:46:15 Well, if we know you're not going to work this way with the exact same method, we just swap

00:46:18 the order of this stuff.

00:46:19 Why are we going to ask you again?

00:46:20 So we just skip that.

00:46:22 So it's a minor thing, but semantics are there to try to help with the performance.

00:46:26 I think people, as people go through your series here, I think they're going to get a deep

00:46:31 appreciation for edge cases.

00:46:33 Yeah.

00:46:33 Subtlety.

00:46:34 Yeah.

00:46:34 Yeah.

00:46:35 I learned a lot.

00:46:37 I mean, it was one of the reasons I finished it is I finished this series as well, even though

00:46:41 I part way through went like, yeah, you know what?

00:46:44 I'm not going to implement Python from scratch, but I was learning.

00:46:48 And it was fun.

00:46:50 Like I got to dive a bit deep.

00:46:52 I got to ask the Python core team is like from people, primarily Guido, who obviously

00:46:56 were there when these decisions were like, why this way?

00:46:59 Like, why do we choose this?

00:47:02 And just trying to understand somewhat historically, how did these things happen?

00:47:06 Right?

00:47:07 Like I think a lot of people don't realize how old Python is, right?

00:47:11 Like February of 1991 is when Python came out.

00:47:14 It predates Linux going public.

00:47:16 Like people really forget that fact.

00:47:18 It's been around for over 32 years.

00:47:20 Yeah.

00:47:21 Decisions were made a long time ago.

00:47:23 And I know everyone got all upset over the two to three transition.

00:47:26 And some people still got upset whenever we push new changes or whatever.

00:47:29 But do realize.

00:47:30 Yeah.

00:47:31 I can't believe you just canceled three, seven.

00:47:32 I like that version.

00:47:35 But the key thing here is the core concepts still work.

00:47:39 Subtraction still works, right?

00:47:41 From the way it worked back then.

00:47:43 There's not been a massive upheaval here.

00:47:45 It's just a lot of us end up using stuff that's kind of fancy.

00:47:48 And sometimes the fancy stuff gets a little tweaked and stuff.

00:47:51 But the really core low level stuff really hasn't shifted very much.

00:47:54 So if at all, depending on your view.

00:47:57 Give people a sense of the timing.

00:47:58 Like the release of Python predates by a couple of years, the release of the web.

00:48:02 Right?

00:48:02 The web was 93, I think.

00:48:03 And so, yeah.

00:48:05 Yeah.

00:48:05 One of the early browsers was actually Guido was writing in Python and TK.

00:48:09 Incredible.

00:48:10 Gradle.

00:48:10 So we talked about simple things like thing dot value A minus B.

00:48:15 The next simple one is the import statement because imports are simple.

00:48:18 Honestly, I think imports are, if you come from a compiled language, they're really, you've really got to change your mindset.

00:48:26 Right?

00:48:27 And so I think this one actually is maybe the opposite end of that spectrum a little.

00:48:30 Oh, yes.

00:48:31 I will fully out my code.

00:48:32 Some of my coworkers who are, because VS Code is written in TypeScript as an electron

00:48:37 app.

00:48:38 So they live in TypeScript all day long.

00:48:41 The fact that Python's imports work the way they are in terms of flexibility and just the

00:48:45 way it works.

00:48:46 And you're not just specifying file paths to everything just really throws them for a loop

00:48:50 and they go like, why is it so complicated?

00:48:52 Once again, the flexibility that Python gives you where the base case, normal case of if you

00:48:57 just do things the way just kind of just it's Python code and directory kind of thing just

00:49:02 works versus I can also import something from a URL if I want.

00:49:06 That's totally optional.

00:49:08 You know, I could keep all my code in a SQLite database and import from there.

00:49:12 Totally possible.

00:49:13 Right?

00:49:14 So it's one of these things, once again, where if you're coming from a Python mindset

00:49:18 of just what makes sense, it all just works.

00:49:21 I realize when you come in with an outside perspective, it can look kind of crazy.

00:49:25 But you also have to understand that a lot of the designs were made A, decades ago.

00:49:30 And B, there's a lot of flexibility there that you may or may not be taken advantage of.

00:49:34 But there are others who are.

00:49:36 And so that's kind of why it exists that way.

00:49:38 Yeah, indeed.

00:49:38 And yes, this posts.

00:49:40 Yeah.

00:49:41 So for those of you who don't know, I actually am responsible for Import Lib and re-implementing

00:49:47 Python's import system in Python itself.

00:49:49 And so I know these details a little too well.

00:49:51 This one you live deep in this world.

00:49:53 Yeah.

00:49:54 So.

00:49:55 You still have nightmares about some of them?

00:49:56 No, luckily.

00:49:57 I'm just kidding.

00:49:58 Luckily, Import Lib, in terms of actual import itself, like this, I'm ignoring Import Lib.resources

00:50:05 or Import Lib.metadata.

00:50:07 Jason Coons mainly manages those modules.

00:50:09 It's been stable enough for long enough now that there's no real crazy surprises anymore.

00:50:14 Honestly, the biggest headache is people doing imports in their threads.

00:50:18 So my word of advice to everyone, don't do imports in threads.

00:50:21 If you're going to do imports, do them on your main thread up front.

00:50:24 Then spawn your threads.

00:50:26 Don't do imports as a side effect of anything either.

00:50:29 It's circular imports.

00:50:31 Same thing.

00:50:32 It's just, just, just don't.

00:50:34 Your life will be so much easier.

00:50:35 But that's honestly where any of the bug reports that ever come in come from is due to either

00:50:40 circular imports and people wondering why or weird race conditions with threads on imports

00:50:45 and just trying to get the locking down such that things lead to the right outcome.

00:50:49 Yeah.

00:50:50 Actually 3.12 almost got held up a little bit due to a slight memory leak from the newest

00:50:55 version of tracking imports via threads.

00:50:59 There was a slight leak of it.

00:51:00 Wow.

00:51:00 Basically an empty dictionary every time you did an important thread and we didn't want to have

00:51:04 that leak.

00:51:04 So we cleaned it up.

00:51:05 But yeah, it once had a lot of subtlety.

00:51:08 Oh, we got lots of memory, bro.

00:51:09 We don't need to worry about those things anymore.

00:51:10 No, just kidding.

00:51:11 Yeah.

00:51:12 There's no reason everyone gets excited every time Apple launches a new M chip, right?

00:51:17 We've had enough processing power since we got someone on the moon with how many hertz?

00:51:22 Exactly.

00:51:23 No one needs more than seven hertz.

00:51:25 You know the favorite thing.

00:51:27 You know, one of the real big differences I think here is that like import runs code,

00:51:32 right?

00:51:32 Like rather than tells the compiler these things are in scope if you want them.

00:51:37 But no, it's like running code.

00:51:39 And if people are wondering where that weird dunder name equals dunder main, so you don't

00:51:46 run too much code during imports and those sorts of things, right?

00:51:49 Yeah, actually.

00:51:50 And this is an interesting case where it's very much syntactic sugar, but it's also very much

00:51:55 syntactic sugar actually for the bytecode.

00:51:58 Yeah.

00:51:58 So the thing here is when you do import spam, right?

00:52:02 Or whatever module you want to import, it effectively ends up being a call to the dunder

00:52:07 import built-in function where it passes in spam as the name, and then it passes in all

00:52:11 the globals and the locals for where it gets called for name resolution and stuff like this

00:52:16 is where you do relative imports with dot, you know, like dot, dot something.

00:52:20 Yeah, exactly.

00:52:21 When I first saw it, like, why are all these arguments going to import?

00:52:23 You just need to know where a, a dot pi or the package a lives and you're good to go

00:52:28 until you say, you know, dot, dot this or from dots.

00:52:32 Yeah.

00:52:33 From dot, dot a import B kind of stuff.

00:52:35 Like there's a surprising amount of information you need to pass in to do those kinds of resolutions

00:52:39 and such from imports, right?

00:52:42 All that kind of thing to make sure those things all exist.

00:52:44 Because what you're effectively doing, you know, from import is if you list multiple ones, you're

00:52:49 basically importing the module that those things are in and making sure that attribute gets set

00:52:53 on the thing you're wanting so that you can then grab it later and all sorts of stuff.

00:52:57 But the other key thing is, is the Dunder import function is structured to kind of make the

00:53:02 up code easier, right?

00:53:03 Because it's very structured to just push things onto the snack that Python's executing and then

00:53:09 make the call to Dunder import where it's just like, yeah, everything's already there.

00:53:12 Right.

00:53:12 But it's also why it's so funky.

00:53:14 You should never call it directly in your own code, right?

00:53:17 Like Dunder imports very much.

00:53:18 It's borderline implementation detail on this kind of thing.

00:53:21 This is why you choose import lib dot import module, right?

00:53:24 That function exists specifically.

00:53:26 And I designed it specifically for those cases where you need to do dynamic imports.

00:53:30 And you want a very clean, simple API because like the return type for Dunder import very much

00:53:36 is designed for the op code so that whether you're doing an import something or from

00:53:42 something import other thing, right?

00:53:44 Like the return value makes sense or that for the bytecode level does not make sense for

00:53:49 human beings, right?

00:53:50 So once again, do not call Dunder import directly.

00:53:52 You should always be calling import lib dot import module if you need something dynamically to

00:53:57 import.

00:53:58 Or just use the word import.

00:53:59 Yeah.

00:53:59 Or just import.

00:54:00 Yeah.

00:54:01 Just import.

00:54:01 Yeah.

00:54:02 In your right up here, you have all the different variations.

00:54:05 Like what does it mean to say from thing import something as or just import something or

00:54:11 relative imports?

00:54:12 So people can see all the different, again, back to that flexibility that you talked about.

00:54:17 Exactly.

00:54:17 So it's definitely one of these things though where in the end, it effectively just boils

00:54:22 down to a function call, right?

00:54:23 Like that piece of syntax of import really is just a function call with an assignment in

00:54:29 the end.

00:54:29 Yeah.

00:54:29 And it's really all it is.

00:54:31 It's the unraveling.

00:54:32 All the trickery is really behind the Dunder import function, but the actual syntax is

00:54:37 not, it's not crazy actually.

00:54:38 But it literally is a function call.

00:54:40 Yeah.

00:54:40 You can fully re-implement import.

00:54:42 Yeah.

00:54:43 But just calling Dunder import and just doing the proper assignment.

00:54:45 Nice.

00:54:45 Some confirmation of your advice out there.

00:54:48 Nathan says, my data science professor always says the same thing.

00:54:50 Import first, which is good.

00:54:52 But also, is there a way to remove syntactical sugar on an example, but not fully through disassembly?

00:55:00 You can actually write a tool that will take Python syntax and unravel it.

00:55:04 I actually started it, but it was just too much of a headache because there's so many variations

00:55:08 and edge cases and all that stuff to handle.

00:55:10 And there was no package out there that was going to, that quite did what I needed it

00:55:14 to do to make my life easier.

00:55:16 And I had other things to do.

00:55:17 Yeah.

00:55:17 What's the canonical, what's the destination, right?

00:55:20 Like if I undo a with statement on a lock, like how far do I want to go back?

00:55:25 You know?

00:55:26 Yeah.

00:55:26 Well, and I can understand people wanting to do it to maybe learn, but I mean, it's going

00:55:32 to be a learning thing, not really a performance thing.

00:55:35 It might be slower, right?

00:55:37 Because some of this stuff is happening at the sea level.

00:55:39 Oh yeah, exactly.

00:55:40 Like, like if you go back to our A plus B example, it actually definitely will be slower

00:55:45 as things, as things happen in Python, because once again, with the speed performance improvements

00:55:53 that have been going in, like, like the byte code is able to go like, all right, is

00:55:58 this an intent and an end?

00:55:59 Okay.

00:55:59 Well then we're, we know exactly how to do integer math.

00:56:02 Let's just do it.

00:56:02 Right.

00:56:03 And then it can add cards in and go like, okay, quick check AB.

00:56:06 Yes.

00:56:07 Okay.

00:56:07 Do the binary int add thing.

00:56:10 Right.

00:56:11 Where it just very, very obviously does that.

00:56:14 But if you unravel it, you can't do that because now you're just doing method calls.

00:56:17 Right.

00:56:18 You can't hide those details anymore and put all that.

00:56:20 Exactly.

00:56:21 But yeah, but to answer the question, you totally could write a tool to do this.

00:56:24 And I kind of started one and it just wasn't fun.

00:56:27 So I just stopped because I just had a thing.

00:56:31 You know, sometimes you see this in the editor as well, when like editors will give you previews.

00:56:35 So for example, if you use optional of a thing or thing pipe none, and then you hover over

00:56:41 it in the editor, it'll say, even if you used optional, it'll say thing pipe none, because

00:56:45 it, it's like, those mean the same thing.

00:56:47 I'm going to just represent them in one way.

00:56:49 And yeah.

00:56:50 Yeah.

00:56:50 Interesting.

00:56:51 Okay.

00:56:52 We have a bunch more things covered, but we don't have really any time.

00:56:54 Like my goal with this, having you on here to talk about this stuff, it's really kind of

00:56:58 like the highlight, the whole series and people should go.

00:57:00 And we've been kind of hand waving because reading C code on air is not ideal to give people

00:57:06 an idea, but really to highlight your whole series and people can just dive into this pretty

00:57:11 deep.

00:57:11 And, and I think they'll have a much better appreciation for when you write this one line.

00:57:16 Oh my goodness.

00:57:17 This is actually what's happening.

00:57:18 And how I actually found a bug in Python.

00:57:21 Thanks to it.

00:57:22 Okay.

00:57:22 Tell us quick about that.

00:57:23 Yeah.

00:57:23 It's covered in the in place binary operator, augmented assignment post.

00:57:28 So, you know how you can do a plus equals B and it's like doing a equals a plus B.

00:57:34 Yeah.

00:57:34 Yeah.

00:57:35 So it turned out it was broken for pal.

00:57:36 So when, you know, when you could do a star, star B, that's a to the B power.

00:57:41 Yeah.

00:57:41 It turned out the semantics were busted for star, star equals.

00:57:45 Wow.

00:57:45 Okay.

00:57:46 And no one had ever noticed because obviously people do not write custom implementations of

00:57:51 thunder pal.

00:57:52 Yeah.

00:57:52 Yeah.

00:57:52 Yeah.

00:57:52 Yeah.

00:57:52 Yeah.

00:57:53 turned out was, and someone actually discovered it and reported it.

00:57:56 I just didn't know about it.

00:57:57 that basically when you did that.

00:58:00 So the in place augmented assignment, there's I versions of everything.

00:58:04 Like I add a dunder.

00:58:06 I add dunder.

00:58:07 I mall dunder.

00:58:08 I pow, right?

00:58:09 It turns out for all of them, they did the right thing except for power where it would

00:58:13 check for I pow.

00:58:14 And I mean, in all these scenarios, because a plus equals B is the same as a equals a plus

00:58:20 B.

00:58:20 If the I version returns, not implemented, it falls back to just doing the binary operator

00:58:26 and then doing the assignment.

00:58:27 Right.

00:58:27 So like if I plus, so I plus equals B unravels to a dot I pap, I, a dot dunder I pow with

00:58:35 B as an argument.

00:58:36 If that returns not implemented, then it devolves into a plus B a equals the result of that.

00:58:42 Right.

00:58:42 In the pow case, if you return not implemented on dunder I pow, it didn't fall back to pow,

00:58:47 dunder pow.

00:58:48 Okay.

00:58:49 It just crashed.

00:58:50 You said, I don't know what to do here.

00:58:51 It was just an exception.

00:58:52 It was like, yeah, no.

00:58:53 I suppose that's better than the wrong answer.

00:58:54 Like actually the square of nine is 18.

00:58:57 Carry on.

00:58:58 It threw me for a loop because I wrote code to verify all my unraveling and how did the

00:59:04 augmented assignment for power just kept not working.

00:59:06 It was like, what the heck's going on?

00:59:08 And then I had to dig into the C code.

00:59:09 I was like, what am I doing wrong here?

00:59:11 Yeah.

00:59:11 Wait a second.

00:59:12 That code unravels calling this C code, calling this C code.

00:59:15 And it didn't check that return value on calling it under ipow.

00:59:19 It's like, well, did it return not implemented?

00:59:21 And if it did, then we've got to try the other version.

00:59:23 It just didn't.

00:59:24 It's like, oh, no, it's just the value just got returned.

00:59:27 It just didn't even check.

00:59:28 I think we figured out it happened when the third argument to pow got added and it was just

00:59:33 someone overlooked it.

00:59:33 But I see it been sitting there for years.

00:59:36 Like I think it was a decade.

00:59:38 Yeah.

00:59:39 You're looking through these things.

00:59:40 You can tell that they're pretty subtle.

00:59:42 There's a lot going on in the different special cases.

00:59:44 So I can see it wouldn't hit you in the face that you necessarily miss something right

00:59:47 away.

00:59:48 Exactly.

00:59:48 Yeah.

00:59:49 Yeah.

00:59:49 Yeah.

00:59:49 I don't fault anyone at all.

00:59:51 I think we were just missing a test case somewhere to make sure that that happened.

00:59:54 Because and once again, I don't think people define their own custom pow operator for their

00:59:59 types.

01:00:00 There's a whole bunch of mathematicians going, we do.

01:00:02 We do.

01:00:03 Or physicists or something.

01:00:05 Yeah.

01:00:06 All right.

01:00:06 We're pretty much out of time to go any deeper on this.

01:00:08 And I think that I think people got a really good sense of what's happening, you know,

01:00:13 like what you mean with your series here.

01:00:15 And hopefully they're inspired to go check it out.

01:00:17 But I do.

01:00:17 While I have this import stuff on the screen and you've done so much work with import lib,

01:00:21 will there ever be a time where like hot reload type of stuff is a thing?

01:00:27 You know, like I edit this file in this web app and it's got this project.

01:00:31 It's been running.

01:00:32 And I just, just maybe could we have a file watcher trigger this module to re-import?

01:00:38 Not necessarily saying it's a good idea, but have you.

01:00:40 Do you mean like you want automatic import lib.reload?

01:00:43 Yes.

01:00:44 Or, you know, even like the lib reload stuff.

01:00:46 A lot of times like you can do it, but it's kind of discouraged because I think largely because

01:00:50 of the side effects.

01:00:51 What can happen there?

01:00:53 No, so to be very specific, if you call a module, if you call import lib.reload on a

01:00:58 module, it effectively reruns import on that module.

01:01:01 The problem is, is all the references you have to objects don't change.

01:01:07 Yeah, exactly.

01:01:07 So if you got something out of that module, like let's say there was a global dictionary

01:01:13 that you stored a reference to a way that you expected.

01:01:15 Right.

01:01:15 Or a function or a class.

01:01:17 Maybe.

01:01:18 Yeah.

01:01:19 And then you call reload, everyone else in the future is going to get the new module

01:01:23 and they'll get the new version of all the things that were in that module.

01:01:26 But all that stuff you still have reference to do, that didn't get magically taken away

01:01:30 or garbage collected.

01:01:30 And we can't really necessarily swap it underneath you either because the whole type could have

01:01:34 changed.

01:01:34 Right, right, right.

01:01:35 So, I mean, if you really wanted to set up your own import system that does file monitoring

01:01:40 and Omnic calls import.reload, you could totally do that today.

01:01:43 There's nothing stopping you.

01:01:45 But you have to just be very aware that.

01:01:48 Only sometimes will it have a good effect.

01:01:50 Yeah, it'll have an effect.

01:01:52 Yeah.

01:01:52 It's just whether it's going to do what you expect.

01:01:55 And that's why import.reload is discouraged because people often don't quite understand

01:02:01 the side effects and the things you have to watch out for to understand that it's going

01:02:05 to do what you expect.

01:02:06 And especially when you import, do from imports, right?

01:02:11 Because then you're getting the direct objects off the module instead of the module itself.

01:02:14 Because if it doesn't in place reimport.

01:02:17 So, if you did import spam and you reloaded spam, the attributes off of spam will now be

01:02:23 the new stuff.

01:02:24 Because we actually changed that dictionary in place.

01:02:26 But if you did from spam import function, function is not going to change.

01:02:30 There's another reason why I always tell everybody, don't import the objects from a module, import

01:02:34 to the module.

01:02:35 I personally find it more readable because I can look at the code no matter where I am

01:02:39 in the file and know where that function came from.

01:02:41 It's not from this module.

01:02:42 It's from somewhere else.

01:02:43 I am always with you.

01:02:43 I'm almost never from thing import other thing.

01:02:46 Yeah.

01:02:47 Unless it's a deep module in a package, in which case that makes sense.

01:02:50 Because you'll still do module dot thing.

01:02:53 Right.

01:02:53 Right.

01:02:53 Well, even though I have that, if it's like four levels deep, I'll do the first three.

01:02:57 And then from the first three, import the last step of the module.

01:03:01 So, you can say like data layer dot, you know.

01:03:03 Exactly.

01:03:04 Update rather than just update.

01:03:05 Like, well, what does update mean?

01:03:06 I don't know.

01:03:07 Exactly.

01:03:07 Yeah.

01:03:08 I mean, the canonical example is random.

01:03:10 You see the function random in your code.

01:03:12 Whose random is that?

01:03:13 Is that from the random module?

01:03:14 Is that from NumPy?

01:03:15 Did you implement random?

01:03:17 Whose random is that?

01:03:18 Yeah.

01:03:19 You just know.

01:03:19 But if you saw np.random, you'd know.

01:03:21 Exactly.

01:03:22 Yeah.

01:03:22 If you knew what np was.

01:03:23 Yeah.

01:03:23 If you did.

01:03:24 Of course.

01:03:25 Right.

01:03:26 I guess give you a chance to kind of summarize.

01:03:29 Final, final thoughts here on your Syntactic Sugar series and, you know, tell people how

01:03:34 to get it and stuff.

01:03:34 You can go to my blog.

01:03:35 It's on Snarky.ca.

01:03:37 It has the tag Syntactic Sugar.

01:03:39 I'm sure Michael will include it in the show notes.

01:03:41 Don't feel the need to read all of it, but do look at at least the first one or two because

01:03:47 I do go into more detail on how you can kind of go exploring on your own in way more detail

01:03:52 in those posts than I do towards Anne because I'll be honest, I lost a bit of steam and

01:03:56 going diving into all the deep layers.

01:03:58 I wanted to get the blog post series done after two years.

01:04:01 It was one of those.

01:04:02 Okay.

01:04:02 Go look at the earlier ones.

01:04:03 They'll explain how to how to figure out how to go from syntax to the bytecode to the C code

01:04:08 and then know where to look in the C code, which, by the way, you don't have to understand

01:04:11 the C code.

01:04:12 It's not a is not crazy C code, but it's also not necessarily critical.

01:04:16 I do try to write down the Python equivalents for everything.

01:04:19 So it's there if you do understand C, but don't feel intimidated if you don't.

01:04:23 And hopefully you just find it interesting, right?

01:04:25 Like you've always wondered how the heck does this work?

01:04:27 If it's in that, if it's in the blog post, you'll be able to have a better understanding

01:04:33 hopefully of how things work.

01:04:33 Because as I said, I honestly even learned some details that I forgot or never even knew

01:04:37 about some of the semantics behind Python and how, like how things actually work underneath

01:04:42 the hood.

01:04:43 And it just gave me a better understanding to understand when things do and don't happen

01:04:46 the way I expect.

01:04:47 And honestly, appreciate all the work everyone's put into language over the decades to make it

01:04:52 all seemingly seem simple.

01:04:53 And yet it's surprisingly complex.

01:04:55 Yeah.

01:04:55 I don't think you need to read them all either as somebody who read most of them the last couple

01:04:59 of days.

01:04:59 No, you don't.

01:05:00 I mean, if you're a completionist, go for it.

01:05:03 But yes, you definitely do not need to.

01:05:04 But I do think going through it, you know, pick out the ones, there's a whole bunch of

01:05:08 different topics.

01:05:09 Pick out the ones that are like, oh, I did always wonder how that one worked.

01:05:11 And pretty much with the exception of pass, I think you'll be like, oh my gosh, I had no

01:05:18 idea what was involved here.

01:05:19 Yeah.

01:05:19 Pass was very much just a, I had a checklist of every piece of syntax and every single keyword.

01:05:24 And that was that the blog post on pass, I think is like three sentences and half of

01:05:29 it saying this is going to be the shortest, shortest post in this whole series.

01:05:32 Yeah.

01:05:33 Pass is.

01:05:33 Yeah.

01:05:34 It was contending with dot, dot, dot, which we haven't even had a chance to talk about

01:05:38 ellipses versus pass, but I think we're out of time, Brett.

01:05:42 So thanks for being here.

01:05:44 Thanks for all you do.

01:05:45 I mean, steering council, core dev, author, VS Code, et cetera.

01:05:50 A lot of contributions.

01:05:51 Thanks.

01:05:52 Thanks for having me back on yet again.

01:05:53 And hopefully I've not worn out my welcome still.

01:05:55 No, you're already thinking about what next WebAssembly Rust thing we'll get together on.

01:06:01 Thanks for being here.

01:06:02 See you later.

01:06:03 Thanks, Michael.

01:06:03 This has been another episode of Talk Python to Me.

01:06:07 Thank you to our sponsors.

01:06:08 Be sure to check out what they're offering.

01:06:10 It really helps support the show.

01:06:11 Want to level up your Python?

01:06:14 We have one of the largest catalogs of Python video courses over at Talk Python.

01:06:18 Our content ranges from true beginners to deeply advanced topics like memory and async.

01:06:23 And best of all, there's not a subscription in sight.

01:06:26 Check it out for yourself at training.talkpython.fm.

01:06:28 Be sure to subscribe to the show.

01:06:30 Open your favorite podcast app and search for Python.

01:06:33 We should be right at the top.

01:06:35 You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:06:40 and the direct RSS feed at /rss on talkpython.fm.

01:06:44 We're live streaming most of our recordings these days.

01:06:47 If you want to be part of the show and have your comments featured on the air,

01:06:50 be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:06:55 This is your host, Michael Kennedy.

01:06:57 Thanks so much for listening.

01:06:58 I really appreciate it.

01:06:59 Now get out there and write some Python code.

01:07:01 I'll see you next time.

