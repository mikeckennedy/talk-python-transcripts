00:00:00 One of the nice things about the Python programming language is it's at least three programming paradigms in one.

00:00:05 There's the procedural style, the object-oriented style, and the functional style of programming.

00:00:12 This week, you'll meet Evan Hubinger, who is taking Python's functional programming style and turning it to 11.

00:00:19 We are talking about Coconut, a full functional programming language that is a proper superset of Python itself.

00:00:25 This is Talk Python, episode 117, recorded May 22, 2017.

00:00:54 Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:01:01 This is your host, Michael Kennedy.

00:01:03 Follow me on Twitter, where I'm @mkennedy.

00:01:05 Keep up with the show and listen to past episodes at talkpython.fm.

00:01:09 And follow the show on Twitter via at Talk Python.

00:01:13 This episode is brought to you by Rollbar and Hired.

00:01:16 Thank them both for supporting the show.

00:01:18 Check them out at Rollbar and at Hired underscore HQ on Twitter and tell them thank you.

00:01:25 Before we jump into the main part of the show, I want to let you know that we're adding a couple of new courses over at Talk Python Training.

00:01:32 Within the next few weeks, we'll be releasing RESTful HTTP services with Pyramid and Python, including a SQLAlchemy data-driven backend, and another course, MongoDB for Python developers.

00:01:45 If you're interested in either of these, be sure to create a free account over at training.talkpython.fm to get notified.

00:01:53 Evan, welcome to Talk Python.

00:01:54 Thank you. Thank you for having me.

00:01:55 Oh, it's an honor to have you. I'm really excited.

00:01:57 You've got this really cool project that I think is doing some interesting stuff in the Python space.

00:02:03 And so I'm pretty excited to share this new functional superset of a language that you've created.

00:02:11 But of course, before we get into the details with Coconut, let's talk about your story.

00:02:15 How did you get into programming in Python?

00:02:16 So I started programming actually as a sort of summer camp thing between middle school and high school.

00:02:24 It was not a very well-taught summer camp, actually.

00:02:28 It was really just, we're going to throw some Python at you.

00:02:32 I took a look at it, and I sort of experimented with it, and it was interesting.

00:02:36 What really got me excited about it was just the things that I started to be able to do once I just was exposed to it,

00:02:45 and then started learning about Python online, going through the documentation, and building up.

00:02:50 I started writing text games and worked my way up to more complicated mathematical stuff,

00:02:57 follow along what I was learning in school.

00:03:00 And as I went through, I sort of worked my way through the various different things in Python,

00:03:06 working my way to know the language better and better, all from this start just as, what is this thing?

00:03:13 This thing that actually lets you take a computer and give it commands and actually output something that's interesting, useful, and powerful.

00:03:20 And so that was my beginning, my introduction, the way that I got started.

00:03:24 That's cool.

00:03:25 And the first language was Python that you learned?

00:03:26 My first language was Python.

00:03:28 Yeah.

00:03:28 And I used Python pretty exclusively for many years after that.

00:03:34 The second language that I really got into after that was Haskell.

00:03:37 Okay.

00:03:38 Yeah.

00:03:39 Haskell is definitely one of the more popular functional programming languages, right?

00:03:43 And so did that kind of blow your mind?

00:03:46 You're like, whoa, Haskell's different.

00:03:48 Absolutely.

00:03:48 Yeah.

00:03:49 So I, at that point, had been pretty used to Python.

00:03:52 That was sort of two years after I had originally learned about Python.

00:03:56 And since that time in doing a lot of Python, like I was saying, Haskell was this new experience.

00:04:01 This experience of there's all these new concepts, all these new features,

00:04:06 all these new powerful things I'd never seen before.

00:04:08 I was blown away by how powerful pattern matching was.

00:04:12 I was blown away by how powerful all of the sorts of different constructs that I had available to me,

00:04:18 the different things that I could do in Haskell that I had never seen before.

00:04:22 And one of the first things, the sort of mythical origin story of sorts was one of the first things I did

00:04:29 when I tried to learn Haskell was I went back and I tried to implement it and like do all of those things in Python.

00:04:35 And of course that wasn't, that didn't go as well as I was hoping.

00:04:38 And that was the sort of basis and jumping off point for what I would later do.

00:04:42 That's really cool.

00:04:43 Is that the thing you called Rabbit?

00:04:45 Yes.

00:04:45 So originally, so the very first programming language that I wrote was Rabbit.

00:04:50 That was a, just a sort of project that I was making.

00:04:54 I was like, I'm going to take all of these cool Haskell features that I think are awesome,

00:04:59 all of these new things that I'm learning, and I'm going to put them in Python.

00:05:03 I'm going to write an interpreter on top of Python that, of course, that's a terrible idea for what should have been obvious reasons.

00:05:11 But how long can it take, like a week?

00:05:13 But yeah, so I wrote that.

00:05:17 It was, it was, it was fun.

00:05:19 It was a cool, interesting project.

00:05:21 Would not recommend trying to write code in Rabbit.

00:05:24 But it was a big learning experience for sure.

00:05:27 And a lot of the lessons that I learned in that process, I would later apply to Google.

00:05:34 Yeah, that's really cool.

00:05:34 And Rabbit is actually on GitHub.

00:05:36 So I'll put it in the show notes.

00:05:37 And if people want to check out your first attempt, they can do that, right?

00:05:41 Yes.

00:05:41 Yes.

00:05:41 That's on my GitHub.

00:05:42 Nice.

00:05:43 All right.

00:05:44 So what do you do day to day?

00:05:46 You're still in college, right?

00:05:47 Yes.

00:05:47 So I'm a student at Harvey Mudd.

00:05:49 I'm a rising junior.

00:05:50 And for people listening to other parts of the world, where's Harvey Mudd?

00:05:54 Harvey Mudd is in Claremont, which is a suburb of LA in California.

00:05:58 Yeah.

00:05:59 Excellent.

00:05:59 Okay.

00:06:00 And then you also did some intern work at some pretty interesting companies, right?

00:06:03 Yeah.

00:06:04 So I am currently an intern at Google.

00:06:06 Last summer, I interned at Yelp.

00:06:09 And before that, I was an intern at Ripple.

00:06:11 Oh, that sounds...

00:06:12 That's pretty awesome, man.

00:06:13 What do you think of that experience?

00:06:16 It's been a blast.

00:06:17 I've really liked all of the companies that I've worked for.

00:06:20 I've done a lot of really interesting things as part of those jobs.

00:06:25 And Yelp, of course, that was really exciting last year because that was all in Python.

00:06:28 Oh, yeah.

00:06:29 Nice.

00:06:30 So you're a math CS grad, right?

00:06:32 That's correct.

00:06:33 Yes, I'm a math CS major.

00:06:34 I see.

00:06:34 Nice.

00:06:35 So, yeah, I also studied math, not so much CS.

00:06:39 Like I said, it's a bit of a minor type thing.

00:06:41 It wasn't called that, but more or less.

00:06:44 And so how do you feel like that's prepared you for this, for these internships and some

00:06:49 of these experiences?

00:06:50 Obviously, the computer science portion of it is there.

00:06:53 But the math thing, it really is also there as well.

00:06:56 I know that in my work at Yelp, there were points where I used graph theory, points where I used

00:07:04 number theory.

00:07:05 So the stuff really does come up where you want to have that background to be able to fall back

00:07:12 on to help you handle weird, interesting, challenging problems.

00:07:16 Right.

00:07:16 More in the algorithmic side.

00:07:18 Yeah, nice.

00:07:19 I also feel like math, if you get really into math, like advanced math proofs and real analysis

00:07:25 and things like that, it teaches you how to think and solve problems.

00:07:29 And it doesn't really matter the rules around it.

00:07:32 The programming rules are programming rules, right?

00:07:34 I think it's pretty good for foundation.

00:07:37 Yeah, I totally agree with that.

00:07:38 Awesome.

00:07:38 So you've had this Pascal experience.

00:07:41 And of course, there's a number of different functional programming languages.

00:07:45 Why don't we talk a little bit about like, what is functional programming?

00:07:49 I mean, it's not just using functions, right?

00:07:51 It's entirely different than that, isn't it?

00:07:54 Yeah.

00:07:55 So the sort of textbook classic definition of functional programming is that it's all

00:08:00 about pure functions.

00:08:01 It's all about immutable data structures.

00:08:03 And all of that is true.

00:08:05 Functional programming does involve pure functions.

00:08:07 It does involve mutable data structures.

00:08:09 But one of the things I think a lot of people get frustrated by with that definition is that

00:08:14 it's sort of exclusive.

00:08:15 It says what functional programming is not.

00:08:18 It isn't about mutability.

00:08:19 And it isn't about functions with side effects.

00:08:22 But it doesn't say what functional programming is.

00:08:25 And what functional programming is, is really those are the parts that Coconut is really

00:08:29 trying to nail down.

00:08:30 Because Coconut isn't a pure functional programming language.

00:08:33 But what it brings to the table, and what functional programming brings to the table,

00:08:37 and what Coconut brings to the table with it, is the way that you work with those pure

00:08:41 functions and those immutable data structures, having them, the things that that lets you do.

00:08:45 It lets you have things like higher order functions.

00:08:47 So you can take paradigm standard practices and turn them into functions that you can then apply

00:08:54 in general concepts.

00:08:55 It lets you have pattern matching.

00:08:56 It lets you, instead of having to explicitly define how you're going to match or take a

00:09:02 look at a particular incoming data type, it lets you just define a general pattern for

00:09:07 what the data type looks like and how it gets deconstructed.

00:09:10 Right.

00:09:10 Maybe the best way to conceptualize that is it's a little bit like function overloading,

00:09:15 but way more general, right?

00:09:18 Yeah.

00:09:19 Yeah.

00:09:19 That's definitely a good way to think about it.

00:09:21 Because when you're overloading a function, I guess, in like C or C++, you're doing it

00:09:26 based on just types.

00:09:27 And pattern matching is sort of, what if you could do that not just on types, but on all

00:09:31 sorts of different attributes of the data?

00:09:34 What if I could have a different function call for when it was an empty list versus when

00:09:38 it wasn't an empty list?

00:09:39 And that's, yeah, that's one of the big things that the pattern matching list you do.

00:09:43 Awesome.

00:09:44 Yeah.

00:09:44 We'll dig into that.

00:09:44 Yeah.

00:09:45 And you also have lazy evaluation.

00:09:47 There's some other follow-ons or corollaries from this that are very, I think one of the

00:09:54 reasons driving functional programming is with this immutability and no side effects, parallelization

00:10:02 becomes like what they call embarrassingly parallel, right?

00:10:07 Where it's just like, well, you just break it into pieces and just do that, right?

00:10:10 Because you don't have to worry about one piece getting ahead of another, right?

00:10:14 Yep, exactly.

00:10:15 Exactly.

00:10:15 Parallelization becomes really trivial, really easy to do when you have your functions written,

00:10:22 your data structures written in a functional style.

00:10:25 Nice.

00:10:25 Nice, nice.

00:10:26 So give us some examples of existing functional languages.

00:10:29 So I mentioned Haskell.

00:10:31 I'm a big fan of Haskell.

00:10:33 I've used Haskell a lot.

00:10:34 But there's definitely lots of other functional languages.

00:10:37 On the sort of more pure side, you have languages like OCaml and Erlang, as well as Elixir.

00:10:44 It's a newer variant.

00:10:45 On the sort of middle ground, sort of half-functional, you have languages like Scala, languages like

00:10:53 CoffeeScript or LiveScript or JavaScript.

00:10:55 There's really a whole wide array of functional programming languages out there that try to bring

00:11:02 in some of these new powerful features and put them in different contexts.

00:11:07 Sure.

00:11:07 And if we think about Python, Python itself has some functional components, right?

00:11:13 We could go like full in OOP programming in Python.

00:11:18 We could go quite deep into the functional program.

00:11:21 You can, or just straight imperative code, right?

00:11:24 We can sort of pick some pieces up and choose a style for Python, right?

00:11:29 Yeah, absolutely.

00:11:30 I mean, that's one of the things that I love about Python.

00:11:32 Python really is great at being a multi-paradigm language.

00:11:36 You really can do all of the functional programming stuff.

00:11:39 You know, one of the things, of course, that I would say attest to that is that Coconut can

00:11:43 compile to Python and make it all work, even when you try to import it from Python.

00:11:47 But there's a lot of things that, while they technically work, really don't work nicely.

00:11:52 So when Python is designed, the sort of whole philosophy around it, the use cases that are

00:11:58 considered really aren't generally functional programming use cases.

00:12:01 You know, when the syntax is designed, when the various different use cases are considered,

00:12:06 it's mostly thinking about and considering object-oriented use cases.

00:12:10 And that's fine.

00:12:11 Python's a great object-oriented programming language.

00:12:13 But it means that a lot of the functional programming use cases will get left behind.

00:12:18 So you have things like Python's Lambda, which is notoriously ugly, as well as functools.partial,

00:12:24 which is difficult to use.

00:12:27 You get a lot of things that don't really...

00:12:29 Features you would really like to see from a functional standpoint that don't exist at all.

00:12:32 Features like tail call optimization or tail recursion elimination.

00:12:35 Features like pattern matching.

00:12:37 And features like immutable algebraic data types.

00:12:40 A lot of that stuff is missing.

00:12:42 Right.

00:12:43 The very dynamic nature of Python does make it a little bit hard to have immutable data types,

00:12:49 for sure.

00:12:50 And yeah, its primary thing is not in its functional style.

00:12:54 I would say whatever it is, maybe it's OOP, maybe it's not quite, maybe it's something slightly

00:13:00 different.

00:13:00 But functional is not its primary focus.

00:13:02 Do you think that the adoption of things like Scheme and Lisp and Haskell and whatnot is somewhat

00:13:12 limited by its pureness?

00:13:14 I would say that's definitely true.

00:13:16 Because it really is much more difficult to try to learn a pure functional programming language

00:13:23 than it is to try to get...

00:13:24 Especially if you're coming from an imperative, non-functional background.

00:13:28 Than it is to try to go with a language that is partially functional.

00:13:33 Haskell is great, but getting started with Haskell isn't easy.

00:13:38 There's a lot to learn.

00:13:39 There's a lot of new concepts that you may not be familiar with, even if you've programmed

00:13:43 for a long time in other programming languages.

00:13:45 And so that really does create a barrier to entry.

00:13:48 I guess so.

00:13:48 It definitely seems like it would be a challenge to me.

00:13:51 So you decided to add one more language to this list of this spectrum of functional programming

00:13:58 languages.

00:13:58 Yeah.

00:14:00 So what's this project called Coconut?

00:14:01 Yes.

00:14:02 So that's true.

00:14:03 So Coconut is a functional programming language that compiles to Python.

00:14:08 So some of the basic design decisions of Coconut.

00:14:11 Coconut syntax is a strict superset of Python 3 syntax.

00:14:15 So Coconut takes Python 3 and adds on top of that new features for functional programming.

00:14:21 That includes things like algebraic data types, tail call optimization, pattern matching.

00:14:26 And then Coconut takes all of that and compiles it to universal version independent Python.

00:14:34 Yeah, the version independent part is pretty awesome.

00:14:36 Well, and it's version independent in certain ways, right?

00:14:39 Like the syntax that you write into your Coco files, that's Python 3, right?

00:14:45 Exactly.

00:14:46 So Coconut syntax is based on Python 3.

00:14:49 It's a strict superset of Python 3.

00:14:50 But then that gets compiled to Python code that is compatible with 2.6, 2.7, 3.2, and above.

00:14:58 Right.

00:14:58 So the execution engine can be either Python 2 or Python 3, but you input Python 3 or pure

00:15:05 Coconut, right?

00:15:06 Yes, that's exactly correct.

00:15:07 Coconut code you input is a strict superset of Python 3.

00:15:11 But the compiled output is universal or you can specifically target one Python version or

00:15:16 another.

00:15:16 Okay.

00:15:17 There are some cases where you are forced to target a Python version.

00:15:20 One example of this is if you wanted to do something like 3.5 matrix multiplication.

00:15:23 There's no way to backport that to Python 2.

00:15:27 And so you're going to have to pass a flag that tells the compiler, I only care about 3.5.

00:15:32 Right.

00:15:32 Okay.

00:15:32 Yeah.

00:15:33 It's really interesting the way it works.

00:15:35 I mean, the analogies that come to mind are like TypeScript, right?

00:15:40 TypeScript is a superset of JavaScript, compiles of pure JavaScript.

00:15:43 C++ on top of C, right?

00:15:46 Not so much things like CoffeeScript where it's entirely a different language.

00:15:51 It just happens to transpile into a thing that you might know like JavaScript or something.

00:15:57 So I think that's going to make it much easier to adopt, right?

00:16:00 Like if I've got some program that's Python 3 and I want to make it more functional, I could

00:16:07 just put a different file extension, the .coco on it, and change it where it matters, right?

00:16:14 Yeah, that's exactly it.

00:16:15 So that was a purposeful design decision on my part from the very beginning.

00:16:20 One of the really core things that I, like I was saying earlier, learned from Rabbit was

00:16:26 I want to make sure to have a coherent story for how people are going to adopt this, why

00:16:33 people are going to use this, and how even just as an existing Python developer, I can make

00:16:38 something that is useful to you.

00:16:39 And one of the ways, one of the really fundamental ways that I try to achieve that is via this,

00:16:45 we're going to make the whole syntax a superset of Python 3.

00:16:49 That way, you already know, if you know Python 3, most of the core syntax of the language.

00:16:55 You don't have to learn anything new to be able to do things you already know how to do.

00:17:00 The only things that you get to learn new are new features, new things that you can add

00:17:06 to your repertoire.

00:17:07 So the point is not to relax, reduce the amount that your Python developer is capable of,

00:17:14 but only to expand and to allow you to be able to do new things in Coconut that you wouldn't

00:17:19 otherwise be able to.

00:17:20 That's really cool.

00:17:21 And I can tell you from going through the tutorial, there's some really mind-bending stuff in there

00:17:25 that we're going to get to.

00:17:26 It's pretty awesome.

00:17:27 So before we get into the details, why do you choose Coconut as a name?

00:17:32 Oh, as a name.

00:17:34 So that's a reference to Monty Python and the Holy Grail.

00:17:38 And the Knights Insane and those guys are clicking along?

00:17:40 Yeah, they've got the follow-behind, the Knights of the Round Table, smashing the coconuts together.

00:17:46 So, yep.

00:17:47 That's awesome.

00:17:47 Yeah, yeah.

00:17:48 If I was going to guess, that's what I thought.

00:17:50 But yeah, perfect, perfect.

00:17:51 It's really funny that a lot of people think Python is some kind of snake reference.

00:17:55 And of course, it's not, right?

00:17:57 Yeah.

00:17:58 Hey, everyone.

00:18:00 Michael here.

00:18:01 Let me take just a moment and thank one of our sponsors who makes this show possible.

00:18:04 This portion of Talk Python To Me has been brought to you by Rollbar.

00:18:07 One of the frustrating things about being a developer is dealing with errors.

00:18:11 Ah, relying on users to report errors, digging through log files, trying to debug them, or a million alerts just flooding your inbox and ruining your day.

00:18:19 With Rollbar's full-stack error monitoring, you get the context, insight, and control you need to find and fix bugs faster.

00:18:25 Adding the Rollbar Python SDK is just as easy as pip install Rollbar.

00:18:30 You can start tracking production errors and deployments in eight minutes or less.

00:18:34 Rollbar works with all the major languages and frameworks, including the Python ones like Django, Flask, Pyramid, as well as Ruby, .NET, Node, iOS, and Android.

00:18:43 You can integrate Rollbar into your existing workflow, send error alerts to Slack or HipChat, or automatically create new JIRA issues, pivotal tracker issues, and a lot more.

00:18:52 They have a special offer for Talk Python To Me listeners.

00:18:54 Visit talkpython.fm/rollbar, sign up, and get the bootstrap plan free for 90 days.

00:19:00 That's 100,000 errors tracked for free.

00:19:02 But, you know, just between you and me, I hope you don't encounter that many errors.

00:19:06 Give Rollbar a try today.

00:19:08 Just go to talkpython.fm/rollbar.

00:19:12 Yeah, so you covered some of the reasons why you built it, but, like, maybe give us some of the technical underpinnings of, like, why do we need this new language instead of just different PEP practices or whatever to work in this way?

00:19:25 Sure.

00:19:26 So, I think Coconut really does add a lot of very fundamental changes to Python syntax.

00:19:33 So, it's very hard to do a lot of that stuff via just, like, the PEP process.

00:19:37 I don't even think that that would necessarily be a good thing if sometime along the road all of that, all of Coconut syntax is implemented in Python.

00:19:45 It really is trying to be a separate language because it adds a lot of new stuff on top of Python that is specifically for being able to do a lot of these more advanced functional things to add to some of the more basic things that you can do in Python.

00:20:02 As well, I would say that as far as, like, why use Python, why get into it, the more technical underpinnings as well.

00:20:11 First, Coconut really is built to be useful to existing Python programmers.

00:20:16 You should be able to just pick it up, write a Coconut file, and immediately, like, as you work your way through the tutorial, as you work with the documentation, see new things that you can just add in to your existing knowledge of Python just to make your code more powerful, to make it so that you have new access to new features, as well as make the version compatibility story really easy for you.

00:20:36 Yeah, and I really like the fact that you take one input language or variation, Python 3, but then it becomes execution independent.

00:20:47 Yeah, exactly.

00:20:48 One of the really nice things about compiling to Python source code is that it really is truly independent.

00:20:53 You can run Python 3 even without adding any new Coconut features, or if you do add new Coconut features, run it through Coconut, get a compiled source that, because it's still Python, you can even run on PyPy, you can run on Jython or IronPy.

00:21:06 You don't even need to, like, if you compile the CPython bytecode, for example, then it'd be sort of very restricted, but it really is just pure Python, and so wherever you want to be able to use Coconut constructs, you can.

00:21:19 Yeah, that's cool. So right now the compiler, or transpiler, or whatever you want to think of it as, takes Cocoa syntax and compiles it to Python syntax that is very careful to work on both versions of the language.

00:21:35 Is there a chance that you could change that compiler, extend it, make it compiler to things like, could I compile it to JavaScript? Could I compile it to .NET Intermediate Language, or Java file, Java bytecode, or things like this?

00:21:49 There are no plans to do something like that right now. That would be a pretty massive undertaking.

00:21:56 But certainly possible, I suppose, sometime very far down the road, I could see Coconut going that direction.

00:22:03 I'm not proposing that it should, I was just kind of curious what your thoughts on that were.

00:22:08 I think that for a lot of that stuff, there are a lot of utilities that already exist for taking Python code and making it available in other frameworks and other places.

00:22:17 And Coconut can run right on top of those things, because it just produces Python source code.

00:22:21 Right, so you really want to just stay focused on enhancing the functional programming story within the Python space purely.

00:22:27 Right. Coconut has a pretty singular mission that is really focused on, I'm going to make Coconut be able to allow you to do functional programming really well in Python.

00:22:36 You don't have to deal with any of the weird syntax ugliness, any of the missing features.

00:22:43 Everything's going to work, you're going to be able to just take all of these powerful functional programming features and just run it in Python.

00:22:48 Nice.

00:22:49 So, what if I don't know functional programming, right?

00:22:53 Maybe I'm self-taught and I've learned Python and whatever.

00:22:56 Should I bother to learn or play with Coconut?

00:22:59 What do you think?

00:23:01 So, I mean, I would simply definitely say yes.

00:23:03 My argument would actually be that Coconut's a really nice way to learn functional programming,

00:23:08 because it means that you can start with everything you know about Python already being applicable.

00:23:14 So, you don't have to, like if you try to learn functional programming through Haskell, for example,

00:23:19 you have to rebuild up all of that knowledge about programming in general

00:23:25 and all of the different ways to perform all of the different operations.

00:23:29 Whereas with Coconut, all of that basic syntax is just Python.

00:23:33 And it's only building functional stuff on top of that that you have to learn.

00:23:38 And so, I think that trying to learn Coconut really is a good way to start getting into different functional programming features.

00:23:46 And the tutorial for Coconut is, I think, a great way to do that.

00:23:49 Yeah, that's really cool.

00:23:51 It's definitely a way to expand your mind of what's possible.

00:23:53 So, how do you install it?

00:23:57 Is there like some download I got to do?

00:23:59 Or what's the story?

00:24:00 pip install Coconut.

00:24:01 That's it.

00:24:02 Beautiful.

00:24:03 It's the way it should be, right?

00:24:04 And then, yeah.

00:24:05 So, once you pip install Coconut, you have a new CLI.

00:24:09 You just say Coconut thing and then stuff happens, right?

00:24:12 Yep.

00:24:12 Most basic command line interface is just Coconut name of a .coco file.

00:24:17 And it'll compile that to a Python file.

00:24:19 There's, of course, more complicated stuff than that.

00:24:21 There's lots of command line flags and whatnot.

00:24:22 But the most basic syntax is just that.

00:24:25 Yeah, nice.

00:24:25 So, you basically run it through this compile step.

00:24:28 And then, you've got a set of Python files laying there.

00:24:30 And you just execute them like you would anything, right?

00:24:33 Any Python program.

00:24:34 Coconut can compile and execute if you want it to take care of both of the steps.

00:24:39 If you pass the minus R flag.

00:24:40 But it can take care of a lot of different things.

00:24:43 It's got a lot of different features.

00:24:44 But most fundamentally, it's a compiler, transpiler, whatever you want to say.

00:24:47 You give it Coconut code, it turns it into Python code.

00:24:50 Sure.

00:24:50 Okay.

00:24:50 So, one of the pieces of syntax.

00:24:52 Like, it's a little.

00:24:53 It's beyond a little.

00:24:54 It is hard to talk about syntax in audio format.

00:24:59 So, I don't want to do it too much.

00:25:00 But I want to touch just a little bit on a few things.

00:25:03 Because a little bit, I think, will give people a strong idea.

00:25:08 So, one of the things that's kind of annoying is if I want to take one function and pass its value to the next function and pass its return value to the next function.

00:25:17 I basically have to do that inside out.

00:25:19 The innermost.

00:25:21 If I want to do it in one expression, not multi-line, right?

00:25:23 I take the first function.

00:25:25 Then I wrap it.

00:25:26 And I call it the second function.

00:25:28 I take that and wrap it in another one.

00:25:29 And so, you don't read it normally.

00:25:32 You read it, like, inside out, which is not great.

00:25:35 So, you have this syntax in Cocoa and Coconut that says, left or right, take this and flow it to the, you know, almost like a Unix pipe sort of thing, right?

00:25:46 Yeah.

00:25:47 Pipeline operators in Coconut are borrowed from F Sharp.

00:25:51 They exist in a lot of other languages as well, like Elm.

00:25:55 But, yeah, the basic idea is it's a much more intuitive way to read and think about function calls.

00:26:03 It really is one of the more syntactic, sugary features.

00:26:07 It's not like something like pattern matching or tail call optimization that is sort of a more powerful thing behind the scenes.

00:26:13 But I really do think that it's a good example of a way in which just from the most basic level before you even start delving into the more complex functional programming features, it just immediately makes your code easier to read, easier to understand, easier to follow.

00:26:28 Because, like you were saying, that is how we more intuitively, natively think about functions is you take some value and you apply a transformation to it.

00:26:38 And then you get something new and then you apply another transformation to it.

00:26:41 And when you write it with that syntax, that's exactly the way that it looks.

00:26:44 And so I do really think that it does make it look nicer.

00:26:48 Yeah, it's pretty interesting.

00:26:49 Let's talk about some of the other features.

00:26:52 Some of them are pretty straightforward.

00:26:54 So you have an alternate Lambda syntax.

00:26:57 Yes.

00:26:58 Give us a sense of what that is.

00:26:59 And also, why did you create that?

00:27:01 It's not that different.

00:27:02 No.

00:27:03 So the alternate Lambda syntax is just an arrow.

00:27:05 It's the hyphen and then the greater than sign, which is already used in Python 3, for example, for the return type annotations.

00:27:14 But the basic idea and operator of these, because another programming language is you use Lambdas a lot in functional programming.

00:27:22 And the word Lambda is somewhat ungainly.

00:27:25 You don't really want to have to write it everywhere.

00:27:28 Of course, you still can in Coconut because it's a strict superset of Python 3.

00:27:31 But it gives you this new syntax that lets you work with it more nicely and make it easier to read.

00:27:37 Again, another one of the more syntactic sugary features.

00:27:40 Coconut does have a lot of nice sugar to play with.

00:27:43 Yeah, and there are some special cases where there's like super short versions of these Lambda expressions where they basically expand out in the arguments, right?

00:27:54 Like X comma Y.

00:27:55 Do like star.

00:27:57 Star in parentheses.

00:27:58 And then it'll like do like an expanding multiplication or something like that, right?

00:28:03 Yeah.

00:28:03 I think you're referring to a couple of different things.

00:28:05 It's the sort of star in parentheses.

00:28:06 That's a syntax that is somewhat borrowed from Haskell.

00:28:10 But you can get an operator function, which in Python you would have to do normally via import operator and then like operator.add or something.

00:28:17 You just put the operator in parentheses, which is another nice syntactic sugary thing.

00:28:22 As well as you can then like compose that with other functions via function composition operator.

00:28:29 Partially apply that via coconut's partial application operator.

00:28:33 And so you can work with these operator functions, work with the built-in functions to build up sort of more complex composite functions out of those in a very functional manner.

00:28:45 Yeah, that's really cool.

00:28:46 All right, let's dig into some of the things that are like farther out there, let's say.

00:28:51 Let's start with algebraic data types.

00:28:54 Those seem pretty easy to describe on air.

00:28:58 All right, I'll give it a shot.

00:28:59 So algebraic data types are fundamentally, first of all, immutable.

00:29:04 And so that means that they've just got, they're sort of like classes, but they've just got that one constructor at the very beginning.

00:29:11 You pass in the data that's going to be inside of it.

00:29:13 And then it's done.

00:29:15 You have a new data type.

00:29:17 Sort of like a tuple.

00:29:19 Yeah, to me it looks like you take the class word and you change it to data.

00:29:22 And then it has a sort of convention for the initialization because it can't be changed once it's initialized, right?

00:29:29 Yep, yep.

00:29:30 You change class to data and then you put the arguments to the constructor effectively, the different things that will be inside of it as instead of the like inheritance right there in the syntax.

00:29:40 But then there's a lot of things that are more complex, more beyond just the fact that, okay, it's an immutable data type and it's got this syntax.

00:29:47 Some of the things that are really cool that you can do with algebraic data types are, first of all, is pattern matching.

00:29:52 You can pattern match against an algebraic data type because you can say in the pattern, like, for example, let's say I have a two vector that I have defined as an algebraic data type.

00:30:03 And then I want to write a function that just gives me that first element.

00:30:07 If it's a two vector and it's got an x position and a y position.

00:30:10 And I can pattern match and I can say, like, two vector of x comma y in my function definitions.

00:30:17 Like, f of def, like, def f of two vector of x comma y.

00:30:22 And then it'll actually match any incoming data that is this two vector, decompose it into the components based on that pattern.

00:30:31 Say, okay, this value matches the pattern.

00:30:34 And I know from the pattern I see that there's this x and this y and I need to bind to the argument, the values inside of the algebraic data type.

00:30:44 And it deconstructs it into its component parts in the pattern.

00:30:48 And then you can take out and work with those components.

00:30:51 So the pattern matching component of algebraic data types is really powerful, really useful stuff.

00:30:56 There's some other cool stuff you can do with algebraic data types, too.

00:31:00 Coconut provides an fmap function that lets you map over the contents inside the algebraic data type to produce a new algebraic data type.

00:31:07 And there's a bunch of other stuff as well along those lines that you can do with algebraic data types that are more powerful than just, okay, it's immutable.

00:31:14 But it is immutable.

00:31:15 And that is important.

00:31:16 Right.

00:31:17 And do you use something like slots or something internally and properties to say there's a property with the name of the thing you added, but in fact, it's like a hidden field?

00:31:27 How do you make it immutable?

00:31:29 Internally, slots and named tuple are very sort of heavily relied upon.

00:31:35 There's some other magic that has to go on sometimes.

00:31:40 If you are somewhat creative with the way you define the constructor, like if you use a star, for example.

00:31:49 But in general, yeah, it uses named tuple and slots pretty heavily behind the scenes.

00:31:53 Yeah, interesting.

00:31:54 Maybe tell people what slots are.

00:31:56 I know some people know, but not everybody.

00:31:58 And it's kind of an under-advertised feature of classes in Python.

00:32:03 Not that you should use it often, but maybe you should know about it, right?

00:32:06 Happily, yeah.

00:32:07 So slots, specifically, it's dunder slots.

00:32:11 It's a very useful attribute that you can set on any class.

00:32:14 And when you set dunder slots to be some container, like I set dunder slots to be a tuple of some strings, then each of those strings, those become the only valid attributes for that class from that point.

00:32:28 So they're the only instance attributes that you can have.

00:32:31 And so for every instance that you make of that class, only the things in dunder slots are allowed to be changed, modified, reassigned, added to it.

00:32:40 Even in dunder init, in your own class, you can't add another thing if it isn't pre-specified in slots.

00:32:45 So that's a good way to get a lot of constraints for immutability.

00:32:50 There's also some interesting memory performance trade-offs that you get with that as well.

00:32:55 But let's not get sidetracked.

00:32:57 You talked about algebraic data types and how they support pattern matching.

00:33:03 Let's talk about pattern matching.

00:33:04 There's like a couple ways which you have this concept, which honestly I've never really done much with.

00:33:12 I know scheme, but that's about it for functional languages.

00:33:15 So tell us what pattern matching is and like how it works.

00:33:20 Yeah, so I sort of introduced this a little bit when I was talking about pattern matching against algebraic data type.

00:33:26 But in its general form, pattern matching says, I have a specific type of data that I'm interested in working on in this function.

00:33:34 So I want to maybe define a function specifically for dictionaries that have the form where one of the keys corresponds to a list of these parts.

00:33:45 And that's pretty common where you have functions that operate on specific types of data.

00:33:49 And pattern matching lets you define the specific type of data that you want the function to operate on.

00:33:55 And then it lets you deconstruct the parts of that match that you actually want to use in the body of that function.

00:34:03 It gives you bindings to them.

00:34:05 And then it also lets you, in Coconut you can use addPattern for this, lets you dispatch to multiple functions based on which patterns match.

00:34:13 So you can say, for this type of data that matches this pattern, I want to do this thing.

00:34:18 But for this other type of data that matches this pattern, I want to do this thing instead.

00:34:22 So pattern matching is a way to both check against your data as well as deconstruct it and make assignments to it.

00:34:30 Yeah, one of the things I like in the function part of it, not necessarily the sort of error handling or case matching component,

00:34:39 is what might have been one big function with many if statements now becomes separate functions, one for each particular case, right?

00:34:50 So if you have an example with a factorial and you say, literally the syntax is def factorial of zero equals one.

00:34:57 What the heck does that mean?

00:34:59 Yes, so that is valid, Coconut.

00:35:01 So what's happening there is you are defining a factorial function and you are saying the argument is the pattern zero.

00:35:09 Zero is a valid pattern and it means it matches only the very specific data that is the number zero.

00:35:16 And then the equals, that's just a little bit of syntactic sugar or an implicit return.

00:35:21 And so the last expression after an equals in a function definition is automatically returned.

00:35:27 Yeah, it doesn't have to be static, right?

00:35:29 It can be computed?

00:35:30 Yeah, it's just whatever the last expression is that gets returned.

00:35:34 Okay, cool.

00:35:35 Cool.

00:35:35 And then you have this add pattern decorator.

00:35:38 And you can take and create another function called factorial.

00:35:42 And instead of having like n for the number being passed in, you have n is int if n is greater than zero.

00:35:50 All right, tell us what this does.

00:35:52 Okay, yeah.

00:35:53 So also valid Coconut.

00:35:54 So what's going on there is you have a little slightly complex pattern.

00:36:00 But that's still what that is, that f is int if n greater than zero.

00:36:04 That's another pattern.

00:36:05 And that's doing a couple of things.

00:36:06 It's first n is int.

00:36:08 That's a type check.

00:36:10 That says I only want to match n if it's an integer.

00:36:14 And then the if n greater than zero, that's a guard.

00:36:17 And that says if my pattern matches, perform this extra check to make sure that it is greater than zero before going in it.

00:36:25 And say that the pattern doesn't match if that extra check at the end fails.

00:36:29 Yeah, that's really cool.

00:36:30 So basically the way you implement the factorial is you've got this one more complicated one that we just talked about.

00:36:37 And it just more or less calls itself, right?

00:36:40 And over and over with one fewer values in there.

00:36:45 And then eventually that pattern doesn't match.

00:36:48 It falls back to the one that returns one.

00:36:49 And that's like the degenerative case of the recursion.

00:36:52 And boom, you're done, right?

00:36:54 But there's no if statements.

00:36:55 You've written factorial with no if statements recursively.

00:36:59 Yep, that's exactly correct.

00:37:00 You know, that's actually, that reminds me of being confused in college.

00:37:04 I remember I'd kind of played around with languages like C++ and stuff.

00:37:10 And then I took the scheme course, a derivative of the list.

00:37:14 And there were a lot of things that were like, okay, we're going to implement this with no if statements.

00:37:22 Or, you know, the scheme itself doesn't even have like a looping construct in the language.

00:37:30 There's no loops.

00:37:31 So loops are actually done with recursion and these sorts of crazy things, right?

00:37:35 And I just remember, wait, do this with no if statements?

00:37:38 That's just kind of crazy, man.

00:37:40 That can't work, can it?

00:37:41 Right.

00:37:42 Well, so as a functional programming guy, that doesn't worry me as much.

00:37:46 Though it doesn't have to, even if it does worry you, that's not a problem in Coconut.

00:37:49 Because you've still got your loops there.

00:37:51 You've still got your if statements there.

00:37:53 But you get to use all of these other very powerful features that sort of can in some ways replace a lot of that as well.

00:38:02 And so it's, I hope, more friendly than trying to jump headfirst at the scheme.

00:38:08 Yeah, you know, it wasn't that it worried me so much as it just kind of blew my mind.

00:38:13 Like, I didn't think of programming.

00:38:15 Like, I had this one view of programming, which was very imperative.

00:38:19 And, you know, looping and ifs and whatnot and conditionals.

00:38:23 And then they're just like, no, there's this completely different way of writing code.

00:38:27 And I think that's one of the values of even if you don't ever want to use Coconut, I would encourage people to go through the tutorial.

00:38:34 Because it's quite involved.

00:38:36 And you really do.

00:38:37 You do get to think or, let's say, challenge your own paradigms of programming, right?

00:38:43 Yes, definitely.

00:38:44 If you functional programming really is a new, interesting, powerful paradigm.

00:38:49 That, if you haven't seen it before, really is nothing like what exists in a lot of other programming.

00:38:56 Yeah, I feel like functional programming is one of those languages that you read more and you write less.

00:39:01 And by that I mean you look at it and you go, okay.

00:39:05 I know it's two lines, but they're very deep.

00:39:08 I'm going to have to contemplate them for a little bit, right?

00:39:10 Do you find that?

00:39:12 Yeah, it's definitely true where it's like you can be very succinct and to the point in functional programming.

00:39:18 Because, like, you know, in the factorial example, it lets you define a lot of the logic without being as, without having to go through the motions of how you would actually implement it.

00:39:28 It lets you just say, factorial of zero is one, you figure out how to actually check to see if the value is zero and then return the right thing.

00:39:37 I'm going to tell you what you need to know, the most basic information, which is zero should map to one, and you can take care of the rest.

00:39:45 And that's sort of how functional programming works in a lot of different cases.

00:39:49 And it's that nature of it that is one of the things that makes it so powerful.

00:39:53 This portion of Talk Python To Me is brought to you by Hired.

00:39:57 Hired is the platform for top Python developer jobs.

00:40:00 Create your profile and instantly get access to thousands of companies who will compete to work with you.

00:40:05 Take it from one of Hired's users who recently got a job and said, I had my first offer within four days and I ended up getting eight offers in total.

00:40:13 I've worked with recruiters in the past, but they were pretty hit and miss.

00:40:16 I tried LinkedIn, but I found Hired to be the best.

00:40:19 I really like knowing the salary up front and privacy was also a huge seller for me.

00:40:23 Well, that sounds pretty awesome, doesn't it?

00:40:25 But wait until you hear about the signing bonus.

00:40:27 Everyone who accepts a job from Hired gets a $300 signing bonus.

00:40:30 And as Talk Python listeners, it gets even sweeter.

00:40:33 Use the link talkpython.fm/hired and Hired will double the signing bonus to $600.

00:40:39 Opportunity is knocking.

00:40:41 Visit talkpython.fm/hired and answer the door.

00:40:45 So let's talk about some of the other features.

00:40:47 Another one, if you haven't done a lot of functional programming, you're probably not familiar with it.

00:40:53 But one of the problems you can have with recursion is the call stack only has so much space on it, right?

00:41:00 If you need to do what would effectively be many, many, many loops or very, very deep recursion, you can end up with an error, right?

00:41:09 So you have a special way to solve this really cleanly.

00:41:12 And I'm not sure I totally understand how you determine how to solve this.

00:41:16 You have to tell me.

00:41:16 All right.

00:41:18 Tell me about your tail call optimization that you do.

00:41:21 I'll go for it.

00:41:22 Yeah.

00:41:22 So in Python, that manifests via maximum recursion depth exceeded error.

00:41:27 And what happens is every time Python sees a function call, it effectively creates a new stack frame.

00:41:34 It says, you know, pops all the existing or pushes all the existing variables onto the stack and then enters this new frame with all of these new variables.

00:41:43 And it does that execution.

00:41:44 But what that means is that every time you call a new function, you're building up more memory, you're building up more function calls, and it can get very intensive doing that a lot.

00:41:53 And so what Coconut does is it actually looks at every single function you write, and it says at any point, if you directly return a call to another function,

00:42:04 then we don't actually need to keep around the stack frame that corresponds to your current function call.

00:42:11 Because all of the data that is necessary to figure out what the return statement, what the actual return value of that function is going to be,

00:42:19 is all contained just in this other function call.

00:42:22 Because you've directly returned that function call.

00:42:25 And so whenever Coconut sees something of that form, it automatically optimizes it away to get rid of the necessity of, like, making, adding this new stack frame.

00:42:36 There's actually two ways in which Coconut does that for two different cases.

00:42:40 The most extreme, most powerful case is Taylor-Cursion elimination.

00:42:43 If you write a function that returns a call to itself, then you can refactor that into a wall loop, which is really nice and very fast.

00:42:52 If it returns a call to another function, that's a little bit slower, but you can still prevent the new stack frame from being created.

00:43:00 But it's a slightly more complex, more involved mechanism.

00:43:05 Yeah, it works really nicely.

00:43:06 And with the pattern matching, with the tail recursion optimization and stuff like that, one thing that I really liked was I was playing with the different versions of your implementation.

00:43:20 And the pure Python, or nearly pure Python version, was slower than the highly Coconut style, the ones that leverages these special features the most.

00:43:35 And so I thought that was pretty cool, actually.

00:43:37 That it's not like, well, you get this better syntax, but you're going to suffer for it.

00:43:42 But who cares?

00:43:43 You don't need that much performance anyway.

00:43:45 That you actually didn't, at least didn't pay a price for using it, but it seems like it actually might even be less of a price than not.

00:43:51 Yeah.

00:43:52 So in most cases, Coconut's performance is going to be very similar to Python's because, of course, it compiles to Python.

00:43:58 But yeah, in some cases, Coconut really can perform optimizations that will save you.

00:44:04 One of the biggest of those optimizations is the tail recursion elimination, tail call optimization, where it'll take a look at every function you write and just see, are you returning a call to another function directly?

00:44:15 Implicitly or explicitly in any way?

00:44:17 And if so, that gets optimized away always.

00:44:20 And that's really nice for adding, like you were saying.

00:44:24 It means that in some cases, Coconut code actually can be significantly faster than the equivalent Python code.

00:44:30 In most cases, at the very least, it's usually not slower just because it really is Python.

00:44:36 It just compiles to it.

00:44:37 Yeah, that's really cool.

00:44:38 And you could, of course, write those optimizations yourself because after all this does compile a Python, you could write what the compiler wrote.

00:44:44 But that's a much harder deal, right?

00:44:46 The goal is to have super simple code that is actually optimized.

00:44:50 Yeah, exactly.

00:44:51 The nice thing about the compiler, you can look through the compiled code.

00:44:56 It'll just be a file right there.

00:44:58 But you'll see that a lot of it really does get very complex, very hairy, very, especially with pattern matching.

00:45:05 A lot of it gets really weird and hard to read because pattern matching can get very complex very quickly.

00:45:12 And having a compiler figure out the sort of ways to implement all of that for you is really nice.

00:45:19 Yeah, the way I think of it is people are very bad at writing state machines.

00:45:22 Compilers are really good at it.

00:45:24 Sometimes you end up with stuff like that, right?

00:45:27 So speaking of debugging and trying to understand, like the thing you're going to actually debug when you run a debugger, be that some CLI one or something like PyCharm, you're going to see the transpiled compiled output, right?

00:45:43 So how do I know if that maps back?

00:45:45 Like, where does this map back to this funky syntax that I maybe have in my Cocoa file?

00:45:50 Yeah, so that's an absolutely great question.

00:45:52 Debugging is, of course, a huge, massive part of what every programmer does all the time.

00:45:57 So Coconut has a really clean, simple story for that.

00:46:01 So you can pass the line numbers flag, which is just minus L.

00:46:06 And what that does is it appends to every line in the compiled Python a comment that says, take a look at this line in the source code that produced this line in the compiled code.

00:46:19 Then you do pdb.setTrace, you get an error, and you see the lines that that error is referring to, and you'll see on those lines comments that are telling you what line in your source code caused that exception.

00:46:33 What line in your source code are you tracing through?

00:46:36 All of that stuff you can see, and you can just look at that line number, you can go right back to the source code without having to really worry about and deal with the compiled code at all.

00:46:46 So that way, when you're debugging, you don't have to do any context switching.

00:46:49 There's also another option, the keep lines option, which actually, instead of a line number, will just put the entirety of the line, and it'll just paste it right in there for you as well.

00:47:00 So that's another option.

00:47:01 Yeah, those are both pretty good stories.

00:47:02 That's cool.

00:47:03 So what about parallelization primitives?

00:47:06 Coconut tries to make parallelization as easy as possible because you can have all of these nice immutable data structures, and ideally, you want to be able to use them in a nice way.

00:47:16 Of course, in CPython, at least, Python fights back against you a little bit there.

00:47:20 You've got the global interpreter lock.

00:47:21 But what you can do, what Coconut provides, is two primitives.

00:47:26 There's a parallel map and a concurrent map, which are multi-processed and multi-threaded, respectively, which take the most basic of the functional programmer's operations, and the one that is most easily parallelizable, the map operation, which just says apply this same thing, the same function, to every element.

00:47:45 of this sequence, this data.

00:47:48 And it allows you to really, really easily do that operation automatically in multiple processes or in multiple threads if you're doing I/O bound stuff such that you don't have to mess with any fancy libraries.

00:48:00 You don't have to mess with anything fancy whatsoever.

00:48:02 You just swap out wherever you're doing the map operation, that really parallelizable operation with the parallel version, and you're automatically getting all of the benefits of running that in parallel.

00:48:12 And, of course, behind the scenes, it's using multi-processing and it's pickling everything.

00:48:16 But yeah, that's really cool.

00:48:17 So basically, it's still a blocking function as far as your code is concerned.

00:48:21 But the internal representation, maybe it changes the order in which it processes them and it just fans it out.

00:48:28 Right.

00:48:28 All right.

00:48:29 Awesome.

00:48:30 And then one final feature we should talk about maybe is partial application.

00:48:35 Is this your dollar operator?

00:48:38 Yes, but the dollar operator is a little bit more than that.

00:48:41 So the dollar operator in Python in Coconut just means lazify this.

00:48:45 It means take this operation in Python and make it lazy instead of doing the Python thing.

00:48:52 And so that means different things in different contexts.

00:48:54 But there are sort of two.

00:48:55 There are two contexts where it's used.

00:48:57 So the big one.

00:48:58 Yeah, you put it right before a function call.

00:48:59 And that means instead of actually doing this function call, I want you to do it lazily.

00:49:03 And don't do it until I actually tell you I want it.

00:49:06 And so that is partial application.

00:49:08 That says, here are the arguments that I'm going to pass to this function when I actually call it.

00:49:12 But I might pass more arguments in later.

00:49:15 And so for right now, you can just throw these arguments in and hold them there.

00:49:18 And that's that partial application.

00:49:19 The other usage of the dollar sign is for indexing, slicing with brackets.

00:49:25 And in that case, it's a lazy form of that as well that doesn't actually perform the operation.

00:49:31 And until you ask for the data, like an iterator, and lets you do it on arbitrary iterators.

00:49:37 And so you can, for example, slice, do sort of complex slicing operations on iterators instead of just on lists or tuples, which lets you make use of the laziness of iterators in a much more effective way.

00:49:51 Yeah, that sounds really pretty awesome.

00:49:53 You definitely have some cool uses and examples in your tutorial.

00:49:58 So one of the things that you talked about in the tutorial is the integration or the capability to use Jupyter or IPython notebooks.

00:50:08 And so when I was playing your project, I'm like, oh, I was just at PyCon.

00:50:13 I just saw Jake Vander Plaats' really cool science-y keynote and got me excited about Jupyter.

00:50:20 And I've, of course, played with it before, but, you know, not a lot.

00:50:23 And I'm like, oh, I'll just explore your library through Jupyter.

00:50:26 And that was really fun.

00:50:27 So you have pretty good support for that, right?

00:50:28 Yep. So Coconut has support for Jupyter through both a kernel, which means instead of running your code through IPython, you just select Coconut instead.

00:50:40 And it works exactly like IPython, including, and this is actually somewhat of a new feature, including support for things like IPython magics and all of the sort of nice, fancy stuff that IPython throws in there.

00:50:53 And then sort of on top of that, you have support for all of the Coconut utilities, all the Coconut language features as well.

00:51:03 And so it's basically just like an IPython notebook, but instead of writing Python, you're writing Coconut.

00:51:07 If you only want to do a little bit of Coconut, you can also use Coconut as an extension inside of IPython.

00:51:13 And then it'll just take all of Coconut's built-ins, give you access to those.

00:51:18 And whenever you want to use Coconut-specific syntax, then you just do the align or block magic specifically just to run the Coconut code.

00:51:25 That looks really cool.

00:51:26 And of course, data science type of work is a place where functional programming would really be applicable, right?

00:51:35 Absolutely, yeah.

00:51:37 The stuff that people do in data science and machine learning, it really does apply to the functional paradigm really well.

00:51:45 Because a lot of that stuff is, first of all, it's data transformation.

00:51:49 Instead of like a lot of the very heavily stateful stuff that happens in other areas of programming,

00:51:55 a lot of that stuff, I would argue, still can benefit from a lot of the features of functional programming.

00:51:59 When you're doing something that really is fundamentally, it's just got the one data that you're passing along.

00:52:04 I've got, this is the data that I collected.

00:52:06 I want to do some statistical transformations on it.

00:52:09 I want to get insight into what it's like.

00:52:11 What you're doing is you're passing it through transformations at each point where the functions themselves are sort of stateless transformations.

00:52:18 And that is exactly the paradigm, exactly the approach that functional programming is built for.

00:52:25 So it really does lend itself well to being able to make use of a lot of these constructs from functional programming.

00:52:33 Especially like easily parallelization, if you just want a down and dirty, really easy way to just like process this data faster.

00:52:41 And a lot of the coconuts, very powerful utilities for working with iterators so that you can construct your data and work with it in a lazy, lazy fashion.

00:52:51 So you only have to deal with what you really need.

00:52:52 Right.

00:52:53 When you have billions of rows, but you only want to find a few of them.

00:52:56 Lazy is good.

00:52:57 Yes, exactly.

00:52:58 Another area it sounds like this might be really helpful is in finance.

00:53:01 I feel like that functional programming gets applied in that area a lot as well.

00:53:06 Yeah, OCaml is really big there, for example.

00:53:09 And so that's totally true.

00:53:11 It's another area where you really want to be able to do a lot of the transformations on the data to be able to see what's happening.

00:53:20 As well as one of the nice things about using immutable data structures is you can always really easily just take a snapshot.

00:53:25 You're just like, okay, give me whatever the immutable data structure was at that point.

00:53:30 And you know once you have a reference to it, it's never going to change.

00:53:33 And so it's very easy to, like if you're doing finance, you want to see, like, okay, what was it like at this point?

00:53:39 You can really easily just store references to immutable data structures because you know once you've got a reference to it, it'll never change.

00:53:44 That's really interesting.

00:53:45 Yeah, that's cool.

00:53:46 Yeah, so that's another feature that is really useful, particularly in finance.

00:53:49 Where else do you see functional programming really, people benefiting from adopting it?

00:53:54 I'm a believer in functional programming being very broadly applicable in almost all cases.

00:54:00 Like, you know, I said I worked at Yelp.

00:54:02 And while I was there, one of the things that I did in my spare time was I, you know, went through some of the code base and tried to rewrite some of the things in Coconut to try to get it working.

00:54:11 And even in, like, like a web application, even in something that doesn't seem functional at all, a lot of those constructs, just making, being able to make use of them gives you a lot more power and being able to define the logic in a simpler, easier manner that I think is really basically always applicable.

00:54:31 Yeah, awesome.

00:54:33 If I go to PyPI and randomly grab a package, could I use it in a Coconut app?

00:54:39 Like, are there restrictions where this doesn't work?

00:54:41 Yes, absolutely.

00:54:42 In fact, you could use it regardless of whether that package was built for Python 2 or Python 3, because Coconut, of course, can compile to code that works on either version.

00:54:51 But yeah, because Coconut compiles just to Python, anything that you would be able to access, anything you would be able to do from Python, you can do from Coconut.

00:55:00 So that includes importing any package that you want to import.

00:55:03 Also, the vice versa is true as well.

00:55:05 If you want to, from Python code, import and make use of anything written in Coconut code, that is also really easy to do, you should, because the Coconut code ends up as Python code.

00:55:17 And so it's really easy to import that as well.

00:55:18 You basically ship the compiled Python files as the deliverable, right?

00:55:22 Very cool.

00:55:23 I think we're getting close to the end of the show, so we should probably start to wrap it up.

00:55:28 I'm going to ask you about your favorite editor.

00:55:30 But before we do, let me ask you an editor question about Coconut.

00:55:33 So one of the things that I really like about editors is when they remind me what features are on a class or in a module and tell me what I have it right or wrong or give me auto-completion and things like that.

00:55:47 Like, do I give that up if I take on Coconut?

00:55:50 So that's a good question.

00:55:51 So the answer is we're working on it.

00:55:53 So right now, you can.

00:55:55 There is one method that I have tested that does work with that.

00:55:58 If you use Jupyter console, I know, and I think the notebook as well, you can get the Coconut's Jupyter or IPython kernel to do some auto-completions for you.

00:56:09 I think, as far as I'm aware, that's the only one we've got so far.

00:56:14 But I'm working on it.

00:56:15 That's definitely, you know, there's other people that's working on it as well.

00:56:18 That's definitely something that should be coming out in a more broader way pretty soon.

00:56:24 I'm going to try to add it into Coconut's just basic command line interpreter as well.

00:56:29 Yeah, it would be great.

00:56:31 I mean, it's already really cool.

00:56:33 But it would be even more cool if it could help us along the way, right?

00:56:37 If you could get into Sublime, VS Code, PyCharm, those sorts of things, right?

00:56:43 Yep.

00:56:43 Definitely a cool feature.

00:56:44 Being worked on for right now, try using the Jupyter IPython.

00:56:49 Nice.

00:56:50 Okay.

00:56:50 And so then let me ask you, if you're going to write some Coconut or Python code, what editor do you open up?

00:56:57 So I use Sublime.

00:56:58 I'm a Sublime fanatic.

00:57:00 I love Sublime.

00:57:01 I use Sublime for everything.

00:57:03 I write my school notes in Sublime.

00:57:05 There are now a bunch of highlighters for Coconut, but the Sublime one, that was the one that I wrote.

00:57:10 That was the sort of first one to be made.

00:57:13 I'm the one that maintains that.

00:57:14 I, of course, use that whenever I write Coconut code.

00:57:17 So yeah, I love Sublime.

00:57:19 That's definitely my editor of choice.

00:57:21 Nice.

00:57:21 And so there's also many, many, many PyPI packages, over 100,000 now, which is totally awesome.

00:57:29 And let me go ahead and throw out Coconut as one of the really cool packages there.

00:57:33 But maybe give us another one.

00:57:35 Yeah, yeah.

00:57:36 As you were saying, pip install Coconut.

00:57:38 But yeah, so my favorite PyPI package would definitely be PyParsing.

00:57:42 So PyParsing is awesome.

00:57:44 It's a really cool utility for being able to define very simple grammars and really complex grammars as well,

00:57:52 just in pure Python and then parse against them.

00:57:55 Coconut's compiler is pretty much entirely written in PyParsing.

00:58:00 So you can tell that I really like it.

00:58:02 It's really powerful.

00:58:03 It works really well.

00:58:04 Coconut pushes PyParsing almost to its limits in a lot of cases, where it's the point where I had to, you know, submit a bunch of issues in the development of Coconut to PyParsing.

00:58:13 But all of that's been fixed.

00:58:15 The newest version of PyParsing is awesome.

00:58:17 It works really well.

00:58:18 Would definitely recommend checking out PyParsing.

00:58:21 I actually used it for another project while I was at Yelp, which allows you to automatically refactor code by defining PyParsing patterns.

00:58:31 Yeah, it looks for like code debt and duplication type things, something like that.

00:58:35 Yep, exactly.

00:58:36 It lets you define patterns using PyParsing grammars, as well as a bunch of sort of other Undeat specific stuff.

00:58:43 And then you can define a like replacement function, and it'll scan for the grammar and then replace it with that.

00:58:50 And so you can use that to really easily refactor code.

00:58:52 Cool.

00:58:53 Yeah, that's a great recommendation.

00:58:53 And I think it's really neat that your work actually expanded PyParsing a little bit.

00:59:00 But also its existence made your work pretty much possible, right?

00:59:04 Yeah, it's a symbiotic relationship.

00:59:06 It definitely is.

00:59:07 Definitely it is.

00:59:08 Okay.

00:59:09 So this brings us to the end of the show.

00:59:12 You know, final call to action.

00:59:14 You have quite a few people who've starred this and are playing with it on GitHub.

00:59:18 Are you looking for people to kick the tires, to contribute?

00:59:22 What's the story?

00:59:23 So yeah, so Coconut is built on GitHub.

00:59:26 Everything's on GitHub.

00:59:27 Definitely, definitely check out the GitHub.

00:59:29 Start on GitHub for sure.

00:59:31 I would definitely recommend trying to at least take a look.

00:59:34 Go through the tutorial.

00:59:36 Take a look at the documentation.

00:59:37 Take a look and see if, you know, maybe this is something that you could really make use of.

00:59:42 I, of course, think it's really cool and that people can really benefit from it.

00:59:47 And if you have any questions, if you want to look around, there's a lot of resources for that.

00:59:52 You can check out Coconut's Gitter, which is a chat room where you can just ask questions.

00:59:57 And then there's a bunch of Coconut developers there, including me, that can just answer questions, check that regularly.

01:00:04 You can also check out all of the sort of documentation resources.

01:00:08 There's a frequently asked questions, the thorough documentation for all of the specification on the features and the tutorial to sort of give you basic introduction.

01:00:17 And then, of course, if you are interested in contributing to Coconut, I would love to have more people get involved, more people take a look.

01:00:25 It's all open source.

01:00:27 Just take a look at the issues, fork it, make changes, submit a pull request.

01:00:32 If you want to ask any questions about it, if you're trying to get started, definitely goes back to the Gitter.

01:00:37 Just ask around on Gitter and I'd be happy to help anybody out there.

01:00:42 So, yeah.

01:00:42 Yeah, yeah, awesome.

01:00:43 And if people are thinking of contributing, like, what kind of crazy language do they have to learn to, like, work with this?

01:00:49 Like, what's it implemented in?

01:00:50 Python!

01:00:51 Yeah, that's awesome.

01:00:53 I noticed in the GitHub is to be believed, you know, click that little bar and I'll tell you the languages used.

01:00:58 It's 99.7% Python and 0.3% makefile or something like that.

01:01:05 Yes, there is one makefile.

01:01:07 So, I hope you don't shy away too much from having to deal with that.

01:01:11 But, yeah, no, it's all Python.

01:01:13 Coconut, the compiler, just like the compiled source, is written in Python that is intended to be universal.

01:01:19 So, it works on 2.6, 2.7, 3.2 and above.

01:01:22 But, yeah, it's just all just Python, pure Python.

01:01:24 All right.

01:01:25 Well, this is definitely an interesting project you have going and I'm happy to see it succeeding.

01:01:29 And thanks for sharing it with everyone.

01:01:31 Absolutely.

01:01:31 Thank you so much for having me.

01:01:33 It was really fun to be here.

01:01:36 This has been another episode of Talk Python To Me.

01:01:39 Today's guest was Evan Hubinger.

01:01:41 And this episode has been brought to you by Rollbar and Hired.

01:01:45 Rollbar takes the pain out of errors.

01:01:48 They give you the context and insight you need to quickly locate and fix errors that might have gone unnoticed until your users complain, of course.

01:01:56 As Talk Python To Me listeners, track a ridiculous number of errors for free at rollbar.com slash Talk Python To Me.

01:02:03 Hired wants to help you find your next big thing.

01:02:06 Visit talkpython.fm/Hired to get five or more offers with salary and equity presented right up front and a special listener signing bonus of $600.

01:02:15 Are you or your colleagues trying to learn Python?

01:02:18 Well, be sure to visit training.talkpython.fm.

01:02:21 We now have year-long course bundles and a couple of new classes released just this week.

01:02:27 Have a look around.

01:02:28 I'm sure you'll find a class you'll enjoy.

01:02:29 Be sure to subscribe to the show.

01:02:32 Open your favorite podcatcher and search for Python.

01:02:34 We should be right at the top.

01:02:35 You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

01:02:45 Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

01:02:50 Corey just recently started selling his tracks on iTunes, so I recommend you check it out at talkpython.fm/music.

01:02:56 You can browse his tracks he has for sale on iTunes and listen to the full-length version of the theme song.

01:03:02 This is your host, Michael Kennedy.

01:03:04 Thanks so much for listening.

01:03:05 I really appreciate it.

01:03:06 Smix, let's get out of here.

01:03:08 Smix, let's get out of here.

01:03:08 Stay tuned.

01:03:10 I'll see you next time.

01:03:15 Bye.

01:03:16 I'll pass the mic back to who rocked his best.

01:03:18 I'll pass the mic back to who rocked his best.

01:03:18 I'll pass the mic back to who rocked his best.

01:03:30 Bye.

