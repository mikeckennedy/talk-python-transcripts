WEBVTT

00:00:00.140 --> 00:00:03.600
Containers are revolutionizing the way that we develop and manage applications.

00:00:03.600 --> 00:00:08.440
These containers allow us to build, develop, test, and even deploy on the exact same system.

00:00:08.440 --> 00:00:12.220
We can build layered systems that fill in our dependencies.

00:00:12.220 --> 00:00:16.340
They even can play a crucial role in zero downtime upgrades.

00:00:16.340 --> 00:00:20.220
This is great until you end up with five different types of containers,

00:00:20.220 --> 00:00:23.500
each of them scaled out, and you need to get them to work together,

00:00:23.500 --> 00:00:25.440
discover each other, and upgrade together.

00:00:25.440 --> 00:00:27.160
That's where Kubernetes comes in.

00:00:27.160 --> 00:00:31.680
Today, we'll meet Kelsey Hightower, a developer advocate on Google's cloud platform.

00:00:31.680 --> 00:00:36.760
This is Talk Python to Me, episode 126, recorded June 9, 2017.

00:00:54.320 --> 00:01:07.760
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:01:07.760 --> 00:01:11.900
This is your host, Michael Kennedy. Follow me on Twitter, where I'm @mkennedy.

00:01:11.900 --> 00:01:18.360
Keep up with the show and listen to past episodes at talkpython.fm, and follow the show on Twitter via at Talk Python.

00:01:18.980 --> 00:01:22.960
This episode is brought to you by Rollbar and us at Talk Python Training.

00:01:22.960 --> 00:01:25.080
Be sure to check out what we're offering during our segments.

00:01:25.080 --> 00:01:26.480
It really helps support the show.

00:01:26.480 --> 00:01:30.040
Hey, everyone. Just a quick heads up on this episode.

00:01:30.040 --> 00:01:36.240
I recorded it on site, on location, with Kelsey Hightower, which is a great experience, cool opportunity,

00:01:36.240 --> 00:01:42.140
but it turns out the audio was a little echoey and not the same as back in the studio where I normally record.

00:01:42.140 --> 00:01:44.560
So you'll have to forgive a bit of an echo on this one.

00:01:44.560 --> 00:01:46.940
It's a great conversation, and I hope you learn a lot from Kelsey.

00:01:47.060 --> 00:01:48.440
Now, let's chat with him.

00:01:48.440 --> 00:01:50.860
Kelsey, welcome to Talk Python.

00:01:50.860 --> 00:01:52.440
Awesome. It's awesome to be here.

00:01:52.440 --> 00:01:54.660
Fantastic show. So I'm honored to be a guest.

00:01:54.660 --> 00:01:56.860
Thanks. It's an honor to have you as a guest.

00:01:56.860 --> 00:02:00.740
You had such a cool keynote at PyCon. It was really fun.

00:02:00.740 --> 00:02:02.280
Yeah, I was honored to do that one.

00:02:02.280 --> 00:02:04.720
That was my, I think, completing the mission.

00:02:04.720 --> 00:02:07.020
You know, Python meetup is where I first started,

00:02:07.020 --> 00:02:12.060
and then having the honor to do a closing keynote at PyCon 2017 was amazing.

00:02:12.060 --> 00:02:14.900
You've completed the circle of your Python journey?

00:02:15.120 --> 00:02:18.140
Yeah, I think so. I think you just think about what just over the years,

00:02:18.140 --> 00:02:22.960
it was probably maybe six or seven years in between my very first talk and giving that Python keynote.

00:02:22.960 --> 00:02:26.400
So a lot has changed for me personally during that time frame.

00:02:26.400 --> 00:02:27.940
Yeah, I'm sure it has.

00:02:27.940 --> 00:02:31.760
So I totally want to talk about PyCon, but let's start with your story.

00:02:31.760 --> 00:02:33.140
How did you get into programming in Python?

00:02:33.520 --> 00:02:37.800
I think, like most people, you know, I was looking for my first real programming language.

00:02:37.800 --> 00:02:40.040
So I started with Bash as a system administrator.

00:02:40.040 --> 00:02:43.980
And you kind of run into some limitations with Bash, you know, things you can and can't do.

00:02:43.980 --> 00:02:46.000
So I reached for things like Python.

00:02:46.000 --> 00:02:51.660
So I was working in the financial industry, and I just needed a tool that could actually replace some of our COBOL jobs.

00:02:51.660 --> 00:02:52.140
Okay.

00:02:52.200 --> 00:02:55.480
So we had these old things that like transform data for the mainframe.

00:02:55.480 --> 00:02:58.060
Can you believe that stuff still runs?

00:02:58.060 --> 00:02:58.580
Oh, yeah.

00:02:58.580 --> 00:02:59.940
I mean, and fast.

00:02:59.940 --> 00:03:00.540
Yeah.

00:03:00.540 --> 00:03:00.780
Right.

00:03:00.780 --> 00:03:02.400
And people still make a ton of cash on it.

00:03:02.400 --> 00:03:06.720
So my first, you know, dip my toes in the water and I learned PacDecimal, right?

00:03:06.720 --> 00:03:09.740
Because I had to convert a lot of the formats for the mainframe.

00:03:09.940 --> 00:03:12.360
So you're dealing with EPSIDIC, fixed-length formats.

00:03:12.360 --> 00:03:21.080
And then Python was like a really straightforward language, but it also had great libraries to kind of deal with a lot of the math stuff and, you know, things that you would do even in the mainframe world.

00:03:21.080 --> 00:03:21.440
Right.

00:03:21.440 --> 00:03:21.820
Absolutely.

00:03:21.820 --> 00:03:22.460
Okay.

00:03:22.460 --> 00:03:29.560
And so you started out in Python and now, well, started out in Bash, got into Python.

00:03:29.560 --> 00:03:30.960
And now what are you doing?

00:03:30.960 --> 00:03:31.520
Mostly Go?

00:03:31.520 --> 00:03:32.220
Yeah.

00:03:32.220 --> 00:03:34.180
So Golang is kind of my language of choice.

00:03:34.180 --> 00:03:39.880
You know, something happened in the industry where, you know, when I used to think back, most of the tools you were using,

00:03:39.880 --> 00:03:45.400
as a system, I remember written in Python, whether it was like AppGit or Yum or, you know, things like Ansible.

00:03:45.400 --> 00:03:49.960
It was kind of like the system means go-to language, you know, after Perl, there was Python.

00:03:49.960 --> 00:03:56.360
And, you know, something happened where Golang just became like the thing you'd use for like distributed systems and containers.

00:03:56.360 --> 00:03:58.860
So kind of made a switch to that a couple of years back.

00:03:58.860 --> 00:03:59.500
That's cool.

00:03:59.500 --> 00:04:01.960
Because, yeah, you're all about the containers these days, right?

00:04:01.960 --> 00:04:07.920
Yeah, containers, distributed systems, this whole new world where we're like packaging our apps in like this universal format

00:04:07.920 --> 00:04:10.200
and then just giving it to the system to deploy.

00:04:10.200 --> 00:04:12.000
So that's been a pretty interesting journey.

00:04:12.000 --> 00:04:12.860
Yeah, yeah.

00:04:12.860 --> 00:04:13.980
It's very interesting.

00:04:13.980 --> 00:04:16.820
And I think we're just at the beginning of this really, right?

00:04:16.820 --> 00:04:19.940
Yeah, I think a lot of times I think these are patterns we've always been doing.

00:04:19.940 --> 00:04:23.340
If you think about like in the Python world, we were dealing with like virtual nth.

00:04:23.340 --> 00:04:25.720
We were trying to create these self-contained deployments.

00:04:25.720 --> 00:04:27.660
So virtual nth, having pip.

00:04:27.860 --> 00:04:34.140
And when you put those things together, things like Docker is the natural evolution where you say, hey, I create this virtual environment.

00:04:34.140 --> 00:04:36.040
Everything I need is in there and self-contained.

00:04:36.040 --> 00:04:38.640
How about we just package that up and ship that around?

00:04:38.640 --> 00:04:39.400
Right.

00:04:39.400 --> 00:04:48.040
Instead of creating a virtual machine or even a real machine on real hardware, setting it up, setting up a virtual environment, get it all going.

00:04:48.040 --> 00:04:50.720
Now you just have, what, like a Docker file?

00:04:51.160 --> 00:04:58.260
Yeah, and I think the Docker file, if you think about what it looks like, if you've never written one before, it's essentially like an organized bash script in many ways, right?

00:04:58.260 --> 00:05:01.420
There's some semantic meaning to some labels and things you can do in there.

00:05:01.420 --> 00:05:04.420
But for the most part, you're making a repeatable set of steps.

00:05:04.420 --> 00:05:08.560
You know, maybe you install Python or you have a base image where Python's already installed.

00:05:08.560 --> 00:05:13.440
And then within that Docker file, you will say things like pip install my requirements.txt.

00:05:13.440 --> 00:05:17.000
And then when you're finished, you can just say, here's how you start my app.

00:05:17.000 --> 00:05:20.600
So it just gives us a repeatable process to what we've already been doing.

00:05:20.600 --> 00:05:21.480
Sure.

00:05:21.480 --> 00:05:27.620
It's like scripting, automating all of the best practices we should be doing, but maybe aren't.

00:05:27.620 --> 00:05:28.700
Yeah, I think so.

00:05:28.700 --> 00:05:33.420
And also, usually on a team, you have like one person who does know how to build an app from scratch, right?

00:05:33.420 --> 00:05:36.800
Usually keep this like build my app type script inside of the directory.

00:05:36.800 --> 00:05:39.040
And a Docker file has become that.

00:05:39.040 --> 00:05:45.840
And it also now produces an artifact so that once you build it once, ideally you can reuse it in multiple environments.

00:05:45.840 --> 00:05:46.120
Right.

00:05:46.120 --> 00:05:46.760
Yeah, that's cool.

00:05:46.760 --> 00:05:50.520
Let's you test closer to production, for example.

00:05:51.140 --> 00:05:54.580
But you definitely don't want to lose that person that knows how to build that thing.

00:05:54.580 --> 00:05:54.900
Oh, yeah.

00:05:54.900 --> 00:05:55.920
We're not replacing people.

00:05:55.920 --> 00:05:58.920
I think what we're doing is also there's a lot of open source projects, right?

00:05:58.920 --> 00:06:02.460
You can imagine going to get like your favorite web app built in like Django, for example.

00:06:02.460 --> 00:06:07.340
And then having to deal with like what version of Python, what dependencies, how to build it.

00:06:07.340 --> 00:06:09.720
Sometimes people just want to play with it right now.

00:06:10.040 --> 00:06:16.440
So an alternative, and this is key because some people are starting to replace their documentation, their scripts with just Docker files.

00:06:16.440 --> 00:06:18.280
And that's infuriating to a lot of people.

00:06:18.280 --> 00:06:27.020
So I think you can complement your installation by saying, hey, here's the raw, you know, maybe if you're still doing eggs or whales for the actual application.

00:06:27.020 --> 00:06:33.360
But an alternative could be, oh, here's a Docker container if you just want to just run it on your Docker machine.

00:06:33.360 --> 00:06:34.560
Yeah, yeah, absolutely.

00:06:34.560 --> 00:06:35.020
Absolutely.

00:06:35.020 --> 00:06:40.380
Let's talk really quickly about PyCon before we dive deep into Kubernetes.

00:06:41.080 --> 00:06:43.960
So you got to go to PyCon and give this presentation.

00:06:43.960 --> 00:06:46.520
That was super amazing.

00:06:46.520 --> 00:06:48.120
What was your favorite thing about the conference?

00:06:48.120 --> 00:06:53.880
Well, I think the thing I like the most about PyCon, most people are there because they want to be right.

00:06:53.880 --> 00:06:56.740
And I think that's a unique thing that we don't see at a lot of tech conferences.

00:06:56.740 --> 00:07:03.700
Either tech conferences could be expensive, so you really need to be reimbursed by your company or you have to take time off work to do it.

00:07:03.700 --> 00:07:07.440
And since PyCon is on the weekend, a lot of people choose to be there.

00:07:07.440 --> 00:07:09.500
Some people, a lot of people pay their own way.

00:07:10.080 --> 00:07:16.200
So just the experience of the, you know, I call it the, I guess kind of the hallway track, right, where you just walk around, you meet new people.

00:07:16.200 --> 00:07:20.940
I met people with the, what do they call it, the holy staff or whatever.

00:07:20.940 --> 00:07:22.800
You know, this thing travels the world.

00:07:22.800 --> 00:07:23.860
Yes, that's right.

00:07:23.860 --> 00:07:24.400
Staff of enlightenment.

00:07:24.400 --> 00:07:25.880
That was Anthony Shaw.

00:07:25.880 --> 00:07:26.920
He brought it from Australia.

00:07:26.920 --> 00:07:32.660
Yeah, so you have people like that walking around PyCon like, hey, we just want to get a picture of you with this staff of enlightenment.

00:07:32.660 --> 00:07:36.140
And you know that there's this organic feel to why people are there.

00:07:36.140 --> 00:07:37.700
It's a deeper community.

00:07:37.820 --> 00:07:40.800
It's like one of these communities that have been around for so long.

00:07:40.800 --> 00:07:43.460
This is a family reunion for most people at PyCon.

00:07:43.460 --> 00:07:44.500
So it just feels different.

00:07:44.500 --> 00:07:45.180
Yeah, yeah.

00:07:45.180 --> 00:07:47.120
I just had Kenneth Wrights on the show.

00:07:47.120 --> 00:07:51.960
He's done a bunch of Python stuff and said, this is my favorite time of the year, right?

00:07:51.960 --> 00:07:53.520
This is actually like the favorite week.

00:07:53.520 --> 00:07:54.900
And so I feel that way as well.

00:07:54.900 --> 00:07:57.320
It's really, really, really amazing.

00:07:57.320 --> 00:07:58.900
We get great keynotes like yours.

00:07:58.940 --> 00:08:02.220
But I really, besides the keynotes, I honestly try to just do the hallway track.

00:08:02.220 --> 00:08:06.720
Like these chances of meeting people who you would not normally get to talk to.

00:08:06.720 --> 00:08:07.800
You just get to stop.

00:08:07.800 --> 00:08:10.820
And then I drop in on YouTube and watch the presentations.

00:08:10.820 --> 00:08:11.140
Yeah.

00:08:11.140 --> 00:08:13.540
And I think the other element, I didn't get to enjoy it this year.

00:08:13.660 --> 00:08:16.840
But my very first real conference was PyCon in Atlanta.

00:08:17.580 --> 00:08:29.520
And the sprints, you know, where you're actually working side by side with, I guess you can call them the big names in Python, the people that are actually doing the hard work, maintaining the packages, maintaining the core.

00:08:29.520 --> 00:08:33.720
And they just make space for you to come in and learn, do your first contribution.

00:08:33.720 --> 00:08:35.380
That was my first contribution to Python.

00:08:35.380 --> 00:08:38.360
I was working on PyPy at the time and PIP.

00:08:38.360 --> 00:08:38.900
Yeah.

00:08:38.900 --> 00:08:40.760
So some of the disk utils and those tools.

00:08:40.760 --> 00:08:46.520
So I think that's kind of the thing that's really unique to PyCon is that you can actually sprint with the people that are working on this stuff.

00:08:46.760 --> 00:08:49.760
That's actually a really good point because most conferences don't have that.

00:08:49.760 --> 00:08:52.540
The big names go up, they speak at you, and then they leave.

00:08:52.540 --> 00:08:53.120
And that's that.

00:08:53.120 --> 00:08:53.760
That's right.

00:08:53.760 --> 00:08:54.160
Yeah.

00:08:54.160 --> 00:08:55.020
So very, very cool.

00:08:55.020 --> 00:08:55.340
Okay.

00:08:55.340 --> 00:08:58.940
There's also the after party events, right?

00:08:58.940 --> 00:09:03.460
We went to like, it was the dinner at the art museum, for example, we got to meet up.

00:09:03.460 --> 00:09:12.260
And we played this really cool game, the classical programmer painting naming game, which I think any programmer must do when they go to an art museum, right?

00:09:12.260 --> 00:09:12.540
Yeah.

00:09:12.540 --> 00:09:16.020
I think for those that have never played the game before is you go to a museum.

00:09:16.020 --> 00:09:17.780
Where it's supposed to be serious business.

00:09:17.780 --> 00:09:20.300
Very proper formal art, Monet and so on.

00:09:20.300 --> 00:09:20.480
Yes.

00:09:20.480 --> 00:09:22.080
People there who are appreciating the art.

00:09:22.080 --> 00:09:27.940
And then, you know, you show up and then you start to give names or meaning to paintings you know nothing about.

00:09:27.940 --> 00:09:33.400
And I think you start to learn more about people as they pick names or they give an explanation for what they see.

00:09:33.400 --> 00:09:35.420
It's like, wow, this person really needs to take a vacation.

00:09:35.760 --> 00:09:36.360
Yes, exactly.

00:09:36.360 --> 00:09:39.900
Maybe there's like a picture of with like a burning field in the background, people working.

00:09:39.900 --> 00:09:44.400
You're like, these are like Java enterprise developers, like finishing a sprint or something like that.

00:09:44.400 --> 00:09:47.080
Or you give it a name of Docker 001, right?

00:09:47.080 --> 00:09:48.160
It's on fire all the time.

00:09:48.160 --> 00:09:48.880
Awesome.

00:09:48.880 --> 00:09:49.380
Awesome.

00:09:49.380 --> 00:09:50.520
All right.

00:09:50.520 --> 00:09:50.780
Cool.

00:09:50.840 --> 00:09:52.340
So let's talk about Kubernetes.

00:09:52.340 --> 00:09:55.080
We spoke about Docker and we spoke about containers.

00:09:55.080 --> 00:09:57.720
How does Kubernetes relate to that?

00:09:57.720 --> 00:09:59.360
What is Kubernetes and how does it relate to Docker?

00:10:00.300 --> 00:10:04.300
So I think when you think about like Docker, you think about I have a single machine.

00:10:04.300 --> 00:10:08.560
And, you know, if we think about the way we used to do deployments or still do, right?

00:10:08.560 --> 00:10:09.820
I don't think it's that far removed.

00:10:09.820 --> 00:10:12.240
You can copy some bits to a machine.

00:10:12.240 --> 00:10:16.620
If you don't have the environment set up, you can probably do something like virtual ent, get all your dependencies there.

00:10:16.620 --> 00:10:21.000
Maybe use an init system to start it up or maybe just, you know, fork it into the background.

00:10:21.000 --> 00:10:26.260
So what Docker does is says, hey, let's contain all of that, make a reusable package and then provide an API.

00:10:26.260 --> 00:10:28.220
So no more logging into servers, right?

00:10:28.220 --> 00:10:29.180
You got a Docker machine.

00:10:29.760 --> 00:10:30.980
You have the Docker command line tool.

00:10:30.980 --> 00:10:33.500
You can say, hey, Docker, run my web app.

00:10:33.500 --> 00:10:33.980
Okay.

00:10:33.980 --> 00:10:35.240
Docker, run my SQL.

00:10:35.240 --> 00:10:37.000
Docker, run all my dependencies.

00:10:37.000 --> 00:10:40.980
And then you look at that and you say, well, how do I scale that across a lot of machines?

00:10:40.980 --> 00:10:43.520
And I think that's where Kubernetes comes in, has a new API.

00:10:43.520 --> 00:10:48.520
You can say things like, hey, give me five of these, decouple from a particular machine.

00:10:48.520 --> 00:10:51.820
And you can also do things like service discovery being built in, right?

00:10:51.820 --> 00:10:56.960
So that's kind of a deeper topic where you already have MySQL deployed in this Kubernetes system.

00:10:56.960 --> 00:10:58.620
You have no idea where it's going to land.

00:10:58.720 --> 00:11:00.040
It's going to get its own unique IP.

00:11:00.040 --> 00:11:01.480
How do you connect to it?

00:11:01.480 --> 00:11:05.020
And those are the kind of features that are built into Kubernetes from a bigger cluster management standpoint.

00:11:05.020 --> 00:11:06.200
Yeah, that's fantastic.

00:11:06.200 --> 00:11:13.060
It solves such a great problem because Docker is pretty straightforward when you're doing one container.

00:11:13.060 --> 00:11:15.660
Your app is in the Docker container.

00:11:15.880 --> 00:11:26.240
But if you've got different tiers, a database tier, like a web tier, a load balancing tier, like different services, like if you're doing microservices, it gets really crazy, right?

00:11:26.240 --> 00:11:29.140
Like how do you even like identify all of these things?

00:11:29.140 --> 00:11:35.840
And so Kubernetes is kind of like that, both the management of all the containers plus that glue that binds them together.

00:11:36.180 --> 00:11:39.860
Yeah, it's like a big framework where you can do all these policy-based decisions.

00:11:39.860 --> 00:11:43.660
Like you can have things like autoscalers or a core concept inside of Kubernetes.

00:11:43.660 --> 00:11:53.280
You can say, whenever this aggregate set of my containers reaches 10% of CPU utilization, scale them up based on the step function.

00:11:53.740 --> 00:11:56.440
And you can define that by just using simple YAML.

00:11:56.440 --> 00:11:57.260
You put it in place.

00:11:57.260 --> 00:11:58.500
And the whole system works that way.

00:11:58.500 --> 00:12:06.860
So it gives you a way to think about a lot of computers, like a single computer, just based on this declarative policy-based way of thinking about compute.

00:12:06.860 --> 00:12:07.660
All right.

00:12:07.660 --> 00:12:08.720
So let's see.

00:12:08.720 --> 00:12:09.780
We take a Docker file.

00:12:09.780 --> 00:12:11.280
I'll start with just one for now.

00:12:11.280 --> 00:12:12.160
We take a Docker file.

00:12:12.160 --> 00:12:14.260
We want to run that in like a cluster.

00:12:14.260 --> 00:12:19.220
We can go to Kubernetes and go, Kubernetes, run this, scale me five of them.

00:12:19.820 --> 00:12:26.780
And you just get like an endpoint and a port and you just treat it as one thing and it's just like round robin and load balances around?

00:12:26.780 --> 00:12:27.080
Yeah.

00:12:27.080 --> 00:12:29.860
So I think for most people it's great to think about this in layers, right?

00:12:29.860 --> 00:12:33.640
So you may use Docker for your day-to-day development and then you're going to produce an artifact.

00:12:33.640 --> 00:12:35.740
Let's call it WebApp001.

00:12:35.740 --> 00:12:37.300
And you push that to a registry.

00:12:37.300 --> 00:12:43.300
So the price of admission to Kubernetes is that container in a registry because that's how it pulls things down.

00:12:43.300 --> 00:12:45.120
This is kind of the fundamental building blocks.

00:12:45.120 --> 00:12:46.820
And then you may have a deployment.

00:12:46.820 --> 00:12:48.540
Hey, deploy three of these.

00:12:48.640 --> 00:12:51.980
And at that point, you just have three of these things sitting there with their own IP addresses.

00:12:51.980 --> 00:12:54.320
They're going to land on the right set of machines.

00:12:54.320 --> 00:12:57.980
And then the next layer is maybe you want to expose it to the outside world.

00:12:57.980 --> 00:13:06.660
Then you can create what we call like a service and say, hey, Kubernetes, anything that looks like that WebApp, which we identify by labels, you know, app equals foobar.

00:13:07.100 --> 00:13:11.780
And then the service will say, okay, I'll go and find those and keep that curated list.

00:13:11.780 --> 00:13:15.360
So if one of them crashes and comes back up, it knows to replace them in a low balancer.

00:13:15.360 --> 00:13:21.360
And then that layer will handle incoming traffic and make sure that it routes directly to the right pause to handle it.

00:13:21.660 --> 00:13:27.500
That is really super nice because that's one of the concerns, right?

00:13:27.500 --> 00:13:30.660
Like I'm going on vacation pretty soon.

00:13:30.660 --> 00:13:35.420
I really don't want my sights to go down and just vanish from the Internet.

00:13:35.420 --> 00:13:39.320
But I also don't want to be like woken in the middle of the night to try to bring it back.

00:13:39.380 --> 00:13:42.820
I mean, this is not something that happens often, but it's something that's like really bad if it does.

00:13:42.820 --> 00:13:47.180
And so we used to solve this problem by sticking pagers on people, right?

00:13:47.180 --> 00:13:47.880
Yeah.

00:13:47.880 --> 00:13:56.780
So I think the whole on-call thing is born from, especially for the simple cases, it's okay to get on-call like for something that is like, oh, wow, no one could imagine that.

00:13:56.780 --> 00:13:57.860
That's a true emergency.

00:13:57.860 --> 00:14:02.680
But some of these on-call pages are like, hey, you're one instance of your site is down.

00:14:02.680 --> 00:14:05.000
You're like, so why are you calling me?

00:14:05.000 --> 00:14:06.720
Like, how about you just re-spin that up?

00:14:06.720 --> 00:14:07.680
We know how to do that.

00:14:07.680 --> 00:14:08.260
Exactly.

00:14:08.260 --> 00:14:09.800
Did you try rebooting the server?

00:14:09.800 --> 00:14:10.460
Yeah, exactly.

00:14:10.460 --> 00:14:11.080
How many times?

00:14:11.080 --> 00:14:12.820
And lots of people wake up and they do that.

00:14:12.820 --> 00:14:16.340
They wake up and say, you know what, let me just kick the server and then go back to sleep.

00:14:16.340 --> 00:14:22.640
And that's the thing that kind of disappears in a system like Kubernetes where you just say, look, I want three no matter what.

00:14:22.640 --> 00:14:31.820
So if a machine goes down, it just knows like, hey, let me just spin one up because the declaration you used to create the first one is still there and it can use the same template over and over again.

00:14:31.820 --> 00:14:32.100
Nice.

00:14:32.100 --> 00:14:33.520
And you basically pin it to a version.

00:14:33.520 --> 00:14:37.500
Like right now you should have three of version three of our app.

00:14:37.500 --> 00:14:39.420
If it goes down, recreate that, right?

00:14:39.420 --> 00:14:39.700
Yeah.

00:14:39.700 --> 00:14:42.100
And that's the key about this whole container thing, right?

00:14:42.100 --> 00:14:46.060
Is people say immutable and that's probably a good way to think about it.

00:14:46.060 --> 00:14:49.080
But, you know, while it's running, of course, there's memory being mutated.

00:14:49.620 --> 00:14:52.800
But on disk, you're starting from the same point over and over again.

00:14:52.800 --> 00:14:58.180
So if you do have to restart two or three, you're always going to get back to the same point that you expect.

00:14:58.180 --> 00:14:59.300
Yeah, that's awesome.

00:14:59.300 --> 00:15:05.580
So really, you're almost to the point where the only reason it wouldn't come back alive, okay, is some other service.

00:15:05.580 --> 00:15:06.860
It depends on changes, right?

00:15:06.860 --> 00:15:12.000
Like if you're doing microservices and the API like completely freaks out your app, then you've got to fix it.

00:15:12.000 --> 00:15:16.000
But if something went wrong with that machine, it's just, well, it's just going to fix itself, right?

00:15:16.000 --> 00:15:16.360
Yeah.

00:15:16.360 --> 00:15:17.920
And it'll come back and it'll be fine.

00:15:18.020 --> 00:15:19.440
And I think you bring up an important point.

00:15:19.440 --> 00:15:21.640
Kubernetes doesn't solve all the problems, right?

00:15:21.640 --> 00:15:22.100
It's not magic.

00:15:22.100 --> 00:15:22.820
It's not magic.

00:15:22.820 --> 00:15:23.680
We can't just sprinkle magic on us.

00:15:23.680 --> 00:15:23.760
No, no, no.

00:15:23.760 --> 00:15:24.620
It's definitely not magic.

00:15:24.620 --> 00:15:36.060
You have people, like you're right, if someone were to deploy a new version of the dependency that you have and the API is fundamentally different, yeah, Kubernetes will say everything looks good to me and your app will be down.

00:15:36.060 --> 00:15:41.400
So you have to think about where Kubernetes starts and stops and then what becomes an application concern.

00:15:41.400 --> 00:15:44.480
And that's where your classic metrics monitoring come into play.

00:15:45.300 --> 00:15:49.520
Yeah, but it does make it easier to test as a kind of a cluster, right?

00:15:49.520 --> 00:16:01.380
So if you have this microservice thing with five services, you could just locally or in some staging areas spin up all the various pieces, make sure they click together, and then just make sure what you deploy is all those pieces, right?

00:16:01.380 --> 00:16:06.240
Yes, we're definitely getting to a place where now we have an API to reason about this kind of thing, right?

00:16:06.240 --> 00:16:08.640
You have five different deployments that need to talk to each other.

00:16:09.180 --> 00:16:20.320
You can associate a service, give every deployment a name, and then just reference those services by name, whether there's one or five of them, and you can be sure to connect to one that's available.

00:16:20.320 --> 00:16:25.500
So that's just much easier to do versus tribal knowledge, scripts, and just knowing how to do things.

00:16:25.500 --> 00:16:26.980
Yeah, it sounds better for sure.

00:16:26.980 --> 00:16:28.800
How do you know from within your app?

00:16:28.800 --> 00:16:37.500
Like, suppose I have a Flask app like you had in your demo, and it talks to, say, a database server that's also running in a different container but also managed by Kubernetes.

00:16:37.500 --> 00:16:40.800
Do I talk to it by name, by IP address?

00:16:40.800 --> 00:16:41.880
How do they find each other?

00:16:42.400 --> 00:16:50.340
So today in Kubernetes, what you would do is ideally just say, hey, I want to connect to MySQL by name, MySQL, on port 3306.

00:16:50.340 --> 00:16:58.480
And what will happen is if you have a deployed container in Kubernetes, ideally you'll have a service in front of it, and the service name will be called MySQL.

00:16:58.480 --> 00:17:01.500
So what that does is Kubernetes has these control loops.

00:17:01.680 --> 00:17:09.960
So what the control loop will do is say, all right, let me find the MySQL server, get its IP address, and update the internal DNS server that we have, cluster-wide.

00:17:09.960 --> 00:17:19.180
So all you have to do is call MySQL, and the name or the IP address associated to that service, that IP will be fixed for the life of the container.

00:17:19.180 --> 00:17:25.260
So even though the container may go up and down and get a new IP, you'll have this kind of virtual IP that maps to it.

00:17:25.260 --> 00:17:28.660
And it kind of runs its own DNS, so you talk to it by the name.

00:17:28.660 --> 00:17:32.640
You've given even maybe that load-balanced group of things, and it just finds it?

00:17:32.640 --> 00:17:33.160
Exactly.

00:17:33.160 --> 00:17:39.840
So that becomes a virtual IP that allows us to have a stable naming convention, kind of the key to doing service discovery correctly.

00:17:39.840 --> 00:17:40.500
Okay.

00:17:40.500 --> 00:17:42.040
This sounds pretty cool.

00:17:42.040 --> 00:17:44.320
Does this work pretty well in your own data center?

00:17:44.320 --> 00:17:47.860
Like if I had 10 big Linux machines, could I just set this up?

00:17:47.860 --> 00:17:49.600
Yeah, so that's always been the goal of Kubernetes.

00:17:49.600 --> 00:17:54.020
We think of it like, you know, some people refer to it like the Linux of distributed systems.

00:17:54.020 --> 00:17:54.260
Okay.

00:17:54.260 --> 00:17:58.620
Right, so the goal is it doesn't really matter too much what distro you have or where you run it.

00:17:58.620 --> 00:18:01.000
We have all these pluggable, what we call them, cloud providers.

00:18:01.000 --> 00:18:06.720
So if you're in Amazon or Microsoft or Google, it will kind of detect that and like integrate with all the stuff that's there.

00:18:06.720 --> 00:18:10.260
So if you say, give me a load balancer, it'll spin up the proper load balancer for that environment.

00:18:10.260 --> 00:18:12.840
If you're on-prem, you're free to make your own integration.

00:18:12.840 --> 00:18:15.320
So maybe you have something like an F5 load balancer.

00:18:15.820 --> 00:18:17.480
You can do your integration there.

00:18:17.480 --> 00:18:21.840
But for most functionality, it doesn't matter if it's on your laptop or in your own data center.

00:18:21.840 --> 00:18:25.220
You install it, you hook it up correctly, you have a Kubernetes cluster.

00:18:25.220 --> 00:18:29.640
And you guys at Google also have, you guys do some cloud computing, right?

00:18:29.640 --> 00:18:30.440
Yes, we do.

00:18:30.440 --> 00:18:31.780
We do a lot of cloud computing.

00:18:31.780 --> 00:18:39.840
And you guys have a Kubernetes service as part, like kind of, you've got Google Compute Engine, you have Google's Kubernetes engine, right?

00:18:39.840 --> 00:18:41.980
Yeah, we call it a Google container engine.

00:18:41.980 --> 00:18:42.660
Container engine, right.

00:18:42.660 --> 00:18:47.100
So it's largely the open source Kubernetes, deeply integrated into Google Cloud.

00:18:47.100 --> 00:18:55.340
And we just try to give you all the things we know you would need, like access to load balancers, storage, metrics, monitoring, logging, audit logs, that kind of thing.

00:18:55.340 --> 00:18:55.920
Okay.

00:18:55.920 --> 00:18:58.440
And so tell me about the persistence stuff.

00:18:58.440 --> 00:19:02.420
This is almost more of a Docker question than it is a Kubernetes question.

00:19:02.420 --> 00:19:07.500
But if I run MySQL in one of these containers, ultimately I want that data to not be transient, right?

00:19:07.500 --> 00:19:09.120
Where does that stuff go?

00:19:09.300 --> 00:19:14.920
On one hand, I could obviously just hook into like RDS and Amazon or some database as a service.

00:19:14.920 --> 00:19:18.800
But assuming I'm not doing that, if I'm storing it on the disk, where does it go?

00:19:18.800 --> 00:19:23.960
So this question is probably the biggest source of confusion because of the defaults.

00:19:23.960 --> 00:19:33.880
If you take Docker out of the equation and I tell you I have a server and I install MySQL on the server, app git install MySQL, and you write data.

00:19:33.880 --> 00:19:34.580
Where does it go?

00:19:34.580 --> 00:19:37.380
It goes to whatever volume you write to on that server.

00:19:37.760 --> 00:19:39.940
If the server dies, there goes your data.

00:19:39.940 --> 00:19:42.360
Now let's add Docker to the equation.

00:19:42.360 --> 00:19:43.780
You say Docker run MySQL.

00:19:43.780 --> 00:19:49.440
Now the default in Docker is that you're going to get a temporary file system and you won't be able to write to those.

00:19:49.440 --> 00:19:49.900
Inside the container.

00:19:49.900 --> 00:19:50.860
Inside the container.

00:19:50.860 --> 00:19:51.180
Yeah.

00:19:51.180 --> 00:19:52.560
But really inside your true root, right?

00:19:52.560 --> 00:19:53.440
Still on the disk.

00:19:53.440 --> 00:19:53.840
Yeah.

00:19:53.920 --> 00:19:55.780
Except for it's going to get its own unique name.

00:19:55.780 --> 00:20:00.600
And by design, by default, we're just going to clean up when that container dies.

00:20:00.600 --> 00:20:02.500
Here's the temp files.

00:20:02.500 --> 00:20:03.140
We don't need any more.

00:20:03.140 --> 00:20:03.620
Yeah, exactly.

00:20:03.620 --> 00:20:07.980
Now, if you wanted to do this, you could just say the same varlib MySQL.

00:20:07.980 --> 00:20:10.000
Just mount that into the containers.

00:20:10.000 --> 00:20:11.480
You can say Docker run MySQL.

00:20:12.040 --> 00:20:16.860
Mount in the host, varlib MySQL, into the container, varlib MySQL.

00:20:16.860 --> 00:20:20.760
And everything you know about writing data to this is pretty much going to be the same.

00:20:20.760 --> 00:20:21.380
Okay.

00:20:21.640 --> 00:20:22.760
So there's no magic there.

00:20:22.760 --> 00:20:25.820
It's just that the default for a container is complete isolation.

00:20:25.820 --> 00:20:26.660
I see.

00:20:26.660 --> 00:20:27.460
So, yeah, right.

00:20:27.460 --> 00:20:34.120
So you basically configured your MySQL to write to, like, slash datastore or var, datastore, whatever.

00:20:34.120 --> 00:20:39.900
And then that, as long as you map that somewhere on your main machine, you could throw away that container, recreate it.

00:20:39.900 --> 00:20:41.120
It'll read from there again.

00:20:41.120 --> 00:20:42.160
It'll carry on, right?

00:20:42.160 --> 00:20:42.600
Exactly.

00:20:42.600 --> 00:20:45.660
And I think we're all spoiled by just having full access to a machine.

00:20:45.660 --> 00:20:48.040
And then, like, wherever it writes, that's where it writes.

00:20:48.520 --> 00:20:55.680
But inside of the container, since you can run multiple of these containers at one time, you kind of want your own file system space to do whatever you want.

00:20:55.680 --> 00:20:58.040
But remember, you can always just mount things.

00:20:58.040 --> 00:21:01.280
You just have to be explicit versus it being in an explicit contract.

00:21:01.280 --> 00:21:01.560
Right.

00:21:01.560 --> 00:21:02.580
And you just put that in the Docker file?

00:21:02.580 --> 00:21:03.740
So that's the thing.

00:21:03.740 --> 00:21:10.920
So in Docker files, that's where Kubernetes starts to be very advantageous to people or something like Docker Compose.

00:21:10.920 --> 00:21:15.940
Some of these semantics around run it like this is kind of where Kubernetes starts to shine.

00:21:16.260 --> 00:21:19.080
So when you look at a Kubernetes manifest, you say, run this container.

00:21:19.080 --> 00:21:22.660
And, oh, these are the volumes that come from the host.

00:21:22.660 --> 00:21:24.700
And I want them mounted here into the container.

00:21:24.700 --> 00:21:28.380
So you look at the full spec, you can see, oh, this is what should happen.

00:21:28.380 --> 00:21:33.220
And you know that that would be the right semantics versus, like, the Docker file, you can express some volumes.

00:21:33.220 --> 00:21:38.240
But you really need to make sure that you do the right thing when you say Docker run, mount all these things up.

00:21:38.240 --> 00:21:39.720
Or do something like Docker Compose.

00:21:39.720 --> 00:21:40.140
Right.

00:21:40.260 --> 00:21:44.380
And it's a little more like your Kubernetes Yemma file can just put that all together, right?

00:21:44.380 --> 00:21:45.700
Yeah, you want that to be the whole contrast.

00:21:45.700 --> 00:21:51.900
When we think about a pod, we say a pod is the network, the container, and the volumes that it needs.

00:21:53.080 --> 00:21:56.240
This portion of Talk Python to Me has been brought to you by Rollbar.

00:21:56.240 --> 00:21:59.920
One of the frustrating things about being a developer is dealing with errors.

00:21:59.920 --> 00:22:00.400
Ugh.

00:22:00.400 --> 00:22:08.940
Relying on users to report errors, digging through log files, trying to debug issues, or getting millions of alerts just flooding your inbox and ruining your day.

00:22:09.400 --> 00:22:15.700
With Rollbar's full-stack error monitoring, you get the context, insight, and control you need to find and fix bugs faster.

00:22:15.700 --> 00:22:19.680
Adding Rollbar to your Python app is as easy as pip install Rollbar.

00:22:19.680 --> 00:22:23.920
You can start tracking production errors and deployments in eight minutes or less.

00:22:23.920 --> 00:22:28.100
Are you considering self-hosting tools for security or compliance reasons?

00:22:28.100 --> 00:22:31.660
Then you should really check out Rollbar's Compliance SaaS option.

00:22:31.840 --> 00:22:41.040
Get advanced security features and meet compliance without the hassle of self-hosting, including HIPAA, ISO 27001, Privacy Shield, and more.

00:22:41.040 --> 00:22:42.420
They'd love to give you a demo.

00:22:42.420 --> 00:22:44.120
Give Rollbar a try today.

00:22:44.120 --> 00:22:47.800
Go to talkpython.fm/Rollbar and check them out.

00:22:47.800 --> 00:22:50.300
How do you guys use Kubernetes at Google?

00:22:50.300 --> 00:22:56.880
Like, I saw that this sort of was born out of the Borg, which is a pretty awesome name.

00:22:58.020 --> 00:23:03.880
And now it's an open source project, and it's hosted by, what is it, the Cloud Native Computing Foundation?

00:23:03.880 --> 00:23:04.580
Yep.

00:23:04.580 --> 00:23:06.260
So Kubernetes was born.

00:23:06.260 --> 00:23:10.520
CNCF is a foundation kind of designed for all these cloud native tools.

00:23:10.520 --> 00:23:14.900
FluidD, Prometheus, Kubernetes, OpenTracing.

00:23:14.900 --> 00:23:19.140
This is where you start to do application level tracing on how web requests flow through a system.

00:23:19.140 --> 00:23:23.940
So all of these collections of tools we think of make up the cloud native stack, kind of cloud native idea.

00:23:24.480 --> 00:23:26.260
And where does Kubernetes come from?

00:23:26.260 --> 00:23:29.240
Internally, we have a thing called Borg, but that's kind of a bit misleading.

00:23:29.240 --> 00:23:33.560
People say Borg, and they mean like maybe six or seven layers of stuff.

00:23:33.560 --> 00:23:33.960
Right.

00:23:33.960 --> 00:23:34.220
Okay.

00:23:34.220 --> 00:23:37.720
So Kubernetes represents one layer of that kind of stack, right?

00:23:37.720 --> 00:23:42.800
So Kubernetes would be the part that knows how to manage resources across a bunch of machines,

00:23:42.800 --> 00:23:49.200
knows how to deploy containers, and then serves as a framework of information for things like metrics and monitoring.

00:23:49.200 --> 00:23:51.060
And you would bring in other tools for that.

00:23:51.060 --> 00:23:54.620
So I think when you say Borg internally, it means a lot to Google.

00:23:54.620 --> 00:23:57.280
It's kind of like a catch-all, but there's lots of stuff in there.

00:23:57.280 --> 00:24:06.280
If you want something like Borg in the real world, you would say Kubernetes plus Prometheus plus there's a new project called Istio that works really great for microservices.

00:24:06.480 --> 00:24:16.440
So Istio's idea is that you have these sidecars that know how to do exponential back-off, retries, TLS mutual off, and authentication between microservices and policies.

00:24:16.440 --> 00:24:22.160
You take that and maybe some more, then you get what we call Borg, right, for the most part.

00:24:22.160 --> 00:24:23.040
Yeah.

00:24:23.220 --> 00:24:27.440
So is Kubernetes actually running inside Google as part of this thing that's called the Borg now?

00:24:27.440 --> 00:24:27.980
No.

00:24:27.980 --> 00:24:29.240
So Borg is its own system.

00:24:29.240 --> 00:24:35.780
It has a lot of features, and it actually has a lot of the way Google works, the way Google infrastructure works.

00:24:35.780 --> 00:24:37.520
Super specialized to Google.

00:24:37.520 --> 00:24:38.960
Hyper-optimized, right?

00:24:38.960 --> 00:24:43.240
But if you think about Kubernetes, it's used a lot in our cloud offerings.

00:24:43.240 --> 00:24:46.320
Like if you think about what the cloud ML and the TensorFlow team is doing.

00:24:46.320 --> 00:24:48.580
So they use Kubernetes for their stuff.

00:24:49.140 --> 00:24:52.880
And you can also imagine a lot of our customers are course running on top of Kubernetes.

00:24:52.880 --> 00:24:55.700
Kubernetes can also be used for other product offerings.

00:24:55.700 --> 00:25:00.340
You can imagine something like building hosted services or something like cloud functions.

00:25:00.340 --> 00:25:04.980
So Kubernetes gives us a really nice API for managing containers in a cloud platform.

00:25:04.980 --> 00:25:17.340
Do you, or I don't know if you can even talk about it, but do you have groups of people who are basically running cloud computing services on top of Google App Engine and these types of things?

00:25:17.340 --> 00:25:22.460
Like they're putting their own infrastructure and then reselling it as a service on top of what you guys are doing?

00:25:22.460 --> 00:25:24.560
Well, you're talking about internally.

00:25:24.560 --> 00:25:31.040
No, I'm talking like, is there a company that like is like DigitalOcean or Linode type of company?

00:25:31.040 --> 00:25:35.140
Oh, like a second tier cloud provider just reselling services?

00:25:35.140 --> 00:25:38.020
They've got some special layer on top of what you guys are doing.

00:25:39.020 --> 00:25:46.320
I don't know if there's any of those that I could probably talk about, but we know there's services like, of course, public like Snapchat, for example.

00:25:46.320 --> 00:25:48.100
You know, they built their platform.

00:25:48.100 --> 00:25:59.180
And most cloud providers, what you'll either see is either they'll use like our storage, you know, if you need petabytes and petabytes of storage at scale, you'll see something like that.

00:25:59.400 --> 00:26:03.240
And maybe they turn around and sell that as some other thing that they call by another name.

00:26:03.240 --> 00:26:03.740
Sure.

00:26:03.740 --> 00:26:09.320
But typically to be a cloud provider reselling another cloud provider, I think you'll get destroyed on margins.

00:26:09.320 --> 00:26:15.760
The best you could probably do is what Rackspace is currently doing, where they're providing like supports, where it's your account.

00:26:15.760 --> 00:26:20.020
You'll be paying the cloud provider and they put their support premium on top.

00:26:21.020 --> 00:26:21.840
Yeah, yeah, that makes sense.

00:26:21.840 --> 00:26:24.020
I mean, the margins are, it's a super competitive business.

00:26:24.020 --> 00:26:24.300
Yeah.

00:26:24.300 --> 00:26:29.620
I mean, like, why would you buy a VM knowing that it's running on like another cloud provider and pay more for it?

00:26:29.620 --> 00:26:30.380
Like, that's going to be tough.

00:26:30.380 --> 00:26:32.760
Yeah, there has to be a secret sauce, something extra.

00:26:32.760 --> 00:26:33.700
Okay.

00:26:33.700 --> 00:26:34.040
Yeah.

00:26:34.040 --> 00:26:34.260
Yeah.

00:26:34.260 --> 00:26:35.300
Very interesting.

00:26:35.300 --> 00:26:44.320
So it feels to me like if I use Kubernetes, I'm a little bit more removed from the infrastructure of any one cloud provider.

00:26:45.080 --> 00:26:51.220
So can you maybe speak to like the relative lock-in of like one cloud provider versus the other and using, say, Kubernetes?

00:26:51.220 --> 00:26:51.940
Yeah.

00:26:51.940 --> 00:26:56.440
So this lock-in thing is like, I look at it and I think I made a quote recently.

00:26:56.440 --> 00:27:00.680
If you try to switch products to avoid lock-in, that's just another form of lock-in.

00:27:00.680 --> 00:27:03.820
And Kubernetes, the API is open.

00:27:03.820 --> 00:27:06.000
The project happens to also be open source.

00:27:06.000 --> 00:27:12.380
So if you run it on your own data center, on your laptop, Google Cloud, Azure, or Amazon, you're going to get the same API.

00:27:12.940 --> 00:27:17.500
So essentially, you can be locked into the Kubernetes API across all these environments.

00:27:17.500 --> 00:27:25.680
So the trade-off there is maybe for some people, that's better than being locked into, say, one endpoint like ECS or Heroku.

00:27:25.680 --> 00:27:31.140
So I think when we talk about lock-in, we ask ourselves, what trade-offs and compromises are we willing to make?

00:27:31.140 --> 00:27:38.060
And Kubernetes offers enough value that if you lock into it, right, to go with the terminology we're using,

00:27:38.060 --> 00:27:42.260
then you feel like you can be a little bit more portable than what we were doing with virtual machines.

00:27:42.620 --> 00:27:43.960
Sure. Yeah, I totally agree.

00:27:43.960 --> 00:27:49.820
Also, it depends on how much you kind of buy into the full set of APIs, right?

00:27:49.820 --> 00:28:06.220
Like if you use Google Blob Storage and hosted databases and all of the specific Google App Engine APIs, well, you're more tied into Google's cloud than if you just use Linux and straight up stuff and write to your own disk and your own server.

00:28:06.380 --> 00:28:09.760
Exactly. I think a lot of us are starting to ask ourselves what the trade-off is worth.

00:28:09.760 --> 00:28:14.340
So when I look at the spectrum of trade-offs around lock-in, you've got a couple of options.

00:28:14.340 --> 00:28:16.400
Like let's say you use a hosted database service.

00:28:16.400 --> 00:28:18.260
Well, they manage the database for you.

00:28:18.260 --> 00:28:18.960
They back it up.

00:28:18.960 --> 00:28:19.800
They control the version.

00:28:20.040 --> 00:28:24.760
But you feel it's a good compromise for your time because you're using an open protocol.

00:28:24.760 --> 00:28:29.600
I can go and talk to the MySQL protocol in any environment that I want.

00:28:29.600 --> 00:28:30.200
So you know what?

00:28:30.200 --> 00:28:30.960
You can host that.

00:28:30.960 --> 00:28:35.360
Now, it gets a bit more tricky when you're dealing with something like maybe, let's say, Cloud Spanner.

00:28:35.740 --> 00:28:37.360
That is its own thing.

00:28:37.360 --> 00:28:38.960
It offers its own capabilities.

00:28:38.960 --> 00:28:40.200
Tell people what Cloud Spanner is.

00:28:40.200 --> 00:28:46.460
So Cloud Spanner is this, like, we are challenging this idea that if you have SQL, that we can scale it horizontally.

00:28:46.460 --> 00:28:48.880
You can also have it multi-regional.

00:28:48.880 --> 00:28:51.320
We can also do distributed transactions.

00:28:51.320 --> 00:28:54.280
So this would be, you have the SQL language you know and love.

00:28:54.280 --> 00:29:03.020
So imagine having a SQL or a Spanner database in Asia, in California, and Europe, and you're able to write to them

00:29:03.020 --> 00:29:09.620
and then actually have all the data be available in all the regions and be able to do things like distributed transactions.

00:29:09.620 --> 00:29:16.740
So you're not making the tradeoff between no SQL where you have eventual consistency from, you know, the traditional database stuff.

00:29:16.740 --> 00:29:19.400
So that's one of those things where people look at it and say, you know what?

00:29:19.400 --> 00:29:24.320
It's really hard to maintain my own MySQL shards and all the magic that goes behind that.

00:29:24.320 --> 00:29:30.320
Maybe I'm willing to trade off a little bit for this kind of proprietary thing that only runs in one cloud provider.

00:29:30.320 --> 00:29:31.460
You just got to make that decision.

00:29:31.820 --> 00:29:33.900
Yeah, that sounds, I remember what that is now.

00:29:33.900 --> 00:29:38.060
That sounds really, really advantageous for global companies, right?

00:29:38.060 --> 00:29:41.020
And if you're on the internet, maybe global, right?

00:29:41.020 --> 00:29:42.740
Yeah, what we're hearing is best of breed.

00:29:42.740 --> 00:29:52.080
So what we'll see now is that there'll be some companies that say, hey, we're using Amazon because we like a few of these things where we got a bunch of data inside of RDS, you know, their MySQL management thing.

00:29:52.640 --> 00:29:54.320
And they say, no, we're going to leave those apps there.

00:29:54.320 --> 00:29:54.920
But you know what?

00:29:54.920 --> 00:29:55.680
We like BigQuery.

00:29:55.680 --> 00:29:59.520
So we're going to deploy some stuff and just use BigQuery on the Google side.

00:29:59.520 --> 00:30:01.580
And you're starting to see, you've seen this.

00:30:01.580 --> 00:30:02.560
Companies are huge.

00:30:02.560 --> 00:30:07.180
They may have like 50 different departments producing their own apps, their own business units.

00:30:07.400 --> 00:30:11.880
So what you'll see is each of them choose their own story or how they want to do things.

00:30:11.880 --> 00:30:14.780
And they'll end up having usage on all platforms.

00:30:14.780 --> 00:30:18.600
And maybe there's no reason to reconcile when they're going for best of breed.

00:30:18.960 --> 00:30:20.980
Yeah, you know, this service works really good for this.

00:30:20.980 --> 00:30:22.260
That service works good for that.

00:30:22.260 --> 00:30:30.440
For a Cloud Spanner, it makes a lot of sense to have this geolocated and maybe starting by region like Asia and Europe and US.

00:30:30.440 --> 00:30:34.500
And so when you do a query, it like hits the local version.

00:30:34.500 --> 00:30:38.060
How do you get your web app near each one of those regions?

00:30:38.060 --> 00:30:40.940
So for each query or each interaction with the database is kind of local.

00:30:40.940 --> 00:30:47.620
So the goal is, of course, you would try to optimize in a way where you write the local stuff to it's local to Asia.

00:30:47.900 --> 00:30:57.200
But if you're in the US and let's say you failed over and you need to query some of that data, ideally we're replicating this, right, synchronously across these regions when it's time.

00:30:57.200 --> 00:30:59.820
So the goal of Spanner is that you don't want to make that tradeoff.

00:30:59.820 --> 00:31:01.680
You know that failures are going to happen.

00:31:01.680 --> 00:31:04.480
Ideally, you want your data in as many places as possible.

00:31:04.480 --> 00:31:06.980
So Spanner kind of gives you that ability to.

00:31:06.980 --> 00:31:08.740
So you don't think about that in your app.

00:31:08.740 --> 00:31:10.500
You don't think about partitions the same way.

00:31:10.500 --> 00:31:14.460
So Spanner tries its best to do the partitioning for you under the covers.

00:31:14.460 --> 00:31:17.300
It does the scaling underneath the covers for you.

00:31:17.560 --> 00:31:20.000
Depending on how much money you have, you can keep scaling horizontally.

00:31:20.000 --> 00:31:21.500
But some people want that.

00:31:21.500 --> 00:31:25.140
The last thing you want to do is stop everything and repartition your database.

00:31:25.140 --> 00:31:27.880
That's a nightmare for people that have ever done that before.

00:31:27.880 --> 00:31:28.980
If you have petabytes of data.

00:31:28.980 --> 00:31:34.060
Yeah, for some people, you just start a whole new cluster and you're like, we'll just phase that thing out.

00:31:34.060 --> 00:31:38.280
So I think it's one of those things where you just got to think of a tradeoff opportunity in time.

00:31:38.640 --> 00:31:43.440
Yeah, I mean, we feel like we have fast internet and these cloud, they're very fast and whatnot.

00:31:43.440 --> 00:31:51.260
But, you know, Amazon, I don't know about Google, but Amazon has a service where you can literally FedEx hard drives as like the fastest way to upload data.

00:31:51.260 --> 00:31:52.060
Yeah.

00:31:52.060 --> 00:31:53.620
I mean, you're going to see this quite a bit.

00:31:53.700 --> 00:32:01.120
I mean, the more data people produce, you need these white glove services where someone shows up with a truck and maybe they use that as the, you know, our sink.

00:32:01.120 --> 00:32:03.940
You know, you just like copy the big file and the our sink from there.

00:32:04.140 --> 00:32:08.100
And I think that's going to be until we get super fast pipes, we're going to have to figure that out.

00:32:08.100 --> 00:32:13.280
But I think that will probably be the fastest way in some cases is to just ship things around at that scale.

00:32:13.280 --> 00:32:13.780
That's awesome.

00:32:13.780 --> 00:32:15.040
You just gave me a vision.

00:32:15.040 --> 00:32:23.640
So, you know, a lot of these cloud providers like Google and Azure, they've got basically what look like shipping containers, which contain the servers.

00:32:23.640 --> 00:32:27.040
I can just see trucks that just drive up with the full container full of servers.

00:32:27.040 --> 00:32:32.080
You fill it with data, it drives over to the next data center and it unloads.

00:32:32.080 --> 00:32:32.400
Yeah.

00:32:32.400 --> 00:32:32.540
Yeah.

00:32:32.540 --> 00:32:34.600
It's possible, right?

00:32:34.600 --> 00:32:34.880
Yeah.

00:32:34.880 --> 00:32:36.740
I think a lot of backup companies have to do this, right?

00:32:36.740 --> 00:32:38.940
Like if you're truly doing backups, they're off site.

00:32:38.940 --> 00:32:46.120
And if you have lots of data, you will have a vendor come around in a truck and securely grab your store's medium and go lock it down somewhere.

00:32:46.120 --> 00:32:46.900
Wow.

00:32:46.900 --> 00:32:47.640
All right.

00:32:47.640 --> 00:32:48.260
That's awesome.

00:32:48.260 --> 00:32:53.560
So we talked about Kubernetes and it's solving the lock-in problem.

00:32:53.560 --> 00:33:02.520
One of my biggest pet peeves with working with these cloud things, especially when you deeply tie into their APIs, is I like to go work at a coffee shop.

00:33:02.520 --> 00:33:09.460
Or on a plane or I'm on a trip and I have crappy internet access because, you know, I don't have a good international data plan or something.

00:33:09.460 --> 00:33:12.700
Is there a way to like run this stuff locally on my laptop?

00:33:12.980 --> 00:33:15.460
On your laptop, you can run a project called Minikube.

00:33:15.460 --> 00:33:16.020
Okay.

00:33:16.020 --> 00:33:18.840
So Minikube basically takes a lot of inspiration from Docker.

00:33:18.840 --> 00:33:21.000
So Docker for Mac or Docker for Windows.

00:33:21.000 --> 00:33:21.300
Yeah.

00:33:21.300 --> 00:33:23.180
This idea that you'll have this kind of lightweight VM.

00:33:23.180 --> 00:33:24.920
Docker will be installed there.

00:33:24.920 --> 00:33:30.100
And Minikube just says, all right, let's install all the Kubernetes components on a single node because you get the same API.

00:33:30.100 --> 00:33:32.620
So whether you have one node or five, you get the same API.

00:33:33.180 --> 00:33:35.440
And for a lot of people, I guess you could do that.

00:33:35.440 --> 00:33:38.740
But me personally, I develop using my normal flow.

00:33:38.740 --> 00:33:40.760
I don't even use containers during development time.

00:33:40.760 --> 00:33:46.200
Like I'll use like Homebrew on my Mac, give me Postgres, give me Redis, get those protocols up.

00:33:46.200 --> 00:33:49.280
And I just write my app outside of all the container stuff.

00:33:49.280 --> 00:33:55.360
Once it works, then I think about packaging and then making sure that I can deploy it on Kubernetes.

00:33:55.360 --> 00:33:57.520
So I kind of decouple those workflows.

00:33:57.520 --> 00:34:00.440
I know some people want to make it part of just the incident workflow.

00:34:00.880 --> 00:34:02.760
But I look at that like running integration tests.

00:34:02.760 --> 00:34:10.340
I run unit tests locally, integration tests on the integration environment, not on my laptop all the time because they may be too big or take too long.

00:34:10.340 --> 00:34:11.360
Yeah, that makes a lot of sense.

00:34:11.360 --> 00:34:11.600
Okay.

00:34:11.600 --> 00:34:12.900
Yeah, very cool.

00:34:12.900 --> 00:34:18.560
So if I'm going to use Kubernetes, how much of an expert do I need to be in like DevOps type stuff?

00:34:18.560 --> 00:34:20.560
So there's two parts to this.

00:34:20.560 --> 00:34:24.480
There's I want to install Kubernetes and manage it and upgrade it.

00:34:24.480 --> 00:34:27.920
Then you should probably learn quite a bit about Kubernetes, right?

00:34:27.920 --> 00:34:30.500
And I think a lot of people are looking for the 10 minute, like,

00:34:30.620 --> 00:34:32.940
give me the tool where I can just twist all the knobs.

00:34:32.940 --> 00:34:35.540
That's not reality right now, right?

00:34:35.540 --> 00:34:39.060
There's some hosted offerings where you click the button and then they'll do everything for you.

00:34:39.060 --> 00:34:39.480
Right.

00:34:39.480 --> 00:34:41.280
That's GKE.

00:34:41.280 --> 00:34:43.140
GKE, Tectonic from CoreOS.

00:34:43.140 --> 00:34:47.100
Red Hat has, you know, OpenShift and, you know, some things to help you with Kubernetes.

00:34:47.100 --> 00:34:54.400
But if you want to be the cluster administrator, meaning the company comes to you when Kubernetes breaks or needs to be upgraded or something doesn't work.

00:34:54.620 --> 00:34:57.700
Yeah, you're in for a learning curve, right?

00:34:57.940 --> 00:35:00.860
Like, have you ever watched a developer use Vim for the first time?

00:35:00.860 --> 00:35:02.100
They can't get out.

00:35:02.100 --> 00:35:03.860
This is a text editor, right?

00:35:04.000 --> 00:35:12.780
And I think when you think about a fully distributed system that has a distributed database, has all these moving parts, you need to expect to study a little bit if you want to manage a cluster.

00:35:12.780 --> 00:35:22.240
Now, if you just want to kick the tires in demo mode, then yeah, install Minikube, go at it, find some Hello World tutorials and you can get off the ground in less than a day for sure.

00:35:22.780 --> 00:35:27.680
But if you just are a developer and you just want to use Kubernetes, this is where someone is managing it for you.

00:35:27.680 --> 00:35:28.380
There's an API.

00:35:28.380 --> 00:35:31.520
Then you install a little bit of tooling, kubectl on your laptop.

00:35:31.520 --> 00:35:37.200
You look at a few examples on how to create your, you know, package your app and describe how you want it to run.

00:35:37.200 --> 00:35:39.020
There's also things like Helm.

00:35:39.020 --> 00:35:41.040
So Helm is a package manager for Kubernetes.

00:35:41.040 --> 00:35:46.480
You can say Helm install etcd, Helm install Zookeeper or MySQL.

00:35:46.480 --> 00:35:56.260
And then that will go out and get all the things you need to do, like the service, the volume, the deployment object and deploy it to Kubernetes and manage it as like a single package.

00:35:56.260 --> 00:35:59.040
So then I can like start that pod, which is just.

00:35:59.040 --> 00:35:59.880
Yeah, exactly.

00:35:59.880 --> 00:36:02.660
So you can say Helm install MySQL, Redis and Kafka.

00:36:02.660 --> 00:36:04.340
That's the things I depend on.

00:36:04.340 --> 00:36:11.320
Then write your app, package it up, and then you can refer to them as MySQL, Redis and Kafka because service discovery is all built in.

00:36:11.320 --> 00:36:13.680
And for a lot of people, that is the magic moment.

00:36:13.680 --> 00:36:15.920
It's like, wow, I didn't have to even touch all that stuff.

00:36:15.920 --> 00:36:16.740
Yeah.

00:36:16.740 --> 00:36:22.260
So we're used to doing that at the application level, but you're kind of doing this at the server level.

00:36:22.260 --> 00:36:26.840
Like, yeah, I install this server machine and every bit of its infrastructure.

00:36:26.840 --> 00:36:28.500
Yeah, because some of these projects are huge.

00:36:28.500 --> 00:36:32.860
Like if you think about a production ready to go Kafka setup, you're talking multi nodes.

00:36:32.860 --> 00:36:33.980
They need to be configured.

00:36:34.180 --> 00:36:35.780
They need to be set up a certain way.

00:36:35.780 --> 00:36:42.940
And you may not want to learn all of Kafka just yet, but you may want something that's a little bit more bulletproof so you can actually test how your client does fail over.

00:36:42.940 --> 00:36:47.480
So it's really nice to have something like Helm install Kafka with three nodes.

00:36:47.480 --> 00:36:51.620
And then you can test out that your client does connect to all three of them and fails over correctly.

00:36:51.620 --> 00:36:52.580
Yeah, that's really nice.

00:36:52.580 --> 00:37:01.440
So basically, I guess to sum it up is if someone is managing it within your environment, it's pretty easy to just like deploy your app and use it.

00:37:01.940 --> 00:37:05.700
But if you want to be the person that maintains it, that's pretty risky, right?

00:37:05.760 --> 00:37:10.580
Because now the entire company is sort of balanced upon your...

00:37:10.580 --> 00:37:12.620
Well, think about your Linux distro, right?

00:37:12.620 --> 00:37:15.960
Like, you know, how many people really know how to build a Linux distro anymore?

00:37:15.960 --> 00:37:22.480
Most people do not know that you got to bootstrap and get the kernel, get the user land, get the package manager, make sure it all works.

00:37:22.540 --> 00:37:27.380
You just like, you use Ubuntu and you're kind of beholden to every distro of Ubuntu works right.

00:37:27.380 --> 00:37:28.920
The upgrades don't break everything.

00:37:28.920 --> 00:37:31.600
And infrastructure is a lot like that, like the networking.

00:37:31.600 --> 00:37:36.760
You realize that someone has all your routes set up that you can actually go out to the internet and back again.

00:37:36.760 --> 00:37:40.200
So we tend to think that these things are...

00:37:40.200 --> 00:37:43.760
We think we have control of them, but they just work and they're largely invisible.

00:37:44.500 --> 00:37:48.240
So if you get a Kubernetes setup that works the same way, you can almost forget about it.

00:37:48.240 --> 00:37:51.660
But if you want to be the management of it, then, you know, it's going to be front and center.

00:37:51.660 --> 00:37:52.640
Yeah, of course.

00:37:52.640 --> 00:37:53.040
Of course.

00:37:53.040 --> 00:37:53.780
Okay, cool.

00:37:54.380 --> 00:37:55.400
Let's talk about your keynote.

00:37:55.400 --> 00:37:56.280
Awesome.

00:37:56.280 --> 00:38:02.320
I heard so much good feedback on the internet about your keynote and people really loved it.

00:38:02.320 --> 00:38:04.700
The comments on the YouTube video, right?

00:38:04.700 --> 00:38:05.300
So it's on YouTube.

00:38:05.300 --> 00:38:06.560
People can go and watch it.

00:38:06.560 --> 00:38:07.040
Yeah.

00:38:07.040 --> 00:38:10.200
So maybe just sort of let's talk about what you did.

00:38:10.200 --> 00:38:12.600
So you start out with a Flask app, right?

00:38:12.600 --> 00:38:13.940
Super simple Flask app.

00:38:13.940 --> 00:38:15.560
You said, great, it runs here.

00:38:15.560 --> 00:38:20.640
Well, you kind of riffed a little bit on the challenges of actually running an app, right?

00:38:20.640 --> 00:38:22.100
Because it's one thing to have Python.

00:38:22.360 --> 00:38:25.800
It's another to have all the dependencies and all the configurations and stuff, right?

00:38:25.800 --> 00:38:26.320
Yeah.

00:38:26.320 --> 00:38:28.900
So I think a lot of people, when we say, hey, just use Docker.

00:38:28.900 --> 00:38:31.860
And you just tell the person that's doing Pythons, just use Docker.

00:38:31.860 --> 00:38:36.100
And then when they go out and look around about what's required, they're like lost.

00:38:36.100 --> 00:38:42.900
Because if you look at just a single container and you got to bundle in Apache, UWSGI, Flask,

00:38:42.900 --> 00:38:45.900
shut the Unix socket, then fork them off in the background.

00:38:45.900 --> 00:38:48.640
Oh, did you forget to change the permission on the Unix socket?

00:38:48.640 --> 00:38:49.920
I don't know why it doesn't work.

00:38:49.920 --> 00:38:50.600
Yeah, exactly.

00:38:50.780 --> 00:38:54.460
So by the time you do all that and you only have one Docker file to express all of this,

00:38:54.460 --> 00:38:55.920
you're like, something's not right.

00:38:55.920 --> 00:38:57.640
This doesn't feel like I would do on a VM.

00:38:57.640 --> 00:39:00.340
Because on a VM, you would have two separate processes.

00:39:00.340 --> 00:39:02.500
And you think about them separately, right?

00:39:02.500 --> 00:39:04.800
So I started with the Hello World.

00:39:04.800 --> 00:39:10.560
And you go from Hello World to let's do Hello World with UWSGI and Apache sitting in front.

00:39:10.900 --> 00:39:13.500
And then once people have that understood, and it's okay, now I get it.

00:39:13.500 --> 00:39:15.280
I see that you're using pip to manage your dependencies.

00:39:15.280 --> 00:39:17.420
What does it take to put that in the container?

00:39:17.420 --> 00:39:20.140
And what we did was say, hey, let's show two.

00:39:20.140 --> 00:39:24.280
There's one for your app and a separate one entirely for Nginx.

00:39:24.280 --> 00:39:25.200
Let's not mix the two.

00:39:25.200 --> 00:39:25.700
Right.

00:39:25.760 --> 00:39:34.440
So you basically set up one Kubernetes pod for Nginx and one for MicroWizGui plus your app.

00:39:34.440 --> 00:39:37.340
And you said, let's run those two together and they can one passes along.

00:39:37.340 --> 00:39:38.100
So slightly differently.

00:39:38.360 --> 00:39:42.400
So the pod concept is to capture what it means to be a logical application.

00:39:42.400 --> 00:39:42.860
Okay.

00:39:42.860 --> 00:39:46.260
So we know that Nginx belongs to this one instance of my app.

00:39:46.260 --> 00:39:47.620
They're inseparable, right?

00:39:47.620 --> 00:39:50.580
So in that case, in a pod, you can actually have a list of containers.

00:39:50.580 --> 00:39:53.060
So we know we want Nginx to be the front door.

00:39:53.060 --> 00:39:57.720
Nginx will mount the Unix socket from the other your app container.

00:39:57.720 --> 00:40:01.040
And then those two should be expressed in the same Kubernetes manifest.

00:40:01.040 --> 00:40:02.520
That's one pod.

00:40:02.520 --> 00:40:06.380
And then I can scale that together horizontally if I want five copies running.

00:40:06.380 --> 00:40:06.880
Nice.

00:40:07.000 --> 00:40:09.560
And do those two containers always run on the same machine?

00:40:09.560 --> 00:40:09.940
Yes.

00:40:09.940 --> 00:40:12.300
They run what we call the same execution context.

00:40:12.300 --> 00:40:12.640
I see.

00:40:12.640 --> 00:40:14.620
So imagine having a virtual machine.

00:40:14.620 --> 00:40:17.780
You would just install Nginx there and your app there, right?

00:40:17.780 --> 00:40:19.140
So they all live in the same place.

00:40:19.140 --> 00:40:23.020
But in this case, since we're using containers, we're going to put them in their own independent

00:40:23.020 --> 00:40:24.560
true roots and file systems.

00:40:24.560 --> 00:40:26.200
So they're still independent from that aspect.

00:40:26.200 --> 00:40:28.560
But where we do start sharing things is the network.

00:40:28.560 --> 00:40:30.500
So they share the same IP address.

00:40:30.500 --> 00:40:33.520
That means Nginx can talk to your app over local host.

00:40:34.120 --> 00:40:37.000
Now, my app is exporting a Unix file socket.

00:40:37.000 --> 00:40:37.640
So it's a file.

00:40:37.640 --> 00:40:42.620
So what I can do there is say, hey, we're going to write that file to a shared file system.

00:40:42.620 --> 00:40:45.860
On wherever that happens to be running on that Unix machine.

00:40:45.860 --> 00:40:46.240
Yep.

00:40:46.240 --> 00:40:48.940
So on that machine, we'll say, I want a temporary host mount.

00:40:49.480 --> 00:40:53.080
And once that host mount is created by Kubernetes, it's going to have a unique name.

00:40:53.080 --> 00:40:54.120
So no one else mounts it.

00:40:54.120 --> 00:40:56.180
And then we're going to give it to both containers.

00:40:56.180 --> 00:40:59.380
So in their own separate worlds, they see the same path.

00:40:59.380 --> 00:41:02.320
Container A, your app, writes its unit socket.

00:41:02.320 --> 00:41:06.700
The Nginx container says, oh, there's a file in this mount point.

00:41:06.700 --> 00:41:09.320
And I'm just going to send traffic to it.

00:41:11.200 --> 00:41:13.900
This portion of Talk Python is brought to you by us.

00:41:13.900 --> 00:41:18.060
As many of you know, I have a growing set of courses to help you go from Python beginner

00:41:18.060 --> 00:41:19.800
to novice to Python expert.

00:41:19.800 --> 00:41:21.840
And there are many more courses in the works.

00:41:21.840 --> 00:41:26.080
So please consider Talk Python training for you and your team's training needs.

00:41:26.080 --> 00:41:30.640
If you're just getting started, I've built a course to teach you Python the way professional

00:41:30.640 --> 00:41:32.520
developers learn by building applications.

00:41:32.520 --> 00:41:37.580
Check out my Python jumpstart by building 10 apps at talkpython.fm/course.

00:41:38.080 --> 00:41:40.720
Are you looking to start adding services to your app?

00:41:40.720 --> 00:41:43.880
Try my brand new consuming HTTP services in Python.

00:41:43.880 --> 00:41:49.320
You'll learn to work with RESTful HTTP services as well as SOAP, JSON, and XML data formats.

00:41:49.320 --> 00:41:51.160
Do you want to launch an online business?

00:41:51.160 --> 00:41:55.380
Well, Matt McKay and I built an entrepreneur's playbook with Python for Entrepreneurs.

00:41:55.380 --> 00:42:00.220
This 16-hour course will teach you everything you need to launch your web-based business with

00:42:00.220 --> 00:42:00.620
Python.

00:42:00.620 --> 00:42:04.160
And finally, there's a couple of new course announcements coming really soon.

00:42:04.160 --> 00:42:07.040
So if you don't already have an account, be sure to create one at

00:42:07.040 --> 00:42:09.620
training.talkpython.fm to get notified.

00:42:09.620 --> 00:42:13.380
And for all of you who have bought my courses, thank you so much.

00:42:13.380 --> 00:42:15.360
It really, really helps support the show.

00:42:15.960 --> 00:42:18.380
So we started with that and you got it working in Kubernetes.

00:42:18.380 --> 00:42:20.920
And then you said, well, let's scale it, right?

00:42:20.920 --> 00:42:21.440
Right.

00:42:21.440 --> 00:42:23.440
So now it's like you got this pod manifest.

00:42:23.440 --> 00:42:26.240
And I guess before we did that, we made sure our container worked with Docker.

00:42:26.240 --> 00:42:26.680
Right.

00:42:26.680 --> 00:42:26.940
Right.

00:42:26.940 --> 00:42:30.240
And then now we said, let's, how do we get this thing to scale inside of Kubernetes?

00:42:30.240 --> 00:42:35.100
So we make this pod manifest and then we submit it to Kubernetes and we watch it just place

00:42:35.100 --> 00:42:35.540
it somewhere.

00:42:35.540 --> 00:42:40.480
So now that it's placed on the machine, you can now say now Kubernetes is in control of this.

00:42:40.480 --> 00:42:42.680
If I delete it, Kubernetes brings it back, right?

00:42:42.740 --> 00:42:44.020
To my original specification.

00:42:44.020 --> 00:42:46.140
That's way better than getting woken up in the middle of the night.

00:42:46.140 --> 00:42:46.680
Of course.

00:42:46.680 --> 00:42:48.440
Like this whole on-call thing is overrated.

00:42:48.440 --> 00:42:49.600
Like you've never done it before.

00:42:49.600 --> 00:42:50.180
Trust me.

00:42:50.180 --> 00:42:51.640
It's not something you really want to do.

00:42:51.640 --> 00:42:56.660
And I guess to spice things up a bit, I decided to show what does the world look like when you

00:42:56.660 --> 00:42:59.060
have an API to control it all, right?

00:42:59.060 --> 00:43:00.240
We're not just talking bash scripts.

00:43:00.240 --> 00:43:05.940
So this is for the first time I broke out the OK Google, scale the particular application.

00:43:05.940 --> 00:43:10.860
And I think a lot of people, if they've been doing this long enough, never thought we would

00:43:10.860 --> 00:43:15.440
get to a point where you can just ask for something and do it the correct way.

00:43:15.900 --> 00:43:20.880
So part of that keynote, not only did we deploy the app, we scaled it horizontally while having

00:43:20.880 --> 00:43:24.460
like curl run in the background, showing the output from the app.

00:43:24.460 --> 00:43:28.400
And then we just did an in-place update of the application, all voice controlled.

00:43:28.400 --> 00:43:28.880
Yeah.

00:43:29.120 --> 00:43:31.060
And I think people were like, wow, we're there.

00:43:31.060 --> 00:43:33.060
It was really such a cool demo.

00:43:33.060 --> 00:43:37.240
I mean, if you guys haven't watched it, those of you who are listening, you basically pulled

00:43:37.240 --> 00:43:41.360
up your phone and you said, okay, Google, connect to Kubernetes.

00:43:41.360 --> 00:43:46.500
And you would set up an app or something in the background to like wire your cluster over

00:43:46.500 --> 00:43:47.020
to...

00:43:47.020 --> 00:43:47.220
Yeah.

00:43:47.220 --> 00:43:50.860
So some of the magic behind the scenes is when you have something like the Google assistance

00:43:50.860 --> 00:43:55.140
or Google Home, what you're really doing is saying, I'm going to send my speech and

00:43:55.140 --> 00:43:58.080
then there'll be a converter that's text to speech or speech to text.

00:43:58.400 --> 00:44:01.540
And it sends it to, in my case, I was using a thing called API.ai.

00:44:01.540 --> 00:44:05.420
And this is where you design your conversation, all the logic branches.

00:44:05.420 --> 00:44:10.220
And that does a bit of ML to take the speech and say, all right, this is your parameters.

00:44:10.220 --> 00:44:11.460
This is your intent.

00:44:11.460 --> 00:44:12.320
This is your action.

00:44:12.320 --> 00:44:12.780
Right.

00:44:12.780 --> 00:44:14.160
And then it sends it to a webhook.

00:44:14.160 --> 00:44:16.520
And that webhook I just had running written in Python.

00:44:16.520 --> 00:44:21.740
I had it running inside of my Kubernetes cluster that would get my intents, like create this

00:44:21.740 --> 00:44:22.160
deployment.

00:44:22.160 --> 00:44:23.440
Well, what's the name of the deployment?

00:44:23.440 --> 00:44:24.760
What's the version of the deployment?

00:44:24.760 --> 00:44:27.400
And it will take that and then it will interact with Kubernetes.

00:44:27.680 --> 00:44:29.660
And send a response back, which is text.

00:44:29.660 --> 00:44:32.780
And when the text hits your phone, it will read it back to you.

00:44:32.780 --> 00:44:36.880
So that's how we got the whole theatrical, it reading back what it was doing.

00:44:36.880 --> 00:44:37.700
That was beautiful.

00:44:37.700 --> 00:44:39.540
It wasn't just like you could talk and it worked.

00:44:39.540 --> 00:44:41.300
It would have a conversation with you, right?

00:44:41.300 --> 00:44:41.620
Yeah.

00:44:41.620 --> 00:44:44.920
So that was kind of the fun part where we would say, you know, I hope the demo guys are on

00:44:44.920 --> 00:44:45.380
your side.

00:44:45.580 --> 00:44:48.680
And that brings a bit of personality to the system.

00:44:48.680 --> 00:44:51.440
Whereas when you run a command, it either works or it doesn't work.

00:44:51.440 --> 00:44:52.060
It's very minor.

00:44:52.060 --> 00:44:52.820
Status code zero.

00:44:52.820 --> 00:44:53.860
Everything okay.

00:44:53.860 --> 00:44:54.320
Exactly.

00:44:54.320 --> 00:44:59.080
But when you have this thing saying, you know, hey, deployment complete, that was awesome.

00:44:59.080 --> 00:45:01.940
And then people were like, oh, wow, that's a bit unique.

00:45:02.180 --> 00:45:02.660
Yeah.

00:45:02.660 --> 00:45:06.860
So you basically got one of them running in Kubernetes and you said, okay, Google, scale

00:45:06.860 --> 00:45:10.400
this five times and five instances of it scaled up.

00:45:10.540 --> 00:45:15.320
Then the real trick that I think really impressed people was the zero downtime deployment.

00:45:15.320 --> 00:45:20.560
Because I know a lot of companies, when they schedule like deployments, they'll have a page

00:45:20.560 --> 00:45:22.240
and say, our site is down for maintenance.

00:45:22.240 --> 00:45:27.360
Our people will come in on the weekend and we're going to try to get it back with this four hour

00:45:27.360 --> 00:45:27.780
window.

00:45:27.780 --> 00:45:31.800
But if it might take 12 hours to deploy it, like that's the wrong way, right?

00:45:31.800 --> 00:45:32.420
Yeah.

00:45:32.420 --> 00:45:35.300
I think that's a way where we just didn't have a cohesive system, right?

00:45:35.300 --> 00:45:39.460
We talked earlier in the show about having that virtual IP sit in front of everything.

00:45:39.700 --> 00:45:42.260
So given that, and we have these controls behind the scenes.

00:45:42.260 --> 00:45:46.740
So when we do our rolling update and on, and part of the demo, I showed how in engine X, there's

00:45:46.740 --> 00:45:51.740
a pre stop hook where you can say, drain the connections before shutting down.

00:45:51.740 --> 00:45:53.380
And then we can reject new traffic.

00:45:53.380 --> 00:45:58.020
So when you combine all that stuff together, Kubernetes gives us enough cover where we can take down

00:45:58.020 --> 00:46:03.340
an instance and then remove from the load balancer, cleanly draining the connections and replace

00:46:03.340 --> 00:46:07.000
it with the new version and just do this over and over again till it's complete.

00:46:07.000 --> 00:46:09.000
That's where the, like the magic comes.

00:46:09.000 --> 00:46:10.020
I see.

00:46:10.020 --> 00:46:12.060
That really does make it work well.

00:46:12.060 --> 00:46:16.560
I was wondering if you just got lucky and it like, there was that microsecond where one

00:46:16.560 --> 00:46:20.280
was down and it wasn't one other, you know, like there was a transitional period where it

00:46:20.280 --> 00:46:20.880
wasn't quite right.

00:46:20.880 --> 00:46:26.120
But no, you had this very carefully, gracefully shutting down and it already spins up the new

00:46:26.120 --> 00:46:26.340
one.

00:46:26.340 --> 00:46:27.180
And then it starts.

00:46:27.180 --> 00:46:27.280
Yeah.

00:46:27.280 --> 00:46:29.000
So Kubernetes understands those semantics.

00:46:29.160 --> 00:46:33.020
So what we did in the demo, when I asked Kubernetes to update the version, of course, that goes

00:46:33.020 --> 00:46:36.560
with the whole pipeline and we create a new deployment object that has a new version.

00:46:36.560 --> 00:46:40.840
And once that's put into the system, Kubernetes says, okay, let's walk through this.

00:46:41.100 --> 00:46:44.560
The first thing we're going to do is launch the new version and make sure that it's all

00:46:44.560 --> 00:46:45.080
up and running.

00:46:45.080 --> 00:46:47.320
So we go from three to let's say four.

00:46:47.320 --> 00:46:51.300
So the fourth one is now in the low balancer and traffic is flowing through.

00:46:51.300 --> 00:46:54.020
And then we're safe to shut down, let's say number three.

00:46:54.120 --> 00:46:57.500
And then we give it as clean shut down hooks and then it's gone.

00:46:57.500 --> 00:47:01.580
But while we initiate that process, we make sure no new traffic is allowed to flow.

00:47:01.580 --> 00:47:04.220
And this is why we don't actually see those blips or hangups.

00:47:04.220 --> 00:47:05.300
That's perfect.

00:47:05.300 --> 00:47:05.840
Yeah.

00:47:05.840 --> 00:47:06.940
I mean, it's so nice.

00:47:06.940 --> 00:47:07.380
Yeah.

00:47:07.380 --> 00:47:08.380
That's like out of the box.

00:47:08.380 --> 00:47:12.620
So I think now that this is what you get out of the box, we're going to start to see new

00:47:12.620 --> 00:47:15.160
functionality as the years evolve or years go by.

00:47:15.160 --> 00:47:16.680
People start to try new challenges.

00:47:16.680 --> 00:47:18.000
What kind of apps can we deploy?

00:47:18.500 --> 00:47:24.680
Maybe even new ways of working develop now that this is automatic and not somebody like

00:47:24.680 --> 00:47:26.400
running manually a bunch of things, right?

00:47:26.400 --> 00:47:26.840
Exactly.

00:47:26.840 --> 00:47:32.320
I did a talk in Paris at a conference called .go and that talk, I had a self-deploying application.

00:47:32.320 --> 00:47:37.500
So in that demo, we talked about making a container and you put it on the registry and you write

00:47:37.500 --> 00:47:40.560
a Kubernetes manifest and you tell it to do things.

00:47:40.560 --> 00:47:43.940
But in that particular talk, I showed an app that deploys itself.

00:47:43.940 --> 00:47:45.540
So it's a statically linked binary.

00:47:45.920 --> 00:47:48.920
And if you run it on your machine, it will just, hello world.

00:47:48.920 --> 00:47:53.820
But if you give it the --Kubernetes flag, it will sense the Kubernetes API that

00:47:53.820 --> 00:47:55.960
you may have either mapped in a config file.

00:47:55.960 --> 00:47:59.220
And then it will do is create its own container in the background.

00:47:59.220 --> 00:48:04.320
It will upload itself, create its own image, and then make all of the configs necessary to

00:48:04.320 --> 00:48:05.880
run in Kubernetes and sit there.

00:48:05.880 --> 00:48:09.500
And if you have five copies running, Kubernetes has an API to get all the logs.

00:48:09.500 --> 00:48:13.660
So you can imagine this thing is now in your laptop running in the foreground and it goes

00:48:13.660 --> 00:48:15.880
out to Kubernetes and says, okay, where am I deployed?

00:48:15.880 --> 00:48:20.340
Give me all three streams of logs and put them together and stream them to the laptop.

00:48:20.340 --> 00:48:24.400
So it looks like it's just running on your machine when in reality it's running on this

00:48:24.400 --> 00:48:25.860
distributed system somewhere in the world.

00:48:25.860 --> 00:48:27.060
That's a really interesting point.

00:48:27.060 --> 00:48:32.140
The logs is also like a big challenge because if you're, anytime you're scaling horizontally,

00:48:32.140 --> 00:48:36.080
putting, especially in microservices where it's going from here to there to there, right?

00:48:36.140 --> 00:48:39.820
It's like, how do I put back together these requests?

00:48:39.820 --> 00:48:40.520
Yeah.

00:48:40.520 --> 00:48:43.860
So that's a thing where when people say they want to move to microservice and it's like,

00:48:43.860 --> 00:48:44.900
we got to have a conversation.

00:48:44.900 --> 00:48:49.140
You're going to go from a monolith where you only have one thing to really worry about to

00:48:49.140 --> 00:48:50.620
breaking it up into a bunch of pieces.

00:48:50.620 --> 00:48:53.260
So now you got to stitch back together your logs.

00:48:53.260 --> 00:48:55.480
And this is where things like trace IDs come in handy.

00:48:56.100 --> 00:48:59.120
You also need to do things like, where's it slow, right?

00:48:59.120 --> 00:49:03.480
First, you were just kind of in memory, making all these calls between, you know, what's on

00:49:03.480 --> 00:49:07.720
the stack or whatever function you need to resolve to, to now it's over the network.

00:49:07.720 --> 00:49:09.120
Well, is it on the same machine?

00:49:09.120 --> 00:49:10.460
Is it on a different machine?

00:49:10.460 --> 00:49:11.400
How do you know?

00:49:11.400 --> 00:49:14.360
So this is where things like tracing become very important.

00:49:14.360 --> 00:49:15.860
So a client hits your front door.

00:49:15.860 --> 00:49:17.940
You may have to talk to three other services.

00:49:17.940 --> 00:49:22.820
You want to have some metric to tell you, you've been spending 25% of your time in service

00:49:22.820 --> 00:49:23.140
A.

00:49:23.140 --> 00:49:24.100
That's your bottleneck.

00:49:24.100 --> 00:49:28.020
You might want to think about moving that either closer to the app or putting it back

00:49:28.020 --> 00:49:29.900
into the app because maybe you cut too deep.

00:49:29.900 --> 00:49:30.520
Right.

00:49:30.520 --> 00:49:31.500
It's too chatty.

00:49:31.500 --> 00:49:33.080
You're making a hundred calls to it.

00:49:33.080 --> 00:49:39.020
That is the number one thing people go from, people have like 10,000 lines of Jason just

00:49:39.020 --> 00:49:42.240
flying around the infrastructure because you're passing all these objects back and forth.

00:49:42.240 --> 00:49:44.480
And you're like, why is my bandwidth going through the roof?

00:49:44.480 --> 00:49:45.420
Or why is it so slow?

00:49:45.420 --> 00:49:46.040
Why is it slow?

00:49:46.040 --> 00:49:46.320
Yeah.

00:49:46.320 --> 00:49:48.920
You just have now Jason parsing as a service.

00:49:48.920 --> 00:49:50.120
Jason parsing as a service.

00:49:50.120 --> 00:49:50.660
I got it.

00:49:50.660 --> 00:49:51.680
Awesome.

00:49:51.960 --> 00:49:52.440
Yeah.

00:49:52.440 --> 00:49:58.320
So I guess the finale of your demo was to just say, okay, Google, upgrade to version

00:49:58.320 --> 00:49:58.600
two.

00:49:58.600 --> 00:50:01.940
And it just, all five instances just switched magically.

00:50:01.940 --> 00:50:02.220
Right.

00:50:02.220 --> 00:50:07.380
And this is the nice thing about the demo is that when I ask it to do that, and when you're

00:50:07.380 --> 00:50:10.840
building these voice integrations, you have this idea of what we call a follow-up.

00:50:10.840 --> 00:50:11.300
Right.

00:50:11.360 --> 00:50:16.140
So if I say a certain word or phrase, it will go down a different logic branch.

00:50:16.140 --> 00:50:19.540
So when it worked, I was able to say thank you.

00:50:19.540 --> 00:50:20.980
And then it was able to respond.

00:50:20.980 --> 00:50:22.980
I got to admit that was pretty dope.

00:50:22.980 --> 00:50:23.400
Yeah.

00:50:23.400 --> 00:50:27.080
And everyone, you know, gave a good round of applause and then you can just end it right

00:50:27.080 --> 00:50:27.400
there.

00:50:27.400 --> 00:50:31.160
But if it didn't work, I was not going to say thank you because it would be silly for this

00:50:31.160 --> 00:50:32.300
thing to say that was pretty dope.

00:50:32.300 --> 00:50:33.980
Thank you for ruining my demo.

00:50:34.100 --> 00:50:34.660
Yeah, exactly.

00:50:34.660 --> 00:50:36.440
Yeah.

00:50:36.440 --> 00:50:37.480
That was really good.

00:50:37.480 --> 00:50:39.360
So people listening, definitely go check it out.

00:50:39.360 --> 00:50:40.360
I'll link to it in the show notes.

00:50:40.360 --> 00:50:41.280
It'll be great.

00:50:41.280 --> 00:50:45.020
So maybe we'll leave it there for Kubernetes.

00:50:45.020 --> 00:50:48.280
If people want to get started, they have good resources.

00:50:48.280 --> 00:50:49.420
You wrote a class, right?

00:50:49.420 --> 00:50:49.820
A course?

00:50:49.820 --> 00:50:50.220
Yeah.

00:50:50.220 --> 00:50:52.600
So I did it with one of my colleagues, Carter Morgan.

00:50:52.600 --> 00:50:58.000
We did a Udacity course on kind of a workshop that I used to give hands-on out in the field

00:50:58.000 --> 00:50:58.780
for a few years.

00:50:58.780 --> 00:51:02.320
And we decided to turn it into a Udacity course so people can learn at their own pace.

00:51:02.740 --> 00:51:06.580
And we kind of go through a narrative like you saw in the keynote where you package a

00:51:06.580 --> 00:51:10.200
container, you play with Docker a little bit, and you go from Docker to Kubernetes.

00:51:10.200 --> 00:51:11.960
And you just kind of go through the basics.

00:51:11.960 --> 00:51:14.880
And there's like sections in there where you do a little hands-on.

00:51:14.880 --> 00:51:19.040
Then we have some slides and you kind of see how things work at a high level illustrated.

00:51:19.040 --> 00:51:23.080
And the goal there is like you learn at your own pace and you kind of really understand what

00:51:23.080 --> 00:51:24.340
this thing is trying to do for you.

00:51:24.340 --> 00:51:26.420
All those things you have to do hands-on to learn.

00:51:26.420 --> 00:51:28.260
You can't just kick back and then know it.

00:51:28.260 --> 00:51:28.960
Yeah, exactly.

00:51:28.960 --> 00:51:30.480
I think there's going to be a mix of learning.

00:51:30.480 --> 00:51:32.700
I tell people it's going to be a little while before you get it all.

00:51:32.700 --> 00:51:35.020
But everyone has a different way they like to start.

00:51:35.020 --> 00:51:38.980
And I think the course is great for people who like to kind of learn visually a little

00:51:38.980 --> 00:51:43.720
bit of hands-on and then have that as a kickstart to go into the deeper material like the Kubernetes

00:51:43.720 --> 00:51:44.280
documentation.

00:51:44.280 --> 00:51:47.960
I also have a book coming out with O'Reilly, Kubernetes Up and Running.

00:51:47.960 --> 00:51:51.980
That's written with the co-founders of Kubernetes, Joe Beta and Brendan Burns.

00:51:51.980 --> 00:51:54.360
So we just put the wraps on that.

00:51:54.360 --> 00:51:56.100
So that should come out pretty soon.

00:51:56.100 --> 00:51:56.500
Yes.

00:51:56.500 --> 00:51:58.280
Writing a book is a tall order.

00:51:58.280 --> 00:52:01.380
But hopefully it helps more people kind of learn and get up and running.

00:52:01.380 --> 00:52:02.060
Yeah, yeah.

00:52:02.060 --> 00:52:02.700
I'm sure it will.

00:52:02.700 --> 00:52:04.380
And your course, it's free, right?

00:52:04.380 --> 00:52:05.120
Yes, of course.

00:52:05.120 --> 00:52:07.360
We try to make as much of the documentation free.

00:52:07.360 --> 00:52:10.140
And the course definitely falls into that bucket.

00:52:10.140 --> 00:52:10.860
All right.

00:52:10.860 --> 00:52:15.860
So just because the timing of PyCon and all this was very, very near, I think it was the

00:52:15.860 --> 00:52:17.220
same week as Google I.O.

00:52:17.220 --> 00:52:19.720
Did you happen to go to Google I.O.?

00:52:19.720 --> 00:52:21.080
I'm sure you watched it, right?

00:52:21.220 --> 00:52:22.820
Yeah, I watched a bit of Google I.O.

00:52:22.820 --> 00:52:24.260
That's a big event for Google.

00:52:24.260 --> 00:52:29.340
It does a lot around the consumer side of things, mobile, a lot of the ML stuff that we're doing

00:52:29.340 --> 00:52:30.200
at Google in general.

00:52:30.200 --> 00:52:32.100
But you know, Python's a special event.

00:52:32.100 --> 00:52:34.020
So we actually had a lot of Googlers show up there as well.

00:52:34.020 --> 00:52:36.040
You know, a lot of people are into Python.

00:52:36.040 --> 00:52:40.900
Python's a big presence on App Engine, the libraries, you know, Google Cloud, the command

00:52:40.900 --> 00:52:42.000
line tools written in Python.

00:52:42.000 --> 00:52:45.960
So Python has a very storied history at Google.

00:52:45.960 --> 00:52:49.580
Lots of people are Pythonistas and will always be.

00:52:49.880 --> 00:52:53.520
So that is also a big event that we all mark in our calendars at Google.

00:52:53.520 --> 00:52:54.160
That's awesome.

00:52:54.160 --> 00:52:59.580
What did you make of like the specialized chips that Google's making and the whole machine

00:52:59.580 --> 00:53:00.300
learning AI?

00:53:00.300 --> 00:53:02.980
Well, Google's just trying to show a little bit of their secret sauce.

00:53:02.980 --> 00:53:05.900
Like Google has been pushing boundaries for a long time.

00:53:05.900 --> 00:53:09.680
I think there's a saying at Google, Google doesn't have all the solutions, but we definitely

00:53:09.680 --> 00:53:10.580
have all the problems.

00:53:11.120 --> 00:53:17.120
So a lot of our problems, if you think about them at a large scale, you get into the situation

00:53:17.120 --> 00:53:21.300
where you need to do specialized things like come up with your own chips to process things

00:53:21.300 --> 00:53:21.760
faster.

00:53:21.760 --> 00:53:22.280
Right?

00:53:22.280 --> 00:53:25.220
Like imagine like when you do a Google search, you want instantaneous.

00:53:25.220 --> 00:53:30.520
Like if it took even 500 milliseconds, you'd be like, this, what's wrong with my internet?

00:53:30.520 --> 00:53:31.140
It was broken.

00:53:31.400 --> 00:53:31.980
Yeah, exactly.

00:53:31.980 --> 00:53:34.780
So people are very impatient at this point.

00:53:34.780 --> 00:53:37.440
So we're always finding a way to reduce perceived latency.

00:53:37.440 --> 00:53:40.780
We got to do things and give you accurate results faster than ever.

00:53:40.780 --> 00:53:43.140
And that pushes us boundaries all the time.

00:53:43.720 --> 00:53:45.760
You've spoiled people for other websites.

00:53:45.760 --> 00:53:49.820
You can go to websites that seem like they're not really big or doing much.

00:53:49.820 --> 00:53:52.280
And they're like two or three, five seconds to respond.

00:53:52.280 --> 00:53:53.600
Like what is wrong with this website?

00:53:53.600 --> 00:53:54.940
Oh, two seconds, people leave.

00:53:54.940 --> 00:53:59.480
Like if your website comes up for two seconds, people won't put their credit card on a website

00:53:59.480 --> 00:53:59.880
that slow.

00:53:59.880 --> 00:54:02.400
They just have an instant mistrust and say, you know what?

00:54:02.400 --> 00:54:06.300
If you can't load the page quickly, I am not putting my credit card in there.

00:54:06.300 --> 00:54:07.520
It's a really interesting point.

00:54:07.520 --> 00:54:13.520
I saw a study that says that people trust from a security perspective, software that's faster

00:54:13.520 --> 00:54:16.600
and software that is functionally accurate.

00:54:16.600 --> 00:54:20.020
They believe it is more secure, even though it's kind of cross-cutting anyway.

00:54:20.020 --> 00:54:22.000
Yeah, and I think there's a good reason for that.

00:54:22.000 --> 00:54:25.140
I mean, you figure that security is probably the hardest part of the problem.

00:54:25.140 --> 00:54:29.040
And if the thing that you think should be the most straightforward part isn't right,

00:54:29.040 --> 00:54:31.000
you really have your doubts about the security part.

00:54:31.000 --> 00:54:32.280
Yeah, that's a really, really good point.

00:54:32.280 --> 00:54:33.520
All right.

00:54:33.520 --> 00:54:35.560
So I guess we'll wrap it up.

00:54:35.560 --> 00:54:36.900
That was such a great conversation.

00:54:36.900 --> 00:54:39.420
I have two more questions before I let you out of here.

00:54:39.420 --> 00:54:39.760
Okay.

00:54:39.760 --> 00:54:42.640
If you're going to write some code, what editor do you open up?

00:54:43.320 --> 00:54:43.560
Vim.

00:54:43.560 --> 00:54:44.220
Vim.

00:54:44.220 --> 00:54:46.140
And Vim with no plugins.

00:54:46.140 --> 00:54:47.440
Just straight.

00:54:47.440 --> 00:54:48.880
No syntax highlighting either.

00:54:48.880 --> 00:54:54.420
Like, it's just straight dark with white letters and no helpers.

00:54:54.420 --> 00:54:56.920
And I tend to pay attention to every line of the code.

00:54:56.920 --> 00:54:58.860
I don't have any blind spots.

00:54:58.860 --> 00:55:01.460
Like, you know, my variables are this color or my comments are this color.

00:55:01.600 --> 00:55:04.020
So I end up just reading everything top to bottom.

00:55:04.020 --> 00:55:05.100
It's probably slower.

00:55:05.100 --> 00:55:09.100
But I feel like I know the code base better because I'm not ignoring things anymore.

00:55:09.100 --> 00:55:13.700
It's not magically just barely completing with a different word than what you meant.

00:55:13.700 --> 00:55:13.940
Nope.

00:55:13.940 --> 00:55:14.540
Yeah.

00:55:14.540 --> 00:55:14.840
Awesome.

00:55:15.500 --> 00:55:18.340
And a notable PyPI package.

00:55:18.340 --> 00:55:20.080
There's over 100,000 of them now.

00:55:20.080 --> 00:55:22.980
Like, one they maybe run across lately that was really cool.

00:55:22.980 --> 00:55:28.840
Well, for the keynote, I actually used the Kubernetes package, which allows you to write integrations for Kubernetes and Python.

00:55:28.840 --> 00:55:34.960
And that was a very interesting package, mainly because it's generated from the Swagger API of Kubernetes.

00:55:34.960 --> 00:55:43.900
So if you've never used Swagger before, it's a way to kind of instrument your API so they can be, you know, you have this machine representation of, hey, here's every endpoint.

00:55:43.900 --> 00:55:44.940
Here's the input.

00:55:44.940 --> 00:55:45.640
Here's the output.

00:55:45.640 --> 00:55:48.560
And that Python library was generated from that.

00:55:48.560 --> 00:55:50.820
And then the documentation is also generated.

00:55:50.820 --> 00:55:53.420
So there's an example for every function you have.

00:55:53.420 --> 00:55:57.320
And it has pretty good coverage across the board of doing things in Kubernetes.

00:55:57.320 --> 00:56:00.080
So that's a well put together package.

00:56:00.080 --> 00:56:01.520
And that's what I've been using lately.

00:56:01.520 --> 00:56:02.040
All right.

00:56:02.040 --> 00:56:03.200
That sounds really, really cool.

00:56:03.200 --> 00:56:04.040
People want to check that out.

00:56:04.040 --> 00:56:06.120
So good place for final call to action.

00:56:06.120 --> 00:56:07.580
Like, people are excited about Kubernetes.

00:56:07.580 --> 00:56:08.380
How do they get started?

00:56:08.380 --> 00:56:12.240
I think a good way to get started is make sure that you need Kubernetes.

00:56:12.240 --> 00:56:14.640
There's a nice little tweet I saw the other day.

00:56:14.640 --> 00:56:18.380
A guy had kind of this full size tractor trailer flatbed.

00:56:18.380 --> 00:56:23.100
And it was just like a little piece of like wood on the flatbed that it was hauling.

00:56:23.100 --> 00:56:30.180
And this is what happens when people are like trying to deploy a very single WordPress on a thousand node Kubernetes cluster.

00:56:30.180 --> 00:56:32.740
Like, listen, it's okay if you want to learn.

00:56:32.740 --> 00:56:33.660
You know, that's cool.

00:56:33.660 --> 00:56:33.920
Yeah.

00:56:33.920 --> 00:56:35.480
But you don't need it for everything.

00:56:35.480 --> 00:56:39.620
So I would say if you want to learn, Minikyu is a great way to start.

00:56:39.980 --> 00:56:45.100
But it's also okay to look at Kubernetes and say, you know what, it's not required for what I'm doing and exit there.

00:56:45.100 --> 00:56:46.880
But if it does, it's a good fit.

00:56:46.880 --> 00:56:50.020
Like, you're running web instances or you want to have mixed workloads.

00:56:50.020 --> 00:56:51.780
You can also do batch jobs on Kubernetes.

00:56:51.780 --> 00:56:53.960
You can do these cron jobs on a timer.

00:56:53.960 --> 00:56:59.220
So Kubernetes kind of gives you this framework for thinking about running multiple workloads on a single set of machines.

00:56:59.220 --> 00:57:01.240
And then you can start going higher up the stack.

00:57:01.240 --> 00:57:07.080
So Minikube, find examples in your language of choice, like how to run my Python app in Kubernetes.

00:57:07.080 --> 00:57:08.960
That's a really kind of good Google search.

00:57:08.960 --> 00:57:10.660
And just take your time with it, right?

00:57:10.660 --> 00:57:13.080
You're going to have a long time to really master this thing.

00:57:13.080 --> 00:57:13.580
Yeah.

00:57:13.580 --> 00:57:16.340
It's something you can get started quick, but it takes a long time to master.

00:57:16.340 --> 00:57:16.820
Exactly.

00:57:16.820 --> 00:57:17.480
Hello, world.

00:57:17.480 --> 00:57:18.420
I always challenge people.

00:57:18.420 --> 00:57:19.480
I say, you know, Kubernetes.

00:57:19.480 --> 00:57:20.980
This is what I want you to do.

00:57:20.980 --> 00:57:25.380
In the language of your choice, I want you to write hello, world, package it, and deploy it in Kubernetes.

00:57:25.380 --> 00:57:29.900
And you watch how many people fall over because they don't actually remember all the commands.

00:57:29.900 --> 00:57:32.340
And they're still looking for their cheat sheet to put things together.

00:57:32.340 --> 00:57:35.560
So make sure you really understand the basics before you jump into all the complexities.

00:57:35.560 --> 00:57:36.260
All right.

00:57:36.260 --> 00:57:37.160
Well, fantastic.

00:57:37.160 --> 00:57:38.480
Thank you so much.

00:57:38.480 --> 00:57:40.280
It's been really great to chat about Kubernetes.

00:57:40.280 --> 00:57:42.060
And congrats on the keynote.

00:57:42.060 --> 00:57:42.600
It was amazing.

00:57:42.600 --> 00:57:42.980
Awesome.

00:57:42.980 --> 00:57:43.380
Thank you.

00:57:43.380 --> 00:57:43.700
Yeah.

00:57:43.700 --> 00:57:43.880
Thanks.

00:57:43.880 --> 00:57:44.120
Bye-bye.

00:57:44.120 --> 00:57:48.280
This has been another episode of Talk Python to Me.

00:57:48.280 --> 00:57:51.080
Today's guest was Kelsey Hightower.

00:57:51.080 --> 00:57:54.820
And this episode has been brought to you by Rollbar and Talk Python Training.

00:57:55.780 --> 00:57:57.800
Rollbar takes the pain out of errors.

00:57:57.800 --> 00:58:05.500
They give you the context and insight you need to quickly locate and fix errors that might have gone unnoticed until your users complain, of course.

00:58:05.500 --> 00:58:12.660
As Talk Python to Me listeners, track a ridiculous number of errors for free at rollbar.com slash Talk Python to Me.

00:58:12.660 --> 00:58:15.080
Are you or a colleague trying to learn Python?

00:58:15.080 --> 00:58:19.740
Have you tried books and videos that just left you bored by covering topics point by point?

00:58:19.820 --> 00:58:28.340
Well, check out my online course, Python Jumpstart, by building 10 apps at talkpython.fm/course to experience a more engaging way to learn Python.

00:58:28.340 --> 00:58:35.700
And if you're looking for something a little more advanced, try my WritePythonic code course at talkpython.fm/Pythonic.

00:58:36.660 --> 00:58:38.420
Be sure to subscribe to the show.

00:58:38.420 --> 00:58:40.640
Open your favorite podcatcher and search for Python.

00:58:40.640 --> 00:58:41.880
We should be right at the top.

00:58:41.880 --> 00:58:51.160
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct RSS feed at /rss on talkpython.fm.

00:58:51.580 --> 00:58:56.260
Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:58:56.260 --> 00:59:02.960
Corey just recently started selling his tracks on iTunes, so I recommend you check it out at talkpython.fm/music.

00:59:02.960 --> 00:59:08.320
You can browse his tracks he has for sale on iTunes and listen to the full-length version of the theme song.

00:59:08.320 --> 00:59:11.400
This is your host, Michael Kennedy.

00:59:11.400 --> 00:59:12.680
Thanks so much for listening.

00:59:12.680 --> 00:59:13.860
I really appreciate it.

00:59:13.860 --> 00:59:16.020
Smix, let's get out of here.

00:59:16.020 --> 00:59:37.400
I'll see you next time.

00:59:37.400 --> 00:59:37.800
Bye.

00:59:37.800 --> 00:59:38.300
you

00:59:38.300 --> 01:00:08.280
Thank you.

