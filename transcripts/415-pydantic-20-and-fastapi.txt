00:00:00 The release of Pydantic 2.0, its partial rewrite in Rust, and its refactoring into Pydantic Core and top-level Pydantic in Python is big news.

00:00:09 In fact, the alpha of Pydantic 2 was just released.

00:00:12 Of course, these changes will have potentially wide-ranging and positive effects on the libraries that are built upon Pydantic, such as FastAPI, Beanie, and others.

00:00:22 That's why this chance I had to catch up with Samuel Colvin from Pydantic and Sebastian Ramirez from FastAPI together, live from PyCon 2023, was really timely.

00:00:32 It's a super fun and wide-ranging interview I'm sure you'll enjoy.

00:00:36 Plus, there's a bit of an Easter egg in the middle.

00:00:38 This is Talk Python To Me, episode 415, recorded on location at PyCon in Salt Lake City on April 23rd, 2023.

00:00:47 Welcome to Talk Python To Me, a weekly podcast on Python.

00:01:02 This is your host, Michael Kennedy.

00:01:04 Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython, both on fosstodon.org.

00:01:12 Be careful with impersonating accounts on other instances.

00:01:14 There are many.

00:01:15 Keep up with the show and listen to over seven years of past episodes at talkpython.fm.

00:01:20 We've started streaming most of our episodes live on YouTube.

00:01:24 Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.

00:01:31 This episode is sponsored by Sentry.

00:01:34 Don't let those errors go unnoticed.

00:01:36 Use Sentry.

00:01:36 Get started today at talkpython.fm/sentry.

00:01:39 And it's brought to you by InfluxDB.

00:01:42 InfluxDB is a database purpose-built for handling time series data at a massive scale for real-time analytics.

00:01:49 Try it for free at talkpython.fm/InfluxDB.

00:01:53 Samuel, Sebastian, super nice to see you here at PyCon.

00:01:56 Welcome to the show.

00:01:57 Thank you very much for having us.

00:01:59 It's strange and exciting to do this live and to see you.

00:02:03 Yes, I know.

00:02:04 Normally it's remote over screen share over half the world or something like that.

00:02:09 Yeah, I've been able to talk with you directly.

00:02:11 Also with Samuel here.

00:02:12 It's super cool, super cool to hear you.

00:02:14 Yeah, thank you very much.

00:02:15 Yes, it's great to be here.

00:02:16 It's really fun being at PyCon and then doing this is like, yeah, even more fun.

00:02:19 I've done my talk, so I'm much more relaxed than I would have been if it had been this time yesterday.

00:02:23 I was just thinking, talking to someone else, like one of the best parts about giving a talk is that when it's over, you can really relax.

00:02:30 You know what I mean? You're like, okay, now I can enjoy the conference.

00:02:33 Absolutely, yeah.

00:02:34 And the parties, because you can't go too big on the parties if you've got to talk.

00:02:36 I feel like all the best ones were last night.

00:02:38 I'm afraid. We were at a pretty good one last night, weren't we?

00:02:41 Yeah.

00:02:41 Yeah.

00:02:42 But that was excellent.

00:02:43 All right, well, really good to have you both at the show.

00:02:46 I guess you hardly need introductions.

00:02:49 You both are doing such cool work.

00:02:51 We've had you on the show several times each.

00:02:53 So maybe just let's start with a catch up.

00:02:55 Like you both have lots of big news.

00:02:57 Don't want to necessarily spoil too much, but you know.

00:03:00 What have you been up to?

00:03:01 Yeah, so I raised money earlier this year.

00:03:03 Well, it was all sorted last year.

00:03:05 Money came in in January this year.

00:03:06 Started a company around Pydantic.

00:03:08 So I've been busy hiring.

00:03:10 Got a team of seven now.

00:03:12 One more going to join in June.

00:03:13 And yeah, currently we're working full-time on Pydantic version 2, getting that released.

00:03:18 And then after that, we're going to move on to the commercial plans, which I'm not talking about too much, mostly because they're up in the air a bit.

00:03:25 Also because if you start talking about them, you have to finish talking about them.

00:03:28 And then that's like, I'll just like take over the whole podcast.

00:03:30 So I'll say that, yeah, working on Pydantic V2 for now and then moving on soon.

00:03:35 Well, first from the whole community, congratulations.

00:03:36 You must be really thrilled.

00:03:38 Yeah, it's amazing.

00:03:39 It's very surreal, right?

00:03:41 Because I was going to say, did you see this coming?

00:03:43 No, I didn't.

00:03:44 My plan had been to start a different company once Pydantic V2 was done.

00:03:49 And then in November, Bogomil from Sequoia, who Sebastian knew, Sebastian recommended,

00:03:55 he chatted to me.

00:03:56 We had a call.

00:03:57 We had another call two weeks later.

00:03:58 And then he said, let's have the final meeting with like a few more partners to decide whether

00:04:02 to invest in two weeks time.

00:04:03 So I thought, oh, I should probably go and speak to some other VCs.

00:04:07 So Sebastian very kindly got me lots of intros.

00:04:08 My girlfriend also got me some intros.

00:04:10 I had like five meetings lined up.

00:04:12 And then the like floodgates opened and I got another like 20 or so VCs emailing me being

00:04:17 like, please, can I call?

00:04:17 Starting to hear about, oh, why are we not part of this?

00:04:20 Right.

00:04:21 And then I got COVID.

00:04:23 So I spent a week like locked in the bedroom upstairs doing VC calls.

00:04:27 Most of them with the like camera off feeling absolutely horrific.

00:04:29 And yeah, and then came back full circle back and had the big call with Sequoia and took

00:04:35 their money.

00:04:35 They've been amazing.

00:04:36 So it was Sequoia that invested.

00:04:37 Yeah.

00:04:37 Wow.

00:04:38 Awesome.

00:04:38 That's a big name to have behind you.

00:04:40 So Sequoia and Partec who are the smaller VC who are like French American and then Irregular

00:04:45 Expression, which is this really cool CTO network based kind of again, like New York and Paris.

00:04:51 And then a bunch of angels.

00:04:52 Yeah.

00:04:53 Last time we spoke, it was about Pydantic V2 and then all of this broke.

00:04:56 Yeah.

00:04:57 Yeah.

00:04:57 So I feel like I'm just back up to, as in problem was, although I was doing it to speed

00:05:02 up, that was there were then two months of basically doing meetings and doing legals.

00:05:06 So I think I've now got a team sufficiently that I'm like caught up to where I would have

00:05:09 been if I had just sat there and written code all along.

00:05:11 Yeah.

00:05:12 That's how it goes, right?

00:05:14 Yeah.

00:05:15 You got to put a little more sand in the gears to grow, I guess.

00:05:19 And Sebastian, how about you?

00:05:21 What do you, what have you been up to?

00:05:22 How have you been?

00:05:22 Oh, I've been good.

00:05:24 I've been good.

00:05:24 Yeah.

00:05:25 Very excited about like what they are doing at Pydantic is like the team they are assembling

00:05:29 is like just amazing.

00:05:30 And like, yeah, just like recently working a bunch in FastAPI and like Typer and actually

00:05:36 like in also some of the low level things of FastAPI and also not just FastAPI, but like

00:05:43 the things that go underneath.

00:05:44 Right now, like one of the things that I am pushing for is having documentation of the

00:05:50 API reference of the reference of the, each one of the parameters for what it is for each

00:05:54 one of the methods, like all that stuff.

00:05:56 Yeah.

00:05:56 And I want to do it in a, in a better way that is more maintainable and that I can test

00:06:01 the actual documentation for those parameters and consistency between like, there's a bunch

00:06:06 of things that I'm trying to do.

00:06:08 And like, it also goes to the low levels of like typing and interacting with the people

00:06:12 that is handling typing and like all the stuff that is super cool, super exciting.

00:06:16 But like, I think it can work and it can, it can make these things have like, you know,

00:06:21 like the API reference for the tools is something that a lot of people have been requesting and

00:06:26 like being able to have that in a way that is easy to maintain and that can work well and

00:06:31 that I can handle.

00:06:32 Like, I think that's, that's super exciting on that side.

00:06:34 And on the other side, of course, like the integration with Pydantic V2 is super exciting

00:06:38 now that they have like the first alpha available.

00:06:41 It is.

00:06:42 I mean, here you are going along working on FastAPI.

00:06:45 Everyone I talked to was just universally impressed with it.

00:06:49 You know, honestly, like I've never heard a bad thing about FastAPI and people are really

00:06:54 enjoying it.

00:06:54 And then here comes Samuel just changing the foundation, changing up Pydantic.

00:07:00 No, no, no.

00:07:02 I'm just teasing.

00:07:03 So how much work is that actually going to be to kind of make the change?

00:07:07 Is it kind of nothing or is it some work?

00:07:09 No, like there will be some working FastAPI.

00:07:11 The thing is for final users, it will be like almost transparent.

00:07:15 Right.

00:07:15 They will probably like, if they are doing like weird stuff, complex things like that touches

00:07:21 the corner cases or things like that, like they will probably have to update some things.

00:07:25 But for most of the use cases, it will be pretty much transparent for people.

00:07:29 And they will just like get like the, like, I don't know, like 10, 20x performance from

00:07:33 Pydantic v2.

00:07:33 And also like the...

00:07:35 I was going to say, just on the performance, I'm sorry to interrupt you.

00:07:37 One of the big things that we will be able to, you'll be able to drop from FastAPI is the,

00:07:42 I'm going to call it a hack, but it's not your fault.

00:07:44 It's my fault.

00:07:44 Of like, don't ask the type problem of serialization.

00:07:48 So I think that the like speed up on serialization in FastAPI could exceed, like, you know,

00:07:54 could be even bigger than that.

00:07:54 I don't know that yet, but I'm really hopeful for some like massive improvements because of

00:07:59 fixes in Pydantic that make FastAPI simpler and more elegant.

00:08:03 Yeah.

00:08:03 And since they're turning up the lights, we'll see how long we last here.

00:08:07 We'll stay as long as we can.

00:08:10 If you hear any noise in the background, that's because they're trying to tear down PyCon,

00:08:13 but we're going to...

00:08:14 They're tearing down PyCon around us, it seems.

00:08:16 We will not let it be torn out.

00:08:17 It will live on.

00:08:19 It's not because of Pydantic V2.

00:08:20 So, yeah, we may have to pause and move, but we'll find out.

00:08:24 Anyway, from a user for Pydantic, Samuel, if you haven't gone to like deeply gone into like

00:08:32 root object validation and all that kind of stuff, it's probably you won't even know, right?

00:08:36 So I think the hardest thing...

00:08:38 Yeah, you're right.

00:08:38 The vast majority of your code will either continue to work or we'll have a...

00:08:44 If you get run over by a forklift, it's going to really slow down the development of Pydantic,

00:08:49 by the way.

00:08:49 We're going to have a mod tool to change the name of methods.

00:08:55 So with luck, the vast majority of the changes should be automated.

00:09:00 I suspect that, and I was saying this earlier in the open space, the hardest thing is probably

00:09:05 going to be where your API subtly changes in its restrictions because of effectively edge

00:09:11 cases that Pydantic has fixed.

00:09:13 So for example, in Pydantic v1, we would coerce a int to a string.

00:09:17 If you passed a string to an int to a string field, we would coerce it.

00:09:21 I think that that's wrong and we shouldn't have done it.

00:09:23 And so now we don't.

00:09:24 But I was saying in the example, if for some reason you stored your IDs as strings and therefore

00:09:29 your API had the ID field as a string, but your user was just like pumping them into your

00:09:34 API as integers because that seemed to make sense to them, that's going to break.

00:09:38 And you probably haven't gotten a unit test that test that because you know your ID field

00:09:41 is a string.

00:09:42 So I feel sorry for those people.

00:09:44 And my biggest request would be if you're a user, try Pydantic v2 as soon as possible.

00:09:50 I know if you use it via FastAPI, you can't yet, but like all the other libraries.

00:09:54 But the sooner you can try it, the sooner you can tell us and the more easily we can fix things.

00:09:59 And we are prepared to add compatibility shims.

00:10:02 Okay.

00:10:03 Well, there, I mean, in Python, we have sort of a from futures import.

00:10:06 Well, there'd be from a, from history import type of like reverse thing.

00:10:10 Just slow that down or is it going to be a deprecation or is it just...

00:10:14 So we're doing deprecation warnings everywhere we can or deprecation errors saying this has

00:10:19 gone away.

00:10:19 You probably want to replace it with this thing.

00:10:20 We're working really hard on that.

00:10:22 We haven't got a like from future import or a compact layer yet for actual like validation

00:10:28 logic.

00:10:29 But if we have to, we will.

00:10:30 Yeah.

00:10:31 Okay.

00:10:31 You'll see, right?

00:10:32 See how much screaming...

00:10:34 What we didn't want to do was try and guess at what the problems were and build a compatibility

00:10:38 layer that people didn't need.

00:10:39 Yeah, of course.

00:10:40 So that's why we're doing it this way.

00:10:41 Yeah.

00:10:42 That makes a lot of sense.

00:10:43 You want to go as minimal backwards trying to fill those gaps as possible, right?

00:10:48 And if I'm brutal about it, if insert name of big bank that use Pydantic locks and never

00:10:53 engage with the open source community, get stung by this, they never paid me a penny and they've

00:10:57 never engaged, then like, I'm sorry for them, but I'm not as sorry as I would be if they

00:11:02 had like come and reported an issue and tried to like help along the way.

00:11:05 Yeah.

00:11:06 Yeah.

00:11:06 Like, can we work with you to just like smooth this over?

00:11:08 And, you know, worst case, can it be, you know, equal, equal, Pydantic, equal, equal,

00:11:13 1.10?

00:11:14 I think we'll carry on supporting critical security fixes for a year.

00:11:18 Okay.

00:11:19 So there's something of an LTS type of thing you're thinking?

00:11:21 Yeah.

00:11:21 For a while.

00:11:22 We have to, right?

00:11:23 For a while.

00:11:24 And yeah, we'll see.

00:11:25 Look at the download numbers and play it by ear.

00:11:27 Yeah.

00:11:27 All right.

00:11:28 Cool.

00:11:28 While we're talking about compatibility, if people are like doing a lot of the overriding

00:11:33 functions and stuff in their Pydantic models, like what do they, what should they expect?

00:11:37 Too many changes are pretty similar.

00:11:38 One of the biggest changes is that the init method of a model is now no longer called when

00:11:45 you're, unless you literally call init.

00:11:47 So if you call model validate, or if your model is nested inside another model, init is no longer

00:11:53 called.

00:11:53 The solution for that is to use a wrap validator or a model validator, but that's going to

00:11:58 be one of the pain points for people.

00:12:00 But there's just, it turns out with the Rust API, it's literally impossible without a massive

00:12:04 performance hit to do that.

00:12:07 This portion of Talk Python To Me is brought to you by Sentry.

00:12:10 You know that Sentry captures the errors that would otherwise go unnoticed.

00:12:14 Of course, they have incredible support for basically any Python framework.

00:12:18 They have direct integrations with Flask, Django, FastAPI, and even things like AWS Lambda and

00:12:25 Celery.

00:12:26 But did you know they also have native integrations with mobile app frameworks?

00:12:30 Whether you're building an Android or iOS app, or both, you can gain complete visibility into

00:12:36 your application's correctness both on the mobile side and server side.

00:12:40 We just completely rewrote Talk Python's mobile apps for taking our courses, and we massively

00:12:46 benefited from having Sentry integration right from the start.

00:12:50 We used Flutter for our native mobile framework, and with Sentry, it was literally just two

00:12:55 lines of code to start capturing errors as soon as they happen.

00:12:58 Of course, we don't love errors, but we do love making our users happy.

00:13:02 Solving problems as soon as possible with Sentry on the mobile Flutter code and the Python server

00:13:08 side code together made understanding error reports a breeze.

00:13:12 So whether you're building Python server side apps or mobile apps or both, give Sentry a try

00:13:19 to get a complete view of your app's correctness.

00:13:22 Thank you to Sentry for sponsoring the show and helping us ship more reliable mobile apps

00:13:27 to all of you.

00:13:27 Do you already have a roadmap?

00:13:30 Have you already tried the alpha on FastAPI?

00:13:33 Like, what's the story for you guys?

00:13:35 So, like...

00:13:36 Pedantic-wise.

00:13:37 Yeah, yeah, yeah.

00:13:37 So, like, we have actually been interacting a lot, like, with what are the changes that are

00:13:42 needed?

00:13:42 Like, what is it going to be?

00:13:43 And like, as someone was saying, like, I have a lot of code that is quite hacky.

00:13:48 I was actually surprised it didn't break much.

00:13:51 It just, like, really worked.

00:13:52 And like, it's for this particular use case where you can have, like, they are so loud.

00:13:58 They really want to tear us down.

00:13:59 I know.

00:14:00 We might have to be weird to say it.

00:14:02 But let's go ahead.

00:14:02 Let's finish this up.

00:14:03 Yeah.

00:14:03 So, like, validation error.

00:14:08 Can it concentrate?

00:14:09 So, imagine this use case where you have user model.

00:14:13 And then this, you want to return this user model.

00:14:16 But then you have an authenticated user model, as you were showing in the talk, in the PyCon talk.

00:14:22 And then this authenticated user model has a field that is a password.

00:14:26 If you return that use, the authenticated user directly, FastAPI does a lot of tricks to make

00:14:33 sure that what you receive in the client side is the actual user without the password.

00:14:38 That is the thing that you declared that you were going to return.

00:14:41 But by default, if you don't do it through FastAPI, but you do it with just plain Pydantic,

00:14:46 it will just check, like, hey, is this an instance of the other?

00:14:48 And then it will include the field.

00:14:50 Because, like, you know, because in thinking about types, it makes sense.

00:14:54 Like, oh, this is a subclass of that.

00:14:56 So, it makes sense that it's valid.

00:14:58 But when you think about data in an API, it doesn't make sense that it will include more

00:15:02 data than what it should.

00:15:03 Right, right, right.

00:15:04 Because you don't want to either have a mass injection attack on the inbound data or an

00:15:10 over-exposure on the way out, right?

00:15:12 You know, give away the password from users.

00:15:14 Is that bad?

00:15:15 I think it's pretty bad.

00:15:16 Okay, yeah, all right.

00:15:18 Like, you know, for example, like, some months ago or years or something, like, I remember

00:15:23 that Kaggle, the Kaggle API was returning, like, some of the hashes of the experiments.

00:15:28 So, like, you know, it's like, it's a mistake and a bit, but it's sad that it will end up

00:15:33 just, like, filtering more data than what it should be returning.

00:15:36 And it's something that can happen very easily.

00:15:38 It can happen very easily to FastAPI applications if people don't specify what is the response

00:15:43 model, the thing that they want to return.

00:15:45 And they just return a bunch of data directly.

00:15:47 So FastAPI does a lot of things to make sure that when you declare a response model that

00:15:52 should filter this data, the data is filtered.

00:15:55 But that's a lot of code in FastAPI to make it compatible.

00:15:58 With the new Pydantic V2, that's going to be pretty much transparent.

00:16:02 So that's amazing.

00:16:03 That is amazing.

00:16:04 Yeah.

00:16:04 There's going to be, like, a bunch of things that require, like, some refactoring and

00:16:08 also making sure that the Pydantic V1 and V2 are compatible at the same time in some way

00:16:14 so that people can have, like, a migration path.

00:16:16 But yeah, like, we have been making sure that, like, all the things that need to be changed

00:16:21 or that need to be updated or, like, all the things that need to be exposed from the Pydantic

00:16:25 side are actually available.

00:16:26 Yeah, it's awesome that you guys are working so closely together on this.

00:16:29 I mean, it's going to make it.

00:16:30 Yeah, absolutely.

00:16:31 So in my mind, these two projects are pretty closely tied.

00:16:34 I know that they're not, but that's a big use case.

00:16:36 Yeah, I think that's true.

00:16:37 And we know that FastAPI is by far our biggest dependent.

00:16:41 But also Django Ninja, which is, I think, now second or third, maybe third after SQL model

00:16:46 by Starz, is, like, Vitaly, who maintains that, has been engaging a lot with us on V2.

00:16:51 So yeah, lots of other projects are interested in it.

00:16:54 And I think, yeah, lots of people will be able to remove messy code because of that problem.

00:16:57 Because, yeah, like, the invariance of the response interface problem.

00:17:01 That's fantastic.

00:17:02 Coming back to your previous question about...

00:17:04 Before we go to that, I think we should probably find it.

00:17:06 What do you think?

00:17:07 Yeah, I think you might be right.

00:17:08 Not even necessarily, I think the audio may be okay, but just for a concentration, it's

00:17:11 very loud with the trucks around us.

00:17:13 I feel like I'm on the deck of that aircraft carrier, so I throw things off the side.

00:17:16 Yeah, okay, let's pause this for a moment.

00:17:17 We'll be back.

00:17:18 Hold on.

00:17:18 So we have survived the disassembly.

00:17:22 We have returned to continue.

00:17:24 We were talking about the integration of FastAPI and Pydantic, and that was really cool.

00:17:29 I think something I'd like to kind of move to real quick is this big announcement, alpha

00:17:34 of version two.

00:17:35 Samuel, last time you were on the show, we spoke about the plan for version two, and

00:17:40 now you're released in an alpha stage.

00:17:41 Tell people where we are with this.

00:17:43 Yeah, so we're, yeah, we've had two alphas, maybe three alphas now out.

00:17:47 We're basically pretty close to a feature freeze, and the plan is to release the package, release

00:17:54 a beta, and effectively, we hope that we can then release the full release, say two weeks

00:17:58 after that.

00:17:59 But there'll be bugs, and we'll fix them, and we'll have more betas.

00:18:01 But effectively, once we get to beta, the plan is that active development is stopping

00:18:06 bar fixing bugs.

00:18:07 Now it's performance and bugs, right?

00:18:09 Yeah.

00:18:10 And obviously, one of the big things will be once that's out, there'll be a lot more work

00:18:13 on, say, FastAPI, Django Ninja, et cetera, et cetera.

00:18:16 And that might come back with, we really need this thing.

00:18:18 Either this is broken, or we really need that to make it, you know, to reduce the overhead

00:18:23 of upgrading.

00:18:24 One of the things I did for Pydantic 1.10, which was super valuable in beta, was to go

00:18:30 through packages that use Pydantic, initially sorting by star, but then looking at what they

00:18:35 actually do, and trying to upgrade them.

00:18:37 And that, like, found me a bunch of bugs in either libraries or in Pydantic.

00:18:41 So we're not promising we're going to go and upgrade the whole of GitHub to Pydantic V2,

00:18:46 but we'll do a bit of that mostly to try and find bugs.

00:18:50 One of the things that would be really useful is if anyone has an application that uses Pydantic,

00:18:54 preferably without FastAPI or another library, that they would like help upgrading, we would

00:18:59 love to come and help.

00:19:00 And it might be a really powerful way of us, again, seeing the real pain points and identifying

00:19:05 bugs before we get to V2.

00:19:07 Yeah.

00:19:07 And I guess another thing to mention that is a real headline, and I also want to get your

00:19:12 thoughts on this, Sebastian, is the performance numbers, right?

00:19:15 I mean, you put out some pretty impressive performance numbers, and Sebastian gets to

00:19:19 piggyback on that, right?

00:19:20 Yeah.

00:19:20 I mean, yeah, I'm really proud of it, right?

00:19:23 Yeah, you should be.

00:19:24 I think to go in a change of release, in a bump of release, to be in the ballpark of 22

00:19:30 times faster, not 22%, but 22 times faster, I don't know of another package that's made

00:19:35 an upgrade of that kind of order of magnitude.

00:19:37 What's crazy is it's not numerical computing, right?

00:19:41 It's general purpose.

00:19:42 If you look at the example I gave in my talk earlier, it's a completely standard Pynantic

00:19:46 model with four fields.

00:19:47 And that's where we're seeing that kind of like 22 times speed up.

00:19:50 So I think it's going to be massive.

00:19:51 I have my own cynicism about people who hype about performance as being the most important

00:19:57 thing.

00:19:57 I don't think most applications, it's actually the thing that matters most.

00:20:01 But I think it matters.

00:20:02 A, it matters to everyone, and everyone wants it to go in the same direction.

00:20:05 And two, it matters to the whole world and to the whole community that we effectively reduce

00:20:10 the energy that we consume, like doing compute, basically.

00:20:14 Right.

00:20:14 That's absolutely true.

00:20:15 And also, even if people don't actually need it, there's a group of people who are like,

00:20:20 well, I'm going to leave for Go because it's not fast enough.

00:20:22 I can't do enough concurrency or whatever.

00:20:24 And if they don't have that feeling, even if they didn't actually need that percentage

00:20:28 increase, that's still really good for the Python community.

00:20:30 Even me, I was saying I had a gigabyte of data from web analytics that I needed to load

00:20:36 into a Polars data frame.

00:20:38 And for that, I needed to A, extract some attributes from nested fields and B, parse dates and things

00:20:43 like that.

00:20:44 And I used Pynantic V2.

00:20:45 And it was vastly faster with V2.

00:20:49 It went from like toodling, what's the word I'm looking for?

00:20:51 Twiddling your thumbs to like it happens virtually instantly, right?

00:20:56 And that's fantastic.

00:20:57 And that'll be even more true when you have an order of magnitude or two orders of magnitude

00:21:01 more data.

00:21:02 Yeah, for sure.

00:21:03 Sebastian, how about you?

00:21:04 What's the knock-on effect for FastAPI?

00:21:06 So I think one of the coolest things is that people won't have to change the code to get

00:21:11 that performance benefit.

00:21:12 It's just going to be like a bump suddenly.

00:21:13 And because of the new ways that Pynantic can handle the data, we're going to be able

00:21:19 to, there's something that needs to be done in FastAPI, but we're going to

00:21:21 be able to let the parsing of the data, let Pynantic handle that in the Rust site.

00:21:28 So Pynantic will be able to just read the JSON bytes instead of reading them in the Python

00:21:34 site and let Pynantic do that.

00:21:35 And then Pynantic give the models back to the rest of the code of FastAPI.

00:21:39 That alone will boost performance a lot.

00:21:41 But the fact that it's being done in Rust, in the Rust site, it's just going to be amazing.

00:21:45 Yeah.

00:21:46 Like one of the other things that I want to do that is on the plans is to let users

00:21:50 define how they want to serialize data and not have like, this is just like by default,

00:21:55 it's just like Pynantic models and like it converts automatically to JSON.

00:21:59 But I want to allow users to decide how to serialize the objects and the data so that

00:22:03 they can just...

00:22:04 Like data classes or something like that?

00:22:06 Yeah.

00:22:06 For example, they can say like, oh, I don't want to serialize with the standard JSON serializer.

00:22:10 I want to serialize with our JSON, which is like the...

00:22:13 I see.

00:22:14 Rust based implementation to serialize JSON.

00:22:17 Or they can say like, I want Pynantic to be the one that serializes this because I know

00:22:21 that this is just a model that can handle that.

00:22:22 They can also like...

00:22:23 And this is one of the things that I think is super cool.

00:22:25 They can also create...

00:22:27 They will be able to create a way to say, I want to serialize this response to XML or something

00:22:33 like that or to YAML and to let Pynantic handle the validation, but then like do the serialization

00:22:38 in a way that they can customize the whole thing without having to do it directly in the code.

00:22:43 Maybe even some of these crazy stream buffer type of protocols.

00:22:47 You know, like, yeah, like protocol buffers with GRPC or like even message pack or like,

00:22:51 you know, like a bunch of these things that there's no obvious way and there's no native

00:22:56 way to have support for that, for reading the data and for exporting the data.

00:23:00 And like, that's one of the things that I have like implants.

00:23:02 I like, I'm probably saying too much and then I'm going to account all the pieces of the code.

00:23:06 And now they're like, you know what?

00:23:07 You promised this.

00:23:08 You did promise it.

00:23:09 Well.

00:23:10 Can I just come back on serialization for a minute?

00:23:12 Yeah, please.

00:23:12 Yeah, please.

00:23:13 Yeah.

00:23:13 So what we've, I've worked from October, quite like putting to one side, the whole funding

00:23:19 round in the middle of it was working solidly on serialization.

00:23:21 So we have, there's almost as much code in Pynantic core now for serialization as there

00:23:26 is for validation.

00:23:26 Yeah.

00:23:27 Well, we can serialize directly to, to Jason using the same underlying library that, or Jason

00:23:32 uses using Serdi, but one, and also we can, you can customize how your serialization

00:23:38 goes on a per field basis rather than on a per type basis, which is like incredibly powerful.

00:23:42 But we also allow you to effectively serialize to Python.

00:23:46 So not just what used to be the dict method, but basically do JSONable Python.

00:23:51 So you effectively set the mode when serializing to Python, to Jason, and you will only get the

00:23:55 like, whatever it is, seven primitive Jason types in Python, which is super valuable if you

00:24:00 want your output to be XML, because then you know your XML encoder only needs to bother,

00:24:04 needs to take in dictionaries, list, ints, floats, none, bool.

00:24:08 Yeah.

00:24:08 Rather than whatever complex data you have.

00:24:11 So there's an, or I, yeah, I'm like super proud of lots of the advantages of serialization.

00:24:15 My 45 minute talk earlier, I was able to touch about half of the big new features, which

00:24:20 kind of talks about quite how much has changed.

00:24:23 Yeah.

00:24:23 That's really exciting.

00:24:24 I think we definitely, I was saying earlier, if I had known how long it was going to take,

00:24:28 I would never have set out on this journey.

00:24:30 So the best thing about it is I didn't, I didn't think about how long it was going to

00:24:33 take because we didn't try and do a bit more.

00:24:36 We tried to do everything or I tried to do everything.

00:24:38 And that's how it's disadvantaged.

00:24:40 It's taken longer than we had hoped, but.

00:24:41 But here you are.

00:24:42 You're pretty much here.

00:24:43 That's really good.

00:24:43 That's really good.

00:24:44 And so when you think about performance, right, obviously the 22 times faster is awesome.

00:24:49 The FastAPI speedup is awesome.

00:24:51 But if you do something like SQL model and FastAPI or Beanie and FastAPI, you're getting

00:24:58 on both ends, you're getting that Beanie or the Pydantic benefits with the Beanie integration

00:25:03 and the fast.

00:25:04 So you, you're kind of putting Pydantic in both those layers.

00:25:08 And so those speedups are like twice as good or something like that.

00:25:11 Yeah.

00:25:12 Right.

00:25:12 I think you, well, they're probably, yeah, they're like, they're the same relatively,

00:25:16 but more in absolute terms.

00:25:17 Yeah.

00:25:18 Yeah.

00:25:18 Yeah, absolutely.

00:25:19 So, yeah, I think it's, you know, the fact that it's a lot of people, so many things have been built upon Pydantic means you've just sped up a bunch of projects

00:25:26 without them doing too much.

00:25:28 Yeah.

00:25:29 We get the, like the win.

00:25:30 It's like CPython itself getting faster, helps everyone.

00:25:32 This is like the next layer down, but we, you know, as a dependency of lots of packages,

00:25:36 we get to speed up lots of the community with one package, like one person devoting a year

00:25:41 to it.

00:25:41 Does this surprise you to see all these projects coming out?

00:25:44 Like here's another project based on Pydantic plus, you know, name your other thing that

00:25:48 it's been crazy, particularly in the like machine learning space where, you know, Langchain, who are one of the like big names right now in these like big language

00:25:56 models, large language models, all based on Pydantic, right?

00:25:59 Yeah.

00:25:59 You were saying, I think on Twitter, that OpenAPI use a bunch of FastAPI, right?

00:26:04 OpenAI?

00:26:04 Sorry.

00:26:05 Yeah.

00:26:06 OpenAI, not OpenAPI.

00:26:08 Marvin from, I think from Prefect is built on Pydantic again.

00:26:11 So like the wave of machine learning stuff seems to have leveraged Pydantic a whole lot.

00:26:16 Docker array being another, another big example.

00:26:18 Some for Elastic and some other things as well.

00:26:24 This portion of Talk Python To Me is brought to you by Influx Data, the makers of Influx

00:26:28 DB.

00:26:28 Influx DB is a database purpose built for handling time series data at a massive scale for real

00:26:35 time analytics.

00:26:36 Developers can ingest, store, and analyze all types of time series data, metrics, events,

00:26:42 and traces in a single platform.

00:26:44 So dear listener, let me ask you a question.

00:26:46 How would boundless cardinality and lightning fast SQL queries impact the way that you develop

00:26:51 real-time applications?

00:26:52 Influx DB processes large time series data sets and provides low latency SQL queries, making

00:26:58 it the go-to choice for developers building real-time applications and seeking crucial insights.

00:27:04 For developer efficiency, Influx DB helps you create IoT analytics and cloud applications

00:27:10 using timestamped data rapidly and at scale.

00:27:13 It's designed to ingest billions of data points in real-time with unlimited cardinality.

00:27:18 Influx DB streamlines building once and deploying across various products and environments from

00:27:24 the edge, on-premise, and to the cloud.

00:27:27 Try it for free at talkpython.fm/influxDB.

00:27:31 The link is in your podcast player show notes.

00:27:33 Thanks to Influx Data for supporting the show.

00:27:36 I'm sure one of the big things you're thinking going forward with FastAPI is like how do you

00:27:42 guys work together and make this a seamless change?

00:27:44 What else you got?

00:27:45 What else are you working on?

00:27:46 What else do you see in the future?

00:27:48 I have a bunch of things.

00:27:49 Are they secret or can you tell us?

00:27:51 No, no, no.

00:27:52 I can't tell.

00:27:52 Most of it I can't tell.

00:27:54 I just feel the accountability.

00:27:57 But I can't tell.

00:27:59 So like I have a bunch of projects and like the funny thing is that in some way it's kind

00:28:04 of a dependency graph of things that I should work on.

00:28:07 So for example, I have this project generator for FastAPI to generate a project with a SQL

00:28:12 database.

00:28:12 I haven't updated it in a long time and it uses SQLAlchemy.

00:28:16 I built SQL model for that project to use it there.

00:28:19 But I haven't updated it there because first I want to upgrade more things in SQL model.

00:28:23 I want to finish the documentation, finish the story about migration.

00:28:26 But then for the story about migration, I need typer for SQL model.

00:28:30 So I need to update things in typer.

00:28:32 And then for typer, I want to add support for annotated, which is actually one of the big

00:28:36 things.

00:28:36 One of the recent big things in FastAPI is that now there's support for annotated.

00:28:41 So annotated is this feature from Python.

00:28:44 It's like standard Python typings.

00:28:46 You import from typing, from typings import annotated, and then you can use that to meet

00:28:52 information to the types that you define for parameters.

00:28:54 Like what?

00:28:55 I haven't used this.

00:28:56 I love typing.

00:28:56 I use it all the time.

00:28:57 And here I'm learning more about typing.

00:28:59 The thing is it exists there in the standard library, but it doesn't have like a canonical

00:29:04 use in Python itself.

00:29:05 It's there mainly for FastAPI and Pydantic to use it.

00:29:09 You know, like it's just that like I haven't, I hadn't pushed for that before.

00:29:13 But the thing is you import from typings, import annotated, and then you create a function that

00:29:19 takes like a username.

00:29:20 And then this function will normally be of type string.

00:29:23 So it will be like the parameter of the function will be username colon str.

00:29:28 Now you can say username colon annotated, and then open square brackets as if it was like

00:29:33 a list or like a dict or something.

00:29:35 Open square brackets.

00:29:36 And then the first thing that you put there, that's the actual type.

00:29:38 So you will say annotated string.

00:29:40 Ah, okay.

00:29:41 And then you can pass additional metadata afterwards.

00:29:43 And the additional metadata is the thing that you will use to tell FastAPI this will be extracted

00:29:48 from the query parameters or from the cookies or from headers.

00:29:51 Before, and like up to recently in FastAPI, the only way to do that was using the default value of the parameter.

00:29:57 Right.

00:29:57 You would set the default to like a depends or...

00:29:59 Yeah, to depends or equals a cookie or equals header or something like that.

00:30:04 And then FastAPI can take the information from that to give you the data in your function.

00:30:08 But the thing is, if you call that function manually somewhere else, the editor and Python

00:30:13 won't complain that you are not passing some parameter that is required.

00:30:16 And then you're going to end up with some strange value internally that is just for FastAPI.

00:30:20 Right.

00:30:21 Or the type checker complains, you're not passing a depends.

00:30:24 Like, no, I'm passing a string.

00:30:25 That's what it's supposed to be.

00:30:26 But that's...

00:30:26 Yeah, exactly.

00:30:27 Some weird thing like that.

00:30:28 Exactly.

00:30:28 Yeah, okay.

00:30:29 So for those cases, having annotated, like all the type is exactly what it is.

00:30:32 And if it has a default value, it's the actual default value instead of like some strange

00:30:37 internal concept in FastAPI.

00:30:40 And having support for that allows having like much better support for typings, for editors,

00:30:45 autocompletion, inline errors, all these things.

00:30:47 It's reusing the same functions in other places.

00:30:49 And it will also, having support for that in typer, will allow users to have the same

00:30:54 function being used for FastAPI and typer, having the custom metadata necessary for each

00:31:01 one of the parameters for FastAPI and for typer and things like that.

00:31:04 So it's something that is super powerful and super interesting.

00:31:06 Yeah.

00:31:07 I'm going to come in on annotated because I'm excited about it too.

00:31:09 So Pydantic V2, we use annotated for all of our custom types.

00:31:13 So for example, positive int type is just annotated of int.

00:31:17 And then we use the annotated types package, which is some reusable metadata for annotated.

00:31:22 So we would use like positive int is annotated of int and then greater than zero.

00:31:28 And what's even cooler is that will be used by Pydantic, of course.

00:31:33 Hypothesis is going to get support for that really soon.

00:31:36 So it will only pass a positive value in if it sees greater than zero there.

00:31:40 And then typer, I guess, could like, even if it's still based on click, it can go and take

00:31:44 that greater than and infer it as, you know, must be greater than zero.

00:31:47 So I think it was one of the things that typing guys, when they first created annotated, hoped

00:31:52 was going to build a rich network of libraries that interchanged metadata.

00:31:56 It's taken a bit longer than they expected, but we're getting there.

00:31:59 Here the two of you are kind of doing that a little bit, right?

00:32:02 That's cool.

00:32:02 That's really cool.

00:32:03 One of the areas where I feel like typing is a little janky is on ORMs and ODMs.

00:32:08 When you define a class, you say, for example, it's like a SQLAlchemy column, or it's a beanie

00:32:15 column or something like that.

00:32:17 And the type is it's a string column, but really it's a string.

00:32:21 It's not a string column.

00:32:22 And so there's this weirdness of using types to kind of drive behavior.

00:32:28 That's a perfect case for using annotated.

00:32:31 That's what I was thinking.

00:32:31 Yeah.

00:32:31 What it doesn't do is the other case where there is a context where you'd want to get the

00:32:36 column object of some sort rather than the integer in a row.

00:32:40 So it does mean two different things, the kind of dot objects in the Django context.

00:32:44 But yeah, absolutely.

00:32:45 Yeah.

00:32:46 It's there precisely to solve this kind of problem.

00:32:48 And it's also because like currently, as far as I remember, there's no way.

00:32:52 So the thing is that this is all based on something called descriptors.

00:32:55 And it's that when you call like, I don't know, class user dot name, it's actually the

00:33:01 attribute in the class.

00:33:02 But when you create an instance of that user and then say user dot name, that is the attribute

00:33:07 on the actual instance.

00:33:08 And the way that these ODMs or ORMs or these things work is that they have a special way

00:33:14 to say like when someone calls the actual class, this is a different thing than when someone

00:33:18 calls an instance attribute.

00:33:20 Right.

00:33:20 And there's sort of two behaviors.

00:33:22 Yeah.

00:33:22 Yeah.

00:33:23 And like it's super powerful.

00:33:24 That's how SQLAlchemy works.

00:33:26 And it's super powerful because then like all the queries and all the stuff is actually

00:33:29 like consistent with how Python works.

00:33:32 And you can say like greater than or equals to using Python syntax, which is great.

00:33:36 But then currently, as far as I know, there's no way to define that with type annotations

00:33:41 in a standard way.

00:33:42 I think it's something that will probably be improvable.

00:33:45 But I think there's currently no way.

00:33:46 There will probably be a way at some point.

00:33:47 But to be able to say like, hey, this SQLAlchemy column is a column when it's accessed

00:33:53 at the class level.

00:33:54 But this is going to be a string when it's accessed at the instance level.

00:33:57 A scope level in the annotated, you know, the class is this and this.

00:34:01 And it's the instance is that and that.

00:34:03 Yeah.

00:34:03 That's really interesting.

00:34:04 While we're talking types, and I know you both are really big fans because it's such a

00:34:09 central part, both your libraries.

00:34:11 What do you want to see coming?

00:34:13 It feels like this is an area of Python changing fast.

00:34:15 But is there something like they just if they could just and I have another question on types

00:34:19 by the way after that.

00:34:20 If I remember.

00:34:20 So I gave a talk at the typing summit asking for certain things.

00:34:23 So now we're going to test my can I remember PEP numbers challenge, which I'm going to fail

00:34:28 in.

00:34:28 But pep472 is that keyword args to so one option would be to allow keyword arguments to get

00:34:36 item, which would make annotated even more powerful because then you could use keyword arguments

00:34:40 to describe the meaning of your metadata, rather than having to have these kind of identifier

00:34:44 types like greater than one of the big things that I hope we're going to persuade.

00:34:49 So I think one of the things that's happened recently is that everyone gets that runtime

00:34:52 use of type hints is a legitimate thing.

00:34:54 They might not want to do it themselves, but they get that like, it's a legitimate thing

00:34:58 to do.

00:34:58 How much pushback was there when you first came out by Tandic there?

00:35:01 I think we were like the black sheep of Python.

00:35:03 I was a black sheep of Python.

00:35:04 This is supposed to have no meaning.

00:35:05 What are you doing?

00:35:06 You're doing it wrong.

00:35:07 And I think nowadays that's changed and everyone gets it's a real thing.

00:35:10 But so for example, the hash of a union is independent of the order of the members of the union.

00:35:16 That makes sense in the context of static typing, where the union of int float is exactly the

00:35:21 same as a union of float int.

00:35:23 It turns out in static typing, particularly when you're doing coercion, there are some cases

00:35:27 where that is not the case.

00:35:28 And so it's really difficult right now that effectively when you unions are fine on their

00:35:34 own.

00:35:34 But if you have a union, say within a string, the capital string square brackets, it will

00:35:40 the order will be match the order that the first time you call that not what you actually call

00:35:45 unless you use lowercase string when it is the right order, except there's a PR open right

00:35:49 now to break it on string to string as well.

00:35:53 So anyway, we are on lowercase lists as well.

00:35:58 Anyway, so things like that, where I do think that we'll see what happens on that particular

00:36:02 case.

00:36:02 But I feel like the voice of people doing runtime use of types, we're not the only people, are

00:36:07 being heard better.

00:36:08 And yeah, I think things are going to continue to improve.

00:36:11 Yeah, there was a PEP that proposed an optimization for typing that kind of broke the runtime behaviors

00:36:17 of it a little bit for both of y'all.

00:36:18 Yeah, it did in some edge cases.

00:36:20 And that's going to be fixed soon by the successor pep.

00:36:24 Absolutely.

00:36:24 So that's really good.

00:36:26 Generic alias is another thing that kills us internally in Pydantic.

00:36:30 I won't go into all of the details of it.

00:36:31 But yeah, the high-level takeaway is that the typing community seemed happy with the idea

00:36:38 that they might make a change to typing to make it easier for us.

00:36:41 And I think that's also for the Pydantic team to engage better.

00:36:44 And instead of spending ages...

00:36:46 Problem is, right?

00:36:46 You have a problem.

00:36:47 You see a solution in typing.

00:36:49 You submit the PR.

00:36:50 Even if it gets accepted in a week, which it won't, you wait five years before we can

00:36:54 remove the code that deals with the other case.

00:36:56 So it's very tempting not to engage with typing, but just go and write the work around where

00:37:00 we should be better Python citizens and go and submit the PR to see Python to try and fix

00:37:04 it properly.

00:37:05 Yeah.

00:37:05 What's your wish list for typing?

00:37:07 So, well, the first thing is like this thing that I have been trying to work on and like

00:37:11 trying to do to have like better ways to do documentation of the APIs that's also related

00:37:15 to typing and to the annotations.

00:37:17 Like, let's see if I can pull it off.

00:37:19 The other thing is like, it's actually not that necessarily that related to the things

00:37:23 that we have been talking about, but it's quite relevant for the data science and machine

00:37:28 learning community.

00:37:28 That is that there are many, many APIs for many libraries that decorate in some way, some

00:37:35 function.

00:37:36 And then the function is expected to give some types of values to the body of the function

00:37:41 internally, but to be able to receive different types of values.

00:37:45 That sounds a bit abstract, but like that's the core idea that is like replicated across

00:37:51 several libraries.

00:37:52 And this will apply to, for example, to Ray, the distributed machine learning or computing

00:37:56 system, to Dask, to, I think, Dagster also uses something like that.

00:38:00 Monad, this system for deploying workloads and machine learning and things like that, also uses

00:38:06 these types of ideas.

00:38:07 So there are many of these libraries that like the way that they are designed is that you create

00:38:12 some function and then you are going to tell something to call this function.

00:38:16 And then in the function, you say, I want to expect this value.

00:38:19 And instead of you calling all the functions that will generate that value, you tell it like,

00:38:23 hey, distributed system, blah, blah, blah.

00:38:25 Give me this value.

00:38:26 Execute this for me.

00:38:27 But that means that you will have or no type annotations or invalid type annotations or red

00:38:34 squiggly lines in some places or no auto completion or auto completion for the wrong things, just

00:38:39 because there's currently no way to define this specific thing of saying, hey, this function after

00:38:45 being decorated is going to be able to receive a different type.

00:38:49 Oh, yeah.

00:38:50 Than what it's going to give to internal.

00:38:52 So I think that's something that, and it's probably quite challenging and like a big thing to tackle,

00:38:57 but it's something that is replicated across several libraries, in particular for these things

00:39:01 that do distributed processing of data.

00:39:04 I think that's something that will be great to improve.

00:39:07 Does paramspec fix some of that?

00:39:10 It's very close, but the paramspec only does it for being able to sort of copy the params

00:39:18 that come from one function to another.

00:39:20 And actually, I use all that for, for example, for async and for other things to be able to

00:39:24 get like auto completion for the decorated function or for the generated function or things like

00:39:30 that.

00:39:30 And it will probably like the change will probably be somewhere around paramspec to

00:39:35 be able to say like, not just the paramspec, but like this function will not only have the

00:39:40 paramspec, but will receive a modification like this of the parameters.

00:39:45 Almost making paramspec generic.

00:39:50 All right.

00:39:50 One more typing question.

00:39:52 Do you all think typing is going too far with like the generic stuff?

00:39:56 And is it going too much like C++ and C# and Java?

00:39:59 Or is it, is it still, still good?

00:40:02 I think it's, I think the way Python is growing is super interesting because like,

00:40:07 we all have to agree that Python 3.12 is not the same Python 2.7.

00:40:12 Yeah.

00:40:12 It's quite different.

00:40:13 And I think it's a different in a good way.

00:40:15 The users are different and the light, the focus of the runtime is different.

00:40:20 And like the things that we can do with types now, and like the fact that in Python, we can

00:40:26 access these types at runtime, which means like, I don't know, I was always confused with the

00:40:31 term runtime.

00:40:32 It's like, what does that mean?

00:40:33 And it's like, when you execute Python, the same Python code can inspect and like see what

00:40:38 are those types.

00:40:39 That's what FastAPI and Pydantic do.

00:40:40 It's just like seeing like, what are those types?

00:40:42 We can do that in Python.

00:40:43 You cannot do that in things like TypeScript, or you cannot do it in Java.

00:40:48 You cannot do it in many other languages.

00:40:49 You get access to this typing information to be able to do additional things with that, like

00:40:53 validation, data serialization, documentation, all that stuff.

00:40:56 So I think that's, to start, that's super powerful in Python.

00:41:00 The language in Python for typings is not as powerful as, for example, TypeScript.

00:41:06 That is just like so much stuff that you can do with that.

00:41:09 Nevertheless, I feel that in Python is just like, is growing and is growing organically.

00:41:14 And like, we have growing pains, you know?

00:41:16 Like, there are some things that is like, oh, this little thing here is slightly incorrectly

00:41:21 named.

00:41:22 Yeah.

00:41:23 But like, now there's a better way to do that in Python 3.10.

00:41:26 So we don't care much about that slightly incorrect name.

00:41:29 Things like that.

00:41:30 Yeah, I feel like there's some tensions of people who are in the mypy side, and they want

00:41:34 perfect validation of, I want to prove my code hangs together like a static compiler.

00:41:39 And folks like you all who are like, we want to leverage typing to make it behave in interesting

00:41:46 ways.

00:41:46 And maybe that behavior expression doesn't exactly match what it looks statically like, but

00:41:51 it is.

00:41:52 Everybody wants it, but it might trip up mypy.

00:41:55 And I feel like there's this tension between those two things.

00:41:57 That's kind of what I was thinking when I asked that question.

00:41:59 I guess there's a little bit of that, but at the same time, there's, is much less than

00:42:04 you could imagine.

00:42:05 There are so many people that are so close to, you know, core mypy and these things that are

00:42:11 actually very excited about the things that we are doing.

00:42:13 So they're like, you know, like the, it's actually quite friendly, all the communication.

00:42:17 It's just that there is some people that just don't really care about runtime types and

00:42:22 that's fine.

00:42:22 But like, I feel like it's much more, you know, much more closer together and like much more

00:42:28 stronger the relationship, I think.

00:42:30 Yeah.

00:42:30 Yeah.

00:42:30 That's great.

00:42:30 Yeah.

00:42:31 I think actually we've gone in the, we've, typing's got better for someone who's not

00:42:35 like, it's actually got less verbose, cleaner, easier to understand.

00:42:38 You don't have to import union.

00:42:40 You can do pipe operator.

00:42:41 You don't have to import list from typing.

00:42:44 You can use list, which makes complete sense.

00:42:46 Any is an unfortunate one, but I also understand why the any function might, it would not make

00:42:51 sense.

00:42:52 I give up.

00:42:52 I just, I can't deal with this part.

00:42:54 So yeah.

00:42:54 No, in general, I think it's got much better.

00:42:57 I do think that the interchange between runtime, so there's a PEP open now to add to data class

00:43:03 transforms, a converter function.

00:43:06 I forget exactly how it works, but I think that is awareness in the static typing space

00:43:11 that data gets converted when you construct something that looks like a data class.

00:43:15 So no, I think, I think it's really positive.

00:43:18 I think we're incredibly lucky that we're like, I could say TypeScript is the other, is in some

00:43:23 ways the best untyped language typing system.

00:43:25 But the fact that they're not available at runtime means we're, we're killing it.

00:43:29 I think I spoke to someone who maintains a library that does a type analysis at runtime in

00:43:35 TypeScript and all his types are strings and like they're valid TypeScript, but they're

00:43:40 strings.

00:43:40 And that's, you know, he was saying that doesn't matter and it's all fine.

00:43:44 I tend to feel like it probably does a bit.

00:43:46 We're really lucky to have them at runtime.

00:43:48 Then you go to the other end where I've been writing a lot of Rust.

00:43:51 I am like, Rust's great.

00:43:52 It has many advances, but if you want to just get something done and not have to,

00:43:55 think too hard about what the types are, it's really nice.

00:43:58 I write a lot of Python that's untyped when I'm just trying to get something to, something

00:44:01 to work.

00:44:01 I'm not a like, everything must have a type on it kind of person.

00:44:05 So no, I think we're in a really great place.

00:44:06 And I think most of the advantages are actually cleaning it up.

00:44:09 So the new six something, 649, the new generics syntax to me, 695.

00:44:18 There are people who know the names of their numbers of their peps and there's everyone

00:44:25 everyone's saying.

00:44:26 That for me, it cleans up generics, right?

00:44:30 Yes, it's a fundamental change to the language.

00:44:32 Yes, it makes the syntax of a function look a bit more like Rust or something.

00:44:36 But like, if you look at it independently of our experience, it's a heck of a lot more elegant

00:44:41 than importing type var.

00:44:42 All right.

00:44:43 Yeah.

00:44:43 Yeah.

00:44:44 Let me ask you one that's, this is purely theoretical because I don't think it'll get adopted,

00:44:48 but we have int, pipe, none.

00:44:50 We have optional of int.

00:44:51 A lot of languages have question mark for nullable types.

00:44:55 Like it'd be int.

00:44:56 You could even say it like int.

00:44:57 I'm not sure.

00:44:58 Is it an int?

00:44:59 It could be an int.

00:44:59 It might be nullable.

00:45:00 I don't know.

00:45:01 Right?

00:45:01 Or use int as an int.

00:45:03 You just know.

00:45:03 There's no question mark.

00:45:04 And those types, what are your thoughts about null, call us, annual care?

00:45:08 I'm really happy with the new situation and not having the optional that isn't optional.

00:45:12 That's been a problem for a long time.

00:45:14 So not needing to use optional is being able to use pipe none is great.

00:45:19 I actually think one of the things that's going to happen with, particularly with the advent

00:45:23 of the match syntax and with increased use of type dict, we're going to need a new union

00:45:29 type that operates much more like an enum in Rust.

00:45:32 So basically a union that keeps track of which member of the enum you have an instance of.

00:45:38 I keep meaning to build a package to demonstrate what I mean.

00:45:40 And I haven't got around to it, but like if you have a union.

00:45:44 Type dict, which is a legitimate thing to do.

00:45:46 It's effectively impossible without starting to do effectively validation to work out which

00:45:50 member you're on.

00:45:51 So I think we need, and it would be really neat if you could use a match expression to process

00:45:55 each branch of your union.

00:45:57 Sebastian?

00:45:57 You already said everything.

00:45:58 No, but like, you know, like I feel, I feel that way, I was saying that like, I feel

00:46:04 Python is just like growing and like the typing system is growing.

00:46:08 I feel it's growing in a very healthy way because it's not, you know, it's not like just some,

00:46:12 some, some academics hidden in some corners somewhere saying like, this is how it should

00:46:17 be done.

00:46:17 I did my thesis on this type system and here we are.

00:46:19 Yeah.

00:46:19 And then like everyone should just use it.

00:46:21 It's just like a lot of hearing everyone and just receiving the feedback from everyone

00:46:26 and just like growing in the ways that it should grow.

00:46:29 I think that's amazing.

00:46:30 I think like we are, you know, it's like a kind of renaissance of like typing in Python

00:46:35 and like how we can build all these things.

00:46:37 I think that's amazing.

00:46:38 I think it absolutely is.

00:46:39 All right.

00:46:39 I think we're pretty much out of time.

00:46:41 We've used up all the various places we've escaped to at a shutting down conference here.

00:46:44 Final question for you both.

00:46:46 Just, you know, what's your big takeaway?

00:46:47 What's the experience like here at PyCon?

00:46:49 Like how's it been 2023?

00:46:51 For me, it's been amazing.

00:46:52 It's my first PyCon in the US.

00:46:55 Oh, it is.

00:46:55 Yeah.

00:46:55 Like I have never been in a PyCon in the US.

00:46:57 I have been in PyCons in like many other places, but not in the US.

00:47:00 And like I got to see, I got to put faces to so many handles in Twitter and GitHub.

00:47:06 I got to meet you in person.

00:47:08 That's amazing.

00:47:09 Wow.

00:47:09 It's great.

00:47:09 Like a bunch of other people that I only knew, you know, just like on the internet,

00:47:14 a bunch of core developers and like, that's so cool.

00:47:16 They are so cool.

00:47:16 Like I knew they were super cool, but just like, you know, talking on Twitter and like

00:47:20 didn't see me in person.

00:47:21 That's amazing.

00:47:23 It's my favorite part of the whole conference.

00:47:25 It's just the people and the getting together.

00:47:27 Definitely.

00:47:28 I think I attended like two talks.

00:47:31 I was just on the hallways talking to everyone.

00:47:34 You feel the hallway track.

00:47:35 Yeah.

00:47:35 I was all the way on the hallway track.

00:47:38 Awesome.

00:47:38 Well, that's great.

00:47:38 Yeah.

00:47:39 I absolutely love it.

00:47:40 I remember Sebastian and I joined the Language Summit remotely two years ago, the year when

00:47:44 there was no PyCon.

00:47:44 And the most interesting bit of the like four hours Zoom call was the five minutes between

00:47:49 talks when people just chatted.

00:47:50 And I remember then thinking how cool PyCon must be to have that same group of people

00:47:54 like in a room rather than on a Zoom call.

00:47:57 So no, I love it.

00:47:58 I think it's, I've really enjoyed it.

00:48:00 Last year was my first year.

00:48:01 This year is even more fun.

00:48:03 Yeah.

00:48:03 I really enjoy it.

00:48:03 Awesome.

00:48:04 Yeah.

00:48:04 It's been great to meet you both in person.

00:48:06 Meeting you has been the best bit of all.

00:48:07 Thank you very much.

00:48:08 No, no.

00:48:08 It's been really great to spend some time with you all here.

00:48:10 Thanks for coming on the podcast.

00:48:12 Part two now here to wrap things up.

00:48:14 So it's, thanks for taking the time and congrats both on the success of your projects.

00:48:18 They're amazing.

00:48:19 Thanks so much.

00:48:20 Thank you very much.

00:48:21 Thanks for having us.

00:48:21 Thanks for seeing us.

00:48:23 Yeah.

00:48:23 Bye guys.

00:48:24 This has been another episode of Talk Python To Me.

00:48:26 Thank you to our sponsors.

00:48:27 Be sure to check out what they're offering.

00:48:29 It really helps support the show.

00:48:30 Take some stress out of your life.

00:48:32 Get notified immediately about errors and performance issues in your web or mobile applications with

00:48:38 Sentry.

00:48:38 Just visit talkpython.fm/sentry and get started for free.

00:48:43 And be sure to use the promo code talkpython, all one word.

00:48:46 InfluxData encourages you to try InfluxDB.

00:48:49 InfluxDB is a database purpose built for handling time series data at a massive scale for real-time analytics.

00:48:56 Try it for free at talkpython.fm/InfluxDB.

00:49:00 Want to level up your Python?

00:49:01 We have one of the largest catalogs of Python video courses over at Talk Python.

00:49:05 Our content ranges from true beginners to deeply advanced topics like memory and async.

00:49:10 And best of all, there's not a subscription in sight.

00:49:13 Check it out for yourself at training.talkpython.fm.

00:49:16 Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

00:49:20 We should be right at the top.

00:49:22 You can also find the iTunes feed at /itunes, the Google Play feed at /play,

00:49:26 and the direct RSS feed at /rss on talkpython.fm.

00:49:31 We're live streaming most of our recordings these days.

00:49:33 If you want to be part of the show and have your comments featured on the air,

00:49:37 be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

00:49:41 This is your host, Michael Kennedy.

00:49:43 Thanks so much for listening.

00:49:44 I really appreciate it.

00:49:45 Now get out there and write some Python code.

00:49:47 I'll see you next time.

00:49:48 Bye.

00:49:48 Bye.

00:49:48 Bye.

00:49:48 Bye.

00:49:49 Bye.

00:49:50 Bye.

00:49:50 Bye.

00:49:50 Bye.

00:49:51 Bye.

00:49:52 Bye.

00:49:52 Bye.

00:49:52 Bye.

00:49:53 Bye.

00:49:54 Bye.

00:49:54 Bye.

00:49:54 Bye.

00:49:54 Bye.

00:49:54 Bye.

00:49:54 Bye.

00:49:54 Bye.

00:49:54 Bye.

00:49:55 Bye.

00:49:55 Bye.

00:49:55 Bye.

00:49:55 Bye.

00:49:56 Bye.

00:49:57 Bye.

00:49:58 Bye.

00:49:59 Bye.

00:50:00 Bye.

00:50:01 you you Thank you.

