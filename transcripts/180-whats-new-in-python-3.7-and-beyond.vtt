WEBVTT

00:00:00.001 --> 00:00:05.720
The Python core developers recently released Python 3.7 and are now busy planning what's coming in 3.8.

00:00:05.720 --> 00:00:09.800
That makes right now a great time to dig into what's included in Python 3.7

00:00:09.800 --> 00:00:13.640
and see what's on deck for this next great release of CPython.

00:00:13.640 --> 00:00:18.100
On this episode, we have Anthony Shaw back on the podcast to tell us all about it.

00:00:18.100 --> 00:00:22.960
This is Talk Python to Me, episode 180, recorded October 1st, 2018.

00:00:22.960 --> 00:00:42.600
Welcome to Talk Python to Me, a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:00:42.600 --> 00:00:46.680
This is your host, Michael Kennedy. Follow me on Twitter where I'm @mkennedy.

00:00:46.680 --> 00:00:50.420
Keep up with the show and listen to past episodes at talkpython.fm.

00:00:50.420 --> 00:00:52.860
And follow the show on Twitter via at Talk Python.

00:00:53.740 --> 00:00:55.240
Hey everyone, Michael here.

00:00:55.240 --> 00:00:58.200
Just a couple of things to share before we get to our chat with Anthony.

00:00:58.200 --> 00:01:01.440
First, you might notice I sound slightly different this week.

00:01:01.440 --> 00:01:03.820
I've been experimenting with a new audio setup.

00:01:03.820 --> 00:01:06.880
Your feedback on whether this is actually an improvement is welcome.

00:01:06.880 --> 00:01:10.160
Just send me a mention on Twitter via at mkennedy or at Talk Python.

00:01:10.160 --> 00:01:15.760
Second, I recently released a new course and this is one I've wanted to create for a long time.

00:01:15.760 --> 00:01:18.640
It's called Asynchronous Techniques and Examples in Python.

00:01:18.640 --> 00:01:22.460
This is the definitive course on asynchronous programming in Python.

00:01:22.460 --> 00:01:27.520
It starts out right away digging into the asyncio and the magical async and await keywords.

00:01:27.520 --> 00:01:31.780
We also discussed the time-tested techniques such as threading and multiprocessing.

00:01:31.780 --> 00:01:33.380
But we don't stop there.

00:01:33.380 --> 00:01:35.520
Once you're using threads, you need thread safety.

00:01:35.520 --> 00:01:36.120
Covered.

00:01:36.120 --> 00:01:39.400
Want to write some async web apps with Flask using async and await.

00:01:39.400 --> 00:01:40.020
Covered.

00:01:40.020 --> 00:01:46.660
We even discussed some ways to combine these techniques for when you have some mixed CPU-based work and some IO-based work.

00:01:46.840 --> 00:01:52.040
We round out the course with leveraging Cython to make our threaded code go truly fast.

00:01:52.040 --> 00:01:56.160
If you're interested in this course, just visit talkpython.fm/async.

00:01:56.160 --> 00:01:59.460
And if you act quickly enough, you can still grab the early bird discount.

00:01:59.460 --> 00:02:02.500
Now, let's talk Python present and future with Anthony Shaw.

00:02:02.500 --> 00:02:05.460
Anthony, welcome back to Talk Python.

00:02:05.460 --> 00:02:06.160
Hi, Michael.

00:02:06.280 --> 00:02:06.980
It's great to be back.

00:02:06.980 --> 00:02:08.180
Yeah, it's super to have you here.

00:02:08.180 --> 00:02:10.220
It's great to have you on as a regular.

00:02:10.220 --> 00:02:11.420
You're doing so many cool things.

00:02:11.420 --> 00:02:11.740
Thanks.

00:02:11.740 --> 00:02:12.020
Yeah.

00:02:12.020 --> 00:02:17.360
So just to let people know, you were on way back in episode 155 for Practical Steps Moving

00:02:17.360 --> 00:02:22.400
to Python 3 and also in 168 for 10 Security Holes in Python.

00:02:22.400 --> 00:02:23.940
Those were both fun episodes.

00:02:23.940 --> 00:02:26.720
But we're kind of not just upgrading to Python 3.

00:02:26.720 --> 00:02:28.340
We're cutting edge at this point, right?

00:02:28.340 --> 00:02:30.040
Yeah, we're going all the way up to 11.

00:02:31.100 --> 00:02:32.340
This one goes to 11.

00:02:32.340 --> 00:02:32.800
Awesome.

00:02:32.800 --> 00:02:35.180
Well, I'm definitely looking forward to doing that.

00:02:35.180 --> 00:02:40.640
But before we get into all the details of Python 3.7 and 3.8 and the speculation around there,

00:02:40.640 --> 00:02:45.580
let's just talk really quickly about what you do day to day so people know where you're coming from.

00:02:45.580 --> 00:02:45.960
Great.

00:02:45.960 --> 00:02:46.320
Yeah, sure.

00:02:46.320 --> 00:02:48.000
I work at Dimension Data.

00:02:48.000 --> 00:02:50.260
It's a big IT company.

00:02:50.260 --> 00:02:53.880
And I actually work in HR, which might surprise a few people.

00:02:53.880 --> 00:02:58.860
As I came from an R&D background and a couple of years ago, I made a big career change.

00:02:58.860 --> 00:03:00.920
So I focus on learning now.

00:03:00.920 --> 00:03:02.040
Similar to you, I guess.

00:03:02.040 --> 00:03:05.180
And skills development within the organization.

00:03:05.180 --> 00:03:05.580
Yeah.

00:03:05.580 --> 00:03:08.280
And just so people know, that's not like a team of 10, right?

00:03:08.280 --> 00:03:12.080
There's more than 10 people, I think, that take some of these programs you put together and stuff.

00:03:12.080 --> 00:03:12.460
Yeah.

00:03:12.460 --> 00:03:14.880
So we're about 31,000 employees.

00:03:14.880 --> 00:03:19.500
And I've been running a whole bunch of learning programs and stuff like that,

00:03:19.500 --> 00:03:21.320
trying to teach people Python, for example.

00:03:21.320 --> 00:03:27.460
About 4,000 people are learning Python that work for us across the world, which has been fantastic.

00:03:27.460 --> 00:03:29.940
And running a whole bunch of other programs as well.

00:03:29.940 --> 00:03:33.460
We're basically trying to make sure that the skills of the people who work at the company

00:03:33.460 --> 00:03:35.160
are up to date with all the latest technologies.

00:03:35.160 --> 00:03:36.200
Wow, that's really cool.

00:03:36.200 --> 00:03:37.260
And you've done some good write-ups.

00:03:37.260 --> 00:03:39.080
Maybe I'll even link to them in the show notes.

00:03:39.080 --> 00:03:41.240
So that's your day-to-day.

00:03:41.240 --> 00:03:44.640
But then when maybe you're on an airplane or you're traveling,

00:03:44.640 --> 00:03:48.060
you decide to break out some massive open source contribution, something like that?

00:03:48.320 --> 00:03:48.660
Yes.

00:03:48.660 --> 00:03:55.220
So I have to travel quite a lot for my job, which means I spend a lot of time on the planes,

00:03:55.220 --> 00:03:56.100
really quite bored.

00:03:56.100 --> 00:03:59.060
And there's only really so many Marvel movies you can watch.

00:03:59.060 --> 00:04:06.720
So really, I kind of feel some time working on open source projects involved in quite a few at the moment.

00:04:06.980 --> 00:04:08.820
So all of them are Python.

00:04:08.820 --> 00:04:14.440
They were a range of different languages a few years ago, but now I'm 100% Python contributions only.

00:04:14.440 --> 00:04:15.840
So that's been excellent.

00:04:15.840 --> 00:04:23.220
And the Apache Software Foundation just got named as a PSF fellow a couple of months ago, which was awesome.

00:04:23.460 --> 00:04:24.620
Yeah, congratulations on that.

00:04:24.620 --> 00:04:25.240
That's really awesome.

00:04:25.240 --> 00:04:28.040
Only five people per quarter get that honor.

00:04:28.040 --> 00:04:29.380
And so that's a big deal.

00:04:29.380 --> 00:04:29.740
That's cool.

00:04:29.740 --> 00:04:31.580
Yeah, I don't really know what I did to get that.

00:04:31.580 --> 00:04:36.740
But it was really great to be among the amazing list of names of people who are on the list.

00:04:36.740 --> 00:04:37.820
Yeah, that's awesome.

00:04:37.820 --> 00:04:38.700
Cool.

00:04:38.700 --> 00:04:44.220
Well, our topic for today is Python current and beyond, right?

00:04:44.220 --> 00:04:47.260
At least the time of this recording, people go back far enough in time.

00:04:47.260 --> 00:04:49.600
Maybe they'll hit 3.7 or something in the past.

00:04:49.600 --> 00:04:56.220
But we're going to start by talking about what is cool in Python 3.7 people should pay attention to, they should learn about.

00:04:56.220 --> 00:05:00.720
And then we're going to talk about what's coming in the next version of Python 3.8.

00:05:00.720 --> 00:05:02.600
So let's start with Python 3.7.

00:05:02.600 --> 00:05:03.800
Like, is it a big change?

00:05:03.800 --> 00:05:04.460
What do you think?

00:05:04.460 --> 00:05:09.220
I guess you kind of have to bring in the whole history of, well, not the whole history of Python 3.

00:05:09.220 --> 00:05:15.540
But you have to kind of take a bigger lens to this because Python 3 has been out for 11 years now.

00:05:15.540 --> 00:05:17.640
Is it 10 years, 11 years?

00:05:17.640 --> 00:05:18.680
Since 2008, I believe.

00:05:19.380 --> 00:05:23.820
It was just 3,000 days, like a year ago or something like that.

00:05:23.820 --> 00:05:27.600
So yeah, it's been about 10 years.

00:05:27.600 --> 00:05:30.440
But no offense to the developers who worked on it.

00:05:30.440 --> 00:05:33.920
But the first few releases weren't really production ready.

00:05:33.920 --> 00:05:40.460
So 3.0 to 3.3 were really where they introduced a lot of the major changes in Python 3.

00:05:40.460 --> 00:05:42.480
And there were a lot of stability issues.

00:05:42.480 --> 00:05:46.060
And there were memory leaks and stuff like that that needed to be fixed.

00:05:46.060 --> 00:05:47.300
Also performance, right?

00:05:47.300 --> 00:05:49.840
Like a lot of people said, well, I need to do this thing.

00:05:49.840 --> 00:05:52.300
And this thing is like 50% slower in Python 3.

00:05:52.300 --> 00:05:53.640
So I'm not doing it.

00:05:53.640 --> 00:05:53.980
Definitely.

00:05:53.980 --> 00:06:00.280
There's some major changes in Python 3 which made things significantly slower in some of the earlier releases.

00:06:00.960 --> 00:06:07.220
But really, the focus was, let's not just spend 10 years and then ta-da, we've come out with something that's production ready.

00:06:07.220 --> 00:06:10.340
They wanted to get something out there and get the feedback earlier on.

00:06:10.560 --> 00:06:18.680
So even though Python 3 has been out for a decade, I guess the stable releases have only been out for the last four years, five years now.

00:06:18.680 --> 00:06:21.160
So 3.4 was pretty stable.

00:06:21.160 --> 00:06:26.960
But 3.5, definitely, that's where you sort of get picked up by some of the major Linux distributions.

00:06:26.960 --> 00:06:30.500
For example, it starts to get packaged with operating systems and stuff like that.

00:06:30.500 --> 00:06:36.300
Yeah, that's a great point because I feel like 3.5 is really where it was clearly the right choice.

00:06:36.300 --> 00:06:38.580
Like 3.4, there was a debate at that time.

00:06:38.580 --> 00:06:39.960
It was like, well, maybe, maybe not.

00:06:39.960 --> 00:06:41.600
At 3.5, it was like, what are you talking about?

00:06:41.600 --> 00:06:42.420
Come on, let's go.

00:06:42.580 --> 00:06:43.080
Yeah, exactly.

00:06:43.080 --> 00:06:44.960
And then 3.6 comes out.

00:06:44.960 --> 00:06:51.000
So 3.5 included the async await, a lot more functions with asynchronous programming.

00:06:51.000 --> 00:07:01.040
And also 3.6 came out with more async await features, like the generators, for example, async with statements.

00:07:01.040 --> 00:07:03.200
So context managers, basically.

00:07:03.200 --> 00:07:09.360
And the f strings came out in 3.6, which is yet another way of formatting strings in Python, which is pretty cool.

00:07:09.360 --> 00:07:12.020
Because I don't know what, five wasn't enough or I don't know if they were.

00:07:12.680 --> 00:07:17.600
And once you get to use it, actually, it's definitely my favorite way to format strings now.

00:07:17.600 --> 00:07:18.300
I'm with you.

00:07:18.300 --> 00:07:25.860
You know, the problem I run into with f strings is I'm like halfway through a string and I decide, oh, yeah, now I want to put this variable here.

00:07:25.860 --> 00:07:28.740
I'm going to go back to the beginning and put the f and then go back and do it.

00:07:28.740 --> 00:07:31.000
And, you know, I don't know.

00:07:31.000 --> 00:07:34.060
That's something I just got to train myself to put the f at the front more often.

00:07:34.060 --> 00:07:36.080
Yeah, so 3.7 came out.

00:07:36.080 --> 00:07:41.960
And, yeah, I guess really they're an opportunity now where they can start adding some good new features.

00:07:41.960 --> 00:07:44.740
For people, it's not just bug fixes and performance improvements.

00:07:44.740 --> 00:07:47.500
So, yeah, it's been a pretty significant change.

00:07:47.500 --> 00:07:48.580
Yeah, that's right.

00:07:48.580 --> 00:07:54.600
Because Python 3 is really either as close to, you know, same as Python 2 or faster, right?

00:07:54.620 --> 00:08:00.700
There's a lot of performance improvements where the argument used to be, well, I can't switch to Python 3 because it's too slow.

00:08:00.700 --> 00:08:03.760
Now it's, well, if I don't, I'm going to be behind, right?

00:08:03.760 --> 00:08:04.020
Yeah.

00:08:04.020 --> 00:08:11.740
So 3.7 was the first release of 3 that basically across all the benchmarks was quicker than Python 2.7.

00:08:11.740 --> 00:08:14.380
With one exception, which is the startup time.

00:08:14.380 --> 00:08:17.140
But that's still been an ongoing issue.

00:08:18.360 --> 00:08:21.360
Yeah, and it really depends on what kind of apps you're building, whether that matters.

00:08:21.360 --> 00:08:26.700
If you're building, like, a background thing that runs in a queue or a web app, like, who cares about startup time?

00:08:26.700 --> 00:08:29.400
If you're building a little command line app, that might matter, right?

00:08:29.400 --> 00:08:29.680
Yeah.

00:08:29.680 --> 00:08:30.940
But it's still milliseconds.

00:08:30.940 --> 00:08:31.520
It's not.

00:08:33.460 --> 00:08:35.660
It's not .NET or something, right?

00:08:35.660 --> 00:08:35.840
Yeah.

00:08:35.840 --> 00:08:36.620
Not WPF.

00:08:36.620 --> 00:08:42.600
I just want to, like, while we're on this little micro subject of Python 2 to 3, I just want to put it out there one more time.

00:08:42.600 --> 00:08:45.620
Let's all call Python 2 Legacy Python.

00:08:45.620 --> 00:08:48.680
And I think that's going to start to make a little dent with the managers.

00:08:48.680 --> 00:08:50.280
Yeah, we're still using the Legacy Python.

00:08:50.280 --> 00:08:51.140
Can we stop doing that?

00:08:51.140 --> 00:08:54.140
Yeah, it came out in June, which is winter for us.

00:08:54.140 --> 00:08:56.120
So I'm on the other side of the world.

00:08:56.120 --> 00:08:56.980
Yeah.

00:08:56.980 --> 00:08:59.240
So, yeah, it came out in June this year, so 2018.

00:08:59.900 --> 00:09:03.920
The first sort of beta versions came out earlier in the year, sort of February time.

00:09:03.920 --> 00:09:09.100
And there's a couple of alphas out very early on in the new year, this 2018.

00:09:09.100 --> 00:09:12.920
So, yeah, it's been out for, what are we, six months now, nearly.

00:09:12.920 --> 00:09:15.760
So that's, yeah, it's kind of had the chance to pick up speed.

00:09:15.760 --> 00:09:20.320
Obviously, it's not been included with any of the major distributions yet.

00:09:20.320 --> 00:09:25.440
So you have to go out of your way to download and install or upgrade to Python 3.7.

00:09:25.440 --> 00:09:29.760
So I'd say it's not as widely used as 3.6 or 3.5 yet.

00:09:29.760 --> 00:09:31.460
But it's definitely a major step forward.

00:09:31.460 --> 00:09:32.380
Yeah, it definitely is.

00:09:32.380 --> 00:09:38.160
And, you know, if I log into my Ubuntu machines, it's Python 3.6.6, I think, which is already

00:09:38.160 --> 00:09:39.040
really awesome, right?

00:09:39.040 --> 00:09:40.520
That's way better than, too.

00:09:40.520 --> 00:09:42.060
Like, that ships with the operating system.

00:09:42.060 --> 00:09:42.900
So that's really cool.

00:09:42.900 --> 00:09:45.260
But 3.7 has a bunch of great features.

00:09:45.260 --> 00:09:50.840
Now, the reason that I thought, hey, I should have Anthony on the show is because you wrote

00:09:50.840 --> 00:09:56.560
a pretty sweet course on specifically what's new in Python 3.7.

00:09:56.560 --> 00:09:58.840
And it's really quite consumable.

00:09:58.840 --> 00:09:59.680
It's like an hour, right?

00:09:59.680 --> 00:10:01.060
Do you want to just tell us quickly about your course?

00:10:01.060 --> 00:10:02.540
And we'll get into the details of the stuff.

00:10:02.540 --> 00:10:03.000
Yeah, sure.

00:10:03.000 --> 00:10:04.560
So the course is on Pluralsight.

00:10:04.560 --> 00:10:07.680
And it's called What's New in Python 3.7.

00:10:08.400 --> 00:10:13.240
And basically, I go through all of the new features and functions and show you how to

00:10:13.240 --> 00:10:15.700
use them, show you any gotchas and stuff like that.

00:10:15.700 --> 00:10:16.720
It's only about an hour.

00:10:16.720 --> 00:10:19.540
So it's not going to take much of your time to watch.

00:10:19.540 --> 00:10:25.560
But yeah, it's been fun to put it together because, you know, with each alpha and beta

00:10:25.560 --> 00:10:30.740
release, I was running all the upgrades or pretty much just running on a copy of the master

00:10:30.740 --> 00:10:34.320
branch on CPython development for a few months.

00:10:34.320 --> 00:10:35.520
Now that it's on GitHub, right?

00:10:35.520 --> 00:10:36.640
Yeah, it's finally on GitHub.

00:10:36.640 --> 00:10:37.460
Yeah, yeah.

00:10:37.700 --> 00:10:42.480
So it's good to kind of keep on the bleeding edge and also to read all the peps and get

00:10:42.480 --> 00:10:44.100
all the background and details and stuff.

00:10:44.100 --> 00:10:49.480
So I put the course together to condense all of that information down into a way that's

00:10:49.480 --> 00:10:54.500
a bit easier for people to just watch, get a gist of and get going with all the cool new

00:10:54.500 --> 00:10:54.760
stuff.

00:10:54.760 --> 00:10:55.320
Yeah, sweet.

00:10:55.320 --> 00:10:57.200
So we'll link to that in the show notes as well.

00:10:57.200 --> 00:11:03.660
I guess it's worth pointing out, like this came out in June and Python right now is on

00:11:03.660 --> 00:11:06.100
an 18-month shipping schedule.

00:11:07.000 --> 00:11:11.460
not next June, but next Christmas, December or something like that.

00:11:11.460 --> 00:11:13.100
It should be Python 3.8.

00:11:13.100 --> 00:11:13.880
Right.

00:11:13.960 --> 00:11:15.020
So that's the current schedule anyway.

00:11:15.020 --> 00:11:15.380
Yeah.

00:11:15.380 --> 00:11:21.880
So about in around August, maybe September, there is actually a Python 3.8 release schedule

00:11:21.880 --> 00:11:22.320
already.

00:11:22.320 --> 00:11:28.460
I think in about September 2019, we're going to start to see some beta releases of 3.8.

00:11:28.460 --> 00:11:33.500
You can actually test some of the new features already if you go and download from the source.

00:11:33.660 --> 00:11:36.760
If you live at the tip of the master branch.

00:11:36.760 --> 00:11:37.580
Yeah, exactly.

00:11:38.120 --> 00:11:42.020
There was a Python meetup in London last month.

00:11:42.020 --> 00:11:45.660
And I gave a quick lightning talk showing some new 3.8 features.

00:11:45.660 --> 00:11:49.040
And it basically segfaulted halfway through the demo.

00:11:49.040 --> 00:11:52.900
Don't do this in production, Jess.

00:11:52.900 --> 00:11:53.860
Don't run it in production.

00:11:53.860 --> 00:11:54.240
Maybe hold off a little bit.

00:11:54.460 --> 00:11:55.780
It's not even alpha ready yet.

00:11:55.780 --> 00:11:57.260
It's very, very, very early.

00:11:57.260 --> 00:11:58.740
Yeah, that's pretty cool though.

00:11:58.740 --> 00:12:00.120
There's some really great stuff in there.

00:12:00.120 --> 00:12:01.500
But let's start with 3.7.

00:12:01.500 --> 00:12:02.700
We'll talk about 3.8 in a little bit.

00:12:02.700 --> 00:12:08.500
So I guess probably the big star of the show for 3.7 is data classes, right?

00:12:08.500 --> 00:12:14.080
That's the thing that is totally new and pretty obvious that most everyone could use, right?

00:12:14.260 --> 00:12:19.980
Yeah, so Python has always come batteries included, which is in the form of the standard library.

00:12:19.980 --> 00:12:23.240
And in the standard library, there's a whole load of things you can do.

00:12:23.240 --> 00:12:26.640
You can talk to HTTP endpoints.

00:12:26.640 --> 00:12:28.760
You can work with the file system.

00:12:28.760 --> 00:12:33.040
You can even manipulate audio files, like all from the standard library.

00:12:33.040 --> 00:12:35.260
There's all this great functionality built in.

00:12:35.260 --> 00:12:43.900
And really, there's been a bit of a gap in terms of working with data structures, like APIs, for example,

00:12:43.900 --> 00:12:45.740
or working with document databases.

00:12:45.740 --> 00:12:50.080
The gap's been filled by a couple of third-party packages.

00:12:50.080 --> 00:12:58.720
Django, for example, has its kind of built-in ORM, which helps you basically create a class called a Django model.

00:12:58.720 --> 00:13:01.200
And you can have attributes on the class.

00:13:01.200 --> 00:13:06.020
And then when you save that to a database, it automatically creates all the fields and stuff for you.

00:13:06.020 --> 00:13:08.060
So Django is not the only one to do that.

00:13:08.060 --> 00:13:09.580
There's lots of other ways of doing it.

00:13:09.580 --> 00:13:13.780
There's also packages like attrs, A-T-T-R-S.

00:13:13.780 --> 00:13:17.220
which is great, which does a very similar thing.

00:13:17.220 --> 00:13:20.740
But the concept is that you have a class in Python.

00:13:20.740 --> 00:13:23.120
You put some fields on it.

00:13:23.120 --> 00:13:27.920
And basically, you can use that to represent data that's in some other system.

00:13:28.120 --> 00:13:34.360
So that could be an API you're talking to or a database or it could be a memory store, for example.

00:13:34.360 --> 00:13:37.820
So it's a whole bunch of border plate code you have to create.

00:13:37.820 --> 00:13:42.980
If you do this from hand, you have to create all the Dunder methods that you want to use.

00:13:42.980 --> 00:13:48.140
So Dunder init, for example, the Dunder EQ, Dunder Reper, Dunder STR, etc.

00:13:48.400 --> 00:13:48.800
Right.

00:13:48.800 --> 00:13:53.600
So it seems like you're kind of done when you've done the Dunder init and you put your fields in there.

00:13:53.600 --> 00:14:00.240
But if you're going to, say, try to hash those things or compare them or sort them or you want them read only,

00:14:00.240 --> 00:14:07.020
all of those things require a pretty good understanding of the Python data model and the magic methods and all that kind of stuff.

00:14:07.140 --> 00:14:11.320
And data classes are just, you know, frozen equals true type thing.

00:14:11.320 --> 00:14:11.780
Yeah.

00:14:11.780 --> 00:14:13.920
So there's some great features in data classes.

00:14:13.920 --> 00:14:20.400
So really what you have to do is you create a new class and that implements a data class.

00:14:20.400 --> 00:14:25.360
And within that, then you basically have attributes on the class.

00:14:25.360 --> 00:14:27.280
So these are class level attributes.

00:14:27.280 --> 00:14:30.200
You have to give them type annotations.

00:14:30.200 --> 00:14:31.480
Otherwise, they .gitignored.

00:14:31.480 --> 00:14:36.500
If you're not aware what type annotations are, it's a colon after the variable name.

00:14:36.500 --> 00:14:38.120
And then the type you want to use.

00:14:38.120 --> 00:14:45.020
But there's another change in type annotations in 3.7 as well, which we'll come back to maybe later.

00:14:45.020 --> 00:14:48.200
And basically, you put the fields on there and then you're done.

00:14:48.200 --> 00:14:51.060
And then you can basically call that class.

00:14:51.060 --> 00:14:56.560
You can call the initializer or the constructor on the class and pass it all the fields that you've assigned.

00:14:56.560 --> 00:15:00.380
And then there's a whole bunch of really cool features you can use.

00:15:00.380 --> 00:15:02.340
For example, you can set default values.

00:15:02.340 --> 00:15:04.380
You can have default factory values.

00:15:04.560 --> 00:15:09.000
You can have it implements done the EQ for you, done the rep, done the STR.

00:15:09.000 --> 00:15:17.600
So basically, it just gets rid of a lot of boilerplate of having a class which basically just stores data and represents some of that kind of data structure.

00:15:17.600 --> 00:15:18.520
Yeah, it's really sweet.

00:15:18.520 --> 00:15:22.220
And that initializer, it writes that for you, right?

00:15:22.220 --> 00:15:23.820
Yeah, it writes everything for you.

00:15:23.940 --> 00:15:28.780
So all you need to do is declare the class and sign the fields and then you're done.

00:15:28.780 --> 00:15:29.240
That's cool.

00:15:29.240 --> 00:15:30.120
Can you inherit them?

00:15:30.120 --> 00:15:31.720
Can you create like a hierarchy of data classes?

00:15:31.720 --> 00:15:32.820
You can.

00:15:34.260 --> 00:15:35.360
I'm not saying you should.

00:15:35.360 --> 00:15:35.460
I'm not saying you should.

00:15:35.460 --> 00:15:36.480
I'm just wondering if you can.

00:15:36.480 --> 00:15:37.640
You definitely can.

00:15:37.640 --> 00:15:40.100
And there's a lot of reasons why you want to do that.

00:15:40.100 --> 00:15:53.320
Now, if you want to inherit from a base class, it's important to note that within data classes, you can have fields with default values and fields with basically require a value.

00:15:53.320 --> 00:16:05.720
So if you mix those things together, so if you have a base class that has both non-default and default fields and then you have a inherited class, you can't mix them in the inherited class.

00:16:05.720 --> 00:16:12.680
This is probably one of the bigger limitations of the data classes package is to do with the way that it builds the done the init method.

00:16:12.680 --> 00:16:17.940
But it's, yeah, that's pretty, I guess, a bit of an edge case, but it's something to watch out for.

00:16:17.940 --> 00:16:18.900
Yeah, that's cool.

00:16:18.900 --> 00:16:29.520
And so if I want to have some kind of check in my initializer, like this number has to be between 0 and 10, but it's written that for me, like where does that happen?

00:16:29.520 --> 00:16:31.140
Yeah, so you can do it in a couple of places.

00:16:31.140 --> 00:16:33.280
One would be a post init method.

00:16:33.280 --> 00:16:41.540
So after the auto-generated dunder init has been called, you can have your own method which does extra stuff at the end.

00:16:41.540 --> 00:16:44.100
So that could be a value check, for example.

00:16:44.100 --> 00:16:45.920
It doesn't do type checking.

00:16:46.060 --> 00:16:56.440
So even though it uses type annotations, I guess the Pythonic way of doing it is that they're just a friendly reminder of the type and they're not guarded in any way.

00:16:56.440 --> 00:17:01.740
They're meant for linting and like build time checks, not run time checks, right?

00:17:01.740 --> 00:17:02.560
Yeah, exactly.

00:17:02.560 --> 00:17:07.480
Another great feature is that you can use, basically you can create immutable types.

00:17:07.600 --> 00:17:11.540
So by default, they're mutable, which means you can change the values.

00:17:11.540 --> 00:17:18.980
You can also create immutable types by setting frozen equals true when you basically instantiate them.

00:17:18.980 --> 00:17:24.020
The frozen basically means that they're immutable, you can't change their values.

00:17:24.020 --> 00:17:28.240
And also they'll implement a dunder hash method as well.

00:17:28.240 --> 00:17:28.800
So they're hashable.

00:17:28.920 --> 00:17:31.140
So you can use them in things like sets.

00:17:31.140 --> 00:17:34.860
Also, you can use them as dictionary keys, which is pretty cool.

00:17:34.860 --> 00:17:41.900
Yeah, that's really cool because you shouldn't be able to put a thing into the dictionary and then change the value of it and then make it no longer have the same key.

00:17:41.900 --> 00:17:47.960
That would definitely drive you insane, which is what it effectively means if the hash value changes, right?

00:17:48.160 --> 00:17:53.520
Yeah, so it's a really cool way of creating more complex dictionary keys, I guess.

00:17:53.520 --> 00:17:59.240
And also moving away from just representing everything in dictionaries all the time.

00:17:59.240 --> 00:18:11.300
I think when you're working with APIs and stuff like that and you're passing data around, it's convenient to just stick with dictionaries because you don't have to worry about what field you have and what types they are, etc.

00:18:11.640 --> 00:18:19.160
But it's definitely nicer and it's also a lot more testable to introduce a bit more concreteness, I guess, to the types.

00:18:19.160 --> 00:18:19.860
Yeah, it's cool.

00:18:19.860 --> 00:18:23.420
And data classes kind of makes that less effort to do so correctly.

00:18:23.420 --> 00:18:24.420
Yeah, really easy.

00:18:24.420 --> 00:18:30.380
This portion of Talk By The Dermade is brought to you by Tidelift.

00:18:30.380 --> 00:18:32.840
Open source software is everywhere.

00:18:32.840 --> 00:18:40.280
How can we as a community ensure that the open source software we rely upon continues to get even more awesome and more dependable?

00:18:40.640 --> 00:18:43.460
Tidelift believes the solution is hiding in plain sight.

00:18:43.460 --> 00:18:44.900
Pay the maintainers.

00:18:44.900 --> 00:18:48.120
They're dedicated to creating an effective way to do just that.

00:18:48.120 --> 00:18:56.100
And today, they're excited to share that they've reached over $1 million in committed payments for maintainers available via the Tidelift platform.

00:18:56.100 --> 00:18:58.760
And yes, that includes Python maintainers.

00:18:58.760 --> 00:19:03.600
Income for a project grows based on usage, not the number of hours spent on the project.

00:19:03.600 --> 00:19:07.500
So you can build significant income around your open source projects.

00:19:07.860 --> 00:19:14.940
Tidelift is offering a guaranteed minimum $10,000 payout over the next 24 months to select projects in the Python ecosystem.

00:19:15.520 --> 00:19:21.640
If you maintain a Python project, visit talkpython.fm/Tidelift to find out if your project is included.

00:19:21.640 --> 00:19:24.440
That's talkpython.fm/Tidelift.

00:19:26.580 --> 00:19:34.840
The next one doesn't actually sound very exciting to me, but I'm sure it's super important, is that the locales and UTF-8 got a little bit of a change, right?

00:19:34.840 --> 00:19:35.740
What's the story around that?

00:19:35.740 --> 00:19:37.980
How much do we need to worry about it?

00:19:37.980 --> 00:19:41.220
I think we won't spend too much time on this because it's really confusing.

00:19:42.100 --> 00:19:44.120
Any form of encoding is confusing.

00:19:44.120 --> 00:19:45.140
It's super confusing.

00:19:45.140 --> 00:19:45.560
Yeah.

00:19:45.560 --> 00:19:56.220
So a local means it's, I guess, the settings on your operating system, which describe what country you're from, for example, and the way you like things to be represented.

00:19:56.220 --> 00:19:57.440
So, you know, in...

00:19:57.440 --> 00:20:02.740
Like, digit grouping or the order of month, date, year when you print out a date, things like that?

00:20:02.740 --> 00:20:03.060
Yeah.

00:20:03.060 --> 00:20:14.420
So, like, in mainland Europe, most countries would represent the number 1,000 with 1.000, whereas in the UK and the US, there would be 1,000.

00:20:14.420 --> 00:20:18.400
So that's one change, I guess, and that would be in the locale.

00:20:18.400 --> 00:20:25.800
Other ones would be the encoding type, which is where UTF-8 comes in, the keyboard mapping, and there's a whole bunch of other things.

00:20:25.980 --> 00:20:35.420
So, basically, there's a default, which is the sort of NCC locale, which was default like 20 years ago, maybe.

00:20:35.420 --> 00:20:41.080
But, you know, since computing has moved on a bit and we've had to support more countries than just the US.

00:20:41.080 --> 00:20:48.060
So I would like to think that this is like the world going, let's just, let's accept everybody and let's support all of those languages.

00:20:48.060 --> 00:20:50.300
But how much of this has to do with emojis?

00:20:50.300 --> 00:20:53.520
It definitely helps with emojis.

00:20:55.360 --> 00:20:56.840
And hopefully that's not the main...

00:20:56.840 --> 00:20:58.400
My thumbs up is a square, come on.

00:20:58.400 --> 00:21:00.440
Hopefully that's not the main driver.

00:21:00.440 --> 00:21:03.460
But yeah, there's quite a few reasons.

00:21:03.460 --> 00:21:17.620
Now, I guess Python 2 doesn't really, or say legacy Python, this problem is a bit more invisible because they use byte strings by default, whereas in Python 3, we use unicode strings by default.

00:21:17.880 --> 00:21:30.360
So I guess the thing is, if you're reading from a shell pipe, for example, so you want to pipe the output of one command into your Python script, then Python will look at the locale.

00:21:30.360 --> 00:21:35.440
So look at the operating system to see, you know, what settings you've got locally.

00:21:35.440 --> 00:21:40.000
Now, the problem is that not everyone configures their operating system correctly.

00:21:40.000 --> 00:21:47.180
There's also other scenarios like people creating Docker containers and not bothering to set the locale.

00:21:47.960 --> 00:21:48.220
Exactly.

00:21:48.220 --> 00:21:49.700
Like all the cloud stuff, right?

00:21:49.700 --> 00:21:50.440
Yeah.

00:21:50.440 --> 00:21:51.160
All the cloud stuff.

00:21:51.160 --> 00:21:53.120
You just fire it up and you're like, oh, look, it works.

00:21:53.120 --> 00:21:59.020
But I passed in my data file, which was in one locale, and I tried to read it in another, and there it went.

00:21:59.160 --> 00:21:59.440
Exactly.

00:21:59.440 --> 00:22:07.060
So if you just had that set to the, I guess, the most basic one, which would be the NCC, then that would not be with UTF-8.

00:22:07.060 --> 00:22:10.700
So Unicode would not work by default.

00:22:10.700 --> 00:22:21.380
So basically, in Python 3.7, they've made more assumptions about people misconfiguring their operating system to make it more friendly for Unicode.

00:22:21.620 --> 00:22:22.060
Nice.

00:22:22.060 --> 00:22:26.640
So the next one that you have on your list, I think, is really interesting.

00:22:26.640 --> 00:22:30.480
And it's interesting because I'm like, oh, this is super.

00:22:30.480 --> 00:22:32.140
This is not like, why would I ever use it?

00:22:32.140 --> 00:22:32.980
I would never use this.

00:22:32.980 --> 00:22:33.660
What is this about?

00:22:33.660 --> 00:22:36.280
And then at the end, I'm like, oh, no, this is really useful.

00:22:36.280 --> 00:22:37.720
And I feel like I really learned something.

00:22:37.720 --> 00:22:39.280
And I always love it when that happens.

00:22:39.280 --> 00:22:41.460
So the next one is breakpoint, right?

00:22:41.460 --> 00:22:44.720
We used to import PDB, and we'd do a set trace thing.

00:22:44.720 --> 00:22:49.520
Or we would fire up PyCharm or Visual Studio Code or something and just click in the side.

00:22:49.520 --> 00:22:51.440
So why does Python need a breakpoint?

00:22:51.440 --> 00:22:55.120
Is it just like an alias for PDB set trace?

00:22:55.120 --> 00:22:56.120
Yes and no.

00:22:56.120 --> 00:23:02.380
So Python 3.7 introduces a new built-in function called breakpoint.

00:23:02.380 --> 00:23:11.240
So if you just write breakpoint, open, close, parentheses, anywhere in your code, when that line executes, it will jump into a debugger.

00:23:11.240 --> 00:23:16.080
By default, that will be the one that comes in the standard library called PDB.

00:23:16.220 --> 00:23:28.020
So anyone who's done debugging in Python today, I guess, would have learned that to jump into a debugger, you basically type import PDB semicolon.

00:23:28.020 --> 00:23:29.340
Wait, wait, wait.

00:23:29.340 --> 00:23:29.920
What did you say?

00:23:29.920 --> 00:23:32.060
Semi-colon.

00:23:32.620 --> 00:23:33.500
Oh my gosh.

00:23:33.500 --> 00:23:33.820
All right.

00:23:33.820 --> 00:23:34.540
Yeah.

00:23:34.540 --> 00:23:36.720
So you can put it on one line and comment it out really easily, right?

00:23:36.720 --> 00:23:37.160
Yeah.

00:23:37.160 --> 00:23:43.300
So basically, to insert a breakpoint in Python requires two separate statements.

00:23:43.780 --> 00:23:52.260
And having two lines of code to do a breakpoint kind of is confusing because then you've basically just changed your code in the way that you didn't really need to.

00:23:52.260 --> 00:24:02.220
It's also, I guess, not super intuitive for people coming from other languages, people who are just used to working in an IDE and clicking on the red circle on the left-hand side.

00:24:02.780 --> 00:24:03.940
You know, how do you do that in Python?

00:24:03.940 --> 00:24:09.840
How do you step into a breakpoint and work in a debugging console within Python?

00:24:09.840 --> 00:24:13.100
So what they've introduced is this new built-in function.

00:24:13.100 --> 00:24:17.980
By default, it will just call import PDB, PDB.setTrace.

00:24:17.980 --> 00:24:21.440
So it behaves the same way that you would expect.

00:24:21.440 --> 00:24:22.680
But you don't have to write a semicolon.

00:24:22.680 --> 00:24:23.240
That's better.

00:24:23.240 --> 00:24:24.100
Yeah, exactly.

00:24:24.100 --> 00:24:31.840
And it doesn't cause the linter to throw up its arms in anger that you've dared to include a semicolon in your code.

00:24:31.840 --> 00:24:35.200
And so if that's all it was, I don't think actually it has that much value.

00:24:35.200 --> 00:24:38.600
I'm not against having the language, but it's not that huge of a thing.

00:24:38.600 --> 00:24:41.720
But then what if I don't want to use PDB?

00:24:41.720 --> 00:24:42.800
Like, I don't like it.

00:24:42.800 --> 00:24:48.400
There's other, even in the terminal, there's other nice sort of semi-graphical debuggers that are pretty cool, right?

00:24:48.400 --> 00:24:57.880
Yeah, so what it actually does is it will eventually call breakpoint hook, which is a global variable within the sys module.

00:24:57.880 --> 00:25:02.260
And like I said, by default, that's set to PDB.setTrace.

00:25:02.260 --> 00:25:04.100
But you can change it to something else.

00:25:04.100 --> 00:25:09.660
So there are loads of other debuggers of Python, which are a lot more friendly to use.

00:25:09.660 --> 00:25:12.980
Also, there's browser-based ones like WebPDB, for example.

00:25:13.140 --> 00:25:22.580
So WebPDB, when you hit that instead of as your breakpoint, it'll actually pause the code and it'll actually start up a little web server.

00:25:22.580 --> 00:25:26.000
And you can open up your browser and you can navigate to it.

00:25:26.000 --> 00:25:35.740
And it's just a lot easier to see and explore through the local scope and the global scope in a browser with a whole tree and everything than it is to do it in a little text console.

00:25:35.740 --> 00:25:36.540
Yeah, that's awesome.

00:25:36.540 --> 00:25:42.760
And basically, the breakpoint lets you customize what debugger gets called when you type breakpoint open close parentheses.

00:25:43.060 --> 00:25:44.960
Yeah, so you can do it either in code.

00:25:44.960 --> 00:25:49.020
So in Python, you can change the value of sys.breakpoint hook.

00:25:49.020 --> 00:25:54.720
Or alternatively, you can set it using an environment variable, which is also pretty cool.

00:25:54.720 --> 00:26:06.360
So if, for example, if you wanted to have breakpoints in a certain part of your code because you wanted to debug something that was running across multiple machines,

00:26:06.660 --> 00:26:18.140
and one of the debuggers would be a local one and one of them might be a remote one, then you could have an environment variable set to basically change which debugger you want to use whenever breakpoint gets called.

00:26:18.140 --> 00:26:19.140
Yeah, that's pretty awesome.

00:26:19.140 --> 00:26:20.320
So even remote debugging.

00:26:20.320 --> 00:26:21.100
I love it.

00:26:21.100 --> 00:26:21.700
Yeah, it's great.

00:26:21.740 --> 00:26:22.600
I think it's a great feature.

00:26:22.600 --> 00:26:22.940
Yeah.

00:26:22.940 --> 00:26:24.780
The next one is pretty cool.

00:26:24.780 --> 00:26:28.820
So time seems pretty accurate in Python already.

00:26:29.360 --> 00:26:37.460
So even like if I subtract two date times and I get a time delta, there's a lot of accuracy to like dt.total seconds or whatever it is.

00:26:37.460 --> 00:26:41.740
But in Python 3.7, there's more seconds or more parts of seconds.

00:26:42.080 --> 00:26:44.820
Yeah, this one really confused me when I was doing the research.

00:26:44.820 --> 00:26:49.160
I think anyone who's worked with time accuracy, this would totally make sense.

00:26:49.160 --> 00:26:59.100
But if you have put it in the I don't really care, I just want the time and it sounds pretty accurate, camp, which is where I was definitely from.

00:26:59.100 --> 00:27:06.820
Then when the announcement came that they were introducing these nanosecond resolution time functions, it's like, okay, great.

00:27:06.820 --> 00:27:10.240
Why do I need that much accuracy in my application?

00:27:11.200 --> 00:27:20.260
So basically what they've changed in 3.7 is they've introduced some new functions into the time standard library module.

00:27:20.260 --> 00:27:27.080
And they have the append xdunda underscore ns for nanoseconds.

00:27:27.080 --> 00:27:31.300
And basically you've got a lot more accurate representation of time.

00:27:31.300 --> 00:27:31.540
Right.

00:27:31.540 --> 00:27:35.980
So it's not like time now returns better numbers.

00:27:35.980 --> 00:27:38.200
You have to call time underscore ns, right?

00:27:38.200 --> 00:27:38.740
Yeah.

00:27:38.740 --> 00:27:40.220
So it's a separate function.

00:27:40.580 --> 00:27:41.380
The different functions.

00:27:41.380 --> 00:27:46.640
And for whatever reason, the old functions that would give you the time epoch.

00:27:46.640 --> 00:27:50.460
So the time epoch was the 1st of January 1970.

00:27:50.460 --> 00:27:53.000
Apparently nothing happened before then.

00:27:53.000 --> 00:27:55.840
But that's basically the beginning of time.

00:27:55.840 --> 00:28:00.020
In Python, it'll give you a floating point number back.

00:28:00.020 --> 00:28:05.960
And anyone who's worked with floating points before will know there can be all sorts of inaccuracies.

00:28:05.960 --> 00:28:11.960
So the number of seconds since the 1st of January 1970 is the major number.

00:28:11.960 --> 00:28:16.000
And then the actual floating point itself is the parts after that.

00:28:16.440 --> 00:28:18.540
So it's, you know, the milliseconds, for example.

00:28:18.540 --> 00:28:22.200
Now, the problem is that you get all sorts of rounding issues.

00:28:22.200 --> 00:28:24.200
And also they're not particularly accurate.

00:28:24.200 --> 00:28:27.300
So it's not necessarily in milliseconds.

00:28:27.320 --> 00:28:33.360
It's almost like the closest number that it could find depending on the operating system and the CPU that you're using.

00:28:33.360 --> 00:28:38.080
So there can be these gaps and issues with accuracy in Python.

00:28:38.080 --> 00:28:44.340
Anyone who's used Python before to try and measure time very accurately will probably know about these limitations.

00:28:44.340 --> 00:28:48.580
So in 3.7, they've introduced a new nanosecond function, which is awesome.

00:28:48.580 --> 00:28:53.420
And it will give you that in basically a long, long integer, which is the Python integer.

00:28:53.660 --> 00:28:56.160
Nice. Well, I know that in that there's a time NS.

00:28:56.160 --> 00:28:59.700
What else are there other underscore NS functions I can use?

00:28:59.700 --> 00:29:01.240
It says get time NS.

00:29:01.240 --> 00:29:04.700
There's set time NS, which you can only use in certain situations.

00:29:04.700 --> 00:29:06.780
And there was a couple of others as well.

00:29:06.780 --> 00:29:07.940
But those were the major ones.

00:29:07.940 --> 00:29:08.440
Yeah, nice.

00:29:08.440 --> 00:29:13.580
For this next one, what do you think, before we get into the details of what's new, let's just talk about type annotations.

00:29:13.580 --> 00:29:19.920
You hinted at this in the data classes bit because it's very interesting that it's even required, although not checked at runtime.

00:29:19.920 --> 00:29:21.980
How do you feel about type annotations?

00:29:21.980 --> 00:29:30.820
So I haven't really used them very much up until 3.7 for exactly the reason that we'll talk about this next feature, actually.

00:29:30.820 --> 00:29:34.980
So in 3.6, they're kind of a bit clunky to use.

00:29:35.220 --> 00:29:43.960
If you want to represent anything remotely complicated, other than just a string or an int, you might have extra code you have to add to your Python modules.

00:29:43.960 --> 00:29:45.640
I think it's just cumbersome.

00:29:45.640 --> 00:29:48.060
And I haven't got a huge amount of value out of it so far.

00:29:48.060 --> 00:29:48.820
So I think...

00:29:48.820 --> 00:29:49.400
Right.

00:29:49.400 --> 00:29:56.120
If you want to say a list, you'd have to say import list from typing like capital L list, not lowercase l list, things like that, right?

00:29:56.120 --> 00:30:06.280
Yeah, because a lot of my code that I would write would return a tuple, for example, and the first entry would be an integer and the second one would be a dictionary.

00:30:06.280 --> 00:30:09.040
And in the dictionary, then there'd be a certain structure.

00:30:09.040 --> 00:30:13.860
And by the time you've had to describe all of that, it's just such a pain.

00:30:13.860 --> 00:30:15.920
And it adds so much code to your...

00:30:15.920 --> 00:30:22.140
And the type annotations themselves, the way to represent complex types is not particularly intuitive.

00:30:22.140 --> 00:30:27.240
And if you're not familiar with type annotations either, then it's quite a bit of a blocker.

00:30:27.240 --> 00:30:27.500
Yeah.

00:30:27.500 --> 00:30:32.000
You know, my take on them is I really like them, but I don't think they belong everywhere.

00:30:32.000 --> 00:30:35.140
But I really love type annotations on the boundaries.

00:30:35.140 --> 00:30:44.460
So if I have like a data access layer and I've got some functions you call, like those functions you call, I love to put like annotations on, well, you get a list of these things back.

00:30:44.460 --> 00:30:47.660
Or this one could be an optional user because they might not exist in the database.

00:30:48.400 --> 00:30:53.120
And then that kind of flows enough through the editors for me that like everything else kind of picks it up.

00:30:53.120 --> 00:30:58.500
But I don't turn it into like C# and put, you know, types on everything that exists, right?

00:30:58.500 --> 00:30:59.160
Yeah.

00:30:59.160 --> 00:31:11.560
One of the other big limitations is that if you're, you know, the type is actually a class that you've declared somewhere, then you have to import that in order to add it as an annotation.

00:31:11.560 --> 00:31:12.200
Yes.

00:31:12.200 --> 00:31:12.520
Yeah.

00:31:12.520 --> 00:31:15.420
And that's partly what drove the changes for 3.7, right?

00:31:15.420 --> 00:31:29.260
Like, so the place that made me the most crazy was it cannot be solved in the most straightforward way is that I have like, say, some kind of method on a class, like a class method on a class that returns an instance of that class.

00:31:29.260 --> 00:31:35.300
I cannot say in the type system, it returns that class because it's not yet defined.

00:31:35.300 --> 00:31:45.840
I mean, you could use like the string sort of cheating style, but you can't, you have to go realize there's this other way to like talk about it when it's not important and it's not as well as enforced and so on.

00:31:45.920 --> 00:31:46.020
Yeah.

00:31:46.020 --> 00:31:57.620
So the example I use in the course is, is sort of fictional, but you know, you could have a theater class, for example, and then in the theater, it has a number of seats and you have a seat class, which is in a separate file.

00:31:57.620 --> 00:32:07.140
So in a separate submodule, and then you've got an attribute on the seat, which says which theater it belongs to, or you've got an attribute in the theater, which says how many seats there are.

00:32:07.140 --> 00:32:08.620
And you can reference the seats.

00:32:08.620 --> 00:32:16.940
Now, in order to do that as a type annotation, you need to import either one from each other, which creates a circular import, which Python is pretty good at handling.

00:32:16.940 --> 00:32:30.180
It's not, it's not as bad as it was in C, but what it's kind of led to is kind of similar to what you see in Java and C#, which is the first, you know, 30 lines of every file is just import statements.

00:32:30.620 --> 00:32:42.160
Which is a bit of a limitation really, because you're not using them for anything other than to add a type hint to the method in terms of what it returns or what it expects as parameters.

00:32:42.160 --> 00:32:43.520
You're not doing anything with it.

00:32:43.520 --> 00:32:47.820
And the imports obviously, you know, add quite a bit of time as well.

00:32:47.820 --> 00:32:49.460
It slows the application down.

00:32:49.460 --> 00:32:51.240
It's not a compile time thing.

00:32:51.240 --> 00:32:52.180
It's a runtime thing.

00:32:52.260 --> 00:33:04.100
So when you import all those things to just declare, here is the return type, that actually slows down the startup of that program, because now it's doing more stuff just to get to that one function.

00:33:04.100 --> 00:33:04.500
Yeah.

00:33:04.500 --> 00:33:05.960
Yeah, exactly.

00:33:05.960 --> 00:33:06.420
All right.

00:33:06.420 --> 00:33:08.040
So what's 3.7 add for us?

00:33:08.040 --> 00:33:09.900
Like, how does it change this or make it better?

00:33:09.900 --> 00:33:19.920
So what they've introduced is delayed evaluation type annotations, which is a very fancy way of saying that.

00:33:19.920 --> 00:33:24.540
Basically, what happens is when your code gets parsed.

00:33:24.540 --> 00:33:36.280
So in Python, to create the, I guess, the executable code, the Python files, the text files, or the code that you've given it needs to be parsed first, and then it needs to be compiled.

00:33:36.500 --> 00:33:48.580
So at the parser stage, if you've imported from Dunder future annotations, and it will enable these delayed evaluations, then what it does is it goes and looks at all your type hints.

00:33:48.580 --> 00:33:54.280
And if you'd imagine, let's say you've got a method, and you want to set the return type.

00:33:54.280 --> 00:33:59.380
So you do a colon, and then the type hint, the type that you want to return.

00:33:59.380 --> 00:34:05.620
Basically, what the parser will do is equivalent to just putting double quotes either side of that name.

00:34:05.620 --> 00:34:12.220
So it's basically a string literal as a type hint instead of the actual reference to the type.

00:34:12.220 --> 00:34:14.200
Right, which already works in the previous version.

00:34:14.200 --> 00:34:21.380
Like, you can do that, sort of put it in a quote, and that actually works for, say, like, the class self-reference thing I talked about.

00:34:21.380 --> 00:34:24.560
But then you don't get, like, say, refactoring help and things like that, right?

00:34:24.560 --> 00:34:28.360
Yeah, so it causes issues with IDEs and other things like that.

00:34:28.480 --> 00:34:32.580
So basically what this does is it supports a lot of stuff you get in IDE.

00:34:32.580 --> 00:34:37.240
So the IDE would know, or should know, how to import those and reference them.

00:34:37.240 --> 00:34:40.300
But it doesn't slow down your application at runtime.

00:34:40.300 --> 00:34:45.660
And it's a lot easier to use because you don't have to worry about all the imports and things like that.

00:34:45.880 --> 00:34:46.620
Yeah, very interesting.

00:34:46.620 --> 00:34:56.280
The IDEs and the linters, they know how to still check for those things, even though Python at execution time doesn't necessarily do the imports, right?

00:34:56.480 --> 00:35:00.260
Yeah, it basically pushes the problem down the path a bit, though.

00:35:00.260 --> 00:35:00.800
Okay.

00:35:00.800 --> 00:35:12.780
Because if you actually want to use the type annotations to find the concrete types, then you need to call a special new function called get type hints.

00:35:12.780 --> 00:35:15.840
And you need to pass it the local and global scope.

00:35:16.740 --> 00:35:27.760
And when you call that function, the thing, the type hints that you, if they'd referenced a class, for example, then you would have need to imported that class by that point.

00:35:27.760 --> 00:35:29.220
Otherwise, that function won't work.

00:35:29.220 --> 00:35:33.520
So you still have to import stuff if you want to use the type hints.

00:35:33.520 --> 00:35:38.520
But it basically assumes that most people just want to use them as general annotations.

00:35:38.520 --> 00:35:42.100
They don't want to use them to actually reference concrete types.

00:35:42.100 --> 00:35:42.480
Right.

00:35:42.480 --> 00:35:43.420
Yeah, very interesting.

00:35:43.820 --> 00:35:51.580
So while we're on this type annotations thing, there's some very interesting stuff happening around type annotations in the later versions of Python.

00:35:51.580 --> 00:35:55.220
And they all seem to be about trying to make Python faster, actually.

00:35:55.220 --> 00:35:59.260
I mean, obviously, it was introduced to make it more understandable and help the tooling and stuff.

00:35:59.260 --> 00:36:10.700
But so Cython has recently started adopting, if you have regular Python 3 type annotations, it'll use those instead of its funky way of declaring variables.

00:36:10.700 --> 00:36:16.360
So it can actually take just annotated code and compile it to see better, which is pretty cool.

00:36:16.360 --> 00:36:16.940
That's awesome.

00:36:16.940 --> 00:36:17.640
I didn't know that.

00:36:17.640 --> 00:36:18.200
Yeah, I know.

00:36:18.200 --> 00:36:19.120
I just learned it as well.

00:36:19.120 --> 00:36:25.920
And do you know about mypy, which is like the type verifiers, like a linter, but like deeply for typing?

00:36:25.920 --> 00:36:28.800
Yeah, it's like an introspection tool, isn't it?

00:36:28.800 --> 00:36:29.160
Yeah.

00:36:29.160 --> 00:36:30.180
So that's pretty interesting.

00:36:30.720 --> 00:36:36.000
And there's some tools to like generate the type annotations based on like runtime stuff and various interesting things.

00:36:36.000 --> 00:36:48.660
But what also is interesting is Dropbox is releasing this thing called mypyC, which is a compiler that takes annotated statically typed Python code and compiles them to C extensions.

00:36:48.660 --> 00:36:48.980
Wow.

00:36:48.980 --> 00:36:49.340
Okay.

00:36:49.340 --> 00:36:50.600
That's really cool.

00:36:50.980 --> 00:36:54.120
So these are both kind of interesting things that people are playing with.

00:36:54.120 --> 00:36:56.420
So anyway, those are worth maybe looking at.

00:36:56.420 --> 00:36:56.700
Yeah.

00:36:56.700 --> 00:37:03.480
And the important thing with this feature is that in the pep, it says that it will be the default behavior in Python 4.

00:37:03.480 --> 00:37:04.200
That's pretty awesome.

00:37:04.200 --> 00:37:05.520
There's going to be a Python 4 pretty soon.

00:37:05.520 --> 00:37:06.920
Well, we don't know how long, but.

00:37:08.040 --> 00:37:10.660
Yeah, well, a couple of 18 month iterations.

00:37:10.660 --> 00:37:18.140
There's actually talk Łukasz Langa is overseeing the release for Python 3.7, 3.8, I believe.

00:37:18.140 --> 00:37:21.100
Definitely for 3.8, maybe 3.8, 3.9.

00:37:21.100 --> 00:37:22.380
I don't want to give me the wrong numbers.

00:37:22.380 --> 00:37:23.240
Yeah, thank you.

00:37:23.240 --> 00:37:28.660
And he's trying to get the release cycle down to yearly, but that's kind of on hold for a little bit.

00:37:28.660 --> 00:37:29.780
Okay.

00:37:29.780 --> 00:37:34.220
So maybe it'll be quicker than it otherwise would have been by, you know, six month segments.

00:37:34.520 --> 00:37:41.700
All right, so we opened this section, the whole podcast a little bit by talking about performance in Python 2 and 3.

00:37:41.700 --> 00:37:45.020
So 3.7 brings some interesting new performance benefits, right?

00:37:45.020 --> 00:37:53.040
Yeah, so I guess calling methods or calling functions in Python definitely has an overhead or an associated cost.

00:37:53.040 --> 00:38:00.100
I got to say, when I first learned Python, I was blown away at how slow a function call was compared to if I inlined it effectively.

00:38:00.100 --> 00:38:01.140
Right, yeah.

00:38:01.140 --> 00:38:02.600
And I think it's a big deal.

00:38:02.880 --> 00:38:11.200
And this leads to people writing code in certain funky ways, copying and pasting things a bit more once they learn about this quirk of Python.

00:38:11.200 --> 00:38:21.580
Especially if you're using some of the frameworks because the number of, I guess, turtles deep or the number of layers that it has to go through function scrolling functions, it can really kind of slow down the application.

00:38:21.580 --> 00:38:22.180
Yeah, yeah.

00:38:22.220 --> 00:38:30.840
I know in SQLAlchemy that Mike Bayer very carefully worked on the architecture to minimize the function call depth, actually, for performance reasons.

00:38:30.840 --> 00:38:31.880
Like, there's a lot.

00:38:32.100 --> 00:38:35.300
So in 3.7 calling functions gets somewhat faster.

00:38:35.300 --> 00:38:38.700
Not quite like inline assembly fast, but faster, right?

00:38:38.700 --> 00:38:38.940
Yeah.

00:38:38.940 --> 00:38:42.720
So basically, they've introduced some new opcodes.

00:38:42.880 --> 00:38:45.240
And there's a different implementation for calling.

00:38:45.240 --> 00:38:47.460
And it's quite specific, actually.

00:38:47.460 --> 00:38:49.740
It's not just functions and methods in general.

00:38:49.740 --> 00:38:57.540
It has to be on a bound method, which means if you've got a class and you've got a method on the class, you've instantiated it.

00:38:57.780 --> 00:39:04.040
When you call it, if that class doesn't have any keyword arguments, then it will be faster than before.

00:39:04.040 --> 00:39:08.040
So like I said, it's quite specific, but that probably covers quite a lot of cases.

00:39:08.040 --> 00:39:10.040
But that's a really common case, right?

00:39:10.040 --> 00:39:14.340
There's a lot of times when you have some kind of object and it has a function and you want to call it.

00:39:14.340 --> 00:39:18.240
Like, if objects don't have functions, why would you create them, right?

00:39:18.240 --> 00:39:20.980
Just put them in a data structure or something, right?

00:39:20.980 --> 00:39:23.580
So it's obviously nice that those are there.

00:39:23.580 --> 00:39:26.620
And I wouldn't say the majority of functions have keyword arguments.

00:39:26.620 --> 00:39:28.120
So it's a good improvement.

00:39:28.120 --> 00:39:28.500
Yeah.

00:39:28.500 --> 00:39:30.140
No, I think it's a good step forward.

00:39:30.140 --> 00:39:31.960
So it's 10% to 15% faster.

00:39:31.960 --> 00:39:37.180
And in benchmarks, there's basically a speed boost because of that knock-on effect.

00:39:37.180 --> 00:39:37.540
Yeah.

00:39:37.540 --> 00:39:38.440
That's really cool.

00:39:38.440 --> 00:39:42.800
So maybe that might even affect like what you've pip installed, right?

00:39:42.800 --> 00:39:49.000
Even if you have no classes, you might be interacting with like some turtle at layer 3 that uses classes, right?

00:39:49.000 --> 00:39:49.240
Yeah.

00:39:49.240 --> 00:39:55.660
So even just by moving to Python 3.7, you can actually see a speed improvement on a lot of applications.

00:39:56.100 --> 00:39:57.820
I've upped 10% to 15%.

00:39:57.820 --> 00:39:58.820
Yeah, that's really sweet.

00:39:58.820 --> 00:40:05.180
So after going through all this, doing all this research, if somebody's on 3.6, is it worth upgrading to 3.7, you think?

00:40:05.180 --> 00:40:09.600
I'd definitely be worth upgrading to 3.7.1.

00:40:09.600 --> 00:40:11.440
Point anything other than 0?

00:40:11.440 --> 00:40:12.220
Yeah.

00:40:12.220 --> 00:40:16.320
I would never upgrade to a .0 release in a production environment.

00:40:16.320 --> 00:40:19.020
But definitely, I think data classes are really cool.

00:40:19.020 --> 00:40:23.040
I'd been using the Attrs module for a few projects and really liked it.

00:40:23.120 --> 00:40:27.780
But obviously, adding yet another dependency to your application is not always desirable.

00:40:27.780 --> 00:40:30.420
So it's nice to have that in the standard library.

00:40:30.420 --> 00:40:32.780
The speed improvements are always welcome.

00:40:32.780 --> 00:40:36.020
I think anything that can make Python faster is great.

00:40:36.020 --> 00:40:47.420
The type annotations change, I think, actually makes it a lot more appealing to me because you don't have to worry so much about the import statements and things like that if you're not actually going to use them in that way.

00:40:47.580 --> 00:40:48.980
So, yeah, there's some big changes.

00:40:48.980 --> 00:40:51.540
I think the one that I've actually used the most is Breakpoint.

00:40:51.540 --> 00:40:58.640
Just since I've switched to 3.7, just got so used to just writing Breakpoint instead of the import PDB.

00:40:58.640 --> 00:41:05.200
And also worked with the pytest team to get Breakpoint supported in pytest, which was pretty fun.

00:41:05.200 --> 00:41:09.020
So I got to kind of dig into some of the details.

00:41:09.020 --> 00:41:15.940
Although somebody, Anthony Sotile, the other Anthony who works on pytest, there's quite a few of us actually,

00:41:15.940 --> 00:41:21.200
but he raised a pull request basically saying that he proved that my pull request basically did nothing.

00:41:21.200 --> 00:41:22.900
So I was a bit disheartened.

00:41:22.900 --> 00:41:25.480
Oh, dear.

00:41:25.480 --> 00:41:27.060
But it has a lot of test coverage.

00:41:27.060 --> 00:41:27.800
That's good.

00:41:27.800 --> 00:41:31.080
I hear you with the .0 release in production.

00:41:31.080 --> 00:41:36.320
Right now, what I'm doing is I'm still using 3.6, 6, whatever the latest on Ubuntu is, right?

00:41:36.320 --> 00:41:38.860
I keep that up to date as it ships with there.

00:41:38.860 --> 00:41:46.920
But I'm doing 3.7 in dev and just making sure that I don't use any of the features yet that are going to cause trouble when I ship it.

00:41:46.920 --> 00:41:54.460
So I've definitely taken my site down by accidentally using an F string in a utility function that was never called in the web app,

00:41:54.460 --> 00:41:56.820
but was actually parsed by 3.5.

00:41:57.340 --> 00:41:58.920
And they wouldn't start the web app.

00:41:58.920 --> 00:42:01.200
So it can sneak in there.

00:42:01.200 --> 00:42:09.520
But maybe you could start testing in dev or Q&A or some sort of staging environment and then someday switch pretty soon.

00:42:09.520 --> 00:42:09.900
Yeah.

00:42:09.900 --> 00:42:11.240
And then someday move to 3.8.

00:42:11.240 --> 00:42:11.980
Yeah.

00:42:11.980 --> 00:42:13.560
You could move to 3.8.

00:42:13.560 --> 00:42:17.840
Although the segfault thing you're talking about, maybe not yet, maybe wait a little bit.

00:42:17.840 --> 00:42:21.440
But yeah, let's do a quick preview of what's coming in 3.8.

00:42:21.440 --> 00:42:22.080
Yeah, sure.

00:42:22.260 --> 00:42:24.620
So there's a couple of quick, easy ones.

00:42:24.620 --> 00:42:31.640
So for example, AsyncIO on Windows gets a different event loop, a proactor event loop.

00:42:31.640 --> 00:42:32.900
I actually have no idea what that is.

00:42:32.900 --> 00:42:35.060
I now want to go research it and see what that is.

00:42:35.060 --> 00:42:40.820
But that's pretty cool that AsyncIO has these configurable, extendable event loops like uv loop and so on.

00:42:40.820 --> 00:42:49.720
There's a few simple language things like a continue statement used to be illegal in a final clause, but now it's not.

00:42:49.720 --> 00:42:52.240
But then there's a few other major ones.

00:42:52.240 --> 00:42:56.300
You want to maybe touch on the big ones and we can hit a few small ones after that.

00:42:56.300 --> 00:43:06.580
Yeah, there's been, well, there's, I guess, for every major release of Python, there's all the proposals for new features in the form of these documents called PEPs.

00:43:06.580 --> 00:43:12.600
So I've been reading, I guess, some of the proposed PEPs in detail and trying to understand what they do.

00:43:12.600 --> 00:43:15.480
There's a couple that have been accepted already.

00:43:15.700 --> 00:43:22.960
The big controversial one, I guess, was PEP 572, which is something called assignment expressions.

00:43:22.960 --> 00:43:32.500
The easiest way to understand it is that if you just do in a REPL, X equals one, enter, and then X, enter, it will return one.

00:43:32.500 --> 00:43:39.280
And assignment expressions basically introduce a new syntax, which is X colon equals one, which will return one.

00:43:39.760 --> 00:43:43.320
So it basically squashes those two statements together into one.

00:43:43.320 --> 00:43:43.720
All right.

00:43:43.720 --> 00:43:46.140
A lot of time you might be thinking, well, I would never use that.

00:43:46.140 --> 00:43:48.020
Like, what is the value of this?

00:43:48.020 --> 00:43:50.840
But if you're doing, well, expressions, right?

00:43:50.840 --> 00:43:58.060
If I'm doing like a list comprehension and I want to do both a test and a creation of a variable or things like that, you know,

00:43:58.100 --> 00:44:02.760
like there's a few interesting use cases where it does simplify the language a bit.

00:44:02.760 --> 00:44:03.060
Yeah.

00:44:03.060 --> 00:44:05.000
And that syntax is in other languages.

00:44:05.000 --> 00:44:07.980
So people might be used to it in other places.

00:44:07.980 --> 00:44:09.800
JavaScript is an example.

00:44:09.800 --> 00:44:12.020
And Perl would be another one.

00:44:12.020 --> 00:44:16.900
So I guess people, some people are more familiar with using that kind of syntax.

00:44:17.620 --> 00:44:30.440
And yeah, if you're doing statements, like if statements, this comprehensions while statements, for example, then yeah, you can introduce this new syntax and you can basically get the value back and then use it for other things.

00:44:30.440 --> 00:44:30.800
All right.

00:44:30.800 --> 00:44:35.500
Maybe like a lambda expression where you've got to squeeze it into one line, possibly.

00:44:35.500 --> 00:44:36.380
I don't know.

00:44:36.380 --> 00:44:36.820
Yeah.

00:44:36.820 --> 00:44:37.100
Yeah.

00:44:37.100 --> 00:44:44.580
It's basically because you can, yeah, you can't write return statements inside where something should be a statement itself.

00:44:44.580 --> 00:44:45.420
Yeah.

00:44:45.420 --> 00:44:46.540
Even with semicolons, right?

00:44:46.960 --> 00:44:49.040
Even with semicolons, you can't do that now.

00:44:49.040 --> 00:44:50.780
Right.

00:44:50.780 --> 00:45:01.120
So this was controversial partly because let's say close to half of the community really you thought like this just does not need to be added to the language.

00:45:01.120 --> 00:45:01.780
We don't do this.

00:45:01.780 --> 00:45:03.940
And there was like maybe a minority.

00:45:03.940 --> 00:45:04.460
I'm not sure.

00:45:04.460 --> 00:45:07.340
But another part of the community that really did want it.

00:45:07.340 --> 00:45:11.720
And so there was actually quite a bit of a disagreement about whether it should have been accepted.

00:45:12.280 --> 00:45:20.180
And the fallout of that is sort of the straw that caused Gita Van Rossum to step down as BDFL.

00:45:20.180 --> 00:45:21.000
Yeah.

00:45:21.000 --> 00:45:25.200
I think that some of the comments got a bit nasty, to be honest, and some of the pushback.

00:45:25.200 --> 00:45:27.080
But I don't know.

00:45:27.480 --> 00:45:29.720
I've seen places where it could be used.

00:45:29.720 --> 00:45:30.920
And I think, yeah, that could be useful.

00:45:30.920 --> 00:45:32.720
But I don't think I'd use it every day.

00:45:32.720 --> 00:45:36.020
Like this is a once every now and again, you'd use it kind of thing.

00:45:36.020 --> 00:45:36.540
Yeah.

00:45:36.540 --> 00:45:37.580
That's kind of how I feel about it.

00:45:37.580 --> 00:45:42.580
Like it's not a huge deal, but I'm not like looking forward to doing amazing stuff with it yet.

00:45:42.580 --> 00:45:42.840
Yeah.

00:45:42.840 --> 00:45:44.440
Like an async context manager.

00:45:44.440 --> 00:45:46.060
Like, you know, that's kind of cool.

00:45:46.560 --> 00:45:48.260
But it's not something you do use in everyday code.

00:45:48.260 --> 00:45:48.880
Yeah, for sure.

00:45:48.880 --> 00:45:56.180
So the one that's coming that I'm really positive about is the none aware or null aware operators.

00:45:56.180 --> 00:45:56.960
Tell us about that.

00:45:56.960 --> 00:45:57.280
Yeah.

00:45:57.280 --> 00:45:59.980
So this one has been proposed, but not accepted.

00:45:59.980 --> 00:46:02.000
I think it's in draft state at the moment.

00:46:02.000 --> 00:46:05.220
So it's basically, again, a new syntax.

00:46:05.880 --> 00:46:14.840
So anyone who works with Python a lot will know the sort of famous error that X is not an attribute of none type or something along those lines.

00:46:14.840 --> 00:46:19.740
So like, I think it's one of the most common exceptions is that attribute error.

00:46:19.740 --> 00:46:22.160
Something is not an attribute of none type.

00:46:22.160 --> 00:46:22.960
Yeah.

00:46:22.960 --> 00:46:31.320
So it's basically like it's the equivalent of a null pointer or a null reference exception in Java or C# or C++.

00:46:31.320 --> 00:46:34.020
It's the Python equivalent of that.

00:46:34.480 --> 00:46:39.760
So none, I guess, is our special type to represent nothing instead of null.

00:46:39.760 --> 00:46:43.300
But it doesn't technically have a value similar to null.

00:46:43.300 --> 00:47:00.900
It's actually a special type in itself, which means that in this PEP and their proposal, what they're proposing is basically a special set of syntax based around the question mark to allow you to basically follow branches depending on whether something is null or not.

00:47:00.900 --> 00:47:10.580
So, for example, if you had a data class, if you had a data class with some fields and one of the values of the fields was null, you could reference it.

00:47:10.780 --> 00:47:14.260
And then if that field itself, you wanted to call a method on it.

00:47:14.260 --> 00:47:16.720
Like, I don't know, let's assume it was a string.

00:47:16.720 --> 00:47:18.180
You wanted to run the upper on it.

00:47:18.180 --> 00:47:22.740
If it was none, then you'd get upper as not a property of none type.

00:47:23.300 --> 00:47:28.880
But basically, instead, you could do question mark dot as the method accessor.

00:47:28.880 --> 00:47:29.160
Right.

00:47:29.160 --> 00:47:29.520
Right.

00:47:29.520 --> 00:47:38.460
Instead of object dot like field dot upper, you'd say object dot field question mark dot question mark upper.

00:47:38.700 --> 00:47:38.940
Yes.

00:47:38.940 --> 00:47:44.280
It also introduces something called a ternary operator, which is a double question mark.

00:47:44.280 --> 00:47:49.240
But that already exists in Python, but it's pretty long form.

00:47:49.240 --> 00:47:55.680
You have to say something equals something if the thing is that else, not this.

00:47:55.680 --> 00:47:56.340
Yeah.

00:47:56.340 --> 00:47:57.340
And it is a little bit longer.

00:47:57.340 --> 00:48:02.760
The sort of double question mark null class none class operator thing does not excite me very much.

00:48:02.760 --> 00:48:12.380
But this fluent style of these chaining function calls that at any step may be none is super exciting to me because you might have to check.

00:48:12.380 --> 00:48:14.180
First, is the original object none?

00:48:14.180 --> 00:48:14.640
OK.

00:48:14.640 --> 00:48:20.360
Then if that's not the case, now is its name, you know, maybe it contains like a rich object.

00:48:20.360 --> 00:48:21.900
You know, is that like an address?

00:48:21.900 --> 00:48:23.160
Like, is the address none?

00:48:23.160 --> 00:48:23.480
OK.

00:48:23.480 --> 00:48:24.340
The address is not none.

00:48:24.340 --> 00:48:26.480
So is the street not none?

00:48:26.480 --> 00:48:28.100
OK, now we can call to upper on it.

00:48:28.100 --> 00:48:29.880
That's like one line, right?

00:48:29.880 --> 00:48:35.000
Object question mark dot address question mark dot street question mark dot upper.

00:48:35.000 --> 00:48:38.020
And boom, you get either none or you get an uppercase street name.

00:48:38.020 --> 00:48:38.560
I love it.

00:48:38.560 --> 00:48:38.780
Yeah.

00:48:38.780 --> 00:48:44.480
So if anyone works with like highly nested types, I guess, then and you have to write all these.

00:48:44.480 --> 00:48:45.960
If that's not none, do this.

00:48:45.960 --> 00:48:46.980
If that's not none, do this.

00:48:46.980 --> 00:48:48.920
Then, yeah, this is super helpful.

00:48:48.920 --> 00:48:51.180
Could be if it gets accepted.

00:48:51.180 --> 00:48:52.460
Yeah, it could be.

00:48:52.460 --> 00:48:55.100
It's one possible branch of the future.

00:48:55.100 --> 00:48:55.980
This will be very helpful.

00:48:55.980 --> 00:49:03.280
Yeah, I just one thing that I dislike a lot in my code is like sort of seesaw nested jaggedy code.

00:49:03.280 --> 00:49:06.520
And this can like turn that into just like a one liner, which I think is great.

00:49:06.520 --> 00:49:09.620
You also have called out runtime audit hooks.

00:49:09.620 --> 00:49:11.160
What might that be useful for?

00:49:11.160 --> 00:49:13.600
This is probably a security feature mainly.

00:49:14.540 --> 00:49:15.920
But again, it's a proposal.

00:49:15.920 --> 00:49:17.200
It's not been accepted yet.

00:49:17.200 --> 00:49:20.560
But the idea is that for any built in functions.

00:49:20.560 --> 00:49:27.560
Or as things in the sys module or some of the low level functions within Python standard library,

00:49:27.760 --> 00:49:36.600
whenever they got called by either your code or somebody else's code, you've got the option to set like a audit hook.

00:49:36.980 --> 00:49:48.820
So you might write a special application like a profiler, for example, if you're writing a profiler and you want to see every time somebody tries to open a network socket or calls a URL or something.

00:49:49.240 --> 00:49:57.940
Or if you wanted to develop security application that checked anyone who is, you know, opening file handles in the operating system or...

00:49:57.940 --> 00:49:57.960
Right.

00:49:57.960 --> 00:50:01.940
You could build a really cool package that you can just import into your app at the beginning.

00:50:02.220 --> 00:50:04.740
And it says, these operations are allowed.

00:50:04.740 --> 00:50:07.960
These are not like no network access, no file access.

00:50:07.960 --> 00:50:11.840
And with this, maybe you could just stop that globally in the runtime, right?

00:50:11.840 --> 00:50:12.260
Yeah.

00:50:12.260 --> 00:50:17.100
So kind of similar to what you can do with SE Linux, if anyone's familiar with SE Linux.

00:50:17.100 --> 00:50:23.460
You can kind of lock down the kernel effectively for certain users and certain method calls can't be run.

00:50:23.460 --> 00:50:25.100
So this would be similar.

00:50:25.100 --> 00:50:27.440
So you could basically have a Python interpreter.

00:50:28.000 --> 00:50:34.000
And when certain things are done inside Python, then your method gets called as part of an audit.

00:50:34.000 --> 00:50:36.760
You could watch for the eval function.

00:50:36.760 --> 00:50:37.500
Yeah, exactly.

00:50:37.500 --> 00:50:41.160
It is a little bit light on the details.

00:50:41.160 --> 00:50:43.840
The implementation is not finished either.

00:50:43.840 --> 00:50:48.240
But I know that Steve Dower is working on this PEP.

00:50:48.240 --> 00:50:54.800
And he has said if anyone wants to help contribute to the implementation or do some testing, then the door is open.

00:50:54.800 --> 00:50:56.140
Nice to get in touch with Steve Dower.

00:50:56.140 --> 00:50:56.740
Perfect.

00:50:57.000 --> 00:51:00.380
So maybe I'll just throw out a few real quick ones also that are like more minor.

00:51:00.380 --> 00:51:09.420
So for virtual environments, it now has an ability to activate this through PowerShell on Windows, which if you use PowerShell on Windows, that's pretty awesome.

00:51:09.420 --> 00:51:10.100
Yeah, that's awesome.

00:51:10.100 --> 00:51:14.560
I don't know why you wouldn't use PowerShell if you're using Windows anymore.

00:51:14.560 --> 00:51:16.160
If you want to use MS-DOS, that's fine.

00:51:16.160 --> 00:51:16.940
Yeah.

00:51:16.940 --> 00:51:18.860
It's not the greatest shell.

00:51:18.860 --> 00:51:19.420
Yeah, yeah.

00:51:19.420 --> 00:51:20.260
I like Commander.

00:51:20.260 --> 00:51:22.440
C-M-D-E-R.

00:51:22.440 --> 00:51:25.120
I think it's commander.net on Windows.

00:51:26.000 --> 00:51:28.560
So optimizations around file copies.

00:51:28.560 --> 00:51:32.200
That's been improved on the Unix-based systems, right?

00:51:32.200 --> 00:51:32.800
Yeah.

00:51:32.800 --> 00:51:35.140
I don't think that makes a pretty big difference, actually.

00:51:35.140 --> 00:51:35.540
Yeah.

00:51:35.540 --> 00:51:38.960
There's some built-in, like, sysplatform-specific fast copy.

00:51:38.960 --> 00:51:45.140
Like, I wonder if it uses the new Apple file system sort of replication stuff, which would be a lot faster.

00:51:45.140 --> 00:51:45.780
It'd be very cool.

00:51:46.320 --> 00:51:49.220
They also removed pyvnv, the script.

00:51:49.220 --> 00:51:55.420
So the expected way that you create a virtual environment is python3-m spacevnv, right?

00:51:55.420 --> 00:51:55.880
Yes.

00:51:55.880 --> 00:51:56.780
Nice.

00:51:56.780 --> 00:51:57.780
I don't really use that, but...

00:51:57.780 --> 00:51:57.860
Nice.

00:51:57.860 --> 00:52:01.960
Well, that's what they tell you in 3.8.

00:52:01.960 --> 00:52:03.640
Other minor changes.

00:52:03.640 --> 00:52:07.860
And I guess one thing that's interesting is python3.8 is temporarily...

00:52:07.860 --> 00:52:12.420
Like, it's pretty far out, so this might not be a problem forever.

00:52:12.420 --> 00:52:21.620
But right now, with Guido stepping down and the governance decision, like, the choice of how Python governs its decision-making is not decided.

00:52:21.620 --> 00:52:27.020
No new features are going into 3.8 until they can decide how to decide on those new features.

00:52:27.020 --> 00:52:27.400
Yeah.

00:52:27.400 --> 00:52:29.540
That's a bit of a weird catch-22 thing there.

00:52:29.540 --> 00:52:38.420
I bump into one of the core developers last month, and they said that it's likely that there'll be fewer features in 3.8 than there have been in previous releases, unless...

00:52:38.980 --> 00:52:51.180
Well, until they can work this thing out, and then even then, having, I guess, faster, sort of mainly bug fix and performance improvement releases is a lot more likely to be the way forward.

00:52:51.180 --> 00:52:51.600
Yeah.

00:52:51.600 --> 00:52:58.660
I suspect it's going to take a little while before this gets dialed in and it becomes a smooth process again, but I'm sure they'll figure it out.

00:52:58.660 --> 00:52:58.960
Yeah.

00:52:58.960 --> 00:53:04.420
Well, there's a few major things that kind of need to happen in future releases.

00:53:04.420 --> 00:53:09.320
I guess one thing is the startup time is still slower than legacy Python.

00:53:09.320 --> 00:53:18.520
I think there's ways for them to optimize that in terms of what it loads at import at startup and how it does all the importing and caching and stuff.

00:53:18.520 --> 00:53:21.120
Hopefully, that'll be quicker in newer releases.

00:53:21.120 --> 00:53:25.200
And then there's a C API, which has, over time, got a little bit messy.

00:53:25.200 --> 00:53:30.260
So I think there's a few proposals for Python 4 for that to have a bit of a revamp.

00:53:30.260 --> 00:53:31.300
Yeah, that'll be interesting.

00:53:31.300 --> 00:53:33.780
That's a little far out, but definitely be interesting.

00:53:33.980 --> 00:53:35.480
Maybe it'll be rewritten in Rust.

00:53:35.480 --> 00:53:36.740
Yeah, maybe.

00:53:36.740 --> 00:53:38.020
Yeah, I don't know about that.

00:53:38.020 --> 00:53:41.520
Anyway, that's a ways out, but definitely something to look forward to.

00:53:41.520 --> 00:53:44.340
Well, I think that's probably a good place to leave it.

00:53:44.340 --> 00:53:47.600
We're probably low on time, kept you long enough.

00:53:47.600 --> 00:53:53.220
But before you go, I know I've asked you this at least back in episode 155, but that was a while ago.

00:53:53.220 --> 00:53:54.060
I'll ask you again.

00:53:54.060 --> 00:53:56.400
If you're going to write some Python code, maybe your answer has changed.

00:53:56.400 --> 00:53:57.600
What editor do you use?

00:53:57.600 --> 00:53:59.300
It's still Visual Studio Code.

00:53:59.300 --> 00:54:01.180
Right, with the Python plugin.

00:54:01.560 --> 00:54:03.420
Yeah, it's definitely a nice thing.

00:54:03.420 --> 00:54:08.520
And it's like, I don't know how many times, millions, like 5, 10 million.

00:54:08.520 --> 00:54:13.640
I don't know how many millions there are downloads of that Python extension for Visual Studio Code, but it's pretty remarkable.

00:54:13.640 --> 00:54:14.480
Yeah, it's great.

00:54:14.560 --> 00:54:24.220
Although I'm using Windows at the moment with Windows subsystem Linux, which is causing me problems because Linux creates different virtual environments to Windows.

00:54:24.220 --> 00:54:30.620
So the IDE is using a different virtual environment to my actual application, which is causing me a source of pain.

00:54:30.880 --> 00:54:37.640
There's all sorts of process isolation and system isolation between the Windows subsystem for Linux and Windows itself, right?

00:54:37.640 --> 00:54:38.100
Yeah.

00:54:38.100 --> 00:54:39.320
So that's causing me.

00:54:39.320 --> 00:54:40.500
You're going to be an expert pretty soon.

00:54:40.500 --> 00:54:41.020
That'd be awesome.

00:54:41.020 --> 00:54:44.980
You'll be able to help people who are also doing this.

00:54:44.980 --> 00:54:45.940
Nice.

00:54:45.940 --> 00:54:46.200
All right.

00:54:46.200 --> 00:54:47.900
So notable PyPI package?

00:54:48.100 --> 00:54:52.320
Yeah, I'd recommend people check out Black if they haven't already as a code formatter.

00:54:52.960 --> 00:55:13.580
It's basically, if you ever check in code and then if the build fails because you've, you know, put an extra space at the end of a line or something, and you've had that frustration, then you can use this basically as a tool to go through your code and format it for you so that it passes most code linters and style checkers and stuff like that.

00:55:13.580 --> 00:55:15.820
And it's basically no options, no configuration.

00:55:15.820 --> 00:55:20.420
You just run the command, give it a directory, and it will just go through and change your code for you.

00:55:20.420 --> 00:55:21.680
I absolutely love that.

00:55:21.680 --> 00:55:27.540
I think the code it produces is really nice, really easy to read, and it's just really easy to get set up with.

00:55:27.540 --> 00:55:31.940
Yeah, most linters, they just complain to you, you should get rid of that space at the end or whatever.

00:55:31.940 --> 00:55:33.280
This one just goes, yeah, I'll fix that.

00:55:33.280 --> 00:55:35.480
Yeah, it just fixes it up for you and you check it in.

00:55:35.480 --> 00:55:36.120
Right on.

00:55:36.120 --> 00:55:37.980
All right, final call to action.

00:55:37.980 --> 00:55:39.540
People are excited about 3.7.

00:55:39.540 --> 00:55:40.520
What do they do?

00:55:40.520 --> 00:55:49.380
They need to download it first, install it, test it out, run their applications on it, see how they're improved, and then check out some of the new features.

00:55:49.380 --> 00:55:50.580
Yeah, maybe check out your course.

00:55:50.580 --> 00:55:52.400
Yeah, and absolutely check out my course.

00:55:52.400 --> 00:55:55.620
Yeah, like I said, it'll take less than an hour of your time.

00:55:55.620 --> 00:55:56.920
It's 57 minutes.

00:55:56.920 --> 00:56:00.580
And you can find out all the details on Python 3.7.

00:56:00.580 --> 00:56:01.180
Yeah, awesome.

00:56:01.180 --> 00:56:01.960
I definitely agree.

00:56:01.960 --> 00:56:02.780
People should check it out.

00:56:02.780 --> 00:56:03.640
There's some great features.

00:56:03.640 --> 00:56:06.380
And Anthony, thanks for being on the show to share them with everyone.

00:56:06.380 --> 00:56:07.040
Thanks, Michael.

00:56:07.040 --> 00:56:08.020
It's been great to be back.

00:56:08.020 --> 00:56:08.340
Yep.

00:56:08.440 --> 00:56:08.660
Bye.

00:56:08.660 --> 00:56:08.660
Bye.

00:56:09.660 --> 00:56:12.600
This has been another episode of Talk Python to Me.

00:56:12.780 --> 00:56:17.260
Our guest on this episode was Anthony Shaw, and it was brought to you by Tidelift.

00:56:17.940 --> 00:56:22.960
If you run an open source project, Tidelift wants to help you get paid for keeping it going strong.

00:56:23.200 --> 00:56:28.580
Just visit talkpython.fm/Tidelift, search for your package, and get started today.

00:56:28.580 --> 00:56:30.120
Want to level up your Python?

00:56:30.560 --> 00:56:35.040
If you're just getting started, try my Python jumpstart by building 10 apps, or our brand

00:56:35.040 --> 00:56:37.160
new 100 days of code in Python.

00:56:37.160 --> 00:56:40.980
And if you're interested in more than one course, be sure to check out the Everything Bundle.

00:56:40.980 --> 00:56:43.220
It's like a subscription that never expires.

00:56:43.220 --> 00:56:45.400
Be sure to subscribe to the show.

00:56:45.400 --> 00:56:47.620
Open your favorite podcatcher and search for Python.

00:56:47.620 --> 00:56:48.860
We should be right at the top.

00:56:48.860 --> 00:56:54.960
You can also find the iTunes feed at /itunes, Google Play feed at /play, and direct

00:56:54.960 --> 00:56:58.160
RSS feed at /rss on talkpython.fm.

00:56:58.160 --> 00:57:00.040
This is your host, Michael Kennedy.

00:57:00.260 --> 00:57:01.400
Thanks so much for listening.

00:57:01.400 --> 00:57:02.460
I really appreciate it.

00:57:02.460 --> 00:57:04.420
Now, get out there and write some Python code.

00:57:04.420 --> 00:57:24.960
Thank you.

00:57:24.960 --> 00:57:54.940
Thank you.

