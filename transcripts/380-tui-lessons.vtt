WEBVTT

00:00:00.001 --> 00:00:04.760
Terminals seem like the very lowest common denominator for software platforms.

00:00:04.760 --> 00:00:09.660
They have to work over SSH, they only show text, you can't do much with them.

00:00:09.660 --> 00:00:10.580
Or can you?

00:00:10.580 --> 00:00:14.480
Will McGoogan and team have been building Textual based on Rich,

00:00:14.480 --> 00:00:18.340
which looks more like an animated web app than a terminal app.

00:00:18.340 --> 00:00:22.680
And he has learned a bunch of lessons trying to maximize terminal-based apps.

00:00:22.680 --> 00:00:27.520
He's here to share his seven lessons he's learned while building a modern TUI,

00:00:27.700 --> 00:00:30.280
that is Text User Interface Framework.

00:00:30.280 --> 00:00:35.720
This is Talk Python to Me, episode 380, recorded September 5th, 2022.

00:00:35.720 --> 00:00:51.780
Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:51.780 --> 00:00:53.500
This is your host, Michael Kennedy.

00:00:53.500 --> 00:00:55.780
Follow me on Twitter where I'm @mkennedy,

00:00:55.940 --> 00:00:59.700
and keep up with the show and listen to past episodes at talkpython.fm.

00:00:59.700 --> 00:01:02.740
And follow the show on Twitter via at Talk Python.

00:01:02.740 --> 00:01:06.400
We've started streaming most of our episodes live on YouTube.

00:01:06.400 --> 00:01:10.140
Subscribe to our YouTube channel over at talkpython.fm/youtube

00:01:10.140 --> 00:01:13.940
to get notified about upcoming shows and be part of that episode.

00:01:14.500 --> 00:01:18.240
This episode is sponsored by Microsoft for Startups Founders Hub.

00:01:18.240 --> 00:01:24.000
Check them out at talkpython.fm/founders hub to get early support for your startup.

00:01:24.000 --> 00:01:26.260
And it's brought to you by Sentry.

00:01:26.260 --> 00:01:28.480
Don't let those errors go unnoticed.

00:01:28.480 --> 00:01:29.520
Use Sentry.

00:01:29.520 --> 00:01:32.360
Get started at talkpython.fm/sentry.

00:01:33.140 --> 00:01:36.640
Transcripts for this and all of our episodes are brought to you by Assembly AI.

00:01:36.640 --> 00:01:39.320
Do you need a great automatic speech-to-text API?

00:01:39.320 --> 00:01:41.860
Get human-level accuracy in just a few lines of code.

00:01:41.860 --> 00:01:44.640
Visit talkpython.fm/assemblyai.

00:01:44.640 --> 00:01:47.520
Will, welcome back to Talk Python to Me.

00:01:47.520 --> 00:01:48.140
Thank you.

00:01:48.140 --> 00:01:48.820
It's good to be here.

00:01:48.820 --> 00:01:50.540
Yeah, it's fantastic to have you here.

00:01:50.540 --> 00:01:56.920
Really looking forward to talking about the progress you've made on Rich and Textual and your company,

00:01:56.920 --> 00:01:58.500
which is pretty fantastic.

00:01:58.820 --> 00:02:00.700
The show is not specifically about that.

00:02:00.700 --> 00:02:04.980
It's more about all these fantastic lessons that you've learned while building it.

00:02:04.980 --> 00:02:08.980
But, you know, of course, we'll get a chance to talk about it and give some updates too, I'm sure.

00:02:08.980 --> 00:02:09.480
Cool.

00:02:09.480 --> 00:02:10.280
Sounds good to me.

00:02:10.280 --> 00:02:10.740
Yeah.

00:02:10.740 --> 00:02:17.420
Well, normally I ask folks how they got into programming and people, if they want to hear that story,

00:02:17.420 --> 00:02:25.720
they can go back and check out your episode 336 on Talk Python way back, way back last year, about a year ago.

00:02:25.720 --> 00:02:26.980
It's a lifetime ago.

00:02:26.980 --> 00:02:27.960
So much has happened.

00:02:28.520 --> 00:02:32.900
In terms of what's happened with your projects and stuff, it really is kind of a lifetime ago.

00:02:32.900 --> 00:02:36.360
So what I want to ask you instead is, you know, what have you been up to the last year?

00:02:36.360 --> 00:02:37.180
Give us an update.

00:02:37.180 --> 00:02:37.720
Yeah.

00:02:37.720 --> 00:02:38.300
Okay.

00:02:38.300 --> 00:02:42.740
So I founded Textualize.io, a new startup.

00:02:42.740 --> 00:02:49.680
I've hired developers and we're very busy working on Textual and it's come on really well.

00:02:49.680 --> 00:02:50.920
It's amazing.

00:02:50.920 --> 00:02:52.880
There's more than I thought it would do, to be honest with you.

00:02:52.880 --> 00:02:54.460
Oh, Textualize.io.

00:02:56.460 --> 00:02:56.860
Yeah.

00:02:56.860 --> 00:02:57.960
Textualize.

00:02:57.960 --> 00:02:58.660
There we go.

00:02:58.660 --> 00:03:00.980
The other one's for sale if you want it.

00:03:00.980 --> 00:03:04.040
I get that all the time.

00:03:04.040 --> 00:03:04.280
Sorry.

00:03:04.280 --> 00:03:04.900
Yeah.

00:03:04.900 --> 00:03:09.620
So you've been working on Textualize and you actually got some investments and you're hiring

00:03:09.620 --> 00:03:10.920
and amazing.

00:03:10.920 --> 00:03:13.000
I'm so happy for you.

00:03:13.000 --> 00:03:13.640
Thank you.

00:03:14.240 --> 00:03:14.480
Yeah.

00:03:14.480 --> 00:03:17.320
When I first heard that, I'm like, well, what is the business model?

00:03:17.320 --> 00:03:18.700
What is the business model here?

00:03:18.700 --> 00:03:20.520
Like, what are you all working towards?

00:03:20.520 --> 00:03:23.100
Like really trying to just leverage the terminal, right?

00:03:23.100 --> 00:03:23.660
Even more.

00:03:23.660 --> 00:03:24.660
Yeah, that's right.

00:03:24.660 --> 00:03:27.400
So that's a very reasonable question that everyone asks.

00:03:27.760 --> 00:03:33.380
So the first part is Textual, which will be open source and distributed just like any other

00:03:33.380 --> 00:03:34.720
open source project.

00:03:34.720 --> 00:03:41.740
But we'll add on this commercial service where you can take those Textual apps and then you

00:03:41.740 --> 00:03:42.520
can put them in the web.

00:03:42.520 --> 00:03:49.000
And then when they're on the web, we can charge companies and organizations a monthly fee for

00:03:49.000 --> 00:03:54.820
various services such as accounts and things and maybe, you know, payment portals and things.

00:03:54.820 --> 00:04:00.560
But there will be a very generous free tier for hobbyists and for open source projects that

00:04:00.560 --> 00:04:01.200
want to do the same.

00:04:01.200 --> 00:04:01.800
Fantastic.

00:04:01.800 --> 00:04:05.800
So we have SAS for software as a service.

00:04:05.800 --> 00:04:09.280
We have PaaS, P-A-A-S for platform as a service.

00:04:09.280 --> 00:04:17.120
And the whole style of apps from Textual and to a lesser degree rich often go under the

00:04:17.120 --> 00:04:20.700
terminology of TUI, a text user interface, right?

00:04:20.700 --> 00:04:24.160
So TUI as a service, TAS, T-A-S.

00:04:24.160 --> 00:04:24.440
T-A-S.

00:04:24.440 --> 00:04:25.020
Yeah.

00:04:25.020 --> 00:04:27.240
Are you creating a new as a service?

00:04:27.240 --> 00:04:28.880
Yeah, I kind of like it.

00:04:28.880 --> 00:04:32.420
TAS, you get, you know, in tech, we love our acronyms.

00:04:32.420 --> 00:04:35.240
So if I don't invent at least one, I'll be disappointed.

00:04:35.240 --> 00:04:36.220
That's right.

00:04:36.220 --> 00:04:36.640
That's right.

00:04:36.640 --> 00:04:42.140
And if they can have like, you know, multiple cases, right, like a capital T-A-S, then I

00:04:42.140 --> 00:04:43.200
think it's going to be great.

00:04:43.200 --> 00:04:43.580
Yeah.

00:04:43.580 --> 00:04:45.940
It's an even, it's one of the better types of acronyms.

00:04:45.940 --> 00:04:46.820
Yeah.

00:04:46.820 --> 00:04:47.100
Yeah.

00:04:47.100 --> 00:04:47.380
Yeah.

00:04:47.380 --> 00:04:48.820
Fantastic.

00:04:48.820 --> 00:04:50.180
Now, I think this is great.

00:04:50.180 --> 00:04:54.740
And, you know, there's one of the things I'm really fascinated about and for a long time

00:04:54.740 --> 00:05:00.120
I've been trying to pay attention to and highlight is how do people go from open source projects

00:05:00.120 --> 00:05:01.220
to business?

00:05:01.220 --> 00:05:06.640
And when I first started the podcast and really started to think about these things, it seemed

00:05:06.640 --> 00:05:08.360
like there was not that many great answers.

00:05:08.360 --> 00:05:12.740
It felt like a lot of, well, here's my PayPal donation link or something.

00:05:13.740 --> 00:05:18.360
And it just seemed like, well, okay, that might feel good as a thanks, but you cannot make

00:05:18.360 --> 00:05:21.640
that your job to say, buy me a coffee most of the time.

00:05:21.640 --> 00:05:21.820
Yeah.

00:05:21.820 --> 00:05:24.620
But there is, there's a lot of progress lately, isn't there?

00:05:24.900 --> 00:05:25.260
Yeah.

00:05:25.260 --> 00:05:25.300
Yeah.

00:05:25.300 --> 00:05:25.340
Yeah.

00:05:25.340 --> 00:05:25.460
Yeah.

00:05:25.460 --> 00:05:28.280
Some GitHub sponsors and similar programs.

00:05:28.280 --> 00:05:34.680
You can get sponsorship and it can be enough to live on.

00:05:34.680 --> 00:05:35.980
It's not easy.

00:05:35.980 --> 00:05:40.340
The type of projects to get sponsored are the ones which are super critical to businesses.

00:05:40.340 --> 00:05:45.960
And in that case, companies don't mind donating $300 a month.

00:05:46.180 --> 00:05:49.140
And if you get enough of those, you could and three live on it.

00:05:49.140 --> 00:05:50.580
And some people certainly do.

00:05:50.580 --> 00:05:54.900
But I don't think it's practical for most people.

00:05:54.900 --> 00:06:01.760
Even if your open source project is widely used and popular, it might not bring in enough

00:06:01.760 --> 00:06:03.960
sponsorship to live on, unfortunately.

00:06:03.960 --> 00:06:04.980
Yeah, unfortunately.

00:06:05.360 --> 00:06:11.540
And so I do think GitHub sponsors really is kind of that done right.

00:06:11.540 --> 00:06:13.520
You know, it's recurring.

00:06:13.520 --> 00:06:14.540
It's automatic.

00:06:14.540 --> 00:06:15.320
Yeah.

00:06:15.320 --> 00:06:19.660
It has a social signal benefit, right?

00:06:19.660 --> 00:06:22.080
Like you can see who is sponsoring which projects.

00:06:22.080 --> 00:06:26.760
And so if you're an organization, right, like you could say, oh, look, our company sponsors

00:06:26.760 --> 00:06:28.300
that project or whatever.

00:06:28.300 --> 00:06:28.740
Yeah.

00:06:28.740 --> 00:06:29.820
It's very well done.

00:06:29.820 --> 00:06:32.580
Actually, I've got no problems with it.

00:06:32.580 --> 00:06:32.880
It's done.

00:06:33.460 --> 00:06:37.740
You can, like I said, you can contribute every month or you can contribute a one-off and you

00:06:37.740 --> 00:06:39.700
can get your name mentioned on the project.

00:06:39.700 --> 00:06:43.060
And the author of the project can offer various perks.

00:06:43.060 --> 00:06:46.120
So I think it's nicely done.

00:06:46.120 --> 00:06:52.400
The other one that I see really, this might be the most popular one, is take an open source

00:06:52.400 --> 00:06:59.060
thing and then take away, help alleviate or completely solve the operational side of things.

00:06:59.060 --> 00:07:00.020
Right.

00:07:00.020 --> 00:07:05.680
You know, for example, we have MongoDB and then they have Atlas, which lets you push a

00:07:05.680 --> 00:07:10.260
button and manage your cluster automatically inside your own AWS or Azure account.

00:07:10.260 --> 00:07:15.580
We've got Streamlit, which just got acquired, has a lot of similarities to what you're doing.

00:07:15.580 --> 00:07:17.900
You know, it's like it's got an open source version.

00:07:17.900 --> 00:07:19.400
You can create these dashboards.

00:07:19.400 --> 00:07:20.200
It's really cool.

00:07:20.480 --> 00:07:22.020
But then how do you put them on the internet?

00:07:22.020 --> 00:07:23.540
How do you maintain them?

00:07:23.540 --> 00:07:24.060
Right.

00:07:24.060 --> 00:07:25.520
And then, well, guess what?

00:07:25.520 --> 00:07:28.960
There's a paid tier that just runs it in our cloud for you.

00:07:28.960 --> 00:07:29.240
Right.

00:07:29.480 --> 00:07:33.840
So it seems like a really great, really great path to proceed down for what you're doing here.

00:07:33.840 --> 00:07:34.920
Yeah, that's right.

00:07:34.920 --> 00:07:36.640
They've got a term for it.

00:07:36.640 --> 00:07:38.060
It's called OpenCore.

00:07:38.060 --> 00:07:43.060
So you use the open source part to drive adoption.

00:07:43.860 --> 00:07:48.420
And then you can use that to sell some related services, which will just make life easier for

00:07:48.420 --> 00:07:53.900
businesses and things because there's a long history of businesses making use of open source

00:07:53.900 --> 00:07:57.260
projects and making a lot of money out of it.

00:07:57.260 --> 00:08:00.900
But they haven't really put that money in the business.

00:08:00.900 --> 00:08:06.180
So if the people that are building and maintaining these open source projects can also build side

00:08:06.180 --> 00:08:11.520
businesses around the open source project, then everyone benefits because your code gets

00:08:11.520 --> 00:08:16.780
maintained for the indefinite future and people can make a living from it.

00:08:16.780 --> 00:08:17.080
Yeah.

00:08:17.080 --> 00:08:22.400
If you would otherwise have to hire somebody to manage a Kubernetes cluster or whatever,

00:08:22.400 --> 00:08:26.080
and instead you can pay $20 a month, that's a real good deal.

00:08:26.080 --> 00:08:26.920
Exactly.

00:08:26.920 --> 00:08:31.540
And you don't want to have to solve all these problems individually for everyone that uses it.

00:08:31.540 --> 00:08:37.180
It's actually far better for someone to solve it once and for all, or at least reduce the

00:08:37.180 --> 00:08:39.240
footprint for maintenance.

00:08:39.240 --> 00:08:39.900
Yeah.

00:08:40.020 --> 00:08:44.240
Who else better to figure out how to put it in the cloud than people who are creating it,

00:08:44.240 --> 00:08:44.420
right?

00:08:44.420 --> 00:08:45.160
Yeah, exactly.

00:08:45.160 --> 00:08:45.440
Yeah.

00:08:45.440 --> 00:08:46.280
Yeah, for sure.

00:08:46.280 --> 00:08:46.800
Okay.

00:08:46.800 --> 00:08:48.200
So fantastic.

00:08:48.200 --> 00:08:52.160
I'm looking forward to TUI as a service to come on strong here.

00:08:52.160 --> 00:08:52.620
That's great.

00:08:52.620 --> 00:08:59.960
So maybe before we jump into the lessons learned, just tell people about what textual is and

00:08:59.960 --> 00:09:02.760
then textual is built upon rich.

00:09:02.760 --> 00:09:08.560
So give us a quick rundown on take whichever order you think is better to go first, rich

00:09:08.560 --> 00:09:09.060
or textual.

00:09:09.060 --> 00:09:10.380
I think rich.

00:09:10.380 --> 00:09:12.540
I'll go in chronological order.

00:09:12.540 --> 00:09:14.180
So I started rich.

00:09:14.180 --> 00:09:16.980
Gosh, it must be like three years now.

00:09:17.320 --> 00:09:23.960
And the idea was to be able to write colored text, the terminal in a nice, elegant way, and

00:09:23.960 --> 00:09:27.480
also be able to build on that with larger components.

00:09:27.480 --> 00:09:29.300
So we've got things like tables.

00:09:29.300 --> 00:09:31.040
We've got progress bars.

00:09:31.040 --> 00:09:34.540
We've got log messages, panels, all sorts of things.

00:09:34.540 --> 00:09:40.380
And they're all using the same core rendering technology, which basically takes your objects

00:09:40.380 --> 00:09:43.620
and then turns it into ANSI codes and text.

00:09:43.620 --> 00:09:46.920
And that got fairly popular, shall we say?

00:09:46.920 --> 00:09:47.620
I was surprised.

00:09:47.620 --> 00:09:48.180
I would say.

00:09:48.180 --> 00:09:50.040
I would say so too.

00:09:50.040 --> 00:09:50.560
Yeah.

00:09:50.560 --> 00:09:56.080
I mean, it's in pip now, which still blows me away because that means that virtually every

00:09:56.080 --> 00:10:01.120
Python developer is running my code, which also scares me just a little bit.

00:10:01.460 --> 00:10:02.120
This is nuts, right?

00:10:02.120 --> 00:10:04.880
Because I mean, if you have Python, you have pip.

00:10:04.880 --> 00:10:06.060
So you have rich.

00:10:06.060 --> 00:10:10.780
Is it a package with pip as a dependency or is it vendored in?

00:10:10.780 --> 00:10:14.680
It's vendored because you've got a chicken and egg problem with pip.

00:10:14.680 --> 00:10:14.700
Right.

00:10:14.700 --> 00:10:16.520
Because pip is how you get the things, right?

00:10:16.520 --> 00:10:17.020
Exactly.

00:10:17.020 --> 00:10:17.460
Exactly.

00:10:17.460 --> 00:10:18.560
So everything is vendored.

00:10:18.560 --> 00:10:23.300
Pip is just one project with lots of vendored projects inside of it.

00:10:23.300 --> 00:10:28.880
Rich, for people who haven't seen it in action, it's not just like Colorama or something,

00:10:28.880 --> 00:10:30.180
which I'm a big fan of Colorama.

00:10:30.540 --> 00:10:34.000
But that's just about how do I make this line this color or whatever.

00:10:34.000 --> 00:10:40.880
But you're talking about like tables with auto, you know, auto ellipsing and all sorts of

00:10:40.880 --> 00:10:43.060
really, really powerful content, right?

00:10:43.060 --> 00:10:43.460
Yeah.

00:10:43.460 --> 00:10:48.780
And some things which you might take for granted in the browser, like text wrapping, that wasn't

00:10:48.780 --> 00:10:50.680
easy to do prior to Rich.

00:10:50.680 --> 00:10:53.920
It's more complex than you might think.

00:10:53.920 --> 00:10:59.460
Things like emoji and Chinese characters, those take up two cells in the terminal.

00:10:59.660 --> 00:11:03.620
If you use the built-in text wrap module, that won't account for that.

00:11:03.620 --> 00:11:06.240
And your text wrapping will be misaligned.

00:11:06.240 --> 00:11:09.320
So I wanted to solve those kind of problems.

00:11:09.320 --> 00:11:10.820
I just want it to be effortless.

00:11:10.820 --> 00:11:15.000
You know, I just, you just say, print this text and it'll wrap it for you, which generally

00:11:15.000 --> 00:11:16.520
makes it a lot more readable.

00:11:16.520 --> 00:11:17.600
Yeah, absolutely.

00:11:17.600 --> 00:11:19.340
There's a lot, there's a lot going on there.

00:11:19.900 --> 00:11:20.980
I would say so.

00:11:20.980 --> 00:11:26.240
And I don't know how many projects are using Rich now, but it's, there constantly seems

00:11:26.240 --> 00:11:28.360
to be like, and now this has Rich support.

00:11:28.360 --> 00:11:33.560
So it has much better, you know, output or it's more understandable or whatever, right?

00:11:33.560 --> 00:11:35.960
A lot of cool things happening because of it.

00:11:36.180 --> 00:11:38.680
I'm delighted every time I read one of those.

00:11:38.680 --> 00:11:42.540
I do try to make it quite easy to drop things in.

00:11:42.540 --> 00:11:48.140
For instance, if you're printing out Python data structures, you can use a Rich method and

00:11:48.140 --> 00:11:51.600
you'll get pretty printing and colorizing built in.

00:11:52.140 --> 00:11:57.620
And things like exception handling, we've got very pretty exceptions that show you snippets

00:11:57.620 --> 00:12:01.860
of code and can, you know, highlight the line where the error occurred.

00:12:01.860 --> 00:12:04.380
And you can add those with just a few lines.

00:12:04.380 --> 00:12:08.960
So I think that's, that's kind of pushing adoption is the fact that there is very low barrier to

00:12:08.960 --> 00:12:09.240
entry.

00:12:09.240 --> 00:12:09.700
Yeah.

00:12:09.700 --> 00:12:11.460
And it's just beautiful, right?

00:12:11.460 --> 00:12:12.880
It's easy to make beautiful UIs.

00:12:12.880 --> 00:12:17.920
And if you make it easy for people to make nice looking things, they, they want to use it.

00:12:17.920 --> 00:12:22.100
I mean, it's not as used as much these days, but think of when Bootstrap came

00:12:22.100 --> 00:12:26.320
on the scene, you know, eight years ago or 10 years, whatever it was 10 years ago, every,

00:12:26.320 --> 00:12:30.160
everything started to look like Bootstrap because you could just apply this magic and like,

00:12:30.160 --> 00:12:32.460
oh, everything looks like professional, but we're not professional.

00:12:32.460 --> 00:12:35.700
And I feel like Rich is a little bit like that for two weeks.

00:12:35.700 --> 00:12:37.180
I think so.

00:12:37.180 --> 00:12:41.800
Cause it was, it was very difficult to add pretty formatting prior to Rich.

00:12:41.800 --> 00:12:45.560
I mean, there were libraries that existed, but they didn't integrate very well.

00:12:45.560 --> 00:12:49.140
Rich kind of combines all that functionality together.

00:12:49.660 --> 00:12:55.820
Um, so it's, it's very easy to, to add a pretty content and, it's not just pretty for pretty

00:12:55.820 --> 00:12:58.480
sake, you know, pretty can also mean more readable.

00:12:58.480 --> 00:13:03.760
Um, you know, developers, we get presented with pages and pages of content that we learned

00:13:03.760 --> 00:13:05.860
to decipher and pick out meaning.

00:13:05.880 --> 00:13:11.120
Um, but we can do that much quicker if there's been some forethought into, into how it's presented

00:13:11.120 --> 00:13:12.140
and rendered in the terminal.

00:13:12.140 --> 00:13:14.560
And Rich does give you that capability.

00:13:16.940 --> 00:13:21.460
This portion of talk Python to me is brought to you by Microsoft for startups founders hub.

00:13:21.460 --> 00:13:24.640
Starting a business is hard by some estimates.

00:13:24.640 --> 00:13:28.480
Over 90% of startups will go out of business in just their first year.

00:13:28.480 --> 00:13:34.160
With that in mind, Microsoft for startups set out to understand what startups need to be successful

00:13:34.160 --> 00:13:37.980
and to create a digital platform to help them overcome those challenges.

00:13:37.980 --> 00:13:40.640
Microsoft for startups founders hub was born.

00:13:40.640 --> 00:13:46.760
Founders hub provides all founders at any stage with free resources to solve their startup

00:13:46.760 --> 00:13:47.280
challenges.

00:13:47.280 --> 00:13:53.580
The platform provides technology benefits, access to expert guidance and skilled resources, mentorship

00:13:53.580 --> 00:13:55.920
and networking connections, and much more.

00:13:55.920 --> 00:14:01.360
Unlike others in the industry, Microsoft for startups founders hub doesn't require startups

00:14:01.360 --> 00:14:05.500
to be investor backed or third party validated to participate.

00:14:05.500 --> 00:14:08.180
Founders hub is truly open to all.

00:14:08.500 --> 00:14:12.580
So what do you get if you join them, you speed up your development with free access to GitHub

00:14:12.580 --> 00:14:17.940
and Microsoft cloud computing resources and the ability to unlock more credits over time.

00:14:17.940 --> 00:14:19.380
Help your startup innovate.

00:14:19.380 --> 00:14:24.660
Founders hub is partnering with innovative companies like open AI, a global leader in AI research and

00:14:24.660 --> 00:14:29.980
development to provide exclusive benefits and discounts through Microsoft for startups founders

00:14:29.980 --> 00:14:30.240
hub.

00:14:30.240 --> 00:14:35.020
Becoming a founder is no longer about who you know, you'll have access to their mentorship network,

00:14:35.020 --> 00:14:40.640
giving you a pool of hundreds of mentors across a range of disciplines and areas like idea

00:14:40.640 --> 00:14:45.900
validation, fundraising management and coaching sales and marketing, as well as specific technical

00:14:45.900 --> 00:14:46.620
stress points.

00:14:46.620 --> 00:14:51.380
You'll be able to book a one-on-one meeting with the mentors, many of whom are former founders

00:14:51.380 --> 00:14:51.820
themselves.

00:14:51.820 --> 00:14:57.740
Make your idea a reality today with a critical support you'll get from founders hub to join the

00:14:57.740 --> 00:14:58.180
program.

00:14:58.180 --> 00:15:03.800
Just visit talkpython.fm/founders hub, all one word, no links in your show notes.

00:15:03.800 --> 00:15:05.800
Thank you to Microsoft for supporting the show.

00:15:05.800 --> 00:15:09.420
Jamie on the audience says, "I love Rich.

00:15:09.420 --> 00:15:11.420
Rich traceback is so helpful."

00:15:11.420 --> 00:15:13.420
Maybe just quickly touch on the traceback.

00:15:13.420 --> 00:15:17.420
And then also, Demetrius is asking about, is this for Jupyter?

00:15:17.420 --> 00:15:19.420
Is it only a thing for Linux terminals?

00:15:19.420 --> 00:15:22.420
And maybe sort of touch on those two things and we'll talk textual.

00:15:22.420 --> 00:15:29.320
Tracebacks, yeah, you can install a traceback handler and it will capture unhandled tracebacks

00:15:29.320 --> 00:15:32.040
and present them nicely in the terminal.

00:15:32.040 --> 00:15:33.040
What was the other question?

00:15:33.040 --> 00:15:34.040
Sorry.

00:15:34.040 --> 00:15:35.040
Where does this apply?

00:15:35.040 --> 00:15:36.040
Like, can I use this on Windows?

00:15:36.040 --> 00:15:37.040
Can I use it on Mac?

00:15:37.040 --> 00:15:38.040
Is it for Jupyter?

00:15:38.040 --> 00:15:39.040
What is this?

00:15:39.040 --> 00:15:40.040
Pretty much everywhere.

00:15:40.040 --> 00:15:45.420
So you can use it on all the major platforms, Linux, Mac and Windows.

00:15:45.420 --> 00:15:48.440
And yes, it does work in Jupyter.

00:15:48.440 --> 00:15:53.040
So it will convert the ANSI codes to HTML automatically.

00:15:53.040 --> 00:15:56.820
That's actually the most impressive thing to me.

00:15:56.820 --> 00:16:01.660
That must be a lot of work to maintain all these different output destinations and whatnot.

00:16:01.660 --> 00:16:03.520
The terminal is not too bad.

00:16:03.520 --> 00:16:08.300
So macOS and Linux are frankly the same as far as I'm concerned.

00:16:08.300 --> 00:16:15.220
Windows has a number of tweaks and hacks because there's two windows basically.

00:16:15.220 --> 00:16:20.100
Newer Windows has virtual terminal sequences which make it just like the Linux and Mac

00:16:20.100 --> 00:16:22.100
terminal and that's terrific.

00:16:22.100 --> 00:16:27.100
But we also support the older style terminal which is quite limited.

00:16:27.100 --> 00:16:28.100
And the review like...

00:16:28.100 --> 00:16:29.100
Right, right.

00:16:29.100 --> 00:16:32.100
CMD.exe is not nearly as powerful as the new Windows terminal.

00:16:32.100 --> 00:16:34.140
No, it's not.

00:16:34.140 --> 00:16:38.520
So we have to make some compromises and some sacrifices.

00:16:38.520 --> 00:16:39.520
It works.

00:16:39.520 --> 00:16:40.520
It's usable.

00:16:40.520 --> 00:16:43.000
It won't look quite as pretty.

00:16:43.000 --> 00:16:44.880
But there's a lot of people using that out there.

00:16:44.880 --> 00:16:46.880
So it's important to maintain.

00:16:46.880 --> 00:16:47.880
Yeah, you can't really drop it.

00:16:47.880 --> 00:16:48.880
Yeah.

00:16:48.880 --> 00:16:49.880
No, you can't drop it.

00:16:49.880 --> 00:16:50.880
Okay.

00:16:50.880 --> 00:16:56.880
And then the other thing that's more directly related to your article and to your business,

00:16:56.880 --> 00:16:58.880
although obviously one's a building block.

00:16:58.880 --> 00:17:00.760
So same as Textual.

00:17:00.760 --> 00:17:01.760
Yeah.

00:17:01.760 --> 00:17:06.920
So Rich was for writing kind of static content into your kind of terminal, your scroll back

00:17:06.920 --> 00:17:07.760
buffer.

00:17:07.760 --> 00:17:13.760
What Textual does is it uses Rich, but it completely takes over your terminal to create an application.

00:17:13.760 --> 00:17:19.640
You don't see a command prompt, but Textual will handle key presses and mouse movements and

00:17:19.640 --> 00:17:25.760
it'll render quite sophisticated applications, which look more like web apps than the previous

00:17:25.760 --> 00:17:26.640
generation of Tuis.

00:17:26.640 --> 00:17:27.640
Yeah.

00:17:27.640 --> 00:17:32.460
But under the hood, it's using the same code that renders tables in Rich.

00:17:32.460 --> 00:17:34.660
It's kind of a, I call it a rendering engine.

00:17:34.660 --> 00:17:40.940
It's designed to take sort of abstract data and then turn it into what I call segments, which

00:17:40.940 --> 00:17:42.720
are basically a piece of text with a style.

00:17:42.720 --> 00:17:43.800
It's pretty amazing.

00:17:43.800 --> 00:17:47.980
You know, if you look at the UI, it's got, it really does feel a bit like a web app.

00:17:48.040 --> 00:17:53.080
It has say like a title bar across the top and you know, this isn't just like text you

00:17:53.080 --> 00:17:54.540
printed out on the top of the output.

00:17:54.540 --> 00:17:54.760
No.

00:17:54.760 --> 00:17:58.720
It's stuck to the top, like a nav bar, I guess is the right word.

00:17:58.720 --> 00:18:02.640
You have these different widgets you can put in line, like code highlighting.

00:18:02.640 --> 00:18:07.020
You've got a text widgets with like scrolling within scrolling.

00:18:07.020 --> 00:18:12.260
You've got animated sidebars that pop out all these cool different aspects, right?

00:18:12.260 --> 00:18:16.540
Even a hotkey support for like D to toggle dark and light mode if you want.

00:18:16.540 --> 00:18:17.080
Yeah.

00:18:17.360 --> 00:18:17.680
Yeah.

00:18:17.680 --> 00:18:20.040
We've even got data tables now, which are pretty cool.

00:18:20.040 --> 00:18:23.620
They look kind of like little Excel windows type of spreadsheets.

00:18:23.620 --> 00:18:24.440
Oh, fantastic.

00:18:24.440 --> 00:18:24.740
Yeah.

00:18:24.740 --> 00:18:29.740
So it's, I think my background is as a web developer, basically.

00:18:29.740 --> 00:18:35.360
So I want to make something which anyone who knows how to use a web, which is pretty much

00:18:35.360 --> 00:18:38.380
everyone, they would be comfortable using one of these applications.

00:18:38.380 --> 00:18:42.280
You could just sit them down in front of it and they'll know exactly what to do.

00:18:42.280 --> 00:18:43.920
They'll know that this is a menu.

00:18:43.920 --> 00:18:44.680
They can click that.

00:18:44.680 --> 00:18:45.640
Here's a scroll bar.

00:18:45.640 --> 00:18:46.620
I don't know how to use a scroll bar.

00:18:46.680 --> 00:18:51.500
It'll work with a mouse wheel or two fingered scroll on the trackpad.

00:18:51.500 --> 00:18:53.600
It'll just be very, very familiar.

00:18:53.600 --> 00:18:58.800
But at the same time, I also want to keep it keyboard focused because one of the benefits

00:18:58.800 --> 00:19:01.940
of TUI is it doesn't interrupt your flow.

00:19:02.740 --> 00:19:08.020
You know, you can be at the terminal typing commands, enter into a TUI and you could work

00:19:08.020 --> 00:19:11.460
with that and use the keyboard and they can drop back straight into the command line.

00:19:11.460 --> 00:19:20.960
So it's kind of this marriage of the command line and more sophisticated applications which work a lot like desktop and web.

00:19:21.160 --> 00:19:25.980
previously when people wanted to create apps like this, well, one, it was very difficult to do.

00:19:25.980 --> 00:19:33.700
But if they wanted to come somewhat close to these types of things, they would use a library called Curses or something like that, right?

00:19:33.700 --> 00:19:34.220
Yeah.

00:19:34.220 --> 00:19:38.320
And Curses has been around for a long time, I think decades.

00:19:38.320 --> 00:19:42.700
I can't remember off the top of my head, but I think in the 90s it came around.

00:19:42.700 --> 00:19:49.300
And, you know, people have done some very cool things with it and have been like attempts to improve upon it.

00:19:49.480 --> 00:19:59.520
But I think still it does take, you have to be very well motivated to create an application with Curses because you're going to have to deal with some quite archaic issues.

00:19:59.520 --> 00:20:00.100
Yeah.

00:20:00.100 --> 00:20:13.660
I haven't done a ton with it, but it feels to me like the equivalent of saying like textual versus Curses would be like you could either use something like Pygame where you can give some sprites and they can move around the screen.

00:20:13.960 --> 00:20:20.960
Or you could fire up OpenGL or DirectX or Metal and you could start rendering pixels on your own.

00:20:20.960 --> 00:20:25.700
Like you could accomplish the same UI, but one is tremendously difficult.

00:20:25.700 --> 00:20:30.320
The other one kind of gives you much higher level building blocks to accomplish the same thing.

00:20:30.320 --> 00:20:31.140
Yeah, exactly.

00:20:31.140 --> 00:20:33.020
So textual is more abstract.

00:20:33.020 --> 00:20:35.320
You don't have to plot individual characters.

00:20:35.320 --> 00:20:43.800
You just say put a text box in this part of the screen and a button in this part of the screen and, you know, textual handles the rest.

00:20:43.800 --> 00:20:51.760
So it's less archaic aspects of terminals that go back decades that you have to think about.

00:20:51.760 --> 00:20:55.180
Let the framework handle it and handle the differences, right?

00:20:55.180 --> 00:20:56.140
Yeah, exactly.

00:20:56.140 --> 00:20:57.960
That's what computing should be.

00:20:57.960 --> 00:20:59.600
It should make your life easier.

00:20:59.600 --> 00:21:02.880
You shouldn't have to think about, you know, decades.

00:21:02.880 --> 00:21:10.160
You know, you hear in science people talking about, you know, standing on the shoulders of giants, of like building on Einstein and whatever.

00:21:10.160 --> 00:21:15.760
There's nothing else that stands on the shoulders of previous work like software, right?

00:21:15.760 --> 00:21:18.080
It's just like layers and layers and layers.

00:21:18.080 --> 00:21:20.320
We don't have to think about that anymore.

00:21:20.320 --> 00:21:23.520
We now have a different set of concepts to think in.

00:21:23.520 --> 00:21:25.000
Now let's go build, you know?

00:21:25.520 --> 00:21:30.060
Yeah, yeah, which is fine for the most part, as long as you don't ever have to look behind the curtain.

00:21:30.060 --> 00:21:33.940
You know, it's the same with any piece of computing.

00:21:33.940 --> 00:21:38.120
It presents a nice, clean interface, but there's a lot of effort to get there.

00:21:38.120 --> 00:21:39.640
It's like an iceberg.

00:21:39.640 --> 00:21:43.960
You only see the very tip of it, but two-thirds are, like, below the water level.

00:21:43.960 --> 00:21:48.080
Basically, if it becomes a leaky abstraction, right?

00:21:48.080 --> 00:21:52.160
And then you've got to deal with the underlying layer, but not exactly anyway.

00:21:52.160 --> 00:21:52.720
Exactly.

00:21:52.840 --> 00:21:55.560
All right, last question, and then we'll move off.

00:21:55.560 --> 00:21:57.580
Talk about the lessons.

00:21:57.580 --> 00:22:04.680
Luca asks, will Textual have a polyfill for blink, like text blinking in terminals, which

00:22:04.680 --> 00:22:06.140
don't support it, or, you know?

00:22:06.140 --> 00:22:10.820
But basically, I guess more interesting, does it have polyfills and, like, other ways to

00:22:10.820 --> 00:22:12.920
make stuff happen that's not naturally supported?

00:22:12.920 --> 00:22:14.480
You know, it could quite easily.

00:22:14.480 --> 00:22:20.740
You could set up a timer called set interval, which would toggle something to show the blink

00:22:20.740 --> 00:22:21.720
or hide the blink.

00:22:22.040 --> 00:22:25.800
I don't think I want to support in Textual because I don't want Textual apps to be blinking.

00:22:25.800 --> 00:22:28.960
It's a terrible user interface for the most part.

00:22:28.960 --> 00:22:31.080
The exception would be a cursor.

00:22:31.080 --> 00:22:34.460
Sometimes you want a cursor to flash so you can see where it is.

00:22:34.460 --> 00:22:40.140
I think I might leave that one up to developer to implement, and it probably is, like, a two-line

00:22:40.140 --> 00:22:40.380
job.

00:22:40.380 --> 00:22:49.480
I can see a future where some movie has, like, a fake hacker UI implemented in Textual, and they

00:22:49.480 --> 00:22:52.580
probably have a blink thing about, like, when something's going to blow up going on.

00:22:52.580 --> 00:22:54.160
All right, let's move on.

00:22:54.160 --> 00:22:55.380
Let's go through your lessons.

00:22:55.380 --> 00:22:59.520
So this is what you've been building and what you are building.

00:22:59.520 --> 00:23:02.200
And obviously you've worked on Rich for a long time.

00:23:02.200 --> 00:23:06.580
You've worked, you and your colleagues at the company, for a year now.

00:23:06.580 --> 00:23:08.140
So tell us about the lessons.

00:23:08.140 --> 00:23:09.340
Let's go through these.

00:23:09.340 --> 00:23:09.920
Yeah.

00:23:09.920 --> 00:23:10.200
Okay.

00:23:10.200 --> 00:23:12.240
So terminals are fast.

00:23:12.240 --> 00:23:14.080
This might surprise people.

00:23:14.080 --> 00:23:15.120
And I can understand why.

00:23:15.120 --> 00:23:15.760
It surprised me.

00:23:16.080 --> 00:23:16.300
Yeah.

00:23:16.300 --> 00:23:19.920
Because when you use a terminal, you type a few characters, and the characters appear

00:23:19.920 --> 00:23:20.340
on screen.

00:23:20.340 --> 00:23:21.360
You hit return.

00:23:21.360 --> 00:23:25.120
You know, half a second later, you'll get a response with some text.

00:23:25.120 --> 00:23:27.380
And you don't think of terminals as being fast.

00:23:27.380 --> 00:23:31.420
But nowadays, they're built on the same technology that runs video games.

00:23:31.420 --> 00:23:38.820
So it uses the GPU to update the terminal with new characters, which have a background and

00:23:38.820 --> 00:23:39.140
a foreground.

00:23:39.600 --> 00:23:45.740
And it turns out that if you can write updates at 60 frames a second from the Python code,

00:23:45.740 --> 00:23:48.120
the terminal will happily display it.

00:23:48.120 --> 00:23:51.060
I was surprised at how smooth it was.

00:23:51.060 --> 00:23:57.100
We had 60 frames per second animation of something moving across the screen, and it looked silky smooth.

00:23:57.100 --> 00:24:00.880
And that was updating the entire screen, like every frame.

00:24:00.880 --> 00:24:01.420
Wow.

00:24:01.420 --> 00:24:07.160
I'm really impressed with the fact that so many of these terminals are hardware accelerated,

00:24:07.160 --> 00:24:08.580
like GPU accelerated.

00:24:08.680 --> 00:24:09.680
And I'm just poking around.

00:24:09.680 --> 00:24:12.080
What am I running here right now?

00:24:12.080 --> 00:24:12.980
I'm running iTerm.

00:24:12.980 --> 00:24:19.640
And it has all these settings for GPU render redraws, and basically the maximum frame rate.

00:24:19.640 --> 00:24:22.020
And so things like this.

00:24:22.020 --> 00:24:29.020
It's just, it's, you would never expect to go find hardware acceleration features inside

00:24:29.020 --> 00:24:29.440
the terminals.

00:24:29.440 --> 00:24:30.180
But they have them.

00:24:30.180 --> 00:24:31.100
They do, yeah.

00:24:31.100 --> 00:24:36.140
And it's quite strange, because not much software takes advantage of that.

00:24:36.300 --> 00:24:40.500
I mean, your day-to-day work at the terminal, it doesn't need to be fast.

00:24:40.500 --> 00:24:41.340
It really doesn't.

00:24:41.340 --> 00:24:46.900
As long as it can add new data, you know, within a second, you're probably quite happy.

00:24:46.900 --> 00:24:50.520
So these terminals have been getting faster and faster and faster.

00:24:50.980 --> 00:24:55.120
Some of them, like I use Kitty and something called Westerm.

00:24:55.120 --> 00:24:56.860
And those are incredibly fast.

00:24:56.860 --> 00:25:00.520
They're really optimized at getting things on the screen.

00:25:00.520 --> 00:25:01.940
As in this thing?

00:25:01.940 --> 00:25:02.260
Most software.

00:25:02.260 --> 00:25:02.880
Yes.

00:25:02.880 --> 00:25:03.920
Kitty's excellent.

00:25:03.920 --> 00:25:04.840
It's super fast.

00:25:04.840 --> 00:25:06.680
But most software doesn't need it.

00:25:06.780 --> 00:25:11.000
You know, it's like you use Vim or HTOP.

00:25:11.000 --> 00:25:12.700
HTOP updates once a second.

00:25:12.700 --> 00:25:17.860
So it's like the developers of these terminals are making it faster and faster and faster.

00:25:17.860 --> 00:25:21.720
But there's very little software that makes use of it.

00:25:21.720 --> 00:25:27.460
Except for like sort of hobbyist demos where they do like video to text things.

00:25:27.460 --> 00:25:31.840
So you can see like your face that's made up with ASCII characters, which is fun, right?

00:25:32.420 --> 00:25:34.900
But you don't think that's not really productivity software.

00:25:34.900 --> 00:25:39.800
So I was very pleased that when I started working on Textual that it wasn't a bottleneck.

00:25:39.800 --> 00:25:46.240
You know, if I could write things fast enough to terminal, the terminal would happily accept it and render it.

00:25:46.240 --> 00:25:51.300
That opens the possibility for so many things if you can get high frame rates.

00:25:51.300 --> 00:25:56.280
You know, and the iTerm default was limit frames to 60 frames a second.

00:25:56.280 --> 00:26:00.460
60 frames a second, that's plenty fine for really smooth animations.

00:26:00.460 --> 00:26:01.180
Yeah.

00:26:01.180 --> 00:26:05.600
And, you know, I think it's probably what my LCD monitor is stuck at, right?

00:26:05.600 --> 00:26:08.740
So that's as fast as you're going to see it basically anyway.

00:26:08.740 --> 00:26:09.400
That's it.

00:26:09.400 --> 00:26:15.860
And it can't, there's not much use in it being any faster because in order to see greater than 60 frames a second,

00:26:15.860 --> 00:26:20.340
you have to have something that's moving greater than 60 frames a second.

00:26:20.340 --> 00:26:28.740
And generally, you don't want things flying about your terminal, unless maybe you're making a video game.

00:26:29.240 --> 00:26:37.300
We use animation quite sparingly for nice kind of things like when a panel slides in, sidebar pops in.

00:26:37.920 --> 00:26:39.100
It's quite smooth.

00:26:39.100 --> 00:26:41.600
We can also use it for fades.

00:26:41.600 --> 00:26:46.420
So we can set the opacity of a block of text and have it fade away and fade in again.

00:26:46.420 --> 00:26:53.140
And that's sometimes quite useful if you want to draw the user's attention to the fact that you've added a new item.

00:26:53.140 --> 00:26:57.160
Rather than having it appear immediately, it'll fade in.

00:26:57.160 --> 00:27:00.080
So we can use animation in those places.

00:27:00.820 --> 00:27:05.000
But again, it doesn't need to be anywhere near 60 frames a second.

00:27:05.000 --> 00:27:06.060
No, it doesn't have to.

00:27:06.060 --> 00:27:15.260
But I do agree that little bits of animation are super important for highlighting things that people need to pay attention to without much effort.

00:27:15.260 --> 00:27:20.080
And it doesn't have to be so bright colored or right in the way, right?

00:27:20.080 --> 00:27:25.800
If you just have a little thing slide down that says, you know, this job has finished while the other work is happening.

00:27:26.500 --> 00:27:27.700
That's really nice.

00:27:27.700 --> 00:27:33.080
And you have a video here on this article, the seven things article that we'll link to, obviously.

00:27:33.080 --> 00:27:36.660
And it shows you running this thing called BasicPi.

00:27:36.660 --> 00:27:38.400
Is this included with Textual or is it?

00:27:38.400 --> 00:27:41.500
Yeah, that's one of our sandbox apps.

00:27:41.500 --> 00:27:45.400
So whenever we're testing something, we just put it in Basic.py.

00:27:45.400 --> 00:27:48.460
So that shows off like a number of the features we've got.

00:27:48.460 --> 00:27:49.900
I think that video is quite old.

00:27:49.900 --> 00:27:50.880
We've got some more cool stuff.

00:27:50.880 --> 00:27:52.620
I'm sure you do.

00:27:52.620 --> 00:27:53.060
Yeah.

00:27:53.500 --> 00:27:57.780
But one of the things that's really nice is it shows a lot of the animations.

00:27:57.780 --> 00:28:00.780
And one of the animations is changing the theme.

00:28:00.780 --> 00:28:03.540
Another one is to pop out the side navigation.

00:28:03.540 --> 00:28:05.100
And those are really nice, right?

00:28:05.100 --> 00:28:14.660
The fact that that happens at a frame rate fast enough that it looks completely smooth means it doesn't just look like some terminal app where a thing clicks in and then it clicks out.

00:28:14.660 --> 00:28:18.160
It actually feels really, you know, really nice and polished.

00:28:18.160 --> 00:28:23.220
Yeah, we've kind of identified there's like a sliding scale of animation.

00:28:23.220 --> 00:28:26.320
At one end, you've got like the scroll bars.

00:28:26.320 --> 00:28:28.680
It might not be obvious, but those animate.

00:28:28.680 --> 00:28:32.060
So if you click below it, it will scroll smoothly downwards.

00:28:32.060 --> 00:28:34.880
And also it will filter when you click and drag.

00:28:34.880 --> 00:28:39.140
It will filter sort of frames between the motion of the mouse.

00:28:39.300 --> 00:28:41.860
And it makes the scrolling look a lot more smooth.

00:28:41.860 --> 00:28:43.920
That's not obvious, but that is a use of animation.

00:28:43.920 --> 00:28:48.200
And at that end of the scale, I think most people would agree that's good.

00:28:48.200 --> 00:28:49.040
That's a bonus.

00:28:49.040 --> 00:28:54.080
At the other end of the scale, we've got things which are a bit gratuitous, like the sidebar.

00:28:54.080 --> 00:28:58.640
I like it, but some people might think, I don't want to be distracted by this animation.

00:28:58.780 --> 00:29:00.600
I just want it to appear instantly.

00:29:00.600 --> 00:29:04.100
I want it to be more, feel more snappy rather than animated.

00:29:04.100 --> 00:29:10.340
So I think what we're going to do is we're going to have like a switch where you can decide as a user what kind of animation you like.

00:29:10.340 --> 00:29:15.040
If you just want the scroll bars, you can set it to be quite low.

00:29:15.040 --> 00:29:18.940
And that would make the sidebar pop in instantly and disappear instantly.

00:29:18.940 --> 00:29:23.160
But if you love the animation, you can just whack it up to the maximum.

00:29:23.460 --> 00:29:27.360
And then it will use animation wherever it can for fading and sliding, etc.

00:29:27.360 --> 00:29:31.840
For example, with a scroll bar, that's not actually the terminal scrolling it.

00:29:31.840 --> 00:29:35.800
That's textual redrawing the screen and reprocessing it.

00:29:35.800 --> 00:29:42.680
If it's not smooth, if it just goes clunk, clunk, clunk, it's super hard to track when I scroll down.

00:29:42.680 --> 00:29:44.580
Where do I continue from?

00:29:44.580 --> 00:29:46.320
And that kind of stuff, right?

00:29:46.320 --> 00:29:49.380
It's not just there to make it feel good or feel smooth.

00:29:49.380 --> 00:29:51.940
It really has an important effect.

00:29:52.660 --> 00:30:00.480
Yeah, if you press the page down, if it was to jump down instantly, you wouldn't be able to find your place in the text again.

00:30:00.480 --> 00:30:04.820
Your eye would just have to focus in to find where you're reading.

00:30:04.820 --> 00:30:11.960
But if it scrolls in over, say, 300 milliseconds, your eye tends to follow where you were reading.

00:30:11.960 --> 00:30:16.580
So you move your eye, you follow the animation, and then you're sort of reading again from the top.

00:30:16.900 --> 00:30:18.720
And that's actually beneficial.

00:30:18.720 --> 00:30:19.940
It's not just eye candy.

00:30:19.940 --> 00:30:23.620
It's not just gratuitous use of a feature, you know?

00:30:23.620 --> 00:30:24.420
Yeah, absolutely.

00:30:24.420 --> 00:30:25.560
It's very, very helpful.

00:30:25.560 --> 00:30:30.380
So you talked about all of this happening without flickering in the terminal.

00:30:30.380 --> 00:30:34.120
We already discussed the GPU accelerated, hardware accelerated aspects.

00:30:34.120 --> 00:30:36.900
But you said also that's not necessarily enough.

00:30:37.040 --> 00:30:40.200
So there's a couple of tricks that you highlight here.

00:30:40.200 --> 00:30:44.240
The protocol of terminals came about over many decades.

00:30:44.240 --> 00:30:47.880
And it wasn't designed to avoid flickering.

00:30:47.880 --> 00:30:49.780
I think when people built the protocol...

00:30:49.780 --> 00:30:51.920
They never imagined what you would be trying to do with it.

00:30:51.920 --> 00:30:55.360
No, they didn't think someone was going to be animating it at 60 frames a second.

00:30:56.640 --> 00:30:58.420
So there's no...

00:30:58.420 --> 00:31:01.460
Well, there's very little help to reduce flicker.

00:31:01.460 --> 00:31:03.280
So there's a few things that you can do.

00:31:03.280 --> 00:31:09.620
One I've discovered is it's better to overwrite content without clearing it.

00:31:09.620 --> 00:31:16.380
So if you want to animate, say, a piece of text, make it move, you might think, I'll clear this text, and I'll draw on top of it.

00:31:16.380 --> 00:31:22.180
But what that does is it'll introduce a potential for a frame where you see where it's cleared.

00:31:22.180 --> 00:31:25.700
And then you see the frame where it's updated, and that'll cause flicker.

00:31:25.700 --> 00:31:31.900
So if you just overwrite the content without clearing it, then that reduces the chance of flickering.

00:31:31.900 --> 00:31:37.600
Yeah, I've also seen sometimes some of these progress bars or the little tables updating.

00:31:37.600 --> 00:31:40.320
They seem to write new whole sections.

00:31:40.320 --> 00:31:44.520
And it's like filling your history with every frame.

00:31:44.520 --> 00:31:48.600
Your terminal history is full of every frame and stuff like that.

00:31:48.600 --> 00:31:53.620
If you start to resize it, and there's all this weird stuff that happens if you're not actually overwriting it.

00:31:53.620 --> 00:31:55.900
Textual goes into what's called application mode.

00:31:55.900 --> 00:31:58.040
This is a feature of terminals.

00:31:58.040 --> 00:32:01.040
So when you're in application mode, you don't have a scroll back buffer.

00:32:01.040 --> 00:32:04.300
The scroll back buffer has that problem.

00:32:04.300 --> 00:32:08.640
It'll tend to fill up with garbage if you're trying to animate things.

00:32:08.640 --> 00:32:14.500
And it's also quicker because the terminal doesn't have to worry about appending data and moving it, etc.

00:32:14.600 --> 00:32:18.280
So Textual goes into application mode.

00:32:18.280 --> 00:32:22.300
And it's generally much faster and able to reduce that flickering.

00:32:22.300 --> 00:32:22.940
Trick two?

00:32:22.940 --> 00:32:23.980
Trick two.

00:32:23.980 --> 00:32:29.580
One of the problems with the protocol is that it's not aware of flickering.

00:32:29.580 --> 00:32:31.300
It doesn't know when to paint the screen.

00:32:31.300 --> 00:32:32.860
So you're sending it data.

00:32:32.860 --> 00:32:35.380
It needs to know when to update the screen.

00:32:35.380 --> 00:32:42.100
If you write lots of small pieces of data, say you're going to update a character over here, you're going to update a progress bar here.

00:32:42.100 --> 00:32:47.700
It might update a few of them and then paint the screen and then update some others and paint the screen.

00:32:47.700 --> 00:32:53.200
And it's that brief moment where you've got half an update, which is what causes flicker.

00:32:53.200 --> 00:33:05.860
So what I've discovered is if you batch all your updates into one write, so you just write standard output the ones rather than several writes, that will reduce the potential flicker quite a bit.

00:33:05.860 --> 00:33:06.400
Interesting.

00:33:06.400 --> 00:33:07.640
Of course it would.

00:33:07.640 --> 00:33:09.040
And I've never really thought about it.

00:33:09.260 --> 00:33:25.720
When you're doing regular pixel-based graphics programming, OpenGL, DirectX, those types of things, they often set up what's called a double-buffered mode, where you actually draw the screen on a hidden piece and then you swap that to be in one Vsync to be the screen.

00:33:25.720 --> 00:33:29.400
So you don't see the pieces streaming in as it goes.

00:33:29.400 --> 00:33:32.140
And this is the same equivalent thing for terminals, huh?

00:33:32.140 --> 00:33:33.480
It's like double-buffered mode.

00:33:33.480 --> 00:33:36.000
You write to it like a whole thing and then you make it the screen.

00:33:36.000 --> 00:33:37.540
It's a very similar concept.

00:33:38.060 --> 00:33:39.620
The terminal doesn't give you that.

00:33:39.620 --> 00:33:43.500
It doesn't have an invisible buffer that you can take your time to draw to.

00:33:43.500 --> 00:33:45.200
So you have to implement that yourself.

00:33:45.200 --> 00:33:47.880
But yeah, essentially, we're implementing a double-buffer.

00:33:47.880 --> 00:33:50.620
And the third one has to do with synchronized output.

00:33:50.620 --> 00:33:53.280
Doing the one write thing, that's very helpful.

00:33:53.280 --> 00:33:58.280
But there's also a fairly recent addition to the protocol, which helps with this.

00:33:58.280 --> 00:34:01.960
Basically, you write an escape code which says, I'm beginning an update.

00:34:01.960 --> 00:34:03.320
And then you write your data.

00:34:03.320 --> 00:34:06.620
And then you write another escape code which says, I've finished the update.

00:34:07.000 --> 00:34:10.220
But between those two escape codes, the terminal won't update.

00:34:10.220 --> 00:34:12.040
It'll only update at the very last moment.

00:34:12.040 --> 00:34:16.800
So that's kind of accomplishing the same thing as the double-buffer.

00:34:16.800 --> 00:34:17.780
Yeah, similar.

00:34:17.780 --> 00:34:23.360
So we do both because not all terminals support these new escape codes.

00:34:23.360 --> 00:34:29.640
So by doing both, we can ensure that it's flicker-free on newer terminals and older terminals.

00:34:29.640 --> 00:34:30.500
Yeah, fantastic.

00:34:30.500 --> 00:34:39.580
Speaking of different terminals, Kim in the audience asks, is application mode that you talked about earlier with the buffer a universal across all the terminals?

00:34:39.960 --> 00:34:40.780
It is, yeah.

00:34:40.780 --> 00:34:42.320
It's been around for a long time.

00:34:42.320 --> 00:34:48.060
If you've used HTOP or anything like it or a full-screen terminal app, that'll use application mode.

00:34:50.340 --> 00:34:53.100
This portion of Talk Byte Under Me is brought to you by Sentry.

00:34:53.100 --> 00:34:56.240
You know Sentry as a longtime sponsor of this podcast.

00:34:56.240 --> 00:34:59.900
They offer great error monitoring software that I've told you about many times.

00:34:59.900 --> 00:35:02.760
It's even software that we use on our own web apps.

00:35:02.760 --> 00:35:06.340
But this time, I want to tell you about a fun conference they have coming up.

00:35:07.000 --> 00:35:13.280
Deploying new code can be a lot like making a really great sandwich, taking a bite, and then having all the contents fall out.

00:35:13.280 --> 00:35:16.000
Exciting, chaotic, and maddening.

00:35:16.000 --> 00:35:20.160
If you know the feeling, then Dex by Sentry might be for you.

00:35:20.160 --> 00:35:28.060
This is a free conference by developers for developers, where you sort through the madness and look for ways to improve your workflow productivity.

00:35:28.380 --> 00:35:36.300
Join Sentry for this event in San Francisco or virtually on September 28th and discover new ways to make your life a little easier.

00:35:36.300 --> 00:35:40.280
Save your seat now at talkpython.fm/Dex.

00:35:40.280 --> 00:35:43.520
That's talkpython.fm/D-E-X.

00:35:43.520 --> 00:35:45.100
The link is in your show notes.

00:35:45.100 --> 00:35:48.400
Thank you to Sentry for supporting Talk Python to me.

00:35:48.400 --> 00:35:52.600
Final question while we're on this performance thing.

00:35:52.600 --> 00:35:54.540
When will we see Doom implemented?

00:35:54.540 --> 00:35:57.360
People keep asking that.

00:35:57.680 --> 00:35:58.500
I don't know.

00:35:58.500 --> 00:35:59.820
It might happen.

00:35:59.820 --> 00:36:00.920
I think it has to happen.

00:36:00.920 --> 00:36:03.220
I mean, Doom runs virtually everywhere.

00:36:03.220 --> 00:36:04.500
It does.

00:36:04.500 --> 00:36:06.020
Maybe the first Doom.

00:36:06.020 --> 00:36:07.060
Maybe not Doom Eternal.

00:36:07.060 --> 00:36:07.760
Yeah, yeah.

00:36:07.760 --> 00:36:11.400
We're thinking the original Doom that really was amazing.

00:36:11.400 --> 00:36:12.920
Right after Castle Wolfenstein.

00:36:12.920 --> 00:36:13.580
Very good stuff.

00:36:13.580 --> 00:36:14.760
Yeah, I love that.

00:36:14.760 --> 00:36:14.980
All right.

00:36:14.980 --> 00:36:18.080
So that was all some really interesting stuff about terminals.

00:36:18.080 --> 00:36:25.380
But we also have some other recommendations and discoveries that are pretty awesome, even if you're doing other types of programming.

00:36:25.380 --> 00:36:27.580
And one of them is Dict Views.

00:36:27.840 --> 00:36:31.820
Apparently, I used Dict Views a lot, but I didn't really know they had a special name.

00:36:31.820 --> 00:36:33.800
Tell us what are Dict Views and then why are they useful?

00:36:34.200 --> 00:36:40.920
So Dict Views are the object returned from a dictionary when you call items or keys.

00:36:41.020 --> 00:36:48.360
And I think almost all Python developers have used this, but we tend to use them to iterate over to get the keys and the items.

00:36:48.360 --> 00:36:51.480
What you might not know is these are special objects.

00:36:51.480 --> 00:36:52.700
They're not just simple iterables.

00:36:52.700 --> 00:36:56.520
And they act a lot like sets, which kind of makes sense.

00:36:56.520 --> 00:36:59.940
Because if you've got a dictionary, the keys are all unique.

00:36:59.940 --> 00:37:01.900
So you can't have a repeating key.

00:37:01.900 --> 00:37:07.880
So if you've got a key view, it's set-like, which means you can do set-like operations on it.

00:37:07.880 --> 00:37:08.280
Right.

00:37:08.280 --> 00:37:12.740
You know, ask the quick question, like, is this thing I'm about to add in here or not?

00:37:12.740 --> 00:37:13.560
Something like that, right?

00:37:13.560 --> 00:37:14.120
Yeah.

00:37:14.120 --> 00:37:14.620
Yeah.

00:37:14.720 --> 00:37:25.340
And you can take two different, you can take a set and a key view and combine them and see the intersection and see what keys are common in both or neither.

00:37:25.340 --> 00:37:31.220
And those type of operations turned out to be very useful for what I was using it for.

00:37:31.220 --> 00:37:35.220
And to be honest, I think this might be the first time I've ever used that in anger.

00:37:35.220 --> 00:37:39.320
It's one of the things that you read about in the notes for the latest Python.

00:37:39.320 --> 00:37:41.740
And you think, I can't imagine I'll ever use that.

00:37:42.160 --> 00:37:51.880
And I didn't for years, but then I had a problem where in Textual, when we do a new update via CSS, we've got two different data structures.

00:37:51.880 --> 00:37:55.620
One with the old positions of things and then one with the new positions of things.

00:37:55.620 --> 00:38:02.120
What we want to do is compare those two data structures and find the things which have moved or have changed size.

00:38:02.120 --> 00:38:05.980
And I started writing code for this and it wasn't straightforward code.

00:38:05.980 --> 00:38:07.440
It was a couple of hours in.

00:38:07.440 --> 00:38:09.820
I had written a lot of code and I think, that's a bit too slow.

00:38:09.820 --> 00:38:11.040
It's a bit too awkward.

00:38:11.620 --> 00:38:17.600
And only then did I remember the fact that you could use these key views as set operations.

00:38:17.600 --> 00:38:20.920
And the code turned out to be almost a one-liner.

00:38:20.920 --> 00:38:23.860
And, you know, I was so happy about this.

00:38:23.860 --> 00:38:28.940
I forgot the fact I'd spent two hours writing code that I had just deleted.

00:38:28.940 --> 00:38:31.960
Let me give people an example here who are listening.

00:38:32.200 --> 00:38:34.820
So if you check out the blog post, there's a nice code example.

00:38:34.820 --> 00:38:38.540
And, you know, the UI of Textual is made up of all these widgets.

00:38:38.540 --> 00:38:41.300
They've got names like header, footer and sidebar.

00:38:41.300 --> 00:38:44.220
And they have boundaries and regions, rectangles.

00:38:44.580 --> 00:38:50.620
And as the UI changes, you might only want to redraw the delta, not the whole thing for performance reason, right?

00:38:50.920 --> 00:38:56.080
And so given the old view and the new view, the question is, well, what widgets have changed?

00:38:56.080 --> 00:39:04.580
And so you just say render map dot items, carrot or symmetric difference with the other newer frame dot items.

00:39:04.580 --> 00:39:07.760
And that tells you these are the pieces that have to be redrawn, right?

00:39:08.040 --> 00:39:09.940
Yeah, that gets exactly the information needed.

00:39:09.940 --> 00:39:15.920
That tells me which things are new, which things have been removed, and then which things have changed position.

00:39:15.920 --> 00:39:20.060
And those three types of things are the things that I need to redraw on the screen.

00:39:20.060 --> 00:39:22.060
And, you know, it's a one-liner.

00:39:22.060 --> 00:39:26.340
And I get that information for free because it is very fast.

00:39:26.340 --> 00:39:30.880
It runs at the C level and produces just information that I needed.

00:39:30.880 --> 00:39:33.580
Honestly, this surprises me that this is possible.

00:39:34.020 --> 00:39:38.240
I would totally expect that with dot keys because keys have to be set like.

00:39:38.240 --> 00:39:43.060
But items, you could have the same item assigned to different keys all over the place and stuff.

00:39:43.060 --> 00:39:44.660
So it's a little interesting here.

00:39:44.660 --> 00:39:48.400
The item is, you know, obviously the key plus the value.

00:39:48.400 --> 00:39:50.680
So together, they're unique.

00:39:50.680 --> 00:39:51.660
The values are not unique.

00:39:51.660 --> 00:39:52.060
Oh, I see.

00:39:52.060 --> 00:39:52.400
That's right.

00:39:52.400 --> 00:39:54.460
Because that's a tuple of the key.

00:39:54.460 --> 00:39:55.140
I see.

00:39:55.140 --> 00:39:55.740
Got it.

00:39:55.740 --> 00:39:55.980
Okay.

00:39:55.980 --> 00:39:58.020
So the keys are guaranteed to be unique.

00:39:58.020 --> 00:39:58.220
That makes sense.

00:39:58.220 --> 00:40:01.080
That's therefore, yeah, whatever you add to it.

00:40:01.080 --> 00:40:03.760
It's not going to make it less unique by adding stuff.

00:40:03.760 --> 00:40:05.560
More possible differences.

00:40:05.560 --> 00:40:06.440
All right.

00:40:06.440 --> 00:40:10.320
So not totally related to this, but I got to ask it because it's just so meta.

00:40:10.320 --> 00:40:14.720
Andrew out in the audience asked, can you embed a terminal within a textual app?

00:40:14.720 --> 00:40:15.620
I can't.

00:40:15.620 --> 00:40:16.760
I've been asked this a few times.

00:40:16.760 --> 00:40:18.900
I'm just, I'm wondering what people want to use this for.

00:40:18.900 --> 00:40:21.240
But in theory, it should be possible.

00:40:21.240 --> 00:40:26.920
It means I'd have to write a software layer which interpreted all the escape codes and then

00:40:26.920 --> 00:40:30.040
translated that to like a region of the textual app.

00:40:30.040 --> 00:40:32.280
But in theory, yes, it's possible.

00:40:32.280 --> 00:40:33.600
Will we do it?

00:40:33.780 --> 00:40:34.040
Maybe.

00:40:34.040 --> 00:40:34.800
One day.

00:40:34.800 --> 00:40:38.280
It's not the highest on the priority, but maybe.

00:40:38.280 --> 00:40:39.040
Yeah, maybe.

00:40:39.040 --> 00:40:39.320
Okay.

00:40:39.320 --> 00:40:40.040
Very interesting.

00:40:40.040 --> 00:40:43.420
Is there something like a textual.contrib?

00:40:43.420 --> 00:40:48.480
You know, these extras that people put in, like there's Django.contrib and there's other

00:40:48.480 --> 00:40:49.240
contribs.

00:40:49.240 --> 00:40:49.800
Yeah.

00:40:49.800 --> 00:40:54.740
Not currently, but I'm really hoping that the community takes it and starts building things.

00:40:54.740 --> 00:41:00.400
So you could search PyPy for textual underscore and get lots of widget libraries and various

00:41:00.400 --> 00:41:00.920
add-ons.

00:41:00.920 --> 00:41:05.400
Is there like a plugin or extension aspect?

00:41:05.400 --> 00:41:06.980
Anything official like that?

00:41:07.240 --> 00:41:07.460
Yes.

00:41:07.460 --> 00:41:10.480
So the widgets are designed to be built that way.

00:41:10.480 --> 00:41:16.140
Widgets are like independent portions of the screen that can handle events and things and

00:41:16.140 --> 00:41:16.640
updates.

00:41:16.640 --> 00:41:20.600
And those are bundled up into separate libraries, third-party libraries.

00:41:21.020 --> 00:41:23.700
So that would be the easiest way to implement something.

00:41:23.700 --> 00:41:29.080
You could implement anything you wish, like a full IDE if you wanted to and just import

00:41:29.080 --> 00:41:30.400
it as a Python library.

00:41:30.400 --> 00:41:30.840
Sure.

00:41:31.380 --> 00:41:37.820
Related to using dictvues for speed, it's really hard to beat caching for speed, isn't

00:41:37.820 --> 00:41:37.980
it?

00:41:37.980 --> 00:41:38.400
Yeah.

00:41:38.400 --> 00:41:43.580
Caching is awesome and it's one of the things which allows textual to be fast.

00:41:43.580 --> 00:41:48.680
So LRU cache, I think a lot of people have used it, but maybe not appreciated how fast

00:41:48.680 --> 00:41:49.020
it is.

00:41:49.020 --> 00:41:51.860
Caching and generating the key is done at the C level.

00:41:51.860 --> 00:41:55.960
So it's super fast and you can use it for quite small functions.

00:41:55.960 --> 00:41:59.220
We've got a lot of calculations which are pretty quick.

00:41:59.640 --> 00:42:03.860
You know, they're well under milliseconds, like fractions of a millisecond.

00:42:03.860 --> 00:42:05.440
But we do them a lot of times.

00:42:05.440 --> 00:42:07.580
So we might do them like 10,000 times.

00:42:07.580 --> 00:42:14.040
But if we introduce the LRU cache, the time it takes to do those function calls becomes time

00:42:14.040 --> 00:42:16.180
it takes to essentially do a dictionary lookup.

00:42:16.180 --> 00:42:18.000
Then they become very fast.

00:42:18.000 --> 00:42:22.300
So that can, that led to quite surprising speed ups.

00:42:22.300 --> 00:42:22.860
Yeah.

00:42:22.860 --> 00:42:29.200
So you have an example here that you talk about where you're given a couple of regions

00:42:29.200 --> 00:42:32.780
regions and you do the intersection of those two, right?

00:42:32.780 --> 00:42:35.700
A region being like a rectangle like thing.

00:42:35.700 --> 00:42:36.140
Yeah.

00:42:36.140 --> 00:42:40.760
So you've got to figure out, well, which is the top left most and like all those, there's

00:42:40.760 --> 00:42:45.460
a bunch of comparisons to find the overlapping rectangle if it exists.

00:42:45.460 --> 00:42:46.020
Right.

00:42:46.020 --> 00:42:47.160
And then, yeah.

00:42:47.160 --> 00:42:48.220
It's not very complicated.

00:42:48.220 --> 00:42:49.260
It's not very slow.

00:42:49.520 --> 00:42:52.780
It's just doing sort of arithmetic and it's working on local variables.

00:42:52.780 --> 00:42:56.040
That's generally the fastest kind of code you can expect from Python.

00:42:56.040 --> 00:43:01.500
You also, you create a region object which has to reserve some memory.

00:43:01.500 --> 00:43:05.460
But if you put the LRU cache on it, that becomes a dick lookup.

00:43:05.460 --> 00:43:06.480
So it becomes very fast.

00:43:06.860 --> 00:43:13.000
And the type of calculations we're doing, we often do the same ones many, many times.

00:43:13.000 --> 00:43:15.780
So we'll use the same two values to find intersection.

00:43:15.780 --> 00:43:20.060
Like that the first time you update the screen, you calculate some intersections.

00:43:20.060 --> 00:43:22.620
And the second time, maybe one or two items has moved.

00:43:22.620 --> 00:43:25.620
But most of the same calculations are done again.

00:43:26.620 --> 00:43:30.080
So LRU cache ensures that you don't do those calculations again.

00:43:30.080 --> 00:43:31.500
You just pick them out of a dictionary.

00:43:31.500 --> 00:43:33.420
And yeah, big wins.

00:43:33.420 --> 00:43:37.040
And it's so easy to just copy that one line and everything works.

00:43:37.040 --> 00:43:37.480
Yeah.

00:43:37.480 --> 00:43:40.560
Also, it's kind of related to what we're going to get to here.

00:43:40.560 --> 00:43:46.080
But this kind of code is fantastic because in terms of caching, because it doesn't really

00:43:46.080 --> 00:43:49.220
depend on something that could change behind the scenes.

00:43:49.220 --> 00:43:55.000
It doesn't have hold of like weird pointers that other, you know, could change in other ways.

00:43:55.000 --> 00:43:58.820
And so it's very, very deterministic.

00:43:58.820 --> 00:44:00.660
It's going to give you the same answer every time.

00:44:00.660 --> 00:44:05.080
And, you know, it's not like the cache is going to get weirdly stale, right?

00:44:05.080 --> 00:44:06.240
Yeah, exactly.

00:44:06.240 --> 00:44:08.540
So it's an immutable object.

00:44:08.540 --> 00:44:11.100
I think region is actually a named tuple.

00:44:11.100 --> 00:44:13.520
And you get all those benefits.

00:44:13.520 --> 00:44:14.580
There's no side effects.

00:44:14.580 --> 00:44:17.800
You can write these functions that have got an input and an output.

00:44:17.800 --> 00:44:20.380
And it doesn't depend on any other state.

00:44:20.380 --> 00:44:23.560
And when you have that kind of function, I think they call it a pure function.

00:44:24.120 --> 00:44:26.100
It's caching works beautifully.

00:44:26.100 --> 00:44:28.440
There's no hidden surprises.

00:44:28.440 --> 00:44:32.400
And also, I think, makes your code more easy to reason about.

00:44:32.400 --> 00:44:35.220
You can trace it, you know, just manually.

00:44:35.220 --> 00:44:37.360
You can tell what's going on.

00:44:37.360 --> 00:44:41.720
Just by looking at one function, you can see the full story.

00:44:41.720 --> 00:44:42.600
Sure.

00:44:42.600 --> 00:44:43.100
Yeah.

00:44:43.100 --> 00:44:44.040
Immutable objects.

00:44:44.420 --> 00:44:48.500
If your code can use immutable objects, I think you should favor it.

00:44:48.500 --> 00:44:49.900
It doesn't always make sense.

00:44:49.900 --> 00:44:51.800
But immutable is definitely best.

00:44:51.800 --> 00:44:52.180
Yeah.

00:44:52.180 --> 00:44:53.820
Definitely easy to reason about.

00:44:53.820 --> 00:45:02.140
Kim in the audience says, presumably, the memory cost of caching many frequently called functions isn't a big issue on a reasonable machine.

00:45:02.140 --> 00:45:06.940
And maybe it's worth pointing out the max size parameter you passed to the LRU cache.

00:45:06.940 --> 00:45:07.660
That's right.

00:45:07.740 --> 00:45:09.660
So you set a maximum size.

00:45:09.660 --> 00:45:13.860
And if you add more items than that, it'll throw out the oldest one.

00:45:13.860 --> 00:45:18.040
So you can define the set, the maximum size that you will record.

00:45:18.040 --> 00:45:20.420
And it depends on how you use it.

00:45:20.980 --> 00:45:30.340
If you tend to have like a common set of calculations, which you're doing repeatedly, and those will kind of be in the cache most of the time.

00:45:30.340 --> 00:45:35.760
And then you might have some calculations which happen infrequently, you know, combinations of input and output.

00:45:35.760 --> 00:45:38.520
And then those get recalculated occasionally.

00:45:38.520 --> 00:45:40.160
But it's still a big win.

00:45:40.160 --> 00:45:46.140
And for 4,096 items for that, the regions name tuple is quite small.

00:45:46.140 --> 00:45:50.360
So that keeps the memory usage to something reasonable.

00:45:50.720 --> 00:45:55.880
I did want to highlight this project called Async Cache.

00:45:55.880 --> 00:46:02.840
Because I think, I haven't checked lately, but I think the LRU cache is only for synchronous functions.

00:46:02.840 --> 00:46:03.740
I think so, yeah.

00:46:03.740 --> 00:46:04.680
Yeah, I think so too.

00:46:04.680 --> 00:46:06.140
You know, maybe it's been upgraded.

00:46:06.140 --> 00:46:07.000
I haven't checked.

00:46:07.000 --> 00:46:18.000
But if it's still true, there's this project called Async Cache, which has nearly the same UI, but applies to Async functions.

00:46:18.720 --> 00:46:24.560
So basically, the decorator has to return a function, which is first checks the cache and then calls the function.

00:46:24.560 --> 00:46:29.020
For the Async version, that has to be an Async function returned out of the decorator.

00:46:29.020 --> 00:46:31.180
Hence the difference, right?

00:46:31.420 --> 00:46:37.200
And so this Async Cache has something really similar where you can have an LRU cache where you set the max size.

00:46:37.200 --> 00:46:42.900
Or you can also have a time to live, like I only want these results to stick around for 60 seconds.

00:46:43.620 --> 00:46:51.920
It also has a bunch of other interesting features that you can bring in, like works on ORM objects, request objects, a bunch of other things.

00:46:51.920 --> 00:46:58.160
It has sort of custom support for custom types that are one of the things that this needs here.

00:46:58.160 --> 00:47:00.420
I think it's hashable.

00:47:00.420 --> 00:47:03.880
I think you have to have hashable arguments for LRU cache.

00:47:04.320 --> 00:47:06.760
Yeah, that strikes me as something very useful.

00:47:06.760 --> 00:47:13.140
If you've got a calculation which does some of weights and you want to cache it, then yeah, that looks like a fantastic project.

00:47:13.140 --> 00:47:14.180
Not super popular.

00:47:14.180 --> 00:47:16.780
People can check it out, but it looks pretty useful.

00:47:16.940 --> 00:47:26.900
Okay, we kind of touched on this already, so maybe we won't go too much into it, but just one of the actual lessons you said is immutability is definitely a good thing.

00:47:26.900 --> 00:47:31.500
So we can get this from tuples, named tuples, which are like better tuples.

00:47:31.500 --> 00:47:36.540
You know, you can address them by a variable type or frozen data classes.

00:47:36.540 --> 00:47:39.260
I tend to think immutable first.

00:47:39.260 --> 00:47:42.280
So I'll prefer to make my objects immutable.

00:47:42.280 --> 00:47:46.440
And only when I think that's going to become a hindrance do I make them mutable.

00:47:46.440 --> 00:47:51.780
And that's, I think, I started doing that a few years ago, and I think that's benefited my code.

00:47:51.780 --> 00:47:53.700
So I'd recommend mutable objects.

00:47:53.700 --> 00:47:54.040
Yeah.

00:47:54.040 --> 00:48:02.960
And then if you're out there doing Pydantic, which many of us are these days, it has faux immutability, which is kind of like it.

00:48:02.960 --> 00:48:05.240
It takes a shot at making things immutable.

00:48:05.240 --> 00:48:11.620
And you can just say allow mutation false as the config for your Pydantic model, which is pretty fantastic.

00:48:12.060 --> 00:48:12.120
Yeah.

00:48:12.120 --> 00:48:14.900
I think Python doesn't support true immutability.

00:48:14.900 --> 00:48:16.160
Immutability.

00:48:16.160 --> 00:48:22.260
If you really wanted to, you could do some horrible hack to change an object, which should be immutable.

00:48:22.260 --> 00:48:25.820
But, you know, like Python's philosophy is we're all adults here, right?

00:48:25.820 --> 00:48:28.140
So don't do crazy things like that.

00:48:28.140 --> 00:48:35.820
And even for languages that have like the word const and stuff, it still doesn't necessarily mean what you think it means.

00:48:35.820 --> 00:48:37.820
There's a little bit of Monty Python going on.

00:48:38.040 --> 00:48:46.240
No, Princess Bride sort of thing going on there where, okay, so this object says it can't be mutable and it has pointers to other objects.

00:48:46.240 --> 00:48:52.920
And so sure, you can't reassign those pointers, but that thing points to something which points to something, which internally you call a function which changes.

00:48:52.920 --> 00:48:53.520
You know what I mean?

00:48:53.600 --> 00:48:58.180
Like to get true immutability is super hard and super restrictive.

00:48:58.180 --> 00:48:59.520
Super hard, yeah.

00:48:59.520 --> 00:48:59.960
Yeah, yeah.

00:48:59.960 --> 00:49:02.140
So Python isn't too bad in that respect.

00:49:02.140 --> 00:49:05.920
It's definitely safer than C, C++, et cetera.

00:49:06.920 --> 00:49:07.780
Yes, that's for sure.

00:49:07.780 --> 00:49:09.880
Okay, immutability is good.

00:49:09.880 --> 00:49:12.100
So is Unicode art.

00:49:12.100 --> 00:49:13.340
What the heck is this?

00:49:13.340 --> 00:49:18.340
In the textual code, there's quite a lot of functions like this, which are kind of geometric.

00:49:18.340 --> 00:49:20.760
So it might divide something into two.

00:49:20.760 --> 00:49:23.180
Yeah, it's always doing visual things, right?

00:49:23.180 --> 00:49:24.420
Quite a lot of visual things.

00:49:24.420 --> 00:49:25.740
So here we've got an example.

00:49:25.740 --> 00:49:32.100
It's a function which takes a region and splits it into four by making two, or making a horizontal and a vertical cut.

00:49:32.660 --> 00:49:36.460
And that's quite hard to express in English succinctly.

00:49:36.460 --> 00:49:39.700
I mean, you can do it, but it'll take you like a big paragraph.

00:49:39.700 --> 00:49:50.500
But if you create something like this, this kind of Unicode art using various box characters, you can draw a diagram to show what you're doing.

00:49:50.500 --> 00:49:57.160
And if you're coming to that code later, that just makes it really obvious at a glance what it's doing.

00:49:57.160 --> 00:49:58.120
Yeah, it's fantastic.

00:49:58.120 --> 00:50:01.380
I'm a big fan of that kind of Unicode art.

00:50:01.560 --> 00:50:05.800
And I use an application called Monodraw, which is macOS only.

00:50:05.800 --> 00:50:08.860
But there are similar applications for other platforms.

00:50:08.860 --> 00:50:11.620
And yeah, I use it wherever I can.

00:50:11.620 --> 00:50:13.320
Also because it's kind of fun.

00:50:13.320 --> 00:50:15.240
It is cool.

00:50:15.240 --> 00:50:18.180
A powerful ASCII art editor designed for the Mac.

00:50:18.180 --> 00:50:21.400
It costs money, $10.

00:50:21.400 --> 00:50:24.860
I love that it has educational pricing, but it only costs $10.

00:50:24.860 --> 00:50:28.000
That's kind of cool.

00:50:28.000 --> 00:50:30.280
But yeah, it's pretty neat.

00:50:30.280 --> 00:50:34.400
I guess you have little arrows and boxes.

00:50:34.400 --> 00:50:42.500
And just like you might draw with PowerPoint or Keynote or something like that is kind of your, let me put together a visual graphic.

00:50:42.500 --> 00:50:44.520
But then output is ASCII art.

00:50:44.520 --> 00:50:44.920
Yeah.

00:50:44.920 --> 00:50:47.440
And it's kind of like a vector graphic type thing.

00:50:47.520 --> 00:50:50.520
So if you draw a box, you can click on the box and drag it.

00:50:50.520 --> 00:50:52.260
It's not like a bitmap.

00:50:52.260 --> 00:50:53.340
Oh, that's fantastic.

00:50:53.340 --> 00:50:55.680
Yeah, it's quite powerful.

00:50:55.680 --> 00:50:59.200
I hope the authors made a fortune out of it, frankly, because I love it.

00:51:00.040 --> 00:51:01.460
So what is the output like?

00:51:01.460 --> 00:51:02.940
You output to clipboard?

00:51:02.940 --> 00:51:05.520
Yeah, you can cut and paste it.

00:51:05.520 --> 00:51:06.420
You output to clipboard.

00:51:06.420 --> 00:51:08.220
You can write it to a text file.

00:51:08.220 --> 00:51:11.220
I usually cut and paste it directly into Python code.

00:51:11.220 --> 00:51:12.060
Yeah, of course.

00:51:12.060 --> 00:51:13.340
So that's really cool.

00:51:13.420 --> 00:51:18.080
It also made me think of something that's not exactly the same purpose, but Balsamic.

00:51:18.080 --> 00:51:22.660
I don't know if you're familiar with Balsamic, which is really great for developing UIs.

00:51:22.660 --> 00:51:24.380
I don't know if they have a gallery or something.

00:51:24.380 --> 00:51:27.020
They need some more graphics on this thing here.

00:51:27.360 --> 00:51:29.240
Yeah, I've used Balsamic for a while.

00:51:29.240 --> 00:51:31.200
It's been around for a long time, hasn't it?

00:51:31.200 --> 00:51:32.280
It's been around forever.

00:51:32.280 --> 00:51:37.580
Yeah, but it basically lets you create UIs that look almost like as if they were created

00:51:37.580 --> 00:51:39.480
using ASCII art.

00:51:39.480 --> 00:51:42.220
Not quite, but it's an interesting goal.

00:51:42.220 --> 00:51:47.300
I did also want to highlight the most useful piece of ASCII art.

00:51:47.300 --> 00:51:51.380
And to be clear, all of this discussion is what goes in the comments, right?

00:51:51.380 --> 00:51:53.500
What goes in the code comments or the doc strings?

00:51:53.940 --> 00:51:58.940
The one for, what is it, for the object allocator in Python.

00:51:58.940 --> 00:52:08.720
So if you look in obmalloc.c in CPython, there's all this fairly intense looking code for allocating

00:52:08.720 --> 00:52:16.740
memory when it's particular CPython objects, like a py object or a py long or whatever, right?

00:52:16.740 --> 00:52:22.440
If you scroll down to the section here around line 777, it has a paragraph.

00:52:22.660 --> 00:52:24.640
It's an object allocator for Python.

00:52:24.640 --> 00:52:28.480
Here's an introduction to the layers of Python's memory architecture, etc.

00:52:28.480 --> 00:52:36.760
And instead of having an essay in here, it has this incredible graphic that is like vertically aligned and shows you,

00:52:36.760 --> 00:52:39.360
here's where we allocate things like integers and lists.

00:52:39.360 --> 00:52:42.960
And here's Python core non-object memory allocation.

00:52:43.300 --> 00:52:46.820
Here's how it relates down to the OS and to actual hardware.

00:52:46.820 --> 00:52:47.820
What do you think of this?

00:52:47.820 --> 00:52:48.760
That's pretty awesome.

00:52:48.760 --> 00:52:52.700
A lot of respect to the author because I'm fairly sure they didn't use monodraw.

00:52:52.700 --> 00:52:57.400
I think they did that by hand with typing the characters and spaces and everything.

00:52:57.400 --> 00:52:59.140
Yeah, it's pretty awesome.

00:52:59.420 --> 00:53:00.880
Yeah, I think this is really fantastic.

00:53:00.880 --> 00:53:10.740
I was trying to piece together, you know, I did a course on Python memory and I was trying to piece together like, well, how do I visually represent how it is described that the memory works?

00:53:10.740 --> 00:53:12.480
And I'm like, well, let me go look in the source code.

00:53:12.480 --> 00:53:15.200
And I was looking at this like, there's an actual picture in here.

00:53:15.200 --> 00:53:16.040
This is amazing.

00:53:16.040 --> 00:53:17.300
I can't believe it.

00:53:17.300 --> 00:53:18.640
So, so neat.

00:53:18.760 --> 00:53:18.920
Yeah.

00:53:18.920 --> 00:53:24.860
So anyway, if people need a concrete example of the type of stuff you're talking about, here's one that's pretty close to home.

00:53:24.860 --> 00:53:26.680
We all use it every day and we didn't know.

00:53:26.680 --> 00:53:27.280
Fractions.

00:53:27.280 --> 00:53:32.520
I was always amazed at the fact that 0.1 plus 0.1 plus 0.1 is not equal to 0.3.

00:53:32.520 --> 00:53:35.760
I learned that in the school and it was, but for some reason it's not.

00:53:35.760 --> 00:53:36.320
What do you think?

00:53:36.320 --> 00:53:39.880
Yeah, so this is a problem that goes, this is, it's not just Python.

00:53:39.880 --> 00:53:44.540
It's pretty much any language which uses floats and doubles, which is like almost all of them.

00:53:44.540 --> 00:53:47.480
And it trips up beginners and experienced developers.

00:53:48.000 --> 00:53:50.040
It tripped up me when I was working on Textual.

00:53:50.040 --> 00:53:54.080
We have lots of code which will divide the screen into various proportions.

00:53:54.080 --> 00:53:59.080
So you might have a third and then a two thirds and you might divide the height into sevenths.

00:53:59.080 --> 00:54:03.020
And what I found was that when I used floats, I got a lot of rounding error.

00:54:03.020 --> 00:54:09.200
Not, actually not a lot of rounding error, but occasional rounding error, which means it wouldn't draw a line or it wouldn't draw a column.

00:54:09.200 --> 00:54:16.920
Because this kind of issue where the rounding error is compounded and it's been rounded down to the nearest character.

00:54:17.240 --> 00:54:17.520
Right.

00:54:17.520 --> 00:54:20.880
Because you've got to, you've got to talk in like little block pieces anyway.

00:54:20.880 --> 00:54:22.940
And if it just misses it, right?

00:54:22.940 --> 00:54:28.220
If it just misses it by 0.0000001, then, then you'll be a whole character out.

00:54:28.520 --> 00:54:38.460
And I did come up with like various ways of solving this where I used integers rather than floats and kept track of the error, which I think is the standard approach of doing it.

00:54:38.460 --> 00:54:42.300
But it was quite tricky code and I get it wrong too frequently.

00:54:42.300 --> 00:54:44.680
But then I remembered fractions.

00:54:44.680 --> 00:54:51.540
So fractions is, they behave just like numbers, but they start at life as a numerator and a denominator.

00:54:51.540 --> 00:54:54.420
So now fraction 1, 2 equals a half.

00:54:54.420 --> 00:54:59.140
And the great thing about fractions in the standard library is they don't suffer from that rounding error.

00:54:59.420 --> 00:55:06.440
So if you have, you know, three, one tenths, it'll add up to three tenths exactly with no rounding error.

00:55:06.440 --> 00:55:11.420
And it makes that kind of code, which I do a lot of in textual, to be much simpler.

00:55:11.920 --> 00:55:18.760
So I was very happy when I re-remembered it because I must have known years ago and thought, why do I need fractions?

00:55:18.760 --> 00:55:19.660
Yeah, exactly.

00:55:19.660 --> 00:55:20.380
Yeah.

00:55:20.380 --> 00:55:22.560
This is not elementary school.

00:55:22.560 --> 00:55:23.240
I don't need this.

00:55:23.240 --> 00:55:23.800
Come on.

00:55:23.800 --> 00:55:25.840
We could just say 0.1.

00:55:25.840 --> 00:55:26.320
Yeah.

00:55:26.320 --> 00:55:32.440
So you learn that you think, well, that's probably useful to mathematicians or something or someone else, not to me.

00:55:32.440 --> 00:55:38.840
But if you work long enough, you'll eventually find a problem where that is actually the perfect solution for it.

00:55:38.840 --> 00:55:40.080
I didn't know about these either.

00:55:40.340 --> 00:55:43.620
I see comments in the audience as well, like, fractions, what is this madness?

00:55:43.620 --> 00:55:51.460
So you're telling us that you can only work in rational numbers, not, you know, irrational numbers like pi and E.

00:55:51.460 --> 00:55:54.940
We can't have columns that are E-wide.

00:55:54.940 --> 00:55:56.840
No, no, you can't.

00:55:56.840 --> 00:55:58.420
Or pi high.

00:55:58.420 --> 00:56:01.840
It's pi by E.

00:56:01.840 --> 00:56:02.740
No, it's cut off.

00:56:02.740 --> 00:56:03.240
Darn it.

00:56:03.240 --> 00:56:03.580
Yeah.

00:56:03.580 --> 00:56:08.780
The cool thing is that fractions, you can drop in replacements to float.

00:56:08.880 --> 00:56:17.100
So if you've written some code which was previously using floats and then you pass in fractions, everything will work as normal, except you'll not get the rounding error.

00:56:17.100 --> 00:56:18.700
It's really kind of beautiful.

00:56:18.700 --> 00:56:19.040
Okay.

00:56:19.360 --> 00:56:27.040
So you're saying the fraction library supports things like division, multiplication, additions, and basically would duck typing behave the same?

00:56:27.040 --> 00:56:27.520
Yeah.

00:56:27.520 --> 00:56:29.560
It's duck typing as a rational number.

00:56:29.560 --> 00:56:32.760
So anywhere we use a float, fractional work.

00:56:32.760 --> 00:56:33.220
Okay.

00:56:33.220 --> 00:56:34.700
I learned about that.

00:56:34.700 --> 00:56:35.060
Amazing.

00:56:35.060 --> 00:56:35.820
Let's see.

00:56:35.820 --> 00:56:37.380
Emojis are hard.

00:56:37.380 --> 00:56:41.760
You talked a little bit about things that take up different sizes and Unicode and whatnot.

00:56:41.980 --> 00:56:42.200
Yeah.

00:56:42.200 --> 00:56:42.780
Yeah.

00:56:42.780 --> 00:56:53.360
So when I started Textalize and I got my first employee, I thought this is the problem that I want to tackle because it has been bugging me for two whole years.

00:56:53.740 --> 00:57:01.200
And the problem is basically this, that some characters will take up two cells in the terminal, they'll double wide, and some characters will take up one cell.

00:57:01.200 --> 00:57:10.580
And if you want to do any kind of formatting, say to draw a line or a panel around it, you need to know exactly how many cells a piece of text will take up.

00:57:10.800 --> 00:57:12.540
And it sounds like a simple problem.

00:57:12.540 --> 00:57:16.420
All you need to do is know how many cells a character will take up.

00:57:16.420 --> 00:57:20.000
So you might have a function which takes a character and returns either one or two.

00:57:20.000 --> 00:57:23.340
And in essence, that's what Rich does.

00:57:23.340 --> 00:57:30.160
But at some characters, you can't know because they will render differently on different terminals.

00:57:30.160 --> 00:57:34.380
They'll render differently on iTerm and Windows and Linux.

00:57:34.380 --> 00:57:36.600
And it gets even more complicated.

00:57:36.800 --> 00:57:41.920
You can get multiple characters, so multiple code points in the characters.

00:57:41.920 --> 00:57:44.220
So you might have something like a flag.

00:57:44.220 --> 00:57:49.120
And a flag has a two-letter character code and another character code which tells you this is a flag.

00:57:49.120 --> 00:57:52.360
So if you iterate over that, you get three code points.

00:57:52.360 --> 00:57:56.360
So you have to know, first of all, how everything works together.

00:57:56.360 --> 00:57:58.520
And there's quite a lot of those type of characters.

00:57:58.520 --> 00:58:01.840
I can't imagine how tricky it is to be done inside Unicode.

00:58:01.840 --> 00:58:02.400
Yeah.

00:58:02.400 --> 00:58:02.960
Yeah.

00:58:02.960 --> 00:58:04.520
It's crazy.

00:58:05.320 --> 00:58:06.940
It's very, very complex.

00:58:06.940 --> 00:58:09.440
And, you know, we thought, well, we'll just do it.

00:58:09.440 --> 00:58:12.580
We'll just apply some engineering effort and just do it.

00:58:12.580 --> 00:58:18.060
But we discovered that it was impossible to know because you can't tell how the terminal is going to render these Unicode.

00:58:18.060 --> 00:58:19.620
It might do it correctly.

00:58:19.620 --> 00:58:21.440
It might actually render a single character.

00:58:21.440 --> 00:58:27.160
If the terminal is not aware of multi-code point emojis, then you might get three characters.

00:58:27.160 --> 00:58:33.360
They might render as nothing or they might render as three double width characters.

00:58:33.360 --> 00:58:35.520
They might not even render properly.

00:58:35.520 --> 00:58:37.860
So they might overlap following character.

00:58:37.860 --> 00:58:39.280
Some number of boxes.

00:58:39.280 --> 00:58:40.000
Yeah.

00:58:40.000 --> 00:58:42.520
It's just every terminal did it differently.

00:58:42.520 --> 00:58:45.100
Not only the terminal, it was platform dependent.

00:58:45.360 --> 00:58:54.140
So if the terminal used the Unicode database on the operating system, then you'd get different results if it shipped its own copy of the Unicode database.

00:58:54.140 --> 00:58:58.880
And it just turned out it was impossible to know how many characters.

00:58:58.880 --> 00:59:00.280
So what do you do?

00:59:00.700 --> 00:59:07.300
Well, there's a subset up to about Unicode 9 where things seem to be mostly sane, most terminal support.

00:59:07.300 --> 00:59:09.220
So if you use those, those are fine.

00:59:09.220 --> 00:59:12.320
But after that, it becomes unreliable.

00:59:12.320 --> 00:59:18.080
If you have flags and multi-code point characters, then it might not work.

00:59:18.080 --> 00:59:23.020
It might cause the alignment of tables and panels to be out.

00:59:23.020 --> 00:59:25.660
You know, the end character might be shifted out by one.

00:59:25.980 --> 00:59:27.920
And it just comes up so frequently.

00:59:27.920 --> 00:59:30.180
And I would solve it if I could.

00:59:30.180 --> 00:59:36.420
But as far as I can tell, there is no reasonable solution which will work across all platforms.

00:59:36.420 --> 00:59:39.500
Too many unknowns, right?

00:59:39.500 --> 00:59:40.860
Too many unknowns, yeah.

00:59:40.860 --> 00:59:46.880
It's a crazy thing, but it kind of makes sense because these Unicode characters came out in the last few years.

00:59:46.880 --> 00:59:52.100
And operating systems and terminals haven't caught up and they haven't agreed on how to render them.

00:59:52.100 --> 00:59:54.500
So it's a frustrating situation.

00:59:55.620 --> 00:59:56.500
I'm sure that it is.

00:59:56.500 --> 01:00:06.020
Yeah, I mean, if you look at like some of the nerd fonts, for example, when I, you know, at nerdfonts.com, you know, you look at some of these, what is possible.

01:00:06.020 --> 01:00:10.100
I think here, you know, you have these like colored arrows.

01:00:10.100 --> 01:00:16.740
And do they have, I don't know, if you go over to Oh My Posh, which I don't really have time to talk about.

01:00:16.820 --> 01:00:27.980
But if you look at the themes that are in here, the different themes that you can pick and just some of the effects, like a character that looks like a git branch with an arrow in it.

01:00:27.980 --> 01:00:29.300
Like, how is that?

01:00:29.940 --> 01:00:31.820
How are you supposed to decide how big that is?

01:00:31.820 --> 01:00:34.340
Or, you know, how is some of this stuff accomplished?

01:00:34.340 --> 01:00:34.940
It's just...

01:00:34.940 --> 01:00:37.920
I don't know how they represent those characters.

01:00:37.920 --> 01:00:40.880
I wonder if they reuse existing characters.

01:00:41.460 --> 01:00:43.940
When I saw that, I'm like, okay, this is...

01:00:43.940 --> 01:00:45.560
I don't know how this is possible, right?

01:00:45.560 --> 01:00:47.900
Rounded edges and all sorts of stuff.

01:00:47.900 --> 01:00:52.740
So I'm like trying to find one where it's like a sparkly fade from one character to the next.

01:00:52.740 --> 01:00:56.520
It's these things over in the OhMyPosh.dev themes.

01:00:56.760 --> 01:01:00.300
If I thought about your job to figure out, like, what is that supposed to look like?

01:01:00.300 --> 01:01:00.860
I don't know.

01:01:00.860 --> 01:01:01.640
I would just give up.

01:01:01.640 --> 01:01:03.960
Because these are...

01:01:03.960 --> 01:01:05.400
I mean, they're really impressive and really useful.

01:01:05.400 --> 01:01:11.720
But this one, for example, the cert theme, where it's got like little dots that fade from one to the next.

01:01:11.720 --> 01:01:12.260
I just...

01:01:12.260 --> 01:01:12.920
I just don't know.

01:01:12.920 --> 01:01:14.240
Amazing, but...

01:01:14.240 --> 01:01:14.840
Those look pretty cool.

01:01:14.840 --> 01:01:16.060
How are you supposed to know, right?

01:01:16.060 --> 01:01:16.540
Right.

01:01:16.540 --> 01:01:19.260
So those are your lessons.

01:01:19.260 --> 01:01:21.300
Very, very cool stuff.

01:01:21.300 --> 01:01:24.400
I really appreciate you coming on to talk about the seven lessons.

01:01:24.400 --> 01:01:26.320
You know, terminals are fast.

01:01:26.780 --> 01:01:27.760
Dictive views are amazing.

01:01:27.760 --> 01:01:29.240
LRU cache is fast.

01:01:29.240 --> 01:01:30.220
Immutable is good.

01:01:30.220 --> 01:01:31.360
Unicode R is good.

01:01:31.360 --> 01:01:32.500
Fractions are good.

01:01:32.500 --> 01:01:33.580
Emoji is bad.

01:01:33.580 --> 01:01:36.140
Does that summarize it?

01:01:36.140 --> 01:01:37.380
That about...

01:01:37.380 --> 01:01:38.360
Yeah, in a nutshell.

01:01:38.360 --> 01:01:41.840
Oh, let's wrap it up with one more thing real quick here.

01:01:41.840 --> 01:01:43.480
Let me see if I can find it.

01:01:43.480 --> 01:01:44.440
This one?

01:01:44.440 --> 01:01:44.980
There we go.

01:01:44.980 --> 01:01:46.780
So one of the...

01:01:46.780 --> 01:01:48.440
Sort of bring it full circle back around.

01:01:48.440 --> 01:01:54.840
One of the cool things to make terminals nicer that you've talked about recently is rich-cli.

01:01:55.080 --> 01:01:56.300
You want to close out the show?

01:01:56.300 --> 01:01:57.240
Just give us...

01:01:57.240 --> 01:01:58.280
Tell us what rich-cli is.

01:01:58.280 --> 01:01:58.780
Sure.

01:01:58.780 --> 01:01:59.060
Okay.

01:01:59.060 --> 01:02:00.760
So as you know, rich is a library.

01:02:00.760 --> 01:02:04.520
And rich-cli is a CLI interface for that library.

01:02:04.520 --> 01:02:08.740
So most of what rich can do is exposed by rich-cli.

01:02:09.020 --> 01:02:13.500
So you can cat most file formats, and it'll be nicely syntax highlighted.

01:02:13.500 --> 01:02:17.440
You'll have line numbers and guidelines and all sorts of things.

01:02:17.440 --> 01:02:20.440
And you can do things like panels.

01:02:20.440 --> 01:02:22.020
You can format text.

01:02:22.020 --> 01:02:23.400
What else?

01:02:23.400 --> 01:02:25.180
There's a whole bunch of other features.

01:02:25.180 --> 01:02:26.180
Yeah.

01:02:26.300 --> 01:02:31.080
So for example, if I had a JSON document on the terminal, I could type...

01:02:31.080 --> 01:02:35.220
I could open it in some terminal-based editor, you know, think SSH somewhere.

01:02:35.220 --> 01:02:42.620
Or I could just type more or cat the name of it, and it would print out just plain text of whatever's on the inside.

01:02:42.620 --> 01:02:53.020
Or now I could type rich, the file name, and I get, you know, highlighted, colorized, formatted content for like CSV and JSON and all those kinds of things, right?

01:02:53.360 --> 01:02:53.900
Yeah, yeah.

01:02:53.900 --> 01:02:58.940
So the rich, the JSON example is quite good because that will decode the JSON.

01:02:58.940 --> 01:03:03.120
So if you've got like compressed JSON with no white space, it makes it impossible to read.

01:03:03.120 --> 01:03:07.120
Rich will decode it, and it'll also format it.

01:03:07.120 --> 01:03:08.000
I see.

01:03:08.000 --> 01:03:09.040
Like pretty prints it.

01:03:09.040 --> 01:03:10.160
Pretty prints it, exactly.

01:03:10.160 --> 01:03:10.560
Yeah.

01:03:10.560 --> 01:03:12.940
And it'll do markdown.

01:03:12.940 --> 01:03:15.320
It'll do a reasonable job of rendering markdown.

01:03:15.320 --> 01:03:20.520
And it'll take CSV files, and it'll turn those into nice rich tables.

01:03:21.040 --> 01:03:24.660
And if your output is quite large, you can add hyphen, hyphen, pager.

01:03:24.660 --> 01:03:30.500
And that'll put in a nice pager where you can scroll up and down with scroll bars and do page up, page down, et cetera.

01:03:30.500 --> 01:03:36.780
So it's kind of like a toolbox for fancy, rich formatting of all sorts of different data types.

01:03:36.780 --> 01:03:38.000
Definitely a cool project.

01:03:38.000 --> 01:03:44.320
And I know you're concerned about emojis, but Paul in the audience says, fortunately, Doom does not require emojis.

01:03:44.320 --> 01:03:45.980
So it's still on the table.

01:03:45.980 --> 01:03:47.100
I suppose not, yeah.

01:03:49.640 --> 01:03:50.340
That's right.

01:03:50.340 --> 01:03:51.640
All right.

01:03:51.640 --> 01:03:53.560
Well, fantastic lessons.

01:03:53.560 --> 01:03:55.460
Thanks for sharing all of your experience.

01:03:55.460 --> 01:03:57.860
Final two questions before you get out of here.

01:03:57.860 --> 01:04:01.480
If you're going to write some Python code, work on rich, what editor are you using these days?

01:04:01.480 --> 01:04:04.800
It's not so meta that you're using Textual to write Textual yet, is it?

01:04:04.800 --> 01:04:05.280
No.

01:04:05.280 --> 01:04:06.100
Maybe one day.

01:04:06.100 --> 01:04:07.880
But no, I use VS Code.

01:04:07.880 --> 01:04:09.640
And I quite like it.

01:04:09.640 --> 01:04:10.500
I'm comfortable with it.

01:04:10.500 --> 01:04:14.040
My colleague uses, what's the editor by JetBrains?

01:04:14.040 --> 01:04:14.900
PyCharm.

01:04:14.900 --> 01:04:15.660
PyCharm.

01:04:16.020 --> 01:04:17.800
And he's very proficient at PyCharm.

01:04:17.800 --> 01:04:20.620
And to be honest with you, I am jealous of some of the features of PyCharm.

01:04:20.620 --> 01:04:22.280
It does some really cool things.

01:04:22.280 --> 01:04:25.320
So I'm kind of tempted to try PyCharm.

01:04:25.320 --> 01:04:26.760
Looking over the shoulder.

01:04:26.760 --> 01:04:27.280
Awesome.

01:04:27.280 --> 01:04:27.700
Yeah.

01:04:27.700 --> 01:04:28.380
Very cool.

01:04:28.380 --> 01:04:30.640
And then notable PyPI package.

01:04:30.640 --> 01:04:34.080
I mean, we've touched on some good ones that start or end with Rich.

01:04:34.320 --> 01:04:37.440
But anything else you run across that you're like, oh, this is fantastic.

01:04:37.440 --> 01:04:38.560
People should check this out.

01:04:38.560 --> 01:04:39.280
Oh, gosh.

01:04:39.280 --> 01:04:40.600
There's so many.

01:04:40.600 --> 01:04:42.200
I'm drawing a blank.

01:04:42.200 --> 01:04:44.820
I should have heard one in advance.

01:04:44.820 --> 01:04:48.580
How about one that you use that makes Rich work well or something?

01:04:48.580 --> 01:04:51.180
Well, there's Prompt Toolkit.

01:04:51.960 --> 01:04:55.040
So I owe Prompt Toolkit a big debt of gratitude.

01:04:55.040 --> 01:04:59.500
Because when I was figuring out the textual stuff, I looked at the Prompt Toolkit source

01:04:59.500 --> 01:05:03.020
code, which is a great thing about open source that you can look at other people's code.

01:05:03.020 --> 01:05:04.900
And it is very good.

01:05:04.900 --> 01:05:06.120
It helped me understand things.

01:05:06.120 --> 01:05:09.240
And it still does things which Textual doesn't do yet.

01:05:09.240 --> 01:05:11.540
So I think Prompt Toolkit is an excellent project.

01:05:11.540 --> 01:05:13.500
And if you haven't used it, you should definitely check it out.

01:05:13.500 --> 01:05:13.860
Yeah.

01:05:13.860 --> 01:05:14.900
Prompt Toolkit's interesting.

01:05:14.900 --> 01:05:15.880
And you'll be typing along.

01:05:15.880 --> 01:05:21.620
And all of a sudden, there's like a combo drop-down box, like a select right in the middle

01:05:21.620 --> 01:05:22.040
of your terminal.

01:05:22.040 --> 01:05:23.100
And then you just carry on.

01:05:23.100 --> 01:05:23.800
Yeah.

01:05:23.800 --> 01:05:25.660
It makes things like, I think it's used in IPython.

01:05:25.660 --> 01:05:28.840
It makes that much nicer and much more friendly.

01:05:28.840 --> 01:05:29.540
Absolutely.

01:05:29.540 --> 01:05:30.400
All right.

01:05:30.400 --> 01:05:32.120
Well, final call to action.

01:05:32.120 --> 01:05:37.080
People want to do stuff with Rich Textual, maybe take some of these lessons and run with

01:05:37.080 --> 01:05:37.280
them.

01:05:37.280 --> 01:05:38.100
What do you tell them, Will?

01:05:38.100 --> 01:05:38.900
Yeah.

01:05:38.900 --> 01:05:40.020
Check out the website.

01:05:40.020 --> 01:05:42.080
Check out my Twitter profile.

01:05:42.320 --> 01:05:44.920
And if you have any questions, feel free to ping them over to me.

01:05:44.920 --> 01:05:48.380
I'm always happy to talk to people about Python-related things.

01:05:48.380 --> 01:05:48.780
Yeah.

01:05:48.780 --> 01:05:49.280
Fantastic.

01:05:49.280 --> 01:05:54.400
And of course, I'll link to the article with your list of topics there so people can check

01:05:54.400 --> 01:05:54.700
that out.

01:05:54.700 --> 01:05:55.760
Thank you so much for being here.

01:05:55.760 --> 01:05:57.020
It's been great to catch up with you.

01:05:57.020 --> 01:05:57.340
Yeah.

01:05:57.340 --> 01:05:57.640
Thank you.

01:05:57.640 --> 01:05:58.060
You bet.

01:05:58.060 --> 01:05:58.320
Take care.

01:05:58.320 --> 01:05:58.500
Bye.

01:05:58.500 --> 01:05:58.960
Bye-bye.

01:05:58.960 --> 01:06:02.700
This has been another episode of Talk Python to Me.

01:06:02.700 --> 01:06:04.520
Thank you to our sponsors.

01:06:04.520 --> 01:06:06.120
Be sure to check out what they're offering.

01:06:06.120 --> 01:06:07.540
It really helps support the show.

01:06:07.540 --> 01:06:09.600
Starting a business is hard.

01:06:10.100 --> 01:06:15.700
Microsoft for Startups, Founders Hub provides all founders at any stage with free resources

01:06:15.700 --> 01:06:18.200
and connections to solve startup challenges.

01:06:18.200 --> 01:06:22.740
Apply for free today at talkpython.fm/founders hub.

01:06:22.740 --> 01:06:28.100
Join Sentry at their conference, Dex, Sort the Madness, the conference for every developer

01:06:28.100 --> 01:06:32.660
to join as they investigate the movement and trends for better and more reliable developer

01:06:32.660 --> 01:06:33.280
experiences.

01:06:33.280 --> 01:06:37.220
Save your seat now at talkpython.fm/Dex.

01:06:37.220 --> 01:06:38.920
Want to level up your Python?

01:06:39.320 --> 01:06:42.960
We have one of the largest catalogs of Python video courses over at Talk Python.

01:06:42.960 --> 01:06:48.140
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:06:48.140 --> 01:06:50.800
And best of all, there's not a subscription in sight.

01:06:50.800 --> 01:06:53.700
Check it out for yourself at training.talkpython.fm.

01:06:53.700 --> 01:06:55.620
Be sure to subscribe to the show.

01:06:55.620 --> 01:06:58.400
Open your favorite podcast app and search for Python.

01:06:58.400 --> 01:06:59.700
We should be right at the top.

01:06:59.700 --> 01:07:04.860
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:07:04.860 --> 01:07:09.060
and the direct RSS feed at /rss on talkpython.fm.

01:07:09.060 --> 01:07:12.500
We're live streaming most of our recordings these days.

01:07:12.500 --> 01:07:15.900
If you want to be part of the show and have your comments featured on the air,

01:07:15.900 --> 01:07:20.280
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:07:20.800 --> 01:07:22.180
This is your host, Michael Kennedy.

01:07:22.180 --> 01:07:23.460
Thanks so much for listening.

01:07:23.460 --> 01:07:24.620
I really appreciate it.

01:07:24.620 --> 01:07:26.540
Now get out there and write some Python code.

01:07:26.540 --> 01:07:47.280
I really appreciate it.

01:07:47.280 --> 01:08:17.260
Thank you.

