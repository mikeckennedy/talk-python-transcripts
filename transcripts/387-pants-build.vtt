WEBVTT

00:00:00.001 --> 00:00:05.520
You have a larger growing Python code base? If you struggle to run builds, tests, linting,

00:00:05.520 --> 00:00:10.840
and other quality checks regularly or quickly, you'll want to hear what Benji Weinberger has

00:00:10.840 --> 00:00:17.180
to say. He's here to introduce Pants Build to us. Pants is a fast, scalable, user-friendly build

00:00:17.180 --> 00:00:23.220
system for code bases of all sizes. It's currently focused on Python, Go, Java, Scala, Kotlin,

00:00:23.220 --> 00:00:27.900
Shell, and Docker with more languages to come. So you can see on that project that even has

00:00:27.900 --> 00:00:35.680
multiple languages at play. This is Talk Python To Me, episode 388, recorded October 6th, 2022.

00:00:35.680 --> 00:00:53.520
Welcome to Talk Python To Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:53.520 --> 00:00:57.720
Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past

00:00:57.720 --> 00:01:03.760
episodes at talkpython.fm and follow the show on Twitter via at Talk Python. We've started

00:01:03.760 --> 00:01:09.460
streaming most of our episodes live on YouTube. Subscribe to our YouTube channel over at talkpython.fm

00:01:09.460 --> 00:01:13.980
slash YouTube to get notified about upcoming shows and be part of that episode.

00:01:13.980 --> 00:01:20.300
This episode is brought to you by the Local Maximum Podcast over at localmaxradio.com

00:01:20.300 --> 00:01:25.620
and Microsoft for Startups, Founders Hub. Get support for your startup at talkpython.fm

00:01:25.620 --> 00:01:31.600
slash founders hub. Transcripts for this and all of our episodes are brought to you by Assembly AI.

00:01:31.600 --> 00:01:36.820
Do you need a great automatic speech to text API? Get human level accuracy in just a few lines of code.

00:01:36.820 --> 00:01:42.580
Visit talkpython.fm/assembly AI. Benji, welcome to Talk Python To Me.

00:01:42.580 --> 00:01:43.660
Thank you. It's great to be here.

00:01:43.660 --> 00:01:55.780
It's great to have you here. I'm quite excited to talk about pants and build and bringing a little bit more structure and automation to the developer workflow using this tool that you all built.

00:01:55.780 --> 00:02:00.020
Very happy to talk about that. Something I've been very passionate about for a long time.

00:02:00.020 --> 00:02:05.940
Yeah, you've been working on this quite a long time, as we will see. But before we get into all the details there, let's start with your story.

00:02:06.020 --> 00:02:07.440
How do you get into programming and Python?

00:02:07.440 --> 00:02:15.600
I love this question because I've been a software developer for 25 years or so. So I've been around for a while.

00:02:15.600 --> 00:02:17.580
You and me both, almost the same duration there.

00:02:17.580 --> 00:02:21.900
So, you know, we've seen some stuff. But I first got into computers when I was about 10 years old.

00:02:21.900 --> 00:02:32.140
And my uncle, who is a big gadget nut, bought a very, very early home computer. This was in the UK. So it was the Sinclair ZX80, if anyone's familiar with that.

00:02:32.140 --> 00:02:43.400
1K of RAM, you know, 8-bit machine. It was, I had just never seen anything like it. And I was instantly smitten by it and got really into it then.

00:02:43.540 --> 00:02:50.360
And at some point, got my own home computer and at some point realized, oh, this is sort of a thing I want to do for the rest of my life.

00:02:50.360 --> 00:02:54.360
Now, granted, at that time, I also thought I would play with Legos for the rest of my life.

00:02:54.360 --> 00:02:57.960
So it's not like I'm always right about that. But in this case, I absolutely was.

00:02:57.960 --> 00:03:00.240
It's pretty awesome that we get to do that, right?

00:03:00.240 --> 00:03:04.800
You know, it's like, oh, this is such a neat little project. And I would just do this for fun.

00:03:04.800 --> 00:03:08.320
But if people pay me, I get to build even more ambitious things.

00:03:08.320 --> 00:03:13.340
And a lot of times those are just the thoughts and dreams of kids who don't know better, right?

00:03:13.340 --> 00:03:18.160
Just wait till you get in the real world. But as programmers, that's not true. Like we get to do it all the time.

00:03:18.160 --> 00:03:23.960
It's absolutely unbelievable that your childhood hobby can become your grown up profession if you have the right hobby.

00:03:23.960 --> 00:03:26.380
Yeah, exactly. It's important to pick good hobbies, kids.

00:03:26.380 --> 00:03:30.360
If you're out there listening and you haven't picked a hobby yet and you're not there, yeah, pick a good hobby.

00:03:30.360 --> 00:03:30.700
Yeah.

00:03:30.700 --> 00:03:38.300
You talked about the 1K of RAM and the retro thing. I just started working on this project last night.

00:03:38.300 --> 00:03:45.960
No, two days ago using CircuitPython. And for, what is that thing? $17, I got an ESP32 feather.

00:03:45.960 --> 00:03:46.520
Whoa.

00:03:46.520 --> 00:03:52.080
Little microchip. It has a Wi-Fi built in. It's got like a temperature sensor and all these things.

00:03:52.080 --> 00:03:57.280
And all you need to make it go is just plug in a USB-C. That thing is like a 240 megahertz.

00:03:58.640 --> 00:04:08.000
Two megs of RAM, four megs of storage, which is not much at all. But like it fits like it has two thirds of your hand.

00:04:08.000 --> 00:04:12.580
And it's unimaginably powerful compared to what the types of computers you're talking about, right?

00:04:12.580 --> 00:04:22.480
Oh, that, as I said, 1K of RAM. It had the Zilog Z80 was the processor, which I believe was clocked at about four megahertz or something.

00:04:22.480 --> 00:04:28.000
It was, yeah. I mean, and at the time, you know, when you're a child, a million sounds like a lot.

00:04:28.000 --> 00:04:30.580
So I'm sort of, what do you mean megahertz? Like I can't count to a million.

00:04:30.580 --> 00:04:37.880
Yeah, that's unbelievable. That's right. And here we are, well, well past the early Pentiums for $14 or $17.

00:04:37.880 --> 00:04:45.260
Anyway, it's just, it's really interesting to think about the different types of computers that we have to work with and where we all start.

00:04:45.400 --> 00:04:54.180
The other thing that I always find interesting is thinking back to early 90s, late 80s, those computers and their interfaces were so basic.

00:04:54.180 --> 00:05:03.920
And yet the possibility that at least I experienced when I worked with them, it seemed so great and so amazing that even stuff today doesn't come close to where you're like, I see where this is going.

00:05:03.920 --> 00:05:05.060
It's going to be incredible.

00:05:05.060 --> 00:05:12.820
There's definitely a joy. I mean, when you use the word basic, I'm assuming in lowercase, but the interface to many of them was literally the language basic all uppercase.

00:05:12.820 --> 00:05:18.780
Or you could just write machine code directly. And those were your only two options essentially.

00:05:18.780 --> 00:05:27.780
And so you were either, you know, 10 print your name, 20 go to 10, or you were messing around with registers.

00:05:27.780 --> 00:05:32.220
And once you learned how to do that, it was such a joy.

00:05:32.220 --> 00:05:35.600
You're essentially, you're melding with the hardware in some way.

00:05:35.600 --> 00:05:42.400
And it's, yeah, today, obviously, mostly for good, we are 19 layers removed from the hardware.

00:05:42.400 --> 00:05:45.780
And if you're going to be removed from the hardware, Python's a good way to do it.

00:05:45.780 --> 00:05:50.100
But yeah, definitely some joy has been lost and replaced with other joys.

00:05:50.100 --> 00:05:51.180
It's a new kind of joy.

00:05:51.180 --> 00:05:53.400
Now I pip install something in three lines.

00:05:53.400 --> 00:05:55.900
I have like a cluster of servers at my command.

00:05:55.900 --> 00:05:58.100
It's a different kind of joy than working with registers.

00:05:58.700 --> 00:06:01.180
All right, well, let's get into the main topic.

00:06:01.180 --> 00:06:04.340
Let's talk about pants, this project that you all have created.

00:06:04.340 --> 00:06:15.520
Its role, as we started, stated briefly at the beginning, is really about helping orchestrate common tasks that we have to do to build and run and prepare software.

00:06:15.520 --> 00:06:17.980
And it's only getting more and more complex.

00:06:17.980 --> 00:06:21.940
I guess Python grows up, as you sort of put it, as we were chatting before I hit record.

00:06:21.940 --> 00:06:35.620
As Python grows up, as it's being used on larger projects, as it's being used across larger teams, the expectations of what it means to have a piece of software and run it is changing and evolving, right?

00:06:35.620 --> 00:06:41.900
So maybe we could just start by talking about some of the pain points of large software, scaling software, Python in particular.

00:06:42.460 --> 00:06:50.920
Sure. An important piece of background here that I'm sure all the listeners will be familiar with is what has happened to Python in the last 10 to 15 years.

00:06:50.920 --> 00:06:55.560
I mean, I started programming in Python about 20 years ago on Python 2.2.

00:06:55.560 --> 00:06:58.380
It was sort of fancy bash at that point, right?

00:06:58.380 --> 00:07:04.780
It was just the language, the little bit of glue you used around the edges of your real code, which was written in C or whatever.

00:07:05.100 --> 00:07:17.760
And fast forward to today, and if you look at the process of particularly over the last 10 years, Python is this absolutely critical language that has grown up incredibly and is now being used to build large systems.

00:07:17.760 --> 00:07:20.680
It's being used as the language of choice for data science.

00:07:20.680 --> 00:07:22.560
It's being used as the language of choice for DevOps.

00:07:22.560 --> 00:07:31.120
It is absolutely crucial language that large, growing, scalable code bases are increasingly being built out of.

00:07:31.120 --> 00:07:34.660
And that's presumably everyone listening is a fan of Python as I am.

00:07:34.660 --> 00:07:37.160
And so there are good reasons why this is the case.

00:07:37.160 --> 00:07:44.580
But we're still a little behind the curve on the tooling that you need to grow a Python code base.

00:07:44.580 --> 00:07:52.240
The standalone Python tooling, and there are so many great tools in that toolkit, they're pretty single use.

00:07:52.240 --> 00:08:04.400
And they tend to be designed to assume that you have a small, single use, sort of standalone binary that's the only thing that your code base contains.

00:08:04.560 --> 00:08:15.800
But now increasingly, you have these large, growing code bases, sometimes referred to as monorepos, where you have a lot of Python code, possibly code in other languages as well.

00:08:15.800 --> 00:08:20.620
You're trying to share code across a bunch of different projects and a bunch of different binaries.

00:08:20.620 --> 00:08:23.940
You have a lot of, you may be deploying out of a single code base.

00:08:23.940 --> 00:08:25.700
You want to deploy many microservices.

00:08:25.700 --> 00:08:28.080
You want to deploy AWS Lambdas.

00:08:28.080 --> 00:08:31.560
You want to deploy many different Docker images.

00:08:31.560 --> 00:08:34.920
You have this complexity that you need to manage.

00:08:34.920 --> 00:08:41.000
And so with other languages, there have been tools around to help you deal with this problem.

00:08:41.000 --> 00:08:57.420
Python and for more contemporary languages, many of the solutions tend to come standard with that language's tool chain, such as, you know, Go just comes with a Swiss Army knife and Rust comes with a Swiss Army knife.

00:08:57.420 --> 00:09:00.480
Python does not, for better or worse, come with a Swiss Army knife.

00:09:00.480 --> 00:09:03.380
It comes with, you know, there are many, many blades out there.

00:09:03.820 --> 00:09:25.980
And particularly in its focus on Python is designed to help you grow and scale that Python code base so that all of the steps you need to take to go from authoring some code to having it be validated, tested, checked, you know, have passed all its quality control checks and be ready to be deployed or used in production.

00:09:25.980 --> 00:09:32.820
Rather than you manually having to figure out, well, which tools do I need to invoke in which order?

00:09:32.820 --> 00:09:33.820
How do I need to ensure that they are consistent?

00:09:33.820 --> 00:09:33.820
How do I need to ensure that they are consistent?

00:09:33.820 --> 00:09:41.820
How do I do the least amount of work in the least amount of time that is necessary to assure those quality checks?

00:09:41.820 --> 00:09:44.700
That is all a very automatable problem.

00:09:44.700 --> 00:09:46.340
And that's essentially what Pants is.

00:09:46.340 --> 00:09:47.840
It can look at your code base.

00:09:47.840 --> 00:09:51.260
It can look at changes to your code base and say, oh, you want to run tests?

00:09:51.260 --> 00:09:53.140
Here's the actual work that needs to happen.

00:09:53.140 --> 00:09:54.860
And here are the tools that need to be invoked.

00:09:54.860 --> 00:09:55.240
Sure.

00:09:55.240 --> 00:09:57.800
So maybe you want to run pytest.

00:09:57.800 --> 00:10:04.160
And as we'll learn, Pants has some great ways to speed up things like executing tests.

00:10:04.400 --> 00:10:05.900
Some of that's parallelism.

00:10:05.900 --> 00:10:07.420
Some of that's going, you know what?

00:10:07.420 --> 00:10:08.160
We already did that work.

00:10:08.160 --> 00:10:08.920
Nothing's changed.

00:10:08.920 --> 00:10:09.560
Carry on.

00:10:09.560 --> 00:10:10.120
Exactly.

00:10:10.120 --> 00:10:15.980
Pants is essentially the layer between either you as a developer working on your laptop or

00:10:15.980 --> 00:10:22.160
your CI environment and the underlying tools of which, you know, there are so many.

00:10:22.160 --> 00:10:25.300
And Pants, I think, supports well over 20 Python tools.

00:10:25.300 --> 00:10:28.020
And it's fairly easy to add more.

00:10:28.020 --> 00:10:30.800
So, for example, test being a very important example.

00:10:31.040 --> 00:10:35.140
You can say, hey, Pants, test, you know, run all the tests on everything that is affected

00:10:35.140 --> 00:10:37.280
by my current set of changes.

00:10:37.280 --> 00:10:42.120
The system can look at your code, look at the dependencies, perform all this analysis and

00:10:42.120 --> 00:10:47.300
say, well, that means I actually need to invoke pytest on these underlying tests.

00:10:47.300 --> 00:10:52.500
And if that means I need to first install pytest in a hermetic environment, I will do that.

00:10:52.500 --> 00:10:59.300
Pants also runs everything in these hermetic sandboxes, which means they are neither consume

00:10:59.300 --> 00:11:05.000
nor create side effects, which means all of this work can be cached at a very fine-grained

00:11:05.000 --> 00:11:05.280
level.

00:11:05.280 --> 00:11:10.360
You can cache the result of an individual test, apply concurrency at the level of an individual

00:11:10.360 --> 00:11:10.860
test.

00:11:10.860 --> 00:11:16.120
And so if you have eight cores on your machine, you can run eight tests at the same time and

00:11:16.120 --> 00:11:20.160
you only need to run the ones that have not, whose inputs have changed because everything

00:11:20.160 --> 00:11:22.320
else is cached potentially.

00:11:22.320 --> 00:11:22.680
Yeah.

00:11:22.680 --> 00:11:23.240
Yeah.

00:11:23.240 --> 00:11:25.280
So that's the test example.

00:11:25.280 --> 00:11:30.100
Then you could look at another really important quality control check is linting and formatting.

00:11:30.100 --> 00:11:35.500
There are, I don't know, eight or 10 different linters and formatters for Python and Pants can

00:11:35.500 --> 00:11:37.640
orchestrate them all in the right order.

00:11:37.640 --> 00:11:42.820
It understands the distinction between linters, which don't modify your source code so they can

00:11:42.820 --> 00:11:48.960
all run concurrently, and formatters which do modify your code so they have to run sequentially.

00:11:49.300 --> 00:11:53.520
So it's a lot of, it's this layer between you that allows you to not worry about which tools

00:11:53.520 --> 00:11:53.960
do I need?

00:11:53.960 --> 00:11:55.320
How do I install them?

00:11:55.320 --> 00:11:56.620
How do I isolate them?

00:11:56.620 --> 00:11:57.920
How do I cache their results?

00:11:57.920 --> 00:12:01.240
How do I reason about concurrency and what can and can't be run together?

00:12:01.240 --> 00:12:02.760
It just takes that away from you.

00:12:03.400 --> 00:12:09.960
One of the most powerful things for me personally, when I see all of this, how it brings all of

00:12:09.960 --> 00:12:15.780
these things together is a lot of times, well, yeah, I should probably run the linter on that,

00:12:15.780 --> 00:12:17.260
but it's fine.

00:12:17.260 --> 00:12:21.660
Maybe I should run the tests, but I didn't change that much.

00:12:21.660 --> 00:12:23.500
I mean, it was only a couple of lines of code.

00:12:23.500 --> 00:12:27.760
I don't really, you know, like there's these different steps you got to keep in mind.

00:12:27.840 --> 00:12:30.140
And at each level, you're like, do I need to do this?

00:12:30.140 --> 00:12:32.160
Or do I need to remember to do it?

00:12:32.160 --> 00:12:35.360
Or is it justified to disrupt what I'm thinking about?

00:12:35.360 --> 00:12:40.920
And if it's just, you know, pants build or pants tests, and you don't have to worry about it,

00:12:40.920 --> 00:12:46.120
and the system just does it all for you, you, at least personally, I am more willing to adopt

00:12:46.120 --> 00:12:51.240
more software engineering practices and guards on my code.

00:12:51.400 --> 00:12:54.900
If it doesn't feel like I have to do them, you know what I mean?

00:12:54.900 --> 00:12:58.800
If I don't actually have to remember like, well, I was doing five steps and that was a lot.

00:12:58.800 --> 00:13:02.360
Now I'm doing six and I'm really sick of these steps now, you know, if it's the same number

00:13:02.360 --> 00:13:07.440
of steps and it's fast enough because of the caching and parallelism, then why not adopt it?

00:13:07.440 --> 00:13:07.840
Exactly.

00:13:07.840 --> 00:13:13.060
And I think an underappreciated complication is when it's not an individual adopting it,

00:13:13.060 --> 00:13:13.760
but a team.

00:13:13.760 --> 00:13:18.980
So a team wants to assume some best practices, but now everyone on your, you want to adopt a new

00:13:18.980 --> 00:13:25.480
linter or a new quality control check of any kind, that's more cognitive load on behalf of,

00:13:25.480 --> 00:13:26.480
you know, now what do you do?

00:13:26.480 --> 00:13:30.220
Do you send an email to everyone on the team saying, well, now you have to run this as well.

00:13:30.220 --> 00:13:36.680
You can set up your existing build layer pants in this case to add, apply that new linter.

00:13:36.680 --> 00:13:37.820
And it just happens.

00:13:37.820 --> 00:13:39.500
Nobody has to change their workflow.

00:13:39.500 --> 00:13:45.340
What, where we want to get to is essentially, and we're in many cases, very close to this

00:13:45.340 --> 00:13:52.800
is you run a single command on, as a developer, you run that same single command in CI and the

00:13:52.800 --> 00:13:54.760
right thing just magically happens.

00:13:54.760 --> 00:14:00.500
And the ability to do the right thing magically depends on the ability to do dependency analysis,

00:14:00.500 --> 00:14:04.720
to build a fine grain workflow, to apply concurrency and caching to it.

00:14:04.860 --> 00:14:10.300
And as I think we'll, we'll get to maybe later, even not just concurrency and caching on your

00:14:10.300 --> 00:14:17.020
machine, but remote execution in a cluster and shared remote caching so that work is being

00:14:17.020 --> 00:14:17.300
shared.

00:14:17.300 --> 00:14:21.740
Not just, you know, it's not just past work that you have done, but past work that anyone

00:14:21.740 --> 00:14:24.040
individually or in CI has done.

00:14:24.040 --> 00:14:25.020
Yeah, that's fantastic.

00:14:25.200 --> 00:14:28.340
And if you've got a large code base, that starts to pay off.

00:14:28.340 --> 00:14:28.500
Yeah.

00:14:28.500 --> 00:14:28.820
Yeah.

00:14:28.820 --> 00:14:33.660
I want to talk to you about monorepos, but before we get to there, maybe you could just

00:14:33.660 --> 00:14:37.000
give a quick shout out about some of the language support.

00:14:37.000 --> 00:14:42.520
I mean, obviously we're talking about Python tools for Python code bases for Python developers

00:14:42.520 --> 00:14:48.900
and data scientists, but we might also live in multilingual heterogeneous environments at

00:14:48.900 --> 00:14:50.240
work and on our projects.

00:14:50.240 --> 00:14:55.820
And we might have, you know, some Kotlin for a mobile app and our Python for APIs or

00:14:55.820 --> 00:14:57.160
something like that.

00:14:57.160 --> 00:15:04.820
So yes, Pants is not a Python only tool, but it is a Python first or a Python centric tool

00:15:04.820 --> 00:15:09.740
in that when we, there is a long history to the project, but the current iteration of Pants,

00:15:09.740 --> 00:15:16.060
which we very unimaginatively called Pants V2, because we're not great at naming, it launched

00:15:16.060 --> 00:15:18.800
almost exactly two years ago, two years ago at the end of the month.

00:15:18.800 --> 00:15:21.600
And with just support for just Python.

00:15:21.600 --> 00:15:27.620
And since then we've added support for Go, for Java, for Scala, for Kotlin, for Shell.

00:15:27.620 --> 00:15:32.100
The next thing we're looking at very closely, obviously, is JavaScript and TypeScript.

00:15:32.100 --> 00:15:33.540
Can't ignore those.

00:15:33.540 --> 00:15:39.180
But one of the things that makes Pants stand out and, you know, the P in the name is no

00:15:39.180 --> 00:15:46.400
accident is the recognition that Python is not, is no longer this third cousin that you sort

00:15:46.400 --> 00:15:48.360
of put at the end of the list of languages to deal with.

00:15:48.360 --> 00:15:49.400
And it's sort of an afterthought.

00:15:49.400 --> 00:15:51.320
But really this thing is designed for Java.

00:15:51.320 --> 00:15:54.260
It was really part of the big driving use cases.

00:15:54.260 --> 00:15:59.120
But if you have many languages in your repo, or if you have no Python at all in your repo,

00:15:59.120 --> 00:16:01.420
Pants is still a useful tool for you.

00:16:01.540 --> 00:16:05.820
Because you still get the benefit of all the analysis that it does on your behalf.

00:16:05.820 --> 00:16:06.180
Indeed.

00:16:06.180 --> 00:16:12.220
And people will see that Python, Pants is written sort of top layer in Python and lower

00:16:12.220 --> 00:16:15.640
layer in Rust and the extensibility layers in Python.

00:16:15.640 --> 00:16:18.160
So there's a lot of Python first, as you say there.

00:16:18.160 --> 00:16:22.200
But I did want to call out, it does work on these other languages.

00:16:22.200 --> 00:16:27.380
So if you're trying to adopt some kind of automation that involves multiple languages, this might

00:16:27.380 --> 00:16:27.860
work for you.

00:16:27.940 --> 00:16:28.340
Yep.

00:16:28.340 --> 00:16:34.000
And we are always interested in people who have opinions about what the next languages

00:16:34.000 --> 00:16:35.220
we support should be.

00:16:35.220 --> 00:16:37.600
Obviously, as I said, JavaScript, TypeScript, very high on the list.

00:16:37.600 --> 00:16:42.900
I suspect Rust is very high on the list, partly because we use it and partly because it is a

00:16:42.900 --> 00:16:44.660
very up and coming and for very good reasons.

00:16:47.160 --> 00:16:50.780
This portion of Talk Python To Me is brought to you by the Local Maximum Podcast.

00:16:50.780 --> 00:16:55.960
It's an interesting and technical podcast that dives into trends in technology, stats, and more.

00:16:55.960 --> 00:17:00.380
But rather than tell you about it, let's hear from Max and Aaron about their show.

00:17:00.380 --> 00:17:03.820
We are now on with Talk Python To Me.

00:17:03.820 --> 00:17:05.560
Let's say hi to all the Python fans.

00:17:05.560 --> 00:17:06.560
Hi, Python fans.

00:17:06.560 --> 00:17:07.700
I'm Max Sklar.

00:17:07.700 --> 00:17:10.220
I have actually done a lot with Python myself.

00:17:10.220 --> 00:17:12.280
So I am a fan of Talk Python.

00:17:12.280 --> 00:17:13.780
Do you know Python, Aaron?

00:17:13.780 --> 00:17:16.560
I took a course years ago, but I am a little rusty.

00:17:16.680 --> 00:17:20.700
We are here today to talk about our podcast, The Local Maximum.

00:17:20.700 --> 00:17:25.440
We've been on a roll lately with a new episode every week, and I wanted to share with you what

00:17:25.440 --> 00:17:26.120
we've been up to.

00:17:26.120 --> 00:17:32.100
Here on The Local Maximum, we tackle subjects in software and technology, topics as diverse

00:17:32.100 --> 00:17:36.180
as the philosophy of probability to Elon Musk's next move.

00:17:36.180 --> 00:17:40.400
For Talk Python listeners, I want to highlight a couple of recent episodes of The Local Maximum.

00:17:40.400 --> 00:17:46.020
In 248, for example, I found out about an open source library that maps the world into

00:17:46.200 --> 00:17:46.720
hexagons.

00:17:46.720 --> 00:17:47.820
And some pentagons.

00:17:47.820 --> 00:17:52.060
I had a discussion with an author about games and puzzles and another on a novel approach

00:17:52.060 --> 00:17:53.280
to doing the job search well.

00:17:53.280 --> 00:17:56.240
We discussed the ramifications of AI-generated art.

00:17:56.240 --> 00:18:00.780
Have we reached peak creativity, or is this just another Local Maximum?

00:18:00.880 --> 00:18:11.220
All developer tools kind of come of age when they can make themselves.

00:18:12.800 --> 00:18:18.860
They're now fully independent where a language or a tool builds its own self with its own

00:18:18.860 --> 00:18:19.720
features.

00:18:19.720 --> 00:18:25.300
So yeah, if you could do that for Rust, then it can kind of be a part of that group.

00:18:25.300 --> 00:18:25.580
Yep.

00:18:25.580 --> 00:18:30.440
Self-hosting is a major milestone in any sort of build type project.

00:18:30.440 --> 00:18:30.900
Indeed.

00:18:31.060 --> 00:18:31.280
All right.

00:18:31.280 --> 00:18:32.460
Quick question from the audience.

00:18:32.460 --> 00:18:36.900
Mustafa out there says, how does Pants handle bulk publishing of packages where I might have

00:18:36.900 --> 00:18:39.160
a set of preconditions to auto-publish it?

00:18:39.160 --> 00:18:43.240
Intervals of all package that meet those conditions or something along those lines.

00:18:43.240 --> 00:18:43.900
Great question.

00:18:43.900 --> 00:18:48.720
So Pants, as I should mention, there are many different types of deployable that it can build.

00:18:48.720 --> 00:18:55.900
I mentioned like AWS Lambda or Google Cloud Functions, or we have a format that's specifically

00:18:55.900 --> 00:18:59.620
of interest to Python users called PEX, which stands for Python Executable.

00:18:59.620 --> 00:19:06.600
And it's basically a single file that contains your Python code and all of its transitive dependencies.

00:19:06.600 --> 00:19:11.100
So it is ready to run as long as there's an Python interpreter on the system you run it on.

00:19:11.100 --> 00:19:13.260
And it even knows how to find that interpreter.

00:19:13.520 --> 00:19:13.900
Interesting.

00:19:13.900 --> 00:19:15.720
PEX came from you guys.

00:19:15.720 --> 00:19:16.200
Yes.

00:19:16.200 --> 00:19:17.180
Oh, I had no idea.

00:19:17.180 --> 00:19:20.000
I mean, I've heard of PEX, but I didn't associate it with Pants.

00:19:20.000 --> 00:19:20.380
That's cool.

00:19:20.380 --> 00:19:20.700
Yeah.

00:19:20.700 --> 00:19:25.600
I mean, other systems can also build PEX, and PEX has a standalone command line tool that

00:19:25.600 --> 00:19:26.700
you can use to build PEXs.

00:19:26.700 --> 00:19:29.800
But Pants is the home base of PEX.

00:19:29.800 --> 00:19:36.220
But I think the question was about building and publishing Python distributions, for example,

00:19:36.220 --> 00:19:40.040
to PyPI, which Pants can obviously do.

00:19:40.620 --> 00:19:43.660
And I'm not 100% sure I'm answering the question appropriately.

00:19:43.660 --> 00:19:49.880
But I think one of the ways that Pants can help you here is it knows when code has changed.

00:19:50.000 --> 00:19:56.400
So if you're publishing a large number of packages from your repo, it can do the math of, you know,

00:19:56.400 --> 00:20:01.900
here are the, by tracking dependencies, it can do the math to say, based on the changes,

00:20:01.900 --> 00:20:06.720
since the last time this thing was published, it now has changed and needs to be republished.

00:20:07.260 --> 00:20:09.540
So it can give you a lot of that logic.

00:20:09.540 --> 00:20:15.840
When it comes to auto-publishing at intervals, I guess I would say Pants can tell you whether

00:20:15.840 --> 00:20:19.380
it meets the conditions based on dependency analysis, etc.

00:20:19.380 --> 00:20:22.660
There is no auto-publishing per se.

00:20:22.660 --> 00:20:24.320
Pants is a tool you have to invoke.

00:20:24.320 --> 00:20:27.860
So you could cron around it or something like that.

00:20:27.860 --> 00:20:28.060
Yeah.

00:20:28.060 --> 00:20:28.400
Cool.

00:20:28.900 --> 00:20:30.420
You mentioned monorepos.

00:20:30.420 --> 00:20:33.640
Now, you also mentioned sharing code.

00:20:33.640 --> 00:20:41.500
If I've got, say, some SQL model definitions that point at what my database looks like, well,

00:20:41.500 --> 00:20:46.080
my API code probably needs access to the right version of those.

00:20:46.440 --> 00:20:53.060
But so do my data scientists for their library that talks using SQL model to get the data into their notebooks.

00:20:53.060 --> 00:20:59.340
And if those things get out of sync, as we know, SQLAlchemy will go bonkers and say,

00:20:59.340 --> 00:21:01.260
you're missing a column here.

00:21:01.260 --> 00:21:01.940
Done.

00:21:01.940 --> 00:21:03.000
Crash, right?

00:21:03.000 --> 00:21:07.820
And so keeping that stuff in sync across these different projects can be challenging.

00:21:07.820 --> 00:21:10.140
Is that the idea behind these monorepos?

00:21:10.140 --> 00:21:10.820
Yes.

00:21:10.820 --> 00:21:15.600
That's one of the reasons why they are increasing in popularity.

00:21:16.080 --> 00:21:20.840
So the problem is, as your codebase grows, when your codebase is small, there are no problems.

00:21:20.840 --> 00:21:26.680
And as your codebase grows, you're faced with kind of two, you're faced with a decision on how to manage that.

00:21:26.680 --> 00:21:33.980
One is to keep breaking it up into multiple smaller repos, essentially, each one with their own build and their own practices.

00:21:33.980 --> 00:21:38.440
And the way you consume code across them is through publishing, through version publishing.

00:21:38.440 --> 00:21:45.800
Maybe you make your SQL models a data package and you publish it to an internal PyPI and everyone consumes it and they pin their

00:21:45.800 --> 00:21:46.480
versions just like...

00:21:46.480 --> 00:21:47.040
Exactly.

00:21:47.040 --> 00:21:54.600
So the problem with that is that there are several problems with it, but a big one is that you're inviting the famous dependency hell problem,

00:21:54.600 --> 00:21:59.360
which is already bad enough with third-party requirements, into your first-party code.

00:21:59.560 --> 00:22:09.560
So the problem is, when you make changes to a library, you have no way of knowing who is consuming you upstream from you and therefore what changes they might need.

00:22:09.560 --> 00:22:13.280
Now, you might say, well, not my problem because everything is supposed to be versioned,

00:22:13.280 --> 00:22:25.100
but that breaks as soon as anyone needs to upgrade anything because now they have this horrific upgrade problem that is happening potentially weeks or months after the changes that are breaking them have happened.

00:22:25.440 --> 00:22:28.820
So you're kind of pushing the problem off.

00:22:28.820 --> 00:22:36.220
Where a monorepo is helpful is that you get this visibility into all of the upstream dependencies.

00:22:36.220 --> 00:22:42.440
Essentially, if all the tests in the monorepo pass, you know that your changes have not broken your coworkers.

00:22:42.440 --> 00:22:56.880
You know that you can use in-repo tools like GitGrep to find or any kind of discovery tools and dependency analysis that tools like Pat's offer within the repo to find out the impact of your changes.

00:22:56.880 --> 00:23:00.200
And this is why monorepos are increasingly popular.

00:23:00.200 --> 00:23:04.880
And, you know, it's not to say that because a bunch of other companies are doing it, you should be doing it.

00:23:04.880 --> 00:23:15.880
But it is instructive to note that Google and Facebook and Twitter and a lot of successful companies have gone in that direction or in Google's case started out in that direction.

00:23:15.880 --> 00:23:16.700
Right.

00:23:16.700 --> 00:23:20.940
It has to be said that with monorepos or without, you need appropriate tooling.

00:23:21.200 --> 00:23:23.340
So at some point you have to pick your poison.

00:23:23.340 --> 00:23:39.920
But the reason I am biased towards monorepos, having worked at companies that have had one unified code base and companies that have had a very fragmented code base, is that the structure of your code base tends to recapitulate the cohesion and structure of your organization itself.

00:23:39.960 --> 00:23:55.340
And if everybody is collaborating on a single large repo within reason, you don't necessarily need to have literally one repo for the entire company, but a small number of large repos with boundaries between them that makes sense because they don't mutually depend on each other, let's say.

00:23:55.720 --> 00:24:02.620
Then that mutuality and that sharing of code creates more cohesion at the organizational level.

00:24:02.620 --> 00:24:06.420
And when you have a very fragmented code base, you tend to have a fragmented organization.

00:24:06.420 --> 00:24:13.820
Now your organization resembles, you know, a loose collection of warring tribes more than a single unified organization.

00:24:14.360 --> 00:24:17.140
So I am biased towards monorepos.

00:24:17.140 --> 00:24:26.660
And while you can use pants very effectively in even, you know, multiple smaller repos, I do think it supports the monorepo architecture really well.

00:24:26.660 --> 00:24:30.740
And the last thing I would say about this is just to really clarify, because we get a lot of questions about this.

00:24:30.740 --> 00:24:35.580
Monorepo is about your repo architecture, nothing to do with your deployment architecture.

00:24:35.580 --> 00:24:38.900
So it is not the opposite of microservices.

00:24:38.900 --> 00:24:46.840
For example, if you have many microservices, you probably want them to be in a single repo because they share, as you said, data models, they share code.

00:24:46.840 --> 00:25:00.440
And it is actually easier to deploy many microservices out of a single repo than constantly creating new teeny repos and having to go through the whole publish and consume dance every time you want to publish a microservice.

00:25:00.440 --> 00:25:08.800
And so publishing many microservices out of a single monolithic repo is actually a common pattern and a very effective one, in my opinion.

00:25:08.800 --> 00:25:18.280
Yeah, I guess if you have a monolith where the code is architectured into one giant thing, it necessarily means that you're probably just going to have it in one repo.

00:25:18.280 --> 00:25:23.600
But if it's microservices, there may be this temptation to have, well, we've got 10 microservices.

00:25:23.600 --> 00:25:30.000
So we've got 20 repos because here's each one for the service and then the shared bits got to be broken out into their own so they can be reused.

00:25:30.000 --> 00:25:30.620
Yes.

00:25:30.620 --> 00:25:37.500
Just essentially, you get a much, in a monorepo, you get a much tighter development loop because you are cutting out all of the publishing.

00:25:37.500 --> 00:25:38.880
Everything is consuming.

00:25:38.880 --> 00:25:41.920
All the inner code-based consumption is happening at head.

00:25:41.920 --> 00:25:45.180
So you don't have this constant publishing and consuming.

00:25:45.180 --> 00:25:45.800
Yeah.

00:25:45.800 --> 00:25:47.520
Yeah, I hadn't really thought about it that way.

00:25:47.520 --> 00:25:58.680
But a lot of the tools, the really good tools that we have, things like PyCharm and stuff, we can open them up and go to a function or a variable or a class and right-click and say, show me all the uses of this.

00:25:58.680 --> 00:26:05.160
But if there's a bunch of different consumers of your library, well, you don't really know because anybody could be grabbing something and using it.

00:26:05.160 --> 00:26:09.100
But if it's a monorepo and it says no usage is found, well, that means more.

00:26:09.100 --> 00:26:09.640
Exactly.

00:26:09.640 --> 00:26:15.020
The consumption metadata on published artifacts goes the wrong way, right?

00:26:15.020 --> 00:26:22.180
It says, the metadata that gets published with the wheel says, here is what this wheel consumes, but it has no idea who consumes it.

00:26:22.180 --> 00:26:25.860
And so if you want to figure that out, now you need a whole bunch of tooling.

00:26:25.860 --> 00:26:28.820
So why not just cut that out entirely?

00:26:28.820 --> 00:26:35.200
Yeah, and you get things like refactor, rename, or to cross the whole company sort of in interesting ways as well.

00:26:35.200 --> 00:26:36.880
Okay, cool.

00:26:36.880 --> 00:26:40.180
Maybe we should touch a little bit on the history of pants.

00:26:40.860 --> 00:26:47.060
There's, I know pants 1.0 has been around for a long time, and then there's this 2.0 version.

00:26:47.060 --> 00:26:49.480
You want to tell people a bit about the changes there?

00:26:49.480 --> 00:26:52.040
They maybe have experienced it a while ago.

00:26:52.040 --> 00:26:52.560
Sure thing.

00:26:52.560 --> 00:26:59.320
So pants, what we now refer to as pants v1, was a project that started as an internal project at Twitter,

00:26:59.320 --> 00:27:07.860
and it was focused primarily on Scala and how can we speed up Scala builds and make them more organized and more tractable.

00:27:07.860 --> 00:27:15.920
It then got open sourced out of Twitter and was used at a handful of other Scala-using companies, notably Foursquare.

00:27:15.920 --> 00:27:17.740
Square used it as well.

00:27:17.740 --> 00:27:24.260
There were a few companies of that vintage of early 2010s, Silicon Valley startups that were using Scala in a big way.

00:27:24.980 --> 00:27:27.860
So, in fact, v1 is basically gone at this point.

00:27:27.860 --> 00:27:30.440
I think there's a handful of organizations still maybe using it.

00:27:30.440 --> 00:27:32.400
We're desperately trying to get them onto v2.

00:27:32.400 --> 00:27:36.760
The pants v2 is a thing that we launched two years ago.

00:27:36.760 --> 00:27:40.060
There's a complete ground-up re-implementation.

00:27:40.060 --> 00:27:47.460
It really only shares a name with the old one and sort of project home with the old one.

00:27:47.460 --> 00:27:48.860
The code is entirely new.

00:27:48.860 --> 00:27:56.400
As you alluded to earlier, one of the big differences in the implementation is that the execution engine in v2 is written in Rust,

00:27:56.400 --> 00:27:59.960
and the APIs are async Python 3.

00:28:00.420 --> 00:28:02.280
But that is an important difference.

00:28:02.280 --> 00:28:11.340
But the bigger difference is the design itself is very different in that the v2 system learned a lot from our experience with v1,

00:28:11.340 --> 00:28:21.100
both in terms of the implementation and how to make important features like caching and concurrency just fall out of the design

00:28:21.100 --> 00:28:25.660
rather than be this laborious thing you have to add at every corner.

00:28:26.260 --> 00:28:31.400
And also, an equally important lesson was, unlike many other systems, including PANS v1,

00:28:31.400 --> 00:28:36.300
which came out of a single company and were really tailored for that company's use cases,

00:28:36.300 --> 00:28:38.760
with v2, we wanted to build something that was for everyone,

00:28:38.760 --> 00:28:42.420
that any organization, large or small, could use and get.

00:28:42.420 --> 00:28:48.340
You shouldn't have to work at Microsoft or Google or Twitter to get this quality of build experience.

00:28:48.340 --> 00:28:49.540
Anyone should be able to.

00:28:49.540 --> 00:28:55.000
And that required looking at the use cases of a lot of organizations of different languages and different sizes.

00:28:55.460 --> 00:28:59.140
And one thing we learned was nobody wants to write a ton of build metadata.

00:28:59.140 --> 00:29:03.840
If anyone's used a system like PANS v1 or Bazel or Buck or something similar,

00:29:03.840 --> 00:29:09.300
you start by potentially refactoring your code base to be what the system expects.

00:29:09.300 --> 00:29:13.980
And then you write thousands and thousands of lines of what so-called build files.

00:29:13.980 --> 00:29:16.020
We wanted to eliminate all of that.

00:29:16.020 --> 00:29:19.140
And so the system is designed to accept your code base as it is.

00:29:19.540 --> 00:29:22.720
And it doesn't require huge amounts of build metadata.

00:29:22.720 --> 00:29:25.260
It requires small amounts that it can mostly generate.

00:29:25.260 --> 00:29:28.140
But the important information, which is the dependencies,

00:29:28.140 --> 00:29:35.100
it actually infers at runtime by looking at import statements and various other tricks and heuristics

00:29:35.100 --> 00:29:38.460
for figuring out what your code's actual dependencies are.

00:29:38.820 --> 00:29:43.040
So that saves a huge amount of time and makes it a lot easier to use and a lot easier to adopt.

00:29:43.040 --> 00:29:45.700
So that's kind of why v2 came about.

00:29:45.700 --> 00:29:47.480
We wanted to build something that wasn't like,

00:29:47.480 --> 00:29:51.440
here's something we built for Twitter, throw it over the wall and you can use it if you want to.

00:29:51.440 --> 00:29:56.000
But here's a thing that was designed for you, designed for Python, designed to be easy to adopt,

00:29:56.000 --> 00:29:58.740
designed to be easy to use, designed to be easy to extend,

00:29:58.740 --> 00:30:03.160
has a robust API that is async Python 3 essentially.

00:30:03.620 --> 00:30:05.980
And that's where that project came from.

00:30:05.980 --> 00:30:10.240
Yeah, it's really interesting how it came from kind of this big tech side of things.

00:30:10.240 --> 00:30:15.420
But second take, it's like, well, how do we just make this for all the projects, not just the large ones?

00:30:15.420 --> 00:30:20.460
There's that, there was an interesting article and it's, you know, quoted in various forms a lot.

00:30:20.460 --> 00:30:23.340
Like, you're not Facebook, you're not Google, you're not LinkedIn.

00:30:23.340 --> 00:30:25.280
Speaking to most people, right?

00:30:25.280 --> 00:30:30.000
I mean, there are people who actually are there, but like for most people who look at these architectures

00:30:30.000 --> 00:30:33.220
and what's happening, they may, oh, look how they're scaling this.

00:30:33.220 --> 00:30:35.320
And like, yeah, but you just have a hundred users.

00:30:35.320 --> 00:30:40.980
You don't need to like go to that much architecture and crazy designs for, you know, what you're doing.

00:30:40.980 --> 00:30:48.000
And so it's, I can see how it would be a temptation to have like an overly complicated system that comes along.

00:30:48.000 --> 00:30:50.120
But it looks to me like this is really easy to adopt.

00:30:50.120 --> 00:30:55.380
It is significantly easier and we are constantly working on automating the adoption.

00:30:55.380 --> 00:31:05.860
There is a, one of the commands in Pants is, this is the only Pants related pun we've allowed ourselves in the system is called tailor because it quote unquote tailors your metadata.

00:31:05.860 --> 00:31:12.780
It essentially generates, it does inspection of your code and generates a bunch of metadata, not including dependencies.

00:31:12.780 --> 00:31:21.520
Those, as I mentioned, are inferred at runtime, but this is kind of a thing you run periodically because this is metadata that you may want to manually tweak.

00:31:21.520 --> 00:31:26.820
And so we're constantly working on making that easier and easier to adopt for real world cases.

00:31:27.080 --> 00:31:35.220
So just one obvious example is many repos have dependency tangles and circular dependencies and Pants v2 can handle that.

00:31:35.220 --> 00:31:38.280
Those other systems cannot, including Pants v1.

00:31:38.280 --> 00:31:48.880
And those other systems were not really designed for easy adoption because they didn't need to be, because they were only designed to be adopted once by a captive audience of all the developers at that company.

00:31:48.880 --> 00:31:53.180
We want this to be adopted thousands of times by thousands of organizations.

00:31:53.180 --> 00:31:55.180
So we want it to be much, much easier.

00:31:55.180 --> 00:32:02.060
This portion of Talk Python To Me is brought to you by Microsoft for Startups Founders Hub.

00:32:02.060 --> 00:32:04.120
Starting a business is hard.

00:32:04.120 --> 00:32:09.060
By some estimates, over 90% of startups will go out of business in just their first year.

00:32:09.060 --> 00:32:18.540
With that in mind, Microsoft for Startups set out to understand what startups need to be successful and to create a digital platform to help them overcome those challenges.

00:32:18.540 --> 00:32:21.220
Microsoft for Startups Founders Hub was born.

00:32:21.220 --> 00:32:27.880
Founders Hub provides all founders at any stage with free resources to solve their startup challenges.

00:32:27.880 --> 00:32:36.520
The platform provides technology benefits, access to expert guidance and skilled resources, mentorship and networking connections, and much more.

00:32:36.520 --> 00:32:46.080
Unlike others in the industry, Microsoft for Startups Founders Hub doesn't require startups to be investor-backed or third-party validated to participate.

00:32:46.080 --> 00:32:48.760
Founders Hub is truly open to all.

00:32:48.760 --> 00:32:50.260
So what do you get if you join them?

00:32:50.260 --> 00:32:58.520
You speed up your development with free access to GitHub and Microsoft Cloud computing resources and the ability to unlock more credits over time.

00:32:58.520 --> 00:33:08.260
To help your startup innovate, Founders Hub is partnering with innovative companies like OpenAI, a global leader in AI research and development, to provide exclusive benefits and discounts.

00:33:08.260 --> 00:33:13.680
Through Microsoft for Startups Founders Hub, becoming a founder is no longer about who you know.

00:33:14.000 --> 00:33:27.240
You'll have access to their mentorship network, giving you a pool of hundreds of mentors across a range of disciplines and areas like idea validation, fundraising, management and coaching, sales and marketing, as well as specific technical stress points.

00:33:27.240 --> 00:33:32.440
You'll be able to book a one-on-one meeting with the mentors, many of whom are former founders themselves.

00:33:32.440 --> 00:33:37.580
Make your idea a reality today with the critical support you'll get from Founders Hub.

00:33:37.940 --> 00:33:43.540
To join the program, just visit talkpython.fm/founders hub, all one word, no links in your show notes.

00:33:43.540 --> 00:33:45.840
Thank you to Microsoft for supporting the show.

00:33:46.200 --> 00:33:51.280
You talked about some of the tools that you could use.

00:33:51.280 --> 00:34:00.860
Maybe we could go through that list of common tools real quickly and you could just give us your thoughts on why you think it's great and maybe why you might want to adopt it and make it part of your flow.

00:34:00.860 --> 00:34:04.180
Because with Pants, you don't have to add more steps, as we said.

00:34:04.180 --> 00:34:06.960
So some of the tools you've called out are mypy.

00:34:06.960 --> 00:34:10.860
I know you're a fan of Python 3 and Pype annotations.

00:34:10.860 --> 00:34:12.280
Tell people quick about mypy.

00:34:12.280 --> 00:34:19.500
So for those who aren't familiar, mypy brings a level of rigor to your Python quality control that is fantastic.

00:34:19.500 --> 00:34:29.240
Essentially, you add type annotations to your Python 3 code and mypy performs static type checking and is absolutely tremendous.

00:34:29.240 --> 00:34:33.620
You know, it is essentially a sort of compilation step for Python.

00:34:33.620 --> 00:34:33.940
Right.

00:34:33.940 --> 00:34:40.460
It's not actually generating code, but it is performing type checks that finds a wide variety of bugs and issues.

00:34:40.660 --> 00:34:43.520
And I would never go back to non-type checked Python.

00:34:43.520 --> 00:34:44.100
Interesting.

00:34:44.100 --> 00:34:44.480
Yeah.

00:34:44.480 --> 00:34:47.960
So it's like, if I were to compile it, what would happen?

00:34:47.960 --> 00:34:54.880
We're not actually going to, but let's go through that and give you a report, like sort of print out the warnings and errors that you would have seen in a compiled language.

00:34:54.880 --> 00:34:57.160
And then we'll carry on.

00:34:57.160 --> 00:35:03.560
You know, a common way these things are referred to in Python is type hints, which kind of implies they have no effect.

00:35:03.560 --> 00:35:06.140
But with mypy, it's a little bit closer, right?

00:35:06.300 --> 00:35:06.560
Right.

00:35:06.560 --> 00:35:11.820
So they have no runtime effect, it is true, but they have the type annotations.

00:35:11.820 --> 00:35:21.200
Well, they can if you, in certain circumstances, pants itself uses its own code type annotations at runtime in an interesting way.

00:35:21.680 --> 00:35:28.240
But generally, running mypy just is an extremely effective quality control check in your code.

00:35:28.240 --> 00:35:31.760
But getting set up with mypy can be complicated.

00:35:31.760 --> 00:35:40.940
And with pants, you just pants check all my code or pants check all my code that has changed since my last, you know, since my last edits.

00:35:41.700 --> 00:35:46.160
And it will install mypy and it will set it up and it will run it.

00:35:46.160 --> 00:35:49.080
First time you do that, you'll get many, many errors, I'm sure.

00:35:49.080 --> 00:35:50.220
I'm sure.

00:35:50.220 --> 00:35:51.460
I'm sure you will.

00:35:51.460 --> 00:35:56.600
Another one you've given a shout out to is Protobuf for protocol buffers.

00:35:56.600 --> 00:35:59.620
I don't know that I've spoken very much about those at all on the show.

00:35:59.620 --> 00:36:02.000
I mean, people know REST and JSON.

00:36:02.000 --> 00:36:05.160
They may have scars from SOAP and XML.

00:36:06.100 --> 00:36:07.860
I'm not sure how many people are doing it.

00:36:07.860 --> 00:36:10.780
It depends on how long they've been doing this kind of stuff.

00:36:10.780 --> 00:36:12.260
But what's Protobuf?

00:36:12.260 --> 00:36:14.520
I just had XML PTSD for a second there.

00:36:14.520 --> 00:36:15.180
Yeah, I'm sorry.

00:36:15.180 --> 00:36:18.400
I'll send a therapist your way after the show.

00:36:18.400 --> 00:36:30.800
So Protobuf is a really fabulous tool out of Google that generates code in many languages from a .proto file,

00:36:30.800 --> 00:36:34.080
which is a language neutral interface definition language.

00:36:34.700 --> 00:36:39.980
And that works well with gRPC, which is the Google RPC language,

00:36:39.980 --> 00:36:47.020
where it actually generates RPC code and stubs so that you can use protocol buffers.

00:36:47.020 --> 00:36:51.120
These over-the-wire protocols is referred to as protocol buffers.

00:36:51.120 --> 00:36:57.120
And you can just use them as this binary interchange format that is very efficient over the wire.

00:36:57.680 --> 00:37:03.160
So exchanging binary data, if you say, here's four bytes, that's the account.

00:37:03.160 --> 00:37:06.720
And then here's the length of the string is the next four bytes.

00:37:06.720 --> 00:37:10.060
And then doing that manually is super tricky.

00:37:10.500 --> 00:37:13.440
And so protocol buffers is a formalization of that.

00:37:13.440 --> 00:37:18.560
And then this tool would maybe write the Python code that understands a particular exchange.

00:37:18.560 --> 00:37:18.800
Okay.

00:37:18.800 --> 00:37:21.200
So PaaS knows how to do code generation in general.

00:37:21.200 --> 00:37:27.200
It supports many code generators, including Thrift, which is a sort of similar in spirit to Protobuf.

00:37:27.780 --> 00:37:29.920
But Protobuf is a very prominent one.

00:37:29.920 --> 00:37:35.420
And the idea is that it will generate this Python code out of, you have this very succinct interface definition,

00:37:35.420 --> 00:37:41.920
and it generates fairly elaborate Python code that can serialize and deserialize these messages

00:37:41.920 --> 00:37:46.900
and send them via RPC interfaces and send and receive them via RPC interfaces over the wire,

00:37:46.900 --> 00:37:50.280
where the thing on the other side of that RPC interface might not be Python at all.

00:37:50.280 --> 00:37:52.620
But they're all talking the same IDL.

00:37:52.620 --> 00:37:56.500
And yeah, protos are very efficient binary formats.

00:37:56.500 --> 00:37:59.100
So they use things like variable length integer encoding.

00:37:59.100 --> 00:38:06.140
So the same message will be significantly more compact in Protobuf as it will be in JSON.

00:38:06.140 --> 00:38:10.480
That said, in probably many, many cases, JSON is absolutely fine, right?

00:38:10.480 --> 00:38:18.520
Exactly. There's a ton of value to be like, I can point my web browser or postman or something at that and see the answer.

00:38:18.520 --> 00:38:19.520
Yes.

00:38:19.520 --> 00:38:21.200
Right? Like, that goes a long ways.

00:38:21.200 --> 00:38:28.720
But if you're exchanging really low latency, lots of data as fast as you can, then, you know, JSON is probably not it.

00:38:28.720 --> 00:38:33.440
Certainly XML with namespaces and XSLT is definitely not the right thing.

00:38:33.440 --> 00:38:37.060
So this sounds like a cool, more modern way to do it.

00:38:37.140 --> 00:38:41.500
Some other tools. We've already talked about pytest. People know what pytest is.

00:38:41.500 --> 00:38:44.640
Black formatting, right? Auto formatting a code.

00:38:44.640 --> 00:38:45.280
So is that much?

00:38:45.280 --> 00:38:47.280
Stop the indentation arguments.

00:38:47.280 --> 00:38:47.800
Yes.

00:38:47.800 --> 00:38:48.600
Oh my God.

00:38:48.660 --> 00:39:00.320
When we adopted black in the pants repo, everybody, myself included, got upset for about 10 minutes and then realized that far more important than which format is that there is format that is enforced automatically.

00:39:00.760 --> 00:39:06.320
I personally used to at least prefer two space indents to four space indents. Black is the reason it's called black.

00:39:06.320 --> 00:39:10.080
For those who don't know, is that famous, you can have any color you want as long as it's black.

00:39:10.080 --> 00:39:11.820
I think that was Henry Ford.

00:39:11.820 --> 00:39:13.260
I think so. Model T.

00:39:13.760 --> 00:39:18.800
So basically, it's a very opinionated formatter that just says this is what Python code should look like.

00:39:18.800 --> 00:39:22.840
And you know what? I embrace robot overlords in this case.

00:39:22.840 --> 00:39:23.240
Yeah.

00:39:23.360 --> 00:39:28.020
It's absolutely wonderful. I can just do pants format and it just formats all the code.

00:39:28.020 --> 00:39:32.920
That is the, there are no more arguments. Like the true formatting is whatever black outputs.

00:39:32.920 --> 00:39:35.560
And pants, again, makes it very easy to adopt black.

00:39:35.560 --> 00:39:44.040
It also makes it easy, I should mention, for linters, for formatters, even for mypy, pants has affordances in it to help you adopt them incrementally, which you kind of have to do.

00:39:44.040 --> 00:39:53.080
If you have an existing code base, you may want to adopt, you know, it takes time to, so black is very aggressive, but there are many other linters that pants can run.

00:39:53.080 --> 00:39:57.500
And a doc formatter and flake eight and pilot and bandit and so on.

00:39:57.500 --> 00:40:03.420
And I sort, and you may want to adopt them incrementally and pants has ways to help you do that.

00:40:03.420 --> 00:40:07.140
And certainly with mypy, because it relies on upstream.

00:40:07.140 --> 00:40:12.600
mypy, you kind of have to adopt independency order because it relies on upstream type annotations.

00:40:12.600 --> 00:40:14.020
And so there are ways to do that.

00:40:14.020 --> 00:40:18.880
Right. To get the most out of it, you've got to have the, we call these three functions.

00:40:18.880 --> 00:40:22.120
Well, those three functions have to have type information and be valid.

00:40:22.240 --> 00:40:23.780
And I got to start at the foundation with those.

00:40:23.780 --> 00:40:25.000
Bandit's interesting.

00:40:25.000 --> 00:40:27.320
I don't know how many people run Bandit.

00:40:27.320 --> 00:40:33.100
Probably people who accept user input probably should or input from the internet.

00:40:33.100 --> 00:40:34.420
Tell people about Bandit.

00:40:34.420 --> 00:40:35.440
I'm not super familiar.

00:40:35.440 --> 00:40:39.040
I'm no expert on Bandit, but it's just about security checks.

00:40:39.040 --> 00:40:43.760
So it will automatically find common security issues in your code.

00:40:43.760 --> 00:40:46.040
And again, Pants makes it very easy to adopt it.

00:40:46.100 --> 00:40:48.700
You essentially just enable the Bandit plugin.

00:40:48.700 --> 00:40:55.620
Pants, I should imagine, has this plugin architecture where you can opt in to whichever sort of bits of functionality you want.

00:40:55.620 --> 00:40:56.980
So you enable the Bandit plugin.

00:40:56.980 --> 00:40:58.120
And that's kind of it.

00:40:58.120 --> 00:41:01.940
And the next time you run Lint, it will run the Bandit checks.

00:41:01.940 --> 00:41:04.800
And it will yell at you about all the security issues that's found in your code.

00:41:04.920 --> 00:41:05.140
That's cool.

00:41:05.140 --> 00:41:06.260
So you have these different categories.

00:41:06.260 --> 00:41:09.420
Like you have a test category, a Lint category, and so on.

00:41:09.420 --> 00:41:14.780
And then in your configuration, you can say, when I say Lint, I mean these three things.

00:41:14.780 --> 00:41:15.180
Correct.

00:41:15.580 --> 00:41:20.460
So what you refer to as a category in the sort of Pants jargon is referred to as a goal.

00:41:20.460 --> 00:41:22.420
So it's basically what you type on the command line.

00:41:22.420 --> 00:41:25.640
You type Pants test means run test.

00:41:25.640 --> 00:41:27.440
Pants Lint means run all the Linters.

00:41:27.440 --> 00:41:30.880
But what all the Linters means depends on your configuration.

00:41:30.880 --> 00:41:31.220
Sure.

00:41:31.220 --> 00:41:32.500
That makes a lot of sense.

00:41:32.500 --> 00:41:33.620
Maybe one more.

00:41:33.620 --> 00:41:36.220
I know the list is kind of unbounded in a sense.

00:41:36.660 --> 00:41:42.460
But AWS Lambda or sort of functions, serverless functions in general.

00:41:42.460 --> 00:41:43.640
There's probably other ones.

00:41:43.640 --> 00:41:46.140
You could probably do Azure functions and other things as well.

00:41:46.140 --> 00:41:50.080
The two we support at the moment are Google Cloud Functions and AWS Lambdas.

00:41:50.080 --> 00:41:50.380
Yes.

00:41:50.380 --> 00:41:56.980
So Pants knows how to take your Python code and package it into a Lambda function that you can

00:41:56.980 --> 00:42:00.540
deploy to AWS or a Cloud Function you can deploy to GCP.

00:42:00.540 --> 00:42:04.920
The management of that kind of stuff is super picky because you might have 20 functions coming

00:42:04.920 --> 00:42:06.420
out of all these different pieces of code.

00:42:06.580 --> 00:42:09.700
Did you forget to push that to that particular function point?

00:42:09.700 --> 00:42:11.580
That's really hard to do to keep that straight.

00:42:11.580 --> 00:42:16.060
If you're using serverless, if you're using Cloud Functions, you probably have many of them.

00:42:16.060 --> 00:42:22.880
And a tool that can tell you which ones need to be redeployed based on changes, because it's

00:42:22.880 --> 00:42:29.440
very simple with Pants to say which Cloud Functions have been affected by any transitive change since

00:42:29.440 --> 00:42:31.860
this tag, since this deployment tag.

00:42:31.860 --> 00:42:35.880
And it will tell you, it'll just give you a list and you can just repackage them and redeploy

00:42:35.880 --> 00:42:36.180
them.

00:42:36.500 --> 00:42:39.840
Without having to repackage and redeploy everything every single time.

00:42:39.840 --> 00:42:40.120
Awesome.

00:42:40.120 --> 00:42:42.260
Yeah, that sounds incredibly helpful if you're using them.

00:42:42.260 --> 00:42:47.540
So the reason I wanted to go through that list here is like if adopting those tools and those

00:42:47.540 --> 00:42:54.640
features sounds interesting, the more you adopt, the more the tools like Pants can help lower

00:42:54.640 --> 00:42:56.480
the burden and just make that automatic, right?

00:42:56.640 --> 00:42:57.000
Exactly.

00:42:57.000 --> 00:43:00.760
It generally just takes away the pain of how do I adopt this tool?

00:43:00.760 --> 00:43:01.760
How do I run it?

00:43:01.760 --> 00:43:03.160
How do I configure it?

00:43:03.160 --> 00:43:07.080
How do I make sure that everyone in my team is on the same page about how to use these things?

00:43:07.080 --> 00:43:09.820
It just automates away all of that.

00:43:10.060 --> 00:43:18.480
It also supports things like you can run a Python REPL that contains all the dependencies of the bit of code you're interested in.

00:43:18.680 --> 00:43:34.020
It can do, because it has this fine-grained dependency analysis, it can know that even if you have like a big requirements.txt file, it knows which sub parts of that requirements.txt and their transitive dependencies are relevant to every given binary.

00:43:34.020 --> 00:43:41.260
So now you're not managing many different sets of requirements for each of your, let's say, Cloud Functions or each of your Docker images.

00:43:41.260 --> 00:43:43.540
That's all happening automatically for you.

00:43:43.540 --> 00:43:43.880
Nice.

00:43:43.880 --> 00:43:50.760
Let's talk about running these tasks and caching, performance, parallelization, and so on.

00:43:50.760 --> 00:44:00.420
So one thing it has here right on the pantsbuild.org page, and you've hinted at this a few times, is that it speaks Git.

00:44:00.420 --> 00:44:03.880
And so it has this way of understanding changes.

00:44:03.880 --> 00:44:04.340
Yes.

00:44:04.340 --> 00:44:12.020
So built into it is the ability to say, like things like when you want to run tests, you can say run all the tests.

00:44:12.020 --> 00:44:13.900
You can say run all the tests in this directory.

00:44:13.900 --> 00:44:16.880
You can say run all the tests, run this specific test.

00:44:16.880 --> 00:44:22.420
You can say run all the tests that have this tag, this like a tagging mechanism sort of where you can label things.

00:44:22.760 --> 00:44:30.660
Or you can say run all the tests that are affected by changes since this other Git state.

00:44:30.660 --> 00:44:40.360
So you can say, you know, as you're working on your laptop, you can say, all right, run the tests that could possibly be affected based on my changes since the main branch.

00:44:40.500 --> 00:44:45.780
It will internally use Git tooling to figure out what that means.

00:44:45.780 --> 00:44:50.460
So it'll say, OK, which files have you changed and which things are downstream from those changes.

00:44:50.460 --> 00:44:54.100
When you say affected by, how is that determined?

00:44:54.100 --> 00:45:00.540
Does that mean I saw there's some Python code that my, here's my test and my test is importing this and these import those?

00:45:00.920 --> 00:45:03.680
Or does it do like code coverage?

00:45:03.680 --> 00:45:07.140
What does it base its opinion on of what's changed?

00:45:07.140 --> 00:45:11.600
It based its opinions on its view of your code's dependencies.

00:45:11.600 --> 00:45:16.140
Now, almost all of that view comes from analysis of import statements.

00:45:16.140 --> 00:45:18.740
Occasionally, you may have to override those.

00:45:18.740 --> 00:45:27.320
So, for example, if you're using Django, we have good support for Django, but Django notoriously does a huge amount of dynamic loading based on strings in settings.py.

00:45:27.320 --> 00:45:28.240
Right, right, right.

00:45:28.240 --> 00:45:31.400
Occasionally, sometimes pants can actually look at those strings and figure it out.

00:45:31.400 --> 00:45:38.100
It has a mode where you can tell it that if it sees strings in a file that look like module names to assume that those are like imports.

00:45:38.100 --> 00:45:39.640
But sometimes that doesn't work.

00:45:39.640 --> 00:45:49.000
And so you can manually override the dependency inference and you can say, actually, here's a dependency that's important and you failed to infer it.

00:45:49.000 --> 00:45:53.020
Or the opposite, you can exclude a dependency that pants mistakenly inferred.

00:45:53.020 --> 00:45:54.600
But that's extremely rare.

00:45:55.460 --> 00:46:00.560
So it bases that on its automatic static analysis of your dependencies.

00:46:00.560 --> 00:46:00.920
Cool.

00:46:00.920 --> 00:46:08.560
So one of the things that might be important when you're running these steps is, for example, the protobuf thing.

00:46:08.560 --> 00:46:09.500
Right.

00:46:09.500 --> 00:46:21.760
Its step has an output and maybe that output is consumed by some other, maybe by the tests or maybe the tests load up the Python file that was generated by that to go talk to some binary blob and see if it understands it.

00:46:21.980 --> 00:46:23.500
It's really important those run in order, right?

00:46:23.500 --> 00:46:23.860
Yes.

00:46:23.860 --> 00:46:38.400
So from your dependencies plus its understanding of which jobs need which inputs, needs to consume which inputs and which jobs produce those inputs as their outputs, it constructs this very fine-grained workflow graph.

00:46:38.840 --> 00:46:41.460
And that is exactly where the caching and the concurrency comes from.

00:46:41.460 --> 00:46:49.440
So every node in this graph, and it could be thousands even, every very fine-grained node in this workflow graph knows exactly which inputs it needs.

00:46:49.440 --> 00:46:53.060
And the work is done in the right sequence.

00:46:53.300 --> 00:47:01.200
So if you have two pieces of work that neither of which depend on each other, right, in the DAG sense, they are independent, they can run concurrently, and they will.

00:47:01.200 --> 00:47:06.720
So presumably, if you have multiple cores on your machine, they literally will run, they could run in parallel at the same time.

00:47:06.720 --> 00:47:14.620
But obviously, if a little work unit needs the output of some other work unit to be its input, then it will wait for those.

00:47:14.700 --> 00:47:20.020
And how all that is strung together is using all of the work as described.

00:47:20.020 --> 00:47:23.760
As I mentioned, the API for this is Python 3, is async Python 3.

00:47:23.760 --> 00:47:29.580
And so you have these things called rules, which are these async coroutines.

00:47:30.000 --> 00:47:36.760
And the Rust engine strings together executions of these rules based on data dependencies.

00:47:36.760 --> 00:47:46.600
And the data dependencies use type annotations, use just regular Python 3 type annotations, to say, to describe the types of the inputs and outputs.

00:47:46.600 --> 00:47:52.160
And so the engine can say, ah, you, this rule needs to consume an output of this type.

00:47:52.160 --> 00:47:58.260
I have found a rule that produces an output of that type based on some other input that I already have.

00:47:58.260 --> 00:47:59.740
So I will string them together.

00:47:59.740 --> 00:48:06.580
And it will do that recursively until it ends up at sort of the initial data, which obviously it has.

00:48:06.580 --> 00:48:06.820
Right.

00:48:06.820 --> 00:48:09.080
We'll start here, go down this path in that order.

00:48:09.080 --> 00:48:11.640
Some of them, though, can be parallel, right?

00:48:11.640 --> 00:48:13.920
Like Bandit and PyFlake.

00:48:13.920 --> 00:48:19.040
Those just, mypy, all those just look at the code and say, looks good or doesn't look good.

00:48:19.040 --> 00:48:20.760
And here's your warning message, right?

00:48:20.760 --> 00:48:25.500
And so you can, does it by default or just optionally parallelize that?

00:48:25.500 --> 00:48:27.300
No, it will happen by default.

00:48:27.300 --> 00:48:30.820
It will always, I mean, you can control the amount of concurrency.

00:48:30.820 --> 00:48:34.640
Let's say you're running multiple things on the machine and you don't want it to consume all your cores.

00:48:34.640 --> 00:48:36.160
You can tune that down.

00:48:36.160 --> 00:48:41.960
But just normally by default, it will use as much concurrency as the graph allows.

00:48:41.960 --> 00:48:49.020
So every one of those small work units is candid for being executed concurrently with other ones.

00:48:49.020 --> 00:48:52.360
But it is also, and this is really important, a candidate for being cached.

00:48:52.360 --> 00:48:56.340
So many, many intermediate steps can be cached.

00:48:56.560 --> 00:49:05.260
In a typical iterative run when you're iterating on your laptop and you're developing and you make some changes and you run some tests and you make some changes and you run the tests again.

00:49:05.260 --> 00:49:12.620
So much work that normally would be repeated will not be repeated by pants because it will be, the outputs will be pulled from cache.

00:49:12.620 --> 00:49:13.660
Yeah, that's fantastic.

00:49:13.800 --> 00:49:17.560
Because every one of those nodes has its, it runs, as I said, with no side effects.

00:49:17.560 --> 00:49:23.480
It runs in a sandbox with no side effects and its inputs and outputs are statically defined.

00:49:23.480 --> 00:49:27.500
So it can be correctly cached every time.

00:49:27.500 --> 00:49:32.760
So you don't, you as an author of a plugin, for example, don't have to think about caching or concurrency.

00:49:32.900 --> 00:49:36.960
You just write to the API and caching or concurrency fall out of the design.

00:49:36.960 --> 00:49:37.780
That's really neat.

00:49:37.780 --> 00:49:44.500
And I can imagine on a large code basis, things like Bandit and mypy, all those analysis tools, they can take a while.

00:49:44.900 --> 00:49:55.180
And if you just change one file, and especially if you're in the monorepo business, where it's not just for your website, but there's a ton of stuff, you don't want to rerun all those things.

00:49:55.180 --> 00:49:56.500
So it could really get a lot faster.

00:49:56.500 --> 00:49:59.020
You can get a lot of speed increases that way.

00:49:59.020 --> 00:49:59.340
Yes.

00:49:59.340 --> 00:49:59.640
Yeah.

00:49:59.640 --> 00:50:06.280
One of the hesitations to adopt tools like this is it keeps rerunning from scratch over and over, and that makes it slow.

00:50:06.640 --> 00:50:18.860
The other one is while you may run it, your teammates may have a less buy-in on some of these linting, formatting, testing ideas.

00:50:18.860 --> 00:50:22.840
And if you just do that in CI, well, when you check it in, it works.

00:50:22.840 --> 00:50:24.260
Someone else gets their code.

00:50:24.260 --> 00:50:24.980
You merge theirs.

00:50:24.980 --> 00:50:25.840
You check it in again.

00:50:25.840 --> 00:50:27.500
And it breaks the build.

00:50:27.500 --> 00:50:28.720
And it can be super frustrating.

00:50:28.720 --> 00:50:36.220
Is there a way, like a pre-commit hook or some other mechanism to encourage these to be run by everyone?

00:50:36.520 --> 00:50:37.600
You certainly can have a-

00:50:37.600 --> 00:50:39.820
Or is that a personnel problem?

00:50:39.820 --> 00:50:41.760
That really depends on the organization.

00:50:41.760 --> 00:50:45.340
We tend to see adoption of pants at the team level.

00:50:45.340 --> 00:50:53.560
Usually what happens is someone who is someone at the team who is just fed up with a not great status quo drives adoption of it.

00:50:53.560 --> 00:51:00.380
And other team members see, there's obviously initial skepticism because there always is whenever you try to introduce new tooling.

00:51:00.380 --> 00:51:02.160
I'm as guilty of this as anyone.

00:51:02.620 --> 00:51:06.720
But then there's that aha moment of, oh, things got more rigorous and faster.

00:51:06.720 --> 00:51:09.340
That is a trade-off I will gladly take.

00:51:09.340 --> 00:51:09.620
Yeah.

00:51:09.620 --> 00:51:23.380
So very often if CI runs pants, and that is therefore in some sense the definition of correct quality control checks, because whether it's testing, linting, packaging, etc.

00:51:24.060 --> 00:51:33.060
Because you can't merge until you pass CI, there's strong incentive there for you to use the same thing that CI is doing on your laptop.

00:51:33.060 --> 00:51:40.660
Because if you get that to pass on your laptop, it is overwhelmingly more likely to pass in CI, which just gets you to merge faster.

00:51:40.660 --> 00:51:44.980
Yeah, I guess it depends a little bit on how you work as a team and source control, right?

00:51:44.980 --> 00:51:49.440
If everyone can just commit to main, it's much harder to have that.

00:51:49.440 --> 00:51:58.980
But if you've got to go through kind of a get flow, like you work on your branch and then you merge it into main when it's approved and CI passes, well, then all of a sudden, if CI is not passing, you're not merging.

00:51:58.980 --> 00:52:02.140
And yeah, then it trickles back until it gets fixed.

00:52:02.260 --> 00:52:18.140
I think this is a big part of Python, quote unquote, growing up as a language like now, again, it's not fancy shell scripts, it is a workhorse language that people are building massive businesses and systems and data science capabilities out of.

00:52:18.140 --> 00:52:25.500
And you need to, you know, that comes with responsibility to be rigorous about quality control.

00:52:26.120 --> 00:52:35.540
And essentially, you know, having really good CI, having really good iterative development practices is something that is really important for these growing repos.

00:52:35.540 --> 00:52:37.260
And it's why pants exists.

00:52:37.260 --> 00:52:42.040
It is to make that much, much easier and much, much faster than it would otherwise be.

00:52:42.460 --> 00:52:53.720
If you are sort of not running tests, not really running any checks, pushing directly to main, you know, because, you know, historically, Python repos were these tiny toy things that you could do that in.

00:52:53.720 --> 00:52:57.900
You know, you're asking for trouble sooner or later.

00:52:57.900 --> 00:53:03.800
So I'm asking you, how do I get this tool that applies all these, automates all of these engineering best practices?

00:53:03.800 --> 00:53:10.200
And you're suggesting that maybe you start by, start at the core and work your way out, right?

00:53:10.200 --> 00:53:16.600
Like, like just the way that you work together as a team through source control, like you formalize that a little bit, then everything else becomes easy.

00:53:16.600 --> 00:53:17.420
I think so.

00:53:17.420 --> 00:53:22.200
I mean, having CI that is the, you need some way of saying what is correct.

00:53:22.200 --> 00:53:27.040
You need some way of saying, if this CI is green, that means you can merge this change.

00:53:27.040 --> 00:53:30.000
If this CI is green, it means that you can deploy to production.

00:53:30.140 --> 00:53:33.580
You need some way, automated way of saying this code is good.

00:53:33.580 --> 00:53:38.800
Pants makes it very easy to build that ability.

00:53:38.800 --> 00:53:42.960
And once you have that, you never want to go back.

00:53:42.960 --> 00:53:49.320
There is a hurdle you have to, you know, it's less convenient than not doing any quality control, but you sort of have to.

00:53:49.320 --> 00:53:51.120
Well, it's less convenient up front.

00:53:51.120 --> 00:53:52.360
It's less convenient up front.

00:53:52.360 --> 00:53:54.500
It's easier to just not worry about it.

00:53:54.500 --> 00:53:55.320
But you.

00:53:55.320 --> 00:53:55.740
It is.

00:53:55.740 --> 00:54:03.900
But as soon as you spend the whole weekend trying to figure out why the thing doesn't work and you're supposed to release it and it turns out it was somebody else's problem and they didn't test.

00:54:03.900 --> 00:54:07.740
And then like, then all of a sudden that, that little bit of work up front didn't seem so big.

00:54:07.740 --> 00:54:09.000
Nobody goes backwards, right?

00:54:09.000 --> 00:54:12.340
Nobody goes in the direction of fewer quality control checks.

00:54:12.340 --> 00:54:18.260
There is a point in the evolution of your repo where you start adopting them and you just adopt more and more of them.

00:54:18.400 --> 00:54:19.440
And right.

00:54:19.440 --> 00:54:19.980
You don't go.

00:54:19.980 --> 00:54:20.500
It's a rat.

00:54:20.500 --> 00:54:21.860
It's a one way ratchet, basically.

00:54:21.860 --> 00:54:22.880
And with good reason.

00:54:22.880 --> 00:54:32.780
In my mind, all these conversations I've been having, I've been around like teams, I guess, maybe seated by the idea of you talking about it coming from places like Twitter and so on.

00:54:32.780 --> 00:54:36.480
What is the pants story for open source repos?

00:54:36.480 --> 00:54:39.880
Like if I was in charge of HTTPX, I'm not.

00:54:39.880 --> 00:54:41.540
But if I were, what does pants offer me?

00:54:41.540 --> 00:54:53.240
So we do, we're starting to see open source repos adopt pants now, tends to be the larger ones where things like how can I speed up tests become a question even in that regard.

00:54:53.240 --> 00:55:05.540
One thing that we haven't talked about really is security and sort of protecting your own software supply chain, especially if you're an open source project where you are typically part of other people's software supply chain.

00:55:05.540 --> 00:55:16.240
So one of the features of pants is it has very strong support for lock files where a universal lock files that are valued across platforms that lock down.

00:55:16.240 --> 00:55:26.400
Essentially, you generate a lock file that contains pins every single transitive dependency, including these SHA-256s of all of the wheel files.

00:55:26.880 --> 00:55:36.120
And pants then knows how to very efficiently build virtual environments out of the subset of those that is actually necessary in any given situation.

00:55:36.120 --> 00:55:39.700
So if a test only needs some small subset, it will only use those.

00:55:39.700 --> 00:55:50.520
The advantage being that that test gets invalidated a lot less when, because it doesn't get invalid, the results don't get invalidated if an unrelated requirement, upstream requirement changes.

00:55:51.720 --> 00:56:02.960
So even for smaller repos or for, you know, open source repos, apart from all the other benefits, one benefit that I think is worth looking at is lock files and just locking down your supply chain.

00:56:02.960 --> 00:56:06.580
It means you don't have like the left pad issue, things like that.

00:56:06.580 --> 00:56:14.780
You are much more robust to your build is much less impacted by changes on PyPI, by changes in the world at large.

00:56:14.780 --> 00:56:23.000
Yeah, in the homepage, it says it has out of the box support for multiple dependency resolvers in addition to these lock files, right?

00:56:23.000 --> 00:56:29.360
So is this like your own private PyPI server that you can limit what goes in there?

00:56:29.360 --> 00:56:29.960
What does that mean?

00:56:29.960 --> 00:56:30.620
Well, you can.

00:56:30.620 --> 00:56:34.480
I think what that was referring to was that you can have multiple of these lock files.

00:56:34.480 --> 00:56:36.740
So you have a large code base.

00:56:36.740 --> 00:56:40.800
You might have different parts of it that genuinely need conflicting dependencies.

00:56:41.140 --> 00:56:54.020
But you can sort of say, OK, here are like two or three lock files that you are allowed to, you know, you have to pick one for a piece of code or a piece of code can be compatible with multiple, but you have to pick one when you come to build a binary or something like that.

00:56:54.020 --> 00:57:00.020
So, for example, it's pretty common to have, you know, here is a lock file that is for my web application code.

00:57:00.020 --> 00:57:06.460
And here's a different lock file for my data science code, because there are just conflicts between them that can't be resolved.

00:57:06.460 --> 00:57:12.620
There may be no reason to install JupyterLab on your FastAPI server, right?

00:57:12.620 --> 00:57:24.140
Well, that wouldn't happen anyway, because Pants would know, even if you had a single lock file that included, say, you know, NumPy, Pants would know that nothing in your web app imports NumPy, so it wouldn't bring it in.

00:57:24.140 --> 00:57:26.980
This is more when you actually have multiple lock files.

00:57:27.380 --> 00:57:34.740
Yeah, so Pants is very good about shaving down the dependencies, both the internal and the external ones, to just what you actually need.

00:57:34.740 --> 00:57:45.680
But where multiple lock files comes in is when you have conflicts, when your code base is large enough that you genuinely cannot have the entire code base be in lockstep on a single set of dependencies.

00:57:45.680 --> 00:57:47.280
We don't encourage that.

00:57:47.280 --> 00:57:48.880
It's not a great way to be.

00:57:48.880 --> 00:57:54.160
It's better if you can have a single, consistent resolve across your entire code base, but it's not always possible.

00:57:54.160 --> 00:58:00.440
And this is an example of where we designed for the world as it is and not the world as we would like it to be.

00:58:00.440 --> 00:58:01.720
Yeah, that makes a lot of sense.

00:58:01.720 --> 00:58:10.600
I mean, if one of the APIs is written in Django 1 and the person who built it left and there's no reason for it to change, like, just don't touch it.

00:58:10.600 --> 00:58:11.700
Just leave that alone over there.

00:58:11.820 --> 00:58:15.700
But the other part needs to use, you know, newer libraries and sure.

00:58:15.700 --> 00:58:17.220
Yes, that's a great example.

00:58:17.220 --> 00:58:17.820
Yeah, cool.

00:58:17.820 --> 00:58:18.700
All right, Benji.

00:58:18.700 --> 00:58:25.180
I think we might be getting short on time here, but let me close this out with one final question.

00:58:25.180 --> 00:58:33.140
So you talked a lot about the caching and the parallelization and how, like, the dependency understanding.

00:58:33.140 --> 00:58:40.980
So if I want to run these tests, I can just say, run since this last get a tag or whatever, a shah or whatever it is you're going back to.

00:58:40.980 --> 00:58:47.000
What is your personal workflow or common workflows you see for managing that?

00:58:47.000 --> 00:58:50.900
Because at some point I'm like, okay, the stuff up to here is good.

00:58:50.900 --> 00:58:52.500
Now I want to, it's been a few days.

00:58:52.500 --> 00:58:54.280
I want to move forward.

00:58:54.280 --> 00:58:57.060
I know the older stuff is good and we're not changing it.

00:58:57.060 --> 00:59:01.360
Like, how do you sort of evolve this developer workflow sort of history?

00:59:01.360 --> 00:59:02.900
What's your workflow there?

00:59:02.900 --> 00:59:07.960
I rely very heavily on the Git comparison logic.

00:59:07.960 --> 00:59:21.420
So I should mention I do not code very much anymore because I'm now, I'm the co-founder of Toolchain, which is a company that actually provides SaaS and support and services around builds, Python and otherwise.

00:59:21.420 --> 00:59:25.840
And obviously that's where a lot of the pants expertise comes from.

00:59:25.840 --> 00:59:30.640
So we provide things like remote caching, remote execution as a service.

00:59:31.220 --> 00:59:33.260
So I don't code that much anymore.

00:59:33.260 --> 00:59:39.740
But, you know, occasionally when I do, I rely very heavily on the Git diff functionality.

00:59:39.740 --> 00:59:48.160
So my command lines are just basically, and one thing pants has is macros where you can create these, sorry, macros is something else.

00:59:48.220 --> 00:59:53.280
What I was actually referring to, but I can run like pants green.

00:59:53.280 --> 00:59:58.340
I can't really say, but I'm going to use my pants green.

00:59:58.340 --> 01:00:04.400
I can't really say, but I'm going to use my pants.

01:00:04.400 --> 01:00:05.400
I'm going to use my pants.

01:00:05.400 --> 01:00:06.400
I'm going to use my pants.

01:00:06.400 --> 01:00:07.400
I'm going to use my pants.

01:00:07.400 --> 01:00:08.400
I'm going to use my pants.

01:00:08.400 --> 01:00:09.400
I'm going to use my pants.

01:00:09.400 --> 01:00:10.400
I'm going to use my pants.

01:00:10.400 --> 01:00:11.400
I'm going to use my pants.

01:00:11.400 --> 01:00:12.400
I'm going to use my pants.

01:00:12.400 --> 01:00:12.400
I'm going to use my pants.

01:00:12.400 --> 01:00:12.400
I'm going to use my pants.

01:00:12.400 --> 01:00:13.400
I'm going to use my pants.

01:00:13.400 --> 01:00:14.400
I'm going to use my pants.

01:00:14.400 --> 01:00:15.400
I'm going to use my pants.

01:00:15.400 --> 01:00:16.400
I'm going to use my pants.

01:00:16.400 --> 01:00:17.400
I'm going to use my pants.

01:00:17.400 --> 01:00:18.400
I'm going to use my pants.

01:00:18.400 --> 01:00:19.400
I'm going to use my pants.

01:00:19.400 --> 01:00:20.400
I'm going to use my pants.

01:00:20.400 --> 01:00:21.400
I'm going to use my pants.

01:00:21.400 --> 01:00:24.400
And what you can actually do is run this in a loop.

01:00:24.400 --> 01:00:27.400
So you can have pants just sort of watch for file system.

01:00:27.400 --> 01:00:32.400
It watches your file system for changes and automatically rerun that logic every time you save.

01:00:32.400 --> 01:00:39.400
So often by the time I tab into my terminal, those checks have already run or are at least running.

01:00:39.400 --> 01:00:40.400
Yeah.

01:00:40.400 --> 01:00:41.400
Okay.

01:00:41.400 --> 01:00:42.400
That's my workflow.

01:00:42.400 --> 01:00:45.400
This command alias is a cool idea as well.

01:00:45.400 --> 01:00:46.400
I'm sure people will dig that.

01:00:46.400 --> 01:00:47.400
All right.

01:00:47.400 --> 01:00:48.400
Well, congratulations on Toolchain.

01:00:48.400 --> 01:00:49.400
Thank you.

01:00:49.400 --> 01:00:54.400
It seems like a cool thing to be working on and clearly builds on a ton of work you all have been doing.

01:00:54.400 --> 01:00:55.400
Thank you.

01:00:55.400 --> 01:00:56.400
Yeah.

01:00:56.400 --> 01:01:06.400
We basically feel both on the open source side and on the company side that you should not have to work at Google or Microsoft or Facebook to have a really fast, stable, powerful build experience.

01:01:06.400 --> 01:01:11.400
You should have that when you're a 20 person company and when you're a 200 person company and when you're a 2,000 person company.

01:01:11.400 --> 01:01:14.400
You should not have to wait to be a 100,000 person company to get that.

01:01:14.400 --> 01:01:15.400
Yeah.

01:01:15.400 --> 01:01:17.400
You should be somebody whose job it is to set up CI.

01:01:17.400 --> 01:01:20.400
I mean, their whole job, not just something they do as part of their job.

01:01:20.400 --> 01:01:22.400
Yeah, I guess that's the other side of things.

01:01:22.400 --> 01:01:23.400
I see about the developer workflow.

01:01:23.400 --> 01:01:24.400
What does it look like?

01:01:24.400 --> 01:01:30.400
It's like, let's suppose I have a GitHub and I'm using GitHub Actions as my CI.

01:01:30.400 --> 01:01:32.400
How do I get pants to work over there?

01:01:32.400 --> 01:01:36.400
So that's an interesting area that we are looking at more and more closely.

01:01:36.400 --> 01:01:40.400
And we will have some interesting announcements about that over the next few weeks.

01:01:40.400 --> 01:01:46.400
And just a heads up, this episode will probably, for people not watching the live stream, will be out probably in three or four weeks.

01:01:46.400 --> 01:01:50.400
So it might actually be real as they hear these words.

01:01:50.400 --> 01:01:51.400
We'll see.

01:01:51.400 --> 01:01:52.400
Maybe.

01:01:52.400 --> 01:01:59.760
But it is very easy to set up GitHub Actions or CircleCI or BuildKite or whatever you're using to run pants commands.

01:01:59.760 --> 01:02:09.780
And those pants commands in turn take away a lot of the or handle a lot of the concurrency and caching concerns that normally you would have to really mess with.

01:02:09.780 --> 01:02:13.620
You'd have to really drill into your CI config in order to get.

01:02:13.620 --> 01:02:21.780
So it essentially makes it much, much, much easier to configure CI because the complexity of, well, how do I get caching?

01:02:21.780 --> 01:02:23.580
How do I get concurrency?

01:02:23.580 --> 01:02:24.980
How do I speed things up?

01:02:24.980 --> 01:02:37.580
Is handled automatically by pants instead of you manually having to write tons of YAML or whatever your CI providers config is in order to get that concurrency.

01:02:37.580 --> 01:02:45.040
Here, there's a lot of heavy lifting going on where the system itself is analyzing your code and saying, oh, here are opportunities for concurrency.

01:02:45.040 --> 01:02:46.420
Here are opportunities for caching.

01:02:46.420 --> 01:02:56.760
Whereas today, with CI of all kinds, CI workflows of all kinds, either you do that yourself or you vary manually or you don't get it.

01:02:56.760 --> 01:02:57.060
Interesting.

01:02:57.060 --> 01:03:01.440
And maybe as part of the caching, you just say, like you described for the developer workflow, right?

01:03:01.440 --> 01:03:06.520
Everything other than, you know, compare that against main and now run it on that diff.

01:03:06.520 --> 01:03:06.980
Exactly.

01:03:07.240 --> 01:03:10.220
And CI is basically, you set up CI to call pants.

01:03:10.220 --> 01:03:11.340
Pants does its magic.

01:03:11.340 --> 01:03:11.760
Correct.

01:03:11.760 --> 01:03:12.240
Answers come out.

01:03:12.240 --> 01:03:21.200
So you don't have to write tons of a CI config because a lot of, so much of the reason you would have to do that is now handled by pants itself.

01:03:21.200 --> 01:03:21.560
Yeah.

01:03:21.560 --> 01:03:22.280
Awesome.

01:03:22.280 --> 01:03:23.100
All right.

01:03:23.160 --> 01:03:28.220
Well, very cool project and definitely something to be checking out.

01:03:28.220 --> 01:03:31.480
Now, before you get out of there, out of here, but final two questions.

01:03:31.480 --> 01:03:35.840
If you're going to write some code, even if you do a little bit less these days, what editor are you using?

01:03:35.840 --> 01:03:36.700
I use PyCharm.

01:03:36.700 --> 01:03:37.900
Yeah.

01:03:37.900 --> 01:03:47.820
Actually, technically I use IntelliJ with the PyCharm plugin because of just habit of, I used to write JVM code and I never lost the habit, but effectively PyCharm.

01:03:47.820 --> 01:03:48.140
Yeah.

01:03:48.140 --> 01:03:48.600
Right on.

01:03:48.600 --> 01:03:48.780
Cool.

01:03:48.780 --> 01:03:51.060
And then notable PyPI package.

01:03:51.060 --> 01:03:52.060
I really like click.

01:03:52.060 --> 01:03:54.120
We don't use it for various reasons.

01:03:54.120 --> 01:04:02.900
We need like a lot of control over the CLI, but I really like click for just cobbling together cool tools that have really good CLI interfaces.

01:04:02.900 --> 01:04:03.280
Excellent.

01:04:03.280 --> 01:04:05.740
And let me hijack the end here just for a moment.

01:04:05.740 --> 01:04:09.360
Maybe I should have asked you before to install pants.

01:04:09.360 --> 01:04:11.100
It's not pip install pants, is it?

01:04:11.100 --> 01:04:11.540
Nope.

01:04:11.540 --> 01:04:17.740
It's, so if you go to our website, pantsbuild.org, there's very simple steps for walking through it.

01:04:17.740 --> 01:04:25.060
But essentially there's a wrapper script that does things like install pants for you in a virtual env and keep it up to date.

01:04:25.060 --> 01:04:31.440
So you don't have to worry about where is this virtual env, how to, which version of pants is in it.

01:04:31.720 --> 01:04:34.260
It will look at the version that's in your pants config file.

01:04:34.260 --> 01:04:36.880
There's a pants.toml file that contains a bunch of pants config.

01:04:36.880 --> 01:04:40.680
One of them is which version of pants is this repo supposed to be using?

01:04:40.680 --> 01:04:43.180
And the script will make sure that is the version being used.

01:04:43.180 --> 01:04:43.460
Yeah.

01:04:43.460 --> 01:04:45.000
So you don't pip install it.

01:04:45.000 --> 01:04:50.820
You run this script and it does a bunch of magic on top of the vanilla virtual env experience.

01:04:50.820 --> 01:04:51.360
Fantastic.

01:04:51.360 --> 01:04:51.900
Okay.

01:04:52.240 --> 01:04:52.400
Yeah.

01:04:52.400 --> 01:04:57.160
Just pantsbuild.org slash docs slash installation and off you go.

01:04:57.160 --> 01:04:57.700
All right.

01:04:57.700 --> 01:04:59.200
Thank you so much for being here.

01:04:59.200 --> 01:05:00.140
Final call to action.

01:05:00.140 --> 01:05:01.380
People want to get started with pants.

01:05:01.380 --> 01:05:01.820
What do they do?

01:05:01.820 --> 01:05:06.480
So pantsbuild.org and probably one of the best resources is our Slack channel.

01:05:06.480 --> 01:05:11.400
So if you go to pantsbuild.org and click on community on that community link at the top,

01:05:11.400 --> 01:05:14.580
it'll take you straight into like how to come chat with us on Slack.

01:05:14.820 --> 01:05:20.720
So obviously you're going to try and get started without that, but it's, we have a very friendly,

01:05:20.720 --> 01:05:26.520
helpful community that firmly believes that there are no bad questions, only bad documentation.

01:05:26.520 --> 01:05:32.880
And so Slack is a great place to kind of sample the community, come chat with us, tell us about

01:05:32.880 --> 01:05:35.780
your needs, tell us about how pants can meet them or how it can't meet them.

01:05:35.780 --> 01:05:37.120
It's open source.

01:05:37.120 --> 01:05:41.660
And we have a lot of contributors from all sorts of companies and all sorts of organizations

01:05:41.660 --> 01:05:47.560
and all sorts of teams who started that way and got really enamored with what pants can

01:05:47.560 --> 01:05:53.180
do and got really involved both in improving the developer experience at their organizations

01:05:53.180 --> 01:05:55.060
and also in improving pants itself.

01:05:55.060 --> 01:05:58.400
So we really, best call to action is come say hi.

01:05:58.400 --> 01:06:01.800
Congrats on cool project and thanks for coming and sharing it with us.

01:06:01.800 --> 01:06:02.200
Thank you.

01:06:02.200 --> 01:06:03.140
It was my pleasure.

01:06:03.140 --> 01:06:03.540
You bet.

01:06:03.540 --> 01:06:03.800
Bye.

01:06:03.800 --> 01:06:07.640
This has been another episode of Talk Python To Me.

01:06:07.640 --> 01:06:09.460
Thank you to our sponsors.

01:06:09.460 --> 01:06:11.060
Be sure to check out what they're offering.

01:06:11.060 --> 01:06:12.480
It really helps support the show.

01:06:12.480 --> 01:06:14.540
Listen to the Local Maximum podcast.

01:06:14.540 --> 01:06:20.540
Learn about topics as diverse as the philosophy of probability and Elon Musk's next move.

01:06:20.540 --> 01:06:23.900
Just search for Local Maximum in your favorite podcast player.

01:06:23.900 --> 01:06:26.340
Starting a business is hard.

01:06:26.340 --> 01:06:32.440
Microsoft for Startups, Founders Hub provides all founders at any stage with free resources

01:06:32.440 --> 01:06:34.960
and connections to solve startup challenges.

01:06:34.960 --> 01:06:39.480
Apply for free today at talkpython.fm/founders hub.

01:06:39.740 --> 01:06:41.120
Want to level up your Python?

01:06:41.120 --> 01:06:45.140
We have one of the largest catalogs of Python video courses over at Talk Python.

01:06:45.140 --> 01:06:50.320
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:06:50.320 --> 01:06:52.980
And best of all, there's not a subscription in sight.

01:06:52.980 --> 01:06:55.900
Check it out for yourself at training.talkpython.fm.

01:06:56.020 --> 01:06:57.800
Be sure to subscribe to the show.

01:06:57.800 --> 01:07:00.580
Open your favorite podcast app and search for Python.

01:07:00.580 --> 01:07:01.900
We should be right at the top.

01:07:01.900 --> 01:07:07.060
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:07:07.060 --> 01:07:11.260
and the direct RSS feed at /rss on talkpython.fm.

01:07:12.080 --> 01:07:14.680
We're live streaming most of our recordings these days.

01:07:14.680 --> 01:07:18.100
If you want to be part of the show and have your comments featured on the air,

01:07:18.100 --> 01:07:22.520
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:07:22.980 --> 01:07:24.360
This is your host, Michael Kennedy.

01:07:24.360 --> 01:07:25.660
Thanks so much for listening.

01:07:25.660 --> 01:07:26.820
I really appreciate it.

01:07:26.820 --> 01:07:28.740
Now get out there and write some Python code.

01:07:28.740 --> 01:07:28.800
Thank you.

01:07:28.800 --> 01:07:28.800
Thank you.

01:07:28.800 --> 01:07:49.620
Thank you.

