00:00:00 If you're a Django developer, I'm sure you've heard so many people raving about FastAPI and Pydantic.

00:00:05 But you really love Django, right? And you don't want to switch?

00:00:08 Well, then you might want to give Django Ninja a serious look.

00:00:11 Django Ninja is highly inspired by FastAPI, but also deeply integrated into Django itself.

00:00:17 We have Vitaliy Kucheryaviy, the creator of Django Ninja, on the show to tell us all about it.

00:00:22 This is Talk Python to Me, episode 490, recorded December 10th, 2024.

00:00:27 Are you ready for your host?

00:00:30 You're listening to Michael Kennedy on Talk Python to Me.

00:00:34 Live from Portland, Oregon, and this segment was made with Python.

00:00:38 Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:44 This is your host, Michael Kennedy.

00:00:46 Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython,

00:00:51 both accounts over at fosstodon.org.

00:00:54 And keep up with the show and listen to over nine years of episodes at talkpython.fm.

00:00:59 If you want to be part of our live episodes, you can find the live streams over on YouTube.

00:01:04 Subscribe to our YouTube channel over at talkpython.fm/youtube and get notified about upcoming

00:01:09 shows.

00:01:10 This episode is brought to you by Sentry.

00:01:12 Don't let those errors go unnoticed.

00:01:14 Use Sentry like we do here at Talk Python.

00:01:15 Sign up at talkpython.fm/sentry.

00:01:19 And this episode is brought to you by Bluehost.

00:01:22 Do you need a website fast?

00:01:23 Get Bluehost.

00:01:24 Their AI builds your WordPress site in minutes, and their built-in tools optimize your growth.

00:01:29 Don't wait.

00:01:30 Visit talkpython.fm/bluehost to get started.

00:01:34 Hey, everyone.

00:01:35 Before we jump into the interview, I want to tell you about a massive article I wrote I

00:01:39 think you'll find interesting.

00:01:40 I did data science things and dug into all the episodes this year and pulled out the top

00:01:44 five Talk Python To Me episodes of 2024.

00:01:48 Then I did a deep dive into the content, what was covered, what was important, even learned

00:01:53 a few things that I missed the first time around.

00:01:55 Just visit talkpython.fm/blog, and the article is right at the top of the page.

00:02:00 I'll put the full link in the podcast show notes.

00:02:02 Also, if you haven't discovered it yet, Talk Python has a blog.

00:02:06 While you're there, please subscribe to the RSS feed to get all the articles and announcements.

00:02:10 Thanks for listening.

00:02:11 Happy holidays, everyone.

00:02:14 Vitaly, welcome to Talk Python To Me.

00:02:15 Yep.

00:02:16 Hello, hello.

00:02:16 Yeah, thank you for having me.

00:02:17 This is going to be the first time I've ever had a ninja on the show.

00:02:20 Okay.

00:02:21 Okay.

00:02:22 That will be fun.

00:02:24 No, Django Ninja.

00:02:24 Django Ninja.

00:02:25 It's going to be a lot of fun, isn't it?

00:02:26 Yep.

00:02:27 Yep.

00:02:27 That's right.

00:02:27 Yeah.

00:02:28 So welcome to the show.

00:02:29 We're going to talk about Django Ninja, which is, at least in my mind, you tell me if I'm

00:02:33 seeing this correctly as we get into it.

00:02:36 But in my mind, I see Django Ninja as Django's FastAPI.

00:02:40 That's exactly like the most asked questions I ever had.

00:02:42 Like, why not just FastAPI?

00:02:44 So I hope I will answer during this podcast why it is, why it exists.

00:02:48 And we will all work with this question.

00:02:50 Ever since it first came out, I was, I saw him.

00:02:53 That's cool.

00:02:54 That is a cool idea.

00:02:55 And I'm pretty excited to talk to you about it.

00:02:57 It's going to be great.

00:02:58 Before we get into all that, though, quick introduction.

00:03:00 Who are you?

00:03:01 What do you do?

00:03:02 How do you get into this Python world?

00:03:04 Yeah.

00:03:04 So my name is Vitaliy Kucheryaviy.

00:03:06 Yeah.

00:03:07 Good luck.

00:03:07 Good luck repeating that last name for everyone.

00:03:10 But yeah, that's my name.

00:03:12 So I'm from Ukraine.

00:03:13 I'm currently in Ukraine.

00:03:15 And I'm in tech for like, I don't know, like more than 20 years probably.

00:03:19 And yeah, I worked with, well, at the beginning of my career, I worked with all sorts of languages,

00:03:24 technologies, like everything, like C++, .NET, Java, PHP, like everything.

00:03:29 And yeah, I guess like one time I tried Python.

00:03:31 And yeah, since then, this is like my go-to tool.

00:03:35 And yeah, I just cannot switch to anything else.

00:03:37 Yeah.

00:03:38 That's how I got there.

00:03:40 And yeah, like currently I work for a company, Modicos Prime, where we do AI for big pharma companies.

00:03:50 We help them, you know, innovate in this area.

00:03:52 And yeah, there I also use Django Ninja.

00:03:55 And yeah, basically eating my own dog food.

00:03:58 So that's a good sign.

00:03:59 That's a very good sign.

00:04:00 And it's so excellent to be able to work on these projects, but also use them with the team.

00:04:07 And in reality, right, on a real day-to-day work, because I think that polishes a lot of the edges that might otherwise exist.

00:04:14 Basically, I'm watching like how other people use like in a team.

00:04:17 And also like I communicate with a bunch of companies who also move to Django Ninja and like are listening to what kind of struggles they have and which kind of problems they jump in.

00:04:28 So yeah, that kind of helps solve it easier and somewhat more maintainable way and easier to integrate.

00:04:36 So basically, that's my end goal.

00:04:38 Yeah, that's awesome.

00:04:39 There's a really interesting stat from the Python, the PSF and JetBrains survey.

00:04:46 I'll put it on the screen for people watching.

00:04:48 I think at least when I personally thought about sort of how popular is Django, I kind of always had it tied with Flask and close with FastAPI, right?

00:04:58 They're kind of, if you look at the survey results, they're kind of similar.

00:05:02 But what's interesting is if you actually look at what web developers use, Django is by far the most popular one, like way more popular than Flask.

00:05:10 50% more or something like that.

00:05:12 Not quite.

00:05:13 I think it's pretty important to have a library like this around to make Django first class citizen in this sort of data exchange typed Pydantic world, right?

00:05:24 This is pretty much described it.

00:05:25 I think like, yeah, before this survey, like there was like Flask and Django, like, you know, there was like a tie.

00:05:32 But now, like basically, I think FastAPI is eating a lot of this pie from Flask and Django.

00:05:38 And yeah, you see now it kind of gets into like, you know, three main players.

00:05:43 And yeah, like from what I experienced is I think it's actually like maybe developers are actually splitting into like two main groups.

00:05:51 Like ones who like to use some kind of tool that have everything like Django.

00:05:55 Yeah, like it can be in the Java world.

00:05:58 It can be like Spring framework in Python and Django.

00:06:01 While others like to, you know, start from scratch and like combine all little pieces together.

00:06:06 Yeah, like take their own RM, take their own configuration, take their own, you know, file system, like everything and make it all their own.

00:06:13 And this is where the market for Flask and FastAPI.

00:06:17 While for other folks, it's like more like, yeah, they just want something ready.

00:06:21 Like whatever issues it have, let's take it.

00:06:24 It's just, you know, more standardized way.

00:06:26 It kind of seems more maintainable for some people while others prefers more like, you know, replacing components, switching frameworks and do like everything custom.

00:06:36 So like my vision of Django is like it should be a little bit glued to two of these worlds.

00:06:42 Because what I noticed is like when people use Django Ninja, it's mainly like all the applications is actually like it's API.

00:06:51 There is no form.

00:06:52 There is no Django admin.

00:06:54 There is no like, you know, custom views.

00:06:56 You're like, so they basically tie to API and doing just the rest API.

00:07:00 And I think, yeah, this is basically when it shines and when you can take like an approach like for FastAPI Flask.

00:07:08 But under the hood, it will have all the batteries that comes with Django.

00:07:11 So I think that's how it's, why it's actually like picking up and why it works and why people use it.

00:07:17 I know there are a lot of people out there that have just some kind of JavaScript front end and a bunch of APIs.

00:07:22 But there's also a lot of websites that are more server side based, more holistic, kind of like Django does.

00:07:29 And having something like Django Ninja to sort of add on the API functionality when you've already got the models, you've already got everything set up.

00:07:37 That's a really cool aspect of it.

00:07:39 It's more interesting like in history, like why actually Django Ninja appear in Havio.

00:07:44 Yeah, yeah.

00:07:45 Back in the day.

00:07:45 So yeah, when Sebastian released FastAPI, I was like really like mind blown.

00:07:50 Like, this is like, this is all I wanted.

00:07:53 Like you just write a couple of types to your function and you got the UI for, you know, for just UI for API, documentation for API, validation and everything like in one package.

00:08:04 So yeah, like for lazy people like me, that was like, you know, like, yes, literally my mind blowing.

00:08:10 Yeah.

00:08:11 So basically I tried it out, kind of worked for me for like, you know, one project.

00:08:15 And that year, like for me, the case was like, I had to integrate it with Django.

00:08:19 So I had existing application with some database and stuff.

00:08:22 And I just needed like simple little API to add there.

00:08:26 So I decided, okay, I'll just take FastAPI for that.

00:08:30 So I took it, it worked, but the problem is like to FastAPI and the hood uses Starlet.

00:08:36 And there's like a little bit different approaches to like, like local storage and threads when you're basically accessing the database.

00:08:44 It's not like without like special hooks and crooks to like access like database within Starlette context.

00:08:51 And you can kind of lose this connection.

00:08:53 And then you get just, you know, error that you cannot really debug or do something with it.

00:08:57 So it was like, like for me, it was like, oh, come on.

00:09:01 Like it was so, so perfect, but it just breaks in the middle of something.

00:09:05 And yeah, but I tried like Django community.

00:09:08 They said, yeah, it's not, it's not, it's not something wrong.

00:09:10 FastAPI community.

00:09:11 They said, yeah, it's, it's not something that we do as well.

00:09:14 It's a Django problem.

00:09:15 It's a Django problem.

00:09:16 It's a fastAPI problem.

00:09:18 Yeah.

00:09:19 So I, and then, then I just took a look inside and yeah, basically I said, okay, just this, but literally it's really simple.

00:09:26 Yeah.

00:09:27 You just take input from HTTP request, you apply by the intake models validation and yeah, and that's it.

00:09:34 And it works.

00:09:34 So like for me, the first prototype was like done in, in a weekend and it was already like working.

00:09:39 And then like rest of the time when I decided, okay, I'll try to make it a project, but yeah, to make it something that will pick up, I need to like, yeah, first make like, you know, 100% coverage and the documentation.

00:09:51 So that part is actually took me like a good amount of like, almost like, you know, half a month or months of work until like, it's like presentable.

00:09:59 So yeah, like the, yeah, the concept is like pretty, pretty easy, but the implementation and, you know, edge cases were like really the hardest part, but yeah, I just started, okay, I'll do it.

00:10:09 And yeah, that's, that's how, how it born.

00:10:11 And I guess the next part is like actually why it exists is like, yeah, so in Pydantic, there is model word is reserved for like, you know, any kind of validation.

00:10:20 Yeah.

00:10:21 So Pydantic uses word model for validation, but in Django world model means like tables, yeah, database tables.

00:10:29 So you cannot just bring Pydantic models.

00:10:31 It's the ORM, yeah.

00:10:31 Yeah.

00:10:32 And because people will be confused when you, okay, you speak about model and then you kind of need to think, okay, is it database or is schema?

00:10:39 So like for me, the main goal was to introduce class called schema, which is like a Pydantic model under the hood.

00:10:46 And then it should like hide as much as possible the word model.

00:10:50 So, and like to make it like as, as much as possible compatible with, with Django and just trying to hide the word model under the hood as much as possible.

00:11:01 And it kind of like, I'm lucky that schema kind of worked and yeah, because schema is, is actually how, like how Swagger defined.

00:11:09 Like open, open API standard names it.

00:11:12 So it kind of fits there perfectly.

00:11:14 And, and yeah, that's kind of how it works.

00:11:17 And yeah, then, then I was sitting like, it was, what should be the name of the thing?

00:11:21 Like it was also the hardest part.

00:11:24 So yeah, but yeah, I first tried it and it did like a really good performance in terms of like, you know, CPU usage and high loads.

00:11:32 It was like really lightweight.

00:11:34 So way faster than Django Rest Framework (DRF).

00:11:36 So I thought, okay, she should be something fast.

00:11:38 Try it, you know, word here and there.

00:11:40 Okay.

00:11:41 And then, and it become ninja.

00:11:42 So that's how it's important.

00:11:45 The naming is perfect.

00:11:46 The naming is just perfect.

00:11:47 You and me both.

00:11:48 When I first saw FastAPI as well, I'm like, this is the way this is how it should be done.

00:11:54 And FastAPI is really interesting when it came on the scene and by way of being very similar.

00:12:00 So it was Django Ninja in that it, it was one of the first frameworks to say them and along with Pydantic say Python types can be something we use, not just something we run through a linter to make a better experience and the async aspect of it.

00:12:16 So, and I saw that like, yeah, this is the way you should build APIs.

00:12:18 And so when I saw Django Ninja, I'm like, of course Django should have this way.

00:12:23 This is the way.

00:12:23 The whole concept is perfect.

00:12:25 Yeah.

00:12:25 We just, you make a type hint and then it does validation for you.

00:12:29 The linting, it does the, you know, editor auto-completion, like everything in one package.

00:12:34 And yeah, like for, if you're lazy, you just thought I did one type in.

00:12:39 Like before that, I was like pretty skeptical, skeptical about typing.

00:12:42 Like, yeah, you just blather your code.

00:12:45 Doesn't, you know, like if you just lint in it with my pie, it's like really painful to make like fully tight project.

00:12:52 It's like, oh my God, it's like, it's like an X impossible to like satisfy my pie in every like, like, so Django Ninja is like my pie compatible.

00:13:02 But there is lots of stuff is just tight typing or it's just some stuff is just not possible or it's like too, too blathered with, with code.

00:13:10 So you have like, it's really hard to read when you fully type your code.

00:13:14 So even in my day, day to day projects, like what I basically try to do, I only do type annotation for arguments.

00:13:22 The rest is actually like editors do perfectly.

00:13:25 So if you return some object, the editor know, okay, this is like this type or that type.

00:13:30 And you don't have to like annotate what exactly does it return.

00:13:34 So a hundred percent.

00:13:35 That's exactly the way that I do it as well.

00:13:37 I know there's some projects whose goal is to basically make Python statically typed like Instagram, for example, to try to get rid of bugs and huge programs.

00:13:45 But for a lot of people, it sounds like you definitely for me, it's like I want the editor to work really well and know what it is that I can do here.

00:13:52 And if I put a type here and there, like on a return value of a function, all of a sudden it gets much easier to work with.

00:13:58 Yum.

00:13:58 This portion of Talk Python To Me is brought to you by Sentry.

00:14:03 Code breaks.

00:14:04 It's a fact of life.

00:14:05 With Sentry, you can fix it faster.

00:14:07 As I've told you all before, we use Sentry on many of our apps and APIs here at Talk Python.

00:14:13 I recently used Sentry to help me track down one of the weirdest bugs I've run into in a long time.

00:14:19 Here's what happened.

00:14:20 When signing up for our mailing list, it would crash under a non-common execution pass, like situations where someone was already subscribed or entered an invalid email address or something like this.

00:14:31 The bizarre part was that our logging of that unusual condition itself was crashing.

00:14:37 How is it possible for our log to crash?

00:14:40 It's basically a glorified print statement.

00:14:43 Well, Sentry to the rescue.

00:14:45 I'm looking at the crash report right now, and I see way more information than you'd expect to find in any log statement.

00:14:51 And because it's production, debuggers are out of the question.

00:14:54 I see the traceback, of course, but also the browser version, client OS, server OS, server OS version, whether it's production or Q&A, the email and name of the person signing up.

00:15:06 That's the person who actually experienced the crash.

00:15:08 Dictionaries of data on the call stack and so much more.

00:15:11 What was the problem?

00:15:12 I initialized the logger with the string info for the level rather than the enumeration dot info, which was an integer based enum.

00:15:22 So the logging statement would crash, saying that I could not use less than or equal to between strings and ints.

00:15:28 Crazy town.

00:15:30 But with Sentry, I captured it, fixed it, and I even helped the user who experienced that crash.

00:15:36 Don't fly blind.

00:15:37 Fix code faster with Sentry.

00:15:39 Create your Sentry account now at talkpython.fm/sentry.

00:15:43 And if you sign up with the code TALKPYTHON, all capital, no spaces, it's good for two free months of Sentry's business plan, which will give you up to 20 times as many monthly events as well as other features.

00:15:55 All right, well, let's dive into Django Ninja.

00:15:58 I guess people got a pretty good sense that it's like FastAPI for Django.

00:16:04 If somebody asks you, what is Django Ninja?

00:16:06 How do you describe it?

00:16:06 What do you tell them?

00:16:07 So basically like extra battery for making.

00:16:10 So Django is all about batteries.

00:16:12 So it's that, I don't know, like it's more like, not a battery, but more like, you know, the energy pack.

00:16:18 If you need API and it's, you need to be, it's like pretty standard way.

00:16:24 Like it is currently, I think like open API standard is kind of one because before there was like here and there, like the different standards.

00:16:31 But yeah, like I think they kind of now become the defector and everything supports it.

00:16:36 Like, yeah, like the big players, like open AI supports open API.

00:16:40 So that kind of makes it easier to integrate with all sorts of tools.

00:16:44 And yeah, there's all different UIs.

00:16:47 Yeah.

00:16:47 Like how you can present your API.

00:16:49 So that kind of a big win.

00:16:52 And yeah, like then it's like deep Django integration because yeah, like in most of the cases you define your, like if you, let's say you want to return some stuff.

00:17:01 Yeah.

00:17:01 Like the list of some objects from your database.

00:17:03 Yeah.

00:17:04 You simply just return query set and then it's validated and described correctly in your documentation.

00:17:10 So yeah, like, I guess like this laziness in terms of that you don't have to write lots of stuff, make it like really perfect in terms of like, you know, day-to-day code.

00:17:20 Yeah.

00:17:20 Like, so you, you just, you, you just describe your, okay, this is a list of, you know, hero objects.

00:17:26 And then you return like queries and that's it.

00:17:28 So you don't have to very worry about like converting the data, serialization, deserialization.

00:17:35 It's like in just three, three lines of code, you usually be able to like, or some kind of filter and input and output some results from the database.

00:17:44 And this is, you know, 90% of business logic is usually like, okay, give me the JSON and return to JSON.

00:17:51 And then you just need some kind of easy glue in between.

00:17:55 I got to make one or two database queries and then here are the database objects, kind of.

00:17:59 One of the things when you're talking about building this, that seemed to me to be maybe the trickiest part of it would be the fact that you have to integrate it with the Django ORM, right?

00:18:10 When Sebastian built FastAPI, he could just go, well, whatever Pydantic does, I'm just going to do that.

00:18:15 And here we go.

00:18:16 Not to downplay the effort he's put into it.

00:18:18 I know it's a lot, but he didn't also have to say, and let's make that compatible with Django models, Django ORM objects, right?

00:18:27 So this integration that you put between those, so they're pretty seamless.

00:18:29 That's really cool.

00:18:30 Yeah.

00:18:30 This is basically like whenever I tried it, then it is something that you definitely need to like.

00:18:36 And it's not only like, because Django comes with like way, way, way more stuff.

00:18:41 And yeah, like because what Django Ninja comes included is like the caching.

00:18:47 Yeah.

00:18:47 That basically fully relies on Django, like a little bit of throttling, filtering, and you know, the fields integration.

00:18:56 Like, so you define some kind of columns on your database and that's automatically converted to your schema types.

00:19:02 It's like, you know, so you don't have to like repeat your work two times.

00:19:07 You're like define, you know, first database tables and then schema tables.

00:19:11 So I think this is like, again, kind of lazy approach, but it works and it's perfect.

00:19:15 This is really, really awesome.

00:19:16 I don't want to make this, I don't want to put you guys, your project in sort of competing against another project.

00:19:24 But for people who are using the Django REST framework, you know, why should they look at or what benefits do they get from Django Ninja?

00:19:30 It's more like, you know, a stealth player that, you know, takes majority.

00:19:35 Like, I think Django Ninja is still like, you know, was it like 5% or something like that on the latest polls?

00:19:41 But yeah, so it's, it's, it's really big industry and Django like REST framework has already like lots of plugins or like tools or like, you know, community that you can rely on.

00:19:52 But yeah, again, like the, the, basically, I think the problem that is solved with like this Pydantic validation and serialization is like, yeah, you simply rely on like latest standards.

00:20:04 Yeah, like, so if you never use like type annotation, this is actually first, the good way to try it out and see the benefits.

00:20:12 Yeah.

00:20:13 Like, so you don't go like, you know, full 100% typed code, but you just lightly type it when you just need it for API.

00:20:21 And then you already can see, okay, what's, what's the benefits and how, how you actually can perform better in terms of like making less mistakes, like, you know, typos or like type conversions.

00:20:34 So like the main benefit is like, it was just, so you define the type input, like from some very complex object that your API inputs.

00:20:43 And then you have like runtime guarantee that whatever type you wrote there, you can just rely it.

00:20:49 You have guarantee that if you define it as an integer, then there will be like a string or I don't know, like a flaw there.

00:20:55 So you, you, you have this guarantee and then you, it kind of brings away from you this validation hassle.

00:21:02 So you can kind of be more relaxed in terms of, okay, yeah, my data is valid and I can work with those types without worrying about validation or, or serialization of the, of the, of those fields.

00:21:15 As you were describing that, I was thinking, think of all the value that Pydantic adds to working with JSON data.

00:21:21 You get that for your API at the boundary, right?

00:21:23 With no effort.

00:21:24 That's pretty amazing.

00:21:25 Yeah.

00:21:25 Pydantic is just, it's so good.

00:21:26 What about performance?

00:21:28 I know you have a, a graph, which I love it.

00:21:32 I never actually like remeasure it again, but that's how it worked at the beginning.

00:21:37 So I don't think like back in a day when this was introduced, I'm not sure if currently a FastAPI or I mean, Django REST framework have any like async support because back then it, it was not.

00:21:49 So you can, you can, you can, you could immediately have a boost on your performance.

00:21:53 If you just, you know, free from database.

00:21:55 So you can just return your, your query set as a sync.

00:21:58 And then you rely on, you know, event loop to pull those data and return it back to the clients.

00:22:03 And it was like really for, for some project that I've communicated with like other companies and they, they like, they saw like a performance, something like that.

00:22:13 Or like their CPU usage was like a, you know, load average about like 50% drop to like 5%.

00:22:20 Yeah.

00:22:20 So that was like really a immediate, immediate boost up, but it only works for you.

00:22:26 If you're like, yeah, for, for like very simple case when you just need to parse data, insert database, return, return the result.

00:22:32 So this is like where it's like performance just, you know, it can be like five to 10 times you can get this improvement.

00:22:39 Yeah.

00:22:39 And people want to see the graph.

00:22:41 They can just visit django-ninja.dev and it's right there on the homepage.

00:22:45 But yeah, if you start doing like you start, you know, doing some kind of square roots of some numbers, yeah, you will not get this performance.

00:22:52 You will have to, again, rely on number of processes or threads or stuff like that.

00:22:56 Did you do this analysis with Pydantic 1 or Pydantic 2?

00:22:59 This is Pydantic 1.

00:23:01 Yeah.

00:23:01 So I never actually measured like what is the performance.

00:23:04 So yeah, like, but again, it's like probably like you will see the difference with Pydantic 2 when you like really, so you're in, you have inputs of like really bulky JSON.

00:23:14 Like, you know, let's say you have like, you know, payload that is like one megabyte and you will, you will definitely see performance.

00:23:23 But yeah, it was just small, small inputs.

00:23:25 Yeah.

00:23:25 It will not be that dramatic.

00:23:27 I see.

00:23:28 So if it's just a small input, then Pydantic is not the main part of what you're doing.

00:23:33 But if it becomes large, then the parsing becomes a big part of it.

00:23:36 Yeah.

00:23:36 Yeah.

00:23:36 There is also like one of the features of Django Ninja.

00:23:39 So you can replace your, your parsers and serializers.

00:23:43 So you can say, okay, you know what?

00:23:45 Let's use or Json for inputting out.

00:23:47 And again, you can, you can get some extra performance just because you have those parsers are quicker.

00:23:52 They have their own quirks.

00:23:54 Maybe not some, something like not standard, but for the, for the most cases, it just, you

00:23:58 can increase your performance with just, you know, adding a few configuration lines.

00:24:03 Yeah.

00:24:03 Yeah.

00:24:04 Yeah.

00:24:04 That's really interesting.

00:24:05 If you know that whatever difference those other faster parsers might have, it doesn't apply to the data you're exchanging.

00:24:10 Just use them.

00:24:11 Right.

00:24:11 Yeah.

00:24:12 What about uv loop for the async side of things?

00:24:14 The thing is like, it's really like Django Ninja has nothing to do with it.

00:24:17 It's fully relies on, on Django itself under the hood.

00:24:21 So like, yeah, basically Django starts, is GI process, do some stuff on top, you know, and then gives you basically back to Django, a final context with request.

00:24:33 And then you, you work on it.

00:24:34 It's probably down to the production app server that use like G uv a corn or hyper corn or, or whatever you run it on.

00:24:43 Right.

00:24:43 Like that thing you just specify that runs on uv loop and then off it goes.

00:24:47 Yeah.

00:24:47 Yeah.

00:24:47 Yeah.

00:24:48 I'm pretty interested to see what would this graph would look like with Pydantic two, because that's the one that was rewritten in rust, which I had Samuel Colvin on to talk about a time or two.

00:24:56 That's, that's fun.

00:24:57 So let's see, let's talk through, give us a sense of what programming this looks like.

00:25:01 And, you know, just keep in mind that, you know, not everyone can see what we're talking about, but give us as much as you can, sort of a, a feel for how to write code in Django Ninja.

00:25:11 You import Ninja API from Ninja, and this is your like main kind of API instance.

00:25:16 And so you, you create this instance, like API, your Ninja API, and then using the decorators, it was just API.get.post.put, like whatever you, method you want.

00:25:28 You just decorate some functions and then inside your functions, you are, you know, you do your business logic.

00:25:34 But the cool part is that you can define input parameters, which are basically gathered from your request.

00:25:42 So if you do define a couple variables type in, they will, by default, they will come from like query parameters.

00:25:48 If you define like more complex object, it will come from like your body and it will be parsed from, from JSON.

00:25:55 And yeah, like you define those functions, you include it into your URL patterns.

00:25:59 That's, that's it.

00:26:00 You have your, your ready API.

00:26:02 You don't have to like do like, put it into installed apps or like configure any settings.

00:26:07 So yeah, like my goal is also to create as simple as possible, like integration.

00:26:11 So just in two, three lines, you're ready, you have already API.

00:26:16 And yeah, that's, that's basically like did the whole, the whole, the whole thing.

00:26:20 That's it, right?

00:26:21 There's not a whole lot to it.

00:26:22 There's also like for, I guess for, for the difference for folks who work with FastAPI.

00:26:27 The key difference is that Django- Ninja, Django-Ninja's operation, their function, the first argument is always request.

00:26:35 Because this is like historically what Django, what Django protocol is.

00:26:39 Yeah.

00:26:39 Like your, your first argument to your view function is request.

00:26:41 And yeah, they, they rely a lot of stuff in their request can have user, you know, extra information like middle layers can access, you know, some kind of attributes.

00:26:51 Okay.

00:26:51 So this is like kind of important.

00:26:53 And this is like also like the key, the key difference or requests is request is always there as a first argument.

00:26:58 And yeah, like there was a suggestion, so let's remove it.

00:27:02 But I think, yeah, we should keep it, we should keep it consistent with, with, with default Django view.

00:27:07 And yeah, like, I think that, that, that, that works perfectly.

00:27:09 I don't remove it.

00:27:10 I like it.

00:27:10 I think, I know FastAPI is optional to have the request or not have the request, which, which is not a bad choice.

00:27:17 I just not too long ago converted the talk Python website into court, which is async flask with the goal of converting the course of websites and a bunch of other things that I have going over as well.

00:27:30 And in that world, you know, you just have this thread local request object.

00:27:36 And that always just seems like breaking the rules to me.

00:27:38 It's like, you know, what if I want to run this, another thread, how do I capture it and send it?

00:27:42 I just like having the object just passed in is nice.

00:27:45 I think I like it.

00:27:46 I think it's a clean design.

00:27:47 Yeah, it's like clear or like more open.

00:27:50 Yeah.

00:27:50 So you can always know, okay, this is something about, about the HTTP request.

00:27:54 So it's always there.

00:27:54 A little easier for testing and reasoning about it.

00:27:56 It's not like, well, if I call a function, which calls a function, which needs the request, is it safe for it to just grab the thread local request?

00:28:03 Or, you know, like there's a lot of ambiguity in here.

00:28:06 It's just like, yeah, here's the request object and go with it.

00:28:08 So that I'm, I'm, I'm a fan.

00:28:10 I'm a fan of it.

00:28:11 Another, another thing that's really nice, and you hinted at this before, is that it has automatic documentation, very, very similar to FastAPI for what you write without you doing any work, right?

00:28:23 You just go to /API /docs, and you get this nice UI, right?

00:28:27 You don't have any hassle of creating some UIs.

00:28:30 You just, you just have it for free, right?

00:28:32 So you just go to /API/docs, and there you have it.

00:28:35 And you can already like, so by default, Django Ninja comes with two, like three doc and a swagger.

00:28:42 But there is technically like pretty easy to integrate any other tool that can work with, with open API specification.

00:28:50 And yeah, that's, that's the way you can like fine tune or like make it nicer, easier, or like, you know, do some kind of custom stuff with your documentation when you share it back to like your, your clients, your users.

00:29:02 This is a very Django like feature as well.

00:29:04 I mean, I know it first probably was seen in FastAPI as an automatic thing, but you know, Django, you just create your models and you get the admin section and you get all these other things around what you've created.

00:29:14 And this is sort of, Hey, you just get this documentation and this testing tool for exploring your API just by creating it.

00:29:21 Basically it was Django who first sort of, yeah, we just give you admin for free, just define a couple of classes in there.

00:29:27 And I think like, I think the Django REST framework was also like the first who like gave you the UI also for free.

00:29:34 So you just define your serializers, you create your classes stuff, and you have UI that you can test.

00:29:43 So I think like the UI testing is like one of the most kind of best debugging tool you can, you can have.

00:29:51 Yeah.

00:29:51 So you like basically like I use it like day to day.

00:29:56 They are like define your function.

00:29:57 I just try it out on three UI and that's it.

00:30:00 That's like very, very, very helpful.

00:30:02 You can turn it off.

00:30:02 Right?

00:30:03 Yeah, sure.

00:30:03 It's really nice for, if you're making a public API, it's nice to just have it.

00:30:07 But if you're making an API that is internal, but your website has to be public, you might not want to publish the API just to the world if it's not meant to be a public API, right?

00:30:17 There is an option to define your custom authentication for the docs.

00:30:21 You can define, okay, docs, doc outs or something like that.

00:30:24 You can say, okay, only like, you know, Django super users can access this documentation.

00:30:29 So it's also like a pretty common request or feature that people use.

00:30:33 And as well, you can, yeah.

00:30:35 So I guess one of the interesting part that, that also differs from FastAPI.

00:30:40 So you can create like, you know, as, as, as many as possible ninja API instances.

00:30:45 So you can have like slash public API/private/custom/, yeah, whatever, like version one, version two, like, and basically you can define multiple, multiple versions, reuse functions.

00:30:57 And then, you know, can continue your work while keeping the old, old, you know, version one, version two code or private public, stuff like that.

00:31:05 So that's, that's, that's also way that people use it and having problems configuring.

00:31:11 So that's what I see from issues.

00:31:15 This portion of talk Python to me is brought to you by Bluehost.

00:31:18 Got ideas, but no idea how to build a website?

00:31:22 Get Bluehost.

00:31:23 With their AI design tool, you can quickly generate a high quality, fast loading WordPress site instantly.

00:31:29 Once you've nailed the look, just hit enter and your site goes live.

00:31:33 It's really that simple.

00:31:34 And it doesn't matter whether you're a hobbyist, entrepreneur, or just starting your side hustle.

00:31:39 Bluehost has you covered with built-in marketing and e-commerce tools to help you grow and scale your website for the long haul.

00:31:46 Since you're listening to my show, you probably know Python, but sometimes it's better to focus on what you're creating rather than a custom built website and add another month till you launch your idea.

00:31:56 When you upgrade to Bluehost cloud, you get 100% uptime and 24 seven support to ensure your site stays online through heavy traffic.

00:32:05 Bluehost really makes building your dream website easier than ever.

00:32:08 So what's stopping you?

00:32:09 You've already got the vision.

00:32:10 Make it real.

00:32:11 Visit talkpython.fm/bluehost right now and get started today.

00:32:16 And thank you to Bluehost for supporting the show.

00:32:19 When I saw this feature, I thought, oh, this is fantastic.

00:32:24 I really, really love it.

00:32:25 So let me give people a sense of how this works.

00:32:27 You create an API instance, a little bit like Flask or FastAPI, and use it as a decorator, like at api.get.

00:32:34 And you give it the URL, right?

00:32:35 So what you're saying is I can create an API 1 and API 2, specify a version on it, which will be part of the specification, and then register both of those under different bases.

00:32:47 So like in the example in your docs, you have registering API slash V1 slash an API slash V2 slash.

00:32:54 And then you can have different implementations, but by just doing this little trick, you can have them both in production at the same time.

00:33:02 And I think that's pretty awesome.

00:33:03 Yeah.

00:33:03 And this is like actually like on practice.

00:33:05 I saw that a couple of times here when people like move to some newer version.

00:33:09 They just copy like entire API, I think, change a couple of methods, say, okay, this is version 2, and you're ready to go.

00:33:14 So they don't have to like rely on some kind of external routers to route between different versions.

00:33:21 So they can keep two versions in same code base and don't have any problems with it.

00:33:25 I think one, this sort of UI pattern or this URL pattern, I think you've got to have a little bit of foresight to have API slash V1 slash to start with, right?

00:33:36 But I mean, I guess you could always add slash V2 slash V3 afterwards.

00:33:43 But if people think ahead a little bit and put versioning in there explicitly, that would be nice.

00:33:49 Now, do you have, can you, if a function doesn't change across APIs, can you put, you know, API 1 decorator get and API 2 decorator get onto the same function?

00:33:59 Or do I have to kind of do some redirect, indirection?

00:34:02 That part is probably will not work.

00:34:04 And I think like, so probably someone next releases.

00:34:07 So inside API, you can also define a couple of routers.

00:34:11 Yeah.

00:34:11 So this is kind of, so you can split your application API into like different modules, which called routers.

00:34:17 And yeah, so basically the idea is that you can define, you know, one router with a couple of methods and then use it in version one and version two.

00:34:25 So that's the idea, which is actually, well, it's not ready yet, but this is something that is coming in next release because this is also like very, very requested feature.

00:34:34 So you don't have to even copy your version in code by just reusing stuff that is common and then just overrule the new methods or the new parameters that land it on new version.

00:34:46 Yeah, I really like it.

00:34:47 That's great.

00:34:48 Well, yeah, this is that this is an amazing feature.

00:34:50 When I first saw this, I thought, oh, yeah, this makes version in your API so simple.

00:34:54 And you even get documentation with it just because that's how documentation works, right?

00:34:59 Yep.

00:34:59 And you pointed out that you can have public and private APIs in this similar way.

00:35:04 And so you could have public APIs, maybe multiple versions of them, but also a separate private API that potentially exposes more things.

00:35:13 Right.

00:35:14 And as you said, you could even put authentication on top of it separately.

00:35:17 Right.

00:35:17 Yep.

00:35:18 I love it.

00:35:18 Let me go back to the homepage.

00:35:20 Let me ask you a question here.

00:35:21 So you said this is another thing that I think I'm a big fan of.

00:35:24 So in your first example, you talked about, oh, if you put parameters into your API and you give them types, they'll be parsed and validated and all that.

00:35:31 But like FastAPI, you can define a Pydantic model that is the type of the thing.

00:35:38 And then the values of that Pydantic model will be validated and populated from different areas.

00:35:43 Right.

00:35:43 So you could have like a customer object or here you've got an item which has a foo and a bar of different types as the parameter to the API.

00:35:51 Right.

00:35:51 This is really key.

00:35:52 So you define it once.

00:35:53 Yeah.

00:35:54 Or maybe you can even define it on a model level.

00:35:56 So you create your table, you know, customer name is string, you know, birth date is like daytime.

00:36:03 Then it can be automatically transferred to the schema, which is Pydantic model under the hood.

00:36:08 And then you call it pass it as an argument.

00:36:11 And yeah, you have your data validated.

00:36:14 It automatically parsed through JSON, extracted, validated.

00:36:18 And you're not only limited to JSON.

00:36:21 So Django Ninja also comes with what is called parsers.

00:36:25 So you can define, okay, is it a YAML parser, XML parser, CSV parser.

00:36:30 So you can define your own parsers.

00:36:32 And then you can just have different inputs.

00:36:34 And yeah, they will parse it.

00:36:36 But yeah, like the core guarantee you have is that your annotated argument that you pass here will always have your log.

00:36:44 If you have name as a string, it will be string.

00:36:46 If your birth date is date, then it will be date.

00:36:49 And you have this kind of guarantee that you can always rely and be sure that it's parsed and validated.

00:36:55 Yeah, that's a big point of this, right?

00:36:57 Once the function gets to where your code actually runs, it's good.

00:37:01 The data has already been validated.

00:37:03 Everything, right?

00:37:04 Yeah, you focus on business logic.

00:37:06 You put aside your mental context about validating stuff.

00:37:10 You're like it's somewhere else.

00:37:11 Someone else defined it.

00:37:13 So you don't worry about it.

00:37:14 You just, in your operation, you focus only on business logic and that's it.

00:37:18 That's super interesting.

00:37:19 And the reason I focus on this is you said that the conversion of input data coming in to the Python model can come from a bunch of different locations.

00:37:28 JSON, path parameters, query parameters, cookies, headers, forms, etc.

00:37:33 Will it take from multiple locations to fill this out?

00:37:36 For example, will it take the body of that JSON and maybe pull the name out of it, but then get the ID from a path parameter or a query parameter?

00:37:46 Will it combine it in this way?

00:37:48 Yeah, basically, like the rules are pretty simple.

00:37:50 So you can actually mark.

00:37:53 So there is like your import from Ninja, like, for example, form or header.

00:37:59 And then in like in this square containers, you can define, okay, this comes from form, let's say.

00:38:05 And that way you can tell, okay, it's just, okay, you parse the data only from form data.

00:38:10 Don't just try to parse it through JSON and stuff like that.

00:38:13 I guess you can search in documentation, try like searching for forms.

00:38:17 That will be a good example.

00:38:19 Form data, yeah.

00:38:21 So you see, you kind of define, so we import form container.

00:38:24 You say, okay, username is a string that should come from form and password is also string here that comes from form.

00:38:31 And that way you can just leverage on default, you know, for multi-pal from data or just default form data.

00:38:38 And yeah, like simply parse it without JSON, but just the raw form data.

00:38:43 So you can say that for individual values, like if you're passing in the username or password.

00:38:49 And you can even do that for your Pydantic models, which is cool.

00:38:53 You say the item, instead of being of type item, you say it's of type form of item, which means go to the form and get it, right?

00:39:01 Yeah.

00:39:01 You must have done some pretty challenging type stuff to get this all to work, right?

00:39:06 To get it.

00:39:07 So how do you specify it comes from the form?

00:39:10 But also that when I say item dot, it gives me lists from items, not from form.

00:39:15 And right.

00:39:15 Is this like an annotated thing or how does this work?

00:39:18 This is actually like, like really kind of hack away.

00:39:22 Like, yeah.

00:39:22 How to make it work.

00:39:24 And then the first, yeah.

00:39:25 Like editor should do that to complete.

00:39:28 mypy should not like scream at you and it should validate under the hood.

00:39:33 So there's like a pretty, pretty like nasty kind of if typing stuff, annotations.

00:39:40 So it's like really like inside it looks ugly, but outside it's like perfect.

00:39:46 Yeah.

00:39:46 So you get like, you just define, okay, it's form from item.

00:39:49 Your editor works, your serializer works, everything works, but under the hood, it's like pretty,

00:39:54 you don't want to maintain, maintain this code.

00:39:57 It's like too much stuff to satisfy all parties, the my pie, the code and the editors.

00:40:02 That's exactly what I was thinking.

00:40:04 It looks simple, but I bet it was, I bet it was tough, but it's really nice.

00:40:08 Yeah.

00:40:08 It's like the differences between 3.7, 3.8, 3.12.

00:40:13 Like they're doing, you know, every like year the new Python works and then there is like

00:40:17 little tweaks here and there.

00:40:18 So it's like, yeah, it's like the simplest to keep it simple.

00:40:21 Like it's, yeah, it goes like a lot of testing on, on, on, under the hood.

00:40:25 That testing is probably pretty hard.

00:40:26 I would imagine because you've got different consumers, you know, how do you make sure that

00:40:30 an editor works and that my pie works in the code runs, you know, this is not just maybe

00:40:35 a unit test, a simple unit test.

00:40:37 I imagine.

00:40:37 Well, yeah, I remember when I started like, yeah, like I just, I thought, okay, I'll just

00:40:41 make a 100% coverage on all Python versions.

00:40:44 But yeah, that was like really tricky part because yeah, there was like edge cases for, for some

00:40:49 combinations.

00:40:49 So if you know, maybe like a Django plus Python 3.6 or stuff like that was like really giving

00:40:55 some headaches.

00:40:56 But I was at some point lucky that first Sebastian did it for FastAPI.

00:41:01 So I literally just copied lots of test cases from FastAPI codebases, just a little bit

00:41:08 adapted, and I already had a pretty extensive test coverage.

00:41:11 So then I just focused on specific implementations of here and there.

00:41:16 But yeah, the end goal is really the usage should be really simple.

00:41:22 So your editor works.

00:41:24 If you use mypy, you really like types, you have 100% type correction.

00:41:30 And then on the hood, it does as fast as possible, whatever, like Pydantic Magic,

00:41:36 media with Rust.

00:41:38 It also does it as fast as possible, currently possible with current technologies.

00:41:44 I'm going to go talk through the motivation section because you've got this motivation

00:41:48 page that I think is probably a really good place for people to start as they're considering

00:41:53 this.

00:41:53 There's a lot of interesting pieces here.

00:41:55 For example, some stuff that we haven't touched on like dependency injection and other really,

00:42:01 really wild ways to sort of combine code to make it cleaner and more single purpose functions,

00:42:09 right?

00:42:10 So we talked about the Django Ninja will take inputs from these various locations, validate them, convert them,

00:42:19 then pass them in.

00:42:20 But this example you got here.

00:42:22 You're using external functions to say get a user and then using that as part of the population,

00:42:29 the data, I guess.

00:42:30 Tell us about this.

00:42:31 Basically, this is how FastAPI works.

00:42:33 So they really define all like arguments there.

00:42:37 And if you like, let's say you need a database in your function, like if you're using like SQL

00:42:42 Alchemist, then you're kind of forced to have this DB engine as dependency or like user as a dependency.

00:42:50 And because, you know, with Django, you kind of already have it either like you don't have like to access database,

00:42:57 you just use models dot object and you don't have to worry about.

00:43:01 So this part is for all the way.

00:43:03 And as well, like users also like stuff that by Django protocol, you kind of have it on a request.

00:43:10 Yeah, request that user or request that session.

00:43:12 There's lots of stuff you already have in kind of like settled way and that people already expect it to be there.

00:43:20 So that's why like, yeah, like I was wondering, should Django Ninja have dependencies?

00:43:25 But my vision, it should not.

00:43:27 It should be like a bit more simple and rely on the current way of work where people are already know,

00:43:33 well, okay, where's my user?

00:43:35 Where's my session?

00:43:35 Where's my cookies extra if I need to?

00:43:37 So you worry only about like your arguments are the stuff that should be validated,

00:43:42 not the stuff you depend on.

00:43:45 Yeah, like, you know, database or like some kind of authentication.

00:43:48 And yeah, that's why you can also separate the logic.

00:43:52 So because if you already like entered the execution of the function, that means all the process that was before is already done.

00:43:58 You have guaranteed that if you define authentication, that's already done and you have your user.

00:44:02 If you like relied on some kind of validation, then it's already there.

00:44:07 So again, your focus is only on business logic of application and the rest pieces should not be involved.

00:44:14 And don't, you know, you don't bother with them at all.

00:44:17 This is super nice.

00:44:17 So let me try to give people a sense of what I'm talking about here over audio.

00:44:22 And so in the example, like I said, I'll link to the motivation page is you've got this function that needs the database.

00:44:30 It needs the current user and it needs some arguments.

00:44:32 Right.

00:44:33 So the argument is handled by just what comes into the posters, part of the URLs and stuff.

00:44:39 And then there's a database and you can say this depends on a function, which then Django Ninja will call automatically.

00:44:45 And you can say the current user also is a user and it depends on this other function, which actually is an async function and being called for, which is, that's amazing.

00:44:54 This is how FastAPI works.

00:44:56 So it depends is actually not the part of Django Ninja on purpose.

00:45:01 So this is like example how it is in FastAPI, but it is not on Django Ninja because it's like all of the building.

00:45:07 This is the Django, this is the, this is the FastAPI version.

00:45:10 Yeah.

00:45:11 Yeah.

00:45:11 And so you're saying, no, this is what we do instead.

00:45:13 Okay.

00:45:13 Got it.

00:45:14 Yeah.

00:45:14 You know what?

00:45:14 I'm not a big fan of dependency injection.

00:45:17 Not necessarily the arguments are fine, but this, the whole idea of dependency injection, I always find it looks cool in practice.

00:45:23 But then when I'm trying to work with it, I'm like, where does this come from?

00:45:26 Like, why do I have this?

00:45:27 And how do I, how do I get back to it?

00:45:29 You know, I have kind of the same feeling about like any, any like Python approaches to the dependency injection libraries,

00:45:36 because I think the Pythonic way is actually like, like it's more kind of, because you can import from strings.

00:45:43 You can, you know, pass kind of any type of arguments and just access them by like the, this quarks.

00:45:49 So you, I think you never should need like, you know, Java, Java world dependency injection, because the language itself kind of gives you a way to not call it a dependency, but find kind of verbal work around how to access, you know, one type of class or another.

00:46:07 So you do, so you do, so you don't even call it like in, in, in, in dependency injection while it, you actually like inject it from some configuration.

00:46:15 So like, basically what I try is like, you know, like the, the, I guess the perfect libraries that exist in like Python is like, let's say like requests, right.

00:46:24 They could have done like the same way.

00:46:26 Like, okay, like let's do dependence injection or some kind of SSL protocols, like, you know, timeouts and stuff like that.

00:46:33 But they, they really try to like make it as current Pythonic way as possible through like some quarks or like, or, or like, you know, stuff that you, you never, you never know.

00:46:42 Okay.

00:46:43 What's actually injected, but verbally, you know, what, what's, what's going on.

00:46:47 Yeah, the quarks and the stargs, quarks, all that stuff is when I see that it's the function signature, I feel like, okay, the, you kind of given up on helping me know what I'm supposed to do here.

00:46:57 The only way to know is to go read the documentation, which not a big fan.

00:47:01 Let's talk about authentication.

00:47:02 So what's the Django ninja way for authentication here?

00:47:07 It looks pretty integrated.

00:47:08 It's kind of both integrated and it's pretty like loose and flexible.

00:47:13 So yeah, even, even, so, you know, you just on your ninja API, you define like auth variable.

00:47:19 So it's purposely not, not called authorization or authentication.

00:47:23 It's just auth, you know, so you can define yourself.

00:47:26 Do you want to implement authorization or authentication?

00:47:28 It's like really up to you.

00:47:29 Okay.

00:47:29 Because it's like, yeah, you just, the auth is like a function that will be called with your request.

00:47:34 And then you can kind of define, you can read some kind of cookie or token or like, you know, whatever, like it's like up to your business implementation.

00:47:42 And yeah, if it, if it's, if it's return something, then this is like a, you know, your, your, your object that will be attached to request.

00:47:49 Dot.

00:47:50 Off inside this function.

00:47:51 You can also access request and like attach your request. User, which is what is in most cases are done.

00:47:57 If you like, you have user in your system that is tied to some token or stuff like that, but it's kind of on purpose that yeah.

00:48:05 Like it's, it's not always, you have user.

00:48:06 So maybe you just need some kind of object.

00:48:09 Maybe you have API keys.

00:48:12 Client or yeah, whatever.

00:48:14 Yeah.

00:48:14 Yeah.

00:48:14 Maybe you just need to pass an API key.

00:48:16 It's not tied to someone.

00:48:17 Yeah, for sure.

00:48:17 I tried not to like force people into like deciding what exactly they're implementing.

00:48:22 They just need to implement a function and then use it.

00:48:26 But yeah, by default, you can just import default Django auth that will use like your standard Django session based authentication.

00:48:35 And yeah, just live with that by some default cookies, tokens.

00:48:39 So like whatever you prefer.

00:48:41 What about async?

00:48:41 I think it was like one of the core features.

00:48:44 Yeah.

00:48:45 Like, and what was like different from Django rest framework.

00:48:48 And yeah, it kind of, yeah, it does.

00:48:50 Like I see like from the feedback from companies who use like it is sometimes like truly help them like to, to take a like some kind of slow, slow request that they're like just to waiting for some data.

00:49:02 Yeah.

00:49:03 But yeah, the thing is like you're not, you are not required to use one or another.

00:49:08 So you can pretty much mix both worlds in your, in your code.

00:49:12 So, because, you know, it was Django because initially Django was not designed to be, I think, friendly.

00:49:18 So, and when you, for example, like, because let's say you, you request a user return, but under the hood, let's say it's called a user dot group, which is also will initiate another request to the database under the hood.

00:49:31 So this is, this part is like, it's really hidden from you and you cannot really sometimes be involved in manipulating.

00:49:38 And so that, that request also gets into async context.

00:49:42 So yeah, the simplest way you just can, for some complex stuff, you can just mix two worlds, you know, async and not async functions.

00:49:51 They decide what you need.

00:49:52 You need like some kind of a weight performance while waiting for some, you know, network connection database, or you just need like, you know, to make it simple.

00:50:00 Simple, easy.

00:50:01 And you just don't worry about if it's, you know, that does some kind of a little bit of weight.

00:50:05 And so mom, I would say my, my go to approach is like, yeah, basically I do all the stuff in sync mode.

00:50:13 It's only when I really need to maybe like server side events or like, you know, a weight into some network connection or like long database queries that returns lots of results.

00:50:22 And yeah, this is, this is like, you just switch to async and you just await your result and you win some, some performance out of it.

00:50:31 But by default, I would, I would just go with no, no, no, no, no, no, no.

00:50:35 I think way.

00:50:36 Yeah. I would as well.

00:50:37 Although for my app, at least I found most of the time there was some database call or there was something going on or like, all right, this part is async.

00:50:45 So, you know, work your way back and make the view function async as well.

00:50:48 But if you don't have to, then certainly don't, right?

00:50:50 It just adds complexity that you don't necessarily need.

00:50:53 The reason I'm asking is what's the story with the Django ORM in async these days.

00:50:58 I know that this is kind of one of the last parts for the Django async support journey.

00:51:03 I think they settled on what it is now.

00:51:05 So you can like, there's extra methods on ORM, like a get, a create, a like filter or stuff like that.

00:51:12 So you can already like do a bunch of default stuff.

00:51:16 All right. So those you can await already. And that should be.

00:51:18 It's a tricky part when, you know, you, let's say you have a query set, so you like awaited it, but then inside you, you do, you do some kind of loop and then access some, you know, dot, dot something that is actually foreign key or many to many field that.

00:51:31 So then you need to like, keep in mind that you need to like do, do the join.

00:51:35 Yeah. Like already in your ORM query, like, you know, select related or pre-fetch related that will do for you this, this pre-fetching.

00:51:42 So then on the time when you're accessing some attribute, it will not, it will not perform like a query for you because this is actually like what's, what's actually biting Django ninja users.

00:51:53 So yeah, they, let's say they're creating like schema that outputs user and a group.

00:51:58 Yeah. Like again, a group is some kind of schema.

00:52:00 So they just, okay, I'll just return the async query set and yeah, be, be ready with it.

00:52:05 But then Django kind of, and I think it's probably good that they, they, they tell you like, okay, so you're accessing the attribute that requires the database.

00:52:13 So you kind of get an error.

00:52:14 So they kind of force you to think, okay, you know, if you want to really get, get it correctly, then you just better like evade with, with joint.

00:52:28 So that's good advice for people, even if they're not doing async, right?

00:52:31 Right.

00:52:32 This, this N plus one problem can make your ORMs very slow.

00:52:34 And if you know, I'm going to go access this thing.

00:52:36 That's a foreign key.

00:52:37 Maybe this means like, if you use it by default, you can kind of catch those, those like parts that you were not a word before.

00:52:44 And then you kind of, they will bite you before you go to production.

00:52:49 So maybe that's, that's the way to go.

00:52:51 Some people will like this and some people will not like it.

00:52:53 But yeah, it will definitely let you know what's going on.

00:52:55 Right.

00:52:56 Amazing.

00:52:57 Anything else before?

00:52:58 I guess one thing really quick here is when you say, when you're doing the async stuff, can I just use the Django admin management tool?

00:53:06 Or do I have to run with an async server separately?

00:53:10 What's the story there?

00:53:11 It's just work out of the box.

00:53:12 So yeah, you just run it under you, you record like any other SGI worker and you have your, your, all your, all your default stuff will be there.

00:53:20 So basically it's like, it's out of the box.

00:53:23 It should work.

00:53:24 Like, you know, it's, it's, it's, it's all, you only have tricks only was, you know, this N plus one problem.

00:53:29 So this is where you will have to keep, keep, keep attention and make sure it's like a weighted properly.

00:53:34 Yeah.

00:53:35 UVicorn is really nice.

00:53:36 They're making a lot of progress.

00:53:37 They're now a standalone server.

00:53:39 You don't have to use them.

00:53:40 You don't have to say G unicorn with UVicorn workers.

00:53:43 You can just run it as its own proper Linux server and so on.

00:53:47 It's really nice.

00:53:48 All right.

00:53:49 So that's what brings up.

00:53:50 Is there anything else you want to tell people about Django Ninja that we, we should cover?

00:53:53 I think I would like to talk about the, the, you know, so currently we are in this LLM era where, you know, people no longer, you know, Google or like go, go to documentation.

00:54:03 They just simply ask your, you know, favorite open AI or anthropic chat to like write you some code.

00:54:10 So what, what I currently notice is like, you know, when library do some kind of new iterations, you're like introduce new stuff.

00:54:18 Like, you know, make some kind of, you know, maybe even breaking changes.

00:54:21 You know, the LLMs will not sexually be out time with, with those changes.

00:54:26 And that is actually like bringing lots of problems.

00:54:28 Like, so like the, with issues that I see, like I see that people just, you know, you're working on recently, but probably they, they asked LLM to implement some feature that is already like old syntax and already like, you know, giving in some problems.

00:54:42 So it's really, you know, this problem for like libraries that, you know, want to make changes, but on the other hand, like LLMs will pick it up, you know, maybe in like year best.

00:54:55 Yeah.

00:54:55 Like whatever new version, like I saw this a lot with Pydantic when they, you know, they already like a version two for like a year in a while.

00:55:04 While if you ask LLM to implement some stuff, they, they still giving you the old, old approaches.

00:55:09 So I think this is like, maybe like a, something it's not to open the developer software and source community, the way to influence it.

00:55:17 But yeah, maybe like, so what I, what I am currently thinking is like adding some kind of tooling on top of, or documentation that will just, will give you the latest, latest result.

00:55:29 Oh, that'd be cool.

00:55:30 Yeah.

00:55:31 But if you like listening to this podcast, you can go to LLM.djangoNinja.dev.

00:55:36 It will, it will, we'll redirect you to some ticket where I will notify when it's ready.

00:55:40 So like for now, we just redirect to, to GitHub issue.

00:55:45 I will probably need to write better access, but here you can subscribe and I will just try to publish some kind of a better documentation tool in this LLM world where you can ask, you know, a question.

00:55:57 And it will answer you latest, latest and better approaches without like, you know, forgetting all the old knowledge and giving you the newer updated version.

00:56:08 So that's, this is a serious annoyance with LLMs because you'll ask it a question on how to do this thing.

00:56:14 And it looks like an amazing answer.

00:56:15 You're like, Oh my gosh, save me so much time.

00:56:17 And then you'll try it and it'll, it'll be using a function or a class or something that doesn't exist.

00:56:22 Like, Oh, you're lying to me, please.

00:56:24 This doesn't exist.

00:56:25 Oh, you're right.

00:56:26 Here's the real way.

00:56:27 And that's, that's even before you get to it being trained exactly on the docs.

00:56:31 So are you using some sort of rag local LLM or what's, what are you doing here?

00:56:36 Generally, like my vision is like, yeah.

00:56:38 So this tooling should give you like some kind of regular latest documentation and also like context with a better, but like recommended by, by the, by the chief ingredients.

00:56:48 Yeah.

00:56:49 So like, no, not like, because I see like, yeah, some, sometimes like you, even on stack overflow, you see some answer, but you technically not, not agree the way it's done, but because it's like on the top and all LLMs already picking it up.

00:57:03 And it's, it's getting like this kind of boost that you don't really want to.

00:57:08 And this is like, I think it becomes kind of problematic that, you know, that you cannot really suggest to large language models.

00:57:14 Okay.

00:57:15 What's the recommended way and why it's better than, than it's currently like suggested.

00:57:19 So yeah, this is, I, yeah, but this is like more like a, it's, it's a new problem that never existed before, but you have to rely on it.

00:57:26 So concurrently, I guess the best way is like to stick with your API forever and just try to, to do stuff on the, under the hood.

00:57:34 So that, you know, users, users always use the, how it was designed at the beginning and yeah, like never, never feel any differences.

00:57:42 Easier said than done.

00:57:43 I will add though, that your documentation has really nice search.

00:57:46 So that that's easy to go here and, and even without the LLM it's pretty approachable.

00:57:53 So it's not, you know, I don't feel like you have to use LLMs to figure this out.

00:57:58 I'm sure people will.

00:57:59 That's actually also the goal, like how, how you make it so that people don't, don't, don't ask any question.

00:58:04 Don't Google like it should be like intuitive.

00:58:06 Let's wrap it up with a thought, I guess, but we talked about using Python typing as a core element of the framework.

00:58:13 And I don't know about other people, but for me, the fact that it has strong typing and maybe put a little bit of that into your code as well.

00:58:21 I find I go to the documentation much less when I do that, or I'm using APIs like that because you just, your editor just tells you, well, here's the three things.

00:58:29 You go, well, this must be the one.

00:58:30 And you know, it guides you down the path.

00:58:33 But if the editor is not there to help, because it doesn't have the type information, then, then you have to go to the docs or you have to go to search and it's just, it's not great.

00:58:41 Yeah.

00:58:41 So I think it's very approachable.

00:58:42 Even if you use some, some stuff like a pilot.

00:58:44 Yeah.

00:58:45 So even if suggested something wrong, but if you like have types that and your editor immediately like highlighted you with some kind of red, red, wavy thing that it's you don't have this attribute and you already like sold it.

00:58:56 And yeah, it's makes you laugh easier.

00:58:58 Yeah, it absolutely does.

00:58:59 All right.

00:59:00 Final thoughts.

00:59:01 People wouldn't get started with Django Ninja.

00:59:03 What do you tell them?

00:59:04 It's definitely worth trying if you like never, because what I often see is like on Reddit on like any, any resources, like people ask, okay, so I have JNDRF and Django Ninja.

00:59:15 So what should I try?

00:59:16 And you're like, there's always like people who answer a bunch of stuff and pros and cons.

00:59:22 Like, yeah, like I think at this point, like, yeah, but before there was like big argument because the Django rest framework is really old stalled product that is like, you know, have like large community.

00:59:33 I think at this point, Django Ninja also becomes this old thing as well, because like, it's already like, I think it's like five, it's five years will be like somewhere this year or more, even more.

00:59:44 I don't count.

00:59:45 It's already like have millions of downloads and it's all like, I know very big, big names of companies who use it and they use it in a pretty kind of sensitive areas.

00:59:56 So yeah, should not, not get worried.

00:59:58 And because also like, I guess one of the things that I'm trying to, as a strategy for this product, I try to be this as, you know, subtle as possible without like, you know, risky moves or changes.

01:00:11 Try to make it for people to migrate to newer, newer versions easier.

01:00:15 So like, I guess the hardest part was like, you know, between version zero something to 1.0, but yeah, it will, it was like dictated by the fact that, you know, Pydantic moved from one to two.

01:00:26 So like, there was no way to make it without breaking changes.

01:00:30 But my goal is like, like actually like, you know, even in this LLM era to try to introduce new features that should not force you to like, you know, may have a breaking changes year in your code.

01:00:42 So yeah, that's my, that's my goal.

01:00:44 And yeah, this is why you should try it.

01:00:46 So if you, if you, if you like try it in introducing to your code, then you probably will be good, good for the, for the good amount of time.

01:00:54 And I think like one more thing that we didn't talk about, but you should definitely try is, is project called nano Django.

01:01:01 So this is a way for you to write a code, like a pro Django project, but just in one file.

01:01:08 So under the hood, it also uses Django Ninja.

01:01:11 So this is also like a very, very easy thing to be, to join the Django Ninja tryout thing.

01:01:18 So here in one file, you can define your model.

01:01:20 You can define your API, run it with one command and you're ready to go.

01:01:24 And basically like same, same way you used to work with Flask or FastAPI.

01:01:29 But the coolest thing about this is like when you see, okay, your, your file grow to like, you know, hundreds of thousands of lines.

01:01:38 There is a tooling that you just, it can convert for you, like your single file into a standard Django project structure.

01:01:45 And that, that way you can, you know, you start small, then you see you're growing and then it, it, it will convert you go to, you know, standard Django configuration,

01:01:54 process and all the conventions.

01:01:56 And yeah, you continue your project without, without any, Yeah.

01:02:00 Yeah.

01:02:01 Nano Django is an interesting project for sure.

01:02:03 It's like, let's start simple, but if you need it to be more structured, then it'll actually explode out the file and stuff.

01:02:09 This is like a very first way to try that to do.

01:02:11 To just simply install Manage Django and you'll have Django in that hood, Ninja under the hood and everything you need all in one, in one file.

01:02:18 Cool.

01:02:19 Awesome.

01:02:20 I'll definitely put that in the links for people as well.

01:02:21 Well, Vitaly, thank you for being here.

01:02:23 I did mention at the top, but I do want to send out some thoughts and support for the folks out in Ukraine as well.

01:02:29 I know it's a ridiculous time and be safe out there.

01:02:33 You guys.

01:02:34 Thank you.

01:02:34 Thank you for being here.

01:02:35 Thank you for creating this awesome project and coming on the show and sharing it with us.

01:02:38 Thank you for having me.

01:02:39 Thank you very much.

01:02:40 Yeah.

01:02:41 Bye.

01:02:42 Bye.

01:02:42 This has been another episode of talk Python to me.

01:02:44 Thank you to our sponsors.

01:02:46 Be sure to check out what they're offering.

01:02:47 It really helps support the show.

01:02:49 Take some stress out of your life.

01:02:51 Get notified immediately about errors and performance issues in your web or mobile applications with Sentry.

01:02:57 Just visit talkpython.fm/sentry and get started for free.

01:03:02 And be sure to use the promo code TALKPYTHON, all one word.

01:03:06 And this episode is brought to you by Bluehost.

01:03:08 Do you need a website fast?

01:03:10 Get Bluehost.

01:03:11 Their AI builds your WordPress site in minutes and their built-in tools optimize your growth.

01:03:16 Don't wait.

01:03:17 Visit talkpython.fm/bluehost to get started.

01:03:21 Want to level up your Python?

01:03:22 We have one of the largest catalogs of Python video courses over at Talk Python.

01:03:26 Our content ranges from true beginners to deeply advanced topics like memory and async.

01:03:31 And best of all, there's not a subscription in sight.

01:03:33 Check it out for yourself at training.talkpython.fm.

01:03:36 Be sure to subscribe to the show.

01:03:39 Open your favorite podcast app and search for Python.

01:03:41 We should be right at the top.

01:03:43 You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

01:03:52 We're live streaming most of our recordings these days.

01:03:55 If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:04:02 This is your host, Michael Kennedy.

01:04:05 Thanks so much for listening.

01:04:06 I really appreciate it.

01:04:07 Now get out there and write some Python code.

01:04:09 write some Python code.
