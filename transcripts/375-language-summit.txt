00:00:00 Every year, the Python core developers and a few other key players in the Python ecosystem

00:00:04 meet to discuss the pressing issues and important advancements at an event called the Python Language Summit.

00:00:11 While Python is a community known for its openness, this meeting is typically held behind closed doors, mostly for efficiency's sake.

00:00:19 On this episode, we'll give you a look behind that door.

00:00:23 We have Alex Waygood here on this episode to break it down for us and give us a report from inside the Python Language Summit.

00:00:30 This is Talk Python to Me, episode 375, recorded June 29th, 2022.

00:00:36 Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:53 This is your host, Michael Kennedy.

00:00:54 Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes at talkpython.fm

00:01:01 and follow the show on Twitter via at Talk Python.

00:01:04 We've started streaming most of our episodes live on YouTube.

00:01:07 Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.

00:01:16 This episode is sponsored by Reflect.run.

00:01:19 If you can browse the web, you can use Reflect.run to create sophisticated tests for your web app.

00:01:24 And it's brought to you by Microsoft for Startups, Founders Hub.

00:01:29 Get early stage support for your startup and build what you've been dreaming about.

00:01:35 Transcripts for this and all of our episodes are brought to you by Assembly AI.

00:01:38 Do you need a great automatic speech-to-text API?

00:01:41 Get human-level accuracy in just a few lines of code.

00:01:44 Visit talkpython.fm/assemblyai.

00:01:46 Alex, welcome to Talk Python to Me.

00:01:49 Thank you.

00:01:50 It's great to be on the show.

00:01:50 Big fan of the podcast.

00:01:52 There's so much going on with the Python Language Summit, especially this year.

00:01:55 I think there's quite a renaissance of new ideas to sort of look at the foundations and the fundamentals of Python.

00:02:02 And a lot of it has to do with speed in different aspects.

00:02:06 Maybe that's through threading or through raw performance or reference counting garbage collection.

00:02:10 And so we're going to dive into all those ideas and more by just talking about your coverage of the Python Language Summit 2022.

00:02:18 It's going to be super fun.

00:02:20 But before we get to that, let's get to your story.

00:02:22 How did you get into programming in Python?

00:02:23 And how did you get inside the Language Summit anyway?

00:02:25 Oh, yeah, sure.

00:02:26 So I started programming actually only around two years ago.

00:02:30 But my first line of code during the pandemic started off as a hobby.

00:02:34 Still actually is a hobby.

00:02:36 Had to have something to do while staying indoors.

00:02:39 Exactly.

00:02:39 Yeah, so Python is my first language and I'm entirely self-taught.

00:02:43 And yeah, once I started, couldn't stop.

00:02:46 That's cool.

00:02:46 What kind of things were you looking to build?

00:02:49 Were you just looking to learn a language or did you have some idea of something you wanted to create?

00:02:52 So I started, so I was doing a journalism master's at the time.

00:02:56 And there's a sub-community of journal coders.

00:03:01 So people who use programming languages to gather data, scrape the web to find stories, essentially.

00:03:08 So I thought that sounded pretty cool.

00:03:10 Yeah, that sounds very cool.

00:03:11 Yeah, so I started learning Python to help with that.

00:03:15 And then sort of started to realize I actually enjoyed Python quite a lot, just for its own sake.

00:03:21 Started building, built a card game using Pygame.

00:03:25 It was one of my first projects, which was a lot harder than I anticipated.

00:03:29 All the first projects are.

00:03:30 Oh, yeah.

00:03:31 Yeah, definitely.

00:03:32 And then built a bad website using Flask.

00:03:35 And then eventually started contributing to open source.

00:03:39 And that's about where I am now.

00:03:41 Fantastic.

00:03:41 Yeah, yeah.

00:03:42 That's really cool.

00:03:43 It's interesting that you bring up journalism.

00:03:45 I had Carolyn Stransky on a little while ago, predated the pandemic.

00:03:50 Is it?

00:03:51 Did it?

00:03:52 Yeah.

00:03:52 Maybe not.

00:03:53 I don't even know when the pandemic was.

00:03:55 A couple of years ago.

00:03:56 Anyway, we talked about Python.

00:03:58 Looks like you just hit before the business started.

00:04:01 Just before it really, really kicked it.

00:04:04 Exactly.

00:04:05 Yeah.

00:04:05 We talked about Python and AI and journalism.

00:04:08 And there's a ton of neat things that people are doing to sort of automate the act of gathering data and reporting on it, right?

00:04:17 Yeah.

00:04:18 No, it's a really cool space.

00:04:19 Directly employed in journalism is my full-time job at the moment.

00:04:22 But it's something I'd love to dip into again at some point.

00:04:26 For sure.

00:04:26 Yeah.

00:04:27 Carolyn was talking about things like monitoring certain websites like the National Geography, whatever the foundation is there, that alerts people about earthquakes.

00:04:38 And I would bring up details and sort of pre-fill.

00:04:42 So like some folks in LA, like on the LA Times or something, would get an alert.

00:04:47 There's an earthquake.

00:04:47 Here's most of the details.

00:04:48 Just put the details around it and hit publish, you know, within 10 minutes or whatever.

00:04:53 That's pretty cool.

00:04:54 A little beep and then go write your article now.

00:04:56 One of my first projects I tried to do, again, biting off much more than I could chew, was there's a, in the UK, we have this body called Historic England, which catalogs England's old buildings and heritage assets.

00:05:10 And I have this all online, but it's not like in an easily downloadable form.

00:05:13 You know, you can't just like download the CSV of the National Heritage List.

00:05:17 So I decided that I was going to try and scrape this from the website.

00:05:20 Of course, the scraping is easy, but then the data cleaning is a nightmare.

00:05:25 Because like there's no consistent format and some of it's from the 1950s and yeah, it's horrible.

00:05:29 Well, it would have been cool if you could have gotten it right and shared it with everyone.

00:05:34 I got, I got some way there, but yeah, it's way too, way too difficult for one man.

00:05:40 Like just started learning a few months ago.

00:05:42 Yeah.

00:05:43 Yeah.

00:05:43 Yeah.

00:05:43 Of course.

00:05:44 It's those kinds of projects that are really good for learning programming.

00:05:47 You know, they're.

00:05:48 Oh yeah.

00:05:48 I learned a ton.

00:05:49 Don't regret it at all.

00:05:50 Yeah.

00:05:50 You're like, here's my goal.

00:05:52 And then you just start frantically searching for like, well, what are the steps I need?

00:05:56 And then how do I make those steps happen in my programming language, Python in this case?

00:05:59 And like, you might not normally care to figure out how do you parse a CSV file out of this,

00:06:04 but you're going to have to do it now because you're trying to, you know, aggregate on, you know,

00:06:07 add onto it, append onto it and so on.

00:06:09 So yeah, those kinds of things are great, great projects.

00:06:12 Cool.

00:06:12 All right.

00:06:13 Well, how'd you get into the Python language summit from a journalism anger, from the open

00:06:18 source angle?

00:06:18 What was, what's the story here?

00:06:20 I was invited in the autumn, I think, to become a triage with CPython.

00:06:25 So at that point I'd contributed a lot of docs, documentation fixes, just something I was pretty

00:06:32 good at because of the journals and masters.

00:06:33 You actually know how to write.

00:06:36 So yeah, I do know.

00:06:37 I'd also contributed code to a few modules at that point, a few small fixes to,

00:06:43 I think, functools, enum.

00:06:46 Yeah, a few standard lib modules.

00:06:47 So I'd been invited by Ken Jin, who's one of the typing module maintainers to become a triage

00:06:55 during the autumn.

00:06:55 So that got me onto the CPython developers' Discord channel.

00:06:59 And then in, I think it was February or March, there was a discussion there where a few cordels

00:07:05 were asking who they were going to invite to become the blogger this year.

00:07:09 You know, Alex does journalism.

00:07:11 Yeah.

00:07:11 I got this, I got this master's.

00:07:14 I mean, could maybe I do it?

00:07:16 And they said yes, which was very flattering.

00:07:19 Yeah.

00:07:19 Fantastic.

00:07:20 And great of them.

00:07:22 And I really, really appreciate it.

00:07:23 So it's Ukash, Mayata, and Sentil this year who organized the Language Summit.

00:07:28 So massive thanks to them for inviting me to be the blogger this year.

00:07:32 I actually appreciate it.

00:07:33 Yeah, that's great.

00:07:34 You must have been also at PyCon then, I'm guessing, because if you're at the Language Summit,

00:07:38 you're at PyCon.

00:07:39 Yeah, what was your experience there?

00:07:40 Was it a good time?

00:07:40 Yeah, I had a blast.

00:07:42 It was great.

00:07:43 Yeah.

00:07:43 It's awesome to meet all these people I've been, you know, doing up and sort of stuff

00:07:47 with online for several months.

00:07:49 Yeah.

00:07:50 It was really cool.

00:07:51 Cool.

00:07:51 I really appreciate these conferences because there's people I work with or talk to in different

00:07:57 ways through, you know, through GitHub, through Twitter, through the podcast.

00:08:01 But you don't really get to see them in person because they're halfway around the world until

00:08:05 you show up and have a beer together or hang out together.

00:08:08 I think that was, I mean, the talks are fantastic.

00:08:10 But yeah, that was definitely the best bit for me.

00:08:12 Yeah, that's the same for me, actually.

00:08:15 That's the thing that I dig the most.

00:08:16 All right.

00:08:17 Let's talk about the Language Summit.

00:08:18 Sure.

00:08:18 So maybe tell people really quickly, what is the Language Summit?

00:08:21 Sure.

00:08:22 The Language Summit is an event every year.

00:08:25 It's just like a day or two days before PyCon itself starts.

00:08:29 Most of PyCon is available to just like anybody who's interested in Python.

00:08:34 The Language Summit is generally only available to like core developers and special guests.

00:08:39 So it's a big exclusive.

00:08:41 That's not because they want to be like secretive about what's happening in there.

00:08:45 It's more so that it can just be a sort of frank conversation between trends, I think.

00:08:51 Sort of.

00:08:52 Yeah.

00:08:53 Does that make sense?

00:08:53 Yeah.

00:08:53 I mean, it's where the business of planning out Python gets done, right?

00:08:58 Yeah, exactly.

00:08:59 Yeah.

00:08:59 It's not the only place.

00:09:00 We have our peps and we have other places where conversation happens.

00:09:04 But it seems like one of the places where, you know, some of the ideas of the peps are discussed

00:09:09 and there's a quick feedback loop amongst a lot of the core developers.

00:09:13 Yeah, exactly.

00:09:14 I think it's just, you know, get everybody together all in one small room, talk Python for the whole

00:09:19 day and then see what comes out of it.

00:09:21 Awesome.

00:09:21 How many people show up there?

00:09:22 How many core developers and other folks?

00:09:25 Around 30 this year, I think.

00:09:27 So mostly core developers, a few triagers and a few special guests.

00:09:33 So Zach Hadfield-Dobbs, I think, from Hypothesis was there.

00:09:38 Sam Colvin from Pydantic.

00:09:40 So yeah, a few open source maintainers outside the Core Dev team as well.

00:09:45 Right, right.

00:09:46 Yeah.

00:09:46 Yeah, Pydantic's interesting.

00:09:48 Obviously a great library.

00:09:49 It's interesting to me because it kind of, a lot of its meaningful functionality is in

00:09:55 the way that it breaks with the tradition of Python, you know, in the same way, like type

00:10:00 hints.

00:10:00 Now all of a sudden don't just mean something, but like they are the core way in which that

00:10:04 library works.

00:10:05 Whereas like most of the time it's a suggestion or a hint as the name would suggest.

00:10:09 Sure.

00:10:09 Yeah, yeah.

00:10:10 And in the way it's quite coercive as well.

00:10:13 So you don't have to like, yeah.

00:10:14 Yeah, for sure.

00:10:15 It's, so he's a good guest to have because he's, he's both got a popular project and

00:10:19 one that's kind of an outlier to some degree.

00:10:21 Yeah.

00:10:21 It's hugely popular, isn't it?

00:10:23 Yeah, it sure is.

00:10:24 We've got, you know, SQL model by Sebastian Ramirez, which is basically take Pydantic models

00:10:30 on top of SQLAlchemy and you've got Beanie from Roman Wright and there's some other ones

00:10:36 that are just like sort of using Pydantic as their, their layer, which is really cool.

00:10:41 So obviously the reason we're chatting today is this year's summit was covered by Alex

00:10:45 Waygood.

00:10:46 That's awesome.

00:10:47 That's me.

00:10:47 Yeah.

00:10:47 Yay.

00:10:48 Nicely done.

00:10:49 And so I, when I saw this article or series of articles, I guess you might say come out,

00:10:54 I thought it was really fantastic because like I said, I think there's just so much that's

00:10:59 exciting going on here.

00:11:01 No, it's not.

00:11:02 Well, we're going to change the language a little bit here or there, but there's, there's stuff

00:11:05 that everyone's going to get.

00:11:06 That's really huge stuff in that.

00:11:08 Yeah.

00:11:08 Yeah, absolutely.

00:11:10 So I thought what we could do for our conversation is just go and order and just sort of chat

00:11:15 through them.

00:11:15 You can give me a sense of what it was like to be in the room.

00:11:18 What are some of the main ideas of, of each of these?

00:11:21 And we'll, we'll just chat about them.

00:11:22 So the first one was a very exciting project by Sam Gross.

00:11:26 Yes.

00:11:27 Who I think works for Meta.

00:11:29 Yeah.

00:11:29 I think he does.

00:11:30 Yeah.

00:11:30 I think he does part of the Cinder stuff.

00:11:31 Yeah.

00:11:31 And this is Python without the GIL or, or no GIL.

00:11:35 I don't think he's on the Cinder team, but, but yeah, he is working at Meta.

00:11:39 Right.

00:11:39 Okay.

00:11:40 Cool.

00:11:41 Yeah.

00:11:41 There's other stuff from Cinder.

00:11:42 We'll get to later.

00:11:43 Yeah.

00:11:43 But yeah, Python without the GIL or, you know, his, his no GIL story.

00:11:48 There's been a, you know, from a historical perspective, we've had attempts to remove the

00:11:53 GIL or change the performance characteristics of the GIL and so on.

00:11:57 And maybe let me just set the stage a little bit with this GIL or global interpreter lock

00:12:02 for people listening.

00:12:03 When I heard this, the global interpreter lock means you can only run one statement of Python

00:12:09 at a time, even if it's happening in multiple threads.

00:12:12 I thought, okay, well, this must be some odd constraint put on the language so that things

00:12:17 like threading are easier for people.

00:12:19 But as I learned more about it, the real purpose of the GIL has nothing to do with threading

00:12:24 per se.

00:12:25 It has to do with memory management.

00:12:27 Yeah.

00:12:27 Yeah.

00:12:27 And so the way memory management happens in Python, at least in the primary first pass

00:12:33 sense is it's reference counted.

00:12:34 So everything, numbers, strings, classes, dictionaries, they all have a ref count.

00:12:39 And if that ref count ever reaches zero, it gets deleted as long as there's no cycles.

00:12:43 And the problem is if you're going to change that number on the object, normally you would

00:12:49 have to do that in a thread safe way.

00:12:50 You will lock it.

00:12:51 But that turns out to slow single threaded Python down a lot when it's unneeded.

00:12:55 And so the global interpreter lock is there to meant to basically allow for that reference

00:13:00 counting to happen quickly in the single threaded case.

00:13:03 And that made fantastic sense 30 years ago.

00:13:05 Now that we're sitting here with our 16 and 32 core CPUs, all of a sudden, we might want

00:13:12 to run more than one thread and get stuff done.

00:13:14 You know what I mean?

00:13:14 Yeah.

00:13:15 That's the history of the GIL.

00:13:16 And so there were other things like Larry Hastine.

00:13:21 He was there, right?

00:13:22 Yeah.

00:13:22 Yeah.

00:13:23 Just to interject for a second.

00:13:24 It's really fun to see sort of how long a project has been to try to remove the GIL.

00:13:29 You can go back 10 years ago and there's a talk by David Beasley on weird things going

00:13:35 on with the GIL in 2010.

00:13:36 And then I was writing this after the summit, looking through the archives, past language

00:13:43 summit bloggers.

00:13:45 I think there's like three successive years running where there's presentations about

00:13:49 the latest project to remove the GIL.

00:13:51 But like this time, it actually seems like it could happen.

00:13:53 It's really cool.

00:13:54 It could happen.

00:13:55 Yeah, it certainly could.

00:13:56 Sam Gross's work seems to be the most likely candidate.

00:14:00 And all the other attempts, their challenges have been, yes, you might remove the GIL and you

00:14:05 might make the parallel computing faster, but you're going to make single threaded Python

00:14:09 so much slower that it's, we don't want to accept it, right?

00:14:13 If you could say, well, you can use core, you can use all the cores on your machine, but

00:14:16 now everything runs half as fast.

00:14:18 That's not a huge benefit to a lot of people.

00:14:20 Yeah.

00:14:21 And especially because, because of the fact that the guild's been there for so long,

00:14:25 the vast majority of Python code is with only one thread, right?

00:14:28 So it's like, well, it could make your Python code faster, but only if you rewrote all of

00:14:33 your code, which not many people want to do.

00:14:36 True.

00:14:36 The other major problem or challenge that is there is how does it work with the C extensions

00:14:42 that are so important to making Python work well, right?

00:14:45 NumPy and all those types of things, right?

00:14:48 Yeah.

00:14:48 So Larry Hastings was there and he worked on the Galectomy, which I think is still the

00:14:54 best name of all these projects.

00:14:55 The Galectomy.

00:14:56 Yes, definitely.

00:14:58 Yeah, but it sounds like he thinks that Sam's project is already farther than his.

00:15:03 This portion of Talk Python To Me is brought to you by Reflect.run.

00:15:08 Reflect is the fastest way to create end-to-end tests for your web app.

00:15:12 Most of us have encountered flaky, unreliable tests over the years.

00:15:16 For a lot of us, testing our code is painful, but it doesn't have to be.

00:15:20 Reflect was created by developers who are tired of dealing with constant problems inherent in

00:15:25 code-based testing tools for web apps.

00:15:27 Reflect is an automated, no-code testing tool that enables you to shave countless hours off

00:15:32 your end-to-end testing timeline.

00:15:34 If you can browse the web, you can create sophisticated tests with Reflect.

00:15:39 navigate to your site within Reflect's simulated browser and perform the actions you want to test.

00:15:43 Reflect will auto-generate selectors and do the painstaking work of test creation and maintenance

00:15:49 for you in minutes.

00:15:50 Instead of creating and maintaining a separate code base for your tests, you can manage all of your tests within Reflect.

00:15:56 Features include visual validation, efficient for debugging and eliminating weights, cross-browser testing, run tests across all modern browsers,

00:16:05 including Safari, Chrome, Firefox, and Edge, and email and SMS validation.

00:16:10 The best way to appreciate what Reflect can do for you is to see it in action.

00:16:14 They put together a nice six-minute video you can watch at talkpython.fm/reflect dash video.

00:16:20 That's reflect dash video.

00:16:21 I encourage you to watch it and see how straightforward and composable their tool is to use.

00:16:26 Once you're ready to try it out, sign up at talkpython.fm/reflect.

00:16:30 And as a special offer for Talk Python listeners, you'll get a free t-shirt when you sign up through this link.

00:16:36 That's talkpython.fm/reflect to see how easy web testing can be.

00:16:40 The link's in your show notes.

00:16:41 Thank you to reflect.run for supporting the show.

00:16:44 Maybe tell us a bit about what Sam was proposing there.

00:16:48 So yeah, Sam has got this fork of cPython where he has removed the GIL and it all works.

00:16:55 I think, you know, there's still a few rough edges, but it all basically works essentially.

00:16:59 So now he is looking to...

00:17:02 So if you want to, you can try that right now.

00:17:03 You can go and download Sam's blog, new gill, and most Python programs will run fine on it.

00:17:09 That's it right there.

00:17:10 Yeah.

00:17:10 For those watching...

00:17:11 Yeah, I'll put a link in the show notes.

00:17:12 Yeah.

00:17:13 People can check out the GitHub repo and it's just a fork of Python, of cPython, and then goes from there, right?

00:17:19 Yeah.

00:17:19 And now Sam is hoping to essentially create a separate mode of cPython that you can enable with a compiler flag,

00:17:27 which would enable new GIL.

00:17:29 So to get his changes merged into the cPython main branch, essentially.

00:17:33 So that would mean you would have to build cPython separately in order to get a version of cPython when no GIL would work.

00:17:41 So it wouldn't be like you'd be able to just open up the repo and go like, import no GIL.

00:17:46 It wouldn't be quite that easy.

00:17:47 Right, right.

00:17:48 It is a bit of a hassle that it's literally a separate compilation step, a separate binary and so on.

00:17:56 But maybe it could ship.

00:17:57 Maybe the cPython distribution, if this really works out well, could be shipped with that.

00:18:03 Like it could be a set of Python or Python 3 or whatever you type.

00:18:08 It could be Python ng or something like that.

00:18:11 You know, like some extra command you can run.

00:18:13 But at least it would be nice at least if you didn't have to literally go find a different installer and try to avoid the name clashes of what Python means, you know?

00:18:21 Yeah.

00:18:21 Yeah, for sure.

00:18:22 And this is a change from his original proposal.

00:18:24 So his original proposal was for a runtime flag.

00:18:27 So that would mean that you would be able to, I don't know.

00:18:30 I don't know how exactly it would work, but do something like import no GIL.

00:18:33 Yeah.

00:18:34 And reading your write up here, it sounded like Sam has come to the conclusion that there's too many differences for a runtime flag to make sense.

00:18:41 And it's got to be a compiled type of thing.

00:18:44 Exactly.

00:18:45 So yeah, that was his proposal.

00:18:47 How was the reception?

00:18:47 There were a lot of questions for Sam.

00:18:50 So I think there were, I think like a few of the other proposal presentations finished under time later on in the summit.

00:18:58 And then we went back and asked some more questions to Sam because we still have questions.

00:19:02 Yeah.

00:19:03 So I think everybody in the room definitely knew.

00:19:06 So like it's crazy.

00:19:07 If you look at the viewing figures for these blogs, like the blog on no GIL is off the charts in terms of how many people have clicked on it and read it.

00:19:17 Interesting.

00:19:18 Okay.

00:19:19 So it's like, the last time I checked, it was like 40,000 people had read the no GIL article and the next highest was 5,000 people.

00:19:26 Wow.

00:19:27 There was a huge amount of interest in this feature and the people in the room knew that there was a huge amount of interest in this feature.

00:19:32 So I think there's a lot of interest in making this work if it can be made to work.

00:19:36 Sure.

00:19:37 But there's just a lot of complications about how to get that.

00:19:40 So there were a lot of people asking what exactly the plan is here because it's this huge project that Sam's been working on for months and months.

00:19:49 And how do you merge that into cPython?

00:19:52 You know, you obviously can't have one PR where you have tens of thousands of lines of code changed all it was.

00:19:58 So how do you split that up?

00:20:00 You know, how do you...

00:20:01 I think Sam was looking for a kind of pre-approval before submitting a PEP.

00:20:07 I think some people were reluctant to...

00:20:09 Right, right.

00:20:09 Just taking the temperature of the room to see if it was just...

00:20:13 Yeah.

00:20:13 If it was welcome or unwelcome, right?

00:20:15 I think the general mood was sort of cautious, if that makes sense.

00:20:18 Yeah.

00:20:18 Like, yes, we'd need to set the plan before we give our stuff.

00:20:23 Yeah.

00:20:23 That was the kind of vibe I got.

00:20:24 Okay.

00:20:24 There was some feedback, like from Barry Warsaw and Itamar Osterker about the impact it might have on third-party libraries.

00:20:32 I think Carol Willing also talked about that because especially these C layers or these native code layers are super common in the data science space, especially.

00:20:41 So, yeah, some conversation about that, right?

00:20:44 Yeah, I think there's a lot of concern about with some features new to the language, for example, with typing was added a few releases back.

00:20:53 I'm very involved with the typing community.

00:20:55 I'm a massive fan of typing.

00:20:57 I am too.

00:20:57 Fan, not involved.

00:20:58 Sure.

00:20:59 But, you know, it's kind of got a little bit of a bad name for itself in some ways because there's some people who go to maintainers and demand that typing to be added or whatever.

00:21:11 Right.

00:21:11 And that's not really felt on the maintainers because everybody's volunteer doing it for free.

00:21:15 It is getting easier because one of the holdups used to be, well, my library is for Python 2 and 3 and I'm not going to maintain two versions and so on and so on.

00:21:26 Right.

00:21:26 So, the typing wouldn't work in Python 2.

00:21:29 At least now we're generally past that holdup.

00:21:32 But still, yeah, it's effort that the person might not want to put out there.

00:21:36 I'm a TypeShed maintainer.

00:21:37 Yeah.

00:21:38 I'm very involved in typing.

00:21:39 So, yeah.

00:21:39 Tell people about TypeShed.

00:21:40 TypeShed's pretty cool.

00:21:41 Oh, sure.

00:21:42 So, TypeShed is the repository of stubs for the standard library and also a bunch of third-party stubs.

00:21:50 So, TypeShed is like the only version of the standard library that mypy knows or Pyright or PyType or any other type checker.

00:21:59 They don't actually know what's going on in real standard library at all.

00:22:04 They only know this bundle of stubs and TypeShed.

00:22:08 They don't feel like I'm explaining it very well.

00:22:09 Yeah.

00:22:09 So, you know, I'll pull it to one for app pairs.

00:22:10 And people, these are not PY files.

00:22:13 These are PYI files.

00:22:15 Yes.

00:22:16 And if you look at them, the implementation is super straight.

00:22:19 Information?

00:22:21 I don't know.

00:22:22 The implementation of all these is super interesting because all the functions are dot, dot, dot.

00:22:27 And the default values are dot, dot, dot.

00:22:29 But what you have is you have function name, variable name, type, return value, type, or class, field type, field type, field type, field type, right?

00:22:40 Yeah.

00:22:40 So, it's like a Python file would like...

00:22:43 Yeah.

00:22:43 I suspect some people don't even know that this is a thing you can do to improve the understanding of editors and stuff, right?

00:22:49 In mypy.

00:22:49 A static type checker will use this information to inform the, like, the errors that's flagging on your file if you use it to check a file.

00:22:57 So, if you import appders in your Python project and you install types appders, then mypy will use the type in some type check to understand, ah, okay, this app does instance has an app name.

00:23:10 Oh, interesting.

00:23:11 To add the address of type checker.

00:23:13 Do you know what the editors do?

00:23:14 Like, does PyCharm already have this information?

00:23:17 Does VS Code already have this information from other sources or behind the scenes?

00:23:22 So, PyCharm...

00:23:22 VS Code does use type checker completely.

00:23:26 PyCharm, I think, mostly uses type checker now.

00:23:29 It was kind of...

00:23:30 They used to have their own way.

00:23:31 Yeah.

00:23:32 I think it was a bit of a journey for them to move to type checker.

00:23:35 I'm not sure if they 100% do yet, but yeah.

00:23:39 Okay.

00:23:39 Yeah, very interesting.

00:23:40 Let's see.

00:23:40 We were talking about the CPython stuff and Mr. Hypermagnetic asked, will CPython ever become Rust Python?

00:23:47 They also pointed out that type, hence, saves lives.

00:23:50 Saves lives.

00:23:51 It's great.

00:23:51 But back to the first question.

00:23:53 Did that come up?

00:23:54 Did Rust ever come up?

00:23:56 My first thought is that's a pretty far bridge, but did it come up?

00:23:59 There is already Rust Python, I think.

00:24:01 You can go and use that if you want.

00:24:03 Sure.

00:24:04 I think it's quite a long way from becoming the default, like default, you know, from becoming the leading version of the reference implementation of Python.

00:24:11 Yeah.

00:24:12 Okay.

00:24:12 We can come back to that in a little bit because it'll circle its way back a little bit.

00:24:16 Yeah.

00:24:16 All right.

00:24:17 We're halfway through the show and we've got one of our items done.

00:24:20 Fantastic.

00:24:20 Yes.

00:24:20 Let's go to the next one.

00:24:21 No, we'll pick up speed as we go.

00:24:23 Yeah.

00:24:23 This next one is a per interpreter gill, which actually has been a little bit around from PEP 684.

00:24:32 And it's still in draft mode from Eric Snow.

00:24:35 And so this also goes back to dealing with the GIL.

00:24:38 And it tries to, instead of remove it, say, well, you know what the GIL does is it makes you have single threaded code.

00:24:44 So what we're going to do is if you want to run a thread, you just start a new sub interpreter in the same process.

00:24:51 And sure, it has a gill, but it's meaningless because there's only one thread per interpreter.

00:24:57 And so it's a way to kind of sidestep that problem, right?

00:25:00 Yeah.

00:25:01 It's kind of funny.

00:25:01 So the first talk is like, yeah, let's get rid of the GIL.

00:25:04 And then Eric comes along and says, but what if we had lots of gill?

00:25:08 The problem is the GIL is shared.

00:25:09 Yeah.

00:25:10 Although we got to rename it if there's a per interpreter GIL.

00:25:13 Yeah.

00:25:14 It's not globally, right?

00:25:15 It should just be a per interpreter ill.

00:25:17 The gill, the g part, the global doesn't make sense anymore.

00:25:20 A pill?

00:25:21 Yeah.

00:25:22 A pill?

00:25:23 Yeah.

00:25:23 That sounds a little bad.

00:25:24 But it's interesting to point out, you know, like you pointed out in your article here, that back in 1997, you know, posted something saying, massive changes for separate thread state management.

00:25:36 All per thread globals are moved to a struct, which is manipulated separately, you know, basically trying to do the same thing.

00:25:44 And it turns out, though, that through another picture that you've got laid out here, there's actually a lot of global state shared across threads and different things, right?

00:25:55 That's the problem.

00:25:55 I think if I understand it correctly.

00:25:57 So, I mean, I'm angry mouth.

00:25:59 It's wrong.

00:26:00 I have had him on the show before, so I'll link to that episode as well.

00:26:03 I think it is possible now to run multiple interpreters within the same process.

00:26:09 But it just doesn't work very well, if I understand correctly.

00:26:11 So, it's like, you know, running to all sorts of problems, which, web safety, and, yeah, various conditions.

00:26:17 Okay.

00:26:18 There we go.

00:26:18 Interesting.

00:26:19 Yeah, so it sounds like he's been working on this for a long time.

00:26:22 I think you opened with a funny quote.

00:26:25 Hopefully, the speaker began.

00:26:27 This is the last time I give a talk on this subject.

00:26:30 He's been working on it since 2014.

00:26:32 Yeah.

00:26:33 I think at the time he gave the talk, he was hoping to get it in for 3.11.

00:26:38 But didn't quite make it.

00:26:39 Yeah, exactly.

00:26:40 So, maybe it'll be 3.12.

00:26:42 Yeah, because 3.11 is already frozen.

00:26:44 Yeah, and it's still in draft mode.

00:26:45 Okay.

00:26:46 So, that's a good one.

00:26:47 People can check that out.

00:26:49 There's a tension between many of these projects in that the optimizations one are making might be complicating the work the others are doing.

00:26:57 Yeah.

00:26:58 And that's also true for the next one here, which actually, I think, is the biggest news of Python 3.11.

00:27:03 I completely agree.

00:27:04 Performance improvements.

00:27:05 Yeah.

00:27:06 Performance improvements for 3.11.

00:27:07 I feel like it's a shame that so many more people read the no-kill one than this one, actually, in a way.

00:27:13 Yeah.

00:27:13 But, you know, I've been watching a C-Python repo.

00:27:15 I know how much work has been going into this.

00:27:17 And I think it's really impressive.

00:27:20 Yeah.

00:27:20 Yeah.

00:27:20 So, essentially, the top-line news from this is Python 3.11 is going to be about 25% faster than Python 3.10.

00:27:29 And this is mainly a result of implementing a PEP by Mark Shannon.

00:27:35 Not sure I can remember the number of the PEP.

00:27:37 It's known as the Shannon plan.

00:27:39 Yeah.

00:27:40 I'm making Python five times faster over five years or something like that by doing, like, this 1.25x per year, which they did it this year.

00:27:48 That's incredible.

00:27:48 The main chunk of this is that there are loads of, like, small optimizations that have gone into this.

00:27:53 But a lot of them have to do with implementing what's called a specializing adaptive interpreter.

00:27:58 Okay.

00:27:58 What does that mean?

00:28:00 What is that?

00:28:00 So, this is essentially an interpreter that monitors your program as it's running and spots if you've got, like, an inefficient bytecode that can do lots of different things.

00:28:14 So, like, maybe it's an add bytecode that could plausibly, I'm almost settling in and get some details wrong here.

00:28:21 But, you know, maybe it could add two lists together or add two ins together.

00:28:25 You know, it's just like a generic add bytecode.

00:28:28 And then the specializing adaptive interpreter will spot, oh, hang on.

00:28:33 Okay, we're in a tight loop here.

00:28:34 Only numbers are being, only ins are being added here.

00:28:37 We can replace this bytecode with a more specialized one, which will do the same thing faster.

00:28:42 Yeah, because there's probably a lot of checks and different types of bits of indirection to let it add strings and lists and so on.

00:28:49 But if you know it's numbers, then just do the number thing without the checks.

00:28:51 Exactly.

00:28:52 So, that's known as quickening.

00:28:53 So, like, as the program's running, specializing adaptive interpreter quickens your code and replaces the bytecode with a more specialized one.

00:29:02 This portion of Talk Python to Me is brought to you by Microsoft for Startups Founders Hub.

00:29:09 Starting a business is hard.

00:29:11 By some estimates, over 90% of startups will go out of business in just their first year.

00:29:16 With that in mind, Microsoft for Startups set out to understand what startups need to be successful and to create a digital platform to help them overcome those challenges.

00:29:25 Microsoft for Startups Founders Hub was born.

00:29:28 Founders Hub provides all founders at any stage with free resources to solve their startup challenges.

00:29:35 The platform provides technology benefits, access to expert guidance and skilled resources, mentorship and networking connections, and much more.

00:29:43 Unlike others in the industry, Microsoft for Startups Founders Hub doesn't require startups to be investor-backed or third-party validated to participate.

00:29:53 Founders Hub is truly open to all.

00:29:56 So, what do you get if you join them?

00:29:57 You speed up your development with free access to GitHub and Microsoft Cloud computing resources and the ability to unlock more credits over time.

00:30:05 To help your startup innovate, Founders Hub is partnering with innovative companies like OpenAI, a global leader in AI research and development, to provide exclusive benefits and discounts.

00:30:15 Through Microsoft for Startups Founders Hub, becoming a founder is no longer about who you know.

00:30:20 You'll have access to their mentorship network, giving you a pool of hundreds of mentors across a range of disciplines and areas like idea validation, fundraising, management and coaching, sales and marketing, as well as specific technical stress points.

00:30:34 You'll be able to book a one-on-one meeting with the mentors, many of whom are former founders themselves.

00:30:39 Make your idea a reality today with the critical support you'll get from Founders Hub.

00:30:44 To join the program, just visit talkpython.fm/founders hub, all one word, no links in your show notes.

00:30:50 Thank you to Microsoft for supporting the show.

00:30:52 Have you heard of Grant Booker's specialist project?

00:30:59 No.

00:30:59 So, if you look that up on GitHub, it's a project that he published a few weeks ago, I think, and it's really cool.

00:31:06 You can see, it's like visualizes the way Python 3.11 will quicken your code that it's running.

00:31:13 So, I'll send you a pass and link.

00:31:15 Yeah, yeah.

00:31:16 Send your link.

00:31:16 Yeah.

00:31:17 Tomer points out that they've been following the faster CPython repository.

00:31:22 And yeah, I'll link to that as well.

00:31:24 You know, Mark Shannon and other stuff.

00:31:26 The ideas for making CPython faster over time and different things.

00:31:30 Yeah.

00:31:31 So, yeah.

00:31:32 Very cool.

00:31:32 Yeah.

00:31:32 So, that does like the ideas hub with all.

00:31:35 Visualizing.

00:31:35 It's specializing adaptive interpreter.

00:31:38 Okay.

00:31:38 Yeah.

00:31:39 All right.

00:31:39 Very interesting.

00:31:40 So, this is the thing.

00:31:42 pip install specialist is a thing you can do.

00:31:44 And then it'll what?

00:31:45 It'll show you like a printout of the code where it's actually found improvements?

00:31:50 Exactly.

00:31:50 So, it'll show you where it's quickened your code and where it's been unable to quicken

00:31:55 your code.

00:31:55 So, I think the green bits here, specialist has, yeah, quickened those bits of code.

00:32:01 But the other bits, it's been like, yeah, don't know what to do here.

00:32:04 Got to leave it.

00:32:05 I said it.

00:32:05 Couldn't do anything.

00:32:06 Yeah.

00:32:06 Yeah.

00:32:06 So, for people listening, if you just pull up the specialist GitHub repository, which

00:32:10 I will put in the show notes, there's a bunch of pictures and colorized code showing you

00:32:15 where Python 3.11 was able to make it faster and where it wasn't.

00:32:18 This is super cool.

00:32:19 I never heard of this.

00:32:21 Yeah.

00:32:21 And this is a project by Brant Booker, who's been one of the major collaborators on the

00:32:28 FasterCPython project.

00:32:29 Right.

00:32:29 Coming from the top.

00:32:30 Yeah.

00:32:30 What also is neat is this is not just for 3.11.

00:32:33 3.11 is the first step.

00:32:35 They're like only halfway through.

00:32:36 Yeah.

00:32:36 3.12 is currently.

00:32:37 It's pretty well funded, too, right?

00:32:39 Like, Microsoft has, I think, a team of six people possibly working with Guido and Mark.

00:32:44 Sounds about right.

00:32:45 And then also Bloomberg has contributed some resources or some help.

00:32:50 Yeah.

00:32:51 Yeah.

00:32:51 It's really got a lot of speed here.

00:32:52 A lot of inertia behind it, I guess I should say.

00:32:55 And speed.

00:32:55 Absolutely.

00:32:56 All right.

00:32:56 This one, actually, I think this is the big news.

00:32:59 I know that it probably didn't make the biggest splash of the headlines, but.

00:33:03 I think it's going to, yeah, because this is going to make everybody's code

00:33:05 faster.

00:33:06 It's not like one small micro-optimization.

00:33:09 It's across the board.

00:33:10 Right.

00:33:11 Yeah.

00:33:11 The threading stuff is very exciting and interesting, but I'm going to go out on LM and say, I think

00:33:16 a lot of people think they need it or they think they want it more than they actually

00:33:20 need it.

00:33:21 So, for example, if you're running a website with APIs and stuff, you know, G Unicorn or

00:33:28 Microwave's Geek or whatever, they all spin out a bunch of worker processes and you can

00:33:32 have several worker processes per core, meaning you're already like saturating every core of

00:33:37 the CPU.

00:33:39 You know, so in those scenarios, it's nice, but it doesn't help that much in terms of, you know,

00:33:43 a lot of stuff that you don't really need the threading.

00:33:45 On the data science side, you might, but at the same time, you often, you're doing the computation

00:33:50 in C or you can use async and await if it's IO bound.

00:33:53 There's a lot of ways where this problem is actually already solved.

00:33:55 It just doesn't feel like it's solved.

00:33:57 And so this one though, this fix it, this makes multi-threaded code faster, single-threaded

00:34:02 code faster.

00:34:03 It's just, it just makes all the code faster, which is great.

00:34:05 This could be a given at a run for the money.

00:34:07 You know, when the listener asked earlier about Rust being the reference implementation

00:34:13 for CPython, well, what is it then?

00:34:15 RPython?

00:34:16 I don't know.

00:34:16 Maybe CPython isn't the name for it anymore.

00:34:18 The reference implementation for Python.

00:34:20 This one here, Python in the browser, could put some pressure to move in that direction.

00:34:25 Right?

00:34:25 So this one has to do with WebAssembly.

00:34:27 Tell us about this.

00:34:28 For a while now, there's been a project called Pyodide, which has been like a third party project,

00:34:33 which has been monkey patching, essentially, CPython to get a version of CPython running in

00:34:39 the browser.

00:34:39 Pyodide has been the basis for several cool projects, which are all sort of just starting to take off

00:34:47 now.

00:34:47 I feel like we've sort of reached this like critical point where it's all the finest of

00:34:52 starting to fit together and make sense.

00:34:54 And over the last two years, Christian Himes, co-developer and contributor Ethan Smith have

00:35:01 been working to upstream loads of these changes that Pyodide has been making to CPython itself,

00:35:08 which would mean that Pyodide doesn't need to monkey patch CPython nearly so much anymore.

00:35:14 And so I think that's actually will just work in the browser, which would be huge.

00:35:18 Yeah, that's fantastic.

00:35:20 There were a bunch of changes made to make this possible.

00:35:22 And I can't remember where in the article you said, but yeah, over 60 PRs.

00:35:27 Yeah.

00:35:28 Yeah.

00:35:28 And a GitHub issue, right?

00:35:29 That's one.

00:35:29 We just like see the numbers.

00:35:31 Consider supporting mscripten slash WebAssembly as a build target.

00:35:35 And guess what?

00:35:36 That's not a thing.

00:35:37 Now you can actually go in and say --with inscripten target equals browser as to compile

00:35:45 CPython.

00:35:45 And that's a big deal.

00:35:47 I think it's going to make it possible to use Python where you would have otherwise used

00:35:52 JavaScript.

00:35:53 For sure.

00:35:53 So I think this is possibly one of the biggest gripes that anybody using Python for web development

00:35:59 has.

00:35:59 And then have to like use JavaScript.

00:36:02 Yeah, people will say sometimes to me that I'm being mean or inconsiderate or something

00:36:07 when I say that we might not want to write in JavaScript.

00:36:10 You're like, why are you hating on JavaScript?

00:36:12 I think the frustration that a lot of people feel in the software industry is not that they

00:36:17 necessarily hate JavaScript, that JavaScript is the only option.

00:36:21 Like there's almost nowhere else in programming where we go, there's one language and one runtime

00:36:26 and that's it.

00:36:27 That's all you get to use, period.

00:36:30 Right.

00:36:30 On the desktop, on embedded, on the web, like on, you know, server side web, like you

00:36:35 can pick tens of languages at least.

00:36:38 Right.

00:36:39 And you pick the one that works well for you and the one you like.

00:36:41 And except for in the browser, everyone is forced to do this one language, which is frustrating.

00:36:46 And so as Python developers, where we like Python, it would be great if we could continue to use

00:36:52 a language that we prefer for things like this.

00:36:55 Right.

00:36:56 Yeah.

00:36:56 And now you can.

00:36:56 And now you can.

00:36:58 There's a few challenges with this.

00:37:00 One is that the WebAssembly binaries are a bit large, not huge.

00:37:04 They're not huge, but they're like five or 10 megs instead of 50k.

00:37:08 So that's a bit of a challenge.

00:37:10 But there's places where this is already highly valuable.

00:37:13 So for example, if you're doing like an Electron JS app, you could write that largely in Python

00:37:19 using this stuff already.

00:37:22 And it doesn't matter because you already downloaded an entire copy of Chrome.

00:37:25 What's another 10 megs?

00:37:27 You know, is it 200 or 205?

00:37:29 Like, I don't care.

00:37:30 It's the same.

00:37:30 Yeah.

00:37:31 I think Simon and Willison might have done that a few weeks ago.

00:37:34 Okay.

00:37:35 I created an Electron JS app with PyScript?

00:37:38 Yeah, I think so.

00:37:39 I'll have to look into that.

00:37:39 That sounds really fantastic.

00:37:40 Let's see.

00:37:42 So this is cool because PyIodide is great, but it's like this sort of project maintain

00:37:48 alongside CPython.

00:37:49 And this is saying the core developers and the team behind Python are allowing you to just

00:37:55 compile a limited version directly, right?

00:37:58 So PyIodide could say build on top of this one and not have to maintain their own copy.

00:38:03 Exactly.

00:38:03 Yeah.

00:38:03 So we do need to be careful here.

00:38:05 Like, it's mscripts in the WebAssembly are not fully supported by CPython yet.

00:38:10 There was a lot of concern about that at the summit.

00:38:11 Like, if we say it's supported now, then it's a big statement to put out there.

00:38:17 So definitely not fully supported yet.

00:38:19 Yeah.

00:38:19 Okay.

00:38:19 Good to point that out.

00:38:20 And there's plenty of things that are not supported because they're probably not just

00:38:25 haven't, they're not ready.

00:38:26 Some things that will never, ever be supported.

00:38:29 Like TK Enter support is probably never coming to the browser.

00:38:32 Yeah.

00:38:33 You know what I mean?

00:38:34 Or other things that are not permitted by the browser's sandboxing rules and so on.

00:38:39 Anything that can be run in the browser needs to be extremely security conscious because

00:38:44 nobody expects to have arbitrary code execution on the browser.

00:38:47 It sounds very, very suspicious.

00:38:49 Like, you're going to let me run binary code in the browser, but it's subjected to exactly

00:38:53 the same rules as JavaScript.

00:38:55 And JavaScript gets JIT compiled to binary code and then run anyway.

00:38:58 It just feels better that it's like, oh, here's a script.

00:39:00 It's like, no, it's the same thing.

00:39:02 So very cool.

00:39:03 I do want to just point out, give a quick shout out to PyScript, which you also did in

00:39:07 your article.

00:39:08 This is super exciting.

00:39:09 This takes it and makes it way, way more real.

00:39:11 This is where you really do put Python in the browser.

00:39:14 This is built on top of Pyroidite, I think.

00:39:16 Yep.

00:39:17 Just enables you to embed Python inside an HTML file.

00:39:22 And it just works.

00:39:23 Yes.

00:39:24 Yeah, it works pretty well.

00:39:25 Opening tag, py-script inside an HTML file.

00:39:29 And don't need to download anything.

00:39:31 Yeah.

00:39:32 Pretty incredible.

00:39:32 You can also say source equals app.py in your browser.

00:39:37 And as long as that can be delivered as a static file, it'll pull that up and run.

00:39:41 I just, quick follow up on this.

00:39:43 No, this is a different one.

00:39:44 I'll roll it.

00:39:46 But I do want to point out that I actually, I don't know if people know this.

00:39:49 I did a video called Python PyScript WebAssembly.

00:39:51 And then I actually created an offline progressive web app with it.

00:39:55 So once you've installed this app, it no longer has to download that larger binary.

00:40:02 So if you look at the code, it's like super, super simple.

00:40:05 You can get this cool little offline app.

00:40:07 And it is like launch time, you know, down to one second, maybe one and a half seconds.

00:40:13 And it's just so bizarre to write Python for like JavaScript events.

00:40:18 So you can say like on click equals here's the Python function and all sorts of stuff.

00:40:23 So people can check that out.

00:40:24 I'll link that in the show notes.

00:40:25 This is a really big deal.

00:40:27 This WebAssembly stuff that's coming in.

00:40:29 It's coming from these different angles.

00:40:30 It's coming from Pyodide, from PyScript, from the core developers compiling to WebAssembly.

00:40:35 All of those things are pretty fantastic.

00:40:38 It's really cool to see so many people collaborate on the same thing at once.

00:40:41 From seven different parts of the community.

00:40:43 It's true.

00:40:43 It's happening.

00:40:44 There's two parts where that's happening, right?

00:40:45 In this GIL thing and in the WebAssembly side of things, right?

00:40:49 They're not necessarily coordinating, but they're all working on the same problem.

00:40:53 And surely we'll get some good outcomes from that.

00:40:55 All right.

00:40:56 Let's talk about the Cinder one next.

00:41:00 So this one does come also from Meta and more Instagram, I suppose, directly.

00:41:04 But this comes from the Cinder project.

00:41:07 And this has to do with some of the optimizations.

00:41:09 You want to tell us about this one?

00:41:11 These are essentially async specific optimizations.

00:41:14 So Cinder, for those who don't know, is a performance-oriented fork of CPython.

00:41:20 So the Instagram team essentially were like, we really love Python, but it's a bit too slow for our web servers if we're going to have the whole thing written in Python.

00:41:28 So they forked it and implemented.

00:41:30 There's a ton of different optimizations implemented in Cinder.

00:41:35 Many changes.

00:41:35 Yeah.

00:41:36 There's a ton.

00:41:37 If you check out the Cinder project, there's just a whole list of all these different things.

00:41:41 Some of them have to do with JIT.

00:41:43 Some of them have to do with immortal objects and some have to do with other things as well.

00:41:49 Yeah.

00:41:49 Async IO.

00:41:50 Lazy imports.

00:41:51 Yeah.

00:41:51 Loads of stuff going on.

00:41:53 Yeah.

00:41:53 With all the attention recently on making Python faster, the Cinder team is hopeful that they will be able to get some of their optimizations merged into the main drive to Cpython.

00:42:04 So this presentation was specifically about some of the async specific optimizations that they have been implementing in their fork.

00:42:12 So essentially, the issue is to do with eagerly awaited coroutines.

00:42:19 So if you have coroutine, then generally, if you have a coroutine function, you'll call that function.

00:42:26 It will create this coroutine object.

00:42:27 That coroutine object doesn't do much until you await it.

00:42:31 And then eventually you get the result back.

00:42:33 But that can be inefficient in some situations.

00:42:37 Because if the task being done in the coroutine can just sort of finish immediately, then there's no reason to create that coroutine object.

00:42:46 Right.

00:42:46 And to schedule it and to do all the stuff on the loop and then wait for it.

00:42:50 All of that is just overhead.

00:42:53 What's done in the Cinder fork is they detect when a task can be immediately finished and don't bother correcting the coroutine object in that case.

00:43:03 So let me see if I can come up with an example for people that might make it concrete.

00:43:07 Kind of complicated.

00:43:07 Yeah, no, it is.

00:43:08 But I think once you get this feel for it, it's no problem.

00:43:11 It's not that bad.

00:43:12 Probably bad to implement, but not bad to understand.

00:43:15 So imagine you have an async function that's going to call an API, but you might have an in-memory cache that says, have I already looked this up for this particular argument?

00:43:25 Right.

00:43:25 So your code could say, if this value is in the cache, just return that value.

00:43:30 Otherwise, await HTTPX get da-da-da-da-da.

00:43:33 Right.

00:43:34 So that first case where you call something that's in the cache, by default in Python now, it's going to still schedule that on the loop and it's going to make it run on the loop and wait for all that to happen in this inefficient way.

00:43:46 So the optimization is like run it as a regular function until you hit an await and then go through that process.

00:43:53 Something like that, right?

00:43:54 I think so.

00:43:55 That's my understanding.

00:43:56 And people can send me messages and let me know I got it wrong.

00:43:59 But I think that's the basic idea.

00:44:00 There's scenarios where, in my case, if it's in the cache, it doesn't ever really need to be treated as a async coroutine ever.

00:44:08 You just get the value back like a regular function.

00:44:10 But if it goes past that, then it does need to be one.

00:44:12 And that's the distinction, I think.

00:44:14 Okay, cool.

00:44:15 So there's actually a lot of improvements and performance things coming from the Cinder project.

00:44:19 There's this one, but there was also the lazy imports, right?

00:44:23 PEP 690 and that one and so on.

00:44:25 On discuss.python.org, there's been a, I think a discussion has reached to over 100 comments now on lazy imports.

00:44:32 So if you have views, that is where to send them.

00:44:37 Absolutely.

00:44:37 That's a whole different proposal where you could, we should introduce an API to enable or disable lazy imports.

00:44:45 So with lazy imports enabled.

00:44:47 So at the moment, all imports in Python are eager.

00:44:50 So if you type in import functools at the top of a file, it will execute the entire functools module and then put a reference to that module in your file for you.

00:45:01 Whereas with lazy imports enabled, it would see the import functools statement.

00:45:05 It'd be like, meh, not going to do anything with that.

00:45:07 And then wouldn't actually import the module until the first time functools was referenced later on down the file.

00:45:13 Right.

00:45:13 Because the problem is there's a cost for doing an import.

00:45:16 It's not like a hash include, which might be a compile time thing.

00:45:20 There's an actual runtime cost for every import.

00:45:23 So PEP 8 says all the imports go at the top to keep them orderly.

00:45:27 But if there's many apps that might or might not use some import, depending on what part of it runs.

00:45:34 Right.

00:45:35 Yeah.

00:45:35 And so if you could delay that, that expense only if you use it, that would be great.

00:45:40 And this can have a major impact on startup time for Python CLI apps.

00:45:44 Yeah.

00:45:44 Especially.

00:45:45 Yeah.

00:45:45 Yeah.

00:45:45 The one that we were talking about is this ASIC optimization.

00:45:48 So that's the one that was actually covered, but it's just one of the things coming out of Cinder, which is cool.

00:45:54 Yes.

00:45:54 And then I think maybe this path forward for immortal objects.

00:45:59 Is that also coming out of Cinder?

00:46:00 Sounds like it.

00:46:01 No, that's another one.

00:46:03 Similar, but not the same.

00:46:04 This is linked to the current up to Gil talk, essentially.

00:46:10 Okay.

00:46:11 This is one of those proposals that's kind of very much in the weeds of how Python is implemented.

00:46:17 So it's a proposal to introduce what's known as immortal objects.

00:46:22 So an immortal object is, well, an object that never dies.

00:46:26 So generally in Python, as we were talking about earlier, objects have a reference count.

00:46:31 And if that reference count reaches zero, then the garbage collector comes along eventually

00:46:36 and deletes it, freeing out memory that was holding that object.

00:46:40 So this path proposes introducing a class of objects where the reference count would never

00:46:45 reach zero, meaning that the object would never be cleaned up by the garbage collector and would

00:46:51 never die.

00:46:51 So this would have the advantage.

00:46:53 Yeah.

00:46:53 Because why are you bothering to like check and check on these objects that you know will

00:46:58 never, ever have any sort of reason to go away?

00:47:01 Right.

00:47:02 So like there's the non-singleton, for example, like it would be quite rare to have a program

00:47:06 that doesn't use none at least once.

00:47:08 Or the number five, which is pre-allocated, right?

00:47:11 As well as the number 200, like the first, the last, the first negative five in the top 255

00:47:18 or something like that.

00:47:19 Yeah.

00:47:19 But nonetheless, Python will like doggedly keep a reference count for these objects and

00:47:25 like track where they are.

00:47:27 Yeah.

00:47:28 So for a lot of these, yeah, pre-allocated object numbers, in terms strings, the empty

00:47:35 tubal, I think is also singleton, the non-singleton.

00:47:39 These would all become immortal objects if this path accepted.

00:47:43 And that would, I think in the short term, make Python a little bit slower, probably.

00:47:48 So I think a naive implementation makes it slower by around 6%.

00:47:52 But with mitigations, you can make it so that performance impacted is marginal.

00:47:58 But then if you do implement immortal objects, there's, it makes things like a paratexta

00:48:04 GIL easier.

00:48:05 It might also simplify no gill, I think.

00:48:07 Yeah, probably.

00:48:08 Because once you know something's immortal and probably also immutable, then you can share

00:48:14 it all you want.

00:48:14 Yeah.

00:48:15 Exactly.

00:48:15 Yeah.

00:48:16 So you don't have to worry about.

00:48:17 Yeah.

00:48:17 Yeah.

00:48:17 So some of that state that's really hard to create one per interpreter, you're just like,

00:48:21 well, it doesn't change.

00:48:22 So here it is.

00:48:23 Yeah.

00:48:24 You don't have to check it either.

00:48:24 Yeah.

00:48:25 Cool.

00:48:25 It just kind of makes sense when you think about it in a way, I think.

00:48:29 You know, like, why would you track the reference counts for all of these objects?

00:48:32 Exactly.

00:48:33 You know, like, true and false are never going to be gone.

00:48:35 So just forget it.

00:48:36 Just leak that memory or whatever, right?

00:48:39 Yeah.

00:48:39 Yeah.

00:48:40 All right.

00:48:40 Let's see.

00:48:40 What else we got to cover here?

00:48:42 Maybe the issues and PR backlog?

00:48:44 Sure.

00:48:45 It's one of the, I think that's the longest one.

00:48:47 Okay.

00:48:47 Yeah.

00:48:47 This is a pretty interesting aspect because it has to do with the developer in residence

00:48:52 and Lucas Lange and all the improvements that having somebody dedicated to that role has

00:48:57 brought, right?

00:48:58 There are a lot of open issues and open PRs on CPython.

00:49:01 But this talk was actually kind of taking a step back and looking philosophically about

00:49:07 it and sort of saying, well, what is an issue for?

00:49:10 You know, why there's all these issues.

00:49:13 Some of them haven't had activity on them for five years or whatever.

00:49:17 Like, why is that issue still open?

00:49:19 Like, what is that doing for us really?

00:49:21 And also, I guess, really quick shout out.

00:49:23 This is from Edreet Catrail.

00:49:25 Yes.

00:49:25 This talk.

00:49:26 So I think it's like two perspectives, right?

00:49:29 You see the person who, when they open their phone at the bottom, it has 26,214 unread messages.

00:49:36 The first is inbox zero.

00:49:38 Like, you know, it's like, well, if we can't close this issue and we can't deal with it within

00:49:44 five years, it's just friction.

00:49:46 That's one side of the argument, I suspect, is it's friction.

00:49:50 The other people are like, well, this is history.

00:49:51 Yeah.

00:49:51 Historical friction.

00:49:52 What do we do about it?

00:49:53 Sahih Spachaka, one of the most prolific SuperIcon core developers who's contributed more to

00:49:59 SuperIcon, like I'd say.

00:50:00 You're sort of saying, well, you know, sometimes I do come back to issues after five years.

00:50:05 I do.

00:50:06 I am planning on working on it, but I'm working on a lot of things and have hundreds of local

00:50:11 branches and I'm working on loads of things at once.

00:50:14 And sometimes I forget about something for five years and then come back to it, which is

00:50:17 totally fair.

00:50:18 It is fair.

00:50:19 But I don't think like one person isn't going to fix all of those issues.

00:50:23 You know, when you've got, how many is it now?

00:50:26 See, six, over 6,500 open issues on the CPython repo.

00:50:30 Yeah.

00:50:30 Yeah.

00:50:31 I don't know how I actually fall on this.

00:50:33 I mean, on one hand, I totally get that you want to keep it around.

00:50:37 On the other, if it was something really important, it would probably resurface again anyway.

00:50:42 You know what I mean?

00:50:43 Like...

00:50:44 No, I completely get that.

00:50:44 I think at the moment, my personal opinion is we do have too many open issues at the moment.

00:50:49 And a lot of them just aren't ever going to have...

00:50:52 Either aren't going to get fixed or like, if they are going to get fixed, it's not because

00:50:55 of the issue being open.

00:50:56 Like somebody else will just come along and be like, I'm going to fix this now.

00:51:00 It's on GitHub now.

00:51:01 You could apply a tag to it like closed due to old age or something.

00:51:05 Yeah.

00:51:06 And then just close them.

00:51:06 They can be reopened.

00:51:08 People could go, well, I really want to see all the ones that were closed due to old age,

00:51:11 plus the ones that are open.

00:51:12 You know, just create a search that shows that view.

00:51:16 Somebody's really bored and is like, I really want to fix some Tkintered feature requests

00:51:21 20 years ago.

00:51:22 We can scroll through those.

00:51:25 Yeah.

00:51:27 Yeah, for sure.

00:51:28 Okay.

00:51:29 It's an interesting conversation and discussion and what to think about, but it's not something

00:51:33 that directly affects people.

00:51:35 Like that's the perfect kind of thing that's like handled at this meeting, right?

00:51:39 Because it's really about those folks.

00:51:40 Yeah.

00:51:40 Yeah.

00:51:41 All right.

00:51:41 The final one, the F string grammar.

00:51:43 We got f-strings in Python 3.6 and it's one of the most popular languages added recently,

00:51:48 language features.

00:51:49 Everyone loves it.

00:51:51 I've heard people upgrading to 3.6 and beyond or throwing away old versions just so they can

00:51:55 write f-strings, which is great.

00:51:57 But it turns out that the actual parser for f-strings is kind of insane.

00:52:01 I had no idea.

00:52:02 Tell us about that.

00:52:03 I think it was how many lines of code is it?

00:52:05 I think it wrote it in the article.

00:52:06 1,400 lines of custom C parser code just for f-strings that's separate from the regular parser.

00:52:14 This whole file is just manually handwritten C code to parse f-strings.

00:52:19 And Pablo brought up this crazy slide on that.

00:52:22 This talk is by Pablo.

00:52:24 And the Salgado.

00:52:25 He is a core developer, steering council member, and lead manager for Python 3.10 and 3.11.

00:52:32 So this is his big project.

00:52:35 So yeah, Pablo brought up this crazy slide showing the dance that the interpreter has to go to

00:52:42 whenever it encounters an F string.

00:52:44 It's like a passed.

00:52:46 It sounds really tricky to figure out because you've got all the captured variables.

00:52:50 You've got to figure out how to pass those over.

00:52:52 Then it goes to the parser and it's like, oh, geez.

00:52:54 Okay.

00:52:54 Yeah.

00:52:55 So what is the idea?

00:52:56 The idea is to make this part of the regular parser?

00:52:58 Just move this over to bring it into the peg parser and all those kinds of things.

00:53:02 Okay.

00:53:03 Yeah.

00:53:03 So since Python 3.9, Python has had a generated parser.

00:53:08 So you just write all the grammar rules down in this file according to a mini language for

00:53:16 the grammar.

00:53:16 And then the program will generate a very large C file to parsing Python according to those

00:53:23 rules.

00:53:23 So it's a much nicer way of doing things.

00:53:26 It's much less error prone.

00:53:28 Just generate all the C code instead of writing it all out.

00:53:32 And so Pablo's big idea is, yeah, let's just move all this F string parsing into the grammar.

00:53:37 Do it all at the same time as that.

00:53:39 Be much cleaner.

00:53:41 It's nicer to maintain.

00:53:43 And it also has some exciting things for users.

00:53:48 It will mean that the code team will be able to do some big work on improving error messages,

00:53:53 for example, for f-strings.

00:53:55 It's currently quite hard to do because if you touch one corner of this C file, it could have

00:54:01 a chain reaction to the rest of it and cause you 10 bugs and nobody wants that.

00:54:04 Yeah, that's great.

00:54:05 That's one of the other areas of focus there has been lately on improving error messages.

00:54:09 That's good.

00:54:10 Yeah.

00:54:11 310 had improvements just in general for error messages.

00:54:14 Yeah.

00:54:14 Maybe that also comes from the peg parser, right?

00:54:16 Like maybe that's related.

00:54:17 If like the peg parser already has better error messages and you can get this into the peg parser,

00:54:21 it'll just bring along better error messages more easily.

00:54:24 So the peg parser is smarter than the old parser has.

00:54:26 So like the old parser couldn't like look back when it encountered the syntax error, essentially.

00:54:32 So like if it encountered the syntax error, it would just kind of throw up its hands and die on you.

00:54:37 Whereas the new parser is able to catch the syntax error and then kind of look around context

00:54:43 and then give you a better message using that context, essentially.

00:54:47 That's great.

00:54:48 Yeah.

00:54:48 Yeah, yeah, sure.

00:54:48 I think that pretty much covers it.

00:54:50 Anything else you want to mention to people about the Language Summit?

00:54:54 You wrote it up pretty well, I think, but there's something else not in there.

00:54:57 Pythons.blogspot.com.

00:54:59 It's the address if you want to read that.

00:55:02 Yeah, for sure.

00:55:02 I'll put the article in the show notes.

00:55:04 I think we've pretty much covered everything.

00:55:05 We've covered a lot anyway.

00:55:06 Yeah, we have covered a lot, Alex.

00:55:08 That's great.

00:55:09 All right.

00:55:09 Well, thanks for all of this and all your work on the other things as well.

00:55:13 Before we get out of here, let me ask you the final two questions.

00:55:15 If you're going to write some Python code, be it 312 or something new or older,

00:55:20 what editor are you using?

00:55:21 I'm actually using Idle quite a lot these days.

00:55:24 Yeah, right on.

00:55:24 I've used Pyjarm for a while.

00:55:26 I've tried out VS Code several times.

00:55:27 I've never really got on with it.

00:55:29 I'm not quite sure why.

00:55:30 Yeah.

00:55:30 I loved all the features Pyjarm had, but nowadays I'm just enjoying something that just starts

00:55:35 up really quickly.

00:55:36 And it's just really simple.

00:55:37 Something simple.

00:55:38 All right, cool.

00:55:39 Yeah.

00:55:39 And then notable PyPI package or library, something you want to give a shout out to?

00:55:44 I mean, we kind of sort of did that in a meta sense with TypeScript or TypeShed, rather.

00:55:48 Yeah, am I allowed to shout out my own package?

00:55:51 You can shout out whatever you want.

00:55:52 Absolutely.

00:55:54 I'll just give another shout out to Specialist, I think.

00:55:57 I think that's really cool.

00:55:58 Yeah, Specialist is neat.

00:56:00 I'm glad I learned about that today.

00:56:02 That's cool.

00:56:02 All right.

00:56:03 Well, I can seem magnanimous by shouting out somebody else's project.

00:56:06 There you go.

00:56:08 All right.

00:56:08 Well, thanks for doing the write-up.

00:56:10 Thanks for taking good notes and sharing it with everyone.

00:56:12 Because while it makes total sense that the Language Summit is this closed-door story where

00:56:19 people can have open conversations and just keep it amongst the core developers, I know

00:56:24 everyone in the community really appreciates having a sense of what's coming, where the focus

00:56:28 is, what people are worried about, and so on.

00:56:30 So thanks for getting that out in the light for us.

00:56:33 Yeah, no worries.

00:56:34 It was fun to do.

00:56:35 Yeah.

00:56:35 Really fun to have this conversation.

00:56:36 Yeah, you bet.

00:56:37 Thanks.

00:56:37 Awesome.

00:56:38 Thanks, man.

00:56:38 This has been another episode of Talk Python to Me.

00:56:42 Thank you to our sponsors.

00:56:44 Be sure to check out what they're offering.

00:56:45 It really helps support the show.

00:56:47 If you can browse the web, you can create sophisticated tests with Reflect.

00:56:52 Navigate to your site within Reflect's simulated browser and perform actions you want to test.

00:56:56 Let Reflect handle the painstaking work of test creation and maintenance.

00:57:00 Sign up and get a free t-shirt at talkpython.fm/reflect.

00:57:04 Starting a business is hard.

00:57:07 Microsoft for Startups Founders Hub provides all founders at any stage with free resources

00:57:13 and connections to solve startup challenges.

00:57:15 Apply for free today at talkpython.fm/foundershub.

00:57:20 Want to level up your Python?

00:57:21 We have one of the largest catalogs of Python video courses over at Talk Python.

00:57:26 Our content ranges from true beginners to deeply advanced topics like memory and async.

00:57:31 And best of all, there's not a subscription in sight.

00:57:33 Check it out for yourself at training.talkpython.fm.

00:57:37 Be sure to subscribe to the show.

00:57:38 Open your favorite podcast app and search for Python.

00:57:41 We should be right at the top.

00:57:42 You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

00:57:52 We're live streaming most of our recordings these days.

00:57:55 If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

00:58:03 This is your host, Michael Kennedy.

00:58:05 Thanks so much for listening.

00:58:06 I really appreciate it.

00:58:07 Now get out there and write some Python code.

00:58:09 Thank you.

00:58:09  Thank you.

00:58:30 Thank you.

