WEBVTT

00:00:00.000 --> 00:00:02.480
You've built an awesome set of APIs,

00:00:02.480 --> 00:00:04.440
and now you have a wide array of devices

00:00:04.440 --> 00:00:05.820
and clients using them.

00:00:05.820 --> 00:00:07.440
Congratulations.

00:00:07.440 --> 00:00:09.280
Then you need to upgrade an endpoint

00:00:09.280 --> 00:00:12.280
or make a change that is meaningful in some way.

00:00:12.280 --> 00:00:13.280
Now what?

00:00:13.280 --> 00:00:15.120
That's the conversation I dive into

00:00:15.120 --> 00:00:17.880
over the next hour with Stanislav Samiv.

00:00:17.880 --> 00:00:20.240
We're talking about versioning APIs on this,

00:00:20.240 --> 00:00:23.120
the 450th episode of Talk Python to Me,

00:00:23.120 --> 00:00:25.920
recorded January 8th, 2024.

00:00:25.920 --> 00:00:28.500
(upbeat music)

00:00:31.080 --> 00:00:41.420
Welcome to Talk Python to Me,

00:00:41.420 --> 00:00:43.340
a weekly podcast on Python.

00:00:43.340 --> 00:00:45.140
This is your host, Michael Kennedy.

00:00:45.140 --> 00:00:47.500
Follow me on Mastodon, where I'm @mkennedy,

00:00:47.500 --> 00:00:50.220
and follow the podcast using @talkpython,

00:00:50.220 --> 00:00:52.780
both on fosstodon.org.

00:00:52.780 --> 00:00:54.900
Keep up with the show and listen to over seven years

00:00:54.900 --> 00:00:58.020
of past episodes at talkpython.fm.

00:00:58.020 --> 00:01:00.100
We've started streaming most of our episodes

00:01:00.100 --> 00:01:01.500
live on YouTube.

00:01:01.500 --> 00:01:02.700
Subscribe to our YouTube channel

00:01:02.700 --> 00:01:05.100
over at talkpython.fm/youtube

00:01:05.100 --> 00:01:07.300
to get notified about upcoming shows

00:01:07.300 --> 00:01:08.940
and be part of that episode.

00:01:08.940 --> 00:01:13.380
This episode is sponsored by Neo4j.

00:01:13.380 --> 00:01:16.220
It's time to stop asking relational databases

00:01:16.220 --> 00:01:18.040
to do more than they were made for

00:01:18.040 --> 00:01:21.580
and simplify complex data models with graphs.

00:01:21.580 --> 00:01:23.900
Check out the sample FastAPI project

00:01:23.900 --> 00:01:27.020
and see what Neo4j, a native graph database,

00:01:27.020 --> 00:01:28.140
can do for you.

00:01:28.140 --> 00:01:32.660
Find out more at talkpython.fm/neo4j.

00:01:32.660 --> 00:01:35.220
And it's brought to you by Sentry.

00:01:35.220 --> 00:01:37.100
Don't let those errors go unnoticed.

00:01:37.100 --> 00:01:39.580
Use Sentry like we do here at Talk Python.

00:01:39.580 --> 00:01:42.820
Sign up at talkpython.fm/sentry.

00:01:42.820 --> 00:01:46.260
Stanislav, welcome to Talk Python to Me.

00:01:46.260 --> 00:01:47.260
It's great to have you here.

00:01:47.260 --> 00:01:48.100
- It's good to be here.

00:01:48.100 --> 00:01:49.500
- Yeah, it's good to have you here.

00:01:49.500 --> 00:01:52.620
I wonder what version we're gonna end up shipping

00:01:52.620 --> 00:01:53.760
of this episode.

00:01:53.760 --> 00:01:55.100
(laughing)

00:01:55.100 --> 00:01:55.940
- That's a good question. - We're gonna talk

00:01:55.940 --> 00:01:57.620
about API versions.

00:01:57.620 --> 00:01:59.260
API versions, API versions.

00:01:59.260 --> 00:02:00.780
- It's good to have many of them, you know?

00:02:00.780 --> 00:02:02.700
- Yeah, it's one of those problems that,

00:02:02.700 --> 00:02:05.140
you know, as soon as you create an API

00:02:05.140 --> 00:02:06.780
and people start to use it,

00:02:06.780 --> 00:02:09.180
they don't wanna keep rewriting their code.

00:02:09.180 --> 00:02:13.160
But you need to evolve your API over time

00:02:13.160 --> 00:02:14.420
as it gets new features,

00:02:14.420 --> 00:02:16.420
as maybe more importantly, you realize,

00:02:16.420 --> 00:02:18.820
like, oh, that was a bad choice.

00:02:18.820 --> 00:02:19.820
How do you fix this, right?

00:02:19.820 --> 00:02:22.780
So that's kind of the theme of this episode.

00:02:22.780 --> 00:02:25.500
We're gonna talk about concrete tools

00:02:25.500 --> 00:02:28.020
that you can use to add versioning

00:02:28.020 --> 00:02:31.180
to various API frameworks in Python

00:02:31.180 --> 00:02:32.560
and some of the ideas behind it.

00:02:32.560 --> 00:02:34.500
So, gonna be a ton of fun.

00:02:34.500 --> 00:02:37.100
Let's start, though, with your story.

00:02:37.100 --> 00:02:38.020
Tell us a bit about yourself.

00:02:38.020 --> 00:02:40.780
- Previously, I have been a backend engineer

00:02:40.780 --> 00:02:44.020
for six or even seven years now.

00:02:44.020 --> 00:02:48.860
But recently, I have shifted into infrastructure.

00:02:48.860 --> 00:02:52.380
Right now, I'm a platform engineering tech lead at Monite.

00:02:52.380 --> 00:02:55.820
What I do is I make architectural decisions,

00:02:55.820 --> 00:02:57.320
I mentor the teams,

00:02:57.320 --> 00:03:01.380
I help the teams with Python-specific questions.

00:03:01.380 --> 00:03:04.460
But mostly, I build Python-specific infrastructure,

00:03:04.460 --> 00:03:07.980
and my main job is making our business teams happy.

00:03:07.980 --> 00:03:11.300
I try to do that in my open-source work as well.

00:03:11.300 --> 00:03:13.540
I like to make my own open-source projects.

00:03:13.540 --> 00:03:16.140
I like to contribute to big projects, small projects.

00:03:16.140 --> 00:03:17.940
It's all over the place.

00:03:17.940 --> 00:03:19.580
And we're going to be mentioning one of them today.

00:03:19.580 --> 00:03:21.140
- Yeah, you build a really cool library

00:03:21.140 --> 00:03:23.380
that we're gonna talk about, and that'll be a lot of fun.

00:03:23.380 --> 00:03:24.340
It looks really useful.

00:03:24.340 --> 00:03:27.140
And some other third-party ones as well.

00:03:27.140 --> 00:03:29.220
So, I wanted to ask you a little bit about

00:03:29.220 --> 00:03:30.920
what is the difference between

00:03:30.920 --> 00:03:33.620
being a backend software developer,

00:03:33.620 --> 00:03:35.640
which I think a lot of people get the sense of,

00:03:35.640 --> 00:03:38.700
like building APIs, building the backend,

00:03:38.700 --> 00:03:41.520
at least, aspect of websites and so on,

00:03:41.520 --> 00:03:44.100
versus, say, building infrastructure in Python.

00:03:44.100 --> 00:03:45.300
Like, what are these two worlds?

00:03:45.300 --> 00:03:46.140
How are they the same?

00:03:46.140 --> 00:03:46.960
How are they different?

00:03:46.960 --> 00:03:48.180
- So, when you're building them,

00:03:48.180 --> 00:03:49.980
especially when you're building products,

00:03:49.980 --> 00:03:51.100
it's very similar.

00:03:51.100 --> 00:03:53.460
However, in backend, there is already

00:03:53.460 --> 00:03:56.780
a lot of infrastructure around you.

00:03:56.780 --> 00:03:58.620
There is already a lot of people

00:03:58.620 --> 00:04:01.080
who do portions of your job.

00:04:01.080 --> 00:04:04.020
So, like, there are people who can sell your product.

00:04:04.020 --> 00:04:05.700
There are people who are thinking about

00:04:05.700 --> 00:04:08.700
how to move it forward, how to evolve it.

00:04:08.700 --> 00:04:12.460
There are people who are designing it, thinking about it.

00:04:12.460 --> 00:04:14.000
But when you're a platform engineer,

00:04:14.000 --> 00:04:16.140
you gotta do all of that yourself.

00:04:16.140 --> 00:04:20.820
And also, one big portion of any library framework

00:04:20.820 --> 00:04:23.980
or anything else, any developer tools development,

00:04:23.980 --> 00:04:26.500
is the fact that, unlike an API,

00:04:26.500 --> 00:04:28.660
well, a web API, a REST API,

00:04:28.660 --> 00:04:33.100
which has a very strict sort of interface

00:04:33.100 --> 00:04:34.700
where the developer wouldn't be able

00:04:34.700 --> 00:04:36.420
to use it in a million ways,

00:04:36.420 --> 00:04:39.180
a library, especially in a language

00:04:39.180 --> 00:04:41.340
as introspectable as Python,

00:04:41.340 --> 00:04:43.880
the developers can do crazy things with your stuff.

00:04:43.880 --> 00:04:47.300
So, you gotta think forward for all of these use cases,

00:04:47.300 --> 00:04:50.380
and you gotta be sure that you don't expose

00:04:50.380 --> 00:04:51.820
extra private interfaces,

00:04:51.820 --> 00:04:53.820
because once you do expose them,

00:04:53.820 --> 00:04:56.540
it won't be nice to break them in the future.

00:04:56.540 --> 00:04:59.740
- I guess it's a little more restricted with APIs

00:04:59.740 --> 00:05:01.940
than it is with handing out packages, right?

00:05:01.940 --> 00:05:05.140
'Cause people, they can just dive into the packages

00:05:05.140 --> 00:05:05.980
and do whatever you want.

00:05:05.980 --> 00:05:07.740
And the API is more or less limited

00:05:07.740 --> 00:05:10.540
by what the website's willing to process, right?

00:05:10.540 --> 00:05:12.420
- Yep. - On the flip side,

00:05:12.420 --> 00:05:13.860
you have code on the internet,

00:05:13.860 --> 00:05:16.220
and anytime you have code on the internet,

00:05:16.220 --> 00:05:17.760
that's always a little stressful, right?

00:05:17.760 --> 00:05:20.600
Just like, whatever's out there, it's incredible

00:05:20.600 --> 00:05:23.000
if you have a website, you pull up the logs,

00:05:23.000 --> 00:05:26.000
how much abuse your website is taking constantly.

00:05:26.000 --> 00:05:27.040
- True. (Gene laughs)

00:05:27.040 --> 00:05:28.760
The great thing about building packages

00:05:28.760 --> 00:05:30.020
is that you're not worried

00:05:30.020 --> 00:05:31.520
about what happens with them after,

00:05:31.520 --> 00:05:34.520
you just give 'em, and then if it breaks,

00:05:34.520 --> 00:05:38.320
it's not you, it's not on your servers, hopefully.

00:05:38.320 --> 00:05:39.640
But also, as I mentioned,

00:05:39.640 --> 00:05:43.080
you gotta both be its designer, you gotta sell it,

00:05:43.080 --> 00:05:45.720
you gotta people do that, you gotta document it.

00:05:45.720 --> 00:05:47.240
You gotta, as a platform engineer,

00:05:47.240 --> 00:05:50.120
you do all of the parts that backend engineers

00:05:50.120 --> 00:05:51.680
are distracted away from,

00:05:51.680 --> 00:05:55.280
or at least in most bigger companies, distracted away from.

00:05:55.280 --> 00:05:56.580
- Yeah, super interesting.

00:05:56.580 --> 00:05:59.360
All right, let's talk about, I guess,

00:05:59.360 --> 00:06:02.400
one more thing for your introduction before we move on.

00:06:02.400 --> 00:06:05.480
You've worked on quite a few interesting projects here,

00:06:05.480 --> 00:06:07.760
so maybe give us just a little bit of background

00:06:07.760 --> 00:06:09.180
on some of your open-source work.

00:06:09.180 --> 00:06:12.080
- I'll just talk about, I guess, the most popular ones.

00:06:12.080 --> 00:06:14.360
The coolest one was PathWalk.

00:06:14.360 --> 00:06:16.480
If you remember, in Python, there is oswalk,

00:06:16.480 --> 00:06:20.040
but then in Python 3.12, I added PathWalk.

00:06:20.040 --> 00:06:23.160
I have also added the type-ins for that into TypeShed,

00:06:23.160 --> 00:06:24.920
I think some other things,

00:06:24.920 --> 00:06:28.960
and I am, I think, top 10 contributor of Tortoise ORM,

00:06:28.960 --> 00:06:33.960
the asynchronous ORM that claims to be the fastest,

00:06:33.960 --> 00:06:36.520
or at least one of the fastest in Python.

00:06:36.520 --> 00:06:38.240
And a few smaller projects,

00:06:38.240 --> 00:06:40.720
which I don't think there is anything

00:06:40.720 --> 00:06:43.340
particularly fun to talk about there.

00:06:43.340 --> 00:06:46.120
It's just mostly bug fixes and small features.

00:06:46.120 --> 00:06:48.040
But then my other projects,

00:06:48.040 --> 00:06:50.520
the ones that I maintain, are way cooler.

00:06:50.520 --> 00:06:52.880
For example, Bidentic Duality enables you

00:06:52.880 --> 00:06:57.280
to have multiple versions of your Bidentic models

00:06:57.280 --> 00:06:59.800
for almost free in terms of performance

00:06:59.800 --> 00:07:02.960
and without any code generation.

00:07:02.960 --> 00:07:05.740
And CADWIN, the project we're going to be discussing today,

00:07:05.740 --> 00:07:08.560
implements, I guess, the fullest

00:07:08.560 --> 00:07:11.360
and most sophisticated API versioning paradigm

00:07:11.360 --> 00:07:12.600
there is at this point.

00:07:12.600 --> 00:07:13.440
- Excellent, yeah.

00:07:13.440 --> 00:07:15.060
- A lot of cool stuff. - Bidentic Duality looks,

00:07:15.060 --> 00:07:17.680
yeah, Bidentic Duality looks really, really cool.

00:07:17.680 --> 00:07:19.480
So a lot of neat stuff here.

00:07:19.480 --> 00:07:21.800
A lot of different ways people might know about you.

00:07:21.800 --> 00:07:23.040
So yeah, CADWIN's the one

00:07:23.040 --> 00:07:25.280
we're gonna be focusing on for here.

00:07:25.280 --> 00:07:29.340
So let's start with talking about APIs.

00:07:29.340 --> 00:07:32.800
You talked about API-first companies, what's that?

00:07:32.800 --> 00:07:36.600
- API-first company, just like any other term

00:07:36.600 --> 00:07:39.880
that gets popular, is a buzzword, obviously.

00:07:39.880 --> 00:07:44.360
But the truth behind it is an API-first company

00:07:44.360 --> 00:07:47.720
is any company whose main product is an API

00:07:47.720 --> 00:07:50.000
and the SDKs associated with it.

00:07:50.000 --> 00:07:52.920
And as a result, API-first company

00:07:52.920 --> 00:07:55.840
has to document their API really thoroughly,

00:07:55.840 --> 00:07:57.040
think about their API,

00:07:57.040 --> 00:07:59.720
both the internal one and the external one,

00:07:59.720 --> 00:08:03.400
and take great care of that because it's their main product.

00:08:03.400 --> 00:08:07.400
We have a lot of API-first companies right now,

00:08:07.400 --> 00:08:10.200
but with every year, new industries are joining.

00:08:10.200 --> 00:08:13.840
And if you ever heard of open banking, things like that,

00:08:13.840 --> 00:08:16.080
banks are going to join us soon.

00:08:16.080 --> 00:08:17.680
In some countries, they already have.

00:08:17.680 --> 00:08:21.280
And Monite is doing similar things

00:08:21.280 --> 00:08:24.920
and tries to bring that innovation, that open banking,

00:08:24.920 --> 00:08:27.520
and that API-first approach into banking.

00:08:27.520 --> 00:08:29.880
- Yeah, so the company you work for, Monite,

00:08:29.880 --> 00:08:32.960
they build, you all build APIs

00:08:32.960 --> 00:08:36.280
to basically facilitate other people doing invoicing

00:08:36.280 --> 00:08:38.200
and bill pay in their apps, is that correct?

00:08:38.200 --> 00:08:41.480
- Yeah, you could call us a B2B2B company

00:08:41.480 --> 00:08:45.120
'cause essentially many banks, many marketplaces

00:08:45.120 --> 00:08:48.800
are very outdated in terms of how they handle

00:08:48.800 --> 00:08:50.160
invoicing and payments.

00:08:50.160 --> 00:08:53.720
And we try to take all of that, combine that,

00:08:53.720 --> 00:08:56.760
and offer that as a white label product to them.

00:08:56.760 --> 00:09:00.360
So we do this for them, they integrate with us once,

00:09:00.360 --> 00:09:03.120
and then they forget it was ever a problem.

00:09:03.120 --> 00:09:06.600
They just give our product as their straight to their clients.

00:09:06.600 --> 00:09:08.440
- Yeah, that's excellent.

00:09:08.440 --> 00:09:12.360
So this seems like kind of in that category of API-first.

00:09:12.360 --> 00:09:14.160
- Oh, yes. - Yeah, okay.

00:09:14.160 --> 00:09:17.160
It's cool that you have concrete experience with it,

00:09:17.160 --> 00:09:18.320
right, of course.

00:09:18.320 --> 00:09:20.760
Give us some of the laws.

00:09:20.760 --> 00:09:22.680
We coordinated a little bit beforehand

00:09:22.680 --> 00:09:26.720
and there's some interesting laws for designing good APIs.

00:09:26.720 --> 00:09:30.160
Like one of them is the reverse Conway maneuver,

00:09:30.160 --> 00:09:33.680
which to me sounds like a jujitsu sort of move

00:09:33.680 --> 00:09:34.880
that you might try to pull.

00:09:34.880 --> 00:09:35.920
What is this? - Oh, yes.

00:09:35.920 --> 00:09:39.600
So when you are designing any system,

00:09:39.600 --> 00:09:42.840
you gotta think about the way it's going to end up

00:09:42.840 --> 00:09:45.040
and the laws that are going to govern them.

00:09:45.040 --> 00:09:48.520
And Conway's law is one of the main laws that do that.

00:09:48.520 --> 00:09:51.120
To explain that to people in simple terms,

00:09:51.120 --> 00:09:53.880
if you have four teams designing a compiler,

00:09:53.880 --> 00:09:56.120
you're going to have a four-pass compiler.

00:09:56.120 --> 00:09:59.600
Essentially, the way you set up communications

00:09:59.600 --> 00:10:01.880
within your company, the way you set up your teams,

00:10:01.880 --> 00:10:04.880
your structure is going to be reflected in your product

00:10:04.880 --> 00:10:06.480
and you can't do anything about it.

00:10:06.480 --> 00:10:09.000
You can spend money, you can coordinate people,

00:10:09.000 --> 00:10:12.360
but at some point, Conway's law is going to affect you

00:10:12.360 --> 00:10:14.000
and it's gonna be harsh.

00:10:14.000 --> 00:10:17.160
So one of the ways to go around it

00:10:17.160 --> 00:10:20.040
is to first think of an interface that you wanna provide

00:10:20.040 --> 00:10:22.560
and it applies to anything, not just APIs.

00:10:22.560 --> 00:10:24.760
API is just a really good example of that.

00:10:24.760 --> 00:10:27.520
And then design your company

00:10:27.520 --> 00:10:29.840
and the communications within your company,

00:10:29.840 --> 00:10:31.360
the teams within your company,

00:10:31.360 --> 00:10:35.160
to reflect the interfaces that you wanna get in the end.

00:10:35.160 --> 00:10:36.800
And that's reverse Conway maneuver.

00:10:36.800 --> 00:10:39.280
- Okay, because your code and your APIs

00:10:39.280 --> 00:10:40.680
and all those things are gonna reflect

00:10:40.680 --> 00:10:42.480
your company's structure and culture.

00:10:42.480 --> 00:10:45.200
So instead of having that being implicit,

00:10:45.200 --> 00:10:47.160
make it more explicit by saying,

00:10:47.160 --> 00:10:48.760
well, this is the endpoint that we want,

00:10:48.760 --> 00:10:50.800
the end result that we want,

00:10:50.800 --> 00:10:53.640
how do we work that backwards to end up

00:10:53.640 --> 00:10:55.560
structuring teams or whatever to get this, right?

00:10:55.560 --> 00:10:56.600
- Precisely, yes.

00:10:56.600 --> 00:10:58.600
- Yeah, it is a little bit like jujitsu.

00:10:58.600 --> 00:11:02.640
- But there are more laws that do that.

00:11:02.640 --> 00:11:04.080
Of course, there is REST,

00:11:04.080 --> 00:11:07.160
which I guess not really laws, but principles.

00:11:07.160 --> 00:11:11.400
Which most people, or at least most companies I saw,

00:11:11.400 --> 00:11:13.920
don't really like to follow it to the letter.

00:11:13.920 --> 00:11:17.880
But if you do follow REST,

00:11:17.880 --> 00:11:22.840
if you try to make your API as available as you can

00:11:22.840 --> 00:11:25.000
and as standardized as you can,

00:11:25.000 --> 00:11:26.680
then it's much easier for new people,

00:11:26.680 --> 00:11:28.400
especially junior developers to learn.

00:11:28.400 --> 00:11:30.520
And then that makes it much easier

00:11:30.520 --> 00:11:33.200
for your clients to integrate with you, which is great.

00:11:33.200 --> 00:11:37.680
There are also a few, I guess, more advanced things.

00:11:37.680 --> 00:11:39.920
For example, when you are designing an API,

00:11:39.920 --> 00:11:41.440
when you're doing microservices

00:11:41.440 --> 00:11:43.920
and when you have many services talking to each other,

00:11:43.920 --> 00:11:47.400
which in the end provide your final product

00:11:47.400 --> 00:11:48.560
to your customers,

00:11:48.560 --> 00:11:52.160
a good idea is to omit any internal APIs

00:11:52.160 --> 00:11:53.920
and make all of your APIs,

00:11:53.920 --> 00:11:56.800
or at least the majority of your APIs external.

00:11:56.800 --> 00:12:00.200
That is also one of the things about API-first.

00:12:00.200 --> 00:12:02.320
Once all of your APIs are external,

00:12:02.320 --> 00:12:06.600
it means that your clients will be able to build a product

00:12:06.600 --> 00:12:08.800
that is of similar quality to yours.

00:12:08.800 --> 00:12:11.320
We're using your APIs, using your data,

00:12:11.320 --> 00:12:14.680
which provides them with infinite capabilities of using you,

00:12:14.680 --> 00:12:15.520
which is great.

00:12:15.520 --> 00:12:16.480
- Yeah, that is great.

00:12:16.480 --> 00:12:19.720
It's certainly frustrating when you see,

00:12:19.720 --> 00:12:20.840
it's not on the API level,

00:12:20.840 --> 00:12:23.600
but you see things in like the iOS platform

00:12:23.600 --> 00:12:25.200
or in Windows or wherever,

00:12:25.200 --> 00:12:27.600
you're like, "Why can't I do this?"

00:12:27.600 --> 00:12:30.560
These are private things that either Apple or Microsoft

00:12:30.560 --> 00:12:32.560
or whoever are keeping to themselves

00:12:32.560 --> 00:12:34.760
and clearly are important for building apps,

00:12:34.760 --> 00:12:36.080
but you can't use them.

00:12:36.080 --> 00:12:39.320
So you're suggesting that by having basically

00:12:39.320 --> 00:12:40.880
whatever APIs you need,

00:12:40.880 --> 00:12:42.760
I guess there's probably limits.

00:12:42.760 --> 00:12:45.400
You don't wanna expose, say, your HR API

00:12:45.400 --> 00:12:47.080
if you're not an HR company.

00:12:47.080 --> 00:12:51.480
But in general, having your APIs just be all public,

00:12:51.480 --> 00:12:52.960
it probably makes them better as well

00:12:52.960 --> 00:12:54.960
because they just get so many more use cases.

00:12:54.960 --> 00:12:57.120
They get treated with things like versioning

00:12:57.120 --> 00:12:58.240
and stuff more seriously.

00:12:58.240 --> 00:12:59.280
- Exactly. - Excellent.

00:12:59.280 --> 00:13:02.240
- It's a complex topic that could span,

00:13:02.240 --> 00:13:03.760
we could discuss it for hours.

00:13:03.760 --> 00:13:06.240
Which parts of your API do you make public?

00:13:06.240 --> 00:13:09.240
Which parts of your API do you start versioning?

00:13:09.240 --> 00:13:11.720
And if you're combining your APIs

00:13:11.720 --> 00:13:16.000
using a gateway or a federation, it's a long story,

00:13:16.000 --> 00:13:17.320
but I guess with a federation,

00:13:17.320 --> 00:13:18.960
you wouldn't really make it public.

00:13:18.960 --> 00:13:20.320
- Sure. Let's dive into that a little bit.

00:13:20.320 --> 00:13:22.920
Let's talk about API versioning.

00:13:22.920 --> 00:13:25.320
We know what versioning is in Python.

00:13:25.320 --> 00:13:29.480
We have lock files, we pin the version,

00:13:29.480 --> 00:13:34.280
we might say we're using Pydantic 2.0.5 or whatever it is,

00:13:34.280 --> 00:13:37.120
and that leaves the Pydantic team free

00:13:37.120 --> 00:13:38.400
to do whatever they want,

00:13:38.400 --> 00:13:40.040
and we can trust that our code

00:13:40.040 --> 00:13:41.760
is gonna stay the way it stayed.

00:13:41.760 --> 00:13:43.600
I guess API versioning is that,

00:13:43.600 --> 00:13:46.520
but for web endpoints rather than software

00:13:46.520 --> 00:13:47.840
links to packages, right?

00:13:47.840 --> 00:13:50.240
- It's a little different though in some regards.

00:13:50.240 --> 00:13:53.160
For example, when you're packaging your, I don't know,

00:13:53.160 --> 00:13:56.000
software and you just send it to clients,

00:13:56.000 --> 00:13:59.800
thing is you need to have versions for every single thing.

00:13:59.800 --> 00:14:02.280
For example, if we are doing a bug fix

00:14:02.280 --> 00:14:03.960
and we need to ship that to our clients,

00:14:03.960 --> 00:14:05.840
that is going to be a separate version.

00:14:05.840 --> 00:14:08.760
But in web, when you're hosting it on a server

00:14:08.760 --> 00:14:11.880
and your clients just make requests to your servers,

00:14:11.880 --> 00:14:12.800
you don't need that.

00:14:12.800 --> 00:14:15.920
You don't need to ship bug fixes as separate versions.

00:14:15.920 --> 00:14:16.960
You can just ship them

00:14:16.960 --> 00:14:19.040
because they're not going to break anything for your clients

00:14:19.040 --> 00:14:21.320
and your clients will be able to automatically get them.

00:14:21.320 --> 00:14:23.360
Same goes for minor versions.

00:14:23.360 --> 00:14:25.640
Minor versions that just add features

00:14:25.640 --> 00:14:28.800
don't really need to be for a version on APIs.

00:14:28.800 --> 00:14:31.520
That leaves us with just major versions,

00:14:31.520 --> 00:14:34.320
which is why many companies like Stripe at Monite

00:14:34.320 --> 00:14:38.040
use dates for their versions

00:14:38.040 --> 00:14:39.200
because we don't really need

00:14:39.200 --> 00:14:41.280
all of the power of semantic versioning.

00:14:41.280 --> 00:14:42.120
- Yeah, yeah, sure.

00:14:42.120 --> 00:14:43.840
More calendar versioning,

00:14:43.840 --> 00:14:45.760
because all you really need to say is,

00:14:45.760 --> 00:14:47.800
this one is different than before, right?

00:14:47.800 --> 00:14:48.640
It doesn't--

00:14:48.640 --> 00:14:50.120
Stripe does a lot of interesting things.

00:14:50.120 --> 00:14:54.760
We're going to talk a little bit about what they're up to.

00:14:54.760 --> 00:14:55.600
But you're right.

00:14:55.600 --> 00:14:57.680
When I think about APIs that I've created,

00:14:57.680 --> 00:15:01.240
sometimes I've had other versions, right?

00:15:01.240 --> 00:15:06.240
One of the main areas is in the apps that we have,

00:15:06.240 --> 00:15:08.280
or it's a URL work it does,

00:15:08.280 --> 00:15:10.200
in the apps for consuming the courses, right?

00:15:10.200 --> 00:15:14.400
We had two completely different versions of the app.

00:15:14.400 --> 00:15:17.240
One got completely rewrote it.

00:15:17.240 --> 00:15:20.080
And many of the API endpoints were just fine.

00:15:20.080 --> 00:15:21.920
We could just use them over,

00:15:21.920 --> 00:15:23.040
and it didn't have to change anything.

00:15:23.040 --> 00:15:24.600
But three or four were like,

00:15:24.600 --> 00:15:27.560
you know, this really would be better if it was different.

00:15:27.560 --> 00:15:32.080
And so added like a slash V2 or something in there, right?

00:15:32.080 --> 00:15:33.600
But really, really limited.

00:15:33.600 --> 00:15:35.080
So the thing that's interesting though,

00:15:35.080 --> 00:15:36.840
that you point out here is like,

00:15:36.840 --> 00:15:37.880
until that happened,

00:15:37.880 --> 00:15:41.960
I'd shipped many, many versions of that API.

00:15:41.960 --> 00:15:43.640
And long as the schema didn't change,

00:15:43.640 --> 00:15:47.080
I didn't bother even specifying that it had a version, right?

00:15:47.080 --> 00:15:49.640
It was just like slash course,

00:15:49.640 --> 00:15:51.240
my courses or whatever it is, right?

00:15:51.240 --> 00:15:52.520
Like just give those to me.

00:15:52.520 --> 00:15:54.800
And long as it kept giving the courses back, it was good.

00:15:54.800 --> 00:15:55.640
- That's the thing.

00:15:55.640 --> 00:15:59.040
As long as you extend stuff, it's going to be fine.

00:15:59.040 --> 00:16:00.840
But as you mentioned in the beginning,

00:16:00.840 --> 00:16:02.880
you can't really do that forever.

00:16:02.880 --> 00:16:06.400
At some point, you're going to make wrong design decisions.

00:16:06.400 --> 00:16:09.360
At some point, even if you did everything perfectly,

00:16:09.360 --> 00:16:11.720
you know, your product is just going to evolve.

00:16:11.720 --> 00:16:12.560
It's just going to evolve.

00:16:12.560 --> 00:16:15.000
And then you'll need to use old endpoints

00:16:15.000 --> 00:16:18.560
that alter or, you know, get old data

00:16:18.560 --> 00:16:21.440
and extend them in some breaking ways.

00:16:21.440 --> 00:16:22.720
Of course, there are ways around it.

00:16:22.720 --> 00:16:24.600
You can use API evolution.

00:16:24.600 --> 00:16:27.360
You can just, you know, add fields constantly

00:16:27.360 --> 00:16:29.440
and duplicate the old functionality.

00:16:29.440 --> 00:16:31.240
But after a few of such versions,

00:16:31.240 --> 00:16:33.040
your API will look terrible,

00:16:33.040 --> 00:16:34.920
which is why we use versioning.

00:16:34.920 --> 00:16:38.920
And which is why when your company's main product is an API,

00:16:38.920 --> 00:16:41.120
when you are an API first company,

00:16:41.120 --> 00:16:44.320
you can't do anything without versioning.

00:16:44.320 --> 00:16:46.880
You can live for a short period of time.

00:16:46.880 --> 00:16:48.880
For example, a pre-Series A company,

00:16:48.880 --> 00:16:51.680
I don't think should deal with versioning.

00:16:51.680 --> 00:16:54.680
But then after Series A, after you gather,

00:16:54.680 --> 00:16:56.560
I don't know, 15, 20 clients,

00:16:56.560 --> 00:16:59.320
it will be really hard to survive without versioning.

00:16:59.320 --> 00:17:02.280
- Yeah, and it's a really quick and easy way

00:17:02.280 --> 00:17:05.080
to make loyal customers angry

00:17:05.080 --> 00:17:08.280
by making changes to your API that just start breaking code.

00:17:08.280 --> 00:17:09.560
- Even if you wait for your clients,

00:17:09.560 --> 00:17:11.520
even if you, you know, warn them,

00:17:11.520 --> 00:17:14.640
it's still not nice when you're trying to use some API

00:17:14.640 --> 00:17:17.720
and then every three months or every month,

00:17:17.720 --> 00:17:18.920
it breaks everything.

00:17:18.920 --> 00:17:19.760
You know, you wouldn't like that.

00:17:19.760 --> 00:17:20.600
- Yeah, exactly.

00:17:20.600 --> 00:17:21.440
- Even with a warning.

00:17:21.440 --> 00:17:23.280
- You put in all the work to do the integration.

00:17:23.280 --> 00:17:25.080
You got it working, you tested it.

00:17:25.080 --> 00:17:28.120
Your job is, your product is not the integration.

00:17:28.120 --> 00:17:30.520
The integration facilitates what you're trying to build.

00:17:30.520 --> 00:17:32.920
And every time you got to go back and rewrite that stuff,

00:17:32.920 --> 00:17:34.240
it's not great.

00:17:34.240 --> 00:17:38.360
I was working, I have MailChimp for our newsletter,

00:17:38.360 --> 00:17:40.760
marketing side of stuff, the courses,

00:17:40.760 --> 00:17:42.360
and use them for a long time.

00:17:42.360 --> 00:17:43.240
And I got a message like,

00:17:43.240 --> 00:17:46.920
"Hey, we're retiring this API you're using."

00:17:46.920 --> 00:17:49.600
And their API is dreadful.

00:17:49.600 --> 00:17:52.480
Like their Python library API is dreadful.

00:17:52.480 --> 00:17:55.480
It's like star args, star star KW args,

00:17:55.480 --> 00:17:56.800
you better pass the right things,

00:17:56.800 --> 00:17:59.360
but there's no enforcement or instruction

00:17:59.360 --> 00:18:00.720
about what goes in there, right?

00:18:00.720 --> 00:18:02.880
And so some random dictionary that was going in there

00:18:02.880 --> 00:18:05.880
was no longer right and had to be like recreated.

00:18:05.880 --> 00:18:07.600
So they just decided,

00:18:07.600 --> 00:18:09.000
you know, we're gonna just take different stuff

00:18:09.000 --> 00:18:10.920
and we're just gonna shut down that endpoint.

00:18:10.920 --> 00:18:15.200
And when they did, all of the aspects of my website

00:18:15.200 --> 00:18:16.200
just started breaking.

00:18:16.200 --> 00:18:18.600
Like it wasn't crashing, but just anything around,

00:18:18.600 --> 00:18:19.880
"Hey, put me on your newsletter."

00:18:19.880 --> 00:18:21.480
Like, nope, you couldn't be on the newsletter

00:18:21.480 --> 00:18:23.760
'cause it, you know, people started sending me message,

00:18:23.760 --> 00:18:25.960
"Michael, I'm trying to sign up to be on the newsletter,

00:18:25.960 --> 00:18:28.440
"but it just keeps saying that something went wrong

00:18:28.440 --> 00:18:29.640
"with our site, we're sorry."

00:18:29.640 --> 00:18:31.920
I'm like, "Oh boy, go look."

00:18:31.920 --> 00:18:33.800
And they just turned off that endpoint.

00:18:33.800 --> 00:18:36.600
And it was just like, nope, not doing that anymore.

00:18:36.600 --> 00:18:37.640
And it was super frustrating.

00:18:37.640 --> 00:18:40.440
It took me eight hours to rewrite it

00:18:40.440 --> 00:18:43.600
because like I said, there was no real guidance on like,

00:18:43.600 --> 00:18:44.960
"Oh, you just pass the dictionary."

00:18:44.960 --> 00:18:46.960
Like, well, what goes in the dictionary?

00:18:46.960 --> 00:18:49.800
You know, it was like some word of one of the keys change.

00:18:49.800 --> 00:18:51.960
I was so, it just took forever, it was frustrating.

00:18:51.960 --> 00:18:54.440
So what we're gonna talk about here

00:18:54.440 --> 00:18:57.520
is a lot about how do you not do,

00:18:57.520 --> 00:18:59.280
how do you not pull a MailChimp?

00:18:59.280 --> 00:19:02.120
How do you set it up so that your code keeps running?

00:19:02.120 --> 00:19:04.560
You know, the reason why they did that is they're like,

00:19:04.560 --> 00:19:06.680
"Well, we feel like we wrote it wrong before.

00:19:06.680 --> 00:19:09.480
"We wanna fix those to make it better,

00:19:09.480 --> 00:19:11.400
"but we don't wanna maintain two versions."

00:19:11.400 --> 00:19:12.480
That's probably the heart of it.

00:19:12.480 --> 00:19:13.520
- And that's a sane idea.

00:19:13.520 --> 00:19:18.080
- It is, until you have half a million users of the old API.

00:19:18.080 --> 00:19:19.920
And how many of those, like, so for me,

00:19:19.920 --> 00:19:20.960
yeah, I was frustrated.

00:19:20.960 --> 00:19:21.800
Yeah, I'm like, "All right, well,

00:19:21.800 --> 00:19:23.880
"I had plans today for constructive work,

00:19:23.880 --> 00:19:26.000
"but I didn't go rewrite what I did four years ago.

00:19:26.000 --> 00:19:27.760
"And then I'll do something again tomorrow."

00:19:27.760 --> 00:19:30.320
But okay, that's like a pretty good outcome.

00:19:30.320 --> 00:19:32.960
A more common outcome is probably,

00:19:32.960 --> 00:19:35.440
I hired a consultant to build me an app

00:19:35.440 --> 00:19:38.000
and integrate MailChimp, and they're gone.

00:19:38.000 --> 00:19:41.440
And now my thing that I built a year ago doesn't even work.

00:19:41.440 --> 00:19:43.320
And I don't have the skills.

00:19:43.320 --> 00:19:44.920
I gotta go hire somebody again

00:19:44.920 --> 00:19:46.720
to dig back in there and fix it, right?

00:19:46.720 --> 00:19:48.600
Like, that would be really frustrating.

00:19:48.600 --> 00:19:49.440
- Yeah, that's crazy.

00:19:49.440 --> 00:19:52.480
And it could be devastating to some clients,

00:19:52.480 --> 00:19:54.560
especially if the changes are huge,

00:19:54.560 --> 00:19:56.360
especially if it's not just a single endpoint,

00:19:56.360 --> 00:19:58.840
or if there is only one endpoint

00:19:58.840 --> 00:20:02.320
and it does a lot of things, then, oh my God, it's scary.

00:20:02.320 --> 00:20:03.400
- It is, it is.

00:20:05.160 --> 00:20:06.720
This portion of Talk Python to Me

00:20:06.720 --> 00:20:09.240
is brought to you by Neo4j.

00:20:09.240 --> 00:20:10.760
Do you know Neo4j?

00:20:10.760 --> 00:20:13.720
Neo4j is a native graph database.

00:20:13.720 --> 00:20:16.440
And if the slowest part of your data access patterns

00:20:16.440 --> 00:20:18.600
involves computing relationships,

00:20:18.600 --> 00:20:21.680
why not use a database that stores those relationships

00:20:21.680 --> 00:20:23.440
directly in the database,

00:20:23.440 --> 00:20:25.600
unlike your typical relational one?

00:20:25.600 --> 00:20:27.680
A graph database lets you model the data

00:20:27.680 --> 00:20:29.160
the way it looks in the real world,

00:20:29.160 --> 00:20:32.560
instead of forcing it into rows and columns.

00:20:32.560 --> 00:20:35.080
It's time to stop asking a relational database

00:20:35.080 --> 00:20:36.640
to do more than they were made for

00:20:36.640 --> 00:20:40.440
and simplify complex data models with graphs.

00:20:40.440 --> 00:20:42.360
If you haven't used a graph database before,

00:20:42.360 --> 00:20:44.640
you might be wondering about common use cases.

00:20:44.640 --> 00:20:45.960
You know, what's it for?

00:20:45.960 --> 00:20:47.160
Here are just a few.

00:20:47.160 --> 00:20:51.560
Detecting fraud, enhancing AI, managing supply chains,

00:20:51.560 --> 00:20:54.520
gaining a 360 degree view of your data,

00:20:54.520 --> 00:20:57.960
and anywhere else you have highly connected data.

00:20:57.960 --> 00:21:00.440
To use Neo4j from Python,

00:21:00.440 --> 00:21:03.720
it's a simple pip install Neo4j.

00:21:03.720 --> 00:21:04.920
And to help you get started,

00:21:04.920 --> 00:21:06.800
their docs include a sample web app

00:21:06.800 --> 00:21:10.840
demonstrating how to use it both from Flask and FastAPI.

00:21:10.840 --> 00:21:12.640
Find it in their docs or search GitHub

00:21:12.640 --> 00:21:15.560
for Neo4j movies application quick start.

00:21:15.560 --> 00:21:17.800
Developers are solving some of the world's

00:21:17.800 --> 00:21:19.680
biggest problems with graphs.

00:21:19.680 --> 00:21:20.680
Now it's your turn.

00:21:20.680 --> 00:21:25.280
Visit talkpython.fm/neo4j to get started.

00:21:25.280 --> 00:21:29.160
That's talkpython.fm/neo, the number four,

00:21:29.160 --> 00:21:30.160
and the letter J.

00:21:30.160 --> 00:21:33.080
Thank you to Neo4j for supporting Talk Python to Me.

00:21:33.080 --> 00:21:38.040
Before we move on to maybe some of the approaches,

00:21:38.040 --> 00:21:40.720
Alex, Alexia out in the audience says,

00:21:40.720 --> 00:21:41.840
"One more law.

00:21:41.840 --> 00:21:43.380
"Hiram's law is also great.

00:21:43.380 --> 00:21:45.620
"With sufficient number of users of an API,

00:21:45.620 --> 00:21:48.620
"it does not matter what you promise in the contract.

00:21:48.620 --> 00:21:50.720
"All observable behaviors of your system

00:21:50.720 --> 00:21:53.240
"will be depended on by somebody."

00:21:53.240 --> 00:21:56.760
- It is one of my favorite laws about any system.

00:21:56.760 --> 00:21:58.000
- That's true.

00:21:58.000 --> 00:22:00.480
- It is very true, and it's a scary law, you know,

00:22:00.480 --> 00:22:03.480
because at some point, you'll have to version everything,

00:22:03.480 --> 00:22:07.200
which is why it's a good idea to make things,

00:22:07.200 --> 00:22:10.800
you know, I guess, to describe all the behaviors

00:22:10.800 --> 00:22:14.840
and to try to handle all of the possible behaviors early

00:22:14.840 --> 00:22:18.440
so that you know what is going to become a part of it.

00:22:18.440 --> 00:22:21.220
Because at some point, you'll just not be able to stop it,

00:22:21.220 --> 00:22:25.020
and then you break something that was never intended to work

00:22:25.020 --> 00:22:26.600
and then 100 of your users are like,

00:22:26.600 --> 00:22:28.680
"Oh, we were using that.

00:22:28.680 --> 00:22:30.960
"It wasn't a bug, it was a feature for us."

00:22:30.960 --> 00:22:31.920
(laughing)

00:22:31.920 --> 00:22:33.320
- Yeah, we needed that.

00:22:33.320 --> 00:22:34.880
We found that's the only way we could use it,

00:22:34.880 --> 00:22:36.200
yeah, for sure.

00:22:36.200 --> 00:22:38.280
All right, let's talk about some of the techniques

00:22:38.280 --> 00:22:39.880
you've put together, a nice thing,

00:22:39.880 --> 00:22:42.200
you know, like how to maintain hundreds of API versions

00:22:42.200 --> 00:22:43.040
and survive.

00:22:43.040 --> 00:22:46.600
So what are some of the ways in which people version APIs?

00:22:46.600 --> 00:22:50.820
- First of all, it's really hard to really figure out

00:22:50.820 --> 00:22:53.320
how people do this and how to do it,

00:22:53.320 --> 00:22:56.640
because 90% of the time when you're going to be researching

00:22:56.640 --> 00:22:59.240
API versioning, what you're going to see is people

00:22:59.240 --> 00:23:02.200
having tough decisions between putting it into a header

00:23:02.200 --> 00:23:03.880
or putting it into a path.

00:23:03.880 --> 00:23:06.480
But then when you ask, "Well, how do you version?"

00:23:06.480 --> 00:23:08.040
Nobody really has an answer.

00:23:08.040 --> 00:23:09.600
Well, there are a few ways.

00:23:09.600 --> 00:23:13.320
First of all, you can go from the lowest level

00:23:13.320 --> 00:23:15.920
and version everything, including your database.

00:23:15.920 --> 00:23:18.080
You just make a separate copy of your app,

00:23:18.080 --> 00:23:19.840
you can host it on a separate server,

00:23:19.840 --> 00:23:22.400
even a separate Kubernetes namespace

00:23:22.400 --> 00:23:23.600
and forget about it.

00:23:23.600 --> 00:23:26.120
And you have two completely separate apps

00:23:26.120 --> 00:23:29.600
and now you need to have double the people

00:23:29.600 --> 00:23:32.600
for the maintenance, or at least a smaller separate team

00:23:32.600 --> 00:23:34.360
to maintain the second product.

00:23:34.360 --> 00:23:37.160
This approach is really nice if you have a product

00:23:37.160 --> 00:23:40.520
that cannot break, like there needs to be zero possibility

00:23:40.520 --> 00:23:41.880
of that breaking.

00:23:41.880 --> 00:23:46.360
If you are on a nuclear power plant, you'll probably do that.

00:23:46.360 --> 00:23:50.480
You can't have the old one broken and the new one working,

00:23:50.480 --> 00:23:53.080
but it's the most expensive approach, obviously.

00:23:53.080 --> 00:23:55.280
You can, however, limit that.

00:23:55.280 --> 00:23:58.600
You can start versioning just the application,

00:23:58.600 --> 00:23:59.560
but not the database.

00:23:59.560 --> 00:24:02.320
Okay, now we have the same thing,

00:24:02.320 --> 00:24:03.760
a separate branch in our code,

00:24:03.760 --> 00:24:06.480
a separate, not in our code, in our repository,

00:24:06.480 --> 00:24:09.400
a separate Kubernetes namespace, whatever,

00:24:09.400 --> 00:24:11.600
but now it's still expensive.

00:24:11.600 --> 00:24:13.240
It's still a whole separate copy

00:24:13.240 --> 00:24:14.520
of everything you have built.

00:24:14.520 --> 00:24:17.520
And now you have to make sure that the new one

00:24:17.520 --> 00:24:19.560
or the old one doesn't break the database

00:24:19.560 --> 00:24:21.920
because the database might have changed,

00:24:21.920 --> 00:24:25.120
but one of the versions of code might not know about that.

00:24:25.120 --> 00:24:28.160
And then you realize that you can go here.

00:24:28.160 --> 00:24:32.320
- Yeah, the database aspect of it sounds especially tricky,

00:24:32.320 --> 00:24:35.760
especially a relational database with super strong schemas.

00:24:35.760 --> 00:24:37.000
Like, you know what?

00:24:37.000 --> 00:24:40.200
That used to be a VAR char, and now it's an int.

00:24:40.200 --> 00:24:43.400
And so, nope, it's just not gonna work, right?

00:24:43.400 --> 00:24:45.400
There's really little flexibility.

00:24:45.400 --> 00:24:48.160
So even if you run the two things in parallel,

00:24:48.160 --> 00:24:50.880
then you almost have to have two databases,

00:24:50.880 --> 00:24:53.160
and then like a mill points out,

00:24:53.160 --> 00:24:55.040
and then you have to sync the databases,

00:24:55.040 --> 00:24:56.680
and like, it's non-trivial.

00:24:56.680 --> 00:24:58.640
- Oh, yes, and then you start realizing,

00:24:58.640 --> 00:25:00.720
okay, why do I need a separate branch

00:25:00.720 --> 00:25:01.880
and a separate namespace?

00:25:01.880 --> 00:25:04.440
Let's just keep them within the same app,

00:25:04.440 --> 00:25:08.320
because as long as you have separate paths for this,

00:25:08.320 --> 00:25:10.800
even you can build separate swaggers from them,

00:25:10.800 --> 00:25:13.640
you can have them within the same branch,

00:25:13.640 --> 00:25:16.080
within the same repository, just in different directories,

00:25:16.080 --> 00:25:18.320
and you can just copy all of your code.

00:25:18.320 --> 00:25:20.960
And now I call that versioning by suffering,

00:25:20.960 --> 00:25:24.320
because you think, oh, I'm going to version less this time.

00:25:24.320 --> 00:25:26.120
You know, now I'm not versioning the database.

00:25:26.120 --> 00:25:27.360
Now it's not a separate branch.

00:25:27.360 --> 00:25:31.920
It's gonna be much easier to make fixes in both places.

00:25:31.920 --> 00:25:35.720
But now you have to support both of the code bases.

00:25:35.720 --> 00:25:39.000
And once you update anything, any of the related resources,

00:25:39.000 --> 00:25:40.720
for example, the database models,

00:25:40.720 --> 00:25:42.080
you have to update them twice.

00:25:42.080 --> 00:25:43.760
If you update any of the dependencies,

00:25:43.760 --> 00:25:45.400
you have to update them twice.

00:25:45.400 --> 00:25:47.720
And that can get painful.

00:25:47.720 --> 00:25:49.040
And after a while,

00:25:49.040 --> 00:25:51.640
if you have more than two of these versions,

00:25:51.640 --> 00:25:52.760
you're going to be asking yourself,

00:25:52.760 --> 00:25:56.280
okay, what is the difference between these versions?

00:25:56.280 --> 00:25:58.400
And if you weren't careful with documentation

00:25:58.400 --> 00:26:01.160
and code review, oh, you're in for a treat.

00:26:01.160 --> 00:26:02.000
- Yeah. - But that's just

00:26:02.000 --> 00:26:02.840
the beginning.

00:26:02.840 --> 00:26:04.800
You can version much less.

00:26:04.800 --> 00:26:06.960
Now, instead of the whole directories,

00:26:06.960 --> 00:26:09.000
you can version just separate endpoints.

00:26:09.000 --> 00:26:12.760
And I think that's the way that I recommend for everyone.

00:26:12.760 --> 00:26:14.600
Everyone who is doing API versioning,

00:26:14.600 --> 00:26:16.920
who wants to be with the cool kids,

00:26:16.920 --> 00:26:18.400
I recommend this approach.

00:26:18.400 --> 00:26:21.680
As long as you are a small company or an individual

00:26:21.680 --> 00:26:24.600
and you want something really simple, that's a good way.

00:26:24.600 --> 00:26:27.120
You just copy a single endpoint that you have changed,

00:26:27.120 --> 00:26:29.080
create another schema for that,

00:26:29.080 --> 00:26:31.960
and then create another branch in your business logic,

00:26:31.960 --> 00:26:33.840
or maybe even no branch.

00:26:33.840 --> 00:26:36.760
That's even better, using the same business logic.

00:26:36.760 --> 00:26:38.480
But then at some point,

00:26:38.480 --> 00:26:40.360
once you want to support many versions

00:26:40.360 --> 00:26:43.240
or your versions become too different,

00:26:43.240 --> 00:26:44.800
that's where you get a problem.

00:26:44.800 --> 00:26:47.080
Because now all of a sudden you have all of these,

00:26:47.080 --> 00:26:49.320
oh, I have this endpoint in this version,

00:26:49.320 --> 00:26:50.520
that endpoint in that version.

00:26:50.520 --> 00:26:53.000
Oh, it's gonna be bad, really bad.

00:26:53.000 --> 00:26:54.240
Again. - We've been talking like

00:26:54.240 --> 00:26:55.880
there's the old version and the new version,

00:26:55.880 --> 00:26:58.280
but in practice, somebody starts to depend

00:26:58.280 --> 00:27:00.520
on the new version, and then you evolve the new version,

00:27:00.520 --> 00:27:04.040
and it just, it combinatorially explodes

00:27:04.040 --> 00:27:05.320
and it's out of control, yeah?

00:27:05.320 --> 00:27:06.160
- Precisely.

00:27:06.160 --> 00:27:08.040
It's gonna be really bad for your developers.

00:27:08.040 --> 00:27:09.920
Your clients are going to be fine with it.

00:27:09.920 --> 00:27:11.280
Your developers are going to hate you.

00:27:11.280 --> 00:27:14.720
Although not as bad as with the previous approach.

00:27:14.720 --> 00:27:18.120
Now, the next one you get to is you start thinking,

00:27:18.120 --> 00:27:22.040
okay, what if instead of duplicating all of that stuff,

00:27:22.040 --> 00:27:25.440
I am just going to change the schemas?

00:27:25.440 --> 00:27:27.600
So, okay, if I do need to rename my endpoint,

00:27:27.600 --> 00:27:28.800
I am going to duplicate it.

00:27:28.800 --> 00:27:30.160
But most of the time you're not.

00:27:30.160 --> 00:27:31.960
Most of the time you're just changing some field

00:27:31.960 --> 00:27:32.800
in some schema.

00:27:32.800 --> 00:27:34.440
You're renaming it, you're extending it,

00:27:34.440 --> 00:27:36.440
changing its type, stuff like that.

00:27:36.440 --> 00:27:38.720
That's like 90% of your use cases.

00:27:38.720 --> 00:27:40.760
Okay, what if we just change the schemas

00:27:40.760 --> 00:27:42.600
and then have some serializers?

00:27:42.600 --> 00:27:45.800
For example, Django, what is it?

00:27:45.800 --> 00:27:47.680
Django DRF loves that.

00:27:47.680 --> 00:27:50.520
They love the serializers and reserializers,

00:27:50.520 --> 00:27:52.720
and you can just have each,

00:27:52.720 --> 00:27:53.680
we have five versions,

00:27:53.680 --> 00:27:56.080
and version one serializes into version five,

00:27:56.080 --> 00:27:57.880
version two serializes into version five,

00:27:57.880 --> 00:27:58.760
yada, yada, yada.

00:27:58.760 --> 00:28:01.800
And so our client sends us a request,

00:28:01.800 --> 00:28:03.920
we reserialize it into the correct version,

00:28:03.920 --> 00:28:05.120
then we return a response,

00:28:05.120 --> 00:28:06.720
we use the same business logic,

00:28:06.720 --> 00:28:09.280
and then we serialize it back into each version.

00:28:09.280 --> 00:28:10.120
Great.

00:28:10.120 --> 00:28:12.360
Now, we have solved all the problems

00:28:12.360 --> 00:28:13.760
of the previous approaches.

00:28:13.760 --> 00:28:15.680
Now, you need to realize that

00:28:15.680 --> 00:28:17.280
when you're doing something like this,

00:28:17.280 --> 00:28:19.800
you are in a little bit of danger

00:28:19.800 --> 00:28:22.760
of creating bugs in the new versions,

00:28:22.760 --> 00:28:25.480
and these bugs cascading to the old versions,

00:28:25.480 --> 00:28:27.880
which hopefully you have tests to handle that.

00:28:27.880 --> 00:28:29.880
But at least your clients are happy

00:28:29.880 --> 00:28:32.720
because you can support versions for a long time,

00:28:32.720 --> 00:28:34.520
and your developers are happy

00:28:34.520 --> 00:28:38.120
because the burden of support is now on the serializers.

00:28:38.120 --> 00:28:40.520
But you still have to support these serializers.

00:28:40.520 --> 00:28:41.600
It's still a lot of stuff,

00:28:41.600 --> 00:28:44.800
you still have to put every field in there,

00:28:44.800 --> 00:28:48.760
and take care of any problems that happen.

00:28:48.760 --> 00:28:50.880
And each new version will change

00:28:50.880 --> 00:28:52.840
basically all of your serializers.

00:28:52.840 --> 00:28:54.040
A little bit, yes,

00:28:54.040 --> 00:28:56.120
but you won't be able to support 20 versions like that.

00:28:56.120 --> 00:28:57.200
It's going to be crazy.

00:28:57.200 --> 00:29:01.720
And now that's where we get to the final approaches,

00:29:01.720 --> 00:29:03.800
the approaches that I guess

00:29:03.800 --> 00:29:05.800
the most sophisticated in the industry.

00:29:05.800 --> 00:29:08.360
If you are making a backend for frontend,

00:29:08.360 --> 00:29:09.640
for your own frontend,

00:29:09.640 --> 00:29:11.000
then you can just use GraphQL.

00:29:11.000 --> 00:29:13.280
GraphQL basically requires no versioning,

00:29:13.280 --> 00:29:16.760
and that's one of the benefits of it.

00:29:16.760 --> 00:29:18.360
I would recommend that.

00:29:18.360 --> 00:29:21.840
If you have developers that are good with GraphQL,

00:29:21.840 --> 00:29:24.200
that's great, you can omit versioning altogether.

00:29:24.200 --> 00:29:26.680
But if you're not, if it's a public API,

00:29:26.680 --> 00:29:29.520
then that's where Stripe's approach comes.

00:29:29.520 --> 00:29:30.960
I think they were the first ones

00:29:30.960 --> 00:29:33.360
to publish an article about that.

00:29:33.360 --> 00:29:35.800
It was Brander Leach, the author of this article,

00:29:35.800 --> 00:29:38.440
he has supported API versioning at Stripe for a while,

00:29:38.440 --> 00:29:41.680
and he has helped us with building

00:29:41.680 --> 00:29:43.760
our API versioning approach.

00:29:43.760 --> 00:29:46.160
Essentially what Stripe did is said,

00:29:46.160 --> 00:29:48.640
"Okay, let's imagine that our developers

00:29:48.640 --> 00:29:50.760
"are only supporting one version, the latest one,

00:29:50.760 --> 00:29:52.720
"just like with serializers.

00:29:52.720 --> 00:29:55.800
"But instead of serializing every version to the latest one,

00:29:55.800 --> 00:29:59.520
"let's say that each version knows how to serialize

00:29:59.520 --> 00:30:00.840
"into the next version."

00:30:00.840 --> 00:30:02.360
- Kind of like database migrations.

00:30:02.360 --> 00:30:05.640
- Let's say that I return response from the latest version.

00:30:05.640 --> 00:30:08.880
This response, or at least they call them,

00:30:08.880 --> 00:30:10.640
I think, version gates.

00:30:10.640 --> 00:30:13.440
These version gates, the version gate for fifth version,

00:30:13.440 --> 00:30:15.920
knows how to convert back my response back

00:30:15.920 --> 00:30:17.160
into the fourth version.

00:30:17.160 --> 00:30:19.240
The version gate for the fourth version

00:30:19.240 --> 00:30:21.760
knows how to convert it back into the third version.

00:30:21.760 --> 00:30:25.360
And all of a sudden, you get simple version gates,

00:30:25.360 --> 00:30:28.360
because if it's just field renaming in a single version,

00:30:28.360 --> 00:30:30.800
then it's just a single line, they're really simple.

00:30:30.800 --> 00:30:32.960
But at the same time, they're immutable,

00:30:32.960 --> 00:30:34.080
because these version gates,

00:30:34.080 --> 00:30:36.000
they're not describing the whole schema.

00:30:36.000 --> 00:30:39.080
They're describing the difference between two versions.

00:30:39.080 --> 00:30:41.400
And because we know that we don't wanna

00:30:41.400 --> 00:30:43.080
change the old version,

00:30:43.080 --> 00:30:45.280
we want the old version to work,

00:30:45.280 --> 00:30:47.560
which is why the difference between version two

00:30:47.560 --> 00:30:49.240
and version three is going to stay.

00:30:49.240 --> 00:30:50.680
It's not going to change,

00:30:50.680 --> 00:30:53.240
which is why these converters are also immutable,

00:30:53.240 --> 00:30:56.160
which means that you don't need to spend much time

00:30:56.160 --> 00:30:57.000
supporting them.

00:30:57.000 --> 00:30:58.920
- Right, once you get, if you're on version three

00:30:58.920 --> 00:31:01.680
and you get the transition from one to two set,

00:31:01.680 --> 00:31:03.800
like that's not gonna change ever, right?

00:31:03.800 --> 00:31:04.640
- Precisely.

00:31:04.640 --> 00:31:07.480
Well, at some point you need it for optimizations

00:31:07.480 --> 00:31:09.440
or for returning extra data,

00:31:09.440 --> 00:31:13.280
but it's such a rare use case that I haven't seen it so far.

00:31:13.280 --> 00:31:15.080
And I hope that I won't.

00:31:15.080 --> 00:31:16.120
- So this is Stripe's approach.

00:31:16.120 --> 00:31:17.920
And one of the things that's really interesting

00:31:17.920 --> 00:31:20.360
that Stripe does and is laid out in this article

00:31:20.360 --> 00:31:22.760
that you're bringing to the table here is,

00:31:22.760 --> 00:31:26.840
they also implicitly assign you a version

00:31:26.840 --> 00:31:30.280
when you first make a call, which was really interesting.

00:31:30.280 --> 00:31:32.400
I use Stripe and I didn't realize

00:31:32.400 --> 00:31:34.720
that when I've made calls into Stripe

00:31:34.720 --> 00:31:36.640
that the first time you make a call,

00:31:36.640 --> 00:31:39.600
it pins you somewhere like on your user account

00:31:39.600 --> 00:31:42.320
on their side, pins you to that version of the API.

00:31:42.320 --> 00:31:44.200
And you never know you're on a different,

00:31:44.200 --> 00:31:46.040
you're on a particular version,

00:31:46.040 --> 00:31:47.640
but they keep you on that version.

00:31:47.640 --> 00:31:48.480
That's wild.

00:31:48.480 --> 00:31:49.320
- That's great.

00:31:49.320 --> 00:31:52.160
Imagine you log in into Stripe, you make a call,

00:31:52.160 --> 00:31:56.120
and then every time you open a documentation in your account

00:31:56.120 --> 00:31:57.400
you're going to see your version.

00:31:57.400 --> 00:31:58.240
Every time you make a call,

00:31:58.240 --> 00:32:00.720
you're going to get response from your version.

00:32:00.720 --> 00:32:04.040
And then because they keep versions for years,

00:32:04.040 --> 00:32:06.480
for example, we are using, I think,

00:32:06.480 --> 00:32:09.840
three or four year old version of Stripe's API

00:32:09.840 --> 00:32:10.920
and they still keep it.

00:32:10.920 --> 00:32:14.000
According to this article, they keep all of their versions,

00:32:14.000 --> 00:32:16.120
all since the company's beginning.

00:32:16.120 --> 00:32:18.160
I'm not sure how true that is.

00:32:18.160 --> 00:32:19.040
- It's 2011.

00:32:19.040 --> 00:32:20.920
- They keep years worth of versions.

00:32:20.920 --> 00:32:21.760
That is very true.

00:32:21.760 --> 00:32:23.200
- Now you might see that as a negative.

00:32:23.200 --> 00:32:25.480
Like you might think, well, I'm pinned to this version.

00:32:25.480 --> 00:32:27.360
Like how do I escape the old version

00:32:27.360 --> 00:32:28.760
if I want the new version?

00:32:28.760 --> 00:32:30.520
But you can pass it in a header

00:32:30.520 --> 00:32:32.240
or there's other ways to say,

00:32:32.240 --> 00:32:34.400
I explicitly choose something else.

00:32:34.400 --> 00:32:36.840
But by default, you're just, you're living in the past.

00:32:36.840 --> 00:32:37.680
- That's really cool.

00:32:37.680 --> 00:32:39.160
You integrate and then you live in the past

00:32:39.160 --> 00:32:40.080
for as long as you want.

00:32:40.080 --> 00:32:44.000
The thing is, yes, you can change it using a header.

00:32:44.000 --> 00:32:46.320
Monite has a similar structure.

00:32:46.320 --> 00:32:50.440
You can also change it in your partner's portal

00:32:50.440 --> 00:32:53.040
and you can also, or I guess developer's portal,

00:32:53.040 --> 00:32:54.720
and you can also specify, for example,

00:32:54.720 --> 00:32:56.520
if you receive webhooks from Stripe,

00:32:56.520 --> 00:32:59.280
you can specify, okay, I want this webhook of this version

00:32:59.280 --> 00:33:00.880
and that webhook of that version.

00:33:00.880 --> 00:33:01.720
- That's cool, yeah.

00:33:01.720 --> 00:33:03.440
- It's a really neat interface

00:33:03.440 --> 00:33:05.480
that if you don't wanna think about versioning,

00:33:05.480 --> 00:33:07.040
you don't, you forget about it.

00:33:07.040 --> 00:33:08.640
But the second you want to,

00:33:08.640 --> 00:33:10.960
the second you wanna have the latest API,

00:33:10.960 --> 00:33:14.480
they give you all the tools to work with it nicely.

00:33:14.480 --> 00:33:15.320
And that's the thing.

00:33:15.320 --> 00:33:19.320
This approach allows you to keep years worth of versions

00:33:19.320 --> 00:33:22.240
or maybe even decades worth of versions, actually,

00:33:22.240 --> 00:33:25.120
without your developers getting overburdened

00:33:25.120 --> 00:33:26.880
because there is still a single version

00:33:26.880 --> 00:33:28.000
of the business logic.

00:33:28.000 --> 00:33:29.640
They work on a single version of Schemas

00:33:29.640 --> 00:33:31.280
and they just need to make sure

00:33:31.280 --> 00:33:33.240
that when they release a new version,

00:33:33.240 --> 00:33:34.600
they write a converter for it.

00:33:34.600 --> 00:33:35.920
And your clients are also happy

00:33:35.920 --> 00:33:37.280
because they never need to switch.

00:33:37.280 --> 00:33:38.120
- It sounds really nice.

00:33:38.120 --> 00:33:42.120
I suspect there's not complete ability

00:33:42.120 --> 00:33:43.680
to just ignore the old versions

00:33:43.680 --> 00:33:46.600
because maybe you want, in your new version,

00:33:46.600 --> 00:33:49.520
you're gonna imagine this piece of data doesn't even exist

00:33:49.520 --> 00:33:51.160
and we're gonna remove it from the database.

00:33:51.160 --> 00:33:53.400
But if it needs to be there for the old ones,

00:33:53.400 --> 00:33:55.520
there's probably some level of,

00:33:55.520 --> 00:33:56.880
you're constrained a little bit,

00:33:56.880 --> 00:33:57.960
but it sounds a lot better.

00:33:57.960 --> 00:34:00.280
- You're still constrained, but remember,

00:34:00.280 --> 00:34:03.520
API versioning, if we translate it,

00:34:03.520 --> 00:34:06.400
application programming interface versioning,

00:34:06.400 --> 00:34:07.880
we're not versioning the app.

00:34:07.880 --> 00:34:09.880
We're versioning the interface to the app.

00:34:09.880 --> 00:34:11.200
- Yeah, so a lot of times it's like,

00:34:11.200 --> 00:34:13.280
what fields are we passing or something, right?

00:34:13.280 --> 00:34:16.480
- If you are trying to change the data between versions,

00:34:16.480 --> 00:34:19.080
if the data is different, entirely different, I mean,

00:34:19.080 --> 00:34:21.680
then you're probably not doing API versioning.

00:34:21.680 --> 00:34:24.000
Then you probably should be calling it

00:34:24.000 --> 00:34:25.280
application versioning.

00:34:25.280 --> 00:34:30.000
And actually Stripe has, I guess, a hack for that too.

00:34:30.000 --> 00:34:32.920
If you take a look at their API, they still have a V1,

00:34:32.920 --> 00:34:33.760
but that's the thing.

00:34:33.760 --> 00:34:35.080
They don't use this V1.

00:34:35.080 --> 00:34:37.720
They use date-based versioning that is in the headers

00:34:37.720 --> 00:34:39.040
and their settings.

00:34:39.040 --> 00:34:42.800
But the V1 is precisely for this situation.

00:34:42.800 --> 00:34:45.680
If someday they will need to have something else,

00:34:45.680 --> 00:34:48.360
if someday they will need to break everything

00:34:48.360 --> 00:34:52.960
and change the data required or any other crazy changes,

00:34:52.960 --> 00:34:55.040
they will be able to do it using that V1.

00:34:55.040 --> 00:34:56.760
- Yeah, it's just there in case.

00:34:56.760 --> 00:34:57.600
- Exactly.

00:34:57.600 --> 00:34:59.840
- Cool, all right, well, let's talk about your project.

00:34:59.840 --> 00:35:00.760
Let's talk about your project

00:35:00.760 --> 00:35:02.440
that makes this possible in Python

00:35:02.440 --> 00:35:04.560
because the Stripe examples,

00:35:04.560 --> 00:35:06.880
I believe this is Ruby that they all have here, right?

00:35:06.880 --> 00:35:10.360
- It is really nice to read until you try to understand it,

00:35:10.360 --> 00:35:12.960
until you try to understand what it actually does.

00:35:12.960 --> 00:35:13.800
And it's crazy.

00:35:13.800 --> 00:35:16.240
- I know, when I was reading this today, I was like,

00:35:16.240 --> 00:35:17.080
you know, I'm pretty glad

00:35:17.080 --> 00:35:18.720
that I'm not writing Ruby right now.

00:35:18.720 --> 00:35:21.400
Okay, all right, let's talk about Python though.

00:35:21.400 --> 00:35:23.560
You've got a project called CAD1

00:35:23.560 --> 00:35:26.920
that takes the Stripe philosophy

00:35:26.920 --> 00:35:28.640
and applies it to versioning

00:35:28.640 --> 00:35:33.640
for the most popular API framework for Python, FastAPI.

00:35:33.640 --> 00:35:34.720
Tell us about it.

00:35:34.720 --> 00:35:37.080
- Here's the thing, when I started developing it,

00:35:37.080 --> 00:35:39.560
we were using versioning by suffering.

00:35:39.560 --> 00:35:41.560
So we were using directory copies

00:35:41.560 --> 00:35:43.480
and none of us really enjoyed it.

00:35:43.480 --> 00:35:45.520
So there needed to be a solution.

00:35:45.520 --> 00:35:48.200
And I went to Stripe, I went to other companies,

00:35:48.200 --> 00:35:49.120
I spoke with them,

00:35:49.120 --> 00:35:53.080
I tried to understand the nitty gritty details.

00:35:53.080 --> 00:35:57.360
As I mentioned, Brander Leach extended us huge help

00:35:57.360 --> 00:36:00.520
when he, I guess, described how he thinks

00:36:00.520 --> 00:36:02.200
about API versioning right now.

00:36:02.200 --> 00:36:03.680
And I built it.

00:36:03.680 --> 00:36:05.960
The first version was just like Stripe.

00:36:05.960 --> 00:36:08.800
It was exactly what Stripe did to the letter.

00:36:08.800 --> 00:36:12.160
But then at some point, we started applying it at Monite

00:36:12.160 --> 00:36:15.720
and I realized, wow, Stripe had a lot of legacy.

00:36:15.720 --> 00:36:17.360
So they didn't implement some things.

00:36:17.360 --> 00:36:18.960
For example, in Stripe's article,

00:36:18.960 --> 00:36:23.280
you can see that they're not using any schema validation

00:36:23.280 --> 00:36:25.880
or at least how do I describe it?

00:36:25.880 --> 00:36:30.200
Their business logic just receives a hash map, a dictionary.

00:36:30.200 --> 00:36:33.800
It's not statically typed, but FastAPI uses Bidentics.

00:36:33.800 --> 00:36:35.880
So it's a bit more complex than that.

00:36:35.880 --> 00:36:38.320
Okay, we added support for that.

00:36:38.320 --> 00:36:39.680
It's a bit more complex.

00:36:39.680 --> 00:36:42.000
It's a bit more, I guess, sophisticated now.

00:36:42.000 --> 00:36:44.280
But then I also realized that Stripe,

00:36:44.280 --> 00:36:46.680
they don't migrate requests.

00:36:46.680 --> 00:36:48.400
They only migrate responses

00:36:48.400 --> 00:36:50.400
because emigration of a request

00:36:50.400 --> 00:36:53.360
is usually not just a breaking change,

00:36:53.360 --> 00:36:55.040
it's a change in a business logic.

00:36:55.040 --> 00:36:56.240
Because when you return a response,

00:36:56.240 --> 00:36:57.560
you can just return the whole thing

00:36:57.560 --> 00:36:59.800
and then just play around with it.

00:36:59.800 --> 00:37:02.760
But when you are changing the request,

00:37:02.760 --> 00:37:04.920
your business logic also needs to change.

00:37:04.920 --> 00:37:06.360
And that's what they did.

00:37:06.360 --> 00:37:08.640
They have extra ifs and extra levels

00:37:08.640 --> 00:37:10.240
of business logic to handle that.

00:37:10.240 --> 00:37:11.960
Well, apparently it's not necessary.

00:37:11.960 --> 00:37:14.920
Apparently requests are also migratable.

00:37:14.920 --> 00:37:17.440
And that's the second feature

00:37:17.440 --> 00:37:20.760
that greatly distinguishes us from Stripe.

00:37:20.760 --> 00:37:23.240
This thing can statically,

00:37:23.240 --> 00:37:25.080
well, by statically, I mean,

00:37:25.080 --> 00:37:26.720
it co-generates your schema

00:37:26.720 --> 00:37:31.720
so that you can see everything before you run your app.

00:37:31.720 --> 00:37:35.200
This thing can migrate both requests and responses,

00:37:35.200 --> 00:37:37.200
and it supports everything that Stripe does.

00:37:37.200 --> 00:37:40.760
And we have pretty big plans for extending it.

00:37:40.760 --> 00:37:42.920
And as an added bonus,

00:37:42.920 --> 00:37:46.080
we also have a pretty big documentation.

00:37:46.080 --> 00:37:48.640
Well, not compared to Django or FastAPI.

00:37:48.640 --> 00:37:53.120
Django is older than me and FastAPI,

00:37:53.120 --> 00:37:55.440
it's pretty amazing in terms of its documentation.

00:37:55.440 --> 00:37:58.680
Sebastian Ramirez is an expert of making tutorials.

00:37:58.680 --> 00:38:01.360
And if you take a look at our reference documentation

00:38:01.360 --> 00:38:03.600
to the left and our, how do you describe it,

00:38:03.600 --> 00:38:05.560
recipes documentation,

00:38:05.560 --> 00:38:08.360
they basically describe to you

00:38:08.360 --> 00:38:11.880
every single use case that you could have

00:38:11.880 --> 00:38:13.440
with API versioning,

00:38:13.440 --> 00:38:15.800
every single problem that you could solve with it.

00:38:15.800 --> 00:38:20.240
And then we try to apply our approach to it.

00:38:20.240 --> 00:38:21.920
So it's not just the framework,

00:38:21.920 --> 00:38:24.360
it's all the ways you could use the framework.

00:38:24.360 --> 00:38:26.880
Someday, hopefully we will also extend it

00:38:26.880 --> 00:38:29.360
beyond FastAPI and Bidantic.

00:38:29.360 --> 00:38:32.440
And we also have sections for theory

00:38:32.440 --> 00:38:34.720
for people who are not Pythonistas,

00:38:34.720 --> 00:38:37.160
who just wanna learn how to do API versioning,

00:38:37.160 --> 00:38:39.840
but failed to find any resources.

00:38:39.840 --> 00:38:41.760
So Katwin also becomes this, I guess,

00:38:41.760 --> 00:38:44.800
hub for API versioning resources

00:38:44.800 --> 00:38:46.400
and anything related to them.

00:38:46.400 --> 00:38:48.480
- It seems like it would probably be pretty easy

00:38:48.480 --> 00:38:51.240
to adapt to anything that uses Pydantic

00:38:51.240 --> 00:38:52.360
for its data exchange.

00:38:52.360 --> 00:38:53.200
- Oh, yes.

00:38:53.200 --> 00:38:55.000
- Yeah, so like, for example, in Flask,

00:38:55.000 --> 00:38:58.280
Flask doesn't do the model binding type stuff

00:38:58.280 --> 00:38:59.120
on the endpoint,

00:38:59.120 --> 00:39:01.360
but you can just take the input data

00:39:01.360 --> 00:39:04.000
and just star star it into a Pydantic model.

00:39:04.000 --> 00:39:06.440
And then, you know, now you're in Pydantic world, right?

00:39:06.440 --> 00:39:09.200
So it sounds like maybe something along those lines

00:39:09.200 --> 00:39:10.640
might be a good bridge.

00:39:10.640 --> 00:39:12.160
- There's a lot of magic involved

00:39:12.160 --> 00:39:14.840
in trying to interface with FastAPI

00:39:14.840 --> 00:39:17.480
simply due to its internal complexity.

00:39:17.480 --> 00:39:18.320
- Right.

00:39:18.320 --> 00:39:20.960
This portion of Talk Python to Me

00:39:20.960 --> 00:39:22.760
is brought to you by Sentry.

00:39:22.760 --> 00:39:25.040
You know Sentry for their error tracking service,

00:39:25.040 --> 00:39:27.200
but did you know you can take that all the way

00:39:27.200 --> 00:39:29.520
through your multi-tiered and distributed app

00:39:29.520 --> 00:39:31.920
with their distributed tracing feature?

00:39:31.920 --> 00:39:34.040
Distributed tracing is a debugging technique

00:39:34.040 --> 00:39:37.040
that involves tracking requests of your system,

00:39:37.040 --> 00:39:39.640
starting from the very beginning, like a user action,

00:39:39.640 --> 00:39:41.360
all the way to the backend, database,

00:39:41.360 --> 00:39:43.160
and third-party services.

00:39:43.160 --> 00:39:45.280
This can help you identify if the cause of an error

00:39:45.280 --> 00:39:48.280
in one project is due to the error in another.

00:39:48.280 --> 00:39:50.680
Every system can benefit from distributed tracing,

00:39:50.680 --> 00:39:53.440
but they're especially useful for microservices.

00:39:53.440 --> 00:39:56.440
In this architecture, logs won't give you the full picture,

00:39:56.440 --> 00:39:58.680
so you can't debug every request in full

00:39:58.680 --> 00:40:00.120
just by reading the logs.

00:40:00.120 --> 00:40:02.560
Distributed tracing with a platform like Sentry

00:40:02.560 --> 00:40:05.600
gives you a visual overview about which services

00:40:05.600 --> 00:40:08.520
were called during the execution of certain requests.

00:40:08.520 --> 00:40:11.440
Aside from debugging and visualizing your architecture,

00:40:11.440 --> 00:40:13.880
distributed tracing also helps you identify

00:40:13.880 --> 00:40:15.480
performance bottlenecks.

00:40:15.480 --> 00:40:17.320
Through a visual like a Gantt chart,

00:40:17.320 --> 00:40:19.440
you can see if a particular span in your stack

00:40:19.440 --> 00:40:20.760
took longer than expected,

00:40:20.760 --> 00:40:22.680
and how it could be causing slowdowns

00:40:22.680 --> 00:40:24.320
in other parts of your app.

00:40:24.320 --> 00:40:27.000
Learn more and see some examples in the tracing section

00:40:27.000 --> 00:40:29.160
at docs.sentry.io.

00:40:29.160 --> 00:40:31.000
To take advantage of all the features

00:40:31.000 --> 00:40:33.920
of the Sentry platform, just create your free account.

00:40:33.920 --> 00:40:35.920
And for all of you Talk Python listeners,

00:40:35.920 --> 00:40:38.720
use the code Talk Python, all one word,

00:40:38.720 --> 00:40:40.440
and you'll activate a free month

00:40:40.440 --> 00:40:42.680
of their premium paid features.

00:40:42.680 --> 00:40:46.880
Get started today at talkpython.fm/sentry-trace.

00:40:46.880 --> 00:40:48.920
That link is in your podcast player show notes

00:40:48.920 --> 00:40:50.460
and the episode page.

00:40:50.460 --> 00:40:53.240
Thank you to Sentry for supporting Talk Python To Me.

00:40:53.240 --> 00:40:56.240
So some good questions,

00:40:56.240 --> 00:40:59.000
but I think they'll be somewhat answered

00:40:59.000 --> 00:41:02.800
if we just maybe talk us through your tutorial here.

00:41:02.800 --> 00:41:06.000
Like how do we use Kadwin and how does it manifest?

00:41:06.000 --> 00:41:07.160
How does it work at runtime?

00:41:07.160 --> 00:41:08.000
Stuff like that.

00:41:08.000 --> 00:41:09.160
- First, before using Kadwin,

00:41:09.160 --> 00:41:10.680
you know, you write your regular app,

00:41:10.680 --> 00:41:13.160
but then you just structure it a little bit differently.

00:41:13.160 --> 00:41:15.080
When you are versioning,

00:41:15.080 --> 00:41:19.760
you need a directory that you will consider versioned.

00:41:19.760 --> 00:41:23.400
So, and this directory will be duplicated for every version.

00:41:23.400 --> 00:41:26.880
No worries, you're not going to support the version code.

00:41:26.880 --> 00:41:29.400
It's going to be code generation all the way through.

00:41:29.400 --> 00:41:31.560
And you can use it to generate connectors

00:41:31.560 --> 00:41:32.680
for your application,

00:41:32.680 --> 00:41:36.200
or you could use it to generate schemas or enums,

00:41:36.200 --> 00:41:38.200
you know, the different version of them

00:41:38.200 --> 00:41:40.080
and anything else related to them.

00:41:40.080 --> 00:41:41.560
So you pick such a directory,

00:41:41.560 --> 00:41:44.800
you call it latest as for your latest version.

00:41:44.800 --> 00:41:48.160
Then you define a single version bundle.

00:41:48.160 --> 00:41:50.920
If you go a little bit down,

00:41:50.920 --> 00:41:53.280
you will see somewhere in here after defining versions.

00:41:53.280 --> 00:41:56.220
Yes, we define our version bundle with a single version,

00:41:56.220 --> 00:41:58.920
whichever version it is for you,

00:41:58.920 --> 00:42:01.120
whichever date it is for you.

00:42:01.120 --> 00:42:03.640
And then you run code generation.

00:42:03.640 --> 00:42:06.760
It generates a directory that simply imports

00:42:06.760 --> 00:42:07.800
from your latest,

00:42:07.800 --> 00:42:10.920
and that's where you can start doing the magic.

00:42:10.920 --> 00:42:13.960
Now you just use our versioned app.

00:42:13.960 --> 00:42:17.640
The, if you take a look, we have a versioned API router.

00:42:17.640 --> 00:42:20.000
Then you use the Kadwin versioned app.

00:42:20.000 --> 00:42:23.440
You generate version routers,

00:42:23.440 --> 00:42:24.820
and then it's going to generate

00:42:24.820 --> 00:42:27.260
a really nice swagger for them.

00:42:27.260 --> 00:42:30.320
If you open it somewhere, I think, yep, this one.

00:42:30.320 --> 00:42:33.000
So now your dashboard, the one on docs,

00:42:33.000 --> 00:42:34.780
is not the swagger page,

00:42:34.780 --> 00:42:37.100
but the dashboard of all your versions.

00:42:37.100 --> 00:42:37.940
And that's it.

00:42:37.940 --> 00:42:41.280
After that, you can simply repeat the steps above.

00:42:41.280 --> 00:42:43.660
So you write a migration,

00:42:43.660 --> 00:42:46.220
write that converter that describes the difference

00:42:46.220 --> 00:42:47.460
between the versions.

00:42:47.460 --> 00:42:49.700
We have it somewhere there.

00:42:49.700 --> 00:42:51.120
If we had an address as a string

00:42:51.120 --> 00:42:52.840
and we want to change it to a list,

00:42:52.840 --> 00:42:55.620
we say, okay, schema, base user,

00:42:55.620 --> 00:42:57.140
field addresses didn't exist.

00:42:57.140 --> 00:43:00.020
- You have a user object, which is a pedantic model.

00:43:00.020 --> 00:43:03.940
The user object in version, the initial version,

00:43:03.940 --> 00:43:06.780
just had a field called address, which was a string.

00:43:06.780 --> 00:43:07.620
But you said, you know what?

00:43:07.620 --> 00:43:10.260
People might have multiple addresses that they live at.

00:43:10.260 --> 00:43:13.420
So let's make it a list of strings

00:43:13.420 --> 00:43:15.260
and make it address as, right?

00:43:15.260 --> 00:43:16.540
Which seems like a minor change,

00:43:16.540 --> 00:43:19.300
but clearly that's going to be a major problem

00:43:19.300 --> 00:43:21.340
for the things that assume there's an address

00:43:21.340 --> 00:43:22.840
and it's no longer there, right?

00:43:22.840 --> 00:43:26.280
So you create this version change derived class

00:43:26.280 --> 00:43:30.120
that has a upgrade downgrade basically feature, right?

00:43:30.120 --> 00:43:32.660
- You simply describe how do you migrate your schemas?

00:43:32.660 --> 00:43:36.480
How do you change your schema classes, your pedantic models?

00:43:36.480 --> 00:43:39.700
And then you describe how you convert your requests

00:43:39.700 --> 00:43:41.200
and response, and that's it.

00:43:41.200 --> 00:43:44.340
This class is the only thing you write for the new versions.

00:43:44.340 --> 00:43:46.800
Then you run code generation, run your app.

00:43:46.800 --> 00:43:47.640
That's it.

00:43:47.640 --> 00:43:48.460
Everything works.

00:43:48.460 --> 00:43:49.360
- Yeah, that's super cool.

00:43:49.360 --> 00:43:51.600
So couple of questions that were,

00:43:51.600 --> 00:43:53.640
or comments that are interesting here is,

00:43:53.640 --> 00:43:57.200
Emil asks, is it like database migrations?

00:43:57.200 --> 00:43:58.360
And Mike Fila points out,

00:43:58.360 --> 00:44:01.040
it's really, really similar to like Alembic, right?

00:44:01.040 --> 00:44:02.840
You say, generate me the changes.

00:44:02.840 --> 00:44:04.880
Alembic is a little different in that it looks

00:44:04.880 --> 00:44:06.840
at the two different database schemas

00:44:06.840 --> 00:44:10.220
and tries to actually write the migration code

00:44:10.220 --> 00:44:11.840
to do the DDL changes.

00:44:11.840 --> 00:44:13.680
But in principle, it's like,

00:44:13.680 --> 00:44:15.080
every time there's a version change,

00:44:15.080 --> 00:44:18.440
there's some bit of code that is generated that will run.

00:44:18.440 --> 00:44:20.360
And then the other one is about,

00:44:20.360 --> 00:44:21.880
how does this affect performance?

00:44:21.880 --> 00:44:24.800
And I guess the only real performance change is like,

00:44:24.800 --> 00:44:27.200
there'll be a couple of steps to the serialization,

00:44:27.200 --> 00:44:28.220
but they're often small.

00:44:28.220 --> 00:44:31.440
Like in this case, the new version takes the old data

00:44:31.440 --> 00:44:32.920
and says, well, we're just gonna have a list

00:44:32.920 --> 00:44:33.920
with one address.

00:44:33.920 --> 00:44:35.720
So we're gonna stick the one address

00:44:35.720 --> 00:44:38.640
into the list of addresses and vice versa.

00:44:38.640 --> 00:44:41.040
You just set the address field to be the first thing

00:44:41.040 --> 00:44:41.880
in the address list.

00:44:41.880 --> 00:44:44.800
And like, that's a really low amount of code overhead

00:44:44.800 --> 00:44:45.640
to go back.

00:44:45.640 --> 00:44:46.840
And hopefully people are moving

00:44:46.840 --> 00:44:48.840
towards the new versions eventually,

00:44:48.840 --> 00:44:50.400
you know, that kind of thing, right?

00:44:50.400 --> 00:44:52.660
But if they don't, then this code just runs

00:44:52.660 --> 00:44:55.240
to transform the dictionaries that goes back to them, right?

00:44:55.240 --> 00:44:58.020
- Imagine you have like Stripe, I don't know,

00:44:58.020 --> 00:45:00.240
13 years worth of versions.

00:45:00.240 --> 00:45:02.440
Now, if you are a successful company,

00:45:02.440 --> 00:45:03.520
and if you are alive,

00:45:03.520 --> 00:45:06.280
you are probably a successful company after 13 years,

00:45:06.280 --> 00:45:07.800
you know, if you're a successful company,

00:45:07.800 --> 00:45:12.040
that most of your clients will probably be newer ones.

00:45:12.040 --> 00:45:14.120
The longer you exist, the more clients you have,

00:45:14.120 --> 00:45:15.080
and the more clients you have,

00:45:15.080 --> 00:45:17.400
the more, you know, newer clients you have,

00:45:17.400 --> 00:45:19.160
the newer API versions they will use.

00:45:19.160 --> 00:45:20.280
- Even if they're old clients,

00:45:20.280 --> 00:45:22.360
they might decide to,

00:45:22.360 --> 00:45:25.120
they might rewrite their own app and get a new version,

00:45:25.120 --> 00:45:25.960
right?

00:45:25.960 --> 00:45:27.720
Like they could upgrade their code

00:45:27.720 --> 00:45:29.600
'cause their code's gonna be 13 years old

00:45:29.600 --> 00:45:31.320
or 12 years old at this point, right?

00:45:31.320 --> 00:45:32.360
They need to change too.

00:45:32.360 --> 00:45:35.760
- At some point, yes, your old client might,

00:45:35.760 --> 00:45:38.440
you know, from the very first version might request something

00:45:38.440 --> 00:45:40.760
and then we'll go through all converters.

00:45:40.760 --> 00:45:43.180
Well, not all, all converters that are related

00:45:43.180 --> 00:45:45.280
to the specific request and response,

00:45:45.280 --> 00:45:47.920
and that is probably going to be in the tens,

00:45:47.920 --> 00:45:50.800
not even in the hundreds, even after 13 years.

00:45:50.800 --> 00:45:52.900
But your clients from the latest versions,

00:45:52.900 --> 00:45:56.120
or even from the middle versions, will not suffer that.

00:45:56.120 --> 00:45:58.120
So the majority of your clients

00:45:58.120 --> 00:46:01.280
will actually see almost no performance difference.

00:46:01.280 --> 00:46:02.800
And even your old clients,

00:46:02.800 --> 00:46:06.760
even your clients for 13 years old will probably,

00:46:06.760 --> 00:46:08.440
even if they do see a performance difference,

00:46:08.440 --> 00:46:10.680
it's not going to be multiple orders,

00:46:10.680 --> 00:46:12.720
it's not going to be 2X, 3X,

00:46:12.720 --> 00:46:14.720
it's probably going to be maybe 20%,

00:46:14.720 --> 00:46:17.920
maybe even 10%, depending on how slow your app is.

00:46:17.920 --> 00:46:21.180
And that's considering how many years have passed

00:46:21.180 --> 00:46:22.720
is crazy fast.

00:46:22.720 --> 00:46:23.680
- Yeah, absolutely.

00:46:23.680 --> 00:46:24.520
That's very cool.

00:46:24.520 --> 00:46:27.000
So what about the URL?

00:46:27.000 --> 00:46:28.740
What about the end point?

00:46:28.740 --> 00:46:32.120
How much do consumers of your API

00:46:32.120 --> 00:46:33.720
have to actually think about,

00:46:33.720 --> 00:46:36.440
I'm using this version or that version?

00:46:36.440 --> 00:46:39.200
Is it passed as a, is the version passed as a header,

00:46:39.200 --> 00:46:41.280
it's a query string, part of the URL?

00:46:41.280 --> 00:46:43.480
- The version is passed as a header

00:46:43.480 --> 00:46:47.560
and Cadwin by default requires it to be.

00:46:47.560 --> 00:46:49.680
But if you have some developer portal,

00:46:49.680 --> 00:46:52.960
if you want to store your version in some database,

00:46:52.960 --> 00:46:56.320
then even though it's a little more advanced,

00:46:56.320 --> 00:46:58.560
you can write yourself your own middleware

00:46:58.560 --> 00:47:01.640
that will check if the client already has a version

00:47:01.640 --> 00:47:02.620
and then pick that version

00:47:02.620 --> 00:47:06.660
and put it into the context var and it's possible.

00:47:06.660 --> 00:47:09.680
So by default, you're going to have,

00:47:09.680 --> 00:47:13.400
no, no, no, middlewares are the more advanced sections,

00:47:13.400 --> 00:47:14.560
not in the tutorial.

00:47:14.560 --> 00:47:16.320
- There's this other one we're gonna talk about in a section

00:47:16.320 --> 00:47:17.840
has just an example of all,

00:47:17.840 --> 00:47:19.920
you basically just in FastAPI,

00:47:19.920 --> 00:47:21.400
when you create the app,

00:47:21.400 --> 00:47:23.680
like app equals FastAPI,

00:47:23.680 --> 00:47:27.080
you just say middleware equals a list of classes

00:47:27.080 --> 00:47:28.360
that implement these behaviors.

00:47:28.360 --> 00:47:30.000
So what you're suggesting is like,

00:47:30.000 --> 00:47:30.920
you just create a class

00:47:30.920 --> 00:47:33.380
and you pass it in at FastAPI startup.

00:47:33.380 --> 00:47:36.580
And it just goes, is there a version being passed to me?

00:47:36.580 --> 00:47:39.400
If not, let's see who the user is

00:47:39.400 --> 00:47:40.440
based on their API key,

00:47:40.440 --> 00:47:41.400
pull that from a database

00:47:41.400 --> 00:47:43.400
and maybe just set that header right there

00:47:43.400 --> 00:47:45.320
before the request and then let it fly, right?

00:47:45.320 --> 00:47:46.160
Something like that.

00:47:46.160 --> 00:47:48.720
- Yep, and then your API will essentially be Stripe-like

00:47:48.720 --> 00:47:50.360
where your client won't need to

00:47:50.360 --> 00:47:51.840
think about versioning at all.

00:47:51.840 --> 00:47:53.380
But by default, of course,

00:47:53.380 --> 00:47:56.120
the clients need to always pass it with a header,

00:47:56.120 --> 00:48:00.360
which might sound like something really unnecessary

00:48:00.360 --> 00:48:01.440
and hard for the clients.

00:48:01.440 --> 00:48:03.440
But if you imagine that you're writing code,

00:48:03.440 --> 00:48:06.800
it's exceptionally easy to just put it into your,

00:48:06.800 --> 00:48:09.840
I don't know, requests or HTTPS client

00:48:09.840 --> 00:48:11.240
and forget about it, you know?

00:48:11.240 --> 00:48:12.920
- It is pretty easy.

00:48:12.920 --> 00:48:14.560
If you're consuming APIs

00:48:14.560 --> 00:48:16.240
in the fashion that we're talking about,

00:48:16.240 --> 00:48:19.520
you're probably already putting an API key

00:48:19.520 --> 00:48:23.520
or some kind of thing into the header as well, right?

00:48:23.520 --> 00:48:26.000
Like, so you're already messing with the header anyway.

00:48:26.000 --> 00:48:27.080
Just put another value in there.

00:48:27.080 --> 00:48:27.920
- Precisely.

00:48:27.920 --> 00:48:30.900
- All right, so right now this is a FastAPI thing,

00:48:30.900 --> 00:48:34.640
but you're considering opening it up to other areas,

00:48:34.640 --> 00:48:36.400
other platforms, other web frameworks?

00:48:36.400 --> 00:48:39.160
- It has a, what is it called?

00:48:39.160 --> 00:48:40.480
Milestone for that,

00:48:40.480 --> 00:48:44.240
which I am planning to extend with tasks, with plans.

00:48:44.240 --> 00:48:46.480
First, you know, it's like with Pydantic,

00:48:46.480 --> 00:48:49.160
you know, at some point it separated the core

00:48:49.160 --> 00:48:51.440
when it was moving to Pydantic 2,

00:48:51.440 --> 00:48:53.940
and that's one of the plans for Kadwin, you know?

00:48:53.940 --> 00:48:57.040
Separate the core without breaking the public interfaces.

00:48:57.040 --> 00:48:58.440
And then at some point,

00:48:58.440 --> 00:49:01.160
use this core to build more Kadwins, you know?

00:49:01.160 --> 00:49:03.440
Kadwin Django, Kadwin Flask, whatever.

00:49:03.440 --> 00:49:06.200
Or it doesn't even have to be a part of Kadwin.

00:49:06.200 --> 00:49:09.040
The approach is there, so anyone can use it.

00:49:09.040 --> 00:49:13.280
Because 99% of complexity in implementing Kadwin

00:49:13.280 --> 00:49:16.620
was actually figuring out these patterns

00:49:16.620 --> 00:49:18.740
and understanding how to do it.

00:49:18.740 --> 00:49:21.920
Because unlike a web app, unlike, I don't know,

00:49:21.920 --> 00:49:24.020
many apps that we develop daily,

00:49:24.020 --> 00:49:27.440
it doesn't, these things haven't been done.

00:49:27.440 --> 00:49:31.120
People have migrated stuff, but it was mostly, you know,

00:49:31.120 --> 00:49:34.200
oh, change this dictionary without a proper DSL

00:49:34.200 --> 00:49:37.120
or without code generation, you know,

00:49:37.120 --> 00:49:41.800
without the niceties that would make your IDs happy

00:49:41.800 --> 00:49:44.680
and that would make, you know, autocompletion happy.

00:49:44.680 --> 00:49:48.800
- Yeah, you are a contributor to TypeShed, which is awesome.

00:49:48.800 --> 00:49:51.380
So you must care about, you know,

00:49:51.380 --> 00:49:55.040
conveying the type information of the different versions

00:49:55.040 --> 00:49:56.240
and stuff like that.

00:49:56.240 --> 00:49:57.360
That's tricky, right?

00:49:57.360 --> 00:49:59.800
And of course, working on FastAPI and Pydantic,

00:49:59.800 --> 00:50:01.440
those are very type, oh,

00:50:01.440 --> 00:50:03.720
and the shirt says TypeHints for life, I love it.

00:50:03.720 --> 00:50:05.080
I don't have any cool slogan on mine,

00:50:05.080 --> 00:50:09.080
I just have gray stripes, but I should, very cool.

00:50:09.080 --> 00:50:11.280
So yeah, wanna speak to the TypeHint,

00:50:11.280 --> 00:50:13.960
type information aspect of this whole thing?

00:50:13.960 --> 00:50:16.440
- Essentially, as I mentioned,

00:50:16.440 --> 00:50:19.920
Stripe did it using, you know, simply dictionaries

00:50:19.920 --> 00:50:22.920
and it was mostly untyped.

00:50:22.920 --> 00:50:25.080
As probably many people know,

00:50:25.080 --> 00:50:28.920
Stripe, after having so many problems with scalability

00:50:28.920 --> 00:50:30.920
in terms of like the team scalability

00:50:30.920 --> 00:50:33.000
and problems with typing,

00:50:33.000 --> 00:50:36.000
they have decided to adopt Sorbet,

00:50:36.000 --> 00:50:38.120
well, not adopt, create Sorbet,

00:50:38.120 --> 00:50:41.760
which is essentially a type checker.

00:50:41.760 --> 00:50:46.160
It's like a type checker and DSL for Ruby for TypeHints,

00:50:46.160 --> 00:50:47.000
which is really nice.

00:50:47.000 --> 00:50:49.080
It has both the runtime component

00:50:49.080 --> 00:50:52.000
and a static component as far as I remember,

00:50:52.000 --> 00:50:55.480
but they still, most of the time, work with untyped code,

00:50:55.480 --> 00:50:57.800
which essentially can lead to many errors.

00:50:57.800 --> 00:50:59.760
Kadwin tries to make sure

00:50:59.760 --> 00:51:02.040
that you still work with your schemas,

00:51:02.040 --> 00:51:03.800
you still know which schema you work with,

00:51:03.800 --> 00:51:05.160
it's always the latest.

00:51:05.160 --> 00:51:07.640
And Kadwin tries to make sure

00:51:07.640 --> 00:51:11.440
that you're not going to have any type errors

00:51:11.440 --> 00:51:12.760
if you don't want to,

00:51:12.760 --> 00:51:15.280
and you're going to have all of the niceties

00:51:15.280 --> 00:51:19.080
of having this dynamic request response conversion thing.

00:51:19.080 --> 00:51:21.800
So we're trying to take the best of both worlds,

00:51:21.800 --> 00:51:23.720
have you support very little code,

00:51:23.720 --> 00:51:26.480
but like make sure that you can type hint everything

00:51:26.480 --> 00:51:29.040
without any issue and you're not going to have problems

00:51:29.040 --> 00:51:31.880
and your type checker is going to check everything for you.

00:51:31.880 --> 00:51:34.480
And your, I don't know, VS Code is going to see

00:51:34.480 --> 00:51:37.040
which fields something has, which type something has.

00:51:37.040 --> 00:51:37.880
- Yeah, excellent.

00:51:37.880 --> 00:51:39.960
One of the big problems with like

00:51:39.960 --> 00:51:42.440
all the runtime modifications,

00:51:42.440 --> 00:51:44.680
like one way you could have done this is that app startup,

00:51:44.680 --> 00:51:46.520
it could look at all of those things

00:51:46.520 --> 00:51:49.120
and it could just dynamically generate

00:51:49.120 --> 00:51:51.400
all the different versions and all the things,

00:51:51.400 --> 00:51:54.200
you know, using meta programming,

00:51:54.200 --> 00:51:55.880
but then the editors hate that.

00:51:55.880 --> 00:51:58.720
- Yeah, it does that with the endpoints

00:51:58.720 --> 00:52:01.680
because endpoints are not your editors,

00:52:01.680 --> 00:52:03.240
they don't care about endpoints.

00:52:03.240 --> 00:52:06.480
You never call your endpoint from your code.

00:52:06.480 --> 00:52:08.880
No, you usually call the business logic from it,

00:52:08.880 --> 00:52:10.480
which is why I decided to do it in runtime.

00:52:10.480 --> 00:52:11.600
You don't really need it.

00:52:11.600 --> 00:52:14.000
But for Schemas, yes, for Schemas,

00:52:14.000 --> 00:52:16.640
having them generated and then having people guessing

00:52:16.640 --> 00:52:20.640
and then having their IDs just put everything in red,

00:52:20.640 --> 00:52:21.800
that is horrible.

00:52:21.800 --> 00:52:23.440
I wouldn't want anyone to have that.

00:52:23.440 --> 00:52:24.920
- Yeah, yeah, I don't like it either.

00:52:24.920 --> 00:52:25.920
Not at all.

00:52:25.920 --> 00:52:28.840
It's right up there with the star, star, star KW orgs.

00:52:28.840 --> 00:52:31.600
Have a good time guessing in my world.

00:52:31.600 --> 00:52:33.200
- I don't like either of them.

00:52:33.200 --> 00:52:34.080
Awesome, all right.

00:52:34.080 --> 00:52:36.720
Well, let's just maybe touch real quickly

00:52:36.720 --> 00:52:39.720
on a couple of other choices that are out here.

00:52:39.720 --> 00:52:41.040
You know, Kadwin looks awesome,

00:52:41.040 --> 00:52:44.360
but we also have, for example, we have from Dean Way,

00:52:44.360 --> 00:52:45.960
we have FastAPI versioning,

00:52:45.960 --> 00:52:47.480
which has a very different philosophy.

00:52:47.480 --> 00:52:51.720
It has kind of the V1, the V2 style

00:52:51.720 --> 00:52:54.360
that you might maintain multiple versions of.

00:52:54.360 --> 00:52:55.960
You wanna just maybe speak to your thoughts

00:52:55.960 --> 00:52:56.800
on this one real quick

00:52:56.800 --> 00:52:59.160
and people can take that if they like this style.

00:52:59.160 --> 00:53:01.800
- I think it's either the first or the most popular.

00:53:01.800 --> 00:53:02.960
It's definitely the most popular,

00:53:02.960 --> 00:53:06.040
but I think it might even be the first library in FastAPI

00:53:06.040 --> 00:53:09.080
to implement versioning, implement proper versioning.

00:53:09.080 --> 00:53:10.440
It has a few issues.

00:53:10.440 --> 00:53:14.320
First of all, it only, as far as I remember,

00:53:14.320 --> 00:53:15.760
it is mostly duplication based,

00:53:15.760 --> 00:53:17.400
so it doesn't automate anything for you,

00:53:17.400 --> 00:53:19.120
which is a good thing if you know what you're doing

00:53:19.120 --> 00:53:21.880
and you're not going to have a lot of versions.

00:53:21.880 --> 00:53:25.120
But if you have 10 or 20 versions,

00:53:25.120 --> 00:53:27.120
if you wanna keep them for a long time,

00:53:27.120 --> 00:53:31.120
this is the endpoint copying approach that I mentioned,

00:53:31.120 --> 00:53:33.840
that with time is going to kill you,

00:53:33.840 --> 00:53:35.040
which is a problem here.

00:53:35.040 --> 00:53:39.280
The second problem is that it, as far as I understand,

00:53:39.280 --> 00:53:41.920
kind of recommends semantic versioning,

00:53:41.920 --> 00:53:43.800
though it doesn't bind you to it.

00:53:43.800 --> 00:53:45.120
You can use dates,

00:53:45.120 --> 00:53:46.280
though you will have to make sure

00:53:46.280 --> 00:53:47.600
that they're dates yourself,

00:53:47.600 --> 00:53:50.680
and you can use just simple integers.

00:53:50.680 --> 00:53:53.160
So you're not bound by semantic versioning,

00:53:53.160 --> 00:53:55.480
but it has a few examples with that.

00:53:55.480 --> 00:53:58.200
Aside from these two, it's an amazing library,

00:53:58.200 --> 00:54:01.360
and for anyone who just wants to version a small app,

00:54:01.360 --> 00:54:03.920
just add a single version that is going to be,

00:54:03.920 --> 00:54:06.480
the old version is going to be deleted in like two months,

00:54:06.480 --> 00:54:08.880
use that, use FastAPI versioning.

00:54:08.880 --> 00:54:12.280
It's an amazing library and you don't need anything else.

00:54:12.280 --> 00:54:15.520
CADWIN is for use cases where you need to keep

00:54:15.520 --> 00:54:18.280
a larger number of versions,

00:54:18.280 --> 00:54:21.240
or if the changes between your versions are much trickier.

00:54:21.240 --> 00:54:23.360
- Yeah, like this might be pretty good for my example

00:54:23.360 --> 00:54:27.400
I talked about with the courses app that we built, right?

00:54:27.400 --> 00:54:28.880
We literally have two versions.

00:54:28.880 --> 00:54:31.800
It's been around since 2018, and there's two versions.

00:54:31.800 --> 00:54:33.760
You know, like that would be a decorator,

00:54:33.760 --> 00:54:35.640
and I'm probably good to go.

00:54:35.640 --> 00:54:36.880
I don't need to think too much about it.

00:54:36.880 --> 00:54:37.720
- Precisely.

00:54:37.720 --> 00:54:39.040
No code generation, no nothing.

00:54:39.040 --> 00:54:41.520
You just put it in and you go.

00:54:41.520 --> 00:54:44.440
- Another one, if you're a Flask person,

00:54:44.440 --> 00:54:46.200
you could have Flask Rebar,

00:54:46.200 --> 00:54:49.960
which seems to have a real similar philosophy

00:54:49.960 --> 00:54:52.680
to what you just described, but it works for Flask.

00:54:52.680 --> 00:54:56.920
I feel like it's a little more complex than that.

00:54:56.920 --> 00:54:59.240
It is also the parent point.

00:54:59.240 --> 00:55:02.880
So it also allows you to duplicate single endpoints.

00:55:02.880 --> 00:55:05.880
It also allows you to do arbitrary prefixes.

00:55:05.880 --> 00:55:07.560
So you can have integers, you can have dates,

00:55:07.560 --> 00:55:09.360
you can have, you know, whatever.

00:55:09.360 --> 00:55:11.320
- Old, new, whatever.

00:55:11.320 --> 00:55:12.520
- Yeah, old, new.

00:55:12.520 --> 00:55:14.560
I guess some people do that.

00:55:14.560 --> 00:55:16.000
- If you want.

00:55:16.000 --> 00:55:17.560
- Yeah, latest, latest.

00:55:17.560 --> 00:55:18.400
- Yeah, yeah.

00:55:18.400 --> 00:55:19.960
Latest, really latest, final.

00:55:19.960 --> 00:55:21.800
- Like a new folder, new folder.

00:55:21.800 --> 00:55:22.840
- Yes, exactly.

00:55:22.840 --> 00:55:26.040
- But yeah, it's really similar.

00:55:26.040 --> 00:55:26.880
And I guess-

00:55:26.880 --> 00:55:28.640
- They probably use zipping up folders

00:55:28.640 --> 00:55:29.800
for version control as well.

00:55:29.800 --> 00:55:31.400
I'm just naming them by the date.

00:55:31.400 --> 00:55:32.680
Final, final, final.

00:55:32.680 --> 00:55:34.400
- Let's not use, let's not use Git.

00:55:34.400 --> 00:55:36.240
Let's just copy them.

00:55:36.240 --> 00:55:38.800
As for versioning, that's like a really good metaphor.

00:55:38.800 --> 00:55:42.320
If you are a person that just needs another version

00:55:42.320 --> 00:55:44.560
of their Google Doc, you wouldn't use Git.

00:55:44.560 --> 00:55:46.920
Well, unless you use Git for everything else.

00:55:46.920 --> 00:55:47.760
And same here.

00:55:47.760 --> 00:55:52.080
You don't need a huge combine for using Flask.

00:55:52.080 --> 00:55:54.520
And Flask usually, at least in my experience,

00:55:54.520 --> 00:55:56.760
tries to build simpler APIs.

00:55:56.760 --> 00:55:58.200
And you wouldn't use, well,

00:55:58.200 --> 00:56:02.360
most companies that do API first don't use Flask.

00:56:02.360 --> 00:56:06.200
They try to do, you know, Django DRF or FastAPI,

00:56:06.200 --> 00:56:09.040
which is why this library seems like a perfect choice

00:56:09.040 --> 00:56:09.880
for that.

00:56:09.880 --> 00:56:10.720
- Yeah, indeed.

00:56:10.720 --> 00:56:11.560
It seems really nice.

00:56:11.560 --> 00:56:14.240
One of the things that, we were speaking of duplication,

00:56:14.240 --> 00:56:16.840
one of the things that they just jumped right into

00:56:16.840 --> 00:56:18.640
to demonstrate here,

00:56:18.640 --> 00:56:22.360
and I imagine the FastAPI version one as well could do it,

00:56:22.360 --> 00:56:25.680
but there's one endpoint that doesn't change.

00:56:25.680 --> 00:56:27.080
And there's one that is different.

00:56:27.080 --> 00:56:28.560
So they copy the one that's different,

00:56:28.560 --> 00:56:29.840
but for the one that doesn't change,

00:56:29.840 --> 00:56:33.480
they just put a V1 and a V2 decorator on that one.

00:56:33.480 --> 00:56:35.720
And it remains unchanged basically, right?

00:56:35.720 --> 00:56:39.000
- Kadwin tries to escape this kind of verbosity.

00:56:39.000 --> 00:56:41.480
And essentially you have all endpoints everywhere.

00:56:41.480 --> 00:56:42.600
And if you wanna, you know,

00:56:42.600 --> 00:56:44.680
omit some endpoint or change some endpoint

00:56:44.680 --> 00:56:47.200
or add some endpoint into the new version,

00:56:47.200 --> 00:56:49.680
you just add a version change and say,

00:56:49.680 --> 00:56:53.160
oh, this endpoint didn't exist in the old version.

00:56:53.160 --> 00:56:54.000
That's it.

00:56:54.000 --> 00:56:54.840
- Very cool.

00:56:54.840 --> 00:56:55.680
Yeah, because if you had 20 of these,

00:56:55.680 --> 00:56:59.000
you'd have 20 decorators in the little function, right?

00:56:59.000 --> 00:56:59.920
That's where it starts to get.

00:56:59.920 --> 00:57:01.680
- Not a huge issue for Flask.

00:57:01.680 --> 00:57:03.760
I haven't seen anyone building, I don't know,

00:57:03.760 --> 00:57:08.000
50 or 200 endpoints apps with Flask.

00:57:08.000 --> 00:57:10.880
I'm sure people do that, but I think it's the minority.

00:57:10.880 --> 00:57:13.560
- Other side of the fence, Django REST framework, DRF.

00:57:13.560 --> 00:57:15.120
You already mentioned them a little bit.

00:57:15.120 --> 00:57:18.840
And so Django, they already have like versioning

00:57:18.840 --> 00:57:21.480
built into the framework itself, right?

00:57:21.480 --> 00:57:23.720
- They have versioning interfaces built into.

00:57:23.720 --> 00:57:25.280
So like, it's not,

00:57:25.280 --> 00:57:27.840
they're not implementing versioning for you,

00:57:27.840 --> 00:57:29.560
but they give you all the tools

00:57:29.560 --> 00:57:30.960
to implement your own versioning.

00:57:30.960 --> 00:57:31.800
- Yeah, okay.

00:57:31.800 --> 00:57:33.560
So they kind of have the building blocks for it.

00:57:33.560 --> 00:57:34.480
Excellent. - Exactly.

00:57:34.480 --> 00:57:35.320
- All right.

00:57:35.320 --> 00:57:37.800
Well, I think we're pretty much out of time,

00:57:37.800 --> 00:57:39.080
but thank you for being here.

00:57:39.080 --> 00:57:40.280
This has been really interesting.

00:57:40.280 --> 00:57:41.840
- Oh, it was for me as well.

00:57:41.840 --> 00:57:42.960
Thank you for having me here.

00:57:42.960 --> 00:57:44.760
- Yeah, you've given everyone a lot to think about.

00:57:44.760 --> 00:57:47.120
You know, before we wrap it up, two quick things,

00:57:47.120 --> 00:57:49.440
you know, notable PyPI package.

00:57:49.440 --> 00:57:51.720
I mean, we've already given Kadwin a shout out.

00:57:51.720 --> 00:57:54.280
Anything else that like, oh, I came across this

00:57:54.280 --> 00:57:55.360
and it was super cool.

00:57:55.360 --> 00:57:57.440
Maybe it deserves a little bit of a shout out.

00:57:57.440 --> 00:57:59.760
Anything that like you use a lot that you would recommend?

00:57:59.760 --> 00:58:01.520
- For us in our company,

00:58:01.520 --> 00:58:04.360
we started using one more package of mine.

00:58:04.360 --> 00:58:06.480
It's called ByteTest fixture classes.

00:58:06.480 --> 00:58:07.400
- Okay. - Essentially,

00:58:07.400 --> 00:58:09.800
when you are building groups of fixtures

00:58:09.800 --> 00:58:12.200
that create some objects for you,

00:58:12.200 --> 00:58:13.680
for you to use in your tests,

00:58:13.680 --> 00:58:16.000
and then all of a sudden one of your tests

00:58:16.000 --> 00:58:18.200
needs an object that's a little different,

00:58:18.200 --> 00:58:19.720
you know, just a little bit,

00:58:19.720 --> 00:58:21.280
and then everything just falls apart.

00:58:21.280 --> 00:58:22.120
- Yeah.

00:58:22.120 --> 00:58:26.000
- A factory fixture pattern that you can see in ByteTest

00:58:26.000 --> 00:58:29.760
allows you to, you know, make a function within a function

00:58:29.760 --> 00:58:33.360
and one of them is a fixture and that's all cool and nice,

00:58:33.360 --> 00:58:35.480
but then it's not typed.

00:58:35.480 --> 00:58:38.240
You can use, you know, the callable syntax

00:58:38.240 --> 00:58:39.560
and then you're not going to have

00:58:39.560 --> 00:58:41.120
the keyword arguments there.

00:58:41.120 --> 00:58:43.920
And otherwise you can write a protocol

00:58:43.920 --> 00:58:45.840
and it's a lot of code.

00:58:45.840 --> 00:58:47.720
What ByteTest fixture classes does

00:58:47.720 --> 00:58:50.520
is it allows you to type everything there.

00:58:50.520 --> 00:58:53.360
So you write the same amount of code,

00:58:53.360 --> 00:58:55.440
but it's all typed and now you have,

00:58:55.440 --> 00:58:58.040
you can have groups of fixture classes

00:58:58.040 --> 00:58:59.600
building on top of each other,

00:58:59.600 --> 00:59:01.520
which is a nice pattern to have,

00:59:01.520 --> 00:59:03.680
but a really bad pattern to abuse.

00:59:03.680 --> 00:59:04.520
- Very cool.

00:59:04.520 --> 00:59:06.880
All right, well, nice, nice recommendation.

00:59:06.880 --> 00:59:07.800
People can check that out.

00:59:07.800 --> 00:59:09.600
Emil, our audience already says,

00:59:09.600 --> 00:59:11.400
"Amazing thing, I'm already using it."

00:59:11.400 --> 00:59:15.000
So final call to action, people have APIs,

00:59:15.000 --> 00:59:16.800
they've listened to us talk for an hour

00:59:16.800 --> 00:59:20.000
and they're like, "Oh, we should be versioning our APIs.

00:59:20.000 --> 00:59:23.240
"We probably should be doing something here."

00:59:23.240 --> 00:59:24.360
What do you recommend people do?

00:59:24.360 --> 00:59:25.440
How do they get started?

00:59:25.440 --> 00:59:26.640
How do they go further?

00:59:26.640 --> 00:59:28.080
- So first you need to decide

00:59:28.080 --> 00:59:30.000
whether your use case is simple.

00:59:30.000 --> 00:59:31.920
How many versions are you going to support?

00:59:31.920 --> 00:59:34.440
If you're not planning to support more than two versions

00:59:34.440 --> 00:59:36.960
or if you are supporting versions

00:59:36.960 --> 00:59:39.200
only for your internal microservices

00:59:39.200 --> 00:59:41.240
or only for your front end,

00:59:41.240 --> 00:59:44.000
then consider using the simple tools.

00:59:44.000 --> 00:59:46.440
Consider using the FastAPI versioning,

00:59:46.440 --> 00:59:49.600
you know, Flask, Raybar, things like that.

00:59:49.600 --> 00:59:52.280
But then once you realize

00:59:52.280 --> 00:59:54.800
that you need to support versions for months

00:59:54.800 --> 00:59:56.800
and you need three or more versions

00:59:56.800 --> 00:59:59.520
and you're providing your versions as a public,

00:59:59.520 --> 01:00:01.080
you know, to the public,

01:00:01.080 --> 01:00:04.200
then I advise moving straight into CADWIN

01:00:04.200 --> 01:00:06.120
or CADWIN-like frameworks.

01:00:06.120 --> 01:00:08.560
If you use FastAPI, you can just use CADWIN.

01:00:08.560 --> 01:00:10.560
It has a bit of a learning curve,

01:00:10.560 --> 01:00:12.400
but within making one version,

01:00:12.400 --> 01:00:14.480
you will realize just how simple it is.

01:00:14.480 --> 01:00:17.720
And if you're not using CADWIN, that's fine as well.

01:00:17.720 --> 01:00:21.080
I have all of the resources that I used to build it

01:00:21.080 --> 01:00:23.600
and all of the resources, you know,

01:00:23.600 --> 01:00:26.160
describing different ways of API versioning

01:00:26.160 --> 01:00:28.840
there in the repository in the theory section.

01:00:28.840 --> 01:00:30.200
So you can just read that.

01:00:30.200 --> 01:00:32.440
And even if you don't like that approach,

01:00:32.440 --> 01:00:34.560
we describe everything else there.

01:00:34.560 --> 01:00:36.960
So you'll be able to pick the one you like.

01:00:36.960 --> 01:00:38.680
But my personal recommendation,

01:00:38.680 --> 01:00:40.120
don't pick the directories.

01:00:40.120 --> 01:00:41.680
They're painful.

01:00:41.680 --> 01:00:43.520
- Awesome. Really good advice.

01:00:43.520 --> 01:00:44.920
Super cool project.

01:00:44.920 --> 01:00:47.160
So thank you for being here Stanislav.

01:00:47.160 --> 01:00:48.320
And talk to you later.

01:00:48.320 --> 01:00:49.720
- Talk to you later.

01:00:49.720 --> 01:00:52.960
- This has been another episode of "Talk Python to Me."

01:00:52.960 --> 01:00:54.400
Thank you to our sponsors.

01:00:54.400 --> 01:00:55.760
Be sure to check out what they're offering.

01:00:55.760 --> 01:00:57.400
It really helps support the show.

01:00:57.400 --> 01:01:01.400
It's time to stop asking relational databases

01:01:01.400 --> 01:01:03.200
to do more than they were made for

01:01:03.200 --> 01:01:06.760
and simplify complex data models with graphs.

01:01:06.760 --> 01:01:09.120
Check out the sample FastAPI project

01:01:09.120 --> 01:01:13.360
and see what Neo4j, a native graph database, can do for you.

01:01:13.360 --> 01:01:17.640
Find out more at talkpython.fm/neo4j.

01:01:17.640 --> 01:01:20.880
Take some stress out of your life.

01:01:20.880 --> 01:01:23.040
Get notified immediately about errors

01:01:23.040 --> 01:01:25.040
and performance issues in your web

01:01:25.040 --> 01:01:26.960
or mobile applications with Sentry.

01:01:26.960 --> 01:01:31.840
Just visit talkpython.fm/sentry and get started for free.

01:01:31.840 --> 01:01:35.240
And be sure to use the promo code, talkpython, all one word.

01:01:36.200 --> 01:01:37.520
Want to level up your Python?

01:01:37.520 --> 01:01:39.280
We have one of the largest catalogs

01:01:39.280 --> 01:01:41.640
of Python video courses over at Talk Python.

01:01:41.640 --> 01:01:43.720
Our content ranges from true beginners

01:01:43.720 --> 01:01:46.680
to deeply advanced topics like memory and async.

01:01:46.680 --> 01:01:49.320
And best of all, there's not a subscription in sight.

01:01:49.320 --> 01:01:52.560
Check it out for yourself at training.talkpython.fm.

01:01:52.560 --> 01:01:54.160
Be sure to subscribe to the show.

01:01:54.160 --> 01:01:57.160
Open your favorite podcast app and search for Python.

01:01:57.160 --> 01:01:58.520
We should be right at the top.

01:01:58.520 --> 01:02:01.400
You can also find the iTunes feed at /iTunes,

01:02:01.400 --> 01:02:03.600
the Google Play feed at /play,

01:02:03.600 --> 01:02:08.040
and the direct RSS feed at /rss on talkpython.fm.

01:02:08.040 --> 01:02:10.640
We're live streaming most of our recordings these days.

01:02:10.640 --> 01:02:11.800
If you want to be part of the show

01:02:11.800 --> 01:02:14.080
and have your comments featured on the air,

01:02:14.080 --> 01:02:15.920
be sure to subscribe to our YouTube channel

01:02:15.920 --> 01:02:19.160
at talkpython.fm/youtube.

01:02:19.160 --> 01:02:20.560
This is your host, Michael Kennedy.

01:02:20.560 --> 01:02:21.720
Thanks so much for listening.

01:02:21.720 --> 01:02:22.960
I really appreciate it.

01:02:22.960 --> 01:02:25.480
Now get out there and write some Python code.

01:02:25.480 --> 01:02:28.060
(upbeat music)

01:02:43.540 --> 01:02:45.580
Thank you for watching.

