WEBVTT

00:00:00.001 --> 00:00:04.980
You've built an awesome set of APIs, and now you have a wide array of devices and clients

00:00:04.980 --> 00:00:10.380
using them. Congratulations. Then you need to upgrade an endpoint or make a change that is

00:00:10.380 --> 00:00:15.980
meaningful in some way. Now what? That's the conversation I dive into over the next hour

00:00:15.980 --> 00:00:21.960
with Stanislav Zmiev. We're talking about versioning APIs on this, the 450th episode

00:00:21.960 --> 00:00:25.300
of Talk Python To Me, recorded January 8th, 2024.

00:00:25.300 --> 00:00:44.700
Welcome to Talk Python To Me, a weekly podcast on Python. This is your host, Michael Kennedy.

00:00:44.700 --> 00:00:49.760
Follow me on Mastodon, where I'm @mkennedy, and follow the podcast using @talkpython,

00:00:49.760 --> 00:00:55.280
both on fosstodon.org. Keep up with the show and listen to over seven years of past

00:00:55.280 --> 00:01:01.080
episodes at talkpython.fm. We've started streaming most of our episodes live on YouTube.

00:01:01.080 --> 00:01:05.720
Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified

00:01:05.720 --> 00:01:08.620
about upcoming shows and be part of that episode.

00:01:08.620 --> 00:01:16.900
This episode is sponsored by Neo4j. It's time to stop asking relational databases to do more than

00:01:16.900 --> 00:01:23.680
they were made for and simplify complex data models with graphs. Check out the sample FastAPI project

00:01:23.680 --> 00:01:30.820
and see what Neo4j, a native graph database, can do for you. Find out more at talkpython.fm slash

00:01:30.820 --> 00:01:38.320
Neo4j. And it's brought to you by Sentry. Don't let those errors go unnoticed. Use Sentry like we do

00:01:38.320 --> 00:01:42.480
here at Talk Python. Sign up at talkpython.fm/sentry.

00:01:42.480 --> 00:01:46.900
Stanislav, welcome to Talk Python To Me. It's great to have you here.

00:01:47.160 --> 00:01:53.460
It's good to be here. Yeah, it's good to have you here. I wonder what version that we're going to end up shipping of this episode.

00:01:53.460 --> 00:01:56.740
We're going to talk about API versions.

00:01:56.740 --> 00:01:59.100
API versions, API versions.

00:01:59.100 --> 00:02:00.620
It's good to have many of them, you know?

00:02:00.720 --> 00:02:06.260
Yeah, it's one of those problems that, you know, as soon as you create an API and people start to use it,

00:02:06.260 --> 00:02:08.180
they don't want to keep rewriting their code.

00:02:08.180 --> 00:02:15.800
So, but you need to evolve your API over time as it gets new features, as maybe more importantly,

00:02:15.800 --> 00:02:18.040
you realize like, oh, that was a bad choice.

00:02:18.040 --> 00:02:19.680
How do you fix this, right?

00:02:19.780 --> 00:02:22.320
So that's kind of the theme of this episode.

00:02:22.320 --> 00:02:30.880
We're going to talk about concrete tools that you can use to add versioning to various API frameworks in Python

00:02:30.880 --> 00:02:32.500
and some of the ideas behind it.

00:02:32.500 --> 00:02:34.080
So it's going to be a ton of fun.

00:02:34.080 --> 00:02:36.560
Let's start, though, with your story.

00:02:36.560 --> 00:02:37.820
Tell us a bit about yourself.

00:02:37.820 --> 00:02:43.460
Previously, I have been a back-end engineer for six or even seven years now.

00:02:43.460 --> 00:02:48.260
But recently, I have shifted into infrastructure.

00:02:48.860 --> 00:02:52.040
Right now, I'm a platform engineering tech lead at Monite.

00:02:52.040 --> 00:02:55.440
What I do is I make architectural decisions.

00:02:55.440 --> 00:02:57.140
I mentor the teams.

00:02:57.140 --> 00:03:00.760
I help the teams with Python-specific questions.

00:03:00.760 --> 00:03:04.000
But mostly, I build Python-specific infrastructure.

00:03:04.000 --> 00:03:07.600
And my main job is making our business teams happy.

00:03:07.600 --> 00:03:10.860
I try to do that in my open source work as well.

00:03:10.860 --> 00:03:13.400
I like to make my own open source projects.

00:03:13.400 --> 00:03:16.000
I like to contribute to big projects, small projects.

00:03:16.000 --> 00:03:17.520
It's all over the place.

00:03:17.920 --> 00:03:19.420
And we're going to be mentioning one of them today.

00:03:19.420 --> 00:03:19.720
Yeah.

00:03:19.720 --> 00:03:22.000
You build a really cool library that we're going to talk about.

00:03:22.000 --> 00:03:23.280
And that'll be a lot of fun.

00:03:23.280 --> 00:03:24.040
It looks really useful.

00:03:24.040 --> 00:03:26.760
And some other third-party ones as well.

00:03:26.760 --> 00:03:33.200
So I wanted to ask you a little bit about what is the difference between being a back-end software developer,

00:03:33.200 --> 00:03:41.220
which I think a lot of people get the sense of, like building APIs, building the back-end, at least, aspect of websites and so on,

00:03:41.440 --> 00:03:43.880
versus, say, building infrastructure in Python.

00:03:43.880 --> 00:03:45.200
Like, what are these two worlds?

00:03:45.200 --> 00:03:45.880
How are they the same?

00:03:45.880 --> 00:03:46.400
How are they different?

00:03:46.400 --> 00:03:50.940
So when you're building them, especially when you're building products, it's very similar.

00:03:50.940 --> 00:03:56.700
However, in back-end, there is already a lot of infrastructure around you.

00:03:56.700 --> 00:04:01.000
There is already a lot of people who do portions of your job.

00:04:01.000 --> 00:04:03.860
So, like, there are people who can sell your product.

00:04:03.860 --> 00:04:08.600
There are people who are thinking about how to, you know, how to move it forward, how to evolve it.

00:04:08.600 --> 00:04:12.240
There are people who are, you know, designing it, thinking about it.

00:04:12.240 --> 00:04:15.500
But when you're a platform engineer, you've got to do all of that yourself.

00:04:15.500 --> 00:04:23.240
And also, one big portion of any library framework or anything else, any developer tools development,

00:04:23.240 --> 00:04:32.820
is the fact that unlike an API, well, a web API, a REST API, which has a very strict sort of interface

00:04:32.820 --> 00:04:36.020
where the developer wouldn't be able to use it in a million ways.

00:04:36.020 --> 00:04:43.560
A library, especially in a language as introspective as Python, the developers can do crazy things with your stuff.

00:04:43.560 --> 00:04:47.040
So you've got to think forward for all of these use cases.

00:04:47.040 --> 00:04:51.660
And you've got to be sure that you don't expose extra private interfaces.

00:04:51.660 --> 00:04:56.320
Because once you do expose them, it won't be nice to break them in the future.

00:04:56.560 --> 00:05:01.840
I guess it's a little more restricted with APIs than it is with handing out packages, right?

00:05:01.840 --> 00:05:05.940
Because people, they can just dive into the packages and do whatever you want.

00:05:05.940 --> 00:05:10.380
And the API is more or less limited by what the website's willing to process, right?

00:05:10.380 --> 00:05:10.660
Yep.

00:05:10.660 --> 00:05:13.620
On the flip side, you have code on the internet.

00:05:13.620 --> 00:05:17.640
And anytime you have code on the internet, that's always a little stressful, right?

00:05:17.640 --> 00:05:20.380
Just like whatever is out there, it's incredible.

00:05:20.380 --> 00:05:25.720
If you have a website, you pull up the logs, how much abuse your website is taking constantly.

00:05:26.120 --> 00:05:26.160
True.

00:05:26.160 --> 00:05:31.360
The great thing about building packages is that you're not worried about what happens with them after.

00:05:31.360 --> 00:05:32.640
You know, you just skim them.

00:05:32.640 --> 00:05:35.160
And then if it breaks, it's not you.

00:05:35.160 --> 00:05:37.820
It's not on your servers, hopefully.

00:05:37.820 --> 00:05:41.740
But also, as I mentioned, you've got to both be its designer.

00:05:41.740 --> 00:05:42.780
You've got to sell it.

00:05:42.780 --> 00:05:44.680
You've got to people through that.

00:05:44.680 --> 00:05:45.640
You've got to document it.

00:05:45.640 --> 00:05:50.440
You've got to, as a platform engineer, you do all of the parts that backend engineers are

00:05:50.440 --> 00:05:55.160
abstracted away from, or at least in most bigger companies, abstracted away from.

00:05:55.160 --> 00:05:56.160
Yeah, super interesting.

00:05:56.160 --> 00:05:56.840
All right.

00:05:56.840 --> 00:06:01.920
Let's talk about, I guess, one more thing for your introduction before we move on.

00:06:01.920 --> 00:06:05.040
You've worked on quite a few interesting projects here.

00:06:05.040 --> 00:06:08.980
So maybe give us just a little bit of background on some of your open source work.

00:06:09.120 --> 00:06:11.680
I'll just talk about, I guess, the most popular ones.

00:06:11.680 --> 00:06:14.080
The coolest one was PathWalk.

00:06:14.080 --> 00:06:16.360
If you remember, in Python, there is OSWalk.

00:06:16.360 --> 00:06:19.740
But then in Python 312, I added PathWalk.

00:06:19.960 --> 00:06:23.040
I have also added the type hints for that into TypeShed.

00:06:23.040 --> 00:06:24.560
I think some other things.

00:06:24.560 --> 00:06:33.280
And I am, I think, top 10 contributor of Tortoise ORM, the asynchronous ORM that claims to be the

00:06:33.280 --> 00:06:36.020
fastest, or at least one of the fastest in Python.

00:06:36.020 --> 00:06:43.120
And a few smaller projects, which I don't think there is anything particularly fun to talk about there.

00:06:43.120 --> 00:06:45.600
It's just mostly bug fixes and small features.

00:06:45.600 --> 00:06:50.300
But then my other projects, the ones that I maintain, are way cooler.

00:06:50.480 --> 00:06:57.600
For example, Pydantic Duality enables you to have multiple versions of your Pydantic models for

00:06:57.600 --> 00:07:02.520
almost free in terms of performance and without any code generation.

00:07:02.520 --> 00:07:08.980
And Cadwin, the project we're going to be discussing today, implements, I guess, the fullest and most

00:07:08.980 --> 00:07:12.460
sophisticated API versioning paradigm there is at this point.

00:07:12.460 --> 00:07:12.820
Excellent.

00:07:12.820 --> 00:07:13.140
Yeah.

00:07:13.140 --> 00:07:14.100
A lot of cool stuff.

00:07:14.100 --> 00:07:17.360
Pydantic Duality looks, yeah, Pydantic Duality looks really, really cool.

00:07:17.360 --> 00:07:19.120
So a lot of neat stuff here.

00:07:19.120 --> 00:07:21.760
A lot of different ways people might know about you.

00:07:21.760 --> 00:07:24.900
So yeah, Cadwin is the one we're going to be focusing on for here.

00:07:24.900 --> 00:07:28.360
So let's start with talking about APIs.

00:07:28.360 --> 00:07:32.040
You talked about API-first companies.

00:07:32.040 --> 00:07:32.620
What's that?

00:07:32.620 --> 00:07:39.280
API-first company, just like any other term that gets popular, is a buzzword, obviously.

00:07:39.280 --> 00:07:47.180
But the truth behind it is an API-first company is any company whose main product is an API

00:07:47.180 --> 00:07:49.680
and the SDKs associated with it.

00:07:49.680 --> 00:07:56.620
And as a result, API-first company has to document their API really thoroughly, think about their

00:07:56.620 --> 00:08:02.240
API, both the internal one and the external one, and take great care of that because it's

00:08:02.240 --> 00:08:03.000
their main product.

00:08:03.180 --> 00:08:07.060
We have a lot of API-first companies right now.

00:08:07.060 --> 00:08:09.940
But with every year, new industries are joining.

00:08:09.940 --> 00:08:16.000
And if you've ever heard of open banking, things like that, banks are going to join us soon.

00:08:16.000 --> 00:08:17.460
In some countries, they already have.

00:08:17.460 --> 00:08:24.780
And Monite is doing similar things and tries to bring that innovation, that open banking,

00:08:24.900 --> 00:08:27.300
that API-first approach into banking.

00:08:27.300 --> 00:08:27.580
Yeah.

00:08:27.580 --> 00:08:34.400
So the company you work for Monite, they build, you all build APIs to basically facilitate

00:08:34.400 --> 00:08:37.540
other people doing invoicing and bill pay in their apps.

00:08:37.540 --> 00:08:38.040
Is that correct?

00:08:38.040 --> 00:08:38.320
Yeah.

00:08:38.320 --> 00:08:41.120
You could call us a B2B2B company.

00:08:41.660 --> 00:08:48.620
Because essentially, many banks, many marketplaces are very outdated in terms of how they handle

00:08:48.620 --> 00:08:49.800
invoicing and payments.

00:08:49.800 --> 00:08:56.400
And we try to take all of that, combine that, and offer that as a white label product to them.

00:08:56.400 --> 00:08:58.220
So we do this for them.

00:08:58.220 --> 00:09:02.780
They integrate with us once, and then they forget it was ever a problem.

00:09:03.040 --> 00:09:06.400
They just give our product as theirs straight to their clients.

00:09:06.400 --> 00:09:06.720
Yeah.

00:09:06.720 --> 00:09:07.800
That's excellent.

00:09:07.800 --> 00:09:12.060
So this seems like kind of in that category of API-first.

00:09:12.060 --> 00:09:12.660
Oh, yes.

00:09:12.660 --> 00:09:12.980
Yeah.

00:09:12.980 --> 00:09:13.440
Okay.

00:09:13.440 --> 00:09:17.320
It's cool that you have concrete experience with it, right?

00:09:17.320 --> 00:09:17.880
Of course.

00:09:17.880 --> 00:09:20.140
Give us some of the laws.

00:09:20.140 --> 00:09:22.400
We coordinated a little bit beforehand.

00:09:22.400 --> 00:09:26.360
And there's some interesting laws for designing good APIs.

00:09:26.360 --> 00:09:32.920
Like one of them is the reverse Conway maneuver, which to me sounds like a jujitsu sort of

00:09:32.920 --> 00:09:34.600
move that you might try to pull.

00:09:34.600 --> 00:09:35.340
What is this?

00:09:35.340 --> 00:09:35.740
Oh, yes.

00:09:35.740 --> 00:09:42.720
So when you are designing any system, you got to think about the way it's going to end up

00:09:42.720 --> 00:09:44.780
and the laws that are going to govern them.

00:09:44.780 --> 00:09:48.160
And Conway's law is one of the main laws that do that.

00:09:48.160 --> 00:09:53.660
To explain that to people in simple terms, if you have four teams designing a compiler,

00:09:53.660 --> 00:09:55.680
you're going to have a four-pass compiler.

00:09:55.680 --> 00:10:01.720
Essentially, the way you set up communications within your company, the way you set up your teams,

00:10:01.860 --> 00:10:04.760
your structure is going to be reflected in your product.

00:10:04.760 --> 00:10:06.240
And you can't do anything about it.

00:10:06.240 --> 00:10:07.300
You can spend money.

00:10:07.300 --> 00:10:08.840
You can coordinate people.

00:10:08.840 --> 00:10:12.260
But at some point, Conway's law is going to affect you.

00:10:12.260 --> 00:10:13.600
And it's going to be harsh.

00:10:13.600 --> 00:10:19.860
So one of the ways to go around it is to first think of an interface that you want to provide.

00:10:20.060 --> 00:10:22.260
And it applies to anything, not just APIs.

00:10:22.260 --> 00:10:24.480
APIs is just a really good example of that.

00:10:24.480 --> 00:10:31.060
And then design your company and the communications within your company, the teams within your company,

00:10:31.060 --> 00:10:34.860
to reflect the interfaces that you want to get in the end.

00:10:34.860 --> 00:10:36.600
And that's reverse Conway maneuver.

00:10:36.760 --> 00:10:37.000
Okay.

00:10:37.000 --> 00:10:41.640
Because your code and your APIs and all those things are going to reflect your company structure

00:10:41.640 --> 00:10:42.180
and culture.

00:10:42.180 --> 00:10:47.840
So instead of having that being implicit, make it more explicit by saying, well, this is the

00:10:47.840 --> 00:10:50.420
endpoint that we want, the end result that we want.

00:10:50.420 --> 00:10:55.440
How do we work that backwards to end up structuring teams or whatever to get this right?

00:10:55.440 --> 00:10:56.060
Precisely.

00:10:56.060 --> 00:10:56.420
Yes.

00:10:56.560 --> 00:10:56.720
Yeah.

00:10:56.720 --> 00:10:58.340
It is a little bit like jujitsu.

00:10:58.340 --> 00:10:58.760
Anyway.

00:10:58.760 --> 00:11:02.580
But there are more laws that do that.

00:11:02.580 --> 00:11:06.340
Of course, there is REST, which I guess not really laws, but principles.

00:11:06.340 --> 00:11:06.900
Yeah.

00:11:06.900 --> 00:11:13.280
Which most people, or at least most companies I saw, don't really like to follow it to the

00:11:13.280 --> 00:11:13.560
letter.

00:11:13.560 --> 00:11:22.720
But if you do, if you do follow REST, if you try to make your API as available as you can

00:11:22.720 --> 00:11:27.240
and as standardized as you can, then it's much easier for new people, especially junior

00:11:27.240 --> 00:11:28.260
developers to learn.

00:11:28.260 --> 00:11:32.840
And then that makes it much easier for your clients to integrate with you, which is great.

00:11:32.840 --> 00:11:37.580
There is also, there are also a few, I guess, more advanced things.

00:11:37.580 --> 00:11:41.720
For example, when you are designing an API, when you're doing microservices and when you

00:11:41.720 --> 00:11:47.560
have many services talking to each other, which in the end provide your final product to your

00:11:47.560 --> 00:11:51.840
customers, a good idea is to omit any internal APIs.

00:11:51.840 --> 00:11:56.460
And make all of your APIs, or at least the majority of your APIs external.

00:11:56.460 --> 00:11:59.580
That is also one of the things about API first.

00:11:59.580 --> 00:12:06.320
Once all of your APIs are external, it means that your clients will be able to build a product

00:12:06.320 --> 00:12:08.440
that is of similar quality to yours.

00:12:08.440 --> 00:12:14.320
We're using your APIs, using your data, which provides them with infinite capabilities of using

00:12:14.320 --> 00:12:15.380
you, which is great.

00:12:15.380 --> 00:12:16.140
Yeah, that is great.

00:12:16.440 --> 00:12:21.000
It's certainly frustrating when you see, you know, it's not on the API level, but you

00:12:21.000 --> 00:12:27.080
see things in like the iOS platform or in Windows or wherever you're like, why can't I do this?

00:12:27.080 --> 00:12:31.980
Like, these are private things that either Apple or Microsoft or whoever are keeping to themselves

00:12:31.980 --> 00:12:35.960
and clearly are important for building apps, but you can't use them, right?

00:12:36.000 --> 00:12:41.800
So you're suggesting that by having basically whatever APIs you need, I guess there's probably

00:12:41.800 --> 00:12:42.520
limits, right?

00:12:42.520 --> 00:12:46.980
Like you don't want to expose, say you're like HR API if you're not an HR company, right?

00:12:46.980 --> 00:12:51.380
But in general, having your APIs just be all public, right?

00:12:51.380 --> 00:12:54.840
It probably makes them better as well because they just get so many more use cases.

00:12:54.840 --> 00:12:58.080
They get treated with things like versioning and stuff more seriously.

00:12:58.080 --> 00:12:58.640
Exactly.

00:12:58.640 --> 00:12:59.160
Excellent.

00:12:59.160 --> 00:13:03.680
It's a complex topic that could span, you know, we could discuss it for hours, you know,

00:13:03.680 --> 00:13:06.120
which parts of your API do you make public?

00:13:06.120 --> 00:13:09.200
Which parts of your API do you start versioning?

00:13:09.200 --> 00:13:15.700
And if you're combining your APIs using a gateway or a federation, you know, it's a long story.

00:13:15.700 --> 00:13:18.860
But I guess with a federation, you wouldn't really make it public.

00:13:18.860 --> 00:13:19.100
Sure.

00:13:19.100 --> 00:13:20.280
Let's dive into that a little bit.

00:13:20.280 --> 00:13:22.420
Let's talk about API versioning.

00:13:22.600 --> 00:13:24.760
We know what versioning is in Python.

00:13:24.760 --> 00:13:27.420
We have lock files.

00:13:27.420 --> 00:13:29.080
We pin the version.

00:13:29.080 --> 00:13:33.980
We might say we're using Pydantic 2.0.5 or whatever it is.

00:13:33.980 --> 00:13:38.060
And that leaves the Pydantic team free to do whatever they want.

00:13:38.060 --> 00:13:41.380
And we can trust that our code is going to stay the way it stayed.

00:13:41.380 --> 00:13:47.440
I guess API versioning is that, but for web endpoints rather than software links to packages,

00:13:47.440 --> 00:13:47.700
right?

00:13:47.700 --> 00:13:50.140
It's a little different though, in some regards.

00:13:50.140 --> 00:13:55.020
For example, when you're packaging your, I don't know, software and you just send it

00:13:55.020 --> 00:13:59.680
to clients, thing is you need to have versions for every single thing.

00:13:59.680 --> 00:14:04.180
For example, if we are doing a bug fix and we need to ship that to our clients, that is

00:14:04.180 --> 00:14:05.340
going to be a separate version.

00:14:05.340 --> 00:14:11.140
But in web, when you're hosting it on a server and your clients just make requests to your

00:14:11.140 --> 00:14:12.540
servers, you don't need that.

00:14:12.540 --> 00:14:15.800
You don't need to ship bug fixes as separate versions.

00:14:15.860 --> 00:14:19.080
You can just ship them because they're not going to break anything for your clients and

00:14:19.080 --> 00:14:20.940
your clients will be able to automatically get them.

00:14:20.940 --> 00:14:22.980
Same goes for minor versions.

00:14:22.980 --> 00:14:28.320
Minor versions that just add features don't really need to be for a version on APIs.

00:14:28.320 --> 00:14:33.960
That leaves us with just major versions, which is why many companies like Stripe at Monite

00:14:33.960 --> 00:14:37.760
use dates for their versions?

00:14:37.760 --> 00:14:41.220
Because we don't really need all of the power of semantic versioning.

00:14:41.220 --> 00:14:41.440
Yeah.

00:14:41.440 --> 00:14:41.800
Yeah.

00:14:41.800 --> 00:14:41.980
Sure.

00:14:41.980 --> 00:14:47.100
More calendar versioning because all you really need to say is this one is different than before,

00:14:47.100 --> 00:14:47.720
right?

00:14:47.720 --> 00:14:48.200
It doesn't.

00:14:48.200 --> 00:14:48.540
Exactly.

00:14:48.540 --> 00:14:50.020
Stripe does a lot of interesting things.

00:14:50.020 --> 00:14:54.420
We're going to talk a little bit about what they're up to.

00:14:54.420 --> 00:14:55.360
But you're right.

00:14:55.420 --> 00:15:00.780
When I think about APIs that I've created, sometimes I've had other versions, right?

00:15:00.780 --> 00:15:07.620
You know, one of the main areas is in the apps that we have over URL work.

00:15:07.620 --> 00:15:07.940
It does.

00:15:07.940 --> 00:15:10.120
In the apps for consuming the courses, right?

00:15:10.120 --> 00:15:14.120
We had two completely different versions of the app.

00:15:14.120 --> 00:15:16.980
One got completely, completely rewrote it.

00:15:16.980 --> 00:15:19.840
And many of the API endpoints were just fine.

00:15:19.840 --> 00:15:22.960
We could just use them over and didn't have to change anything.

00:15:22.960 --> 00:15:27.460
But three or four were like, you know, this really would be better if it was different.

00:15:27.460 --> 00:15:31.600
And so added like a slash v2 or something in there, right?

00:15:31.600 --> 00:15:33.120
But really, really limited.

00:15:33.120 --> 00:15:37.780
So the thing that's interesting, though, that you point out here is like until that happened,

00:15:37.780 --> 00:15:41.840
I'd shipped many, many versions of that API.

00:15:41.840 --> 00:15:46.520
And long as the schema didn't change, I didn't bother even specifying that it had a version,

00:15:46.520 --> 00:15:47.020
right?

00:15:47.020 --> 00:15:51.200
It was just like slash course, my courses or whatever it is, right?

00:15:51.200 --> 00:15:52.500
Like just give those to me.

00:15:52.560 --> 00:15:54.700
As long as it kept giving the courses back, it was good.

00:15:54.700 --> 00:15:55.420
That's the thing.

00:15:55.420 --> 00:15:58.800
As long as you extend stuff, it's going to be fine.

00:15:58.800 --> 00:16:02.480
But as you mentioned in the beginning, you can't really do that forever.

00:16:02.480 --> 00:16:06.120
At some point, you're going to make wrong design decisions.

00:16:06.120 --> 00:16:11.480
At some point, even if you did everything perfectly, you know, your product is just going to evolve.

00:16:11.480 --> 00:16:12.400
It's just going to evolve.

00:16:12.400 --> 00:16:16.280
And then you'll need to use old endpoints.

00:16:16.280 --> 00:16:20.160
You know, you can't do that.

00:16:20.160 --> 00:16:21.080
In some breaking ways.

00:16:21.080 --> 00:16:22.700
Of course, there are ways around it.

00:16:22.700 --> 00:16:24.440
You can use API evolution.

00:16:24.440 --> 00:16:29.220
You can just, you know, add fields constantly and duplicate the old functionality.

00:16:29.220 --> 00:16:34.660
But after a few of such versions, your API will look terrible, which is why we use versioning.

00:16:34.660 --> 00:16:44.180
And which is why when your company's main product is an API, when you are an API first company, you can't do anything without versioning.

00:16:44.180 --> 00:16:46.760
You can live for a short period of time.

00:16:46.760 --> 00:16:51.420
For example, a pre-Series A company, I don't think should deal with versioning.

00:16:51.420 --> 00:16:59.200
But then after a series A, after you gather, I don't know, 15, 20 clients, it will be really hard to survive without versioning.

00:16:59.200 --> 00:16:59.520
Yeah.

00:16:59.520 --> 00:17:08.120
And it's a really quick and easy way to make loyal customers angry by making changes to your API that just start breaking code.

00:17:08.120 --> 00:17:14.280
Even if you wait for your clients, even if you, you know, warn them, it's still not nice when you're trying to use some API.

00:17:14.280 --> 00:17:18.580
And then every three months or every month, it breaks everything.

00:17:18.580 --> 00:17:19.760
You know, you wouldn't like that.

00:17:19.760 --> 00:17:21.080
Even with a warning.

00:17:21.080 --> 00:17:23.080
You put in all the work to do the integration.

00:17:23.080 --> 00:17:24.020
You got it working.

00:17:24.020 --> 00:17:24.800
You tested it.

00:17:24.800 --> 00:17:27.820
Your job is, your product is not the integration.

00:17:27.820 --> 00:17:30.440
The integration facilitates what you're trying to build.

00:17:30.440 --> 00:17:34.120
And every time you got to go back and rewrite that stuff, it's not great.

00:17:34.120 --> 00:17:42.300
I was working, I have MailChimp for our newsletter marketing side of stuff, the courses and use them for a long time.

00:17:42.300 --> 00:17:46.420
And I got a message like, hey, we're retiring this API you're using.

00:17:46.420 --> 00:17:49.440
And their API is dreadful.

00:17:49.600 --> 00:17:52.420
Like their Python library API is dreadful.

00:17:52.420 --> 00:17:55.180
It's like star args, star star kwo args.

00:17:55.180 --> 00:17:56.740
You better pass the right things.

00:17:56.740 --> 00:18:00.680
But there's no enforcement or instruction about what goes in there, right?

00:18:00.680 --> 00:18:05.680
And so some random dictionary that was going in there was no longer right and had to be like recreated.

00:18:05.820 --> 00:18:10.380
So they just decided, you know, we're going to just take different stuff and we're just going to shut down that endpoint.

00:18:10.700 --> 00:18:16.040
And when they did, all of the aspects of my website just started breaking.

00:18:16.040 --> 00:18:19.740
Like it wasn't crashing, but just anything around, hey, put me on your newsletter.

00:18:19.740 --> 00:18:23.720
Like, nope, you couldn't be on the newsletter because it, you know, people started sending me a message.

00:18:23.720 --> 00:18:25.780
Michael, I'm trying to sign up to be on the newsletter.

00:18:25.980 --> 00:18:29.080
But it just keeps saying that something went wrong with our site.

00:18:29.080 --> 00:18:29.540
We're sorry.

00:18:29.540 --> 00:18:30.580
I'm like, oh, boy.

00:18:30.580 --> 00:18:31.740
Go look.

00:18:31.740 --> 00:18:33.360
And they just turned off that endpoint.

00:18:33.360 --> 00:18:36.200
And it was just like, nope, not doing that anymore.

00:18:36.200 --> 00:18:37.480
And it was super frustrating.

00:18:37.480 --> 00:18:44.800
It took me eight hours to rewrite it because, like I said, there was no real guidance on like, oh, you just passed the dictionary.

00:18:44.920 --> 00:18:46.420
Like, well, what goes in the dictionary?

00:18:46.420 --> 00:18:49.700
You know, it was like some word of one of the keys changed.

00:18:49.700 --> 00:18:51.000
I was so, it just took forever.

00:18:51.000 --> 00:18:51.600
It was frustrating.

00:18:51.600 --> 00:18:58.740
So what we're going to talk about here is a lot about how, how do you not do, how do you not pull a MailChimp?

00:18:58.740 --> 00:19:01.700
How do you set it up so that your code keeps running?

00:19:01.700 --> 00:19:06.620
You know, the reason why they did that is they're like, well, we feel like we wrote it wrong before.

00:19:06.620 --> 00:19:10.980
We want to fix those for, to make it better, but we don't want to maintain two versions.

00:19:10.980 --> 00:19:12.380
That's probably the heart of it.

00:19:12.380 --> 00:19:13.360
And that's a sane idea.

00:19:13.360 --> 00:19:13.960
It is.

00:19:14.240 --> 00:19:17.500
Until you have half a million users of the old API.

00:19:17.500 --> 00:19:20.800
And how many of those, like, so for me, yeah, I was frustrated.

00:19:20.800 --> 00:19:25.740
Yeah, I'm like, all right, well, I had plans today for constructive work, but I'm going to go rewrite what I did four years ago.

00:19:25.740 --> 00:19:27.320
And then I'll do something again tomorrow.

00:19:27.320 --> 00:19:29.920
But, okay, that's like a pretty good outcome.

00:19:29.920 --> 00:19:37.560
A more common outcome is probably I hired a consultant to build me an app and integrate MailChimp, and they're gone.

00:19:37.560 --> 00:19:41.200
And now my thing that I built a year ago doesn't even work.

00:19:41.200 --> 00:19:42.780
And I don't have the skills.

00:19:43.240 --> 00:19:46.640
I got to go hire somebody again to dig back in there and fix it, right?

00:19:46.640 --> 00:19:48.240
Like, that would be really frustrating.

00:19:48.240 --> 00:19:49.200
Yeah, that's crazy.

00:19:49.200 --> 00:19:56.160
And it could be devastating to some clients, especially if the changes are huge, especially if it's not just a single endpoint.

00:19:56.160 --> 00:20:02.140
Or if there is only one endpoint, and it does a lot of things, then, oh my God, it's scary.

00:20:02.140 --> 00:20:02.660
It is.

00:20:02.840 --> 00:20:08.380
This portion of Talk Python To Me is brought to you by Neo4j.

00:20:08.380 --> 00:20:10.320
Do you know Neo4j?

00:20:10.320 --> 00:20:13.060
Neo4j is a native graph database.

00:20:13.060 --> 00:20:17.920
And if the slowest part of your data access patterns involves computing relationships,

00:20:17.920 --> 00:20:25.160
why not use a database that stores those relationships directly in the database, unlike your typical relational one?

00:20:25.160 --> 00:20:31.860
A graph database lets you model the data the way it looks in the real world, instead of forcing it into rows and columns.

00:20:31.860 --> 00:20:39.460
It's time to stop asking a relational database to do more than they were made for and simplify complex data models with graphs.

00:20:40.100 --> 00:20:44.540
If you haven't used a graph database before, you might be wondering about common use cases.

00:20:44.540 --> 00:20:45.420
You know, what's it for?

00:20:45.420 --> 00:20:46.820
Here are just a few.

00:20:46.820 --> 00:20:47.940
Detecting fraud.

00:20:47.940 --> 00:20:49.460
Enhancing AI.

00:20:49.460 --> 00:20:51.260
Managing supply chains.

00:20:51.260 --> 00:20:54.120
Gaining a 360-degree view of your data.

00:20:54.120 --> 00:20:57.500
And anywhere else you have highly connected data.

00:20:57.500 --> 00:21:02.960
To use Neo4j from Python, it's a simple pip install Neo4j.

00:21:03.380 --> 00:21:10.100
And to help you get started, their docs include a sample web app demonstrating how to use it, both from Flask and FastAPI.

00:21:10.100 --> 00:21:15.080
Find it in their docs or search GitHub for Neo4j Movies Application Quick Start.

00:21:15.080 --> 00:21:19.280
Developers are solving some of the world's biggest problems with graphs.

00:21:19.280 --> 00:21:20.480
Now it's your turn.

00:21:20.480 --> 00:21:24.780
Visit talkpython.fm/neo4j to get started.

00:21:24.780 --> 00:21:28.720
That's talkpython.fm/neo4j.

00:21:28.720 --> 00:21:32.740
Thank you to Neo4j for supporting Talk Python To Me.

00:21:32.740 --> 00:21:40.460
Before we move on to maybe some of the approaches, Alex, Alexey out in the audience says,

00:21:40.460 --> 00:21:41.560
One more law.

00:21:41.560 --> 00:21:43.360
Hiram's law is also great.

00:21:43.360 --> 00:21:48.280
With sufficient number of users of an API, it does not matter what you promise in the contract.

00:21:48.280 --> 00:21:52.540
All observable behaviors of your system will be depended on by somebody.

00:21:52.540 --> 00:21:56.560
It is one of my favorite laws about any system.

00:21:56.560 --> 00:21:57.800
That's true.

00:21:57.800 --> 00:21:58.640
That is very true.

00:21:58.640 --> 00:22:14.540
And it's a scary law, you know, because at some point you'll have to version everything, which is why it's a good idea to make things, you know, I guess to describe all the behaviors and to try to handle all of the possible behaviors early.

00:22:14.540 --> 00:22:17.840
So that you know what is going to become a part of it.

00:22:17.840 --> 00:22:21.180
Because at some point you'll just not be able to stop it.

00:22:21.180 --> 00:22:24.960
And then you break something that was never intended to work.

00:22:24.960 --> 00:22:27.880
And then a hundred of your users are like, oh, we were using that.

00:22:27.880 --> 00:22:29.700
We were, it wasn't a bug.

00:22:29.700 --> 00:22:30.720
It was a feature for us.

00:22:30.720 --> 00:22:32.100
Yeah.

00:22:32.100 --> 00:22:33.240
We needed that.

00:22:33.240 --> 00:22:34.860
We found that's the only way we could use it.

00:22:34.860 --> 00:22:35.580
Yeah, for sure.

00:22:36.120 --> 00:22:36.400
All right.

00:22:36.400 --> 00:22:39.160
Let's talk about some of the techniques you put together.

00:22:39.160 --> 00:22:42.720
A nice thing here, like how to maintain hundreds of API versions and survive.

00:22:42.720 --> 00:22:46.120
So what are some of the ways in which people version APIs?

00:22:46.120 --> 00:22:53.140
First of all, it's really hard to really figure out how people do this and how to do it.

00:22:53.140 --> 00:23:03.580
Because 90% of the time when you're going to be researching API versioning, what you're going to see is people having tough decisions between putting it into a header or putting it into a path.

00:23:03.580 --> 00:23:06.020
But then when you ask, well, how do you version?

00:23:06.020 --> 00:23:07.740
Nobody really has an answer.

00:23:07.740 --> 00:23:09.360
Well, there are a few ways.

00:23:09.360 --> 00:23:15.400
First of all, you can go from the lowest level and version everything, including your database.

00:23:15.400 --> 00:23:18.040
You just make a separate copy of your app.

00:23:18.040 --> 00:23:23.560
You can host it on a separate server, even a separate Kubernetes namespace and forget about it.

00:23:23.560 --> 00:23:26.020
And, you know, you have two completely separate apps.

00:23:26.020 --> 00:23:33.840
And now you need to have double the people for the maintenance or at least a smaller separate team to maintain the second product.

00:23:33.840 --> 00:23:37.840
This approach is really nice if you have a product that cannot break.

00:23:37.840 --> 00:23:41.140
Like there needs to be zero possibility of that breaking.

00:23:41.540 --> 00:23:45.660
You know, if you are on a nuclear power plant, you'll probably do that.

00:23:45.660 --> 00:23:50.340
You know, you can't have the old one broken and, you know, the new one working.

00:23:50.340 --> 00:23:52.620
But it's the most expensive approach, obviously.

00:23:52.620 --> 00:23:55.020
You can, however, limit that.

00:23:55.020 --> 00:23:59.380
You can start versioning just the application, but not the database.

00:23:59.540 --> 00:24:08.980
Okay, now we have the same thing, you know, a separate branch in our code, a separate, not in our code, in our repository, a separate Kubernetes namespace, whatever.

00:24:08.980 --> 00:24:11.080
But now it's still expensive.

00:24:11.080 --> 00:24:14.380
It's still a whole separate copy of everything you have built.

00:24:14.380 --> 00:24:21.780
And now you have to make sure that the new one or the old one doesn't break the database because the database might have changed.

00:24:21.780 --> 00:24:24.700
But some of the one of the versions of code might not know about that.

00:24:24.700 --> 00:24:27.520
And then you realize that you go.

00:24:27.520 --> 00:24:29.000
Yeah, the database.

00:24:29.000 --> 00:24:35.620
This aspect of it sounds especially tricky, especially a relational database with super strong schemas.

00:24:35.620 --> 00:24:36.420
Like, you know what?

00:24:36.420 --> 00:24:40.100
That used to be a varchar and now it's an int.

00:24:40.100 --> 00:24:43.320
And so, nope, it's not like it's just not going to work, right?

00:24:43.320 --> 00:24:45.100
There's really little flexibility.

00:24:45.100 --> 00:24:50.440
So even if you run the two things in parallel, then you almost have to have two databases.

00:24:50.440 --> 00:24:54.740
And then like Emil points out and then you have to sync the databases.

00:24:54.740 --> 00:24:56.340
And like, it's non-trivial.

00:24:56.340 --> 00:24:56.980
Oh, yes.

00:24:57.120 --> 00:25:01.760
And then you start realizing, okay, why do I need a separate branch and a separate namespace?

00:25:01.760 --> 00:25:04.180
Let's just keep them within the same app.

00:25:04.400 --> 00:25:10.440
Because as long as, you know, you have separate paths for this, even you can build separate swaggers from them.

00:25:10.440 --> 00:25:16.000
You can have them within the same branch, within the same repository, just in different directories.

00:25:16.000 --> 00:25:17.900
And you can just copy all of your code.

00:25:17.900 --> 00:25:20.640
And now I call that versioning by suffering.

00:25:20.640 --> 00:25:24.200
Because you think, oh, I'm going to version less this time.

00:25:24.200 --> 00:25:25.900
You know, now I'm not versioning the database.

00:25:26.100 --> 00:25:27.280
Now it's not a separate branch.

00:25:27.280 --> 00:25:31.380
It's going to be much easier to make fixes in both places.

00:25:31.380 --> 00:25:35.560
But now you have to support both of the code bases.

00:25:35.560 --> 00:25:41.820
And once you update anything, any of the related resources, for example, the database models, you have to update them twice.

00:25:41.820 --> 00:25:44.820
If you update any of the dependencies, you have to update them twice.

00:25:45.060 --> 00:25:47.520
And that can get painful.

00:25:47.520 --> 00:25:55.800
And after a while, if you have more than two of these versions, you're going to be asking yourself, okay, what is the difference between these versions?

00:25:55.800 --> 00:26:00.880
And if you weren't careful with documentation and code review, oh, you're in for a treat.

00:26:00.880 --> 00:26:01.340
Yeah.

00:26:01.340 --> 00:26:02.320
But that's just the beginning.

00:26:02.320 --> 00:26:04.500
You can version much less.

00:26:04.500 --> 00:26:08.560
Now, instead of the whole directories, you can version just separate endpoints.

00:26:08.560 --> 00:26:12.400
And I think that's the way that I recommend for everyone.

00:26:12.540 --> 00:26:18.040
Everyone who is doing API versioning who wants to, you know, to be with the cool kids, I recommend this approach.

00:26:18.040 --> 00:26:24.300
As long as you are a small company or an individual and you want something really simple, that's a good way.

00:26:24.300 --> 00:26:31.840
You just copy a single endpoint that you have changed, create another schema for that, and then create another branch in your business logic.

00:26:31.840 --> 00:26:33.540
Or maybe even no branch.

00:26:33.540 --> 00:26:36.480
That's even better, you know, using the same business logic.

00:26:36.760 --> 00:26:44.640
But then at some point, once you want to support many versions or your versions become too different, that's where you get a problem.

00:26:44.640 --> 00:26:50.400
Because now all of a sudden, you have all of these, oh, I have this endpoint in this version, that endpoint in that version.

00:26:50.400 --> 00:26:51.940
Oh, it's going to be bad.

00:26:51.940 --> 00:26:52.720
Really bad.

00:26:52.720 --> 00:26:53.200
Again.

00:26:53.200 --> 00:26:55.780
We've been talking like there's the old version and the new version.

00:26:55.940 --> 00:27:04.860
But in practice, somebody starts to depend on the new version, and then you evolve the new version, and it just, it combinatorially explodes and it's out of control.

00:27:04.860 --> 00:27:05.120
Yeah.

00:27:05.120 --> 00:27:05.800
Precisely.

00:27:05.800 --> 00:27:07.880
It's going to be really bad for your developers.

00:27:07.880 --> 00:27:09.860
Your clients are going to be fine with it.

00:27:09.860 --> 00:27:11.260
Your developers are going to hate you.

00:27:11.300 --> 00:27:14.120
Although not as bad as with the previous approach.

00:27:14.120 --> 00:27:25.040
Now, the next one you get to is you start thinking, okay, what if instead of duplicating all of that stuff, I am just going to change the schemas.

00:27:25.040 --> 00:27:28.740
So, okay, if I do need to rename my endpoint, I am going to duplicate it.

00:27:28.740 --> 00:27:29.860
But most of the time, you're not.

00:27:29.860 --> 00:27:32.520
Most of the time, you're just changing some field in some schema.

00:27:32.520 --> 00:27:33.440
You're renaming it.

00:27:33.440 --> 00:27:36.220
You're extending it, changing its type, you know, stuff like that.

00:27:36.220 --> 00:27:38.360
That's like 90% of your use cases.

00:27:38.380 --> 00:27:42.480
Okay, what if we just change the schemas and then have some serializers?

00:27:42.480 --> 00:27:47.400
For example, you know, Django DRF loves that.

00:27:47.400 --> 00:27:50.320
They love, you know, the serializers and re-serializers.

00:27:50.320 --> 00:27:58.380
And you can just have each, we have five versions, and version one serializes into version five, version two serializes into version five, yada, yada, yada.

00:27:58.380 --> 00:28:06.400
And so our client sends us a request, we re-serialize it into the correct version, then we return a response, we use the same business logic,

00:28:06.400 --> 00:28:08.940
and then we serialize it back into each version.

00:28:08.940 --> 00:28:09.480
Great.

00:28:09.480 --> 00:28:13.340
Now, we have solved all the problems of the previous approaches.

00:28:13.340 --> 00:28:22.400
Now, you need to realize that when you're doing something like this, you are in a little bit of danger of creating bugs in the new versions,

00:28:22.400 --> 00:28:27.600
and these bugs cascading to the old versions, which hopefully you have tests to handle that.

00:28:27.600 --> 00:28:37.540
But at least your clients are happy because, you know, you can support versions for a long time, and your developers are happy because the burden of support is now on the serializers.

00:28:37.540 --> 00:28:40.020
But you still have to support these serializers.

00:28:40.020 --> 00:28:41.520
It's still a lot of stuff.

00:28:41.520 --> 00:28:48.620
You still have to, you know, put every field in there, you know, and take care of any problems that happen.

00:28:48.760 --> 00:28:52.400
And each new version will change basically all of your serializers.

00:28:52.400 --> 00:28:53.680
A little bit, yes.

00:28:53.680 --> 00:28:56.020
But you won't be able to support 20 versions like that.

00:28:56.020 --> 00:28:56.880
It's going to be crazy.

00:28:56.880 --> 00:29:05.200
And now that's where we get to the final approaches, the approaches that I guess are the most sophisticated in the industry.

00:29:05.600 --> 00:29:10.780
If you are making a backend for frontend, for your own frontend, then you can just use GraphQL.

00:29:10.780 --> 00:29:16.060
GraphQL basically requires no versioning, and that's one of the benefits of it.

00:29:16.060 --> 00:29:22.200
I would recommend that if you have developers that are, you know, good with GraphQL, that's great.

00:29:22.200 --> 00:29:23.800
You can omit versioning altogether.

00:29:23.800 --> 00:29:29.120
But if you're not, if it's a public API, then that's where Stripe's approach comes.

00:29:29.120 --> 00:29:33.040
I think they were the first ones to publish an article about that.

00:29:33.340 --> 00:29:35.660
It was Brander Leach, the author of this article.

00:29:35.660 --> 00:29:43.340
He has supported API versioning at Stripe for a while, and he has helped us with building our API versioning approach.

00:29:43.340 --> 00:29:52.260
Essentially, what Stripe did is said, okay, let's imagine that our developers are only supporting one version, the latest one, just like with serializers.

00:29:52.260 --> 00:30:00.660
But instead of serializing every version to the latest one, let's say that each version knows how to serialize into the next version.

00:30:00.660 --> 00:30:02.060
Kind of like database migrations.

00:30:02.300 --> 00:30:05.320
Let's say that I return response from the latest version.

00:30:05.320 --> 00:30:10.120
This response, or at least they call them, I think, version gates.

00:30:10.120 --> 00:30:16.860
These version gates, version gate for fifth version, knows how to convert back my response back into the fourth version.

00:30:16.860 --> 00:30:21.420
The version gate for the fourth version knows how to convert it back into the third version.

00:30:21.760 --> 00:30:25.100
And all of a sudden, you get simple version gates.

00:30:25.100 --> 00:30:29.280
Because, you know, if it's just field renaming in a single version, then it's just a single line.

00:30:29.280 --> 00:30:30.440
It's, they're really simple.

00:30:30.440 --> 00:30:32.520
But at the same time, they're immutable.

00:30:32.520 --> 00:30:35.620
Because these version gates, they're not describing the whole schema.

00:30:35.620 --> 00:30:38.640
They're describing the difference between two versions.

00:30:38.780 --> 00:30:42.620
And because we know that we don't want to, you know, change the old version.

00:30:42.620 --> 00:30:44.960
We want the word, the old version to work.

00:30:44.960 --> 00:30:48.940
Which is why the difference between version two and version three is going to stay.

00:30:48.940 --> 00:30:50.240
It's not going to change.

00:30:50.240 --> 00:30:52.900
Which is why these converters are also immutable.

00:30:52.900 --> 00:30:56.760
Which means that you don't need to spend much time supporting them.

00:30:56.760 --> 00:30:56.980
Right.

00:30:57.060 --> 00:31:03.680
Once you get, if you're on version three and you get the transition from one to two set, like that's not going to change ever, right?

00:31:03.680 --> 00:31:04.200
Precisely.

00:31:04.200 --> 00:31:09.260
Well, at some point, you need it for optimizations or for returning extra data.

00:31:09.260 --> 00:31:13.160
But it's such a rare use case that I haven't seen it so far.

00:31:13.160 --> 00:31:14.960
And I hope that I won't.

00:31:14.960 --> 00:31:16.020
So this is Stripe's approach.

00:31:16.020 --> 00:31:22.420
And one of the things that's really interesting that Stripe does and is laid out in this article that you're bringing to the table here is,

00:31:22.720 --> 00:31:29.660
they also implicitly assign you a version when you first make a call, which was really interesting.

00:31:29.660 --> 00:31:36.540
I use Stripe and I didn't realize that when I've made calls into Stripe that the first time you make a call,

00:31:36.540 --> 00:31:42.120
it pins you somewhere like on your user account on their side, pins you to that version of the API.

00:31:42.120 --> 00:31:47.340
And you never know you're on a different, you're on a particular version, but they keep you on that version.

00:31:47.340 --> 00:31:47.980
That's wild.

00:31:47.980 --> 00:31:48.620
That's great.

00:31:48.620 --> 00:31:51.760
Imagine you log into Stripe, you make a call,

00:31:52.060 --> 00:31:57.060
and then every time you open a documentation in your account, you're going to see your version.

00:31:57.060 --> 00:32:00.520
Every time you make a call, you're going to get response from your version.

00:32:00.520 --> 00:32:10.620
And then because they keep versions for years, for example, we are using, I think, a three or four year old version of Stripe's API and they still keep it.

00:32:10.620 --> 00:32:15.720
According to this article, they keep all of their versions, all since the company's beginning.

00:32:15.720 --> 00:32:18.000
I'm not sure how true that is.

00:32:18.000 --> 00:32:20.540
They keep years worth of versions.

00:32:20.540 --> 00:32:21.460
That is very true.

00:32:21.460 --> 00:32:22.980
Now you might see that as a negative.

00:32:22.980 --> 00:32:25.380
Like you might think, well, I'm pinned to this version.

00:32:25.380 --> 00:32:28.280
Like how do I escape the old version if I want the new version?

00:32:28.280 --> 00:32:34.360
But you can pass it in a header or there's other ways to say I explicitly choose something else.

00:32:34.360 --> 00:32:36.760
But by default, you're just, you're living in the past.

00:32:36.760 --> 00:32:37.500
That's really cool.

00:32:37.500 --> 00:32:39.980
You integrate and then you live in the past for as long as you want.

00:32:39.980 --> 00:32:43.100
The thing is, yes, you can change it using a header.

00:32:43.100 --> 00:32:45.920
Monite has a similar structure.

00:32:45.920 --> 00:32:50.100
You can change it in your partner's portal.

00:32:50.100 --> 00:32:52.780
And you can also, or I guess developer's portal.

00:32:52.780 --> 00:32:57.060
And you can also specify, for example, if you receive webhooks from Stripe, you can specify,

00:32:57.060 --> 00:33:00.760
okay, I want this webhook of this version and that webhook of that version.

00:33:00.760 --> 00:33:01.180
That's cool.

00:33:01.180 --> 00:33:01.620
Yeah.

00:33:01.700 --> 00:33:06.020
It's a really neat interface that if you don't want to think about versioning, you don't.

00:33:06.020 --> 00:33:06.800
You forget about it.

00:33:06.800 --> 00:33:14.180
But the second you want to, the second you want to have the latest API, they give you all the tools to work with it nicely.

00:33:14.180 --> 00:33:15.080
And that's the thing.

00:33:15.220 --> 00:33:25.100
This approach allows you to keep years worth of versions or maybe even decades worth of versions, actually, without your developers getting overburdened.

00:33:25.100 --> 00:33:27.740
Because there is still a single version of the business logic.

00:33:27.740 --> 00:33:34.380
They work on a single version of schemas and they just need to make sure that when they release a new version, they write a converter for it.

00:33:34.380 --> 00:33:37.180
And your clients are also happy because they never need to switch.

00:33:37.180 --> 00:33:38.020
It sounds really nice.

00:33:38.140 --> 00:33:49.400
I suspect there's not complete ability to just ignore the old versions because, you know, maybe you want in your new version, you're going to imagine this piece of data doesn't even exist.

00:33:49.400 --> 00:33:51.020
And we're going to remove it from the database.

00:33:51.020 --> 00:33:58.240
But if it needs to be there for the old ones, you know, there's probably some level of you're constrained a little bit, but it sounds a lot better still.

00:33:58.240 --> 00:33:59.240
You're still constrained.

00:33:59.240 --> 00:34:06.320
But remember, API versioning, if we translate it, you know, application programming interface versioning.

00:34:06.320 --> 00:34:07.640
We're not versioning the app.

00:34:07.920 --> 00:34:09.800
We're versioning the interface to the app.

00:34:09.800 --> 00:34:10.000
Yeah.

00:34:10.000 --> 00:34:13.000
So a lot of times it's like, what fields are we passing or something, right?

00:34:13.000 --> 00:34:21.000
If you are trying to change the data between versions, if the data is different, entirely different, I mean, then you're probably not doing API versioning.

00:34:21.000 --> 00:34:25.000
Then you probably should be calling it application versioning.

00:34:25.000 --> 00:34:29.660
And actually, Stripe has, I guess, a hack for that too.

00:34:29.660 --> 00:34:32.560
If you take a look at their API, they still have a V1.

00:34:32.560 --> 00:34:33.480
But that's the thing.

00:34:33.480 --> 00:34:34.920
They don't use this V1.

00:34:35.080 --> 00:34:38.740
They use date-based versioning that is in the headers and their settings.

00:34:38.740 --> 00:34:42.400
But the V1 is precisely for this situation.

00:34:42.620 --> 00:34:54.880
If someday they will need to have something else, if someday they will need to break everything and, you know, change the data required or any other crazy changes, they will be able to do it using that V1.

00:34:55.000 --> 00:34:55.160
Yeah.

00:34:55.160 --> 00:34:56.320
It's just there in case.

00:34:56.320 --> 00:34:57.100
Exactly.

00:34:57.100 --> 00:34:57.500
Yeah.

00:34:57.500 --> 00:34:57.720
Cool.

00:34:57.720 --> 00:34:58.000
All right.

00:34:58.000 --> 00:34:59.460
Well, let's talk about your project.

00:34:59.460 --> 00:35:06.740
Let's talk about your project that makes this possible in Python because the Stripe examples, I believe this is Ruby that they all have here, right?

00:35:06.820 --> 00:35:10.160
It is really nice to read until you try to understand it.

00:35:10.160 --> 00:35:12.560
Until you try to understand what it actually does.

00:35:12.560 --> 00:35:13.380
And it's crazy.

00:35:13.380 --> 00:35:13.860
I know.

00:35:13.860 --> 00:35:18.140
When I was reading this today, I was like, you know, I'm pretty glad that I'm not writing Ruby right now.

00:35:18.140 --> 00:35:18.940
Okay.

00:35:18.940 --> 00:35:19.780
All right.

00:35:19.780 --> 00:35:21.040
Let's talk about Python, though.

00:35:21.040 --> 00:35:33.420
You've got a project called Cadwin that takes the Stripe philosophy and applies it to versioning for the most popular API framework for Python, FastAPI.

00:35:33.420 --> 00:35:34.340
Tell us about it.

00:35:34.480 --> 00:35:35.000
Here's the thing.

00:35:35.000 --> 00:35:39.120
When I started developing it, we were using versioning by suffering.

00:35:39.120 --> 00:35:43.440
So we were using directory copies and none of us really enjoyed it.

00:35:43.440 --> 00:35:45.160
So there needed to be a solution.

00:35:45.160 --> 00:35:46.820
And I went to Stripe.

00:35:46.820 --> 00:35:47.940
I went to other companies.

00:35:47.940 --> 00:35:49.000
I spoke with them.

00:35:49.000 --> 00:35:52.820
I tried to understand the nitty gritty details.

00:35:52.820 --> 00:36:01.860
As I mentioned, Brander Leach extended us huge help when he, I guess, described how he thinks about API versioning right now.

00:36:01.860 --> 00:36:03.460
And I built it.

00:36:03.460 --> 00:36:05.720
The first version was just like Stripe.

00:36:05.720 --> 00:36:08.480
It was exactly what Stripe did to the letter.

00:36:08.480 --> 00:36:11.960
But then at some point, we started applying it at Monite.

00:36:11.960 --> 00:36:15.240
And I realized, wow, Stripe had a lot of legacy.

00:36:15.800 --> 00:36:17.260
So they didn't implement some things.

00:36:17.260 --> 00:36:25.560
For example, in Stripe's article, you can see that they're not using any schema validation or at least, how do I describe it?

00:36:25.560 --> 00:36:29.400
Their business logic just receives a hash map, a dictionary.

00:36:29.400 --> 00:36:31.740
It's not statically typed.

00:36:31.740 --> 00:36:33.540
But FastAPI uses Pydantic.

00:36:33.540 --> 00:36:35.780
So it's a bit more complex than that.

00:36:35.860 --> 00:36:38.200
Okay, we added support for that.

00:36:38.200 --> 00:36:39.480
It's a bit more complex.

00:36:39.480 --> 00:36:41.380
It's a bit more, I guess, sophisticated now.

00:36:41.640 --> 00:36:46.380
But then I also realized that Stripe, they don't migrate requests.

00:36:46.380 --> 00:36:47.900
They only migrate responses.

00:36:47.900 --> 00:36:53.060
Because a migration of a request is usually not just a breaking change.

00:36:53.060 --> 00:36:54.680
It's a change in a business logic.

00:36:54.680 --> 00:36:59.540
Because when you return a response, you can just return the whole thing and then, you know, just play around with it.

00:36:59.540 --> 00:37:04.560
But when you are changing the request, your business logic also needs to change.

00:37:04.560 --> 00:37:06.000
And that's what they did.

00:37:06.000 --> 00:37:10.000
You know, they have extra ifs and extra levels of business logic to handle that.

00:37:10.000 --> 00:37:11.760
Well, apparently, it's not necessary.

00:37:11.760 --> 00:37:14.500
Apparently, requests are also migratable.

00:37:14.500 --> 00:37:20.680
And that's the second feature that greatly distinguishes us from Stripe.

00:37:20.680 --> 00:37:31.080
This thing can statically, well, by statically, I mean, it co-generates your schema so that you can see everything before you run your app.

00:37:31.080 --> 00:37:34.980
This thing can migrate both requests and responses.

00:37:34.980 --> 00:37:36.960
And it supports everything that Stripe does.

00:37:36.960 --> 00:37:40.440
And we have pretty big plans for extending it.

00:37:40.440 --> 00:37:45.820
And as an added bonus, we also have pretty big documentation.

00:37:45.820 --> 00:37:48.120
Well, not compared to Django or FastAPI.

00:37:48.660 --> 00:37:52.360
Django is, you know, older than me and FastAPI.

00:37:52.360 --> 00:37:55.140
It's pretty amazing in terms of its documentation.

00:37:55.140 --> 00:37:58.260
Sebastian Ramirez is an expert at making tutorials.

00:37:58.260 --> 00:38:04.540
And if you take a look at our reference documentation to the left and our, how do I describe it, recipes documentation,

00:38:04.540 --> 00:38:13.180
they basically describe to you every single use case that you could have with API versioning.

00:38:13.180 --> 00:38:15.500
Every single problem that you could solve with it.

00:38:15.800 --> 00:38:19.940
And then we try to apply our approach to it.

00:38:19.940 --> 00:38:21.540
So it's not just the framework.

00:38:21.540 --> 00:38:24.000
It's all the ways you could use the framework.

00:38:24.000 --> 00:38:28.980
Someday, hopefully, we will also extend it beyond FastAPI and Pydantic.

00:38:29.380 --> 00:38:39.320
And we also have sections for theory for people who are not Pythonistas, who just want to learn how to do API versioning, but fail to find any resources.

00:38:39.320 --> 00:38:46.280
So Cadwin also becomes this, I guess, hub for API versioning resources and anything related to them.

00:38:46.280 --> 00:38:52.300
It seems like it would probably be pretty easy to adapt to anything that uses Pydantic for its data exchange.

00:38:52.300 --> 00:38:52.660
Oh, yes.

00:38:52.840 --> 00:38:53.020
Yeah.

00:38:53.020 --> 00:39:03.600
So like, for example, in Flask, Flask doesn't do the model binding type stuff on the endpoint, but you can just take the input data and just star start into a Pydantic model.

00:39:03.600 --> 00:39:06.380
And then, you know, now you're in Pydantic world, right?

00:39:06.380 --> 00:39:10.520
So it sounds like maybe something along those lines might be a good bridge.

00:39:10.520 --> 00:39:17.320
There's a lot of magic involved in trying to interface with FastAPI simply due to its internal complexity.

00:39:17.320 --> 00:39:17.600
Right.

00:39:17.600 --> 00:39:22.240
This portion of Talk Python To Me is brought to you by Sentry.

00:39:22.240 --> 00:39:24.880
You know Sentry for their error tracking service.

00:39:24.880 --> 00:39:31.120
But did you know you can take that all the way through your multi-tiered and distributed app with their distributed tracing feature?

00:39:31.860 --> 00:39:42.500
Distributed tracing is a debugging technique that involves tracking requests of your system, starting from the very beginning like a user action, all the way to the backend, database, and third-party services.

00:39:42.500 --> 00:39:47.880
This can help you identify if the cause of an error in one project is due to the error in another.

00:39:47.880 --> 00:39:52.760
Every system can benefit from distributed tracing, but they're especially useful for microservices.

00:39:52.760 --> 00:39:59.580
In this architecture, logs won't give you the full picture, so you can't debug every request in full just by reading the logs.

00:40:00.160 --> 00:40:07.780
Distributed tracing with a platform like Sentry gives you a visual overview about which services were called during the execution of certain requests.

00:40:07.780 --> 00:40:14.940
Aside from debugging and visualizing your architecture, distributed tracing also helps you identify performance bottlenecks.

00:40:14.940 --> 00:40:23.820
Through a visual like a Gantt chart, you can see if a particular span in your stack took longer than expected and how it could be causing slowdowns in other parts of your app.

00:40:23.820 --> 00:40:28.820
Learn more and see some examples in the tracing section at docs.sentry.io.

00:40:29.120 --> 00:40:33.520
To take advantage of all the features of the Sentry platform, just create your free account.

00:40:33.520 --> 00:40:41.960
And for all of you Talk Python listeners, use the code TALKPYTHON, all one word, and you'll activate a free month of their premium paid features.

00:40:41.960 --> 00:40:46.620
Get started today at talkpython.fm/sentry-trace.

00:40:46.620 --> 00:40:49.700
That link is in your podcast player show notes and the episode page.

00:40:49.700 --> 00:40:52.980
Thank you to Sentry for supporting Talk Python To Me.

00:40:54.800 --> 00:41:02.720
So some good questions, but I think they'll be somewhat answered if we just maybe talk us through your tutorial here.

00:41:02.720 --> 00:41:05.820
Like how do we use Cadwyn and how does it manifest?

00:41:05.820 --> 00:41:07.000
How does it work at runtime?

00:41:07.000 --> 00:41:07.700
Stuff like that.

00:41:07.700 --> 00:41:12.680
First, before using Cadwyn, you know, you write your regular app, but then you just structure it a little bit differently.

00:41:13.200 --> 00:41:19.500
When you are versioning, you need a directory that you will consider versioned.

00:41:19.500 --> 00:41:23.080
And this directory will be duplicated for every version.

00:41:23.080 --> 00:41:26.560
No worries, you're not going to support the version code.

00:41:26.560 --> 00:41:29.000
It's going to be code generation all the way through.

00:41:29.160 --> 00:41:39.860
And you can use it to generate connectors for your application, or you could use it to generate schemas or enums, you know, the different version of them and anything else related to them.

00:41:39.860 --> 00:41:44.360
So you pick such a directory, you call it latest as for your latest version.

00:41:44.360 --> 00:41:48.020
Then you define a single version bundle.

00:41:48.260 --> 00:41:53.200
If you go a little bit down, you will see somewhere in here after defining versions.

00:41:53.200 --> 00:42:00.460
Yes, we define our version bundle with a single version, whichever version it is for you, whichever date it is for you.

00:42:00.460 --> 00:42:03.400
And then you run code generation.

00:42:03.400 --> 00:42:07.420
It generates a directory that simply imports from your latest.

00:42:07.420 --> 00:42:10.540
And that's where you can start doing the magic.

00:42:10.540 --> 00:42:13.900
Now you just use our versioned app.

00:42:13.900 --> 00:42:17.140
If you take a look, we have a versioned API router.

00:42:17.420 --> 00:42:19.780
Then you use the Cadwyn version app.

00:42:19.780 --> 00:42:23.040
You generate version routers.

00:42:23.040 --> 00:42:27.060
And then it's going to generate a really nice Swagger for them.

00:42:27.060 --> 00:42:29.840
If you open it somewhere, I think, yep, this one.

00:42:29.840 --> 00:42:36.660
So now your dashboard, the one on docs, is not the Swagger page, but the dashboard of all your versions.

00:42:36.660 --> 00:42:37.500
And that's it.

00:42:37.500 --> 00:42:41.000
After that, you can simply repeat the steps above.

00:42:41.000 --> 00:42:47.000
So you write a migration, write that converter that describes the difference between the versions.

00:42:47.300 --> 00:42:49.260
We have it somewhere there.

00:42:49.260 --> 00:42:57.000
If we had an address as a string and we want to change it to a list, we say, okay, schema, base user, field addresses didn't exist.

00:42:57.000 --> 00:42:59.660
You have a user object, which is a Pydantic model.

00:42:59.660 --> 00:43:06.420
The user object in the initial version just had a field called address, which was a string.

00:43:06.420 --> 00:43:07.460
But you said, you know what?

00:43:07.460 --> 00:43:10.160
People might have multiple addresses that they live at.

00:43:10.280 --> 00:43:15.160
So let's make it a list of strings and make it addresses, right?

00:43:15.160 --> 00:43:22.320
Which seems like a minor change, but clearly that's going to be a major problem for the things that assume there's an address and it's no longer there.

00:43:22.320 --> 00:43:22.760
Right.

00:43:22.800 --> 00:43:29.880
So you create this version change derived class that has a upgrade downgrade basically feature, right?

00:43:29.880 --> 00:43:32.280
You simply describe how do you migrate your schemas?

00:43:32.280 --> 00:43:36.040
How do you change your schema classes, your bidentic models?

00:43:36.280 --> 00:43:40.320
And then you describe how you convert your requests and response.

00:43:40.320 --> 00:43:40.940
And that's it.

00:43:40.940 --> 00:43:44.000
This class is the only thing you write for the new versions.

00:43:44.000 --> 00:43:46.740
Then you run code generation, run your app.

00:43:46.740 --> 00:43:47.140
That's it.

00:43:47.140 --> 00:43:47.960
Everything works.

00:43:48.140 --> 00:43:49.020
Yeah, that's super cool.

00:43:49.020 --> 00:43:56.760
So a couple of questions that were comments that are interesting here is Emile asks, is it like database migrations?

00:43:56.760 --> 00:44:00.580
And Mike Fila points out, it's really, really similar to like Alembic, right?

00:44:00.580 --> 00:44:02.740
You say, generate me the changes.

00:44:02.740 --> 00:44:11.740
Alembic is a little different in that it looks at the two different database schemas and tries to actually write the migration code to do the DDL changes.

00:44:11.740 --> 00:44:18.100
But in principle, it's like every time there's a version change, there's some bit of code that is generated that will run.

00:44:18.100 --> 00:44:21.600
And then the other one is about, you know, how does this affect performance?

00:44:21.600 --> 00:44:28.160
And I guess the only real performance change is like there'll be a couple of steps to the serialization, but they're often small.

00:44:28.160 --> 00:44:33.800
Like in this case, the new version takes the old data and says, well, we're just going to have a list with one address.

00:44:33.800 --> 00:44:36.980
So we're going to stick the one address into the list of addresses.

00:44:37.180 --> 00:44:41.780
And vice versa, you just set the address field to be the first thing in the address list.

00:44:41.780 --> 00:44:45.380
And like, that's a really low amount of code overhead to go back.

00:44:45.380 --> 00:44:50.320
And hopefully people are moving towards the new versions eventually, you know, that kind of thing, right?

00:44:50.320 --> 00:44:55.160
But if they don't, then this code just runs to transform the dictionaries that goes back to it, right?

00:44:55.160 --> 00:44:59.820
Imagine you have like Stripe, I don't know, 13 years worth of versions.

00:45:00.340 --> 00:45:05.020
Now, if you are a successful company, and if you are alive, you are probably a successful company.

00:45:05.020 --> 00:45:11.640
After 13 years, you know, if you are a successful company, that most of your clients will probably be newer ones.

00:45:11.640 --> 00:45:19.020
The longer you exist, the more clients you have, and the more clients you have, the more, you know, newer clients you have, the newer API versions they will use.

00:45:19.020 --> 00:45:25.340
Even if they're old clients, they might decide to, they might rewrite their own app and get a new version, right?

00:45:25.340 --> 00:45:30.820
Like, they could upgrade their code, because their code is going to be 13 years old or 12 years old at this point.

00:45:30.820 --> 00:45:32.260
They're like, they need to change too.

00:45:32.260 --> 00:45:40.540
At some point, yes, your old client might, you know, from the very first version might request something, and then we'll go through all converters.

00:45:40.540 --> 00:45:50.360
Well, not all, all converters that are related to the specific request and response, and that is probably going to be in the tens, not even in the hundreds, even after 13 years.

00:45:50.360 --> 00:45:55.820
But your clients from the latest versions, or even from the middle versions, will not suffer that.

00:45:55.820 --> 00:46:01.140
So the majority of your clients will actually see almost no performance difference.

00:46:01.140 --> 00:46:10.480
And even your old clients, even your clients for 13 years old will probably, even if they do see a performance difference, it's not going to be multiple orders.

00:46:10.480 --> 00:46:12.680
It's not going to be 2x, 3x.

00:46:12.680 --> 00:46:17.620
It's probably going to be maybe 20%, maybe even 10%, depending on how slow your app is.

00:46:17.620 --> 00:46:22.560
And that's considering how many years have passed is crazy fast.

00:46:22.560 --> 00:46:23.220
Yeah, absolutely.

00:46:23.220 --> 00:46:24.180
That's very cool.

00:46:24.180 --> 00:46:26.780
So what about the URL?

00:46:26.780 --> 00:46:27.960
What about the endpoint?

00:46:28.480 --> 00:46:36.340
How much do consumers of your API have to actually think about, I'm using this version or that version?

00:46:36.340 --> 00:46:38.780
Is it passed as a, is the version passed as a header?

00:46:38.780 --> 00:46:41.040
Is the query string part of the URL?

00:46:41.040 --> 00:46:43.140
The version is passed as a header.

00:46:43.140 --> 00:46:47.320
And Cadwin, by default, requires it to be.

00:46:47.320 --> 00:46:52.540
But if you have some developer portal, if you want to, you know, store your version in some database,

00:46:52.900 --> 00:47:04.980
then even though it's a little more advanced, you can write yourself your own middleware that will, you know, check if the client already has a version and then pick that version and put it into the context bar.

00:47:04.980 --> 00:47:06.380
And it's possible.

00:47:06.740 --> 00:47:14.360
So by default, you're going to have, no, no, no, middlewares are the more advanced sections, not in the tutorial.

00:47:14.360 --> 00:47:16.120
There's this other one we're going to talk about in a section.

00:47:16.120 --> 00:47:28.180
It has just an example of all, you basically just, in FastAPI, when you create the app, you know, like app equals FastAPI, you just say middleware equals a list of classes that implement these behaviors.

00:47:28.180 --> 00:47:36.240
So what you're suggesting is, like, you just create a class and you pass it in at FastAPI startup, and it just goes, is there a version being passed to me?

00:47:36.240 --> 00:47:45.220
If not, let's see who the user is based on their API key, pull that from a database, and maybe just set that header right there before the request and then let it fly, right?

00:47:45.220 --> 00:47:45.860
Something like that?

00:47:45.860 --> 00:47:46.100
Yep.

00:47:46.100 --> 00:47:51.580
And then your API will essentially be Stripe-like, where your client won't need to think about versioning at all.

00:47:51.580 --> 00:48:01.320
But by default, of course, the clients need to always pass it with a header, which might sound like something really unnecessary and hard for the clients.

00:48:01.320 --> 00:48:11.140
But if you imagine that you're writing code, it's exceptionally easy to just put it into your, I don't know, requests or HTTPX client and forget about it, you know?

00:48:11.140 --> 00:48:12.160
It is pretty easy.

00:48:12.160 --> 00:48:23.440
If you're consuming APIs in the fashion that we're talking about, you're probably already putting an API key or some kind of thing into the header as well, right?

00:48:23.440 --> 00:48:25.600
Like, so you're already messing with the header anyway.

00:48:25.600 --> 00:48:27.080
Just put another value in there.

00:48:27.080 --> 00:48:27.540
Precisely.

00:48:27.540 --> 00:48:27.900
All right.

00:48:27.900 --> 00:48:36.220
So right now, this is a FastAPI thing, but you're considering opening up to other areas, other platforms, other web frameworks?

00:48:36.220 --> 00:48:44.160
It has a, what is it called, a milestone for that, which I am planning to extend with tasks, with plans.

00:48:44.160 --> 00:48:51.340
First, you know, it's like with Pydantic, you know, at some point it separated the core when it was moving to Pydantic 2.

00:48:51.340 --> 00:48:56.300
And that's one of the plans for Cadwin, you know, separate the core without breaking the public interfaces.

00:48:56.300 --> 00:49:02.920
And then at some point use this core to build more Cadwins, you know, Cadwin Django, Cadwin Flask, whatever.

00:49:02.920 --> 00:49:05.940
Or it doesn't even have to be a part of Cadwin.

00:49:05.940 --> 00:49:08.900
The approach is there so anyone can use it.

00:49:08.900 --> 00:49:18.660
Because 99% of complexity in implementing Cadwin was actually figuring out these patterns and understanding how to do it.

00:49:18.660 --> 00:49:27.140
Because unlike a web app, unlike, I don't know, many apps that we develop daily, it doesn't, these things haven't been done.

00:49:27.480 --> 00:49:41.480
People have migrated stuff, but it was mostly, you know, oh, change this dictionary without a proper DSL or without code generation, you know, without the niceties that would make your IDs happy.

00:49:41.480 --> 00:49:44.520
And that would make, you know, auto-completion happy.

00:49:44.720 --> 00:49:47.820
Yeah, you are a contributor to TypeShed, which is awesome.

00:49:48.660 --> 00:49:56.180
So you must care about, you know, conveying the type information of the different versions and stuff like that.

00:49:56.180 --> 00:49:57.280
That's tricky, right?

00:49:57.280 --> 00:50:00.640
And of course, working on FastAPI and Pydantic, those are very type.

00:50:00.640 --> 00:50:03.060
Oh, and the shirt says TypeHints for Life.

00:50:03.060 --> 00:50:03.540
I love it.

00:50:03.700 --> 00:50:07.700
I don't have any cool slogan in my eyes to have gray stripes, but I should.

00:50:07.700 --> 00:50:08.660
Very cool.

00:50:08.660 --> 00:50:13.780
So yeah, want to speak to the TypeHint type information aspect of this whole thing?

00:50:13.780 --> 00:50:19.520
Essentially, as I mentioned, Stripe did it using, you know, simply dictionaries.

00:50:19.520 --> 00:50:22.840
And it was mostly untyped.

00:50:22.840 --> 00:50:32.420
As probably many people know, Stripe, after having so many problems with scalability in terms of like the team scalability and problems with typing,

00:50:32.620 --> 00:50:35.660
they have decided to adopt Sorbet.

00:50:35.660 --> 00:50:41.500
Well, not adopt, create Sorbet, which is essentially a type checker.

00:50:41.500 --> 00:50:46.880
It's like a type checker and DSL for Ruby for TypeKins, which is really nice.

00:50:46.880 --> 00:50:51.660
It has both the runtime component and a static component, as far as I remember.

00:50:51.660 --> 00:50:57.500
But they still, most of the time, work with untyped code, which essentially can lead to many errors.

00:50:57.500 --> 00:51:01.960
Cadwin tries to make sure that you still work with your schemas.

00:51:02.060 --> 00:51:03.760
You still know which schema you work with.

00:51:03.760 --> 00:51:04.740
It's always the latest.

00:51:04.740 --> 00:51:12.420
And Cadwin tries to make sure that you're not going to have any type errors if you don't want to.

00:51:12.420 --> 00:51:18.760
And you're going to have all of the niceties of having this dynamic request response conversion thing.

00:51:19.100 --> 00:51:31.760
So we're trying to take the best of both worlds, have you support very little code, but like make sure that you can type in everything without any issue and you're not going to have problems and your type checker is going to check everything for you.

00:51:31.760 --> 00:51:36.920
And your VS Code is going to see which field something has, which type something has.

00:51:37.040 --> 00:51:37.420
Excellent.

00:51:37.420 --> 00:51:53.740
One of the big problems with like all the runtime modifications, like one way you could have done this is that app startup, it could look at all of those things and it could just dynamically generate all the different versions and all the things, you know, using meta programming.

00:51:54.280 --> 00:51:55.820
But then the editors hate that.

00:51:55.820 --> 00:51:56.020
Yeah.

00:51:56.020 --> 00:51:56.200
Yeah.

00:51:56.200 --> 00:52:01.500
It does that with the endpoints because endpoints are not your editors.

00:52:01.500 --> 00:52:02.860
They don't care about endpoints.

00:52:02.860 --> 00:52:06.400
You never call your endpoint from your code.

00:52:06.400 --> 00:52:08.540
No, you usually call the business logic from it.

00:52:08.540 --> 00:52:08.780
Yeah.

00:52:08.840 --> 00:52:10.320
Which is why I decided to do it in runtime.

00:52:10.320 --> 00:52:11.520
You don't really need it.

00:52:11.520 --> 00:52:12.920
But for schemas, yes.

00:52:12.920 --> 00:52:20.240
For schemas, having them generated and then having people guessing and then having their IDs just put everything in red.

00:52:20.240 --> 00:52:21.260
That is horrible.

00:52:21.260 --> 00:52:23.320
I wouldn't want anyone to have that.

00:52:23.320 --> 00:52:23.580
Yeah.

00:52:23.580 --> 00:52:23.760
Yeah.

00:52:23.760 --> 00:52:24.400
I don't like it either.

00:52:24.400 --> 00:52:25.580
Not at all.

00:52:25.580 --> 00:52:28.560
It's right up there with the star, star, star, star, KW orgs.

00:52:28.560 --> 00:52:31.500
Have a good time guessing in my world.

00:52:31.500 --> 00:52:32.600
I don't like either of them.

00:52:32.600 --> 00:52:33.440
Awesome.

00:52:33.440 --> 00:52:33.800
All right.

00:52:33.800 --> 00:52:39.600
Well, let's just maybe touch real quickly on a couple of other choices that are out here.

00:52:39.600 --> 00:52:40.900
You know, Cadwin looks awesome.

00:52:40.900 --> 00:52:47.260
But we also have, for example, we have from Dean Way, we have FastAPI versioning, which has a very different philosophy.

00:52:47.260 --> 00:52:54.040
It has kind of the V1, the V2 style that you might maintain multiple versions of.

00:52:54.040 --> 00:52:59.040
You want to just maybe speak to your thoughts on this one real quick and that people can take that if they like this style.

00:52:59.040 --> 00:53:01.720
I think it's either the first or the most popular.

00:53:01.720 --> 00:53:08.680
It's definitely the most popular, but I think it might even be the first library in FastAPI to implement versioning, implement proper versioning.

00:53:08.680 --> 00:53:10.100
It has a few issues.

00:53:10.100 --> 00:53:15.620
First of all, it only as long, as far as I remember, it is mostly duplication based.

00:53:15.620 --> 00:53:21.500
So it doesn't automate anything for you, which is a good thing if you know what you're doing and you're not going to have a lot of versions.

00:53:22.440 --> 00:53:34.820
If you have 10 or 20 versions, if you want to keep them for a long time, this is the, you know, endpoint point copying approach that I mentioned that with time is going to kill you, which is a problem here.

00:53:35.080 --> 00:53:43.620
The second problem is that it, as far as I understand, kind of recommends semantic versioning, though it doesn't bind you to it.

00:53:43.620 --> 00:53:47.260
You can use dates, though you have to make sure that they're dates yourself.

00:53:47.260 --> 00:53:50.160
And you can use just simple integers.

00:53:50.820 --> 00:53:55.220
So you're not bound by semantic versioning, but it has a few examples with that.

00:53:55.220 --> 00:53:58.020
Aside from these two, it's an amazing library.

00:53:58.020 --> 00:54:06.080
And for anyone who just wants to version a small app, you know, just add a single version that is going to be, you know, the old version is going to be deleted in like two months.

00:54:06.080 --> 00:54:06.980
Use that.

00:54:06.980 --> 00:54:08.600
Use FastAPI versioning.

00:54:08.680 --> 00:54:11.700
It's an amazing library and you don't need anything else.

00:54:11.700 --> 00:54:21.100
Catwin is for use cases where you need to keep a larger number of versions or if the changes between your versions are much trickier.

00:54:21.100 --> 00:54:27.320
Yeah, like this might be pretty good for my example I talked about with the courses app that we built, right?

00:54:27.320 --> 00:54:28.640
We literally have two versions.

00:54:28.640 --> 00:54:31.640
It's been around since 2018 and there's two versions.

00:54:31.640 --> 00:54:35.580
You know, like that would be a decorator and I'm probably good to go.

00:54:35.580 --> 00:54:36.860
I don't need to think too much about it.

00:54:36.860 --> 00:54:37.340
Precisely.

00:54:37.560 --> 00:54:38.940
No code generation, no nothing.

00:54:38.940 --> 00:54:41.300
You just, you know, you just put it in and you go.

00:54:41.300 --> 00:54:42.040
Another one.

00:54:42.040 --> 00:54:52.560
If you're a Flask person, you could have Flask rebar, which seems to have a real similar philosophy to what you just described, but, you know, works for Flask.

00:54:52.560 --> 00:54:56.640
I feel like it's a little more complex than that.

00:54:56.640 --> 00:54:58.980
It is also the parent point.

00:54:58.980 --> 00:55:02.480
So it also allows you to duplicate single endpoints.

00:55:02.480 --> 00:55:05.380
It also allows you to do arbitrary prefixes.

00:55:05.900 --> 00:55:09.140
So you can have integers, you can have dates, you can have, you know, whatever.

00:55:09.140 --> 00:55:10.660
Old, new, whatever.

00:55:10.660 --> 00:55:11.460
Yeah.

00:55:11.460 --> 00:55:11.640
Yeah.

00:55:11.640 --> 00:55:12.080
Old, new.

00:55:12.080 --> 00:55:13.860
I guess some people do that.

00:55:13.860 --> 00:55:15.120
If you want.

00:55:15.120 --> 00:55:16.180
Yeah.

00:55:16.180 --> 00:55:17.200
Latest, latest.

00:55:17.200 --> 00:55:17.820
Yeah.

00:55:17.820 --> 00:55:18.140
Yeah.

00:55:18.140 --> 00:55:19.780
Latest, really latest, final.

00:55:19.940 --> 00:55:21.580
Like a new folder, new folder.

00:55:21.580 --> 00:55:22.480
Yes, exactly.

00:55:22.480 --> 00:55:25.860
But yeah, it's really similar.

00:55:25.860 --> 00:55:26.500
And I guess.

00:55:26.500 --> 00:55:29.760
They probably use zipping up folders for version control as well.

00:55:29.760 --> 00:55:30.960
I'm just naming them by the date.

00:55:30.960 --> 00:55:32.480
Final, final, final.

00:55:32.480 --> 00:55:34.320
Let's not use, let's not use Git.

00:55:34.320 --> 00:55:36.060
Let's, let's just copy them.

00:55:36.280 --> 00:55:38.360
As for versioning, that's like a really good metaphor.

00:55:38.360 --> 00:55:43.920
If you are a person that just needs another version of their Google Doc, you wouldn't use

00:55:43.920 --> 00:55:44.240
Git.

00:55:44.240 --> 00:55:46.600
Well, unless you use Git for everything else.

00:55:46.600 --> 00:55:47.480
And same here.

00:55:47.680 --> 00:55:51.800
You don't need a huge combine for using Flask.

00:55:51.800 --> 00:55:56.280
And Flask usually, at least in my experience, tries to build simpler APIs.

00:55:56.280 --> 00:56:02.100
And you wouldn't use, well, most companies that do API first don't do, don't use Flask.

00:56:02.100 --> 00:56:08.660
They try to do, you know, Django DRF or FastAPI, which is why this library seems like a perfect

00:56:08.660 --> 00:56:09.300
choice for that.

00:56:09.300 --> 00:56:09.820
Yeah, indeed.

00:56:09.820 --> 00:56:11.020
It seems really nice.

00:56:11.020 --> 00:56:16.020
One of the things that we were speaking of duplication, one of the things that they just

00:56:16.020 --> 00:56:18.020
jump right into to demonstrate here.

00:56:18.020 --> 00:56:22.320
And I imagine the FastAPI version one as well could do it.

00:56:22.320 --> 00:56:25.240
But there's one endpoint that doesn't change.

00:56:25.240 --> 00:56:26.940
And there's one that is different.

00:56:26.940 --> 00:56:28.400
So they copy the one that's different.

00:56:28.400 --> 00:56:33.380
But for the one that doesn't change, they just put a V1 and a V2 decorator on that one.

00:56:33.380 --> 00:56:35.580
And it, it remains unchanged, basically, right?

00:56:35.580 --> 00:56:38.320
Cadwyn tries to escape this kind of verbosity.

00:56:38.320 --> 00:56:41.200
And essentially, you have all endpoints everywhere.

00:56:41.200 --> 00:56:45.540
And if you want to, you know, omit some endpoint or change some endpoint or add some endpoint,

00:56:45.960 --> 00:56:51.800
into the new version, you just add a version change and say, oh, this endpoint didn't exist

00:56:51.800 --> 00:56:52.820
in the old version.

00:56:52.820 --> 00:56:53.460
That's it.

00:56:53.460 --> 00:56:53.860
Very cool.

00:56:53.860 --> 00:56:57.440
Yeah, because if you had 20 of these, you'd have 20 decorators in the little function.

00:56:57.440 --> 00:56:58.880
Right?

00:56:58.880 --> 00:56:59.800
That's where it starts to get.

00:56:59.800 --> 00:57:01.260
Not a huge issue for Flask.

00:57:01.260 --> 00:57:07.840
I haven't seen anyone building, I don't know, 50 or 200 endpoint apps with Flask.

00:57:07.840 --> 00:57:08.820
I'm sure people do that.

00:57:08.820 --> 00:57:10.560
But I think it's the minority.

00:57:10.560 --> 00:57:14.880
Other side of the fence, Django REST framework, DRF, you already mentioned them a little bit.

00:57:14.880 --> 00:57:21.240
And so Django, they already have like versioning built into the framework itself, right?

00:57:21.240 --> 00:57:23.400
They have versioning interfaces built into.

00:57:23.400 --> 00:57:29.080
So like, it's not, they're not implementing versioning for you, but they give you all the

00:57:29.080 --> 00:57:30.840
tools to implement your own versioning.

00:57:30.840 --> 00:57:31.100
Yeah.

00:57:31.160 --> 00:57:31.360
Okay.

00:57:31.360 --> 00:57:33.360
So they kind of have the building blocks for it.

00:57:33.360 --> 00:57:33.780
Excellent.

00:57:33.780 --> 00:57:34.300
Exactly.

00:57:34.300 --> 00:57:34.680
All right.

00:57:34.680 --> 00:57:38.980
Well, I think we're pretty much out of time, but thank you for being here.

00:57:38.980 --> 00:57:39.920
It's been really interesting.

00:57:39.920 --> 00:57:41.440
Oh, it was for me as well.

00:57:41.440 --> 00:57:42.780
Thank you for having me here.

00:57:42.780 --> 00:57:43.080
Yeah.

00:57:43.080 --> 00:57:46.640
You've given everyone a lot to think about, you know, before we wrap it up, two quick

00:57:46.640 --> 00:57:49.280
things, you know, notable PyPI package.

00:57:49.280 --> 00:57:51.640
I mean, we've already given Cadwin a shout out.

00:57:51.640 --> 00:57:55.120
Anything else that like, oh, I came across this and it was super cool.

00:57:55.120 --> 00:57:57.340
Maybe it deserves a little bit of a shout out.

00:57:57.340 --> 00:57:59.560
Anything that like you use a lot that you would recommend?

00:57:59.840 --> 00:58:04.140
For us in our company, we started using one more package of mine.

00:58:04.140 --> 00:58:06.320
It's called pytest Fixture Classes.

00:58:06.320 --> 00:58:06.620
Okay.

00:58:06.620 --> 00:58:12.100
Essentially, when you are building groups of fixtures that create some objects for you,

00:58:12.100 --> 00:58:16.620
for you to use in your tests, and then all of a sudden, one of your tests needs an object

00:58:16.620 --> 00:58:19.400
that's a little different, you know, just a little bit.

00:58:19.400 --> 00:58:21.120
And then everything just falls apart.

00:58:21.120 --> 00:58:21.380
Yeah.

00:58:21.380 --> 00:58:28.760
A factory fixture pattern that you can see in pytest allows you to, you know, make a function

00:58:28.760 --> 00:58:34.620
within a function and one of them is a fixture and that's all cool and nice, but then it's

00:58:34.620 --> 00:58:35.140
not typed.

00:58:35.140 --> 00:58:40.580
You can use, you know, the callable syntax and then you're not going to have the keyword arguments

00:58:40.580 --> 00:58:41.000
there.

00:58:41.000 --> 00:58:45.560
And otherwise you can write a protocol and it's a lot of code.

00:58:45.740 --> 00:58:50.140
What pytest Fixture Classes does is it allows you to type everything there.

00:58:50.140 --> 00:58:54.260
So you write the same amount of code, but it's all typed.

00:58:54.260 --> 00:58:59.720
And now you have, you can have groups of fixture classes building on top of each other, which

00:58:59.720 --> 00:59:03.040
is a nice pattern to have, but a really bad pattern to abuse.

00:59:03.040 --> 00:59:04.020
Very cool.

00:59:04.380 --> 00:59:04.600
All right.

00:59:04.600 --> 00:59:06.600
Well, nice, nice recommendation.

00:59:06.600 --> 00:59:07.740
People can check that out.

00:59:07.740 --> 00:59:10.380
Emil, an audience already says, amazing thing.

00:59:10.380 --> 00:59:11.160
I'm already using it.

00:59:11.160 --> 00:59:12.880
So final call to action.

00:59:12.880 --> 00:59:14.360
People have APIs.

00:59:14.360 --> 00:59:19.120
They've listened to us talk for an hour and they're like, oh, we should be versioning our

00:59:19.120 --> 00:59:19.600
APIs.

00:59:19.600 --> 00:59:22.780
We probably should be doing something here.

00:59:22.780 --> 00:59:24.320
What do you recommend people do?

00:59:24.320 --> 00:59:25.020
How do they get started?

00:59:25.020 --> 00:59:26.380
How do they go further?

00:59:26.380 --> 00:59:29.840
So first you need to decide whether your use case is simple.

00:59:29.840 --> 00:59:31.580
How many versions are you going to support?

00:59:31.580 --> 00:59:36.840
If you're not planning to support more than two versions, or if you are supporting versions

00:59:36.840 --> 00:59:43.260
only for your internal microservices or only for your front end, then consider using the

00:59:43.260 --> 00:59:43.980
simple tools.

00:59:43.980 --> 00:59:49.340
Consider using the FastAPI versioning, you know, fast rebar, things like that.

00:59:49.340 --> 00:59:55.520
But then once you realize that you need to support versions for months and you need three

00:59:55.520 --> 01:00:00.760
or more versions and you're providing your versions as a public, you know, to the public,

01:00:00.760 --> 01:00:05.920
then I advise moving straight into Cadwin or Cadwin-like frameworks.

01:00:05.920 --> 01:00:08.180
If you use FastAPI, you can just use Cadwin.

01:00:08.180 --> 01:00:13.280
It has a bit of a learning curve, but within making one version, you will realize just how

01:00:13.280 --> 01:00:13.960
simple it is.

01:00:13.960 --> 01:00:17.440
And if you're not using Cadwin, that's fine as well.

01:00:17.440 --> 01:00:23.280
I have all of the resources that I use to build it and all of the resources, you know,

01:00:23.640 --> 01:00:28.520
describing different ways of API versioning there in the repository in the theory section.

01:00:28.520 --> 01:00:30.120
So you can just read that.

01:00:30.120 --> 01:00:34.480
And even if you don't like that approach, we describe everything else there.

01:00:34.480 --> 01:00:36.800
So you'll be able to pick the one you like.

01:00:36.800 --> 01:00:39.960
But my personal recommendation, don't pick the directories.

01:00:39.960 --> 01:00:40.780
They're painful.

01:00:41.180 --> 01:00:41.900
Awesome.

01:00:41.900 --> 01:00:43.020
Really good advice.

01:00:43.020 --> 01:00:44.740
Super cool project.

01:00:44.740 --> 01:00:46.760
So thank you for being here, Stanislav.

01:00:46.760 --> 01:00:48.200
And talk to you later.

01:00:48.200 --> 01:00:48.720
Talk to you later.

01:00:48.720 --> 01:00:52.220
This has been another episode of Talk Python To Me.

01:00:52.220 --> 01:00:53.980
Thank you to our sponsors.

01:00:53.980 --> 01:00:55.640
Be sure to check out what they're offering.

01:00:55.640 --> 01:00:57.060
It really helps support the show.

01:00:58.340 --> 01:01:03.840
It's time to stop asking relational databases to do more than they were made for and simplify

01:01:03.840 --> 01:01:06.080
complex data models with graphs.

01:01:06.080 --> 01:01:12.520
Check out the sample FastAPI project and see what Neo4j, a native graph database, can do

01:01:12.520 --> 01:01:12.900
for you.

01:01:12.900 --> 01:01:17.340
Find out more at talkpython.fm/Neo4j.

01:01:18.820 --> 01:01:20.600
Take some stress out of your life.

01:01:20.600 --> 01:01:26.080
Get notified immediately about errors and performance issues in your web or mobile applications with

01:01:26.080 --> 01:01:26.380
Sentry.

01:01:26.380 --> 01:01:31.380
Just visit talkpython.fm/sentry and get started for free.

01:01:31.380 --> 01:01:34.980
And be sure to use the promo code talkpython, all one word.

01:01:34.980 --> 01:01:37.040
Want to level up your Python?

01:01:37.040 --> 01:01:41.100
We have one of the largest catalogs of Python video courses over at Talk Python.

01:01:41.100 --> 01:01:46.260
Our content ranges from true beginners to deeply advanced topics like memory and async.

01:01:46.260 --> 01:01:48.940
And best of all, there's not a subscription in sight.

01:01:48.940 --> 01:01:51.840
Check it out for yourself at training.talkpython.fm.

01:01:51.840 --> 01:01:53.900
Be sure to subscribe to the show.

01:01:53.900 --> 01:01:56.680
Open your favorite podcast app and search for Python.

01:01:56.680 --> 01:01:58.000
We should be right at the top.

01:01:58.000 --> 01:02:03.160
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:02:03.160 --> 01:02:07.360
and the direct RSS feed at /rss on talkpython.fm.

01:02:07.360 --> 01:02:10.320
We're live streaming most of our recordings these days.

01:02:10.320 --> 01:02:13.720
If you want to be part of the show and have your comments featured on the air,

01:02:13.720 --> 01:02:18.160
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:02:18.160 --> 01:02:20.220
This is your host, Michael Kennedy.

01:02:20.220 --> 01:02:21.500
Thanks so much for listening.

01:02:21.500 --> 01:02:22.680
I really appreciate it.

01:02:22.680 --> 01:02:24.580
Now get out there and write some Python code.

01:02:24.580 --> 01:02:45.500
I'll see you next time.

