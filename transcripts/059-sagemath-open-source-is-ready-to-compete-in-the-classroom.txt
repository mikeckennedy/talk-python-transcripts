00:00:00 What do you do when you're a high caliber mathematician or a scientist and you want to

00:00:03 share your algorithms and code? Sounds like a job for GitHub, doesn't it? But the problem is often

00:00:08 this work is done on proprietary platforms such as Magma, MATLAB, Mathematica, and others.

00:00:12 Not only can you not share your licenses for, say, MATLAB, but there are often proprietary

00:00:18 separate libraries and tools for specialized work. These are expensive products. One example

00:00:23 from my distant past was using the wavelet toolbox on MATLAB. MATLAB itself is over $2,000

00:00:29 and the wavelet library is another $1,000. So to share my code, you must have both licenses

00:00:35 yourself. This is a problem. Well, if you're William Stein, you take this problem and you turn

00:00:40 it into an opportunity to build an open source competitor to MATLAB and related platforms.

00:00:44 This episode is all about SageMath, an open source feature-rich option for scientists and mathematicians

00:00:50 built by over 500 contributors and consisting of over 500,000 lines of Python and Cython code.

00:00:57 This is Talk Python To Me, episode 59, recorded May 10th, 2016.

00:01:24 Welcome to Talk Python To Me, a weekly podcast on Python, the language, the libraries, the

00:01:30 ecosystem, and the personalities. This is your host, Michael Kennedy. Follow me on Twitter

00:01:35 where I'm @mkennedy. Keep up with the show and listen to past episodes at talkpython.fm

00:01:40 and follow the show on Twitter via at Talk Python. This episode is brought to you by Hired and SnapCI.

00:01:47 Thank them for supporting the show on Twitter via at Hired underscore HQ and at Snap underscore CI.

00:01:53 During the conversation, we talked about running SageMath on Windows and some of the challenges there.

00:01:59 We mentioned that the new Ubuntu subsystem coming to Windows 10 this summer may make this easier.

00:02:04 Well, just after we recorded this episode, someone did indeed post a message to the SageMath mailing list

00:02:09 showing it running on the Ubuntu subsystem on Windows 10. So look for more goodness in that area down the line.

00:02:15 Now, let's chat with William.

00:02:17 William, welcome to the show.

00:02:19 Thank you.

00:02:20 Yeah, it's super exciting what we have to talk about today. We're going to talk about

00:02:23 building quite a large ecosystem of computational mathematical tools with Python and a bunch of

00:02:33 other related technologies, Cython, C, IPython, lots of stuff, right?

00:02:38 Mm-hmm.

00:02:39 Yeah, it'll be a lot of fun. But before we get into it, of course, tell me your story. How do you get

00:02:43 into programming and Python? You're a mathematician by training, right?

00:02:47 Yes. Yeah. So I've always been into programming since I was like five years old, but I got very

00:02:56 much into mathematics. As an undergraduate, I was a computer science major for a little while,

00:03:01 and then I switched to mathematics since I love it, especially number theory. And then I went to

00:03:06 graduate school at UC Berkeley from 1995 to 2000. And while I was at graduate school, I got heavily

00:03:13 involved into computing with various objects that come up in number theory. And so I had to write a

00:03:19 lot of code in order to compute with those objects. So I just wrote a huge amount of C++ code using a lot

00:03:27 of the libraries in the mid-1990s. It was really painful. It would take like 30 minutes or an hour to

00:03:32 compile, do lots of templating. And I wrote a little interpreter so I could create modular forms and

00:03:38 other mathematical objects and compute with them. And I was doing this sort of all in isolation without

00:03:47 using much beyond some C++ libraries. And then I found out about a computer algebra system called

00:03:53 Magma, which was extremely powerful for computing in abstract mathematical domains. It's kind of,

00:04:01 it's in a way, kind of a competitor to Mathematica or MATLAB, but aimed much more abstract mathematics.

00:04:07 So it has heavy support for group theory, abstract algebra, graph theory, etc. And very little support

00:04:14 for symbolic calculus. But it's what I needed for my PhD thesis work. So I worked really heavily on it.

00:04:20 It's extremely powerful system. And I wrote maybe 30 or 40,000 lines of code that are included with

00:04:26 that software. I went down and visited them in Sydney, Australia a few times. But one frustrating

00:04:33 thing about Magma is that it's closed source. I saw a talk by Manjul Bhargava, who recently won the

00:04:40 Fields Medal. But back in 2003, he was talking in Paris about using Magma for some research on quadratic

00:04:47 forms. And he was running into some brick walls due to it being closed source. And I also kind of took

00:04:53 stock of my own computing environment at the time. I used Linux, LaTeX, Emacs, and everything on my

00:05:00 computer was open source, except Magma, which was the one program that I cared about, and which really

00:05:05 mattered for my research. So I thought that was ridiculous.

00:05:08 Right. That's the most important thing. Yeah, the most important thing that you actually were working

00:05:12 with was the one that you had the least control or visibility into, right?

00:05:17 Yeah, exactly. And at that time, I was also using Python a lot, not for mathematics, but for

00:05:25 kind of scripting mathematics. So if I wanted to do a bunch of computations on a cluster, I would start

00:05:30 them. I would write little scripts via Python to start up the computations. I wrote websites using

00:05:35 Python. So I was using Python a lot, kind of as a complementary tool to mathematical computation.

00:05:41 And so I was at least familiar with Python because of this. And it was back in 2002, 2003, when Python

00:05:47 was more primitive than it is now.

00:05:50 Right. That's just a little before it started to get its scientific legs under it with things like

00:05:57 NumPy and SciPy. And it wasn't quite there, but it was on the verge of that breakout, right?

00:06:02 Yeah. But it still was a pleasant interpreter environment. And it had modern features like

00:06:08 multiple inheritance, you could define your own data types, had good exception handling, etc.

00:06:13 And so I really appreciated some of the functionality it had over, say, Magma. Magma,

00:06:18 though, has a massive library and is incredibly powerful. It misses a lot of basic features of a modern

00:06:25 programming language, which by modern, I mean, say, at least as good as C++ in 1993. I was used to at

00:06:32 least having exception handling and being able to define my own classes and so on.

00:06:36 Right. That's one of the challenges of not just Magma, I would say, but, you know, things like

00:06:42 R to some degree, MATLAB, Mathematica, all these various highly specialized tools that are great at

00:06:49 solving some type of computation or some kind of problem. But when you have to go and build a full

00:06:54 application out of it or something, it kind of hits a wall, right?

00:06:58 Yeah, exactly. There are a whole bunch of special purpose math languages designed by mathematicians.

00:07:04 And though they are pretty good for mathematics, they don't really compete with what you get when

00:07:12 you have computer science people systematically put full-time effort into designing a language

00:07:17 and then a whole ecosystem around that language. And so the difference between trying to write a

00:07:22 non-trivial program in Python versus Magma is that with Python, you have this massive ecosystem of

00:07:28 tools plus a language that's very general purpose. Whereas with Magma or Mathematica or MATLAB,

00:07:33 it's really good maybe for parts of the math things, but for the other parts, just manipulating strings

00:07:39 or whatever, it can be pretty painful.

00:07:41 Yeah, absolutely. So you were working with Magma and you couldn't really use it in the way that you

00:07:48 wanted to, sort of like a web front end or as the backend for a web front end. And that's one of the

00:07:54 problems you run into a lot with these types of software. I'm specifically thinking of MATLAB because

00:07:59 I have the most experience with it, but there's all sorts of little, you know, pay for this bit,

00:08:03 pay for that bit. It's registered on that machine. Like the rules are just crazy, right? And so you got

00:08:10 frustrated with this. Yeah.

00:08:11 Yeah. So in particular with Magma, the project director sent me in a message saying that I wasn't

00:08:18 allowed to use it as a general purpose compute engine on the backend for my websites. And that

00:08:25 was very frustrating. It wasn't just a matter of pay them or not pay them or get the right license

00:08:28 since they're a little more informal than that. And they don't really have kind of official licenses.

00:08:33 So that was like a huge wake up call that I really needed to do something. And so I decided I was going

00:08:39 to survey the open source landscape again for math software and see what's out there and then switch.

00:08:44 But when I looked around, it was really kind of frustrating back then. There were a number of

00:08:52 programs that kind of competed with Magma, but were much more specialized. And despite Magma's language

00:08:59 being fairly primitive compared to say Python, the other systems had languages that were much, much more

00:09:04 primitive yet. So, I mean, it's kind of hard to emphasize how primitive they are. It's kind of like

00:09:11 using, I don't know, assembly programming. I mean, things like different namespaces, that sort of thing is,

00:09:17 is an advanced feature compared to what's available in some of those languages. So I couldn't really bring

00:09:23 myself to go back to that. And also there's a huge amount of functionality that got implemented in Magma

00:09:29 over about a decade. And it just wasn't implemented anywhere in open source, which was a serious problem

00:09:36 as well. So there was just a massive lack of functionality. So what I decided naively first to

00:09:43 do is just choose a language. And I spent about six months to a year evaluating options like OCaml and

00:09:49 directly writing something myself in C++ and using Python. And at the end of the day, I chose Python

00:09:55 because the language was most similar to Magma's. And so I thought it would be easier to get users over

00:10:01 from Magma. And also the Python C API was kind of like what Magma had, but much cleaner as far as how

00:10:09 Magma itself is implemented. And so one thing about Python is that if you want to write a function that you

00:10:15 can use from the interpreter and is really fast, you can write it in C if you need to. And it's just as fast as if

00:10:20 you wrote it in C. And that's kind of a basic requirement if you're going to write code that will be used for

00:10:24 research, that you can write very, very fast code. So Python was good enough. And then I decided I would just sit down

00:10:30 in Python C and me, and I would look at maybe code from other projects and look up algorithms and implement

00:10:36 everything I needed. And this lasted about three hours. And I realized how insanely hard that would be to do.

00:10:43 And I completely switched courses and decided that purely out of laziness, I would try to wrap existing

00:10:50 code in whatever way I had to do so. So using P expect pseudo TTY type stuff, using C libraries,

00:10:59 and we're adding C libraries to existing computer algebra systems, etc.

00:11:04 So maybe not everyone knows expect. Actually, a lot of people don't know. What was it? They know

00:11:09 C, of course, but what does P expect? So one way if you have a, say, Python program,

00:11:15 and you'd like it to interact with some other kind of bizarre, let's just let's say there's a program

00:11:21 called Symmetrica or something, just some one researcher wrote it has a command line interface,

00:11:26 and it doesn't have any C library interface or anything. But you really want to call functions

00:11:31 in there and run some code there and get the results. What P expect will do is let you basically

00:11:36 simulate the terminal and use Python to programmatically feed code into the other program,

00:11:43 look at what output it produces, and then parse that output and return it. So it abstracts things away

00:11:48 and makes it look like you're calling some functions in a Python library. But really behind the scenes,

00:11:54 things are really more or less being copy pasted into a terminal. It's nice because you can interface

00:12:00 with a black, a closed source black box this way, if you need to. And the drawback is that it's brittle,

00:12:07 and it's potentially slow. There's a lot of latency. Instead of, well, there's a several millisecond

00:12:13 overhead to every single thing you do, which is painful. You really want the overhead to be a microsecond,

00:12:18 not a milliseconds. So there's like a order of magnitude of 1000 latency, which can be really

00:12:23 annoying. Interesting. So yeah, yeah. So you were, you were naive and hopeful and you just said,

00:12:30 I'm going to go write this. And then you basically just said, all right, forget that. Let's try to find

00:12:35 all the good building blocks that are already built and build upon them. And that's a very open source

00:12:40 way of problem solving as anyway, right? Yep. So I think about it this way. Like when I worked with Magma,

00:12:46 my team was all the other people, you know, working on that project. And when I switched to trying to do

00:12:51 something open source, the team was all other people in the entire open source sort of world,

00:12:55 everybody that contributed to open source. And definitely the easy way to go would be to

00:13:00 choose the best libraries for number theory and commutative algebra and graph theory and so on and

00:13:05 put them all together. And they weren't kind of built to be put together or to be called from Python,

00:13:11 Python. But it, no matter how hard it would be, it's way easier to provide a library interface to

00:13:17 one of those other systems that you can then use from Python very efficiently than to write one of

00:13:22 those systems from scratch. Like each of those systems took decades and decades of work to write.

00:13:28 So, I mean, total.

00:13:29 Yeah. And to debug them and fine tune them and, you know, that kind of stuff's very hard to know,

00:13:34 even if it's right some of the time.

00:13:36 And a lot of the algorithms, you really kind of have to be in the throes of a PhD

00:13:40 focused for years just to understand what the algorithms are and how they work. And

00:13:44 like, there's just no way one person can replicate that despite wanting to.

00:13:50 That's interesting. So in the end, you decided, all right, Magma is cool, but it's, it's got all

00:13:57 these restrictions and I'm going to go put this thing together. And what you built was called

00:14:01 SageMath, right?

00:14:02 Yes. Yep. So I built SageMath, which is, well, basically what it is, is it's a Python library,

00:14:13 but many of the dependencies are these tricky to compile C programs or Fortran programs or whatever,

00:14:20 which were written by mathematicians only to run on Linux, maybe just for their research.

00:14:26 And so in addition to just being a Python library, it's also a build system,

00:14:30 kind of like Anaconda, but obviously a little bit before that. And it targets a different type of

00:14:37 dependence, like different types of packages. It's a build system. It's a Python library,

00:14:43 library. And then to make it more friendly for mathematicians, it has a customized IPython

00:14:48 command line. And also around 2006, we wrote a web-based graphical interface, which is like the

00:14:55 IPython notebook, but we wrote it a few years earlier. And it was before things like WebSockets

00:15:00 and a lot of nice modern JavaScript functionality existed.

00:15:04 Back in the dark days of JavaScript, when it was earning its bad reputation.

00:15:09 Yep. It was, we started writing it right when I think Google Maps and Gmail appeared.

00:15:13 And there was this thing called Ajax, which let you update a web page without refreshing.

00:15:19 And so we had that little bit of functionality, but the thing we didn't get was a consistent

00:15:23 or a persistent connection. So instead we had to do polling techniques and all kinds of tricks that

00:15:29 were ugly.

00:15:30 Yeah. Very interesting.

00:15:31 In order to make it like, when you do a for loop in Python, you want to see the output as it appears.

00:15:35 And in order to do that, we had to do a lot of hacky stuff.

00:15:38 Yeah. So I think the way maybe to conceptualize it is this is an open source alternative to

00:15:43 something like Mathematica.

00:15:45 Exactly.

00:15:45 Or MATLAB maybe, but it's, it leverages a lot of the good data science, scientific tooling

00:15:52 of Python, like IPython notebooks, for example.

00:15:55 Exactly. So initially I just wanted it to be good enough for my number theory research, number

00:16:02 theory being my research area. But the second developer wasn't a number theorist. The second

00:16:07 person I could get on board is did research in coding theory. And so he wanted a bunch of

00:16:12 functionality that had little to do with number theories. And then he also wanted to teach

00:16:16 undergraduate courses like calculus and differential equations. And so I started adding a lot of

00:16:21 functionality related to those classes, just so that the range of applicability would get

00:16:26 bigger and I could get a few more developers and things sort of growing, started growing

00:16:31 that way. And so this, the system quickly went from being just for number theory to being much

00:16:36 more general. And in order to kind of focus development and decide what it should be, we chose the motto

00:16:42 or the mission statement to create a viable open source free alternative to Magma, Mathematica,

00:16:49 Matlab and Maple. Our focus, none of the developers really have a focus on numerical computation.

00:16:55 So we, in Sage itself, in the Sage library, focus more on algebraic aspects of things. So arbitrary

00:17:03 precision arithmetic, working with very quickly with large integers and rational numbers, doing linear algebra,

00:17:10 where you have no roundoff error, that sort of thing. And for the more numerical parts, the kind of viable

00:17:16 alternative to Matlab, we just incorporate libraries like NumPy, SciPy, et cetera. Yeah.

00:17:22 Which the Python community has done an amazing job of developing over the years.

00:17:25 Right. And that's definitely gaining speed now, right?

00:17:27 Yeah. It's absolutely incredible now. I mean, we wanted all along to be a viable alternative

00:17:32 to Matlab. And I remember in 2006, trying to write statistics, functionality, and all this kind of stuff for Sage directly. And just being like, I don't want to do

00:17:42 this at all, but it's part of what we're trying to do to get more users. So here I am doing it.

00:17:46 And I'm so happy that the community has come along and just made Python absolutely first rate in

00:17:52 statistics and numerical computing so that we can just incorporate that functionality.

00:17:56 Yeah, that's really great. One thing I think before we get too far into the details would be

00:18:00 interesting for the listeners is just the scale of this project, the number of developers, number of

00:18:06 lines of code, the technologies involved. Could you just give them like a quick sense of that?

00:18:10 Sure. So the project itself incorporates about 100 packages. We have done a lot of development at what

00:18:18 we call Sage Days workshops. And those we often have about 10 to 15 per year. We've had, I think,

00:18:27 80 Sage Days workshops so far. They're kind of inspired by the pypy workshops that happened about

00:18:33 a couple of years ago. But basically, we come together for a week and do lots of development.

00:18:39 The number of contributors to Sage is around 500. So those are people who have contributed

00:18:43 directly to the Sage library. Of course, Sage itself incorporates all these other open source

00:18:49 packages, which have their own contributor groups. The amount of source code, I don't know the exact

00:18:55 number, but it's on the order of several hundred thousand lines of actual code. And the code is about

00:19:02 maybe 60% Python and maybe 40% Cython code. So there's a very, very large amount of Cython code that we've

00:19:11 written. And functionality wise, we do cover very wide range of areas of mathematics. So almost anytime

00:19:19 somebody comes to use it, they find that there is something for the area of math that they're interested in.

00:19:25 This episode is brought to you by Hired. Hired is a two sided curated marketplace that connects the

00:19:42 world's knowledge workers to the best opportunities. Each offer you receive has salary and equity presented

00:19:47 right up front, and you can view the offers to accept or reject them before you even talk to the company.

00:19:52 Typically candidates receive five or more offers within the first week and there are no obligations

00:19:57 ever. Sounds awesome, doesn't it? Well, did I mention the signing bonus? Everyone who accepts a job

00:20:02 from Hired gets a thousand dollar signing bonus. And as Talk Python listeners, it gets way sweeter.

00:20:07 Use the link Hired.com slash Talk Python To Me and Hired will double the signing bonus to $2,000.

00:20:12 Opportunities knocking. Visit Hired.com slash Talk Python To Me and answer the call.

00:20:18 That's awesome. That's a really large scale project. And I think it's a cool success story.

00:20:30 So it's written in Python and Cython, which is kind of a flavor of Python. But you also chose Python as

00:20:38 basically the programming language of the system itself, right? Like MATLAB has its .in files with its own

00:20:45 language. Mathematica has their own language. But you sort of said, hey, Python is a good match for

00:20:50 the mathematicians.

00:20:51 Yes. So this is a decision that I made, I would say, purely out of laziness originally. As a CS undergrad,

00:21:00 I had written an interpreter. I took a course in writing interpreters. And I tried to do that again

00:21:07 for some of my number three research. And I also had just seen how hard it is to really develop a

00:21:13 programming language. And I really didn't want to do it. And moreover, the MAGMA group, I had often made

00:21:19 requests for them to improve their language. And they responded that though they could get grant funding

00:21:23 for the mathematical algorithms, they had a huge amount of trouble getting any funding for the actual

00:21:29 language because their funding sources were in mathematics. So I was kind of scared for a number of

00:21:34 reasons off from writing my own language. And basically, I'm like, well, I mean, it just follows

00:21:42 the same principle of reusing third party libraries and computer algebra systems to reuse a third party

00:21:47 language as well. I decided to use Python. It was criticized a lot by math people, because like literally

00:21:54 every other project like Sage that's ever happened up until that point used their made up their own

00:21:59 language was kind of like the thing you had to do. How has that criticism changed over time?

00:22:03 Do they still feel that way? Or has it become more accepted?

00:22:07 Way more accepted. And it's now considered a huge advantage. And often when people when I hear people

00:22:14 convincing other people to switch from Mathematica to Sage, at all levels, both at research and undergrad

00:22:20 teaching, one of the biggest, maybe the strongest arguments is that Python, the language is just a better

00:22:26 language. Because the syntax is easier for the students. And it's it prepares them for other

00:22:32 possible employment opportunities and down the line. So that's pretty interesting. Because when

00:22:38 I was studying math at university, I did study C++ and scheme and other things because I took some

00:22:46 computer science classes. But my math education really taught me just the math,

00:22:52 math lab language, whatever you call that. I'm sure there's a name for it. But you know,

00:22:58 that that's a very limited skill set to take away if I go out into the job market, right? But if people

00:23:05 as part of learning their their math and doing their research, their statistics, whatever, become

00:23:11 semi-proficient in Python, just sort of silently in the background, that's a really cool side effect.

00:23:18 Yeah. And I have had many PhD students who learned Python really, really well as a result of working

00:23:25 with me. And they really do use it in their jobs today. Like one of them, Robert Miller, who wrote a

00:23:32 huge amount of our graph theory functionality, now works as a data scientist at Google. And another one,

00:23:37 Simon Spicer, also works as a data scientist, but at Facebook. And they use Python, both of them use

00:23:42 Python really heavily in their jobs.

00:23:43 That's cool. Do you know if they use SageMath there?

00:23:45 I don't think either of them use SageMath for their jobs. But I do know that SageMath is used

00:23:50 at Google by some people, but not necessarily my students.

00:23:54 Okay, yeah, that's very cool. What would you say to people who are maybe just straight up using

00:23:59 NumPy or Matplotlib today? Maybe they're using an IPython notebook, like, should they consider using

00:24:07 SageMath? And what would it offer them?

00:24:08 It depends on what you're doing. So SageMath does symbolic things, and it can be very efficient at

00:24:14 doing them. Like you have a large matrix, and you want to do something with it, and you want to have

00:24:19 no rounding errors at all. Or you want to do something with linear algebra over finite fields or coding

00:24:25 theory. Basically, Sage provides a lot of functionality that's complementary to the numerical things that are

00:24:31 offered by NumPy and SciPy. It overlaps some with SymPy, S-Y-M-P-Y, though it has a lot of functionality that isn't in

00:24:40 SymPy. And in many cases, it can be a lot faster. So also, another remark is that Sage now uses Jupyter

00:24:48 Notebooks as our default graphical user interface. So when you download and install Sage, you get Jupyter

00:24:53 Notebooks. One big drawback, which I hope to address in the future, is that currently, by far, the easiest way to use

00:25:00 Sage is to install our self-contained distribution. And it's completely separate, really, from PyPy,

00:25:07 the Python packaging repository. And it's not something that you can just install in your own

00:25:13 Python environment. Right. There's no pip install SageMath. Yeah. Not yet. Yeah. I really, really hope

00:25:18 there will be in the future. But right now, that isn't the case. Right. And so that interferes with easy

00:25:24 adoption by existing Python users. That's true. But you do have a pretty decent way of getting it. You can go

00:25:30 like on the Mac, you can go download just a DMG, just a disk image. Or on Linux, you can get a tarball.

00:25:38 And it's kind of all self-contained there. So it's not too hard to get started with, right?

00:25:42 Yeah. A lot of our users just want to do math rather than deal with installation. And so we do put a huge

00:25:49 amount of effort into making it easy to just install. So we have Windows, Linux, and OS X binaries ready to go.

00:25:57 So the Windows one currently is a virtual machine that you run. And then it provides a server. And

00:26:03 then you get a Jupyter notebook that you can use Sage through.

00:26:05 I see. So maybe you run Internet Explorer, but then you're requesting back into like a Linux thing on a

00:26:12 virtual box or something?

00:26:13 Exactly. Yeah. That's how currently, that's our main supported environment in Windows right now.

00:26:17 Okay. Yeah. That's an easier way to get some of those libraries to compile for Windows, right?

00:26:22 Yeah. That is a seriously hard problem to get some of those libraries that were not built for Windows,

00:26:27 the C libraries or Fortran to compile there, right?

00:26:30 It's really, really hard. We've, we tried for years and are still trying to natively port Sage to Windows.

00:26:38 And I don't know if or when it will ever succeed.

00:26:41 Yeah. Yeah. Interesting.

00:26:43 It's like a, I don't know, in the Sage project, there's a lot of these sort of tall mountains that are

00:26:47 very difficult to climb and four or five people will try and fail. And then the sixth person will succeed.

00:26:53 Like writing a really good implementation of working with what are called finite abelian groups was one

00:27:00 thing where it just seemed like one person after the other tried and failed. And then eventually somebody got it.

00:27:05 And I hope porting Sage to Windows will be a similar thing. Some combination of

00:27:09 the right approach and Microsoft Windows getting more friendly to PostSix style programs.

00:27:16 Yeah. Well, you know, did you, I don't know if you heard, you are in Seattle, right? So maybe you heard

00:27:22 that Microsoft in this summer, they're shipping a new version of Windows 10 and it comes

00:27:28 with the ability to run native Linux binaries on the command line.

00:27:33 Yeah. So that's just awesome. And Microsoft is going in the right direction that we should

00:27:38 have something that works natively by maybe using, well, using that. It sounds really likely

00:27:43 actually.

00:27:43 It's, it was, it's gotta be a huge step in the right direction for you guys. So I don't

00:27:48 know if it'd fix it, but it's definitely not a negative.

00:27:50 Yep. Absolutely.

00:27:51 So one thing that's interesting, well, there's, there's a bunch of interesting things I want

00:27:56 to ask you about this. Let's start with this one. So doing math is obviously computational,

00:28:03 right? Computationally intensive and having more computational power is, is key on modern

00:28:10 hardware. That means parallelism, right?

00:28:12 Yep. It can.

00:28:16 How does it leverage, like multi-core machines? Does it support like parallel computational

00:28:21 parallelism and things like that in it?

00:28:23 So one thing that surprises me a lot over the years, at least in pure mathematics, the

00:28:30 sort of parallelism that we have to do is usually what's called embarrassingly parallel sometimes.

00:28:35 So somehow it's a lot easier than what people do in numerical computing with, you know, earthquake

00:28:41 simulation or whatever, where they have some big distributed computation and each step depends

00:28:46 on previous steps and there's lots of data flying all over the place and you have to use MPI or

00:28:51 something to do it. So the parallelization that typically comes up is you want to evaluate some

00:28:58 function F, 10,000 values of N. And so you just do it pretty easily and there's no real

00:29:04 dependencies between them. So basically using fork, just using stuff built around fork, you can do pretty

00:29:11 good parallelization that works pretty well for us as I've found.

00:29:17 Yeah. Okay. So in the embarrassingly parallel case, you just basically split it across processes

00:29:23 or something like that and a problem is solved, right? They've, they got their own guild, but who

00:29:27 cares? Cause it's theirs.

00:29:28 And you also, if you use a database, so you have your, you can have a process startup query a database

00:29:34 for some things that haven't been done, do them and put the results back in. So simple techniques

00:29:40 like that have pretty kept, I don't know, the community pretty happy. Some of our parallelization

00:29:46 issues aren't too ridiculously hard. There are, there are much more subtle, interesting, like low

00:29:51 level parallelization techniques that go into Sage where there's some C library or C++ library,

00:29:58 some Sage developer writes like David Harvey is a guy who wrote some super fast code for

00:30:03 polynomial multiplication and it uses parallelization techniques. And so Sage just kind of, or really Sage

00:30:11 via some, via Python just calls out to this library. The library happens to do things in parallel and

00:30:17 then give back a result. And so there's lots of little places like that where we have libraries

00:30:21 that just implicitly do things in parallel. They're like highly multi-threaded and you don't even know

00:30:26 they're, they're doing it unless you, you know, explicitly look right. So there's that level.

00:30:31 And then there's also the level of other, of forking. I wrote a decorator for Python called

00:30:37 parallel, which is included in Sage. So you put app parallel before a function. And then if you call

00:30:43 it with a list of inputs, it will, it'll fork the process, call the function with each of those inputs

00:30:49 up to the number of processors you have, and then get the results and give them back to you as a generator.

00:30:54 So there's some little things like that that are built into Sage and it takes care of some

00:30:58 possibly tricky surprises that would happen behind the scenes involving sub processes and so on.

00:31:04 That's really awesome. That's a very, Pythonic little statement you made there. I'm going to put a

00:31:09 decorator on it. It's going to, you know, fork this off and return it as a generator. I mean, that's,

00:31:14 that is really great.

00:31:15 Yeah. And it works really well. We have code that like nested functions written in Cython that just

00:31:22 happen to have an app parallel decorator on them and then they'll fork and regroup properly.

00:31:26 And the code itself is just probably two pages of code, maybe three pages. It's not a lot of code.

00:31:31 Yeah. It's just getting the right, concept or the Zen of the style to make it really,

00:31:38 expressive or whatever. Right.

00:31:39 Yep. there's a lot of, there's a ton of pieces of little things like that all over in Sage,

00:31:44 where I would like to separate them out as Python libraries, like individual standalone Python

00:31:50 libraries, and then have Sage pip install them as part of its kind of build process. So that would

00:31:56 make them much more widely available to the community. And then when they're running the context of Sage,

00:32:00 they would know to do the extra things that Sage needs and they wouldn't do those things.

00:32:04 otherwise. We also have a pre-parser. So for mathematicians, just an example, if you type two

00:32:11 slash three in Python two, which is what Sage uses, you get zero, which is floor division in Python three,

00:32:18 you get 0.666666. And neither of those are what pure mathematician expects. Pure mathematician

00:32:24 expects to get two thirds, which is like an exact rational number. So in Sage, we have a little pre-parser.

00:32:31 So when you use Sage directly via its own command line, which is this modified IPython

00:32:35 interactive command line, it will take each line of input and then do a little bit of parsing to it.

00:32:41 for example, when you type two slash three, it replaces it by integer of two slash integer of three.

00:32:47 And then that allows you to make your own custom integer type. And then there's a bunch of other

00:32:51 things similar to that. would like, for example, when you use the carrot symbol, which in Python

00:32:57 means exclusive or a lot of mathematicians are used to that meaning exponentiation because that's what

00:33:02 it means in LaTeX.

00:33:03 Right. Not as opposed to double star or something like this. Yeah.

00:33:06 Yeah. It's really like, so in Sage, when you type the carrot symbol, it gets converted to double star

00:33:11 before it gets sent to Python. So there's, you don't do it. Mathematicians almost never do exclusive

00:33:17 or, but they do exponentiation constantly when typing in polynomials and all kinds of things.

00:33:23 so it's this optional thing that makes the Sage interface more friendly to mathematicians. It gives

00:33:28 us our own kind of new language, but in a very well-defined minimal way, which is just built on top of

00:33:34 Python. And in most cases, the things that get pre-parsed would be invalid Python code. And it would be nice to

00:33:40 connect us with Python packages. It would be nice if we could take this pre-parser and make it a standalone

00:33:45 Python package, which Sage just happens to use. And maybe like we have various interesting functionality in there,

00:33:52 like square brackets, one dot dot 10 gives you the list of numbers from one to 10. It's kind of like the notation you'd have in

00:34:00 MATLAB or Maple instead of using the range function. And there was a Python PEP to implement it, but it didn't get

00:34:06 accepted. But so many Sage people wanted it. Robert Bradshaw just implemented it anyways and added it to the pre-parser.

00:34:13 So it would be kind of neat if this whole pre-parser were made more generally available and then Sage just happened to use it.

00:34:34 Continuous delivery isn't just a buzzword. It's a shift in productivity that will help your whole team become more efficient.

00:34:39 With SnapCI's continuous delivery tool, you can test, debug, and deploy your code quickly and reliably.

00:34:46 Get your product in the hands of your users faster and deploy from just about anywhere at any time.

00:34:51 And did you know that ThoughtWorks literally wrote the book on continuous integration and continuous delivery?

00:34:57 Connect Snap to your GitHub repo and they'll build and run your first pipeline automagically.

00:35:02 Thanks SnapCI for sponsoring this episode by trying them for free at snap.ci slash talkpython.

00:35:17 Maybe it could even have different grammars for different areas.

00:35:21 Like maybe geologists do something different for the mathematicians. Who knows?

00:35:25 Yeah. And so maybe somebody is proposing some great matrix operations to include in Python eventually.

00:35:31 And maybe they get added to Python 3, but they're not in Python 2.

00:35:35 You could use the pre-parser and still have those.

00:35:36 And everything just gets converted to straight Python.

00:35:39 So you could convert everything and then stick it in a Python library if you need to.

00:35:43 That's cool.

00:35:43 You said that in your documentation you say you have a UI kit for adding user interfaces to calculations and the app.

00:35:50 That sounds pretty cool.

00:35:52 What's the UI technology there and how does that work?

00:35:55 Do you remember?

00:35:56 Yeah, I'm not quite sure what that refers to.

00:35:59 Yeah, okay. No worries.

00:36:00 Yeah, sorry.

00:36:01 That was written long ago, right? Okay.

00:36:03 And there's a lot of people.

00:36:04 The other problem is there's 500 contributors.

00:36:06 So I have very limited knowledge.

00:36:10 Sure, no worries.

00:36:10 I'll ask you another sort of math question.

00:36:13 One of the things when you're writing scientific and especially mathematical papers for academics and so on is you use LaTeX.

00:36:22 So you can very precisely express symbolic mathematics like integral signs and things like that.

00:36:30 And this is built right into it, right?

00:36:32 Yeah, so the connection between Sage and LaTeX is, of course, mathematicians all use LaTeX.

00:36:39 So we have a Dunder method.

00:36:41 Well, it's really just a single underscore method, underscore LaTeX underscore, and it's defined on most objects that you create in Sage.

00:36:49 And it gives back the LaTeX representation of that object.

00:36:52 It works a lot like the wrapper method in Python, but it's to give you a LaTeX representation rather than...

00:36:58 Right, right. That's awesome.

00:36:59 Yeah, so we have...

00:36:59 And it kind of recursively goes down the stack.

00:37:02 So if you make a matrix with entries that are rational functions over some other thing, then there's automatically a way to turn that entire matrix into a LaTeX representation.

00:37:12 And that gets used in the graphical user interface fairly automatically if you want, like in Jupyter Notebooks or in Sage worksheets.

00:37:19 Also, we have a LaTeX package called SageTec, which lets you write a LaTeX document and then use commands like backslash Sage right inside the LaTeX document.

00:37:34 So you can write something like consider and then in dollar signs backslash Sage.

00:37:39 And then in braces, you can put some expression and it will get evaluated using Sage whenever you LaTeX the document.

00:37:45 And then the result's cached.

00:37:46 And you can also put blocks of code and the output gets automatically put into your LaTeX document.

00:37:51 So basically it makes it so your LaTeX document can have executable Python code.

00:37:56 But it's really...

00:37:58 I mean, there's a similar thing like this for just Python.

00:38:00 But for Sage, it also gives functionality for graphics.

00:38:04 And it knows that Sage objects can be... have a LaTeX representation and it uses that automatically when typesetting the results.

00:38:12 Yeah, that's really cool.

00:38:13 So it's something that was written at the first Sage days way back in 2006.

00:38:17 Yeah, yeah, really nice.

00:38:18 Long, long ago.

00:38:19 So...

00:38:20 And it's been developed ever since.

00:38:21 So another part of this system that I think is really interesting is Cython.

00:38:27 And Cython actually...

00:38:28 This I had no idea about.

00:38:30 I just want to talk to you about SageMath.

00:38:31 But Cython actually came out of this project, right?

00:38:34 Yes, in the following sense.

00:38:35 So when I started Sage, I mentioned before that Python plus the Python C API was kind of like the killer combination that meant that I could implement what I wanted in Sage on top of Python.

00:38:48 So I had all these little benchmark programs and I would try to implement them in other languages like OCaml, like these really fast functional compiled languages.

00:38:58 And I would get something that was fast, but it wasn't quite as fast as I could write in C.

00:39:01 And if you kind of look, basically overall C lets you write really fast code and Python lets you use C code to write new functions.

00:39:10 But the Python C API is pretty challenging and potentially error prone.

00:39:14 You have to do manual reference counting all over the place.

00:39:16 And the different...

00:39:18 The ways in which the Python C API functions work can take a while to learn.

00:39:22 And I really envisioned a lot of people, including me when I'm tired or just really want to get work done, writing code.

00:39:30 And I wanted to write a huge amount of code.

00:39:31 And I didn't think it was really viable to write directly against the Python C API.

00:39:35 I would mess up some reference counting and get seg faults.

00:39:38 And that just wasn't what I wanted to do.

00:39:40 And so I started planning to write some Python program that would generate code against the Python C API.

00:39:46 And I got excited about the possibility of doing that.

00:39:51 And then I started searching around and found a program called Pyrex, which is like the glassware, P-Y-R-E-X, by Greg Ewing, who is a Python contributor.

00:40:00 And he wrote this amazing program where you could write code.

00:40:05 It looked almost like Python, but it would get converted into C extensions.

00:40:09 And those would get linked into Python.

00:40:12 And so that was really amazing.

00:40:14 But it lacked a lot of functionality.

00:40:16 Like it didn't have list comprehensions.

00:40:18 And there were just a lot of little things.

00:40:21 You couldn't do nested functions.

00:40:23 Also, he didn't use revision control or anything.

00:40:25 And he just kind of made it a zip archive every once in a while.

00:40:29 It seemed like he worked on it mainly during the Christmas break each year or something.

00:40:33 Those were the early days.

00:40:34 A lot ago, right?

00:40:36 So, yeah.

00:40:36 So this was like 2004, 2005.

00:40:39 And it was an absolutely awesome project.

00:40:42 But it kind of wasn't really going anywhere.

00:40:44 And so I started adding functionality I needed to Pyrex.

00:40:49 And that was...

00:40:52 I mean, I don't really like writing compilers very much.

00:40:54 It's not my thing.

00:40:55 I'm not very good at it.

00:40:57 But I had this PhD student, Robert Bradshaw, who I mentioned before, who now works at Google.

00:41:01 And he started diving in and writing a lot of really tricky stuff and doing all these optimizations to Pyrex.

00:41:08 And I thought that was pretty cool.

00:41:10 And then another guy, Stefan Benel, who is the developer of LXML, which is a Python library,

00:41:16 he was forking Pyrex to add all kinds of things as well.

00:41:19 And then at the same time, I made up a project called SageX for making Sage faster.

00:41:25 And it was just a combination of some of these Pyrex forks.

00:41:28 The name was really bad, though.

00:41:30 SageX.

00:41:30 And we were just distributing it inside of Sage.

00:41:33 So that was kind of stupid.

00:41:34 And so after about a year of that, I looked at this book by Fogel called Producing OSS.

00:41:40 It's on his website, producingoss.com.

00:41:43 And I think it's inspired by the Subversion Project.

00:41:46 It's a great book.

00:41:48 And I started...

00:41:49 You know, like when you read a book...

00:41:51 To me, like when I read a book, I kind of as an exercise think about a lot of stuff while I'm reading the book.

00:41:55 And so I started thinking about SageX and Pyrex.

00:41:58 And then I was brainstorming for a name for this thing and kind of thinking,

00:42:04 I should make this into a proper open source project.

00:42:06 And then I came up with this name, Cython, which is like Python, but C.

00:42:11 But I thought it was a better name than SageX, which is hard to say.

00:42:15 And sort of doesn't have anything to do with Python or C.

00:42:18 And so I Googled it.

00:42:19 And there was only one hit, which I could find.

00:42:22 And it was a picture of this punk rocker in England who called himself Cython flipping you off.

00:42:28 And so I thought, I'm safe.

00:42:30 You'll probably not lay claim to this, really.

00:42:34 Exactly.

00:42:35 So I thought, I'm safe.

00:42:36 I can choose this as a name.

00:42:37 And then I wrote to...

00:42:38 Or I talked to my PhD student, Robert, and to Stefan Benel.

00:42:42 And I'm like, so I'm going to start this project and make you the lead developer.

00:42:48 And each of them said no.

00:42:49 And so I was a little worried about that.

00:42:51 So I made them both lead developers and kind of like stepped back from it, made the website, bought the domain name.

00:42:57 And though they both sort of decided not to be the lead developer, they together did an amazing amount of work.

00:43:04 And then other people started contributing.

00:43:06 And I mean, it really has blown up a huge amount since then.

00:43:10 So I did try to push their direction to be, make it so that Cython can compile all of Python.

00:43:17 Like you could take the standard Python test suite and just build it and see how fast it is compared to Python.

00:43:22 And the systems really got deep because part of the test cases for Cython is compile all of Sage, which is huge, and then run the Sage test suite.

00:43:33 And also there are sort of things we need, like when you're running blocking C code, you want to be able to hit control C and have that interrupt the running code.

00:43:40 And so in Sage, we put a lot of work into writing something that would let you interrupt blocking C code that was written using Cython.

00:43:49 Martin Albrecht recently separated that out as a separate project that you can pip install.

00:43:54 So you can use it in your own Cython code.

00:43:56 Right. Okay. That's really cool.

00:43:57 So that's kind of where Cython came from.

00:43:59 And I think it's been steadily progressing over the years.

00:44:03 Very often there are things that come along which kind of sound like they do something similar, but Cython is just so battle-tested.

00:44:10 And no matter what, like if you want to write some fast code that you can use from Python and you're willing to understand the basics of C data types, you can use Cython and do it and get it done.

00:44:22 And if you want to make some code that's usable from C or C++, like a C or C++ library available to Python with no overhead, then you can do that via Cython.

00:44:32 So it's very different than SWIG, Standard Wrapper and Interface Generator, where SWIG will automatically take a C++ library and make it usable from Python.

00:44:41 But there's some Python code between the C++ library and you, and that slows things down a lot.

00:44:48 So with Cython, we do things like make it so you can use a third-party library that provides basic arithmetic addition and multiplication, say, in a finite field.

00:44:57 And we can make that so it's very, very fast.

00:44:59 So it just takes on the order of 100 nanoseconds to do additions and multiplications.

00:45:03 So it really, really eliminates overhead and makes using very, very low-level C code possible.

00:45:08 Yeah, that's really awesome.

00:45:10 How applicable is that in general?

00:45:13 Is this something you would only use on math?

00:45:15 Or if you've got a web service backend and there's a section that needs to go faster, would Cython be something you might consider?

00:45:23 I think it's really, really aimed towards very compute-heavy loads.

00:45:29 So it doesn't help much if your problem is IO-bound.

00:45:33 And then the new Python async stuff is probably way more useful, or something like Twisted.

00:45:39 Yeah, absolutely.

00:45:39 So it's really, really all about compute-heavy, non-asynchronous.

00:45:43 You have a synchronous thing like a for loop where you have a doubly nested for loop that's doing some calculation in the inside.

00:45:50 And you want to make that one part really, really fast, as fast as you could possibly write it in C.

00:45:55 That's what Cython lets you do.

00:45:56 Okay, very cool.

00:45:58 And that's the sort of thing that comes up a lot in math programming.

00:46:01 Yeah, of course it does.

00:46:02 Matrix multiplies and all sorts of things, right?

00:46:05 Yep.

00:46:06 So the sort of next step that you might take this whole project is rather than having people download 800 megs of all those packages and run it locally,

00:46:16 it's just fire up a web browser.

00:46:18 And so you started cloud.sagemath.com, right?

00:46:21 Yes.

00:46:22 Yep.

00:46:22 I started that in 2013.

00:46:25 And my initial motivation was that I had been teaching courses for just repeatedly every year for about a decade to undergraduates on how to use open source math software for kind of math.

00:46:38 So I get like 40 or 50 math or math CS stats econ undergrads.

00:46:44 And the whole course is about how to, you know, program in Python, program in Cython, use lots of functionality from Sage, use NumPy, use LaTeX a little bit.

00:46:53 And the installation challenges for the students were pretty bad.

00:46:57 And so for quite a while, they would use, they would often just use the Sage notebook server we had running, but that could only handle maybe a dozen people at once.

00:47:05 It really wasn't very scalable.

00:47:07 And all it did was give you Sage.

00:47:10 So you could type in Sage code and see the output, but it didn't have a terminal and it didn't have LaTeX.

00:47:15 And so I decided to write something that was much more all-inclusive where you could teach a whole course about anything related to basically open source scientific software and do it all in one unified place where the students in about, you know, 15 seconds are up and running.

00:47:31 So that was the motivation.

00:47:33 And something I've refined over the last few years.

00:47:37 I've taught using it a couple of times now and written some research papers and a book all within Sage Math Cloud.

00:47:43 And there have been several hundred other people who have done courses using it now.

00:47:48 Yeah, that's, that's really great.

00:47:49 I can just imagine the first day of these sort of computational math classes where it's like, all right, so what we're going to do is we're all going to download this.

00:48:00 Like my download canceled.

00:48:02 Mine won't install.

00:48:03 Mine installed, but it won't launch.

00:48:05 You're just like, ah, why?

00:48:06 This is not what this class is about, right?

00:48:09 But you've got to plow through that if it's on the machines, right?

00:48:12 So this, this is really cool.

00:48:13 And, you know, it's a really slick web app that you guys have built.

00:48:16 Thanks.

00:48:17 Yeah.

00:48:18 So I've, I've been working on an enormous amount for the last couple of years with some input from Jonathan Lee and Nicholas Rund, who are two UW undergraduates.

00:48:28 And also Harold Schilley, who's been working on Sage since about 2007 and who lives in Vienna, Austria.

00:48:34 So we've done, we've written this application and it has, I don't know, around about 4,000 users each day.

00:48:45 And it'll often have about 400 active users at once.

00:48:48 So it's a pretty heavily used.

00:48:50 And the usage is heavy because people are really running code.

00:48:54 And they're running lots of Jupyter notebooks and Sage worksheets and editing LaTeX documents and maybe running long-term calculations.

00:49:01 It all runs on top of Google Compute Engine, but it's also entirely top to bottom open source.

00:49:06 And some people download it and install it on their own computers.

00:49:10 Okay.

00:49:10 That's a really interesting component of it that you can get a local server version.

00:49:15 Yep.

00:49:16 And it provides, so what it gives you is real-time collaborative editing of terminals, Jupyter notebooks, LaTeX documents.

00:49:25 It also has a course management system built in for assigning homework to students and collecting it.

00:49:29 And everything's collaborative in that you can see other people editing, kind of like Google Docs.

00:49:34 There's also chats and stuff.

00:49:36 Yeah, that's fantastic.

00:49:37 And you've got a lot of features there.

00:49:39 Like, it's not just for, say, running Python code, but you can run C or Go, or there's the ability to open terminals, just Linux Bash or something like this, right?

00:49:51 Yep, absolutely.

00:49:52 So it's kind of like those online IDEs, but, you know, like cloud9.io or one of those.

00:49:59 But our target audience isn't at all programmers.

00:50:02 It's just people who, especially students who just want to get up and running quickly with open source math-related software.

00:50:09 And we also have really good support for R and Julia and Octave and so on, especially because Jupyter notebooks have kernels for all these languages.

00:50:17 Right.

00:50:18 You just pass it right along to Jupyter and let it deal with it, right?

00:50:21 Yep, exactly.

00:50:22 Nice.

00:50:22 So you've got a lot of cool stuff in your GitHub, which I'll put in the SageMath GitHub, and I'll put a link to that in the show notes.

00:50:31 And one of my stuff on there was stuff to do with Docker.

00:50:34 How does Docker fit into this?

00:50:36 First, there is a SageMath Docker image that Eric Bray, who I think is a guy in Europe, in France, who I think has the distinction of being the first full-time person to work on Sage.

00:50:48 So NSF grants for Sage have kind of dried up recently.

00:50:51 But in Europe, they just got this huge $8 million grant called Open Dream Kit.

00:50:57 It's across the European Union, and it supports open source math software, including Sage.

00:51:02 So the Europeans are really, really supporting open source math software.

00:51:05 And Eric created some really nice Docker images for running Sage.

00:51:09 So you just do like Docker run dash something SageMath, and you're up and running with Sage.

00:51:16 So it's yet another way of installing Sage.

00:51:18 And there's a Jupyter version of it.

00:51:20 So that's one thing.

00:51:21 So SageMath Cloud doesn't currently exactly use Docker.

00:51:26 We use Cgroups and a lot of the stuff that Docker is built on.

00:51:29 But I think it will use Docker extensively in the next few months under the hood.

00:51:35 You won't know the difference, but it will just make things run a little smoother and be more scalable.

00:51:40 Yeah, and let the Docker folks manage that kind of stuff and not you, right?

00:51:44 Yep.

00:51:44 Yeah, exactly.

00:51:45 Yeah, yeah.

00:51:46 Very cool.

00:51:46 All right.

00:51:47 We're getting kind of to the end of the show.

00:51:49 One thing I wanted to recommend for people is if this is all interesting to you guys, go to cloud.sagemath.com.

00:51:56 You can create an account there and check it out.

00:51:58 But there's also a video like right on the landing page there that gives the two-minute story of this.

00:52:04 If you want to share it, that's cool.

00:52:06 And it features you and a bunch of other people in there, which is cool.

00:52:09 And you've got some pretty sweet skating in there.

00:52:13 Yep.

00:52:13 I own the biggest skateboard ramp in the Northwest and I skate it a lot.

00:52:18 So I'm really into skating large half pipes.

00:52:20 Wow.

00:52:20 That's really cool.

00:52:22 Is it?

00:52:22 This is at your house?

00:52:23 It's at a friend of mine's house, thankfully.

00:52:24 It's not at my house.

00:52:26 Nice.

00:52:28 Nice.

00:52:28 That's really cool.

00:52:29 When I was growing up, my brother built a quarter pipe.

00:52:32 So we periodically hurt ourselves.

00:52:35 So I think that was cool.

00:52:36 Yeah.

00:52:36 I got into skateboarding with my brother.

00:52:38 We skateboard together a lot still.

00:52:40 Oh, yeah.

00:52:41 That's great.

00:52:41 That's great.

00:52:41 All right.

00:52:43 So I think it's probably a good time to wrap up our conversation.

00:52:47 So let me ask you two questions I always ask my guests.

00:52:49 First, even though you can't pip install SageMath, there's still a lot of packages that you guys

00:52:56 must use.

00:52:56 And so do you have a favorite PyPI package that is really helpful to you that maybe other

00:53:01 people don't know about?

00:53:02 Well, okay.

00:53:03 Let's see.

00:53:04 First, again, I really wish the answer was SageMath.

00:53:07 I did.

00:53:09 I posted my first ever package to PyPI.

00:53:12 How do you say it?

00:53:13 PyPI.

00:53:14 Guido says that PyPI and some of the core developers say PyPI and PyPI conflicts with PyPI the runtime.

00:53:22 So I'm with PyPI as well.

00:53:25 Okay.

00:53:25 So I posted to PyPI a PyGSL package.

00:53:30 So I'll say that that's a brand new one that wasn't there before.

00:53:32 I did it because a physicist who wanted to use it in their class on SageMath Cloud wanted

00:53:38 this.

00:53:38 GSL is the GNU scientific library, and they wanted these Cython bindings to the GNU scientific

00:53:43 library to be available.

00:53:44 And the only way to do it was to download some zip file off of SourceForge.

00:53:49 And that sucks.

00:53:50 So yeah, anything on SourceForge these days is a little suspect.

00:53:53 So I set up a PyPI account and figured out how to...

00:54:00 I took the zip file, then I pushed it.

00:54:02 So I myself became the kind of manager of the PyGSL package on PyPI.

00:54:08 Yeah, lovely.

00:54:09 It took me about two to three minutes to learn how to do so.

00:54:12 So my answer is that package or push your own package, especially some old thing on SourceForge

00:54:17 that should be pip installable and make it pip installable.

00:54:20 It's easy for anybody to make things pip installable.

00:54:23 Yeah, it's surprisingly easy to register a package and upload it and so on.

00:54:27 It's...

00:54:28 You just more or less create an account and just use the built-in tools and the set of tools

00:54:33 and stuff.

00:54:34 Yeah, it's really nice.

00:54:34 Yeah, absolutely.

00:54:35 Awesome.

00:54:36 And then what editor do you use when you write Python code?

00:54:39 So I dogfood everything.

00:54:42 So I do absolutely all of my development of SageMath Cloud and Sage from within SageMath Cloud.

00:54:49 And the editor of SageMath Cloud is...

00:54:51 It's built on top of Codemirror, which is a web, like a JavaScript-based code editor.

00:54:58 So I added things like multiple panes so you can split the view and see two points in the

00:55:03 document at once.

00:55:04 And also because the editing is synchronized, you can just open multiple browser tabs to

00:55:08 see multiple points in the same document at once.

00:55:11 And then I also have various plugins for the kind of functionality I felt like I really needed,

00:55:16 like deleting, trailing, white space, and so on.

00:55:18 So my answer is Codemirror, which is probably not the most popular answer, but that's my

00:55:23 answer.

00:55:23 Oh, oh, one other thing.

00:55:24 I think that's really cool.

00:55:25 One other thing is in SageMath Cloud, there's a history.

00:55:28 So whenever you edit, every keystroke almost is recorded.

00:55:32 And there's a slider that lets you slide back and forth and see the past, all past versions

00:55:37 of your document.

00:55:37 And so like when I'm editing code, I'll be like, oh, I wanted to look at what it was like

00:55:42 three minutes ago or 10 minutes ago and copy something from that.

00:55:45 And you can very easily do that with a little slider.

00:55:48 So you get kind of a whole third dimension of time when editing.

00:55:51 So it does have some benefits.

00:55:53 Yeah, that's a really nice feature.

00:55:54 I feel like a system has reached some level of maturity and well-roundedness and goodness,

00:56:03 basically, when it can create itself.

00:56:06 You know, when you compile C with a C compiler, when you write like PyPy, you know, you run

00:56:14 Python with Python, these types of things.

00:56:16 It's pretty cool.

00:56:17 So it's nice to hear you're doing that for your editor.

00:56:19 Awesome.

00:56:20 So before we say goodbye, what should people know about getting started with this?

00:56:27 If they want to check it out, what should they do?

00:56:29 So just type Sage or SageMath into Google and you'll get to the SageMath.org website.

00:56:35 And that has all kinds of documentation.

00:56:37 There's like probably 10 to 15,000 pages of documentation there, links to books and so on.

00:56:42 And there's a big link to, which just says SageMath online.

00:56:48 And if you click that, it takes you to the SageMath cloud site that we've been talking about.

00:56:53 And there's also something called SageMath cell, which gives you a single,

00:56:57 one single input box where you can type in a block of Sage code and see output.

00:57:02 And you can also embed those blocks inside of your own static website.

00:57:05 And there's an API for doing that.

00:57:07 So go to the website SageMath.org.

00:57:10 You can either download it or go to the cloud site and use it online.

00:57:14 It's all 100% open source, top to bottom.

00:57:17 William, this is quite an achievement.

00:57:19 I really love looking inside of it because you solved a lot of cool problems and a lot of

00:57:25 excellent technologies come out of it.

00:57:27 So congratulations.

00:57:28 Thank you.

00:57:29 Yeah.

00:57:29 It's been good to talk to you.

00:57:30 Take care.

00:57:31 Okay.

00:57:31 Thanks a lot.

00:57:31 Great talking to you.

00:57:32 Yeah.

00:57:32 Bye.

00:57:34 This has been another episode of Talk Python To Me.

00:57:37 Today's guest was William Stein.

00:57:39 And this episode has been sponsored by Hired and SnapCI.

00:57:41 Thank you guys for supporting the show.

00:57:43 Hired wants to help you find your next big thing.

00:57:46 Visit Hired.com slash Talk Python To Me to get five or more offers with salary and equity

00:57:50 presented right up front.

00:57:52 And a special listener signing bonus of $2,000.

00:57:54 SnapCI is modern, continuous integration and delivery.

00:57:58 Build, test, and deploy your code directly from GitHub.

00:58:01 All in your browser with debugging, Docker, and parallels included.

00:58:04 Try them for free at snap.ci slash Talk Python.

00:58:07 Are you or a colleague trying to learn Python?

00:58:10 Have you tried books and videos that left you bored by just covering topics point by point?

00:58:15 Well, check out my online course, Python Jumpstart by Building 10 Apps at talkpython.fm slash

00:58:20 course to experience a more engaging way to learn Python.

00:58:23 You can find the links from this show at talkpython.fm/episodes slash show slash 59.

00:58:30 Be sure to subscribe to the show.

00:58:32 Open your favorite podcatcher and search for Python.

00:58:34 We should be right at the top.

00:58:36 You can also find the iTunes feed at /itunes, Google Play feed at /play, and

00:58:41 direct RSS feed at /rss on talkpython.fm.

00:58:45 Our theme music is Developers, Developers, Developers by Corey Smith, who goes by Smix.

00:58:50 You can hear the entire song at talkpython.fm/music.

00:58:54 This is your host, Michael Kennedy.

00:58:56 Thanks so much for listening.

00:58:57 I really appreciate it.

00:58:59 Smix, let's get out of here.

00:59:00 I'm dating with my voice.

00:59:03 There's no norm that I can feel within.

00:59:04 Haven't been sleeping.

00:59:06 I've been using lots of rest.

00:59:07 I'll pass the mic back to who rocked it best.

00:59:10 I'm first, developers, developers, developers, developers, developers, developers, developers,

00:59:16 developers, developers, developers, developers, developers, developers, developers, developers,

00:59:22 you

