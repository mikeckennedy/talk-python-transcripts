WEBVTT

00:00:00.001 --> 00:00:03.140
Grab your micro framework and pour some web into your flask.

00:00:03.140 --> 00:00:08.200
It's time for Talk Python to Me, episode number 13 with guest Armin Roenacker.

00:00:08.200 --> 00:00:11.980
Recorded Monday, May 29th, 2015.

00:00:11.980 --> 00:00:40.760
Hello and welcome to Talk Python to Me,

00:00:40.760 --> 00:00:46.280
a weekly podcast on Python, the language, the libraries, the ecosystem, and the personalities.

00:00:46.280 --> 00:00:48.380
This is your host, Michael Kennedy.

00:00:48.380 --> 00:00:55.680
Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes at talkpythontome.com.

00:00:55.680 --> 00:01:02.580
This episode, we'll be talking to Armin Roenacker about Flask, Python, the web, and Rust.

00:01:02.580 --> 00:01:07.380
I'm really fortunate to have CodeChip and Hired sponsoring the show.

00:01:07.380 --> 00:01:09.780
Let me take just a few seconds to tell you about them.

00:01:09.780 --> 00:01:15.440
CodeChip is a platform for continuous integration and continuous delivery as a service.

00:01:15.440 --> 00:01:18.080
They encourage you to always keep shipping.

00:01:18.900 --> 00:01:23.820
Please take a moment and check them out at codeship.com or follow them on Twitter where they're at codeship.

00:01:23.820 --> 00:01:26.800
Hired wants to help you find your dream job.

00:01:26.800 --> 00:01:30.420
Hired is built specifically for developers looking for new opportunities.

00:01:30.420 --> 00:01:35.540
Check them out and get a very special offer at hired.com slash talkpythontome.

00:01:35.740 --> 00:01:39.620
And you'll find them on Twitter where they're at hired underscore HQ.

00:01:39.620 --> 00:01:41.920
Now for a few announcements.

00:01:42.400 --> 00:01:45.260
First, the Talk Python to Me t-shirt is here.

00:01:45.260 --> 00:01:49.780
I talked about the possibility of a Talk Python to Me t-shirt a few shows back.

00:01:49.780 --> 00:01:53.040
Well, there were enough requests to make this a reality.

00:01:53.040 --> 00:01:58.780
And today, I'm happy to tell you that a pretty sweet shirt awaits you at bit.ly slash python shirt.

00:01:59.180 --> 00:02:08.680
It's a Kickstarter project, but because you guys are so awesome, the Kickstarter was funded within three hours of my announcing it on Twitter and before I could even properly announce it on the air.

00:02:09.260 --> 00:02:11.960
So if you visit the Kickstarter, you'll find there's three tiers.

00:02:11.960 --> 00:02:13.400
One is the shirt, of course.

00:02:13.400 --> 00:02:16.920
But there are other options that get you a promotional spot on the show.

00:02:16.920 --> 00:02:21.680
So if you have a product, website, or company you want to get the word out about, here's your chance.

00:02:21.680 --> 00:02:27.280
Also, before we get to the interview, there's a few additional guests that made a cameo appearance in the show.

00:02:27.280 --> 00:02:29.100
I'll let them introduce themselves.

00:02:37.100 --> 00:02:39.820
Seriously, there is a horse and some birds in this episode.

00:02:39.820 --> 00:02:49.880
Didn't mean for that to happen, but with the crazy time zones between Germany and the U.S. West Coast, we recorded this episode somewhat out in nature in the evening for Armin.

00:02:49.880 --> 00:02:51.740
I hope you don't mind the extra guests.

00:02:51.740 --> 00:02:53.640
Now let's get on to a great show.

00:02:53.640 --> 00:02:56.120
Armin, welcome to the show.

00:02:56.120 --> 00:02:56.620
Hello.

00:02:56.620 --> 00:02:58.640
Thank you so much for being on my show.

00:02:58.640 --> 00:03:04.940
I'm a big fan of Flask, and I think it's one of the most used web frameworks out there in the Python space.

00:03:04.940 --> 00:03:07.380
And I'm really excited to talk to you about it today.

00:03:07.380 --> 00:03:08.780
Yeah, sounds good.

00:03:08.780 --> 00:03:10.520
I'm always glad to share.

00:03:10.520 --> 00:03:11.580
Yeah, great.

00:03:11.580 --> 00:03:15.940
And we'll talk a lot about the details of Flask and some of the other projects you're working on.

00:03:15.940 --> 00:03:19.780
But before we get to them, you know, people are always wondering, you know,

00:03:19.780 --> 00:03:24.840
everyone who's really accomplished a lot in their programming career like you have, you know, how did you get started?

00:03:24.840 --> 00:03:26.260
Where do you start programming?

00:03:26.260 --> 00:03:28.400
How do you get inspired to do this kind of stuff?

00:03:28.940 --> 00:03:33.260
I think for me, it didn't really start anywhere.

00:03:33.260 --> 00:03:36.820
It just gradually became more and more.

00:03:36.820 --> 00:03:40.180
So I just had an interest in technology and programming.

00:03:41.660 --> 00:03:47.820
And I just quite early on figured out that they're computers and you can do stuff with them.

00:03:47.820 --> 00:03:49.740
And then it just grew.

00:03:49.740 --> 00:03:53.180
So it's actually very hard for me to figure out where exactly I started in Python.

00:03:53.180 --> 00:04:02.260
It definitely wasn't the first programming language I used, but it was one of the earliest ones I used in a proper way.

00:04:02.260 --> 00:04:02.860
Sure.

00:04:02.860 --> 00:04:04.940
Do you remember what you started with before Python?

00:04:05.840 --> 00:04:08.580
Oh, I know that the first thing I ever used was Quick Basic.

00:04:08.580 --> 00:04:10.160
That's what I found.

00:04:10.160 --> 00:04:15.640
Quick Basic was the one with the line numbers, right?

00:04:15.640 --> 00:04:16.260
Like 10.

00:04:16.260 --> 00:04:17.160
No, no, no.

00:04:17.160 --> 00:04:17.600
It didn't even.

00:04:17.600 --> 00:04:18.180
No, no.

00:04:18.180 --> 00:04:19.920
It had proper structures.

00:04:19.920 --> 00:04:20.540
Did it?

00:04:20.540 --> 00:04:20.740
Okay.

00:04:20.740 --> 00:04:21.820
You have functions and everything.

00:04:21.820 --> 00:04:26.500
Although I did use GoTo, but to go to label and not go to line number.

00:04:26.500 --> 00:04:27.740
It was actually quite good.

00:04:27.740 --> 00:04:28.380
Yeah, yeah.

00:04:28.380 --> 00:04:28.800
That's good.

00:04:28.800 --> 00:04:31.740
And then I found Pascal.

00:04:32.260 --> 00:04:37.780
And there was a version you can run on Windows, which is called Delphi or Delphi.

00:04:37.780 --> 00:04:38.860
And I used that.

00:04:38.860 --> 00:04:40.200
And then I found Python.

00:04:40.200 --> 00:04:42.580
And that just...

00:04:42.580 --> 00:04:44.060
It's not even true.

00:04:44.060 --> 00:04:45.440
I used PHP before.

00:04:45.440 --> 00:04:50.540
That's how I got into web development was that I found Python and PHP sort of at the same time.

00:04:51.560 --> 00:04:54.280
And I tried to make Python more into PHP.

00:04:54.280 --> 00:04:58.380
Because when I started using Python originally, there was...

00:04:58.380 --> 00:05:04.460
So when I started using Python originally for web development, Django didn't exist yet.

00:05:04.460 --> 00:05:07.380
It kind of was starting to...

00:05:07.380 --> 00:05:09.600
So there was a Python talk, a Python talk, I think.

00:05:09.600 --> 00:05:12.680
And then it came out in 2005 or something.

00:05:13.960 --> 00:05:15.240
And I was...

00:05:15.240 --> 00:05:22.160
At the time, I was trying to make just web applications with just CGI and stuff like that.

00:05:22.160 --> 00:05:22.740
Right.

00:05:22.740 --> 00:05:26.380
And then that's how I figured out that WSGI is a thing.

00:05:26.380 --> 00:05:29.200
It was just drafted up as a PEP at that point.

00:05:29.200 --> 00:05:31.940
And then I just got interested in how it works.

00:05:31.940 --> 00:05:35.600
And that's how I ended up doing Python properly, I guess.

00:05:35.600 --> 00:05:36.760
Yeah, that's cool.

00:05:36.760 --> 00:05:39.500
So what do you do today for work?

00:05:39.500 --> 00:05:40.960
That's complicated.

00:05:42.740 --> 00:05:48.660
So for the last three years, I have worked at a gaming company in London.

00:05:48.660 --> 00:05:51.100
And there was a lot of Python, obviously.

00:05:51.100 --> 00:05:53.140
Because we're doing...

00:05:53.140 --> 00:05:55.400
That's what I do professionally, obviously.

00:05:55.400 --> 00:06:00.140
But a lot of the stuff we did there was very game-related.

00:06:00.140 --> 00:06:06.640
So we built server infrastructure for computer games with Python and just general databases.

00:06:06.640 --> 00:06:12.060
But then also quite a lot of stuff on the game side itself.

00:06:12.520 --> 00:06:24.280
So the last project I worked on before the stuff I'm doing currently was helping out with the Halo Master Chief Collection.

00:06:24.280 --> 00:06:26.580
And that was mostly client-side.

00:06:26.580 --> 00:06:28.520
So it was more C++ than Python.

00:06:28.520 --> 00:06:29.220
Yeah.

00:06:29.220 --> 00:06:31.700
On the client-side, when you're doing games, there's a lot of C++.

00:06:31.700 --> 00:06:34.060
Did it have an online component, a web component?

00:06:35.120 --> 00:06:38.160
Yeah, there's lots of web stuff nowadays in these computer games.

00:06:38.160 --> 00:06:40.020
Like, everything is in the cloud.

00:06:40.020 --> 00:06:42.040
So there's lots of HTTP and everything.

00:06:43.540 --> 00:06:52.880
And now, with sort of the beginning of the year, I'm doing both the computer-side thing, computer-game-side thing still.

00:06:52.880 --> 00:06:58.640
But also working on Sentry now, which is an online error-reporting tool.

00:06:58.640 --> 00:07:00.700
Excellent.

00:07:00.700 --> 00:07:01.440
That sounds...

00:07:01.440 --> 00:07:01.580
Yeah.

00:07:01.580 --> 00:07:02.020
Yeah.

00:07:02.180 --> 00:07:03.480
I think you might have seen that.

00:07:03.480 --> 00:07:05.760
It is a Django project.

00:07:05.760 --> 00:07:08.480
And it's quite popular in the Python community.

00:07:08.480 --> 00:07:09.240
Yeah, yeah.

00:07:09.240 --> 00:07:11.300
So that's why I spend some of my time on now.

00:07:11.300 --> 00:07:12.320
Yeah, it's really great.

00:07:12.320 --> 00:07:14.960
We'll put links to those in the show notes.

00:07:15.280 --> 00:07:16.900
Can you say the name of the game that you're working on?

00:07:16.900 --> 00:07:21.300
So the last game I was working on was Halo the Master Chief Collection.

00:07:21.300 --> 00:07:22.980
And I can't say what I'm doing currently.

00:07:22.980 --> 00:07:23.860
Yeah, okay.

00:07:23.860 --> 00:07:24.260
Great.

00:07:24.260 --> 00:07:26.200
Sounds like a lot of fun, though.

00:07:26.200 --> 00:07:31.820
So the thing that I sort of know you for out in the community is Flask.

00:07:31.820 --> 00:07:33.040
What is Flask?

00:07:33.040 --> 00:07:34.380
And how do you get started with that?

00:07:36.000 --> 00:07:44.080
So Flask in itself is the end result of just taking a bunch of stuff that I built before

00:07:44.080 --> 00:07:47.300
and make it into a proper framework.

00:07:47.300 --> 00:07:52.760
So Flask in itself can be used for building sort of any web application you want to do.

00:07:52.760 --> 00:07:56.400
It's sort of the base building block you can put the application on top.

00:07:56.400 --> 00:07:59.420
But Flask is not the...

00:07:59.420 --> 00:08:04.340
When Flask came out originally, it was pretty much empty

00:08:04.340 --> 00:08:08.680
because it's sitting on top of two or more than two.

00:08:08.680 --> 00:08:09.980
I think it's like three base libraries.

00:08:09.980 --> 00:08:14.760
It's Werkzeug, which is a WGRI implementation,

00:08:14.760 --> 00:08:20.040
which does the HTTP handling so that you can get your form data parsed.

00:08:20.040 --> 00:08:22.280
You can get access to your cookies and all that sort of stuff.

00:08:22.280 --> 00:08:25.180
And then Jinja, which is a templating engine,

00:08:25.180 --> 00:08:30.480
which originally started out as an evolution of the Django templating engine.

00:08:31.640 --> 00:08:35.480
And then it's sitting on top of markup safe and it's dangerous.

00:08:35.480 --> 00:08:40.640
These are two libraries which are dealing with security-related things

00:08:40.640 --> 00:08:47.580
just to keep HTML safe and to sign your cookies to keep them safe from tampering with.

00:08:47.580 --> 00:08:50.700
And that's what Flask is.

00:08:50.980 --> 00:08:52.900
So it's basically a combination.

00:08:52.900 --> 00:09:01.280
It configures three base libraries I wrote before into a coherent package you can get started with.

00:09:01.280 --> 00:09:02.460
All right.

00:09:02.460 --> 00:09:03.040
That's really cool.

00:09:03.040 --> 00:09:06.940
What were you using before Flask that kind of inspired you to create this framework?

00:09:06.940 --> 00:09:08.840
Was that Django or something else?

00:09:09.460 --> 00:09:14.160
So I was always using my own libraries, which was Werkzeug, Jinja, It's Dangerous.

00:09:14.160 --> 00:09:15.600
Basically, What's Sitting...

00:09:15.600 --> 00:09:19.120
It's Dangerous came afterwards, but there was an implementation of that before.

00:09:19.120 --> 00:09:24.300
So these were always these libraries which I wrote before, which I was using,

00:09:24.300 --> 00:09:26.040
but they were never really all that popular.

00:09:26.040 --> 00:09:30.600
And then people started doing this one-file micro-frameworks,

00:09:30.600 --> 00:09:33.800
and I started doing an April's full stroke,

00:09:33.800 --> 00:09:36.760
where I basically took all the libraries I had and put them into a zip file,

00:09:36.760 --> 00:09:39.400
Bay64 encoded them into a Python file,

00:09:39.400 --> 00:09:43.480
and then I distributed one Python file, which included all my libraries.

00:09:43.480 --> 00:09:44.240
Oh, nice.

00:09:44.240 --> 00:09:48.100
And I made an April's full stroke with screencast and everything about it.

00:09:48.100 --> 00:09:52.300
And what I learned there is that that actually got really popular,

00:09:52.300 --> 00:09:56.160
and it didn't actually get popular because people realized it was an April's full stroke.

00:09:56.160 --> 00:10:00.060
It got popular because there was a little bit of marketing behind it.

00:10:00.060 --> 00:10:05.920
So I took that sort of lesson and applied it to making a wrapper around my libraries,

00:10:05.920 --> 00:10:10.820
which I called Flask, and I wrote good documentation for it, made a website,

00:10:10.820 --> 00:10:18.960
and I just promoted it a little bit, just at conferences and just shared it with people.

00:10:18.960 --> 00:10:22.940
And that then got a lot more popular than the libraries themselves were.

00:10:22.940 --> 00:10:25.080
So that's how Flask actually happened.

00:10:25.280 --> 00:10:32.020
It was more sort of the first push to try to make it into something that people would actually use,

00:10:32.020 --> 00:10:32.620
and not just me.

00:10:32.620 --> 00:10:34.180
So you have these little separate libraries.

00:10:34.180 --> 00:10:38.300
They were all useful, but it was the putting them together as like a coherent whole

00:10:38.300 --> 00:10:40.640
that kind of made it really interesting in the community.

00:10:40.640 --> 00:10:42.540
Yeah, I think so.

00:10:42.540 --> 00:10:46.380
I mean, there's still probably more people that use the base libraries than actually use Flask,

00:10:46.380 --> 00:10:50.960
but Flask is the one thing that you can easily find now.

00:10:51.680 --> 00:10:52.320
Yeah, for sure.

00:10:52.320 --> 00:10:53.520
And it's very popular.

00:10:53.520 --> 00:10:57.540
You know, on GitHub, you've got over 14,000 stars, over 4,000 forks.

00:10:57.540 --> 00:10:59.120
You must be pretty proud of it.

00:10:59.120 --> 00:11:02.120
Yeah, it's pretty cool that it took off this way.

00:11:02.120 --> 00:11:03.040
Yeah.

00:11:03.040 --> 00:11:03.900
Nice.

00:11:03.900 --> 00:11:05.220
When did you release it originally?

00:11:05.220 --> 00:11:07.760
Ah, I don't know anymore.

00:11:07.760 --> 00:11:12.860
I know that it was a couple of, I think it might have been like two or three months.

00:11:12.860 --> 00:11:16.960
No, even probably less than a month even after it was full stroke.

00:11:17.100 --> 00:11:20.500
That was probably, I don't know, six years ago now?

00:11:20.500 --> 00:11:21.280
Yeah.

00:11:21.280 --> 00:11:22.260
I can't remember.

00:11:22.260 --> 00:11:23.720
It would actually be interesting.

00:11:23.720 --> 00:11:26.880
Oh, it's not even one pounder.

00:11:26.880 --> 00:11:29.540
Yeah, you've got to celebrate his birthday or something like that, right?

00:11:29.540 --> 00:11:35.220
Yeah, I'm not that attached to actually celebrating things.

00:11:35.220 --> 00:11:36.180
Sure.

00:11:36.180 --> 00:11:38.100
So one thing that...

00:11:38.100 --> 00:11:38.740
2010.

00:11:38.740 --> 00:11:40.140
So that sounds at all.

00:11:40.140 --> 00:11:40.960
Yeah, okay.

00:11:40.960 --> 00:11:42.520
So it's five years.

00:11:42.520 --> 00:11:43.520
Almost five years.

00:11:43.520 --> 00:11:44.480
Exactly, right?

00:11:44.480 --> 00:11:45.800
Because it's a...

00:11:45.800 --> 00:11:47.760
Yeah, made it for 12.

00:11:47.760 --> 00:11:48.300
Yeah.

00:11:48.300 --> 00:11:49.380
Great.

00:11:49.380 --> 00:11:51.020
Okay, so perfect.

00:11:51.020 --> 00:11:51.460
Five years.

00:11:51.460 --> 00:11:51.460
Five years.

00:12:05.160 --> 00:12:10.780
CodeChip is a hosted, continuous delivery service focused on speed, security, and customizability.

00:12:10.780 --> 00:12:16.600
You can set up continuous integration in a matter of seconds and automatically deploy when your tests have passed.

00:12:16.600 --> 00:12:19.840
CodeChip supports your GitHub and Bitbucket projects.

00:12:19.840 --> 00:12:22.620
You can get started with CodeChip's free plan today.

00:12:22.620 --> 00:12:31.100
Should you decide to go with a premium plan, Talk Python listeners can save 20% off any plan for the next three months by using the code TALKPython.

00:12:31.100 --> 00:12:32.840
All caps, no spaces.

00:12:33.440 --> 00:12:40.180
Check them out at CodeChip.com and tell them thanks for sponsoring the show on Twitter where they're at CodeChip.

00:12:40.180 --> 00:12:52.740
One thing I thought would be interesting for people, even though it's a little hard to do, is maybe just describe a little bit of the type of code that you have to write.

00:12:52.740 --> 00:12:57.220
I suspect many people out there have written Flask apps, but also many of them haven't.

00:12:57.220 --> 00:12:58.460
So, like, how do I get started?

00:12:59.080 --> 00:13:05.900
So, I guess the easiest way to get started with it is to download it from pip, which is what most people use now.

00:13:05.900 --> 00:13:15.740
Set up a virtual env, get pip, install Flask in there, and then you can probably even just go to the front page of Flask and copy-paste the Hello World example.

00:13:15.740 --> 00:13:19.700
And that's probably good enough to get going, which is really not that much.

00:13:19.700 --> 00:13:20.680
It's like four lines of code.

00:13:20.820 --> 00:13:28.420
So, it's quite straightforward, and it comes, like most Python frameworks, with a local development server and pretty much all the stuff you need.

00:13:28.640 --> 00:13:37.480
You basically create an instance of the Flask class, you give it a name, and you call run on it, and you map some routes to some methods and things like that, right?

00:13:37.480 --> 00:13:38.380
Yeah.

00:13:38.520 --> 00:13:49.220
So, I think one of the things I wanted to do with Flask was to show people what's a better idea to structure an application compared to how you do it in Django, for instance.

00:13:49.220 --> 00:13:55.000
Because if you have used Django, Django has this huge config problem.

00:13:55.000 --> 00:13:59.080
Where they have this module, it's called Django Conf Settings.

00:13:59.380 --> 00:14:10.080
And it's one global object which holds all your configuration, which basically means that in one Python process, you can only run one application, because they would touch each other's config settings.

00:14:10.080 --> 00:14:17.180
So, with Flask, I wanted to show that you can do it differently as well, where in Flask, you have to create an instance of Flask.

00:14:17.180 --> 00:14:21.180
And you can create multiple instances, and they can be living entirely separate of each other.

00:14:22.540 --> 00:14:28.040
So, that's why you have to create this Flask object, because you configure that Flask object.

00:14:28.040 --> 00:14:32.320
And it's actually really nice, the effect to get out of this.

00:14:32.320 --> 00:14:35.420
I mean, Flask is obviously not the first framework that does that.

00:14:35.420 --> 00:14:37.780
I mean, that's a general really good pattern for development.

00:14:37.780 --> 00:14:44.800
But I think it was definitely one of the frameworks that popularized this idea of creating an application object,

00:14:45.320 --> 00:14:55.620
and then configuring that application object instead of just changing some configuration, which is entirely detached from what you're doing somewhere else in the Python process.

00:14:55.620 --> 00:14:58.980
Yeah, I really like that way that you're doing that as well.

00:14:58.980 --> 00:15:01.640
And does it help with testing and things like that?

00:15:01.640 --> 00:15:02.880
Yeah, definitely.

00:15:02.880 --> 00:15:06.280
Especially the test for Flask itself.

00:15:06.520 --> 00:15:15.860
I mean, they create like 500 different individual Flask applications and test them, which is a lot nicer to work with than trying to do test separation on Django,

00:15:15.860 --> 00:15:23.200
where you're never quite sure if the last test run actually reset everything to the state you thought it should be.

00:15:23.200 --> 00:15:29.400
So, it's very nice that you can actually create those applications and guarantee that they will be separate of each other.

00:15:29.400 --> 00:15:29.900
Sure.

00:15:29.900 --> 00:15:36.160
So, you just don't know if there's some sort of order dependency in your Django test, because it's really the same one, right?

00:15:36.420 --> 00:15:36.600
Mm-hmm.

00:15:36.600 --> 00:15:38.160
Okay, that's really cool.

00:15:38.160 --> 00:15:39.620
You've been talking about Django.

00:15:39.620 --> 00:15:46.340
There's some other web frameworks that come to mind as well, like Pyramid is probably the other major one that comes to mind for me.

00:15:46.340 --> 00:15:50.300
Can you sort of compare and contrast what it's like working in those different environments?

00:15:50.300 --> 00:15:54.600
Like, what is special about Flask over, say, Django or Pyramid?

00:15:54.600 --> 00:15:56.480
I don't know.

00:15:56.480 --> 00:15:59.480
It's very hard for me to say now, because I have been using...

00:16:00.000 --> 00:16:13.560
Like, originally, when I started doing Flask, or even before that, when I just wrote the base libraries, there was a really, like, an almost war going on between the different frameworks and the popularity between them.

00:16:13.780 --> 00:16:20.280
And a lot of that had to do with that Whiskey as a standard was not very well established at that point.

00:16:20.280 --> 00:16:27.240
For instance, a lot of developers deployed the Django applications with ModPython.

00:16:27.240 --> 00:16:37.120
And even if they did use ModWhiskey to deploy them or just any other WSGI server, there was no real way to interact with Whiskey in Django.

00:16:37.120 --> 00:16:39.300
So you couldn't add any Whiskey middlewares.

00:16:39.300 --> 00:16:40.080
There was...

00:16:40.080 --> 00:16:45.420
Basically, people wrote their libraries very, very specific to frameworks.

00:16:45.420 --> 00:16:55.820
Flask Stephanie was a framework that did it differently, because it promoted the idea of you actually write library against no framework at all.

00:16:55.820 --> 00:17:01.780
You just try to write your library in a way that makes it work in an isolated way.

00:17:01.780 --> 00:17:09.920
And then later on, you make an extension, and then you bind your library as conveniently as possible for the framework you want to use it with.

00:17:09.920 --> 00:17:11.780
And I think that is...

00:17:11.780 --> 00:17:22.720
Flask was probably not the first one which did it, but I think that is a much better situation to be in now, because many libraries do not require to be in the context of a specific framework.

00:17:23.100 --> 00:17:33.320
So at this point, I think it's very irrelevant which framework you actually use, because you can use pretty much all the functionality in the Python ecosystem in any of those frameworks.

00:17:33.320 --> 00:17:45.260
There might be small differences in how it works, but it's definitely very different than how it was in 2007 or 2008, when some functionality only existed within Django, for instance.

00:17:45.260 --> 00:17:48.660
Or you had to use TurboGear or something of that sort.

00:17:48.660 --> 00:17:51.220
So I think that is different now.

00:17:51.220 --> 00:18:03.600
And at this point, the framework is such a small part of your overall development experience that whatever floats your boat, I guess, is a good way to get started.

00:18:03.600 --> 00:18:09.920
And then after some period of time, you probably will end up modifying the framework you're using anyways.

00:18:10.520 --> 00:18:11.220
So, yeah.

00:18:11.220 --> 00:18:15.820
I don't know if that answers the question about comparing those frameworks.

00:18:15.820 --> 00:18:17.980
No, but it's an interesting answer for sure.

00:18:17.980 --> 00:18:19.620
I think it does somewhat answer it.

00:18:19.620 --> 00:18:27.660
But, I mean, it's interesting to say that for the most part, it's not as front and center as it used to be.

00:18:28.020 --> 00:18:29.740
Yeah, I don't think it's front and center at all.

00:18:29.740 --> 00:18:35.520
Especially both Flask and Pyramid have the same general idea of...

00:18:35.520 --> 00:18:36.600
I mean, Pyramid is very different.

00:18:36.600 --> 00:18:42.420
But both of those systems have the idea that it's sort of a layered cake.

00:18:42.420 --> 00:18:44.480
And at the very bottom, you have Whiskey.

00:18:44.480 --> 00:18:50.380
And then one layer above that, you have a base implementation of Whiskey, which in case of Flask is Werkzeug.

00:18:50.380 --> 00:18:52.440
And in case of Pyramid is WebOp.

00:18:53.520 --> 00:19:01.000
And you can sort of reach through and then slice away every single layer you don't want to use and dig a little bit deeper.

00:19:01.000 --> 00:19:07.060
Django doesn't do it just as much because of its long history of re-implementing everything for itself.

00:19:07.060 --> 00:19:16.920
But even if you can't use a certain functionality in Django, you can still go and use Flask together with Django if you would need to do that.

00:19:17.920 --> 00:19:25.980
And so in that sense, I think it's a lot less important now to pick a framework as it is or as it was before.

00:19:25.980 --> 00:19:27.360
Right. Okay, cool.

00:19:27.360 --> 00:19:31.080
So you said you created this in 2010.

00:19:31.080 --> 00:19:37.680
The way people write web apps today is fairly different than the way it was in 2010 and certainly before then.

00:19:37.680 --> 00:19:39.820
What's your thoughts on that?

00:19:40.220 --> 00:19:40.780
Yeah.

00:19:40.780 --> 00:19:48.140
So I think that Flask doesn't actually do a really good way in staying on top of things in that sense.

00:19:48.140 --> 00:19:56.120
So obviously, now there's a lot more JavaScript, for instance, in web development.

00:19:56.120 --> 00:20:00.980
And the idea of rendering something on the server is now almost like a holy war.

00:20:00.980 --> 00:20:01.880
Like, should you do it?

00:20:01.880 --> 00:20:04.260
Should you make React everything?

00:20:04.260 --> 00:20:05.080
Should you use Angular?

00:20:05.260 --> 00:20:05.640
I don't know.

00:20:05.640 --> 00:20:15.340
So especially in that environment, there is so much change happening currently that I'm sort of on the side a little bit of just seeing what happens.

00:20:15.340 --> 00:20:25.680
I made two terrible technology choices in the last three years by trying to use Angular, which then turned out to just not make sense in the way I was using it.

00:20:25.680 --> 00:20:28.620
Or maybe not even in the sense how Angular 1 was implemented.

00:20:30.440 --> 00:20:32.440
And then I don't even know what the other thing was.

00:20:32.440 --> 00:20:33.980
Maybe it was Backbone.

00:20:33.980 --> 00:20:34.660
I can't remember.

00:20:34.660 --> 00:20:47.500
But basically, the JavaScript world is moving so very fast in trying to change the whole infrastructure that right now it's actually really hard to make a good decision in regards to how you should build it.

00:20:47.500 --> 00:21:01.740
It's actually very good to be a little bit more conservative and try to pick something which hasn't been, is not entirely the latest thing that's happening because you just run at risk of that thing changing so quickly while you need to use it.

00:21:01.740 --> 00:21:12.420
But I do think that there's a, so generally, like, the way I use my own software at my work is very different than how most people use Flask.

00:21:13.120 --> 00:21:28.780
Because, for instance, at Fireteam, which is the London-based gaming company I work for, we basically build infrastructure by, when we have front-end UIs, they sit on top of an API server, which then talks to a remote API server.

00:21:28.780 --> 00:21:32.800
So it's a very layered situation you have there.

00:21:32.800 --> 00:21:39.500
And that is getting more and more common, that you basically build services out of plugging individual APIs together.

00:21:39.500 --> 00:21:43.440
I wouldn't necessarily call it service-oriented architecture, but it does kind of go that way.

00:21:43.440 --> 00:21:47.600
And that is definitely getting more popular.

00:21:47.600 --> 00:21:55.700
And I think that is probably an area where Flask will develop into the moment it becomes clear that this is something that makes sense.

00:21:55.700 --> 00:21:57.940
But you can already do that today.

00:21:57.940 --> 00:22:11.700
There's so much stuff that you can plug into Flask that will support you in writing APIs and then putting front-end UIs on top of that, instead of actually going and just delivering HTML to the client directly.

00:22:11.700 --> 00:22:21.720
Yeah, I think one of the things that really impresses me about Flask is all the stuff that people are layering on top of Flask to write really cool applications.

00:22:22.600 --> 00:22:31.520
Yeah, I think it's a good thing that Flask itself, it did grow in size, but it's still very, very small and tiny.

00:22:31.520 --> 00:22:36.360
And there's a lot more that actually exists in the ecosystem that doesn't exist in Flask itself.

00:22:36.360 --> 00:22:37.480
Right.

00:22:37.480 --> 00:22:41.920
One of the ones I was thinking of is this thing called Eve by a guy named Nicola Hiroshi.

00:22:41.920 --> 00:22:43.940
He was one of our first guests, actually.

00:22:44.200 --> 00:22:49.740
And that's like a REST API on top of Mongo and SQLAlchemy and so on that has Flask as the base.

00:22:49.740 --> 00:22:58.040
What else is out there like that that I can add in and maybe create a RESTful system or whatever else that you've seen that's pretty cool?

00:23:08.040 --> 00:23:10.860
This episode is brought to you by Hired.

00:23:10.860 --> 00:23:17.320
Hired is a two-sided, curated marketplace that connects the world's knowledge workers to the best opportunities.

00:23:17.320 --> 00:23:26.480
Each offer you receive has salary and equity presented right up front and you can view the offers to accept or reject them before you even talk to the company.

00:23:26.480 --> 00:23:32.840
Typically, candidates receive five or more offers in just the first week and there are no obligations ever.

00:23:32.840 --> 00:23:34.940
Sounds pretty awesome, doesn't it?

00:23:34.940 --> 00:23:37.000
Well, did I mention there's a signing bonus?

00:23:37.320 --> 00:23:41.120
Everyone who accepts a job from Hired gets a $2,000 signing bonus.

00:23:41.120 --> 00:23:45.420
And as Talk Python listeners, it gets way sweeter.

00:23:45.420 --> 00:23:52.980
Use the link Hired.com slash Talk Python To Me and Hired will double the signing bonus to $4,000.

00:23:52.980 --> 00:23:54.700
Opportunity's knocking.

00:23:54.700 --> 00:23:58.320
Visit Hired.com slash Talk Python To Me and answer the call.

00:24:06.600 --> 00:24:10.500
So the thing is, I'm not using Flask extension myself much.

00:24:10.500 --> 00:24:11.740
I don't know.

00:24:11.740 --> 00:24:16.140
I like the idea of having as much control as possible over what I'm doing.

00:24:16.140 --> 00:24:21.140
And unless I'm not using it, I'm not using it.

00:24:21.140 --> 00:24:23.080
I'm probably not necessarily going to use it.

00:24:23.080 --> 00:24:30.760
So I use a ton of the database integrations like Flask and Quarkomy, obviously, because I'm a friend of Postgres.

00:24:30.760 --> 00:24:32.660
So that's sort of my database of choice.

00:24:32.660 --> 00:24:40.020
So these little extensions that just make it very easy to connect to a database, I use them pretty much all.

00:24:40.740 --> 00:24:54.820
There is the Flask security, which gets you quite far in just setting up an authentication layer and getting the most problematic security problems out of your way.

00:24:54.820 --> 00:24:56.720
What else am I using?

00:24:56.880 --> 00:25:00.240
I'm using Flask WTF just because it's good enough.

00:25:00.240 --> 00:25:09.840
It's maybe not the best extension in the world, but if you do have a simple problem where you do want to run down the server and you want to do form handling, that's a pretty good way to do it.

00:25:11.000 --> 00:25:18.440
And there are a lot of extensions for building APIs, of which I am not going to name any of them because you can easily find them.

00:25:18.440 --> 00:25:25.200
I don't want to give one of them more the head of sort of an advantage over the others, which is name dropping them.

00:25:25.200 --> 00:25:29.520
Because I honestly have no idea which one of them is the one to pick.

00:25:29.520 --> 00:25:30.080
Right.

00:25:30.080 --> 00:25:30.560
Of course.

00:25:30.560 --> 00:25:38.620
When I go and I create one of these views, I basically take a method and I put a cool attribute on it like app.route.

00:25:38.620 --> 00:25:39.180
Is that it right?

00:25:39.180 --> 00:25:40.160
If I'm recalling correctly.

00:25:40.420 --> 00:25:40.540
Yeah.

00:25:40.540 --> 00:25:41.020
Yeah.

00:25:41.020 --> 00:25:42.500
I say app.route is the decorator.

00:25:42.500 --> 00:25:47.980
Then that just automatically chooses the URL template that I'm going to use, right?

00:25:47.980 --> 00:25:49.260
That's going to map to that method.

00:25:49.260 --> 00:25:52.000
Is there a way to do that with classes in a more general way?

00:25:52.000 --> 00:25:58.000
So I can say like map this sort of base URL to this class and then pick off the methods.

00:25:58.000 --> 00:25:58.540
Yeah.

00:25:58.540 --> 00:26:00.520
There's lots of stuff you can do that.

00:26:00.520 --> 00:26:05.160
I'm not a huge fan of using classes for that sort of stuff.

00:26:05.740 --> 00:26:15.520
So there's this class-based view thing where you can invoke different methods depending on what HTTP method, for instance, gets passed in.

00:26:15.760 --> 00:26:20.840
That's a thing that's a little bit more interesting than actually routing directly to methods based on a URL.

00:26:20.840 --> 00:26:26.640
I had not so good experience in the past with accidentally doing something you don't want to do.

00:26:27.360 --> 00:26:30.300
But I do think there are some packages that do that.

00:26:30.300 --> 00:26:45.260
But I think when it comes to this routing recursively into a class or a method in a class, there are probably systems out there for which this sort of routing behavior is a little bit more natural than it is for Flask.

00:26:45.660 --> 00:26:49.040
Flask has a very different philosophy for the URL mapping.

00:26:49.040 --> 00:27:02.520
The philosophy that originally went into the Vectsug URL system, what it's based on, is that a resource should be uniquely identified by the URL it maps to.

00:27:02.520 --> 00:27:04.500
Which you can actually see very...

00:27:04.500 --> 00:27:09.400
You can see this quite far in how the routing system behaves.

00:27:09.400 --> 00:27:20.780
For instance, if you go to a URL and the URL is declared with a slash in the end and you don't go to the URL with the slash, it will redirect before it even goes to matching to have the slash there.

00:27:20.780 --> 00:27:25.540
So it will enforce that the URL is unique if there are ambiguities.

00:27:26.960 --> 00:27:42.600
Even if you build a pagination system and you have slash, I don't know, slash wiki as the base part, and then you have slash wiki slash page slash one, that page slash one will redirect to slash wiki.

00:27:42.600 --> 00:27:49.060
So the routing system is based on the idea that everything has to be... there's only one URL for the resource.

00:27:49.060 --> 00:27:50.360
I really like that philosophy.

00:27:50.360 --> 00:27:51.280
That sounds great.

00:27:51.280 --> 00:27:53.700
I didn't realize it would actually disambiguate it for you.

00:27:53.700 --> 00:27:54.120
That's cool.

00:27:54.640 --> 00:28:01.860
Yeah, and that's why it's very hard to do generic URL routing with it where you have like, oh, and now I go to like a method.

00:28:01.860 --> 00:28:05.120
Because very often those systems, they have to be a little bit fuzzy.

00:28:05.120 --> 00:28:10.320
And the vector routing system is not entirely... like it's based on not being fuzzy, basically.

00:28:10.320 --> 00:28:14.540
So that part... that's why they are a little bit in a conflict with each other.

00:28:14.540 --> 00:28:19.000
But if you would want to build something like this on top of it, you could probably do it.

00:28:19.000 --> 00:28:23.540
But I would probably recommend looking more into Pyramid for that sort of thing.

00:28:23.540 --> 00:28:24.100
Sure.

00:28:24.380 --> 00:28:27.760
Because they have this sort of recursive routing system.

00:28:27.760 --> 00:28:28.660
Yeah, that makes sense.

00:28:28.660 --> 00:28:29.420
Okay, cool.

00:28:29.420 --> 00:28:35.820
So the last show that we just released on Tuesday, a couple days ago, was with Docker.

00:28:35.820 --> 00:28:38.240
Are you doing anything with Docker?

00:28:38.240 --> 00:28:41.940
Does Flask have any sort of special place with Docker?

00:28:41.940 --> 00:28:43.940
What's your thoughts there on how those go together?

00:28:43.940 --> 00:28:45.140
I love Docker.

00:28:45.140 --> 00:28:47.260
I think it's a cool thing.

00:28:47.600 --> 00:28:51.980
I don't like Docker in itself as much as I like the idea of containers.

00:28:51.980 --> 00:28:55.260
I think that's just an amazing thing.

00:28:55.260 --> 00:29:01.140
And it kind of shocks me that they haven't been more popular before because the concept is not entirely new.

00:29:02.620 --> 00:29:05.920
So it's great that that's taking off.

00:29:06.000 --> 00:29:07.240
And I don't know.

00:29:07.240 --> 00:29:13.460
I think this kind of sort of way of deploying applications this way is definitely going to be much more popular in the future.

00:29:14.600 --> 00:29:18.740
I think for Docker deployments, it's not really a framework problem.

00:29:18.740 --> 00:29:22.520
For Docker deployments, there's many other things that need solving.

00:29:22.520 --> 00:29:24.340
Like, where do I get my configuration?

00:29:24.340 --> 00:29:26.400
How do I make different services talk to each other?

00:29:26.400 --> 00:29:27.240
Right.

00:29:27.300 --> 00:29:28.860
How does this container talk to that container?

00:29:28.860 --> 00:29:29.700
Yeah.

00:29:29.700 --> 00:29:37.640
I don't know what the word for that is, but you have a lot of coordination between these different systems.

00:29:37.640 --> 00:29:40.800
And I think Flask will never gain that.

00:29:40.800 --> 00:29:44.400
That's just entirely out of its area.

00:29:44.400 --> 00:29:50.320
But maybe there will be systems that will support that in a way.

00:29:50.320 --> 00:29:51.000
Yeah.

00:29:51.000 --> 00:29:55.760
I definitely see Flask being more of one of the bricks that you use to build up that system.

00:29:55.760 --> 00:29:58.420
and not really involved in the connecting part.

00:29:58.420 --> 00:29:59.500
Yeah.

00:29:59.500 --> 00:30:02.100
I think this container part is going to be huge.

00:30:02.100 --> 00:30:08.300
But also, we are definitely going to build our applications fundamentally different when that becomes bigger.

00:30:08.300 --> 00:30:11.940
Many companies already do that anyways.

00:30:11.940 --> 00:30:15.300
It will just take some time until it trickles into the open source community.

00:30:15.300 --> 00:30:23.820
And we will start to pick up the ideas and lessons learned and build it into reusable systems.

00:30:23.820 --> 00:30:24.520
Absolutely.

00:30:24.520 --> 00:30:28.740
I think the whole deployment story in five years is going to look really different than it does today.

00:30:28.740 --> 00:30:29.960
Yeah, definitely.

00:30:29.960 --> 00:30:30.500
Yeah.

00:30:30.500 --> 00:30:31.220
Very cool.

00:30:31.220 --> 00:30:34.140
HTTP2 is coming along.

00:30:34.140 --> 00:30:36.240
What's the story of HTTP2 and Python?

00:30:36.240 --> 00:30:38.160
That's a good question.

00:30:38.160 --> 00:30:41.520
Like, you could theoretically use HTTP2 with Python.

00:30:41.520 --> 00:30:42.680
It would be perfectly fine.

00:30:43.480 --> 00:30:46.460
But you don't gain any of the benefits you have from that.

00:30:46.460 --> 00:30:53.300
And in order to actually use HTTP2 with Python or with an application efficiently,

00:30:53.300 --> 00:31:00.200
I think we will all have to actually sit down together as a community again and figure out how to extend the Whiskey protocol.

00:31:00.740 --> 00:31:02.340
So there are two ways we can go.

00:31:02.340 --> 00:31:18.780
Either one of them is nobody cares about WSGI anymore as a protocol and it's useless and it will just slowly die and we will bypass it and just figure out how to make frameworks talk directly HTTP, which might happen.

00:31:19.140 --> 00:31:27.280
HTTP2 as a protocol is complicated, but it's a little bit more lightweight in a way than HTTP is maybe.

00:31:28.360 --> 00:31:29.160
It's tricky.

00:31:29.160 --> 00:31:33.760
But basically the point is, Whiskey could die and we no longer care about it.

00:31:33.760 --> 00:31:38.740
Or we will have to evolve Whiskey to support what HTTP2 supports.

00:31:38.740 --> 00:31:50.020
Because one of the big features that you have as HTTP2 is that the server can decide to already deliver some content into the client's buffer before the client has to actually ask for it.

00:31:50.020 --> 00:31:58.780
So you could send your current page plus all the images plus all the statuses plus all the JavaScript in one go with the client having to do individual requests.

00:31:58.780 --> 00:32:04.480
And we don't have a good support for any of that stuff in Python so far.

00:32:04.480 --> 00:32:06.480
Right, exactly.

00:32:06.480 --> 00:32:09.240
Because those are going to different routes and it's basically coming in.

00:32:09.240 --> 00:32:11.980
Yeah, you have to restructure your application for that.

00:32:11.980 --> 00:32:16.900
It's very hard to just pretend that you don't have to have an understanding of that.

00:32:16.900 --> 00:32:23.540
You as an application writer have to inform the server about related resources.

00:32:23.540 --> 00:32:26.520
And there is no good way to magically do that.

00:32:26.520 --> 00:32:29.620
I mean, it could probably work, but yeah, we don't have that.

00:32:29.620 --> 00:32:33.600
And we might have to architect our applications a little bit different for that.

00:32:33.600 --> 00:32:42.220
There's a lot of promise there to reducing the number of actual server requests to load a page from something like 15 to 2 or something like that.

00:32:42.220 --> 00:32:42.940
That would be really nice.

00:32:42.940 --> 00:32:44.920
And we've got to make it possible, right?

00:32:44.920 --> 00:32:46.160
Okay, so very interesting.

00:32:46.160 --> 00:32:49.580
What's the future of Flask?

00:32:49.580 --> 00:32:53.420
Where are you putting your energy into when you're working on it now?

00:32:53.420 --> 00:32:59.720
I'm barely working on any of my open source libraries in the last two years, to be honest.

00:32:59.720 --> 00:33:02.900
I make sure that they release.

00:33:02.900 --> 00:33:06.960
I make sure that patches get merged at least to some degree.

00:33:07.300 --> 00:33:11.060
But there are many more people than me now which take care of those things.

00:33:11.060 --> 00:33:17.120
Yeah, looking on GitHub right now, you've got 268 registered contributors to Flask.

00:33:17.120 --> 00:33:19.280
So it's almost a management job, huh?

00:33:19.280 --> 00:33:24.060
Yeah, it becomes different than it was originally.

00:33:24.760 --> 00:33:30.440
For me, personally, what's in the future of Flask for me is that it becomes more stable.

00:33:30.440 --> 00:33:32.320
I don't want it to change too much.

00:33:33.500 --> 00:33:36.340
I learned this lesson in a way with Jinja.

00:33:36.340 --> 00:33:42.880
Jinja is a tablet engine which hasn't changed functionality-wise in a really long time.

00:33:42.880 --> 00:33:48.260
And I know there are flaws in there, and I know there are things I would do different nowadays.

00:33:48.960 --> 00:33:54.600
But I don't want to break anyone's stuff to fix some problems that I made.

00:33:54.600 --> 00:34:00.020
Because usually, it's not that you can fix a problem and it will make everyone's life easier.

00:34:00.020 --> 00:34:06.680
Usually, if you make a design this mistake, you have to change it in a way where you break people's stuff.

00:34:06.680 --> 00:34:09.860
And that makes nobody happy, especially if the problems are not big enough.

00:34:09.860 --> 00:34:16.940
Flask will not evolve in such big ways as Django as a framework is evolving.

00:34:17.060 --> 00:34:22.740
I think it's more likely that if I discover that I will no longer like developing this Flask,

00:34:22.740 --> 00:34:29.580
there will be a separate project which will solve the problem in a different way and become that.

00:34:29.580 --> 00:34:32.420
Flask doesn't really have to evolve in itself.

00:34:32.420 --> 00:34:37.320
I think it's not the worst spot right now.

00:34:37.320 --> 00:34:38.420
It needs new releases.

00:34:38.420 --> 00:34:40.540
It needs updates.

00:34:40.540 --> 00:34:44.020
But I don't think it has to fundamentally change to stay relevant.

00:34:44.220 --> 00:34:44.660
Sure.

00:34:44.660 --> 00:34:53.240
I think that that's probably partly attributable to the fact that you kept it small and didn't try to make everybody build on your APIs, but kind of pass through.

00:34:53.240 --> 00:34:55.740
Yeah, I think keeping it small is a good thing.

00:34:55.740 --> 00:34:59.220
I'm struggling right now to keep another library of mine small, which is Click.

00:34:59.220 --> 00:35:00.360
Yeah.

00:35:00.360 --> 00:35:02.280
Well, Click's cool.

00:35:02.280 --> 00:35:03.620
Can you tell people what Click is?

00:35:03.620 --> 00:35:09.260
Click is basically a micro framework for making commands and applications.

00:35:10.440 --> 00:35:12.700
It's based on similar ideas as Flask in a way.

00:35:12.700 --> 00:35:13.980
It's very composable.

00:35:13.980 --> 00:35:21.020
You make a Click application and you can attach another Click application to another Click application.

00:35:21.020 --> 00:35:28.780
You can basically build your whole whatever you used, art parse or opt parse or whatever else you had before for little command line scripts.

00:35:29.200 --> 00:35:35.080
You can use Click for that and then you can just scale them up to larger applications over time.

00:35:35.080 --> 00:35:41.720
So it's very often in the past I used to do this little script which just did one job and it was really terrible.

00:35:42.200 --> 00:35:53.020
And then if I wanted to make it nicer by adding a command line interface, I really hated the experience of adding yet another arc parse invocation for this.

00:35:53.020 --> 00:36:00.800
Or even things like DocOpt suffer a little bit from the same thing where it's just too much work to deal with the argument parsing properly.

00:36:01.840 --> 00:36:03.420
So this is where Click comes in handy.

00:36:03.420 --> 00:36:10.720
You basically make a Click application, attach a function to it and describe the parameters that go in.

00:36:10.720 --> 00:36:12.420
And then you have a little script.

00:36:12.420 --> 00:36:21.020
And then if you want to merge multiple of those scripts together, similar to how systems like Django Manage have like 20,000 subcommands.

00:36:21.020 --> 00:36:26.080
You could take all of those scripts and then merge them together into a larger application.

00:36:26.080 --> 00:36:28.020
And they will still continue working as they did before.

00:36:28.020 --> 00:36:31.020
It's a very composable way to build command line interfaces.

00:36:31.160 --> 00:36:32.080
That's really amazing.

00:36:32.080 --> 00:36:36.320
So it sounds like they'd be easier to maintain because they're not this great giant thing in the end.

00:36:36.320 --> 00:36:38.640
They're like little parts that are focused on one task.

00:36:38.640 --> 00:36:39.940
Yeah.

00:36:39.940 --> 00:36:43.660
And I think it's a lot more fun to keep them that way.

00:36:43.660 --> 00:36:47.560
What's the story with Python 3 and Flask?

00:36:47.560 --> 00:36:50.200
I don't know.

00:36:50.200 --> 00:36:54.040
The thing is, it runs on Python 3.

00:36:54.040 --> 00:36:56.040
That's as far as my support for it goes.

00:36:56.040 --> 00:36:58.480
I will try to keep it working on Python 3.

00:36:58.480 --> 00:37:00.460
I'm not using Python 3 myself.

00:37:00.480 --> 00:37:03.000
So that's basically it.

00:37:03.000 --> 00:37:06.540
If people would start using Python 3, then I will move over there as well.

00:37:06.540 --> 00:37:08.940
But since nobody else is moving, I am not really moving.

00:37:08.940 --> 00:37:12.220
It's a very pragmatic approach.

00:37:12.220 --> 00:37:20.900
But I have more important things to do than try to force people to go to some version of the language.

00:37:20.900 --> 00:37:21.280
Sure.

00:37:21.780 --> 00:37:23.640
Basically, that's what it boils down to.

00:37:23.640 --> 00:37:31.220
There are plenty of comments of mine on the interwebs in regards to the state of Python 3.

00:37:31.220 --> 00:37:34.520
There is really not much else to add to that.

00:37:34.520 --> 00:37:35.440
Sure.

00:37:35.840 --> 00:37:37.820
And I don't necessarily want to make the whole show about that.

00:37:37.820 --> 00:37:38.880
So that's all good.

00:37:38.880 --> 00:37:41.080
But what do you think the future of Python is?

00:37:41.080 --> 00:37:43.100
Like where are things going more broadly?

00:37:43.100 --> 00:37:44.600
I don't know.

00:37:45.860 --> 00:37:50.120
So there's always like what's the future of a programming language?

00:37:50.120 --> 00:37:51.920
And then what's the future of what I will be doing?

00:37:51.920 --> 00:37:54.860
I don't know what the future of Python is as a programming language.

00:37:54.860 --> 00:37:57.840
That it will do something.

00:37:59.980 --> 00:38:11.860
For me personally, the sort of development I've been doing more and more in the last couple of years makes me feel like I probably want to start picking up other technologies as well.

00:38:11.860 --> 00:38:16.260
I started writing a lot more JavaScript, even though I don't like the experience.

00:38:16.260 --> 00:38:18.400
I started writing a ton of Rust.

00:38:18.400 --> 00:38:22.060
I picked up a little bit of Golang just for fun.

00:38:22.060 --> 00:38:25.040
And then I'm starting to write a lot more C and C++ as well.

00:38:25.920 --> 00:38:32.480
So by share of how much time I spend on one programming language, Python is still above 50%, but it's dropping.

00:38:32.480 --> 00:38:37.840
And that is probably for me personally that I will start to look at other things as well.

00:38:37.840 --> 00:38:42.720
Python will always be there for the things I have been doing with it in the past.

00:38:42.720 --> 00:38:44.980
But I might just be doing different things in the future.

00:38:44.980 --> 00:38:46.700
Yeah, that makes sense.

00:38:46.700 --> 00:38:52.940
I think if you look at the types of technologies that have been used and what's popular and what's not and so on.

00:38:52.940 --> 00:38:58.920
And in the last couple of years, there have been so many, maybe the last five years, so many new technologies.

00:38:58.920 --> 00:39:04.620
It used to be like, well, are you a C++ or a Java or a .NET or Python guy?

00:39:04.620 --> 00:39:06.260
And there was like a few choices, right?

00:39:06.260 --> 00:39:10.820
And now it's a hundred types of frameworks in JavaScript.

00:39:10.820 --> 00:39:12.800
And there's so many variations.

00:39:13.800 --> 00:39:21.060
I think there's one thing that's happening, which is that people used to associate programmers with a programming language really strongly.

00:39:21.060 --> 00:39:27.560
And now if you look at some of those people that used to be associated with one programming language, they're actually doing different things.

00:39:27.560 --> 00:39:34.900
Like, for instance, a good example is the packaging infrastructure in the Rust programming language is written by Ruby people.

00:39:35.700 --> 00:39:46.920
And not just any Ruby people, but the ones who wrote Bundler, which is one of, if not the most popular way to do, to basically work with gems in Ruby.

00:39:47.520 --> 00:39:53.820
So you have this sort of situation where people just jump from community to community.

00:39:53.820 --> 00:40:01.340
Ian Bicking, who was the heart and soul of web development and Python, moved over and started doing JavaScript.

00:40:02.200 --> 00:40:09.480
So it's, and then you have people from JavaScript who moved to Python or who moved to even C# or something.

00:40:09.480 --> 00:40:13.220
So it's not that people stay very strong in one community.

00:40:13.220 --> 00:40:18.320
They don't leave it, but they might just also start using other technologies.

00:40:18.320 --> 00:40:20.520
And I think that's more common now.

00:40:20.520 --> 00:40:22.680
Yeah, and I think it's probably healthy, right?

00:40:22.680 --> 00:40:24.680
You get exposed to a lot more that way.

00:40:24.680 --> 00:40:25.240
Cool.

00:40:25.240 --> 00:40:29.840
Before we move off Flask, what are the notable deployments Flask like?

00:40:29.920 --> 00:40:32.880
Do you know popular websites running it or things like this?

00:40:32.880 --> 00:40:34.220
I don't know.

00:40:34.220 --> 00:40:37.740
I used to keep this powered by Flask page running.

00:40:37.740 --> 00:40:44.180
But fundamentally, one problem you have with Flask is people will start using it at one point.

00:40:44.180 --> 00:40:53.260
And then if you look at the same website after one and a half years, it has either disappeared because the website was of a startup was not a good business idea or something.

00:40:53.260 --> 00:40:56.940
Or it would grow and become larger.

00:40:56.940 --> 00:41:01.920
And then all of a sudden, it will outgrow what it had and might change technology.

00:41:01.920 --> 00:41:03.280
So I don't know.

00:41:03.280 --> 00:41:06.760
I don't keep track of what currently runs Flask or not.

00:41:06.760 --> 00:41:09.020
I know that Discuss was using it heavily.

00:41:09.020 --> 00:41:12.640
I think they still are, but I think they're using some Go.

00:41:13.600 --> 00:41:20.600
Yeah, so it's very hard to say what website is based on what technology at this point, especially for a framework.

00:41:20.600 --> 00:41:25.620
Because it's a small part in the overall execution of the whole thing.

00:41:25.620 --> 00:41:28.800
So I don't know what currently runs on Flask.

00:41:28.800 --> 00:41:30.940
I know there are plenty of websites which do use it.

00:41:31.340 --> 00:41:34.820
Yeah, if you have 14,000 stars on GitHub, there's definitely a lot of people using it.

00:41:34.820 --> 00:41:36.860
So it's just not clear what they are, right?

00:41:36.860 --> 00:41:39.100
They're dark matter websites.

00:41:39.100 --> 00:41:41.120
Nice.

00:41:41.120 --> 00:41:44.060
So one of the other things that you brought up was Rust.

00:41:44.060 --> 00:41:46.700
Is that a language that Mozilla came up with?

00:41:46.700 --> 00:41:52.880
It's not Mozilla came up with, but Mozilla started supporting the development heavily.

00:41:53.320 --> 00:41:53.640
Okay.

00:41:53.640 --> 00:41:55.140
So what is Rust?

00:41:55.140 --> 00:41:56.980
Rust is definitely not Python.

00:41:56.980 --> 00:41:58.660
It's a completely different language.

00:41:58.660 --> 00:42:01.500
It's more C++ than it is Python.

00:42:01.500 --> 00:42:06.000
It's a really weird language in what it tries to do.

00:42:06.000 --> 00:42:15.200
And I find it interesting because it's the first time that someone came up with a really crazy idea of how to build something.

00:42:15.200 --> 00:42:23.960
And it actually turned out practical enough that it might start sort of a new way of thinking of how to do programming.

00:42:23.960 --> 00:42:24.980
That's really awesome.

00:42:24.980 --> 00:42:27.140
It's a system-level language, right?

00:42:27.140 --> 00:42:29.160
It's basically a system-level language.

00:42:29.160 --> 00:42:38.900
By system-level language, it means a language that gives you low-level access to the operating system, nearly as C or C++ do.

00:42:38.900 --> 00:42:41.260
Or the same way C and C++ do.

00:42:41.260 --> 00:42:44.320
But unlike C and C++, Rust doesn't crash on you.

00:42:44.580 --> 00:42:48.000
It doesn't feel like you have to juggle with pointers or anything of that sort.

00:42:48.000 --> 00:42:55.280
It feels very much like you're programming in something very high-level, like Python or C#.

00:42:55.280 --> 00:42:58.320
Something that is very friendly to you as a developer.

00:42:58.320 --> 00:43:02.920
But it has manual memory management in the sense that there is no garbage collector.

00:43:02.920 --> 00:43:04.120
There is no reference counting.

00:43:04.120 --> 00:43:07.540
It achieves this...

00:43:07.540 --> 00:43:09.160
I would say this...

00:43:09.160 --> 00:43:10.360
I don't know what it achieves.

00:43:10.360 --> 00:43:13.180
Basically, it achieves the way of development.

00:43:13.960 --> 00:43:15.220
It is very high-level.

00:43:15.220 --> 00:43:25.020
But also, at the same time, very close to the hardware by tracking who owns what piece of memory at what point in time.

00:43:25.260 --> 00:43:29.840
And it's a very interesting way to develop because it makes you think a little bit more about what you're doing.

00:43:29.840 --> 00:43:33.760
And it also rules out a ton of problems in the process.

00:43:33.760 --> 00:43:42.020
It makes you a better developer just because it tells you to rethink things that you could otherwise do in programming languages, which were a terrible idea.

00:43:42.680 --> 00:43:53.940
I had an example a couple of days ago where I was showing how threading issues in Python are something that can just happen.

00:43:54.480 --> 00:43:59.500
Or they will naturally happen because there's nothing in the language that prevents you from doing something really stupid.

00:43:59.500 --> 00:44:04.980
Like not mutex locking some important piece of code.

00:44:05.860 --> 00:44:13.000
And Rust is different because this concept of memory ownership helps really greatly when you build anything concurrent.

00:44:13.000 --> 00:44:16.820
So it's a very interesting language for that reason.

00:44:17.080 --> 00:44:21.500
I find it exciting because there's never been anything like this before.

00:44:21.500 --> 00:44:27.900
There were languages like Java, Go, which have garbage collector and achieve safety this way.

00:44:27.900 --> 00:44:34.520
And there have been languages like C and Z++, which have been very fast, but also very frustrating if you did something wrong.

00:44:34.520 --> 00:44:37.660
And just generally not very fun to work with.

00:44:37.660 --> 00:44:40.600
And Rust just is very different in that sense.

00:44:41.080 --> 00:44:41.720
That's really cool.

00:44:41.720 --> 00:44:44.240
It sounds inspiring like I should check it out.

00:44:44.240 --> 00:44:46.320
What kind of things do I build with Rust?

00:44:46.320 --> 00:44:50.760
Well, the thing is, Rust just came out 1.0 finally a couple of days ago.

00:44:50.760 --> 00:44:57.600
So at the moment, you probably can build less stuff with this than with many other languages just because it's very new.

00:44:57.600 --> 00:45:01.720
But there's already a handful of stuff you can build really well with Rust.

00:45:01.720 --> 00:45:10.620
If you're in the computer games, there's a ton of really good libraries that you can use to build your own game engines and just your own games.

00:45:10.760 --> 00:45:21.420
It has excellent support for doing basic game mathematics operations, talking to your graphics card, getting input from joysticks and game pads and just keyboard and mouse.

00:45:21.420 --> 00:45:23.700
So that's a very strong area.

00:45:23.700 --> 00:45:27.660
And that's just natural to the language because that's why it's very strong.

00:45:27.660 --> 00:45:32.120
But it also already has really good support for doing web applications.

00:45:32.120 --> 00:45:36.320
The database drivers, you can talk to Redis, you can talk, I think, to MongoDB.

00:45:36.320 --> 00:45:39.920
There's a couple of web frameworks for it.

00:45:40.440 --> 00:45:46.240
They all feel very different than frameworks do in Python just because it's more rigid.

00:45:46.240 --> 00:45:55.160
But if you're into writing JavaScript applications with a backend API, you can do that quite well in Rust already.

00:45:55.160 --> 00:46:00.260
In fact, what the Python package index for Rust is, it's called crates.io.

00:46:00.260 --> 00:46:03.200
That is entirely written in Rust itself.

00:46:03.200 --> 00:46:04.600
And you can get the source code.

00:46:05.020 --> 00:46:07.740
You said crates, like C-R-A-T-E-S?

00:46:07.740 --> 00:46:08.920
Okay, cool.

00:46:08.920 --> 00:46:11.280
How many packages are there?

00:46:11.280 --> 00:46:14.120
3,000, I think.

00:46:14.120 --> 00:46:14.920
I don't know, actually.

00:46:14.920 --> 00:46:17.040
Yeah, we got 2,200 already.

00:46:17.040 --> 00:46:18.320
So it sounds like it's growing fast.

00:46:18.320 --> 00:46:18.780
That's awesome.

00:46:20.060 --> 00:46:21.060
Yeah, it's doing really well.

00:46:21.060 --> 00:46:22.280
So it doesn't have 3,000 yet.

00:46:22.280 --> 00:46:23.460
But it is growing.

00:46:23.460 --> 00:46:25.860
And it has...

00:46:25.860 --> 00:46:36.200
Because it is a new programming language, many of the problems that we still fight with in the Python community in getting our infrastructure improved, Rust never had as a problem.

00:46:36.200 --> 00:46:41.000
Like, for instance, the packaging in Rust is really good.

00:46:41.780 --> 00:46:47.760
It is a perfect package manager that comes with the system, which makes development a ton of fun.

00:46:47.760 --> 00:46:51.980
It's similar to how the JavaScript community had NPM quite early on.

00:46:51.980 --> 00:46:55.960
We have with the combination of pip and VirtualLine and everything.

00:46:55.960 --> 00:47:02.140
But for those systems, it just already becomes as a base package, basically.

00:47:02.140 --> 00:47:05.780
It's really cool that basically that came out with it as it...

00:47:05.780 --> 00:47:08.500
You know, from day one, that was there, right?

00:47:08.500 --> 00:47:08.960
That's nice.

00:47:08.960 --> 00:47:09.640
Yeah.

00:47:10.040 --> 00:47:11.380
So Cargo came...

00:47:11.380 --> 00:47:18.140
Well, it wasn't day one, because if you consider Rust is already a couple of years old by now because it had a long development path.

00:47:18.140 --> 00:47:24.880
But Rust 1.0, so the official release, comes with package manager and linters and documentation tool and everything.

00:47:24.880 --> 00:47:26.240
Yeah, really nice.

00:47:26.240 --> 00:47:28.060
Okay, so I'm definitely going to check out Rust.

00:47:28.060 --> 00:47:28.700
That sounds neat.

00:47:28.700 --> 00:47:33.980
Armin, I think that might be a good place to wrap up the show.

00:47:33.980 --> 00:47:37.440
Before we finish, though, I'd like to ask you a question I always ask my guests,

00:47:38.300 --> 00:47:41.080
which is, what's your favorite PyPI package?

00:47:41.080 --> 00:47:45.380
Or what are some notable ones that you would like to call people's attention to?

00:47:45.380 --> 00:47:46.300
Like, say, hey, this is awesome.

00:47:46.300 --> 00:47:46.780
Check it out.

00:47:46.780 --> 00:47:49.100
Oh, that's hard.

00:47:49.100 --> 00:47:51.520
Well, I can't name any of my own ones, obviously.

00:47:51.520 --> 00:47:52.760
I'll name them for you.

00:47:52.760 --> 00:47:54.640
So Flask, Click, and...

00:47:54.640 --> 00:47:56.800
It's probably SQLAlchemy.

00:47:56.800 --> 00:47:58.240
It's my favorite package.

00:47:58.240 --> 00:48:00.080
It ends up almost everywhere.

00:48:00.460 --> 00:48:01.860
And it's just really good.

00:48:01.860 --> 00:48:03.860
So that will have to be it.

00:48:03.860 --> 00:48:06.160
Yeah, SQLAlchemy really is amazing.

00:48:06.160 --> 00:48:08.540
And we had Mike on for show five, I think.

00:48:08.540 --> 00:48:09.880
Yeah, SQLAlchemy is amazing.

00:48:09.880 --> 00:48:10.480
Cool.

00:48:10.480 --> 00:48:13.220
And what editor are you using these days for your Python stuff?

00:48:13.220 --> 00:48:14.780
I'm still using Vim.

00:48:14.780 --> 00:48:17.180
I'm trying to migrate over to a new Vim.

00:48:17.180 --> 00:48:19.340
So that might happen soon.

00:48:19.340 --> 00:48:20.780
But so far, it's Vim.

00:48:20.780 --> 00:48:21.680
All right.

00:48:21.680 --> 00:48:22.060
Awesome.

00:48:22.060 --> 00:48:24.700
Armin, thank you for being on the show.

00:48:24.700 --> 00:48:25.600
It's been a great conversation.

00:48:26.320 --> 00:48:26.680
You're welcome.

00:48:26.680 --> 00:48:27.300
It was fun.

00:48:27.300 --> 00:48:28.560
Yeah.

00:48:28.560 --> 00:48:29.440
See you later.

00:48:29.440 --> 00:48:34.020
This has been another episode of Talk Python to Me.

00:48:34.020 --> 00:48:36.000
Today's guest was Armin Roenaker.

00:48:36.000 --> 00:48:40.160
And this episode has been sponsored by CodeChip and Hired.

00:48:40.160 --> 00:48:42.220
Thank you guys for supporting the show.

00:48:42.220 --> 00:48:45.040
Check out CodeChip at CodeChip.com

00:48:45.040 --> 00:48:47.200
and thank them on Twitter via at CodeChip.

00:48:47.200 --> 00:48:49.300
Don't forget the discount code for listeners.

00:48:49.300 --> 00:48:50.000
It's easy.

00:48:50.000 --> 00:48:52.540
Talk Python, all caps, no spaces.

00:48:52.540 --> 00:48:55.740
Hired wants to help you find your next big thing.

00:48:56.260 --> 00:48:58.900
Visit Hired.com slash Talk Python To Me

00:48:58.900 --> 00:49:02.840
to get five or more offers with salary and equity right up front

00:49:02.840 --> 00:49:06.880
and a special listener signing bonus of $4,000.

00:49:06.880 --> 00:49:12.900
Also, don't forget, an awesome t-shirt awaits you at bit.ly slash PythonShirt

00:49:12.900 --> 00:49:16.780
or just visit our website and click on shirt in the footer.

00:49:16.780 --> 00:49:20.680
You can find the links of the show at Talk Python To Me.com

00:49:20.680 --> 00:49:23.600
slash episodes slash show slash 13.

00:49:24.480 --> 00:49:26.340
Be sure to subscribe to the show.

00:49:26.340 --> 00:49:28.740
Open your favorite podcatcher and search for Python.

00:49:28.740 --> 00:49:29.980
We should be right at the top.

00:49:29.980 --> 00:49:34.460
You can also find the iTunes and direct RSS feeds in the footer of the website.

00:49:34.460 --> 00:49:36.340
This is your host, Michael Kennedy.

00:49:36.340 --> 00:49:37.480
Thanks for listening.

00:49:37.480 --> 00:49:39.860
Smix, take us out of here.

00:49:40.400 --> 00:49:41.560
Staying with my voice.

00:49:41.560 --> 00:49:41.560
Staying with my voice.

00:49:41.560 --> 00:49:43.340
There's no norm that I can feel within.

00:49:43.340 --> 00:49:44.560
Haven't been sleeping.

00:49:44.560 --> 00:49:46.180
I've been using lots of rest.

00:49:46.180 --> 00:49:49.040
I'll pass the mic back to who rocked it best.

00:49:49.040 --> 00:50:01.240
I'll pass the mic.

