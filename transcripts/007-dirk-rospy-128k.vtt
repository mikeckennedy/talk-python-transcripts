WEBVTT

00:00:00.001 --> 00:00:08.840
Talk Python To Me, episode number seven, with guest Dirk Thomas, recorded Monday, April 27th, 2015.

00:00:08.840 --> 00:00:38.820
Hello and welcome to Talk Python To Me, a weekly podcast on Python.

00:00:38.820 --> 00:00:42.680
The language, the libraries, the ecosystem, and the personalities.

00:00:42.680 --> 00:00:44.880
This is your host, Michael Kennedy.

00:00:44.880 --> 00:00:52.980
Follow me on Twitter where I'm @mkennedy and keep up with the show and listen to past episodes at talkpythontome.com.

00:00:52.980 --> 00:00:59.480
This episode, we'll be talking to Dirk Thomas about the robot operating system ROS and ROSPi.

00:00:59.480 --> 00:01:03.160
Before we get to Dirk, I have a couple of news items.

00:01:03.160 --> 00:01:06.360
Top of the queue is a huge show announcement.

00:01:06.360 --> 00:01:09.640
We have our first long-term sponsor of the show.

00:01:09.640 --> 00:01:14.660
I'm happy to tell you that Codeship is now the premier sponsor of Talk Python.

00:01:14.660 --> 00:01:20.860
Codeship is a platform for powerful continuous integration and continuous delivery as a service.

00:01:20.860 --> 00:01:26.360
I'll talk more about them later in the show, but please take a moment and check them out at codeship.com

00:01:26.940 --> 00:01:31.980
or follow them on Twitter where they're at codeship, C-O-D-E-S-H-I-P.

00:01:31.980 --> 00:01:36.420
And if you love this podcast, please send Codeship a message to say thank you.

00:01:36.420 --> 00:01:38.340
Jump on Twitter and say something like,

00:01:38.340 --> 00:01:42.300
Thank you, at Codeship, for sponsoring the Talk Python podcast.

00:01:42.300 --> 00:01:43.240
You rock!

00:01:43.240 --> 00:01:44.760
Or however you want to say it.

00:01:45.640 --> 00:01:47.160
Next up, timestamps.

00:01:47.160 --> 00:01:53.860
Several listeners have asked for something like an outline with timestamps so they can go back into the show and look up topics.

00:01:53.860 --> 00:01:56.880
It's a great idea, but I'm taking that to the next level.

00:01:56.880 --> 00:02:03.620
I intend to have full-text, searchable transcripts for the shows, which of course include timestamps.

00:02:03.980 --> 00:02:08.280
Only a couple of shows have transcripts so far, and I'm adding them as fast as I can.

00:02:08.280 --> 00:02:13.940
Check out episode number four on Enterprise Python or episode number five on SQLAlchemy

00:02:13.940 --> 00:02:17.640
and click the full transcript button to the right to see what I'm talking about.

00:02:17.640 --> 00:02:19.140
I think you'll find it really useful.

00:02:19.140 --> 00:02:23.660
Special thanks to Mark Weimer for recommending a show on RossPi.

00:02:23.660 --> 00:02:29.100
We probably wouldn't have this show that you're listening to right now without you, Mark, so thanks a bunch.

00:02:29.100 --> 00:02:31.640
There are comments everywhere.

00:02:32.080 --> 00:02:35.020
I've added a comment section to every show on our site.

00:02:35.020 --> 00:02:39.720
So now, in addition to using @talkpython on Twitter or just emailing us,

00:02:39.720 --> 00:02:44.420
you can send us feedback via the Discus comment area at the bottom of each show,

00:02:44.420 --> 00:02:46.900
and I've already received some great comments that way.

00:02:46.900 --> 00:02:53.460
Finally, I have created a Twitter list aggregating all the tweets from all the guests who have been on our show.

00:02:53.460 --> 00:03:00.460
Visit Talk Python on Twitter, choose the View Lists option, and subscribe to the show underscore guest list.

00:03:00.460 --> 00:03:06.620
There you'll find the Twitter stream from all the guests who have been on the show, and of course, that list will be growing over time.

00:03:06.620 --> 00:03:09.420
You can also find the link to the list on our homepage.

00:03:09.420 --> 00:03:11.000
Wow, what a week.

00:03:11.000 --> 00:03:13.520
Now, let's get on to the interview with Dirk Thomas.

00:03:15.320 --> 00:03:16.100
Hello, Dirk.

00:03:16.100 --> 00:03:16.980
Welcome to the show.

00:03:16.980 --> 00:03:18.440
Thank you for having me.

00:03:18.440 --> 00:03:21.080
Yeah, I'm really excited to have you as a guest.

00:03:21.080 --> 00:03:27.820
We've had some what I would consider mainstream developer topics so far, and we have more coming up.

00:03:27.820 --> 00:03:31.000
Of course, they're mainstream, so we'll probably have a lot of them throughout the show.

00:03:31.060 --> 00:03:35.460
But I'm thinking of things like web frameworks, data access libraries, Pyramid.

00:03:35.460 --> 00:03:37.260
We're going to do a show on Flask.

00:03:37.260 --> 00:03:41.520
A show on SQLAlchemy is coming out pretty soon.

00:03:41.520 --> 00:03:44.860
And what we're going to talk about today is a little bit different.

00:03:44.860 --> 00:03:50.720
It's a little more edgy, and I think it's something that so many people that go into software development,

00:03:51.260 --> 00:03:55.300
maybe it's the reason they got into software, and then they got drug over to the financial section

00:03:55.300 --> 00:04:00.660
where they're building reports out of databases or something like that, which is robotics.

00:04:00.660 --> 00:04:08.100
Yeah, that's a very great project because robotics in general is, I think, more interesting than classic software engineering

00:04:08.100 --> 00:04:12.240
because it's just much more hands-on, and you have real results which you can try

00:04:12.240 --> 00:04:14.860
instead of the big business projects.

00:04:14.860 --> 00:04:15.360
Absolutely.

00:04:15.660 --> 00:04:22.980
And I think one of the things that is sort of representative of that is I do a lot of work with schools and training.

00:04:22.980 --> 00:04:29.120
I do professional training for real developers, but I also help my kids' schools out with after-school projects and stuff,

00:04:29.120 --> 00:04:32.000
and they very rarely want to write a financial trading system.

00:04:32.000 --> 00:04:33.640
They're more like, how do we build a robot?

00:04:33.640 --> 00:04:34.660
How do we build a game?

00:04:34.660 --> 00:04:40.120
And so you're really involved with this thing called ROS, the Robotic Operating System,

00:04:40.120 --> 00:04:41.980
and we're going to talk about that for this show.

00:04:41.980 --> 00:04:45.080
Before we get to it, though, I think the listeners are really interested to hear

00:04:45.080 --> 00:04:49.560
kind of how everyone who's gotten to some really cool place contributed to some great project.

00:04:49.560 --> 00:04:50.600
Well, how did you get started?

00:04:50.600 --> 00:04:51.360
What's your background?

00:04:51.360 --> 00:04:52.300
How did you get into Python?

00:04:52.300 --> 00:04:56.900
So basically my background is I started computer science at the university

00:04:56.900 --> 00:04:59.220
because I liked computer.

00:04:59.220 --> 00:05:00.140
I liked programming.

00:05:00.140 --> 00:05:02.100
Of course, I liked games at that time.

00:05:02.100 --> 00:05:05.400
So I thought computer science, that's like a nice thing to do.

00:05:05.400 --> 00:05:10.540
And at the university, you learn a lot about languages and algorithms

00:05:10.540 --> 00:05:12.180
and a lot of like technical background.

00:05:13.180 --> 00:05:17.920
But we also had projects at the university which were more hands-on.

00:05:17.920 --> 00:05:22.020
And one of the big ones was RoboCup where you play like soccer with the robot.

00:05:22.020 --> 00:05:26.020
And you try to make the robot play soccer on its own.

00:05:26.020 --> 00:05:28.840
So you're not like steering him with a joystick but make him like autonomous.

00:05:28.840 --> 00:05:31.040
And that was a really interesting project.

00:05:31.040 --> 00:05:33.540
And that's how I got into robotics in the first place.

00:05:33.540 --> 00:05:36.780
And what languages did you use to teach the robot to be autonomous?

00:05:37.620 --> 00:05:37.960
Yeah.

00:05:37.960 --> 00:05:45.600
So usually a lot of things in robotics, if they're like the algorithms which do like C objects in the camera and make decisions,

00:05:45.600 --> 00:05:48.720
a lot of those things are like in C++ classically.

00:05:48.720 --> 00:05:49.380
Of course.

00:05:49.900 --> 00:05:56.480
But C++ is like a good language for doing like the lower level languages where you need a lot of libraries

00:05:56.480 --> 00:05:58.620
which are only available in that language potentially.

00:05:58.620 --> 00:06:01.280
Or you need like things which need to be really fast.

00:06:01.280 --> 00:06:08.960
But for other things, when you do like put things together, like the glue making the overall system work,

00:06:08.960 --> 00:06:12.760
that might not even require like really fast code or something.

00:06:13.380 --> 00:06:19.440
And then something like Python comes in more handy because you're just much more efficient in writing code and putting things together.

00:06:19.440 --> 00:06:20.100
Right.

00:06:20.100 --> 00:06:24.600
It's more about understanding what you build than it is building, you know, shaving that millisecond or microsecond off there.

00:06:24.600 --> 00:06:25.620
Exactly.

00:06:25.620 --> 00:06:25.860
Yeah.

00:06:25.860 --> 00:06:32.740
Especially if you think about like user interfaces or when you start the robot to determine which parts to start and how to configure them.

00:06:32.740 --> 00:06:33.860
Those are not time critical.

00:06:33.860 --> 00:06:37.280
So you want to be like as fast as possible developing them.

00:06:37.280 --> 00:06:40.440
And it doesn't need to be like that fast at runtime.

00:06:40.440 --> 00:06:40.980
Perfect.

00:06:40.980 --> 00:06:43.140
So you started working on these robotics projects.

00:06:43.300 --> 00:06:44.280
And they were in C++.

00:06:44.280 --> 00:06:48.140
And somewhere along the way, you're like, all right, enough C++, Python.

00:06:48.140 --> 00:06:49.060
Where did that happen?

00:06:49.060 --> 00:06:51.400
Yeah, that was actually an interesting project.

00:06:51.400 --> 00:07:01.500
We had like a graphical user interface to like do all the controlling of the robot and look into the state of the robot to see what it's currently doing and changing like plans.

00:07:01.500 --> 00:07:05.400
And we started because the rest of the software was in C++.

00:07:05.400 --> 00:07:06.760
We're all familiar with it.

00:07:06.760 --> 00:07:08.340
So we started with C++, of course.

00:07:09.180 --> 00:07:15.840
And then we figured out that like for a graphical user interface, you want to be really fast and developing new things to interact with the robot.

00:07:15.840 --> 00:07:19.500
And I tried to like look at different languages.

00:07:19.500 --> 00:07:22.020
And with some coworkers, we looked into Python.

00:07:22.020 --> 00:07:30.160
And I tried first, actually, a C++ user interface, which was able to run like parts of it in Python.

00:07:30.160 --> 00:07:33.420
So that was my first contact with Python.

00:07:33.820 --> 00:07:34.180
Very nice.

00:07:34.180 --> 00:07:43.220
So maybe you could give us a little bit of an overview of what the robotics, the sort of where Python is being used throughout the robotics industry.

00:07:43.220 --> 00:07:44.600
Oh, yeah.

00:07:44.660 --> 00:07:55.700
So especially in the robot operating system, which we work on at the Open Source Robotic Foundation, it is usually like twofold that you have a lot of code in C++ on one hand.

00:07:55.700 --> 00:07:58.320
And on the other side, you have a lot of code in Python.

00:07:58.320 --> 00:08:03.200
And usually you decide like which one is better for the part of the work you're doing.

00:08:04.200 --> 00:08:09.260
And while there are many language bindings for different languages, those are the two common ones.

00:08:09.260 --> 00:08:18.780
And Python especially is used for, for example, writing command line tools because they are very easy to write.

00:08:18.780 --> 00:08:20.380
They are really fast to develop.

00:08:20.380 --> 00:08:26.820
And you don't need like features which are specific to C++ at that point.

00:08:27.520 --> 00:08:32.800
And also on the user interfaces, a lot of user interfaces are mostly based on Python.

00:08:32.800 --> 00:08:38.720
Sometimes you use some C libraries if you need to access some other libraries which are not available in Python.

00:08:38.720 --> 00:08:48.900
But, yeah, all those kinds of like glue code to put things together to make a bigger system, those are usually relying on Python in our cases.

00:08:48.900 --> 00:08:50.300
Sure, that makes perfect sense.

00:08:50.300 --> 00:08:55.760
Like when you're down talking to the serial port or the hardware interrupt, maybe Python is not the right choice.

00:08:55.840 --> 00:09:00.640
But once you have that in place, you do the higher level logic, the sort of orchestration with Python, right?

00:09:00.640 --> 00:09:02.900
That's actually a really interesting problem.

00:09:02.900 --> 00:09:08.840
If you think about like serial communication, you would think like serial communication, very low level.

00:09:08.840 --> 00:09:12.500
Like C, C++ is the most fitting language for that.

00:09:12.500 --> 00:09:12.960
Sure.

00:09:12.960 --> 00:09:22.320
But if you try like implementing a little communication over USB or like a serial link, actually in C++ that gets really tedious.

00:09:22.320 --> 00:09:27.440
It's like a lot of work, a lot of cases to consider, and you have to do a lot manually.

00:09:27.440 --> 00:09:34.040
Python is really well suited for that because you're not dealing with a lot of data because serial is usually like low bandwidth.

00:09:34.040 --> 00:09:37.480
And the latency is also usually not an issue.

00:09:37.480 --> 00:09:43.700
So actually writing data to a serial port or reading from a serial port, I probably would choose Python for that.

00:09:43.760 --> 00:09:44.600
That's really interesting.

00:09:44.600 --> 00:09:47.000
I wouldn't have guessed that, but I guess it makes sense.

00:09:47.000 --> 00:09:47.500
That's cool.

00:09:47.500 --> 00:09:55.660
So you're associated with the ROS project, the robotic operating system at ROS.org, ROS.org.

00:09:55.660 --> 00:09:57.780
Maybe we should talk about that for a little while.

00:09:57.780 --> 00:09:58.800
Yeah.

00:09:58.880 --> 00:10:06.260
So when I first started at the university, we were just working on our own little software, you know, like you want to develop it yourself to learn.

00:10:06.260 --> 00:10:14.060
But in the near future, we noticed that, well, it just is better to reuse something which already exists.

00:10:14.360 --> 00:10:19.260
And the robot operating system has been started like seven years ago at Willow Garage.

00:10:19.260 --> 00:10:25.060
And they developed it for a very huge humanoid-like robot.

00:10:25.060 --> 00:10:31.560
It's like a robot on a mobile platform with two very complex arms and a head with like different camera systems.

00:10:31.560 --> 00:10:40.720
And ROS was basically just the outcome of trying to use this robot and make it usable for different researchers.

00:10:41.400 --> 00:10:48.680
So it was not the first goal to develop the software, but first they developed the robot, and then they developed the software for the robot, basically.

00:10:48.680 --> 00:10:49.780
That's interesting.

00:10:49.780 --> 00:10:56.100
So it was almost, you know, extracted from the construction of the robot and the needs that they had.

00:10:56.100 --> 00:10:57.100
Yes.

00:10:57.100 --> 00:10:59.000
So basically, that was the first application.

00:10:59.000 --> 00:11:08.520
And seven years later, we still have like things in the software which are like basically designed and evolved based on that robot.

00:11:08.760 --> 00:11:14.420
So later on, more robots came into the game, and we tried to support more of them and different variety of things.

00:11:14.420 --> 00:11:19.980
But you see a lot of design decisions in the system are just based because they were like developed for that first robot.

00:11:19.980 --> 00:11:27.680
So you're also working on this thing called ROSPi, which is part of the ROSCon or communication project on GitHub.

00:11:27.680 --> 00:11:29.800
What's the relationship between those two?

00:11:30.300 --> 00:11:34.860
So basically, ROSPi is like many things at the same time.

00:11:34.860 --> 00:11:46.380
On the one hand, you have the communication system, which provides you like communication patterns like publish, subscribe, or service response, which are very common ways to communicate between components.

00:11:46.380 --> 00:11:51.640
This is like the low-level like communication functionality of ROS.

00:11:52.300 --> 00:11:55.180
But then there is like, and ROSPi is one of those.

00:11:55.180 --> 00:12:00.360
So ROSPi is basically the Python implementation of this communication primitives.

00:12:00.360 --> 00:12:05.100
But ROS provides more than just the bare communication.

00:12:05.100 --> 00:12:08.360
There's on the one hand a lot of tooling.

00:12:08.360 --> 00:12:12.020
So you have a lot of tools to help you develop software for robots.

00:12:12.020 --> 00:12:14.380
You can introspect the state of a robot.

00:12:14.520 --> 00:12:16.240
You can change things at one time.

00:12:16.240 --> 00:12:20.200
Additionally, besides these tools, you have a lot of visualization.

00:12:20.200 --> 00:12:36.220
Developers around the world write applications and functional components, capabilities, for example, to make a robot be able to navigate, make a robot be able to recognize objects with a camera.

00:12:36.220 --> 00:12:36.800
Excellent.

00:12:36.800 --> 00:12:38.480
So there's like a simulator or something.

00:12:38.480 --> 00:12:39.100
Is that right?

00:12:39.100 --> 00:12:39.980
Oh, yeah.

00:12:39.980 --> 00:12:41.640
There's also the option for a simulator.

00:12:42.340 --> 00:12:44.940
You can actually use different ones.

00:12:44.940 --> 00:12:53.780
But one of the most common ones is Gazebo, which is used to try your software with a simulated robot before you actually run it on the real robot.

00:12:53.780 --> 00:12:54.480
Okay.

00:12:54.480 --> 00:13:02.780
So could I actually build and have a virtual robot before I even touch a piece of hardware and then decide, okay, now I'm ready to go in and actually get the hardware?

00:13:02.780 --> 00:13:04.060
Yeah, absolutely.

00:13:04.060 --> 00:13:08.200
And that's the big advantage because you don't want to spend the cost of the hardware first.

00:13:08.200 --> 00:13:12.000
And then you figure out, oh, well, that's actually not good for a certain use case.

00:13:12.080 --> 00:13:13.380
So you want to try that out before.

00:13:13.380 --> 00:13:20.420
So the simulation allows you to rapidly prototype a certain design of your robot and iterate on that one.

00:13:20.420 --> 00:13:25.300
You can make it run the same kind of code to drive around and pick up objects.

00:13:25.300 --> 00:13:31.800
And if you're not happy with the geometry of your robot, you can change it and iterate on it over time.

00:13:31.800 --> 00:13:34.380
And when you're happy with it, you actually go to the hardware.

00:13:34.380 --> 00:13:48.240
Now let me take a minute and tell you about our sponsor for the show, CodeChip.

00:13:48.240 --> 00:13:54.800
CodeChip is a hosted continuous delivery service focused on speed, security, and customizability.

00:13:54.800 --> 00:14:00.960
You can set up continuous integration in a matter of seconds and automatically deploy when your tests have passed.

00:14:00.960 --> 00:14:04.320
CodeChip supports your GitHub and Bitbucket projects.

00:14:04.320 --> 00:14:07.520
You can get started with CodeChip's free plan today.

00:14:08.320 --> 00:14:17.520
Should you decide to go with a premium plan, Talk Python listeners can save 20% off any plan for the next three months by using the code TALKPYTHON.

00:14:17.520 --> 00:14:23.100
That's T-A-L-K-P-Y-T-H-O-N, all caps, no spaces.

00:14:24.100 --> 00:14:31.900
Thanks to CodeChip for sponsoring the show, and I encourage you to check them out right now at CodeChip.com and thank them on Twitter where they're at CodeChip.

00:14:31.900 --> 00:14:37.420
So you mentioned some other tools.

00:14:37.420 --> 00:14:43.100
Like when I was looking through the project, I noticed there's one called RViz and one called RQT.

00:14:43.100 --> 00:14:44.200
Oh, yeah.

00:14:44.200 --> 00:14:52.400
So these are the two most commonly used user interfaces to interact and look into a robot and control it.

00:14:53.500 --> 00:14:56.720
RViz is the older software.

00:14:56.720 --> 00:14:57.880
It's like the more mature one.

00:14:57.880 --> 00:14:58.760
It has more features.

00:14:58.760 --> 00:15:06.840
It provides you basically with a 3D scene of the environment, and your robot can move in this 3D scene.

00:15:06.840 --> 00:15:12.260
So you have a CAD model, for example, which you can import as like a mesh of the robot.

00:15:12.260 --> 00:15:17.520
And the robot can actually drive through an environment which you can render.

00:15:18.380 --> 00:15:29.100
And, for example, if you see a camera image from the robot's head, it can project this image into the scene as the robot sees it.

00:15:29.100 --> 00:15:36.740
So it's very, very good for the user to get a feel what the robot currently sees and what his information about his world is.

00:15:36.740 --> 00:15:37.500
That's really cool.

00:15:37.600 --> 00:15:42.540
So it's like a 3D environment, and it basically sets the viewport of the 3D simulator to be where the camera would be?

00:15:43.060 --> 00:15:43.440
Exactly.

00:15:43.440 --> 00:15:48.100
And you can actually put multiple viewports in there where you have multiple views on the same scene.

00:15:48.100 --> 00:15:52.340
Or you can render all the sensor information the robot has.

00:15:52.340 --> 00:16:00.880
So if he has a laser in the base, you can render the laser scan itself, and you see how good does it fit with the walls where they actually are.

00:16:01.440 --> 00:16:06.220
And you can, for example, render a path where the robot plans to go next.

00:16:06.220 --> 00:16:16.880
It's very good for you to get a sense of why the robot is doing something, because the more complex it gets, the more difficult it is for the developer to follow what's actually going on in the system.

00:16:17.320 --> 00:16:24.720
Yeah, and you said there's some debugging capabilities that can let you capture those messages and that data flowing in and replay it and stuff, right?

00:16:24.720 --> 00:16:34.740
Yeah, so that's another feature for us in general, that since you try to decouple your logic into different components which communicate over messages,

00:16:34.740 --> 00:16:39.840
you can record all those messages and later look at them or play them back.

00:16:39.840 --> 00:16:44.220
And that helps to figure out problems which happened on a robot like yesterday.

00:16:44.220 --> 00:16:54.160
But if you have the information written down to the log file, you can actually introspect the problem from yesterday and actually try to reproduce it, for example, in simulation.

00:16:54.160 --> 00:16:59.080
And that helps you, like, actually fixing things which are really hard to debug otherwise.

00:16:59.080 --> 00:17:03.400
Yeah, it sounds like it'd be really hard to set a breakpoint on, like, a live robot moving around.

00:17:03.400 --> 00:17:08.600
But maybe you could do that on the simulator if it was, you know, getting the same sort of inputs or something, right?

00:17:08.600 --> 00:17:09.360
Exactly.

00:17:09.360 --> 00:17:11.300
With a simulator, you're able to reproduce it.

00:17:11.400 --> 00:17:19.160
And you're not even able to do a breakpoint, actually pause the simulator and then change something in the debugging code and continue.

00:17:19.160 --> 00:17:25.960
But you're actually able to, like, change your code and run it against the same laser information, for example.

00:17:25.960 --> 00:17:29.060
And you can ensure that now with your changes, it's fixed.

00:17:29.060 --> 00:17:31.820
With a live system, you have a hard time doing that.

00:17:31.820 --> 00:17:34.500
Yeah, the reproducibility part of it sounds really hard.

00:17:34.580 --> 00:17:35.500
So that's fantastic.

00:17:35.500 --> 00:17:36.680
Yeah.

00:17:36.680 --> 00:17:39.080
And the second part you asked about, that was RQT.

00:17:39.080 --> 00:17:41.940
It's basically a different approach than Arvis.

00:17:41.940 --> 00:17:44.620
So they are both, like, serving a little bit different needs.

00:17:44.620 --> 00:17:48.120
And RQT is where a lot of Python comes in, actually.

00:17:48.120 --> 00:17:50.280
Because Arvis is mostly based in C++.

00:17:50.280 --> 00:17:53.720
It has some ability to run Python plugins.

00:17:54.720 --> 00:17:56.800
And RQT is the other way around.

00:17:56.800 --> 00:18:06.040
RQT is like a Python application, which has the option to run, like, C++ plugins if you really need, like, the logic, the power of C++.

00:18:07.060 --> 00:18:10.220
And RQT is not built around, like, a 3D environment.

00:18:10.220 --> 00:18:16.140
It's more like a, I would say, like a development environment where you can add different things.

00:18:16.140 --> 00:18:26.780
So we have plugins which visualize, for example, just single numeric values over time, like a function, like a controller or a distance to an object.

00:18:26.780 --> 00:18:31.040
Or you can visualize images just as a plain 2D image.

00:18:31.040 --> 00:18:35.300
And you can look into all the communication which is going on.

00:18:35.300 --> 00:18:42.660
So it's more like a kind of tool set the developer can use to look into certain things and have that all in one powerful environment.

00:18:42.660 --> 00:18:44.020
Very nice.

00:18:44.020 --> 00:18:47.560
So Arvis is kind of the simulation bit.

00:18:47.560 --> 00:18:52.140
And RQT is more like setting it up and debugging it, maybe.

00:18:52.140 --> 00:18:53.760
Yeah, almost.

00:18:53.760 --> 00:18:57.140
The Arvis thing, though, does not do real simulation.

00:18:57.140 --> 00:18:59.640
It only shows you the current 3D state.

00:18:59.640 --> 00:19:04.520
It does not, it doesn't do, like, physics-based simulation or something.

00:19:04.800 --> 00:19:06.800
That would be, like, a similar external tool then.

00:19:06.800 --> 00:19:07.380
Right.

00:19:07.380 --> 00:19:07.700
Okay.

00:19:07.700 --> 00:19:08.540
Fantastic.

00:19:08.540 --> 00:19:12.300
You know, mostly I touch computers through software.

00:19:12.300 --> 00:19:14.520
So the hardware parts are a little unknown to me.

00:19:14.520 --> 00:19:22.060
Like, if I've got servos and hydraulics and stuff, like, what do I put together to put ROS on?

00:19:22.060 --> 00:19:24.420
Do I have, like, an embedded Linux in my robot?

00:19:24.420 --> 00:19:26.040
Does it run on other types of things?

00:19:26.040 --> 00:19:29.120
Where do I install the robot operation system?

00:19:29.680 --> 00:19:31.440
It completely depends on the use case.

00:19:31.440 --> 00:19:32.480
There's such a variety.

00:19:32.480 --> 00:19:37.980
For example, the PR2 robot from Willow Garage I mentioned earlier is, like, this huge robot.

00:19:37.980 --> 00:19:41.840
It has, like, two I7 multicore machines.

00:19:41.840 --> 00:19:43.660
It's, like, a heavy beast, I would say.

00:19:43.940 --> 00:19:46.660
It does a lot of things, but it's, like, it's very powerful.

00:19:46.660 --> 00:19:57.300
On the other end, you have, like, really small, like, Adreno-based ones or Raspberry Pi-based computers, which just have a connector to, like, motors or sensors.

00:19:57.940 --> 00:20:00.720
And that's totally enough to do, like, smaller projects.

00:20:00.720 --> 00:20:02.980
So it all depends on your use case.

00:20:02.980 --> 00:20:12.020
And some of the microcontrollers, depending on what you use, very common is the Linux version, the Linux distribution Ubuntu.

00:20:12.020 --> 00:20:16.700
But people have run it on various different other systems.

00:20:16.700 --> 00:20:19.520
So we are very flexible in that term.

00:20:19.520 --> 00:20:21.200
That's really cool.

00:20:21.200 --> 00:20:22.620
There's a lot of functionality here.

00:20:22.700 --> 00:20:29.800
Is this something I would consider using for, like, a toy, or is it only really for, like, professional use, or is it kind of more general?

00:20:29.800 --> 00:20:31.280
Would it make sense in a lot of places?

00:20:31.280 --> 00:20:38.380
So that's actually the difficulty of the project, I would say, since it's an open-source project and many people contribute to it.

00:20:38.380 --> 00:20:42.280
You have a large variety of people trying to use the system.

00:20:42.280 --> 00:20:51.280
So on the one hand, we have the hobbyist who tries to, like, just put his, like, Raspberry Pi and a couple of motors and sensors into a small robot, like a toy,

00:20:51.640 --> 00:20:59.000
which just, as, like, kids or teenagers, just trying to, like, make it, like, drive around, avoid obstacles, and that's, like, a great project.

00:20:59.000 --> 00:21:08.920
And on the other hand, you have developers which really use that on, like, product-level, like, robots, which are, like, car-sized robots,

00:21:08.920 --> 00:21:12.780
which drive around, for example, on a field for farming.

00:21:12.780 --> 00:21:14.860
And they have to drive reliable.

00:21:14.860 --> 00:21:16.160
They have to drive autonomously.

00:21:16.160 --> 00:21:19.960
They have to be, like, if something goes wrong, they have to, like, have fail-safes.

00:21:20.080 --> 00:21:23.480
So you have the whole spectrum of, like, kind of users which use the system.

00:21:23.480 --> 00:21:24.840
Wow.

00:21:24.840 --> 00:21:29.480
I suspect that presents some design challenges architecturally in the software, right?

00:21:29.480 --> 00:21:33.040
Like, on one hand, you want to make it so kids can, like, build little fun robots.

00:21:33.360 --> 00:21:38.860
But the requirements for a real thing that could run someone over, those are different.

00:21:38.860 --> 00:21:41.100
So what's the tension like there?

00:21:41.100 --> 00:21:46.220
Oh, the tension is definitely that it's really difficult to, like, satisfy, like, everybody in the community.

00:21:46.220 --> 00:21:52.600
So you have, like, very different demands in terms of, like, the people who want, like, that for a hobby project.

00:21:52.600 --> 00:21:54.420
They want a very lower entry barrier.

00:21:54.420 --> 00:21:56.900
They want, like, really easy tutorials.

00:21:56.900 --> 00:22:03.120
A lot of people are not software engineers which, like, look at those things and try to build, like, their small robot at home.

00:22:03.120 --> 00:22:11.680
They're, like, eventually mechanical engineers or probably even not that, but might be teenagers just trying to play with it, right?

00:22:12.820 --> 00:22:18.480
So it's really difficult to bridge that whole area of users.

00:22:18.480 --> 00:22:21.900
And I would say there are a lot of design challenges.

00:22:21.900 --> 00:22:35.760
So one example is when it was originally developed for the PR2, it was meant for, like, researchers, for, like, developers who knew, like, what they tried to achieve.

00:22:36.040 --> 00:22:39.360
And if it didn't work, it was fine to just, like, restart, right?

00:22:39.360 --> 00:22:46.960
So if the experiment didn't work, you just, like, control C everything and restart, restart the camera for the video for your presentation.

00:22:46.960 --> 00:22:48.660
And you try again.

00:22:48.660 --> 00:22:50.860
That was totally feasible at that time.

00:22:50.860 --> 00:22:59.020
But if you have a robot, for example, Ross also runs on the Robonaut 2, which is on the ISS space station.

00:22:59.020 --> 00:22:59.880
That's amazing.

00:22:59.880 --> 00:23:04.880
So at that point, you probably have a harder time, like, retrying things over and over.

00:23:04.880 --> 00:23:07.560
You want some kind of deterministic behavior.

00:23:07.560 --> 00:23:12.080
And these are still things where Ross needs to improve in the future.

00:23:12.080 --> 00:23:24.120
So we're always working on, like, making it more suitable for, like, production-level software that you can actually rely on it and can sell the product and don't have to worry about it ever going wrong.

00:23:24.120 --> 00:23:28.520
But that's definitely an ongoing effort to make it more solid in these domains.

00:23:28.520 --> 00:23:29.520
That's really cool.

00:23:29.520 --> 00:23:33.020
I'm sure it's a challenge, but it probably also makes it a better thing in the end.

00:23:33.020 --> 00:23:33.840
Oh, yeah.

00:23:33.840 --> 00:23:38.020
I mean, the more use cases your software has, the more flexible it gets.

00:23:38.020 --> 00:23:49.440
We often get, like, you know, a totally different operating system, which we don't even have in our office.

00:23:49.440 --> 00:23:50.540
We can't even test it.

00:23:50.540 --> 00:23:57.460
So we rely on external people, which use it on their systems to contribute back and make it more usable in different scenarios.

00:23:57.460 --> 00:23:59.060
Wow, that's amazing.

00:23:59.060 --> 00:24:04.280
So maybe we should talk a little bit about the core components.

00:24:04.280 --> 00:24:08.860
Like, what is Ross meta before we talk about more how PyOnton's working there?

00:24:08.860 --> 00:24:12.600
Yeah, so the core components for the communication.

00:24:12.600 --> 00:24:20.740
So first of all, the system encourages the developer to split functional components in separate pieces.

00:24:21.040 --> 00:24:33.380
So if you think about something which, a component which reads the camera image, and then a component which extracts from the camera image a certain feature where it wants to drive to,

00:24:33.720 --> 00:24:45.020
and then the actual planning where to drive to, and then the component which talks to the motors and actually maps the drive command to a real action in the world.

00:24:45.400 --> 00:24:49.000
And the system tries to, like, keep those things separate.

00:24:49.000 --> 00:24:58.960
And this abstraction on the first level allows the developer later to swap out a certain thing with a new implementation and try them out.

00:24:58.960 --> 00:25:08.540
And that's where all this communication infrastructure comes in, that every component talks to other components by exchanging messages.

00:25:08.540 --> 00:25:11.080
It's like a data-centric approach.

00:25:11.080 --> 00:25:12.800
Right, and these are asynchronous messages.

00:25:12.960 --> 00:25:16.260
You kick them off, and then eventually maybe a new message comes back for you or something like that.

00:25:16.260 --> 00:25:18.840
Yeah, so most of the times they are asynchronous.

00:25:18.840 --> 00:25:22.920
There are times when you can do synchronous request response and you wait for the answer.

00:25:22.920 --> 00:25:27.640
But this is something you usually want to avoid because maybe the answer comes in, like, two minutes.

00:25:27.640 --> 00:25:29.600
That's probably not how long you want to wait.

00:25:29.600 --> 00:25:34.800
So writing your code in an asynchronous fashion is usually the preferred style, yes.

00:25:34.800 --> 00:25:38.180
Excellent, and Ross really encourages that with its APIs and so on, right?

00:25:38.180 --> 00:25:41.440
Yes, so if you look at the PR2 robot,

00:25:41.680 --> 00:25:46.580
it runs, I think, roughly 150 processes in parallel, and they all talk to each other.

00:25:46.580 --> 00:25:54.940
And as long as you remove one of the components, which has a certain interface on a message level,

00:25:54.940 --> 00:25:59.580
it receives certain messages on a so-called topic, basically a named bus,

00:25:59.580 --> 00:26:02.340
and it responds on another topic.

00:26:02.340 --> 00:26:06.280
If you replace it with a different component which has the same kind of interface,

00:26:06.860 --> 00:26:10.400
nobody will notice as long as you, like, produce similar results.

00:26:10.400 --> 00:26:12.660
That's really excellent.

00:26:12.660 --> 00:26:19.480
I'm sure it's good for, you know, testing or adapting or maybe even trying different pieces of hardware in your robot, right?

00:26:19.480 --> 00:26:20.460
Yeah, exactly.

00:26:20.660 --> 00:26:26.220
So that's another big strength of the size of the community because so many people use the software,

00:26:26.220 --> 00:26:31.540
that if you have, like, a set of cameras, for example, or motors,

00:26:31.540 --> 00:26:35.460
then somebody very likely has, if it's used in other robots,

00:26:35.460 --> 00:26:39.980
then somebody very likely has already implemented the driver's side of it

00:26:39.980 --> 00:26:43.920
and make it a ROS component that you can just send it a ROS message,

00:26:43.920 --> 00:26:48.200
you drive forward with that speed, and the motor will do it,

00:26:48.200 --> 00:26:52.340
and you don't have to take care about how it actually maps to the protocol of that motor

00:26:52.340 --> 00:26:54.320
and how it communicates over serial.

00:26:54.320 --> 00:26:56.600
It's all hidden and abstracted from you.

00:26:56.600 --> 00:26:58.960
So these nice little building blocks are kind of there,

00:26:58.960 --> 00:27:02.780
so you're almost ready to start using the Python stuff to just orchestrate that.

00:27:02.780 --> 00:27:03.560
Exactly.

00:27:03.560 --> 00:27:06.720
And that's where Python is very strong at, the orchestration part.

00:27:06.840 --> 00:27:09.520
For example, we have a tool which is called ROS Lounge,

00:27:09.520 --> 00:27:15.760
and it's basically a description in an XML file which tells you what kind of software

00:27:15.760 --> 00:27:18.960
and programs you want to run at the same time and how they talk to each other.

00:27:18.960 --> 00:27:22.660
And all this, like, orchestration happens in Python because it's just,

00:27:22.660 --> 00:27:28.300
it's way easier and faster to write, and you have the power of, like, dynamic language

00:27:28.300 --> 00:27:31.360
where you don't need to know all the types at compile time.

00:27:31.360 --> 00:27:36.180
It gives you a lot of, like, power over, like, static and compile languages.

00:27:36.640 --> 00:27:40.920
So another strength of the core building blocks seems to be around geometry, right?

00:27:40.920 --> 00:27:42.640
Like, that's got to be a real hard problem.

00:27:42.640 --> 00:27:44.260
I've got all these moving parts to my robot.

00:27:44.260 --> 00:27:48.520
Maybe it's got an arm and it's got wheels and it's moving around.

00:27:48.520 --> 00:27:49.100
That's hard.

00:27:49.100 --> 00:27:51.780
So there's support for modeling, that kind of stuff, right?

00:27:51.780 --> 00:27:52.620
Yeah, exactly.

00:27:52.740 --> 00:27:59.580
So if you think that you receive a camera image and in the image you see a certain object you want to grasp,

00:27:59.580 --> 00:28:06.380
then you don't really know yet where that object is because you don't know without any further information

00:28:06.380 --> 00:28:08.420
where your camera was when it took the picture.

00:28:09.160 --> 00:28:16.560
So one thing which the robots usually keep track of is, like, first, their location in a known environment.

00:28:16.560 --> 00:28:21.120
So it's usually, like, the base where your robot stands or where your wheels are.

00:28:21.820 --> 00:28:28.180
But then you know all your joints and your arms and your head and neck, how all these, like, joints are oriented.

00:28:28.180 --> 00:28:31.820
And then you can build up a transformation to where your camera is.

00:28:31.820 --> 00:28:38.020
And to do that, like, in a very easy way, there's, like, packages which support you with that.

00:28:38.020 --> 00:28:39.160
Like, geometry is one.

00:28:39.160 --> 00:28:41.640
There's another one called TF for transform.

00:28:42.320 --> 00:28:49.720
It can basically transform, if you see in your camera, in the middle of the camera, in a meter away, a certain object.

00:28:49.720 --> 00:28:53.500
You can transform how far is that away from my left hand, for example.

00:28:53.500 --> 00:28:56.840
So you can do all these computations very nicely.

00:28:56.840 --> 00:28:57.880
That's cool.

00:28:57.880 --> 00:29:00.820
I bet there's a lot of matrix multiplication going on in there, right?

00:29:00.820 --> 00:29:02.020
Oh, yeah, for sure.

00:29:02.020 --> 00:29:04.760
And that can get really difficult.

00:29:04.760 --> 00:29:06.720
And depending on how complex your robot is,

00:29:06.720 --> 00:29:11.080
you have to be careful setting up the kinematic and the computation

00:29:11.080 --> 00:29:12.740
that it's, like, actually, like, fast.

00:29:12.740 --> 00:29:15.800
Because you probably are not interested in every joint of your robot.

00:29:15.800 --> 00:29:20.340
It's probably fast, fine enough if you only know a certain amount of them.

00:29:20.340 --> 00:29:23.000
That's math you want to just put into a library and forget.

00:29:23.000 --> 00:29:24.040
Exactly.

00:29:24.040 --> 00:29:26.580
Because not everybody wants to write and see that stuff.

00:29:26.580 --> 00:29:27.920
That's right.

00:29:27.920 --> 00:29:30.680
So I actually have a couple of questions from some listeners

00:29:30.680 --> 00:29:33.880
who sent in some messages or questions for you.

00:29:33.880 --> 00:29:35.440
So one of them was,

00:29:35.440 --> 00:29:39.800
what's the process of writing and deploying your own packages using Rospy?

00:29:40.840 --> 00:29:45.120
Oh, so that's another interesting question for Ross in general,

00:29:45.120 --> 00:29:47.780
because we don't only provide the software.

00:29:47.780 --> 00:29:50.600
There's a lot of infrastructure because we have this federated approach.

00:29:50.600 --> 00:29:52.100
Everybody contributes a package.

00:29:52.100 --> 00:29:57.700
And I think the latest Ross release has, like, about 1,500 packages,

00:29:57.700 --> 00:30:00.420
which we build for people into Debian packages,

00:30:00.420 --> 00:30:04.300
because also nobody wants to deal with, like, creating a Debian package manually,

00:30:04.300 --> 00:30:07.960
if you can avoid it, because you really don't care how the internals work.

00:30:08.900 --> 00:30:12.200
And so we also make this packaging process very easy.

00:30:12.200 --> 00:30:17.820
So if you want to write, for example, a simple package which does a certain task,

00:30:17.820 --> 00:30:22.540
you just create a repository somewhere.

00:30:22.540 --> 00:30:23.640
You want to share your code.

00:30:23.640 --> 00:30:27.380
A lot of our code is on GitHub, but that's not, like, the only platform.

00:30:27.380 --> 00:30:28.900
You can put it, like, anywhere else.

00:30:29.740 --> 00:30:33.080
You have to be able to build your package.

00:30:33.080 --> 00:30:35.700
Usually, if it's Python, you have a setup.py file.

00:30:35.700 --> 00:30:42.340
Additionally, we have an XML file describing, like, meta information,

00:30:42.340 --> 00:30:44.600
like what's your package's name, what's the license,

00:30:44.600 --> 00:30:47.160
because people want to know if they can use your code or not.

00:30:47.160 --> 00:30:49.200
What's the maintainer?

00:30:49.200 --> 00:30:51.760
Does he have an email address which I can, like, talk to?

00:30:51.760 --> 00:30:53.900
Is there a website which contains more information?

00:30:55.100 --> 00:30:59.020
And also very important, what kind of other packages do you depend on?

00:30:59.020 --> 00:31:03.520
And then, besides those meta information, it's all about your code.

00:31:03.520 --> 00:31:05.620
So you put your Python code in there.

00:31:05.620 --> 00:31:09.360
And after that one, you just go to our, like, website.

00:31:09.660 --> 00:31:13.860
And there is a process how you can tell us that there is a repository with a ROS package.

00:31:13.860 --> 00:31:18.300
And if you give us the location and we can access it, so it must be publicly readable,

00:31:18.300 --> 00:31:21.480
then we can actually, like, provide that information to others.

00:31:21.480 --> 00:31:24.260
And we can potentially even build, like, packages out of that.

00:31:24.260 --> 00:31:26.100
And people can easily reuse it.

00:31:26.100 --> 00:31:27.180
That's cool.

00:31:27.180 --> 00:31:32.240
Is there, like, a central repository, kind of like PyPI with Python packages?

00:31:32.240 --> 00:31:34.360
Yeah, that's kind of it.

00:31:34.360 --> 00:31:36.080
But we don't separate them by language.

00:31:36.080 --> 00:31:39.040
But there is a so-called repository called ROS Distro.

00:31:39.040 --> 00:31:45.800
And that one defines repositories, external ones, where ROS packages are.

00:31:45.800 --> 00:31:49.120
And there's, like, basically, I would say, like, two classes of packages.

00:31:49.120 --> 00:31:54.740
There are the ones which are, like, released in terms of that we build, like, Debian packages out of them.

00:31:54.740 --> 00:31:57.320
Or Fedora RPM packages.

00:31:57.320 --> 00:31:59.240
Or whatever platform you want to imagine.

00:31:59.240 --> 00:32:04.900
OS X is also one thing where we actively support people to build their code on.

00:32:05.700 --> 00:32:10.660
And, yeah, you just have to register in this, like, it's basically a huge YAML file.

00:32:10.660 --> 00:32:13.820
And you register your repository with a name and the URL.

00:32:13.820 --> 00:32:16.480
And you can specify which branch it's coming from.

00:32:16.480 --> 00:32:21.680
And after that one, anybody can use on his computer, like, a command similar to PyPI.

00:32:21.680 --> 00:32:26.800
But it's a ROS-specific one which says, like, hey, give me the repository for the repository foo.

00:32:26.800 --> 00:32:28.900
And it pulls down the information.

00:32:28.900 --> 00:32:34.260
You can just either build it, if it's C++ code, if it's Python code, you can basically just run it.

00:32:34.300 --> 00:32:35.860
So you talked about licensing.

00:32:35.860 --> 00:32:39.580
And some of this, I'm sure, is open source, probably a lot of it.

00:32:39.580 --> 00:32:41.200
Is there, like, a commercial ecosystem?

00:32:41.200 --> 00:32:44.680
Are there companies that, like, build these packages and sell them?

00:32:45.040 --> 00:32:46.220
That's a very good question.

00:32:46.220 --> 00:32:48.560
I can't say for sure because the community is so big.

00:32:48.560 --> 00:32:51.940
But I'm not aware of companies which sell, like, packages.

00:32:51.940 --> 00:32:59.320
But there are definitely companies which use, like, the open source core packages, which are available.

00:32:59.320 --> 00:33:06.340
And they build their own proprietary software on top, which they are free to do because most of the packages is licensed under BSD.

00:33:06.880 --> 00:33:10.480
So we actually encourage people to build, like, commercial software on top.

00:33:10.480 --> 00:33:19.580
And then they use these proprietary packages either to sell their products or use it only for their in-house robots, depending on their use case.

00:33:20.160 --> 00:33:27.480
So another listener question is, says, is there a time where we can build ROS nodes without Katkin make?

00:33:27.480 --> 00:33:31.320
When using ROSPy, they don't really feel that it's super Pythonic.

00:33:31.820 --> 00:33:33.180
Oh, that's a good one.

00:33:33.180 --> 00:33:42.840
So classically, in the very beginning, we had a tool called ROSMake, which was basically a make file, and it built the whole process.

00:33:42.840 --> 00:33:52.120
And, like, two years ago, two and a half years ago, we introduced a new build system, which is called Katkin, which is based on CMake.

00:33:52.120 --> 00:33:59.680
So CMake calls Python setup.py install, which is definitely not very native for a Python developer.

00:34:00.980 --> 00:34:10.600
So for the current system, what I would call ROS1, which is currently ROS Indigo, we name them, like, in alphabetic order, like a lot of other projects.

00:34:10.600 --> 00:34:13.080
There will be ROS Jade soon.

00:34:13.080 --> 00:34:19.800
But for those things, we might not touch that because a lot of these changes will affect a lot of users.

00:34:19.800 --> 00:34:26.560
And updating our tutorials and teaching the whole community to change their workflow is really difficult.

00:34:26.920 --> 00:34:31.200
We learned that when we deployed the new build system, Katkin, like, two and a half years ago.

00:34:31.200 --> 00:34:35.760
And we would not go for a change in the new future again, I would say.

00:34:35.760 --> 00:34:40.720
Yeah, it's too much infrastructure and support knowledge around it to change it, right?

00:34:40.720 --> 00:34:41.120
Exactly.

00:34:41.120 --> 00:34:44.320
But we always work on, like, new stuff.

00:34:44.320 --> 00:34:46.700
And that's currently one thing we focus on.

00:34:46.700 --> 00:34:47.500
It's called ROS2.

00:34:47.500 --> 00:34:50.820
It's basically we have learned a lot in the last seven years.

00:34:50.820 --> 00:34:57.300
And we know that there are certain things where we have to make the system more flexible and more capable,

00:34:57.300 --> 00:35:01.880
especially if you think about, like, really small systems like microcontrollers.

00:35:02.200 --> 00:35:04.420
That's something we currently don't support very well.

00:35:04.420 --> 00:35:09.200
Because of early design decisions, we use XML for some RPCs.

00:35:09.200 --> 00:35:13.660
And generating XML on a microcontroller is really, like, not something you want to do.

00:35:13.660 --> 00:35:19.280
That made sense, you know, seven years ago, probably, when XML was the thing, right?

00:35:19.280 --> 00:35:19.760
Yeah.

00:35:19.760 --> 00:35:23.540
And you had two i7s in the first robot, so they didn't care.

00:35:24.040 --> 00:35:28.840
But now you have, like, Raspberry Pis and really smaller microcontrollers where you want to run stuff on.

00:35:28.840 --> 00:35:34.160
And on the other hand, you have people who want to ship their robot, like the vacuum robot or their lawnmower,

00:35:34.160 --> 00:35:40.080
which just works 100% of the time out of the box without ever a developer touching it.

00:35:40.080 --> 00:35:42.680
The user can just use the product.

00:35:42.680 --> 00:35:48.280
And for those things, the requirements are very different than the first systems ROS was built for.

00:35:48.280 --> 00:35:52.860
And so we currently work on the next thing called ROS2.

00:35:53.900 --> 00:36:01.420
And for this one, we actually think about and have some prototyping which have a pure, what you would call pure Python package.

00:36:01.420 --> 00:36:08.260
It contains of the meta information, an XML file, because you still need, like, a coherent way to, like, describe your package.

00:36:08.260 --> 00:36:13.660
Like, I don't know, like, other languages have the same thing, like manifest file, basically.

00:36:13.660 --> 00:36:17.660
And beside that, you only have to set up the Py file, what you would expect.

00:36:17.660 --> 00:36:23.760
And there's no, like, CMake around because you don't want to have, like, you don't need CMake to build a Python package.

00:36:23.760 --> 00:36:24.640
Absolutely.

00:36:24.640 --> 00:36:29.200
And then you also gain back features which the previous system didn't have.

00:36:29.200 --> 00:36:33.080
For example, you could only use a very limited set of the setup.py functionality.

00:36:33.080 --> 00:36:41.760
For example, like a C extension was really difficult to do because our system just, like, didn't allow you to do that.

00:36:41.960 --> 00:36:49.480
But with a pure setup.py file, you can use the full power of whatever, for example, setup tools gives you to build your package.

00:36:49.480 --> 00:36:50.500
That sounds fantastic.

00:36:50.500 --> 00:36:52.620
So when's ROS2 planned?

00:36:53.560 --> 00:36:54.860
That's always a good question.

00:36:54.860 --> 00:36:55.580
Of course.

00:36:55.580 --> 00:36:58.780
I would say it's going to be shipped when it's ready.

00:36:58.780 --> 00:37:02.860
But we aim to release a first version in this summer.

00:37:03.440 --> 00:37:10.580
But due to the scope of the project, it might not be something every user wants to switch over immediately.

00:37:10.580 --> 00:37:14.320
It will be something which developers are interested in to see the new features.

00:37:14.820 --> 00:37:19.880
And if they want to try it out and see how it fits their applications.

00:37:19.880 --> 00:37:24.640
But it will take a long time for the majority of the user base to migrate.

00:37:24.640 --> 00:37:29.180
So we don't plan to replace the original system with a new one.

00:37:29.180 --> 00:37:31.060
It will be more a coexistence.

00:37:31.060 --> 00:37:32.380
You can still use the old system.

00:37:32.380 --> 00:37:33.220
It will be maintained.

00:37:33.720 --> 00:37:38.920
And the new system will give you changes, but also more features and functionality.

00:37:38.920 --> 00:37:42.940
And it's your choice when you want to adopt the new thing.

00:37:42.940 --> 00:37:43.660
That's cool.

00:37:43.660 --> 00:37:44.660
What kind of features are coming?

00:37:44.660 --> 00:37:49.020
So that's actually a lot of things.

00:37:49.020 --> 00:37:49.640
All right.

00:37:49.640 --> 00:37:50.300
What are the highlights?

00:37:50.300 --> 00:37:51.120
The highlights.

00:37:51.120 --> 00:37:52.800
Let me think about it.

00:37:52.800 --> 00:37:58.740
So the first thing is the new system uses a completely different communication system under the hood.

00:37:58.740 --> 00:38:03.560
For the first version of ROS, we developed everything from serialization,

00:38:03.660 --> 00:38:08.620
messages to the TCP transfer, UDP transfer, everything from scratch.

00:38:08.620 --> 00:38:12.340
Because seven years ago, there was not that great library support for that.

00:38:12.340 --> 00:38:14.180
But, yeah, time has changed.

00:38:14.180 --> 00:38:20.000
And for the new thing, we actually rely on a standard from the OMG, which is called DDS,

00:38:20.000 --> 00:38:21.520
the Data Distribution Services.

00:38:21.520 --> 00:38:28.380
And relying on that gives us a lot of functionality without having to reimplement it from scratch.

00:38:28.380 --> 00:38:33.360
And built on that system, we can provide you with much better support for,

00:38:33.580 --> 00:38:37.380
for example, deterministic startup, reliable delivery of a message.

00:38:37.380 --> 00:38:44.060
We can tell you your message got delivered, or we will give you an event like a callback and tell you that it has not.

00:38:44.460 --> 00:38:51.000
And you can tune how often you want to retry it and things like this, which matter in a bigger system.

00:38:51.000 --> 00:38:57.160
I could probably fill a whole podcast about the features of ROS 2, which will hopefully be better than ROS 1.

00:38:57.160 --> 00:39:02.760
For example, one of the interesting things is ROS 1 always focused on Linux support, so Ubuntu.

00:39:03.300 --> 00:39:08.920
There are a lot of versions where you can build it on Fedora and Pure Debian and OS X.

00:39:08.920 --> 00:39:12.480
But one thing which it is not good at is building it on Windows.

00:39:12.480 --> 00:39:17.020
And this is something we have fixed for the ROS 2 prototypes very early on.

00:39:17.020 --> 00:39:24.040
So ROS 2 will just build natively in Visual Studio on Windows, the same as on other platforms.

00:39:24.100 --> 00:39:27.720
So it's really like from day one to support it well.

00:39:27.720 --> 00:39:30.700
And once you support it, it will be supported in the future.

00:39:30.700 --> 00:39:33.300
But adding the support later is really difficult.

00:39:33.300 --> 00:39:37.060
Yeah, because you've got to go back and fix a thousand errors and you've got to rewrite this and that.

00:39:37.060 --> 00:39:38.780
That's great that you're supporting Windows as well.

00:39:38.780 --> 00:39:41.100
It's nice to just say, yes, we support everything.

00:39:41.100 --> 00:39:43.920
There's still a lot of people using Windows for this kind of stuff.

00:39:44.320 --> 00:39:44.720
Exactly.

00:39:44.720 --> 00:39:46.840
And currently, they have a really hard time using it.

00:39:46.840 --> 00:39:51.600
Either they use virtual machines inside of Windows or they try it with Segwin.

00:39:51.600 --> 00:39:54.140
And there are some tutorials where people make it work.

00:39:54.140 --> 00:39:56.660
But it's everything but a smooth process.

00:39:56.660 --> 00:39:57.800
It takes a lot of effort.

00:39:57.800 --> 00:39:58.940
That's right.

00:39:58.940 --> 00:39:59.680
Let's see.

00:39:59.680 --> 00:40:03.460
So I have a couple of sort of larger scale pictures for you.

00:40:03.460 --> 00:40:07.820
First of all, what kind of robots or automation have you seen using ROS?

00:40:07.820 --> 00:40:11.240
You said something about the International Space Station, which is just amazing.

00:40:11.240 --> 00:40:12.180
Oh, yeah.

00:40:12.180 --> 00:40:13.900
That was actually a really interesting project.

00:40:13.900 --> 00:40:16.580
The first, Robonaut, which is like a humanoid robot.

00:40:16.580 --> 00:40:20.180
The first one had only torso and arms and the head.

00:40:20.180 --> 00:40:22.120
That was not yet running ROS.

00:40:22.120 --> 00:40:27.040
But the second iteration, which was launched last year, now has legs.

00:40:27.040 --> 00:40:30.120
So it's more like four arms if you look at it.

00:40:30.120 --> 00:40:32.120
And that one has a new computer system.

00:40:32.120 --> 00:40:34.360
And the computer system is completely ROS-based.

00:40:34.360 --> 00:40:43.360
And I think they made the choice to use ROS because it allows them to really fast prototype new functionality,

00:40:43.640 --> 00:40:44.440
try them out.

00:40:44.440 --> 00:40:50.760
And then if that goes well, focus on something they want to make more detailed.

00:40:51.860 --> 00:40:58.120
And sure, our communication protocol is not the best one to communicate with a space station because that's definitely not designed for.

00:40:58.120 --> 00:41:01.620
But they just wrapped the whole communication in the VPN tunnel.

00:41:01.620 --> 00:41:06.440
And that's good enough for them because it's like it's isolated, it's secure.

00:41:06.580 --> 00:41:14.340
And if our protocol has like 15 seconds or something latency to talk to the space station, that was totally fine for their use case.

00:41:14.500 --> 00:41:19.160
Probably part of the benefit of the async message passing, not waiting on things and all that kind of stuff.

00:41:19.160 --> 00:41:19.820
Exactly, yeah.

00:41:19.820 --> 00:41:29.580
You have to be a little bit more defensive when you write your component to like not embed assumptions in your code, which don't hold in those scenarios.

00:41:29.580 --> 00:41:33.880
But if you're careful about your code, obviously you can make it work for those cases.

00:41:33.880 --> 00:41:36.620
Other notable use cases that you can talk about?

00:41:36.620 --> 00:41:38.800
There are a lot of references of robots.

00:41:39.200 --> 00:41:47.860
For example, there are a lot of industrial arms where they try to use ROS to do the higher level planning.

00:41:47.860 --> 00:42:01.480
So classically, the robot in an industrial setting has like this really like tailored embedded controller, which is very robust and has to fulfill a lot of safety requirements.

00:42:02.360 --> 00:42:11.120
But then you have the really complex behavior to plan a path around obstacles, probably in a dynamic environment.

00:42:11.120 --> 00:42:13.040
And that's where ROS is very good at.

00:42:13.040 --> 00:42:23.620
And so a lot of these use cases, they use like the industrial controllers on the lower level and then put ROS on top to do the more sophisticated dynamic environment planning.

00:42:23.620 --> 00:42:39.300
And of course, there's a variety of vehicles from like small autonomous cars to like platforms in like warehouses to drive around and deliver things, which all rely on like localizing yourself and then autonomously navigating in an environment.

00:42:39.300 --> 00:42:46.440
How do you see the future of robotics and what role do you think Python and ROS are playing in it?

00:42:46.900 --> 00:42:53.780
I think ROS has a very bright future in robotics because the community is just very big.

00:42:53.780 --> 00:42:57.800
A lot of people use it and that makes it grow very well.

00:42:57.800 --> 00:43:04.520
So it addresses a lot of use cases and makes the things that people want to do achieve more easy.

00:43:04.520 --> 00:43:09.040
So I think that will continue to grow and just spread into more use cases.

00:43:09.040 --> 00:43:12.460
For example, quadrotors or things which are currently evolving.

00:43:13.140 --> 00:43:15.940
The people, when they start these projects, look at what's out there.

00:43:15.940 --> 00:43:23.180
And a lot of people just choose ROS because it helps them to like get there faster and prototype faster and get their product ready faster.

00:43:23.180 --> 00:43:31.160
And usually that's to a very big amount due to Python because they can just like rapidly prototype what they have in mind.

00:43:31.160 --> 00:43:38.600
And later on, if they figure out something is not fast enough or they can still like migrate code to C++ if there's need.

00:43:38.600 --> 00:43:40.500
But a lot of stuff is not that critical.

00:43:41.240 --> 00:43:44.420
Yeah, it seems like there's maybe two ways to go faster.

00:43:44.420 --> 00:43:47.980
One hand is to write something in C++ and ROS directly.

00:43:47.980 --> 00:43:52.120
And the other is maybe write a C extension for your Python code.

00:43:52.120 --> 00:43:53.560
Is that a thing that would actually work?

00:43:53.560 --> 00:43:56.220
Yeah, that's definitely something which works.

00:43:56.920 --> 00:44:01.360
It's always a matter of like first you have to identify what's really the bottleneck.

00:44:01.360 --> 00:44:04.860
And in a lot of cases, it's not the Python code.

00:44:04.860 --> 00:44:09.220
It's like it's more like you have an algorithm which is just like not well structured.

00:44:09.220 --> 00:44:12.940
And even if you restructure that in Python, you will be already good to go.

00:44:13.400 --> 00:44:23.160
So it's really like finding the knob which you have to tune and not like just merge your code to C++ and then are not even better because your algorithm has a flaw.

00:44:23.160 --> 00:44:24.320
Yeah.

00:44:24.460 --> 00:44:30.580
Sometimes choosing the right data structure like a dictionary instead of a list or something would make all the difference.

00:44:30.580 --> 00:44:31.120
Oh, yeah.

00:44:31.120 --> 00:44:31.920
Lookups, right?

00:44:32.420 --> 00:44:32.820
Exactly.

00:44:32.820 --> 00:44:42.900
And especially in Python, a lot of things where you like sometimes unintentionally duplicate lists which are big instead of just mutating the list in place.

00:44:42.900 --> 00:44:44.700
Those things can matter a lot.

00:44:44.700 --> 00:44:55.580
So before moving code from one language to another, I would always suggest spending a good amount of like debugging and profiling before like making something like that because it's a lot of effort.

00:44:55.580 --> 00:45:00.680
So it sounds like you guys are taking contributions for your projects and people are working on it.

00:45:00.680 --> 00:45:05.020
They can find it at github.com/ROS, R-O-S.

00:45:05.020 --> 00:45:09.980
And then the ROS pie is really in the ROS underscore com repository, right?

00:45:09.980 --> 00:45:10.900
Yes, correct.

00:45:10.900 --> 00:45:18.300
And probably the easiest entry point is usually wiki.ros.org because that gives you like the documentation like front end.

00:45:18.300 --> 00:45:23.340
And from there, you find a lot of links to the repositories with the code.

00:45:23.780 --> 00:45:26.480
And also a lot of tutorials, especially for the Python part.

00:45:26.480 --> 00:45:36.180
So that sort of answers one of my other questions is if I've got, you know, a motor and I've got a Raspberry Pi and I've got some servos and I just want to make this thing.

00:45:36.180 --> 00:45:38.400
I want to build a robot and I have some parts.

00:45:38.400 --> 00:45:39.280
How do I get started?

00:45:39.280 --> 00:45:51.220
I think the best thing for something like that is always like, I mean, depending if you want to like get there fast or if you just want the full learning experience, I would expect first like, of course, Googling.

00:45:51.400 --> 00:45:53.960
We also have a platform where people ask questions.

00:45:53.960 --> 00:45:55.540
It's answers.ros.org.

00:45:55.540 --> 00:45:58.880
And just like, look if other people have done something similar.

00:45:58.880 --> 00:46:04.380
And I'm pretty much sure that for this specific use case, people have tried that.

00:46:04.380 --> 00:46:13.020
So you will see people how they did that, what kind of motors they used and what kind of applications they like try to develop and see how they did it.

00:46:13.100 --> 00:46:16.900
And then try your project based on that one.

00:46:16.900 --> 00:46:22.940
And I think that's always a good thing because you can just get back to the community and ask questions.

00:46:22.940 --> 00:46:28.980
And usually you get like really good responses in like a short amount of time, which help you keep going on the project.

00:46:28.980 --> 00:46:32.280
Did you guys do anything with the hour of code?

00:46:32.280 --> 00:46:36.560
Like were there projects going on that you knew of or anything like that?

00:46:36.560 --> 00:46:40.000
It seems like robotics would play a big role in that area.

00:46:40.000 --> 00:46:41.180
Was the hour of code?

00:46:41.380 --> 00:46:42.940
Are you familiar with this, the hour of code?

00:46:42.940 --> 00:46:44.340
I'm sadly not.

00:46:44.340 --> 00:46:45.900
I might miss something.

00:46:45.900 --> 00:46:46.440
Oh, yeah.

00:46:46.440 --> 00:46:47.440
So check it out next year.

00:46:47.440 --> 00:46:51.960
It's in, oh, gosh, it feels like it was like three or four months ago.

00:46:51.960 --> 00:46:53.680
Just check out code.org.

00:46:53.680 --> 00:46:57.580
And there's a lot of robotics sort of projects.

00:46:57.580 --> 00:47:02.880
The idea of the hour of code is have every student in the world do one hour of programming during that week.

00:47:03.380 --> 00:47:07.840
And many of the projects that were sort of formed from there were robot based.

00:47:07.840 --> 00:47:10.720
And so it seems like a really cool place to get involved with.

00:47:10.720 --> 00:47:15.000
Oh, that sounds great because that will get the people engaged into the project.

00:47:15.000 --> 00:47:16.080
That sounds really amazing.

00:47:16.080 --> 00:47:16.760
Absolutely.

00:47:16.760 --> 00:47:17.240
I will look that up.

00:47:17.240 --> 00:47:17.920
Yeah, check it out.

00:47:17.920 --> 00:47:18.640
Okay, awesome.

00:47:19.480 --> 00:47:21.980
I think that might be a good place to call it a show.

00:47:21.980 --> 00:47:28.320
A question I ask all my guests sort of near the end of the show is there's a ton of packages on PyPI.

00:47:28.320 --> 00:47:30.480
And there's a lot of stuff on GitHub.

00:47:30.480 --> 00:47:34.960
There's some really awesome stuff out there in Python you want to call people's attention to.

00:47:34.960 --> 00:47:38.240
And, you know, Rospy might be the best one.

00:47:38.240 --> 00:47:38.860
I don't know.

00:47:39.400 --> 00:47:46.300
Yeah, Rospy, which you can sadly not get over PyPI because it requires more than just Python because of all the dependencies it uses.

00:47:46.300 --> 00:47:55.280
But I think there are a good amount of tools available which came from the ROS project, which are really nice to use.

00:47:55.280 --> 00:48:00.740
So just when you go through the wiki of ros.org, look at packages.

00:48:00.740 --> 00:48:05.280
And maybe some of them are even useful for you without using them in the context of ROS.

00:48:05.640 --> 00:48:11.460
And that's the big advantage that people can actually make use of them and apply them to different areas.

00:48:11.460 --> 00:48:16.320
So anything you want to give a shout out to your organization, something like that?

00:48:16.320 --> 00:48:19.520
Oh, well, I'm happy to work on the project.

00:48:19.520 --> 00:48:21.440
So it's a fun project.

00:48:21.440 --> 00:48:22.700
You see great results.

00:48:22.700 --> 00:48:26.420
You have the hands-on experience in contrast to classic software engineering.

00:48:26.420 --> 00:48:28.200
It's a great community.

00:48:28.200 --> 00:48:31.560
And it's really fun to be a part of and design the future of robotics.

00:48:31.560 --> 00:48:33.440
Well, thank you so much for being on the show, Dirk.

00:48:33.440 --> 00:48:35.200
Thank you, Michael, for having me.

00:48:35.380 --> 00:48:35.640
You bet.

00:48:35.640 --> 00:48:39.520
This has been another episode of Talk Python To Me.

00:48:39.520 --> 00:48:41.340
Today's guest was Dirk Thomas.

00:48:41.340 --> 00:48:44.480
And this episode has been sponsored by Codeship.

00:48:44.480 --> 00:48:49.520
Please check them out at Codeship.com and thank them on Twitter via at Codeship.

00:48:49.520 --> 00:48:52.020
Don't forget the discount code for listeners.

00:48:52.020 --> 00:48:52.760
It's easy.

00:48:52.760 --> 00:48:53.900
Talk Python.

00:48:53.900 --> 00:48:55.100
All caps, no spaces.

00:48:55.100 --> 00:49:03.780
Remember, you can find the links to the show at talkpythontome.com slash episodes slash show slash seven.

00:49:05.120 --> 00:49:09.840
And if you're feeling generous, please check out our Patreon campaign at patreon.com slash mkennedy.

00:49:09.840 --> 00:49:12.120
Be sure to subscribe to the show.

00:49:12.120 --> 00:49:18.860
Visit the website and choose subscribe in iTunes or grab the episode RSS feed and drop it into your favorite podcatcher.

00:49:19.080 --> 00:49:21.180
You'll find the link at the bottom of every page.

00:49:21.180 --> 00:49:23.840
This is your host, Michael Kennedy.

00:49:23.840 --> 00:49:25.020
Thanks for listening.

00:49:25.020 --> 00:49:27.280
Smix, take us out of here.

00:49:27.280 --> 00:49:29.320
Stating with my voice.

00:49:29.320 --> 00:49:31.120
There's no norm that I can feel within.

00:49:31.120 --> 00:49:32.340
Haven't been sleeping.

00:49:32.340 --> 00:49:33.940
I've been using lots of rest.

00:49:33.940 --> 00:49:36.820
I'll pass the mic back to who rocked it best.

00:49:36.820 --> 00:49:48.240
I'll pass the mic back to who rocked it best.

00:49:48.240 --> 00:49:48.740
Bye.

00:49:48.740 --> 00:49:49.040
.

00:49:49.040 --> 00:49:49.540
you

